1
00:00:00,000 --> 00:00:04,000
すぐにパズルを質問します。実際、それはかなり難しいパズルです。しかし、その前に、ネタバレをしていきたいと思います。つまり、この問題を解決する方法には、次のような問題が含まれます。複素数の。

2
00:00:04,000 --> 00:00:09,040


3
00:00:09,040 --> 00:00:11,280


4
00:00:11,280 --> 00:00:14,560
そして、一度聞いたら、パズルが純粋に個別の質問になることを考えると、それはばかげていると思われることに同意するでしょう。

5
00:00:14,560 --> 00:00:17,600


6
00:00:17,600 --> 00:00:20,480
整数とその合計についてのみ質問されます。

7
00:00:20,480 --> 00:00:24,560
地平線のどこにも、想像上のものや連続性の匂いさえありません。

8
00:00:25,120 --> 00:00:27,840
言い方を借りれば、複素数が離散数学に不当に役立つのは、決してこの時だけではありません。

9
00:00:27,840 --> 00:00:30,960


10
00:00:30,960 --> 00:00:34,960
私が挙げられるより有名な例は、数学者が素数をどのように理解するかという現代的な方法です。素数がどのように分布しているか、特定の領域での密度などに関する質問です。特別に設計された関数を研究する必要があります。その入力と出力は複素数です。

11
00:00:34,960 --> 00:00:38,160


12
00:00:38,160 --> 00:00:40,320


13
00:00:40,320 --> 00:00:45,920


14
00:00:45,920 --> 00:00:49,520
これが有名なリーマン予想の内容であることをご存知の方もいらっしゃるかもしれません。

15
00:00:49,520 --> 00:00:52,560
基本的には特別に設計された関数があり、一見すると素数の離散世界とは無関係に見えます。

16
00:00:52,560 --> 00:00:55,200


17
00:00:55,200 --> 00:00:57,280
滑らかで、複雑な価値があります。

18
00:00:57,280 --> 00:01:00,640
しかし、内部では、離散素数について必要なすべての情報がエンコードされています。

19
00:01:00,640 --> 00:01:02,400


20
00:01:02,400 --> 00:01:06,480
そして最も重要なことは、素数に関する特定の質問は、素数自体を直接分析するよりも、この関数を分析することで簡単に答えることができます。

21
00:01:06,480 --> 00:01:10,560


22
00:01:11,120 --> 00:01:14,000
もちろん、私たちのパズルは、すぐに共有することを約束しますが、リーマン予想よりもはるかに無邪気です。

23
00:01:14,000 --> 00:01:16,320


24
00:01:16,320 --> 00:01:17,760
おもちゃの問題です。

25
00:01:17,760 --> 00:01:21,200
しかし、ビデオの最後では、それを解決するために私たちが使用するテクニック、つまり私たちがここにいる本当の理由が、実際にはリーマン予想につながる設定と精神的にかなり似ていることを共有します。

26
00:01:21,200 --> 00:01:24,400


27
00:01:24,400 --> 00:01:27,040


28
00:01:27,040 --> 00:01:29,760
そして素数定理とそれをめぐる一連の思考。

29
00:01:35,040 --> 00:01:39,520
今日のパズルは、Titou、Rescu、Zoomingfeng によるこの本から来ています。

30
00:01:39,520 --> 00:01:42,640
基本的には、国際数学オリンピックの米国チームのトレーニングに使用される問題集です。

31
00:01:42,640 --> 00:01:44,720


32
00:01:44,720 --> 00:01:47,040
第 2 章「高度な問題」に目を向けると、問題番号

33
00:01:47,040 --> 00:01:50,160
10 でこの一見無害な質問が行われます。

34
00:01:50,800 --> 00:01:54,960
要素の合計が 5 で割り切れる集合 1

35
00:01:54,960 --> 00:01:57,520
の部分集合の数を 2000 まで求めます。

36
00:01:59,040 --> 00:02:01,520
さて、解析には少し時間がかかるかもしれません。

37
00:02:01,520 --> 00:02:05,520
たとえば、セット 3、1、4 のようなものはサブセットになります。

38
00:02:05,520 --> 00:02:08,480
そのすべての要素は、大きなセットの要素でもあります。

39
00:02:08,480 --> 00:02:12,480
そして、その合計、3 プラス 1 プラス 4 は 8 なので、これは考慮されません。

40
00:02:12,480 --> 00:02:13,680
それは私たちの計算には含まれていません。

41
00:02:13,680 --> 00:02:18,320
一方、セット 2、3、5 などもサブセットであり、合計は 10 になります。

42
00:02:18,320 --> 00:02:20,880
これは 5 で割り切れるので、数えておきたい値です。

43
00:02:21,520 --> 00:02:23,760
最初に用意したプレビュー

44
00:02:23,760 --> 00:02:27,440
アニメーションは、本質的には、この質問に答えようとする強引なプログラムです。

45
00:02:27,440 --> 00:02:30,640
考えられるさまざまなサブセットをすべて反復処理して、途中で各サブセットの合計を見つけ、5

46
00:02:30,640 --> 00:02:32,880
の倍数が見つかるたびにカウンターをインクリメントします。

47
00:02:32,880 --> 00:02:36,000


48
00:02:36,560 --> 00:02:40,000
ここでのウォーミングアップの質問としては、少し立ち止まって、全体のサブセットの合計がいくつあるかについて考えてみるのがよいでしょう。

49
00:02:40,000 --> 00:02:42,560


50
00:02:42,560 --> 00:02:44,400
この 5 の倍数のことは忘れてください。

51
00:02:44,400 --> 00:02:46,560
このプログラムが終了するまでどれくらい時間がかかりますか?

52
00:02:48,480 --> 00:02:51,840
答えは2の2000乗であることをご存知の方も多いかもしれません。

53
00:02:51,920 --> 00:02:54,880
基本的な考え方は、サブセットを構築するときに、2,000 の異なる

54
00:02:54,880 --> 00:02:57,840
2 つの選択肢があるということです。

55
00:02:57,840 --> 00:02:59,920
要素を含めますか、含めませんか?

56
00:02:59,920 --> 00:03:02,640
そして、これらの選択肢はすべて互いに独立しているため、サブセットを構築する際の選択肢の総数は、2 × 2 ×

57
00:03:02,640 --> 00:03:05,840
2 × 2

58
00:03:05,840 --> 00:03:08,960
と、延々と 2000 回となります。

59
00:03:09,680 --> 00:03:13,440
私たちのプログラムについて考えると、それは恐ろしく膨大な数です。

60
00:03:13,440 --> 00:03:16,720
したがって、たとえ私たちがこの強引なアプローチを宇宙で常に与えたとしても、宇宙が提供できるすべての物理的リソースを使って、それに近づくことさえなく、表面を傷つけることはありません。

61
00:03:16,720 --> 00:03:19,760


62
00:03:20,320 --> 00:03:22,880


63
00:03:22,880 --> 00:03:25,360
明らかに、私たちはそれよりもずっと賢くならなければなりません。

64
00:03:25,360 --> 00:03:29,040
そして、答えが何であるべきかを単に推測し、大まかに概算すると、おそらく、それは全サブセットの約 5 分の

65
00:03:29,040 --> 00:03:32,320
1 になるはずだと推測するでしょう。

66
00:03:32,320 --> 00:03:35,840
おそらく、これらすべての合計は mod 5 でほぼ均等に分布します。

67
00:03:35,840 --> 00:03:38,400
そして、はい、それは真実であり、それはまともな近似値です。

68
00:03:38,400 --> 00:03:42,640
しかし、質問の核心、つまりここでの本当の課題は、正確な答えを得ることです。

69
00:03:42,640 --> 00:03:45,520
これは整数ではないので実際の答えにはなりませんが、本当の答えはもう少し多いのでしょうか、それとも少し少ないのでしょうか?

70
00:03:45,520 --> 00:03:48,320


71
00:03:48,320 --> 00:03:50,400
それとも、もっと多いのか、それとも少ないのでしょうか？

72
00:03:50,400 --> 00:03:53,520
そのエラーを解決するためにどのような戦術を使用できるでしょうか?

73
00:03:55,520 --> 00:04:00,000
はっきり言っておきますが、このレッスンは目的地よりも旅そのものに関するものです。

74
00:04:00,000 --> 00:04:03,120
この方法でサブセットをフィルタリングしてカウントする必要があるでしょうか?

75
00:04:03,120 --> 00:04:05,360
ほぼ間違いなくそうではありませんが、私はそうは期待していません。

76
00:04:05,360 --> 00:04:09,200
しかし、おもちゃの問題かどうかにかかわらず、それは正当に挑戦的な質問であり、その挑戦を乗り越えることで、他の種類の難しい質問に関連するスキルが開発されます。

77
00:04:09,200 --> 00:04:14,160


78
00:04:14,160 --> 00:04:18,160
あなたと私にとって、私があなたと共有したいソリューションには、少なくとも 2

79
00:04:19,040 --> 00:04:21,120
つの非常に驚くべき、そして非常に美しい展開があります。

80
00:04:21,120 --> 00:04:24,720
複素数が驚くべき登場をするだろうということはすでに伝えましたが、それに到達する前に、さらに奇妙で予想外の別の奇妙な展開があると思われます。

81
00:04:24,720 --> 00:04:27,520


82
00:04:27,520 --> 00:04:30,720


83
00:04:31,280 --> 00:04:33,920
ただし、準備を整えるために、パズルの方向性を理解して、すべての優れた問題解決者が行うべきことを実行して、より単純な例から始めましょう。おそらくセット

84
00:04:33,920 --> 00:04:37,840
1、2、3、4、5

85
00:04:37,840 --> 00:04:40,320
で試してみましょう。

86
00:04:41,040 --> 00:04:43,200
もしあなたが紙と鉛筆を使ってこの問題を解いていたとしたら、ご存知のように、あなたも IMO の訓練を受けている子供の一人であるなら、単純に

87
00:04:43,200 --> 00:04:45,600
2 から

88
00:04:45,600 --> 00:04:49,120
5 のサブセットをすべてリストアップするのは悪い考えではありません。

89
00:04:49,120 --> 00:04:50,880
まだ32人なのでそんなに多くないです。

90
00:04:55,680 --> 00:04:58,720
これらすべてを頭の中で整理するにはさまざまな方法がありますが、私たちが関心があるのはそれらの合計であるため、自然なことは、それらすべてを

91
00:04:58,720 --> 00:05:01,840
1

92
00:05:01,840 --> 00:05:06,320
つずつ調べてそれらの合計を計算することです。

93
00:05:06,320 --> 00:05:08,640
ここでは、YouTube

94
00:05:08,640 --> 00:05:11,360
でやっているだけです。私はコンピューターを持っているので、少しごまかして、すべての合計がいくらになるかを示します。

95
00:05:11,360 --> 00:05:14,000
また、少し騙してこれらすべてを再配置し、すべてが同じ合計を持つコレクションに暗示的に整理します。

96
00:05:14,000 --> 00:05:17,680


97
00:05:18,240 --> 00:05:21,280
たとえば、合計すると 6 になる

98
00:05:21,280 --> 00:05:23,120
3 つの異なるサブセットがあり、それらはすべてこの小さなボックス内に収まり、3 つのサブセットを合計すると

99
00:05:23,120 --> 00:05:26,480
10 になるものもすべてこの小さなボックス内に収まります。

100
00:05:27,120 --> 00:05:28,960
全体として、私たちが注目しているもの、合計が 5

101
00:05:28,960 --> 00:05:31,120
で割り切れるサブセットが左側に表示されており、合計 8

102
00:05:31,680 --> 00:05:35,120
つあるように見えます。

103
00:05:36,160 --> 00:05:39,520
ああ、ところで、空集合を数えていると言うべきですが、その合計は 0 であると考えられ、それは

104
00:05:39,520 --> 00:05:43,760
5 の倍数であると考えられます。

105
00:05:43,760 --> 00:05:47,200
最後に、これらすべてがごく自然な選択であることに同意していただければ幸いです。

106
00:05:47,920 --> 00:05:51,680
少し時間を取って、この答えをヒューリスティックに予想されるものと比較してください。

107
00:05:51,680 --> 00:05:56,560
合計 32 のサブセットのうち、5 分の 1 は 6 になります。 4

108
00:05:56,560 --> 00:06:00,240
なので、少なくともこの小さな例では、本当の答えはそれより少し大きくなります。

109
00:06:00,240 --> 00:06:02,480
それは頭の片隅に置いておきたいことかもしれません。

110
00:06:03,760 --> 00:06:07,120
さて、これはビデオの部分ですが、正直に言うと、どうやってモチベーションを上げればよいのかわかりません。

111
00:06:07,120 --> 00:06:08,960


112
00:06:08,960 --> 00:06:12,480
個人的には、数学が自分で発見できたような気がするのが好きです。もしあなたと私が一緒に座ってこの問題を解いているとしたら、あらゆる種類の自然な手順が取れると思います。

113
00:06:12,480 --> 00:06:15,360


114
00:06:15,360 --> 00:06:18,000


115
00:06:18,000 --> 00:06:21,600
おそらく、サブセットに何らかの構造があるかどうかを理解しようとしたり、他の小さな例に対して、多くの異なる反復でこれらの合計が

116
00:06:21,600 --> 00:06:24,800
mod

117
00:06:24,800 --> 00:06:27,440
5

118
00:06:27,440 --> 00:06:30,240
でどのように分布するかを試したり、そこから次のような方法で何らかの証明をつかもうとしたりするかもしれません。誘導。

119
00:06:30,800 --> 00:06:33,280
このレッスンの初期バージョンを何人かの利用者と共有したとき、人々はいくつかの素晴らしい線形代数のアプローチを持ち出しました。

120
00:06:33,280 --> 00:06:35,600


121
00:06:35,600 --> 00:06:37,920
それらはすべて良好であり、何も問題はありません。

122
00:06:37,920 --> 00:06:41,920
しかし、代わりに、ここでの私の目標は、生成関数と呼ばれるものについて教えることです。これは、事後に「なるほど、これでうまくいくのは分かった」と考えることができる戦術の

123
00:06:41,920 --> 00:06:45,120
1

124
00:06:45,120 --> 00:06:49,040
つです。しかし一体どうやって考えたでしょうか。それ？

125
00:06:49,680 --> 00:06:51,280
正直に言うと、分かりません。

126
00:06:51,280 --> 00:06:55,280
人生には、生成関数を理解するまでの時期とその後の時期がありますが、思いつき以外にそれらを結びつけるものは思いつきません。

127
00:06:55,280 --> 00:06:58,400


128
00:06:59,120 --> 00:07:03,920
多項式 1 プラス x 倍 1 プラス x の 2 乗倍 1 プラス x の

129
00:07:04,480 --> 00:07:08,720
3 乗倍 1 プラス x の 4 倍 1 プラス x の 5 倍を考えてもらいます。

130
00:07:08,720 --> 00:07:11,360
さて、これはどこから来たのですか?と尋ねるのは当然だと思います。

131
00:07:11,360 --> 00:07:13,360
多項式は物事と何の関係があるのでしょうか?

132
00:07:13,360 --> 00:07:16,160
変数 x は今何を表しているのでしょうか?

133
00:07:16,960 --> 00:07:19,280
そして本質的に、x は純粋に記号です。

134
00:07:19,280 --> 00:07:24,640
ここで多項式を書いた唯一の理由は、それを代数的に拡張する行為が部分集合を構築する行為を完全に反映することになるからです。

135
00:07:24,640 --> 00:07:28,640


136
00:07:28,640 --> 00:07:33,120
そして重要なことに、これを行うと、同じ合計を持つサブセットがすべてまとめられるという、私たちが望むこのグループ化が自動的に行われます。

137
00:07:33,120 --> 00:07:37,120


138
00:07:37,120 --> 00:07:38,320
そして、私が何を言いたいのかをお見せしましょう。

139
00:07:38,880 --> 00:07:43,600
この式を拡張すると、基本的には 5 つの二者択一を行うことになります。

140
00:07:43,600 --> 00:07:45,760
各括弧内のどの用語を選択しますか?

141
00:07:46,480 --> 00:07:49,360
これらの括弧のそれぞれから 1

142
00:07:49,360 --> 00:07:53,120
を選択すると、それは要素を何も選択しない空のセットに対応します。

143
00:07:53,760 --> 00:07:57,680
一方、1 項に x を選択し、その他すべてから 1

144
00:07:57,680 --> 00:08:01,280
を選択すると、数値 1 だけを含むシングルトン セットに対応します。

145
00:08:01,920 --> 00:08:05,840
同様に、x の 2 乗項を選択したが、他のすべてから

146
00:08:05,840 --> 00:08:08,320
1 を選択した場合、それは 2 だけを含むセットに対応します。

147
00:08:08,320 --> 00:08:12,240
x の 3 乗項を選択するだけで、数値 3 だけを含むセットに対応します。

148
00:08:12,880 --> 00:08:17,040
しかし、興味深いことに、1 項に x を選択し、x の

149
00:08:17,040 --> 00:08:20,160
2 乗項を選択し、その他すべてから 1 を選択するとどうなるかに注目してください。

150
00:08:20,160 --> 00:08:25,600
これは、1 と 2 を持ち、その他すべてから何も持たないサブセットの選択に対応します。

151
00:08:25,600 --> 00:08:30,000
しかし、多項式では、展開の仕方は x の 3 乗のように見えます。

152
00:08:30,000 --> 00:08:32,400
したがって、2 つの異なる x 3

153
00:08:32,400 --> 00:08:35,280
乗項があり、それぞれの合計が 3 である部分集合から来ています。

154
00:08:36,160 --> 00:08:40,160
正直に言うと、ここで私が行おうとしているパターンは、時間をかけて立ち止まって、ここですべてを展開するとどうなるかを自分で考えてみると、おそらく最も簡単なパターンです。

155
00:08:40,160 --> 00:08:43,760


156
00:08:44,480 --> 00:08:48,960
基本的に、考えられるすべてのサブセットは、この展開内の項の 1 つに対応します。

157
00:08:49,520 --> 00:08:54,160
そして重要な点は、その展開から得られる項の指数が、対応するサブセットの合計に等しいということです。

158
00:08:54,160 --> 00:08:57,360


159
00:08:57,360 --> 00:08:59,520
口に出して言うとややこしいかもしれませんが、自分の頭でよく考えてみれば、私の言いたいことがわかると思います。

160
00:08:59,520 --> 00:09:02,480


161
00:09:02,480 --> 00:09:06,800
たとえば、問題がすべて解決し、ここで 32 個の項をすべて収集すると、それらの項のうち 3

162
00:09:06,800 --> 00:09:09,280
つは x から 10

163
00:09:09,280 --> 00:09:13,520
番目までであり、それらのそれぞれは合計が 10 に等しい要素の選択に由来しています。

164
00:09:14,320 --> 00:09:18,560
さて、通常、多項式を書くときは、同様の項をすべて集めます。

165
00:09:18,560 --> 00:09:20,960
10 番目までの x のコピーを 3 つ持つ代わりに、10

166
00:09:20,960 --> 00:09:24,240
番目までの x の前に係数 3 が表示されるだけです。

167
00:09:24,240 --> 00:09:29,520
したがって、これらの各係数は、サブセットの数を特定の合計でエンコードする方法です。

168
00:09:30,240 --> 00:09:34,400
これは、最初に述べたように、生成関数と呼ばれるものの例です。アイデアは、それぞれの正の整数に関連付けられた答えを持つ質問があるかどうかです。つまり、私たちの場合、サブセットの合計が何個になるかということになります。特定の値。

169
00:09:34,400 --> 00:09:39,760


170
00:09:39,760 --> 00:09:43,280


171
00:09:43,280 --> 00:09:48,640
係数がその質問の答えに対応する多項式を作成する場合、この多項式のプロパティを数学的に操作および分析することで、元の質問から驚くほど多くの洞察を得ることができます。

172
00:09:48,640 --> 00:09:51,760


173
00:09:51,760 --> 00:09:56,400


174
00:09:56,400 --> 00:09:59,440
生成関数の例は山ほどありますが、特に面白い例をもう

175
00:09:59,440 --> 00:10:02,320
1

176
00:10:02,320 --> 00:10:05,200
つ取り上げます。同じ考え方を使ってフィボナッチ数列を学ぶことができます。

177
00:10:05,200 --> 00:10:08,960
したがって、この多項式の係数はすべてフィボナッチ数になります。この場合、それは無限多項式なので、実際にはべき級数と呼ぶべきです。

178
00:10:08,960 --> 00:10:12,880


179
00:10:13,440 --> 00:10:15,280
詳細についてはここでは詳しく説明しませんが、興味のある方のために画面上に残しておきます。

180
00:10:15,280 --> 00:10:18,160


181
00:10:18,160 --> 00:10:22,080
基本的な考え方は、フィボナッチ数を定義するために使用されるルール (それぞれが前の

182
00:10:22,080 --> 00:10:24,080
2 つの合計である)

183
00:10:24,080 --> 00:10:26,800
は、この関数に関して方程式として表現できるということです。

184
00:10:27,360 --> 00:10:31,120
この方程式により、その関数を別の形式で記述することができます。

185
00:10:31,920 --> 00:10:34,880
そして、ここで詳細のほとんどを省略しますが、これを操作すると、ご存知のとおり、ここに少しの部分分数分解と、少しの等比級数展開を追加すると、正確な閉形式を取得できます。個々のフィボナッチ数式を表現できるので、とてもクールです。

186
00:10:34,880 --> 00:10:38,720


187
00:10:38,720 --> 00:10:41,600


188
00:10:41,600 --> 00:10:46,080


189
00:10:46,080 --> 00:10:46,960


190
00:10:47,600 --> 00:10:50,800
私がこれを言及したのは、実際には、この生成関数の考え方が、特定の例をはるかに超えているという事実の氷山の一角を示すためでした。

191
00:10:50,800 --> 00:10:55,200


192
00:10:55,440 --> 00:11:00,960
さて、私たちの特定の問題では、12345 だけを含む単純な例から 2000 までのすべての数値を含む大きな例に拡張すると、対応する生成関数には 2000

193
00:11:00,960 --> 00:11:03,840
個の異なる二項項が含まれます (1 プラス x、1

194
00:11:03,840 --> 00:11:08,720
プラス x)。 2 乗を繰り返し、1 に

195
00:11:08,720 --> 00:11:12,960
x を加えて 2000 まで計算します。

196
00:11:12,960 --> 00:11:16,000
そして、これを拡張すると、係数が必要な情報をすべて教えてくれるという考えです。

197
00:11:16,000 --> 00:11:18,800


198
00:11:18,800 --> 00:11:21,680
実際にそれを拡張するのは非常識なことですが、原理的にはそれがどのようなものになるかを頭の片隅に留めておくと役に立ちます。

199
00:11:22,560 --> 00:11:26,640


200
00:11:26,640 --> 00:11:31,440
たとえば、原則として、これを拡張すると、25 項の x

201
00:11:31,440 --> 00:11:34,800
の前の係数がたまたま 142 であることがわかります。

202
00:11:35,360 --> 00:11:41,680
そして、これは、合計が 25 である異なるサブセットが 142 個あるという事実に対応します。

203
00:11:42,480 --> 00:11:45,440
したがって、ここでの母関数を分析する技術は、実際に式を拡張することなく、これらの係数に関する事実を推測することになります。

204
00:11:45,440 --> 00:11:51,040


205
00:11:51,680 --> 00:11:59,600
したがって、先に進むと、この展開をより抽象的に書きます。n が 0

206
00:11:59,600 --> 00:12:02,640
から大文字 N までの合計だけです。ここで、c

207
00:12:02,640 --> 00:12:05,680
sub n は未知の係数を示します。

208
00:12:05,680 --> 00:12:08,240
私たちにとって、それらすべてはブラックボックスとして始まります。

209
00:12:08,240 --> 00:12:11,280
そしてさらに先に進むと、これを実際の関数、つまり

210
00:12:11,280 --> 00:12:14,000
x

211
00:12:14,000 --> 00:12:16,880
を接続するものとして扱い始め、出力が何であるかを確認し、それから係数について何が分かるのかを尋ねます。

212
00:12:16,880 --> 00:12:20,960
たとえば、非常に簡単な入力は、「x = 0」のようなものを入力することです。

213
00:12:20,960 --> 00:12:25,200
この場合、重要なのは、上記の因数分解形式を使用してそれを評価する方法を知っていることです。

214
00:12:25,200 --> 00:12:30,240
x がすべて 0 に等しいと代入すると、すべての項が 1 のように見えるため、答えは 1 になります。

215
00:12:30,240 --> 00:12:33,600
そして、拡張された形式では、x に関係する項はすべて削除され、0 になり、最初の項 c

216
00:12:33,600 --> 00:12:36,960
sub 0 だけが残ります。

217
00:12:37,680 --> 00:12:40,880
さて、この場合、それは実際にはそれほど興味深いことを教えてくれません。

218
00:12:40,880 --> 00:12:45,360
これは本質的に、空のセットが 1 つ存在するということになりますが、まだ準備が整っているだけです。

219
00:12:46,160 --> 00:12:49,600
次の例として、f を 1 で評価することについて考えてみましょう。

220
00:12:50,320 --> 00:12:52,720
これは、私たちが知っている式を使って行うことができます。これらの x のすべてに 1

221
00:12:52,720 --> 00:12:56,480
を代入すると、すべての項が 2 のように見えるため、合計で 2

222
00:12:56,480 --> 00:13:00,480
を 2,000 回乗算することになります。

223
00:13:00,480 --> 00:13:04,320
一方、拡張された式では、x が 1 に等しいと代入すると、x

224
00:13:04,960 --> 00:13:09,680
のすべてのべき乗が 1 になるため、基本的にすべての係数を加算することになります。

225
00:13:09,680 --> 00:13:11,440
それについて考えると、それはとても素晴らしいことです。

226
00:13:11,440 --> 00:13:14,080
単一の数値で関数を評価するだけで、すべての係数の合計が何であるかを推測できます。

227
00:13:14,080 --> 00:13:16,880


228
00:13:17,440 --> 00:13:20,240
ここでもう一度、私たちの特定の例では、これらの係数の合計が何であるかがすでにわかっているため、それほど興味深いものではありません。

229
00:13:20,240 --> 00:13:24,160


230
00:13:24,720 --> 00:13:28,800
各係数は、特定の合計を持つサブセットの数をカウントするため、それらを合計するときは、2 から

231
00:13:28,800 --> 00:13:31,440
2,000

232
00:13:31,440 --> 00:13:33,280
までであることがわかっているすべてのサブセットをカウントしているだけであることに注意してください。

233
00:13:34,000 --> 00:13:36,560
ただし、この関数をマイナス 1

234
00:13:36,560 --> 00:13:39,440
で評価してもらうと、真に新しい事実を与えることができます。

235
00:13:39,440 --> 00:13:41,040
それが何を意味するのか少し考えてみましょう。

236
00:13:43,360 --> 00:13:46,320
負の 1

237
00:13:46,320 --> 00:13:50,240
を入力すると、再び既知のもの、つまり一番上の因数分解された式から始まります。ここで必要なのは、最初の項を確認することだけです。

238
00:13:50,240 --> 00:13:55,440
x を代入すると、最初のかっこが 0 になるため、式全体が 0 になる必要があります。

239
00:13:55,440 --> 00:13:58,960
しかし、すべての係数を使用して展開された式にそれを適用すると、何がわかるでしょうか?

240
00:13:58,960 --> 00:14:00,560


241
00:14:00,560 --> 00:14:05,120
そして、この解決策がとる奇妙な展開をできるだけ示唆するという精神で、この式のマイナス

242
00:14:05,120 --> 00:14:09,440
1

243
00:14:09,440 --> 00:14:11,200
のさまざまな累乗を回転の観点から実際に視覚化してもらいたいと思います。

244
00:14:11,200 --> 00:14:16,160
最初の項、つまり 0 から 1 までの負の値は単なる 1 であり、これを 0 から 1 までのベクトルとして描きます。

245
00:14:16,560 --> 00:14:20,000
マイナス 1 の 1 乗はマイナス

246
00:14:20,000 --> 00:14:25,360
1 そのものであり、最後の項から 180 度回転したものとして考えてください。

247
00:14:25,360 --> 00:14:30,880
次に、負の 1 の 2 乗を取得すると、正の 1 になり、再び 180 度回転します。

248
00:14:30,880 --> 00:14:35,760
そして一般に、ここでの連続する各用語は、180 度回転したように見えます。

249
00:14:35,760 --> 00:14:39,280
これを代数的に解釈すると、偶数係数と奇数係数の間で合計が振動していることになります。

250
00:14:39,280 --> 00:14:42,000


251
00:14:42,000 --> 00:14:44,160
ただし、ビジュアルを頭の片隅に置いておいてください。

252
00:14:44,160 --> 00:14:46,720
この式はどの生成関数にも当てはまりますが、ここでも特別な生成関数の場合、この値、この交互の合計は

253
00:14:46,720 --> 00:14:49,120
0

254
00:14:49,120 --> 00:14:52,800
に等しくなることがわかっています。

255
00:14:52,800 --> 00:14:56,240
そして、これを解釈する方法は、偶数係数と奇数係数の間に均等なバランスがあることを示しているということです。

256
00:14:56,240 --> 00:14:58,880


257
00:14:59,520 --> 00:15:02,640
そして、おそらくこの小さな例の文脈では、これらの係数はサブセットに関する事実をエンコードしていることを思い出してください。

258
00:15:02,640 --> 00:15:06,480


259
00:15:06,480 --> 00:15:11,200
したがって、これらすべての偶数係数と奇数係数のバランスが等しい場合、すべてのサブセットの半分が偶数の合計を持ち、半分が奇数の合計を持っていることがわかります。

260
00:15:11,200 --> 00:15:16,480


261
00:15:16,480 --> 00:15:20,720
おそらくそれが予想されることでしょうが、最初はそれをどのように示すかは明らかではありません。

262
00:15:20,720 --> 00:15:23,200
そして、生成関数を使用すると、それがすぐに現れます。

263
00:15:24,320 --> 00:15:28,160
もう一度、私たちがどこへ向かうのかを示唆するために、評価した最後の 2 つの項目を取得し、それら

264
00:15:28,160 --> 00:15:33,600
2 つを合計して、1/2 で割ることによって、これを少し書き直させてください。

265
00:15:34,960 --> 00:15:39,120
考えてみれば、これはすべての偶数係数をフィルタリングして、すべての奇数係数を消去する方法です。

266
00:15:39,120 --> 00:15:41,680


267
00:15:41,680 --> 00:15:46,480
したがって、すべての偶数係数の合計

268
00:15:46,480 --> 00:15:50,640
(これも頭の片隅で、偶数の合計を持つ部分集合の総数を意味します)

269
00:15:50,640 --> 00:15:52,480
が全体の半分のように見えるという事実を記述するための特にきれいな方法になります。

270
00:15:52,480 --> 00:15:57,280
言うまでもなく、これは私たちが答えたい実際の質問に興味をそそられるほど近いものです。

271
00:15:57,280 --> 00:16:01,520
私たちがやりたいのは、関数 f

272
00:16:01,520 --> 00:16:04,160
に対して実行できる賢い方法、関数 f

273
00:16:04,160 --> 00:16:07,760
を評価するための適切に選択された数値を見つけて、5 の倍数に対応するすべての係数を取得することです。

274
00:16:07,760 --> 00:16:10,720
もう一度、これらの係数が何をエンコードしているかを考えると、それが最後の質問の答えになります。

275
00:16:10,720 --> 00:16:12,560


276
00:16:12,560 --> 00:16:16,800
これは、合計が 5 で割り切れるサブセットの総数を数えることになります。

277
00:16:19,040 --> 00:16:21,920
これを行うためのコツは、入力の連続するパワーが前後に回転する、今行ったことを一般化することです。

278
00:16:21,920 --> 00:16:25,280


279
00:16:26,000 --> 00:16:28,720
ただし、今回は 1 回おきに回転させるのではなく、何らかの方法で

280
00:16:28,720 --> 00:16:31,520
5 周期で回転させたいと考えています。

281
00:16:31,520 --> 00:16:34,400
そしてそれを行うために、複素平面に拡張します。

282
00:16:34,480 --> 00:16:39,440
ご覧のとおり、そこにある値を見つけることができ、その値を連続的に累乗すると、その値は 5 分の 1

283
00:16:39,440 --> 00:16:44,000
回転して、周波数 5 のプロセスが得られます。

284
00:16:44,560 --> 00:16:47,440
一歩下がったら、私が複素数について考えろと言うのは、ある意味ばかばかしいことだとわかっています。

285
00:16:47,440 --> 00:16:49,680


286
00:16:49,680 --> 00:16:52,640
つまり、計数の問題から始めました。これは離散数学ですが、それほど乱暴なものではないことを願っています。

287
00:16:52,640 --> 00:16:54,560


288
00:16:55,360 --> 00:17:00,560
繰り返しになりますが、私が解決策におけるさまざまな奇妙な展開を整理するために図を描いている理由は、それらが実際には数学のより広範なスキームの中ではそれほど奇妙ではないからです。

289
00:17:00,560 --> 00:17:04,000


290
00:17:04,000 --> 00:17:08,320
これから適用しようとしているトリックは、整数の離散的な問題をよりよく理解するために複素数を使用する他の多くの例とよく似ています。

291
00:17:08,320 --> 00:17:12,640


292
00:17:12,640 --> 00:17:16,320
したがって、それが自分自身で発見できたもののように感じられれば感じるほど、この思考の循環の中で将来の問題に取り組んでいるときに、実際にはそれを自分で発見する可能性が高くなります。

293
00:17:16,320 --> 00:17:20,000


294
00:17:20,000 --> 00:17:23,120


295
00:17:28,800 --> 00:17:33,600
具体的に言うと、私が関心のある複素数はゼータとラベル付けするもので、単位円の 5 分の

296
00:17:33,600 --> 00:17:36,560
1 周の位置にあります。

297
00:17:36,560 --> 00:17:41,280
したがって、その角度は 2 π 5 ラジアンで、大きさは 1 です。

298
00:17:41,840 --> 00:17:44,400
これは、標準的なオイラーの公式表記では、その数値を e の 2 乗

299
00:17:44,400 --> 00:17:49,520
pi i を 5 で割ったものとして明示的に記述することを意味します。

300
00:17:49,520 --> 00:17:52,560
この表記に慣れていない場合は、実数部が 72 度の余弦 (72

301
00:17:52,560 --> 00:17:58,240
は 1 回転の 5

302
00:17:58,240 --> 00:18:01,440
分の 1)、虚数部が 72 度の正弦であると考えることもできます。

303
00:18:02,400 --> 00:18:06,160
しかし、正直に言うと、実際には明示的な値について考える必要はありません。

304
00:18:06,160 --> 00:18:10,400
代わりに、注目すべき重要なことは、この数の累乗が持つ特性です。

305
00:18:10,960 --> 00:18:14,240
たとえば、それを 2 乗すると、その大きさが 1 なので、その 2

306
00:18:14,240 --> 00:18:19,120
乗の大きさも 1 になりますが、単位円の周りを 5 分の 1

307
00:18:19,120 --> 00:18:21,040
回転するため、今度は 5 分の 2 回転した位置になります。

308
00:18:22,000 --> 00:18:26,160
同様に、3 乗に上げると、最終的に 5 分の

309
00:18:26,160 --> 00:18:30,400
3 回転し、4 乗に上げます。最終的に 5

310
00:18:30,480 --> 00:18:32,800
分の 4 に上げて、5 乗すると、次のようになります。ずっと1つに戻ります。

311
00:18:32,800 --> 00:18:35,680
これは、ゼロ乗した場合と同じであり、この循環は 5

312
00:18:35,680 --> 00:18:39,040
期ごとに発生します。 それが私たちが大切にしていることです。

313
00:18:39,600 --> 00:18:42,880
これらの数値には特別な名前があり、1 の 5 乗根と呼ばれます。本質的に、方程式 z

314
00:18:43,440 --> 00:18:47,360
を解くと 5 が 1 に等しく、数値

315
00:18:47,360 --> 00:18:49,600
1 の 5 乗根です。

316
00:18:49,600 --> 00:18:52,560
この方程式を誰かに提示したとしたら、おそらく答えは明らかに z が

317
00:18:52,560 --> 00:18:55,120
1 に等しい、と言うでしょう。しかし、複素平面には他に

318
00:18:55,120 --> 00:18:58,800
4 つの答えがあり、他の

319
00:18:58,800 --> 00:19:01,840
4 つの数値があり、それらを

320
00:19:01,840 --> 00:19:04,720
5 番目に上げると次のようになります。それらを集合体として考えると、多くの場合非常に役立ちます。

321
00:19:04,720 --> 00:19:07,280
この方程式を覚えておいてください。少し後で戻ってきます。

322
00:19:08,560 --> 00:19:13,680
したがって、前に行ったことと同様に、1 の f

323
00:19:13,680 --> 00:19:16,160
と負の 1 の

324
00:19:16,160 --> 00:19:19,760
f を加算して奇数項間で相殺を行いました。これから行うことは、これらの数値の 5

325
00:19:19,760 --> 00:19:23,120
つすべてで f を評価し、加算することです。一緒に参加して、キャンセルが得られることを願っています。

326
00:19:23,120 --> 00:19:26,720
やや複雑に思えるかもしれませんが、x の f

327
00:19:26,720 --> 00:19:29,840
が単に x に等しい場合など、非常に単純な例を考えてみましょう。

328
00:19:29,840 --> 00:19:31,840
その場合、これら 5 つの項を合計するとき、ゼータとゼロ、ゼータと

329
00:19:31,840 --> 00:19:34,240
1 を加えて、ゼータと

330
00:19:34,240 --> 00:19:38,160
4 番目まで、単一の根自体を合計しているだけです。

331
00:19:38,160 --> 00:19:41,360
複素数を加算するときは、先端から末尾までのベクトル加算のように考えることができます。

332
00:19:41,360 --> 00:19:42,400


333
00:19:42,960 --> 00:19:46,160
したがって、ゼータにゼロを加えたゼータは次のようになります。そして、ゼータの

334
00:19:46,160 --> 00:19:48,320
2

335
00:19:48,320 --> 00:19:52,160
乗を追加して、そのベクトルの尾部を最後のベクトルの先端に持ってくると、これが得られます。

336
00:19:52,720 --> 00:19:56,400
次に、同様に、3 乗したゼータの尾部をその先端に持ってきて、ゼータを

337
00:19:56,960 --> 00:19:59,520
4

338
00:19:59,520 --> 00:20:03,200
番目まで同様に実行すると、全体の合計が実際にどのようにループしてゼロに戻るかがわかります。

339
00:20:03,200 --> 00:20:06,080
これについて別の考え方をすると、これらの 5 つの項はすべて、数字の

340
00:20:06,080 --> 00:20:08,800
0 を中心に均等にバランスが取れています。

341
00:20:08,800 --> 00:20:10,640
それらの重心は原点にあります。

342
00:20:11,920 --> 00:20:14,800
ここで、x の f が

343
00:20:14,800 --> 00:20:16,480
x の 2 乗である場合の、もう少し簡単な例を考えると役に立ちます。

344
00:20:17,120 --> 00:20:20,000
したがって、ゼータをゼロに二乗すると、ゼータはゼロのままになります。

345
00:20:20,000 --> 00:20:21,920
これはナンバーワンを表現する単なる派手な方法です。

346
00:20:22,480 --> 00:20:25,280
ゼータを 2 乗すると、ゼータの 2 乗自体が得られます。

347
00:20:25,280 --> 00:20:29,840
したがって、これを実行すると、この点がゼータ二乗点に移動することを想像できるかもしれません。

348
00:20:30,480 --> 00:20:33,040
ゼータの二乗は 4 番目のゼータに移動します。

349
00:20:33,040 --> 00:20:35,680
この点がゼータから 4 番目に移動する様子を想像するかもしれません。

350
00:20:36,560 --> 00:20:39,120
ゼータの 3 乗は 6 番目のゼータに移動します。これは

351
00:20:39,120 --> 00:20:43,280
5 回ごとにループするため、ゼータから 1 番目のゼータと同じことになります。

352
00:20:43,280 --> 00:20:44,880
したがって、この点はここで上に移動します。

353
00:20:46,480 --> 00:20:50,000
そして最後に、ゼータを 4 番目の平方にして、ゼータを 8

354
00:20:50,000 --> 00:20:54,480
番目に求めます。これは、ゼータの 3 乗と同じになります。これは、次のように描画できます。

355
00:20:55,520 --> 00:20:57,440
特にここに描いたすべての矢印を考えると、考えるのが少し混乱するように思えるかもしれませんが、人生で少なくとも一度は考えてみる価値があります。なぜなら、ここでの考え方は、これを二乗すると、これらすべての異なる矢印に行くようなものだからです。用語をプログラムして角度を

356
00:20:57,440 --> 00:20:59,600


357
00:20:59,600 --> 00:21:01,840
2

358
00:21:01,840 --> 00:21:04,480


359
00:21:04,480 --> 00:21:08,720
倍にすると、全体的な効果はそれらの用語をシャッフルするだけになります。

360
00:21:09,280 --> 00:21:11,680


361
00:21:11,680 --> 00:21:14,400
同じ数値が得られますが、異なる順序で書かれているため、それらの合計は依然としてゼロになります。

362
00:21:14,400 --> 00:21:16,160


363
00:21:16,800 --> 00:21:21,440
同様に、x の

364
00:21:21,440 --> 00:21:24,640
3 乗に関するこの演習を実行することをお勧めします。これらの点のそれぞれがどこに行き着くのかを追跡すると、これらの項を

365
00:21:25,280 --> 00:21:27,440
3

366
00:21:27,440 --> 00:21:30,720
乗すると、次のことがわかるでしょう。それぞれを取り出し、その角度を 3

367
00:21:31,280 --> 00:21:33,040
倍し、再びそれらをシャッフルします。

368
00:21:33,040 --> 00:21:35,040
同じ用語が別の順序でリストされています。

369
00:21:35,040 --> 00:21:38,240
当然のことながら、関数が 4 番目の x だった場合にも同じことが起こります。

370
00:21:41,840 --> 00:21:46,480
しかし、重要なことに、関数 x を 5 番目まで考慮すると、状況が変わります。

371
00:21:47,040 --> 00:21:51,760
その場合、ゼータを 5 乗すると、定義上、ゼータは 1 になります。

372
00:21:52,320 --> 00:21:55,520
同様に、ゼータの 2 乗の 5 乗は 1 になります。

373
00:21:55,520 --> 00:21:57,920
これらすべてが一つになり、統一の根源となります。

374
00:21:57,920 --> 00:22:00,320
結局のところ、これが彼らの人生の目的のすべてなのです。

375
00:22:00,320 --> 00:22:03,600
したがって、この場合、関数を適用してそれらをすべて加算すると、ゼロになってキャンセルが得られる代わりに、一種の建設的な干渉が得られます。

376
00:22:03,600 --> 00:22:08,640


377
00:22:08,640 --> 00:22:11,920
それらはすべて 1 なので、合計は 5 になります。

378
00:22:11,920 --> 00:22:14,880
したがって、一歩下がって、これらすべての例が何を意味するのかを考えてみると、本質的にこの式は、5 で割り切れない

379
00:22:15,440 --> 00:22:19,360
x

380
00:22:19,360 --> 00:22:24,080
のべき乗についてはゼロになるものですが、x

381
00:22:24,080 --> 00:22:25,760
のべき乗についてはゼロ以外の何かになります。は5で割り切れます。

382
00:22:25,760 --> 00:22:28,160
そして、それはまさに私たちが探している種類のフィルターです。

383
00:22:28,960 --> 00:22:33,760
実際の関数が単純な x

384
00:22:33,760 --> 00:22:36,960
の累乗よりもはるかに複雑であることが心配な場合は、すべてが線形であるため、ここでは基本的に物事は非常にうまく機能します。

385
00:22:37,600 --> 00:22:41,200
f

386
00:22:41,760 --> 00:22:44,000
が巨大な多項式で、この大きな合計を評価したい場合は、列ごとに処理することを考えることができます。毎回、実際にはゼータの累乗を加算することになります。

387
00:22:44,240 --> 00:22:47,360


388
00:22:47,360 --> 00:22:51,440
そしてほとんどの場合、これらのパワーはすべて互いに相殺され、結果はゼロになります。

389
00:22:51,440 --> 00:22:55,440
しかし、これらのべき乗がすべて 5 の倍数である場合、それらは建設的に干渉し、代わりに、対応する係数が何であっても

390
00:22:55,440 --> 00:22:58,880
5 倍の値が得られます。

391
00:22:59,440 --> 00:23:02,320
雑草の奥深くにいると、そもそもなぜここにいるのか忘れてしまいがちです。

392
00:23:02,320 --> 00:23:08,000
ただし、これらの係数のそれぞれによって、サブセットの合計が特定の値に達するかどうかがわかることを覚えておいてください。

393
00:23:08,000 --> 00:23:12,240
したがって、私たちが望んでいるのは、最初に存在するすべての係数を合計することです。

394
00:23:12,320 --> 00:23:15,840
そして私たちが現在持っているのは、それを明示的に行う方法です。

395
00:23:15,840 --> 00:23:19,120
この関数をこれら 5

396
00:23:19,120 --> 00:23:22,800
つの異なる単位根に基づいて評価すると、奇妙に思えるかもしれませんが、5

397
00:23:22,800 --> 00:23:24,640
で割るだけで必要な合計が得られます。

398
00:23:25,280 --> 00:23:27,360
私に言わせれば、それは本当に素晴らしいことです。

399
00:23:27,360 --> 00:23:31,040
部分集合に関する質問があり、それは離散数学の問題ですが、それに答える方法は、慎重に選択した複素数に対してクレイジーな多項式を評価することです。

400
00:23:31,040 --> 00:23:35,760


401
00:23:35,760 --> 00:23:38,480


402
00:23:38,480 --> 00:23:40,480
計算をすればするほど、より多くのことが得られます。

403
00:23:41,280 --> 00:23:43,440
複素数は離散数学と奇妙な関係にあるため、数学をやればやるほどクレイジーではなくなりますが、これは本当に素晴らしいことであり、これについては二通りの方法はありません。

404
00:23:43,440 --> 00:23:46,960


405
00:23:46,960 --> 00:23:49,200


406
00:23:50,160 --> 00:23:53,920
ただし、これが役立つ唯一の方法は、このワイルドな式を多項式で実際に評価できる場合だと不満を言う人もいるかもしれません。

407
00:23:53,920 --> 00:23:58,480


408
00:23:58,480 --> 00:24:02,400
ここで思い出してください、私たちが知っている多項式の形式、つまり私たちが使いやすいのは、因数分解された形式です。1 プラス x、1 プラス

409
00:24:02,400 --> 00:24:06,080
x の 2 乗を繰り返し、1

410
00:24:06,080 --> 00:24:08,560
プラス x まで続きます。 2,000。

411
00:24:09,120 --> 00:24:12,480
ここまでのすべては、ここで実際に腕まくりをして正直に計算できない限り、1

412
00:24:12,480 --> 00:24:14,880
つの難しい問題を別の難しい問題に押し込む、無意味な象徴的な遊びにすぎません。

413
00:24:14,880 --> 00:24:18,720


414
00:24:18,720 --> 00:24:22,560
これが私たちの議論の最後の主張ですので、一歩下がって、深呼吸してください。

415
00:24:22,560 --> 00:24:26,320
実際には、あなたが思っているほど悪くはありませんが、必要な統一の根の 1

416
00:24:26,320 --> 00:24:30,640
つだけ、おそらくゼータ自体をどのように評価するかを考えることから始めましょう。

417
00:24:31,600 --> 00:24:34,880
つまり、1 プラス ゼータ、× 1 プラス ゼータの 2

418
00:24:34,880 --> 00:24:36,960
乗、× 1 プラス ゼータの 3 乗、というようになります。

419
00:24:36,960 --> 00:24:41,280
ただし、重要なことは、最初の 5

420
00:24:41,280 --> 00:24:43,120
項の後に、ゼータの力が繰り返されるため、すべてが繰り返され始めることです。

421
00:24:43,120 --> 00:24:49,520
2,000 までの式全体は、基本的にこの式を 400 回コピーするだけになります。

422
00:24:49,520 --> 00:24:51,920
この式を評価するのはまだ難しいように思えるかもしれませんが、2,000

423
00:24:51,920 --> 00:24:55,680
の異なる項を掛け合わせるよりははるかに簡単です。

424
00:24:55,680 --> 00:24:59,520
これを視覚化すると、統一のルートを 1 つずつ取得していますが、基本的には

425
00:24:59,520 --> 00:25:02,880
1 つ追加して、それらをすべて右にシフトしていることになります。

426
00:25:02,880 --> 00:25:06,080
実際、この図は、私たちが期待するであろう数値的な答えを幾何学的に直感的に導き出すのに役立ちます。

427
00:25:06,080 --> 00:25:08,720


428
00:25:08,720 --> 00:25:12,960
私たちが求めているのは、これら 5 つの異なる複素数の積、つまり

429
00:25:12,960 --> 00:25:14,640
5 つの黄色い点です。

430
00:25:14,640 --> 00:25:18,800
複素数についてある程度の知識がある場合、複素数は共役ペアで表現されるため、実際に必要なのは、これらの 5

431
00:25:18,800 --> 00:25:22,880
本の黄色の線の長さを乗算することだけです。

432
00:25:23,840 --> 00:25:28,960
たとえば、一番右にある点は、1 プラス ゼータから 5 番目の点に対応します。図では、これを

433
00:25:28,960 --> 00:25:32,560
0 プラス 1 へのゼータとしてラベル付けしています。

434
00:25:32,560 --> 00:25:34,080
しかし、それは問題ではありません。どちらの場合も、どちらも数字の 2

435
00:25:34,080 --> 00:25:36,800
を単に派手に書いているだけです。

436
00:25:36,800 --> 00:25:41,280
その隣には、1 プラス ゼータと 1

437
00:25:41,280 --> 00:25:42,960
プラス ゼータから 4 番目の値があり、どちらも同じ大きさです。

438
00:25:42,960 --> 00:25:44,720
これらの線の長さは同じです。

439
00:25:44,720 --> 00:25:46,880
それに、L1 という名前を付けましょう。

440
00:25:46,880 --> 00:25:50,320
したがって、その長さの 2 つの異なるコピー (L1 の 2 乗) を乗算する必要があります。

441
00:25:51,120 --> 00:25:55,600
同様に、残りの 2 つの値、ゼータ 2 乗プラス 1

442
00:25:55,600 --> 00:25:58,400
とゼータ 3 乗プラス 1 も同じ長さを持ち、共役ペアです。

443
00:25:58,400 --> 00:26:00,640
したがって、その長さを単に L2 と呼びましょう。

444
00:26:00,640 --> 00:26:03,680
したがって、私たちの製品にはその L2 のコピーが 2 つ含まれる必要があります。

445
00:26:04,160 --> 00:26:08,480
緩いヒューリスティックな推測を行っているだけであれば、L1 は 1 より少し長い長さであり、L2

446
00:26:08,480 --> 00:26:13,920
は 1 より少し短い長さであることに気づくかもしれません。

447
00:26:13,920 --> 00:26:17,760
したがって、ここでの最終的な答えは、おそらく 2 つくらいのものになるでしょう。

448
00:26:17,760 --> 00:26:19,920
私たちは前向きではありませんが、その程度のことはあります。

449
00:26:19,920 --> 00:26:24,240
これを正確な答えにするには、式全体を拡張するだけです。

450
00:26:24,240 --> 00:26:27,200
正直、それほど悪くはありません。用語は 32 種類しかありません。

451
00:26:27,200 --> 00:26:37,120
さて、あなたは長い間私と付き合ってきました、そして私はそれが多くのことになることを知っています。

452
00:26:37,120 --> 00:26:40,720
しかし、この議論全体には最後のトリックが 1

453
00:26:40,720 --> 00:26:42,400
つあり、それによって最後のステップが思っているよりもはるかに簡単になります。

454
00:26:43,040 --> 00:26:45,520
そして、私たちがどこにいるのかを思い出すために、要約してみましょう。

455
00:26:45,520 --> 00:26:47,440
そこで私たちは、1 の部分集合の数を 2,000

456
00:26:47,440 --> 00:26:52,480
まで数えて、その合計が 5 で割り切れるという質問から始めました。

457
00:26:52,480 --> 00:26:56,800
次に、この多項式を構築しました。その係数は、各値 n

458
00:26:56,960 --> 00:26:58,880
に対して特定の合計を持つサブセットがいくつあるかを示します。

459
00:26:59,760 --> 00:27:03,600
したがって、私たちが望むのは、その多項式の 5 番目ごとの係数を合計することです。

460
00:27:04,720 --> 00:27:09,680
次に、この多項式を 1 の

461
00:27:09,680 --> 00:27:13,520
5 乗根すべての関数として評価し、それらを加算すると、最終的にまさに必要なフィルターが得られることがわかりました。

462
00:27:13,520 --> 00:27:16,640
そしてここでは、それらの項のうちの 1 つであるゼータの f

463
00:27:16,640 --> 00:27:19,760
だけを評価しています。これは本質的に 5 つの複素数の積になります。

464
00:27:20,320 --> 00:27:24,480
その製品を実際に評価するための非常に巧妙な方法として、最後のトリックを紹介します。

465
00:27:25,120 --> 00:27:27,920
私がこれらの数字を統一の根として説明したことを思い出してください。

466
00:27:27,920 --> 00:27:30,880
彼らは方程式 z を解き、5 番目が 1 に等しくなります。

467
00:27:30,880 --> 00:27:36,080
これについての別の考え方は、それらが 5 から 1 を引いた多項式 z の根であるということです。

468
00:27:36,720 --> 00:27:42,480
これが意味するのは、多項式 z を 5 から

469
00:27:42,480 --> 00:27:45,280
1 を引いた数で因数分解すると、次のようになります。各根に対応する因数が 1 つあります。

470
00:27:45,280 --> 00:27:47,520
z から各根を引いたものを取ります。

471
00:27:47,520 --> 00:27:50,560
すべてを拡張すると発生するクレイジーなキャンセルのすべてを考えると、この表現は一種の魔法のようです。

472
00:27:50,560 --> 00:27:53,360


473
00:27:53,360 --> 00:27:56,800
しかし、それは真実であり、右側の式はここの上部で評価する必要があるものとほぼ同じに見えるため、現時点では非常に便利です。

474
00:27:56,800 --> 00:28:00,400


475
00:28:00,400 --> 00:28:03,120


476
00:28:03,120 --> 00:28:06,240
基本的にはプラス記号があればいいところにマイナス記号があるだけです。

477
00:28:07,520 --> 00:28:10,160
秘訣は、z が負の 1 に等しいという値を代入することです。

478
00:28:10,800 --> 00:28:14,240
それを行うと、本質的に私たちが望んでいることがマイナスになります。

479
00:28:14,240 --> 00:28:18,160
したがって、これにマイナス 1 を掛けると、マイナス 1 マイナス 1

480
00:28:18,160 --> 00:28:22,400
またはマイナス 2 として始まった左側が、どのように 2 になるかに注目してください。

481
00:28:23,040 --> 00:28:26,720
そして、右辺が評価したいものになります。

482
00:28:26,720 --> 00:28:30,320
したがって、先ほどの幾何学的直観が示唆したように、答えは約 2 であるだけでなく、まったく魔法のように、答えは正確に

483
00:28:30,320 --> 00:28:35,440
2 であることがわかります。

484
00:28:36,320 --> 00:28:40,880
これは、実際には非常に素晴らしく、とても素敵です。なぜなら、これは、評価したいこのより大きな式を意味するからです。ここで、さまざまな単一根のすべてに

485
00:28:40,880 --> 00:28:45,200
f

486
00:28:45,200 --> 00:28:47,360
を加算しており、最初の単一根に関するその値がわかっています。

487
00:28:47,360 --> 00:28:49,600
2の400乗になります。

488
00:28:49,600 --> 00:28:53,680
本質的に同じ推論は、次の 3 つの 1 の根の値も

489
00:28:53,680 --> 00:28:59,200
2 の 400 乗であることを示しています。これは、ゼータ 2

490
00:28:59,200 --> 00:29:02,160
乗またはゼータ 3 乗を計算すると、異なる順序でシャッフルされた同じ数値のリストが得られることを思い出してください。 。

491
00:29:02,720 --> 00:29:06,640
唯一異なるのは、それをゼロに対するゼータとして評価する場合です。

492
00:29:06,640 --> 00:29:10,080
しかし、ゼータからゼロというのは数字の 1 を表す派手な言い方であり、私たちはこれを

493
00:29:10,080 --> 00:29:12,000
1 で評価する方法を知っています。

494
00:29:12,000 --> 00:29:13,040
それは簡単なことの一つです。

495
00:29:13,040 --> 00:29:14,160
これは以前に行いました。

496
00:29:14,160 --> 00:29:16,640
これらの括弧はすべて 2 になるので、2

497
00:29:16,640 --> 00:29:20,320
を 2,000 回掛け合わせたように見えます。

498
00:29:20,320 --> 00:29:26,160
そしてついに、私たちの計数に関する質問に対する非常に明確な正直な答えが得られました。

499
00:29:26,160 --> 00:29:29,520
5 で割り切れるこれらの係数をすべて合計すると、合計が 5 で割り切れるサブセットの合計がいくつあるかを数える方法であることを思い出してください。答えは、この奇妙な複雑な式の 5

500
00:29:29,520 --> 00:29:34,640
分の 1 であり、計算すると 2

501
00:29:34,640 --> 00:29:38,160
になります。 2,000 に 2 つを加えた

502
00:29:38,160 --> 00:29:44,400
4 つの異なるコピーを 400 に加えます。

503
00:29:45,360 --> 00:29:49,200
ここで、この回答に意味があるかどうかを簡単に確認してみるとよいでしょう。

504
00:29:49,840 --> 00:29:53,920
たとえば、セット 1、2、3、4、5 を使用した小さい場合で、先ほどと同じ推論をすべて実行すると、答えは 2 の

505
00:29:53,920 --> 00:29:56,800
5 分の 1 であることがわかります。 5

506
00:29:56,800 --> 00:29:59,920
番目は、サブセットの総数で、この場合の 1 に 4 ×

507
00:29:59,920 --> 00:30:04,000
2 を加えたものです。これは、32 プラス 8 の

508
00:30:04,560 --> 00:30:08,160
5 分の 1 で、8 になります。

509
00:30:08,160 --> 00:30:12,160
そして、私たちがそれらすべてを明確に調べたときのことを覚えておいてください、実際、それが答えでした。

510
00:30:14,960 --> 00:30:22,080
ほら、これは難しいパズルです。難しい問題を解くのに時間を費やす価値があるなら、時間をかけてそれについて考える価値もあります。

511
00:30:22,080 --> 00:30:24,240


512
00:30:24,240 --> 00:30:26,000
ここから何が得られますか？ 何がお得ですか？

513
00:30:26,640 --> 00:30:28,640
ここで、答えそのもの、つまり、私たちが推測したように、支配的な部分が実際にすべてのサブセット全体の 5

514
00:30:28,640 --> 00:30:32,960
分の

515
00:30:32,960 --> 00:30:36,960
1

516
00:30:36,960 --> 00:30:39,280
であること、およびこの誤差項が、ユニティの根の大規模な組み合わせにおける完全に破壊的ではない干渉からどのようにして生じたかを考えることができます。

517
00:30:40,080 --> 00:30:43,600
しかし、繰り返しになりますが、この質問が興味深いのは答えではなく、それを解決した方法です。つまり、理解したい離散シーケンスを取得し、それを多項式の係数として扱い、その多項式を複素数値で評価します。

518
00:30:43,600 --> 00:30:48,560


519
00:30:48,560 --> 00:30:51,680


520
00:30:51,680 --> 00:30:55,120


521
00:30:55,760 --> 00:30:59,360
これらのステップは両方とも、最初は非常に予想外のことかもしれませんが、どちらのステップも、数学の他の場所で見られる非常に一般的で強力なテクニックに関連しています。

522
00:30:59,360 --> 00:31:02,720


523
00:31:02,720 --> 00:31:04,720


524
00:31:04,720 --> 00:31:09,120
たとえば、レッスンの冒頭で、私たちが使用するテクニックは、素数の研究方法や、リーマン予想などにつながる一連のアイデアと精神的に似ていると約束しました。

525
00:31:09,120 --> 00:31:12,320


526
00:31:12,320 --> 00:31:16,240


527
00:31:16,240 --> 00:31:18,320
さて、これは非常に美しいトピックなので、ここで最後にある種の急ぎバージョンを詰め込むのは少し犯罪的だと思うほどです。

528
00:31:18,320 --> 00:31:23,280


529
00:31:23,280 --> 00:31:27,440
正しいことは、少し前に約束したゼータ関数に関するビデオを作成することです。時間をかけて、正しく行うことです。

530
00:31:27,440 --> 00:31:29,680


531
00:31:30,320 --> 00:31:33,920
しかし、興味があれば、説明せずに画面上にいくつかのことを吐き出すことを許可していただければ、この 2 つがどのように並列しているかを 2

532
00:31:33,920 --> 00:31:38,320
文または 3 文で説明します。

533
00:31:38,880 --> 00:31:40,480
部分集合パズルと同じように、リーマンが素数を研究した方法には、理解したい離散数列、つまり素数に関する情報を運ぶ何かが含まれ、その係数がその数列内の項である関数を考慮する必要がありました。

534
00:31:40,480 --> 00:31:44,880


535
00:31:44,880 --> 00:31:47,280


536
00:31:47,840 --> 00:31:52,320


537
00:31:53,040 --> 00:31:57,360
この場合、それは完全な多項式ではなく、代わりに、ディリクレ級数として知られる関連する構造になります。または、尋ねる人によって異なりますが、本質的な考え方は同じです。

538
00:31:57,360 --> 00:32:02,080


539
00:32:02,080 --> 00:32:06,320
これらの係数に関する情報を探り出す方法は、ご想像のとおり、この関数が複素数値の入力に対してどのように動作するかを研究することによって得られます。

540
00:32:06,320 --> 00:32:09,120


541
00:32:09,120 --> 00:32:11,360


542
00:32:12,160 --> 00:32:15,040
彼の場合のテクニックはより洗練されています。結局のところ、リーマンは複素解析の先駆者だったのです。しかし、このように領域を実数を超えて拡張すると、数学者は係数について推論する際により多くの力を得ることができるという事実は変わりません。

543
00:32:15,040 --> 00:32:18,400


544
00:32:18,400 --> 00:32:22,320
。

545
00:32:22,320 --> 00:32:27,520


546
00:32:28,560 --> 00:32:31,600
一部の視聴者にとって、なぜ複素数がこのように不当に役立つのかという疑問がいつまでも残るかもしれません。

547
00:32:31,600 --> 00:32:35,840


548
00:32:36,480 --> 00:32:41,280
正確に答えるのは難しい質問ですが、私たちのパズルについて考えてみると、さまざまな入力を差し込むと係数に関する隠された情報が明らかになったこの状況に陥るとすぐに、入力が増えれば増えるほど、私たちが行ったすべてのことは、ある種のことです。より良いものを扱うことができるので、複素平面のような、より豊かな数の空間に自分自身を開くのもよいでしょう。

549
00:32:41,280 --> 00:32:45,280


550
00:32:45,280 --> 00:32:49,920


551
00:32:49,920 --> 00:32:54,000


552
00:32:54,000 --> 00:32:55,120


553
00:32:55,680 --> 00:32:59,920
しかし、ここでぜひ理解していただきたい、より具体的な直感があります。

554
00:32:59,920 --> 00:33:04,720
私たちのパズルでは、私たちが求めていた関連する事実、つまり 5

555
00:33:04,720 --> 00:33:06,960
番目ごとの係数の合計は、一種の頻度に関する質問でした。

556
00:33:06,960 --> 00:33:10,720
そして、他の構造とは対照的に、複素数が私たちにとって有用であることが判明した本当の理由は、後続の製品がこの循環動作を行うための値を見つけることができたからです。

557
00:33:10,720 --> 00:33:13,760


558
00:33:13,760 --> 00:33:16,960


559
00:33:16,960 --> 00:33:20,720
単位円上の値、特に単位根の使用は、周波数情報を探るために非常に有益です。

560
00:33:20,720 --> 00:33:24,240


561
00:33:24,240 --> 00:33:27,840
このアイデアがどれほど役立つかは、いくら強調してもしすぎることはありません。

562
00:33:28,400 --> 00:33:33,840
何千もの例のうちの 1 つを挙げると、1990

563
00:33:33,840 --> 00:33:38,480
年代にピーター ショールは、量子コンピューターが古典的なコンピューターよりもはるかに速く大きな数を因数分解する方法を発見しました。

564
00:33:38,480 --> 00:33:42,960
そして、私たちが現在ショールのアルゴリズムと呼んでいるものがどのように機能するかを詳細に見てみると、そのアイデアは本質的にこれであり、ある種の周波数情報を検出するために単一根を使用するということです。

565
00:33:43,520 --> 00:33:49,120


566
00:33:49,120 --> 00:33:53,680
より一般的には、これはフーリエ変換とフーリエ級数の基礎となる中心的な考え方であり、そこから続くトピックの無限の広がりです。

567
00:33:53,680 --> 00:33:56,000


568
00:33:56,800 --> 00:34:01,520
生成関数自体のトピックに関しては、ここではほんの表面をなぞっただけです。さらに詳しく知りたい場合は、ハーバート

569
00:34:01,520 --> 00:34:05,840
ウィルフによるこの種の陽気な名前の本、『Generating

570
00:34:05,840 --> 00:34:08,320
Functionology』を強くお勧めします。

571
00:34:08,320 --> 00:34:10,800
また、アイデアを少し試してみたい人のために、画面上にいくつかの楽しいパズルも残しておきます。

572
00:34:10,800 --> 00:34:23,680


