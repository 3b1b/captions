1
00:00:00,000 --> 00:00:03,737
一会儿，我会问你一个谜题，实际上，这是一个相当 

2
00:00:03,737 --> 00:00:07,474
难的谜题，但在我这样做之前，我想先剧透一下，事 

3
00:00:07,474 --> 00:00:10,900
实上，我们解决这个问题的方法涉及到使用复数。

4
00:00:11,560 --> 00:00:14,600
一旦你听到它，你就会同意这似乎很荒谬 

5
00:00:14,600 --> 00:00:17,480
，因为这个谜题纯粹是一个离散的问题。

6
00:00:17,800 --> 00:00:20,260
它只询问整数及其总和。

7
00:00:20,660 --> 00:00:24,560
地平线上的任何地方都没有一丝想象的气息，甚至连连续性都没有。

8
00:00:25,280 --> 00:00:30,720
借用一句话来说，这当然不是复 数对于离散数学的唯一用处。

9
00:00:31,160 --> 00:00:34,863
我可以举的更著名的例子是数学家如何理解素 

10
00:00:34,863 --> 00:00:38,566
数的现代方式，你知道，关于它们如何分布、 

11
00:00:38,566 --> 00:00:42,269
它们在某些区域的密度等问题，嗯，它涉及研 

12
00:00:42,269 --> 00:00:45,620
究专门设计的函数其输入和输出都是复数。

13
00:00:46,120 --> 00:00:49,360
你们中有些人可能知道这就是著名的黎曼猜想的全部内容。

14
00:00:49,680 --> 00:00:52,391
基本上，有一个专门设计的函数，从表面 

15
00:00:52,391 --> 00:00:54,960
上看，它看起来与素数的离散世界无关。

16
00:00:55,060 --> 00:00:57,000
它很光滑，它的值很复杂。

17
00:00:57,000 --> 00:01:02,180
但在幕后，它编码了您可能想要的 有关这些离散素数的所有信息。

18
00:01:02,600 --> 00:01:06,702
最重要的是，通过分析这个函数比直接分析 

19
00:01:06,702 --> 00:01:10,600
素数本身更容易回答有关素数的某些问题。

20
00:01:11,260 --> 00:01:16,060
当然，我们的难题（我保证稍后会 分享）比黎曼假设要简单得多。

21
00:01:16,260 --> 00:01:17,420
这是一个玩具问题。

22
00:01:17,880 --> 00:01:21,001
但在视频的最后，我将分享我们用来解决这个问 

23
00:01:21,001 --> 00:01:23,981
题的技术，以及我们在这里的真正原因，实际 

24
00:01:23,981 --> 00:01:26,820
上在精神上与导致黎曼假设的设置非常相似。

25
00:01:27,000 --> 00:01:29,600
还有素数定理和围绕它的整个思想圈。

26
00:01:29,600 --> 00:01:33,466
我们今天的谜题来自这本书，作者是 

27
00:01:33,466 --> 00:01:39,380
Titou、Rescu 和 Zoomingfeng。

28
00:01:39,480 --> 00:01:41,973
它基本上是训练美国队参加国际数学 

29
00:01:41,973 --> 00:01:44,320
奥林匹克竞赛时使用的一系列问题。

30
00:01:44,940 --> 00:01:47,590
如果我们翻到第 2 章“高级问题”，第 

31
00:01:47,590 --> 00:01:50,240
10 个问题就提出了这个看似无辜的问题。

32
00:01:50,920 --> 00:01:54,381
求集合 1 到 2000 的子集 

33
00:01:54,381 --> 00:01:57,640
个数，其元素之和能被 5 整除。

34
00:01:59,180 --> 00:02:01,420
好的，这可能需要一些时间来解析。

35
00:02:01,640 --> 00:02:05,320
例如，像集合 3、1、4 这样的集合就是一个子集。

36
00:02:05,660 --> 00:02:08,060
它的所有元素也是大集合中的元素。

37
00:02:08,580 --> 00:02:12,500
它的和，3 加 1 加 4，是 8，所以不予考虑。

38
00:02:12,600 --> 00:02:13,540
这不在我们的计算范围之内。

39
00:02:13,840 --> 00:02:17,718
而像集合 2、3、5 这样的集合（也是一个子集）的总和为 

40
00:02:17,718 --> 00:02:18,120
10。

41
00:02:18,440 --> 00:02:20,920
它可以被 5 整除，所以我们要计算它。

42
00:02:21,400 --> 00:02:27,140
我一开始的预览动画本质上是一个 试图回答这个问题的暴力程序。

43
00:02:27,720 --> 00:02:30,722
它将迭代所有不同的可能子集，一路找 

44
00:02:30,722 --> 00:02:33,724
到每个子集的总和，并且每次找到 5 

45
00:02:33,724 --> 00:02:36,060
的倍数时都会增加一个计数器。

46
00:02:36,760 --> 00:02:39,722
你知道吗，这里的一个很好的热身问题 

47
00:02:39,722 --> 00:02:42,520
是停下来思考一下总共有多少个子集？

48
00:02:42,820 --> 00:02:44,160
忘记这个 5 的倍数吧。

49
00:02:44,420 --> 00:02:46,560
该程序需要多长时间才能终止？

50
00:02:48,060 --> 00:02:51,500
你们中的许多人可能知道答案是 2 的 2000 次方。

51
00:02:52,120 --> 00:02:55,030
基本思想是，当您构建子集时，您可以 

52
00:02:55,030 --> 00:02:57,780
做出 2000 种不同的二元选择。

53
00:02:58,000 --> 00:02:59,480
您是否包含某个元素？

54
00:03:00,080 --> 00:03:04,960
所有这些选择都是相互独立的，因此构建 子集时的选择总数是 

55
00:03:04,960 --> 00:03:09,000
2 × 2 × 2 × 2，等等，2000 次。

56
00:03:09,800 --> 00:03:13,240
想想我们的计划，这是一个巨大的数字。

57
00:03:13,620 --> 00:03:16,730
因此，即使我们在宇宙中一直采用这种强 

58
00:03:16,730 --> 00:03:19,677
力方法，即使宇宙可以提供所有物理资 

59
00:03:19,677 --> 00:03:22,460
源，它也不会接近，它不会触及表面。

60
00:03:23,060 --> 00:03:25,180
显然我们必须比这聪明得多。

61
00:03:25,560 --> 00:03:29,075
如果你只是猜测答案应该是什么，做一个粗略的近似，你可能 

62
00:03:29,075 --> 00:03:32,340
会猜测，你知道，它应该是所有子集总数的五分之一左右。

63
00:03:32,540 --> 00:03:35,580
所有这些总和 mod 5 可能大致均匀分布。

64
00:03:36,000 --> 00:03:38,080
是的，确实如此，这是一个不错的近似值。

65
00:03:38,500 --> 00:03:42,220
但问题的核心、真正的挑战是获得准确的答案。

66
00:03:42,720 --> 00:03:45,538
这不可能是实际答案，因为它不是整数 

67
00:03:45,538 --> 00:03:48,200
，但真正的答案是多一点还是少一点？

68
00:03:48,520 --> 00:03:50,340
或者可能多了很多或少了很多？

69
00:03:50,600 --> 00:03:53,540
您可以使用什么策略来找出该错误？

70
00:03:55,680 --> 00:03:59,540
需要明确的是，本课绝对更多的是关于旅程而不是目的地。

71
00:04:00,260 --> 00:04:02,820
您是否需要以这种方式过滤和计算子集？

72
00:04:03,300 --> 00:04:05,160
几乎肯定不会，我没想到会这样。

73
00:04:05,360 --> 00:04:09,771
但无论是否是玩具问题，这都是一个合理的挑战性问题，应 

74
00:04:09,771 --> 00:04:14,020
对这一挑战可以培养与其他类型的挑战性问题相关的技能。

75
00:04:14,020 --> 00:04:17,507
对于你我来说，我想与你分享的解决方案至 

76
00:04:17,507 --> 00:04:20,820
少有两个非常令人惊讶和非常美丽的转折。

77
00:04:21,300 --> 00:04:24,577
我已经暗示复数会令人惊讶地出现，但在我 

78
00:04:24,577 --> 00:04:27,690
们做到这一点之前，还有另一个奇怪的转 

79
00:04:27,690 --> 00:04:30,640
折，这可以说是更奇怪、更意想不到的。

80
00:04:31,300 --> 00:04:34,153
不过，为了做好准备，让我们先弄清楚这个难题，并做所 

81
00:04:34,153 --> 00:04:37,006
有优秀问题解决者应该做的事情，从一个更简单的例子开 

82
00:04:37,006 --> 00:04:39,640
始，也许只是尝试使用第 1、2、3、4、5 组。

83
00:04:39,640 --> 00:04:42,810
如果您用铅笔和纸解决这个问题，您知道，您 

84
00:04:42,810 --> 00:04:45,980
是 IMO 培训的孩子之一，简单地列出所 

85
00:04:45,980 --> 00:04:49,000
有 2 到 5 个子集并不是一个坏主意。

86
00:04:49,340 --> 00:04:51,240
只有32个，不算多。

87
00:04:55,680 --> 00:04:59,236
您可能想用不同的方式在脑海中组织所有这些内容 

88
00:04:59,236 --> 00:05:02,792
，但由于我们关心的是它们的总和，因此自然要做 

89
00:05:02,792 --> 00:05:06,040
的就是一一浏览所有这些内容并计算这些总和。

90
00:05:06,520 --> 00:05:08,826
在这里，只是在 YouTube 上做，我有一台电 

91
00:05:08,826 --> 00:05:11,040
脑，所以我会作一点小作弊，显示他们的总和是多少。

92
00:05:11,040 --> 00:05:14,589
我还会作一点小作弊，重新排列所有这些，将 

93
00:05:14,589 --> 00:05:17,800
它们暗示性地组织成具有相同总和的集合。

94
00:05:18,500 --> 00:05:21,288
例如，有 3 个不同的子集，总计为 6， 

95
00:05:21,288 --> 00:05:24,077
它们都将位于这个小盒子中，而总计为 10 

96
00:05:24,077 --> 00:05:26,600
的 3 个子集将全部位于这个小盒子中。

97
00:05:27,260 --> 00:05:32,846
总而言之，我们关心的，总和 能被5整除的子集，都放在左 

98
00:05:32,846 --> 00:05:35,240
边了，看起来总共有8个。

99
00:05:36,340 --> 00:05:40,009
哦，顺便说一句，我们正在计算空集，我们认为它 

100
00:05:40,009 --> 00:05:43,520
的总和为 0，并且我们认为它是 5 的倍数。

101
00:05:43,940 --> 00:05:47,340
到最后，我希望您会同意所有这些都是非常自然的选择。

102
00:05:48,140 --> 00:05:51,260
花点时间将此答案与您启发式的预期进行比较。

103
00:05:51,800 --> 00:05:55,599
在全部 32 个子集中，其中的五分之一是 6。

104
00:05:55,599 --> 00:06:00,060
4 ，所以至少在这个小例子中，真正的答案比这个大一点。

105
00:06:00,360 --> 00:06:02,540
这也许是你想要藏在心里的事情。

106
00:06:03,719 --> 00:06:08,900
好吧，这就是视频的一部分，老 实说，我不知道如何激发它。

107
00:06:08,900 --> 00:06:11,914
就我个人而言，我喜欢数学感觉像是你可以自 

108
00:06:11,914 --> 00:06:14,929
己发现的东西，如果你和我一起坐下来解决这 

109
00:06:14,929 --> 00:06:17,800
个问题，我认为你可以采取各种自然的步骤。

110
00:06:18,240 --> 00:06:21,333
也许您尝试了解子集是否存在某种结构，或者 

111
00:06:21,333 --> 00:06:25,458
您尝试了解这些总和如何在其他小示例的许多 不同迭代中以 

112
00:06:25,458 --> 00:06:29,436
mod 5 分布，并从中尝 试通过以下方式勉强得出某种

113
00:06:29,436 --> 00:06:30,320
证明：就职。

114
00:06:31,040 --> 00:06:33,278
当我与一些顾客分享本课程的早期版本时 

115
00:06:33,278 --> 00:06:35,400
，人们提出了一些很好的线性代数方法。

116
00:06:35,720 --> 00:06:37,580
所有这些都很好，没有什么问题。

117
00:06:37,580 --> 00:06:41,499
但相反，我的目标是教你一些叫做生成函数的东 

118
00:06:41,499 --> 00:06:45,418
西，这是一种策略，事后你可以想，好吧，是的 

119
00:06:45,418 --> 00:06:49,160
，我知道这是有效的，但你到底会怎么想到那？

120
00:06:49,920 --> 00:06:51,140
老实说，我不知道。

121
00:06:51,420 --> 00:06:54,950
在你的生命中，有一段时间你还没有理解生成函数，另一段时间之后

122
00:06:54,950 --> 00:06:58,480
 ，除了信仰的飞跃之外，我想不出还有什么可以将它们联系起来。

123
00:06:59,380 --> 00:07:02,446
我要请你考虑多项式 1 加 x 乘以 1 

124
00:07:02,446 --> 00:07:05,367
加 x 平方乘以 1 加 x 立方乘以 

125
00:07:05,367 --> 00:07:08,580
1 加 x 到第四次 1 加 x 到第五次。

126
00:07:08,980 --> 00:07:11,540
现在，我知道你可以正确地问，这是从哪里来的？

127
00:07:11,580 --> 00:07:13,160
多项式与事物有什么关系？

128
00:07:13,520 --> 00:07:16,340
变量 x 现在应该代表什么？

129
00:07:17,160 --> 00:07:19,120
本质上，x 纯粹是一个符号。

130
00:07:19,440 --> 00:07:24,103
我们在这里编写多项式的唯一原因是代数展 

131
00:07:24,103 --> 00:07:28,300
开它的行为将完全反映构造子集的行为。

132
00:07:28,300 --> 00:07:32,806
而且，重要的是，我们想要的这种分组，即具有相同总和的 

133
00:07:32,806 --> 00:07:36,980
子集全部聚集在一起，当您执行此操作时，会自动发生。

134
00:07:37,400 --> 00:07:38,440
让我告诉你我的意思。

135
00:07:39,020 --> 00:07:43,520
当你展开这个表达式时，它基本上可以归结为做出五个二元选择。

136
00:07:43,800 --> 00:07:45,800
您从每个括号中选择哪个术语？

137
00:07:46,600 --> 00:07:50,115
如果您从每个括号中选择 1，则它将对 

138
00:07:50,115 --> 00:07:53,260
应于空集，其中我们不选择任何元素。

139
00:07:53,980 --> 00:07:57,911
然而，如果我选择第 1 项中的 x，然后从其他项中 

140
00:07:57,911 --> 00:08:01,540
选择 1，则这将对应于仅包含数字 1 的单例集。

141
00:08:02,200 --> 00:08:05,174
同样，如果我选择 x 平方项，但其他项 

142
00:08:05,174 --> 00:08:08,000
均为 1，则对应于仅包含 2 的集合。

143
00:08:08,520 --> 00:08:12,320
仅选择 x 立方项对应于仅包含数字 3 的集合。

144
00:08:13,100 --> 00:08:16,578
但是，有趣的是，请注意如果我选择 1 项中的 x、x 

145
00:08:16,578 --> 00:08:19,800
的平方项，然后从其他项中选择 1，会发生什么情况。

146
00:08:20,280 --> 00:08:25,380
这对应于选择具有 1 和 2 的子集，而不是其他所有子集。

147
00:08:25,380 --> 00:08:30,120
但在多项式中，它的展开方式看起来像 x 的三次方。

148
00:08:30,260 --> 00:08:33,415
所以我们有两个不同的 x 立方项， 

149
00:08:33,415 --> 00:08:36,220
每个项都来自总和为 3 的子集。

150
00:08:36,220 --> 00:08:40,213
老实说，如果您花时间停下来思考一下当您扩展此处的所有 

151
00:08:40,213 --> 00:08:44,059
内容时会发生什么，我在这里采用的模式可能是最简单的。

152
00:08:44,660 --> 00:08:49,020
本质上，每个可能的子集都对应于该展开式中的一项。

153
00:08:49,680 --> 00:08:53,523
然后关键的一点是，从该展开式中得到 

154
00:08:53,523 --> 00:08:56,940
的项中的指数等于相应子集的总和。

155
00:08:57,600 --> 00:09:00,051
当你大声说出来时有点令人困惑，但同样，如果 

156
00:09:00,051 --> 00:09:02,280
你自己思考一下，我想你就能明白我的意思。

157
00:09:02,620 --> 00:09:06,411
例如，当所有尘埃落定，我们在这里收集所有 32 

158
00:09:06,411 --> 00:09:10,044
个项时，其中三个项是 x 的第 10 次，并 

159
00:09:10,044 --> 00:09:13,520
且每一项都来自总和等于 10 的元素的选择。

160
00:09:14,540 --> 00:09:18,400
通常，当我们写多项式时，我们会将所有相似的项收集在一起。

161
00:09:18,680 --> 00:09:21,697
我们不会看到 x 到 10 的三个副本，而 

162
00:09:21,697 --> 00:09:24,440
是只看到 x 到 10 前面的系数 3。

163
00:09:24,440 --> 00:09:29,640
因此，每个系数都是用特定总和对子集数量进行编码的一种方式。

164
00:09:30,460 --> 00:09:34,606
所以，就像我在开始时所说的那样，这是一个称为生成函数的示例，

165
00:09:34,606 --> 00:09:38,753
 其中的想法是，如果您有一些问题，并且答案与每个正整数相关联

166
00:09:38,753 --> 00:09:42,900
 ，那么在我们的例子中，有多少个子集加起来为一个特别的价值。

167
00:09:43,480 --> 00:09:47,886
当您构造一个其系数与该问题的答案相对应的多 

168
00:09:47,886 --> 00:09:52,093
项式时，通过数学操作和分析该多项式的属性 

169
00:09:52,093 --> 00:09:56,100
，您可以从原始问题中获得令人惊讶的见解。

170
00:09:56,660 --> 00:09:59,461
生成函数的例子有很多很多，但为了 

171
00:09:59,461 --> 00:10:02,263
提出另一个特别有趣的例子，你可以 

172
00:10:02,263 --> 00:10:04,900
使用相同的想法来研究斐波那契数。

173
00:10:05,340 --> 00:10:09,153
所以这个多项式的所有系数都是斐波那契数，在这种情况 

174
00:10:09,153 --> 00:10:12,820
下它是一个无限多项式，所以我真的应该称它为幂级数。

175
00:10:13,520 --> 00:10:15,752
我不会在这里完全解释细节，但我会将 

176
00:10:15,752 --> 00:10:17,860
它们留在屏幕上供任何好奇的人使用。

177
00:10:18,220 --> 00:10:21,147
基本思想是，用于定义斐波那契数 

178
00:10:21,147 --> 00:10:24,075
的规则（每个数都是前两个数的和 

179
00:10:24,075 --> 00:10:26,820
）可以用该函数表示为一个方程。

180
00:10:27,580 --> 00:10:31,200
该方程又可以让您以另一种形式编写该函数。

181
00:10:32,180 --> 00:10:35,244
然后，这是我跳过的大部分细节，如果你 

182
00:10:35,244 --> 00:10:38,309
操纵它，你知道，在这里投入一点部分分 

183
00:10:38,309 --> 00:10:41,213
数分解，那里投入一点几何级数幂展开 

184
00:10:41,213 --> 00:10:44,277
，你就可以得到一个精确的封闭形式每个 

185
00:10:44,277 --> 00:10:47,020
斐波那契数列的表达式，这真的很酷。

186
00:10:47,579 --> 00:10:51,602
我提到这一点实际上只是为了展示冰山一角，即 

187
00:10:51,602 --> 00:10:55,260
生成函数的想法远远超出了我们的特定示例。

188
00:10:56,460 --> 00:11:00,829
现在，在我们的特定问题中，如果我们从只有 12345 的简 

189
00:11:00,829 --> 00:11:05,198
单示例扩展到所有数字最多为 2000 的大示例，我们相应的 

190
00:11:05,198 --> 00:11:09,276
生成函数涉及这 2000 个不同的二项式项，您知道，1 

191
00:11:09,276 --> 00:11:13,500
加 x，1 加 x平方，一直到 1 加 x 到 2000。

192
00:11:13,500 --> 00:11:16,719
这个想法是，如果你要扩展它，系数 

193
00:11:16,719 --> 00:11:19,560
会告诉我们我们想要的所有信息。

194
00:11:20,060 --> 00:11:23,326
现在，真正扩展它是疯狂的，但原则 

195
00:11:23,326 --> 00:11:26,400
上记住它会是什么样子是有帮助的。

196
00:11:26,800 --> 00:11:30,805
例如，原则上，如果你展开它，你会发现 

197
00:11:30,805 --> 00:11:34,600
x前面到第25项的系数恰好是142。

198
00:11:35,520 --> 00:11:41,640
这对应于有 142 个不同子集的总和为 25 的事实。

199
00:11:42,280 --> 00:11:46,974
因此，这里分析生成函数的技巧是推断有关 

200
00:11:46,974 --> 00:11:51,200
这些系数的事实，而不实际扩展表达式。

201
00:11:55,880 --> 00:11:59,189
因此，接下来，我将更抽象地编写这个展开式，只 

202
00:11:59,189 --> 00:12:02,498
是从 n 等于 0 到大写 N 的总和，其中 

203
00:12:02,498 --> 00:12:05,520
c sub n 告诉我们我们不知道的系数。

204
00:12:05,880 --> 00:12:08,060
所有这一切对我们来说都是一个黑匣子。

205
00:12:08,360 --> 00:12:11,783
展望未来，我们将开始将其视为一个实际函 数，代入 

206
00:12:11,783 --> 00:12:15,755
x，我们看到输出是什么，然后 我们问，这告诉我们有关系数的

207
00:12:15,755 --> 00:12:16,440
什么信息？

208
00:12:17,060 --> 00:12:20,620
例如，一个非常简单的输入是插入 x 等于 0 之类的值。

209
00:12:21,120 --> 00:12:23,110
在这种情况下，重要的是，我们知道

210
00:12:23,110 --> 00:12:25,100
如何使用上面的分解形式来评估它。

211
00:12:25,380 --> 00:12:28,731
如果将所有项代入 x 等于 0，则所有项看起来都像 

212
00:12:28,731 --> 00:12:30,020
1，因此答案为 1。

213
00:12:30,360 --> 00:12:33,764
在扩展形式中，所有涉及 x 的项都将被杀死， 

214
00:12:33,764 --> 00:12:37,020
它们变为 0，只剩下第一项，c sub 0。

215
00:12:37,800 --> 00:12:40,600
现在，在这种情况下，这并没有真正告诉我们任何令人兴奋的事情。

216
00:12:40,600 --> 00:12:45,600
它本质上意味着有一个空集，但我们才刚刚起步。

217
00:12:46,040 --> 00:12:49,640
作为下一个示例，请花点时间考虑一下将 f 评估为 1。

218
00:12:50,460 --> 00:12:53,792
这是我们可以用我们知道的表达式来做的事情，当你为所 

219
00:12:53,792 --> 00:12:57,124
有这些 x 代入 1 时，每个项看起来都像 2，所 

220
00:12:57,124 --> 00:13:00,200
以总共我们得到 2 乘以它本身 2,000 次。

221
00:13:00,720 --> 00:13:04,784
另一方面，在扩展表达式中，如果代入 x 等于 1，则 

222
00:13:04,784 --> 00:13:09,300
x 的所有这些幂都变为 1，因此我们实际上是将所有系数相加。

223
00:13:09,300 --> 00:13:11,460
当你想到这一点时，这真是太酷了。

224
00:13:11,740 --> 00:13:17,160
只需通过单个数字评估函数，我们 就可以推断出所有系数的总和。

225
00:13:17,680 --> 00:13:21,224
现在，在我们的特定示例中，这并不是那么令人兴 

226
00:13:21,224 --> 00:13:24,460
奋，因为我们已经知道这些系数的总和是多少。

227
00:13:24,960 --> 00:13:27,826
请记住，每个系数都会计算有多少个子集具有特定的 

228
00:13:27,826 --> 00:13:30,692
总和，因此当您将它们相加时，我们只是计算所有子 

229
00:13:30,692 --> 00:13:33,320
集，我们知道这些子集是 2 到 2,000。

230
00:13:34,220 --> 00:13:36,920
然而，如果我要求你将此函数评估为负 

231
00:13:36,920 --> 00:13:39,320
1，我可以给你一个真正的新事实。

232
00:13:39,720 --> 00:13:41,220
花点时间思考一下这意味着什么。

233
00:13:43,340 --> 00:13:46,783
如果你插入负数 1，我们再次从我们知道的东西开始，即 

234
00:13:46,783 --> 00:13:50,100
顶部的因式分解表达式，这里你所需要的就是查看第一项。

235
00:13:50,440 --> 00:13:52,894
当你代入 x 时，第一个括号变为 

236
00:13:52,894 --> 00:13:55,060
0，因此整个表达式必须为 0。

237
00:13:55,640 --> 00:13:57,999
但是，当我们使用所有系数将其应用 

238
00:13:57,999 --> 00:14:00,220
于扩展表达式时，这会告诉您什么？

239
00:14:00,720 --> 00:14:04,177
本着尽可能暗示这个解决方案所采取的奇怪 

240
00:14:04,177 --> 00:14:07,635
转折的精神，我希望您能够真正以旋转的形 

241
00:14:07,635 --> 00:14:10,920
式形象化这个表达式中负 1 的各种幂。

242
00:14:11,460 --> 00:14:15,258
第一项，负 1 到 0，就是 1，我们将其描绘为从 

243
00:14:15,258 --> 00:14:16,720
0 到 1 的向量。

244
00:14:16,720 --> 00:14:21,069
负 1 的 1 次方就是负 1 本身，我希望 

245
00:14:21,069 --> 00:14:25,040
您将其视为与上一项相距 180 度的旋转。

246
00:14:25,540 --> 00:14:28,594
然后，当我们取负 1 的平方时，即为正 

247
00:14:28,594 --> 00:14:30,580
1，同样旋转 180 度。

248
00:14:30,580 --> 00:14:35,820
一般来说，这里的每个连续项看起来都像是又旋转了 180 度。

249
00:14:36,180 --> 00:14:39,064
从代数上来说，这意味着我们在偶数 

250
00:14:39,064 --> 00:14:41,780
系数和奇数系数之间有一个振荡和。

251
00:14:42,180 --> 00:14:43,860
但请记住视觉效果。

252
00:14:44,260 --> 00:14:47,082
这个表达式对于任何生成函数都成立，但 

253
00:14:47,082 --> 00:14:49,905
同样，对于我们的特殊生成函数，我们知 

254
00:14:49,905 --> 00:14:52,580
道这个值，这个交替和，应该等于 0。

255
00:14:53,040 --> 00:14:56,132
您可以解释的一种方式是，它告诉您偶数 

256
00:14:56,132 --> 00:14:58,900
系数和奇数系数之间存在相等的平衡。

257
00:14:59,460 --> 00:15:03,186
请记住，也许在我们较小的示例中，这些 

258
00:15:03,186 --> 00:15:06,520
系数正在为我们编码有关子集的事实。

259
00:15:06,760 --> 00:15:11,548
因此，如果所有偶数系数和奇数系数之间存在相等的平衡， 

260
00:15:11,548 --> 00:15:16,160
则表明所有子集的一半具有偶数和，其中一半具有奇数和。

261
00:15:16,660 --> 00:15:20,640
这可能是您所期望的，但一开始并不清楚如何展示这一点。

262
00:15:20,820 --> 00:15:23,440
有了生成函数，它就会立即弹出。

263
00:15:24,480 --> 00:15:29,133
再次，为了暗示我们要去哪里，让我通过我们评估的最后两项 

264
00:15:29,133 --> 00:15:33,620
内容来稍微重写一下，将这两项相加，然后除以 1 一半。

265
00:15:35,100 --> 00:15:38,278
如果你仔细想想，这是一种过滤掉所有 

266
00:15:38,278 --> 00:15:41,280
偶数系数并消除所有奇数系数的方法。

267
00:15:41,900 --> 00:15:45,461
因此，它成为一种特别干净的方式来编写以下事实： 

268
00:15:45,461 --> 00:15:48,875
所有偶数系数的总和（在您的脑海中再次意味着具 

269
00:15:48,875 --> 00:15:52,140
有偶数总和的子集总数）将看起来像总数的一半。

270
00:15:52,620 --> 00:15:57,100
不用说，这非常接近我们想要回答的实际问题。

271
00:15:57,100 --> 00:16:00,604
我们想要做的是找到一些可以对函数 f 做的聪 

272
00:16:00,604 --> 00:16:04,108
明的事情，一些精心挑选的数字来评估它，这样我 

273
00:16:04,108 --> 00:16:07,460
们就可以得到与 5 的倍数相对应的所有系数。

274
00:16:08,000 --> 00:16:10,454
再次回想一下这些系数为我们编码的 

275
00:16:10,454 --> 00:16:12,620
内容，这将回答我们的最终问题。

276
00:16:12,760 --> 00:16:16,860
这将计算总和可被 5 整除的子集总数。

277
00:16:18,900 --> 00:16:22,248
这样做的技巧是概括我们刚刚所做的 

278
00:16:22,248 --> 00:16:25,400
事情，其中输入的连续幂来回旋转。

279
00:16:25,900 --> 00:16:28,680
但这一次，我们不希望它们每隔一段时间旋转一次 

280
00:16:28,680 --> 00:16:31,340
，我们希望它们以某种方式以 5 为周期旋转。

281
00:16:31,740 --> 00:16:34,220
为此，我们扩展到复平面。

282
00:16:34,640 --> 00:16:39,402
你看，在那里，我们可以找到一个值，这样当我们连续取它的幂 

283
00:16:39,402 --> 00:16:44,000
时，它就会旋转五分之一圈，给我们一个频率为 5 的过程。

284
00:16:44,700 --> 00:16:49,500
如果你退后一步，我知道我 要求你思考复数有点荒谬。

285
00:16:49,860 --> 00:16:52,314
我的意思是，我们从一个计数问题开始， 

286
00:16:52,314 --> 00:16:54,640
它是离散数学，但希望它不是那么疯狂。

287
00:16:55,400 --> 00:16:59,599
再说一次，我之所以把事情画出来是为了解决解决方案中的各种奇怪

288
00:16:59,599 --> 00:17:03,800
 的转折，是因为它们实际上在更广泛的数学方案中并不那么奇怪。

289
00:17:04,140 --> 00:17:08,455
我们将要应用的技巧与使用复数来更好地理解 

290
00:17:08,455 --> 00:17:12,359
整数的离散问题的许多其他实例非常相似。

291
00:17:12,740 --> 00:17:18,270
因此，越感觉像是你自己可以发现的东西 

292
00:17:18,270 --> 00:17:23,800
，就越有可能当你在这个思想圈子中解决 

293
00:17:23,800 --> 00:17:29,040
未来的某个问题时，你自己就会发现它。

294
00:17:29,040 --> 00:17:32,884
具体来说，我关心的复数是我要标记为 zet 

295
00:17:32,884 --> 00:17:36,380
a 的复数，它位于单位圆的五分之一圈处。

296
00:17:36,780 --> 00:17:41,340
所以它的角度是 2 pi 五分之一弧度，大小是 1。

297
00:17:42,060 --> 00:17:45,862
这意味着使用标准欧拉公式符号，我们可以将该数字明 

298
00:17:45,862 --> 00:17:49,360
确写为 e 的 2 pi i 除以 5 次方。

299
00:17:49,640 --> 00:17:55,600
如果您对这种表示法不太熟悉，您可以将其 视为实部为 72 

300
00:17:55,600 --> 00:18:01,560
度的余弦，72 为五 分之一整圈，虚部为 72 度的正弦。

301
00:18:02,540 --> 00:18:05,940
但说实话，你实际上不需要考虑显式的值。

302
00:18:06,200 --> 00:18:10,580
相反，需要关注的重要事情是这个数字的幂所具有的属性。

303
00:18:11,100 --> 00:18:14,570
例如，当你平方它时，因为它的大小是一，所 

304
00:18:14,570 --> 00:18:18,040
以它的平方的大小也是一，但它绕单位圆旋转 

305
00:18:18,040 --> 00:18:21,180
五分之一圈，所以它现在位于五分之二圈。

306
00:18:22,280 --> 00:18:25,739
同样，当你将其提高到三次方时，你最终会得到五分之 

307
00:18:25,739 --> 00:18:29,198
三回合，将其提高到四次方时，你最终会得到五分之四 

308
00:18:29,198 --> 00:18:32,520
回合，并将其提高到五次方，你就得到了一路回到一。

309
00:18:32,860 --> 00:18:37,600
这与将其提高到零次方是一样的，我们每五 项就进行一次循环。

310
00:18:37,860 --> 00:18:39,200
这就是我们关心的事情。

311
00:18:39,760 --> 00:18:42,976
这些数字有一个特殊的名字，它们被称为 

312
00:18:42,976 --> 00:18:46,192
五次单位根，本质上是因为它们解方程z 

313
00:18:46,192 --> 00:18:49,240
到五次等于一，它们是数字一的五次根。

314
00:18:49,460 --> 00:18:52,501
如果你刚刚向某人提出这个方程，他们可能会 

315
00:18:52,501 --> 00:18:55,543
说，答案显然是 z 等于 1，但这个想法 

316
00:18:55,543 --> 00:18:58,585
是在复平面上还有四个其他答案，四个其他数 

317
00:18:58,585 --> 00:19:01,627
字，当你将它们提高到第五个时，你会得到一 

318
00:19:01,627 --> 00:19:04,380
个，并将它们视为一个集体通常非常有用。

319
00:19:04,880 --> 00:19:07,440
记住这个等式，稍后我们就会回来。

320
00:19:08,700 --> 00:19:13,275
因此，与我们之前所做的类似，我们将 1 的 f 和负 1 

321
00:19:13,275 --> 00:19:15,800
的 f 加在一起以获得奇数项中 

322
00:19:15,800 --> 00:19:19,428
的抵消，我们要做的就是对所有五个数字求 f， 

323
00:19:19,428 --> 00:19:22,900
然后相加他们在一起，希望我们能得到一些取消。

324
00:19:23,240 --> 00:19:26,457
这可能看起来有点复杂，但让我们举一个超级简单的 

325
00:19:26,457 --> 00:19:29,540
例子，比如 x 的 f 简单等于 x 的情况。

326
00:19:30,000 --> 00:19:32,666
在这种情况下，当我们将这五个项相加时，我们只是将 

327
00:19:32,666 --> 00:19:35,226
单位根本身相加，即 zeta 到零加上 zet 

328
00:19:35,226 --> 00:19:37,680
a 到一，如此往复，直到 zeta 到第四个。

329
00:19:38,240 --> 00:19:42,480
当您添加复数时，您可以将其 视为向量加法，尖端在尾部。

330
00:19:42,899 --> 00:19:46,070
所以 zeta 到零加上 zeta 看起来像这 

331
00:19:46,070 --> 00:19:49,241
样，然后如果我加上 zeta 平方，将该向量的 

332
00:19:49,241 --> 00:19:52,280
尾部带到最后一个向量的尖端，我们就得到了这个。

333
00:19:52,980 --> 00:19:56,306
然后类似地，如果我将 zeta 的尾部的立方放 

334
00:19:56,306 --> 00:19:59,632
在该顶点的尖端，然后对 zeta 进行同样的操 

335
00:19:59,632 --> 00:20:02,820
作到第四个，您将看到总和实际上如何循环回到零。

336
00:20:03,360 --> 00:20:08,320
另一种思考方式是，所有这五 个项都围绕数字零均匀平衡。

337
00:20:08,880 --> 00:20:10,620
它们的质心位于原点。

338
00:20:11,700 --> 00:20:14,199
现在考虑一个稍微不那么简单的例子会很有帮 

339
00:20:14,199 --> 00:20:16,460
助，如果 x 的 f 是 x 的平方。

340
00:20:17,360 --> 00:20:19,333
因此，当您将 zeta 平方为零时，它会保持 

341
00:20:19,333 --> 00:20:20,020
zeta 为零。

342
00:20:20,260 --> 00:20:21,980
这只是说第一名的一种奇特方式。

343
00:20:22,640 --> 00:20:24,149
当您对 zeta 进行平方时，您会得到 

344
00:20:24,149 --> 00:20:24,980
zeta 本身的平方。

345
00:20:25,440 --> 00:20:29,072
所以你可能会想象，当我们这样做时，这里的这个点会移动到 

346
00:20:29,072 --> 00:20:30,240
zeta 平方点。

347
00:20:30,720 --> 00:20:32,680
Zeta 平方移动到 zeta 到第四位。

348
00:20:33,200 --> 00:20:35,760
您可能会想象这个点移动到 zeta 到第四个。

349
00:20:36,580 --> 00:20:39,887
Zeta 立方移动到 zeta 到第六，因为我们每 

350
00:20:39,887 --> 00:20:42,940
循环五次，所以它与 zeta 到 1 是一样的。

351
00:20:43,420 --> 00:20:44,879
所以这个点会向上移动。

352
00:20:46,420 --> 00:20:50,581
最后，zeta 到第四个正方形，得到 zeta 到第八个 

353
00:20:50,581 --> 00:20:54,600
正方形，它减少到与 zeta 立方相同，我可能会这样画。

354
00:20:55,560 --> 00:20:58,267
考虑起来可能有点令人困惑，尤其是我在 

355
00:20:58,267 --> 00:21:00,974
这里画的所有箭头，但在你的一生中至少 

356
00:21:00,974 --> 00:21:03,681
值得思考一次，因为这里的想法是，当我 

357
00:21:03,681 --> 00:21:06,388
们将其平方时，就像去所有这些不同的方 

358
00:21:06,388 --> 00:21:09,095
向一样项，我将它们编程为将它们所具有 

359
00:21:09,095 --> 00:21:11,660
的角度加倍，总体效果就是打乱这些项。

360
00:21:12,000 --> 00:21:14,163
我们得到相同的数字，但以不同的顺 

361
00:21:14,163 --> 00:21:16,200
序写入，因此它们的总和仍然为零。

362
00:21:16,959 --> 00:21:20,245
同样，如果你用 x 的立方来完成这个练习 

363
00:21:20,245 --> 00:21:23,373
（我鼓励你这样做），并且你跟踪这些点中 

364
00:21:23,373 --> 00:21:26,659
的每一个最终会在哪里，你将能够看到，当我 

365
00:21:26,659 --> 00:21:29,787
们对这些项进行立方时，当我们取出每一个 

366
00:21:29,787 --> 00:21:32,760
，将其角度乘以三，然后再次将它们打乱。

367
00:21:33,140 --> 00:21:34,880
相同的术语以不同的顺序列出。

368
00:21:34,880 --> 00:21:36,614
不出所料，如果我们的函数是 x 

369
00:21:36,614 --> 00:21:38,240
的四次方，同样的事情也会发生。

370
00:21:41,780 --> 00:21:44,170
但是，关键的是，如果我们考虑函数 

371
00:21:44,170 --> 00:21:46,420
x 的第五次，事情就会发生变化。

372
00:21:47,060 --> 00:21:49,300
在这种情况下，当你将 zeta 

373
00:21:49,300 --> 00:21:51,820
提高到五次方时，根据定义它会变成一。

374
00:21:52,540 --> 00:21:55,200
同样，zeta 平方的五次方变为一。

375
00:21:55,560 --> 00:21:57,960
所有这些都归于一，它们是团结的根源。

376
00:21:57,980 --> 00:21:59,940
毕竟，这就是他们人生的全部目的。

377
00:22:00,440 --> 00:22:04,484
因此，在这种情况下，当我们应用该函数并将它们全部相加 

378
00:22:04,484 --> 00:22:08,380
时，我们得到的是一种相长干涉，而不是归零并得到抵消。

379
00:22:08,780 --> 00:22:11,440
它们都等于一，所以它们的总和等于五。

380
00:22:12,060 --> 00:22:15,501
因此，如果你退一步思考所有这些例子的含 

381
00:22:15,501 --> 00:22:18,942
义，本质上这个表达式对于 x 的幂来说 

382
00:22:18,942 --> 00:22:22,383
将趋于零，不能被五整除，但对于 x 的 

383
00:22:22,383 --> 00:22:25,480
幂来说它会趋于非零，这可以被五整除。

384
00:22:25,900 --> 00:22:28,380
这正是我们正在寻找的过滤器。

385
00:22:29,020 --> 00:22:33,169
如果您担心我们的实际函数比简单的 x 幂复杂得多， 

386
00:22:33,169 --> 00:22:37,000
那么本质上这里的情况非常好，因为一切都是线性的。

387
00:22:37,700 --> 00:22:42,005
如果 f 是某个大多项式，并且我们想要计 

388
00:22:42,005 --> 00:22:47,950
算这个大和，您可以考虑逐列进行计算，每 次您实际上只是将 

389
00:22:47,950 --> 00:22:50,000
zeta 的幂相加。

390
00:22:50,360 --> 00:22:54,000
在大多数情况下，所有这些力量都会相互抵消，结果为零。

391
00:22:54,380 --> 00:22:58,230
但是，当所有这些幂都是五的倍数时，它们会产生相 

392
00:22:58,230 --> 00:23:01,920
长干涉，无论相应的系数是多少，您都会得到五倍。

393
00:23:02,040 --> 00:23:05,100
在杂草深处，我们很容易忘记我们最初为何来到这里。

394
00:23:05,360 --> 00:23:07,900
但请记住，这些系数中的每一个都告诉我

395
00:23:07,900 --> 00:23:10,440
们有多少个子集加起来达到某一特定值。

396
00:23:10,920 --> 00:23:14,980
所以我们首先想要的是将所有系数相加。

397
00:23:15,380 --> 00:23:18,540
我们现在拥有的是一种明确做到这一点的方法。

398
00:23:18,800 --> 00:23:21,804
如果我们根据这五个不同的单位根来评估这个函 

399
00:23:21,804 --> 00:23:24,808
数（我知道这似乎有点奇怪），那么我们所要做 

400
00:23:24,808 --> 00:23:27,540
的就是除以五，它就给出了我们想要的总和。

401
00:23:28,480 --> 00:23:30,220
如果你问我的话，那真的很酷。

402
00:23:30,220 --> 00:23:33,951
我们有一个关于子集的问题，这是一个离散 

403
00:23:33,951 --> 00:23:37,682
数学问题，但我们回答它的方法是在一些明 

404
00:23:37,682 --> 00:23:41,040
智选择的复数上评估一个疯狂的多项式。

405
00:23:41,520 --> 00:23:42,080
你做的数学越多，你得到的就越多。

406
00:23:42,080 --> 00:23:44,691
你做的数学越多，看起来就越不疯狂， 

407
00:23:44,691 --> 00:23:47,158
因为复数与离散数学有这种奇怪的关 

408
00:23:47,158 --> 00:23:49,480
系，但这确实很棒，没有两种方法。

409
00:23:50,340 --> 00:23:54,296
然而，你们中的一些人可能会抱怨，唯一有用的方法是我 

410
00:23:54,296 --> 00:23:58,100
们是否可以在我们的多项式上实际评估这个通配表达式。

411
00:23:58,620 --> 00:24:02,098
现在记住，我们知道的多项式的形式，我们熟悉的形式， 

412
00:24:02,098 --> 00:24:05,309
是因式分解形式，其中有 1 加 x，1 加 x 

413
00:24:05,309 --> 00:24:08,520
的平方，等等，一直到 1 加 x 到2,000。

414
00:24:09,220 --> 00:24:12,440
到目前为止，一切都只是毫无意义的象征性游 

415
00:24:12,440 --> 00:24:15,506
戏，将一个难题推向另一个难题，除非我们 

416
00:24:15,506 --> 00:24:18,420
真的能卷起袖子在这里做一些诚实的计算。

417
00:24:18,900 --> 00:24:22,320
这是我们论证的最后一个要点，所以退后一步，深吸一口气。

418
00:24:22,700 --> 00:24:26,816
它实际上并不像你想象的那么糟糕，但让我们首先考虑如何 

419
00:24:26,816 --> 00:24:30,780
评估我们需要的统一根源之一，也许是 Zeta 本身。

420
00:24:31,780 --> 00:24:34,151
所以看起来就是 1 加 zeta，乘以 1 加 

421
00:24:34,151 --> 00:24:36,820
z eta 平方，乘以 1 加 zeta 立方，等等。

422
00:24:37,060 --> 00:24:39,952
但重要的是，在前五个任期之后，一切都开 

423
00:24:39,952 --> 00:24:42,700
始重复，因为 Zeta 的力量会重复。

424
00:24:43,220 --> 00:24:47,510
整个表达式最多 2,000 基本上只是该表达式 

425
00:24:47,510 --> 00:24:49,120
400 次的副本。

426
00:24:49,600 --> 00:24:52,512
评估这个表达式似乎仍然很困难，但它比乘 

427
00:24:52,512 --> 00:24:55,280
以 2,000 个不同的项要容易得多。

428
00:24:55,280 --> 00:24:58,990
您可以想象的一种方式是，我们采用每一个统一根 

429
00:24:58,990 --> 00:25:02,540
，但基本上添加一个，我们将它们全部向右移动。

430
00:25:03,060 --> 00:25:05,795
这张图实际上为我们可能期望的数 

431
00:25:05,795 --> 00:25:08,360
字答案提供了非常好的几何直觉。

432
00:25:08,880 --> 00:25:14,260
我们想要的是这五个不同复 数的乘积，即这五个黄点。

433
00:25:14,820 --> 00:25:19,015
如果你对复数略知一二，因为它们是共轭对的， 

434
00:25:19,015 --> 00:25:23,020
我们真正需要的就是将这五条黄线的长度相乘。

435
00:25:23,679 --> 00:25:27,688
例如，最右边的那个点对应于 1 加 zeta 

436
00:25:27,688 --> 00:25:32,220
到 第五个，在图中我将其标记为 zeta 到零加一。

437
00:25:32,720 --> 00:25:36,440
但没关系，无论哪种情况，它们 都只是写数字二的奇特方式。

438
00:25:36,980 --> 00:25:40,105
接下来，我们有值一加 zeta 和一加 ze 

439
00:25:40,105 --> 00:25:42,960
ta 到第四个值，这两个值具有相同的大小。

440
00:25:43,000 --> 00:25:44,600
这些线的长度是相同的。

441
00:25:44,940 --> 00:25:46,680
我们给它起个名字，L1。

442
00:25:47,080 --> 00:25:50,280
所以我们需要将该长度 L1 的平方的两个不同副本相乘。

443
00:25:51,020 --> 00:25:54,660
同样，剩下的两个值，zeta 平方加一和 zeta 

444
00:25:54,660 --> 00:25:58,160
立方加一，它们也具有相同的长度，并且它们是共轭对。

445
00:25:58,580 --> 00:26:00,200
所以我们称这个长度为L2。

446
00:26:00,880 --> 00:26:03,800
因此我们的产品需要包含该 L2 的两个副本。

447
00:26:04,340 --> 00:26:08,745
如果我们只是进行松散的启发式猜测，您可能会注意到 

448
00:26:08,745 --> 00:26:13,680
L1 的长度比 1 稍长，而 L2 的长度比 1 稍短。

449
00:26:13,960 --> 00:26:17,700
所以这里的最终答案可能是大约两个左右。

450
00:26:17,960 --> 00:26:19,700
我们并不乐观，但大致上有些东西。

451
00:26:19,700 --> 00:26:24,140
为了将其变成精确的答案，我们可以扩展完整的表达式。

452
00:26:24,520 --> 00:26:27,420
老实说，这并没有那么糟糕，只有 32 个不同的术语。

453
00:26:33,320 --> 00:26:37,020
好吧，你已经和我在一起很长时间了，我知道它会变得很多。

454
00:26:37,280 --> 00:26:40,130
但整个论证中还有最后一个技巧，它使我 

455
00:26:40,130 --> 00:26:42,680
们的最后一步比您想象的要简单得多。

456
00:26:43,260 --> 00:26:45,620
让我们回顾一下，以提醒自己我们现在所处的位置。

457
00:26:45,820 --> 00:26:48,852
所以我们从这个问题开始，要求我们计算 1 到 

458
00:26:48,852 --> 00:26:52,280
2 ,000 的子集的数量，其总和可以被 5 整除。

459
00:26:52,740 --> 00:26:55,966
然后我们构造了这个多项式，其系数告诉我们 

460
00:26:55,966 --> 00:26:59,040
有多少子集对于每个值 n 具有特定的和。

461
00:26:59,960 --> 00:27:03,620
所以我们想要的是将该多项式的每五个系数相加。

462
00:27:04,780 --> 00:27:09,143
然后我们看到了如何将该多项式作为所有单位五次根的函 

463
00:27:09,143 --> 00:27:13,340
数求值，然后将它们相加，最终得到我们想要的滤波器。

464
00:27:13,600 --> 00:27:16,699
在这里，我们只评估其中一项，即 zeta 

465
00:27:16,699 --> 00:27:19,800
的 f，它本质上可以归结为五个复数的乘积。

466
00:27:20,540 --> 00:27:24,640
作为实际评估该产品的超级巧妙方法，这是最后一个技巧。

467
00:27:25,320 --> 00:27:27,820
请记住，我将这些数字描述为统一根。

468
00:27:28,200 --> 00:27:30,580
他们解方程 z 到第五次等于一。

469
00:27:31,060 --> 00:27:36,180
另一种思考方式是，它们是多项式 z 的第五次减一的根。

470
00:27:36,920 --> 00:27:41,300
现在这意味着我们可以将多项式 z 分解为第五 

471
00:27:41,300 --> 00:27:45,300
次减一，如下所示，其中每个根对应一个因子。

472
00:27:45,300 --> 00:27:47,160
你用 z 减去每一个根。

473
00:27:47,840 --> 00:27:50,637
当你想到当你把它全部展开时必须发生的 

474
00:27:50,637 --> 00:27:53,140
所有疯狂取消时，这个表达有点神奇。

475
00:27:53,160 --> 00:27:56,590
但这是真的，而且现在对我们来说非常 

476
00:27:56,590 --> 00:27:59,830
有用，因为右侧的表达式看起来与我 

477
00:27:59,830 --> 00:28:02,880
们需要在顶部评估的内容几乎相同。

478
00:28:03,300 --> 00:28:06,360
它基本上只有减号，而我们希望有加号。

479
00:28:07,680 --> 00:28:10,240
诀窍是插入 z 等于负一。

480
00:28:10,800 --> 00:28:13,620
如果你这样做，你基本上就得到了我们想要的负面结果。

481
00:28:13,620 --> 00:28:18,292
因此，如果将其乘以负一，请注意这里的左侧 

482
00:28:18,292 --> 00:28:22,520
（一开始是负一减一或负二）如何变成二。

483
00:28:23,240 --> 00:28:26,320
然后右边就变成了我们想要评估的东西。

484
00:28:27,000 --> 00:28:31,427
因此，正如我们之前的几何直觉所暗示的那样，答案不 

485
00:28:31,427 --> 00:28:35,500
仅是 2 左右，而且答案非常神奇地恰好是 2。

486
00:28:36,380 --> 00:28:40,078
这实际上非常好，非常可爱，因为这意味着我们想要 

487
00:28:40,078 --> 00:28:43,776
评估这个更大的表达式，我们将 f 在所有不同的 

488
00:28:43,776 --> 00:28:47,320
单位根上相加，我们知道它在第一个单位根上的值。

489
00:28:47,580 --> 00:28:49,220
它将是 2 的 400 次方。

490
00:28:49,820 --> 00:28:53,581
本质上相同的推理表明，它在接下来的三个单位根上的值也是 

491
00:28:53,581 --> 00:28:56,403
2 的 400 次方，因为请记住，当您取 

492
00:28:56,403 --> 00:28:59,493
zeta 平方或 zeta 立方的幂时，您会得

493
00:28:59,493 --> 00:29:02,180
到相同的数字列表，只是以不同的顺序洗牌。

494
00:29:02,880 --> 00:29:06,120
唯一不同的是当我们将其评估为 zeta 为零时。

495
00:29:06,840 --> 00:29:09,542
但 zeta 为零是表达第一的一种奇 

496
00:29:09,542 --> 00:29:11,960
特方式，我们知道如何以一来评估它。

497
00:29:12,220 --> 00:29:13,080
这是很容易的事情之一。

498
00:29:13,140 --> 00:29:13,900
我们之前就这样做过。

499
00:29:14,200 --> 00:29:17,121
所有这些括号都变成了 2，所以看起 

500
00:29:17,121 --> 00:29:19,880
来就像 2 乘以 2,000 倍。

501
00:29:20,520 --> 00:29:25,720
最后，我们对计数问题有了一个非常明确、诚实的答案。

502
00:29:26,160 --> 00:29:30,871
将所有可被五整除的系数相加，记住这是一种计算有多 

503
00:29:30,871 --> 00:29:35,582
少总子集的总和可被五整除的方法，答案是这个奇怪的 

504
00:29:35,582 --> 00:29:40,294
复杂表达式的五分之一，我们刚刚计算为二2,000 

505
00:29:40,294 --> 00:29:44,440
份加上 2 份到 400 份的四个不同副本。

506
00:29:45,520 --> 00:29:49,360
在这里，您可能只想快速检查一下这个答案是否有意义。

507
00:29:50,040 --> 00:29:53,733
例如，如果您在较小的情况下使用设置一、二 

508
00:29:53,733 --> 00:29:57,427
、三、四、五进行计算，并且您执行与我们刚 

509
00:29:57,427 --> 00:30:00,944
才相同的所有推理，它会告诉您答案是二的 

510
00:30:00,944 --> 00:30:05,517
五分之一第五，子集总数，在本例中加四乘二 到一，即 

511
00:30:05,517 --> 00:30:07,980
32 的五分之一加八，即八。

512
00:30:08,440 --> 00:30:10,365
如果您还记得当我们明确地查看所

513
00:30:10,365 --> 00:30:12,420
有这些内容时，这实际上就是答案。

514
00:30:17,500 --> 00:30:21,061
看，这是一个很难的难题，当值得投入时间来解 

515
00:30:21,061 --> 00:30:24,300
决一个难题时，也值得花一些时间进行反思。

516
00:30:24,420 --> 00:30:25,200
你从中得到什么？

517
00:30:29,640 --> 00:30:25,200
外卖是什么？

518
00:30:29,640 --> 00:30:32,756
现在你可以反思答案本身，主导部分如何确实是 

519
00:30:32,756 --> 00:30:35,730
所有子集总数的五分之一，就像我们可能猜测 

520
00:30:35,730 --> 00:30:38,847
的那样，以及这个误差项是如何从统一根的大规 

521
00:30:38,847 --> 00:30:41,680
模组合中不完全具有破坏性的干扰中产生的。

522
00:30:41,680 --> 00:30:45,648
但同样，让这个问题有趣的不是答案，而 

523
00:30:45,648 --> 00:30:49,408
是我们解决它的方式，即采用我们想要 

524
00:30:49,408 --> 00:30:53,168
理解的离散序列，并将其视为多项式的 

525
00:30:53,168 --> 00:30:56,720
系数，然后在复数值上评估该多项式。

526
00:30:56,720 --> 00:30:59,287
这两个步骤一开始可能是非常出乎意料的，但 

527
00:30:59,287 --> 00:31:01,854
这两个步骤都与一些非常通用和强大的技术相 

528
00:31:01,854 --> 00:31:04,300
关，您可以在数学的其他地方找到这些技术。

529
00:31:04,900 --> 00:31:08,703
例如，在课程的顶部，我承诺我们将使用的 

530
00:31:08,703 --> 00:31:12,506
技术在本质上将类似于研究素数的方式，以 

531
00:31:12,506 --> 00:31:16,120
及导致黎曼假设和类似事物的一系列想法。

532
00:31:16,500 --> 00:31:19,849
这是一个非常美丽的话题，足以让我觉得把某 

533
00:31:19,849 --> 00:31:23,040
种仓促的版本塞到这里的结尾似乎有点犯罪。

534
00:31:23,340 --> 00:31:26,655
我认为正确的做法是制作我不久前承诺过的关于 

535
00:31:26,655 --> 00:31:29,820
zeta 函数的视频，花点时间，把它做好。

536
00:31:30,440 --> 00:31:34,515
但如果你很好奇，并且允许我在屏幕上抛出一些东西而不解释 

537
00:31:34,515 --> 00:31:38,300
它们，这里有两到三句话的版本来说明两者是如何平行的。

538
00:31:39,020 --> 00:31:42,440
就像我们的子集难题一样，黎曼研究素 

539
00:31:42,440 --> 00:31:45,860
数的方式涉及我们想要理解的离散序列 

540
00:31:45,860 --> 00:31:49,280
，其中包含有关素数的信息，然后考虑 

541
00:31:49,280 --> 00:31:52,320
一个其系数是该序列中的项的函数。

542
00:31:53,120 --> 00:31:55,955
在这种情况下，它不完全是一个多项式，而是一

543
00:31:55,955 --> 00:31:58,790
个称为狄利克雷级数的相 关结构，或狄利克雷

544
00:31:58,790 --> 00:32:01,760
级数取决于你问的是谁，但它是相同的基本思想。

545
00:32:02,160 --> 00:32:05,445
然后，找出有关这些系数的信息的 

546
00:32:05,445 --> 00:32:11,400
方法来自于研究该函数如何与（ 您猜对了）复值输入一起运行。

547
00:32:12,360 --> 00:32:16,274
毕竟黎曼是复分析的先驱，他的例子中的 

548
00:32:16,274 --> 00:32:19,983
技术变得更加复杂，但事实仍然是，像 

549
00:32:19,983 --> 00:32:23,897
这样将你的域扩展到实数之外，为你（数 

550
00:32:23,897 --> 00:32:27,400
学家）提供了更多的能力来推论系数。

551
00:32:28,700 --> 00:32:32,386
对于一些观众来说，这一切可能会留下一个挥之不去 

552
00:32:32,386 --> 00:32:35,920
的问题：为什么复数以这种方式如此不合理地有用。

553
00:32:36,660 --> 00:32:40,396
这是一个很难准确回答的问题，但如果你想想我们 

554
00:32:40,396 --> 00:32:44,132
的难题，我们刚刚所做的一切，一旦我们处于这种 

555
00:32:44,132 --> 00:32:47,869
情况，插入不同的输入就会显示有关系数的隐藏信 

556
00:32:47,869 --> 00:32:51,605
息，这有点像，你的输入越多可以工作得越好，所 

557
00:32:51,605 --> 00:32:55,180
以你不妨向更丰富的数字空间开放，比如复平面。

558
00:32:55,840 --> 00:32:59,560
但我希望你能有一个更具体的直觉。

559
00:33:00,060 --> 00:33:03,408
在我们的难题中，我们想要的相关事实， 

560
00:33:03,408 --> 00:33:06,580
即每五个系数的总和，是一种频率问题。

561
00:33:06,840 --> 00:33:10,181
与其他结构相比，复数被证明对我们有 

562
00:33:10,181 --> 00:33:13,523
用的真正原因是，我们可以找到一个值 

563
00:33:13,523 --> 00:33:16,680
，以便连续的产品具有这种循环行为。

564
00:33:17,000 --> 00:33:20,678
使用单位圆上的值，特别是单位根来 

565
00:33:20,678 --> 00:33:24,140
找出频率信息，是非常富有成效的。

566
00:33:24,400 --> 00:33:28,300
这个想法的帮助之大几乎不可能被夸大。

567
00:33:28,580 --> 00:33:31,967
仅举数千个例子中的一个，在 20 世纪 90 

568
00:33:31,967 --> 00:33:35,207
年代，Peter S hor 找到了一种让量

569
00:33:35,207 --> 00:33:38,300
子计算机比传统计算机更快地分解大数的方法。

570
00:33:38,620 --> 00:33:42,013
如果你深入了解我们现在所说的 Shor 

571
00:33:42,013 --> 00:33:47,103
算法的工作原理，你会 发现其想法本质上是这样的，即使用单位根

572
00:33:47,103 --> 00:33:48,800
来检测一种频率信息。

573
00:33:49,320 --> 00:33:52,802
更一般地说，这是傅里叶变换和傅里叶级数的 

574
00:33:52,802 --> 00:33:56,120
核心思想，以及随之而来的无穷无尽的主题。

575
00:33:56,980 --> 00:34:00,869
至于生成函数本身的主题，我们实际上只是触及了表面， 

576
00:34:00,869 --> 00:34:04,609
如果您想了解更多信息，我强烈推荐 Herbert 

577
00:34:04,609 --> 00:34:08,199
Wilf 所著的这种名字搞笑的书《生成函数学》。

578
00:34:08,540 --> 00:34:10,939
我还会在屏幕上留下一些有趣的谜题，供那些想 

579
00:34:10,939 --> 00:34:13,120
要通过这个想法稍微展示一下肌肉的人使用。

