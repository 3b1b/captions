1
00:00:00,000 --> 00:00:03,867
一会儿，我会问你一个谜题，实际上，这是一个相当

2
00:00:03,867 --> 00:00:07,734
难的谜题，但在我这样做之前，我想先剧透一下，事

3
00:00:07,734 --> 00:00:11,280
实上，我们解决这个问题的方法涉及到使用复数。

4
00:00:11,280 --> 00:00:14,525
一旦你听到它，你就会同意这似乎很荒谬

5
00:00:14,525 --> 00:00:17,600
，因为这个谜题纯粹是一个离散的问题。

6
00:00:17,600 --> 00:00:20,480
它只询问整数及其总和。

7
00:00:20,480 --> 00:00:25,120
地平线上的任何地方都没有一丝想象的气息，甚至连连续性都没有。

8
00:00:25,120 --> 00:00:30,960
借用一句话来说，这当然不是复 数对于离散数学的唯一用处。

9
00:00:30,960 --> 00:00:34,791
我可以举的更著名的例子是数学家如何理解素

10
00:00:34,791 --> 00:00:38,622
数的现代方式，你知道，关于它们如何分布、

11
00:00:38,622 --> 00:00:42,453
它们在某些区域的密度等问题，嗯，它涉及研

12
00:00:42,453 --> 00:00:45,920
究专门设计的函数其输入和输出都是复数。

13
00:00:45,920 --> 00:00:49,520
你们中有些人可能知道这就是著名的黎曼猜想的全部内容。

14
00:00:49,520 --> 00:00:52,436
基本上，有一个专门设计的函数，从表面

15
00:00:52,436 --> 00:00:55,200
上看，它看起来与素数的离散世界无关。

16
00:00:55,200 --> 00:00:57,280
它很光滑，它的值很复杂。

17
00:00:57,280 --> 00:01:02,400
但在幕后，它编码了您可能想要的 有关这些离散素数的所有信息。

18
00:01:02,400 --> 00:01:06,871
最重要的是，通过分析这个函数比直接分析

19
00:01:06,871 --> 00:01:11,120
素数本身更容易回答有关素数的某些问题。

20
00:01:11,120 --> 00:01:16,320
当然，我们的难题（我保证稍后会 分享）比黎曼假设要简单得多。

21
00:01:16,320 --> 00:01:17,760
这是一个玩具问题。

22
00:01:17,760 --> 00:01:21,000
但在视频的最后，我将分享我们用来解决这个问

23
00:01:21,000 --> 00:01:24,093
题的技术，以及我们在这里的真正原因，实际

24
00:01:24,093 --> 00:01:27,040
上在精神上与导致黎曼假设的设置非常相似。

25
00:01:27,040 --> 00:01:35,040
还有素数定理和围绕它的整个思想圈。

26
00:01:35,040 --> 00:01:36,811
我们今天的谜题来自这本书，作者是

27
00:01:36,811 --> 00:01:39,520
Titou、Rescu 和 Zoomingfeng。

28
00:01:39,520 --> 00:01:42,198
它基本上是训练美国队参加国际数学

29
00:01:42,198 --> 00:01:44,720
奥林匹克竞赛时使用的一系列问题。

30
00:01:44,720 --> 00:01:47,760
如果我们翻到第 2 章“高级问题”，第

31
00:01:47,760 --> 00:01:50,800
10 个问题就提出了这个看似无辜的问题。

32
00:01:50,800 --> 00:01:55,044
求集合 1 到 2000 的子集

33
00:01:55,044 --> 00:01:59,040
个数，其元素之和能被 5 整除。

34
00:01:59,040 --> 00:02:01,520
好的，这可能需要一些时间来解析。

35
00:02:01,520 --> 00:02:05,520
例如，像集合 3、1、4 这样的集合就是一个子集。

36
00:02:05,520 --> 00:02:08,480
它的所有元素也是大集合中的元素。

37
00:02:08,480 --> 00:02:12,480
它的和，3 加 1 加 4，是 8，所以不予考虑。

38
00:02:12,480 --> 00:02:13,680
这不在我们的计算范围之内。

39
00:02:13,680 --> 00:02:17,885
而像集合 2、3、5 这样的集合（也是一个子集）的总和为

40
00:02:17,885 --> 00:02:18,320
10。

41
00:02:18,320 --> 00:02:21,520
它可以被 5 整除，所以我们要计算它。

42
00:02:21,520 --> 00:02:27,440
我一开始的预览动画本质上是一个 试图回答这个问题的暴力程序。

43
00:02:27,440 --> 00:02:30,723
它将迭代所有不同的可能子集，一路找

44
00:02:30,723 --> 00:02:34,006
到每个子集的总和，并且每次找到 5

45
00:02:34,006 --> 00:02:36,560
的倍数时都会增加一个计数器。

46
00:02:36,560 --> 00:02:39,645
你知道吗，这里的一个很好的热身问题

47
00:02:39,645 --> 00:02:42,560
是停下来思考一下总共有多少个子集？

48
00:02:42,560 --> 00:02:44,400
忘记这个 5 的倍数吧。

49
00:02:44,400 --> 00:02:48,480
该程序需要多长时间才能终止？

50
00:02:48,480 --> 00:02:51,920
你们中的许多人可能知道答案是 2 的 2000 次方。

51
00:02:51,920 --> 00:02:54,964
基本思想是，当您构建子集时，您可以

52
00:02:54,964 --> 00:02:57,840
做出 2000 种不同的二元选择。

53
00:02:57,840 --> 00:02:59,920
您是否包含某个元素？

54
00:02:59,920 --> 00:03:05,260
所有这些选择都是相互独立的，因此构建 子集时的选择总数是

55
00:03:05,260 --> 00:03:09,680
2 × 2 × 2 × 2，等等，2000 次。

56
00:03:09,680 --> 00:03:13,440
想想我们的计划，这是一个巨大的数字。

57
00:03:13,440 --> 00:03:16,761
因此，即使我们在宇宙中一直采用这种强

58
00:03:16,761 --> 00:03:19,908
力方法，即使宇宙可以提供所有物理资

59
00:03:19,908 --> 00:03:22,880
源，它也不会接近，它不会触及表面。

60
00:03:22,880 --> 00:03:25,360
显然我们必须比这聪明得多。

61
00:03:25,360 --> 00:03:28,968
如果你只是猜测答案应该是什么，做一个粗略的近似，你可能

62
00:03:28,968 --> 00:03:32,320
会猜测，你知道，它应该是所有子集总数的五分之一左右。

63
00:03:32,320 --> 00:03:35,840
所有这些总和 mod 5 可能大致均匀分布。

64
00:03:35,840 --> 00:03:38,400
是的，确实如此，这是一个不错的近似值。

65
00:03:38,400 --> 00:03:42,640
但问题的核心、真正的挑战是获得准确的答案。

66
00:03:42,640 --> 00:03:45,561
这不可能是实际答案，因为它不是整数

67
00:03:45,561 --> 00:03:48,320
，但真正的答案是多一点还是少一点？

68
00:03:48,320 --> 00:03:50,400
或者可能多了很多或少了很多？

69
00:03:50,400 --> 00:03:55,520
您可以使用什么策略来找出该错误？

70
00:03:55,520 --> 00:04:00,000
需要明确的是，本课绝对更多的是关于旅程而不是目的地。

71
00:04:00,000 --> 00:04:03,120
您是否需要以这种方式过滤和计算子集？

72
00:04:03,120 --> 00:04:05,360
几乎肯定不会，我没想到会这样。

73
00:04:05,360 --> 00:04:09,843
但无论是否是玩具问题，这都是一个合理的挑战性问题，应

74
00:04:09,843 --> 00:04:14,160
对这一挑战可以培养与其他类型的挑战性问题相关的技能。

75
00:04:14,160 --> 00:04:17,729
对于你我来说，我想与你分享的解决方案至

76
00:04:17,729 --> 00:04:21,120
少有两个非常令人惊讶和非常美丽的转折。

77
00:04:21,120 --> 00:04:24,684
我已经暗示复数会令人惊讶地出现，但在我

78
00:04:24,684 --> 00:04:28,071
们做到这一点之前，还有另一个奇怪的转

79
00:04:28,071 --> 00:04:31,280
折，这可以说是更奇怪、更意想不到的。

80
00:04:31,280 --> 00:04:34,618
不过，为了做好准备，让我们先弄清楚这个难题，并做所

81
00:04:34,618 --> 00:04:37,957
有优秀问题解决者应该做的事情，从一个更简单的例子开

82
00:04:37,957 --> 00:04:41,040
始，也许只是尝试使用第 1、2、3、4、5 组。

83
00:04:41,040 --> 00:04:43,776
如果您用铅笔和纸解决这个问题，您知道，您

84
00:04:43,776 --> 00:04:46,513
是 IMO 培训的孩子之一，简单地列出所

85
00:04:46,513 --> 00:04:49,120
有 2 到 5 个子集并不是一个坏主意。

86
00:04:49,120 --> 00:04:55,680
只有32个，不算多。

87
00:04:55,680 --> 00:04:59,332
您可能想用不同的方式在脑海中组织所有这些内容

88
00:04:59,332 --> 00:05:02,985
，但由于我们关心的是它们的总和，因此自然要做

89
00:05:02,985 --> 00:05:06,320
的就是一一浏览所有这些内容并计算这些总和。

90
00:05:06,320 --> 00:05:08,891
在这里，只是在 YouTube 上做，我有一台电

91
00:05:08,891 --> 00:05:11,360
脑，所以我会作一点小作弊，显示他们的总和是多少。

92
00:05:11,360 --> 00:05:14,972
我还会作一点小作弊，重新排列所有这些，将

93
00:05:14,972 --> 00:05:18,240
它们暗示性地组织成具有相同总和的集合。

94
00:05:18,240 --> 00:05:21,297
例如，有 3 个不同的子集，总计为 6，

95
00:05:21,297 --> 00:05:24,354
它们都将位于这个小盒子中，而总计为 10

96
00:05:24,354 --> 00:05:27,120
的 3 个子集将全部位于这个小盒子中。

97
00:05:27,120 --> 00:05:33,448
总而言之，我们关心的，总和 能被5整除的子集，都放在左

98
00:05:33,448 --> 00:05:36,160
边了，看起来总共有8个。

99
00:05:36,160 --> 00:05:40,044
哦，顺便说一句，我们正在计算空集，我们认为它

100
00:05:40,044 --> 00:05:43,760
的总和为 0，并且我们认为它是 5 的倍数。

101
00:05:43,760 --> 00:05:47,920
到最后，我希望您会同意所有这些都是非常自然的选择。

102
00:05:47,920 --> 00:05:51,680
花点时间将此答案与您启发式的预期进行比较。

103
00:05:51,680 --> 00:05:55,617
在全部 32 个子集中，其中的五分之一是 6。

104
00:05:55,617 --> 00:06:00,240
4 ，所以至少在这个小例子中，真正的答案比这个大一点。

105
00:06:00,240 --> 00:06:03,760
这也许是你想要藏在心里的事情。

106
00:06:03,760 --> 00:06:08,960
好吧，这就是视频的一部分，老 实说，我不知道如何激发它。

107
00:06:08,960 --> 00:06:12,021
就我个人而言，我喜欢数学感觉像是你可以自

108
00:06:12,021 --> 00:06:15,083
己发现的东西，如果你和我一起坐下来解决这

109
00:06:15,083 --> 00:06:18,000
个问题，我认为你可以采取各种自然的步骤。

110
00:06:18,000 --> 00:06:21,278
也许您尝试了解子集是否存在某种结构，或者

111
00:06:21,278 --> 00:06:25,648
您尝试了解这些总和如何在其他小示例的许多 不同迭代中以

112
00:06:25,648 --> 00:06:29,863
mod 5 分布，并从中尝 试通过以下方式勉强得出某种

113
00:06:29,863 --> 00:06:30,800
证明：就职。

114
00:06:30,800 --> 00:06:33,264
当我与一些顾客分享本课程的早期版本时

115
00:06:33,264 --> 00:06:35,600
，人们提出了一些很好的线性代数方法。

116
00:06:35,600 --> 00:06:37,920
所有这些都很好，没有什么问题。

117
00:06:37,920 --> 00:06:41,900
但相反，我的目标是教你一些叫做生成函数的东

118
00:06:41,900 --> 00:06:45,880
西，这是一种策略，事后你可以想，好吧，是的

119
00:06:45,880 --> 00:06:49,680
，我知道这是有效的，但你到底会怎么想到那？

120
00:06:49,680 --> 00:06:51,280
老实说，我不知道。

121
00:06:51,280 --> 00:06:55,200
在你的生命中，有一段时间你还没有理解生成函数，另一段时间之后

122
00:06:55,200 --> 00:06:59,120
，除了信仰的飞跃之外，我想不出还有什么可以将它们联系起来。

123
00:06:59,120 --> 00:07:02,320
我要请你考虑多项式 1 加 x 乘以 1

124
00:07:02,320 --> 00:07:05,367
加 x 平方乘以 1 加 x 立方乘以

125
00:07:05,367 --> 00:07:08,720
1 加 x 到第四次 1 加 x 到第五次。

126
00:07:08,720 --> 00:07:11,360
现在，我知道你可以正确地问，这是从哪里来的？

127
00:07:11,360 --> 00:07:13,360
多项式与事物有什么关系？

128
00:07:13,360 --> 00:07:16,960
变量 x 现在应该代表什么？

129
00:07:16,960 --> 00:07:19,280
本质上，x 纯粹是一个符号。

130
00:07:19,280 --> 00:07:24,206
我们在这里编写多项式的唯一原因是代数展

131
00:07:24,206 --> 00:07:28,640
开它的行为将完全反映构造子集的行为。

132
00:07:28,640 --> 00:07:33,043
而且，重要的是，我们想要的这种分组，即具有相同总和的

133
00:07:33,043 --> 00:07:37,120
子集全部聚集在一起，当您执行此操作时，会自动发生。

134
00:07:37,120 --> 00:07:38,880
让我告诉你我的意思。

135
00:07:38,880 --> 00:07:43,600
当你展开这个表达式时，它基本上可以归结为做出五个二元选择。

136
00:07:43,600 --> 00:07:46,480
您从每个括号中选择哪个术语？

137
00:07:46,480 --> 00:07:50,322
如果您从每个括号中选择 1，则它将对

138
00:07:50,322 --> 00:07:53,760
应于空集，其中我们不选择任何元素。

139
00:07:53,760 --> 00:07:58,003
然而，如果我选择第 1 项中的 x，然后从其他项中

140
00:07:58,003 --> 00:08:01,920
选择 1，则这将对应于仅包含数字 1 的单例集。

141
00:08:01,920 --> 00:08:05,202
同样，如果我选择 x 平方项，但其他项

142
00:08:05,202 --> 00:08:08,320
均为 1，则对应于仅包含 2 的集合。

143
00:08:08,320 --> 00:08:12,880
仅选择 x 立方项对应于仅包含数字 3 的集合。

144
00:08:12,880 --> 00:08:16,660
但是，有趣的是，请注意如果我选择 1 项中的 x、x

145
00:08:16,660 --> 00:08:20,160
的平方项，然后从其他项中选择 1，会发生什么情况。

146
00:08:20,160 --> 00:08:25,600
这对应于选择具有 1 和 2 的子集，而不是其他所有子集。

147
00:08:25,600 --> 00:08:30,000
但在多项式中，它的展开方式看起来像 x 的三次方。

148
00:08:30,000 --> 00:08:33,261
所以我们有两个不同的 x 立方项，

149
00:08:33,261 --> 00:08:36,160
每个项都来自总和为 3 的子集。

150
00:08:36,160 --> 00:08:40,398
老实说，如果您花时间停下来思考一下当您扩展此处的所有

151
00:08:40,398 --> 00:08:44,480
内容时会发生什么，我在这里采用的模式可能是最简单的。

152
00:08:44,480 --> 00:08:49,520
本质上，每个可能的子集都对应于该展开式中的一项。

153
00:08:49,520 --> 00:08:53,670
然后关键的一点是，从该展开式中得到

154
00:08:53,670 --> 00:08:57,360
的项中的指数等于相应子集的总和。

155
00:08:57,360 --> 00:09:00,041
当你大声说出来时有点令人困惑，但同样，如果

156
00:09:00,041 --> 00:09:02,480
你自己思考一下，我想你就能明白我的意思。

157
00:09:02,480 --> 00:09:06,598
例如，当所有尘埃落定，我们在这里收集所有 32

158
00:09:06,598 --> 00:09:10,544
个项时，其中三个项是 x 的第 10 次，并

159
00:09:10,544 --> 00:09:14,320
且每一项都来自总和等于 10 的元素的选择。

160
00:09:14,320 --> 00:09:18,560
通常，当我们写多项式时，我们会将所有相似的项收集在一起。

161
00:09:18,560 --> 00:09:21,535
我们不会看到 x 到 10 的三个副本，而

162
00:09:21,535 --> 00:09:24,240
是只看到 x 到 10 前面的系数 3。

163
00:09:24,240 --> 00:09:30,240
因此，每个系数都是用特定总和对子集数量进行编码的一种方式。

164
00:09:30,240 --> 00:09:34,586
所以，就像我在开始时所说的那样，这是一个称为生成函数的示例，

165
00:09:34,586 --> 00:09:38,933
其中的想法是，如果您有一些问题，并且答案与每个正整数相关联

166
00:09:38,933 --> 00:09:43,280
，那么在我们的例子中，有多少个子集加起来为一个特别的价值。

167
00:09:43,280 --> 00:09:47,861
当您构造一个其系数与该问题的答案相对应的多

168
00:09:47,861 --> 00:09:52,234
项式时，通过数学操作和分析该多项式的属性

169
00:09:52,234 --> 00:09:56,400
，您可以从原始问题中获得令人惊讶的见解。

170
00:09:56,400 --> 00:09:59,392
生成函数的例子有很多很多，但为了

171
00:09:59,392 --> 00:10:02,384
提出另一个特别有趣的例子，你可以

172
00:10:02,384 --> 00:10:05,200
使用相同的想法来研究斐波那契数。

173
00:10:05,200 --> 00:10:09,400
所以这个多项式的所有系数都是斐波那契数，在这种情况

174
00:10:09,400 --> 00:10:13,440
下它是一个无限多项式，所以我真的应该称它为幂级数。

175
00:10:13,440 --> 00:10:15,867
我不会在这里完全解释细节，但我会将

176
00:10:15,867 --> 00:10:18,160
它们留在屏幕上供任何好奇的人使用。

177
00:10:18,160 --> 00:10:21,291
基本思想是，用于定义斐波那契数

178
00:10:21,291 --> 00:10:24,423
的规则（每个数都是前两个数的和

179
00:10:24,423 --> 00:10:27,360
）可以用该函数表示为一个方程。

180
00:10:27,360 --> 00:10:31,920
该方程又可以让您以另一种形式编写该函数。

181
00:10:31,920 --> 00:10:35,158
然后，这是我跳过的大部分细节，如果你

182
00:10:35,158 --> 00:10:38,396
操纵它，你知道，在这里投入一点部分分

183
00:10:38,396 --> 00:10:41,464
数分解，那里投入一点几何级数幂展开

184
00:10:41,464 --> 00:10:44,702
，你就可以得到一个精确的封闭形式每个

185
00:10:44,702 --> 00:10:47,600
斐波那契数列的表达式，这真的很酷。

186
00:10:47,600 --> 00:10:51,706
我提到这一点实际上只是为了展示冰山一角，即

187
00:10:51,706 --> 00:10:55,440
生成函数的想法远远超出了我们的特定示例。

188
00:10:55,440 --> 00:10:59,932
现在，在我们的特定问题中，如果我们从只有 12345 的简

189
00:10:59,932 --> 00:11:04,424
单示例扩展到所有数字最多为 2000 的大示例，我们相应的

190
00:11:04,424 --> 00:11:08,617
生成函数涉及这 2000 个不同的二项式项，您知道，1

191
00:11:08,617 --> 00:11:12,960
加 x，1 加 x平方，一直到 1 加 x 到 2000。

192
00:11:12,960 --> 00:11:16,062
这个想法是，如果你要扩展它，系数

193
00:11:16,062 --> 00:11:18,800
会告诉我们我们想要的所有信息。

194
00:11:18,800 --> 00:11:22,838
现在，真正扩展它是疯狂的，但原则

195
00:11:22,838 --> 00:11:26,640
上记住它会是什么样子是有帮助的。

196
00:11:26,640 --> 00:11:31,117
例如，原则上，如果你展开它，你会发现

197
00:11:31,117 --> 00:11:35,360
x前面到第25项的系数恰好是142。

198
00:11:35,360 --> 00:11:42,480
这对应于有 142 个不同子集的总和为 25 的事实。

199
00:11:42,480 --> 00:11:47,322
因此，这里分析生成函数的技巧是推断有关

200
00:11:47,322 --> 00:11:51,680
这些系数的事实，而不实际扩展表达式。

201
00:11:51,680 --> 00:11:56,485
因此，接下来，我将更抽象地编写这个展开式，只

202
00:11:56,485 --> 00:12:01,291
是从 n 等于 0 到大写 N 的总和，其中

203
00:12:01,291 --> 00:12:05,680
c sub n 告诉我们我们不知道的系数。

204
00:12:05,680 --> 00:12:08,240
所有这一切对我们来说都是一个黑匣子。

205
00:12:08,240 --> 00:12:11,901
展望未来，我们将开始将其视为一个实际函 数，代入

206
00:12:11,901 --> 00:12:16,147
x，我们看到输出是什么，然后 我们问，这告诉我们有关系数的

207
00:12:16,147 --> 00:12:16,880
什么信息？

208
00:12:16,880 --> 00:12:20,960
例如，一个非常简单的输入是插入 x 等于 0 之类的值。

209
00:12:20,960 --> 00:12:23,080
在这种情况下，重要的是，我们知道

210
00:12:23,080 --> 00:12:25,200
如何使用上面的分解形式来评估它。

211
00:12:25,200 --> 00:12:28,840
如果将所有项代入 x 等于 0，则所有项看起来都像

212
00:12:28,840 --> 00:12:30,240
1，因此答案为 1。

213
00:12:30,240 --> 00:12:34,042
在扩展形式中，所有涉及 x 的项都将被杀死，

214
00:12:34,042 --> 00:12:37,680
它们变为 0，只剩下第一项，c sub 0。

215
00:12:37,680 --> 00:12:40,880
现在，在这种情况下，这并没有真正告诉我们任何令人兴奋的事情。

216
00:12:40,880 --> 00:12:46,160
它本质上意味着有一个空集，但我们才刚刚起步。

217
00:12:46,160 --> 00:12:50,320
作为下一个示例，请花点时间考虑一下将 f 评估为 1。

218
00:12:50,320 --> 00:12:53,795
这是我们可以用我们知道的表达式来做的事情，当你为所

219
00:12:53,795 --> 00:12:57,271
有这些 x 代入 1 时，每个项看起来都像 2，所

220
00:12:57,271 --> 00:13:00,480
以总共我们得到 2 乘以它本身 2,000 次。

221
00:13:00,480 --> 00:13:04,837
另一方面，在扩展表达式中，如果代入 x 等于 1，则

222
00:13:04,837 --> 00:13:09,680
x 的所有这些幂都变为 1，因此我们实际上是将所有系数相加。

223
00:13:09,680 --> 00:13:11,440
当你想到这一点时，这真是太酷了。

224
00:13:11,440 --> 00:13:17,440
只需通过单个数字评估函数，我们 就可以推断出所有系数的总和。

225
00:13:17,440 --> 00:13:21,245
现在，在我们的特定示例中，这并不是那么令人兴

226
00:13:21,245 --> 00:13:24,720
奋，因为我们已经知道这些系数的总和是多少。

227
00:13:24,720 --> 00:13:27,901
请记住，每个系数都会计算有多少个子集具有特定的

228
00:13:27,901 --> 00:13:31,083
总和，因此当您将它们相加时，我们只是计算所有子

229
00:13:31,083 --> 00:13:34,000
集，我们知道这些子集是 2 到 2,000。

230
00:13:34,000 --> 00:13:36,880
然而，如果我要求你将此函数评估为负

231
00:13:36,880 --> 00:13:39,440
1，我可以给你一个真正的新事实。

232
00:13:39,440 --> 00:13:43,360
花点时间思考一下这意味着什么。

233
00:13:43,360 --> 00:13:46,864
如果你插入负数 1，我们再次从我们知道的东西开始，即

234
00:13:46,864 --> 00:13:50,240
顶部的因式分解表达式，这里你所需要的就是查看第一项。

235
00:13:50,240 --> 00:13:53,002
当你代入 x 时，第一个括号变为

236
00:13:53,002 --> 00:13:55,440
0，因此整个表达式必须为 0。

237
00:13:55,440 --> 00:13:58,077
但是，当我们使用所有系数将其应用

238
00:13:58,077 --> 00:14:00,560
于扩展表达式时，这会告诉您什么？

239
00:14:00,560 --> 00:14:04,166
本着尽可能暗示这个解决方案所采取的奇怪

240
00:14:04,166 --> 00:14:07,773
转折的精神，我希望您能够真正以旋转的形

241
00:14:07,773 --> 00:14:11,200
式形象化这个表达式中负 1 的各种幂。

242
00:14:11,200 --> 00:14:15,071
第一项，负 1 到 0，就是 1，我们将其描绘为从

243
00:14:15,071 --> 00:14:16,560
0 到 1 的向量。

244
00:14:16,560 --> 00:14:21,160
负 1 的 1 次方就是负 1 本身，我希望

245
00:14:21,160 --> 00:14:25,360
您将其视为与上一项相距 180 度的旋转。

246
00:14:25,360 --> 00:14:28,705
然后，当我们取负 1 的平方时，即为正

247
00:14:28,705 --> 00:14:30,880
1，同样旋转 180 度。

248
00:14:30,880 --> 00:14:35,760
一般来说，这里的每个连续项看起来都像是又旋转了 180 度。

249
00:14:35,760 --> 00:14:38,974
从代数上来说，这意味着我们在偶数

250
00:14:38,974 --> 00:14:42,000
系数和奇数系数之间有一个振荡和。

251
00:14:42,000 --> 00:14:44,160
但请记住视觉效果。

252
00:14:44,160 --> 00:14:47,091
这个表达式对于任何生成函数都成立，但

253
00:14:47,091 --> 00:14:50,022
同样，对于我们的特殊生成函数，我们知

254
00:14:50,022 --> 00:14:52,800
道这个值，这个交替和，应该等于 0。

255
00:14:52,800 --> 00:14:56,346
您可以解释的一种方式是，它告诉您偶数

256
00:14:56,346 --> 00:14:59,520
系数和奇数系数之间存在相等的平衡。

257
00:14:59,520 --> 00:15:03,193
请记住，也许在我们较小的示例中，这些

258
00:15:03,193 --> 00:15:06,480
系数正在为我们编码有关子集的事实。

259
00:15:06,480 --> 00:15:11,574
因此，如果所有偶数系数和奇数系数之间存在相等的平衡，

260
00:15:11,574 --> 00:15:16,480
则表明所有子集的一半具有偶数和，其中一半具有奇数和。

261
00:15:16,480 --> 00:15:20,720
这可能是您所期望的，但一开始并不清楚如何展示这一点。

262
00:15:20,720 --> 00:15:24,320
有了生成函数，它就会立即弹出。

263
00:15:24,320 --> 00:15:29,736
再次，为了暗示我们要去哪里，让我通过我们评估的最后两项

264
00:15:29,736 --> 00:15:34,960
内容来稍微重写一下，将这两项相加，然后除以 1 一半。

265
00:15:34,960 --> 00:15:38,416
如果你仔细想想，这是一种过滤掉所有

266
00:15:38,416 --> 00:15:41,680
偶数系数并消除所有奇数系数的方法。

267
00:15:41,680 --> 00:15:45,436
因此，它成为一种特别干净的方式来编写以下事实：

268
00:15:45,436 --> 00:15:49,036
所有偶数系数的总和（在您的脑海中再次意味着具

269
00:15:49,036 --> 00:15:52,480
有偶数总和的子集总数）将看起来像总数的一半。

270
00:15:52,480 --> 00:15:57,280
不用说，这非常接近我们想要回答的实际问题。

271
00:15:57,280 --> 00:16:00,824
我们想要做的是找到一些可以对函数 f 做的聪

272
00:16:00,824 --> 00:16:04,369
明的事情，一些精心挑选的数字来评估它，这样我

273
00:16:04,369 --> 00:16:07,760
们就可以得到与 5 的倍数相对应的所有系数。

274
00:16:07,760 --> 00:16:10,310
再次回想一下这些系数为我们编码的

275
00:16:10,310 --> 00:16:12,560
内容，这将回答我们的最终问题。

276
00:16:12,560 --> 00:16:19,040
这将计算总和可被 5 整除的子集总数。

277
00:16:19,040 --> 00:16:22,625
这样做的技巧是概括我们刚刚所做的

278
00:16:22,625 --> 00:16:26,000
事情，其中输入的连续幂来回旋转。

279
00:16:26,000 --> 00:16:28,821
但这一次，我们不希望它们每隔一段时间旋转一次

280
00:16:28,821 --> 00:16:31,520
，我们希望它们以某种方式以 5 为周期旋转。

281
00:16:31,520 --> 00:16:34,480
为此，我们扩展到复平面。

282
00:16:34,480 --> 00:16:39,608
你看，在那里，我们可以找到一个值，这样当我们连续取它的幂

283
00:16:39,608 --> 00:16:44,560
时，它就会旋转五分之一圈，给我们一个频率为 5 的过程。

284
00:16:44,560 --> 00:16:49,680
如果你退后一步，我知道我 要求你思考复数有点荒谬。

285
00:16:49,680 --> 00:16:52,596
我的意思是，我们从一个计数问题开始，

286
00:16:52,596 --> 00:16:55,360
它是离散数学，但希望它不是那么疯狂。

287
00:16:55,360 --> 00:16:59,680
再说一次，我之所以把事情画出来是为了解决解决方案中的各种奇怪

288
00:16:59,680 --> 00:17:04,000
的转折，是因为它们实际上在更广泛的数学方案中并不那么奇怪。

289
00:17:04,000 --> 00:17:08,536
我们将要应用的技巧与使用复数来更好地理解

290
00:17:08,536 --> 00:17:12,640
整数的离散问题的许多其他实例非常相似。

291
00:17:12,640 --> 00:17:18,122
因此，越感觉像是你自己可以发现的东西

292
00:17:18,122 --> 00:17:23,605
，就越有可能当你在这个思想圈子中解决

293
00:17:23,605 --> 00:17:28,800
未来的某个问题时，你自己就会发现它。

294
00:17:28,800 --> 00:17:32,864
具体来说，我关心的复数是我要标记为 zet

295
00:17:32,864 --> 00:17:36,560
a 的复数，它位于单位圆的五分之一圈处。

296
00:17:36,560 --> 00:17:41,840
所以它的角度是 2 pi 五分之一弧度，大小是 1。

297
00:17:41,840 --> 00:17:45,840
这意味着使用标准欧拉公式符号，我们可以将该数字明

298
00:17:45,840 --> 00:17:49,520
确写为 e 的 2 pi i 除以 5 次方。

299
00:17:49,520 --> 00:17:55,960
如果您对这种表示法不太熟悉，您可以将其 视为实部为 72

300
00:17:55,960 --> 00:18:02,400
度的余弦，72 为五 分之一整圈，虚部为 72 度的正弦。

301
00:18:02,400 --> 00:18:06,160
但说实话，你实际上不需要考虑显式的值。

302
00:18:06,160 --> 00:18:10,960
相反，需要关注的重要事情是这个数字的幂所具有的属性。

303
00:18:10,960 --> 00:18:14,760
例如，当你平方它时，因为它的大小是一，所

304
00:18:14,760 --> 00:18:18,561
以它的平方的大小也是一，但它绕单位圆旋转

305
00:18:18,561 --> 00:18:22,000
五分之一圈，所以它现在位于五分之二圈。

306
00:18:22,000 --> 00:18:25,648
同样，当你将其提高到三次方时，你最终会得到五分之

307
00:18:25,648 --> 00:18:29,297
三回合，将其提高到四次方时，你最终会得到五分之四

308
00:18:29,297 --> 00:18:32,800
回合，并将其提高到五次方，你就得到了一路回到一。

309
00:18:32,800 --> 00:18:37,360
这与将其提高到零次方是一样的，我们每五 项就进行一次循环。

310
00:18:37,360 --> 00:18:39,600
这就是我们关心的事情。

311
00:18:39,600 --> 00:18:42,992
这些数字有一个特殊的名字，它们被称为

312
00:18:42,992 --> 00:18:46,385
五次单位根，本质上是因为它们解方程z

313
00:18:46,385 --> 00:18:49,600
到五次等于一，它们是数字一的五次根。

314
00:18:49,600 --> 00:18:52,682
如果你刚刚向某人提出这个方程，他们可能会

315
00:18:52,682 --> 00:18:55,765
说，答案显然是 z 等于 1，但这个想法

316
00:18:55,765 --> 00:18:58,848
是在复平面上还有四个其他答案，四个其他数

317
00:18:58,848 --> 00:19:01,930
字，当你将它们提高到第五个时，你会得到一

318
00:19:01,930 --> 00:19:04,720
个，并将它们视为一个集体通常非常有用。

319
00:19:04,720 --> 00:19:08,560
记住这个等式，稍后我们就会回来。

320
00:19:08,560 --> 00:19:13,251
因此，与我们之前所做的类似，我们将 1 的 f 和负 1

321
00:19:13,251 --> 00:19:15,840
的 f 加在一起以获得奇数项中

322
00:19:15,840 --> 00:19:19,560
的抵消，我们要做的就是对所有五个数字求 f，

323
00:19:19,560 --> 00:19:23,120
然后相加他们在一起，希望我们能得到一些取消。

324
00:19:23,120 --> 00:19:26,551
这可能看起来有点复杂，但让我们举一个超级简单的

325
00:19:26,551 --> 00:19:29,840
例子，比如 x 的 f 简单等于 x 的情况。

326
00:19:29,840 --> 00:19:32,728
在这种情况下，当我们将这五个项相加时，我们只是将

327
00:19:32,728 --> 00:19:35,502
单位根本身相加，即 zeta 到零加上 zet

328
00:19:35,502 --> 00:19:38,160
a 到一，如此往复，直到 zeta 到第四个。

329
00:19:38,160 --> 00:19:42,960
当您添加复数时，您可以将其 视为向量加法，尖端在尾部。

330
00:19:42,960 --> 00:19:46,259
所以 zeta 到零加上 zeta 看起来像这

331
00:19:46,259 --> 00:19:49,558
样，然后如果我加上 zeta 平方，将该向量的

332
00:19:49,558 --> 00:19:52,720
尾部带到最后一个向量的尖端，我们就得到了这个。

333
00:19:52,720 --> 00:19:56,262
然后类似地，如果我将 zeta 的尾部的立方放

334
00:19:56,262 --> 00:19:59,805
在该顶点的尖端，然后对 zeta 进行同样的操

335
00:19:59,805 --> 00:20:03,200
作到第四个，您将看到总和实际上如何循环回到零。

336
00:20:03,200 --> 00:20:08,800
另一种思考方式是，所有这五 个项都围绕数字零均匀平衡。

337
00:20:08,800 --> 00:20:11,920
它们的质心位于原点。

338
00:20:11,920 --> 00:20:14,650
现在考虑一个稍微不那么简单的例子会很有帮

339
00:20:14,650 --> 00:20:17,120
助，如果 x 的 f 是 x 的平方。

340
00:20:17,120 --> 00:20:19,256
因此，当您将 zeta 平方为零时，它会保持

341
00:20:19,256 --> 00:20:20,000
zeta 为零。

342
00:20:20,000 --> 00:20:22,480
这只是说第一名的一种奇特方式。

343
00:20:22,480 --> 00:20:24,286
当您对 zeta 进行平方时，您会得到

344
00:20:24,286 --> 00:20:25,280
zeta 本身的平方。

345
00:20:25,280 --> 00:20:29,215
所以你可能会想象，当我们这样做时，这里的这个点会移动到

346
00:20:29,215 --> 00:20:30,480
zeta 平方点。

347
00:20:30,480 --> 00:20:33,040
Zeta 平方移动到 zeta 到第四位。

348
00:20:33,040 --> 00:20:36,560
您可能会想象这个点移动到 zeta 到第四个。

349
00:20:36,560 --> 00:20:40,054
Zeta 立方移动到 zeta 到第六，因为我们每

350
00:20:40,054 --> 00:20:43,280
循环五次，所以它与 zeta 到 1 是一样的。

351
00:20:43,280 --> 00:20:46,480
所以这个点会向上移动。

352
00:20:46,480 --> 00:20:51,079
最后，zeta 到第四个正方形，得到 zeta 到第八个

353
00:20:51,079 --> 00:20:55,520
正方形，它减少到与 zeta 立方相同，我可能会这样画。

354
00:20:55,520 --> 00:20:58,237
考虑起来可能有点令人困惑，尤其是我在

355
00:20:58,237 --> 00:21:00,954
这里画的所有箭头，但在你的一生中至少

356
00:21:00,954 --> 00:21:03,671
值得思考一次，因为这里的想法是，当我

357
00:21:03,671 --> 00:21:06,388
们将其平方时，就像去所有这些不同的方

358
00:21:06,388 --> 00:21:09,105
向一样项，我将它们编程为将它们所具有

359
00:21:09,105 --> 00:21:11,680
的角度加倍，总体效果就是打乱这些项。

360
00:21:11,680 --> 00:21:14,317
我们得到相同的数字，但以不同的顺

361
00:21:14,317 --> 00:21:16,800
序写入，因此它们的总和仍然为零。

362
00:21:16,800 --> 00:21:20,176
同样，如果你用 x 的立方来完成这个练习

363
00:21:20,176 --> 00:21:23,392
（我鼓励你这样做），并且你跟踪这些点中

364
00:21:23,392 --> 00:21:26,769
的每一个最终会在哪里，你将能够看到，当我

365
00:21:26,769 --> 00:21:29,984
们对这些项进行立方时，当我们取出每一个

366
00:21:29,984 --> 00:21:33,040
，将其角度乘以三，然后再次将它们打乱。

367
00:21:33,040 --> 00:21:35,040
相同的术语以不同的顺序列出。

368
00:21:35,040 --> 00:21:38,549
不出所料，如果我们的函数是 x

369
00:21:38,549 --> 00:21:41,840
的四次方，同样的事情也会发生。

370
00:21:41,840 --> 00:21:44,518
但是，关键的是，如果我们考虑函数

371
00:21:44,518 --> 00:21:47,040
x 的第五次，事情就会发生变化。

372
00:21:47,040 --> 00:21:49,524
在这种情况下，当你将 zeta

373
00:21:49,524 --> 00:21:52,320
提高到五次方时，根据定义它会变成一。

374
00:21:52,320 --> 00:21:55,520
同样，zeta 平方的五次方变为一。

375
00:21:55,520 --> 00:21:57,920
所有这些都归于一，它们是团结的根源。

376
00:21:57,920 --> 00:22:00,320
毕竟，这就是他们人生的全部目的。

377
00:22:00,320 --> 00:22:04,558
因此，在这种情况下，当我们应用该函数并将它们全部相加

378
00:22:04,558 --> 00:22:08,640
时，我们得到的是一种相长干涉，而不是归零并得到抵消。

379
00:22:08,640 --> 00:22:11,920
它们都等于一，所以它们的总和等于五。

380
00:22:11,920 --> 00:22:15,468
因此，如果你退一步思考所有这些例子的含

381
00:22:15,468 --> 00:22:19,017
义，本质上这个表达式对于 x 的幂来说

382
00:22:19,017 --> 00:22:22,566
将趋于零，不能被五整除，但对于 x 的

383
00:22:22,566 --> 00:22:25,760
幂来说它会趋于非零，这可以被五整除。

384
00:22:25,760 --> 00:22:28,960
这正是我们正在寻找的过滤器。

385
00:22:28,960 --> 00:22:33,452
如果您担心我们的实际函数比简单的 x 幂复杂得多，

386
00:22:33,452 --> 00:22:37,600
那么本质上这里的情况非常好，因为一切都是线性的。

387
00:22:37,600 --> 00:22:41,016
如果 f 是某个大多项式，并且我们想要计

388
00:22:41,016 --> 00:22:45,733
算这个大和，您可以考虑逐列进行计算，每 次您实际上只是将

389
00:22:45,733 --> 00:22:47,360
zeta 的幂相加。

390
00:22:47,360 --> 00:22:51,440
在大多数情况下，所有这些力量都会相互抵消，结果为零。

391
00:22:51,440 --> 00:22:55,525
但是，当所有这些幂都是五的倍数时，它们会产生相

392
00:22:55,525 --> 00:22:59,440
长干涉，无论相应的系数是多少，您都会得到五倍。

393
00:22:59,440 --> 00:23:02,320
在杂草深处，我们很容易忘记我们最初为何来到这里。

394
00:23:02,320 --> 00:23:05,160
但请记住，这些系数中的每一个都告诉我

395
00:23:05,160 --> 00:23:08,000
们有多少个子集加起来达到某一特定值。

396
00:23:08,000 --> 00:23:12,320
所以我们首先想要的是将所有系数相加。

397
00:23:12,320 --> 00:23:15,840
我们现在拥有的是一种明确做到这一点的方法。

398
00:23:15,840 --> 00:23:19,085
如果我们根据这五个不同的单位根来评估这个函

399
00:23:19,085 --> 00:23:22,330
数（我知道这似乎有点奇怪），那么我们所要做

400
00:23:22,330 --> 00:23:25,280
的就是除以五，它就给出了我们想要的总和。

401
00:23:25,280 --> 00:23:27,360
如果你问我的话，那真的很酷。

402
00:23:27,360 --> 00:23:31,194
我们有一个关于子集的问题，这是一个离散

403
00:23:31,194 --> 00:23:35,028
数学问题，但我们回答它的方法是在一些明

404
00:23:35,028 --> 00:23:38,480
智选择的复数上评估一个疯狂的多项式。

405
00:23:38,480 --> 00:23:41,280
你做的数学越多，你得到的就越多。

406
00:23:41,280 --> 00:23:44,414
你做的数学越多，看起来就越不疯狂，

407
00:23:44,414 --> 00:23:47,374
因为复数与离散数学有这种奇怪的关

408
00:23:47,374 --> 00:23:50,160
系，但这确实很棒，没有两种方法。

409
00:23:50,160 --> 00:23:54,401
然而，你们中的一些人可能会抱怨，唯一有用的方法是我

410
00:23:54,401 --> 00:23:58,480
们是否可以在我们的多项式上实际评估这个通配表达式。

411
00:23:58,480 --> 00:24:02,218
现在记住，我们知道的多项式的形式，我们熟悉的形式，

412
00:24:02,218 --> 00:24:05,669
是因式分解形式，其中有 1 加 x，1 加 x

413
00:24:05,669 --> 00:24:09,120
的平方，等等，一直到 1 加 x 到2,000。

414
00:24:09,120 --> 00:24:12,480
到目前为止，一切都只是毫无意义的象征性游

415
00:24:12,480 --> 00:24:15,680
戏，将一个难题推向另一个难题，除非我们

416
00:24:15,680 --> 00:24:18,720
真的能卷起袖子在这里做一些诚实的计算。

417
00:24:18,720 --> 00:24:22,560
这是我们论证的最后一个要点，所以退后一步，深吸一口气。

418
00:24:22,560 --> 00:24:27,165
它实际上并不像你想象的那么糟糕，但让我们首先考虑如何

419
00:24:27,165 --> 00:24:31,600
评估我们需要的统一根源之一，也许是 Zeta 本身。

420
00:24:31,600 --> 00:24:34,122
所以看起来就是 1 加 zeta，乘以 1 加

421
00:24:34,122 --> 00:24:36,960
z eta 平方，乘以 1 加 zeta 立方，等等。

422
00:24:36,960 --> 00:24:40,118
但重要的是，在前五个任期之后，一切都开

423
00:24:40,118 --> 00:24:43,120
始重复，因为 Zeta 的力量会重复。

424
00:24:43,120 --> 00:24:47,774
整个表达式最多 2,000 基本上只是该表达式

425
00:24:47,774 --> 00:24:49,520
400 次的副本。

426
00:24:49,520 --> 00:24:52,678
评估这个表达式似乎仍然很困难，但它比乘

427
00:24:52,678 --> 00:24:55,680
以 2,000 个不同的项要容易得多。

428
00:24:55,680 --> 00:24:59,360
您可以想象的一种方式是，我们采用每一个统一根

429
00:24:59,360 --> 00:25:02,880
，但基本上添加一个，我们将它们全部向右移动。

430
00:25:02,880 --> 00:25:05,894
这张图实际上为我们可能期望的数

431
00:25:05,894 --> 00:25:08,720
字答案提供了非常好的几何直觉。

432
00:25:08,720 --> 00:25:14,640
我们想要的是这五个不同复 数的乘积，即这五个黄点。

433
00:25:14,640 --> 00:25:19,346
如果你对复数略知一二，因为它们是共轭对的，

434
00:25:19,346 --> 00:25:23,840
我们真正需要的就是将这五条黄线的长度相乘。

435
00:25:23,840 --> 00:25:27,933
例如，最右边的那个点对应于 1 加 zeta

436
00:25:27,933 --> 00:25:32,560
到 第五个，在图中我将其标记为 zeta 到零加一。

437
00:25:32,560 --> 00:25:36,800
但没关系，无论哪种情况，它们 都只是写数字二的奇特方式。

438
00:25:36,800 --> 00:25:40,020
接下来，我们有值一加 zeta 和一加 ze

439
00:25:40,020 --> 00:25:42,960
ta 到第四个值，这两个值具有相同的大小。

440
00:25:42,960 --> 00:25:44,720
这些线的长度是相同的。

441
00:25:44,720 --> 00:25:46,880
我们给它起个名字，L1。

442
00:25:46,880 --> 00:25:51,120
所以我们需要将该长度 L1 的平方的两个不同副本相乘。

443
00:25:51,120 --> 00:25:54,831
同样，剩下的两个值，zeta 平方加一和 zeta

444
00:25:54,831 --> 00:25:58,400
立方加一，它们也具有相同的长度，并且它们是共轭对。

445
00:25:58,400 --> 00:26:00,640
所以我们称这个长度为L2。

446
00:26:00,640 --> 00:26:04,160
因此我们的产品需要包含该 L2 的两个副本。

447
00:26:04,160 --> 00:26:08,763
如果我们只是进行松散的启发式猜测，您可能会注意到

448
00:26:08,763 --> 00:26:13,920
L1 的长度比 1 稍长，而 L2 的长度比 1 稍短。

449
00:26:13,920 --> 00:26:17,760
所以这里的最终答案可能是大约两个左右。

450
00:26:17,760 --> 00:26:19,920
我们并不乐观，但大致上有些东西。

451
00:26:19,920 --> 00:26:24,240
为了将其变成精确的答案，我们可以扩展完整的表达式。

452
00:26:24,240 --> 00:26:27,200
老实说，这并没有那么糟糕，只有 32 个不同的术语。

453
00:26:27,200 --> 00:26:37,120
好吧，你已经和我在一起很长时间了，我知道它会变得很多。

454
00:26:37,120 --> 00:26:40,244
但整个论证中还有最后一个技巧，它使我

455
00:26:40,244 --> 00:26:43,040
们的最后一步比您想象的要简单得多。

456
00:26:43,040 --> 00:26:45,520
让我们回顾一下，以提醒自己我们现在所处的位置。

457
00:26:45,520 --> 00:26:48,786
所以我们从这个问题开始，要求我们计算 1 到

458
00:26:48,786 --> 00:26:52,480
2 ,000 的子集的数量，其总和可以被 5 整除。

459
00:26:52,480 --> 00:26:56,208
然后我们构造了这个多项式，其系数告诉我们

460
00:26:56,208 --> 00:26:59,760
有多少子集对于每个值 n 具有特定的和。

461
00:26:59,760 --> 00:27:04,720
所以我们想要的是将该多项式的每五个系数相加。

462
00:27:04,720 --> 00:27:09,206
然后我们看到了如何将该多项式作为所有单位五次根的函

463
00:27:09,206 --> 00:27:13,520
数求值，然后将它们相加，最终得到我们想要的滤波器。

464
00:27:13,520 --> 00:27:16,920
在这里，我们只评估其中一项，即 zeta

465
00:27:16,920 --> 00:27:20,320
的 f，它本质上可以归结为五个复数的乘积。

466
00:27:20,320 --> 00:27:25,120
作为实际评估该产品的超级巧妙方法，这是最后一个技巧。

467
00:27:25,120 --> 00:27:27,920
请记住，我将这些数字描述为统一根。

468
00:27:27,920 --> 00:27:30,880
他们解方程 z 到第五次等于一。

469
00:27:30,880 --> 00:27:36,720
另一种思考方式是，它们是多项式 z 的第五次减一的根。

470
00:27:36,720 --> 00:27:41,194
现在这意味着我们可以将多项式 z 分解为第五

471
00:27:41,194 --> 00:27:45,280
次减一，如下所示，其中每个根对应一个因子。

472
00:27:45,280 --> 00:27:47,520
你用 z 减去每一个根。

473
00:27:47,520 --> 00:27:50,602
当你想到当你把它全部展开时必须发生的

474
00:27:50,602 --> 00:27:53,360
所有疯狂取消时，这个表达有点神奇。

475
00:27:53,360 --> 00:27:56,804
但这是真的，而且现在对我们来说非常

476
00:27:56,804 --> 00:28:00,058
有用，因为右侧的表达式看起来与我

477
00:28:00,058 --> 00:28:03,120
们需要在顶部评估的内容几乎相同。

478
00:28:03,120 --> 00:28:07,520
它基本上只有减号，而我们希望有加号。

479
00:28:07,520 --> 00:28:10,800
诀窍是插入 z 等于负一。

480
00:28:10,800 --> 00:28:14,240
如果你这样做，你基本上就得到了我们想要的负面结果。

481
00:28:14,240 --> 00:28:18,860
因此，如果将其乘以负一，请注意这里的左侧

482
00:28:18,860 --> 00:28:23,040
（一开始是负一减一或负二）如何变成二。

483
00:28:23,040 --> 00:28:26,720
然后右边就变成了我们想要评估的东西。

484
00:28:26,720 --> 00:28:31,720
因此，正如我们之前的几何直觉所暗示的那样，答案不

485
00:28:31,720 --> 00:28:36,320
仅是 2 左右，而且答案非常神奇地恰好是 2。

486
00:28:36,320 --> 00:28:40,051
这实际上非常好，非常可爱，因为这意味着我们想要

487
00:28:40,051 --> 00:28:43,783
评估这个更大的表达式，我们将 f 在所有不同的

488
00:28:43,783 --> 00:28:47,360
单位根上相加，我们知道它在第一个单位根上的值。

489
00:28:47,360 --> 00:28:49,600
它将是 2 的 400 次方。

490
00:28:49,600 --> 00:28:53,593
本质上相同的推理表明，它在接下来的三个单位根上的值也是

491
00:28:53,593 --> 00:28:56,587
2 的 400 次方，因为请记住，当您取

492
00:28:56,587 --> 00:28:59,867
zeta 平方或 zeta 立方的幂时，您会得

493
00:28:59,867 --> 00:29:02,720
到相同的数字列表，只是以不同的顺序洗牌。

494
00:29:02,720 --> 00:29:06,640
唯一不同的是当我们将其评估为 zeta 为零时。

495
00:29:06,640 --> 00:29:09,468
但 zeta 为零是表达第一的一种奇

496
00:29:09,468 --> 00:29:12,000
特方式，我们知道如何以一来评估它。

497
00:29:12,000 --> 00:29:13,040
这是很容易的事情之一。

498
00:29:13,040 --> 00:29:14,160
我们之前就这样做过。

499
00:29:14,160 --> 00:29:17,328
所有这些括号都变成了 2，所以看起

500
00:29:17,328 --> 00:29:20,320
来就像 2 乘以 2,000 倍。

501
00:29:20,320 --> 00:29:26,160
最后，我们对计数问题有了一个非常明确、诚实的答案。

502
00:29:26,160 --> 00:29:31,108
将所有可被五整除的系数相加，记住这是一种计算有多

503
00:29:31,108 --> 00:29:36,056
少总子集的总和可被五整除的方法，答案是这个奇怪的

504
00:29:36,056 --> 00:29:41,005
复杂表达式的五分之一，我们刚刚计算为二2,000

505
00:29:41,005 --> 00:29:45,360
份加上 2 份到 400 份的四个不同副本。

506
00:29:45,360 --> 00:29:49,840
在这里，您可能只想快速检查一下这个答案是否有意义。

507
00:29:49,840 --> 00:29:53,611
例如，如果您在较小的情况下使用设置一、二

508
00:29:53,611 --> 00:29:57,383
、三、四、五进行计算，并且您执行与我们刚

509
00:29:57,383 --> 00:30:00,975
才相同的所有推理，它会告诉您答案是二的

510
00:30:00,975 --> 00:30:05,645
五分之一第五，子集总数，在本例中加四乘二 到一，即

511
00:30:05,645 --> 00:30:08,160
32 的五分之一加八，即八。

512
00:30:08,160 --> 00:30:11,450
如果您还记得当我们明确地查看所

513
00:30:11,450 --> 00:30:14,960
有这些内容时，这实际上就是答案。

514
00:30:14,960 --> 00:30:19,820
看，这是一个很难的难题，当值得投入时间来解

515
00:30:19,820 --> 00:30:24,240
决一个难题时，也值得花一些时间进行反思。

516
00:30:24,240 --> 00:30:25,251
你从中得到什么？

517
00:30:25,251 --> 00:30:26,640
外卖是什么？

518
00:30:26,640 --> 00:30:30,118
现在你可以反思答案本身，主导部分如何确实是

519
00:30:30,118 --> 00:30:33,439
所有子集总数的五分之一，就像我们可能猜测

520
00:30:33,439 --> 00:30:36,917
的那样，以及这个误差项是如何从统一根的大规

521
00:30:36,917 --> 00:30:40,080
模组合中不完全具有破坏性的干扰中产生的。

522
00:30:40,080 --> 00:30:44,217
但同样，让这个问题有趣的不是答案，而

523
00:30:44,217 --> 00:30:48,137
是我们解决它的方式，即采用我们想要

524
00:30:48,137 --> 00:30:52,057
理解的离散序列，并将其视为多项式的

525
00:30:52,057 --> 00:30:55,760
系数，然后在复数值上评估该多项式。

526
00:30:55,760 --> 00:30:58,794
这两个步骤一开始可能是非常出乎意料的，但

527
00:30:58,794 --> 00:31:01,829
这两个步骤都与一些非常通用和强大的技术相

528
00:31:01,829 --> 00:31:04,720
关，您可以在数学的其他地方找到这些技术。

529
00:31:04,720 --> 00:31:08,625
例如，在课程的顶部，我承诺我们将使用的

530
00:31:08,625 --> 00:31:12,530
技术在本质上将类似于研究素数的方式，以

531
00:31:12,530 --> 00:31:16,240
及导致黎曼假设和类似事物的一系列想法。

532
00:31:16,240 --> 00:31:19,845
这是一个非常美丽的话题，足以让我觉得把某

533
00:31:19,845 --> 00:31:23,280
种仓促的版本塞到这里的结尾似乎有点犯罪。

534
00:31:23,280 --> 00:31:26,881
我认为正确的做法是制作我不久前承诺过的关于

535
00:31:26,881 --> 00:31:30,320
zeta 函数的视频，花点时间，把它做好。

536
00:31:30,320 --> 00:31:34,758
但如果你很好奇，并且允许我在屏幕上抛出一些东西而不解释

537
00:31:34,758 --> 00:31:38,880
它们，这里有两到三句话的版本来说明两者是如何平行的。

538
00:31:38,880 --> 00:31:42,521
就像我们的子集难题一样，黎曼研究素

539
00:31:42,521 --> 00:31:46,162
数的方式涉及我们想要理解的离散序列

540
00:31:46,162 --> 00:31:49,803
，其中包含有关素数的信息，然后考虑

541
00:31:49,803 --> 00:31:53,040
一个其系数是该序列中的项的函数。

542
00:31:53,040 --> 00:31:56,006
在这种情况下，它不完全是一个多项式，而是一

543
00:31:56,006 --> 00:31:58,972
个称为狄利克雷级数的相 关结构，或狄利克雷

544
00:31:58,972 --> 00:32:02,080
级数取决于你问的是谁，但它是相同的基本思想。

545
00:32:02,080 --> 00:32:05,664
然后，找出有关这些系数的信息的

546
00:32:05,664 --> 00:32:12,160
方法来自于研究该函数如何与（ 您猜对了）复值输入一起运行。

547
00:32:12,160 --> 00:32:16,428
毕竟黎曼是复分析的先驱，他的例子中的

548
00:32:16,428 --> 00:32:20,472
技术变得更加复杂，但事实仍然是，像

549
00:32:20,472 --> 00:32:24,740
这样将你的域扩展到实数之外，为你（数

550
00:32:24,740 --> 00:32:28,560
学家）提供了更多的能力来推论系数。

551
00:32:28,560 --> 00:32:32,604
对于一些观众来说，这一切可能会留下一个挥之不去

552
00:32:32,604 --> 00:32:36,480
的问题：为什么复数以这种方式如此不合理地有用。

553
00:32:36,480 --> 00:32:40,353
这是一个很难准确回答的问题，但如果你想想我们

554
00:32:40,353 --> 00:32:44,227
的难题，我们刚刚所做的一切，一旦我们处于这种

555
00:32:44,227 --> 00:32:48,101
情况，插入不同的输入就会显示有关系数的隐藏信

556
00:32:48,101 --> 00:32:51,974
息，这有点像，你的输入越多可以工作得越好，所

557
00:32:51,974 --> 00:32:55,680
以你不妨向更丰富的数字空间开放，比如复平面。

558
00:32:55,680 --> 00:32:59,920
但我希望你能有一个更具体的直觉。

559
00:32:59,920 --> 00:33:03,535
在我们的难题中，我们想要的相关事实，

560
00:33:03,535 --> 00:33:06,960
即每五个系数的总和，是一种频率问题。

561
00:33:06,960 --> 00:33:10,356
与其他结构相比，复数被证明对我们有

562
00:33:10,356 --> 00:33:13,752
用的真正原因是，我们可以找到一个值

563
00:33:13,752 --> 00:33:16,960
，以便连续的产品具有这种循环行为。

564
00:33:16,960 --> 00:33:20,710
使用单位圆上的值，特别是单位根来

565
00:33:20,710 --> 00:33:24,240
找出频率信息，是非常富有成效的。

566
00:33:24,240 --> 00:33:28,400
这个想法的帮助之大几乎不可能被夸大。

567
00:33:28,400 --> 00:33:31,912
仅举数千个例子中的一个，在 20 世纪 90

568
00:33:31,912 --> 00:33:35,272
年代，Peter S hor 找到了一种让量

569
00:33:35,272 --> 00:33:38,480
子计算机比传统计算机更快地分解大数的方法。

570
00:33:38,480 --> 00:33:42,026
如果你深入了解我们现在所说的 Shor

571
00:33:42,026 --> 00:33:47,346
算法的工作原理，你会 发现其想法本质上是这样的，即使用单位根

572
00:33:47,346 --> 00:33:49,120
来检测一种频率信息。

573
00:33:49,120 --> 00:33:53,053
更一般地说，这是傅里叶变换和傅里叶级数的

574
00:33:53,053 --> 00:33:56,800
核心思想，以及随之而来的无穷无尽的主题。

575
00:33:56,800 --> 00:34:00,793
至于生成函数本身的主题，我们实际上只是触及了表面，

576
00:34:00,793 --> 00:34:04,633
如果您想了解更多信息，我强烈推荐 Herbert

577
00:34:04,633 --> 00:34:08,320
Wilf 所著的这种名字搞笑的书《生成函数学》。

578
00:34:08,320 --> 00:34:09,619
我还会在屏幕上留下一些有趣的谜题，供那些想

579
00:34:09,619 --> 00:34:10,800
要通过这个想法稍微展示一下肌肉的人使用。

