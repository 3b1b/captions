1
00:00:00,000 --> 00:00:02,647
一会儿，我会问你一个谜题，实际上，

2
00:00:02,647 --> 00:00:05,917
这是一个相当 难的谜题，但在我这样做之前，

3
00:00:05,917 --> 00:00:09,498
我想先剧透一下，事 实上，我们解决这个问题的方

4
00:00:09,498 --> 00:00:10,900
法涉及到使用复数。

5
00:00:11,560 --> 00:00:14,760
一旦你听到它，你就会同意这似乎很荒谬 ，

6
00:00:14,760 --> 00:00:17,480
因为这个谜题纯粹是一个离散的问题。

7
00:00:17,800 --> 00:00:20,260
它只询问整数及其总和。

8
00:00:20,660 --> 00:00:24,560
地平线上的任何地方都没有一丝想象的气息，甚至连连续性都没有。

9
00:00:25,280 --> 00:00:30,720
借用一句话来说，这当然不是复 数对于离散数学的唯一用处。

10
00:00:31,160 --> 00:00:36,097
我可以举的更著名的例子是数学家如何理解素 数的现代方式，

11
00:00:36,097 --> 00:00:41,035
你知道，关于它们如何分布、 它们在某些区域的密度等问题，

12
00:00:41,035 --> 00:00:45,620
嗯，它涉及研 究专门设计的函数其输入和输出都是复数。

13
00:00:46,120 --> 00:00:49,360
你们中有些人可能知道这就是著名的黎曼猜想的全部内容。

14
00:00:49,680 --> 00:00:52,819
基本上，有一个专门设计的函数，从表面 上看，

15
00:00:52,819 --> 00:00:54,960
它看起来与素数的离散世界无关。

16
00:00:55,060 --> 00:00:57,000
它很光滑，它的值很复杂。

17
00:00:57,000 --> 00:01:02,180
但在幕后，它编码了您可能想要的 有关这些离散素数的所有信息。

18
00:01:02,600 --> 00:01:06,702
最重要的是，通过分析这个函数比直接分析 

19
00:01:06,702 --> 00:01:10,600
素数本身更容易回答有关素数的某些问题。

20
00:01:11,260 --> 00:01:16,060
当然，我们的难题（我保证稍后会 分享）比黎曼假设要简单得多。

21
00:01:16,260 --> 00:01:17,420
这是一个玩具问题。

22
00:01:17,880 --> 00:01:21,711
但在视频的最后，我将分享我们用来解决这个问 题的技术，

23
00:01:21,711 --> 00:01:23,981
以及我们在这里的真正原因，实际 

24
00:01:23,981 --> 00:01:26,820
上在精神上与导致黎曼假设的设置非常相似。

25
00:01:27,000 --> 00:01:29,600
还有素数定理和围绕它的整个思想圈。

26
00:01:29,600 --> 00:01:33,466
我们今天的谜题来自这本书，作者是 

27
00:01:33,466 --> 00:01:39,380
Titou、Rescu 和 Zoomingfeng。

28
00:01:39,480 --> 00:01:41,973
它基本上是训练美国队参加国际数学 

29
00:01:41,973 --> 00:01:44,320
奥林匹克竞赛时使用的一系列问题。

30
00:01:44,940 --> 00:01:47,325
如果我们翻到第 2 章“高级问题”，

31
00:01:47,325 --> 00:01:50,240
第 10 个问题就提出了这个看似无辜的问题。

32
00:01:50,920 --> 00:01:54,992
求集合 1 到 2000 的子集 个数，

33
00:01:54,992 --> 00:01:57,640
其元素之和能被 5 整除。

34
00:01:59,180 --> 00:02:01,420
好的，这可能需要一些时间来解析。

35
00:02:01,640 --> 00:02:05,320
例如，像集合 3、1、4 这样的集合就是一个子集。

36
00:02:05,660 --> 00:02:08,060
它的所有元素也是大集合中的元素。

37
00:02:08,580 --> 00:02:12,500
它的和，3 加 1 加 4，是 8，所以不予考虑。

38
00:02:12,600 --> 00:02:13,540
这不在我们的计算范围之内。

39
00:02:13,840 --> 00:02:17,718
而像集合 2、3、5 这样的集合（也是一个子集）的总和为 

40
00:02:17,718 --> 00:02:18,120
10。

41
00:02:18,440 --> 00:02:20,920
它可以被 5 整除，所以我们要计算它。

42
00:02:21,400 --> 00:02:27,140
我一开始的预览动画本质上是一个 试图回答这个问题的暴力程序。

43
00:02:27,720 --> 00:02:32,223
它将迭代所有不同的可能子集，一路找 到每个子集的总和，

44
00:02:32,223 --> 00:02:36,060
并且每次找到 5 的倍数时都会增加一个计数器。

45
00:02:36,760 --> 00:02:39,722
你知道吗，这里的一个很好的热身问题 

46
00:02:39,722 --> 00:02:42,520
是停下来思考一下总共有多少个子集？

47
00:02:42,820 --> 00:02:44,160
忘记这个 5 的倍数吧。

48
00:02:44,420 --> 00:02:46,560
该程序需要多长时间才能终止？

49
00:02:48,060 --> 00:02:51,500
你们中的许多人可能知道答案是 2 的 2000 次方。

50
00:02:52,120 --> 00:02:55,030
基本思想是，当您构建子集时，您可以 

51
00:02:55,030 --> 00:02:57,780
做出 2000 种不同的二元选择。

52
00:02:58,000 --> 00:02:59,480
您是否包含某个元素？

53
00:03:00,080 --> 00:03:04,960
所有这些选择都是相互独立的，因此构建 子集时的选择总数是 

54
00:03:04,960 --> 00:03:09,000
2 × 2 × 2 × 2，等等，2000 次。

55
00:03:09,800 --> 00:03:13,240
想想我们的计划，这是一个巨大的数字。

56
00:03:13,620 --> 00:03:17,385
因此，即使我们在宇宙中一直采用这种强 力方法，

57
00:03:17,385 --> 00:03:21,150
即使宇宙可以提供所有物理资 源，它也不会接近，

58
00:03:21,150 --> 00:03:22,460
它不会触及表面。

59
00:03:23,060 --> 00:03:25,180
显然我们必须比这聪明得多。

60
00:03:25,560 --> 00:03:28,573
如果你只是猜测答案应该是什么，做一个粗略的近似，

61
00:03:28,573 --> 00:03:32,340
你可能 会猜测，你知道，它应该是所有子集总数的五分之一左右。

62
00:03:32,540 --> 00:03:35,580
所有这些总和 mod 5 可能大致均匀分布。

63
00:03:36,000 --> 00:03:38,080
是的，确实如此，这是一个不错的近似值。

64
00:03:38,500 --> 00:03:42,220
但问题的核心、真正的挑战是获得准确的答案。

65
00:03:42,720 --> 00:03:45,694
这不可能是实际答案，因为它不是整数 ，

66
00:03:45,694 --> 00:03:48,200
但真正的答案是多一点还是少一点？

67
00:03:48,520 --> 00:03:50,340
或者可能多了很多或少了很多？

68
00:03:50,600 --> 00:03:53,540
您可以使用什么策略来找出该错误？

69
00:03:55,680 --> 00:03:59,540
需要明确的是，本课绝对更多的是关于旅程而不是目的地。

70
00:04:00,260 --> 00:04:02,820
您是否需要以这种方式过滤和计算子集？

71
00:04:03,300 --> 00:04:05,160
几乎肯定不会，我没想到会这样。

72
00:04:05,360 --> 00:04:09,444
但无论是否是玩具问题，这都是一个合理的挑战性问题，

73
00:04:09,444 --> 00:04:14,020
应 对这一挑战可以培养与其他类型的挑战性问题相关的技能。

74
00:04:14,020 --> 00:04:17,507
对于你我来说，我想与你分享的解决方案至 

75
00:04:17,507 --> 00:04:20,820
少有两个非常令人惊讶和非常美丽的转折。

76
00:04:21,300 --> 00:04:26,051
我已经暗示复数会令人惊讶地出现，但在我 们做到这一点之前，

77
00:04:26,051 --> 00:04:30,640
还有另一个奇怪的转 折，这可以说是更奇怪、更意想不到的。

78
00:04:31,300 --> 00:04:33,714
不过，为了做好准备，让我们先弄清楚这个难题，

79
00:04:33,714 --> 00:04:35,799
并做所 有优秀问题解决者应该做的事情，

80
00:04:35,799 --> 00:04:38,323
从一个更简单的例子开 始，也许只是尝试使用第 

81
00:04:38,323 --> 00:04:39,640
1、2、3、4、5 组。

82
00:04:39,640 --> 00:04:42,508
如果您用铅笔和纸解决这个问题，您知道，

83
00:04:42,508 --> 00:04:44,923
您 是 IMO 培训的孩子之一，

84
00:04:44,923 --> 00:04:49,000
简单地列出所 有 2 到 5 个子集并不是一个坏主意。

85
00:04:49,340 --> 00:04:51,240
只有32个，不算多。

86
00:04:55,680 --> 00:04:59,391
您可能想用不同的方式在脑海中组织所有这些内容 ，

87
00:04:59,391 --> 00:05:02,792
但由于我们关心的是它们的总和，因此自然要做 

88
00:05:02,792 --> 00:05:06,040
的就是一一浏览所有这些内容并计算这些总和。

89
00:05:06,520 --> 00:05:09,010
在这里，只是在 YouTube 上做，我有一台电 脑，

90
00:05:09,010 --> 00:05:11,040
所以我会作一点小作弊，显示他们的总和是多少。

91
00:05:11,040 --> 00:05:14,251
我还会作一点小作弊，重新排列所有这些，

92
00:05:14,251 --> 00:05:17,800
将 它们暗示性地组织成具有相同总和的集合。

93
00:05:18,500 --> 00:05:21,155
例如，有 3 个不同的子集，总计为 6，

94
00:05:21,155 --> 00:05:23,678
 它们都将位于这个小盒子中，而总计为 

95
00:05:23,678 --> 00:05:26,600
10 的 3 个子集将全部位于这个小盒子中。

96
00:05:27,260 --> 00:05:31,848
总而言之，我们关心的，总和 能被5整除的子集，

97
00:05:31,848 --> 00:05:35,240
都放在左 边了，看起来总共有8个。

98
00:05:36,340 --> 00:05:39,052
哦，顺便说一句，我们正在计算空集，

99
00:05:39,052 --> 00:05:43,520
我们认为它 的总和为 0，并且我们认为它是 5 的倍数。

100
00:05:43,940 --> 00:05:47,340
到最后，我希望您会同意所有这些都是非常自然的选择。

101
00:05:48,140 --> 00:05:51,260
花点时间将此答案与您启发式的预期进行比较。

102
00:05:51,800 --> 00:05:56,095
在全部 32 个子集中，其中的五分之一是 6。4 ，

103
00:05:56,095 --> 00:06:00,060
所以至少在这个小例子中，真正的答案比这个大一点。

104
00:06:00,360 --> 00:06:02,540
这也许是你想要藏在心里的事情。

105
00:06:03,719 --> 00:06:08,900
好吧，这就是视频的一部分，老 实说，我不知道如何激发它。

106
00:06:08,900 --> 00:06:12,919
就我个人而言，我喜欢数学感觉像是你可以自 己发现的东西，

107
00:06:12,919 --> 00:06:15,503
如果你和我一起坐下来解决这 个问题，

108
00:06:15,503 --> 00:06:17,800
我认为你可以采取各种自然的步骤。

109
00:06:18,240 --> 00:06:20,891
也许您尝试了解子集是否存在某种结构，

110
00:06:20,891 --> 00:06:24,427
或者 您尝试了解这些总和如何在其他小示例的许多 

111
00:06:24,427 --> 00:06:26,784
不同迭代中以 mod 5 分布，

112
00:06:26,784 --> 00:06:30,320
并从中尝 试通过以下方式勉强得出某种证明：就职。

113
00:06:31,040 --> 00:06:33,396
当我与一些顾客分享本课程的早期版本时 ，

114
00:06:33,396 --> 00:06:35,400
人们提出了一些很好的线性代数方法。

115
00:06:35,720 --> 00:06:37,580
所有这些都很好，没有什么问题。

116
00:06:37,580 --> 00:06:41,855
但相反，我的目标是教你一些叫做生成函数的东 西，

117
00:06:41,855 --> 00:06:45,596
这是一种策略，事后你可以想，好吧，是的 ，

118
00:06:45,596 --> 00:06:49,160
我知道这是有效的，但你到底会怎么想到那？

119
00:06:49,920 --> 00:06:51,140
老实说，我不知道。

120
00:06:51,420 --> 00:06:54,126
在你的生命中，有一段时间你还没有理解生成函数，

121
00:06:54,126 --> 00:06:56,361
另一段时间之后 ，除了信仰的飞跃之外，

122
00:06:56,361 --> 00:06:58,480
我想不出还有什么可以将它们联系起来。

123
00:06:59,380 --> 00:07:02,446
我要请你考虑多项式 1 加 x 乘以 1 

124
00:07:02,446 --> 00:07:05,367
加 x 平方乘以 1 加 x 立方乘以 

125
00:07:05,367 --> 00:07:08,580
1 加 x 到第四次 1 加 x 到第五次。

126
00:07:08,980 --> 00:07:11,540
现在，我知道你可以正确地问，这是从哪里来的？

127
00:07:11,580 --> 00:07:13,160
多项式与事物有什么关系？

128
00:07:13,520 --> 00:07:16,340
变量 x 现在应该代表什么？

129
00:07:17,160 --> 00:07:19,120
本质上，x 纯粹是一个符号。

130
00:07:19,440 --> 00:07:24,103
我们在这里编写多项式的唯一原因是代数展 

131
00:07:24,103 --> 00:07:28,300
开它的行为将完全反映构造子集的行为。

132
00:07:28,300 --> 00:07:31,304
而且，重要的是，我们想要的这种分组，

133
00:07:31,304 --> 00:07:35,978
即具有相同总和的 子集全部聚集在一起，当您执行此操作时，

134
00:07:35,978 --> 00:07:36,980
会自动发生。

135
00:07:37,400 --> 00:07:38,440
让我告诉你我的意思。

136
00:07:39,020 --> 00:07:43,520
当你展开这个表达式时，它基本上可以归结为做出五个二元选择。

137
00:07:43,800 --> 00:07:45,800
您从每个括号中选择哪个术语？

138
00:07:46,600 --> 00:07:51,040
如果您从每个括号中选择 1，则它将对 应于空集，

139
00:07:51,040 --> 00:07:53,260
其中我们不选择任何元素。

140
00:07:53,980 --> 00:07:56,701
然而，如果我选择第 1 项中的 x，

141
00:07:56,701 --> 00:08:00,481
然后从其他项中 选择 1，则这将对应于仅包含数字 

142
00:08:00,481 --> 00:08:01,540
1 的单例集。

143
00:08:02,200 --> 00:08:05,917
同样，如果我选择 x 平方项，但其他项 均为 1，

144
00:08:05,917 --> 00:08:08,000
则对应于仅包含 2 的集合。

145
00:08:08,520 --> 00:08:12,320
仅选择 x 立方项对应于仅包含数字 3 的集合。

146
00:08:13,100 --> 00:08:16,578
但是，有趣的是，请注意如果我选择 1 项中的 x、x 

147
00:08:16,578 --> 00:08:19,800
的平方项，然后从其他项中选择 1，会发生什么情况。

148
00:08:20,280 --> 00:08:25,380
这对应于选择具有 1 和 2 的子集，而不是其他所有子集。

149
00:08:25,380 --> 00:08:30,120
但在多项式中，它的展开方式看起来像 x 的三次方。

150
00:08:30,260 --> 00:08:33,240
所以我们有两个不同的 x 立方项，

151
00:08:33,240 --> 00:08:36,220
 每个项都来自总和为 3 的子集。

152
00:08:36,220 --> 00:08:40,213
老实说，如果您花时间停下来思考一下当您扩展此处的所有 

153
00:08:40,213 --> 00:08:44,059
内容时会发生什么，我在这里采用的模式可能是最简单的。

154
00:08:44,660 --> 00:08:49,020
本质上，每个可能的子集都对应于该展开式中的一项。

155
00:08:49,680 --> 00:08:53,523
然后关键的一点是，从该展开式中得到 

156
00:08:53,523 --> 00:08:56,940
的项中的指数等于相应子集的总和。

157
00:08:57,600 --> 00:08:59,717
当你大声说出来时有点令人困惑，但同样，

158
00:08:59,717 --> 00:09:02,280
如果 你自己思考一下，我想你就能明白我的意思。

159
00:09:02,620 --> 00:09:07,043
例如，当所有尘埃落定，我们在这里收集所有 32 个项时，

160
00:09:07,043 --> 00:09:09,728
其中三个项是 x 的第 10 次，

161
00:09:09,728 --> 00:09:13,520
并 且每一项都来自总和等于 10 的元素的选择。

162
00:09:14,540 --> 00:09:18,400
通常，当我们写多项式时，我们会将所有相似的项收集在一起。

163
00:09:18,680 --> 00:09:21,422
我们不会看到 x 到 10 的三个副本，

164
00:09:21,422 --> 00:09:24,440
而 是只看到 x 到 10 前面的系数 3。

165
00:09:24,440 --> 00:09:29,640
因此，每个系数都是用特定总和对子集数量进行编码的一种方式。

166
00:09:30,460 --> 00:09:34,606
所以，就像我在开始时所说的那样，这是一个称为生成函数的示例，

167
00:09:34,606 --> 00:09:36,956
 其中的想法是，如果您有一些问题，

168
00:09:36,956 --> 00:09:40,412
并且答案与每个正整数相关联 ，那么在我们的例子中，

169
00:09:40,412 --> 00:09:42,900
有多少个子集加起来为一个特别的价值。

170
00:09:43,480 --> 00:09:48,688
当您构造一个其系数与该问题的答案相对应的多 项式时，

171
00:09:48,688 --> 00:09:52,293
通过数学操作和分析该多项式的属性 ，

172
00:09:52,293 --> 00:09:56,100
您可以从原始问题中获得令人惊讶的见解。

173
00:09:56,660 --> 00:10:01,604
生成函数的例子有很多很多，但为了 提出另一个特别有趣的例子，

174
00:10:01,604 --> 00:10:04,900
你可以 使用相同的想法来研究斐波那契数。

175
00:10:05,340 --> 00:10:08,273
所以这个多项式的所有系数都是斐波那契数，

176
00:10:08,273 --> 00:10:10,766
在这种情况 下它是一个无限多项式，

177
00:10:10,766 --> 00:10:12,820
所以我真的应该称它为幂级数。

178
00:10:13,520 --> 00:10:15,752
我不会在这里完全解释细节，但我会将 

179
00:10:15,752 --> 00:10:17,860
它们留在屏幕上供任何好奇的人使用。

180
00:10:18,220 --> 00:10:21,147
基本思想是，用于定义斐波那契数 

181
00:10:21,147 --> 00:10:24,075
的规则（每个数都是前两个数的和 

182
00:10:24,075 --> 00:10:26,820
）可以用该函数表示为一个方程。

183
00:10:27,580 --> 00:10:31,200
该方程又可以让您以另一种形式编写该函数。

184
00:10:32,180 --> 00:10:35,890
然后，这是我跳过的大部分细节，如果你 操纵它，

185
00:10:35,890 --> 00:10:38,954
你知道，在这里投入一点部分分 数分解，

186
00:10:38,954 --> 00:10:42,664
那里投入一点几何级数幂展开 ，你就可以得到一个

187
00:10:42,664 --> 00:10:47,020
精确的封闭形式每个 斐波那契数列的表达式，这真的很酷。

188
00:10:47,579 --> 00:10:51,237
我提到这一点实际上只是为了展示冰山一角，

189
00:10:51,237 --> 00:10:55,260
即 生成函数的想法远远超出了我们的特定示例。

190
00:10:56,460 --> 00:11:00,829
现在，在我们的特定问题中，如果我们从只有 12345 的简 

191
00:11:00,829 --> 00:11:04,324
单示例扩展到所有数字最多为 2000 的大示例，

192
00:11:04,324 --> 00:11:08,402
我们相应的 生成函数涉及这 2000 个不同的二项式项，

193
00:11:08,402 --> 00:11:11,024
您知道，1 加 x，1 加 x平方，

194
00:11:11,024 --> 00:11:13,500
一直到 1 加 x 到 2000。

195
00:11:13,500 --> 00:11:16,719
这个想法是，如果你要扩展它，系数 

196
00:11:16,719 --> 00:11:19,560
会告诉我们我们想要的所有信息。

197
00:11:20,060 --> 00:11:23,326
现在，真正扩展它是疯狂的，但原则 

198
00:11:23,326 --> 00:11:26,400
上记住它会是什么样子是有帮助的。

199
00:11:26,800 --> 00:11:30,805
例如，原则上，如果你展开它，你会发现 

200
00:11:30,805 --> 00:11:34,600
x前面到第25项的系数恰好是142。

201
00:11:35,520 --> 00:11:41,640
这对应于有 142 个不同子集的总和为 25 的事实。

202
00:11:42,280 --> 00:11:48,852
因此，这里分析生成函数的技巧是推断有关 这些系数的事实，

203
00:11:48,852 --> 00:11:51,200
而不实际扩展表达式。

204
00:11:55,880 --> 00:11:58,901
因此，接下来，我将更抽象地编写这个展开式，

205
00:11:58,901 --> 00:12:02,066
只 是从 n 等于 0 到大写 N 的总和，

206
00:12:02,066 --> 00:12:05,520
其中 c sub n 告诉我们我们不知道的系数。

207
00:12:05,880 --> 00:12:08,060
所有这一切对我们来说都是一个黑匣子。

208
00:12:08,360 --> 00:12:12,057
展望未来，我们将开始将其视为一个实际函 数，代入 x，

209
00:12:12,057 --> 00:12:14,385
我们看到输出是什么，然后 我们问，

210
00:12:14,385 --> 00:12:16,440
这告诉我们有关系数的什么信息？

211
00:12:17,060 --> 00:12:20,620
例如，一个非常简单的输入是插入 x 等于 0 之类的值。

212
00:12:21,120 --> 00:12:23,110
在这种情况下，重要的是，我们知道

213
00:12:23,110 --> 00:12:25,100
如何使用上面的分解形式来评估它。

214
00:12:25,380 --> 00:12:27,442
如果将所有项代入 x 等于 0，

215
00:12:27,442 --> 00:12:30,020
则所有项看起来都像 1，因此答案为 1。

216
00:12:30,360 --> 00:12:33,616
在扩展形式中，所有涉及 x 的项都将被杀死，

217
00:12:33,616 --> 00:12:37,020
 它们变为 0，只剩下第一项，c sub 0。

218
00:12:37,800 --> 00:12:40,600
现在，在这种情况下，这并没有真正告诉我们任何令人兴奋的事情。

219
00:12:40,600 --> 00:12:45,600
它本质上意味着有一个空集，但我们才刚刚起步。

220
00:12:46,040 --> 00:12:49,640
作为下一个示例，请花点时间考虑一下将 f 评估为 1。

221
00:12:50,460 --> 00:12:53,151
这是我们可以用我们知道的表达式来做的事情，

222
00:12:53,151 --> 00:12:56,867
当你为所 有这些 x 代入 1 时，每个项看起来都像 2，

223
00:12:56,867 --> 00:13:00,200
所 以总共我们得到 2 乘以它本身 2,000 次。

224
00:13:00,720 --> 00:13:04,483
另一方面，在扩展表达式中，如果代入 x 等于 1，

225
00:13:04,483 --> 00:13:06,891
则 x 的所有这些幂都变为 1，

226
00:13:06,891 --> 00:13:09,300
因此我们实际上是将所有系数相加。

227
00:13:09,300 --> 00:13:11,460
当你想到这一点时，这真是太酷了。

228
00:13:11,740 --> 00:13:17,160
只需通过单个数字评估函数，我们 就可以推断出所有系数的总和。

229
00:13:17,680 --> 00:13:21,532
现在，在我们的特定示例中，这并不是那么令人兴 奋，

230
00:13:21,532 --> 00:13:24,460
因为我们已经知道这些系数的总和是多少。

231
00:13:24,960 --> 00:13:28,184
请记住，每个系数都会计算有多少个子集具有特定的 总和，

232
00:13:28,184 --> 00:13:30,931
因此当您将它们相加时，我们只是计算所有子 集，

233
00:13:30,931 --> 00:13:33,320
我们知道这些子集是 2 到 2,000。

234
00:13:34,220 --> 00:13:37,220
然而，如果我要求你将此函数评估为负 1，

235
00:13:37,220 --> 00:13:39,320
我可以给你一个真正的新事实。

236
00:13:39,720 --> 00:13:41,220
花点时间思考一下这意味着什么。

237
00:13:43,340 --> 00:13:46,528
如果你插入负数 1，我们再次从我们知道的东西开始，

238
00:13:46,528 --> 00:13:50,100
即 顶部的因式分解表达式，这里你所需要的就是查看第一项。

239
00:13:50,440 --> 00:13:53,183
当你代入 x 时，第一个括号变为 0，

240
00:13:53,183 --> 00:13:55,060
因此整个表达式必须为 0。

241
00:13:55,640 --> 00:13:59,109
但是，当我们使用所有系数将其应用 于扩展表达式时，

242
00:13:59,109 --> 00:14:00,220
这会告诉您什么？

243
00:14:00,720 --> 00:14:05,214
本着尽可能暗示这个解决方案所采取的奇怪 转折的精神，

244
00:14:05,214 --> 00:14:10,055
我希望您能够真正以旋转的形 式形象化这个表达式中负 1 

245
00:14:10,055 --> 00:14:10,920
的各种幂。

246
00:14:11,460 --> 00:14:13,943
第一项，负 1 到 0，就是 1，

247
00:14:13,943 --> 00:14:16,720
我们将其描绘为从 0 到 1 的向量。

248
00:14:16,720 --> 00:14:20,312
负 1 的 1 次方就是负 1 本身，

249
00:14:20,312 --> 00:14:25,040
我希望 您将其视为与上一项相距 180 度的旋转。

250
00:14:25,540 --> 00:14:27,983
然后，当我们取负 1 的平方时，

251
00:14:27,983 --> 00:14:30,580
即为正 1，同样旋转 180 度。

252
00:14:30,580 --> 00:14:35,820
一般来说，这里的每个连续项看起来都像是又旋转了 180 度。

253
00:14:36,180 --> 00:14:39,064
从代数上来说，这意味着我们在偶数 

254
00:14:39,064 --> 00:14:41,780
系数和奇数系数之间有一个振荡和。

255
00:14:42,180 --> 00:14:43,860
但请记住视觉效果。

256
00:14:44,260 --> 00:14:47,528
这个表达式对于任何生成函数都成立，但 同样，

257
00:14:47,528 --> 00:14:51,540
对于我们的特殊生成函数，我们知 道这个值，这个交替和，

258
00:14:51,540 --> 00:14:52,580
应该等于 0。

259
00:14:53,040 --> 00:14:56,132
您可以解释的一种方式是，它告诉您偶数 

260
00:14:56,132 --> 00:14:58,900
系数和奇数系数之间存在相等的平衡。

261
00:14:59,460 --> 00:15:02,597
请记住，也许在我们较小的示例中，

262
00:15:02,597 --> 00:15:06,520
这些 系数正在为我们编码有关子集的事实。

263
00:15:06,760 --> 00:15:11,371
因此，如果所有偶数系数和奇数系数之间存在相等的平衡，

264
00:15:11,371 --> 00:15:16,160
 则表明所有子集的一半具有偶数和，其中一半具有奇数和。

265
00:15:16,660 --> 00:15:20,640
这可能是您所期望的，但一开始并不清楚如何展示这一点。

266
00:15:20,820 --> 00:15:23,440
有了生成函数，它就会立即弹出。

267
00:15:24,480 --> 00:15:29,133
再次，为了暗示我们要去哪里，让我通过我们评估的最后两项 

268
00:15:29,133 --> 00:15:33,620
内容来稍微重写一下，将这两项相加，然后除以 1 一半。

269
00:15:35,100 --> 00:15:38,278
如果你仔细想想，这是一种过滤掉所有 

270
00:15:38,278 --> 00:15:41,280
偶数系数并消除所有奇数系数的方法。

271
00:15:41,900 --> 00:15:45,461
因此，它成为一种特别干净的方式来编写以下事实： 

272
00:15:45,461 --> 00:15:48,875
所有偶数系数的总和（在您的脑海中再次意味着具 

273
00:15:48,875 --> 00:15:52,140
有偶数总和的子集总数）将看起来像总数的一半。

274
00:15:52,620 --> 00:15:57,100
不用说，这非常接近我们想要回答的实际问题。

275
00:15:57,100 --> 00:16:01,365
我们想要做的是找到一些可以对函数 f 做的聪 明的事情，

276
00:16:01,365 --> 00:16:04,108
一些精心挑选的数字来评估它，这样我 

277
00:16:04,108 --> 00:16:07,460
们就可以得到与 5 的倍数相对应的所有系数。

278
00:16:08,000 --> 00:16:10,887
再次回想一下这些系数为我们编码的 内容，

279
00:16:10,887 --> 00:16:12,620
这将回答我们的最终问题。

280
00:16:12,760 --> 00:16:16,860
这将计算总和可被 5 整除的子集总数。

281
00:16:18,900 --> 00:16:22,839
这样做的技巧是概括我们刚刚所做的 事情，

282
00:16:22,839 --> 00:16:25,400
其中输入的连续幂来回旋转。

283
00:16:25,900 --> 00:16:28,801
但这一次，我们不希望它们每隔一段时间旋转一次 ，

284
00:16:28,801 --> 00:16:31,340
我们希望它们以某种方式以 5 为周期旋转。

285
00:16:31,740 --> 00:16:34,220
为此，我们扩展到复平面。

286
00:16:34,640 --> 00:16:37,431
你看，在那里，我们可以找到一个值，

287
00:16:37,431 --> 00:16:41,536
这样当我们连续取它的幂 时，它就会旋转五分之一圈，

288
00:16:41,536 --> 00:16:44,000
给我们一个频率为 5 的过程。

289
00:16:44,700 --> 00:16:49,500
如果你退后一步，我知道我 要求你思考复数有点荒谬。

290
00:16:49,860 --> 00:16:52,185
我的意思是，我们从一个计数问题开始，

291
00:16:52,185 --> 00:16:54,640
 它是离散数学，但希望它不是那么疯狂。

292
00:16:55,400 --> 00:16:59,599
再说一次，我之所以把事情画出来是为了解决解决方案中的各种奇怪

293
00:16:59,599 --> 00:17:03,800
 的转折，是因为它们实际上在更广泛的数学方案中并不那么奇怪。

294
00:17:04,140 --> 00:17:08,455
我们将要应用的技巧与使用复数来更好地理解 

295
00:17:08,455 --> 00:17:12,359
整数的离散问题的许多其他实例非常相似。

296
00:17:12,740 --> 00:17:18,561
因此，越感觉像是你自己可以发现的东西 ，

297
00:17:18,561 --> 00:17:26,420
就越有可能当你在这个思想圈子中解决 未来的某个问题时，

298
00:17:26,420 --> 00:17:29,040
你自己就会发现它。

299
00:17:29,040 --> 00:17:33,933
具体来说，我关心的复数是我要标记为 zet a 的复数，

300
00:17:33,933 --> 00:17:36,380
它位于单位圆的五分之一圈处。

301
00:17:36,780 --> 00:17:41,340
所以它的角度是 2 pi 五分之一弧度，大小是 1。

302
00:17:42,060 --> 00:17:45,862
这意味着使用标准欧拉公式符号，我们可以将该数字明 

303
00:17:45,862 --> 00:17:49,360
确写为 e 的 2 pi i 除以 5 次方。

304
00:17:49,640 --> 00:17:55,600
如果您对这种表示法不太熟悉，您可以将其 视为实部为 72 

305
00:17:55,600 --> 00:18:01,560
度的余弦，72 为五 分之一整圈，虚部为 72 度的正弦。

306
00:18:02,540 --> 00:18:05,940
但说实话，你实际上不需要考虑显式的值。

307
00:18:06,200 --> 00:18:10,580
相反，需要关注的重要事情是这个数字的幂所具有的属性。

308
00:18:11,100 --> 00:18:14,239
例如，当你平方它时，因为它的大小是一，

309
00:18:14,239 --> 00:18:19,031
所 以它的平方的大小也是一，但它绕单位圆旋转 五分之一圈，

310
00:18:19,031 --> 00:18:21,180
所以它现在位于五分之二圈。

311
00:18:22,280 --> 00:18:26,292
同样，当你将其提高到三次方时，你最终会得到五分之 三回合，

312
00:18:26,292 --> 00:18:29,614
将其提高到四次方时，你最终会得到五分之四 回合，

313
00:18:29,614 --> 00:18:32,520
并将其提高到五次方，你就得到了一路回到一。

314
00:18:32,860 --> 00:18:37,600
这与将其提高到零次方是一样的，我们每五 项就进行一次循环。

315
00:18:37,860 --> 00:18:39,200
这就是我们关心的事情。

316
00:18:39,760 --> 00:18:43,992
这些数字有一个特殊的名字，它们被称为 五次单位根，

317
00:18:43,992 --> 00:18:47,377
本质上是因为它们解方程z 到五次等于一，

318
00:18:47,377 --> 00:18:49,240
它们是数字一的五次根。

319
00:18:49,460 --> 00:18:52,791
如果你刚刚向某人提出这个方程，他们可能会 说，

320
00:18:52,791 --> 00:18:55,543
答案显然是 z 等于 1，但这个想法 

321
00:18:55,543 --> 00:18:58,875
是在复平面上还有四个其他答案，四个其他数 字，

322
00:18:58,875 --> 00:19:01,917
当你将它们提高到第五个时，你会得到一 个，

323
00:19:01,917 --> 00:19:04,380
并将它们视为一个集体通常非常有用。

324
00:19:04,880 --> 00:19:07,440
记住这个等式，稍后我们就会回来。

325
00:19:08,700 --> 00:19:13,275
因此，与我们之前所做的类似，我们将 1 的 f 和负 1 

326
00:19:13,275 --> 00:19:16,431
的 f 加在一起以获得奇数项中 的抵消，

327
00:19:16,431 --> 00:19:21,006
我们要做的就是对所有五个数字求 f， 然后相加他们在一起，

328
00:19:21,006 --> 00:19:22,900
希望我们能得到一些取消。

329
00:19:23,240 --> 00:19:26,859
这可能看起来有点复杂，但让我们举一个超级简单的 例子，

330
00:19:26,859 --> 00:19:29,540
比如 x 的 f 简单等于 x 的情况。

331
00:19:30,000 --> 00:19:32,026
在这种情况下，当我们将这五个项相加时，

332
00:19:32,026 --> 00:19:34,800
我们只是将 单位根本身相加，即 zeta 到零加上 

333
00:19:34,800 --> 00:19:37,680
zet a 到一，如此往复，直到 zeta 到第四个。

334
00:19:38,240 --> 00:19:42,480
当您添加复数时，您可以将其 视为向量加法，尖端在尾部。

335
00:19:42,899 --> 00:19:46,334
所以 zeta 到零加上 zeta 看起来像这 样，

336
00:19:46,334 --> 00:19:48,448
然后如果我加上 zeta 平方，

337
00:19:48,448 --> 00:19:52,280
将该向量的 尾部带到最后一个向量的尖端，我们就得到了这个。

338
00:19:52,980 --> 00:19:56,306
然后类似地，如果我将 zeta 的尾部的立方放 

339
00:19:56,306 --> 00:20:00,463
在该顶点的尖端，然后对 zeta 进行同样的操 作到第四个，

340
00:20:00,463 --> 00:20:02,820
您将看到总和实际上如何循环回到零。

341
00:20:03,360 --> 00:20:08,320
另一种思考方式是，所有这五 个项都围绕数字零均匀平衡。

342
00:20:08,880 --> 00:20:10,620
它们的质心位于原点。

343
00:20:11,700 --> 00:20:14,437
现在考虑一个稍微不那么简单的例子会很有帮 助，

344
00:20:14,437 --> 00:20:16,460
如果 x 的 f 是 x 的平方。

345
00:20:17,360 --> 00:20:18,904
因此，当您将 zeta 平方为零时，

346
00:20:18,904 --> 00:20:20,020
它会保持 zeta 为零。

347
00:20:20,260 --> 00:20:21,980
这只是说第一名的一种奇特方式。

348
00:20:22,640 --> 00:20:24,149
当您对 zeta 进行平方时，您会得到 

349
00:20:24,149 --> 00:20:24,980
zeta 本身的平方。

350
00:20:25,440 --> 00:20:27,645
所以你可能会想象，当我们这样做时，

351
00:20:27,645 --> 00:20:30,240
这里的这个点会移动到 zeta 平方点。

352
00:20:30,720 --> 00:20:32,680
Zeta 平方移动到 zeta 到第四位。

353
00:20:33,200 --> 00:20:35,760
您可能会想象这个点移动到 zeta 到第四个。

354
00:20:36,580 --> 00:20:39,124
Zeta 立方移动到 zeta 到第六，

355
00:20:39,124 --> 00:20:42,940
因为我们每 循环五次，所以它与 zeta 到 1 是一样的。

356
00:20:43,420 --> 00:20:44,879
所以这个点会向上移动。

357
00:20:46,420 --> 00:20:48,716
最后，zeta 到第四个正方形，

358
00:20:48,716 --> 00:20:51,155
得到 zeta 到第八个 正方形，

359
00:20:51,155 --> 00:20:54,600
它减少到与 zeta 立方相同，我可能会这样画。

360
00:20:55,560 --> 00:20:59,549
考虑起来可能有点令人困惑，尤其是我在 这里画的所有箭头，

361
00:20:59,549 --> 00:21:03,253
但在你的一生中至少 值得思考一次，因为这里的想法是，

362
00:21:03,253 --> 00:21:07,100
当我 们将其平方时，就像去所有这些不同的方 向一样项，

363
00:21:07,100 --> 00:21:09,950
我将它们编程为将它们所具有 的角度加倍，

364
00:21:09,950 --> 00:21:11,660
总体效果就是打乱这些项。

365
00:21:12,000 --> 00:21:14,672
我们得到相同的数字，但以不同的顺 序写入，

366
00:21:14,672 --> 00:21:16,200
因此它们的总和仍然为零。

367
00:21:16,959 --> 00:21:20,245
同样，如果你用 x 的立方来完成这个练习 

368
00:21:20,245 --> 00:21:23,373
（我鼓励你这样做），并且你跟踪这些点中 

369
00:21:23,373 --> 00:21:26,189
的每一个最终会在哪里，你将能够看到，

370
00:21:26,189 --> 00:21:29,944
当我 们对这些项进行立方时，当我们取出每一个 ，

371
00:21:29,944 --> 00:21:32,760
将其角度乘以三，然后再次将它们打乱。

372
00:21:33,140 --> 00:21:34,880
相同的术语以不同的顺序列出。

373
00:21:34,880 --> 00:21:37,156
不出所料，如果我们的函数是 x 的四次方，

374
00:21:37,156 --> 00:21:38,240
同样的事情也会发生。

375
00:21:41,780 --> 00:21:45,154
但是，关键的是，如果我们考虑函数 x 的第五次，

376
00:21:45,154 --> 00:21:46,420
事情就会发生变化。

377
00:21:47,060 --> 00:21:50,420
在这种情况下，当你将 zeta 提高到五次方时，

378
00:21:50,420 --> 00:21:51,820
根据定义它会变成一。

379
00:21:52,540 --> 00:21:55,200
同样，zeta 平方的五次方变为一。

380
00:21:55,560 --> 00:21:57,960
所有这些都归于一，它们是团结的根源。

381
00:21:57,980 --> 00:21:59,940
毕竟，这就是他们人生的全部目的。

382
00:22:00,440 --> 00:22:04,784
因此，在这种情况下，当我们应用该函数并将它们全部相加 时，

383
00:22:04,784 --> 00:22:08,380
我们得到的是一种相长干涉，而不是归零并得到抵消。

384
00:22:08,780 --> 00:22:11,440
它们都等于一，所以它们的总和等于五。

385
00:22:12,060 --> 00:22:15,845
因此，如果你退一步思考所有这些例子的含 义，

386
00:22:15,845 --> 00:22:19,802
本质上这个表达式对于 x 的幂来说 将趋于零，

387
00:22:19,802 --> 00:22:24,103
不能被五整除，但对于 x 的 幂来说它会趋于非零，

388
00:22:24,103 --> 00:22:25,480
这可以被五整除。

389
00:22:25,900 --> 00:22:28,380
这正是我们正在寻找的过滤器。

390
00:22:29,020 --> 00:22:33,010
如果您担心我们的实际函数比简单的 x 幂复杂得多，

391
00:22:33,010 --> 00:22:37,000
 那么本质上这里的情况非常好，因为一切都是线性的。

392
00:22:37,700 --> 00:22:43,235
如果 f 是某个大多项式，并且我们想要计 算这个大和，

393
00:22:43,235 --> 00:22:48,975
您可以考虑逐列进行计算，每 次您实际上只是将 zeta 

394
00:22:48,975 --> 00:22:50,000
的幂相加。

395
00:22:50,360 --> 00:22:54,000
在大多数情况下，所有这些力量都会相互抵消，结果为零。

396
00:22:54,380 --> 00:22:58,871
但是，当所有这些幂都是五的倍数时，它们会产生相 长干涉，

397
00:22:58,871 --> 00:23:01,920
无论相应的系数是多少，您都会得到五倍。

398
00:23:02,040 --> 00:23:05,100
在杂草深处，我们很容易忘记我们最初为何来到这里。

399
00:23:05,360 --> 00:23:07,900
但请记住，这些系数中的每一个都告诉我

400
00:23:07,900 --> 00:23:10,440
们有多少个子集加起来达到某一特定值。

401
00:23:10,920 --> 00:23:14,980
所以我们首先想要的是将所有系数相加。

402
00:23:15,380 --> 00:23:18,540
我们现在拥有的是一种明确做到这一点的方法。

403
00:23:18,800 --> 00:23:21,804
如果我们根据这五个不同的单位根来评估这个函 

404
00:23:21,804 --> 00:23:25,764
数（我知道这似乎有点奇怪），那么我们所要做 的就是除以五，

405
00:23:25,764 --> 00:23:27,540
它就给出了我们想要的总和。

406
00:23:28,480 --> 00:23:30,220
如果你问我的话，那真的很酷。

407
00:23:30,220 --> 00:23:34,883
我们有一个关于子集的问题，这是一个离散 数学问题，

408
00:23:34,883 --> 00:23:40,293
但我们回答它的方法是在一些明 智选择的复数上评估一个疯狂的

409
00:23:40,293 --> 00:23:41,040
多项式。

410
00:23:41,520 --> 00:23:42,080
你做的数学越多，你得到的就越多。

411
00:23:42,080 --> 00:23:44,546
你做的数学越多，看起来就越不疯狂，

412
00:23:44,546 --> 00:23:48,464
 因为复数与离散数学有这种奇怪的关 系，但这确实很棒，

413
00:23:48,464 --> 00:23:49,480
没有两种方法。

414
00:23:50,340 --> 00:23:52,774
然而，你们中的一些人可能会抱怨，

415
00:23:52,774 --> 00:23:56,578
唯一有用的方法是我 们是否可以在我们的多项式上实际

416
00:23:56,578 --> 00:23:58,100
评估这个通配表达式。

417
00:23:58,620 --> 00:24:01,964
现在记住，我们知道的多项式的形式，我们熟悉的形式，

418
00:24:01,964 --> 00:24:04,506
 是因式分解形式，其中有 1 加 x，

419
00:24:04,506 --> 00:24:08,520
1 加 x 的平方，等等，一直到 1 加 x 到2,000。

420
00:24:09,220 --> 00:24:12,746
到目前为止，一切都只是毫无意义的象征性游 戏，

421
00:24:12,746 --> 00:24:15,506
将一个难题推向另一个难题，除非我们 

422
00:24:15,506 --> 00:24:18,420
真的能卷起袖子在这里做一些诚实的计算。

423
00:24:18,900 --> 00:24:22,320
这是我们论证的最后一个要点，所以退后一步，深吸一口气。

424
00:24:22,700 --> 00:24:25,139
它实际上并不像你想象的那么糟糕，

425
00:24:25,139 --> 00:24:28,950
但让我们首先考虑如何 评估我们需要的统一根源之一，

426
00:24:28,950 --> 00:24:30,780
也许是 Zeta 本身。

427
00:24:31,780 --> 00:24:33,460
所以看起来就是 1 加 zeta，

428
00:24:33,460 --> 00:24:35,041
乘以 1 加 z eta 平方，

429
00:24:35,041 --> 00:24:36,820
乘以 1 加 zeta 立方，等等。

430
00:24:37,060 --> 00:24:40,530
但重要的是，在前五个任期之后，一切都开 始重复，

431
00:24:40,530 --> 00:24:42,700
因为 Zeta 的力量会重复。

432
00:24:43,220 --> 00:24:47,510
整个表达式最多 2,000 基本上只是该表达式 

433
00:24:47,510 --> 00:24:49,120
400 次的副本。

434
00:24:49,600 --> 00:24:52,512
评估这个表达式似乎仍然很困难，但它比乘 

435
00:24:52,512 --> 00:24:55,280
以 2,000 个不同的项要容易得多。

436
00:24:55,280 --> 00:24:59,152
您可以想象的一种方式是，我们采用每一个统一根 ，

437
00:24:59,152 --> 00:25:02,540
但基本上添加一个，我们将它们全部向右移动。

438
00:25:03,060 --> 00:25:05,795
这张图实际上为我们可能期望的数 

439
00:25:05,795 --> 00:25:08,360
字答案提供了非常好的几何直觉。

440
00:25:08,880 --> 00:25:14,260
我们想要的是这五个不同复 数的乘积，即这五个黄点。

441
00:25:14,820 --> 00:25:18,824
如果你对复数略知一二，因为它们是共轭对的，

442
00:25:18,824 --> 00:25:23,020
 我们真正需要的就是将这五条黄线的长度相乘。

443
00:25:23,679 --> 00:25:28,734
例如，最右边的那个点对应于 1 加 zeta 到 第五个，

444
00:25:28,734 --> 00:25:32,220
在图中我将其标记为 zeta 到零加一。

445
00:25:32,720 --> 00:25:36,440
但没关系，无论哪种情况，它们 都只是写数字二的奇特方式。

446
00:25:36,980 --> 00:25:40,105
接下来，我们有值一加 zeta 和一加 ze 

447
00:25:40,105 --> 00:25:42,960
ta 到第四个值，这两个值具有相同的大小。

448
00:25:43,000 --> 00:25:44,600
这些线的长度是相同的。

449
00:25:44,940 --> 00:25:46,680
我们给它起个名字，L1。

450
00:25:47,080 --> 00:25:50,280
所以我们需要将该长度 L1 的平方的两个不同副本相乘。

451
00:25:51,020 --> 00:25:54,660
同样，剩下的两个值，zeta 平方加一和 zeta 

452
00:25:54,660 --> 00:25:58,160
立方加一，它们也具有相同的长度，并且它们是共轭对。

453
00:25:58,580 --> 00:26:00,200
所以我们称这个长度为L2。

454
00:26:00,880 --> 00:26:03,800
因此我们的产品需要包含该 L2 的两个副本。

455
00:26:04,340 --> 00:26:07,335
如果我们只是进行松散的启发式猜测，

456
00:26:07,335 --> 00:26:11,036
您可能会注意到 L1 的长度比 1 稍长，

457
00:26:11,036 --> 00:26:13,680
而 L2 的长度比 1 稍短。

458
00:26:13,960 --> 00:26:17,700
所以这里的最终答案可能是大约两个左右。

459
00:26:17,960 --> 00:26:19,700
我们并不乐观，但大致上有些东西。

460
00:26:19,700 --> 00:26:24,140
为了将其变成精确的答案，我们可以扩展完整的表达式。

461
00:26:24,520 --> 00:26:27,420
老实说，这并没有那么糟糕，只有 32 个不同的术语。

462
00:26:33,320 --> 00:26:37,020
好吧，你已经和我在一起很长时间了，我知道它会变得很多。

463
00:26:37,280 --> 00:26:40,130
但整个论证中还有最后一个技巧，它使我 

464
00:26:40,130 --> 00:26:42,680
们的最后一步比您想象的要简单得多。

465
00:26:43,260 --> 00:26:45,620
让我们回顾一下，以提醒自己我们现在所处的位置。

466
00:26:45,820 --> 00:26:48,852
所以我们从这个问题开始，要求我们计算 1 到 

467
00:26:48,852 --> 00:26:52,280
2 ,000 的子集的数量，其总和可以被 5 整除。

468
00:26:52,740 --> 00:26:55,966
然后我们构造了这个多项式，其系数告诉我们 

469
00:26:55,966 --> 00:26:59,040
有多少子集对于每个值 n 具有特定的和。

470
00:26:59,960 --> 00:27:03,620
所以我们想要的是将该多项式的每五个系数相加。

471
00:27:04,780 --> 00:27:09,815
然后我们看到了如何将该多项式作为所有单位五次根的函 数求值，

472
00:27:09,815 --> 00:27:13,340
然后将它们相加，最终得到我们想要的滤波器。

473
00:27:13,600 --> 00:27:17,290
在这里，我们只评估其中一项，即 zeta 的 f，

474
00:27:17,290 --> 00:27:19,800
它本质上可以归结为五个复数的乘积。

475
00:27:20,540 --> 00:27:24,640
作为实际评估该产品的超级巧妙方法，这是最后一个技巧。

476
00:27:25,320 --> 00:27:27,820
请记住，我将这些数字描述为统一根。

477
00:27:28,200 --> 00:27:30,580
他们解方程 z 到第五次等于一。

478
00:27:31,060 --> 00:27:36,180
另一种思考方式是，它们是多项式 z 的第五次减一的根。

479
00:27:36,920 --> 00:27:42,062
现在这意味着我们可以将多项式 z 分解为第五 次减一，

480
00:27:42,062 --> 00:27:45,300
如下所示，其中每个根对应一个因子。

481
00:27:45,300 --> 00:27:47,160
你用 z 减去每一个根。

482
00:27:47,840 --> 00:27:51,815
当你想到当你把它全部展开时必须发生的 所有疯狂取消时，

483
00:27:51,815 --> 00:27:53,140
这个表达有点神奇。

484
00:27:53,160 --> 00:27:57,162
但这是真的，而且现在对我们来说非常 有用，

485
00:27:57,162 --> 00:28:02,880
因为右侧的表达式看起来与我 们需要在顶部评估的内容几乎相同。

486
00:28:03,300 --> 00:28:06,360
它基本上只有减号，而我们希望有加号。

487
00:28:07,680 --> 00:28:10,240
诀窍是插入 z 等于负一。

488
00:28:10,800 --> 00:28:13,620
如果你这样做，你基本上就得到了我们想要的负面结果。

489
00:28:13,620 --> 00:28:18,292
因此，如果将其乘以负一，请注意这里的左侧 

490
00:28:18,292 --> 00:28:22,520
（一开始是负一减一或负二）如何变成二。

491
00:28:23,240 --> 00:28:26,320
然后右边就变成了我们想要评估的东西。

492
00:28:27,000 --> 00:28:30,718
因此，正如我们之前的几何直觉所暗示的那样，

493
00:28:30,718 --> 00:28:35,500
答案不 仅是 2 左右，而且答案非常神奇地恰好是 2。

494
00:28:36,380 --> 00:28:40,078
这实际上非常好，非常可爱，因为这意味着我们想要 

495
00:28:40,078 --> 00:28:43,776
评估这个更大的表达式，我们将 f 在所有不同的 

496
00:28:43,776 --> 00:28:47,320
单位根上相加，我们知道它在第一个单位根上的值。

497
00:28:47,580 --> 00:28:49,220
它将是 2 的 400 次方。

498
00:28:49,820 --> 00:28:53,581
本质上相同的推理表明，它在接下来的三个单位根上的值也是 

499
00:28:53,581 --> 00:28:55,865
2 的 400 次方，因为请记住，

500
00:28:55,865 --> 00:28:59,090
当您取 zeta 平方或 zeta 立方的幂时，

501
00:28:59,090 --> 00:29:02,180
您会得到相同的数字列表，只是以不同的顺序洗牌。

502
00:29:02,880 --> 00:29:06,120
唯一不同的是当我们将其评估为 zeta 为零时。

503
00:29:06,840 --> 00:29:10,111
但 zeta 为零是表达第一的一种奇 特方式，

504
00:29:10,111 --> 00:29:11,960
我们知道如何以一来评估它。

505
00:29:12,220 --> 00:29:13,080
这是很容易的事情之一。

506
00:29:13,140 --> 00:29:13,900
我们之前就这样做过。

507
00:29:14,200 --> 00:29:17,121
所有这些括号都变成了 2，所以看起 

508
00:29:17,121 --> 00:29:19,880
来就像 2 乘以 2,000 倍。

509
00:29:20,520 --> 00:29:25,720
最后，我们对计数问题有了一个非常明确、诚实的答案。

510
00:29:26,160 --> 00:29:30,871
将所有可被五整除的系数相加，记住这是一种计算有多 

511
00:29:30,871 --> 00:29:33,886
少总子集的总和可被五整除的方法，

512
00:29:33,886 --> 00:29:37,655
答案是这个奇怪的 复杂表达式的五分之一，

513
00:29:37,655 --> 00:29:41,990
我们刚刚计算为二2,000 份加上 2 份到 

514
00:29:41,990 --> 00:29:44,440
400 份的四个不同副本。

515
00:29:45,520 --> 00:29:49,360
在这里，您可能只想快速检查一下这个答案是否有意义。

516
00:29:50,040 --> 00:29:53,733
例如，如果您在较小的情况下使用设置一、二 

517
00:29:53,733 --> 00:29:59,010
、三、四、五进行计算，并且您执行与我们刚 才相同的所有推理，

518
00:29:59,010 --> 00:30:03,055
它会告诉您答案是二的 五分之一第五，子集总数，

519
00:30:03,055 --> 00:30:07,980
在本例中加四乘二 到一，即 32 的五分之一加八，即八。

520
00:30:08,440 --> 00:30:11,264
如果您还记得当我们明确地查看所有这些内容时，

521
00:30:11,264 --> 00:30:12,420
这实际上就是答案。

522
00:30:17,500 --> 00:30:22,195
看，这是一个很难的难题，当值得投入时间来解 决一个难题时，

523
00:30:22,195 --> 00:30:24,300
也值得花一些时间进行反思。

524
00:30:24,420 --> 00:30:25,200
你从中得到什么？

525
00:30:29,640 --> 00:30:25,200
外卖是什么？

526
00:30:29,640 --> 00:30:32,756
现在你可以反思答案本身，主导部分如何确实是 

527
00:30:32,756 --> 00:30:36,297
所有子集总数的五分之一，就像我们可能猜测 的那样，

528
00:30:36,297 --> 00:30:38,847
以及这个误差项是如何从统一根的大规 

529
00:30:38,847 --> 00:30:41,680
模组合中不完全具有破坏性的干扰中产生的。

530
00:30:41,680 --> 00:30:47,737
但同样，让这个问题有趣的不是答案，而 是我们解决它的方式，

531
00:30:47,737 --> 00:30:53,795
即采用我们想要 理解的离散序列，并将其视为多项式的 系数，

532
00:30:53,795 --> 00:30:56,720
然后在复数值上评估该多项式。

533
00:30:56,720 --> 00:30:59,042
这两个步骤一开始可能是非常出乎意料的，

534
00:30:59,042 --> 00:31:02,099
但 这两个步骤都与一些非常通用和强大的技术相 关，

535
00:31:02,099 --> 00:31:04,300
您可以在数学的其他地方找到这些技术。

536
00:31:04,900 --> 00:31:08,703
例如，在课程的顶部，我承诺我们将使用的 

537
00:31:08,703 --> 00:31:12,126
技术在本质上将类似于研究素数的方式，

538
00:31:12,126 --> 00:31:16,120
以 及导致黎曼假设和类似事物的一系列想法。

539
00:31:16,500 --> 00:31:19,849
这是一个非常美丽的话题，足以让我觉得把某 

540
00:31:19,849 --> 00:31:23,040
种仓促的版本塞到这里的结尾似乎有点犯罪。

541
00:31:23,340 --> 00:31:26,655
我认为正确的做法是制作我不久前承诺过的关于 

542
00:31:26,655 --> 00:31:29,820
zeta 函数的视频，花点时间，把它做好。

543
00:31:30,440 --> 00:31:34,515
但如果你很好奇，并且允许我在屏幕上抛出一些东西而不解释 

544
00:31:34,515 --> 00:31:38,300
它们，这里有两到三句话的版本来说明两者是如何平行的。

545
00:31:39,020 --> 00:31:42,440
就像我们的子集难题一样，黎曼研究素 

546
00:31:42,440 --> 00:31:46,050
数的方式涉及我们想要理解的离散序列 ，

547
00:31:46,050 --> 00:31:49,280
其中包含有关素数的信息，然后考虑 

548
00:31:49,280 --> 00:31:52,320
一个其系数是该序列中的项的函数。

549
00:31:53,120 --> 00:31:55,549
在这种情况下，它不完全是一个多项式，

550
00:31:55,549 --> 00:31:58,114
而是一个称为狄利克雷级数的相 关结构，

551
00:31:58,114 --> 00:32:01,760
或狄利克雷级数取决于你问的是谁，但它是相同的基本思想。

552
00:32:02,160 --> 00:32:05,445
然后，找出有关这些系数的信息的 

553
00:32:05,445 --> 00:32:11,400
方法来自于研究该函数如何与（ 您猜对了）复值输入一起运行。

554
00:32:12,360 --> 00:32:18,128
毕竟黎曼是复分析的先驱，他的例子中的 技术变得更加复杂，

555
00:32:18,128 --> 00:32:22,867
但事实仍然是，像 这样将你的域扩展到实数之外，

556
00:32:22,867 --> 00:32:27,400
为你（数 学家）提供了更多的能力来推论系数。

557
00:32:28,700 --> 00:32:32,386
对于一些观众来说，这一切可能会留下一个挥之不去 

558
00:32:32,386 --> 00:32:35,920
的问题：为什么复数以这种方式如此不合理地有用。

559
00:32:36,660 --> 00:32:41,046
这是一个很难准确回答的问题，但如果你想想我们 的难题，

560
00:32:41,046 --> 00:32:44,620
我们刚刚所做的一切，一旦我们处于这种 情况，

561
00:32:44,620 --> 00:32:49,006
插入不同的输入就会显示有关系数的隐藏信 息，这有点像，

562
00:32:49,006 --> 00:32:51,605
你的输入越多可以工作得越好，所 

563
00:32:51,605 --> 00:32:55,180
以你不妨向更丰富的数字空间开放，比如复平面。

564
00:32:55,840 --> 00:32:59,560
但我希望你能有一个更具体的直觉。

565
00:33:00,060 --> 00:33:03,231
在我们的难题中，我们想要的相关事实，

566
00:33:03,231 --> 00:33:06,580
 即每五个系数的总和，是一种频率问题。

567
00:33:06,840 --> 00:33:11,667
与其他结构相比，复数被证明对我们有 用的真正原因是，

568
00:33:11,667 --> 00:33:16,680
我们可以找到一个值 ，以便连续的产品具有这种循环行为。

569
00:33:17,000 --> 00:33:22,192
使用单位圆上的值，特别是单位根来 找出频率信息，

570
00:33:22,192 --> 00:33:24,140
是非常富有成效的。

571
00:33:24,400 --> 00:33:28,300
这个想法的帮助之大几乎不可能被夸大。

572
00:33:28,580 --> 00:33:32,409
仅举数千个例子中的一个，在 20 世纪 90 年代，

573
00:33:32,409 --> 00:33:35,649
Peter S hor 找到了一种让量子计算

574
00:33:35,649 --> 00:33:38,300
机比传统计算机更快地分解大数的方法。

575
00:33:38,620 --> 00:33:43,370
如果你深入了解我们现在所说的 Shor 算法的工作原理，

576
00:33:43,370 --> 00:33:46,085
你会 发现其想法本质上是这样的，

577
00:33:46,085 --> 00:33:48,800
即使用单位根来检测一种频率信息。

578
00:33:49,320 --> 00:33:53,632
更一般地说，这是傅里叶变换和傅里叶级数的 核心思想，

579
00:33:53,632 --> 00:33:56,120
以及随之而来的无穷无尽的主题。

580
00:33:56,980 --> 00:34:00,720
至于生成函数本身的主题，我们实际上只是触及了表面，

581
00:34:00,720 --> 00:34:04,609
 如果您想了解更多信息，我强烈推荐 Herbert 

582
00:34:04,609 --> 00:34:08,199
Wilf 所著的这种名字搞笑的书《生成函数学》。

583
00:34:08,540 --> 00:34:10,393
我还会在屏幕上留下一些有趣的谜题，

584
00:34:10,393 --> 00:34:13,120
供那些想 要通过这个想法稍微展示一下肌肉的人使用。

