1
00:00:00,000 --> 00:00:02,332
Misalkan saya memberi Anda dua daftar angka yang berbeda,

2
00:00:02,332 --> 00:00:05,187
atau mungkin dua fungsi yang berbeda, dan saya meminta Anda memikirkan

3
00:00:05,187 --> 00:00:08,806
semua cara untuk menggabungkan kedua daftar tersebut untuk mendapatkan daftar angka baru,

4
00:00:08,806 --> 00:00:11,782
atau menggabungkan kedua fungsi tersebut untuk mendapatkan fungsi baru. .

5
00:00:11,782 --> 00:00:13,952
Mungkin salah satu cara sederhana yang terlintas dalam

6
00:00:13,952 --> 00:00:16,320
pikiran adalah dengan menjumlahkannya istilah demi istilah.

7
00:00:16,320 --> 00:00:20,131
Begitu pula dengan fungsinya, Anda dapat menambahkan semua output yang sesuai.

8
00:00:20,131 --> 00:00:23,167
Dengan cara yang sama, Anda juga dapat mengalikan dua daftar

9
00:00:23,167 --> 00:00:26,202
suku demi suku dan melakukan hal yang sama dengan fungsinya.

10
00:00:26,202 --> 00:00:30,514
Namun ada jenis kombinasi lain yang sama mendasarnya dengan keduanya,

11
00:00:30,514 --> 00:00:33,840
namun jarang dibahas, yang dikenal sebagai konvolusi.

12
00:00:33,840 --> 00:00:36,902
Namun tidak seperti dua kasus sebelumnya, ini bukanlah sesuatu yang

13
00:00:36,902 --> 00:00:39,964
hanya diwarisi dari operasi yang dapat Anda lakukan terhadap angka.

14
00:00:39,964 --> 00:00:42,386
Ini adalah sesuatu yang benar-benar baru untuk

15
00:00:42,386 --> 00:00:44,809
konteks daftar angka atau fungsi penggabungan.

16
00:00:44,809 --> 00:00:48,602
Mereka muncul di mana-mana, mereka ada di mana-mana dalam pemrosesan gambar,

17
00:00:48,602 --> 00:00:51,213
ini adalah konstruksi inti dalam teori probabilitas,

18
00:00:51,213 --> 00:00:54,513
mereka banyak digunakan dalam menyelesaikan persamaan diferensial,

19
00:00:54,513 --> 00:00:58,947
dan satu konteks di mana Anda hampir pasti pernah melihatnya, jika tidak dengan nama ini,

20
00:00:58,947 --> 00:01:00,277
mengalikan dua polinomial.

21
00:01:00,277 --> 00:01:03,233
Sebagai seseorang yang berkecimpung dalam bidang penjelasan visual,

22
00:01:03,233 --> 00:01:06,886
ini adalah topik yang sangat bagus, karena definisi yang dirumuskan secara terpisah

23
00:01:06,886 --> 00:01:09,190
dan tanpa konteks bisa terlihat agak mengintimidasi,

24
00:01:09,190 --> 00:01:12,886
namun jika kita meluangkan waktu untuk benar-benar membongkar apa yang dikatakannya,

25
00:01:12,886 --> 00:01:16,408
dan sebelum itu benar-benar memotivasi alasannya Anda pasti menginginkan sesuatu

26
00:01:16,408 --> 00:01:18,800
seperti ini, ini adalah operasi yang luar biasa indah.

27
00:01:18,800 --> 00:01:21,516
Dan harus saya akui, saya sebenarnya belajar sedikit

28
00:01:21,516 --> 00:01:23,514
saat menyusun visual untuk proyek ini.

29
00:01:23,514 --> 00:01:25,863
Dalam kasus menggabungkan dua fungsi yang berbeda,

30
00:01:25,863 --> 00:01:29,087
saya mencoba memikirkan cara berbeda untuk menggambarkan apa artinya,

31
00:01:29,087 --> 00:01:32,864
dan dengan salah satu dari mereka saya punya sedikit momen aha mengapa distribusi

32
00:01:32,864 --> 00:01:35,950
normal memainkan peran itu. kemungkinan besar mereka melakukannya,

33
00:01:35,950 --> 00:01:38,483
mengapa itu merupakan bentuk alami untuk suatu fungsi.

34
00:01:38,483 --> 00:01:41,645
Tapi saya terlalu terburu-buru, ada banyak pengaturan untuk itu.

35
00:01:41,645 --> 00:01:44,999
Dalam video ini, fokus utama kita hanyalah pada kasus terpisah,

36
00:01:44,999 --> 00:01:49,192
dan khususnya membangun algoritma yang sangat tidak terduga namun sangat cerdas

37
00:01:49,192 --> 00:01:50,293
untuk menghitungnya.

38
00:01:50,293 --> 00:01:54,400
Dan pembahasan kasus lanjutan ini akan saya tarik menjadi bagian kedua.

39
00:01:54,400 --> 00:01:58,106
Sangat menggoda untuk membuka diri dengan contoh pemrosesan gambar,

40
00:01:58,106 --> 00:02:02,739
karena secara visual paling menarik, namun ada beberapa kerumitan yang membuat kasus

41
00:02:02,739 --> 00:02:06,228
pemrosesan gambar kurang mewakili konvolusi secara keseluruhan,

42
00:02:06,228 --> 00:02:10,643
jadi mari kita mulai dengan probabilitas, dan khususnya salah satu contoh paling

43
00:02:10,643 --> 00:02:15,167
sederhana yang saya yakin semua orang di sini pernah memikirkannya pada suatu saat

44
00:02:15,167 --> 00:02:19,528
dalam hidup mereka, yaitu melempar sepasang dadu dan mencari tahu peluang untuk

45
00:02:19,528 --> 00:02:21,600
melihat berbagai jumlah yang berbeda.

46
00:02:21,600 --> 00:02:24,213
Dan Anda mungkin berkata, bukan masalah, bukan masalah.

47
00:02:24,213 --> 00:02:27,740
Masing-masing dari dua dadu Anda memiliki enam kemungkinan hasil yang berbeda,

48
00:02:27,740 --> 00:02:30,777
yang memberi kita total 36 kemungkinan pasangan hasil yang berbeda,

49
00:02:30,777 --> 00:02:34,439
dan jika kita melihat semuanya, kita dapat menghitung berapa banyak pasangan yang

50
00:02:34,439 --> 00:02:35,600
memiliki jumlah tertentu.

51
00:02:35,600 --> 00:02:38,367
Dan menyusun semua pasangan dalam kotak seperti ini,

52
00:02:38,367 --> 00:02:41,500
satu hal yang cukup menyenangkan adalah semua pasangan yang

53
00:02:41,500 --> 00:02:45,678
memiliki jumlah konstan terlihat di sepanjang salah satu diagonal yang berbeda.

54
00:02:45,678 --> 00:02:48,739
Jadi, menghitung berapa banyak yang ada pada masing-masing diagonal tersebut

55
00:02:48,739 --> 00:02:51,920
akan memberi tahu Anda seberapa besar kemungkinan Anda melihat jumlah tertentu.

56
00:02:51,920 --> 00:02:55,328
Dan menurut saya, sangat bagus, sangat bagus, tetapi bisakah Anda

57
00:02:55,328 --> 00:02:58,788
memikirkan cara lain untuk memvisualisasikan pertanyaan yang sama?

58
00:02:58,788 --> 00:03:01,079
Gambaran lain yang dapat terlintas dalam pikiran saat

59
00:03:01,079 --> 00:03:03,836
memikirkan semua pasangan berbeda yang memiliki jumlah tertentu?

60
00:03:03,836 --> 00:03:07,586
Dan mungkin salah satu dari Anda mengangkat tangan dan berkata, ya, saya punya.

61
00:03:07,586 --> 00:03:10,639
Katakanlah Anda membayangkan dua rangkaian kemungkinan berbeda ini

62
00:03:10,639 --> 00:03:14,056
masing-masing dalam satu baris, tetapi Anda membalik baris kedua tersebut.

63
00:03:14,056 --> 00:03:16,725
Dengan begitu semua pasangan berbeda yang berjumlah

64
00:03:16,725 --> 00:03:18,984
tujuh berbaris secara vertikal seperti ini.

65
00:03:18,984 --> 00:03:22,029
Dan jika kita geser baris terbawah itu ke kanan,

66
00:03:22,029 --> 00:03:26,380
maka hanya pasangan unik yang berjumlah dua, mata ular, yang sejajar.

67
00:03:26,380 --> 00:03:29,630
Dan jika saya urutkan satu unit ke kanan, pasangan yang

68
00:03:29,630 --> 00:03:32,938
sejajar adalah dua pasangan berbeda yang berjumlah tiga.

69
00:03:32,938 --> 00:03:36,037
Dan secara umum, nilai offset berbeda dari array bawah ini,

70
00:03:36,037 --> 00:03:40,583
ingat saya harus membaliknya terlebih dahulu, mengungkapkan semua pasangan berbeda yang

71
00:03:40,583 --> 00:03:41,926
memiliki jumlah tertentu.

72
00:03:41,926 --> 00:03:46,517
Sejauh menyangkut pertanyaan probabilitas, hal ini masih kurang menarik,

73
00:03:46,517 --> 00:03:51,359
karena yang kami lakukan hanyalah menghitung berapa banyak hasil yang ada di

74
00:03:51,359 --> 00:03:53,120
masing-masing kategori ini.

75
00:03:53,120 --> 00:03:55,579
Tapi itu dengan asumsi implisit bahwa ada peluang

76
00:03:55,579 --> 00:03:57,941
yang sama untuk masing-masing wajah ini muncul.

77
00:03:57,941 --> 00:04:01,909
Tapi bagaimana jika saya bilang saya punya satu set dadu khusus yang tidak seragam?

78
00:04:01,909 --> 00:04:05,915
Mungkin dadu biru mempunyai kumpulan angkanya sendiri yang menggambarkan probabilitas

79
00:04:05,915 --> 00:04:09,782
setiap wajah yang muncul, dan dadu merah mempunyai kumpulan angka uniknya sendiri.

80
00:04:09,782 --> 00:04:13,808
Dalam hal ini, jika Anda ingin mengetahui, katakanlah, peluang munculnya angka dua,

81
00:04:13,808 --> 00:04:17,163
Anda perlu mengalikan peluang munculnya dadu biru dengan probabilitas

82
00:04:17,163 --> 00:04:19,943
satu kali peluang munculnya dadu merah dengan angka satu.

83
00:04:19,943 --> 00:04:23,451
Dan untuk peluang melihat angka tiga, Anda melihat dua pasangan

84
00:04:23,451 --> 00:04:27,727
berbeda yang memungkinkan, dan sekali lagi, kalikan probabilitas yang sesuai,

85
00:04:27,727 --> 00:04:30,029
lalu jumlahkan kedua hasil kali tersebut.

86
00:04:30,029 --> 00:04:33,602
Demikian pula, peluang melihat angka empat melibatkan mengalikan

87
00:04:33,602 --> 00:04:36,845
tiga pasang kemungkinan berbeda dan menjumlahkan semuanya.

88
00:04:36,845 --> 00:04:41,449
Dan dalam semangat membuat beberapa rumus, beri nama probabilitas teratas ini a1, a2,

89
00:04:41,449 --> 00:04:45,946
a3, dan seterusnya, dan beri nama probabilitas terbawah b1, b2, b3, dan seterusnya.

90
00:04:45,946 --> 00:04:49,479
Dan secara umum, proses ini, dimana kita mengambil dua susunan angka yang berbeda,

91
00:04:49,479 --> 00:04:52,458
membalik susunan angka yang kedua, dan kemudian menyejajarkannya pada

92
00:04:52,458 --> 00:04:55,565
berbagai nilai offset yang berbeda, mengambil sekumpulan hasil perkalian

93
00:04:55,565 --> 00:04:58,928
berpasangan dan menjumlahkannya, itulah salah satu proses yang paling penting.

94
00:04:58,928 --> 00:05:01,311
cara mendasar untuk berpikir tentang apa itu konvolusi.

95
00:05:01,311 --> 00:05:05,191
Jadi untuk menjelaskannya lebih tepatnya, melalui proses ini,

96
00:05:05,191 --> 00:05:09,509
kita hanya menghasilkan probabilitas untuk melihat dua, tiga, empat,

97
00:05:09,509 --> 00:05:15,078
terus menerus hingga 12, dan kita mendapatkannya dengan menggabungkan satu daftar nilai,

98
00:05:15,078 --> 00:05:17,143
a, dan lainnya. daftar nilai, b.

99
00:05:17,143 --> 00:05:20,315
Dalam istilahnya, kita dapat mengatakan bahwa konvolusi kedua rangkaian

100
00:05:20,315 --> 00:05:24,060
tersebut memberi kita rangkaian baru ini, rangkaian baru yang terdiri dari 11 nilai,

101
00:05:24,060 --> 00:05:27,188
yang masing-masing terlihat seperti penjumlahan perkalian berpasangan.

102
00:05:27,188 --> 00:05:32,078
Jika mau, cara lain untuk melakukan operasi yang sama adalah dengan terlebih dahulu

103
00:05:32,078 --> 00:05:36,793
membuat tabel semua hasil kali berpasangan, lalu menjumlahkan semua diagonalnya.

104
00:05:36,793 --> 00:05:39,629
Sekali lagi, itu adalah cara menggabungkan dua rangkaian

105
00:05:39,629 --> 00:05:42,315
angka ini untuk menghasilkan rangkaian 11 angka baru.

106
00:05:42,315 --> 00:05:45,421
Ini adalah operasi yang sama seperti yang dipikirkan oleh jendela geser,

107
00:05:45,421 --> 00:05:46,400
hanya perspektif lain.

108
00:05:46,400 --> 00:05:50,335
Dengan memberikan sedikit notasi, beginilah cara Anda melihatnya tertulis.

109
00:05:50,335 --> 00:05:53,523
Konvolusi a dan b, dilambangkan dengan tanda bintang kecil ini,

110
00:05:53,523 --> 00:05:57,160
adalah sebuah daftar baru, dan elemen ke-n dari daftar tersebut terlihat

111
00:05:57,160 --> 00:06:00,748
seperti sebuah penjumlahan, dan jumlah tersebut mencakup semua pasangan

112
00:06:00,748 --> 00:06:04,833
indeks yang berbeda, i dan j, sehingga jumlah dari indeks tersebut sama dengan n.

113
00:06:04,833 --> 00:06:10,354
Agak rumit, tapi misalnya, jika n adalah 6, pasangan yang kita bahas adalah 1 dan 5,

114
00:06:10,354 --> 00:06:15,680
2 dan 4, 3 dan 3, 4 dan 2, 5 dan 1, semua pasangan berbeda yang dijumlahkan ke 6.

115
00:06:15,680 --> 00:06:18,120
Tapi sejujurnya, bagaimana pun Anda menuliskannya,

116
00:06:18,120 --> 00:06:21,710
notasi adalah hal kedua yang penting dibandingkan visual yang mungkin Anda

117
00:06:21,710 --> 00:06:23,145
ingat selama proses tersebut.

118
00:06:23,145 --> 00:06:26,679
Di sini, mungkin akan membantu jika saya memberikan contoh yang sangat sederhana,

119
00:06:26,679 --> 00:06:29,738
di mana saya mungkin bertanya kepada Anda apa konvolusi dari daftar 1,

120
00:06:29,738 --> 00:06:30,987
2, 3, dengan daftar 4, 5, 6.

121
00:06:30,987 --> 00:06:35,035
Anda mungkin membayangkan mengambil kedua daftar ini, membalik daftar kedua,

122
00:06:35,035 --> 00:06:37,926
dan kemudian memulai dengan penutupnya hingga ke kiri.

123
00:06:37,926 --> 00:06:40,438
Kemudian pasangan nilai yang sejajar adalah 1 dan 4,

124
00:06:40,438 --> 00:06:43,851
kalikan keduanya, dan itu menghasilkan suku pertama dari keluaran kita.

125
00:06:43,851 --> 00:06:48,080
Geser array bawah satu unit ke kanan, pasangan yang sejajar adalah 1 dan 5,

126
00:06:48,080 --> 00:06:50,917
dan 2 dan 4, kalikan pasangan tersebut, jumlahkan,

127
00:06:50,917 --> 00:06:54,367
dan hasilnya adalah 13, entri berikutnya dalam keluaran kita.

128
00:06:54,367 --> 00:06:57,858
Geser semuanya sekali lagi, dan kita akan ambil 1 kali 6,

129
00:06:57,858 --> 00:07:01,651
ditambah 2 kali 5, ditambah 3 kali 4, yang hasilnya adalah 28.

130
00:07:01,651 --> 00:07:05,307
Satu slide lagi, dan kita mendapatkan 2 kali 6, ditambah 3 kali 5,

131
00:07:05,307 --> 00:07:10,000
dan hasilnya adalah 27, dan akhirnya suku terakhirnya akan terlihat seperti 3 kali 6.

132
00:07:10,000 --> 00:07:13,095
Jika mau, Anda dapat menggunakan bahasa pemrograman apa pun favorit Anda,

133
00:07:13,095 --> 00:07:16,023
dan perpustakaan favorit Anda yang mencakup berbagai operasi numerik,

134
00:07:16,023 --> 00:07:18,910
dan Anda dapat mengonfirmasi bahwa saya tidak berbohong kepada Anda.

135
00:07:18,910 --> 00:07:21,760
Jika Anda mengambil konvolusi 1, 2, 3 melawan 4,

136
00:07:21,760 --> 00:07:24,320
5, 6, inilah hasil yang akan Anda dapatkan.

137
00:07:24,320 --> 00:07:28,222
Kita telah melihat satu kasus di mana ini adalah operasi alami dan diinginkan,

138
00:07:28,222 --> 00:07:32,422
menambahkan hingga distribusi probabilitas, dan contoh umum lainnya adalah rata-rata

139
00:07:32,422 --> 00:07:32,916
bergerak.

140
00:07:32,916 --> 00:07:35,193
Bayangkan Anda memiliki daftar angka yang panjang,

141
00:07:35,193 --> 00:07:38,811
dan Anda mengambil daftar angka lain yang lebih kecil yang semuanya berjumlah 1.

142
00:07:38,811 --> 00:07:41,983
Dalam hal ini, saya hanya memiliki daftar kecil berisi 5 nilai,

143
00:07:41,983 --> 00:07:43,420
dan semuanya sama dengan 15.

144
00:07:43,420 --> 00:07:46,677
Lalu jika kita melakukan proses konvolusi jendela geser ini,

145
00:07:46,677 --> 00:07:50,095
dan menutup mata dan mengabaikan apa yang terjadi pada awalnya,

146
00:07:50,095 --> 00:07:53,939
setelah daftar nilai kita yang lebih kecil tumpang tindih dengan daftar

147
00:07:53,939 --> 00:07:57,464
nilai yang lebih besar, pikirkan tentang setiap suku di dalamnya.

148
00:07:57,464 --> 00:07:59,066
konvolusi sebenarnya berarti.

149
00:07:59,066 --> 00:08:03,210
Pada setiap iterasi, yang Anda lakukan adalah mengalikan masing-masing

150
00:08:03,210 --> 00:08:06,653
nilai dari data Anda dengan 15, dan menjumlahkan semuanya,

151
00:08:06,653 --> 00:08:10,797
artinya Anda mengambil rata-rata data Anda di dalam jendela kecil ini.

152
00:08:10,797 --> 00:08:14,242
Secara keseluruhan, proses ini memberi Anda versi data asli yang diperhalus,

153
00:08:14,242 --> 00:08:17,777
dan Anda dapat memodifikasinya dimulai dengan daftar angka kecil yang berbeda,

154
00:08:17,777 --> 00:08:20,014
dan selama daftar kecil itu semuanya berjumlah 1,

155
00:08:20,014 --> 00:08:22,878
Anda masih dapat menafsirkannya sebagai perpindahan. rata-rata.

156
00:08:22,878 --> 00:08:25,480
Dalam contoh yang ditunjukkan di sini, rata-rata pergerakan

157
00:08:25,480 --> 00:08:27,822
tersebut akan memberi bobot lebih pada nilai sentral.

158
00:08:27,822 --> 00:08:30,720
Hal ini juga menghasilkan versi data yang lebih halus.

159
00:08:30,720 --> 00:08:33,908
Jika Anda membuat analog dua dimensi seperti ini,

160
00:08:33,908 --> 00:08:38,691
ini memberi Anda algoritme menyenangkan untuk mengaburkan gambar tertentu.

161
00:08:38,691 --> 00:08:42,575
Dan menurut saya animasi yang akan saya tampilkan dimodifikasi dari sesuatu yang

162
00:08:42,575 --> 00:08:46,698
awalnya saya buat untuk bagian dari serangkaian kuliah yang saya lakukan dengan Julia

163
00:08:46,698 --> 00:08:50,918
Lab di MIT untuk kelas OpenCourseWare tertentu yang menyertakan unit pemrosesan gambar.

164
00:08:50,918 --> 00:08:53,842
Di sana kami melakukan sedikit lebih banyak untuk menyelami kode di balik semua ini,

165
00:08:53,842 --> 00:08:56,456
jadi jika Anda penasaran saya akan meninggalkan beberapa tautan untuk Anda.

166
00:08:56,456 --> 00:09:00,548
Tapi fokus kembali pada contoh kabur ini, apa yang terjadi adalah saya punya kotak

167
00:09:00,548 --> 00:09:04,888
kecil 3x3 nilai yang berbaris di sepanjang gambar asli kita, dan jika kita memperbesar,

168
00:09:04,888 --> 00:09:09,178
masing-masing nilai tersebut adalah 1 9, dan apa yang saya lakukan pada setiap iterasi

169
00:09:09,178 --> 00:09:13,369
adalah mengalikan masing-masing nilai tersebut dengan piksel yang sesuai di atasnya.

170
00:09:13,369 --> 00:09:16,934
Dan tentu saja dalam ilmu komputer kita menganggap warna sebagai vektor

171
00:09:16,934 --> 00:09:20,400
kecil dari tiga nilai, yang mewakili komponen merah, hijau, dan biru.

172
00:09:20,400 --> 00:09:24,040
Saat saya mengalikan semua nilai kecil ini dengan 19 dan menjumlahkannya,

173
00:09:24,040 --> 00:09:26,549
hasilnya adalah rata-rata di setiap saluran warna,

174
00:09:26,549 --> 00:09:30,239
dan piksel yang sesuai untuk gambar di sebelah kanan didefinisikan sebagai

175
00:09:30,239 --> 00:09:31,075
jumlah tersebut.

176
00:09:31,075 --> 00:09:34,824
Efek keseluruhannya, saat kita melakukan ini untuk setiap piksel pada gambar,

177
00:09:34,824 --> 00:09:37,852
adalah setiap jenis piksel akan merembes ke semua tetangganya,

178
00:09:37,852 --> 00:09:40,880
sehingga menghasilkan versi yang lebih buram daripada aslinya.

179
00:09:40,880 --> 00:09:44,485
Dalam istilah tersebut, kami mengatakan bahwa gambar di sebelah kanan

180
00:09:44,485 --> 00:09:47,885
adalah konvolusi dari gambar asli kami dengan sedikit kisi nilai.

181
00:09:47,885 --> 00:09:51,226
Atau lebih teknisnya mungkin saya harus mengatakan bahwa ini adalah

182
00:09:51,226 --> 00:09:54,468
konvolusi dengan versi grid nilai kecil yang diputar 180 derajat.

183
00:09:54,468 --> 00:09:57,315
Hal ini tidak menjadi masalah jika kisi-kisinya simetris,

184
00:09:57,315 --> 00:10:00,899
namun perlu diingat bahwa definisi konvolusi, seperti yang diwarisi dari

185
00:10:00,899 --> 00:10:04,679
konteks matematika murni, harus selalu mengajak Anda berpikir untuk membalik

186
00:10:04,679 --> 00:10:05,760
array kedua tersebut.

187
00:10:05,760 --> 00:10:08,411
Jika kita memodifikasinya sedikit, kita bisa mendapatkan efek

188
00:10:08,411 --> 00:10:11,148
kabur yang lebih elegan dengan memilih grid nilai yang berbeda.

189
00:10:11,148 --> 00:10:13,491
Dalam hal ini saya memiliki grid kecil berukuran 5x5,

190
00:10:13,491 --> 00:10:15,920
namun perbedaannya tidak terlalu banyak pada ukurannya.

191
00:10:15,920 --> 00:10:19,192
Jika kita memperbesar, kita melihat bahwa nilai di tengah jauh

192
00:10:19,192 --> 00:10:22,517
lebih besar daripada nilai di tepinya, dan hal ini berasal dari

193
00:10:22,517 --> 00:10:26,102
sampel dari kurva lonceng, yang dikenal sebagai distribusi Gaussian.

194
00:10:26,102 --> 00:10:29,649
Dengan demikian, ketika kita mengalikan semua nilai ini dengan piksel

195
00:10:29,649 --> 00:10:33,247
yang sesuai di atasnya, kita memberikan lebih banyak bobot pada piksel

196
00:10:33,247 --> 00:10:36,439
pusat tersebut dan lebih sedikit bobot pada piksel di tepinya.

197
00:10:36,439 --> 00:10:40,475
Dan seperti sebelumnya, piksel terkait di sebelah kanan didefinisikan sebagai jumlah ini.

198
00:10:40,475 --> 00:10:43,157
Saat kami melakukan proses ini untuk setiap piksel,

199
00:10:43,157 --> 00:10:47,696
hal ini memberikan efek kabur yang secara lebih autentik menyimulasikan gagasan membuat

200
00:10:47,696 --> 00:10:49,760
lensa Anda tidak fokus atau semacamnya.

201
00:10:49,760 --> 00:10:53,504
Namun pengaburan bukanlah satu-satunya hal yang dapat Anda lakukan dengan ide ini.

202
00:10:53,504 --> 00:10:55,666
Sebagai contoh, lihatlah kotak nilai kecil ini,

203
00:10:55,666 --> 00:10:58,729
yang melibatkan beberapa angka positif di sebelah kiri dan beberapa

204
00:10:58,729 --> 00:11:01,793
angka negatif di sebelah kanan, yang akan saya warnai masing-masing

205
00:11:01,793 --> 00:11:03,099
dengan warna biru dan merah.

206
00:11:03,099 --> 00:11:06,200
Luangkan waktu sejenak untuk melihat apakah Anda dapat

207
00:11:06,200 --> 00:11:09,808
memprediksi dan memahami apa pengaruhnya terhadap gambar akhir.

208
00:11:09,808 --> 00:11:13,795
Jadi dalam hal ini saya hanya akan menganggap gambar sebagai skala abu-abu,

209
00:11:13,795 --> 00:11:18,149
bukan berwarna, sehingga setiap piksel hanya diwakili oleh satu angka, bukan tiga.

210
00:11:18,149 --> 00:11:21,269
Dan satu hal yang perlu diperhatikan adalah saat kita melakukan konvolusi ini,

211
00:11:21,269 --> 00:11:23,164
ada kemungkinan kita mendapatkan nilai negatif.

212
00:11:23,164 --> 00:11:26,114
Sebagai contoh pada titik ini di sini jika kita memperbesar bagian

213
00:11:26,114 --> 00:11:29,020
kiri dari grid kecil kita seluruhnya berada di atas piksel hitam,

214
00:11:29,020 --> 00:11:31,925
yang akan memiliki nilai nol, namun bagian kanan dari nilai-nilai

215
00:11:31,925 --> 00:11:35,360
negatif semuanya berada di atas piksel putih, yang akan mempunyai nilai satu.

216
00:11:35,360 --> 00:11:38,670
Jadi ketika kita mengalikan suku-suku yang bersesuaian dan menjumlahkannya,

217
00:11:38,670 --> 00:11:42,328
hasilnya akan sangat negatif, dan cara saya menampilkannya dengan gambar di sebelah

218
00:11:42,328 --> 00:11:46,117
kanan adalah dengan mewarnai nilai negatif dengan merah dan nilai positif dengan biru.

219
00:11:46,117 --> 00:11:50,932
Hal lain yang perlu diperhatikan adalah ketika Anda berada di patch yang warnanya sama,

220
00:11:50,932 --> 00:11:54,871
semuanya menjadi nol karena jumlah nilai di grid kecil kita adalah nol.

221
00:11:54,871 --> 00:11:58,871
Ini sangat berbeda dari dua contoh sebelumnya di mana jumlah grid kecil kita adalah satu,

222
00:11:58,871 --> 00:12:01,761
yang memungkinkan kita menafsirkannya sebagai rata-rata bergerak

223
00:12:01,761 --> 00:12:03,050
dan karenanya menjadi kabur.

224
00:12:03,050 --> 00:12:06,635
Secara keseluruhan, proses kecil ini pada dasarnya mendeteksi di mana pun ada

225
00:12:06,635 --> 00:12:09,669
variasi dalam nilai piksel saat Anda bergerak dari kiri ke kanan,

226
00:12:09,669 --> 00:12:13,760
sehingga memberi Anda semacam cara untuk mengambil semua tepi vertikal dari gambar Anda.

227
00:12:13,760 --> 00:12:19,227
Demikian pula jika kita memutar kotak tersebut sehingga bervariasi saat Anda

228
00:12:19,227 --> 00:12:24,268
bergerak dari atas ke bawah, ini akan menangkap semua tepi horizontal,

229
00:12:24,268 --> 00:12:30,020
yang dalam kasus gambar makhluk pai kecil kita menghasilkan beberapa mata setan.

230
00:12:30,020 --> 00:12:31,989
Grid yang lebih kecil ini sering disebut kernel,

231
00:12:31,989 --> 00:12:35,567
dan keindahannya di sini adalah bahwa hanya dengan memilih kernel yang berbeda Anda bisa

232
00:12:35,567 --> 00:12:37,536
mendapatkan efek pemrosesan gambar yang berbeda,

233
00:12:37,536 --> 00:12:40,792
tidak hanya mengaburkan deteksi tepi Anda tetapi juga hal-hal seperti penajaman.

234
00:12:40,792 --> 00:12:44,374
Bagi Anda yang pernah mendengar tentang jaringan saraf konvolusional,

235
00:12:44,374 --> 00:12:47,751
idenya adalah menggunakan data untuk mencari tahu kernel apa yang

236
00:12:47,751 --> 00:12:51,691
seharusnya ditentukan oleh apa pun yang ingin dideteksi oleh jaringan saraf.

237
00:12:51,691 --> 00:12:55,457
Hal lain yang mungkin harus saya kemukakan adalah panjang outputnya.

238
00:12:55,457 --> 00:12:59,397
Untuk contoh seperti rata-rata bergerak, Anda mungkin hanya ingin memikirkan

239
00:12:59,397 --> 00:13:02,211
ketentuan ketika kedua jendela sejajar satu sama lain,

240
00:13:02,211 --> 00:13:06,458
atau dalam contoh pemrosesan gambar mungkin Anda ingin hasil akhir memiliki ukuran

241
00:13:06,458 --> 00:13:07,789
yang sama dengan aslinya.

242
00:13:07,789 --> 00:13:10,885
Sekarang konvolusi sebagai operasi matematika murni selalu menghasilkan

243
00:13:10,885 --> 00:13:13,249
larik yang lebih besar dari dua larik yang Anda mulai,

244
00:13:13,249 --> 00:13:16,431
setidaknya dengan asumsi salah satunya tidak memiliki panjang satu larik.

245
00:13:16,431 --> 00:13:18,894
Ketahuilah bahwa dalam konteks ilmu komputer tertentu Anda

246
00:13:18,894 --> 00:13:21,440
sering kali ingin dengan sengaja memotong keluaran tersebut.

247
00:13:21,440 --> 00:13:25,438
Hal lain yang perlu disoroti adalah bahwa dalam konteks ilmu komputer,

248
00:13:25,438 --> 00:13:29,775
gagasan membalik kernel sebelum membiarkannya berjalan sesuai aslinya sering

249
00:13:29,775 --> 00:13:33,830
kali terasa sangat aneh dan tidak pantas, tetapi sekali lagi perhatikan

250
00:13:33,830 --> 00:13:37,941
bahwa itulah yang diwarisi dari konteks matematika murni di mana seperti

251
00:13:37,941 --> 00:13:42,560
kita melihat dengan kemungkinan itu adalah hal yang sangat wajar untuk dilakukan.

252
00:13:42,560 --> 00:13:45,853
Dan sebenarnya saya dapat menunjukkan kepada Anda satu lagi contoh matematika

253
00:13:45,853 --> 00:13:49,063
murni yang bahkan para pemrogram pun harus memperhatikan hal ini karena ini

254
00:13:49,063 --> 00:13:52,399
membuka pintu bagi algoritma yang jauh lebih cepat untuk menghitung semua ini.

255
00:13:52,399 --> 00:13:56,005
Untuk mengatur apa yang saya maksud dengan lebih cepat di sini biarkan saya kembali dan

256
00:13:56,005 --> 00:13:59,651
menarik beberapa python lagi dan saya akan membuat dua array berbeda yang relatif besar.

257
00:13:59,651 --> 00:14:03,683
Masing-masing akan memiliki seratus ribu elemen acak di dalamnya dan

258
00:14:03,683 --> 00:14:07,598
saya akan menilai runtime fungsi convolve dari perpustakaan numpy.

259
00:14:07,598 --> 00:14:11,250
Dan dalam hal ini ia menjalankannya untuk beberapa iterasi yang berbeda,

260
00:14:11,250 --> 00:14:15,453
mencoba menemukan rata-rata, dan sepertinya di komputer ini setidaknya rata-ratanya

261
00:14:15,453 --> 00:14:16,403
adalah 4.87 detik.

262
00:14:16,403 --> 00:14:21,238
Sebaliknya jika saya menggunakan fungsi yang berbeda dari perpustakaan scipy yang disebut

263
00:14:21,238 --> 00:14:25,805
fftconvolve yang merupakan hal yang sama hanya diimplementasikan secara berbeda yang

264
00:14:25,805 --> 00:14:30,640
hanya membutuhkan 4. Rata-rata 3 milidetik, sehingga terjadi peningkatan tiga kali lipat.

265
00:14:30,640 --> 00:14:33,075
Dan sekali lagi, meskipun ia menggunakan nama yang berbeda,

266
00:14:33,075 --> 00:14:35,754
ia memberikan keluaran yang sama dengan fungsi konvolusi lainnya,

267
00:14:35,754 --> 00:14:38,880
ia hanya melakukan sesuatu untuk melakukannya dengan cara yang lebih cerdas.

268
00:14:38,880 --> 00:14:43,318
Ingat bagaimana dengan contoh probabilitas saya mengatakan cara lain untuk

269
00:14:43,318 --> 00:14:47,876
memikirkan konvolusi adalah dengan membuat tabel semua perkalian berpasangan

270
00:14:47,876 --> 00:14:52,611
dan kemudian menjumlahkan perkalian berpasangan tersebut di sepanjang diagonal.

271
00:14:52,611 --> 00:14:55,882
Tentu saja tidak ada sesuatu yang spesifik mengenai probabilitas setiap kali Anda

272
00:14:55,882 --> 00:14:59,352
menggabungkan dua daftar angka yang berbeda, Anda dapat memikirkannya dengan cara ini.

273
00:14:59,352 --> 00:15:03,058
Buat tabel perkalian seperti ini dengan semua hasil kali berpasangan dan kemudian

274
00:15:03,058 --> 00:15:06,492
setiap jumlah sepanjang diagonal sesuai dengan salah satu hasil akhir Anda.

275
00:15:06,492 --> 00:15:09,382
Salah satu konteks di mana pandangan ini sangat

276
00:15:09,382 --> 00:15:12,513
alami adalah ketika Anda mengalikan dua polinomial.

277
00:15:12,513 --> 00:15:17,963
Misalnya izinkan saya mengambil kotak kecil yang sudah kita miliki dan mengganti suku

278
00:15:17,963 --> 00:15:22,906
teratas dengan 1, 2x, dan 3x kuadrat dan mengganti suku lainnya dengan 4, 5x,

279
00:15:22,906 --> 00:15:23,920
dan 6x kuadrat.

280
00:15:23,920 --> 00:15:26,340
Sekarang pikirkan apa artinya ketika kita membuat semua

281
00:15:26,340 --> 00:15:28,760
produk berpasangan yang berbeda di antara kedua daftar.

282
00:15:28,760 --> 00:15:33,495
Apa yang Anda lakukan pada dasarnya adalah memperluas produk lengkap dari dua polinomial

283
00:15:33,495 --> 00:15:37,752
yang telah saya tulis dan kemudian ketika Anda menjumlahkan sepanjang diagonal,

284
00:15:37,752 --> 00:15:42,381
itu sesuai dengan mengumpulkan semua suku serupa yang cukup rapi memperluas polinomial

285
00:15:42,381 --> 00:15:47,011
dan mengumpulkan suku-suku serupa adalah persisnya proses yang sama seperti konvolusi.

286
00:15:47,011 --> 00:15:49,753
Namun hal ini memungkinkan kami melakukan sesuatu yang

287
00:15:49,753 --> 00:15:52,696
cukup keren karena pikirkan apa yang kami katakan di sini.

288
00:15:52,696 --> 00:15:55,848
Maksudnya, jika Anda mengambil dua fungsi berbeda dan mengalikannya,

289
00:15:55,848 --> 00:15:59,913
yang merupakan operasi pointwise sederhana, hal ini sama saja seperti jika Anda terlebih

290
00:15:59,913 --> 00:16:03,751
dahulu mengekstrak koefisien dari masing-masing fungsi tersebut dengan asumsi bahwa

291
00:16:03,751 --> 00:16:07,816
fungsi tersebut adalah polinomial dan kemudian melakukan konvolusi dari fungsi tersebut.

292
00:16:07,816 --> 00:16:08,821
dua daftar koefisien.

293
00:16:08,821 --> 00:16:12,303
Apa yang membuatnya menarik adalah bahwa konvolusi pada prinsipnya terasa

294
00:16:12,303 --> 00:16:15,926
jauh lebih rumit daripada perkalian sederhana dan saya tidak hanya bermaksud

295
00:16:15,926 --> 00:16:19,314
secara konseptual, konvolusi lebih sulit untuk dipikirkan. Maksud saya,

296
00:16:19,314 --> 00:16:22,890
secara komputasi, diperlukan lebih banyak langkah untuk melakukan konvolusi

297
00:16:22,890 --> 00:16:26,089
daripada melakukan a produk pointwise dari dua daftar yang berbeda.

298
00:16:26,089 --> 00:16:29,794
Sebagai contoh, katakanlah saya memberi Anda dua polinomial yang sangat besar,

299
00:16:29,794 --> 00:16:33,077
katakanlah masing-masing polinomial dengan seratus koefisien berbeda,

300
00:16:33,077 --> 00:16:36,829
lalu jika cara Anda mengalikannya adalah dengan memperluas hasil perkalian ini,

301
00:16:36,829 --> 00:16:40,674
Anda tahu mengisi seluruh kotak perkalian berpasangan berukuran 100 kali 100 yang

302
00:16:40,674 --> 00:16:44,567
mengharuskan Anda melakukannya melakukan 10.000 produk berbeda dan kemudian ketika

303
00:16:44,567 --> 00:16:48,788
Anda mengumpulkan semua suku serupa di sepanjang diagonal, itu adalah kumpulan sekitar 10.

304
00:16:48,788 --> 00:16:49,773
000 operasi lainnya.

305
00:16:49,773 --> 00:16:53,239
Secara lebih umum dalam istilah kita akan mengatakan bahwa

306
00:16:53,239 --> 00:16:56,646
algoritme adalah O dari n kuadrat yang berarti dua daftar

307
00:16:56,646 --> 00:17:00,935
berukuran n dengan cara jumlah skala operasi sebanding dengan kuadrat n.

308
00:17:00,935 --> 00:17:05,154
Di sisi lain jika saya memikirkan dua polinomial dalam hal keluarannya,

309
00:17:05,154 --> 00:17:08,553
misalnya mengambil sampel nilainya pada beberapa masukan,

310
00:17:08,553 --> 00:17:13,592
lalu mengalikannya hanya memerlukan operasi sebanyak jumlah sampel karena sekali lagi

311
00:17:13,592 --> 00:17:18,456
ini adalah operasi yang tepat dan dengan polinomial Anda hanya perlu banyak sampel

312
00:17:18,456 --> 00:17:21,152
hingga dapat memperoleh kembali koefisiennya.

313
00:17:21,152 --> 00:17:25,214
Misalnya dua keluaran cukup untuk menentukan polinomial linier secara unik.

314
00:17:25,214 --> 00:17:29,360
Tiga keluaran akan cukup untuk menentukan polinomial kuadrat secara unik.

315
00:17:29,360 --> 00:17:32,408
Dan secara umum jika Anda mengetahui n keluaran berbeda,

316
00:17:32,408 --> 00:17:36,901
itu cukup untuk menentukan secara unik polinomial yang memiliki n koefisien berbeda.

317
00:17:36,901 --> 00:17:41,188
Atau jika Anda mau, kita dapat mengungkapkannya dalam bahasa sistem persamaan.

318
00:17:41,188 --> 00:17:43,886
Bayangkan saya memberi tahu Anda bahwa saya mempunyai polinomial tetapi saya

319
00:17:43,886 --> 00:17:46,480
tidak memberi tahu Anda berapa koefisiennya, itu adalah misteri bagi Anda.

320
00:17:46,480 --> 00:17:50,666
Dalam contoh kami, Anda mungkin menganggap ini sebagai produk yang kami coba cari tahu.

321
00:17:50,666 --> 00:17:53,870
Maka misalkan saya katakan saya akan memberitahu Anda apa keluaran dari

322
00:17:53,870 --> 00:17:57,295
polinomial ini jika Anda memasukkan berbagai masukan yang berbeda seperti 0,

323
00:17:57,295 --> 00:18:00,721
1, 2, 3, dan seterusnya, dan saya berikan secukupnya sehingga Anda mempunyai

324
00:18:00,721 --> 00:18:03,791
persamaan sebanyak-banyaknya. Anda memiliki hal yang tidak diketahui.

325
00:18:03,791 --> 00:18:07,245
Bahkan sistem persamaannya linier, jadi itu bagus.

326
00:18:07,245 --> 00:18:11,137
Dan setidaknya pada prinsipnya, ini sudah cukup untuk memulihkan koefisien.

327
00:18:11,137 --> 00:18:15,296
Jadi garis besar algoritme secara kasar adalah kapan pun Anda ingin menggabungkan

328
00:18:15,296 --> 00:18:19,253
dua daftar angka, Anda memperlakukannya seperti koefisien dari dua polinomial.

329
00:18:19,253 --> 00:18:23,106
Anda mengambil sampel polinomial tersebut dengan keluaran yang cukup,

330
00:18:23,106 --> 00:18:27,070
mengalikan sampel tersebut berdasarkan titik, lalu menyelesaikan sistem

331
00:18:27,070 --> 00:18:31,364
untuk memulihkan koefisien sebagai cara tersembunyi untuk menemukan konvolusi.

332
00:18:31,364 --> 00:18:34,060
Dan setidaknya seperti yang telah saya nyatakan sejauh ini,

333
00:18:34,060 --> 00:18:37,564
beberapa dari Anda berhak mengeluh, &quot;Grant, itu rencana yang bodoh&quot;.

334
00:18:37,564 --> 00:18:42,552
Karena menghitung semua sampel ini untuk salah satu polinomial yang kita tahu

335
00:18:42,552 --> 00:18:47,476
sudah memerlukan operasi n kuadrat, belum lagi menyelesaikan sistem tersebut

336
00:18:47,476 --> 00:18:52,656
tentu akan menjadi sulit secara komputasi seperti hanya melakukan konvolusi saja.

337
00:18:52,656 --> 00:18:56,192
Jadi, tentu saja kita memiliki hubungan antara perkalian dan konvolusi,

338
00:18:56,192 --> 00:19:00,268
tetapi semua kerumitan terjadi dalam penerjemahan dari satu sudut pandang ke sudut

339
00:19:00,268 --> 00:19:01,054
pandang lainnya.

340
00:19:01,054 --> 00:19:04,646
Namun ada triknya, dan bagi Anda yang mengetahui tentang transformasi

341
00:19:04,646 --> 00:19:07,673
Fourier dan algoritma FFT mungkin dapat mengetahui arahnya.

342
00:19:07,673 --> 00:19:09,815
Jika Anda belum familiar dengan topik-topik ini,

343
00:19:09,815 --> 00:19:12,176
apa yang akan saya sampaikan mungkin terasa tiba-tiba.

344
00:19:12,176 --> 00:19:14,765
Ketahuilah bahwa ada jalur tertentu yang bisa Anda lalui

345
00:19:14,765 --> 00:19:17,582
dalam matematika yang menjadikan langkah ini lebih diharapkan.

346
00:19:17,582 --> 00:19:20,697
Pada dasarnya idenya adalah kita memiliki kebebasan memilih di sini.

347
00:19:20,697 --> 00:19:24,672
Jika alih-alih mengevaluasi himpunan masukan sembarang seperti 0, 1, 2, 3,

348
00:19:24,672 --> 00:19:29,337
dan seterusnya, Anda memilih untuk mengevaluasi himpunan bilangan kompleks yang dipilih

349
00:19:29,337 --> 00:19:30,080
secara khusus.

350
00:19:30,080 --> 00:19:33,138
Khususnya yang terletak secara merata pada lingkaran satuan,

351
00:19:33,138 --> 00:19:34,894
yang disebut sebagai akar kesatuan.

352
00:19:34,894 --> 00:19:37,364
Ini memberi kita sistem yang lebih ramah.

353
00:19:37,364 --> 00:19:41,695
Ide dasarnya adalah dengan menemukan bilangan yang pangkatnya termasuk dalam

354
00:19:41,695 --> 00:19:45,970
pola perputaran ini, berarti sistem yang kita hasilkan akan memiliki banyak

355
00:19:45,970 --> 00:19:48,727
redundansi dalam berbagai suku yang Anda hitung,

356
00:19:48,727 --> 00:19:53,114
dan dengan cerdik dalam menentukan caranya. Anda memanfaatkan redundansi itu,

357
00:19:53,114 --> 00:19:55,252
Anda dapat menghemat banyak pekerjaan.

358
00:19:55,252 --> 00:19:58,956
Kumpulan keluaran yang saya tulis ini memiliki nama khusus,

359
00:19:58,956 --> 00:20:02,166
yang disebut transformasi koefisien Fourier diskrit.

360
00:20:02,166 --> 00:20:05,748
Dan jika Anda ingin mempelajari lebih lanjut, saya sebenarnya melakukan kuliah

361
00:20:05,748 --> 00:20:09,103
lain untuk kelas Julia MIT yang sama tentang transformasi Fourier diskrit.

362
00:20:09,103 --> 00:20:13,069
Dan ada juga video yang sangat bagus di saluran yang dapat direduksi berbicara tentang

363
00:20:13,069 --> 00:20:16,989
transformasi Fourier cepat, yang merupakan algoritma untuk menghitungnya dengan lebih

364
00:20:16,989 --> 00:20:17,263
cepat.

365
00:20:17,263 --> 00:20:20,535
Veritasium juga baru-baru ini membuat video yang sangat bagus di FFT,

366
00:20:20,535 --> 00:20:21,984
jadi Anda punya banyak pilihan.

367
00:20:21,984 --> 00:20:24,786
Dan algoritme cepat itulah yang menjadi tujuan kami.

368
00:20:24,786 --> 00:20:28,491
Sekali lagi karena semua redundansi ini, terdapat metode untuk beralih

369
00:20:28,491 --> 00:20:32,926
dari koefisien ke semua keluaran ini, di mana alih-alih melakukan operasi n kuadrat,

370
00:20:32,926 --> 00:20:36,475
Anda melakukan operasi n kali log n operasi, yang jauh lebih besar.

371
00:20:36,475 --> 00:20:39,293
jauh lebih baik saat Anda menskalakan ke daftar besar.

372
00:20:39,293 --> 00:20:42,386
Dan yang terpenting, algoritma fft ini berjalan dua arah.

373
00:20:42,386 --> 00:20:45,515
Ini juga memungkinkan Anda beralih dari keluaran ke koefisien.

374
00:20:45,515 --> 00:20:49,054
Jadi dengan menyatukan semuanya, mari kita lihat kembali garis besar algoritme kita.

375
00:20:49,054 --> 00:20:52,511
Sekarang kita dapat mengatakan kapan pun Anda diberikan dua daftar angka

376
00:20:52,511 --> 00:20:54,974
yang panjang dan Anda ingin mengambil konvolusinya,

377
00:20:54,974 --> 00:20:58,857
pertama-tama hitung transformasi Fourier cepat dari masing-masing angka tersebut,

378
00:20:58,857 --> 00:21:02,457
yang di benak Anda dapat Anda anggap memperlakukannya seperti mereka adalah

379
00:21:02,457 --> 00:21:06,103
koefisien polinomial dan mengevaluasinya pada serangkaian titik yang dipilih

380
00:21:06,103 --> 00:21:06,766
secara khusus.

381
00:21:06,766 --> 00:21:11,169
Kemudian gandakan kedua hasil yang baru saja Anda dapatkan, yang bagus dan cepat,

382
00:21:11,169 --> 00:21:13,853
lalu lakukan transformasi Fourier cepat terbalik,

383
00:21:13,853 --> 00:21:18,041
dan hasilnya adalah cara pintu belakang yang licik untuk menghitung konvolusi

384
00:21:18,041 --> 00:21:18,847
yang kita cari.

385
00:21:18,847 --> 00:21:22,957
Namun kali ini hanya melibatkan operasi O dari n log n.

386
00:21:22,957 --> 00:21:24,865
Itu sangat keren bagiku!

387
00:21:24,865 --> 00:21:29,638
Konteks yang sangat spesifik di mana konvolusi muncul, mengalikan dua polinomial,

388
00:21:29,638 --> 00:21:34,235
membuka pintu bagi algoritma yang relevan di mana pun konvolusi mungkin muncul.

389
00:21:34,235 --> 00:21:36,529
Jika Anda ingin menambahkan distribusi probabilitas,

390
00:21:36,529 --> 00:21:38,822
lakukan pemrosesan gambar besar-besaran, apa pun itu.

391
00:21:38,822 --> 00:21:41,657
Dan menurut saya itu adalah contoh bagus mengapa Anda harus

392
00:21:41,657 --> 00:21:44,586
bersemangat ketika melihat beberapa operasi atau konsep dalam

393
00:21:44,586 --> 00:21:47,798
matematika muncul di banyak bidang yang tampaknya tidak berhubungan.

394
00:21:47,798 --> 00:21:49,997
Jika Anda ingin sedikit pekerjaan rumah, inilah

395
00:21:49,997 --> 00:21:51,967
sesuatu yang menyenangkan untuk dipikirkan.

396
00:21:51,967 --> 00:21:54,651
Jelaskan mengapa ketika Anda mengalikan dua bilangan berbeda,

397
00:21:54,651 --> 00:21:58,201
yang merupakan perkalian biasa seperti yang kita semua pelajari di sekolah dasar,

398
00:21:58,201 --> 00:22:01,924
yang Anda lakukan pada dasarnya adalah konvolusi antara digit-digit bilangan tersebut.

399
00:22:01,924 --> 00:22:04,821
Ada beberapa langkah tambahan dengan carry dan sejenisnya,

400
00:22:04,821 --> 00:22:06,785
tetapi langkah intinya adalah konvolusi.

401
00:22:06,785 --> 00:22:10,532
Mengingat adanya algoritma yang cepat, artinya jika Anda memiliki dua

402
00:22:10,532 --> 00:22:14,547
bilangan bulat yang sangat besar, maka ada cara untuk mencari perkaliannya

403
00:22:14,547 --> 00:22:18,240
yang lebih cepat daripada metode yang kita pelajari di sekolah dasar.

404
00:22:18,240 --> 00:22:22,560
Bahwa alih-alih membutuhkan O dari n operasi kuadrat hanya membutuhkan O dari n log n,

405
00:22:22,560 --> 00:22:25,291
yang bahkan sepertinya hal itu tidak mungkin dilakukan.

406
00:22:25,291 --> 00:22:28,929
Masalahnya adalah sebelum ini benar-benar berguna dalam praktik,

407
00:22:28,929 --> 00:22:31,280
angka Anda harus benar-benar sangat besar.

408
00:22:31,280 --> 00:22:34,445
Tapi tetap saja, keren kalau ada algoritma seperti itu.

409
00:22:34,445 --> 00:22:37,154
Selanjutnya kita akan mengalihkan perhatian kita pada kasus

410
00:22:37,154 --> 00:22:40,000
berkelanjutan dengan fokus khusus pada distribusi probabilitas.

