1
00:00:00,000 --> 00:00:02,240
Misalkan saya memberi Anda dua daftar angka yang berbeda, 

2
00:00:02,240 --> 00:00:04,983
atau mungkin dua fungsi yang berbeda, dan saya meminta Anda memikirkan 

3
00:00:04,983 --> 00:00:08,461
semua cara untuk menggabungkan kedua daftar tersebut untuk mendapatkan daftar angka baru, 

4
00:00:08,461 --> 00:00:11,320
atau menggabungkan kedua fungsi tersebut untuk mendapatkan fungsi baru. . 

5
00:00:12,120 --> 00:00:14,339
Mungkin salah satu cara sederhana yang terlintas dalam 

6
00:00:14,339 --> 00:00:16,760
pikiran adalah dengan menjumlahkannya istilah demi istilah. 

7
00:00:17,160 --> 00:00:19,920
Begitu pula dengan fungsinya, Anda dapat menambahkan semua output yang sesuai. 

8
00:00:20,540 --> 00:00:23,110
Dengan cara yang sama, Anda juga dapat mengalikan dua daftar 

9
00:00:23,110 --> 00:00:25,680
suku demi suku dan melakukan hal yang sama dengan fungsinya. 

10
00:00:26,360 --> 00:00:30,390
Namun ada jenis kombinasi lain yang sama mendasarnya dengan keduanya, 

11
00:00:30,390 --> 00:00:33,500
namun jarang dibahas, yang dikenal sebagai konvolusi. 

12
00:00:34,080 --> 00:00:36,950
Namun tidak seperti dua kasus sebelumnya, ini bukanlah sesuatu yang 

13
00:00:36,950 --> 00:00:39,820
hanya diwarisi dari operasi yang dapat Anda lakukan terhadap angka. 

14
00:00:39,980 --> 00:00:42,340
Ini adalah sesuatu yang benar-benar baru untuk 

15
00:00:42,340 --> 00:00:44,700
konteks daftar angka atau fungsi penggabungan. 

16
00:00:45,320 --> 00:00:48,978
Mereka muncul di mana-mana, mereka ada di mana-mana dalam pemrosesan gambar, 

17
00:00:48,978 --> 00:00:51,497
ini adalah konstruksi inti dalam teori probabilitas, 

18
00:00:51,497 --> 00:00:54,680
mereka banyak digunakan dalam menyelesaikan persamaan diferensial, 

19
00:00:54,680 --> 00:00:58,957
dan satu konteks di mana Anda hampir pasti pernah melihatnya, jika tidak dengan nama ini, 

20
00:00:58,957 --> 00:01:00,240
mengalikan dua polinomial. 

21
00:01:00,740 --> 00:01:03,546
Sebagai seseorang yang berkecimpung dalam bidang penjelasan visual, 

22
00:01:03,546 --> 00:01:07,012
ini adalah topik yang sangat bagus, karena definisi yang dirumuskan secara terpisah 

23
00:01:07,012 --> 00:01:09,199
dan tanpa konteks bisa terlihat agak mengintimidasi, 

24
00:01:09,199 --> 00:01:12,707
namun jika kita meluangkan waktu untuk benar-benar membongkar apa yang dikatakannya, 

25
00:01:12,707 --> 00:01:16,050
dan sebelum itu benar-benar memotivasi alasannya Anda pasti menginginkan sesuatu 

26
00:01:16,050 --> 00:01:18,320
seperti ini, ini adalah operasi yang luar biasa indah. 

27
00:01:18,960 --> 00:01:21,598
Dan harus saya akui, saya sebenarnya belajar sedikit 

28
00:01:21,598 --> 00:01:23,540
saat menyusun visual untuk proyek ini. 

29
00:01:23,540 --> 00:01:25,890
Dalam kasus menggabungkan dua fungsi yang berbeda, 

30
00:01:25,890 --> 00:01:29,117
saya mencoba memikirkan cara berbeda untuk menggambarkan apa artinya, 

31
00:01:29,117 --> 00:01:32,896
dan dengan salah satu dari mereka saya punya sedikit momen aha mengapa distribusi 

32
00:01:32,896 --> 00:01:35,984
normal memainkan peran itu. kemungkinan besar mereka melakukannya, 

33
00:01:35,984 --> 00:01:38,520
mengapa itu merupakan bentuk alami untuk suatu fungsi. 

34
00:01:39,020 --> 00:01:41,520
Tapi saya terlalu terburu-buru, ada banyak pengaturan untuk itu. 

35
00:01:41,840 --> 00:01:45,105
Dalam video ini, fokus utama kita hanyalah pada kasus terpisah, 

36
00:01:45,105 --> 00:01:49,188
dan khususnya membangun algoritma yang sangat tidak terduga namun sangat cerdas 

37
00:01:49,188 --> 00:01:50,260
untuk menghitungnya. 

38
00:01:50,260 --> 00:01:54,480
Dan pembahasan kasus lanjutan ini akan saya tarik menjadi bagian kedua. 

39
00:01:58,580 --> 00:02:01,703
Sangat menggoda untuk membuka diri dengan contoh pemrosesan gambar, 

40
00:02:01,703 --> 00:02:05,607
karena secara visual paling menarik, namun ada beberapa kerumitan yang membuat kasus 

41
00:02:05,607 --> 00:02:08,547
pemrosesan gambar kurang mewakili konvolusi secara keseluruhan, 

42
00:02:08,547 --> 00:02:12,267
jadi mari kita mulai dengan probabilitas, dan khususnya salah satu contoh paling 

43
00:02:12,267 --> 00:02:16,080
sederhana yang saya yakin semua orang di sini pernah memikirkannya pada suatu saat 

44
00:02:16,080 --> 00:02:19,754
dalam hidup mereka, yaitu melempar sepasang dadu dan mencari tahu peluang untuk 

45
00:02:19,754 --> 00:02:21,500
melihat berbagai jumlah yang berbeda. 

46
00:02:22,460 --> 00:02:24,460
Dan Anda mungkin berkata, bukan masalah, bukan masalah. 

47
00:02:24,680 --> 00:02:28,143
Masing-masing dari dua dadu Anda memiliki enam kemungkinan hasil yang berbeda, 

48
00:02:28,143 --> 00:02:31,124
yang memberi kita total 36 kemungkinan pasangan hasil yang berbeda, 

49
00:02:31,124 --> 00:02:34,720
dan jika kita melihat semuanya, kita dapat menghitung berapa banyak pasangan yang 

50
00:02:34,720 --> 00:02:35,860
memiliki jumlah tertentu. 

51
00:02:36,600 --> 00:02:39,027
Dan menyusun semua pasangan dalam kotak seperti ini, 

52
00:02:39,027 --> 00:02:41,775
satu hal yang cukup menyenangkan adalah semua pasangan yang 

53
00:02:41,775 --> 00:02:45,440
memiliki jumlah konstan terlihat di sepanjang salah satu diagonal yang berbeda. 

54
00:02:45,440 --> 00:02:48,716
Jadi, menghitung berapa banyak yang ada pada masing-masing diagonal tersebut 

55
00:02:48,716 --> 00:02:52,120
akan memberi tahu Anda seberapa besar kemungkinan Anda melihat jumlah tertentu. 

56
00:02:53,220 --> 00:02:55,919
Dan menurut saya, sangat bagus, sangat bagus, tetapi bisakah Anda 

57
00:02:55,919 --> 00:02:58,660
memikirkan cara lain untuk memvisualisasikan pertanyaan yang sama? 

58
00:02:59,300 --> 00:03:01,460
Gambaran lain yang dapat terlintas dalam pikiran saat 

59
00:03:01,460 --> 00:03:04,060
memikirkan semua pasangan berbeda yang memiliki jumlah tertentu? 

60
00:03:04,860 --> 00:03:07,980
Dan mungkin salah satu dari Anda mengangkat tangan dan berkata, ya, saya punya. 

61
00:03:08,280 --> 00:03:10,865
Katakanlah Anda membayangkan dua rangkaian kemungkinan berbeda ini 

62
00:03:10,865 --> 00:03:13,760
masing-masing dalam satu baris, tetapi Anda membalik baris kedua tersebut. 

63
00:03:13,760 --> 00:03:16,468
Dengan begitu semua pasangan berbeda yang berjumlah 

64
00:03:16,468 --> 00:03:18,760
tujuh berbaris secara vertikal seperti ini. 

65
00:03:19,360 --> 00:03:22,209
Dan jika kita geser baris terbawah itu ke kanan, 

66
00:03:22,209 --> 00:03:26,280
maka hanya pasangan unik yang berjumlah dua, mata ular, yang sejajar. 

67
00:03:26,620 --> 00:03:29,325
Dan jika saya urutkan satu unit ke kanan, pasangan yang 

68
00:03:29,325 --> 00:03:32,080
sejajar adalah dua pasangan berbeda yang berjumlah tiga. 

69
00:03:32,880 --> 00:03:35,838
Dan secara umum, nilai offset berbeda dari array bawah ini, 

70
00:03:35,838 --> 00:03:40,177
ingat saya harus membaliknya terlebih dahulu, mengungkapkan semua pasangan berbeda yang 

71
00:03:40,177 --> 00:03:41,460
memiliki jumlah tertentu. 

72
00:03:44,820 --> 00:03:48,027
Sejauh menyangkut pertanyaan probabilitas, hal ini masih kurang menarik, 

73
00:03:48,027 --> 00:03:51,409
karena yang kami lakukan hanyalah menghitung berapa banyak hasil yang ada di 

74
00:03:51,409 --> 00:03:52,640
masing-masing kategori ini. 

75
00:03:52,980 --> 00:03:55,602
Tapi itu dengan asumsi implisit bahwa ada peluang 

76
00:03:55,602 --> 00:03:58,120
yang sama untuk masing-masing wajah ini muncul. 

77
00:03:58,360 --> 00:04:01,620
Tapi bagaimana jika saya bilang saya punya satu set dadu khusus yang tidak seragam? 

78
00:04:02,060 --> 00:04:05,978
Mungkin dadu biru mempunyai kumpulan angkanya sendiri yang menggambarkan probabilitas 

79
00:04:05,978 --> 00:04:09,760
setiap wajah yang muncul, dan dadu merah mempunyai kumpulan angka uniknya sendiri. 

80
00:04:10,299 --> 00:04:13,889
Dalam hal ini, jika Anda ingin mengetahui, katakanlah, peluang munculnya angka dua, 

81
00:04:13,889 --> 00:04:16,881
Anda perlu mengalikan peluang munculnya dadu biru dengan probabilitas 

82
00:04:16,881 --> 00:04:19,360
satu kali peluang munculnya dadu merah dengan angka satu. 

83
00:04:19,360 --> 00:04:22,949
Dan untuk peluang melihat angka tiga, Anda melihat dua pasangan 

84
00:04:22,949 --> 00:04:27,324
berbeda yang memungkinkan, dan sekali lagi, kalikan probabilitas yang sesuai, 

85
00:04:27,324 --> 00:04:29,680
lalu jumlahkan kedua hasil kali tersebut. 

86
00:04:30,100 --> 00:04:33,622
Demikian pula, peluang melihat angka empat melibatkan mengalikan 

87
00:04:33,622 --> 00:04:36,820
tiga pasang kemungkinan berbeda dan menjumlahkan semuanya. 

88
00:04:36,820 --> 00:04:41,443
Dan dalam semangat membuat beberapa rumus, beri nama probabilitas teratas ini a1, a2, 

89
00:04:41,443 --> 00:04:45,960
a3, dan seterusnya, dan beri nama probabilitas terbawah b1, b2, b3, dan seterusnya. 

90
00:04:46,400 --> 00:04:49,697
Dan secara umum, proses ini, dimana kita mengambil dua susunan angka yang berbeda, 

91
00:04:49,697 --> 00:04:52,477
membalik susunan angka yang kedua, dan kemudian menyejajarkannya pada 

92
00:04:52,477 --> 00:04:55,377
berbagai nilai offset yang berbeda, mengambil sekumpulan hasil perkalian 

93
00:04:55,377 --> 00:04:58,515
berpasangan dan menjumlahkannya, itulah salah satu proses yang paling penting. 

94
00:04:58,515 --> 00:05:00,740
cara mendasar untuk berpikir tentang apa itu konvolusi. 

95
00:05:00,740 --> 00:05:04,719
Jadi untuk menjelaskannya lebih tepatnya, melalui proses ini, 

96
00:05:04,719 --> 00:05:09,148
kita hanya menghasilkan probabilitas untuk melihat dua, tiga, empat, 

97
00:05:09,148 --> 00:05:14,861
terus menerus hingga 12, dan kita mendapatkannya dengan menggabungkan satu daftar nilai, 

98
00:05:14,861 --> 00:05:16,980
a, dan lainnya. daftar nilai, b. 

99
00:05:17,440 --> 00:05:20,566
Dalam istilahnya, kita dapat mengatakan bahwa konvolusi kedua rangkaian 

100
00:05:20,566 --> 00:05:24,257
tersebut memberi kita rangkaian baru ini, rangkaian baru yang terdiri dari 11 nilai, 

101
00:05:24,257 --> 00:05:27,340
yang masing-masing terlihat seperti penjumlahan perkalian berpasangan. 

102
00:05:27,340 --> 00:05:32,247
Jika mau, cara lain untuk melakukan operasi yang sama adalah dengan terlebih dahulu 

103
00:05:32,247 --> 00:05:36,980
membuat tabel semua hasil kali berpasangan, lalu menjumlahkan semua diagonalnya. 

104
00:05:37,460 --> 00:05:40,181
Sekali lagi, itu adalah cara menggabungkan dua rangkaian 

105
00:05:40,181 --> 00:05:42,760
angka ini untuk menghasilkan rangkaian 11 angka baru. 

106
00:05:43,240 --> 00:05:45,688
Ini adalah operasi yang sama seperti yang dipikirkan oleh jendela geser, 

107
00:05:45,688 --> 00:05:46,460
hanya perspektif lain. 

108
00:05:47,140 --> 00:05:49,800
Dengan memberikan sedikit notasi, beginilah cara Anda melihatnya tertulis. 

109
00:05:50,220 --> 00:05:53,439
Konvolusi a dan b, dilambangkan dengan tanda bintang kecil ini, 

110
00:05:53,439 --> 00:05:57,112
adalah sebuah daftar baru, dan elemen ke-n dari daftar tersebut terlihat 

111
00:05:57,112 --> 00:06:00,734
seperti sebuah penjumlahan, dan jumlah tersebut mencakup semua pasangan 

112
00:06:00,734 --> 00:06:04,860
indeks yang berbeda, i dan j, sehingga jumlah dari indeks tersebut sama dengan n. 

113
00:06:05,280 --> 00:06:10,634
Agak rumit, tapi misalnya, jika n adalah 6, pasangan yang kita bahas adalah 1 dan 5, 

114
00:06:10,634 --> 00:06:15,800
2 dan 4, 3 dan 3, 4 dan 2, 5 dan 1, semua pasangan berbeda yang dijumlahkan ke 6. 

115
00:06:16,620 --> 00:06:18,490
Tapi sejujurnya, bagaimana pun Anda menuliskannya, 

116
00:06:18,490 --> 00:06:21,239
notasi adalah hal kedua yang penting dibandingkan visual yang mungkin Anda 

117
00:06:21,239 --> 00:06:22,340
ingat selama proses tersebut. 

118
00:06:23,280 --> 00:06:26,659
Di sini, mungkin akan membantu jika saya memberikan contoh yang sangat sederhana, 

119
00:06:26,659 --> 00:06:29,584
di mana saya mungkin bertanya kepada Anda apa konvolusi dari daftar 1, 

120
00:06:29,584 --> 00:06:30,780
2, 3, dengan daftar 4, 5, 6. 

121
00:06:31,480 --> 00:06:35,096
Anda mungkin membayangkan mengambil kedua daftar ini, membalik daftar kedua, 

122
00:06:35,096 --> 00:06:37,680
dan kemudian memulai dengan penutupnya hingga ke kiri. 

123
00:06:38,180 --> 00:06:40,452
Kemudian pasangan nilai yang sejajar adalah 1 dan 4, 

124
00:06:40,452 --> 00:06:43,540
kalikan keduanya, dan itu menghasilkan suku pertama dari keluaran kita. 

125
00:06:43,960 --> 00:06:48,182
Geser array bawah satu unit ke kanan, pasangan yang sejajar adalah 1 dan 5, 

126
00:06:48,182 --> 00:06:51,015
dan 2 dan 4, kalikan pasangan tersebut, jumlahkan, 

127
00:06:51,015 --> 00:06:54,460
dan hasilnya adalah 13, entri berikutnya dalam keluaran kita. 

128
00:06:54,960 --> 00:06:58,123
Geser semuanya sekali lagi, dan kita akan ambil 1 kali 6, 

129
00:06:58,123 --> 00:07:01,560
ditambah 2 kali 5, ditambah 3 kali 4, yang hasilnya adalah 28. 

130
00:07:02,020 --> 00:07:05,567
Satu slide lagi, dan kita mendapatkan 2 kali 6, ditambah 3 kali 5, 

131
00:07:05,567 --> 00:07:10,120
dan hasilnya adalah 27, dan akhirnya suku terakhirnya akan terlihat seperti 3 kali 6. 

132
00:07:10,660 --> 00:07:13,550
Jika mau, Anda dapat menggunakan bahasa pemrograman apa pun favorit Anda, 

133
00:07:13,550 --> 00:07:16,284
dan perpustakaan favorit Anda yang mencakup berbagai operasi numerik, 

134
00:07:16,284 --> 00:07:18,980
dan Anda dapat mengonfirmasi bahwa saya tidak berbohong kepada Anda. 

135
00:07:18,980 --> 00:07:21,877
Jika Anda mengambil konvolusi 1, 2, 3 melawan 4, 

136
00:07:21,877 --> 00:07:24,480
5, 6, inilah hasil yang akan Anda dapatkan. 

137
00:07:25,920 --> 00:07:29,434
Kita telah melihat satu kasus di mana ini adalah operasi alami dan diinginkan, 

138
00:07:29,434 --> 00:07:33,215
menambahkan hingga distribusi probabilitas, dan contoh umum lainnya adalah rata-rata 

139
00:07:33,215 --> 00:07:33,660
bergerak. 

140
00:07:34,080 --> 00:07:36,274
Bayangkan Anda memiliki daftar angka yang panjang, 

141
00:07:36,274 --> 00:07:39,760
dan Anda mengambil daftar angka lain yang lebih kecil yang semuanya berjumlah 1. 

142
00:07:40,100 --> 00:07:42,825
Dalam hal ini, saya hanya memiliki daftar kecil berisi 5 nilai, 

143
00:07:42,825 --> 00:07:44,060
dan semuanya sama dengan 15. 

144
00:07:44,060 --> 00:07:47,107
Lalu jika kita melakukan proses konvolusi jendela geser ini, 

145
00:07:47,107 --> 00:07:50,305
dan menutup mata dan mengabaikan apa yang terjadi pada awalnya, 

146
00:07:50,305 --> 00:07:53,903
setelah daftar nilai kita yang lebih kecil tumpang tindih dengan daftar 

147
00:07:53,903 --> 00:07:57,201
nilai yang lebih besar, pikirkan tentang setiap suku di dalamnya. 

148
00:07:57,201 --> 00:07:58,700
konvolusi sebenarnya berarti. 

149
00:07:59,400 --> 00:08:03,327
Pada setiap iterasi, yang Anda lakukan adalah mengalikan masing-masing 

150
00:08:03,327 --> 00:08:06,592
nilai dari data Anda dengan 15, dan menjumlahkan semuanya, 

151
00:08:06,592 --> 00:08:10,520
artinya Anda mengambil rata-rata data Anda di dalam jendela kecil ini. 

152
00:08:11,100 --> 00:08:14,413
Secara keseluruhan, proses ini memberi Anda versi data asli yang diperhalus, 

153
00:08:14,413 --> 00:08:17,813
dan Anda dapat memodifikasinya dimulai dengan daftar angka kecil yang berbeda, 

154
00:08:17,813 --> 00:08:19,965
dan selama daftar kecil itu semuanya berjumlah 1, 

155
00:08:19,965 --> 00:08:22,720
Anda masih dapat menafsirkannya sebagai perpindahan. rata-rata. 

156
00:08:23,400 --> 00:08:25,694
Dalam contoh yang ditunjukkan di sini, rata-rata pergerakan 

157
00:08:25,694 --> 00:08:27,760
tersebut akan memberi bobot lebih pada nilai sentral. 

158
00:08:28,420 --> 00:08:30,800
Hal ini juga menghasilkan versi data yang lebih halus. 

159
00:08:33,140 --> 00:08:35,371
Jika Anda membuat analog dua dimensi seperti ini, 

160
00:08:35,371 --> 00:08:38,720
ini memberi Anda algoritme menyenangkan untuk mengaburkan gambar tertentu. 

161
00:08:38,720 --> 00:08:42,646
Dan menurut saya animasi yang akan saya tampilkan dimodifikasi dari sesuatu yang 

162
00:08:42,646 --> 00:08:46,814
awalnya saya buat untuk bagian dari serangkaian kuliah yang saya lakukan dengan Julia 

163
00:08:46,814 --> 00:08:51,080
Lab di MIT untuk kelas OpenCourseWare tertentu yang menyertakan unit pemrosesan gambar. 

164
00:08:51,560 --> 00:08:54,051
Di sana kami melakukan sedikit lebih banyak untuk menyelami kode di balik semua ini, 

165
00:08:54,051 --> 00:08:56,280
jadi jika Anda penasaran saya akan meninggalkan beberapa tautan untuk Anda. 

166
00:08:56,620 --> 00:09:00,733
Tapi fokus kembali pada contoh kabur ini, apa yang terjadi adalah saya punya kotak 

167
00:09:00,733 --> 00:09:05,095
kecil 3x3 nilai yang berbaris di sepanjang gambar asli kita, dan jika kita memperbesar, 

168
00:09:05,095 --> 00:09:09,407
masing-masing nilai tersebut adalah 1 9, dan apa yang saya lakukan pada setiap iterasi 

169
00:09:09,407 --> 00:09:13,620
adalah mengalikan masing-masing nilai tersebut dengan piksel yang sesuai di atasnya. 

170
00:09:13,900 --> 00:09:17,094
Dan tentu saja dalam ilmu komputer kita menganggap warna sebagai vektor 

171
00:09:17,094 --> 00:09:20,200
kecil dari tiga nilai, yang mewakili komponen merah, hijau, dan biru. 

172
00:09:20,560 --> 00:09:24,188
Saat saya mengalikan semua nilai kecil ini dengan 19 dan menjumlahkannya, 

173
00:09:24,188 --> 00:09:26,689
hasilnya adalah rata-rata di setiap saluran warna, 

174
00:09:26,689 --> 00:09:30,366
dan piksel yang sesuai untuk gambar di sebelah kanan didefinisikan sebagai 

175
00:09:30,366 --> 00:09:31,200
jumlah tersebut. 

176
00:09:31,940 --> 00:09:35,350
Efek keseluruhannya, saat kita melakukan ini untuk setiap piksel pada gambar, 

177
00:09:35,350 --> 00:09:38,105
adalah setiap jenis piksel akan merembes ke semua tetangganya, 

178
00:09:38,105 --> 00:09:40,860
sehingga menghasilkan versi yang lebih buram daripada aslinya. 

179
00:09:41,720 --> 00:09:44,818
Dalam istilah tersebut, kami mengatakan bahwa gambar di sebelah kanan 

180
00:09:44,818 --> 00:09:47,740
adalah konvolusi dari gambar asli kami dengan sedikit kisi nilai. 

181
00:09:48,140 --> 00:09:51,316
Atau lebih teknisnya mungkin saya harus mengatakan bahwa ini adalah 

182
00:09:51,316 --> 00:09:54,400
konvolusi dengan versi grid nilai kecil yang diputar 180 derajat. 

183
00:09:54,620 --> 00:09:57,298
Hal ini tidak menjadi masalah jika kisi-kisinya simetris, 

184
00:09:57,298 --> 00:10:00,668
namun perlu diingat bahwa definisi konvolusi, seperti yang diwarisi dari 

185
00:10:00,668 --> 00:10:04,224
konteks matematika murni, harus selalu mengajak Anda berpikir untuk membalik 

186
00:10:04,224 --> 00:10:05,240
array kedua tersebut. 

187
00:10:05,960 --> 00:10:08,489
Jika kita memodifikasinya sedikit, kita bisa mendapatkan efek 

188
00:10:08,489 --> 00:10:11,100
kabur yang lebih elegan dengan memilih grid nilai yang berbeda. 

189
00:10:11,440 --> 00:10:13,570
Dalam hal ini saya memiliki grid kecil berukuran 5x5, 

190
00:10:13,570 --> 00:10:15,780
namun perbedaannya tidak terlalu banyak pada ukurannya. 

191
00:10:15,980 --> 00:10:19,181
Jika kita memperbesar, kita melihat bahwa nilai di tengah jauh 

192
00:10:19,181 --> 00:10:22,433
lebih besar daripada nilai di tepinya, dan hal ini berasal dari 

193
00:10:22,433 --> 00:10:25,940
sampel dari kurva lonceng, yang dikenal sebagai distribusi Gaussian. 

194
00:10:26,800 --> 00:10:30,087
Dengan demikian, ketika kita mengalikan semua nilai ini dengan piksel 

195
00:10:30,087 --> 00:10:33,421
yang sesuai di atasnya, kita memberikan lebih banyak bobot pada piksel 

196
00:10:33,421 --> 00:10:36,380
pusat tersebut dan lebih sedikit bobot pada piksel di tepinya. 

197
00:10:36,800 --> 00:10:40,560
Dan seperti sebelumnya, piksel terkait di sebelah kanan didefinisikan sebagai jumlah ini. 

198
00:10:41,320 --> 00:10:43,746
Saat kami melakukan proses ini untuk setiap piksel, 

199
00:10:43,746 --> 00:10:47,853
hal ini memberikan efek kabur yang secara lebih autentik menyimulasikan gagasan membuat 

200
00:10:47,853 --> 00:10:49,720
lensa Anda tidak fokus atau semacamnya. 

201
00:10:49,900 --> 00:10:53,360
Namun pengaburan bukanlah satu-satunya hal yang dapat Anda lakukan dengan ide ini. 

202
00:10:53,800 --> 00:10:55,850
Sebagai contoh, lihatlah kotak nilai kecil ini, 

203
00:10:55,850 --> 00:10:58,755
yang melibatkan beberapa angka positif di sebelah kiri dan beberapa 

204
00:10:58,755 --> 00:11:01,661
angka negatif di sebelah kanan, yang akan saya warnai masing-masing 

205
00:11:01,661 --> 00:11:02,900
dengan warna biru dan merah. 

206
00:11:03,640 --> 00:11:05,876
Luangkan waktu sejenak untuk melihat apakah Anda dapat 

207
00:11:05,876 --> 00:11:08,480
memprediksi dan memahami apa pengaruhnya terhadap gambar akhir. 

208
00:11:10,720 --> 00:11:14,257
Jadi dalam hal ini saya hanya akan menganggap gambar sebagai skala abu-abu, 

209
00:11:14,257 --> 00:11:18,120
bukan berwarna, sehingga setiap piksel hanya diwakili oleh satu angka, bukan tiga. 

210
00:11:18,440 --> 00:11:21,313
Dan satu hal yang perlu diperhatikan adalah saat kita melakukan konvolusi ini, 

211
00:11:21,313 --> 00:11:23,060
ada kemungkinan kita mendapatkan nilai negatif. 

212
00:11:23,060 --> 00:11:26,059
Sebagai contoh pada titik ini di sini jika kita memperbesar bagian 

213
00:11:26,059 --> 00:11:29,013
kiri dari grid kecil kita seluruhnya berada di atas piksel hitam, 

214
00:11:29,013 --> 00:11:31,968
yang akan memiliki nilai nol, namun bagian kanan dari nilai-nilai 

215
00:11:31,968 --> 00:11:35,460
negatif semuanya berada di atas piksel putih, yang akan mempunyai nilai satu. 

216
00:11:36,180 --> 00:11:39,312
Jadi ketika kita mengalikan suku-suku yang bersesuaian dan menjumlahkannya, 

217
00:11:39,312 --> 00:11:42,774
hasilnya akan sangat negatif, dan cara saya menampilkannya dengan gambar di sebelah 

218
00:11:42,774 --> 00:11:46,360
kanan adalah dengan mewarnai nilai negatif dengan merah dan nilai positif dengan biru. 

219
00:11:46,880 --> 00:11:50,839
Hal lain yang perlu diperhatikan adalah ketika Anda berada di patch yang warnanya sama, 

220
00:11:50,839 --> 00:11:54,080
semuanya menjadi nol karena jumlah nilai di grid kecil kita adalah nol. 

221
00:11:55,180 --> 00:11:58,603
Ini sangat berbeda dari dua contoh sebelumnya di mana jumlah grid kecil kita adalah satu, 

222
00:11:58,603 --> 00:12:01,076
yang memungkinkan kita menafsirkannya sebagai rata-rata bergerak 

223
00:12:01,076 --> 00:12:02,180
dan karenanya menjadi kabur. 

224
00:12:03,640 --> 00:12:07,081
Secara keseluruhan, proses kecil ini pada dasarnya mendeteksi di mana pun ada 

225
00:12:07,081 --> 00:12:09,993
variasi dalam nilai piksel saat Anda bergerak dari kiri ke kanan, 

226
00:12:09,993 --> 00:12:13,920
sehingga memberi Anda semacam cara untuk mengambil semua tepi vertikal dari gambar Anda. 

227
00:12:16,500 --> 00:12:20,817
Demikian pula jika kita memutar kotak tersebut sehingga bervariasi saat Anda 

228
00:12:20,817 --> 00:12:24,798
bergerak dari atas ke bawah, ini akan menangkap semua tepi horizontal, 

229
00:12:24,798 --> 00:12:29,340
yang dalam kasus gambar makhluk pai kecil kita menghasilkan beberapa mata setan. 

230
00:12:30,400 --> 00:12:32,308
Grid yang lebih kecil ini sering disebut kernel, 

231
00:12:32,308 --> 00:12:35,775
dan keindahannya di sini adalah bahwa hanya dengan memilih kernel yang berbeda Anda bisa 

232
00:12:35,775 --> 00:12:37,684
mendapatkan efek pemrosesan gambar yang berbeda, 

233
00:12:37,684 --> 00:12:40,840
tidak hanya mengaburkan deteksi tepi Anda tetapi juga hal-hal seperti penajaman. 

234
00:12:40,840 --> 00:12:44,336
Bagi Anda yang pernah mendengar tentang jaringan saraf konvolusional, 

235
00:12:44,336 --> 00:12:47,633
idenya adalah menggunakan data untuk mencari tahu kernel apa yang 

236
00:12:47,633 --> 00:12:51,480
seharusnya ditentukan oleh apa pun yang ingin dideteksi oleh jaringan saraf. 

237
00:12:52,760 --> 00:12:55,520
Hal lain yang mungkin harus saya kemukakan adalah panjang outputnya. 

238
00:12:55,820 --> 00:12:59,481
Untuk contoh seperti rata-rata bergerak, Anda mungkin hanya ingin memikirkan 

239
00:12:59,481 --> 00:13:02,096
ketentuan ketika kedua jendela sejajar satu sama lain, 

240
00:13:02,096 --> 00:13:06,043
atau dalam contoh pemrosesan gambar mungkin Anda ingin hasil akhir memiliki ukuran 

241
00:13:06,043 --> 00:13:07,280
yang sama dengan aslinya. 

242
00:13:07,280 --> 00:13:10,468
Sekarang konvolusi sebagai operasi matematika murni selalu menghasilkan 

243
00:13:10,468 --> 00:13:12,903
larik yang lebih besar dari dua larik yang Anda mulai, 

244
00:13:12,903 --> 00:13:16,180
setidaknya dengan asumsi salah satunya tidak memiliki panjang satu larik. 

245
00:13:16,720 --> 00:13:19,079
Ketahuilah bahwa dalam konteks ilmu komputer tertentu Anda 

246
00:13:19,079 --> 00:13:21,520
sering kali ingin dengan sengaja memotong keluaran tersebut. 

247
00:13:24,720 --> 00:13:28,074
Hal lain yang perlu disoroti adalah bahwa dalam konteks ilmu komputer, 

248
00:13:28,074 --> 00:13:31,713
gagasan membalik kernel sebelum membiarkannya berjalan sesuai aslinya sering 

249
00:13:31,713 --> 00:13:35,115
kali terasa sangat aneh dan tidak pantas, tetapi sekali lagi perhatikan 

250
00:13:35,115 --> 00:13:38,565
bahwa itulah yang diwarisi dari konteks matematika murni di mana seperti 

251
00:13:38,565 --> 00:13:42,440
kita melihat dengan kemungkinan itu adalah hal yang sangat wajar untuk dilakukan. 

252
00:13:43,020 --> 00:13:46,032
Dan sebenarnya saya dapat menunjukkan kepada Anda satu lagi contoh matematika 

253
00:13:46,032 --> 00:13:48,968
murni yang bahkan para pemrogram pun harus memperhatikan hal ini karena ini 

254
00:13:48,968 --> 00:13:52,020
membuka pintu bagi algoritma yang jauh lebih cepat untuk menghitung semua ini. 

255
00:13:52,620 --> 00:13:56,179
Untuk mengatur apa yang saya maksud dengan lebih cepat di sini biarkan saya kembali dan 

256
00:13:56,179 --> 00:13:59,780
menarik beberapa python lagi dan saya akan membuat dua array berbeda yang relatif besar. 

257
00:13:59,940 --> 00:14:03,795
Masing-masing akan memiliki seratus ribu elemen acak di dalamnya dan 

258
00:14:03,795 --> 00:14:07,540
saya akan menilai runtime fungsi convolve dari perpustakaan numpy. 

259
00:14:08,180 --> 00:14:11,639
Dan dalam hal ini ia menjalankannya untuk beberapa iterasi yang berbeda, 

260
00:14:11,639 --> 00:14:15,619
mencoba menemukan rata-rata, dan sepertinya di komputer ini setidaknya rata-ratanya 

261
00:14:15,619 --> 00:14:16,520
adalah 4.87 detik. 

262
00:14:16,960 --> 00:14:21,443
Sebaliknya jika saya menggunakan fungsi yang berbeda dari perpustakaan scipy yang disebut 

263
00:14:21,443 --> 00:14:25,676
fftconvolve yang merupakan hal yang sama hanya diimplementasikan secara berbeda yang 

264
00:14:25,676 --> 00:14:30,160
hanya membutuhkan 4. Rata-rata 3 milidetik, sehingga terjadi peningkatan tiga kali lipat. 

265
00:14:30,160 --> 00:14:32,808
Dan sekali lagi, meskipun ia menggunakan nama yang berbeda, 

266
00:14:32,808 --> 00:14:35,721
ia memberikan keluaran yang sama dengan fungsi konvolusi lainnya, 

267
00:14:35,721 --> 00:14:39,120
ia hanya melakukan sesuatu untuk melakukannya dengan cara yang lebih cerdas. 

268
00:14:42,200 --> 00:14:45,587
Ingat bagaimana dengan contoh probabilitas saya mengatakan cara lain untuk 

269
00:14:45,587 --> 00:14:49,066
memikirkan konvolusi adalah dengan membuat tabel semua perkalian berpasangan 

270
00:14:49,066 --> 00:14:52,680
dan kemudian menjumlahkan perkalian berpasangan tersebut di sepanjang diagonal. 

271
00:14:53,660 --> 00:14:56,270
Tentu saja tidak ada sesuatu yang spesifik mengenai probabilitas setiap kali Anda 

272
00:14:56,270 --> 00:14:59,040
menggabungkan dua daftar angka yang berbeda, Anda dapat memikirkannya dengan cara ini. 

273
00:14:59,040 --> 00:15:02,890
Buat tabel perkalian seperti ini dengan semua hasil kali berpasangan dan kemudian 

274
00:15:02,890 --> 00:15:06,460
setiap jumlah sepanjang diagonal sesuai dengan salah satu hasil akhir Anda. 

275
00:15:07,600 --> 00:15:10,096
Salah satu konteks di mana pandangan ini sangat 

276
00:15:10,096 --> 00:15:12,800
alami adalah ketika Anda mengalikan dua polinomial. 

277
00:15:13,300 --> 00:15:18,221
Misalnya izinkan saya mengambil kotak kecil yang sudah kita miliki dan mengganti suku 

278
00:15:18,221 --> 00:15:22,684
teratas dengan 1, 2x, dan 3x kuadrat dan mengganti suku lainnya dengan 4, 5x, 

279
00:15:22,684 --> 00:15:23,600
dan 6x kuadrat. 

280
00:15:24,000 --> 00:15:26,420
Sekarang pikirkan apa artinya ketika kita membuat semua 

281
00:15:26,420 --> 00:15:28,840
produk berpasangan yang berbeda di antara kedua daftar. 

282
00:15:29,040 --> 00:15:33,554
Apa yang Anda lakukan pada dasarnya adalah memperluas produk lengkap dari dua polinomial 

283
00:15:33,554 --> 00:15:37,613
yang telah saya tulis dan kemudian ketika Anda menjumlahkan sepanjang diagonal, 

284
00:15:37,613 --> 00:15:42,026
itu sesuai dengan mengumpulkan semua suku serupa yang cukup rapi memperluas polinomial 

285
00:15:42,026 --> 00:15:46,440
dan mengumpulkan suku-suku serupa adalah persisnya proses yang sama seperti konvolusi. 

286
00:15:47,740 --> 00:15:49,959
Namun hal ini memungkinkan kami melakukan sesuatu yang 

287
00:15:49,959 --> 00:15:52,340
cukup keren karena pikirkan apa yang kami katakan di sini. 

288
00:15:52,340 --> 00:15:55,565
Maksudnya, jika Anda mengambil dua fungsi berbeda dan mengalikannya, 

289
00:15:55,565 --> 00:15:59,725
yang merupakan operasi pointwise sederhana, hal ini sama saja seperti jika Anda terlebih 

290
00:15:59,725 --> 00:16:03,651
dahulu mengekstrak koefisien dari masing-masing fungsi tersebut dengan asumsi bahwa 

291
00:16:03,651 --> 00:16:07,811
fungsi tersebut adalah polinomial dan kemudian melakukan konvolusi dari fungsi tersebut. 

292
00:16:07,811 --> 00:16:08,840
dua daftar koefisien. 

293
00:16:09,620 --> 00:16:12,874
Apa yang membuatnya menarik adalah bahwa konvolusi pada prinsipnya terasa 

294
00:16:12,874 --> 00:16:16,260
jauh lebih rumit daripada perkalian sederhana dan saya tidak hanya bermaksud 

295
00:16:16,260 --> 00:16:19,427
secara konseptual, konvolusi lebih sulit untuk dipikirkan. Maksud saya, 

296
00:16:19,427 --> 00:16:22,769
secara komputasi, diperlukan lebih banyak langkah untuk melakukan konvolusi 

297
00:16:22,769 --> 00:16:25,760
daripada melakukan a produk pointwise dari dua daftar yang berbeda. 

298
00:16:26,319 --> 00:16:30,002
Sebagai contoh, katakanlah saya memberi Anda dua polinomial yang sangat besar, 

299
00:16:30,002 --> 00:16:33,265
katakanlah masing-masing polinomial dengan seratus koefisien berbeda, 

300
00:16:33,265 --> 00:16:36,994
lalu jika cara Anda mengalikannya adalah dengan memperluas hasil perkalian ini, 

301
00:16:36,994 --> 00:16:40,816
Anda tahu mengisi seluruh kotak perkalian berpasangan berukuran 100 kali 100 yang 

302
00:16:40,816 --> 00:16:44,685
mengharuskan Anda melakukannya melakukan 10.000 produk berbeda dan kemudian ketika 

303
00:16:44,685 --> 00:16:48,881
Anda mengumpulkan semua suku serupa di sepanjang diagonal, itu adalah kumpulan sekitar 10.

304
00:16:48,881 --> 00:16:49,860
000 operasi lainnya. 

305
00:16:50,700 --> 00:16:53,941
Secara lebih umum dalam istilah kita akan mengatakan bahwa 

306
00:16:53,941 --> 00:16:57,128
algoritme adalah O dari n kuadrat yang berarti dua daftar 

307
00:16:57,128 --> 00:17:01,140
berukuran n dengan cara jumlah skala operasi sebanding dengan kuadrat n. 

308
00:17:01,820 --> 00:17:05,726
Di sisi lain jika saya memikirkan dua polinomial dalam hal keluarannya, 

309
00:17:05,726 --> 00:17:08,873
misalnya mengambil sampel nilainya pada beberapa masukan, 

310
00:17:08,873 --> 00:17:13,540
lalu mengalikannya hanya memerlukan operasi sebanyak jumlah sampel karena sekali lagi 

311
00:17:13,540 --> 00:17:18,043
ini adalah operasi yang tepat dan dengan polinomial Anda hanya perlu banyak sampel 

312
00:17:18,043 --> 00:17:20,540
hingga dapat memperoleh kembali koefisiennya. 

313
00:17:20,540 --> 00:17:25,060
Misalnya dua keluaran cukup untuk menentukan polinomial linier secara unik.

314
00:17:25,660 --> 00:17:29,400
Tiga keluaran akan cukup untuk menentukan polinomial kuadrat secara unik.

315
00:17:29,640 --> 00:17:32,874
Dan secara umum jika Anda mengetahui n keluaran berbeda, 

316
00:17:32,874 --> 00:17:37,640
itu cukup untuk menentukan secara unik polinomial yang memiliki n koefisien berbeda.

317
00:17:37,780 --> 00:17:40,720
Atau jika Anda mau, kita dapat mengungkapkannya dalam bahasa sistem persamaan.

318
00:17:41,200 --> 00:17:43,912
Bayangkan saya memberi tahu Anda bahwa saya mempunyai polinomial tetapi saya 

319
00:17:43,912 --> 00:17:46,520
tidak memberi tahu Anda berapa koefisiennya, itu adalah misteri bagi Anda.

320
00:17:46,700 --> 00:17:50,800
Dalam contoh kami, Anda mungkin menganggap ini sebagai produk yang kami coba cari tahu.

321
00:17:50,800 --> 00:17:53,889
Maka misalkan saya katakan saya akan memberitahu Anda apa keluaran dari 

322
00:17:53,889 --> 00:17:57,194
polinomial ini jika Anda memasukkan berbagai masukan yang berbeda seperti 0, 

323
00:17:57,194 --> 00:18:00,498
1, 2, 3, dan seterusnya, dan saya berikan secukupnya sehingga Anda mempunyai 

324
00:18:00,498 --> 00:18:03,460
persamaan sebanyak-banyaknya. Anda memiliki hal yang tidak diketahui.

325
00:18:04,140 --> 00:18:07,340
Bahkan sistem persamaannya linier, jadi itu bagus.

326
00:18:07,780 --> 00:18:10,900
Dan setidaknya pada prinsipnya, ini sudah cukup untuk memulihkan koefisien.

327
00:18:11,740 --> 00:18:15,460
Jadi garis besar algoritme secara kasar adalah kapan pun Anda ingin menggabungkan 

328
00:18:15,460 --> 00:18:19,000
dua daftar angka, Anda memperlakukannya seperti koefisien dari dua polinomial.

329
00:18:19,420 --> 00:18:22,964
Anda mengambil sampel polinomial tersebut dengan keluaran yang cukup, 

330
00:18:22,964 --> 00:18:26,610
mengalikan sampel tersebut berdasarkan titik, lalu menyelesaikan sistem 

331
00:18:26,610 --> 00:18:30,560
untuk memulihkan koefisien sebagai cara tersembunyi untuk menemukan konvolusi.

332
00:18:31,420 --> 00:18:33,993
Dan setidaknya seperti yang telah saya nyatakan sejauh ini, 

333
00:18:33,993 --> 00:18:37,340
beberapa dari Anda berhak mengeluh, &quot;Grant, itu rencana yang bodoh&quot;.

334
00:18:37,580 --> 00:18:42,378
Karena menghitung semua sampel ini untuk salah satu polinomial yang kita tahu 

335
00:18:42,378 --> 00:18:47,116
sudah memerlukan operasi n kuadrat, belum lagi menyelesaikan sistem tersebut 

336
00:18:47,116 --> 00:18:52,100
tentu akan menjadi sulit secara komputasi seperti hanya melakukan konvolusi saja.

337
00:18:52,600 --> 00:18:55,917
Jadi, tentu saja kita memiliki hubungan antara perkalian dan konvolusi, 

338
00:18:55,917 --> 00:18:59,742
tetapi semua kerumitan terjadi dalam penerjemahan dari satu sudut pandang ke sudut 

339
00:18:59,742 --> 00:19:00,480
pandang lainnya.

340
00:19:01,600 --> 00:19:04,931
Namun ada triknya, dan bagi Anda yang mengetahui tentang transformasi 

341
00:19:04,931 --> 00:19:07,740
Fourier dan algoritma FFT mungkin dapat mengetahui arahnya.

342
00:19:07,740 --> 00:19:09,852
Jika Anda belum familiar dengan topik-topik ini, 

343
00:19:09,852 --> 00:19:12,180
apa yang akan saya sampaikan mungkin terasa tiba-tiba.

344
00:19:12,260 --> 00:19:14,463
Ketahuilah bahwa ada jalur tertentu yang bisa Anda lalui 

345
00:19:14,463 --> 00:19:16,860
dalam matematika yang menjadikan langkah ini lebih diharapkan.

346
00:19:17,720 --> 00:19:20,360
Pada dasarnya idenya adalah kita memiliki kebebasan memilih di sini.

347
00:19:20,540 --> 00:19:24,421
Jika alih-alih mengevaluasi himpunan masukan sembarang seperti 0, 1, 2, 3, 

348
00:19:24,421 --> 00:19:28,975
dan seterusnya, Anda memilih untuk mengevaluasi himpunan bilangan kompleks yang dipilih 

349
00:19:28,975 --> 00:19:29,700
secara khusus.

350
00:19:30,240 --> 00:19:33,162
Khususnya yang terletak secara merata pada lingkaran satuan, 

351
00:19:33,162 --> 00:19:34,840
yang disebut sebagai akar kesatuan.

352
00:19:35,200 --> 00:19:36,880
Ini memberi kita sistem yang lebih ramah.

353
00:19:38,360 --> 00:19:42,258
Ide dasarnya adalah dengan menemukan bilangan yang pangkatnya termasuk dalam 

354
00:19:42,258 --> 00:19:46,106
pola perputaran ini, berarti sistem yang kita hasilkan akan memiliki banyak 

355
00:19:46,106 --> 00:19:48,587
redundansi dalam berbagai suku yang Anda hitung, 

356
00:19:48,587 --> 00:19:52,536
dan dengan cerdik dalam menentukan caranya. Anda memanfaatkan redundansi itu, 

357
00:19:52,536 --> 00:19:54,460
Anda dapat menghemat banyak pekerjaan.

358
00:19:56,020 --> 00:19:59,373
Kumpulan keluaran yang saya tulis ini memiliki nama khusus, 

359
00:19:59,373 --> 00:20:02,280
yang disebut transformasi koefisien Fourier diskrit.

360
00:20:02,500 --> 00:20:05,928
Dan jika Anda ingin mempelajari lebih lanjut, saya sebenarnya melakukan kuliah 

361
00:20:05,928 --> 00:20:09,140
lain untuk kelas Julia MIT yang sama tentang transformasi Fourier diskrit.

362
00:20:09,220 --> 00:20:13,059
Dan ada juga video yang sangat bagus di saluran yang dapat direduksi berbicara tentang 

363
00:20:13,059 --> 00:20:16,855
transformasi Fourier cepat, yang merupakan algoritma untuk menghitungnya dengan lebih 

364
00:20:16,855 --> 00:20:17,120
cepat.

365
00:20:17,480 --> 00:20:20,446
Veritasium juga baru-baru ini membuat video yang sangat bagus di FFT, 

366
00:20:20,446 --> 00:20:21,760
jadi Anda punya banyak pilihan.

367
00:20:22,260 --> 00:20:24,660
Dan algoritme cepat itulah yang menjadi tujuan kami.

368
00:20:25,120 --> 00:20:28,715
Sekali lagi karena semua redundansi ini, terdapat metode untuk beralih 

369
00:20:28,715 --> 00:20:33,021
dari koefisien ke semua keluaran ini, di mana alih-alih melakukan operasi n kuadrat, 

370
00:20:33,021 --> 00:20:36,465
Anda melakukan operasi n kali log n operasi, yang jauh lebih besar. 

371
00:20:36,465 --> 00:20:39,200
jauh lebih baik saat Anda menskalakan ke daftar besar.

372
00:20:39,660 --> 00:20:42,540
Dan yang terpenting, algoritma fft ini berjalan dua arah.

373
00:20:42,700 --> 00:20:45,480
Ini juga memungkinkan Anda beralih dari keluaran ke koefisien.

374
00:20:46,220 --> 00:20:49,060
Jadi dengan menyatukan semuanya, mari kita lihat kembali garis besar algoritme kita.

375
00:20:49,420 --> 00:20:52,730
Sekarang kita dapat mengatakan kapan pun Anda diberikan dua daftar angka 

376
00:20:52,730 --> 00:20:55,088
yang panjang dan Anda ingin mengambil konvolusinya, 

377
00:20:55,088 --> 00:20:58,806
pertama-tama hitung transformasi Fourier cepat dari masing-masing angka tersebut, 

378
00:20:58,806 --> 00:21:02,253
yang di benak Anda dapat Anda anggap memperlakukannya seperti mereka adalah 

379
00:21:02,253 --> 00:21:05,745
koefisien polinomial dan mengevaluasinya pada serangkaian titik yang dipilih 

380
00:21:05,745 --> 00:21:06,380
secara khusus.

381
00:21:06,899 --> 00:21:11,273
Kemudian gandakan kedua hasil yang baru saja Anda dapatkan, yang bagus dan cepat, 

382
00:21:11,273 --> 00:21:13,940
lalu lakukan transformasi Fourier cepat terbalik, 

383
00:21:13,940 --> 00:21:18,100
dan hasilnya adalah cara pintu belakang yang licik untuk menghitung konvolusi 

384
00:21:18,100 --> 00:21:18,900
yang kita cari.

385
00:21:19,040 --> 00:21:22,240
Namun kali ini hanya melibatkan operasi O dari n log n.

386
00:21:23,139 --> 00:21:24,740
Itu sangat keren bagiku!

387
00:21:25,120 --> 00:21:29,693
Konteks yang sangat spesifik di mana konvolusi muncul, mengalikan dua polinomial, 

388
00:21:29,693 --> 00:21:34,100
membuka pintu bagi algoritma yang relevan di mana pun konvolusi mungkin muncul.

389
00:21:34,180 --> 00:21:36,590
Jika Anda ingin menambahkan distribusi probabilitas, 

390
00:21:36,590 --> 00:21:39,000
lakukan pemrosesan gambar besar-besaran, apa pun itu.

391
00:21:39,220 --> 00:21:41,828
Dan menurut saya itu adalah contoh bagus mengapa Anda harus 

392
00:21:41,828 --> 00:21:44,523
bersemangat ketika melihat beberapa operasi atau konsep dalam 

393
00:21:44,523 --> 00:21:47,480
matematika muncul di banyak bidang yang tampaknya tidak berhubungan.

394
00:21:48,480 --> 00:21:50,072
Jika Anda ingin sedikit pekerjaan rumah, inilah 

395
00:21:50,072 --> 00:21:51,500
sesuatu yang menyenangkan untuk dipikirkan.

396
00:21:51,720 --> 00:21:54,485
Jelaskan mengapa ketika Anda mengalikan dua bilangan berbeda, 

397
00:21:54,485 --> 00:21:58,143
yang merupakan perkalian biasa seperti yang kita semua pelajari di sekolah dasar, 

398
00:21:58,143 --> 00:22:01,980
yang Anda lakukan pada dasarnya adalah konvolusi antara digit-digit bilangan tersebut.

399
00:22:02,500 --> 00:22:04,860
Ada beberapa langkah tambahan dengan carry dan sejenisnya, 

400
00:22:04,860 --> 00:22:06,460
tetapi langkah intinya adalah konvolusi.

401
00:22:07,280 --> 00:22:10,747
Mengingat adanya algoritma yang cepat, artinya jika Anda memiliki dua 

402
00:22:10,747 --> 00:22:14,462
bilangan bulat yang sangat besar, maka ada cara untuk mencari perkaliannya 

403
00:22:14,462 --> 00:22:17,880
yang lebih cepat daripada metode yang kita pelajari di sekolah dasar.

404
00:22:18,140 --> 00:22:22,293
Bahwa alih-alih membutuhkan O dari n operasi kuadrat hanya membutuhkan O dari n log n, 

405
00:22:22,293 --> 00:22:24,920
yang bahkan sepertinya hal itu tidak mungkin dilakukan.

406
00:22:25,380 --> 00:22:28,696
Masalahnya adalah sebelum ini benar-benar berguna dalam praktik, 

407
00:22:28,696 --> 00:22:30,840
angka Anda harus benar-benar sangat besar.

408
00:22:31,220 --> 00:22:35,340
Tapi tetap saja, keren kalau ada algoritma seperti itu.

409
00:22:35,340 --> 00:22:37,437
Selanjutnya kita akan mengalihkan perhatian kita pada kasus 

410
00:22:37,437 --> 00:22:39,640
berkelanjutan dengan fokus khusus pada distribusi probabilitas.

