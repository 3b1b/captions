1
00:00:00,000 --> 00:00:04,480
Tegyük fel, hogy adok neked két különböző számlistát, vagy esetleg két különböző függvényt, és arra

2
00:00:04,480 --> 00:00:08,400
kérlek, gondold végig, hogyan kombinálhatod ezt a két listát, hogy új számlistát kapj, vagy

3
00:00:08,400 --> 00:00:14,000
a két függvény kombinálásával új függvényt kapj. . Talán az egyik egyszerű módszer, ami eszünkbe

4
00:00:14,000 --> 00:00:18,640
jut, az, hogy szóról szóra összeadjuk őket. Hasonlóan a függvényekhez, hozzáadhatja az összes

5
00:00:18,640 --> 00:00:24,000
megfelelő kimenetet. Hasonló módon megszorozhatja a két listát kifejezésenként, és

6
00:00:24,000 --> 00:00:28,720
ugyanezt teheti a függvényekkel. De van egy másik fajta kombináció, amely

7
00:00:28,720 --> 00:00:33,840
ugyanolyan alapvető, mint a kettő, de sokkal ritkábban tárgyalják, konvolúcióként ismert.

8
00:00:33,840 --> 00:00:38,240
De az előző két esettől eltérően ez nem pusztán egy számokkal

9
00:00:38,240 --> 00:00:43,360
végzett műveletből öröklődik. Ez valami igazán új a számlisták vagy a függvények

10
00:00:43,360 --> 00:00:49,280
kombinálása szempontjából. Mindenhol megjelennek, mindenütt jelen vannak a képfeldolgozásban, ez

11
00:00:49,280 --> 00:00:53,760
a valószínűségelmélet alapvető konstrukciója, sokat használják differenciálegyenletek megoldásában, és egy

12
00:00:53,760 --> 00:00:58,240
olyan kontextus, ahol szinte biztosan láttad, ha nem ezen a néven

13
00:00:58,240 --> 00:01:03,440
két polinomot összeszoroz. A vizuális magyarázatokkal foglalkozó emberként ez egy különösen

14
00:01:03,440 --> 00:01:08,800
jó téma, mert a képletes definíció elszigetelten és kontextus nélkül megfélemlítőnek

15
00:01:08,800 --> 00:01:14,080
tűnhet, de ha szánunk időt arra, hogy valóban kibontsuk, amit mond,

16
00:01:14,080 --> 00:01:18,800
és előtte megindítjuk, hogy miért. valami ilyesmit szeretne, hihetetlenül szép művelet.

17
00:01:18,800 --> 00:01:22,880
És be kell vallanom, tanultam egy kicsit, miközben összeállítottam a projekt

18
00:01:22,880 --> 00:01:26,960
látványvilágát. Két különböző függvény összevonása esetén különböző módokon próbáltam elképzelni, hogy

19
00:01:26,960 --> 00:01:30,720
ez mit jelenthet, és az egyiknél volt egy kis aha pillanatom,

20
00:01:30,720 --> 00:01:35,840
hogy miért játsszák a normál eloszlások azt a szerepet, valószínű, hogy

21
00:01:35,840 --> 00:01:40,320
miért olyan természetes alakja egy függvénynek. De előre haladok, nagyon sok

22
00:01:40,320 --> 00:01:44,800
beállítás van ehhez. Ebben a videóban elsősorban a diszkrét esetre összpontosítunk,

23
00:01:44,800 --> 00:01:49,920
és különösen egy nagyon váratlan, de nagyon okos algoritmusra ezek kiszámításához.

24
00:01:49,920 --> 00:01:54,400
A folyamatos eset vitáját pedig kihúzom egy második részbe.

25
00:01:57,840 --> 00:02:03,120
Nagyon csábító a képfeldolgozási példákkal nyitni, mivel vizuálisan ezek a legérdekesebbek, de

26
00:02:03,120 --> 00:02:06,880
van néhány apróság, ami miatt a képfeldolgozási eset kevésbé reprezentálja a konvolúciókat

27
00:02:06,880 --> 00:02:11,760
összességében, ezért inkább kezdjük a dolgokat valószínűséggel, és különösen az egyik legegyszerűbb

28
00:02:11,760 --> 00:02:15,520
példa, amelyre biztos vagyok benne, hogy itt mindenki elgondolkodott az élete egy

29
00:02:15,520 --> 00:02:20,320
bizonyos pontján, ami egy pár kockával dobott, és a különböző összegek megtekintésének

30
00:02:20,320 --> 00:02:25,600
esélyeinek kitalálása. És mondhatod, nem probléma, nem probléma. Mind a két kockádnak

31
00:02:25,600 --> 00:02:31,600
hat különböző lehetséges kimenetele van, ami összesen 36 különböző lehetséges kimenetelpárt ad, és ha

32
00:02:31,600 --> 00:02:35,600
csak végignézzük az összeset, meg tudjuk számolni, hogy hány párnak van egy adott összege.

33
00:02:36,240 --> 00:02:41,120
És az összes párt így egy rácsba rendezve, egy nagyon szép dolog az, hogy

34
00:02:41,120 --> 00:02:47,040
az összes állandó összegű pár látható a különböző átlók egyikén. Tehát egyszerűen csak megszámolja,

35
00:02:47,040 --> 00:02:51,920
hány van az egyes átlókon, megmutatja, mekkora valószínűséggel lát egy bizonyos összeget.

36
00:02:52,880 --> 00:02:57,760
És azt mondanám, nagyon jó, nagyon jó, de tud más módon elképzelni ugyanezt

37
00:02:57,760 --> 00:03:03,120
a kérdést? Egyéb képek, amelyek eszünkbe juthatnak, ha az összes különálló párra gondolunk, amelyeknek adott összege

38
00:03:03,120 --> 00:03:08,800
van? És lehet, hogy egyikőtök felemeli a kezét, és azt mondja: igen, van egy. Tegyük fel, hogy ezt

39
00:03:08,800 --> 00:03:14,560
a két különböző lehetőségkészletet egymás után képzeli el, de megfordítja a második sort. Így az

40
00:03:14,560 --> 00:03:20,160
összes különböző pár, amely összesen hét, így függőlegesen sorakozik. És ha ezt az

41
00:03:20,160 --> 00:03:24,880
alsó sort egészen jobbra csúsztatjuk, akkor az egyedülálló pár, amely kettőt ad, a kígyószemek

42
00:03:24,880 --> 00:03:29,680
az egyetlenek, amelyek igazodnak. És ha ezt egy egységnél jobbra csúsztatom, akkor az egymáshoz igazodó

43
00:03:29,680 --> 00:03:35,440
párok a két különböző pár, amelyek összeadódnak három. Általánosságban elmondható, hogy ennek az alsó tömbnek a

44
00:03:35,440 --> 00:03:40,320
különböző eltolási értékei, amelyek emlékeznek arra, hogy először meg kellett fordítanom, felfedik az összes különálló párt, amelyeknek adott

45
00:03:40,320 --> 00:03:48,800
összege van. Ami a valószínűségi kérdéseket illeti, ez még mindig nem különösebben

46
00:03:48,800 --> 00:03:53,120
érdekes, mert csak azt számoljuk, hány eredmény van az egyes kategóriákban.

47
00:03:53,120 --> 00:03:57,280
De ez azzal a burkolt feltételezéssel van így, hogy minden arcnak egyenlő esélye van

48
00:03:57,280 --> 00:04:02,240
felbukkanni. De mi lenne, ha azt mondanám, hogy van egy speciális kockakészletem, ami nem egységes? Lehet,

49
00:04:02,240 --> 00:04:06,800
hogy a kék kocka saját számkészlettel rendelkezik, amely leírja az egyes arcok felbukkanásának valószínűségét,

50
00:04:06,800 --> 00:04:11,920
a piros kocka pedig saját egyedi számkészlettel rendelkezik. Ebben az esetben, ha például azt akarná

51
00:04:11,920 --> 00:04:17,360
kitalálni, hogy mekkora valószínűséggel lát egy kettőt, akkor megszorozná annak valószínűségét, hogy a kék kocka 1-szerese

52
00:04:17,360 --> 00:04:22,000
annak a valószínűségnek, hogy a piros kocka egy. És annak esélye érdekében, hogy hármast lásson,

53
00:04:22,000 --> 00:04:26,880
nézze meg a két különálló párt, ahol ez lehetséges, és ismét megszorozza a megfelelő

54
00:04:26,880 --> 00:04:32,240
valószínűségeket, majd összeadja ezt a két szorzatot. Hasonlóképpen, annak az esélye, hogy

55
00:04:32,240 --> 00:04:36,320
négyet látunk, három különböző lehetőségpárt össze kell szorozni és összeadni.

56
00:04:36,320 --> 00:04:41,360
Néhány képlet felállításának szellemében nevezzük el ezeket a felső valószínűségeket a1, a2, a3 és így

57
00:04:41,360 --> 00:04:48,000
tovább, az alsókat pedig b1, b2, b3 és így tovább. És általában, ez a

58
00:04:48,000 --> 00:04:52,080
folyamat, ahol veszünk két különböző számtömböt, megfordítjuk a másodikat, majd sorba rendezzük

59
00:04:52,080 --> 00:04:56,160
őket különböző eltolási értékekkel, veszünk egy csomó páros szorzatot és összeadjuk őket,

60
00:04:56,160 --> 00:05:00,960
ez az egyik alapvető módja annak, hogy gondolkodjunk arról, mi a konvolúció.

61
00:05:00,960 --> 00:05:08,960
Tehát, hogy egy kicsit pontosabban fogalmazzuk meg, ezen a folyamaton keresztül csak valószínűségeket generáltunk, hogy

62
00:05:08,960 --> 00:05:13,840
kettő, három, négy, 12-ig és 12-ig láthatók legyenek, és ezeket úgy kaptuk meg, hogy összekevertünk egy

63
00:05:13,840 --> 00:05:20,080
értéklistát, a-t és egy másikat. értékjegyzék, b. A szóhasználatban azt mondanánk, hogy ennek a két

64
00:05:20,080 --> 00:05:25,600
sorozatnak a konvolúciója adja nekünk ezt az új sorozatot, a 11 értékből álló új sorozatot, amelyek

65
00:05:25,600 --> 00:05:30,160
mindegyike páronkénti szorzatok összegének tűnik. Ha úgy tetszik, egy másik módja annak, hogy ugyanarra a műveletre

66
00:05:30,160 --> 00:05:36,240
gondoljon, ha először hozzon létre egy táblázatot az összes páronkénti szorzatról, majd összeadja az összes

67
00:05:36,240 --> 00:05:41,120
átlót. Ez egy módja annak, hogy összekeverjük ezt a két számsorozatot, hogy egy új, 11 számból

68
00:05:41,120 --> 00:05:46,400
álló sorozatot kapjunk. Ez ugyanaz a művelet, mint a tolóablakok gondolták, csak egy másik perspektíva.

69
00:05:46,960 --> 00:05:51,280
Egy kis jelöléssel a következőképpen láthatod leírva. Az a és b

70
00:05:51,280 --> 00:05:57,200
konvolúciója, amelyet ezzel a kis csillaggal jelölünk, egy új lista, és ennek a lista n-edik eleme összegnek tűnik,

71
00:05:57,200 --> 00:06:03,440
és ez az összeg átmegy az összes különböző indexpáron, az i-n és a j-n, így az ezek az

72
00:06:03,440 --> 00:06:09,440
indexek egyenlők n-nel. Ez amolyan falat, de például ha n 6, akkor a párok, amelyeken átmegyünk, az 1 és

73
00:06:09,440 --> 00:06:15,680
5, 2 és 4, 3 és 3, 4 és 2, 5 és 1, a különböző párok, amelyek összeadódnak. 6-ra.

74
00:06:16,400 --> 00:06:20,640
De őszintén szólva, bárhogyan írja is le, a jelölés másodlagos fontosságú ahhoz képest, amit

75
00:06:20,640 --> 00:06:26,320
a folyamathoz a fejében tart. Itt talán segít egy szuper egyszerű példa, ahol megkérdezhetem, mi

76
00:06:26,320 --> 00:06:32,000
a konvolúciója az 1., 2., 3. listának és a 4., 5., 6. listának. Elképzelheti, hogy

77
00:06:32,000 --> 00:06:36,160
mindkét listát felveszi, megfordítja a másodikat, majd a fedelével

78
00:06:36,160 --> 00:06:41,200
kezdi egészen balra. Ezután az egymáshoz igazodó értékpár 1 és 4, szorozzuk meg

79
00:06:41,200 --> 00:06:45,680
őket, és ez adja a kimenetünk első tagját. Csúsztassa az alsó tömböt egy egységgel jobbra, az

80
00:06:45,680 --> 00:06:51,840
egymáshoz igazodó párok 1 és 5, valamint 2 és 4, szorozd meg ezeket a párokat, add össze, és így

81
00:06:51,840 --> 00:06:57,600
13-at kapunk, a következő bejegyzést a kimenetünkben. Csúsztassa át a dolgokat még egyszer, és 1-szer 6-ot, plusz

82
00:06:57,600 --> 00:07:04,400
2-szer 5-öt, plusz 3-szor 4-et veszünk, ami történetesen 28. Még egy dia, és 2-szer 6-ot kapunk,

83
00:07:04,400 --> 00:07:10,000
plusz 3-szor 5-öt, és így 27-et kapunk, és végül az utolsó tag 3-szor 6-nak fog kinézni.

84
00:07:10,560 --> 00:07:14,080
Ha szeretné, előhívhatja a kedvenc programozási nyelvét, és kedvenc könyvtárát, amely

85
00:07:14,080 --> 00:07:18,640
különféle numerikus műveleteket tartalmaz, és megerősítheti, hogy nem hazudok neked.

86
00:07:18,640 --> 00:07:24,320
Ha az 1, 2, 3 és 4, 5, 6 konvolúcióját felveszi, akkor valóban ezt az eredményt kapja.

87
00:07:24,880 --> 00:07:29,200
Láttunk egy olyan esetet, amikor ez természetes és kívánatos művelet, a valószínűségi eloszlások

88
00:07:29,200 --> 00:07:34,640
összeadásával, egy másik gyakori példa pedig a mozgóátlag. Képzeld el, hogy van egy

89
00:07:34,640 --> 00:07:39,920
hosszú számlistád, és veszel egy másik kisebb számlistát, amelyek mindegyike 1-et ad. Ebben az esetben csak

90
00:07:39,920 --> 00:07:45,280
van egy kis listám 5 értékből, és mindegyik egyenlő 15-tel. Aztán ha végrehajtjuk ezt a csúszóablak-konvolúciós

91
00:07:45,280 --> 00:07:49,760
folyamatot, és valahogy becsukjuk a szemünket, és a szőnyeg alá söpörjük azt, ami a legelején

92
00:07:50,560 --> 00:07:55,120
történik, ha a kisebb értéklistánk teljesen átfedésben van a nagyobb értékkel, akkor gondoljuk át, hogy

93
00:07:55,680 --> 00:08:01,120
mi az egyes kifejezések. a konvolúció valóban azt jelenti. Minden iterációnál megszorozod az adataidból

94
00:08:01,120 --> 00:08:06,400
származó értékeket 15-tel, és összeadod az összeset, ami azt jelenti, hogy

95
00:08:06,400 --> 00:08:12,080
ebben a kis ablakban az adatok átlagát veszed. Összességében a folyamat

96
00:08:12,080 --> 00:08:16,800
az eredeti adatok kiegyenlített változatát adja meg, és ezt módosíthatja egy másik kis

97
00:08:16,800 --> 00:08:21,280
számlistával kezdve, és amíg ez a kis lista összesen 1-et tesz ki, akkor

98
00:08:21,280 --> 00:08:25,840
is értelmezheti mozgóképként. átlagos. Az itt bemutatott példában ez a mozgóátlag nagyobb súlyt

99
00:08:25,840 --> 00:08:30,720
adna a központi értéknek. Ez egyben az adatok kisimított változatát is eredményezi.

100
00:08:33,200 --> 00:08:37,840
Ha ennek egyfajta kétdimenziós analógját készíti, akkor egy szórakoztató algoritmust ad egy adott kép

101
00:08:37,840 --> 00:08:43,120
elmosására. És azt kell mondanom, hogy az animációk, amelyeket most mutatok, olyan módosítások,

102
00:08:43,120 --> 00:08:48,160
amelyeket eredetileg egy olyan előadássorozat részeként készítettem, amelyet a Julia Laborral tartottam az MIT-n

103
00:08:48,160 --> 00:08:52,320
egy bizonyos OpenCourseWare osztály számára, amely képfeldolgozó egységet tartalmazott. Ott egy kicsit többet tettünk, hogy

104
00:08:52,320 --> 00:08:56,640
belemerüljünk az egész mögött meghúzódó kódba, így ha kíváncsi vagy, hagyok néhány linket. De

105
00:08:56,640 --> 00:09:01,440
visszagondolva erre az elmosódó példára, az történik, hogy megvan ez a kis 3x3-as

106
00:09:01,440 --> 00:09:06,480
értékrács, ami az eredeti képünk mentén halad, és ha nagyítunk, ezek az

107
00:09:06,480 --> 00:09:11,120
értékek mindegyike 19., és mit csinálok. minden iterációnál az értékek mindegyikét megszorozza a

108
00:09:11,120 --> 00:09:16,080
megfelelő pixellel, amelyik tetején található. És természetesen az informatikában a színekre úgy gondolunk,

109
00:09:16,080 --> 00:09:20,400
mint három értékből álló kis vektorokra, amelyek a piros, zöld és kék komponenseket képviselik.

110
00:09:20,400 --> 00:09:25,440
Ha ezeket a kis értékeket megszorzom 1 9-eddel, és összeadom őket, akkor az egyes

111
00:09:25,440 --> 00:09:30,480
színcsatornákon átlagot kapunk, és a jobb oldali kép megfelelő pixelét ez az összeg határozza

112
00:09:30,480 --> 00:09:36,320
meg. Az általános hatás, ahogy ezt a kép minden egyes pixelére tesszük, az,

113
00:09:36,320 --> 00:09:40,880
hogy mindegyik beszivárog az összes szomszédjába, ami az eredetinél homályosabb verziót ad.

114
00:09:41,680 --> 00:09:46,640
A szóhasználatban azt mondanánk, hogy a jobb oldali kép az eredeti képünk egy kis

115
00:09:46,640 --> 00:09:52,000
értékrácsával egybeeső konvolúciója. Vagy technikailag talán azt kellene mondanom, hogy ez a konvolúció ennek

116
00:09:52,000 --> 00:09:56,160
a kis értékrácsnak a 180 fokkal elforgatott változatával. Nem mintha az számít, mikor szimmetrikus

117
00:09:56,160 --> 00:10:00,720
a rács, de érdemes észben tartani, hogy a konvolúció definíciója, amint azt a tiszta

118
00:10:00,720 --> 00:10:05,760
matematikai kontextusból örökölte, mindig arra ösztönözze Önt, hogy gondolkodjon el a második tömb körül.

119
00:10:05,760 --> 00:10:10,240
Ha ezt kissé módosítjuk, akkor más értékrács kiválasztásával sokkal elegánsabb elmosódási hatást érhetünk

120
00:10:10,240 --> 00:10:15,920
el. Ebben az esetben van egy kis 5x5-ös rácsom, de a különbség nem annyira a méret.

121
00:10:15,920 --> 00:10:19,920
Ha ráközelítünk, észrevesszük, hogy a középső érték sokkal nagyobb, mint a szélek felé eső

122
00:10:19,920 --> 00:10:25,360
érték, és ahonnan ez származik, az összes mintát egy haranggörbéből vettük, amelyet Gauss-eloszlásnak

123
00:10:25,360 --> 00:10:30,240
neveznek. Így amikor ezeket az értékeket megszorozzuk a megfelelő pixellel, amelyik tetején

124
00:10:30,240 --> 00:10:35,200
ülnek, sokkal nagyobb súlyt adunk ennek a központi pixelnek, és sokkal kevésbé

125
00:10:35,200 --> 00:10:39,920
a szélén lévőknek. És csakúgy, mint korábban, a jobb oldali megfelelő pixelt ez az összeg határozza

126
00:10:39,920 --> 00:10:45,360
meg. Mivel ezt a folyamatot minden egyes pixelnél elvégezzük, elmosódási hatást ad, ami

127
00:10:45,360 --> 00:10:49,760
sokkal hitelesebben szimulálja azt a gondolatot, hogy az objektívet eltünteti vagy valami hasonlót.

128
00:10:49,760 --> 00:10:54,960
De az elmosódás messze nem az egyetlen dolog, amit ezzel az ötlettel tehet. Például vessünk egy pillantást erre

129
00:10:54,960 --> 00:10:59,600
a kis értékrácsra, amely tartalmaz néhány pozitív számot a bal oldalon és néhány negatív

130
00:10:59,600 --> 00:11:04,480
számot a jobb oldalon, amelyeket kékre és pirosra színezünk. Szánjon rá egy pillanatot, hogy meg

131
00:11:04,480 --> 00:11:11,680
tudja-e jósolni és megérteni, hogy ez milyen hatással lesz a végső képre. Tehát ebben az esetben

132
00:11:11,680 --> 00:11:16,560
a képre csak szürkeárnyalatosnak fogok gondolni, nem pedig színesre, tehát minden képpontot három helyett

133
00:11:16,560 --> 00:11:21,280
csak egy szám jelöl. És egy dolog, amit érdemes megjegyezni, az az, hogy a

134
00:11:21,280 --> 00:11:26,240
konvolúció során negatív értékeket kaphatunk. Például ezen a ponton, ha nagyítunk, a kis rácsunk bal

135
00:11:26,240 --> 00:11:30,960
fele teljes egészében a fekete pixelek tetején helyezkedik el, aminek értéke nulla lenne, de

136
00:11:30,960 --> 00:11:35,360
a negatív értékek jobb fele mind a fehér képpontok tetején található, ami értéke egy.

137
00:11:36,000 --> 00:11:40,960
Tehát ha a megfelelő kifejezéseket megszorozzuk és összeadjuk, az eredmény nagyon negatív lesz, és ezt

138
00:11:40,960 --> 00:11:45,120
a jobb oldali képpel úgy jelenítem meg, hogy a negatív értékeket pirosra, a pozitív értékeket

139
00:11:45,120 --> 00:11:49,520
pedig kékre színezem. Egy másik dolog, amit észre kell venni, hogy ha egy olyan foltot használ, amely

140
00:11:49,520 --> 00:11:55,680
ugyanolyan színű, akkor minden nullára megy, mivel a mi kis rácsunkban az értékek összege nulla. Ez nagyban

141
00:11:55,680 --> 00:11:59,680
különbözik az előző két példától, ahol a mi kis rácsunk összege egy volt, ami lehetővé

142
00:11:59,680 --> 00:12:05,760
tette, hogy mozgóátlagként és így elmosódásként értelmezzük. Összességében ez a kis folyamat alapvetően

143
00:12:05,760 --> 00:12:10,240
észleli, hogy hol van eltérés a pixelértékben, ahogy balról jobbra mozog,

144
00:12:10,240 --> 00:12:13,760
és így egyfajta módot ad a kép függőleges széleinek feltérképezésére.

145
00:12:16,560 --> 00:12:20,960
És hasonlóképpen, ha megforgattuk a rácsot úgy, hogy a felülről lefelé haladva

146
00:12:20,960 --> 00:12:26,000
változik, ez az összes vízszintes élt felveszi, ami a mi kis

147
00:12:26,000 --> 00:12:31,520
pite lényképünk esetében igencsak démoni szemeket eredményez. Ezt a kisebb rácsot

148
00:12:31,520 --> 00:12:36,160
egyébként gyakran kernelnek is nevezik, és itt az a szépség, hogy egy másik kernel kiválasztásával

149
00:12:36,160 --> 00:12:40,240
különböző képfeldolgozási effektusokat érhet el, nem csak az élészlelés elmosódását, hanem például az élesítést

150
00:12:40,240 --> 00:12:44,800
is. Azok számára, akik hallottak a konvolúciós neurális hálózatról, az az ötlet, hogy adatokat

151
00:12:44,800 --> 00:12:49,600
használjanak annak kiderítésére, hogy mik legyenek a kernelek, amit az határozza meg, hogy a

152
00:12:49,600 --> 00:12:55,120
neurális hálózat mit akar észlelni. Egy másik dolog, amit talán fel kell emelnem, az a kimenet

153
00:12:55,120 --> 00:12:59,040
hossza. A mozgóátlagos példához hasonló eseteknél előfordulhat, hogy csak akkor érdemes a kifejezésekre gondolni,

154
00:12:59,040 --> 00:13:04,080
amikor mindkét ablak teljesen egymáshoz igazodik, vagy a képfeldolgozási példában esetleg azt szeretné,

155
00:13:04,080 --> 00:13:09,200
hogy a végső kimenet az eredetivel megegyező méretű legyen. A konvolúciók, mint pusztán

156
00:13:09,200 --> 00:13:13,920
matematikai műveletek, mindig olyan tömböt hoznak létre, amely nagyobb, mint a két tömb, amellyel

157
00:13:13,920 --> 00:13:17,520
elkezdte, legalábbis feltételezve, hogy az egyiknek nem egy hosszúsága. Csak tudd, hogy bizonyos

158
00:13:17,520 --> 00:13:21,440
számítástechnikai kontextusokban gyakran akarod szándékosan csonkolni ezt a kimenetet.

159
00:13:21,520 --> 00:13:29,200
Egy másik dolog, amit érdemes kiemelni, hogy számítástechnikai kontextusban az az elképzelés, hogy a

160
00:13:29,200 --> 00:13:34,080
kernelt körül kell forgatni, mielőtt átengednéd az eredetit, gyakran nagyon furcsának és szükségtelennek

161
00:13:34,080 --> 00:13:38,960
tűnik, de ismételten jegyezzük meg, hogy ez az, amit a tiszta matematikai kontextusból

162
00:13:38,960 --> 00:13:44,000
örököltünk. nagy valószínűséggel látta, hogy ez hihetetlenül természetes dolog. És tulajdonképpen mutathatok még egy

163
00:13:44,000 --> 00:13:48,480
tiszta matematikai példát, ahol még a programozóknak is törődniük kell ezzel, mert megnyitja

164
00:13:48,480 --> 00:13:53,760
a kaput egy sokkal gyorsabb algoritmus előtt, amely mindezeket kiszámítja. Ahhoz, hogy beállítsam, mit értek

165
00:13:53,760 --> 00:13:58,560
itt gyorsabb alatt, hadd menjek vissza, és húzzak fel megint egy pythont, és két különböző, viszonylag nagy

166
00:13:58,560 --> 00:14:02,880
tömböt fogok létrehozni. Mindegyikben százezer véletlenszerű elem lesz, és felmérem a

167
00:14:02,880 --> 00:14:08,640
convolve függvény futási idejét a numpy könyvtárból. És ebben az

168
00:14:08,640 --> 00:14:12,800
esetben több különböző iterációra futtatja, megpróbálja megtalálni az átlagot, és úgy tűnik, ezen

169
00:14:12,880 --> 00:14:18,640
a számítógépen legalább 4-es az átlag. 87 másodperc. Ezzel szemben, ha a scipy könyvtártól

170
00:14:18,640 --> 00:14:24,080
eltérő, fftconvolve nevű függvényt használok, ami ugyanaz, csak másképp van megvalósítva, akkor csak

171
00:14:24,080 --> 00:14:30,640
4-et vesz igénybe. Átlagosan 3 ezredmásodperc, tehát három nagyságrendű javulás.

172
00:14:30,640 --> 00:14:34,800
És még egyszer, bár más néven repül, ugyanazt a kimenetet adja, mint

173
00:14:34,800 --> 00:14:38,880
a másik convolve függvény, csak tesz valamit, hogy ügyesebben járjon el.

174
00:14:38,880 --> 00:14:46,800
Emlékezzen arra, hogy a valószínűségi példában azt mondtam, hogy a konvolúció másik módja az volt,

175
00:14:46,800 --> 00:14:51,520
hogy létrehozza ezt a táblázatot az összes páronkénti szorzatról, majd összeadja ezeket a páronkénti szorzatokat

176
00:14:51,520 --> 00:14:56,560
az átlók mentén. Természetesen nincs semmi konkrét a valószínűségre vonatkozóan, amikor két különböző

177
00:14:56,560 --> 00:15:00,880
számlistát von össze, és így gondolhatja át. Hozzon létre egy ilyen szorzótáblát

178
00:15:00,880 --> 00:15:05,520
az összes páronkénti szorzattal, majd az átló mentén minden összeg megfelel az egyik végső

179
00:15:05,520 --> 00:15:11,680
kimenetnek. Az egyik olyan kontextus, ahol ez a nézet különösen természetes, az az, amikor két

180
00:15:11,680 --> 00:15:16,240
polinomot összeszorozunk. Például hadd vegyem a már meglévő kis rácsot, és cseréljem le a felső

181
00:15:16,240 --> 00:15:23,920
tagokat 1, 2x és 3x négyzetre, a többi tagot pedig 4, 5x és 6x négyzetre.

182
00:15:23,920 --> 00:15:27,920
Most gondolja át, mit jelent az, amikor ezeket a különböző páronkénti termékeket hozzuk létre a két

183
00:15:27,920 --> 00:15:32,960
lista között. Amit csinálsz, az lényegében az általam felírt két polinom teljes szorzatának kiterjesztése,

184
00:15:32,960 --> 00:15:38,240
majd amikor összeadod az átló mentén, amely megfelel az összes hasonló kifejezés összegyűjtésének,

185
00:15:38,240 --> 00:15:43,920
ami elég ügyes, egy polinom kiterjesztése és a hasonló kifejezések összegyűjtése pontosan a ugyanaz

186
00:15:43,920 --> 00:15:50,640
a folyamat, mint a konvolúció. De ez lehetővé teszi számunkra, hogy valami nagyon menőt tegyünk,

187
00:15:50,640 --> 00:15:55,360
mert gondoljunk arra, amit itt mondunk. Azt mondjuk, ha veszünk két különböző függvényt,

188
00:15:55,360 --> 00:16:00,560
és összeszorozzuk őket, ami egy egyszerű pontszerű művelet, az ugyanaz, mintha először mindegyikből

189
00:16:00,560 --> 00:16:05,920
kivontuk volna az együtthatókat, feltételezve, hogy ezek polinomok, majd konvolúciót vettünk volna

190
00:16:05,920 --> 00:16:11,840
ezekből. az együtthatók két listája. Az teszi ezt olyan érdekessé, hogy a

191
00:16:11,840 --> 00:16:16,560
konvolúciók elvileg sokkal bonyolultabbnak tűnnek, mint az egyszerű szorzás, és nem csak

192
00:16:16,560 --> 00:16:21,760
fogalmilag értem, hogy nehezebb elgondolkodni rajtuk, hanem számítási szempontból, több lépést igényel

193
00:16:21,760 --> 00:16:27,040
a konvolúció végrehajtása, mint egy két különböző lista pontszerű szorzata. Például tegyük fel,

194
00:16:27,040 --> 00:16:31,920
hogy adtam neked két igazán nagy polinomot, mondjuk mindegyik száz különböző együtthatóval, akkor ha a

195
00:16:32,480 --> 00:16:37,520
szorzás módja ennek a szorzatnak a kibontása volt, akkor tudod, hogy kitöltöd a teljes 100x100-as

196
00:16:37,520 --> 00:16:43,600
páros szorzatok rácsát, amihez szükség lenne végezzen el 10 000 különböző terméket, majd amikor

197
00:16:43,600 --> 00:16:48,560
összegyűjti az összes hasonló kifejezést az átlók mentén, az egy újabb körülbelül 10 000 műveletből

198
00:16:48,560 --> 00:16:55,200
álló halmaz. Általánosabban a nyelvhasználatban azt mondanánk, hogy az algoritmus n négyzetes jelentése O

199
00:16:55,200 --> 00:17:00,560
két n méretű lista esetén, úgy, hogy a műveletek száma arányos n négyzetével.

200
00:17:00,560 --> 00:17:06,320
Másrészt, ha két polinomra gondolok a kimeneteik szempontjából, például mintavételezzük az értékeket

201
00:17:06,320 --> 00:17:11,680
néhány bemenetnél, akkor a szorzásuk csak annyi műveletet igényel, ahány minta van,

202
00:17:11,680 --> 00:17:17,200
mivel ez ismét egy pontszerű művelet, és polinomokkal csak annyi kell. véges

203
00:17:17,200 --> 00:17:22,400
sok mintát, hogy vissza lehessen állítani az együtthatókat. Például két kimenet elegendő

204
00:17:22,400 --> 00:17:27,920
egy lineáris polinom egyedi meghatározásához, három kimenet elegendő lenne egy másodfokú polinom

205
00:17:27,920 --> 00:17:33,680
egyedi meghatározásához, és általában ha n különböző kimenetet ismer, az elegendő egy n

206
00:17:33,680 --> 00:17:38,800
különböző együtthatójú polinom egyedi meghatározásához, vagy ha úgy tetszik, megtehetjük. Fogalmazd meg

207
00:17:38,800 --> 00:17:43,680
ezt az egyenletrendszerek nyelvén. Képzeld el, hogy van egy polinomom, de nem mondom

208
00:17:43,680 --> 00:17:47,840
meg, hogy mik az együtthatók, ezek rejtélyek számodra. Példánkban ezt úgy gondolhatja, mint a

209
00:17:47,840 --> 00:17:52,960
szorzatot, amelyet megpróbálunk kitalálni, majd tegyük fel, hogy azt mondom, hogy csak megmondom, mik lennének

210
00:17:52,960 --> 00:17:59,600
ennek a polinomnak a kimenetei, ha különféle bemeneteket adna meg, például 0, 1, 2 ,

211
00:17:59,600 --> 00:18:04,800
3, tovább és tovább, és adok neked annyit, hogy annyi egyenleted legyen, ahány ismeretlened, sőt

212
00:18:04,800 --> 00:18:09,840
előfordul, hogy lineáris egyenletrendszer, szóval ez szép, és elvileg legalább ennyi elég kell, hogy legyen

213
00:18:09,840 --> 00:18:14,880
az együtthatók visszanyeréséhez.

214
00:18:14,880 --> 00:18:20,160
two lists of numbers you treat them like they're coefficients of two polynomials you sample those

215
00:18:20,160 --> 00:18:26,560
polynomials at enough outputs multiply those samples point-wise and then solve the system

216
00:18:26,560 --> 00:18:32,720
to recover the coefficients as a sneaky backdoor way to find the convolution and as I've stated it

217
00:18:32,720 --> 00:18:38,000
so far at least some of you could rightfully complain grant that is an idiotic plan because

218
00:18:38,000 --> 00:18:43,120
for one thing just calculating all these samples for one of the polynomials we know already takes

219
00:18:43,120 --> 00:18:47,760
on the order of n squared operations not to mention solving that system is certainly going

220
00:18:47,760 --> 00:18:53,520
to be computationally as difficult as just doing the convolution in the first place so like sure

221
00:18:53,520 --> 00:18:58,400
we have this connection between multiplication and convolutions but all of the complexity happens in

222
00:18:58,400 --> 00:19:04,240
translating from one viewpoint to the other but there is a trick and those of you who know about

223
00:19:04,240 --> 00:19:09,200
Fourier transforms and the FFT algorithm might see where this is going if you're unfamiliar with this

224
00:19:09,200 --> 00:19:13,600
topics what I'm about to say might seem completely out of the blue just know that there are certain

225
00:19:13,600 --> 00:19:18,720
paths you could have walked in math that make this more of an expected step basically the idea is

226
00:19:18,720 --> 00:19:23,840
that we have a freedom of choice here if instead of evaluating at some arbitrary set of inputs like

227
00:19:23,840 --> 00:19:30,080
0 1 2 3 on and on you choose to evaluate on a very specially selected set of complex numbers

228
00:19:30,080 --> 00:19:34,400
specifically the ones that sit evenly spaced on the unit circle what are known as the roots of

229
00:19:34,400 --> 00:19:41,600
unity this gives us a friendlier system the basic idea is that by finding a number where taking its

230
00:19:41,600 --> 00:19:46,480
powers falls into this cycling pattern it means that the system we generate is going to have a lot

231
00:19:46,480 --> 00:19:51,360
of redundancy in the different terms that you're calculating and by being clever about how you

232
00:19:51,360 --> 00:19:57,600
leverage that redundancy you can save yourself a lot of work this set of outputs that I've written

233
00:19:57,600 --> 00:20:03,200
has a special name it's called the discrete Fourier transform of the coefficients and if you want to

234
00:20:03,200 --> 00:20:08,160
learn more I actually did another lecture for that same julia mit class all about discrete

235
00:20:08,160 --> 00:20:12,640
Fourier transforms and there's also a really excellent video on the channel reducible talking

236
00:20:12,640 --> 00:20:17,520
about the fast Fourier transform which is an algorithm for computing these more quickly also

237
00:20:17,520 --> 00:20:22,720
veritasium recently did a really good video on fft's so you've got lots of options and that fast

238
00:20:22,720 --> 00:20:28,320
algorithm really is the point for us again because of all this redundancy there exists a method to go

239
00:20:28,320 --> 00:20:33,040
from the coefficients to all of these outputs where instead of doing on the order of n squared

240
00:20:33,040 --> 00:20:38,080
operations you do on the order of n times the log of n operations which is much much better as you

241
00:20:38,080 --> 00:20:43,600
scale to big lists and importantly this fft algorithm goes both ways it also lets you go

242
00:20:43,600 --> 00:20:48,640
from the outputs to the coefficients so bringing it all together let's look back at our algorithm

243
00:20:48,640 --> 00:20:53,200
outline now we can say whenever you're given two long lists of numbers and you want to take their

244
00:20:53,200 --> 00:20:58,960
convolution first compute the fast Fourier transform of each one of them which in the back

245
00:20:58,960 --> 00:21:03,280
of your mind you can just think of as treating them like they're the coefficients of a polynomial

246
00:21:03,280 --> 00:21:08,960
and evaluating it at a very specially selected set of points then multiply together the two results

247
00:21:08,960 --> 00:21:14,480
that you just got point-wise which is nice and fast and then do an inverse fast Fourier transform

248
00:21:14,480 --> 00:21:18,480
and what that gives you is the sneaky backdoor way to compute the convolution that we were looking

249
00:21:18,480 --> 00:21:25,600
for but this time it only involves o of n log n operations that's really cool to me this very

250
00:21:25,600 --> 00:21:30,560
specific context where convolutions show up multiplying two polynomials opens the doors for

251
00:21:30,560 --> 00:21:35,120
an algorithm that's relevant everywhere else where convolutions might come up if you want to add

252
00:21:35,120 --> 00:21:39,600
probability distributions do some large image processing whatever it might be and i just think

253
00:21:39,600 --> 00:21:44,480
that's such a good example of why you should be excited when you see some operation or concept in

254
00:21:44,480 --> 00:21:50,160
math show up in a lot of seemingly unrelated areas if you want a little homework here's

255
00:21:50,160 --> 00:21:54,800
something that's fun to think about explain why when you multiply two different numbers just

256
00:21:54,800 --> 00:21:59,360
ordinary multiplication the way we all learn in elementary school what you're doing is basically

257
00:21:59,360 --> 00:22:04,640
a convolution between the digits of those numbers there's some added steps with carries and the like

258
00:22:04,640 --> 00:22:10,720
but the core step is a convolution in light of the existence of a fast algorithm what that means is

259
00:22:10,720 --> 00:22:16,000
if you have two very large integers then there exists a way to find their product that's faster

260
00:22:16,000 --> 00:22:20,720
than the method we learn in elementary school that instead of requiring o of n squared operations

261
00:22:20,720 --> 00:22:26,320
only requires o of n log n which doesn't even feel like it should be possible the catch is that

262
00:22:26,320 --> 00:22:31,280
before this is actually useful in practice your numbers would have to be absolutely monstrous

263
00:22:31,280 --> 00:22:36,880
but still it's cool that such an algorithm exists and next up we'll turn our attention to the

264
00:22:36,880 --> 00:22:51,040
continuous case with a special focus on probability distributions

