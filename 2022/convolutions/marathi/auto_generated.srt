1
00:00:00,000 --> 00:00:04,480
समजा, मी तुम्हाला संख्यांच्या दोन भिन्न याद्या, किंवा कदाचित दोन भिन्न कार्ये देतो, आणि मी तुम्हाला

2
00:00:04,480 --> 00:00:08,400
संख्यांची नवीन यादी मिळविण्यासाठी त्या दोन याद्या एकत्रित करण्याच्या सर्व मार्गांचा विचार करण्यास सांगतो, किंवा

3
00:00:08,400 --> 00:00:14,000
नवीन कार्य मिळविण्यासाठी दोन कार्ये एकत्र करू शकता. . कदाचित मनात येणारा एक सोपा

4
00:00:14,000 --> 00:00:18,640
मार्ग म्हणजे त्यांना शब्दानुसार एकत्र जोडणे. त्याचप्रमाणे फंक्शन्ससह, तुम्ही सर्व संबंधित आउटपुट

5
00:00:18,640 --> 00:00:24,000
जोडू शकता. अशाच प्रकारे, तुम्ही दोन लिस्ट टर्म टर्मनुसार गुणाकार करू शकता

6
00:00:24,000 --> 00:00:28,720
आणि फंक्शन्ससह समान गोष्ट करू शकता. परंतु या दोन्हींप्रमाणेच आणखी एक प्रकारचा संयोग मूलभूत

7
00:00:28,720 --> 00:00:33,840
आहे, परंतु सामान्यत: फारच कमी चर्चिला जातो, ज्याला कॉन्व्होल्यूशन म्हणून ओळखले जाते.

8
00:00:33,840 --> 00:00:38,240
परंतु मागील दोन प्रकरणांप्रमाणे, ही अशी गोष्ट नाही जी केवळ एका ऑपरेशनमधून मिळालेली आहे जी

9
00:00:38,240 --> 00:00:43,360
तुम्ही संख्यांवर करू शकता. संख्यांच्या याद्या किंवा फंक्शन्स एकत्रित करण्याच्या संदर्भासाठी हे खरोखर

10
00:00:43,360 --> 00:00:49,280
काहीतरी नवीन आहे. ते सर्वत्र दिसून येतात, ते इमेज प्रोसेसिंगमध्ये सर्वव्यापी आहेत, संभाव्यतेच्या सिद्धांतामध्ये

11
00:00:49,280 --> 00:00:53,760
ते एक मूळ रचना आहे, ते विभेदक समीकरणे सोडवण्यासाठी खूप वापरले जातात आणि एक

12
00:00:53,760 --> 00:00:58,240
संदर्भ जिथे तुम्ही जवळजवळ निश्चितपणे पाहिले असेल, जर नसेल तर या नावाने, दोन

13
00:00:58,240 --> 00:01:03,440
बहुपदांचा एकत्र गुणाकार केला जातो. व्हिज्युअल स्पष्टीकरणाच्या व्यवसायातील कोणीतरी म्हणून, हा विशेषतः चांगला विषय

14
00:01:03,440 --> 00:01:08,800
आहे, कारण एकाकी आणि संदर्भाशिवाय फॉर्म्युलाची व्याख्या एक प्रकारची भीतीदायक वाटू शकते, परंतु जर

15
00:01:08,800 --> 00:01:14,080
आपण ते काय म्हणत आहे ते खरोखर अनपॅक करण्यासाठी वेळ काढला आणि त्याआधी प्रत्यक्षात

16
00:01:14,080 --> 00:01:18,800
का प्रेरित केले. तुम्हाला असे काहीतरी हवे आहे, हे आश्चर्यकारकपणे सुंदर ऑपरेशन आहे.

17
00:01:18,800 --> 00:01:22,880
आणि मला हे मान्य करावेच लागेल की, या प्रोजेक्टसाठी व्हिज्युअल्स एकत्र करताना मी खरंच काहीतरी

18
00:01:22,880 --> 00:01:26,960
शिकलो. दोन भिन्न कार्ये एकत्रित करण्याच्या बाबतीत, मी याचा अर्थ काय असू शकतो हे

19
00:01:26,960 --> 00:01:30,720
आपण चित्रित करू शकता अशा वेगवेगळ्या मार्गांनी विचार करण्याचा प्रयत्न करत होतो आणि त्यापैकी एकासह

20
00:01:30,720 --> 00:01:35,840
मला थोडासा अहाहा क्षण मिळाला की सामान्य वितरण ही भूमिका का बजावते. ते संभाव्यतेनुसार

21
00:01:35,840 --> 00:01:40,320
करतात, फंक्शनसाठी ते इतके नैसर्गिक आकार का आहे. पण मी स्वतःहून पुढे जात आहे,

22
00:01:40,320 --> 00:01:44,800
त्यासाठी खूप सेटअप आहे. या व्हिडिओमध्ये, आमचा प्राथमिक फोकस फक्त वेगळ्या केसवर असेल

23
00:01:44,800 --> 00:01:49,920
आणि विशेषत: या गणनेसाठी एक अतिशय अनपेक्षित परंतु अतिशय हुशार अल्गोरिदम तयार करणे.

24
00:01:49,920 --> 00:01:54,400
आणि मी सतत प्रकरणाची चर्चा दुसऱ्या भागात काढेन.

25
00:01:57,840 --> 00:02:03,120
इमेज प्रोसेसिंगच्या उदाहरणांसह ते उघडणे खूप मोहक आहे, कारण ते दृश्यदृष्ट्या सर्वात वेधक

26
00:02:03,120 --> 00:02:06,880
आहेत, परंतु काही सूक्ष्मता आहेत ज्यामुळे प्रतिमा प्रक्रिया केस एकंदरीत कमी प्रतिनिधीत्व

27
00:02:06,880 --> 00:02:11,760
करतात, म्हणून त्याऐवजी संभाव्यतेसह गोष्टी सुरू करूया, आणि विशेषतः साध्या उदाहरणांपैकी एक,

28
00:02:11,760 --> 00:02:15,520
ज्याचा मला खात्री आहे की येथे प्रत्येकाने त्यांच्या जीवनात कधीतरी विचार केला

29
00:02:15,520 --> 00:02:20,320
असेल, जे फासेची जोडी फिरवत आहे आणि विविध भिन्न बेरीज पाहण्याची शक्यता

30
00:02:20,320 --> 00:02:25,600
शोधत आहे. आणि तुम्ही म्हणाल, समस्या नाही, समस्या नाही. तुमच्या प्रत्येक दोन फासेचे सहा

31
00:02:25,600 --> 00:02:31,600
वेगवेगळे संभाव्य परिणाम आहेत, जे आम्हाला एकूण 36 वेगळ्या संभाव्य जोड्या परिणाम देतात आणि जर

32
00:02:31,600 --> 00:02:35,600
आम्ही त्या सर्वांचा विचार केला तर आम्ही मोजू शकतो की किती जोड्या दिलेल्या बेरीज आहेत.

33
00:02:36,240 --> 00:02:41,120
आणि अशा प्रकारे सर्व जोड्या एका ग्रिडमध्ये मांडणे, एक चांगली गोष्ट म्हणजे स्थिर बेरीज

34
00:02:41,120 --> 00:02:47,040
असलेल्या सर्व जोड्या या भिन्न कर्णांपैकी एकासह दृश्यमान आहेत. त्यामुळे त्या प्रत्येक कर्णावर

35
00:02:47,040 --> 00:02:51,920
किती अस्तित्वात आहेत याची मोजणी केल्याने तुम्हाला विशिष्ट बेरीज दिसण्याची शक्यता किती आहे हे सांगेल.

36
00:02:52,880 --> 00:02:57,760
आणि मी म्हणेन, खूप चांगले, खूप चांगले, परंतु आपण त्याच प्रश्नाची कल्पना करू शकणार्‍या इतर कोणत्याही मार्गांचा विचार

37
00:02:57,760 --> 00:03:03,120
करू शकता का? दिलेल्या बेरीज असलेल्या सर्व भिन्न जोड्यांचा विचार करण्यासाठी मनात येऊ शकणार्‍या इतर

38
00:03:03,120 --> 00:03:08,800
प्रतिमा? आणि कदाचित तुमच्यापैकी कोणीतरी तुमचा हात वर करून म्हणेल, हो, माझ्याकडे एक आहे. समजा तुम्ही या दोन

39
00:03:08,800 --> 00:03:14,560
वेगवेगळ्या शक्यतांचे एका ओळीत चित्र काढता, परंतु तुम्ही त्या दुसऱ्या पंक्तीभोवती फिरता. अशा रीतीने

40
00:03:14,560 --> 00:03:20,160
सर्व भिन्न जोड्या ज्या सात रेषा पर्यंत उभ्या जोडतात. आणि जर आपण

41
00:03:20,160 --> 00:03:24,880
ती खालची पंक्ती उजवीकडे सरकवली, तर दोन जोडणारी अनोखी जोडी, सापाचे डोळे,

42
00:03:24,880 --> 00:03:29,680
फक्त संरेखित होतात. आणि जर मी ते एका युनिटवर उजवीकडे झुकवले, तर ज्या जोड्या संरेखित करतात

43
00:03:29,680 --> 00:03:35,440
त्या दोन भिन्न जोड्या असतात ज्या तीन पर्यंत जोडतात. आणि सर्वसाधारणपणे, या खालच्या अॅरेची वेगवेगळी ऑफसेट व्हॅल्यूज,

44
00:03:35,440 --> 00:03:40,320
ज्यांना आठवते की मला प्रथम इकडे तिकडे फ्लिप करावे लागले, दिलेल्या बेरीज असलेल्या सर्व भिन्न जोड्या

45
00:03:40,320 --> 00:03:48,800
उघड करा. संभाव्यतेच्या प्रश्नांनुसार, हे अद्याप विशेषतः मनोरंजक नाही, कारण आम्ही जे काही

46
00:03:48,800 --> 00:03:53,120
करत आहोत ते मोजत आहे की या प्रत्येक श्रेणीमध्ये किती परिणाम आहेत.

47
00:03:53,120 --> 00:03:57,280
परंतु यापैकी प्रत्येक चेहऱ्याला समोर येण्याची समान संधी आहे असे गर्भित गृहीत धरून

48
00:03:57,280 --> 00:04:02,240
आहे. पण जर मी तुम्हाला सांगितले की माझ्याकडे फासांचा एक विशेष संच आहे जो एकसमान नाही? कदाचित

49
00:04:02,240 --> 00:04:06,800
निळ्या डाईकडे येणाऱ्या प्रत्येक चेहऱ्याच्या संभाव्यतेचे वर्णन करणाऱ्या संख्यांचा स्वतःचा संच असेल आणि लाल

50
00:04:06,800 --> 00:04:11,920
रंगाचा स्वतःचा विशिष्ट विशिष्ट संख्यांचा संच असेल. त्या बाबतीत, जर तुम्हाला दोन

51
00:04:11,920 --> 00:04:17,360
दिसण्याची संभाव्यता शोधायची असेल, तर तुम्ही निळ्या रंगाची संभाव्यता लाल रंगाची

52
00:04:17,360 --> 00:04:22,000
असण्याची संभाव्यता एक पटीने गुणाकार कराल. आणि तीन दिसण्याच्या शक्यतेसाठी, तुम्ही दोन

53
00:04:22,000 --> 00:04:26,880
वेगळ्या जोड्यांकडे पहा जेथे ते शक्य आहे, आणि पुन्हा, संबंधित संभाव्यतेचा गुणाकार करा

54
00:04:26,880 --> 00:04:32,240
आणि नंतर ती दोन उत्पादने एकत्र जोडा. त्याचप्रमाणे, चार दिसण्याच्या शक्यतांमध्ये शक्यतांच्या तीन

55
00:04:32,240 --> 00:04:36,320
भिन्न जोड्या एकत्र गुणाकार करणे आणि त्या सर्व एकत्र जोडणे समाविष्ट

56
00:04:36,320 --> 00:04:41,360
आहे. आणि काही सूत्रे सेट करण्याच्या भावनेने, या वरच्या संभाव्यतेला a1, a2, a3 आणि असेच नाव देऊ या

57
00:04:41,360 --> 00:04:48,000
आणि खालच्या संभाव्यांना b1, b2, b3 आणि असेच नाव देऊ या. आणि सर्वसाधारणपणे, ही प्रक्रिया, जिथे

58
00:04:48,000 --> 00:04:52,080
आपण संख्यांचे दोन वेगवेगळे अॅरे घेत आहोत, दुसऱ्याला आजूबाजूला फ्लिप करत आहोत, आणि नंतर

59
00:04:52,080 --> 00:04:56,160
त्यांना वेगवेगळ्या ऑफसेट व्हॅल्यूजवर लाइनअप करत आहोत, पेअरवाइज उत्पादनांचा एक गुच्छ घेतो आणि

60
00:04:56,160 --> 00:05:00,960
त्यांना जोडतो, ही त्यापैकी एक आहे संभ्रम म्हणजे काय याचा विचार करण्याचे मूलभूत मार्ग.

61
00:05:00,960 --> 00:05:08,960
तर फक्त त्याचे थोडे अधिक अचूक शब्दलेखन करण्यासाठी, या प्रक्रियेद्वारे, आम्ही फक्त 12 पर्यंत दोन, तीन,

62
00:05:08,960 --> 00:05:13,840
चार, वर आणि वर पाहण्यासाठी संभाव्यता निर्माण केली आणि आम्ही मूल्यांची एक सूची, a आणि

63
00:05:13,840 --> 00:05:20,080
दुसरी एकत्र करून ती मिळवली. मूल्यांची यादी, b. लिंगोमध्ये, आम्ही असे म्हणू की त्या दोन

64
00:05:20,080 --> 00:05:25,600
अनुक्रमांच्या संचलनामुळे आम्हाला हा नवीन क्रम, 11 मूल्यांचा नवीन क्रम मिळतो, ज्यापैकी प्रत्येक जोडी

65
00:05:25,600 --> 00:05:30,160
उत्पादनांच्या काही बेरीजसारखे दिसते. तुम्ही प्राधान्य दिल्यास, त्याच ऑपरेशनबद्दल तुम्ही विचार करू शकता असा

66
00:05:30,160 --> 00:05:36,240
दुसरा मार्ग म्हणजे प्रथम सर्व जोडीच्या उत्पादनांची सारणी तयार करणे, आणि नंतर या सर्व कर्णांसह

67
00:05:36,240 --> 00:05:41,120
जोडणे. पुन्हा, 11 संख्यांचा एक नवीन क्रम मिळवण्यासाठी संख्यांच्या या दोन अनुक्रमांचे मिश्रण करण्याचा हा

68
00:05:41,120 --> 00:05:46,400
एक मार्ग आहे. हे स्लाइडिंग विंडोंप्रमाणेच ऑपरेशन आहे, फक्त दुसरा दृष्टीकोन.

69
00:05:46,960 --> 00:05:51,280
त्यावर थोडेसे नोटेशन टाकून, तुम्हाला ते कसे लिहिलेले दिसेल ते येथे आहे. या छोट्या तारकाने दर्शविलेले

70
00:05:51,280 --> 00:05:57,200
a आणि b चे संचलन ही एक नवीन यादी आहे आणि त्या यादीतील nवा घटक बेरीज सारखा

71
00:05:57,200 --> 00:06:03,440
दिसतो आणि ती बेरीज सर्व वेगवेगळ्या निर्देशांकांच्या i आणि j वर जाते, जेणेकरून बेरीज ते निर्देशांक n

72
00:06:03,440 --> 00:06:09,440
च्या समान आहेत. हे एक प्रकारचे तोंडी आहे, परंतु उदाहरणार्थ, जर n 6 असेल, तर आपण 1 आणि 5,

73
00:06:09,440 --> 00:06:15,680
2 आणि 4, 3 आणि 3, 4 आणि 2, 5 आणि 1 या सर्व वेगवेगळ्या जोड्या जोडत आहोत. ते 6.

74
00:06:16,400 --> 00:06:20,640
पण प्रामाणिकपणे, तुम्ही ते लिहून ठेवले तरी, या प्रक्रियेसाठी तुम्ही तुमच्या डोक्यात धारण करू

75
00:06:20,640 --> 00:06:26,320
शकणार्‍या व्हिज्युअलसाठी नोटेशनचे महत्त्व दुय्यम आहे. येथे, कदाचित हे एक अतिशय साधे उदाहरण करण्यास मदत करेल, जिथे मी

76
00:06:26,320 --> 00:06:32,000
तुम्हाला विचारू शकतो की यादी 1, 2, 3 ची यादी 4, 5, 6 सह काय आहे. तुम्ही या दोन्ही

77
00:06:32,000 --> 00:06:36,160
याद्या घेऊन, त्या दुस-या भोवती फिरत, आणि नंतर त्याच्या झाकणाने डावीकडे सर्व

78
00:06:36,160 --> 00:06:41,200
मार्गाने सुरुवात करत असाल. मग मूल्यांची जोडी जी 1 आणि 4 संरेखित करतात, त्यांना एकत्र गुणाकार

79
00:06:41,200 --> 00:06:45,680
करतात आणि ते आम्हाला आमच्या आउटपुटची पहिली टर्म देते. त्या खालच्या अॅरेचे एक युनिट उजवीकडे सरकवा, 1

80
00:06:45,680 --> 00:06:51,840
आणि 5 आणि 2 आणि 4 अशा जोड्या संरेखित करा, त्या जोड्या गुणाकार करा, त्यांना एकत्र जोडा, आणि ते

81
00:06:51,840 --> 00:06:57,600
आम्हाला 13 देते, आमच्या आउटपुटमध्ये पुढील एंट्री. गोष्टी पुन्हा एकदा सरकवा, आणि आम्ही 1 गुणिले 6, अधिक 2

82
00:06:57,600 --> 00:07:04,400
गुणिले 5, अधिक 3 गुणिले 4 घेऊ, जे 28 होईल. आणखी एक स्लाइड, आणि आम्हाला 2 गुणिले 6,

83
00:07:04,400 --> 00:07:10,000
अधिक 3 गुणिले 5 मिळेल, आणि ते आम्हाला 27 देते, आणि शेवटी शेवटची संज्ञा 3 गुणिले 6 सारखी दिसेल.

84
00:07:10,560 --> 00:07:14,080
तुमची इच्छा असल्यास, तुमची आवडती प्रोग्रॅमिंग भाषा आणि तुमची आवडती लायब्ररी ज्यामध्ये विविध संख्यात्मक ऑपरेशन्स समाविष्ट

85
00:07:14,080 --> 00:07:18,640
आहेत, तुम्ही खेचू शकता आणि मी तुमच्याशी खोटे बोलत नाही याची तुम्ही पुष्टी करू शकता.

86
00:07:18,640 --> 00:07:24,320
जर तुम्ही 1, 2, 3, 4, 5, 6 च्या विरुद्ध 4, 5, 6 चे परिभ्रमण घेतले, तर हा परिणाम तुम्हाला मिळेल.

87
00:07:24,880 --> 00:07:29,200
आम्ही एक केस पाहिली आहे जिथे हे नैसर्गिक आणि इष्ट ऑपरेशन आहे, संभाव्यता वितरणास

88
00:07:29,200 --> 00:07:34,640
जोडून, आणि दुसरे सामान्य उदाहरण म्हणजे मूव्हिंग एव्हरेज असेल. कल्पना करा की तुमच्याकडे संख्यांची काही लांबलचक

89
00:07:34,640 --> 00:07:39,920
यादी आहे आणि तुम्ही संख्यांची आणखी एक छोटी यादी घ्या जी सर्व 1 पर्यंत जोडली जाईल. या प्रकरणात, माझ्याकडे फक्त 5

90
00:07:39,920 --> 00:07:45,280
मूल्यांची एक छोटी यादी आहे, आणि ती सर्व 1 5व्या समान आहेत. मग जर आपण ही स्लाइडिंग विंडो

91
00:07:45,280 --> 00:07:49,760
कॉन्व्होल्युशन प्रक्रिया केली आणि आपले डोळे बंद केले आणि त्याच्या सुरवातीला जे घडते ते गालिच्याखाली

92
00:07:50,560 --> 00:07:55,120
स्वीप केले, एकदा आपली लहान मूल्यांची सूची मोठ्या मूल्याशी पूर्णपणे ओव्हरलॅप झाली की, यातील प्रत्येक

93
00:07:55,680 --> 00:08:01,120
पद काय आहे याचा विचार करा. convolution म्हणजे खरोखर. प्रत्येक पुनरावृत्तीवर, तुम्ही जे करत आहात

94
00:08:01,120 --> 00:08:06,400
ते म्हणजे तुमच्या डेटामधील प्रत्येक मूल्याचा 1 5 व्या ने गुणाकार करणे आणि ते सर्व एकत्र

95
00:08:06,400 --> 00:08:12,080
जोडणे, म्हणजे तुम्ही या छोट्या विंडोमध्ये तुमचा डेटा सरासरी घेत आहात. एकूणच, ही प्रक्रिया तुम्हाला

96
00:08:12,080 --> 00:08:16,800
मूळ डेटाची एक गुळगुळीत आवृत्ती देते, आणि तुम्ही संख्यांच्या वेगळ्या छोट्या सूचीपासून हे

97
00:08:16,800 --> 00:08:21,280
बदल करू शकता आणि जोपर्यंत ती छोटी यादी 1 पर्यंत जोडते, तोपर्यंत तुम्ही त्याचा

98
00:08:21,280 --> 00:08:25,840
अर्थ बदलू शकता. सरासरी येथे दर्शविलेल्या उदाहरणामध्ये, ती हलणारी सरासरी मध्यवर्ती

99
00:08:25,840 --> 00:08:30,720
मूल्याकडे अधिक वजन देते. याचा परिणाम डेटाच्या स्मूथ आउट आवृत्तीमध्ये देखील होतो.

100
00:08:33,200 --> 00:08:37,840
जर तुम्ही याचे द्विमितीय अॅनालॉग केले तर ते तुम्हाला दिलेल्या इमेजला अस्पष्ट करण्यासाठी एक मजेदार

101
00:08:37,840 --> 00:08:43,120
अल्गोरिदम देते. आणि मी जे अॅनिमेशन दाखवणार आहे ते मी मूळत: एमआयटी येथील ज्युलिया

102
00:08:43,120 --> 00:08:48,160
लॅबमध्ये एका विशिष्ट OpenCourseWare क्लाससाठी केलेल्या व्याख्यानांच्या संचाच्या भागासाठी बनवलेल्या गोष्टींमधून सुधारित केले आहे,

103
00:08:48,160 --> 00:08:52,320
ज्यामध्ये इमेज प्रोसेसिंग युनिट समाविष्ट आहे असे म्हणायला हवे. तेथे आम्ही या सर्वांच्या मागे असलेल्या कोडमध्ये

104
00:08:52,320 --> 00:08:56,640
जाण्यासाठी थोडे अधिक केले आहे, म्हणून जर तुम्ही उत्सुक असाल तर मी तुम्हाला काही लिंक देईन. परंतु

105
00:08:56,640 --> 00:09:01,440
या अस्पष्ट उदाहरणावर परत लक्ष केंद्रित करताना, काय चालले आहे ते म्हणजे माझ्या मूळ प्रतिमेच्या बाजूने

106
00:09:01,440 --> 00:09:06,480
चालत असलेल्या मूल्यांचा हा छोटासा 3x3 ग्रिड आहे आणि जर आपण झूम इन केले तर त्यातील

107
00:09:06,480 --> 00:09:11,120
प्रत्येक मूल्य 1 9वी आहे आणि मी काय करत आहे. प्रत्येक पुनरावृत्तीवर त्या प्रत्येक व्हॅल्यूला ते

108
00:09:11,120 --> 00:09:16,080
शीर्षस्थानी असलेल्या संबंधित पिक्सेलने गुणाकारत आहे. आणि अर्थातच संगणक शास्त्रामध्ये आपण रंगांना

109
00:09:16,080 --> 00:09:20,400
लाल, हिरवे आणि निळे या तीन मूल्यांचे छोटे वेक्टर समजतो.

110
00:09:20,400 --> 00:09:25,440
जेव्हा मी या सर्व लहान मूल्यांना 1 9 व्या ने गुणाकार करतो आणि मी त्यांना एकत्र जोडतो, तेव्हा

111
00:09:25,440 --> 00:09:30,480
ते आम्हाला प्रत्येक रंग चॅनेलसह सरासरी देते आणि उजवीकडील प्रतिमेसाठी संबंधित पिक्सेल ही बेरीज म्हणून परिभाषित केले

112
00:09:30,480 --> 00:09:36,320
जाते. एकंदरीत परिणाम, जसे की आपण प्रतिमेवरील प्रत्येक पिक्सेलसाठी हे करतो, प्रत्येक एक

113
00:09:36,320 --> 00:09:40,880
प्रकारचा त्याच्या सर्व शेजारी रक्तस्त्राव होतो, ज्यामुळे आम्हाला मूळपेक्षा अस्पष्ट आवृत्ती मिळते.

114
00:09:41,680 --> 00:09:46,640
लिंगोमध्ये आपण असे म्हणू की उजवीकडील प्रतिमा ही आपल्या मूळ प्रतिमेची थोडीशी मूल्ये असलेली

115
00:09:46,640 --> 00:09:52,000
प्रतिमा आहे. किंवा अधिक तांत्रिकदृष्ट्या कदाचित मला असे म्हणायचे आहे की हे मूल्यांच्या

116
00:09:52,000 --> 00:09:56,160
त्या छोट्या ग्रिडच्या 180 अंश फिरवलेल्या आवृत्तीसह आहे. ग्रिड सममितीय आहे हे महत्त्वाचे

117
00:09:56,160 --> 00:10:00,720
नाही, परंतु हे लक्षात ठेवण्यासारखे आहे की शुद्ध गणिताच्या संदर्भातून वारशाने मिळालेल्या

118
00:10:00,720 --> 00:10:05,760
कॉन्व्होल्युशनची व्याख्या नेहमी तुम्हाला त्या दुसऱ्या अॅरेभोवती फिरण्याचा विचार करण्यास आमंत्रित करते.

119
00:10:05,760 --> 00:10:10,240
जर आपण यात थोडासा बदल केला तर भिन्न मूल्यांचा ग्रिड निवडून आपल्याला अधिक मोहक अस्पष्ट प्रभाव

120
00:10:10,240 --> 00:10:15,920
मिळू शकतो. या प्रकरणात माझ्याकडे थोडे 5x5 ग्रिड आहे, परंतु फरक त्याच्या आकारात इतका नाही.

121
00:10:15,920 --> 00:10:19,920
जर आपण झूम इन केले तर आपल्या लक्षात येते की मध्यभागी असलेले मूल्य हे कडांच्या दिशेने असलेल्या मूल्यापेक्षा

122
00:10:19,920 --> 00:10:25,360
खूप मोठे आहे आणि हे कोठून येत आहे ते सर्व बेल वक्र, गौसियन वितरण म्हणून ओळखले जाणारे

123
00:10:25,360 --> 00:10:30,240
नमुना आहेत. अशा प्रकारे जेव्हा आपण या सर्व मूल्यांचा ते वर बसलेल्या संबंधित पिक्सेलने गुणाकार

124
00:10:30,240 --> 00:10:35,200
करतो, तेव्हा आपण त्या मध्यवर्ती पिक्सेलला खूप जास्त वजन देतो आणि काठावर असलेल्या पिक्सेलला

125
00:10:35,200 --> 00:10:39,920
खूप कमी देतो. आणि उजवीकडील संबंधित पिक्सेलच्या आधी ही बेरीज म्हणून परिभाषित केली

126
00:10:39,920 --> 00:10:45,360
आहे. आम्ही प्रत्येक पिक्सेलसाठी ही प्रक्रिया करत असताना ते एक अस्पष्ट प्रभाव देते जे

127
00:10:45,360 --> 00:10:49,760
अधिक प्रमाणिकपणे तुमच्या लेन्सला फोकसच्या बाहेर ठेवण्याच्या कल्पनेचे अनुकरण करते किंवा असे काहीतरी करते.

128
00:10:49,760 --> 00:10:54,960
परंतु अस्पष्ट करणे ही एकमेव गोष्ट आहे जी आपण या कल्पनेसह करू शकता. उदाहरणार्थ, मूल्यांच्या या छोट्या ग्रिडवर

129
00:10:54,960 --> 00:10:59,600
एक नजर टाका, ज्यात डावीकडे काही सकारात्मक संख्या आणि उजवीकडे काही ऋण संख्या समाविष्ट

130
00:10:59,600 --> 00:11:04,480
आहेत, ज्यांना मी अनुक्रमे निळा आणि लाल रंग देईन. याचा अंतिम प्रतिमेवर काय परिणाम

131
00:11:04,480 --> 00:11:11,680
होईल याचा अंदाज आणि समजू शकतो का ते पाहण्यासाठी थोडा वेळ द्या. तर या प्रकरणात मी

132
00:11:11,680 --> 00:11:16,560
चित्राचा रंगीत ऐवजी ग्रेस्केल म्हणून विचार करेन, म्हणून प्रत्येक पिक्सेल तीन ऐवजी फक्त

133
00:11:16,560 --> 00:11:21,280
एका संख्येने दर्शविला जाईल. आणि एक गोष्ट लक्षात घेण्यासारखी आहे की आपण हे कव्होल्यूशन करत असताना

134
00:11:21,280 --> 00:11:26,240
नकारात्मक मूल्ये मिळणे शक्य आहे. उदाहरणार्थ या टप्प्यावर जर आपण आपल्या छोट्या ग्रिडच्या डाव्या

135
00:11:26,240 --> 00:11:30,960
अर्ध्या भागामध्ये झूम केला तर पूर्णपणे काळ्या पिक्सेलच्या शीर्षस्थानी बसतो, ज्याचे मूल्य शून्य असेल,

136
00:11:30,960 --> 00:11:35,360
परंतु उजव्या निगेटिव्ह व्हॅल्यूचा अर्धा भाग पांढर्‍या पिक्सेलच्या वर बसेल, एक मूल्य आहे.

137
00:11:36,000 --> 00:11:40,960
म्हणून जेव्हा आपण संबंधित संज्ञांचा गुणाकार करतो आणि त्यांना एकत्र जोडतो तेव्हा परिणाम खूप नकारात्मक होतील आणि

138
00:11:40,960 --> 00:11:45,120
मी ज्या प्रकारे हे उजवीकडील प्रतिमेसह प्रदर्शित करत आहे ते म्हणजे नकारात्मक मूल्यांना लाल आणि सकारात्मक मूल्यांना

139
00:11:45,120 --> 00:11:49,520
निळा रंग देणे. आणखी एक गोष्ट लक्षात घेण्यासारखी आहे की जेव्हा तुम्ही एकाच रंगाच्या पॅचवर असता

140
00:11:49,520 --> 00:11:55,680
तेव्हा सर्व काही शून्यावर जाते कारण आमच्या छोट्या ग्रिडमधील मूल्यांची बेरीज शून्य असते. हे मागील

141
00:11:55,680 --> 00:11:59,680
दोन उदाहरणांपेक्षा खूप वेगळे आहे जेथे आमच्या छोट्या ग्रिडची बेरीज एक होती, ज्यामुळे आपण त्याचा

142
00:11:59,680 --> 00:12:05,760
मूव्हिंग एव्हरेज म्हणून अर्थ लावू आणि त्यामुळे अस्पष्ट. या सर्व छोट्या प्रक्रियेत मुळात तुम्ही

143
00:12:05,760 --> 00:12:10,240
डावीकडून उजवीकडे जाताना पिक्सेल मूल्यामध्ये कुठेही फरक असेल ते शोधून काढले जाते आणि

144
00:12:10,240 --> 00:12:13,760
त्यामुळे तुम्हाला तुमच्या प्रतिमेतील सर्व उभ्या किनारी उचलण्याचा एक प्रकारचा मार्ग मिळतो.

145
00:12:16,560 --> 00:12:20,960
आणि त्याचप्रमाणे जर आपण तो ग्रिड फिरवला की आपण वरपासून खालपर्यंत जाताना ते

146
00:12:20,960 --> 00:12:26,000
बदलत जाईल, हे सर्व आडव्या कडा वर उचलले जाईल, जे आपल्या लहान पाई

147
00:12:26,000 --> 00:12:31,520
प्राण्याच्या प्रतिमेच्या बाबतीत काही सुंदर राक्षसी डोळ्यांमध्ये परिणाम करतात. तसे, या लहान ग्रिडला बर्‍याचदा

148
00:12:31,520 --> 00:12:36,160
कर्नल म्हटले जाते, आणि येथे सौंदर्य हे आहे की भिन्न कर्नल निवडून तुम्ही भिन्न प्रतिमा प्रक्रिया

149
00:12:36,160 --> 00:12:40,240
प्रभाव कसे मिळवू शकता, केवळ तुमची किनार ओळखणे अस्पष्ट नाही तर तीक्ष्ण करण्यासारख्या गोष्टी देखील मिळवू

150
00:12:40,240 --> 00:12:44,800
शकता. तुमच्यापैकी ज्यांनी कन्व्होल्युशनल न्यूरल नेटवर्कबद्दल ऐकले आहे त्यांच्यासाठी न्यूरल नेटवर्कला जे

151
00:12:44,800 --> 00:12:49,600
काही शोधायचे आहे त्यावरून निर्धारित केल्यानुसार कर्नल काय असावेत हे शोधण्यासाठी

152
00:12:49,600 --> 00:12:55,120
डेटा वापरण्याची कल्पना आहे. दुसरी गोष्ट मी कदाचित आणली पाहिजे ती म्हणजे आउटपुटची लांबी.

153
00:12:55,120 --> 00:12:59,040
मूव्हिंग अॅव्हरेज उदाहरणासारख्या गोष्टीसाठी तुम्ही फक्त अटींबद्दल विचार करू शकता जेव्हा

154
00:12:59,040 --> 00:13:04,080
दोन्ही विंडो पूर्णपणे एकमेकांशी संरेखित होतात किंवा इमेज प्रोसेसिंगच्या उदाहरणामध्ये कदाचित

155
00:13:04,080 --> 00:13:09,200
तुम्हाला अंतिम आउटपुटचा आकार मूळ सारखाच हवा असेल. आता प्युअर मॅथ ऑपरेशन

156
00:13:09,200 --> 00:13:13,920
म्‍हणून कॉन्व्होल्यूशन्‍स नेहमी तुम्‍ही सुरू करण्‍याच्‍या दोन अॅरेपेक्षा मोठा अ‍ॅरे तयार करतात,

157
00:13:13,920 --> 00:13:17,520
किमान त्‍यापैकी एकाची लांबी नाही असे गृहीत धरून. फक्त हे जाणून घ्या

158
00:13:17,520 --> 00:13:21,440
की काही संगणक विज्ञान संदर्भांमध्ये तुम्हाला ते आउटपुट जाणीवपूर्वक कापायचे असते.

159
00:13:21,520 --> 00:13:29,200
आणखी एक गोष्ट अधोरेखित करण्यासारखी आहे की संगणक विज्ञानाच्या संदर्भात त्या कर्नलला मूळ

160
00:13:29,200 --> 00:13:34,080
ओलांडून पुढे जाण्याआधी त्याभोवती फिरण्याची ही कल्पना अनेकदा खरोखरच विचित्र आणि केवळ अप्रत्याशित

161
00:13:34,080 --> 00:13:38,960
वाटते, परंतु पुन्हा लक्षात घ्या की शुद्ध गणिताच्या संदर्भातून हाच वारसा मिळाला आहे.

162
00:13:38,960 --> 00:13:44,000
संभाव्यतेसह पाहिले की ही एक आश्चर्यकारकपणे नैसर्गिक गोष्ट आहे. आणि खरं तर मी तुम्हाला

163
00:13:44,000 --> 00:13:48,480
आणखी एक शुद्ध गणिताचे उदाहरण दाखवू शकतो जिथे प्रोग्रामरने देखील याची काळजी घेतली पाहिजे कारण

164
00:13:48,480 --> 00:13:53,760
ते या सर्वांची गणना करण्यासाठी खूप वेगवान अल्गोरिदमसाठी दरवाजे उघडते. येथे मला काय म्हणायचे आहे

165
00:13:53,760 --> 00:13:58,560
ते अधिक जलद सेट करण्यासाठी मी परत जाऊ आणि काही अजगर पुन्हा खेचू आणि मी दोन भिन्न तुलनेने मोठे

166
00:13:58,560 --> 00:14:02,880
अॅरे तयार करणार आहे. प्रत्येकामध्ये एक लाख यादृच्छिक घटक असतील आणि मी

167
00:14:02,880 --> 00:14:08,640
numpy लायब्ररीतून convolve फंक्शनच्या रनटाइमचे मूल्यांकन करणार आहे. आणि या प्रकरणात

168
00:14:08,640 --> 00:14:12,800
ते एकाधिक वेगवेगळ्या पुनरावृत्तीसाठी चालवते, सरासरी शोधण्याचा प्रयत्न करते आणि या संगणकावर

169
00:14:12,880 --> 00:14:18,640
किमान 4 वर सरासरी असे दिसते. 87 सेकंद. याउलट जर मी स्किपी लायब्ररीमधील fftconvolve

170
00:14:18,640 --> 00:14:24,080
नावाचे वेगळे फंक्शन वापरत असलो तर तीच गोष्ट वेगळ्या पद्धतीने अंमलात आणली जाते

171
00:14:24,080 --> 00:14:30,640
जी फक्त 4 घेते. सरासरी 3 मिलीसेकंद, त्यामुळे परिमाण सुधारण्याचे तीन ऑर्डर.

172
00:14:30,640 --> 00:14:34,800
आणि जरी ते वेगळ्या नावाने उडत असले तरी ते इतर कॉन्व्हॉल्व्ह फंक्शन

173
00:14:34,800 --> 00:14:38,880
प्रमाणेच आउटपुट देत आहे, ते फक्त त्याबद्दल अधिक हुशारीने काहीतरी करत आहे.

174
00:14:38,880 --> 00:14:46,800
लक्षात ठेवा की संभाव्यतेच्या उदाहरणासह मी म्हटल्याचा दुसरा मार्ग म्हणजे तुम्ही कन्व्होल्यूशनचा विचार करू शकता

175
00:14:46,800 --> 00:14:51,520
तो म्हणजे सर्व पेअरवाइज उत्पादनांचे हे टेबल तयार करणे आणि नंतर ती पेअरवाइज उत्पादने

176
00:14:51,520 --> 00:14:56,560
कर्णरेषांसह जोडणे. तुम्ही अशा प्रकारे विचार करू शकता अशा संख्येच्या दोन भिन्न याद्या तुम्ही

177
00:14:56,560 --> 00:15:00,880
गुंतवून ठेवता तेव्हा संभाव्यतेसाठी अर्थातच काही विशिष्ट नाही. सर्व जोड्यानिहाय उत्पादनांसह अशा प्रकारचे गुणाकार

178
00:15:00,880 --> 00:15:05,520
सारणी तयार करा आणि नंतर कर्णाच्या बाजूची प्रत्येक बेरीज तुमच्या अंतिम आउटपुटपैकी एकाशी संबंधित

179
00:15:05,520 --> 00:15:11,680
असेल. एक संदर्भ जेथे हे दृश्य विशेषतः नैसर्गिक आहे जेव्हा तुम्ही दोन बहुपदी एकत्र

180
00:15:11,680 --> 00:15:16,240
गुणाकार करता. उदाहरणार्थ मी आमच्याकडे आधीपासून असलेली छोटी ग्रिड घेऊ आणि वरच्या संज्ञा 1,

181
00:15:16,240 --> 00:15:23,920
2x आणि 3x स्क्वेअरने बदलू आणि इतर संज्ञा 4, 5x आणि 6x स्क्वेअरने बदलू.

182
00:15:23,920 --> 00:15:27,920
आता आपण दोन सूचींमध्ये ही सर्व भिन्न जोडी उत्पादने तयार करत असताना याचा अर्थ काय याचा

183
00:15:27,920 --> 00:15:32,960
विचार करा. तुम्ही जे करत आहात ते मूलत: मी लिहिलेल्या दोन बहुपदींच्या पूर्ण उत्पादनाचा विस्तार

184
00:15:32,960 --> 00:15:38,240
करत आहे आणि नंतर जेव्हा तुम्ही कर्ण सोबत जोडता जे सर्व सारख्या संज्ञा एकत्रित

185
00:15:38,240 --> 00:15:43,920
करण्याशी संबंधित आहे जे अतिशय व्यवस्थित आहे बहुपदीचा विस्तार करणे आणि अटींसारख्या संकलित करणे हे

186
00:15:43,920 --> 00:15:50,640
नक्की आहे. एक convolution सारखीच प्रक्रिया. परंतु हे आम्हाला खूप छान असे काहीतरी करण्यास अनुमती देते कारण

187
00:15:50,640 --> 00:15:55,360
आम्ही येथे काय म्हणत आहोत याचा विचार करा. आम्ही म्हणतो की तुम्ही दोन भिन्न फंक्शन्स घेतलीत आणि

188
00:15:55,360 --> 00:16:00,560
तुम्ही त्यांचा एकत्र गुणाकार करत असाल जे एक साधे पॉइंटवाइज ऑपरेशन आहे जे तुम्ही

189
00:16:00,560 --> 00:16:05,920
प्रथम बहुपदी आहेत असे गृहीत धरलेल्या प्रत्येकाचे गुणांक काढले असतील आणि नंतर त्यांचे एक

190
00:16:05,920 --> 00:16:11,840
परिभ्रमण घेतले असेल. गुणकांच्या दोन सूची. हे इतके मनोरंजक काय आहे की कॉन्व्होल्यूशन

191
00:16:11,840 --> 00:16:16,560
हे तत्त्वतः साध्या गुणाकारापेक्षा खूपच क्लिष्ट वाटते आणि मला असे म्हणायचे नाही

192
00:16:16,560 --> 00:16:21,760
की संकल्पनात्मकदृष्ट्या ते विचार करणे कठिण आहे, म्हणजे गणनेच्या दृष्टीने कंव्होल्यूशन करण्यासाठी

193
00:16:21,760 --> 00:16:27,040
अधिक पायऱ्या आवश्यक आहेत. दोन भिन्न सूचींचे पॉइंटवार उत्पादन. उदाहरणार्थ, समजा की

194
00:16:27,040 --> 00:16:31,920
मी तुम्हाला दोन खरोखरच मोठ्या बहुपदी दिल्या आहेत प्रत्येक शंभर भिन्न गुणांकांसह म्हणा, मग

195
00:16:32,480 --> 00:16:37,520
जर तुम्ही त्यांचा गुणाकार करण्याच्या पद्धतीनुसार या उत्पादनाचा विस्तार कराल तर तुम्हाला हे संपूर्ण

196
00:16:37,520 --> 00:16:43,600
100 बाय 100 ग्रिडमध्ये पेअरवाइज उत्पादनांचे ग्रिड भरावे लागेल. 10,000 भिन्न उत्पादने करा आणि

197
00:16:43,600 --> 00:16:48,560
नंतर जेव्हा तुम्ही कर्णांसह सर्व समान संज्ञा एकत्रित करता तेव्हा सुमारे 10,000 ऑपरेशन्सचा दुसरा

198
00:16:48,560 --> 00:16:55,200
संच आहे. सामान्यतः लिंगोमध्ये आपण असे म्हणू शकतो की अल्गोरिदम हे n स्क्वेअरचा O आहे

199
00:16:55,200 --> 00:17:00,560
म्हणजे आकाराच्या दोन सूचीसाठी n ज्या प्रकारे ऑपरेशन स्केलची संख्या n च्या वर्गाच्या प्रमाणात असते.

200
00:17:00,560 --> 00:17:06,320
दुसरीकडे, जर मी त्यांच्या आउटपुटच्या संदर्भात दोन बहुपदांचा विचार करतो, उदाहरणार्थ, काही मूठभर इनपुटवर

201
00:17:06,320 --> 00:17:11,680
त्यांची मूल्ये सॅम्पल करणे, तर त्यांचा गुणाकार करण्यासाठी पुन्हा नमुन्यांची संख्या जितकी ऑपरेशन्स आवश्यक

202
00:17:11,680 --> 00:17:17,200
आहेत तितकीच ऑपरेशन्सची आवश्यकता आहे आणि ते पॉईंटवाइज ऑपरेशन आहे आणि आपल्याला फक्त बहुपदांसह

203
00:17:17,200 --> 00:17:22,400
आवश्यक आहे. गुणांक पुनर्प्राप्त करण्यात सक्षम होण्यासाठी निश्चितपणे अनेक नमुने. उदाहरणार्थ एक रेखीय बहुपदी

204
00:17:22,400 --> 00:17:27,920
अद्वितीयपणे निर्दिष्ट करण्यासाठी दोन आउटपुट पुरेसे आहेत तीन आउटपुट एक चतुर्भुज बहुपदी अद्वितीयपणे निर्दिष्ट करण्यासाठी पुरेसे

205
00:17:27,920 --> 00:17:33,680
आहेत आणि सर्वसाधारणपणे जर तुम्हाला n वेगळे आउटपुट माहित असतील जे भिन्न गुणांक असलेल्या बहुपदी

206
00:17:33,680 --> 00:17:38,800
विशिष्टपणे निर्दिष्ट करण्यासाठी पुरेसे आहेत किंवा आपण प्राधान्य दिल्यास आम्ही करू शकतो. समीकरणांच्या प्रणालींच्या भाषेत हे

207
00:17:38,800 --> 00:17:43,680
वाक्यांश कल्पना करा मी तुम्हाला सांगतो की माझ्याकडे काही बहुपदी आहेत परंतु मी तुम्हाला सांगत

208
00:17:43,680 --> 00:17:47,840
नाही की गुणांक काय आहेत ते तुमच्यासाठी एक रहस्य आहे. आमच्या उदाहरणात तुम्ही हे उत्पादन म्हणून

209
00:17:47,840 --> 00:17:52,960
विचार करू शकता जे आम्ही शोधण्याचा प्रयत्न करत आहोत आणि नंतर समजा मी तुम्हाला सांगेन की

210
00:17:52,960 --> 00:17:59,600
तुम्ही 0, 1, 2 सारखे विविध इनपुट इनपुट केल्यास या बहुपदीचे आउटपुट काय असतील. , 3,

211
00:17:59,600 --> 00:18:04,800
चालू आणि चालू आणि मी तुम्हाला पुरेशी देतो जेणेकरून तुमच्याकडे जितकी समीकरणे असतील तितकी तुम्हाला माहिती

212
00:18:04,800 --> 00:18:09,840
नाही, ती समीकरणांची एक रेखीय प्रणाली देखील बनते जेणेकरून ते छान आहे आणि तत्त्वतः हे गुणांक पुनर्प्राप्त

213
00:18:09,840 --> 00:18:14,880
करण्यासाठी पुरेसे असावे.

214
00:18:14,880 --> 00:18:20,160


215
00:18:20,160 --> 00:18:26,560


216
00:18:26,560 --> 00:18:32,720


217
00:18:32,720 --> 00:18:38,000


218
00:18:38,000 --> 00:18:43,120


219
00:18:43,120 --> 00:18:47,760


220
00:18:47,760 --> 00:18:53,520


221
00:18:53,520 --> 00:18:58,400


222
00:18:58,400 --> 00:19:04,240


223
00:19:04,240 --> 00:19:09,200


224
00:19:09,200 --> 00:19:13,600


225
00:19:13,600 --> 00:19:18,720


226
00:19:18,720 --> 00:19:23,840


227
00:19:23,840 --> 00:19:30,080


228
00:19:30,080 --> 00:19:34,400


229
00:19:34,400 --> 00:19:41,600


230
00:19:41,600 --> 00:19:46,480


231
00:19:46,480 --> 00:19:51,360


232
00:19:51,360 --> 00:19:57,600


233
00:19:57,600 --> 00:20:03,200


234
00:20:03,200 --> 00:20:08,160


235
00:20:08,160 --> 00:20:12,640


236
00:20:12,640 --> 00:20:17,520


237
00:20:17,520 --> 00:20:22,720


238
00:20:22,720 --> 00:20:28,320


239
00:20:28,320 --> 00:20:33,040


240
00:20:33,040 --> 00:20:38,080


241
00:20:38,080 --> 00:20:43,600


242
00:20:43,600 --> 00:20:48,640


243
00:20:48,640 --> 00:20:53,200


244
00:20:53,200 --> 00:20:58,960


245
00:20:58,960 --> 00:21:03,280


246
00:21:03,280 --> 00:21:08,960


247
00:21:08,960 --> 00:21:14,480


248
00:21:14,480 --> 00:21:18,480


249
00:21:18,480 --> 00:21:25,600


250
00:21:25,600 --> 00:21:30,560


251
00:21:30,560 --> 00:21:35,120


252
00:21:35,120 --> 00:21:39,600


253
00:21:39,600 --> 00:21:44,480


254
00:21:44,480 --> 00:21:50,160


255
00:21:50,160 --> 00:21:54,800


256
00:21:54,800 --> 00:21:59,360


257
00:21:59,360 --> 00:22:04,640


258
00:22:04,640 --> 00:22:10,720


259
00:22:10,720 --> 00:22:16,000


260
00:22:16,000 --> 00:22:20,720


261
00:22:20,720 --> 00:22:26,320


262
00:22:26,320 --> 00:22:31,280


263
00:22:31,280 --> 00:22:36,880


264
00:22:36,880 --> 00:22:51,040


