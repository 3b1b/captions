1
00:00:00,000 --> 00:00:03,601
समजा, मी तुम्हाला संख्यांच्या दोन भिन्न याद्या, किंवा कदाचित दोन भिन्न कार्ये देतो, 

2
00:00:03,601 --> 00:00:07,460
आणि मी तुम्हाला संख्यांची नवीन यादी मिळविण्यासाठी त्या दोन याद्या एकत्रित करण्याच्या सर्व 

3
00:00:07,460 --> 00:00:11,320
मार्गांचा विचार करण्यास सांगतो, किंवा नवीन कार्य मिळविण्यासाठी दोन कार्ये एकत्र करू शकता. 

4
00:00:12,120 --> 00:00:16,760
. कदाचित मनात येणारा एक सोपा मार्ग म्हणजे त्यांना शब्दानुसार एकत्र जोडणे. 

5
00:00:17,160 --> 00:00:19,920
त्याचप्रमाणे फंक्शन्ससह, तुम्ही सर्व संबंधित आउटपुट जोडू शकता. 

6
00:00:20,540 --> 00:00:22,928
अशाच प्रकारे, तुम्ही दोन लिस्ट टर्म टर्मनुसार 

7
00:00:22,928 --> 00:00:25,680
गुणाकार करू शकता आणि फंक्शन्ससह समान गोष्ट करू शकता. 

8
00:00:26,360 --> 00:00:30,235
परंतु या दोन्हींप्रमाणेच आणखी एक प्रकारचा संयोग मूलभूत आहे, परंतु सामान्यत: 

9
00:00:30,235 --> 00:00:33,500
फारच कमी चर्चिला जातो, ज्याला कॉन्व्होल्यूशन म्हणून ओळखले जाते. 

10
00:00:34,080 --> 00:00:36,974
परंतु मागील दोन प्रकरणांप्रमाणे, ही अशी गोष्ट नाही जी केवळ 

11
00:00:36,974 --> 00:00:39,820
एका ऑपरेशनमधून मिळालेली आहे जी तुम्ही संख्यांवर करू शकता. 

12
00:00:39,980 --> 00:00:42,699
संख्यांच्या याद्या किंवा फंक्शन्स एकत्रित करण्याच्या 

13
00:00:42,699 --> 00:00:44,700
संदर्भासाठी हे खरोखर काहीतरी नवीन आहे. 

14
00:00:45,320 --> 00:00:48,783
ते सर्वत्र दिसून येतात, ते इमेज प्रोसेसिंगमध्ये सर्वव्यापी आहेत, 

15
00:00:48,783 --> 00:00:51,394
संभाव्यतेच्या सिद्धांतामध्ये ते एक मूळ रचना आहे, 

16
00:00:51,394 --> 00:00:54,964
ते विभेदक समीकरणे सोडवण्यासाठी खूप वापरले जातात आणि एक संदर्भ जिथे 

17
00:00:54,964 --> 00:00:58,161
तुम्ही जवळजवळ निश्चितपणे पाहिले असेल, जर नसेल तर या नावाने, 

18
00:00:58,161 --> 00:01:00,240
दोन बहुपदांचा एकत्र गुणाकार केला जातो. 

19
00:01:00,740 --> 00:01:05,056
व्हिज्युअल स्पष्टीकरणाच्या व्यवसायातील कोणीतरी म्हणून, हा विशेषतः चांगला विषय आहे, 

20
00:01:05,056 --> 00:01:09,321
कारण एकाकी आणि संदर्भाशिवाय फॉर्म्युलाची व्याख्या एक प्रकारची भीतीदायक वाटू शकते, 

21
00:01:09,321 --> 00:01:13,378
परंतु जर आपण ते काय म्हणत आहे ते खरोखर अनपॅक करण्यासाठी वेळ काढला आणि त्याआधी 

22
00:01:13,378 --> 00:01:16,447
प्रत्यक्षात का प्रेरित केले. तुम्हाला असे काहीतरी हवे आहे, 

23
00:01:16,447 --> 00:01:18,320
हे आश्चर्यकारकपणे सुंदर ऑपरेशन आहे. 

24
00:01:18,960 --> 00:01:21,295
आणि मला हे मान्य करावेच लागेल की, या प्रोजेक्टसाठी 

25
00:01:21,295 --> 00:01:23,540
व्हिज्युअल्स एकत्र करताना मी खरंच काहीतरी शिकलो. 

26
00:01:23,540 --> 00:01:27,149
दोन भिन्न कार्ये एकत्रित करण्याच्या बाबतीत, मी याचा अर्थ काय असू शकतो हे 

27
00:01:27,149 --> 00:01:30,758
आपण चित्रित करू शकता अशा वेगवेगळ्या मार्गांनी विचार करण्याचा प्रयत्न करत 

28
00:01:30,758 --> 00:01:35,207
होतो आणि त्यापैकी एकासह मला थोडासा अहाहा क्षण मिळाला की सामान्य वितरण ही भूमिका का बजावते.

29
00:01:35,207 --> 00:01:38,520
 ते संभाव्यतेनुसार करतात, फंक्शनसाठी ते इतके नैसर्गिक आकार का आहे. 

30
00:01:39,020 --> 00:01:41,520
पण मी स्वतःहून पुढे जात आहे, त्यासाठी खूप सेटअप आहे. 

31
00:01:41,840 --> 00:01:46,109
या व्हिडिओमध्ये, आमचा प्राथमिक फोकस फक्त वेगळ्या केसवर असेल आणि विशेषत: 

32
00:01:46,109 --> 00:01:50,260
या गणनेसाठी एक अतिशय अनपेक्षित परंतु अतिशय हुशार अल्गोरिदम तयार करणे. 

33
00:01:50,260 --> 00:01:54,480
आणि मी सतत प्रकरणाची चर्चा दुसऱ्या भागात काढेन. 

34
00:01:58,580 --> 00:02:01,505
इमेज प्रोसेसिंगच्या उदाहरणांसह ते उघडणे खूप मोहक आहे, 

35
00:02:01,505 --> 00:02:06,003
कारण ते दृश्यदृष्ट्या सर्वात वेधक आहेत, परंतु काही सूक्ष्मता आहेत ज्यामुळे प्रतिमा 

36
00:02:06,003 --> 00:02:10,663
प्रक्रिया केस एकंदरीत कमी प्रतिनिधीत्व करतात, म्हणून त्याऐवजी संभाव्यतेसह गोष्टी सुरू 

37
00:02:10,663 --> 00:02:15,268
करूया, आणि विशेषतः साध्या उदाहरणांपैकी एक, ज्याचा मला खात्री आहे की येथे प्रत्येकाने 

38
00:02:15,268 --> 00:02:19,711
त्यांच्या जीवनात कधीतरी विचार केला असेल, जे फासेची जोडी फिरवत आहे आणि विविध भिन्न 

39
00:02:19,711 --> 00:02:21,500
बेरीज पाहण्याची शक्यता शोधत आहे. 

40
00:02:22,460 --> 00:02:24,460
आणि तुम्ही म्हणाल, समस्या नाही, समस्या नाही. 

41
00:02:24,680 --> 00:02:27,980
तुमच्या प्रत्येक दोन फासेचे सहा वेगवेगळे संभाव्य परिणाम आहेत, 

42
00:02:27,980 --> 00:02:31,600
जे आम्हाला एकूण 36 वेगळ्या संभाव्य जोड्या परिणाम देतात आणि जर आम्ही 

43
00:02:31,600 --> 00:02:35,860
त्या सर्वांचा विचार केला तर आम्ही मोजू शकतो की किती जोड्या दिलेल्या बेरीज आहेत. 

44
00:02:36,600 --> 00:02:39,646
आणि अशा प्रकारे सर्व जोड्या एका ग्रिडमध्ये मांडणे, 

45
00:02:39,646 --> 00:02:44,185
एक चांगली गोष्ट म्हणजे स्थिर बेरीज असलेल्या सर्व जोड्या या भिन्न कर्णांपैकी 

46
00:02:44,185 --> 00:02:45,440
एकासह दृश्यमान आहेत. 

47
00:02:45,440 --> 00:02:48,628
त्यामुळे त्या प्रत्येक कर्णावर किती अस्तित्वात आहेत याची मोजणी 

48
00:02:48,628 --> 00:02:52,120
केल्याने तुम्हाला विशिष्ट बेरीज दिसण्याची शक्यता किती आहे हे सांगेल. 

49
00:02:53,220 --> 00:02:55,961
आणि मी म्हणेन, खूप चांगले, खूप चांगले, परंतु आपण त्याच प्रश्नाची 

50
00:02:55,961 --> 00:02:58,660
कल्पना करू शकणार्‍या इतर कोणत्याही मार्गांचा विचार करू शकता का? 

51
00:02:59,300 --> 00:03:01,882
दिलेल्या बेरीज असलेल्या सर्व भिन्न जोड्यांचा विचार 

52
00:03:01,882 --> 00:03:04,060
करण्यासाठी मनात येऊ शकणार्‍या इतर प्रतिमा? 

53
00:03:04,860 --> 00:03:07,980
आणि कदाचित तुमच्यापैकी कोणीतरी तुमचा हात वर करून म्हणेल, हो, माझ्याकडे एक आहे. 

54
00:03:08,280 --> 00:03:11,455
समजा तुम्ही या दोन वेगवेगळ्या शक्यतांचे एका ओळीत चित्र काढता, 

55
00:03:11,455 --> 00:03:13,760
परंतु तुम्ही त्या दुसऱ्या पंक्तीभोवती फिरता. 

56
00:03:13,760 --> 00:03:18,760
अशा रीतीने सर्व भिन्न जोड्या ज्या सात रेषा पर्यंत उभ्या जोडतात. 

57
00:03:19,360 --> 00:03:24,062
आणि जर आपण ती खालची पंक्ती उजवीकडे सरकवली, तर दोन जोडणारी अनोखी जोडी, 

58
00:03:24,062 --> 00:03:26,280
सापाचे डोळे, फक्त संरेखित होतात. 

59
00:03:26,620 --> 00:03:29,484
आणि जर मी ते एका युनिटवर उजवीकडे झुकवले, तर ज्या जोड्या संरेखित 

60
00:03:29,484 --> 00:03:32,080
करतात त्या दोन भिन्न जोड्या असतात ज्या तीन पर्यंत जोडतात. 

61
00:03:32,880 --> 00:03:36,041
आणि सर्वसाधारणपणे, या खालच्या अॅरेची वेगवेगळी ऑफसेट व्हॅल्यूज, 

62
00:03:36,041 --> 00:03:38,901
ज्यांना आठवते की मला प्रथम इकडे तिकडे फ्लिप करावे लागले, 

63
00:03:38,901 --> 00:03:41,460
दिलेल्या बेरीज असलेल्या सर्व भिन्न जोड्या उघड करा. 

64
00:03:44,820 --> 00:03:48,087
संभाव्यतेच्या प्रश्नांनुसार, हे अद्याप विशेषतः मनोरंजक नाही, 

65
00:03:48,087 --> 00:03:52,640
कारण आम्ही जे काही करत आहोत ते मोजत आहे की या प्रत्येक श्रेणीमध्ये किती परिणाम आहेत. 

66
00:03:52,980 --> 00:03:58,120
परंतु यापैकी प्रत्येक चेहऱ्याला समोर येण्याची समान संधी आहे असे गर्भित गृहीत धरून आहे. 

67
00:03:58,360 --> 00:04:01,620
पण जर मी तुम्हाला सांगितले की माझ्याकडे फासांचा एक विशेष संच आहे जो एकसमान नाही? 

68
00:04:02,060 --> 00:04:05,722
कदाचित निळ्या डाईकडे येणाऱ्या प्रत्येक चेहऱ्याच्या संभाव्यतेचे वर्णन करणाऱ्या 

69
00:04:05,722 --> 00:04:09,760
संख्यांचा स्वतःचा संच असेल आणि लाल रंगाचा स्वतःचा विशिष्ट विशिष्ट संख्यांचा संच असेल. 

70
00:04:10,299 --> 00:04:14,105
त्या बाबतीत, जर तुम्हाला दोन दिसण्याची संभाव्यता शोधायची असेल, 

71
00:04:14,105 --> 00:04:19,360
तर तुम्ही निळ्या रंगाची संभाव्यता लाल रंगाची असण्याची संभाव्यता एक पटीने गुणाकार कराल. 

72
00:04:19,360 --> 00:04:24,613
आणि तीन दिसण्याच्या शक्यतेसाठी, तुम्ही दोन वेगळ्या जोड्यांकडे पहा जेथे ते शक्य आहे, 

73
00:04:24,613 --> 00:04:29,680
आणि पुन्हा, संबंधित संभाव्यतेचा गुणाकार करा आणि नंतर ती दोन उत्पादने एकत्र जोडा. 

74
00:04:30,100 --> 00:04:33,434
त्याचप्रमाणे, चार दिसण्याच्या शक्यतांमध्ये शक्यतांच्या तीन भिन्न 

75
00:04:33,434 --> 00:04:36,820
जोड्या एकत्र गुणाकार करणे आणि त्या सर्व एकत्र जोडणे समाविष्ट आहे. 

76
00:04:36,820 --> 00:04:41,113
आणि काही सूत्रे सेट करण्याच्या भावनेने, या वरच्या संभाव्यतेला a1, a2, 

77
00:04:41,113 --> 00:04:45,960
a3 आणि असेच नाव देऊ या आणि खालच्या संभाव्यांना b1, b2, b3 आणि असेच नाव देऊ या. 

78
00:04:46,400 --> 00:04:50,173
आणि सर्वसाधारणपणे, ही प्रक्रिया, जिथे आपण संख्यांचे दोन वेगवेगळे अॅरे घेत आहोत, 

79
00:04:50,173 --> 00:04:53,475
दुसऱ्याला आजूबाजूला फ्लिप करत आहोत, आणि नंतर त्यांना वेगवेगळ्या ऑफसेट 

80
00:04:53,475 --> 00:04:57,390
व्हॅल्यूजवर लाइनअप करत आहोत, पेअरवाइज उत्पादनांचा एक गुच्छ घेतो आणि त्यांना जोडतो, 

81
00:04:57,390 --> 00:05:00,740
ही त्यापैकी एक आहे संभ्रम म्हणजे काय याचा विचार करण्याचे मूलभूत मार्ग. 

82
00:05:00,740 --> 00:05:05,667
तर फक्त त्याचे थोडे अधिक अचूक शब्दलेखन करण्यासाठी, या प्रक्रियेद्वारे, 

83
00:05:05,667 --> 00:05:10,942
आम्ही फक्त 12 पर्यंत दोन, तीन, चार, वर आणि वर पाहण्यासाठी संभाव्यता निर्माण 

84
00:05:10,942 --> 00:05:16,980
केली आणि आम्ही मूल्यांची एक सूची, a आणि दुसरी एकत्र करून ती मिळवली. मूल्यांची यादी, b. 

85
00:05:17,440 --> 00:05:22,306
लिंगोमध्ये, आम्ही असे म्हणू की त्या दोन अनुक्रमांच्या संचलनामुळे आम्हाला हा नवीन क्रम, 

86
00:05:22,306 --> 00:05:27,340
11 मूल्यांचा नवीन क्रम मिळतो, ज्यापैकी प्रत्येक जोडी उत्पादनांच्या काही बेरीजसारखे दिसते. 

87
00:05:27,340 --> 00:05:31,962
तुम्ही प्राधान्य दिल्यास, त्याच ऑपरेशनबद्दल तुम्ही विचार करू शकता असा दुसरा मार्ग 

88
00:05:31,962 --> 00:05:36,980
म्हणजे प्रथम सर्व जोडीच्या उत्पादनांची सारणी तयार करणे, आणि नंतर या सर्व कर्णांसह जोडणे. 

89
00:05:37,460 --> 00:05:40,277
पुन्हा, 11 संख्यांचा एक नवीन क्रम मिळवण्यासाठी संख्यांच्या 

90
00:05:40,277 --> 00:05:42,760
या दोन अनुक्रमांचे मिश्रण करण्याचा हा एक मार्ग आहे. 

91
00:05:43,240 --> 00:05:46,460
हे स्लाइडिंग विंडोंप्रमाणेच ऑपरेशन आहे, फक्त दुसरा दृष्टीकोन. 

92
00:05:47,140 --> 00:05:49,800
त्यावर थोडेसे नोटेशन टाकून, तुम्हाला ते कसे लिहिलेले दिसेल ते येथे आहे. 

93
00:05:50,220 --> 00:05:55,233
या छोट्या तारकाने दर्शविलेले a आणि b चे संचलन ही एक नवीन यादी आहे आणि त्या 

94
00:05:55,233 --> 00:06:00,581
यादीतील nवा घटक बेरीज सारखा दिसतो आणि ती बेरीज सर्व वेगवेगळ्या निर्देशांकांच्या 

95
00:06:00,581 --> 00:06:04,860
i आणि j वर जाते, जेणेकरून बेरीज ते निर्देशांक n च्या समान आहेत. 

96
00:06:05,280 --> 00:06:10,365
हे एक प्रकारचे तोंडी आहे, परंतु उदाहरणार्थ, जर n 6 असेल, तर आपण 1 आणि 5, 

97
00:06:10,365 --> 00:06:15,800
2 आणि 4, 3 आणि 3, 4 आणि 2, 5 आणि 1 या सर्व वेगवेगळ्या जोड्या जोडत आहोत. ते 6. 

98
00:06:16,620 --> 00:06:19,577
पण प्रामाणिकपणे, तुम्ही ते लिहून ठेवले तरी, या प्रक्रियेसाठी तुम्ही तुमच्या 

99
00:06:19,577 --> 00:06:22,340
डोक्यात धारण करू शकणार्‍या व्हिज्युअलसाठी नोटेशनचे महत्त्व दुय्यम आहे. 

100
00:06:23,280 --> 00:06:26,502
येथे, कदाचित हे एक अतिशय साधे उदाहरण करण्यास मदत करेल, 

101
00:06:26,502 --> 00:06:30,780
जिथे मी तुम्हाला विचारू शकतो की यादी 1, 2, 3 ची यादी 4, 5, 6 सह काय आहे. 

102
00:06:31,480 --> 00:06:34,270
तुम्ही या दोन्ही याद्या घेऊन, त्या दुस-या भोवती फिरत, 

103
00:06:34,270 --> 00:06:37,680
आणि नंतर त्याच्या झाकणाने डावीकडे सर्व मार्गाने सुरुवात करत असाल. 

104
00:06:38,180 --> 00:06:40,770
मग मूल्यांची जोडी जी 1 आणि 4 संरेखित करतात, त्यांना एकत्र 

105
00:06:40,770 --> 00:06:43,540
गुणाकार करतात आणि ते आम्हाला आमच्या आउटपुटची पहिली टर्म देते. 

106
00:06:43,960 --> 00:06:48,823
त्या खालच्या अॅरेचे एक युनिट उजवीकडे सरकवा, 1 आणि 5 आणि 2 आणि 4 अशा जोड्या संरेखित करा, 

107
00:06:48,823 --> 00:06:52,636
त्या जोड्या गुणाकार करा, त्यांना एकत्र जोडा, आणि ते आम्हाला 13 देते, 

108
00:06:52,636 --> 00:06:54,460
आमच्या आउटपुटमध्ये पुढील एंट्री. 

109
00:06:54,960 --> 00:06:58,192
गोष्टी पुन्हा एकदा सरकवा, आणि आम्ही 1 गुणिले 6, 

110
00:06:58,192 --> 00:07:01,560
अधिक 2 गुणिले 5, अधिक 3 गुणिले 4 घेऊ, जे 28 होईल. 

111
00:07:02,020 --> 00:07:05,799
आणखी एक स्लाइड, आणि आम्हाला 2 गुणिले 6, अधिक 3 गुणिले 5 मिळेल, 

112
00:07:05,799 --> 00:07:10,120
आणि ते आम्हाला 27 देते, आणि शेवटी शेवटची संज्ञा 3 गुणिले 6 सारखी दिसेल. 

113
00:07:10,660 --> 00:07:13,379
तुमची इच्छा असल्यास, तुमची आवडती प्रोग्रॅमिंग भाषा आणि तुमची आवडती 

114
00:07:13,379 --> 00:07:15,814
लायब्ररी ज्यामध्ये विविध संख्यात्मक ऑपरेशन्स समाविष्ट आहेत, 

115
00:07:15,814 --> 00:07:18,980
तुम्ही खेचू शकता आणि मी तुमच्याशी खोटे बोलत नाही याची तुम्ही पुष्टी करू शकता. 

116
00:07:18,980 --> 00:07:22,818
जर तुम्ही 1, 2, 3, 4, 5, 6 च्या विरुद्ध 4, 5, 6 चे परिभ्रमण घेतले, 

117
00:07:22,818 --> 00:07:24,480
तर हा परिणाम तुम्हाला मिळेल. 

118
00:07:25,920 --> 00:07:29,299
आम्ही एक केस पाहिली आहे जिथे हे नैसर्गिक आणि इष्ट ऑपरेशन आहे, 

119
00:07:29,299 --> 00:07:33,660
संभाव्यता वितरणास जोडून, आणि दुसरे सामान्य उदाहरण म्हणजे मूव्हिंग एव्हरेज असेल. 

120
00:07:34,080 --> 00:07:37,051
कल्पना करा की तुमच्याकडे संख्यांची काही लांबलचक यादी आहे आणि तुम्ही 

121
00:07:37,051 --> 00:07:39,760
संख्यांची आणखी एक छोटी यादी घ्या जी सर्व 1 पर्यंत जोडली जाईल. 

122
00:07:40,100 --> 00:07:44,060
या प्रकरणात, माझ्याकडे फक्त 5 मूल्यांची एक छोटी यादी आहे, आणि ती सर्व 1 5व्या समान आहेत. 

123
00:07:44,060 --> 00:07:47,590
मग जर आपण ही स्लाइडिंग विंडो कॉन्व्होल्युशन प्रक्रिया केली आणि आपले 

124
00:07:47,590 --> 00:07:51,380
डोळे बंद केले आणि त्याच्या सुरवातीला जे घडते ते गालिच्याखाली स्वीप केले, 

125
00:07:51,380 --> 00:07:55,169
एकदा आपली लहान मूल्यांची सूची मोठ्या मूल्याशी पूर्णपणे ओव्हरलॅप झाली की, 

126
00:07:55,169 --> 00:07:58,700
यातील प्रत्येक पद काय आहे याचा विचार करा. convolution म्हणजे खरोखर. 

127
00:07:59,400 --> 00:08:03,272
प्रत्येक पुनरावृत्तीवर, तुम्ही जे करत आहात ते म्हणजे तुमच्या डेटामधील 

128
00:08:03,272 --> 00:08:07,034
प्रत्येक मूल्याचा 1 5 व्या ने गुणाकार करणे आणि ते सर्व एकत्र जोडणे, 

129
00:08:07,034 --> 00:08:10,520
म्हणजे तुम्ही या छोट्या विंडोमध्ये तुमचा डेटा सरासरी घेत आहात. 

130
00:08:11,100 --> 00:08:14,734
एकूणच, ही प्रक्रिया तुम्हाला मूळ डेटाची एक गुळगुळीत आवृत्ती देते, 

131
00:08:14,734 --> 00:08:18,479
आणि तुम्ही संख्यांच्या वेगळ्या छोट्या सूचीपासून हे बदल करू शकता आणि 

132
00:08:18,479 --> 00:08:22,720
जोपर्यंत ती छोटी यादी 1 पर्यंत जोडते, तोपर्यंत तुम्ही त्याचा अर्थ बदलू शकता. 

133
00:08:23,400 --> 00:08:27,712
सरासरी येथे दर्शविलेल्या उदाहरणामध्ये, ती हलणारी सरासरी मध्यवर्ती मूल्याकडे अधिक वजन देते.

134
00:08:27,712 --> 00:08:27,760
 

135
00:08:28,420 --> 00:08:30,800
याचा परिणाम डेटाच्या स्मूथ आउट आवृत्तीमध्ये देखील होतो. 

136
00:08:33,140 --> 00:08:35,734
जर तुम्ही याचे द्विमितीय अॅनालॉग केले तर ते तुम्हाला 

137
00:08:35,734 --> 00:08:38,720
दिलेल्या इमेजला अस्पष्ट करण्यासाठी एक मजेदार अल्गोरिदम देते. 

138
00:08:38,720 --> 00:08:42,856
आणि मी जे अॅनिमेशन दाखवणार आहे ते मी मूळत: एमआयटी येथील ज्युलिया लॅबमध्ये एका विशिष्ट 

139
00:08:42,856 --> 00:08:47,184
OpenCourseWare क्लाससाठी केलेल्या व्याख्यानांच्या संचाच्या भागासाठी बनवलेल्या गोष्टींमधून 

140
00:08:47,184 --> 00:08:51,080
सुधारित केले आहे, ज्यामध्ये इमेज प्रोसेसिंग युनिट समाविष्ट आहे असे म्हणायला हवे. 

141
00:08:51,560 --> 00:08:54,242
तेथे आम्ही या सर्वांच्या मागे असलेल्या कोडमध्ये जाण्यासाठी थोडे अधिक केले आहे, 

142
00:08:54,242 --> 00:08:56,280
म्हणून जर तुम्ही उत्सुक असाल तर मी तुम्हाला काही लिंक देईन. 

143
00:08:56,620 --> 00:08:59,285
परंतु या अस्पष्ट उदाहरणावर परत लक्ष केंद्रित करताना, 

144
00:08:59,285 --> 00:09:03,359
काय चालले आहे ते म्हणजे माझ्या मूळ प्रतिमेच्या बाजूने चालत असलेल्या मूल्यांचा हा 

145
00:09:03,359 --> 00:09:07,584
छोटासा 3x3 ग्रिड आहे आणि जर आपण झूम इन केले तर त्यातील प्रत्येक मूल्य 1 9वी आहे आणि 

146
00:09:07,584 --> 00:09:12,010
मी काय करत आहे. प्रत्येक पुनरावृत्तीवर त्या प्रत्येक व्हॅल्यूला ते शीर्षस्थानी असलेल्या 

147
00:09:12,010 --> 00:09:13,620
संबंधित पिक्सेलने गुणाकारत आहे. 

148
00:09:13,900 --> 00:09:16,987
आणि अर्थातच संगणक शास्त्रामध्ये आपण रंगांना लाल, 

149
00:09:16,987 --> 00:09:20,200
हिरवे आणि निळे या तीन मूल्यांचे छोटे वेक्टर समजतो. 

150
00:09:20,560 --> 00:09:24,835
जेव्हा मी या सर्व लहान मूल्यांना 1 9 व्या ने गुणाकार करतो आणि मी त्यांना एकत्र जोडतो, 

151
00:09:24,835 --> 00:09:28,614
तेव्हा ते आम्हाला प्रत्येक रंग चॅनेलसह सरासरी देते आणि उजवीकडील प्रतिमेसाठी 

152
00:09:28,614 --> 00:09:31,200
संबंधित पिक्सेल ही बेरीज म्हणून परिभाषित केले जाते. 

153
00:09:31,940 --> 00:09:35,378
एकंदरीत परिणाम, जसे की आपण प्रतिमेवरील प्रत्येक पिक्सेलसाठी हे करतो, 

154
00:09:35,378 --> 00:09:38,368
प्रत्येक एक प्रकारचा त्याच्या सर्व शेजारी रक्तस्त्राव होतो, 

155
00:09:38,368 --> 00:09:40,860
ज्यामुळे आम्हाला मूळपेक्षा अस्पष्ट आवृत्ती मिळते. 

156
00:09:41,720 --> 00:09:44,525
लिंगोमध्ये आपण असे म्हणू की उजवीकडील प्रतिमा ही 

157
00:09:44,525 --> 00:09:47,740
आपल्या मूळ प्रतिमेची थोडीशी मूल्ये असलेली प्रतिमा आहे. 

158
00:09:48,140 --> 00:09:51,125
किंवा अधिक तांत्रिकदृष्ट्या कदाचित मला असे म्हणायचे आहे की हे 

159
00:09:51,125 --> 00:09:54,400
मूल्यांच्या त्या छोट्या ग्रिडच्या 180 अंश फिरवलेल्या आवृत्तीसह आहे. 

160
00:09:54,620 --> 00:09:58,144
ग्रिड सममितीय आहे हे महत्त्वाचे नाही, परंतु हे लक्षात ठेवण्यासारखे आहे की 

161
00:09:58,144 --> 00:10:01,573
शुद्ध गणिताच्या संदर्भातून वारशाने मिळालेल्या कॉन्व्होल्युशनची व्याख्या 

162
00:10:01,573 --> 00:10:05,240
नेहमी तुम्हाला त्या दुसऱ्या अॅरेभोवती फिरण्याचा विचार करण्यास आमंत्रित करते. 

163
00:10:05,960 --> 00:10:08,530
जर आपण यात थोडासा बदल केला तर भिन्न मूल्यांचा ग्रिड 

164
00:10:08,530 --> 00:10:11,100
निवडून आपल्याला अधिक मोहक अस्पष्ट प्रभाव मिळू शकतो. 

165
00:10:11,440 --> 00:10:15,780
या प्रकरणात माझ्याकडे थोडे 5x5 ग्रिड आहे, परंतु फरक त्याच्या आकारात इतका नाही. 

166
00:10:15,980 --> 00:10:19,348
जर आपण झूम इन केले तर आपल्या लक्षात येते की मध्यभागी असलेले मूल्य हे 

167
00:10:19,348 --> 00:10:23,742
कडांच्या दिशेने असलेल्या मूल्यापेक्षा खूप मोठे आहे आणि हे कोठून येत आहे ते सर्व बेल वक्र, 

168
00:10:23,742 --> 00:10:25,940
गौसियन वितरण म्हणून ओळखले जाणारे नमुना आहेत. 

169
00:10:26,800 --> 00:10:31,308
अशा प्रकारे जेव्हा आपण या सर्व मूल्यांचा ते वर बसलेल्या संबंधित पिक्सेलने गुणाकार करतो, 

170
00:10:31,308 --> 00:10:34,330
तेव्हा आपण त्या मध्यवर्ती पिक्सेलला खूप जास्त वजन देतो आणि 

171
00:10:34,330 --> 00:10:36,380
काठावर असलेल्या पिक्सेलला खूप कमी देतो. 

172
00:10:36,800 --> 00:10:40,560
आणि उजवीकडील संबंधित पिक्सेलच्या आधी ही बेरीज म्हणून परिभाषित केली आहे. 

173
00:10:41,320 --> 00:10:43,908
आम्ही प्रत्येक पिक्सेलसाठी ही प्रक्रिया करत असताना ते एक 

174
00:10:43,908 --> 00:10:46,859
अस्पष्ट प्रभाव देते जे अधिक प्रमाणिकपणे तुमच्या लेन्सला फोकसच्या 

175
00:10:46,859 --> 00:10:49,720
बाहेर ठेवण्याच्या कल्पनेचे अनुकरण करते किंवा असे काहीतरी करते. 

176
00:10:49,900 --> 00:10:53,360
परंतु अस्पष्ट करणे ही एकमेव गोष्ट आहे जी आपण या कल्पनेसह करू शकता. 

177
00:10:53,800 --> 00:10:56,643
उदाहरणार्थ, मूल्यांच्या या छोट्या ग्रिडवर एक नजर टाका, 

178
00:10:56,643 --> 00:11:00,676
ज्यात डावीकडे काही सकारात्मक संख्या आणि उजवीकडे काही ऋण संख्या समाविष्ट आहेत, 

179
00:11:00,676 --> 00:11:02,900
ज्यांना मी अनुक्रमे निळा आणि लाल रंग देईन. 

180
00:11:03,640 --> 00:11:06,085
याचा अंतिम प्रतिमेवर काय परिणाम होईल याचा अंदाज 

181
00:11:06,085 --> 00:11:08,480
आणि समजू शकतो का ते पाहण्यासाठी थोडा वेळ द्या. 

182
00:11:10,720 --> 00:11:14,447
तर या प्रकरणात मी चित्राचा रंगीत ऐवजी ग्रेस्केल म्हणून विचार करेन, 

183
00:11:14,447 --> 00:11:18,120
म्हणून प्रत्येक पिक्सेल तीन ऐवजी फक्त एका संख्येने दर्शविला जाईल. 

184
00:11:18,440 --> 00:11:20,523
आणि एक गोष्ट लक्षात घेण्यासारखी आहे की आपण हे 

185
00:11:20,523 --> 00:11:23,060
कव्होल्यूशन करत असताना नकारात्मक मूल्ये मिळणे शक्य आहे. 

186
00:11:23,060 --> 00:11:27,193
उदाहरणार्थ या टप्प्यावर जर आपण आपल्या छोट्या ग्रिडच्या डाव्या अर्ध्या भागामध्ये झूम 

187
00:11:27,193 --> 00:11:31,080
केला तर पूर्णपणे काळ्या पिक्सेलच्या शीर्षस्थानी बसतो, ज्याचे मूल्य शून्य असेल, 

188
00:11:31,080 --> 00:11:35,460
परंतु उजव्या निगेटिव्ह व्हॅल्यूचा अर्धा भाग पांढर्‍या पिक्सेलच्या वर बसेल, एक मूल्य आहे. 

189
00:11:36,180 --> 00:11:39,573
म्हणून जेव्हा आपण संबंधित संज्ञांचा गुणाकार करतो आणि त्यांना एकत्र जोडतो तेव्हा 

190
00:11:39,573 --> 00:11:42,924
परिणाम खूप नकारात्मक होतील आणि मी ज्या प्रकारे हे उजवीकडील प्रतिमेसह प्रदर्शित 

191
00:11:42,924 --> 00:11:46,360
करत आहे ते म्हणजे नकारात्मक मूल्यांना लाल आणि सकारात्मक मूल्यांना निळा रंग देणे. 

192
00:11:46,880 --> 00:11:50,587
आणखी एक गोष्ट लक्षात घेण्यासारखी आहे की जेव्हा तुम्ही एकाच रंगाच्या पॅचवर असता तेव्हा 

193
00:11:50,587 --> 00:11:54,080
सर्व काही शून्यावर जाते कारण आमच्या छोट्या ग्रिडमधील मूल्यांची बेरीज शून्य असते. 

194
00:11:55,180 --> 00:11:58,855
हे मागील दोन उदाहरणांपेक्षा खूप वेगळे आहे जेथे आमच्या छोट्या ग्रिडची बेरीज एक होती, 

195
00:11:58,855 --> 00:12:02,180
ज्यामुळे आपण त्याचा मूव्हिंग एव्हरेज म्हणून अर्थ लावू आणि त्यामुळे अस्पष्ट. 

196
00:12:03,640 --> 00:12:07,066
या सर्व छोट्या प्रक्रियेत मुळात तुम्ही डावीकडून उजवीकडे जाताना पिक्सेल 

197
00:12:07,066 --> 00:12:10,445
मूल्यामध्ये कुठेही फरक असेल ते शोधून काढले जाते आणि त्यामुळे तुम्हाला 

198
00:12:10,445 --> 00:12:13,920
तुमच्या प्रतिमेतील सर्व उभ्या किनारी उचलण्याचा एक प्रकारचा मार्ग मिळतो. 

199
00:12:16,500 --> 00:12:21,588
आणि त्याचप्रमाणे जर आपण तो ग्रिड फिरवला की आपण वरपासून खालपर्यंत जाताना ते बदलत जाईल, 

200
00:12:21,588 --> 00:12:25,493
हे सर्व आडव्या कडा वर उचलले जाईल, जे आपल्या लहान पाई प्राण्याच्या 

201
00:12:25,493 --> 00:12:29,340
प्रतिमेच्या बाबतीत काही सुंदर राक्षसी डोळ्यांमध्ये परिणाम करतात. 

202
00:12:30,400 --> 00:12:32,611
तसे, या लहान ग्रिडला बर्‍याचदा कर्नल म्हटले जाते, 

203
00:12:32,611 --> 00:12:36,018
आणि येथे सौंदर्य हे आहे की भिन्न कर्नल निवडून तुम्ही भिन्न प्रतिमा प्रक्रिया 

204
00:12:36,018 --> 00:12:39,734
प्रभाव कसे मिळवू शकता, केवळ तुमची किनार ओळखणे अस्पष्ट नाही तर तीक्ष्ण करण्यासारख्या 

205
00:12:39,734 --> 00:12:40,840
गोष्टी देखील मिळवू शकता. 

206
00:12:40,840 --> 00:12:44,145
तुमच्यापैकी ज्यांनी कन्व्होल्युशनल न्यूरल नेटवर्कबद्दल ऐकले आहे 

207
00:12:44,145 --> 00:12:47,761
त्यांच्यासाठी न्यूरल नेटवर्कला जे काही शोधायचे आहे त्यावरून निर्धारित 

208
00:12:47,761 --> 00:12:51,480
केल्यानुसार कर्नल काय असावेत हे शोधण्यासाठी डेटा वापरण्याची कल्पना आहे. 

209
00:12:52,760 --> 00:12:55,520
दुसरी गोष्ट मी कदाचित आणली पाहिजे ती म्हणजे आउटपुटची लांबी. 

210
00:12:55,820 --> 00:12:59,606
मूव्हिंग अॅव्हरेज उदाहरणासारख्या गोष्टीसाठी तुम्ही फक्त अटींबद्दल विचार करू 

211
00:12:59,606 --> 00:13:03,044
शकता जेव्हा दोन्ही विंडो पूर्णपणे एकमेकांशी संरेखित होतात किंवा इमेज 

212
00:13:03,044 --> 00:13:07,280
प्रोसेसिंगच्या उदाहरणामध्ये कदाचित तुम्हाला अंतिम आउटपुटचा आकार मूळ सारखाच हवा असेल. 

213
00:13:07,280 --> 00:13:11,756
आता प्युअर मॅथ ऑपरेशन म्‍हणून कॉन्व्होल्यूशन्‍स नेहमी तुम्‍ही सुरू करण्‍याच्‍या दोन 

214
00:13:11,756 --> 00:13:16,180
अॅरेपेक्षा मोठा अ‍ॅरे तयार करतात, किमान त्‍यापैकी एकाची लांबी नाही असे गृहीत धरून. 

215
00:13:16,720 --> 00:13:19,360
फक्त हे जाणून घ्या की काही संगणक विज्ञान संदर्भांमध्ये 

216
00:13:19,360 --> 00:13:21,520
तुम्हाला ते आउटपुट जाणीवपूर्वक कापायचे असते. 

217
00:13:24,720 --> 00:13:29,176
आणखी एक गोष्ट अधोरेखित करण्यासारखी आहे की संगणक विज्ञानाच्या संदर्भात त्या कर्नलला 

218
00:13:29,176 --> 00:13:33,633
मूळ ओलांडून पुढे जाण्याआधी त्याभोवती फिरण्याची ही कल्पना अनेकदा खरोखरच विचित्र आणि 

219
00:13:33,633 --> 00:13:38,090
केवळ अप्रत्याशित वाटते, परंतु पुन्हा लक्षात घ्या की शुद्ध गणिताच्या संदर्भातून हाच 

220
00:13:38,090 --> 00:13:42,440
वारसा मिळाला आहे. संभाव्यतेसह पाहिले की ही एक आश्चर्यकारकपणे नैसर्गिक गोष्ट आहे. 

221
00:13:43,020 --> 00:13:46,068
आणि खरं तर मी तुम्हाला आणखी एक शुद्ध गणिताचे उदाहरण दाखवू शकतो 

222
00:13:46,068 --> 00:13:48,923
जिथे प्रोग्रामरने देखील याची काळजी घेतली पाहिजे कारण ते या 

223
00:13:48,923 --> 00:13:52,020
सर्वांची गणना करण्यासाठी खूप वेगवान अल्गोरिदमसाठी दरवाजे उघडते. 

224
00:13:52,620 --> 00:13:56,073
येथे मला काय म्हणायचे आहे ते अधिक जलद सेट करण्यासाठी मी परत जाऊ आणि 

225
00:13:56,073 --> 00:13:59,780
काही अजगर पुन्हा खेचू आणि मी दोन भिन्न तुलनेने मोठे अॅरे तयार करणार आहे. 

226
00:13:59,940 --> 00:14:03,512
प्रत्येकामध्ये एक लाख यादृच्छिक घटक असतील आणि मी numpy 

227
00:14:03,512 --> 00:14:07,540
लायब्ररीतून convolve फंक्शनच्या रनटाइमचे मूल्यांकन करणार आहे. 

228
00:14:08,180 --> 00:14:11,664
आणि या प्रकरणात ते एकाधिक वेगवेगळ्या पुनरावृत्तीसाठी चालवते, 

229
00:14:11,664 --> 00:14:16,520
सरासरी शोधण्याचा प्रयत्न करते आणि या संगणकावर किमान 4 वर सरासरी असे दिसते. 87 सेकंद. 

230
00:14:16,960 --> 00:14:21,248
याउलट जर मी स्किपी लायब्ररीमधील fftconvolve नावाचे वेगळे फंक्शन 

231
00:14:21,248 --> 00:14:26,206
वापरत असलो तर तीच गोष्ट वेगळ्या पद्धतीने अंमलात आणली जाते जी फक्त 4 घेते. 

232
00:14:26,206 --> 00:14:30,160
सरासरी 3 मिलीसेकंद, त्यामुळे परिमाण सुधारण्याचे तीन ऑर्डर. 

233
00:14:30,160 --> 00:14:34,417
आणि जरी ते वेगळ्या नावाने उडत असले तरी ते इतर कॉन्व्हॉल्व्ह फंक्शन 

234
00:14:34,417 --> 00:14:39,120
प्रमाणेच आउटपुट देत आहे, ते फक्त त्याबद्दल अधिक हुशारीने काहीतरी करत आहे. 

235
00:14:42,200 --> 00:14:45,742
लक्षात ठेवा की संभाव्यतेच्या उदाहरणासह मी म्हटल्याचा दुसरा मार्ग म्हणजे 

236
00:14:45,742 --> 00:14:49,383
तुम्ही कन्व्होल्यूशनचा विचार करू शकता तो म्हणजे सर्व पेअरवाइज उत्पादनांचे 

237
00:14:49,383 --> 00:14:52,680
हे टेबल तयार करणे आणि नंतर ती पेअरवाइज उत्पादने कर्णरेषांसह जोडणे. 

238
00:14:53,660 --> 00:14:56,290
तुम्ही अशा प्रकारे विचार करू शकता अशा संख्येच्या दोन भिन्न याद्या 

239
00:14:56,290 --> 00:14:59,040
तुम्ही गुंतवून ठेवता तेव्हा संभाव्यतेसाठी अर्थातच काही विशिष्ट नाही. 

240
00:14:59,040 --> 00:15:02,676
सर्व जोड्यानिहाय उत्पादनांसह अशा प्रकारचे गुणाकार सारणी तयार करा आणि नंतर 

241
00:15:02,676 --> 00:15:06,460
कर्णाच्या बाजूची प्रत्येक बेरीज तुमच्या अंतिम आउटपुटपैकी एकाशी संबंधित असेल. 

242
00:15:07,600 --> 00:15:12,800
एक संदर्भ जेथे हे दृश्य विशेषतः नैसर्गिक आहे जेव्हा तुम्ही दोन बहुपदी एकत्र गुणाकार करता. 

243
00:15:13,300 --> 00:15:18,625
उदाहरणार्थ मी आमच्याकडे आधीपासून असलेली छोटी ग्रिड घेऊ आणि वरच्या संज्ञा 1, 

244
00:15:18,625 --> 00:15:23,600
2x आणि 3x स्क्वेअरने बदलू आणि इतर संज्ञा 4, 5x आणि 6x स्क्वेअरने बदलू. 

245
00:15:24,000 --> 00:15:26,544
आता आपण दोन सूचींमध्ये ही सर्व भिन्न जोडी उत्पादने 

246
00:15:26,544 --> 00:15:28,840
तयार करत असताना याचा अर्थ काय याचा विचार करा. 

247
00:15:29,040 --> 00:15:33,361
तुम्ही जे करत आहात ते मूलत: मी लिहिलेल्या दोन बहुपदींच्या पूर्ण उत्पादनाचा 

248
00:15:33,361 --> 00:15:37,855
विस्तार करत आहे आणि नंतर जेव्हा तुम्ही कर्ण सोबत जोडता जे सर्व सारख्या संज्ञा 

249
00:15:37,855 --> 00:15:42,118
एकत्रित करण्याशी संबंधित आहे जे अतिशय व्यवस्थित आहे बहुपदीचा विस्तार करणे 

250
00:15:42,118 --> 00:15:46,440
आणि अटींसारख्या संकलित करणे हे नक्की आहे. एक convolution सारखीच प्रक्रिया. 

251
00:15:47,740 --> 00:15:50,040
परंतु हे आम्हाला खूप छान असे काहीतरी करण्यास अनुमती 

252
00:15:50,040 --> 00:15:52,340
देते कारण आम्ही येथे काय म्हणत आहोत याचा विचार करा. 

253
00:15:52,340 --> 00:15:57,735
आम्ही म्हणतो की तुम्ही दोन भिन्न फंक्शन्स घेतलीत आणि तुम्ही त्यांचा एकत्र गुणाकार करत 

254
00:15:57,735 --> 00:16:03,005
असाल जे एक साधे पॉइंटवाइज ऑपरेशन आहे जे तुम्ही प्रथम बहुपदी आहेत असे गृहीत धरलेल्या 

255
00:16:03,005 --> 00:16:07,522
प्रत्येकाचे गुणांक काढले असतील आणि नंतर त्यांचे एक परिभ्रमण घेतले असेल. 

256
00:16:07,522 --> 00:16:08,840
गुणकांच्या दोन सूची. 

257
00:16:09,620 --> 00:16:14,000
हे इतके मनोरंजक काय आहे की कॉन्व्होल्यूशन हे तत्त्वतः साध्या गुणाकारापेक्षा 

258
00:16:14,000 --> 00:16:17,978
खूपच क्लिष्ट वाटते आणि मला असे म्हणायचे नाही की संकल्पनात्मकदृष्ट्या 

259
00:16:17,978 --> 00:16:22,186
ते विचार करणे कठिण आहे, म्हणजे गणनेच्या दृष्टीने कंव्होल्यूशन करण्यासाठी 

260
00:16:22,186 --> 00:16:25,760
अधिक पायऱ्या आवश्यक आहेत. दोन भिन्न सूचींचे पॉइंटवार उत्पादन. 

261
00:16:26,319 --> 00:16:31,120
उदाहरणार्थ, समजा की मी तुम्हाला दोन खरोखरच मोठ्या बहुपदी दिल्या आहेत प्रत्येक शंभर 

262
00:16:31,120 --> 00:16:35,689
भिन्न गुणांकांसह म्हणा, मग जर तुम्ही त्यांचा गुणाकार करण्याच्या पद्धतीनुसार या 

263
00:16:35,689 --> 00:16:40,258
उत्पादनाचा विस्तार कराल तर तुम्हाला हे संपूर्ण 100 बाय 100 ग्रिडमध्ये पेअरवाइज 

264
00:16:40,258 --> 00:16:44,885
उत्पादनांचे ग्रिड भरावे लागेल. 10,000 भिन्न उत्पादने करा आणि नंतर जेव्हा तुम्ही 

265
00:16:44,885 --> 00:16:49,860
कर्णांसह सर्व समान संज्ञा एकत्रित करता तेव्हा सुमारे 10,000 ऑपरेशन्सचा दुसरा संच आहे. 

266
00:16:50,700 --> 00:16:55,620
सामान्यतः लिंगोमध्ये आपण असे म्हणू शकतो की अल्गोरिदम हे n स्क्वेअरचा O आहे म्हणजे 

267
00:16:55,620 --> 00:17:00,780
आकाराच्या दोन सूचीसाठी n ज्या प्रकारे ऑपरेशन स्केलची संख्या n च्या वर्गाच्या प्रमाणात 

268
00:17:00,780 --> 00:17:01,140
असते. 

269
00:17:01,820 --> 00:17:05,366
दुसरीकडे, जर मी त्यांच्या आउटपुटच्या संदर्भात दोन बहुपदांचा विचार करतो, 

270
00:17:05,366 --> 00:17:08,273
उदाहरणार्थ, काही मूठभर इनपुटवर त्यांची मूल्ये सॅम्पल करणे, 

271
00:17:08,273 --> 00:17:12,066
तर त्यांचा गुणाकार करण्यासाठी पुन्हा नमुन्यांची संख्या जितकी ऑपरेशन्स आवश्यक 

272
00:17:12,066 --> 00:17:15,859
आहेत तितकीच ऑपरेशन्सची आवश्यकता आहे आणि ते पॉईंटवाइज ऑपरेशन आहे आणि आपल्याला 

273
00:17:15,859 --> 00:17:19,406
फक्त बहुपदांसह आवश्यक आहे. गुणांक पुनर्प्राप्त करण्यात सक्षम होण्यासाठी 

274
00:17:19,406 --> 00:17:20,540
निश्चितपणे अनेक नमुने. 

275
00:17:20,540 --> 00:17:25,060
उदाहरणार्थ रेखीय बहुपदी विशिष्टपणे निर्दिष्ट करण्यासाठी दोन आउटपुट पुरेसे आहेत.

276
00:17:25,660 --> 00:17:29,400
चतुर्भुज बहुपदी विशिष्टपणे निर्दिष्ट करण्यासाठी तीन आउटपुट पुरेसे असतील.

277
00:17:29,640 --> 00:17:33,670
आणि सर्वसाधारणपणे तुम्हाला n वेगळे आउटपुट माहित असल्यास ते n भिन्न 

278
00:17:33,670 --> 00:17:37,640
गुणांक असलेल्या बहुपदी विशिष्टपणे निर्दिष्ट करण्यासाठी पुरेसे आहे.

279
00:17:37,780 --> 00:17:40,720
किंवा तुमची इच्छा असल्यास आम्ही समीकरणांच्या प्रणालींच्या भाषेत हे वाक्य सांगू शकतो.

280
00:17:41,200 --> 00:17:43,879
कल्पना करा मी तुम्हाला सांगतो की माझ्याकडे काही बहुपदी आहेत परंतु मी 

281
00:17:43,879 --> 00:17:46,520
तुम्हाला गुणांक काय आहेत हे सांगत नाही, ते तुमच्यासाठी एक रहस्य आहे.

282
00:17:46,700 --> 00:17:48,794
आमच्या उदाहरणात तुम्ही हे उत्पादन म्हणून विचार 

283
00:17:48,794 --> 00:17:50,800
करू शकता जे आम्ही शोधण्याचा प्रयत्न करत आहोत.

284
00:17:50,800 --> 00:17:55,312
मग समजा मी तुम्हाला सांगेन की या बहुपदीचे आउटपुट काय असतील जर तुम्ही 0, 

285
00:17:55,312 --> 00:17:59,574
1, 2, 3, ऑन आणि ऑन असे विविध इनपुट दिले आणि मी तुम्हाला पुरेशी देतो 

286
00:17:59,574 --> 00:18:03,460
जेणेकरून तुमच्याकडे तितकी समीकरणे असतील. तुम्हाला अज्ञात आहेत.

287
00:18:04,140 --> 00:18:07,340
हे समीकरणांची एक रेषीय प्रणाली देखील आहे, त्यामुळे ते छान आहे.

288
00:18:07,780 --> 00:18:10,900
आणि तत्त्वतः, हे गुणांक पुनर्प्राप्त करण्यासाठी पुरेसे असावे.

289
00:18:11,740 --> 00:18:15,255
तेव्हा रफ अल्गोरिदमची रूपरेषा अशी असेल की जेव्हा तुम्ही संख्यांच्या दोन सूची 

290
00:18:15,255 --> 00:18:19,000
तयार करू इच्छित असाल तेव्हा तुम्ही त्यांना दोन बहुपदांचे गुणांक असल्यासारखे वागता.

291
00:18:19,420 --> 00:18:24,494
तुम्ही त्या बहुपदींचा नमुना पुरेशा आउटपुटवर घ्या, ते नमुने पॉइंट-वार गुणाकार करा, 

292
00:18:24,494 --> 00:18:29,755
आणि नंतर कंव्होल्यूशन शोधण्याचा एक गुप्त मार्ग म्हणून गुणांक पुनर्प्राप्त करण्यासाठी 

293
00:18:29,755 --> 00:18:30,560
सिस्टम सोडवा.

294
00:18:31,420 --> 00:18:34,429
आणि मी आतापर्यंत म्हटल्याप्रमाणे, तुमच्यापैकी काहीजण हक्काने 

295
00:18:34,429 --> 00:18:37,340
तक्रार करू शकतात &quot;अनुदान, ही एक मूर्ख योजना आहे&quot;.

296
00:18:37,580 --> 00:18:42,441
कारण एक तर आपल्याला माहित असलेल्या बहुपदीपैकी एकासाठी हे सर्व नमुने मोजणे हे 

297
00:18:42,441 --> 00:18:47,238
n स्क्वेअर ऑपरेशन्सचा क्रम घेते, हे सांगायला नकोच की त्या प्रणालीचे निराकरण 

298
00:18:47,238 --> 00:18:52,100
करणे संगणकीयदृष्ट्या केवळ पहिल्या स्थानावर कनव्होल्यूशन करण्याइतकेच कठीण आहे.

299
00:18:52,600 --> 00:18:56,433
तर, जसे की, गुणाकार आणि परिभ्रमण यांच्यात हा संबंध असल्याची खात्री आहे, 

300
00:18:56,433 --> 00:19:00,480
परंतु सर्व गुंतागुंत एका दृष्टिकोनातून दुसऱ्या दृष्टिकोनातून भाषांतरीत होते.

301
00:19:01,600 --> 00:19:04,670
पण एक युक्ती आहे, आणि तुमच्यापैकी ज्यांना Fourier transforms आणि FFT 

302
00:19:04,670 --> 00:19:07,740
अल्गोरिदम बद्दल माहिती आहे ते कदाचित हे कुठे चालले आहे ते पाहू शकतात.

303
00:19:07,740 --> 00:19:09,936
जर तुम्हाला या विषयांशी अपरिचित असेल, तर मी जे 

304
00:19:09,936 --> 00:19:12,180
सांगणार आहे ते पूर्णपणे निळ्या रंगाचे वाटू शकते.

305
00:19:12,260 --> 00:19:14,676
फक्त हे जाणून घ्या की असे काही मार्ग आहेत जे तुम्ही 

306
00:19:14,676 --> 00:19:16,860
गणितात चालले असता जे याला अपेक्षित पाऊल बनवतात.

307
00:19:17,720 --> 00:19:20,360
मुळात कल्पना अशी आहे की आपल्याला इथे निवडीचे स्वातंत्र्य आहे.

308
00:19:20,540 --> 00:19:25,541
0, 1, 2, 3, चालू आणि चालू सारख्या इनपुटच्या काही अनियंत्रित संचावर मूल्यमापन करण्याऐवजी, 

309
00:19:25,541 --> 00:19:29,700
तुम्ही जटिल संख्यांच्या अतिशय खास निवडलेल्या संचावर मूल्यमापन करणे निवडता.

310
00:19:30,240 --> 00:19:34,840
विशेषत: जे एकक वर्तुळावर समान अंतरावर बसतात, ज्याला एकतेची मुळे म्हणतात.

311
00:19:35,200 --> 00:19:36,880
हे आम्हाला एक अनुकूल प्रणाली देते.

312
00:19:38,360 --> 00:19:42,810
मूळ कल्पना अशी आहे की एक संख्या शोधून जिथे तिची शक्ती घेणे या सायकलिंग पॅटर्नमध्ये येते, 

313
00:19:42,810 --> 00:19:46,960
याचा अर्थ असा होतो की आम्ही तयार करत असलेल्या सिस्टममध्ये तुम्ही गणना करत असलेल्या 

314
00:19:46,960 --> 00:19:50,960
वेगवेगळ्या अटींमध्ये भरपूर रिडंडंसी असणार आहे आणि ते कसे आहे याबद्दल हुशार आहे. 

315
00:19:50,960 --> 00:19:54,460
तुम्ही त्या रिडंडंसीचा फायदा घ्याल, तुम्ही स्वतःला खूप काम वाचवू शकता.

316
00:19:56,020 --> 00:19:59,092
मी लिहिलेल्या आउटपुटच्या या संचाला एक विशेष नाव आहे, 

317
00:19:59,092 --> 00:20:02,280
त्याला गुणांकांचे स्वतंत्र फूरियर ट्रान्सफॉर्म म्हणतात.

318
00:20:02,500 --> 00:20:05,920
आणि जर तुम्हाला अधिक जाणून घ्यायचे असेल तर मी त्याच ज्युलिया एमआयटी 

319
00:20:05,920 --> 00:20:09,140
वर्गासाठी वेगळे फूरियर ट्रान्सफॉर्म्सबद्दल दुसरे व्याख्यान केले.

320
00:20:09,220 --> 00:20:14,569
आणि जलद फूरियर ट्रान्सफॉर्मबद्दल बोलणारा चॅनेलवर एक खरोखर उत्कृष्ट व्हिडिओ देखील आहे, 

321
00:20:14,569 --> 00:20:17,120
जो या अधिक जलद गणनासाठी एक अल्गोरिदम आहे.

322
00:20:17,480 --> 00:20:20,222
तसेच Veritasium ने अलीकडेच FFT वर खरोखर चांगला व्हिडिओ बनवला आहे, 

323
00:20:20,222 --> 00:20:21,760
त्यामुळे तुमच्याकडे बरेच पर्याय आहेत.

324
00:20:22,260 --> 00:20:24,660
आणि ते जलद अल्गोरिदम खरोखरच आमच्यासाठी मुद्दा आहे.

325
00:20:25,120 --> 00:20:30,031
पुन्हा या सर्व रिडंडंसीमुळे गुणांकांपासून या सर्व आउटपुटवर जाण्यासाठी एक पद्धत अस्तित्वात 

326
00:20:30,031 --> 00:20:32,978
आहे, जिथे n स्क्वेअर ऑपरेशन्सच्या क्रमाने करण्याऐवजी, 

327
00:20:32,978 --> 00:20:35,652
तुम्ही n ऑपरेशन्सच्या लॉगच्या n गुणाप्रमाणे करा, 

328
00:20:35,652 --> 00:20:39,200
जे खूप आहे तुम्ही मोठ्या याद्यांमध्ये स्केल कराल तसे बरेच चांगले.

329
00:20:39,660 --> 00:20:42,540
आणि महत्त्वाचे म्हणजे हे एफएफटी अल्गोरिदम दोन्ही प्रकारे जाते.

330
00:20:42,700 --> 00:20:45,480
हे तुम्हाला आऊटपुटमधून गुणांकापर्यंत जाऊ देते.

331
00:20:46,220 --> 00:20:49,060
तर हे सर्व एकत्र आणून, आपल्या अल्गोरिदमची रूपरेषा परत पाहू.

332
00:20:49,420 --> 00:20:53,683
आता आम्ही असे म्हणू शकतो की जेव्हाही तुम्हाला संख्यांच्या दोन लांबलचक याद्या दिल्या जातील 

333
00:20:53,683 --> 00:20:57,710
आणि तुम्हाला त्यांचे संभाषण घ्यायचे असेल, तेव्हा प्रथम त्या प्रत्येकाच्या जलद फूरियर 

334
00:20:57,710 --> 00:21:01,879
ट्रान्सफॉर्मची गणना करा, जे तुमच्या मनाच्या मागे तुम्ही त्यांच्याशी वागण्याचा विचार करू 

335
00:21:01,879 --> 00:21:06,095
शकता. ते बहुपदीचे गुणांक आहेत आणि विशेष निवडलेल्या बिंदूंच्या संचामध्ये त्याचे मूल्यमापन 

336
00:21:06,095 --> 00:21:06,380
करतात.

337
00:21:06,899 --> 00:21:11,141
मग तुम्हाला नुकतेच मिळालेले दोन परिणाम गुणानुसार गुणाकार करा, जे छान आणि जलद आहे, 

338
00:21:11,141 --> 00:21:13,624
आणि नंतर एक व्यस्त जलद फूरियर ट्रान्सफॉर्म करा, 

339
00:21:13,624 --> 00:21:17,451
आणि हे तुम्हाला जे देते ते म्हणजे आम्ही शोधत असलेल्या कनव्होल्यूशनची गणना 

340
00:21:17,451 --> 00:21:18,900
करण्याचा एक गुप्त मार्ग आहे.

341
00:21:19,040 --> 00:21:22,240
पण यावेळी यात फक्त n log n ऑपरेशन्सचा O समावेश आहे.

342
00:21:23,139 --> 00:21:24,740
ते माझ्यासाठी खरोखर छान आहे!

343
00:21:25,120 --> 00:21:29,256
हा अतिशय विशिष्ट संदर्भ जेथे परिभ्रमण दर्शवितो, दोन बहुपदांचा गुणाकार करून, 

344
00:21:29,256 --> 00:21:34,100
अल्गोरिदमसाठी दरवाजे उघडतो जे इतर सर्वत्र जेथे कोन्व्होल्यूशन येऊ शकतात तेथे संबंधित आहे.

345
00:21:34,180 --> 00:21:38,258
तुम्हाला संभाव्यता वितरण जोडायचे असल्यास, काही मोठ्या प्रतिमा प्रक्रिया करा, 

346
00:21:38,258 --> 00:21:39,000
ते काहीही असो.

347
00:21:39,220 --> 00:21:43,161
आणि मला असे वाटते की गणितातील काही ऑपरेशन किंवा संकल्पना बऱ्याच असंबंधित 

348
00:21:43,161 --> 00:21:47,480
क्षेत्रांमध्ये दिसल्यावर तुम्ही का उत्साहित व्हावे याचे हे एक चांगले उदाहरण आहे.

349
00:21:48,480 --> 00:21:51,500
जर तुम्हाला थोडासा गृहपाठ हवा असेल तर येथे विचार करायला मजा येईल असे काहीतरी आहे.

350
00:21:51,720 --> 00:21:55,177
जेव्हा आपण दोन भिन्न संख्यांचा गुणाकार करता, तेव्हा आपण सर्व 

351
00:21:55,177 --> 00:21:58,465
प्राथमिक शाळेत शिकतो त्याप्रमाणे सामान्य गुणाकार का करता, 

352
00:21:58,465 --> 00:22:01,980
आपण जे करत आहात ते मुळात त्या संख्यांच्या अंकांमधील गोंधळ आहे.

353
00:22:02,500 --> 00:22:06,460
कॅरी आणि सारख्या काही जोडलेल्या पायऱ्या आहेत, परंतु मुख्य पायरी ही एक संभ्रम आहे.

354
00:22:07,280 --> 00:22:12,215
वेगवान अल्गोरिदमच्या अस्तित्वाच्या प्रकाशात, जर तुमच्याकडे दोन खूप मोठे पूर्णांक असतील, 

355
00:22:12,215 --> 00:22:15,580
तर त्यांचे उत्पादन शोधण्याचा एक मार्ग आहे जो आम्ही प्राथमिक 

356
00:22:15,580 --> 00:22:17,880
शाळेत शिकतो त्या पद्धतीपेक्षा वेगवान आहे.

357
00:22:18,140 --> 00:22:23,064
n स्क्वेअर ऑपरेशन्सच्या O आवश्यकतेऐवजी फक्त n log n चा O आवश्यक आहे, 

358
00:22:23,064 --> 00:22:24,920
जे शक्य आहे असे वाटत नाही.

359
00:22:25,380 --> 00:22:28,377
पकड अशी आहे की हे प्रत्यक्षात सरावात उपयुक्त होण्याआधी, 

360
00:22:28,377 --> 00:22:30,840
तुमची संख्या पूर्णपणे राक्षसी असणे आवश्यक आहे.

361
00:22:31,220 --> 00:22:35,340
परंतु तरीही, हे छान आहे की असा अल्गोरिदम अस्तित्वात आहे.

362
00:22:35,340 --> 00:22:39,640
पुढे आम्ही संभाव्यता वितरणावर विशेष लक्ष केंद्रित करून सतत केसकडे आमचे लक्ष वळवू.

