1
00:00:00,000 --> 00:00:03,748
समजा, मी तुम्हाला संख्यांच्या दोन भिन्न याद्या, किंवा कदाचित दोन भिन्न कार्ये देतो,

2
00:00:03,748 --> 00:00:07,765
आणि मी तुम्हाला संख्यांची नवीन यादी मिळविण्यासाठी त्या दोन याद्या एकत्रित करण्याच्या सर्व

3
00:00:07,765 --> 00:00:11,782
मार्गांचा विचार करण्यास सांगतो, किंवा नवीन कार्य मिळविण्यासाठी दोन कार्ये एकत्र करू शकता.

4
00:00:11,782 --> 00:00:16,320
. कदाचित मनात येणारा एक सोपा मार्ग म्हणजे त्यांना शब्दानुसार एकत्र जोडणे.

5
00:00:16,320 --> 00:00:20,131
त्याचप्रमाणे फंक्शन्ससह, तुम्ही सर्व संबंधित आउटपुट जोडू शकता.

6
00:00:20,131 --> 00:00:22,952
अशाच प्रकारे, तुम्ही दोन लिस्ट टर्म टर्मनुसार

7
00:00:22,952 --> 00:00:26,202
गुणाकार करू शकता आणि फंक्शन्ससह समान गोष्ट करू शकता.

8
00:00:26,202 --> 00:00:30,348
परंतु या दोन्हींप्रमाणेच आणखी एक प्रकारचा संयोग मूलभूत आहे, परंतु सामान्यत:

9
00:00:30,348 --> 00:00:33,840
फारच कमी चर्चिला जातो, ज्याला कॉन्व्होल्यूशन म्हणून ओळखले जाते.

10
00:00:33,840 --> 00:00:36,928
परंतु मागील दोन प्रकरणांप्रमाणे, ही अशी गोष्ट नाही जी केवळ

11
00:00:36,928 --> 00:00:39,964
एका ऑपरेशनमधून मिळालेली आहे जी तुम्ही संख्यांवर करू शकता.

12
00:00:39,964 --> 00:00:42,755
संख्यांच्या याद्या किंवा फंक्शन्स एकत्रित करण्याच्या

13
00:00:42,755 --> 00:00:44,809
संदर्भासाठी हे खरोखर काहीतरी नवीन आहे.

14
00:00:44,809 --> 00:00:48,400
ते सर्वत्र दिसून येतात, ते इमेज प्रोसेसिंगमध्ये सर्वव्यापी आहेत,

15
00:00:48,400 --> 00:00:51,107
संभाव्यतेच्या सिद्धांतामध्ये ते एक मूळ रचना आहे,

16
00:00:51,107 --> 00:00:54,808
ते विभेदक समीकरणे सोडवण्यासाठी खूप वापरले जातात आणि एक संदर्भ जिथे

17
00:00:54,808 --> 00:00:58,122
तुम्ही जवळजवळ निश्चितपणे पाहिले असेल, जर नसेल तर या नावाने,

18
00:00:58,122 --> 00:01:00,277
दोन बहुपदांचा एकत्र गुणाकार केला जातो.

19
00:01:00,277 --> 00:01:04,825
व्हिज्युअल स्पष्टीकरणाच्या व्यवसायातील कोणीतरी म्हणून, हा विशेषतः चांगला विषय आहे,

20
00:01:04,825 --> 00:01:09,319
कारण एकाकी आणि संदर्भाशिवाय फॉर्म्युलाची व्याख्या एक प्रकारची भीतीदायक वाटू शकते,

21
00:01:09,319 --> 00:01:13,593
परंतु जर आपण ते काय म्हणत आहे ते खरोखर अनपॅक करण्यासाठी वेळ काढला आणि त्याआधी

22
00:01:13,593 --> 00:01:16,827
प्रत्यक्षात का प्रेरित केले. तुम्हाला असे काहीतरी हवे आहे,

23
00:01:16,827 --> 00:01:18,800
हे आश्चर्यकारकपणे सुंदर ऑपरेशन आहे.

24
00:01:18,800 --> 00:01:21,204
आणि मला हे मान्य करावेच लागेल की, या प्रोजेक्टसाठी

25
00:01:21,204 --> 00:01:23,514
व्हिज्युअल्स एकत्र करताना मी खरंच काहीतरी शिकलो.

26
00:01:23,514 --> 00:01:27,120
दोन भिन्न कार्ये एकत्रित करण्याच्या बाबतीत, मी याचा अर्थ काय असू शकतो हे

27
00:01:27,120 --> 00:01:30,727
आपण चित्रित करू शकता अशा वेगवेगळ्या मार्गांनी विचार करण्याचा प्रयत्न करत

28
00:01:30,727 --> 00:01:35,173
होतो आणि त्यापैकी एकासह मला थोडासा अहाहा क्षण मिळाला की सामान्य वितरण ही भूमिका का बजावते.

29
00:01:35,173 --> 00:01:38,483
ते संभाव्यतेनुसार करतात, फंक्शनसाठी ते इतके नैसर्गिक आकार का आहे.

30
00:01:38,483 --> 00:01:41,645
पण मी स्वतःहून पुढे जात आहे, त्यासाठी खूप सेटअप आहे.

31
00:01:41,645 --> 00:01:46,030
या व्हिडिओमध्ये, आमचा प्राथमिक फोकस फक्त वेगळ्या केसवर असेल आणि विशेषत:

32
00:01:46,030 --> 00:01:50,293
या गणनेसाठी एक अतिशय अनपेक्षित परंतु अतिशय हुशार अल्गोरिदम तयार करणे.

33
00:01:50,293 --> 00:01:54,400
आणि मी सतत प्रकरणाची चर्चा दुसऱ्या भागात काढेन.

34
00:01:54,400 --> 00:01:57,872
इमेज प्रोसेसिंगच्या उदाहरणांसह ते उघडणे खूप मोहक आहे,

35
00:01:57,872 --> 00:02:03,209
कारण ते दृश्यदृष्ट्या सर्वात वेधक आहेत, परंतु काही सूक्ष्मता आहेत ज्यामुळे प्रतिमा

36
00:02:03,209 --> 00:02:08,739
प्रक्रिया केस एकंदरीत कमी प्रतिनिधीत्व करतात, म्हणून त्याऐवजी संभाव्यतेसह गोष्टी सुरू

37
00:02:08,739 --> 00:02:14,205
करूया, आणि विशेषतः साध्या उदाहरणांपैकी एक, ज्याचा मला खात्री आहे की येथे प्रत्येकाने

38
00:02:14,205 --> 00:02:19,478
त्यांच्या जीवनात कधीतरी विचार केला असेल, जे फासेची जोडी फिरवत आहे आणि विविध भिन्न

39
00:02:19,478 --> 00:02:21,600
बेरीज पाहण्याची शक्यता शोधत आहे.

40
00:02:21,600 --> 00:02:24,213
आणि तुम्ही म्हणाल, समस्या नाही, समस्या नाही.

41
00:02:24,213 --> 00:02:27,575
तुमच्या प्रत्येक दोन फासेचे सहा वेगवेगळे संभाव्य परिणाम आहेत,

42
00:02:27,575 --> 00:02:31,262
जे आम्हाला एकूण 36 वेगळ्या संभाव्य जोड्या परिणाम देतात आणि जर आम्ही

43
00:02:31,262 --> 00:02:35,600
त्या सर्वांचा विचार केला तर आम्ही मोजू शकतो की किती जोड्या दिलेल्या बेरीज आहेत.

44
00:02:35,600 --> 00:02:39,072
आणि अशा प्रकारे सर्व जोड्या एका ग्रिडमध्ये मांडणे,

45
00:02:39,072 --> 00:02:44,248
एक चांगली गोष्ट म्हणजे स्थिर बेरीज असलेल्या सर्व जोड्या या भिन्न कर्णांपैकी

46
00:02:44,248 --> 00:02:45,678
एकासह दृश्यमान आहेत.

47
00:02:45,678 --> 00:02:48,657
त्यामुळे त्या प्रत्येक कर्णावर किती अस्तित्वात आहेत याची मोजणी

48
00:02:48,657 --> 00:02:51,920
केल्याने तुम्हाला विशिष्ट बेरीज दिसण्याची शक्यता किती आहे हे सांगेल.

49
00:02:51,920 --> 00:02:55,380
आणि मी म्हणेन, खूप चांगले, खूप चांगले, परंतु आपण त्याच प्रश्नाची

50
00:02:55,380 --> 00:02:58,788
कल्पना करू शकणार्‍या इतर कोणत्याही मार्गांचा विचार करू शकता का?

51
00:02:58,788 --> 00:03:01,527
दिलेल्या बेरीज असलेल्या सर्व भिन्न जोड्यांचा विचार

52
00:03:01,527 --> 00:03:03,836
करण्यासाठी मनात येऊ शकणार्‍या इतर प्रतिमा?

53
00:03:03,836 --> 00:03:07,586
आणि कदाचित तुमच्यापैकी कोणीतरी तुमचा हात वर करून म्हणेल, हो, माझ्याकडे एक आहे.

54
00:03:07,586 --> 00:03:11,335
समजा तुम्ही या दोन वेगवेगळ्या शक्यतांचे एका ओळीत चित्र काढता,

55
00:03:11,335 --> 00:03:14,056
परंतु तुम्ही त्या दुसऱ्या पंक्तीभोवती फिरता.

56
00:03:14,056 --> 00:03:18,984
अशा रीतीने सर्व भिन्न जोड्या ज्या सात रेषा पर्यंत उभ्या जोडतात.

57
00:03:18,984 --> 00:03:24,010
आणि जर आपण ती खालची पंक्ती उजवीकडे सरकवली, तर दोन जोडणारी अनोखी जोडी,

58
00:03:24,010 --> 00:03:26,380
सापाचे डोळे, फक्त संरेखित होतात.

59
00:03:26,380 --> 00:03:29,820
आणि जर मी ते एका युनिटवर उजवीकडे झुकवले, तर ज्या जोड्या संरेखित

60
00:03:29,820 --> 00:03:32,938
करतात त्या दोन भिन्न जोड्या असतात ज्या तीन पर्यंत जोडतात.

61
00:03:32,938 --> 00:03:36,249
आणि सर्वसाधारणपणे, या खालच्या अॅरेची वेगवेगळी ऑफसेट व्हॅल्यूज,

62
00:03:36,249 --> 00:03:39,245
ज्यांना आठवते की मला प्रथम इकडे तिकडे फ्लिप करावे लागले,

63
00:03:39,245 --> 00:03:41,926
दिलेल्या बेरीज असलेल्या सर्व भिन्न जोड्या उघड करा.

64
00:03:41,926 --> 00:03:46,603
संभाव्यतेच्या प्रश्नांनुसार, हे अद्याप विशेषतः मनोरंजक नाही,

65
00:03:46,603 --> 00:03:53,120
कारण आम्ही जे काही करत आहोत ते मोजत आहे की या प्रत्येक श्रेणीमध्ये किती परिणाम आहेत.

66
00:03:53,120 --> 00:03:57,941
परंतु यापैकी प्रत्येक चेहऱ्याला समोर येण्याची समान संधी आहे असे गर्भित गृहीत धरून आहे.

67
00:03:57,941 --> 00:04:01,909
पण जर मी तुम्हाला सांगितले की माझ्याकडे फासांचा एक विशेष संच आहे जो एकसमान नाही?

68
00:04:01,909 --> 00:04:05,653
कदाचित निळ्या डाईकडे येणाऱ्या प्रत्येक चेहऱ्याच्या संभाव्यतेचे वर्णन करणाऱ्या

69
00:04:05,653 --> 00:04:09,782
संख्यांचा स्वतःचा संच असेल आणि लाल रंगाचा स्वतःचा विशिष्ट विशिष्ट संख्यांचा संच असेल.

70
00:04:09,782 --> 00:04:14,050
त्या बाबतीत, जर तुम्हाला दोन दिसण्याची संभाव्यता शोधायची असेल,

71
00:04:14,050 --> 00:04:19,943
तर तुम्ही निळ्या रंगाची संभाव्यता लाल रंगाची असण्याची संभाव्यता एक पटीने गुणाकार कराल.

72
00:04:19,943 --> 00:04:25,078
आणि तीन दिसण्याच्या शक्यतेसाठी, तुम्ही दोन वेगळ्या जोड्यांकडे पहा जेथे ते शक्य आहे,

73
00:04:25,078 --> 00:04:30,029
आणि पुन्हा, संबंधित संभाव्यतेचा गुणाकार करा आणि नंतर ती दोन उत्पादने एकत्र जोडा.

74
00:04:30,029 --> 00:04:33,411
त्याचप्रमाणे, चार दिसण्याच्या शक्यतांमध्ये शक्यतांच्या तीन भिन्न

75
00:04:33,411 --> 00:04:36,845
जोड्या एकत्र गुणाकार करणे आणि त्या सर्व एकत्र जोडणे समाविष्ट आहे.

76
00:04:36,845 --> 00:04:41,120
आणि काही सूत्रे सेट करण्याच्या भावनेने, या वरच्या संभाव्यतेला a1, a2,

77
00:04:41,120 --> 00:04:45,946
a3 आणि असेच नाव देऊ या आणि खालच्या संभाव्यांना b1, b2, b3 आणि असेच नाव देऊ या.

78
00:04:45,946 --> 00:04:49,989
आणि सर्वसाधारणपणे, ही प्रक्रिया, जिथे आपण संख्यांचे दोन वेगवेगळे अॅरे घेत आहोत,

79
00:04:49,989 --> 00:04:53,527
दुसऱ्याला आजूबाजूला फ्लिप करत आहोत, आणि नंतर त्यांना वेगवेगळ्या ऑफसेट

80
00:04:53,527 --> 00:04:57,723
व्हॅल्यूजवर लाइनअप करत आहोत, पेअरवाइज उत्पादनांचा एक गुच्छ घेतो आणि त्यांना जोडतो,

81
00:04:57,723 --> 00:05:01,311
ही त्यापैकी एक आहे संभ्रम म्हणजे काय याचा विचार करण्याचे मूलभूत मार्ग.

82
00:05:01,311 --> 00:05:06,115
तर फक्त त्याचे थोडे अधिक अचूक शब्दलेखन करण्यासाठी, या प्रक्रियेद्वारे,

83
00:05:06,115 --> 00:05:11,257
आम्ही फक्त 12 पर्यंत दोन, तीन, चार, वर आणि वर पाहण्यासाठी संभाव्यता निर्माण

84
00:05:11,257 --> 00:05:17,143
केली आणि आम्ही मूल्यांची एक सूची, a आणि दुसरी एकत्र करून ती मिळवली. मूल्यांची यादी, b.

85
00:05:17,143 --> 00:05:22,080
लिंगोमध्ये, आम्ही असे म्हणू की त्या दोन अनुक्रमांच्या संचलनामुळे आम्हाला हा नवीन क्रम,

86
00:05:22,080 --> 00:05:27,188
11 मूल्यांचा नवीन क्रम मिळतो, ज्यापैकी प्रत्येक जोडी उत्पादनांच्या काही बेरीजसारखे दिसते.

87
00:05:27,188 --> 00:05:31,794
तुम्ही प्राधान्य दिल्यास, त्याच ऑपरेशनबद्दल तुम्ही विचार करू शकता असा दुसरा मार्ग

88
00:05:31,794 --> 00:05:36,793
म्हणजे प्रथम सर्व जोडीच्या उत्पादनांची सारणी तयार करणे, आणि नंतर या सर्व कर्णांसह जोडणे.

89
00:05:36,793 --> 00:05:39,728
पुन्हा, 11 संख्यांचा एक नवीन क्रम मिळवण्यासाठी संख्यांच्या

90
00:05:39,728 --> 00:05:42,315
या दोन अनुक्रमांचे मिश्रण करण्याचा हा एक मार्ग आहे.

91
00:05:42,315 --> 00:05:46,400
हे स्लाइडिंग विंडोंप्रमाणेच ऑपरेशन आहे, फक्त दुसरा दृष्टीकोन.

92
00:05:46,400 --> 00:05:50,335
त्यावर थोडेसे नोटेशन टाकून, तुम्हाला ते कसे लिहिलेले दिसेल ते येथे आहे.

93
00:05:50,335 --> 00:05:55,300
या छोट्या तारकाने दर्शविलेले a आणि b चे संचलन ही एक नवीन यादी आहे आणि त्या

94
00:05:55,300 --> 00:06:00,596
यादीतील nवा घटक बेरीज सारखा दिसतो आणि ती बेरीज सर्व वेगवेगळ्या निर्देशांकांच्या

95
00:06:00,596 --> 00:06:04,833
i आणि j वर जाते, जेणेकरून बेरीज ते निर्देशांक n च्या समान आहेत.

96
00:06:04,833 --> 00:06:10,077
हे एक प्रकारचे तोंडी आहे, परंतु उदाहरणार्थ, जर n 6 असेल, तर आपण 1 आणि 5,

97
00:06:10,077 --> 00:06:15,680
2 आणि 4, 3 आणि 3, 4 आणि 2, 5 आणि 1 या सर्व वेगवेगळ्या जोड्या जोडत आहोत. ते 6.

98
00:06:15,680 --> 00:06:19,539
पण प्रामाणिकपणे, तुम्ही ते लिहून ठेवले तरी, या प्रक्रियेसाठी तुम्ही तुमच्या

99
00:06:19,539 --> 00:06:23,145
डोक्यात धारण करू शकणार्‍या व्हिज्युअलसाठी नोटेशनचे महत्त्व दुय्यम आहे.

100
00:06:23,145 --> 00:06:26,515
येथे, कदाचित हे एक अतिशय साधे उदाहरण करण्यास मदत करेल,

101
00:06:26,515 --> 00:06:30,987
जिथे मी तुम्हाला विचारू शकतो की यादी 1, 2, 3 ची यादी 4, 5, 6 सह काय आहे.

102
00:06:30,987 --> 00:06:34,110
तुम्ही या दोन्ही याद्या घेऊन, त्या दुस-या भोवती फिरत,

103
00:06:34,110 --> 00:06:37,926
आणि नंतर त्याच्या झाकणाने डावीकडे सर्व मार्गाने सुरुवात करत असाल.

104
00:06:37,926 --> 00:06:40,790
मग मूल्यांची जोडी जी 1 आणि 4 संरेखित करतात, त्यांना एकत्र

105
00:06:40,790 --> 00:06:43,851
गुणाकार करतात आणि ते आम्हाला आमच्या आउटपुटची पहिली टर्म देते.

106
00:06:43,851 --> 00:06:48,721
त्या खालच्या अॅरेचे एक युनिट उजवीकडे सरकवा, 1 आणि 5 आणि 2 आणि 4 अशा जोड्या संरेखित करा,

107
00:06:48,721 --> 00:06:52,540
त्या जोड्या गुणाकार करा, त्यांना एकत्र जोडा, आणि ते आम्हाला 13 देते,

108
00:06:52,540 --> 00:06:54,367
आमच्या आउटपुटमध्ये पुढील एंट्री.

109
00:06:54,367 --> 00:06:57,934
गोष्टी पुन्हा एकदा सरकवा, आणि आम्ही 1 गुणिले 6,

110
00:06:57,934 --> 00:07:01,651
अधिक 2 गुणिले 5, अधिक 3 गुणिले 4 घेऊ, जे 28 होईल.

111
00:07:01,651 --> 00:07:05,547
आणखी एक स्लाइड, आणि आम्हाला 2 गुणिले 6, अधिक 3 गुणिले 5 मिळेल,

112
00:07:05,547 --> 00:07:10,000
आणि ते आम्हाला 27 देते, आणि शेवटी शेवटची संज्ञा 3 गुणिले 6 सारखी दिसेल.

113
00:07:10,000 --> 00:07:12,912
तुमची इच्छा असल्यास, तुमची आवडती प्रोग्रॅमिंग भाषा आणि तुमची आवडती

114
00:07:12,912 --> 00:07:15,520
लायब्ररी ज्यामध्ये विविध संख्यात्मक ऑपरेशन्स समाविष्ट आहेत,

115
00:07:15,520 --> 00:07:18,910
तुम्ही खेचू शकता आणि मी तुमच्याशी खोटे बोलत नाही याची तुम्ही पुष्टी करू शकता.

116
00:07:18,910 --> 00:07:22,685
जर तुम्ही 1, 2, 3, 4, 5, 6 च्या विरुद्ध 4, 5, 6 चे परिभ्रमण घेतले,

117
00:07:22,685 --> 00:07:24,320
तर हा परिणाम तुम्हाला मिळेल.

118
00:07:24,320 --> 00:07:28,073
आम्ही एक केस पाहिली आहे जिथे हे नैसर्गिक आणि इष्ट ऑपरेशन आहे,

119
00:07:28,073 --> 00:07:32,916
संभाव्यता वितरणास जोडून, आणि दुसरे सामान्य उदाहरण म्हणजे मूव्हिंग एव्हरेज असेल.

120
00:07:32,916 --> 00:07:35,999
कल्पना करा की तुमच्याकडे संख्यांची काही लांबलचक यादी आहे आणि तुम्ही

121
00:07:35,999 --> 00:07:38,811
संख्यांची आणखी एक छोटी यादी घ्या जी सर्व 1 पर्यंत जोडली जाईल.

122
00:07:38,811 --> 00:07:43,420
या प्रकरणात, माझ्याकडे फक्त 5 मूल्यांची एक छोटी यादी आहे, आणि ती सर्व 1 5व्या समान आहेत.

123
00:07:43,420 --> 00:07:47,193
मग जर आपण ही स्लाइडिंग विंडो कॉन्व्होल्युशन प्रक्रिया केली आणि आपले

124
00:07:47,193 --> 00:07:51,243
डोळे बंद केले आणि त्याच्या सुरवातीला जे घडते ते गालिच्याखाली स्वीप केले,

125
00:07:51,243 --> 00:07:55,293
एकदा आपली लहान मूल्यांची सूची मोठ्या मूल्याशी पूर्णपणे ओव्हरलॅप झाली की,

126
00:07:55,293 --> 00:07:59,066
यातील प्रत्येक पद काय आहे याचा विचार करा. convolution म्हणजे खरोखर.

127
00:07:59,066 --> 00:08:03,151
प्रत्येक पुनरावृत्तीवर, तुम्ही जे करत आहात ते म्हणजे तुमच्या डेटामधील

128
00:08:03,151 --> 00:08:07,120
प्रत्येक मूल्याचा 1 5 व्या ने गुणाकार करणे आणि ते सर्व एकत्र जोडणे,

129
00:08:07,120 --> 00:08:10,797
म्हणजे तुम्ही या छोट्या विंडोमध्ये तुमचा डेटा सरासरी घेत आहात.

130
00:08:10,797 --> 00:08:14,576
एकूणच, ही प्रक्रिया तुम्हाला मूळ डेटाची एक गुळगुळीत आवृत्ती देते,

131
00:08:14,576 --> 00:08:18,469
आणि तुम्ही संख्यांच्या वेगळ्या छोट्या सूचीपासून हे बदल करू शकता आणि

132
00:08:18,469 --> 00:08:22,878
जोपर्यंत ती छोटी यादी 1 पर्यंत जोडते, तोपर्यंत तुम्ही त्याचा अर्थ बदलू शकता.

133
00:08:22,878 --> 00:08:27,768
सरासरी येथे दर्शविलेल्या उदाहरणामध्ये, ती हलणारी सरासरी मध्यवर्ती मूल्याकडे अधिक वजन देते.

134
00:08:27,768 --> 00:08:27,822


135
00:08:27,822 --> 00:08:30,720
याचा परिणाम डेटाच्या स्मूथ आउट आवृत्तीमध्ये देखील होतो.

136
00:08:30,720 --> 00:08:34,426
जर तुम्ही याचे द्विमितीय अॅनालॉग केले तर ते तुम्हाला

137
00:08:34,426 --> 00:08:38,691
दिलेल्या इमेजला अस्पष्ट करण्यासाठी एक मजेदार अल्गोरिदम देते.

138
00:08:38,691 --> 00:08:42,783
आणि मी जे अॅनिमेशन दाखवणार आहे ते मी मूळत: एमआयटी येथील ज्युलिया लॅबमध्ये एका विशिष्ट

139
00:08:42,783 --> 00:08:47,064
OpenCourseWare क्लाससाठी केलेल्या व्याख्यानांच्या संचाच्या भागासाठी बनवलेल्या गोष्टींमधून

140
00:08:47,064 --> 00:08:50,918
सुधारित केले आहे, ज्यामध्ये इमेज प्रोसेसिंग युनिट समाविष्ट आहे असे म्हणायला हवे.

141
00:08:50,918 --> 00:08:54,065
तेथे आम्ही या सर्वांच्या मागे असलेल्या कोडमध्ये जाण्यासाठी थोडे अधिक केले आहे,

142
00:08:54,065 --> 00:08:56,456
म्हणून जर तुम्ही उत्सुक असाल तर मी तुम्हाला काही लिंक देईन.

143
00:08:56,456 --> 00:08:59,108
परंतु या अस्पष्ट उदाहरणावर परत लक्ष केंद्रित करताना,

144
00:08:59,108 --> 00:09:03,161
काय चालले आहे ते म्हणजे माझ्या मूळ प्रतिमेच्या बाजूने चालत असलेल्या मूल्यांचा हा

145
00:09:03,161 --> 00:09:07,365
छोटासा 3x3 ग्रिड आहे आणि जर आपण झूम इन केले तर त्यातील प्रत्येक मूल्य 1 9वी आहे आणि

146
00:09:07,365 --> 00:09:11,768
मी काय करत आहे. प्रत्येक पुनरावृत्तीवर त्या प्रत्येक व्हॅल्यूला ते शीर्षस्थानी असलेल्या

147
00:09:11,768 --> 00:09:13,369
संबंधित पिक्सेलने गुणाकारत आहे.

148
00:09:13,369 --> 00:09:16,814
आणि अर्थातच संगणक शास्त्रामध्ये आपण रंगांना लाल,

149
00:09:16,814 --> 00:09:20,400
हिरवे आणि निळे या तीन मूल्यांचे छोटे वेक्टर समजतो.

150
00:09:20,400 --> 00:09:24,690
जेव्हा मी या सर्व लहान मूल्यांना 1 9 व्या ने गुणाकार करतो आणि मी त्यांना एकत्र जोडतो,

151
00:09:24,690 --> 00:09:28,481
तेव्हा ते आम्हाला प्रत्येक रंग चॅनेलसह सरासरी देते आणि उजवीकडील प्रतिमेसाठी

152
00:09:28,481 --> 00:09:31,075
संबंधित पिक्सेल ही बेरीज म्हणून परिभाषित केले जाते.

153
00:09:31,075 --> 00:09:34,855
एकंदरीत परिणाम, जसे की आपण प्रतिमेवरील प्रत्येक पिक्सेलसाठी हे करतो,

154
00:09:34,855 --> 00:09:38,141
प्रत्येक एक प्रकारचा त्याच्या सर्व शेजारी रक्तस्त्राव होतो,

155
00:09:38,141 --> 00:09:40,880
ज्यामुळे आम्हाला मूळपेक्षा अस्पष्ट आवृत्ती मिळते.

156
00:09:40,880 --> 00:09:44,144
लिंगोमध्ये आपण असे म्हणू की उजवीकडील प्रतिमा ही

157
00:09:44,144 --> 00:09:47,885
आपल्या मूळ प्रतिमेची थोडीशी मूल्ये असलेली प्रतिमा आहे.

158
00:09:47,885 --> 00:09:51,024
किंवा अधिक तांत्रिकदृष्ट्या कदाचित मला असे म्हणायचे आहे की हे

159
00:09:51,024 --> 00:09:54,468
मूल्यांच्या त्या छोट्या ग्रिडच्या 180 अंश फिरवलेल्या आवृत्तीसह आहे.

160
00:09:54,468 --> 00:09:58,215
ग्रिड सममितीय आहे हे महत्त्वाचे नाही, परंतु हे लक्षात ठेवण्यासारखे आहे की

161
00:09:58,215 --> 00:10:01,861
शुद्ध गणिताच्या संदर्भातून वारशाने मिळालेल्या कॉन्व्होल्युशनची व्याख्या

162
00:10:01,861 --> 00:10:05,760
नेहमी तुम्हाला त्या दुसऱ्या अॅरेभोवती फिरण्याचा विचार करण्यास आमंत्रित करते.

163
00:10:05,760 --> 00:10:08,454
जर आपण यात थोडासा बदल केला तर भिन्न मूल्यांचा ग्रिड

164
00:10:08,454 --> 00:10:11,148
निवडून आपल्याला अधिक मोहक अस्पष्ट प्रभाव मिळू शकतो.

165
00:10:11,148 --> 00:10:15,920
या प्रकरणात माझ्याकडे थोडे 5x5 ग्रिड आहे, परंतु फरक त्याच्या आकारात इतका नाही.

166
00:10:15,920 --> 00:10:19,364
जर आपण झूम इन केले तर आपल्या लक्षात येते की मध्यभागी असलेले मूल्य हे

167
00:10:19,364 --> 00:10:23,856
कडांच्या दिशेने असलेल्या मूल्यापेक्षा खूप मोठे आहे आणि हे कोठून येत आहे ते सर्व बेल वक्र,

168
00:10:23,856 --> 00:10:26,102
गौसियन वितरण म्हणून ओळखले जाणारे नमुना आहेत.

169
00:10:26,102 --> 00:10:30,967
अशा प्रकारे जेव्हा आपण या सर्व मूल्यांचा ते वर बसलेल्या संबंधित पिक्सेलने गुणाकार करतो,

170
00:10:30,967 --> 00:10:34,228
तेव्हा आपण त्या मध्यवर्ती पिक्सेलला खूप जास्त वजन देतो आणि

171
00:10:34,228 --> 00:10:36,439
काठावर असलेल्या पिक्सेलला खूप कमी देतो.

172
00:10:36,439 --> 00:10:40,475
आणि उजवीकडील संबंधित पिक्सेलच्या आधी ही बेरीज म्हणून परिभाषित केली आहे.

173
00:10:40,475 --> 00:10:43,335
आम्ही प्रत्येक पिक्सेलसाठी ही प्रक्रिया करत असताना ते एक

174
00:10:43,335 --> 00:10:46,598
अस्पष्ट प्रभाव देते जे अधिक प्रमाणिकपणे तुमच्या लेन्सला फोकसच्या

175
00:10:46,598 --> 00:10:49,760
बाहेर ठेवण्याच्या कल्पनेचे अनुकरण करते किंवा असे काहीतरी करते.

176
00:10:49,760 --> 00:10:53,504
परंतु अस्पष्ट करणे ही एकमेव गोष्ट आहे जी आपण या कल्पनेसह करू शकता.

177
00:10:53,504 --> 00:10:56,502
उदाहरणार्थ, मूल्यांच्या या छोट्या ग्रिडवर एक नजर टाका,

178
00:10:56,502 --> 00:11:00,755
ज्यात डावीकडे काही सकारात्मक संख्या आणि उजवीकडे काही ऋण संख्या समाविष्ट आहेत,

179
00:11:00,755 --> 00:11:03,099
ज्यांना मी अनुक्रमे निळा आणि लाल रंग देईन.

180
00:11:03,099 --> 00:11:06,489
याचा अंतिम प्रतिमेवर काय परिणाम होईल याचा अंदाज

181
00:11:06,489 --> 00:11:09,808
आणि समजू शकतो का ते पाहण्यासाठी थोडा वेळ द्या.

182
00:11:09,808 --> 00:11:14,010
तर या प्रकरणात मी चित्राचा रंगीत ऐवजी ग्रेस्केल म्हणून विचार करेन,

183
00:11:14,010 --> 00:11:18,149
म्हणून प्रत्येक पिक्सेल तीन ऐवजी फक्त एका संख्येने दर्शविला जाईल.

184
00:11:18,149 --> 00:11:20,411
आणि एक गोष्ट लक्षात घेण्यासारखी आहे की आपण हे

185
00:11:20,411 --> 00:11:23,164
कव्होल्यूशन करत असताना नकारात्मक मूल्ये मिळणे शक्य आहे.

186
00:11:23,164 --> 00:11:27,229
उदाहरणार्थ या टप्प्यावर जर आपण आपल्या छोट्या ग्रिडच्या डाव्या अर्ध्या भागामध्ये झूम

187
00:11:27,229 --> 00:11:31,052
केला तर पूर्णपणे काळ्या पिक्सेलच्या शीर्षस्थानी बसतो, ज्याचे मूल्य शून्य असेल,

188
00:11:31,052 --> 00:11:35,360
परंतु उजव्या निगेटिव्ह व्हॅल्यूचा अर्धा भाग पांढर्‍या पिक्सेलच्या वर बसेल, एक मूल्य आहे.

189
00:11:35,360 --> 00:11:38,945
म्हणून जेव्हा आपण संबंधित संज्ञांचा गुणाकार करतो आणि त्यांना एकत्र जोडतो तेव्हा

190
00:11:38,945 --> 00:11:42,487
परिणाम खूप नकारात्मक होतील आणि मी ज्या प्रकारे हे उजवीकडील प्रतिमेसह प्रदर्शित

191
00:11:42,487 --> 00:11:46,117
करत आहे ते म्हणजे नकारात्मक मूल्यांना लाल आणि सकारात्मक मूल्यांना निळा रंग देणे.

192
00:11:46,117 --> 00:11:50,625
आणखी एक गोष्ट लक्षात घेण्यासारखी आहे की जेव्हा तुम्ही एकाच रंगाच्या पॅचवर असता तेव्हा

193
00:11:50,625 --> 00:11:54,871
सर्व काही शून्यावर जाते कारण आमच्या छोट्या ग्रिडमधील मूल्यांची बेरीज शून्य असते.

194
00:11:54,871 --> 00:11:59,165
हे मागील दोन उदाहरणांपेक्षा खूप वेगळे आहे जेथे आमच्या छोट्या ग्रिडची बेरीज एक होती,

195
00:11:59,165 --> 00:12:03,050
ज्यामुळे आपण त्याचा मूव्हिंग एव्हरेज म्हणून अर्थ लावू आणि त्यामुळे अस्पष्ट.

196
00:12:03,050 --> 00:12:06,620
या सर्व छोट्या प्रक्रियेत मुळात तुम्ही डावीकडून उजवीकडे जाताना पिक्सेल

197
00:12:06,620 --> 00:12:10,139
मूल्यामध्ये कुठेही फरक असेल ते शोधून काढले जाते आणि त्यामुळे तुम्हाला

198
00:12:10,139 --> 00:12:13,760
तुमच्या प्रतिमेतील सर्व उभ्या किनारी उचलण्याचा एक प्रकारचा मार्ग मिळतो.

199
00:12:13,760 --> 00:12:20,204
आणि त्याचप्रमाणे जर आपण तो ग्रिड फिरवला की आपण वरपासून खालपर्यंत जाताना ते बदलत जाईल,

200
00:12:20,204 --> 00:12:25,149
हे सर्व आडव्या कडा वर उचलले जाईल, जे आपल्या लहान पाई प्राण्याच्या

201
00:12:25,149 --> 00:12:30,020
प्रतिमेच्या बाबतीत काही सुंदर राक्षसी डोळ्यांमध्ये परिणाम करतात.

202
00:12:30,020 --> 00:12:32,302
तसे, या लहान ग्रिडला बर्‍याचदा कर्नल म्हटले जाते,

203
00:12:32,302 --> 00:12:35,817
आणि येथे सौंदर्य हे आहे की भिन्न कर्नल निवडून तुम्ही भिन्न प्रतिमा प्रक्रिया

204
00:12:35,817 --> 00:12:39,651
प्रभाव कसे मिळवू शकता, केवळ तुमची किनार ओळखणे अस्पष्ट नाही तर तीक्ष्ण करण्यासारख्या

205
00:12:39,651 --> 00:12:40,792
गोष्टी देखील मिळवू शकता.

206
00:12:40,792 --> 00:12:44,178
तुमच्यापैकी ज्यांनी कन्व्होल्युशनल न्यूरल नेटवर्कबद्दल ऐकले आहे

207
00:12:44,178 --> 00:12:47,882
त्यांच्यासाठी न्यूरल नेटवर्कला जे काही शोधायचे आहे त्यावरून निर्धारित

208
00:12:47,882 --> 00:12:51,691
केल्यानुसार कर्नल काय असावेत हे शोधण्यासाठी डेटा वापरण्याची कल्पना आहे.

209
00:12:51,691 --> 00:12:55,457
दुसरी गोष्ट मी कदाचित आणली पाहिजे ती म्हणजे आउटपुटची लांबी.

210
00:12:55,457 --> 00:12:59,532
मूव्हिंग अॅव्हरेज उदाहरणासारख्या गोष्टीसाठी तुम्ही फक्त अटींबद्दल विचार करू

211
00:12:59,532 --> 00:13:03,231
शकता जेव्हा दोन्ही विंडो पूर्णपणे एकमेकांशी संरेखित होतात किंवा इमेज

212
00:13:03,231 --> 00:13:07,789
प्रोसेसिंगच्या उदाहरणामध्ये कदाचित तुम्हाला अंतिम आउटपुटचा आकार मूळ सारखाच हवा असेल.

213
00:13:07,789 --> 00:13:12,136
आता प्युअर मॅथ ऑपरेशन म्‍हणून कॉन्व्होल्यूशन्‍स नेहमी तुम्‍ही सुरू करण्‍याच्‍या दोन

214
00:13:12,136 --> 00:13:16,431
अॅरेपेक्षा मोठा अ‍ॅरे तयार करतात, किमान त्‍यापैकी एकाची लांबी नाही असे गृहीत धरून.

215
00:13:16,431 --> 00:13:19,186
फक्त हे जाणून घ्या की काही संगणक विज्ञान संदर्भांमध्ये

216
00:13:19,186 --> 00:13:21,440
तुम्हाला ते आउटपुट जाणीवपूर्वक कापायचे असते.

217
00:13:21,440 --> 00:13:26,752
आणखी एक गोष्ट अधोरेखित करण्यासारखी आहे की संगणक विज्ञानाच्या संदर्भात त्या कर्नलला

218
00:13:26,752 --> 00:13:32,064
मूळ ओलांडून पुढे जाण्याआधी त्याभोवती फिरण्याची ही कल्पना अनेकदा खरोखरच विचित्र आणि

219
00:13:32,064 --> 00:13:37,376
केवळ अप्रत्याशित वाटते, परंतु पुन्हा लक्षात घ्या की शुद्ध गणिताच्या संदर्भातून हाच

220
00:13:37,376 --> 00:13:42,560
वारसा मिळाला आहे. संभाव्यतेसह पाहिले की ही एक आश्चर्यकारकपणे नैसर्गिक गोष्ट आहे.

221
00:13:42,560 --> 00:13:45,892
आणि खरं तर मी तुम्हाला आणखी एक शुद्ध गणिताचे उदाहरण दाखवू शकतो

222
00:13:45,892 --> 00:13:49,013
जिथे प्रोग्रामरने देखील याची काळजी घेतली पाहिजे कारण ते या

223
00:13:49,013 --> 00:13:52,399
सर्वांची गणना करण्यासाठी खूप वेगवान अल्गोरिदमसाठी दरवाजे उघडते.

224
00:13:52,399 --> 00:13:55,896
येथे मला काय म्हणायचे आहे ते अधिक जलद सेट करण्यासाठी मी परत जाऊ आणि

225
00:13:55,896 --> 00:13:59,651
काही अजगर पुन्हा खेचू आणि मी दोन भिन्न तुलनेने मोठे अॅरे तयार करणार आहे.

226
00:13:59,651 --> 00:14:03,387
प्रत्येकामध्ये एक लाख यादृच्छिक घटक असतील आणि मी numpy

227
00:14:03,387 --> 00:14:07,598
लायब्ररीतून convolve फंक्शनच्या रनटाइमचे मूल्यांकन करणार आहे.

228
00:14:07,598 --> 00:14:11,277
आणि या प्रकरणात ते एकाधिक वेगवेगळ्या पुनरावृत्तीसाठी चालवते,

229
00:14:11,277 --> 00:14:16,403
सरासरी शोधण्याचा प्रयत्न करते आणि या संगणकावर किमान 4 वर सरासरी असे दिसते. 87 सेकंद.

230
00:14:16,403 --> 00:14:21,028
याउलट जर मी स्किपी लायब्ररीमधील fftconvolve नावाचे वेगळे फंक्शन

231
00:14:21,028 --> 00:14:26,376
वापरत असलो तर तीच गोष्ट वेगळ्या पद्धतीने अंमलात आणली जाते जी फक्त 4 घेते.

232
00:14:26,376 --> 00:14:30,640
सरासरी 3 मिलीसेकंद, त्यामुळे परिमाण सुधारण्याचे तीन ऑर्डर.

233
00:14:30,640 --> 00:14:34,555
आणि जरी ते वेगळ्या नावाने उडत असले तरी ते इतर कॉन्व्हॉल्व्ह फंक्शन

234
00:14:34,555 --> 00:14:38,880
प्रमाणेच आउटपुट देत आहे, ते फक्त त्याबद्दल अधिक हुशारीने काहीतरी करत आहे.

235
00:14:38,880 --> 00:14:43,521
लक्षात ठेवा की संभाव्यतेच्या उदाहरणासह मी म्हटल्याचा दुसरा मार्ग म्हणजे

236
00:14:43,521 --> 00:14:48,291
तुम्ही कन्व्होल्यूशनचा विचार करू शकता तो म्हणजे सर्व पेअरवाइज उत्पादनांचे

237
00:14:48,291 --> 00:14:52,611
हे टेबल तयार करणे आणि नंतर ती पेअरवाइज उत्पादने कर्णरेषांसह जोडणे.

238
00:14:52,611 --> 00:14:55,907
तुम्ही अशा प्रकारे विचार करू शकता अशा संख्येच्या दोन भिन्न याद्या

239
00:14:55,907 --> 00:14:59,352
तुम्ही गुंतवून ठेवता तेव्हा संभाव्यतेसाठी अर्थातच काही विशिष्ट नाही.

240
00:14:59,352 --> 00:15:02,851
सर्व जोड्यानिहाय उत्पादनांसह अशा प्रकारचे गुणाकार सारणी तयार करा आणि नंतर

241
00:15:02,851 --> 00:15:06,492
कर्णाच्या बाजूची प्रत्येक बेरीज तुमच्या अंतिम आउटपुटपैकी एकाशी संबंधित असेल.

242
00:15:06,492 --> 00:15:12,513
एक संदर्भ जेथे हे दृश्य विशेषतः नैसर्गिक आहे जेव्हा तुम्ही दोन बहुपदी एकत्र गुणाकार करता.

243
00:15:12,513 --> 00:15:18,410
उदाहरणार्थ मी आमच्याकडे आधीपासून असलेली छोटी ग्रिड घेऊ आणि वरच्या संज्ञा 1,

244
00:15:18,410 --> 00:15:23,920
2x आणि 3x स्क्वेअरने बदलू आणि इतर संज्ञा 4, 5x आणि 6x स्क्वेअरने बदलू.

245
00:15:23,920 --> 00:15:26,464
आता आपण दोन सूचींमध्ये ही सर्व भिन्न जोडी उत्पादने

246
00:15:26,464 --> 00:15:28,760
तयार करत असताना याचा अर्थ काय याचा विचार करा.

247
00:15:28,760 --> 00:15:33,292
तुम्ही जे करत आहात ते मूलत: मी लिहिलेल्या दोन बहुपदींच्या पूर्ण उत्पादनाचा

248
00:15:33,292 --> 00:15:38,006
विस्तार करत आहे आणि नंतर जेव्हा तुम्ही कर्ण सोबत जोडता जे सर्व सारख्या संज्ञा

249
00:15:38,006 --> 00:15:42,478
एकत्रित करण्याशी संबंधित आहे जे अतिशय व्यवस्थित आहे बहुपदीचा विस्तार करणे

250
00:15:42,478 --> 00:15:47,011
आणि अटींसारख्या संकलित करणे हे नक्की आहे. एक convolution सारखीच प्रक्रिया.

251
00:15:47,011 --> 00:15:49,853
परंतु हे आम्हाला खूप छान असे काहीतरी करण्यास अनुमती

252
00:15:49,853 --> 00:15:52,696
देते कारण आम्ही येथे काय म्हणत आहोत याचा विचार करा.

253
00:15:52,696 --> 00:15:57,969
आम्ही म्हणतो की तुम्ही दोन भिन्न फंक्शन्स घेतलीत आणि तुम्ही त्यांचा एकत्र गुणाकार करत

254
00:15:57,969 --> 00:16:03,119
असाल जे एक साधे पॉइंटवाइज ऑपरेशन आहे जे तुम्ही प्रथम बहुपदी आहेत असे गृहीत धरलेल्या

255
00:16:03,119 --> 00:16:07,534
प्रत्येकाचे गुणांक काढले असतील आणि नंतर त्यांचे एक परिभ्रमण घेतले असेल.

256
00:16:07,534 --> 00:16:08,821
गुणकांच्या दोन सूची.

257
00:16:08,821 --> 00:16:13,508
हे इतके मनोरंजक काय आहे की कॉन्व्होल्यूशन हे तत्त्वतः साध्या गुणाकारापेक्षा

258
00:16:13,508 --> 00:16:17,764
खूपच क्लिष्ट वाटते आणि मला असे म्हणायचे नाही की संकल्पनात्मकदृष्ट्या

259
00:16:17,764 --> 00:16:22,266
ते विचार करणे कठिण आहे, म्हणजे गणनेच्या दृष्टीने कंव्होल्यूशन करण्यासाठी

260
00:16:22,266 --> 00:16:26,089
अधिक पायऱ्या आवश्यक आहेत. दोन भिन्न सूचींचे पॉइंटवार उत्पादन.

261
00:16:26,089 --> 00:16:30,919
उदाहरणार्थ, समजा की मी तुम्हाला दोन खरोखरच मोठ्या बहुपदी दिल्या आहेत प्रत्येक शंभर

262
00:16:30,919 --> 00:16:35,516
भिन्न गुणांकांसह म्हणा, मग जर तुम्ही त्यांचा गुणाकार करण्याच्या पद्धतीनुसार या

263
00:16:35,516 --> 00:16:40,113
उत्पादनाचा विस्तार कराल तर तुम्हाला हे संपूर्ण 100 बाय 100 ग्रिडमध्ये पेअरवाइज

264
00:16:40,113 --> 00:16:44,768
उत्पादनांचे ग्रिड भरावे लागेल. 10,000 भिन्न उत्पादने करा आणि नंतर जेव्हा तुम्ही

265
00:16:44,768 --> 00:16:49,773
कर्णांसह सर्व समान संज्ञा एकत्रित करता तेव्हा सुमारे 10,000 ऑपरेशन्सचा दुसरा संच आहे.

266
00:16:49,773 --> 00:16:55,033
सामान्यतः लिंगोमध्ये आपण असे म्हणू शकतो की अल्गोरिदम हे n स्क्वेअरचा O आहे म्हणजे

267
00:16:55,033 --> 00:17:00,550
आकाराच्या दोन सूचीसाठी n ज्या प्रकारे ऑपरेशन स्केलची संख्या n च्या वर्गाच्या प्रमाणात

268
00:17:00,550 --> 00:17:00,935
असते.

269
00:17:00,935 --> 00:17:04,766
दुसरीकडे, जर मी त्यांच्या आउटपुटच्या संदर्भात दोन बहुपदांचा विचार करतो,

270
00:17:04,766 --> 00:17:07,904
उदाहरणार्थ, काही मूठभर इनपुटवर त्यांची मूल्ये सॅम्पल करणे,

271
00:17:07,904 --> 00:17:12,001
तर त्यांचा गुणाकार करण्यासाठी पुन्हा नमुन्यांची संख्या जितकी ऑपरेशन्स आवश्यक

272
00:17:12,001 --> 00:17:16,097
आहेत तितकीच ऑपरेशन्सची आवश्यकता आहे आणि ते पॉईंटवाइज ऑपरेशन आहे आणि आपल्याला

273
00:17:16,097 --> 00:17:19,928
फक्त बहुपदांसह आवश्यक आहे. गुणांक पुनर्प्राप्त करण्यात सक्षम होण्यासाठी

274
00:17:19,928 --> 00:17:21,152
निश्चितपणे अनेक नमुने.

275
00:17:21,152 --> 00:17:25,214
उदाहरणार्थ रेखीय बहुपदी विशिष्टपणे निर्दिष्ट करण्यासाठी दोन आउटपुट पुरेसे आहेत.

276
00:17:25,214 --> 00:17:29,360
चतुर्भुज बहुपदी विशिष्टपणे निर्दिष्ट करण्यासाठी तीन आउटपुट पुरेसे असतील.

277
00:17:29,360 --> 00:17:33,159
आणि सर्वसाधारणपणे तुम्हाला n वेगळे आउटपुट माहित असल्यास ते n भिन्न

278
00:17:33,159 --> 00:17:36,901
गुणांक असलेल्या बहुपदी विशिष्टपणे निर्दिष्ट करण्यासाठी पुरेसे आहे.

279
00:17:36,901 --> 00:17:41,188
किंवा तुमची इच्छा असल्यास आम्ही समीकरणांच्या प्रणालींच्या भाषेत हे वाक्य सांगू शकतो.

280
00:17:41,188 --> 00:17:43,853
कल्पना करा मी तुम्हाला सांगतो की माझ्याकडे काही बहुपदी आहेत परंतु मी

281
00:17:43,853 --> 00:17:46,480
तुम्हाला गुणांक काय आहेत हे सांगत नाही, ते तुमच्यासाठी एक रहस्य आहे.

282
00:17:46,480 --> 00:17:48,618
आमच्या उदाहरणात तुम्ही हे उत्पादन म्हणून विचार

283
00:17:48,618 --> 00:17:50,666
करू शकता जे आम्ही शोधण्याचा प्रयत्न करत आहोत.

284
00:17:50,666 --> 00:17:55,344
मग समजा मी तुम्हाला सांगेन की या बहुपदीचे आउटपुट काय असतील जर तुम्ही 0,

285
00:17:55,344 --> 00:17:59,763
1, 2, 3, ऑन आणि ऑन असे विविध इनपुट दिले आणि मी तुम्हाला पुरेशी देतो

286
00:17:59,763 --> 00:18:03,791
जेणेकरून तुमच्याकडे तितकी समीकरणे असतील. तुम्हाला अज्ञात आहेत.

287
00:18:03,791 --> 00:18:07,245
हे समीकरणांची एक रेषीय प्रणाली देखील आहे, त्यामुळे ते छान आहे.

288
00:18:07,245 --> 00:18:11,137
आणि तत्त्वतः, हे गुणांक पुनर्प्राप्त करण्यासाठी पुरेसे असावे.

289
00:18:11,137 --> 00:18:15,067
तेव्हा रफ अल्गोरिदमची रूपरेषा अशी असेल की जेव्हा तुम्ही संख्यांच्या दोन सूची

290
00:18:15,067 --> 00:18:19,253
तयार करू इच्छित असाल तेव्हा तुम्ही त्यांना दोन बहुपदांचे गुणांक असल्यासारखे वागता.

291
00:18:19,253 --> 00:18:24,770
तुम्ही त्या बहुपदींचा नमुना पुरेशा आउटपुटवर घ्या, ते नमुने पॉइंट-वार गुणाकार करा,

292
00:18:24,770 --> 00:18:30,490
आणि नंतर कंव्होल्यूशन शोधण्याचा एक गुप्त मार्ग म्हणून गुणांक पुनर्प्राप्त करण्यासाठी

293
00:18:30,490 --> 00:18:31,364
सिस्टम सोडवा.

294
00:18:31,364 --> 00:18:34,516
आणि मी आतापर्यंत म्हटल्याप्रमाणे, तुमच्यापैकी काहीजण हक्काने

295
00:18:34,516 --> 00:18:37,564
तक्रार करू शकतात &quot;अनुदान, ही एक मूर्ख योजना आहे&quot;.

296
00:18:37,564 --> 00:18:42,616
कारण एक तर आपल्याला माहित असलेल्या बहुपदीपैकी एकासाठी हे सर्व नमुने मोजणे हे

297
00:18:42,616 --> 00:18:47,603
n स्क्वेअर ऑपरेशन्सचा क्रम घेते, हे सांगायला नकोच की त्या प्रणालीचे निराकरण

298
00:18:47,603 --> 00:18:52,656
करणे संगणकीयदृष्ट्या केवळ पहिल्या स्थानावर कनव्होल्यूशन करण्याइतकेच कठीण आहे.

299
00:18:52,656 --> 00:18:56,741
तर, जसे की, गुणाकार आणि परिभ्रमण यांच्यात हा संबंध असल्याची खात्री आहे,

300
00:18:56,741 --> 00:19:01,054
परंतु सर्व गुंतागुंत एका दृष्टिकोनातून दुसऱ्या दृष्टिकोनातून भाषांतरीत होते.

301
00:19:01,054 --> 00:19:04,364
पण एक युक्ती आहे, आणि तुमच्यापैकी ज्यांना Fourier transforms आणि FFT

302
00:19:04,364 --> 00:19:07,673
अल्गोरिदम बद्दल माहिती आहे ते कदाचित हे कुठे चालले आहे ते पाहू शकतात.

303
00:19:07,673 --> 00:19:09,901
जर तुम्हाला या विषयांशी अपरिचित असेल, तर मी जे

304
00:19:09,901 --> 00:19:12,176
सांगणार आहे ते पूर्णपणे निळ्या रंगाचे वाटू शकते.

305
00:19:12,176 --> 00:19:15,015
फक्त हे जाणून घ्या की असे काही मार्ग आहेत जे तुम्ही

306
00:19:15,015 --> 00:19:17,582
गणितात चालले असता जे याला अपेक्षित पाऊल बनवतात.

307
00:19:17,582 --> 00:19:20,697
मुळात कल्पना अशी आहे की आपल्याला इथे निवडीचे स्वातंत्र्य आहे.

308
00:19:20,697 --> 00:19:25,820
0, 1, 2, 3, चालू आणि चालू सारख्या इनपुटच्या काही अनियंत्रित संचावर मूल्यमापन करण्याऐवजी,

309
00:19:25,820 --> 00:19:30,080
तुम्ही जटिल संख्यांच्या अतिशय खास निवडलेल्या संचावर मूल्यमापन करणे निवडता.

310
00:19:30,080 --> 00:19:34,894
विशेषत: जे एकक वर्तुळावर समान अंतरावर बसतात, ज्याला एकतेची मुळे म्हणतात.

311
00:19:34,894 --> 00:19:37,364
हे आम्हाला एक अनुकूल प्रणाली देते.

312
00:19:37,364 --> 00:19:42,308
मूळ कल्पना अशी आहे की एक संख्या शोधून जिथे तिची शक्ती घेणे या सायकलिंग पॅटर्नमध्ये येते,

313
00:19:42,308 --> 00:19:46,919
याचा अर्थ असा होतो की आम्ही तयार करत असलेल्या सिस्टममध्ये तुम्ही गणना करत असलेल्या

314
00:19:46,919 --> 00:19:51,363
वेगवेगळ्या अटींमध्ये भरपूर रिडंडंसी असणार आहे आणि ते कसे आहे याबद्दल हुशार आहे.

315
00:19:51,363 --> 00:19:55,252
तुम्ही त्या रिडंडंसीचा फायदा घ्याल, तुम्ही स्वतःला खूप काम वाचवू शकता.

316
00:19:55,252 --> 00:19:58,645
मी लिहिलेल्या आउटपुटच्या या संचाला एक विशेष नाव आहे,

317
00:19:58,645 --> 00:20:02,166
त्याला गुणांकांचे स्वतंत्र फूरियर ट्रान्सफॉर्म म्हणतात.

318
00:20:02,166 --> 00:20:05,740
आणि जर तुम्हाला अधिक जाणून घ्यायचे असेल तर मी त्याच ज्युलिया एमआयटी

319
00:20:05,740 --> 00:20:09,103
वर्गासाठी वेगळे फूरियर ट्रान्सफॉर्म्सबद्दल दुसरे व्याख्यान केले.

320
00:20:09,103 --> 00:20:14,628
आणि जलद फूरियर ट्रान्सफॉर्मबद्दल बोलणारा चॅनेलवर एक खरोखर उत्कृष्ट व्हिडिओ देखील आहे,

321
00:20:14,628 --> 00:20:17,263
जो या अधिक जलद गणनासाठी एक अल्गोरिदम आहे.

322
00:20:17,263 --> 00:20:20,288
तसेच Veritasium ने अलीकडेच FFT वर खरोखर चांगला व्हिडिओ बनवला आहे,

323
00:20:20,288 --> 00:20:21,984
त्यामुळे तुमच्याकडे बरेच पर्याय आहेत.

324
00:20:21,984 --> 00:20:24,786
आणि ते जलद अल्गोरिदम खरोखरच आमच्यासाठी मुद्दा आहे.

325
00:20:24,786 --> 00:20:29,846
पुन्हा या सर्व रिडंडंसीमुळे गुणांकांपासून या सर्व आउटपुटवर जाण्यासाठी एक पद्धत अस्तित्वात

326
00:20:29,846 --> 00:20:32,883
आहे, जिथे n स्क्वेअर ऑपरेशन्सच्या क्रमाने करण्याऐवजी,

327
00:20:32,883 --> 00:20:35,638
तुम्ही n ऑपरेशन्सच्या लॉगच्या n गुणाप्रमाणे करा,

328
00:20:35,638 --> 00:20:39,293
जे खूप आहे तुम्ही मोठ्या याद्यांमध्ये स्केल कराल तसे बरेच चांगले.

329
00:20:39,293 --> 00:20:42,386
आणि महत्त्वाचे म्हणजे हे एफएफटी अल्गोरिदम दोन्ही प्रकारे जाते.

330
00:20:42,386 --> 00:20:45,515
हे तुम्हाला आऊटपुटमधून गुणांकापर्यंत जाऊ देते.

331
00:20:45,515 --> 00:20:49,054
तर हे सर्व एकत्र आणून, आपल्या अल्गोरिदमची रूपरेषा परत पाहू.

332
00:20:49,054 --> 00:20:53,507
आता आम्ही असे म्हणू शकतो की जेव्हाही तुम्हाला संख्यांच्या दोन लांबलचक याद्या दिल्या जातील

333
00:20:53,507 --> 00:20:57,712
आणि तुम्हाला त्यांचे संभाषण घ्यायचे असेल, तेव्हा प्रथम त्या प्रत्येकाच्या जलद फूरियर

334
00:20:57,712 --> 00:21:02,066
ट्रान्सफॉर्मची गणना करा, जे तुमच्या मनाच्या मागे तुम्ही त्यांच्याशी वागण्याचा विचार करू

335
00:21:02,066 --> 00:21:06,469
शकता. ते बहुपदीचे गुणांक आहेत आणि विशेष निवडलेल्या बिंदूंच्या संचामध्ये त्याचे मूल्यमापन

336
00:21:06,469 --> 00:21:06,766
करतात.

337
00:21:06,766 --> 00:21:11,036
मग तुम्हाला नुकतेच मिळालेले दोन परिणाम गुणानुसार गुणाकार करा, जे छान आणि जलद आहे,

338
00:21:11,036 --> 00:21:13,535
आणि नंतर एक व्यस्त जलद फूरियर ट्रान्सफॉर्म करा,

339
00:21:13,535 --> 00:21:17,389
आणि हे तुम्हाला जे देते ते म्हणजे आम्ही शोधत असलेल्या कनव्होल्यूशनची गणना

340
00:21:17,389 --> 00:21:18,847
करण्याचा एक गुप्त मार्ग आहे.

341
00:21:18,847 --> 00:21:22,957
पण यावेळी यात फक्त n log n ऑपरेशन्सचा O समावेश आहे.

342
00:21:22,957 --> 00:21:24,865
ते माझ्यासाठी खरोखर छान आहे!

343
00:21:24,865 --> 00:21:29,181
हा अतिशय विशिष्ट संदर्भ जेथे परिभ्रमण दर्शवितो, दोन बहुपदांचा गुणाकार करून,

344
00:21:29,181 --> 00:21:34,235
अल्गोरिदमसाठी दरवाजे उघडतो जे इतर सर्वत्र जेथे कोन्व्होल्यूशन येऊ शकतात तेथे संबंधित आहे.

345
00:21:34,235 --> 00:21:38,117
तुम्हाला संभाव्यता वितरण जोडायचे असल्यास, काही मोठ्या प्रतिमा प्रक्रिया करा,

346
00:21:38,117 --> 00:21:38,822
ते काहीही असो.

347
00:21:38,822 --> 00:21:43,105
आणि मला असे वाटते की गणितातील काही ऑपरेशन किंवा संकल्पना बऱ्याच असंबंधित

348
00:21:43,105 --> 00:21:47,798
क्षेत्रांमध्ये दिसल्यावर तुम्ही का उत्साहित व्हावे याचे हे एक चांगले उदाहरण आहे.

349
00:21:47,798 --> 00:21:51,967
जर तुम्हाला थोडासा गृहपाठ हवा असेल तर येथे विचार करायला मजा येईल असे काहीतरी आहे.

350
00:21:51,967 --> 00:21:55,322
जेव्हा आपण दोन भिन्न संख्यांचा गुणाकार करता, तेव्हा आपण सर्व

351
00:21:55,322 --> 00:21:58,513
प्राथमिक शाळेत शिकतो त्याप्रमाणे सामान्य गुणाकार का करता,

352
00:21:58,513 --> 00:22:01,924
आपण जे करत आहात ते मुळात त्या संख्यांच्या अंकांमधील गोंधळ आहे.

353
00:22:01,924 --> 00:22:06,785
कॅरी आणि सारख्या काही जोडलेल्या पायऱ्या आहेत, परंतु मुख्य पायरी ही एक संभ्रम आहे.

354
00:22:06,785 --> 00:22:12,119
वेगवान अल्गोरिदमच्या अस्तित्वाच्या प्रकाशात, जर तुमच्याकडे दोन खूप मोठे पूर्णांक असतील,

355
00:22:12,119 --> 00:22:15,755
तर त्यांचे उत्पादन शोधण्याचा एक मार्ग आहे जो आम्ही प्राथमिक

356
00:22:15,755 --> 00:22:18,240
शाळेत शिकतो त्या पद्धतीपेक्षा वेगवान आहे.

357
00:22:18,240 --> 00:22:23,361
n स्क्वेअर ऑपरेशन्सच्या O आवश्यकतेऐवजी फक्त n log n चा O आवश्यक आहे,

358
00:22:23,361 --> 00:22:25,291
जे शक्य आहे असे वाटत नाही.

359
00:22:25,291 --> 00:22:28,579
पकड अशी आहे की हे प्रत्यक्षात सरावात उपयुक्त होण्याआधी,

360
00:22:28,579 --> 00:22:31,280
तुमची संख्या पूर्णपणे राक्षसी असणे आवश्यक आहे.

361
00:22:31,280 --> 00:22:34,445
परंतु तरीही, हे छान आहे की असा अल्गोरिदम अस्तित्वात आहे.

362
00:22:34,445 --> 00:22:40,000
पुढे आम्ही संभाव्यता वितरणावर विशेष लक्ष केंद्रित करून सतत केसकडे आमचे लक्ष वळवू.

