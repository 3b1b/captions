[
 {
  "input": "Suppose I give you two different lists of numbers, or maybe two different functions, and I ask you to think of all the ways you might combine those two lists to get a new list of numbers, or combine the two functions to get a new function.",
  "translatedText": "",
  "from_community_srt": "제가 당신에게 두 개의 다른 숫자 목록 또는 두 개의 다른 함수를 제공하고, 이 두 목록을 결합하여 새로운 숫자 목록을 얻거나 두 함수를 결합하여 새 함수를 얻을 수 있는 모든 방법을 생각해 보라고 가정해봅시다.",
  "n_reviews": 0,
  "start": 0.0,
  "end": 11.32
 },
 {
  "input": "Maybe one simple way that comes to mind is to simply add them together term by term.",
  "translatedText": "",
  "from_community_srt": "마음에 떠오르는 한 가지 간단한 방법은 단순히 항끼리 함께 더하는 것입니다.",
  "n_reviews": 0,
  "start": 12.12,
  "end": 16.76
 },
 {
  "input": "Likewise with the functions, you can add all the corresponding outputs.",
  "translatedText": "",
  "from_community_srt": "마찬가지로, 함수에서도 해당 함수값을 모두 더할 수 있습니다.",
  "n_reviews": 0,
  "start": 17.16,
  "end": 19.92
 },
 {
  "input": "In a similar vein, you could also multiply the two lists term by term and do the same thing with the functions.",
  "translatedText": "",
  "from_community_srt": "비슷한 맥락에서, 두 목록을 구간별로 곱하고 함수로도 동일한 작업을 수행할 수도 있습니다.",
  "n_reviews": 0,
  "start": 20.54,
  "end": 25.68
 },
 {
  "input": "But there's another kind of combination just as fundamental as both of those, but a lot less commonly discussed, known as a convolution.",
  "translatedText": "",
  "from_community_srt": "그러나 이 두 가지 조합만큼 기본적이지만 일반적으로 덜 언급되는 합성곱(Convolution)으로 알려져 있는 또 다른 종류의 조합이 있습니다.",
  "n_reviews": 0,
  "start": 26.36,
  "end": 33.5
 },
 {
  "input": "But unlike the previous two cases, it's not something that's merely inherited from an operation you can do to numbers.",
  "translatedText": "",
  "from_community_srt": "그러나 앞의 두 경우와 달리, 단순히 숫자에 적용되는 연산에 연관된 것이 아닙니다.",
  "n_reviews": 0,
  "start": 34.08,
  "end": 39.82
 },
 {
  "input": "It's something genuinely new for the context of lists of numbers or combining functions.",
  "translatedText": "",
  "from_community_srt": "이것은 숫자의 목록 또는 함수의 결합과 같은 맥락에서 진정으로 새로운 것입니다.",
  "n_reviews": 0,
  "start": 39.98,
  "end": 44.7
 },
 {
  "input": "They show up all over the place, they are ubiquitous in image processing, it's a core construct in the theory of probability, they're used a lot in solving differential equations, and one context where you've almost certainly seen it, if not by this name, is multiplying two polynomials together.",
  "translatedText": "",
  "from_community_srt": "이들은 주위 어디든지 나타나있고, 사진 처리에서 아주 흔합니다. 이것은 확률론의 핵심 구조이며, 미분 방정식을 푸는 데 많이 사용되며 그리고 \"합성곱\"이라는 용어를 못 봤더라도, 여러분은 다항식을 서로 곱하는 것과 같은 맥락에서 많이 봤을 겁니다.",
  "n_reviews": 0,
  "start": 45.32,
  "end": 60.24
 },
 {
  "input": "As someone in the business of visual explanations, this is an especially great topic, because the formulaic definition in isolation and without context can look kind of intimidating, but if we take the time to really unpack what it's saying, and before that actually motivate why you would want something like this, it's an incredibly beautiful operation.",
  "translatedText": "",
  "from_community_srt": "시각적 설명에 종사하는 사람으로서는, 이것은 특히 훌륭한 주제입니다. 왜냐하면 고립되고 예시가 없는 공식으로 된 정의는 겁 주는 것처럼 보일 수 있기 때문입니다. 하지만 만약 우리가 시간을 내서 이것이 무엇을 말하고 있는지 분석하고 그 전에, 여러분이 왜 이런 것을 원하는지에 대한 동기를 부여한다면, 이것은 믿을 수 없을 정도로 아름다운 작업입니다.",
  "n_reviews": 0,
  "start": 60.74,
  "end": 78.32
 },
 {
  "input": "And I have to admit, I actually learned a little something while putting together the visuals for this project.",
  "translatedText": "",
  "from_community_srt": "그리고 저도 이 프로젝트를 위한 시각 요소를 준비하는 동안, 실제로 저도 약간은 더 배웠다는 것을 인정합니다.",
  "n_reviews": 0,
  "start": 78.96,
  "end": 83.54
 },
 {
  "input": "In the case of convolving two different functions, I was trying to think of different ways you might picture what that could mean, and with one of them I had a little bit of an aha moment for why it is that normal distributions play the role that they do in probability, why it's such a natural shape for a function.",
  "translatedText": "",
  "from_community_srt": "서로 다른 두 함수를 합성곱하는 경우, 저는 여러분들이 이것의 의미를 상상하는 것과 다른 방법들로 생각하려고 노력했습니다. 그리고 이들 중 하나에서, 저는 정규 분포가 확률론에서 왜 이런 역할을 하는지에 대해, 깨달음을 가졌습니다. 왜 정규 분포가 함수에 대해 그렇게 자연스러운 모양일까요,",
  "n_reviews": 0,
  "start": 83.54,
  "end": 98.52
 },
 {
  "input": "But I'm getting ahead of myself, there's a lot of setup for that one.",
  "translatedText": "",
  "from_community_srt": "저는 제 자신을 앞서가고 있습니다. 이것에는 많은 설정이 있습니다.",
  "n_reviews": 0,
  "start": 99.02,
  "end": 101.52
 },
 {
  "input": "In this video, our primary focus is just going to be on the discrete case, and in particular building up to a very unexpected but very clever algorithm for computing these.",
  "translatedText": "",
  "from_community_srt": "이 비디오에서 우리의 주된 초점은 이산적인 사례에 맞춰질 것이고, 특히 이런것들을 계산하기 위한, 매우 예상은 못했지만 매우 영리한 알고리즘을 만드는 것입니다.",
  "n_reviews": 0,
  "start": 101.84,
  "end": 110.26
 },
 {
  "input": "And I'll pull out the discussion for the continuous case into a second part.",
  "translatedText": "",
  "n_reviews": 0,
  "start": 110.26,
  "end": 114.48
 },
 {
  "input": "It's very tempting to open up with the image processing examples, since they're visually the most intriguing, but there are a couple bits of finickiness that make the image processing case less representative of convolutions overall, so instead let's kick things off with probability, and in particular one of the simplest examples that I'm sure everyone here has thought about at some point in their life, which is rolling a pair of dice and figuring out the chances of seeing various different sums.",
  "translatedText": "",
  "from_community_srt": "그리고 저는 연속적인 사례에 대한 논의를 두 번째 파트에 끌어올 것입니다. 시각적으로 가장 흥미롭기 때문에, 이미지 처리 사례로 시작하고 싶은 유혹이 크지만 이미지 처리 사례가 전체적으로 합성곱을 덜 대표한다는 약간의 까다로움이 있습니다. 그래서, 대신에 확률론으로 시작해봅시다. 그리고 특히, 모든 사람들이 그들의 삶의 어느 순간에 대해 생각해본다고 확신하는 가장 간단한 예 중 하나입니다. 바로, 주사위를 굴리고 다양한 합계를 볼 수 있는 확률을 알아내는 것입니다.",
  "n_reviews": 0,
  "start": 118.58,
  "end": 141.5
 },
 {
  "input": "And you might say, not a problem, not a problem.",
  "translatedText": "",
  "from_community_srt": "그리고 여러분은 별거 없다고 말할 수 있습니다. 실제로 그렇습니다.",
  "n_reviews": 0,
  "start": 142.46,
  "end": 144.46
 },
 {
  "input": "Each of your two dice has six different possible outcomes, which gives us a total of 36 distinct possible pairs of outcomes, and if we just look through them all we can count up how many pairs have a given sum.",
  "translatedText": "",
  "from_community_srt": "두 개의 주사위 각각에는 6개의 다른 가능한 결과가 있으므로 총 36개의 서로 다른 가능한 결과 쌍을 제공합니다. 그리고 그것들을 모두 살펴보면, 주어진 합계를 가진 쌍이 몇 개인지 셀 수 있습니다.",
  "n_reviews": 0,
  "start": 144.68,
  "end": 155.86
 },
 {
  "input": "And arranging all the pairs in a grid like this, one pretty nice thing is that all of the pairs that have a constant sum are visible along one of these different diagonals.",
  "translatedText": "",
  "from_community_srt": "모든 쌍을 이와 같이 격자에 배열하면, 한 가지 매우 좋은 점은 합계가 일정한 모든 쌍이 서로 다른 대각선 중 하나를 따라 표시된다는 것입니다.",
  "n_reviews": 0,
  "start": 156.6,
  "end": 165.44
 },
 {
  "input": "So simply counting how many exist on each of those diagonals will tell you how likely you are to see a particular sum.",
  "translatedText": "",
  "from_community_srt": "따라서 각 대각선에 존재하는 숫자를 세는 것만으로 특정 합계를 볼 확률이 얼마나 되는지 알 수 있습니다.",
  "n_reviews": 0,
  "start": 165.44,
  "end": 172.12
 },
 {
  "input": "And I'd say, very good, very good, but can you think of any other ways that you might visualize the same question?",
  "translatedText": "",
  "from_community_srt": "그리고 전 말합니다, 아주 좋아, 아주 좋아.",
  "n_reviews": 0,
  "start": 173.22,
  "end": 178.66
 },
 {
  "input": "Other images that can come to mind to think of all the distinct pairs that have a given sum?",
  "translatedText": "",
  "from_community_srt": "그러나 여러분은 동일한 질문을 시각화할 수 있는 다른 방법을 생각할 수 있나요? 주어진 합계를 갖는 모든 별개의 쌍을 생각할 수 있는,",
  "n_reviews": 0,
  "start": 179.3,
  "end": 184.06
 },
 {
  "input": "And maybe one of you raises your hand and says, yeah, I've got one.",
  "translatedText": "",
  "from_community_srt": "마음에 떠오르는 다른 그림이 있나요? 그리고 아마도 여러분 중 한 명이 손을 들고 '예아, 난 있습니다.'라고 말할 수도 있습니다.",
  "n_reviews": 0,
  "start": 184.86,
  "end": 187.98
 },
 {
  "input": "Let's say you picture these two different sets of possibilities each in a row, but you flip around that second row.",
  "translatedText": "",
  "from_community_srt": "이 두 가지 다른 확률 세트를 각각 행에 그려보고, 두 번째 행을 뒤집는다고 가정해 보겠습니다.",
  "n_reviews": 0,
  "start": 188.28,
  "end": 193.76
 },
 {
  "input": "That way all of the different pairs which add up to seven line up vertically like this.",
  "translatedText": "",
  "from_community_srt": "그런 식으로, 7로 더해지는 모든 서로 다른 쌍은 다음과 같이 세로로 정렬됩니다.",
  "n_reviews": 0,
  "start": 193.76,
  "end": 198.76
 },
 {
  "input": "And if we slide that bottom row all the way to the right, then the unique pair that adds up to two, the snake eyes, are the only ones that align, and if I schlunk that over one unit to the right, the pairs which align are the two different pairs that add up to three.",
  "translatedText": "",
  "from_community_srt": "그리고 맨 아래 행을 *왼쪽으로 끝까지 밀면, 합이 2인 *뱀의 눈만 정렬됩니다. (The Snake Eyes; 2개 주사위에서 1만 나온 상태) 그리고 이것을 오른쪽으로 한 단위 밀면, 정렬되는 쌍은 서로 다른 두 쌍이 되고 합은 3이 됩니다.",
  "n_reviews": 0,
  "start": 199.36,
  "end": 212.08
 },
 {
  "input": "And in general, different offset values of this lower array, which remember I had to flip around first, reveal all the distinct pairs that have a given sum.",
  "translatedText": "",
  "from_community_srt": "그리고 일반적으로 이 하위 배열의 다른 오프셋 값은, 제가 이것을 먼저 뒤집어야 했다는 것을 기억하고,",
  "n_reviews": 0,
  "start": 212.88,
  "end": 221.46
 },
 {
  "input": "As far as probability questions go, this still isn't especially interesting because all we're doing is counting how many outcomes there are in each of these categories.",
  "translatedText": "",
  "from_community_srt": "주어진 합계를 갖는 모든 개별 쌍을 나타냅니다. 확률 질문이 진행될수록, 우리가 하는 모든 것은 이러한 각 범주에 얼마나 많은 결과가 있는지 세는 것이므로 이것은 여전히 특별히 흥미롭지 않습니다.",
  "n_reviews": 0,
  "start": 224.82,
  "end": 232.64
 },
 {
  "input": "But that is with the implicit assumption that there's an equal chance for each of these faces to come up.",
  "translatedText": "",
  "from_community_srt": "하지만 이는 각 면이 나올 확률이 같다는 암묵적인 가정에 따른 것입니다.",
  "n_reviews": 0,
  "start": 232.98,
  "end": 238.12
 },
 {
  "input": "But what if I told you I have a special set of dice that's not uniform?",
  "translatedText": "",
  "n_reviews": 0,
  "start": 238.36,
  "end": 241.62
 },
 {
  "input": "Maybe the blue die has its own set of numbers describing the probabilities for each face coming up, and the red die has its own unique distinct set of numbers.",
  "translatedText": "",
  "from_community_srt": "하지만 균등하지 않은 특별한 주사위 세트가 있다고 말하면 어떻게 될까요? 파란색 주사위에는 각 면이 나올 확률을 나타내는 고유한 숫자 집합이 있고 빨간색 주사위에도 고유한 숫자 집합이 있을 수 있습니다.",
  "n_reviews": 0,
  "start": 242.06,
  "end": 249.76
 },
 {
  "input": "In that case, if you wanted to figure out, say, the probability of seeing a 2, you would multiply the probability that the blue die is a 1 times the probability that the red die is a 1.",
  "translatedText": "",
  "from_community_srt": "이 경우 예를 들어 2가 나올 확률을 알고 싶다면, 파란색 주사위가 1일 확률에 빨간색 주사위가 1일 확률을 곱하면 됩니다.",
  "n_reviews": 0,
  "start": 250.3,
  "end": 259.86
 },
 {
  "input": "And for the chances of seeing a 3, you look at the two distinct pairs where that's possible, and again multiply the corresponding probabilities and then add those two products together.",
  "translatedText": "",
  "from_community_srt": "그리고 3이 나올 확률을 얻으려면, 그것이 가능한 두 개의 별개의 쌍을 보고 해당 확률들을 다시 곱한 다음 이 두 곱들을 함께 더합니다.",
  "n_reviews": 0,
  "start": 260.28,
  "end": 269.68
 },
 {
  "input": "Similarly, the chances of seeing a 4 involves multiplying together three different pairs of possibilities and adding them all together.",
  "translatedText": "",
  "from_community_srt": "마찬가지로, 4가 나올 확률은 세 가지 다른 확률 쌍을 곱하고 모두 더하는 것입니다.",
  "n_reviews": 0,
  "start": 270.1,
  "end": 276.82
 },
 {
  "input": "And in the spirit of setting up some formulas, let's name these top probabilities a 1, a 2, a 3, and so on, and name the bottom ones b 1, b 2, b 3, and so on.",
  "translatedText": "",
  "from_community_srt": "그리고 어떤 공식을 만든다는 정신으로, 이 위에 있는 확률의 이름을 \"𝒂₁, 𝒂₂, 𝒂₃\" 등으로 지정하고 밑에 있는 확률의 이름을 \"𝒃₁, 𝒃₂, 𝒃₃\" 등으로 지정하겠습니다.",
  "n_reviews": 0,
  "start": 276.82,
  "end": 285.96
 },
 {
  "input": "And in general, this process where we're taking two different arrays of numbers, flipping the second one around, and then lining them up at various different offset values, taking a bunch of pairwise products and adding them up, that's one of the fundamental ways to think about what a convolution is.",
  "translatedText": "",
  "from_community_srt": "그리고 일반적으로, 두 개의 서로 다른 숫자 배열을 사용하여, 두 번째 배열을 뒤집은 다음 다양한 오프셋 값에 정렬하고, 여러 쌍의 곱을 가져와 더하는 이 과정이 합성곱이 뭔지 생각할 수 있는 근본적인 방법입니다.",
  "n_reviews": 0,
  "start": 286.4,
  "end": 301.62
 },
 {
  "input": "So just to spell it out a little more exactly, through this process, we just generated probabilities for seeing 2, 3, 4, on and on up to 12, and we got them by mixing together one list of values, a, and another list of values, b.",
  "translatedText": "",
  "from_community_srt": "그래서, 이 과정에 관해 좀 더 정확하게 설명하자면, 우리는 2, 3, 4, 계속해서 최대 12까지 나올 확률을 생성했습니다. 그리고 하나의 값 목록 𝒂와 다른 값 목록 𝒃를 함께 혼합하여 값을 얻었습니다.",
  "n_reviews": 0,
  "start": 304.86,
  "end": 316.98
 },
 {
  "input": "In the lingo, we'd say the convolution of those two sequences gives us this new sequence, the new sequence of 11 values, each of which looks like some sum of pairwise products.",
  "translatedText": "",
  "from_community_srt": "전문 용어로, 우리는 이 두 배열의 합성곱이 우리에게 이 새로운 배열을 제공한다고 말합니다. 11개 값의 새로운 배열은, 각 값은 쌍들의 곱의 합처럼 보입니다.",
  "n_reviews": 0,
  "start": 317.44,
  "end": 327.34
 },
 {
  "input": "If you prefer, another way you could think about the same operation is to first create a table of all the pairwise products, and then add up along all these diagonals.",
  "translatedText": "",
  "from_community_srt": "원하는 경우, 동일한 연산에 대해 생각할 수 있는 또 다른 방법은 먼저 모든 쌍들의 곱을 격자로 만든 다음 이러한 모든 대각선을 따라 더하는 것입니다.",
  "n_reviews": 0,
  "start": 327.34,
  "end": 336.98
 },
 {
  "input": "Again, that's a way of mixing together these two sequences of numbers to get us a new sequence of 11 numbers.",
  "translatedText": "",
  "from_community_srt": "다시 말하지만, 이것은 이 두 개의 숫자 배열을 함께 혼합하여 새로운 11개의 숫자 배열을 얻는 방법입니다.",
  "n_reviews": 0,
  "start": 337.46,
  "end": 342.76
 },
 {
  "input": "It's the same operation as the sliding windows thought, just another perspective.",
  "translatedText": "",
  "from_community_srt": "그리고 이것은 *슬라이딩 창으로 했던 동일한 연산이며, 단지 다른 관점일 뿐입니다.",
  "n_reviews": 0,
  "start": 343.24,
  "end": 346.46
 },
 {
  "input": "Putting a little notation to it, here's how you might see it written down.",
  "translatedText": "",
  "from_community_srt": "(이전 영상 참고) 약간의 표기법을 적용하면,",
  "n_reviews": 0,
  "start": 347.14,
  "end": 349.8
 },
 {
  "input": "The convolution of a and b, denoted with this little asterisk, is a new list, and the nth element of that list looks like a sum, and that sum goes over all different pairs of indices, i and j, so that the sum of those indices is equal to n.",
  "translatedText": "",
  "from_community_srt": "다음과 같이 쓰여진 것을 볼 수 있습니다. 이 작은 *로 표시된 𝒂와 𝒃의 합성곱은 새로운 목록입니다. 그리고 그 목록의 n번째 요소는, 합처럼 보이고 그 합은 인덱스의 모든 다른 쌍인 𝒊와 𝒋에 적용되므로 해당 인덱스의 합은 𝒏과 같습니다.",
  "n_reviews": 0,
  "start": 350.22,
  "end": 364.86
 },
 {
  "input": "It's kind of a mouthful, but for example, if n was 6, the pairs we're going over are 1 and 5, 2 and 4, 3 and 3, 4 and 2, 5 and 1, all the different pairs that add up to 6.",
  "translatedText": "",
  "from_community_srt": "길고 복잡한 말인거 같지만, 예를 들어 𝒏이 6이라면 우리가 살펴볼 쌍들은 1과 5, 2와 4, 3과 3, 4와 2, 5와 1입니다. 이 모든 다른 쌍들은 6으로 더해집니다.",
  "n_reviews": 0,
  "start": 365.28,
  "end": 375.8
 },
 {
  "input": "But honestly, however you write it down, the notation is secondary in importance to the visual you might hold in your head for the process.",
  "translatedText": "",
  "from_community_srt": "그러나 솔직히, 여러분이 어떻게 기록하든, 표기법은 여러분이 그 과정을 여러분의 머리 속에 간직할 수 있는 시각적인 것보다 중요하지는 않습니다.",
  "n_reviews": 0,
  "start": 376.62,
  "end": 382.34
 },
 {
  "input": "Here, maybe it helps to do a super simple example, where I might ask you what's the convolution of the list 1, 2, 3 with the list 4, 5, 6.",
  "translatedText": "",
  "from_community_srt": "여기에서, 제가 여러분에게 물어볼 수 있는 아주 간단한 예를 생각하는 것이 도움이 될 것입니다. 목록 1, 2, 3과 목록 4, 5,",
  "n_reviews": 0,
  "start": 383.28,
  "end": 390.78
 },
 {
  "input": "You might picture taking both of these lists, flipping around that second one, and then starting with its lid all the way over to the left.",
  "translatedText": "",
  "from_community_srt": "6의 합성곱은 무엇이나요? 여러분은 이 두 목록을 모두 가져와, 두 번째 목록을 뒤집은 다음 왼쪽 끝에서 슬라이딩을 시작하는 것을 상상할 수 있습니다.",
  "n_reviews": 0,
  "start": 391.48,
  "end": 397.68
 },
 {
  "input": "Then the pair of values which align are 1 and 4, multiply them together, and that gives us our first term of our output.",
  "translatedText": "",
  "from_community_srt": "그런 다음 정렬되는 값의 쌍은 1과 4이고, 함께 곱하면 결과값의 첫 번째 항이 제공됩니다.",
  "n_reviews": 0,
  "start": 398.18,
  "end": 403.54
 },
 {
  "input": "Slide that bottom array one unit to the right, the pairs which align are 1, 5 and 2 and 4, multiply those pairs, add them together, and that gives us 13, the next entry in our output.",
  "translatedText": "",
  "from_community_srt": "아래 배열을 오른쪽으로 한 단위 밀어서, 정렬되는 쌍은 1, 5, 2 그리고 4입니다. 이 쌍을 곱하고, 서로 더하면 13이 됩니다. 이 결과값의 다음 항입니다.",
  "n_reviews": 0,
  "start": 403.96,
  "end": 414.46
 },
 {
  "input": "Slide things over once more, and we'll take 1 times 6 plus 2 times 5 plus 3 times 4, which happens to be 28.",
  "translatedText": "",
  "from_community_srt": "한 번 더 슬라이드하면, 1×6+2×5+3×4이므로 28이 됩니다.",
  "n_reviews": 0,
  "start": 414.96,
  "end": 421.56
 },
 {
  "input": "One more slide and we get 2 times 6 plus 3 times 5, and that gives us 27.",
  "translatedText": "",
  "from_community_srt": "한 번 더 슬라이드하면,",
  "n_reviews": 0,
  "start": 422.02,
  "end": 427.02
 },
 {
  "input": "And finally the last term will look like 3 times 6.",
  "translatedText": "",
  "from_community_srt": "2×6+3×5인 27이 되고 마지막 항은 3×6처럼 보입니다.",
  "n_reviews": 0,
  "start": 427.5,
  "end": 430.12
 },
 {
  "input": "If you'd like, you can pull up whatever your favorite programming language is and your favorite library that includes various numerical operations, and you can confirm I'm not lying to you.",
  "translatedText": "",
  "from_community_srt": "원하는 경우, 좋아하는 프로그래밍 언어와 다양한 수치 연산이 포함된 라이브러리를 가져올 수 있으며, 제가 거짓말을 하고 있지 않다는 것을 확인할 수 있습니다.",
  "n_reviews": 0,
  "start": 430.66,
  "end": 438.98
 },
 {
  "input": "If you take the convolution of 1, 2, 3 against 4, 5, 6, this is indeed the result that you'll get.",
  "translatedText": "",
  "from_community_srt": "4, 5, 6에 대해 1, 2, 3의 합성곱을 취하면 실제로 얻을 수 있는 결과입니다.",
  "n_reviews": 0,
  "start": 438.98,
  "end": 444.48
 },
 {
  "input": "We've seen one case where this is a natural and desirable operation, adding up to probability distributions, and another common example would be a moving average.",
  "translatedText": "",
  "from_community_srt": "우리는 이것이 확률 분포에 추가되는 자연스럽고 바람직한 연산이라는 경우를 한 번 보았습니다. 그리고 또 다른 일반적인 예는 이동 평균입니다.",
  "n_reviews": 0,
  "start": 445.92,
  "end": 453.66
 },
 {
  "input": "Imagine you have some long list of numbers, and you take another smaller list of numbers that all add up to 1.",
  "translatedText": "",
  "from_community_srt": "긴 숫자 목록이 있고, 모두 더하면 1이 되는 더 작은 숫자 목록이 하나 더 있다고 상상해봅시다.",
  "n_reviews": 0,
  "start": 454.08,
  "end": 459.76
 },
 {
  "input": "In this case, I just have a little list of 5 values and they're all equal to 1 5th.",
  "translatedText": "",
  "from_community_srt": "이 경우에는, 5개의 값이 있는 작은 목록이 있고 모두 ⅕로 같습니다.",
  "n_reviews": 0,
  "start": 460.1,
  "end": 464.06
 },
 {
  "input": "Then if we do this sliding window convolution process, and kind of close our eyes and sweep under the rug what happens at the very beginning of it, once our smaller list of values entirely overlaps with the bigger one, think about what each term in this convolution really means.",
  "translatedText": "",
  "from_community_srt": "그런 다음 이 슬라이딩 창 합성곱 과정을 실행하고, 눈을 감은 거와 같이 이 과정을 숨긴다면 맨 처음에 했었던 *일이 발생합니다. (이전 영상 참고) 우리의 작은 값의 목록이 더 큰 값의 목록과 완전히 겹치면, 이 합성곱의 각 구간이 실제로 무엇을 의미하는지 생각해봅시다.",
  "n_reviews": 0,
  "start": 464.06,
  "end": 478.7
 },
 {
  "input": "At each iteration, what you're doing is multiplying each of the values from your data by 1 5th and adding them all together, which is to say you're taking an average of your data inside this little window.",
  "translatedText": "",
  "from_community_srt": "각 반복에서, 실행하는 연산은 데이터의 각 값에 ⅕을 곱하고 모두 더하는 것입니다. 즉, 이 작은 창에서 데이터의 평균을 구하고 있습니다.",
  "n_reviews": 0,
  "start": 479.4,
  "end": 490.52
 },
 {
  "input": "Overall, the process gives you a smoothed out version of the original data, and you could modify this starting with a different little list of numbers, and as long as that little list all adds up to 1, you can still interpret it as a moving average.",
  "translatedText": "",
  "from_community_srt": "전반적으로, 이 프로세스는 원본 데이터에 비해 부드러운 버전을 제공합니다. 그리고 모두 더하면 1이 되는 다른 숫자 목록으로 수정해도, 이를 여전히 이동 평균으로 해석할 수 있습니다.",
  "n_reviews": 0,
  "start": 491.1,
  "end": 502.72
 },
 {
  "input": "In the example shown here, that moving average would be giving more weight towards the central value.",
  "translatedText": "",
  "from_community_srt": "여기에 표시된 예에서, 해당 이동 평균은 중앙 값에 더 많은 가중치를 부여합니다.",
  "n_reviews": 0,
  "start": 503.4,
  "end": 507.76
 },
 {
  "input": "This also results in a smoothed out version of the data.",
  "translatedText": "",
  "n_reviews": 0,
  "start": 508.42,
  "end": 510.8
 },
 {
  "input": "If you do kind of a two-dimensional analog of this, it gives you a fun algorithm for blurring a given image.",
  "translatedText": "",
  "from_community_srt": "이것은 또한 데이터의 부드러운 버전을 생성합니다. 이것을 2차원 아날로그에 수행하면, 주어진 이미지를 흐리게 하는 재미있는 알고리즘을 제공합니다.",
  "n_reviews": 0,
  "start": 513.14,
  "end": 518.72
 },
 {
  "input": "And I should say the animations I'm about to show are modified from something I originally made for part of a set of lectures I did with the Julia lab at MIT for a certain open courseware class that included an image processing unit.",
  "translatedText": "",
  "from_community_srt": "그리고 제가 보여주려는 애니메이션은, 이미지 처리 과정이 포함된 특정 공개 교육용 수업을 위해 MIT의 Julia Lab과 함께 했던, 제가 원래 만든 강의의 일부에서 수정되었습니다.",
  "n_reviews": 0,
  "start": 518.72,
  "end": 531.08
 },
 {
  "input": "There we did a little bit more to dive into the code behind all of this, so if you're curious, I'll leave you some links.",
  "translatedText": "",
  "from_community_srt": "거기에서 우리는 이 모든 것 뒤에 있는 코드에 대해 조금 더 자세히 살펴보았습니다. 그래서 궁금하신 분들을 위해, 링크를 남겨드립니다.",
  "n_reviews": 0,
  "start": 531.56,
  "end": 536.28
 },
 {
  "input": "But focusing back on this blurring example, what's going on is I've got this little 3x3 grid of values that's marching along our original image, and if we zoom in, each one of those values is 1 9th, and what I'm doing at each iteration is multiplying each of those values by the corresponding pixel that it sits on top of.",
  "translatedText": "",
  "from_community_srt": "그러나 이 모자이크 예에 다시 집중해봅시다. 여기서 진행되고 있는 것은 원래 이미지를 따라 움직이는 이 작은 3×3의 격자가 있습니다. 그리고 확대하면, 각 값은 ⅑입니다. 그리고 각 반복에서 제가 하는 것은, 각 값을 그 위에 있는 해당 픽셀과 곱하는 것입니다.",
  "n_reviews": 0,
  "start": 536.62,
  "end": 553.62
 },
 {
  "input": "And of course in computer science, we think of colors as little vectors of three values, representing the red, green, and blue components.",
  "translatedText": "",
  "from_community_srt": "그리고 물론 컴퓨터 과학에서, 우리는 색상을 빨강, 녹색 및 파랑 구성요소로 나타내는 *세 가지 값의 작은 벡터로 생각합니다.",
  "n_reviews": 0,
  "start": 553.9,
  "end": 560.2
 },
 {
  "input": "When I multiply all these little values by 1 9th and I add them together, it gives us an average along each color channel, and the corresponding pixel for the image on the right is defined to be that sum.",
  "translatedText": "",
  "from_community_srt": "(RGB) 이 모든 작은 값에 ⅑을 곱하고 모두 더하면, 각 색상들의 평균이 되고 오른쪽 이미지의 해당 픽셀이 그 합계로 정의됩니다.",
  "n_reviews": 0,
  "start": 560.56,
  "end": 571.2
 },
 {
  "input": "The overall effect, as we do this for every single pixel on the image, is that each one kind of bleeds into all of its neighbors, which gives us a blurrier version than the original.",
  "translatedText": "",
  "from_community_srt": "이미지의 모든 단일 픽셀에 대해 이 연산을 수행할 때 전반적인 효과는, 각 번짐이 모든 이웃에 있어, 원본보다 더 흐린 버전을 제공한다는 것입니다.",
  "n_reviews": 0,
  "start": 571.94,
  "end": 580.86
 },
 {
  "input": "In the lingo, we'd say that the image on the right is a convolution of our original image with a little grid of values.",
  "translatedText": "",
  "from_community_srt": "전문 용어로, 오른쪽에 있는 이미지는 작은 값의 격자와 원본 이미지의 합성곱이라고 말할 수 있습니다.",
  "n_reviews": 0,
  "start": 581.72,
  "end": 587.74
 },
 {
  "input": "Or more technically, maybe I should say that it's the convolution with a 180 degree rotated version of that little grid of values.",
  "translatedText": "",
  "from_community_srt": "또는 좀 더 기술적으로 말하자면, 이 작은 격자가 180°로 회전된 합성곱이라고 말해야 할 것 같습니다.",
  "n_reviews": 0,
  "start": 588.14,
  "end": 594.4
 },
 {
  "input": "Not that it matters when the grid is symmetric, but it's just worth keeping in mind that the definition of a convolution, as inherited from the pure math context, should always invite you to think about flipping around that second array.",
  "translatedText": "",
  "from_community_srt": "격자가 대칭인 경우는 중요하지 않지만, 순수 수학의 맥락에서, 합성곱의 정의는, 항상 두 번째 배열을 뒤집는 것에 대한 생각을 초대해야 한다는 점을 명심해야 합니다.",
  "n_reviews": 0,
  "start": 594.62,
  "end": 605.24
 },
 {
  "input": "If we modify this slightly, we can get a much more elegant blurring effect by choosing a different grid of values.",
  "translatedText": "",
  "from_community_srt": "이것을 약간 수정하면, 다른 값의 격자를 선택하여 훨씬 더 우아한 모자이크 효과를 얻을 수 있습니다.",
  "n_reviews": 0,
  "start": 605.96,
  "end": 611.1
 },
 {
  "input": "In this case, I have a little 5x5 grid, but the distinction is not so much its size.",
  "translatedText": "",
  "from_community_srt": "이 경우에는, 약간의 5×5 격자가 있지만 그 크기가 그다지 큰 차이는 아닙니다.",
  "n_reviews": 0,
  "start": 611.44,
  "end": 615.78
 },
 {
  "input": "If we zoom in, we notice that the value in the middle is a lot bigger than the value towards the edges.",
  "translatedText": "",
  "from_community_srt": "확대하면, 중간 값이 가장자리 값보다 훨씬 더 크다는 것을 알 수 있습니다.",
  "n_reviews": 0,
  "start": 615.98,
  "end": 620.54
 },
 {
  "input": "And where this is coming from is they're all sampled from a bell curve, known as a Gaussian distribution.",
  "translatedText": "",
  "from_community_srt": "그리고 이것이 어디에서 왔냐면, 가우스 분포로 알려진 종형 곡선에서 모두 나온 것 입니다.",
  "n_reviews": 0,
  "start": 621.18,
  "end": 625.94
 },
 {
  "input": "That way, when we multiply all of these values by the corresponding pixel that they're sitting on top of, we're giving a lot more weight to that central pixel, and much less towards the ones out at the edge.",
  "translatedText": "",
  "from_community_srt": "이런 식으로, 이 모든 값을 해당 픽셀과 곱하면, 중앙 픽셀에 훨씬 더 많은 가중치를 부여하고 가장자리에 있는 픽셀에는 훨씬 적은 가중치를 부여합니다.",
  "n_reviews": 0,
  "start": 626.8,
  "end": 636.38
 },
 {
  "input": "And just as before, the corresponding pixel on the right is defined to be this sum.",
  "translatedText": "",
  "from_community_srt": "그리고 이전과 마찬가지로, 오른쪽의 해당 픽셀은 이 합계로 정의됩니다.",
  "n_reviews": 0,
  "start": 636.8,
  "end": 640.56
 },
 {
  "input": "As we do this process for every single pixel, it gives a blurring effect, which much more authentically simulates the notion of putting your lens out of focus, or something like that.",
  "translatedText": "",
  "from_community_srt": "모든 단일 픽셀에 대해 이 과정을 수행함에 따라, 렌즈를 초점에서 벗어나게 하는 개념을, 훨씬 더 확실하게 시뮬레이션하는 흐림 효과를 제공합니다.",
  "n_reviews": 0,
  "start": 641.32,
  "end": 649.72
 },
 {
  "input": "But blurring is far from the only thing that you can do with this idea.",
  "translatedText": "",
  "from_community_srt": "하지만 블러링은 이 아이디어로 할 수 있는 유일한 것이 아닙니다.",
  "n_reviews": 0,
  "start": 649.9,
  "end": 653.36
 },
 {
  "input": "For instance, take a look at this little grid of values, which involves some positive numbers on the left, and some negative numbers on the right, which I'll color with blue and red respectively.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 왼쪽에는 양수 그리고 오른쪽에는 음수가 포함된 이 작은 값 격자를 살펴보세요. 각각 파란색과 빨간색으로 색칠하겠습니다.",
  "n_reviews": 0,
  "start": 653.8,
  "end": 662.9
 },
 {
  "input": "Take a moment to see if you can predict and understand what effect this will have on the final image.",
  "translatedText": "",
  "from_community_srt": "이것이 최종 이미지에 어떤 영향을 미칠지 예측하고, 이해할 수 있는지 잠시 시간을 내어 확인해보세요.",
  "n_reviews": 0,
  "start": 663.64,
  "end": 668.48
 },
 {
  "input": "So in this case, I'll just be thinking of the image as grayscale instead of colored, so each of the pixels is just represented by one number instead of three.",
  "translatedText": "",
  "from_community_srt": "따라서 이 경우에는, 이미지를 컬러가 아닌 흑백으로 생각하겠습니다. 따라서 각 픽셀은 3개가 아닌 하나의 숫자로 표시됩니다.",
  "n_reviews": 0,
  "start": 670.72,
  "end": 678.12
 },
 {
  "input": "And one thing worth noticing is that as we do this convolution, it's possible to get negative values.",
  "translatedText": "",
  "from_community_srt": "주목할 가치가 있는 한 가지는 이 합성곱을 수행할 때, 음수 값을 얻을 수 있다는 것입니다.",
  "n_reviews": 0,
  "start": 678.44,
  "end": 683.06
 },
 {
  "input": "For example, at this point here, if we zoom in, the left half of our little grid sits entirely on top of black pixels, which would have a value of zero, but the right half of negative values all sit on top of white pixels, which would have a value of one.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 여기 이 지점에서 확대하면, 작은 격자의 왼쪽 절반이 값이 0인 검은색 픽셀 위에 완전히 위치합니다. 그러나 음수 값의 오른쪽 절반은 모두 값이 1인 흰색 픽셀 위에 있습니다.",
  "n_reviews": 0,
  "start": 683.06,
  "end": 695.46
 },
 {
  "input": "So when we multiply corresponding terms and add them together, the results will be very negative.",
  "translatedText": "",
  "from_community_srt": "따라서 해당 항을 곱하고 서로 더하면, 결과는 매우 음수가 됩니다.",
  "n_reviews": 0,
  "start": 696.18,
  "end": 700.82
 },
 {
  "input": "And the way I'm displaying this with the image on the right is to color negative values red and positive values blue.",
  "translatedText": "",
  "from_community_srt": "오른쪽 이미지와 함께 이것을 표시하는 방법은 음수 값을 빨간색으로, 양수 값을 파란색으로 칠하는 것입니다.",
  "n_reviews": 0,
  "start": 701.16,
  "end": 706.36
 },
 {
  "input": "Another thing to notice is that when you're on a patch that's all the same color, everything goes to zero, since the sum of the values in our little grid is zero.",
  "translatedText": "",
  "from_community_srt": "주목해야 할 또 다른 사항은 모두 같은 색상의 부분에 있을 때, 작은 격자의 값의 합계가 0이기 때문에 모든 것이 0이 된다는 것입니다.",
  "n_reviews": 0,
  "start": 706.88,
  "end": 714.08
 },
 {
  "input": "This is very different from the previous two examples where the sum of our little grid was one, which let us interpret it as a moving average and hence a blur.",
  "translatedText": "",
  "from_community_srt": "이것은 우리의 작은 격자의 합이 1인 이전 두 예제와 매우 다릅니다. 이를 통해 이동 평균으로 해석할 수 있고,",
  "n_reviews": 0,
  "start": 715.18,
  "end": 722.18
 },
 {
  "input": "All in all, this little process basically detects wherever there's variation in the pixel value as you move from left to right, and so it gives you a kind of way to pick up on all the vertical edges from your image.",
  "translatedText": "",
  "from_community_srt": "이 이유 때문에 모자이크가 발생합니다. 대체로, 이 작은 과정 기본적으로 왼쪽에서 오른쪽으로 이동할 때 픽셀 값의 변화가 있는 곳을 감지합니다. 따라서 이미지에서 모든 수직 가장자리를 가려낼 수 있는 일종의 방법을 제공합니다.",
  "n_reviews": 0,
  "start": 723.64,
  "end": 733.92
 },
 {
  "input": "And similarly, if we rotated that grid around so that it varies as you move from the top to the bottom, this will be picking up on all the horizontal edges, which in the case of our little pie creature image does result in some pretty demonic eyes.",
  "translatedText": "",
  "from_community_srt": "마찬가지로, 위에서 아래로 이동할 때 격자가 달라지도록 회전하면 모든 수평 가장자리를 가려낼 수 있습니다. 우리의 작은 π 이미지의 경우에는, 예쁜 악마의 눈이 생깁니다.",
  "n_reviews": 0,
  "start": 736.5,
  "end": 749.34
 },
 {
  "input": "This smaller grid, by the way, is often called a kernel, and the beauty here is how just by choosing a different kernel, you can get different image processing effects, not just blurring your edge detection, but also things like sharpening.",
  "translatedText": "",
  "from_community_srt": "그런데, 이 작은 격자를, 종종 핵(kernel)이라고 합니다. 그리고 여기서 아름다움은 다른 핵(kernel)을 선택하는 것만으로도, 다른 이미지 처리 효과를 얻을 수 있다는 것입니다. 가장자리를 흐리게 하는 것뿐만 아니라 선명하게 하는 것과 같은 것들도 있습니다.",
  "n_reviews": 0,
  "start": 750.4,
  "end": 760.84
 },
 {
  "input": "For those of you who have heard of a convolutional neural network, the idea there is to use data to figure out what the kernels should be in the first place, as determined by whatever the neural network wants to detect.",
  "translatedText": "",
  "from_community_srt": "합성곱 신경망(CNN)에 대해 들어본 적이 있는 사람들에게는, 데이터를 사용하여 처음에 핵(kernel)이 무엇이어야 하는지 파악하는 아이디어가 있습니다. 신경망이 감지하려는 것이 무엇이든 결정됩니다.",
  "n_reviews": 0,
  "start": 760.84,
  "end": 771.48
 },
 {
  "input": "Another thing I should maybe bring up is the length of the output.",
  "translatedText": "",
  "from_community_srt": "제가 언급해야 할 또 다른 사항은 결과값 길이입니다.",
  "n_reviews": 0,
  "start": 772.76,
  "end": 775.52
 },
 {
  "input": "For something like the moving average example, you might only want to think about the terms when both of the windows fully align with each other.",
  "translatedText": "",
  "from_community_srt": "이동 평균 예와 같은 경우, 두 창이 서로 완전히 정렬되는 경우에만 구간에 대해 생각하고 싶을 수 있습니다.",
  "n_reviews": 0,
  "start": 775.82,
  "end": 781.9
 },
 {
  "input": "Or in the image processing example, maybe you want the final output to have the same size as the original.",
  "translatedText": "",
  "from_community_srt": "또는 이미지 처리 예제에서, 최종 출력이 원본과 동일한 크기를 갖기를 원할 수 있습니다.",
  "n_reviews": 0,
  "start": 782.12,
  "end": 787.28
 },
 {
  "input": "Now, convolutions as a pure math operation always produce an array that's bigger than the two arrays that you started with, at least assuming one of them doesn't have a length of one.",
  "translatedText": "",
  "from_community_srt": "이제, 순수한 수학 연산으로서의 합성곱은, 항상 시작했던 두 개의 배열보다 큰 배열을 생성합니다. 적어도 그들 중 하나의 길이가 1이 아니라고 가정합니다.",
  "n_reviews": 0,
  "start": 787.28,
  "end": 796.18
 },
 {
  "input": "Just know that in certain computer science contexts, you often want to deliberately truncate that output.",
  "translatedText": "",
  "from_community_srt": "특정 컴퓨터 과학 맥락에서,",
  "n_reviews": 0,
  "start": 796.72,
  "end": 801.52
 },
 {
  "input": "Another thing worth highlighting is that in the computer science context, this notion of flipping around that kernel before you let it march across the original often feels really weird and just uncalled for, but again, note that that's what's inherited from the pure math context, where like we saw with the probabilities, it's an incredibly natural thing to do.",
  "translatedText": "",
  "from_community_srt": "의도적으로 해당 출력을 자르려는 경우가 종종 있습니다. 강조할 가치가 있는 또 다른 사항은 컴퓨터 과학의 맥락에서, 핵이 원본을 가로질러 행진하기 전에, 해당 핵을 뒤집는다는 개념이 종종 정말 이상하고 불필요하게 느껴진다는 것입니다. 그러나 다시 말하지만, 확률에서 보았던 것처럼, 순수한 수학적 맥락에 연관 돼 있는 것은, 믿을 수 없을 정도로 자연스러운 일이라는 점에 유의하세요.",
  "n_reviews": 0,
  "start": 804.72,
  "end": 822.44
 },
 {
  "input": "And actually, I can show you one more pure math example where even the programmers should care about this one, because it opens the doors for a much faster algorithm to compute all of these.",
  "translatedText": "",
  "from_community_srt": "그리고 사실, 전 여러분에게 프로그래머도 관심을 가져야 할 더 순수한 수학적 예제를 보여줄 수 있습니다. 왜냐하면 이것은 이러한 모든 것들을 더 빠르게 계산할 수 있는 알고리즘의 문을 열어주기 때문입니다.",
  "n_reviews": 0,
  "start": 823.02,
  "end": 832.02
 },
 {
  "input": "To set up what I mean by faster here, let me go back and pull up some Python again, and I'm going to create two different relatively big arrays.",
  "translatedText": "",
  "from_community_srt": "여기에서 제가 의미하는 바를 더 빠르게 준비하기 위해, 뒤로 돌아가서 일부 Python을 다시 가져오고 상대적으로 큰 두 개의 서로 다른 배열을 만들 것입니다.",
  "n_reviews": 0,
  "start": 832.62,
  "end": 839.78
 },
 {
  "input": "Each one will have a hundred thousand random elements in it, and I'm going to assess the runtime, of the convolve function from the NumPy library.",
  "translatedText": "",
  "from_community_srt": "각각에는 10만개의 임의의 원소가 있으며 Numpy 라이브러리에서 합성곱 함수의 실행 시간을 측정할 것입니다.",
  "n_reviews": 0,
  "start": 839.94,
  "end": 847.54
 },
 {
  "input": "And in this case, it runs it for multiple different iterations, tries to find an average, and it looks like, on this computer at least, it averages at 4.87 seconds.",
  "translatedText": "",
  "from_community_srt": "그리고 이 경우, Python은 여러 다른 반복을 위해 합성곱을 실행하고, 평균을 찾으려고 시도하고, 이 결과는 이 컴퓨터에서 적어도 평균 4.87초인 것처럼 보입니다.",
  "n_reviews": 0,
  "start": 848.18,
  "end": 856.52
 },
 {
  "input": "By contrast, if I use a different function from the SciPy library called fftConvolve, which is the same thing just implemented differently, that only takes 4.3 milliseconds on average, so three orders of magnitude improvement.",
  "translatedText": "",
  "from_community_srt": "반대로, *FFT합성곱 이라는 SciPy 라이브러리의 다른 함수를 사용하는 경우에는, (Fast Fourier Transform) 동일한 계산을 다르게 구현하면 평균 4.3밀리초밖에 걸리지 않습니다. 따라서, 세자리 수 만큼 개선되었습니다.",
  "n_reviews": 0,
  "start": 856.96,
  "end": 870.16
 },
 {
  "input": "And again, even though it flies under a different name, it's giving the same output that the other convolve function does, it's just doing something to go about it in a cleverer way.",
  "translatedText": "",
  "from_community_srt": "(1,000 ms = 1s) 그리고 다시, 다른 이름으로 작동하지만, 다른 합성곱 함수와 동일한 출력을 제공하고, 더 영리한 방식으로 작업을 수행할 뿐입니다.",
  "n_reviews": 0,
  "start": 870.16,
  "end": 879.12
 },
 {
  "input": "Remember how with the probability example, I said another way you could think about the convolution was to create this table of all the pairwise products, and then add up those pairwise products along the diagonals.",
  "translatedText": "",
  "from_community_srt": "[Music] FFT합성곱이 뭘까? 그 전에 한 확률론의 예제를 기억해보면, 합성곱에 대해 생각할 수 있는 또 다른 방법은 모든 쌍별 곱의 표를 만든 다음 대각선을 따라 해당 쌍별 곱을 더하는 것이라고 말했습니다.",
  "n_reviews": 0,
  "start": 882.2,
  "end": 892.68
 },
 {
  "input": "There's of course nothing specific to probability.",
  "translatedText": "",
  "from_community_srt": "물론, 확률에 특별한 것은 따로 없습니다.",
  "n_reviews": 0,
  "start": 893.66,
  "end": 895.5
 },
 {
  "input": "Any time you're convolving two different lists of numbers, you can think about it this way.",
  "translatedText": "",
  "from_community_srt": "여러분은 두 개의 서로 다른 숫자 목록을 합성곱할 때마다,",
  "n_reviews": 0,
  "start": 895.66,
  "end": 899.04
 },
 {
  "input": "Create this kind of multiplication table with all pairwise products, and then each sum along the diagonal corresponds to one of your final outputs.",
  "translatedText": "",
  "from_community_srt": "이렇게 생각할 수 있습니다. 모든 쌍별 곱을 이러한 종류의 곱셈 표를 만든 다음 대각선을 따라 더한 것은, 최종 출력 중 하나에 해당합니다.",
  "n_reviews": 0,
  "start": 899.04,
  "end": 906.46
 },
 {
  "input": "One context where this view is especially natural is when you multiply together two polynomials.",
  "translatedText": "",
  "from_community_srt": "이 보기가 특히 자연스러운 상황 중 하나는, 두 개의 다항식을 함께 곱할 때입니다.",
  "n_reviews": 0,
  "start": 907.6,
  "end": 912.8
 },
 {
  "input": "For example, let me take the little grid we already have and replace the top terms with 1, 2x, and 3x squared, and replace the other terms with 4, 5x, and 6x squared.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 우리가 이미 가지고 있는 작은 격자판에서 위쪽 항을 1, 2𝒙, 3𝒙² 으로 바꾸고 다른 항을 4, 5𝒙, 6𝒙² 으로 바꾸겠습니다.",
  "n_reviews": 0,
  "start": 913.3,
  "end": 923.6
 },
 {
  "input": "Now, think about what it means when we're creating all of these different pairwise products between the two lists.",
  "translatedText": "",
  "from_community_srt": "이제 우리가 두 목록 사이에 이러한 서로 다른 모든 쌍별 곱을 생성할 때, 이것이 무엇을 의미하는지 생각해 보세오.",
  "n_reviews": 0,
  "start": 924.0,
  "end": 928.84
 },
 {
  "input": "What you're doing is essentially expanding out the full product of the two polynomials I have written down, and then when you add up along the diagonal, that corresponds to collecting all like terms.",
  "translatedText": "",
  "from_community_srt": "여러분이 하고 있는 것은 본질적으로 제가 기록한 두 다항식의 전체 곱을 확장하는 것입니다. 그런 다음 대각선을 따라 더하면, 이것은 유사한 항들을 모두 모으는 것과 같습니다.",
  "n_reviews": 0,
  "start": 929.04,
  "end": 939.9
 },
 {
  "input": "Which is pretty neat.",
  "translatedText": "",
  "n_reviews": 0,
  "start": 940.6,
  "end": 941.5
 },
 {
  "input": "Expanding a polynomial and collecting like terms is exactly the same process as a convolution.",
  "translatedText": "",
  "from_community_srt": "이건 꽤 깔끔합니다. 다항식을 확장하고 유사한 항들을 수집하는 것은 합성곱과 정확히 동일한 과정입니다.",
  "n_reviews": 0,
  "start": 941.74,
  "end": 946.44
 },
 {
  "input": "But this allows us to do something that's pretty cool, because think about what we're saying here.",
  "translatedText": "",
  "from_community_srt": "하지만 이것은 우리가 꽤 멋진 일을 할 수 있게 해줍니다. 여기서 우리가 말하는 것을 생각해봅시다.",
  "n_reviews": 0,
  "start": 947.74,
  "end": 952.34
 },
 {
  "input": "We're saying if you take two different functions and you multiply them together, which is a simple pointwise operation, that's the same thing as if you had first extracted the coefficients from each one of those, assuming they're polynomials, and then taken a convolution of those two lists of coefficients.",
  "translatedText": "",
  "from_community_srt": "두 개의 서로 다른 함수를 취하고 함께 곱하면, 간단한 점 연산인 경우 각 함수에서 먼저 계수를 추출한 것과 같습니다. 그것들이 다항식이라고 가정하고 두 계수 목록의 합성곱을 취합니다.",
  "n_reviews": 0,
  "start": 952.34,
  "end": 968.84
 },
 {
  "input": "What makes that so interesting is that convolutions feel, in principle, a lot more complicated than simple multiplication.",
  "translatedText": "",
  "from_community_srt": "이를 흥미롭게 만드는 것은, 합성곱이 원칙적으로 단순한 곱셈보다 훨씬 더 복잡하게 느껴진다는 것입니다.",
  "n_reviews": 0,
  "start": 969.62,
  "end": 975.36
 },
 {
  "input": "And I don't just mean conceptually they're harder to think about.",
  "translatedText": "",
  "from_community_srt": "개념적으로 생각하기 어렵다는 의미가 아니라,",
  "n_reviews": 0,
  "start": 975.82,
  "end": 978.46
 },
 {
  "input": "I mean, computationally, it requires more steps to perform a convolution than it does to perform a pointwise product of two different lists.",
  "translatedText": "",
  "from_community_srt": "계산적으로 두 개의 서로 다른 목록의 점곱을 수행하는 것보다 합성곱을 수행하는 데 더 많은 단계가 필요하다는 것을 의미합니다.",
  "n_reviews": 0,
  "start": 978.84,
  "end": 985.76
 },
 {
  "input": "For example, let's say I gave you two really big polynomials, say each one with a hundred different coefficients.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 제가 여러분에게 두 개의 정말 큰 다항식을 주었다고 합시다. 100개의 서로 다른 계수로 있다고 가정해봅시다.",
  "n_reviews": 0,
  "start": 986.32,
  "end": 991.9
 },
 {
  "input": "Then if the way you multiply them was to expand out this product, you know, filling in this entire 100 by 100 grid of pairwise products, that would require you to perform 10,000 different products.",
  "translatedText": "",
  "from_community_srt": "그런 다음 이 방법이 이 곱을 확장하는 것이라면, 쌍으로 된 곱의 전체 100×100 격자를 채우는 것입니다. 그렇게 하려면 10,000개의 서로 다른 곱을 수행해야 합니다.",
  "n_reviews": 0,
  "start": 992.74,
  "end": 1003.24
 },
 {
  "input": "And then, when you're collecting all the like terms along the diagonals, that's another set of around 10,000 operations.",
  "translatedText": "",
  "from_community_srt": "그런 다음 대각선을 따라 유사한 항들을 모두 수집하면 약 10,000개 연산의 또 다른 집합이 됩니다.",
  "n_reviews": 0,
  "start": 1003.74,
  "end": 1009.86
 },
 {
  "input": "More generally, in the lingo, we'd say the algorithm is O of n squared, meaning for two lists of size n, the way that the number of operations scales is in proportion to the square of n.",
  "translatedText": "",
  "from_community_srt": "좀 더 일반적으로 전문용어에서는, 알고리즘이 *𝑶(𝑵²)이라고 말합니다. (시간 복잡도의 개념; Big O Notation) 연산 수가 확장되는 방식인, 크기 𝑵의 두 목록에 대한 의미는 𝑵²에 비례합니다.",
  "n_reviews": 0,
  "start": 1010.7,
  "end": 1021.14
 },
 {
  "input": "On the other hand, if I think of two polynomials in terms of their outputs, for example, sampling their values at some handful of inputs, then multiplying them only requires as many operations as the number of samples, since again, it's a pointwise operation.",
  "translatedText": "",
  "from_community_srt": "반면에, 예를 들어 결과값의 관점에서 두 개의 다항식을 생각해보면, 몇 개의 입력에서 그들의 값을 샘플링하는 것입니다. 그런 다음 이들을 곱하는 데는 표본 수만큼의 연산만 필요합니다.",
  "n_reviews": 0,
  "start": 1021.82,
  "end": 1035.62
 },
 {
  "input": "And with polynomials, you only need finitely many samples to be able to recover the coefficients.",
  "translatedText": "",
  "from_community_srt": "다시 말하지만 이것은 점별 연산이고 다항식을 사용하므로, 계수를 복구할 수 있는 유한한 자그마한 표본만 필요합니다.",
  "n_reviews": 0,
  "start": 1036.18,
  "end": 1040.54
 },
 {
  "input": "For example, two outputs are enough to uniquely specify a linear polynomial, three outputs would be enough to uniquely specify a quadratic polynomial, and in general, if you know n distinct outputs, that's enough to uniquely specify a polynomial that has n different coefficients.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 선형 다항식을 유일하게 지정하려면 두 개의 결과값이면 충분합니다. 3개의 결과값은 2차 다항식을 유일하게 지정하는 데 충분하며, 일반적으로 N개의 고유한 결과값을 알고 있는 경우 𝑵개의 다른 계수가 있는 다항식을 유일하게 지정하기에 충분합니다.",
  "n_reviews": 0,
  "start": 1040.54,
  "end": 1056.74
 },
 {
  "input": "Or, if you prefer, we could phrase this in the language of systems of equations.",
  "translatedText": "",
  "from_community_srt": "또는 원하는 경우, 방정식 시스템의 언어로 표현할 수 있습니다.",
  "n_reviews": 0,
  "start": 1057.44,
  "end": 1060.72
 },
 {
  "input": "Imagine I tell you I have some polynomial, but I don't tell you what the coefficients are.",
  "translatedText": "",
  "from_community_srt": "내가 당신에게 다항식을 가지고 있지만 계수가 무엇인지 말하지 않는다고 상상해보세요.",
  "n_reviews": 0,
  "start": 1061.2,
  "end": 1065.2
 },
 {
  "input": "Those are a mystery to you.",
  "translatedText": "",
  "from_community_srt": "이 계수들은 당신에게 미스터리입니다.",
  "n_reviews": 0,
  "start": 1065.26,
  "end": 1066.52
 },
 {
  "input": "In our example, you might think of this as the product that we're trying to figure out.",
  "translatedText": "",
  "from_community_srt": "이 예에서는, 이것을 우리가 찾아내려는 곱으로 생각할 수 있습니다.",
  "n_reviews": 0,
  "start": 1066.7,
  "end": 1070.18
 },
 {
  "input": "And then, suppose I say, I'll just tell you what the outputs of this polynomial would be if you inputted various different inputs, like 0, 1, 2, 3, on and on, and I give you enough so that you have as many equations as you have unknowns.",
  "translatedText": "",
  "from_community_srt": "그리고 나서 제가, 여러분이 0, 1, 2, 3…과 같은 다양한 다른 입력을 넣는다면, 이 다항식의 결과값이 무엇인지 말하겠습니다. 그리고 저는 당신이 가지고 있는 미지수만큼 많은 방정식을 충분히 줄 것입니다.",
  "n_reviews": 0,
  "start": 1070.18,
  "end": 1083.46
 },
 {
  "input": "It even happens to be a linear system of equations, so that's nice, and in principle, at least, this should be enough to recover the coefficients.",
  "translatedText": "",
  "from_community_srt": "이것은 방정식의 선형 시스템이기 때문에 좋습니다. 그리고 원칙적으로는, 이것은 최소한 계수를 되찾을 정도로 충분해야 합니다.",
  "n_reviews": 0,
  "start": 1084.14,
  "end": 1090.9
 },
 {
  "input": "So the rough algorithm outline then would be, whenever you want to convolve two lists of numbers, you treat them like they're coefficients of two polynomials, you sample those polynomials at enough outputs, multiply those samples point-wise, and then solve this system to recover the coefficients as a sneaky backdoor way to find the convolution.",
  "translatedText": "",
  "from_community_srt": "따라서 대략적인 알고리즘 개요는 두 개의 숫자 목록을 합성곱하고 싶을 때마다, 두 개의 다항식의 계수인 것처럼 생각하는 것입니다. 충분한 결과값에서 해당 다항식을 샘플링하고, 해당 샘플을 점별로 곱한 다음, 시스템을 해결하여 합성곱을 찾기 위한 교활한 백도어 방법으로 계수를 되찾습니다.",
  "n_reviews": 0,
  "start": 1091.74,
  "end": 1110.56
 },
 {
  "input": "And, as I've stated it so far, at least, some of you could rightfully complain, grant, that is an idiotic plan, because, for one thing, just calculating all these samples for one of the polynomials we know already takes on the order of n-squared operations.",
  "translatedText": "",
  "from_community_srt": "그리고 지금까지 말했듯이, 적어도 여러분 중 일부는, “Grant, 이것은 바보 같은 계획이야!” 라고 마땅히 불평할 수 있습니다. 우선, 우리가 알고 있는 다항식 중 하나에 대해 이러한 모든 샘플을 계산하는 것은, 이미 𝑵²의 연산을 취하기 때문입니다.",
  "n_reviews": 0,
  "start": 1111.42,
  "end": 1125.12
 },
 {
  "input": "Not to mention, solving that system is certainly going to be computationally as difficult as just doing the convolution in the first place.",
  "translatedText": "",
  "from_community_srt": "말할 것도 없이, 이 시스템을 푸는 것은 확실히 처음에 합성곱을 하는 것만큼 계산적으로 어려울 것입니다.",
  "n_reviews": 0,
  "start": 1125.6,
  "end": 1132.1
 },
 {
  "input": "So, like, sure, we have this connection between multiplication and convolutions, but all of the complexity happens in translating from one viewpoint to the other.",
  "translatedText": "",
  "from_community_srt": "그래서, 물론, 우리는 곱셈과 합성곱 사이에 이러한 연관성을 가지고 있지만, 모든 복잡성은 한 관점에서 다른 관점으로 옮기는 데서 발생합니다.",
  "n_reviews": 0,
  "start": 1132.6,
  "end": 1140.48
 },
 {
  "input": "But there is a trick, and those of you who know about Fourier transforms and the FFT algorithm might see where this is going.",
  "translatedText": "",
  "from_community_srt": "그러나 트릭이 있습니다. 그리고 푸리에 변환과 FFT 알고리즘에 대해 알고 있는 분들은, 이것이 어디에 쓰이는 지 아실 겁니다.",
  "n_reviews": 0,
  "start": 1141.6,
  "end": 1147.74
 },
 {
  "input": "If you're unfamiliar with those topics, what I'm about to say might seem completely out of the blue.",
  "translatedText": "",
  "from_community_srt": "이러한 주제에 익숙하지 않은 경우, 제가 말하려는 내용이 완전히 난데없이 보일 수 있습니다.",
  "n_reviews": 0,
  "start": 1147.74,
  "end": 1152.18
 },
 {
  "input": "Just know that there are certain paths you could have walked in math that make this more of an expected step.",
  "translatedText": "",
  "from_community_srt": "그냥 여러분이 수학에서 걸었던 특정한 경로들이, 이것을 더 예상되는 단계로 만들 수 있다는 것을 알아두세요.",
  "n_reviews": 0,
  "start": 1152.26,
  "end": 1156.86
 },
 {
  "input": "Basically, the idea is that we have a freedom of choice here.",
  "translatedText": "",
  "from_community_srt": "기본적으로 아이디어는 우리가 여기에서 선택의 자유가 있다는 것입니다.",
  "n_reviews": 0,
  "start": 1157.72,
  "end": 1160.36
 },
 {
  "input": "If instead of evaluating at some arbitrary set of inputs, like 0, 1, 2, 3, on and on, you choose to evaluate on a very specially selected set of complex numbers, specifically the ones that sit evenly spaced on the unit circle, what are known as the roots of unity, this gives us a friendlier system.",
  "translatedText": "",
  "from_community_srt": "0, 1, 2, 3…과 같은 임의의 입력 집합으로 계산하는 대신, 매우 특별하게 선택된 복소수 집합에 대해 계산하도록 결정하는 것 입니다. 구체적으로 단위 원 위에 일정한 간격으로 있는 것들, 즉 *1의 거듭제곱근으로 (Roots of Unity) 알려진 것입니다. 이것은 우리에게 더 친근한 시스템을 제공합니다.",
  "n_reviews": 0,
  "start": 1160.54,
  "end": 1176.88
 },
 {
  "input": "The basic idea is that by finding a number where taking its powers falls into this cycling pattern, it means that the system we generate is going to have a lot of redundancy in the different terms that you're calculating, and by being clever about how you leverage that redundancy, you can save yourself a lot of work.",
  "translatedText": "",
  "from_community_srt": "기본 아이디어는 제곱을 해도 이 순환 패턴에 있는 숫자를 찾는 것으로, 우리가 생성한 시스템이, 계산할 때 다른 항에서 많은 중복성을 갖게 된다는 것을 의미합니다. 이러한 중복성을 활용하는 방법을 영리하게 생각하면,",
  "n_reviews": 0,
  "start": 1178.36,
  "end": 1194.46
 },
 {
  "input": "This set of outputs that I've written has a special name.",
  "translatedText": "",
  "from_community_srt": "많은 연산을 절약할 수 있습니다. 제가 작성한 이 결과값 집합에는 특별한 이름이 있습니다.",
  "n_reviews": 0,
  "start": 1196.02,
  "end": 1198.56
 },
 {
  "input": "It's called the discrete Fourier transform of the coefficients, and if you want to learn more, I actually did another lecture for that same Julia MIT class all about discrete Fourier transforms, and there's also a really excellent video on the channel Reducible talking about the fast Fourier transform, which is an algorithm for computing these more quickly.",
  "translatedText": "",
  "from_community_srt": "바로 계수의 *이산 푸리에 변환이라고 합니다. (DFT) 더 많은 것을 알고 싶으시다면, 제가 이 동일한 내용을 실제로 Julia MIT 수업에서, 이산 푸리에 변환에 대한 강의를 했습니다. 또한 채널 Reducible에 빠른 푸리에 변환에 대해 설명하는 정말 훌륭한 영상이 있습니다. FFT는 이런 것들을 더 빨리 계산해주는 알고리즘입니다.",
  "n_reviews": 0,
  "start": 1198.9,
  "end": 1217.12
 },
 {
  "input": "Also Veritasium recently did a really good video on FFTs, so you've got lots of options.",
  "translatedText": "",
  "from_community_srt": "또한 Veritasium도 최근에 FFT에 대한 정말 좋은 영상을 만들었으므로 여러분은 많은 선택들이 있습니다.",
  "n_reviews": 0,
  "start": 1217.48,
  "end": 1221.76
 },
 {
  "input": "And that fast algorithm really is the point for us.",
  "translatedText": "",
  "from_community_srt": "그리고 이 빠른 알고리즘이 정말 우리에게 핵심입니다.",
  "n_reviews": 0,
  "start": 1222.26,
  "end": 1224.66
 },
 {
  "input": "Again, because of all this redundancy, there exists a method to go from the coefficients to all of these outputs, where instead of doing on the order of n squared operations, you do on the order of n times the log of n operations, which is much much better as you scale to big lists.",
  "translatedText": "",
  "from_community_srt": "다시 말하지만, 이 모든 중복성 때문에, 이 계수들에서 이러한 모든 결과값으로 이동하는 방법이 있습니다. 𝑵² 연산으로 실행하는 대신, 𝑵 log(𝑵)의 연산으로 실행하면 큰 목록으로 확장할 때 훨씬 더 좋습니다.",
  "n_reviews": 0,
  "start": 1225.12,
  "end": 1239.2
 },
 {
  "input": "And, importantly, this FFT algorithm goes both ways.",
  "translatedText": "",
  "from_community_srt": "그리고 중요한 것은, 이 FFT 알고리즘이 양방향으로 작동한다는 것입니다.",
  "n_reviews": 0,
  "start": 1239.66,
  "end": 1242.54
 },
 {
  "input": "It also lets you go from the outputs to the coefficients.",
  "translatedText": "",
  "from_community_srt": "또한 결과값에서 계수로 이동할 수 있습니다.",
  "n_reviews": 0,
  "start": 1242.7,
  "end": 1245.48
 },
 {
  "input": "So, bringing it all together, let's look back at our algorithm outline.",
  "translatedText": "",
  "from_community_srt": "모든 것을 종합했지만, 알고리즘의 개요를 다시 살펴보겠습니다.",
  "n_reviews": 0,
  "start": 1246.22,
  "end": 1249.06
 },
 {
  "input": "Now we can say, whenever you're given two long lists of numbers, and you want to take their convolution, first compute the fast Fourier transform of each one of them, which, in the back of your mind, you can just think of as treating them like they're the coefficients of a polynomial, and evaluating it at a very specially selected set of points.",
  "translatedText": "",
  "from_community_srt": "이제, 우리는, 두 개의 긴 숫자 목록이 주어질 때 합성곱을 하고 싶을 때마다, 먼저, 각각의 빠른 푸리에 변환을 계산한다고 말할 수 있습니다. 여러분의 마음 한구석에서, 여러분은 이것들을 다항식의 계수처럼 생각하고 매우 특별하게 선택된 점들의 집합에서 이것을 계산하는 것으로 생각할 수 있습니다.",
  "n_reviews": 0,
  "start": 1249.42,
  "end": 1266.38
 },
 {
  "input": "Then, multiply together the two results that you just got, point-wise, which is nice and fast, and then do an inverse fast Fourier transform, and what that gives you is the sneaky backdoor way to compute the convolution that we were looking for.",
  "translatedText": "",
  "from_community_srt": "그런 다음, 방금 얻은 두 가지 결과를 함께 점곱하면, 좋고 빠릅니다. 그런 다음 역의 빠른 푸리에 변환을 실행하면, 우리가 찾던 합성곱을 계산하는 교활한 백도어 방법이 제공됩니다.",
  "n_reviews": 0,
  "start": 1266.9,
  "end": 1278.9
 },
 {
  "input": "But this time, it only involves O of n log n operations.",
  "translatedText": "",
  "from_community_srt": "그러나 이번에는, 𝑶(𝑵log𝑵) 연산만 하면 됩니다.",
  "n_reviews": 0,
  "start": 1279.04,
  "end": 1282.24
 },
 {
  "input": "That's really cool to me.",
  "translatedText": "",
  "from_community_srt": "정말 멋지네요.",
  "n_reviews": 0,
  "start": 1283.14,
  "end": 1284.74
 },
 {
  "input": "This very specific context where convolutions show up, multiplying two polynomials, opens the doors for an algorithm that's relevant everywhere else where convolutions might come up.",
  "translatedText": "",
  "from_community_srt": "이 매우 특정한 맥락에서, 합성곱이 나타나는 것은 두 개의 다항식을 곱한 것으로, 합성곱이 나타날 수 있는 다른 모든 곳에서 합성곱과 연관된 알고리즘의 문을",
  "n_reviews": 0,
  "start": 1285.12,
  "end": 1294.1
 },
 {
  "input": "If you want to add probability distributions, do some large image processing, whatever it might be, and I just think that's such a good example of why you should be excited when you see some operation or concept in math show up in a lot of seemingly unrelated areas.",
  "translatedText": "",
  "from_community_srt": "열어줍니다. 큰 이미지 처리에 확률 분포를 추가하려는 경우에도, 그리고 무엇이든 가능합니다. 그리고 저는 수학에 있는 몇몇 연산이나 개념들이 전혀 관련 없어 보이는 많은 영역에서 나타나는 것을 확인 했을 때 왜 여러분이 흥분해야 하는지에 대한 좋은 예라고 생각합니다.",
  "n_reviews": 0,
  "start": 1294.18,
  "end": 1307.48
 },
 {
  "input": "If you want a little homework, here's something that's fun to think about.",
  "translatedText": "",
  "from_community_srt": "여러분이 약간의 과제를 원하신다면, 여기 생각해 볼 만한 재미있는 것이 있습니다.",
  "n_reviews": 0,
  "start": 1308.48,
  "end": 1311.5
 },
 {
  "input": "Explain why when you multiply two different numbers, just ordinary multiplication the way we all learn in elementary school, what you're doing is basically a convolution between the digits of those numbers.",
  "translatedText": "",
  "from_community_srt": "두 개의 서로 다른 숫자를 곱할 때, 우리 모두가 초등학교에서 배우는 일반적인 곱셈이, 기본적으로 그 숫자들의 합성곱인 이유를 설명해보세요.",
  "n_reviews": 0,
  "start": 1311.72,
  "end": 1321.98
 },
 {
  "input": "There's some added steps with carries and the like, but the core step is a convolution.",
  "translatedText": "",
  "from_community_srt": "몇몇 추가가된 단계가 있지만 핵심 단계는 합성곱입니다.",
  "n_reviews": 0,
  "start": 1322.5,
  "end": 1326.46
 },
 {
  "input": "In light of the existence of a fast algorithm, what that means is if you have two very large integers, then there exists a way to find their product that's faster than the method we learn in elementary school, that instead of requiring O of n squared operations, only requires O of n log n, which doesn't even feel like it should be possible.",
  "translatedText": "",
  "from_community_srt": "빠른 알고리즘의 존재에 비추어 볼 때, 이것이 의미하는 바는 두 개의 매우 큰 정수가 있는 경우, 우리가 초등학교에서 배우는 방법보다 더 빠른 곱을 찾을 수 있는 방법이 있다는 것입니다. 𝑶(𝑵²) 연산을 요구하는 대신 𝑶(𝑵 log 𝑵)만 요구합니다. 이건 가능할 것 같다고 느껴지지 않습니다.",
  "n_reviews": 0,
  "start": 1327.28,
  "end": 1344.92
 },
 {
  "input": "The catch is that before this is actually useful in practice, your numbers would have to be absolutely monstrous.",
  "translatedText": "",
  "from_community_srt": "문제는 이것이 현실적으로 유용하기 전에, 여러분의 숫자는 정말로 엄청나야 한다는 것입니다.",
  "n_reviews": 0,
  "start": 1345.38,
  "end": 1350.84
 },
 {
  "input": "But still, it's cool that such an algorithm exists.",
  "translatedText": "",
  "from_community_srt": "그러나 여전히 이러한 알고리즘이 존재한다는 것은 멋진 일입니다.",
  "n_reviews": 0,
  "start": 1351.22,
  "end": 1353.86
 },
 {
  "input": "And next up, we'll turn our attention to the continuous case with a special focus on probability distributions.",
  "translatedText": "",
  "from_community_srt": "그리고 다음으로, 확률 분포에 특별히 초점을 맞춘 연속적인 사건에 우리의 관심을 돌릴 것입니다.",
  "n_reviews": 0,
  "start": 1355.16,
  "end": 1359.64
 }
]