1
00:00:00,000 --> 00:00:02,282
두 개의 서로 다른 숫자 목록 또는 두 개의 

2
00:00:02,282 --> 00:00:04,655
서로 다른 함수를 주고 이 두 목록을 결합하여 

3
00:00:04,655 --> 00:00:07,029
새로운 숫자 목록을 얻거나 두 함수를 결합하여 

4
00:00:07,029 --> 00:00:09,129
새로운 함수를 얻을 수 있는 모든 방법을 

5
00:00:09,129 --> 00:00:11,320
생각해 보라고 요청한다고 가정해 보겠습니다.

6
00:00:12,120 --> 00:00:14,388
떠오르는 간단한 방법 중 하나는 단순히 

7
00:00:14,388 --> 00:00:16,760
용어 하나하나를 더하는 것일 수 있습니다.

8
00:00:17,160 --> 00:00:18,673
함수와 마찬가지로 해당 출력을 

9
00:00:18,673 --> 00:00:19,920
모두 추가할 수 있습니다.

10
00:00:20,540 --> 00:00:23,018
비슷한 맥락에서 두 목록에 용어를 하나씩 곱하고 

11
00:00:23,018 --> 00:00:25,680
함수를 사용하여 동일한 작업을 수행할 수도 있습니다.

12
00:00:26,360 --> 00:00:29,024
하지만 이 두 가지 조합만큼이나 기본적이지만 

13
00:00:29,024 --> 00:00:31,368
덜 일반적으로 논의되는 또 다른 종류의 

14
00:00:31,368 --> 00:00:33,500
조합이 있는데, 바로 컨볼루션입니다.

15
00:00:34,080 --> 00:00:36,950
하지만 앞의 두 경우와 달리 단순히 숫자에 

16
00:00:36,950 --> 00:00:39,820
할 수 있는 연산에서 상속된 것이 아닙니다.

17
00:00:39,980 --> 00:00:42,091
숫자 목록이나 함수 결합이라는 

18
00:00:42,091 --> 00:00:44,700
맥락에서 보면 정말 새로운 기능입니다.

19
00:00:45,320 --> 00:00:48,454
다항식은 이미지 처리에서 흔히 볼 수 있고, 

20
00:00:48,454 --> 00:00:52,090
확률 이론의 핵심 구조이며, 미분 방정식을 푸는 데 

21
00:00:52,090 --> 00:00:55,726
많이 사용되며, 이 이름은 아니더라도 거의 확실하게 

22
00:00:55,726 --> 00:00:59,111
본 적이 있는 맥락 중 하나는 두 다항식을 함께 

23
00:00:59,111 --> 00:01:00,240
곱하는 것입니다.

24
00:01:00,740 --> 00:01:03,393
시각적 설명을 하는 사람으로서 이것은 특히 

25
00:01:03,393 --> 00:01:06,268
훌륭한 주제입니다. 문맥 없이 공식적인 정의만 

26
00:01:06,268 --> 00:01:09,585
따로 떼어놓고 보면 다소 위협적으로 보일 수 있지만, 

27
00:01:09,585 --> 00:01:12,460
시간을 들여서 그 의미를 제대로 풀고 그 전에 

28
00:01:12,460 --> 00:01:15,334
실제로 왜 이런 것을 원하는지 동기를 부여하면 

29
00:01:15,334 --> 00:01:18,320
엄청나게 아름다운 작업이 될 수 있기 때문입니다.

30
00:01:18,960 --> 00:01:21,303
그리고 이 프로젝트의 비주얼을 구성하는 

31
00:01:21,303 --> 00:01:23,540
동안 실제로 배운 것이 조금 있습니다.

32
00:01:23,540 --> 00:01:26,036
서로 다른 두 함수를 컨볼빙하는 경우, 

33
00:01:26,036 --> 00:01:28,760
그것이 무엇을 의미할 수 있는지 여러 가지 

34
00:01:28,760 --> 00:01:31,597
방법을 생각해 보았는데, 그 중 하나를 통해 

35
00:01:31,597 --> 00:01:34,548
정규 분포가 확률에서 왜 그런 역할을 하는지, 

36
00:01:34,548 --> 00:01:37,385
왜 함수의 자연스러운 모양인지에 대해 약간의 

37
00:01:37,385 --> 00:01:38,520
아하를 느꼈습니다.

38
00:01:39,020 --> 00:01:40,814
하지만 제가 너무 앞서 나가고 있는 것 같아서요, 

39
00:01:40,814 --> 00:01:41,520
준비할 게 많거든요.

40
00:01:41,840 --> 00:01:43,828
이 동영상에서는 이산 케이스, 

41
00:01:43,828 --> 00:01:46,517
특히 이를 계산하는 매우 예상치 못했지만 

42
00:01:46,517 --> 00:01:49,324
매우 영리한 알고리즘을 구축하는 데 초점을 

43
00:01:49,324 --> 00:01:50,260
맞출 것입니다.

44
00:01:50,260 --> 00:01:52,189
연속 사례에 대한 논의는 두 

45
00:01:52,189 --> 00:01:54,480
번째 파트에서 다루도록 하겠습니다.

46
00:01:58,580 --> 00:02:01,660
시각적으로 가장 흥미롭기 때문에 이미지 처리 

47
00:02:01,660 --> 00:02:04,741
예제로 시작하고 싶지만, 이미지 처리 사례는 

48
00:02:04,741 --> 00:02:07,945
전체적으로 컨볼루션을 대표하지 못하는 몇 가지 

49
00:02:07,945 --> 00:02:10,409
까다로운 점이 있으므로 대신 확률, 

50
00:02:10,409 --> 00:02:13,490
특히 여기 계신 모든 분들이 한 번쯤 생각해 

51
00:02:13,490 --> 00:02:16,570
보셨을 가장 간단한 예제 중 하나인 주사위를 

52
00:02:16,570 --> 00:02:19,898
굴려서 다양한 합이 나올 확률을 알아내는 것으로 

53
00:02:19,898 --> 00:02:21,500
시작해보도록 하겠습니다.

54
00:02:22,460 --> 00:02:24,460
문제없다, 문제없다고 말할 수도 있습니다.

55
00:02:24,680 --> 00:02:27,211
두 개의 주사위에는 각각 6개의 서로 다른 

56
00:02:27,211 --> 00:02:30,059
결과가 나올 수 있으므로 총 36개의 서로 다른 

57
00:02:30,059 --> 00:02:31,852
쌍의 결과가 나올 수 있으며, 

58
00:02:31,852 --> 00:02:34,699
이를 모두 살펴보면 주어진 합을 가진 쌍의 수를 

59
00:02:34,699 --> 00:02:35,860
세어볼 수 있습니다.

60
00:02:36,600 --> 00:02:39,546
이렇게 그리드에 모든 쌍을 배열하면 합이 

61
00:02:39,546 --> 00:02:42,365
일정한 모든 쌍이 서로 다른 대각선 중 

62
00:02:42,365 --> 00:02:45,440
하나를 따라 표시된다는 점이 매우 좋습니다.

63
00:02:45,440 --> 00:02:48,721
따라서 각 대각선에 몇 개가 있는지 세어보면 특정 

64
00:02:48,721 --> 00:02:52,120
합계가 나타날 확률이 얼마나 되는지 알 수 있습니다.

65
00:02:53,220 --> 00:02:55,940
아주 좋아요, 아주 좋다고 말하고 싶지만 같은 

66
00:02:55,940 --> 00:02:58,660
질문을 시각화할 수 있는 다른 방법이 있을까요?

67
00:02:59,300 --> 00:03:01,627
주어진 합이 다른 모든 쌍을 생각할 때 

68
00:03:01,627 --> 00:03:04,060
떠올릴 수 있는 다른 이미지는 무엇인가요?

69
00:03:04,860 --> 00:03:06,593
그리고 여러분 중 한 명이 손을 들고 "네, 

70
00:03:06,593 --> 00:03:07,980
저 있어요"라고 말할 수도 있습니다.

71
00:03:08,280 --> 00:03:10,925
각각 다른 두 가지 가능성 세트를 연속으로 상상해 

72
00:03:10,925 --> 00:03:13,760
보았는데, 두 번째 행을 뒤집는다고 가정해 보겠습니다.

73
00:03:13,760 --> 00:03:16,320
이렇게 하면 최대 7개를 더하는 모든 

74
00:03:16,320 --> 00:03:18,760
다른 쌍이 이렇게 세로로 정렬됩니다.

75
00:03:19,360 --> 00:03:22,305
그리고 맨 아래 줄을 오른쪽으로 끝까지 

76
00:03:22,305 --> 00:03:26,322
밀면 두 개를 더하는 독특한 쌍인 뱀 눈만 정렬되고, 

77
00:03:26,322 --> 00:03:29,268
오른쪽으로 한 단위 위로 밀면 세 개를 

78
00:03:29,268 --> 00:03:32,080
더하는 두 개의 다른 쌍이 정렬됩니다.

79
00:03:32,880 --> 00:03:35,854
그리고 일반적으로 이 하위 배열의 다른 오프셋 

80
00:03:35,854 --> 00:03:38,485
값은 먼저 뒤집어야 했던 것을 기억하며, 

81
00:03:38,485 --> 00:03:41,460
주어진 합을 가진 모든 고유한 쌍을 표시합니다.

82
00:03:44,820 --> 00:03:48,595
확률 질문의 경우, 각 범주에 얼마나 많은 결과가 

83
00:03:48,595 --> 00:03:52,640
있는지 세는 것이기 때문에 특별히 흥미롭지는 않습니다.

84
00:03:52,980 --> 00:03:55,378
하지만 이는 각 얼굴이 등장할 기회가 

85
00:03:55,378 --> 00:03:58,120
동등하다는 암묵적인 가정이 전제된 것입니다.

86
00:03:58,360 --> 00:03:59,841
하지만 제가 획일적이지 않은 특별한 

87
00:03:59,841 --> 00:04:01,620
주사위 세트를 가지고 있다고 하면 어떨까요?

88
00:04:02,060 --> 00:04:04,795
파란색 주사위에는 각 면이 나올 확률을 나타내는 

89
00:04:04,795 --> 00:04:07,328
고유한 숫자 집합이 있고, 빨간색 주사위에는 

90
00:04:07,328 --> 00:04:09,760
고유한 고유 숫자 집합이 있을 수 있습니다.

91
00:04:10,300 --> 00:04:13,348
이 경우, 예를 들어 2가 나올 확률을 

92
00:04:13,348 --> 00:04:16,534
알고 싶다면 파란색 주사위가 1일 확률에 

93
00:04:16,534 --> 00:04:19,860
빨간색 주사위가 1일 확률을 곱하면 됩니다.

94
00:04:20,279 --> 00:04:24,823
그리고 3이 나올 확률은 가능한 두 개의 다른 쌍을 

95
00:04:24,823 --> 00:04:28,896
살펴보고 다시 해당 확률을 곱한 다음 두 곱을 

96
00:04:28,896 --> 00:04:29,680
더합니다.

97
00:04:30,100 --> 00:04:33,391
마찬가지로 4가 나올 확률은 서로 다른 세 

98
00:04:33,391 --> 00:04:36,820
쌍의 가능성을 곱한 다음 모두 더하면 됩니다.

99
00:04:36,820 --> 00:04:39,649
그리고 몇 가지 공식을 설정하기 위해 이 상위 

100
00:04:39,649 --> 00:04:42,695
확률의 이름을 1, 2, 3 등으로 지정하고 하위 

101
00:04:42,695 --> 00:04:45,960
확률의 이름을 1, 2, 3 등으로 지정해 보겠습니다.

102
00:04:46,400 --> 00:04:49,369
일반적으로 두 개의 서로 다른 숫자 배열을 

103
00:04:49,369 --> 00:04:52,339
가져와 두 번째 배열을 뒤집은 다음 다양한 

104
00:04:52,339 --> 00:04:55,185
오프셋 값으로 정렬하고, 쌍으로 이루어진 

105
00:04:55,185 --> 00:04:58,402
여러 곱을 가져와 더하는 이 과정은 컨볼루션이 

106
00:04:58,402 --> 00:05:01,620
무엇인지 생각하는 근본적인 방법 중 하나입니다.

107
00:05:04,860 --> 00:05:08,154
좀 더 정확하게 설명하자면, 이 과정을 통해 2, 

108
00:05:08,154 --> 00:05:11,096
3, 4, 그리고 최대 12까지 볼 수 있는 

109
00:05:11,096 --> 00:05:14,155
확률을 생성하고, 하나의 값 목록인 A와 다른 

110
00:05:14,155 --> 00:05:16,980
값 목록인 B를 혼합하여 확률을 얻었습니다.

111
00:05:17,440 --> 00:05:20,857
전문 용어로 설명하자면, 이 두 시퀀스의 컨볼루션을 

112
00:05:20,857 --> 00:05:24,157
통해 11개의 값으로 구성된 새로운 시퀀스를 얻을 

113
00:05:24,157 --> 00:05:27,340
수 있으며, 각 값은 쌍별 곱의 합처럼 보입니다.

114
00:05:27,340 --> 00:05:30,438
원하는 경우 동일한 연산에 대해 생각할 수 있는 

115
00:05:30,438 --> 00:05:33,881
또 다른 방법은 먼저 모든 쌍으로 된 제품의 테이블을 

116
00:05:33,881 --> 00:05:36,980
만든 다음 모든 대각선을 따라 합산하는 것입니다.

117
00:05:37,460 --> 00:05:40,254
다시 말하지만, 이 두 가지 숫자 시퀀스를 혼합하여 

118
00:05:40,254 --> 00:05:42,760
11개의 새로운 숫자 시퀀스를 얻는 방법입니다.

119
00:05:43,240 --> 00:05:44,923
슬라이딩 윈도우에서 생각했던 것과 동일한 

120
00:05:44,923 --> 00:05:46,460
작동 방식이며, 다른 관점일 뿐입니다.

121
00:05:47,140 --> 00:05:49,800
약간의 표기를 추가하면 다음과 같이 적을 수 있습니다.

122
00:05:50,220 --> 00:05:53,517
이 작은 별표로 표시된 a와 b의 컨볼루션은 

123
00:05:53,517 --> 00:05:56,814
새로운 목록이며, 해당 목록의 n번째 요소는 

124
00:05:56,814 --> 00:06:00,243
합계처럼 보이며, 그 합계는 모든 다른 인덱스 

125
00:06:00,243 --> 00:06:03,804
쌍인 i와 j를 거쳐 해당 인덱스의 합계가 n과 

126
00:06:03,804 --> 00:06:04,860
같도록 합니다.

127
00:06:05,280 --> 00:06:09,191
다소 어렵지만, 예를 들어 n이 6이라면 1과 5, 

128
00:06:09,191 --> 00:06:11,618
2와 4, 3과 3, 4와 2, 

129
00:06:11,618 --> 00:06:15,125
5와 1 등 6을 더하는 모든 쌍을 살펴볼 수 

130
00:06:15,125 --> 00:06:15,800
있습니다.

131
00:06:16,620 --> 00:06:18,526
하지만 솔직히 어떻게 적든, 표기법은 

132
00:06:18,526 --> 00:06:20,524
프로세스를 위해 머릿속에 그리는 시각적 

133
00:06:20,524 --> 00:06:22,340
이미지에 비하면 부차적인 문제입니다.

134
00:06:23,280 --> 00:06:25,851
여기에서는 목록 1, 2, 3과 목록 4, 

135
00:06:25,851 --> 00:06:28,315
5, 6의 컨볼루션이 무엇인지 묻는 아주 

136
00:06:28,315 --> 00:06:30,780
간단한 예를 들어보면 도움이 될 것입니다.

137
00:06:31,480 --> 00:06:33,546
이 두 목록을 모두 가져와서 두 번째 

138
00:06:33,546 --> 00:06:35,514
목록을 뒤집은 다음 뚜껑을 왼쪽으로 

139
00:06:35,514 --> 00:06:37,680
완전히 뒤집는 것을 상상할 수 있습니다.

140
00:06:38,180 --> 00:06:40,860
그런 다음 정렬되는 값의 쌍이 1과 4이면 

141
00:06:40,860 --> 00:06:43,540
이를 곱하면 출력의 첫 번째 항이 나옵니다.

142
00:06:43,960 --> 00:06:47,599
하단 배열을 오른쪽으로 한 단위 밀면 정렬되는 

143
00:06:47,599 --> 00:06:49,979
쌍은 1, 5, 2, 4이며, 

144
00:06:49,979 --> 00:06:53,340
이 쌍을 곱하고 더하면 출력의 다음 항목인 

145
00:06:53,340 --> 00:06:54,460
13이 됩니다.

146
00:06:54,960 --> 00:06:58,330
한 번 더 밀면 1 곱하기 6에 2 곱하기 

147
00:06:58,330 --> 00:07:01,560
5에 3 곱하기 4가 되어 28이 됩니다.

148
00:07:02,020 --> 00:07:04,573
슬라이드가 하나 더 있으면 6의 2 곱하기 

149
00:07:04,573 --> 00:07:07,020
5의 3 곱하기 5가 되어 27이 됩니다.

150
00:07:07,500 --> 00:07:08,810
마지막으로 마지막 학기는 3 

151
00:07:08,810 --> 00:07:10,120
곱하기 6처럼 보일 것입니다.

152
00:07:10,660 --> 00:07:13,253
원한다면 좋아하는 프로그래밍 언어와 다양한 

153
00:07:13,253 --> 00:07:16,062
숫자 연산이 포함된 라이브러리를 불러와서 제가 

154
00:07:16,062 --> 00:07:18,980
거짓말을 하지 않는다는 것을 확인할 수 있습니다.

155
00:07:18,980 --> 00:07:21,118
1, 2, 3의 컨볼루션을 4, 5, 

156
00:07:21,118 --> 00:07:23,970
6에 대입하면 실제로 얻을 수 있는 결과는 다음과 

157
00:07:23,970 --> 00:07:24,480
같습니다.

158
00:07:25,920 --> 00:07:29,865
확률 분포를 합산하는 것이 자연스럽고 바람직한 

159
00:07:29,865 --> 00:07:33,660
연산인 경우와 이동 평균이 일반적인 예입니다.

160
00:07:34,080 --> 00:07:36,919
긴 숫자 목록이 있고 모두 1을 더하는 

161
00:07:36,919 --> 00:07:39,760
작은 숫자 목록이 있다고 상상해 보세요.

162
00:07:40,100 --> 00:07:42,126
이 경우에는 5개의 값으로 구성된 작은 

163
00:07:42,126 --> 00:07:44,060
목록이 있고 모두 5의 1과 같습니다.

164
00:07:44,060 --> 00:07:47,154
그런 다음 슬라이딩 윈도우 컨볼루션 프로세스를 

165
00:07:47,154 --> 00:07:49,773
수행하면서 눈을 감고 처음에 어떤 일이 

166
00:07:49,773 --> 00:07:52,510
일어나는지 살펴본 다음, 작은 값 목록이 

167
00:07:52,510 --> 00:07:55,367
큰 값 목록과 완전히 겹치면 이 컨볼루션의 

168
00:07:55,367 --> 00:07:58,700
각 용어가 실제로 무엇을 의미하는지 생각해 보세요.

169
00:07:59,400 --> 00:08:03,010
반복할 때마다 데이터의 각 값에 5분의 1을 

170
00:08:03,010 --> 00:08:06,620
곱한 다음 모두 더하는 것, 즉 이 작은 창 

171
00:08:06,620 --> 00:08:10,520
안에서 데이터의 평균을 구하는 작업을 수행합니다.

172
00:08:11,100 --> 00:08:13,926
전반적으로 이 프로세스는 원본 데이터의 매끄러운 

173
00:08:13,926 --> 00:08:16,962
버전을 제공하며, 다른 작은 숫자 목록으로 시작하여 

174
00:08:16,962 --> 00:08:19,684
이를 수정할 수 있으며, 그 작은 목록이 모두 

175
00:08:19,684 --> 00:08:22,720
1로 합산되는 한 이동 평균으로 해석할 수 있습니다.

176
00:08:23,400 --> 00:08:25,580
여기에 표시된 예시에서는 이동 평균이 

177
00:08:25,580 --> 00:08:27,760
중심값에 더 많은 가중치를 부여합니다.

178
00:08:28,420 --> 00:08:30,800
이렇게 하면 데이터의 매끄러운 버전이 생성됩니다.

179
00:08:33,140 --> 00:08:35,783
이를 2차원적으로 아날로그화하면 주어진 이미지를 

180
00:08:35,783 --> 00:08:38,720
흐리게 처리하는 재미있는 알고리즘을 얻을 수 있습니다.

181
00:08:38,720 --> 00:08:41,836
그리고 지금 보여드리려는 애니메이션은 제가 MIT의 

182
00:08:41,836 --> 00:08:44,846
줄리아 연구소와 함께 이미지 처리 장치를 포함하는 

183
00:08:44,846 --> 00:08:47,963
특정 오픈 코스웨어 수업을 위해 만든 강의의 일부로 

184
00:08:47,963 --> 00:08:51,080
원래 만든 것을 수정한 것이라고 말씀드리고 싶습니다.

185
00:08:51,560 --> 00:08:53,781
이 모든 것의 이면에 있는 코드를 조금 더 

186
00:08:53,781 --> 00:08:56,280
자세히 살펴보고 싶으시다면 링크를 남겨두겠습니다.

187
00:08:56,620 --> 00:08:59,824
하지만 이 흐릿한 예시로 다시 돌아가서, 

188
00:08:59,824 --> 00:09:03,029
원본 이미지를 따라 행진하는 작은 3x3 

189
00:09:03,029 --> 00:09:06,234
그리드의 값이 있는데, 확대하면 각 값은 

190
00:09:06,234 --> 00:09:09,579
9분의 1이고 각 반복에서 수행하는 작업은 

191
00:09:09,579 --> 00:09:13,620
각 값에 그 위에 있는 해당 픽셀을 곱하는 것입니다.

192
00:09:13,900 --> 00:09:16,552
물론 컴퓨터 과학에서는 색을 빨강, 초록, 

193
00:09:16,552 --> 00:09:19,536
파랑 성분을 나타내는 세 가지 값의 작은 벡터로 

194
00:09:19,536 --> 00:09:20,200
생각합니다.

195
00:09:20,560 --> 00:09:23,856
이 모든 작은 값에 9분의 1을 곱하고 

196
00:09:23,856 --> 00:09:27,003
더하면 각 색상 채널의 평균이 나오고 

197
00:09:27,003 --> 00:09:31,200
오른쪽 이미지의 해당 픽셀이 그 합으로 정의됩니다.

198
00:09:31,940 --> 00:09:34,700
이미지의 모든 픽셀에 대해 이 작업을 수행하기 

199
00:09:34,700 --> 00:09:37,780
때문에 전체적인 효과는 각 픽셀이 모든 이웃 픽셀로 

200
00:09:37,780 --> 00:09:40,860
번져 원본보다 더 흐릿한 버전이 만들어지는 것입니다.

201
00:09:41,720 --> 00:09:43,535
전문 용어로 설명하자면, 오른쪽의 

202
00:09:43,535 --> 00:09:45,446
이미지는 원본 이미지에 작은 그리드 

203
00:09:45,446 --> 00:09:47,740
값을 추가한 컨볼루션이라고 할 수 있습니다.

204
00:09:48,140 --> 00:09:50,985
더 엄밀히 말하면, 작은 값 격자를 180도 

205
00:09:50,985 --> 00:09:54,400
회전한 버전의 컨볼루션이라고 해야 할지도 모르겠습니다.

206
00:09:54,620 --> 00:09:56,933
그리드가 대칭일 때는 중요하지 않지만, 

207
00:09:56,933 --> 00:09:59,667
순수 수학의 맥락에서 상속된 컨볼루션의 정의는 

208
00:09:59,667 --> 00:10:01,980
항상 두 번째 배열을 뒤집는 것에 대해 

209
00:10:01,980 --> 00:10:04,714
생각하도록 유도해야 한다는 점을 명심할 필요가 

210
00:10:04,714 --> 00:10:05,240
있습니다.

211
00:10:05,960 --> 00:10:08,530
이를 약간 수정하면 다른 값 그리드를 선택하여 

212
00:10:08,530 --> 00:10:11,100
훨씬 더 우아한 블러 효과를 얻을 수 있습니다.

213
00:10:11,440 --> 00:10:13,331
이 경우 5x5 그리드가 약간 

214
00:10:13,331 --> 00:10:15,780
있지만 그 차이는 그다지 크지 않습니다.

215
00:10:15,980 --> 00:10:18,020
확대하면 가운데 값이 가장자리 

216
00:10:18,020 --> 00:10:20,540
값보다 훨씬 큰 것을 알 수 있습니다.

217
00:10:21,180 --> 00:10:23,618
그리고 이 모든 것이 가우스 분포라고 

218
00:10:23,618 --> 00:10:25,940
하는 종 곡선에서 샘플링된 것입니다.

219
00:10:26,800 --> 00:10:29,269
이렇게 하면 이 모든 값에 해당 값의 상단에 

220
00:10:29,269 --> 00:10:31,540
있는 픽셀을 곱하면 중앙 픽셀에 훨씬 더 

221
00:10:31,540 --> 00:10:33,713
많은 가중치를 부여하고 가장자리에 있는 

222
00:10:33,713 --> 00:10:36,380
픽셀에는 훨씬 적은 가중치를 부여할 수 있습니다.

223
00:10:36,800 --> 00:10:38,680
그리고 이전과 마찬가지로 오른쪽의 

224
00:10:38,680 --> 00:10:40,560
해당 픽셀은 이 합계로 정의됩니다.

225
00:10:41,320 --> 00:10:43,988
모든 픽셀에 대해 이 프로세스를 수행하면 흐릿한 

226
00:10:43,988 --> 00:10:46,854
효과가 발생하여 렌즈의 초점이 맞지 않는 것과 같은 

227
00:10:46,854 --> 00:10:49,720
개념을 훨씬 더 사실적으로 시뮬레이션할 수 있습니다.

228
00:10:49,900 --> 00:10:51,481
하지만 이 아이디어로 할 수 

229
00:10:51,481 --> 00:10:53,360
있는 것은 블러 처리뿐이 아닙니다.

230
00:10:53,800 --> 00:10:56,529
예를 들어 왼쪽에는 양수, 오른쪽에는 

231
00:10:56,529 --> 00:10:59,520
음수가 있는 이 작은 값 격자를 살펴보고 

232
00:10:59,520 --> 00:11:02,900
각각 파란색과 빨간색으로 색을 칠해 보겠습니다.

233
00:11:03,640 --> 00:11:06,060
잠시 시간을 내어 최종 이미지에 어떤 영향을 

234
00:11:06,060 --> 00:11:08,480
미칠지 예측하고 이해할 수 있는지 살펴보세요.

235
00:11:10,720 --> 00:11:14,037
따라서 이 경우 이미지를 컬러가 아닌 회색조로 

236
00:11:14,037 --> 00:11:17,354
생각하므로 각 픽셀은 3이 아닌 하나의 숫자로 

237
00:11:17,354 --> 00:11:18,120
표시됩니다.

238
00:11:18,440 --> 00:11:20,850
한 가지 주목할 점은 이 컨볼루션을 수행할 

239
00:11:20,850 --> 00:11:23,060
때 음수 값이 나올 수 있다는 점입니다.

240
00:11:23,060 --> 00:11:25,843
예를 들어, 이 시점에서 확대하면 작은 

241
00:11:25,843 --> 00:11:28,880
격자의 왼쪽 절반은 값이 0인 검은색 픽셀 

242
00:11:28,880 --> 00:11:32,043
위에 완전히 배치되지만, 오른쪽 절반의 음수 

243
00:11:32,043 --> 00:11:35,460
값은 모두 값이 1인 흰색 픽셀 위에 배치됩니다.

244
00:11:36,180 --> 00:11:38,831
따라서 해당 용어를 곱하고 합산하면 

245
00:11:38,831 --> 00:11:40,820
결과는 매우 음수가 됩니다.

246
00:11:41,160 --> 00:11:43,817
오른쪽 이미지에서 음수 값은 빨간색으로, 

247
00:11:43,817 --> 00:11:46,360
양수 값은 파란색으로 표시하고 있습니다.

248
00:11:46,880 --> 00:11:49,348
또 한 가지 주목할 점은 모두 같은 색으로 

249
00:11:49,348 --> 00:11:51,817
된 패치에서는 작은 격자의 값의 합이 0이 

250
00:11:51,817 --> 00:11:54,080
되므로 모든 것이 0이 된다는 것입니다.

251
00:11:55,180 --> 00:11:57,258
이는 작은 그리드의 합이 1이었기 

252
00:11:57,258 --> 00:11:59,664
때문에 이동 평균으로 해석하여 흐릿하게 

253
00:11:59,664 --> 00:12:02,180
표현했던 앞의 두 예시와는 매우 다릅니다.

254
00:12:03,640 --> 00:12:05,971
이 작은 프로세스는 기본적으로 왼쪽에서 

255
00:12:05,971 --> 00:12:08,621
오른쪽으로 이동할 때 픽셀 값의 변화가 있는 

256
00:12:08,621 --> 00:12:10,846
곳을 감지하므로 이미지에서 모든 수직 

257
00:12:10,846 --> 00:12:13,920
가장자리를 포착할 수 있는 일종의 방법을 제공합니다.

258
00:12:16,500 --> 00:12:19,743
마찬가지로 그리드를 회전하여 위에서 아래로 

259
00:12:19,743 --> 00:12:22,852
이동함에 따라 달라지도록 하면 모든 가로 

260
00:12:22,852 --> 00:12:25,825
가장자리에서 포착되며, 작은 파이 생물 

261
00:12:25,825 --> 00:12:29,340
이미지의 경우 악마 같은 눈동자가 만들어집니다.

262
00:12:30,400 --> 00:12:33,055
그런데 이 작은 그리드를 흔히 커널이라고 부르는데, 

263
00:12:33,055 --> 00:12:35,528
다른 커널을 선택하는 것만으로도 가장자리 감지를 

264
00:12:35,528 --> 00:12:38,184
흐리게 하는 것뿐만 아니라 선명하게 하는 등 다양한 

265
00:12:38,184 --> 00:12:40,840
이미지 처리 효과를 얻을 수 있다는 점이 장점입니다.

266
00:12:40,840 --> 00:12:43,443
컨볼루션 신경망에 대해 들어본 적이 있는 

267
00:12:43,443 --> 00:12:46,046
분들을 위해 설명하자면, 데이터를 사용해 

268
00:12:46,046 --> 00:12:48,423
신경망이 감지하고자 하는 대상에 따라 

269
00:12:48,423 --> 00:12:51,480
커널이 무엇이어야 하는지 먼저 파악하는 것입니다.

270
00:12:52,760 --> 00:12:55,520
또 한 가지 짚고 넘어가야 할 것은 출력의 길이입니다.

271
00:12:55,820 --> 00:12:58,694
이동 평균 예시와 같은 경우에는 두 창이 서로 

272
00:12:58,694 --> 00:13:01,900
완전히 일치하는 경우에만 조건을 고려할 수 있습니다.

273
00:13:02,120 --> 00:13:04,700
또는 이미지 처리 예시에서 최종 출력물의 

274
00:13:04,700 --> 00:13:07,280
크기가 원본과 같기를 원할 수도 있습니다.

275
00:13:07,280 --> 00:13:10,136
이제 순수 수학 연산으로서의 컨볼루션은 적어도 

276
00:13:10,136 --> 00:13:13,213
둘 중 하나의 길이가 1이 아니라고 가정하면 항상 

277
00:13:13,213 --> 00:13:16,180
처음에 시작한 두 배열보다 큰 배열을 생성합니다.

278
00:13:16,720 --> 00:13:19,167
특정 컴퓨터 과학 환경에서는 의도적으로 출력을 

279
00:13:19,167 --> 00:13:21,520
잘라내야 하는 경우가 많다는 점만 알아두세요.

280
00:13:24,720 --> 00:13:27,893
또 한 가지 강조할 만한 점은 컴퓨터 과학 

281
00:13:27,893 --> 00:13:31,331
맥락에서 커널이 원본을 가로지르기 전에 커널을 

282
00:13:31,331 --> 00:13:35,034
뒤집는다는 개념은 종종 매우 이상하게 느껴지지만, 

283
00:13:35,034 --> 00:13:38,340
이는 확률에서 보았듯이 순수 수학 맥락에서는 

284
00:13:38,340 --> 00:13:41,778
매우 자연스러운 일이라는 점에 유의해야 한다는 

285
00:13:41,778 --> 00:13:42,440
것입니다.

286
00:13:43,020 --> 00:13:45,009
실제로 프로그래머도 관심을 가져야 할 

287
00:13:45,009 --> 00:13:47,662
순수한 수학의 예를 하나 더 보여드릴 수 있는데, 

288
00:13:47,662 --> 00:13:49,841
이 모든 것을 훨씬 더 빠르게 계산할 수 

289
00:13:49,841 --> 00:13:52,020
있는 알고리즘의 문을 열어주기 때문입니다.

290
00:13:52,620 --> 00:13:54,911
여기서 더 빠르다는 것이 무엇을 의미하는지 

291
00:13:54,911 --> 00:13:57,393
설정하기 위해 다시 돌아가서 파이썬을 가져와서 

292
00:13:57,393 --> 00:13:59,780
비교적 큰 두 개의 배열을 만들어 보겠습니다.

293
00:13:59,940 --> 00:14:03,330
각각에는 10만 개의 무작위 요소가 포함될 것이며, 

294
00:14:03,330 --> 00:14:05,786
NumPy 라이브러리의 컨볼브 함수의 

295
00:14:05,786 --> 00:14:07,540
런타임을 평가해 보겠습니다.

296
00:14:08,180 --> 00:14:10,669
이 경우 여러 번 반복해서 실행하고 

297
00:14:10,669 --> 00:14:13,657
평균을 구한 결과, 적어도 이 컴퓨터에서는 

298
00:14:13,657 --> 00:14:16,520
평균 4.87초가 걸리는 것으로 보입니다.

299
00:14:16,960 --> 00:14:19,600
반면, 같은 것을 구현만 달리한 

300
00:14:19,600 --> 00:14:24,000
fftConvolve라는 SciPy 라이브러리의 다른 

301
00:14:24,000 --> 00:14:28,399
함수를 사용하면 평균 4.3밀리초밖에 걸리지 않으므로 

302
00:14:28,399 --> 00:14:30,160
3배 정도 개선됩니다.

303
00:14:30,160 --> 00:14:33,146
다시 말하지만, 다른 이름으로 작동하지만 다른 

304
00:14:33,146 --> 00:14:36,363
컨볼브 함수가 하는 것과 동일한 출력을 제공하지만 

305
00:14:36,363 --> 00:14:39,120
더 영리한 방식으로 처리하는 것일 뿐입니다.

306
00:14:42,200 --> 00:14:45,612
확률 예제에서 컨볼루션을 생각할 수 있는 또 다른 

307
00:14:45,612 --> 00:14:49,146
방법은 모든 쌍 곱의 표를 만든 다음 대각선을 따라 

308
00:14:49,146 --> 00:14:52,680
쌍 곱을 더하는 것이라고 말씀드린 것을 기억하시나요?

309
00:14:53,660 --> 00:14:55,500
물론 확률에 대한 구체적인 내용은 없습니다.

310
00:14:55,660 --> 00:14:57,349
서로 다른 두 개의 숫자 목록을 변환할 

311
00:14:57,349 --> 00:14:59,040
때마다 이런 식으로 생각할 수 있습니다.

312
00:14:59,040 --> 00:15:02,626
모든 쌍의 곱셈으로 이런 종류의 곱셈표를 만든 다음 

313
00:15:02,626 --> 00:15:05,718
대각선을 따라 각 합이 최종 출력 중 하나에 

314
00:15:05,718 --> 00:15:06,460
해당합니다.

315
00:15:07,600 --> 00:15:10,270
이 보기가 특히 자연스러운 상황은 

316
00:15:10,270 --> 00:15:12,800
두 다항식을 함께 곱할 때입니다.

317
00:15:13,300 --> 00:15:16,774
예를 들어, 이미 가지고 있는 작은 격자를 가지고 

318
00:15:16,774 --> 00:15:20,001
맨 위 항을 1, 2배, 3배 제곱으로 바꾸고 

319
00:15:20,001 --> 00:15:23,600
다른 항을 4, 5배, 6배 제곱으로 바꿔보겠습니다.

320
00:15:24,000 --> 00:15:26,377
이제 두 목록 사이에 서로 다른 쌍으로 된 제품을 

321
00:15:26,377 --> 00:15:28,840
모두 생성하는 것이 무엇을 의미하는지 생각해 보세요.

322
00:15:29,040 --> 00:15:32,441
여러분이 하고 있는 일은 기본적으로 제가 적어 

323
00:15:32,441 --> 00:15:36,105
놓은 두 다항식의 전체 곱을 확장한 다음 대각선을 

324
00:15:36,105 --> 00:15:39,900
따라 더하면 같은 항을 모두 모으는 것에 해당합니다.

325
00:15:40,600 --> 00:15:41,500
꽤 깔끔합니다.

326
00:15:41,740 --> 00:15:43,926
다항식을 확장하고 같은 항을 모으는 

327
00:15:43,926 --> 00:15:46,440
것은 컨볼루션과 완전히 동일한 과정입니다.

328
00:15:47,740 --> 00:15:50,114
하지만 이를 통해 우리는 꽤 

329
00:15:50,114 --> 00:15:52,340
멋진 일을 할 수 있습니다.

330
00:15:52,340 --> 00:15:56,387
즉, 두 개의 서로 다른 함수를 가지고 간단한 

331
00:15:56,387 --> 00:15:59,033
점 단위 연산인 곱셈을 하면, 

332
00:15:59,033 --> 00:16:03,080
다항식이라고 가정하고 각 함수에서 계수를 먼저 

333
00:16:03,080 --> 00:16:07,127
추출한 다음 두 계수 목록의 컨볼루션을 취하는 

334
00:16:07,127 --> 00:16:08,840
것과 같은 것입니다.

335
00:16:09,620 --> 00:16:12,596
이것이 흥미로운 이유는 컨볼루션이 원칙적으로 단순 

336
00:16:12,596 --> 00:16:15,360
곱셈보다 훨씬 더 복잡하게 느껴진다는 점입니다.

337
00:16:15,820 --> 00:16:18,460
개념적으로만 생각하기 어렵다는 뜻이 아닙니다.

338
00:16:18,840 --> 00:16:21,288
계산적으로 볼 때, 컨볼루션을 수행하려면 

339
00:16:21,288 --> 00:16:23,737
서로 다른 두 목록의 점근 곱을 수행하는 

340
00:16:23,737 --> 00:16:25,760
것보다 더 많은 단계가 필요합니다.

341
00:16:26,320 --> 00:16:29,062
예를 들어, 각각 100개의 서로 다른 계수를 가진 

342
00:16:29,062 --> 00:16:31,900
매우 큰 다항식 두 개를 제공했다고 가정해 보겠습니다.

343
00:16:32,740 --> 00:16:35,097
그런 다음 이 제품을 곱하는 방식이 이 

344
00:16:35,097 --> 00:16:37,775
제품을 확장하는 것이라면, 즉 100×100 

345
00:16:37,775 --> 00:16:40,561
쌍으로 된 제품 그리드 전체를 채우는 것이라면 

346
00:16:40,561 --> 00:16:43,240
10,000개의 다른 제품을 수행해야 합니다.

347
00:16:43,740 --> 00:16:46,744
그리고 대각선을 따라 비슷한 용어를 모두 모으면 

348
00:16:46,744 --> 00:16:49,860
약 10,000개의 연산이 또 다른 집합이 됩니다.

349
00:16:50,700 --> 00:16:54,003
일반적으로 알고리즘은 n의 제곱의 O라고 할 

350
00:16:54,003 --> 00:16:57,307
수 있는데, 이는 n 크기의 두 목록에 대해 

351
00:16:57,307 --> 00:17:01,140
연산 횟수가 n의 제곱에 비례하는 방식을 의미합니다.

352
00:17:01,820 --> 00:17:05,270
반면에 두 다항식을 출력으로 생각하면, 

353
00:17:05,270 --> 00:17:09,817
예를 들어 몇 개의 입력에서 값을 샘플링하는 경우, 

354
00:17:09,817 --> 00:17:14,051
곱하기는 다시 점 단위 연산이므로 샘플 수만큼의 

355
00:17:14,051 --> 00:17:15,619
연산만 필요합니다.

356
00:17:16,180 --> 00:17:18,463
또한 다항식을 사용하면 계수를 복구하는 

357
00:17:18,463 --> 00:17:20,540
데 필요한 샘플 수가 매우 적습니다.

358
00:17:20,540 --> 00:17:23,642
예를 들어 선형 다항식을 고유하게 지정하려면 두 

359
00:17:23,642 --> 00:17:26,744
개의 출력이면 충분하고, 이차 다항식을 고유하게 

360
00:17:26,744 --> 00:17:29,271
지정하려면 세 개의 출력이면 충분하며, 

361
00:17:29,271 --> 00:17:32,374
일반적으로 n개의 고유한 출력을 알고 있다면 그 

362
00:17:32,374 --> 00:17:35,476
정도면 서로 다른 계수를 갖는 다항식을 고유하게 

363
00:17:35,476 --> 00:17:36,740
지정할 수 있습니다.

364
00:17:37,440 --> 00:17:38,947
또는 원하는 경우 이를 방정식 

365
00:17:38,947 --> 00:17:40,720
체계의 언어로 표현할 수도 있습니다.

366
00:17:41,200 --> 00:17:43,026
어떤 다항식이 있다고 말하지만 계수가 

367
00:17:43,026 --> 00:17:45,200
무엇인지 알려주지 않는다고 가정해 보겠습니다.

368
00:17:45,260 --> 00:17:46,520
여러분에게는 미스터리입니다.

369
00:17:46,700 --> 00:17:48,522
이 예제에서는 이것을 우리가 알아내려고 

370
00:17:48,522 --> 00:17:50,180
하는 제품이라고 생각할 수 있습니다.

371
00:17:50,180 --> 00:17:53,531
그런 다음 0, 1, 2, 3 등 다양한 입력을 

372
00:17:53,531 --> 00:17:56,385
입력하면 이 다항식의 출력이 어떻게 될지 

373
00:17:56,385 --> 00:17:59,736
알려드리겠다고 말하고 미지수의 수만큼의 방정식이 

374
00:17:59,736 --> 00:18:03,460
나올 수 있도록 충분히 알려드린다고 가정해 보겠습니다.

375
00:18:04,140 --> 00:18:07,399
심지어 선형 방정식 시스템이기 때문에 원칙적으로 

376
00:18:07,399 --> 00:18:10,900
적어도 이 정도면 계수를 복구하기에 충분할 것입니다.

377
00:18:11,740 --> 00:18:15,504
따라서 대략적인 알고리즘 개요는 두 개의 숫자 목록을 

378
00:18:15,504 --> 00:18:18,766
컨볼루션하고 싶을 때마다 두 다항식의 계수처럼 

379
00:18:18,766 --> 00:18:22,530
취급하고, 충분한 출력에서 해당 다항식을 샘플링하고, 

380
00:18:22,530 --> 00:18:24,663
샘플을 점 단위로 곱한 다음, 

381
00:18:24,663 --> 00:18:28,176
이 시스템을 풀어서 계수를 복구하는 교묘한 백도어 

382
00:18:28,176 --> 00:18:30,560
방식으로 컨볼루션을 찾는 것입니다.

383
00:18:31,420 --> 00:18:33,184
그리고 지금까지 말씀드렸듯이, 

384
00:18:33,184 --> 00:18:36,090
적어도 어떤 분들은 '이건 바보 같은 계획'이라고 

385
00:18:36,090 --> 00:18:38,685
불평할 수도 있습니다. 왜냐하면 우리가 이미 

386
00:18:38,685 --> 00:18:41,176
알고 있는 다항식 중 하나에 대해 이 모든 

387
00:18:41,176 --> 00:18:43,978
샘플을 계산하는 것만으로도 n제곱 연산의 순서가 

388
00:18:43,978 --> 00:18:45,120
필요하기 때문입니다.

389
00:18:45,600 --> 00:18:47,631
말할 것도 없이, 이 시스템을 푸는 

390
00:18:47,631 --> 00:18:49,459
것은 애초에 컨볼루션을 수행하는 

391
00:18:49,459 --> 00:18:52,100
것만큼이나 계산적으로 어려운 일이 될 것입니다.

392
00:18:52,600 --> 00:18:55,960
예를 들어 곱셈과 컨볼루션은 서로 연결되어 있지만, 

393
00:18:55,960 --> 00:18:58,278
한 관점에서 다른 관점으로 변환하는 

394
00:18:58,278 --> 00:19:00,480
과정에서 모든 복잡성이 발생합니다.

395
00:19:01,600 --> 00:19:03,814
하지만 푸리에 변환과 FFT 알고리즘에 

396
00:19:03,814 --> 00:19:05,928
대해 알고 계신 분들은 이것이 어떻게 

397
00:19:05,928 --> 00:19:07,740
진행되는지 알 수 있을 것입니다.

398
00:19:07,740 --> 00:19:09,843
이러한 주제에 익숙하지 않으시다면 제가 지금부터 

399
00:19:09,843 --> 00:19:12,180
말씀드리는 내용이 완전히 뜬금없어 보일 수도 있습니다.

400
00:19:12,260 --> 00:19:14,373
다만 수학에서 예상할 수 있는 

401
00:19:14,373 --> 00:19:16,860
특정 경로가 있다는 것을 알아두세요.

402
00:19:17,720 --> 00:19:20,360
기본적으로 여기에는 선택의 자유가 있습니다.

403
00:19:20,540 --> 00:19:24,590
0, 1, 2, 3 등과 같은 임의의 입력 집합에서 

404
00:19:24,590 --> 00:19:28,360
평가하는 대신 단위 원에 균등하게 배치된 복소수 

405
00:19:28,360 --> 00:19:32,410
집합, 특히 합집합의 근으로 알려진 복소수 집합에서 

406
00:19:32,410 --> 00:19:36,181
평가하도록 선택하면 더 친숙한 시스템을 만들 수 

407
00:19:36,181 --> 00:19:36,880
있습니다.

408
00:19:38,360 --> 00:19:41,230
기본 아이디어는 이 순환 패턴에 해당하는 

409
00:19:41,230 --> 00:19:44,225
숫자를 찾으면, 우리가 생성하는 시스템에서 

410
00:19:44,225 --> 00:19:47,221
계산하는 여러 용어에 많은 중복성이 있다는 

411
00:19:47,221 --> 00:19:50,091
것을 의미하며, 이러한 중복성을 활용하는 

412
00:19:50,091 --> 00:19:53,087
방법을 영리하게 활용하면 많은 작업을 줄일 

413
00:19:53,087 --> 00:19:54,460
수 있다는 것입니다.

414
00:19:56,020 --> 00:19:57,494
제가 작성한 이 출력물 세트에는 

415
00:19:57,494 --> 00:19:58,560
특별한 이름이 있습니다.

416
00:19:58,900 --> 00:20:01,977
이를 계수의 이산 푸리에 변환이라고 하는데, 

417
00:20:01,977 --> 00:20:05,178
더 자세히 알고 싶으시다면 같은 줄리아 MIT 

418
00:20:05,178 --> 00:20:08,379
강의에서 이산 푸리에 변환에 관한 다른 강의도 

419
00:20:08,379 --> 00:20:11,949
진행했고, Reducible 채널에 이를 더 빠르게 

420
00:20:11,949 --> 00:20:15,396
계산하는 알고리즘인 고속 푸리에 변환에 관한 정말 

421
00:20:15,396 --> 00:20:17,120
훌륭한 동영상도 있습니다.

422
00:20:17,480 --> 00:20:19,661
또한 최근 베리타시움에서 FFT에 대한 훌륭한 

423
00:20:19,661 --> 00:20:21,760
동영상을 제작했으므로 다양한 옵션이 있습니다.

424
00:20:22,260 --> 00:20:24,660
그리고 그 빠른 알고리즘이 바로 저희의 핵심입니다.

425
00:20:25,120 --> 00:20:28,369
다시 말하지만, 이 모든 중복성 때문에 계수에서 

426
00:20:28,369 --> 00:20:31,738
이러한 모든 출력으로 이동하는 방법이 존재하는데, 

427
00:20:31,738 --> 00:20:34,988
이 방법은 n제곱 연산을 하는 대신 n배의 로그 

428
00:20:34,988 --> 00:20:38,357
연산을 하는 것으로, 큰 목록으로 확장할수록 훨씬 

429
00:20:38,357 --> 00:20:39,200
더 좋습니다.

430
00:20:39,660 --> 00:20:40,884
그리고 중요한 것은 이 FFT 

431
00:20:40,884 --> 00:20:42,540
알고리즘이 양방향으로 작동한다는 점입니다.

432
00:20:42,700 --> 00:20:45,480
또한 출력에서 계수로 이동할 수도 있습니다.

433
00:20:46,220 --> 00:20:47,743
이제 이 모든 것을 종합하여 알고리즘의 

434
00:20:47,743 --> 00:20:49,060
개요를 다시 한 번 살펴보겠습니다.

435
00:20:49,420 --> 00:20:52,575
이제 두 개의 긴 숫자 목록이 주어지고 그 

436
00:20:52,575 --> 00:20:55,599
컨볼루션을 구하려면 먼저 각 숫자의 빠른 

437
00:20:55,599 --> 00:20:57,965
푸리에 변환을 계산해야 하는데, 

438
00:20:57,965 --> 00:21:01,252
마음속으로는 이를 다항식의 계수처럼 취급하고 

439
00:21:01,252 --> 00:21:04,407
매우 특수하게 선택된 점 집합에서 평가하는 

440
00:21:04,407 --> 00:21:06,380
것으로 생각할 수 있습니다.

441
00:21:06,900 --> 00:21:10,667
그런 다음 방금 얻은 두 결과를 점 단위로 곱한 

442
00:21:10,667 --> 00:21:14,574
다음 역 고속 푸리에 변환을 수행하면 우리가 찾고 

443
00:21:14,574 --> 00:21:18,202
있던 컨볼루션을 계산하는 교묘한 백도어 방법이 

444
00:21:18,202 --> 00:21:18,900
생깁니다.

445
00:21:19,040 --> 00:21:22,240
하지만 이번에는 n 로그 n 연산 중 O만 포함됩니다.

446
00:21:23,140 --> 00:21:24,740
정말 멋지네요.

447
00:21:25,120 --> 00:21:27,891
두 다항식을 곱하는 컨볼루션이 나타나는 매우 

448
00:21:27,891 --> 00:21:30,774
특정한 상황은 컨볼루션이 나타날 수 있는 다른 

449
00:21:30,774 --> 00:21:34,100
모든 곳에서 관련성이 있는 알고리즘의 문을 열어줍니다.

450
00:21:34,180 --> 00:21:36,902
확률 분포를 추가하고 싶거나 큰 이미지 처리를 

451
00:21:36,902 --> 00:21:39,102
하고 싶다면, 그것이 무엇이든 간에, 

452
00:21:39,102 --> 00:21:41,824
수학의 어떤 연산이나 개념이 전혀 관련이 없어 

453
00:21:41,824 --> 00:21:44,338
보이는 많은 영역에서 나타나는 것을 볼 때 

454
00:21:44,338 --> 00:21:47,480
흥분해야 하는 이유를 보여주는 좋은 예라고 생각합니다.

455
00:21:48,480 --> 00:21:49,884
약간의 숙제가 필요하신 분들을 위해 

456
00:21:49,884 --> 00:21:51,500
생각해 볼 만한 재미있는 내용이 있습니다.

457
00:21:51,720 --> 00:21:53,772
서로 다른 두 숫자를 곱할 때, 

458
00:21:53,772 --> 00:21:56,964
즉 우리가 초등학교에서 배우는 일반적인 곱셈을 할 

459
00:21:56,964 --> 00:22:00,270
때, 기본적으로 그 숫자의 자릿수 사이에 컨볼루션을 

460
00:22:00,270 --> 00:22:01,980
하는 이유를 설명해 주세요.

461
00:22:02,500 --> 00:22:04,579
캐리 등을 통해 몇 가지 추가 단계가 

462
00:22:04,579 --> 00:22:06,460
있지만 핵심 단계는 컨볼루션입니다.

463
00:22:07,280 --> 00:22:09,912
빠른 알고리즘의 존재를 고려할 때, 

464
00:22:09,912 --> 00:22:13,467
이는 매우 큰 정수 두 개가 있다면 초등학교에서 

465
00:22:13,467 --> 00:22:15,836
배우는 방법보다 더 빠른 방법, 

466
00:22:15,836 --> 00:22:19,259
즉 n의 제곱 연산이 필요한 것이 아니라 n의 

467
00:22:19,259 --> 00:22:22,813
로그 n의 O만 필요한, 가능하지 않을 것 같은 

468
00:22:22,813 --> 00:22:24,920
방법도 존재한다는 의미입니다.

469
00:22:25,380 --> 00:22:28,284
문제는 이 기능이 실제로 유용하게 사용되려면 

470
00:22:28,284 --> 00:22:30,840
수치가 엄청나게 높아야 한다는 점입니다.

471
00:22:31,220 --> 00:22:32,577
하지만 여전히 이러한 알고리즘이 

472
00:22:32,577 --> 00:22:33,860
존재한다는 것은 멋진 일입니다.

473
00:22:35,160 --> 00:22:37,336
다음은 확률 분포에 중점을 둔 

474
00:22:37,336 --> 00:22:39,640
연속형 사례에 주목해 보겠습니다.

