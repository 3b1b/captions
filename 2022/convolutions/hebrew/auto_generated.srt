1
00:00:00,000 --> 00:00:04,480
נניח שאני נותן לך שתי רשימות שונות של מספרים, או אולי שתי פונקציות שונות, ואני מבקש ממך

2
00:00:04,480 --> 00:00:08,400
לחשוב על כל הדרכים שבהן תוכל לשלב את שתי הרשימות האלה כדי לקבל רשימה חדשה של מספרים,

3
00:00:08,400 --> 00:00:14,000
או לשלב את שתי הפונקציות כדי לקבל פונקציה חדשה . אולי דרך פשוטה אחת שעולה בראש

4
00:00:14,000 --> 00:00:18,640
היא פשוט לחבר אותם מונח אחר מונח. באופן דומה עם הפונקציות, אתה יכול להוסיף את

5
00:00:18,640 --> 00:00:24,000
כל הפלטים התואמים. ברוח דומה, אתה יכול גם להכפיל את שתי הרשימות מונח אחר מונח

6
00:00:24,000 --> 00:00:28,720
ולעשות את אותו הדבר עם הפונקציות. אבל יש עוד סוג של שילוב מהותי

7
00:00:28,720 --> 00:00:33,840
בדיוק כמו שניהם, אבל הרבה פחות נפוץ לדון בו, המכונה קונבולציה.

8
00:00:33,840 --> 00:00:38,240
אבל בניגוד לשני המקרים הקודמים, זה לא משהו שעובר רק בירושה מפעולה שאתה

9
00:00:38,240 --> 00:00:43,360
יכול לעשות למספרים. זה משהו חדש באמת בהקשר של רשימות של מספרים

10
00:00:43,360 --> 00:00:49,280
או שילוב פונקציות. הם מופיעים בכל מקום, הם נמצאים בכל מקום בעיבוד תמונה,

11
00:00:49,280 --> 00:00:53,760
זה מבנה ליבה בתורת ההסתברות, הם משמשים הרבה בפתרון משוואות דיפרנציאליות, והקשר

12
00:00:53,760 --> 00:00:58,240
אחד שבו כמעט בוודאות ראית את זה, אם לא בשם זה, הוא

13
00:00:58,240 --> 00:01:03,440
הכפלת שני פולינומים יחד. בתור מישהו בעסק של הסברים ויזואליים, זה נושא

14
00:01:03,440 --> 00:01:08,800
נהדר במיוחד, כי ההגדרה הנוסחתית בבידוד וללא הקשר יכולה להיראות קצת מאיימת, אבל

15
00:01:08,800 --> 00:01:14,080
אם ניקח את הזמן כדי באמת לפרק את מה שהיא אומרת, ולפני

16
00:01:14,080 --> 00:01:18,800
זה בעצם להניע למה היית רוצה משהו כזה, זה מבצע יפה להפליא.

17
00:01:18,800 --> 00:01:22,880
ואני חייב להודות, למעשה למדתי משהו קטן תוך כדי הרכבת הוויזואליה לפרויקט

18
00:01:22,880 --> 00:01:26,960
הזה. במקרה של סיבוך של שתי פונקציות שונות, ניסיתי לחשוב על דרכים שונות

19
00:01:26,960 --> 00:01:30,720
שבהן תוכל לדמיין מה זה יכול להיות, ועם אחת מהן היה לי קצת

20
00:01:30,720 --> 00:01:35,840
רגע של אהה למה זה שהתפלגויות נורמליות ממלאות את התפקיד הם עושים זאת בהסתברות,

21
00:01:35,840 --> 00:01:40,320
מדוע זו צורה כל כך טבעית לפונקציה. אבל אני מקדים את עצמי, יש

22
00:01:40,320 --> 00:01:44,800
הרבה הגדרות לזה. בסרטון זה, ההתמקדות העיקרית שלנו היא רק במקרה הבדיד,

23
00:01:44,800 --> 00:01:49,920
ובמיוחד הבנייה לאלגוריתם מאוד לא צפוי אך חכם מאוד לחישוב אלה.

24
00:01:49,920 --> 00:01:54,400
ואני אוציא את הדיון בתיק המתמשך לחלק שני.

25
00:01:57,840 --> 00:02:03,120
זה מאוד מפתה להיפתח עם דוגמאות עיבוד התמונה, מכיוון שהן הכי מסקרנות

26
00:02:03,120 --> 00:02:06,880
מבחינה ויזואלית, אבל יש כמה פיסות של עדינות שהופכות את מקרה

27
00:02:06,880 --> 00:02:11,760
עיבוד התמונה לפחות מייצג של פיתולים בסך הכל, אז במקום זאת, בואו

28
00:02:11,760 --> 00:02:15,520
נתחיל בסבירות, ובמיוחד אחת הדוגמאות הפשוטות ביותר שאני בטוח שכולם כאן

29
00:02:15,520 --> 00:02:20,320
חשבו עליה בשלב מסוים בחייו, שהיא הטלת זוג קוביות והבנת הסיכויים לראות

30
00:02:20,320 --> 00:02:25,600
סכומים שונים. ואפשר לומר, לא בעיה, לא בעיה. לכל אחת משתי הקוביות

31
00:02:25,600 --> 00:02:31,600
שלך יש שש תוצאות אפשריות שונות, מה שנותן לנו בסך הכל 36 זוגות אפשריים ברורים

32
00:02:31,600 --> 00:02:35,600
של תוצאות, ואם רק נסתכל על כולן נוכל לספור לכמה זוגות יש סכום נתון.

33
00:02:36,240 --> 00:02:41,120
ולסדר את כל הזוגות ברשת כמו זה, דבר אחד נחמד הוא שכל הזוגות שיש

34
00:02:41,120 --> 00:02:47,040
להם סכום קבוע נראים לאורך אחד מהאלכסונים השונים האלה. אז פשוט ספירה כמה

35
00:02:47,040 --> 00:02:51,920
קיימים בכל אחד מהאלכסונים האלה יגיד לך מה הסיכוי שתראה סכום מסוים.

36
00:02:52,880 --> 00:02:57,760
והייתי אומר, טוב מאוד, טוב מאוד, אבל האם אתה יכול לחשוב על דרכים אחרות שאתה יכול לדמיין את

37
00:02:57,760 --> 00:03:03,120
אותה שאלה? תמונות אחרות שיכולות לעלות בראש לחשוב על כל הזוגות הנבדלים שיש להם סכום

38
00:03:03,120 --> 00:03:08,800
נתון? ואולי אחד מכם מרים את היד ואומר, כן, יש לי אחד. נניח שאתה מדמיין את

39
00:03:08,800 --> 00:03:14,560
שתי קבוצות האפשרויות השונות האלה כל אחת בשורה, אבל אתה מתהפך בשורה השנייה. כך כל

40
00:03:14,560 --> 00:03:20,160
הזוגות השונים שמצטברים לשבעה מסתדרים בצורה אנכית כך. ואם נחליק את

41
00:03:20,160 --> 00:03:24,880
השורה התחתונה עד הסוף ימינה, אז הזוג הייחודי שמצטבר לשניים, עיני הנחש,

42
00:03:24,880 --> 00:03:29,680
הם היחידים שמתיישרים. ואם אני מעביר את זה על יחידה אחת ימינה, הזוגות

43
00:03:29,680 --> 00:03:35,440
שמתיישרים הם שני הזוגות השונים שמצטברים לשלושה. ובאופן כללי, ערכי היסט שונים של המערך

44
00:03:35,440 --> 00:03:40,320
התחתון הזה, שזוכרים שהייתי צריך להסתובב קודם, חושפים את כל הזוגות הנבדלים שיש להם

45
00:03:40,320 --> 00:03:48,800
סכום נתון. בכל הקשור לשאלות הסתברות, זה עדיין לא מעניין במיוחד, כי כל

46
00:03:48,800 --> 00:03:53,120
מה שאנחנו עושים זה לספור כמה תוצאות יש בכל אחת מהקטגוריות האלה.

47
00:03:53,120 --> 00:03:57,280
אבל זה עם ההנחה הסמויה שיש סיכוי שווה לכל אחד מהפנים האלה

48
00:03:57,280 --> 00:04:02,240
לעלות. אבל מה אם אגיד לך שיש לי סט מיוחד של קוביות שהוא לא אחיד? אולי

49
00:04:02,240 --> 00:04:06,800
לקובייה הכחולה יש קבוצת מספרים משלה המתארת את ההסתברויות לכל פרצוף שמגיע, ולקובייה

50
00:04:06,800 --> 00:04:11,920
האדומה יש קבוצת מספרים ייחודית משלה. במקרה כזה, אם היית רוצה להבין,

51
00:04:11,920 --> 00:04:17,360
נניח, את ההסתברות לראות שתיים, היית מכפיל את ההסתברות שהקוביה הכחולה היא פי

52
00:04:17,360 --> 00:04:22,000
אחת מההסתברות שהקוביה האדומה היא אחת. ולמען הסיכויים לראות שלשה, אתה מסתכל

53
00:04:22,000 --> 00:04:26,880
על שני הזוגות הנבדלים היכן שזה אפשרי, ושוב, מכפילים את ההסתברויות המתאימות,

54
00:04:26,880 --> 00:04:32,240
ואז מוסיפים את שני המוצרים האלה יחד. באופן דומה, הסיכוי לראות ארבע

55
00:04:32,240 --> 00:04:36,320
כרוך בהכפלה של שלושה זוגות שונים של אפשרויות וחיבור של כולן יחד.

56
00:04:36,320 --> 00:04:41,360
וברוח הגדרת כמה נוסחאות, בואו נקרא להסתברויות העליונות האלה a1, a2, a3 וכן

57
00:04:41,360 --> 00:04:48,000
הלאה, ונמנה את התחתונות b1, b2, b3 וכו&#39;. ובאופן כללי, התהליך הזה,

58
00:04:48,000 --> 00:04:52,080
שבו אנחנו לוקחים שני מערכים שונים של מספרים, הופכים את השני,

59
00:04:52,080 --> 00:04:56,160
ואז מסדרים אותם בערכים שונים של היסט, לוקחים חבורה של מוצרים

60
00:04:56,160 --> 00:05:00,960
זוגיים ומוסיפים אותם, זה אחד מהאפשרויות. דרכים בסיסיות לחשוב מהי קונבולציה.

61
00:05:00,960 --> 00:05:08,960
אז רק כדי לאיית את זה קצת יותר במדויק, באמצעות התהליך הזה, פשוט יצרנו הסתברויות לראות

62
00:05:08,960 --> 00:05:13,840
שניים, שלוש, ארבע, על והלאה עד 12, והשגנו אותם על ידי ערבוב של רשימה אחת

63
00:05:13,840 --> 00:05:20,080
של ערכים, a ועוד אחת רשימת ערכים, ב. בשפה השפה, היינו אומרים שהקונבולוציה של שני הרצפים

64
00:05:20,080 --> 00:05:25,600
הללו נותנת לנו את הרצף החדש הזה, הרצף החדש של 11 ערכים, שכל אחד מהם נראה כמו

65
00:05:25,600 --> 00:05:30,160
סכום כלשהו של מוצרים בזוגיות. אם אתה מעדיף, דרך נוספת שאתה יכול לחשוב על אותה

66
00:05:30,160 --> 00:05:36,240
פעולה היא תחילה ליצור טבלה של כל המוצרים בזוגיות, ולאחר מכן להוסיף לאורך כל האלכסונים

67
00:05:36,240 --> 00:05:41,120
הללו. שוב, זו דרך לערבב יחד את שני רצפי המספרים הללו כדי להשיג לנו רצף חדש

68
00:05:41,120 --> 00:05:46,400
של 11 מספרים. זו אותה פעולה כמו שהחלונות ההזזה חשבו, רק עוד פרספקטיבה.

69
00:05:46,960 --> 00:05:51,280
שים לזה סימון קטן, הנה איך אתה עשוי לראות את זה כתוב. הקונבולולוציה של a ו-b,

70
00:05:51,280 --> 00:05:57,200
המסומנת בכוכבית קטנה זו, היא רשימה חדשה, והאלמנט ה-n של רשימה זו נראה כמו סכום,

71
00:05:57,200 --> 00:06:03,440
והסכום הזה עובר על כל זוגות המדדים השונים, i ו-j, כך שהסכום של המדדים

72
00:06:03,440 --> 00:06:09,440
האלה שווים ל-n. זה סוג של פת, אבל למשל, אם n היה 6, הזוגות שאנחנו עוברים עליהם

73
00:06:09,440 --> 00:06:15,680
הם 1 ו-5, 2 ו-4, 3 ו-3, 4 ו-2, 5 ו-1, כל הזוגות השונים שמצטברים עד 6.

74
00:06:16,400 --> 00:06:20,640
אבל בכנות, איך שתכתבו את זה, הסימון הוא משני בחשיבותו לוויז&#39;ואל

75
00:06:20,640 --> 00:06:26,320
שאולי תחזיק בראשכם לתהליך. כאן, אולי זה יעזור לעשות דוגמה סופר פשוטה, שבה אני עשוי

76
00:06:26,320 --> 00:06:32,000
לשאול אותך מה הקונבולולוציה של הרשימה 1, 2, 3, עם הרשימה 4, 5, 6. אתה יכול לצלם

77
00:06:32,000 --> 00:06:36,160
את שתי הרשימות האלה, להסתובב באחת השנייה, ואז להתחיל עם המכסה שלה

78
00:06:36,160 --> 00:06:41,200
כל הדרך שמאלה. ואז צמד הערכים שמתיישרים הם 1 ו-4, מכפילים אותם יחד, וזה

79
00:06:41,200 --> 00:06:45,680
נותן לנו את האיבר הראשון של הפלט שלנו. החלק את המערך התחתון הזה יחידה אחת

80
00:06:45,680 --> 00:06:51,840
ימינה, הזוגות שמתיישרים הם 1 ו-5, ו-2 ו-4, הכפל את הזוגות האלה, חבר אותם יחד, וזה נותן

81
00:06:51,840 --> 00:06:57,600
לנו 13, הערך הבא בפלט שלנו. החלק את הדברים פעם נוספת, וניקח 1 כפול 6, פלוס

82
00:06:57,600 --> 00:07:04,400
2 כפול 5, ועוד 3 כפול 4, שהם במקרה 28. עוד שקופית אחת, ונקבל 2 כפול 6,

83
00:07:04,400 --> 00:07:10,000
פלוס 3 כפול 5, וזה נותן לנו 27, ולבסוף המונח האחרון ייראה כמו 3 כפול 6.

84
00:07:10,560 --> 00:07:14,080
אם תרצה, תוכל להעלות את כל שפת התכנות המועדפת עליך ואת הספרייה

85
00:07:14,080 --> 00:07:18,640
האהובה עליך הכוללת פעולות מספריות שונות, ותוכל לאשר שאני לא משקר לך.

86
00:07:18,640 --> 00:07:24,320
אם אתה לוקח את הקונבולולוציה של 1, 2, 3, מול 4, 5, 6, זו אכן התוצאה שתקבל.

87
00:07:24,880 --> 00:07:29,200
ראינו מקרה אחד שבו זו פעולה טבעית ורצויה, המצטברת להתפלגות הסתברות,

88
00:07:29,200 --> 00:07:34,640
ודוגמה נפוצה נוספת תהיה ממוצע נע. תאר לעצמך שיש לך רשימה ארוכה

89
00:07:34,640 --> 00:07:39,920
של מספרים, ואתה לוקח עוד רשימה קטנה יותר של מספרים שכולם מסתכמים ב-1. במקרה הזה, יש לי

90
00:07:39,920 --> 00:07:45,280
רק רשימה קטנה של 5 ערכים, וכולם שווים ל-1 5. ואז אם נעשה את תהליך

91
00:07:45,280 --> 00:07:49,760
פיתול החלונות ההזזה הזה, וסוג של עוצם את עינינו ומטאטא מתחת לשטיח את מה

92
00:07:50,560 --> 00:07:55,120
שקורה ממש בתחילתו, ברגע שרשימת הערכים הקטנה שלנו חופפת לחלוטין לגדולה יותר, תחשוב

93
00:07:55,680 --> 00:08:01,120
על מה כל מונח בזה קונבולציה אומר באמת. בכל איטרציה, מה שאתה עושה זה

94
00:08:01,120 --> 00:08:06,400
להכפיל כל אחד מהערכים מהנתונים שלך ב-1 5, ולחבר את כולם ביחד, כלומר

95
00:08:06,400 --> 00:08:12,080
אתה לוקח ממוצע של הנתונים שלך בתוך החלון הקטן הזה. בסך הכל, התהליך נותן

96
00:08:12,080 --> 00:08:16,800
לך גרסה מוחלקת של הנתונים המקוריים, ואתה יכול לשנות את זה החל מרשימה קטנה

97
00:08:16,800 --> 00:08:21,280
אחרת של מספרים, וכל עוד הרשימה הקטנה הזו מסתכמת ב-1, אתה עדיין יכול לפרש

98
00:08:21,280 --> 00:08:25,840
אותה כתנועה נעה מְמוּצָע. בדוגמה המוצגת כאן, הממוצע הנע הזה ייתן משקל

99
00:08:25,840 --> 00:08:30,720
רב יותר לערך המרכזי. זה גם מביא לגרסה מוחלקת של הנתונים.

100
00:08:33,200 --> 00:08:37,840
אם אתה עושה סוג של אנלוגי דו מימדי של זה, זה נותן לך אלגוריתם מהנה לטשטוש

101
00:08:37,840 --> 00:08:43,120
תמונה נתונה. ואני צריך לומר שהאנימציות שאני עומד להראות שונו ממשהו שהכנתי

102
00:08:43,120 --> 00:08:48,160
במקור עבור חלק ממערך הרצאות שעשיתי עם מעבדת ג&#39;וליה ב-MIT עבור שיעור

103
00:08:48,160 --> 00:08:52,320
מסוים של OpenCourseWare שכללה יחידת עיבוד תמונה. שם עשינו קצת יותר כדי לצלול

104
00:08:52,320 --> 00:08:56,640
לתוך הקוד מאחורי כל זה, אז אם אתה סקרן אני אשאיר לך כמה קישורים. אבל

105
00:08:56,640 --> 00:09:01,440
אם נתמקד בחזרה בדוגמה המטשטשת הזו, מה שקורה הוא שיש לי את הרשת הקטנה

106
00:09:01,440 --> 00:09:06,480
הזו של ערכים בגודל 3x3 שצועדת לאורך התמונה המקורית שלנו, ואם נתקרב, כל אחד

107
00:09:06,480 --> 00:09:11,120
מהערכים האלה הוא 1 9, ומה אני עושה. בכל איטרציה מכפילים כל אחד מהערכים

108
00:09:11,120 --> 00:09:16,080
הללו בפיקסל המתאים שעליו הוא יושב. וכמובן שבמדעי המחשב אנו חושבים על צבעים

109
00:09:16,080 --> 00:09:20,400
כעל וקטורים קטנים בעלי שלושה ערכים, המייצגים את הרכיבים האדומים, הירוקים והכחולים.

110
00:09:20,400 --> 00:09:25,440
כשאני מכפיל את כל הערכים הקטנים האלה ב-1 9 ומחבר אותם יחד, זה

111
00:09:25,440 --> 00:09:30,480
נותן לנו ממוצע לאורך כל ערוץ צבע, והפיקסל המתאים לתמונה מימין מוגדר כסכום

112
00:09:30,480 --> 00:09:36,320
זה. ההשפעה הכוללת, כפי שאנו עושים זאת עבור כל פיקסל בודד בתמונה, היא שכל

113
00:09:36,320 --> 00:09:40,880
אחד מדמם לתוך כל השכנים שלו, מה שנותן לנו גרסה מטושטשת יותר מהמקור.

114
00:09:41,680 --> 00:09:46,640
בשפה השפה היינו אומרים שהתמונה מימין היא פיתול של התמונה המקורית שלנו עם רשת

115
00:09:46,640 --> 00:09:52,000
קטנה של ערכים. או יותר טכנית אולי אני צריך לומר שזו ההתהפכות עם גרסה מסובבת

116
00:09:52,000 --> 00:09:56,160
של 180 מעלות של רשת הערכים הקטנה הזו. לא שזה משנה מתי הרשת

117
00:09:56,160 --> 00:10:00,720
היא סימטרית, אבל רק כדאי לזכור שההגדרה של קונבולציה, כפי שהורשתה מהקשר

118
00:10:00,720 --> 00:10:05,760
המתמטי הטהור, צריכה תמיד להזמין אותך לחשוב על דפדוף במערך השני הזה.

119
00:10:05,760 --> 00:10:10,240
אם נשנה את זה מעט נוכל לקבל אפקט טשטוש הרבה יותר אלגנטי על ידי בחירת רשת

120
00:10:10,240 --> 00:10:15,920
ערכים אחרת. במקרה הזה יש לי רשת קטנה של 5x5, אבל ההבחנה היא לא כל כך בגודל שלה.

121
00:10:15,920 --> 00:10:19,920
אם אנו מתקרבים אנו מבחינים שהערך באמצע הוא הרבה יותר גדול מהערך

122
00:10:19,920 --> 00:10:25,360
כלפי הקצוות, ומאיפה זה מגיע הוא שכולם נדגמו מעקומת פעמון, המכונה התפלגות

123
00:10:25,360 --> 00:10:30,240
גאוסית. בדרך זו, כאשר אנו מכפילים את כל הערכים הללו בפיקסל המתאים שעליו

124
00:10:30,240 --> 00:10:35,200
הם יושבים, אנו נותנים הרבה יותר משקל לפיקסל המרכזי הזה והרבה פחות

125
00:10:35,200 --> 00:10:39,920
כלפי אלה שבקצה. ובדיוק כמו קודם הפיקסל המתאים בצד ימין מוגדר כסכום זה.

126
00:10:39,920 --> 00:10:45,360
כשאנחנו עושים את התהליך הזה עבור כל פיקסל בודד, זה נותן אפקט טשטוש שמדמה

127
00:10:45,360 --> 00:10:49,760
בצורה הרבה יותר אותנטית את הרעיון של הוצאת העדשה שלך מפוקוס או משהו כזה.

128
00:10:49,760 --> 00:10:54,960
אבל טשטוש הוא רחוק מלהיות הדבר היחיד שאתה יכול לעשות עם הרעיון הזה. לדוגמה, תסתכל על רשת

129
00:10:54,960 --> 00:10:59,600
הערכים הקטנה הזו, הכוללת כמה מספרים חיוביים משמאל וכמה מספרים

130
00:10:59,600 --> 00:11:04,480
שליליים מימין, שאצבע אותם בכחול ואדום בהתאמה. קחו רגע כדי לראות אם

131
00:11:04,480 --> 00:11:11,680
אתם יכולים לחזות ולהבין איזו השפעה תהיה לזה על התמונה הסופית. אז במקרה הזה אני

132
00:11:11,680 --> 00:11:16,560
פשוט אחשוב על התמונה כגווני אפור במקום צבעוני, כך שכל אחד מהפיקסלים מיוצג רק

133
00:11:16,560 --> 00:11:21,280
במספר אחד במקום שלושה. ודבר אחד שכדאי לשים לב אליו הוא שכשאנחנו עושים את הפיתול

134
00:11:21,280 --> 00:11:26,240
הזה אפשר לקבל ערכים שליליים. לדוגמה, בשלב זה כאן, אם אנו מתקרבים החצי השמאלי של

135
00:11:26,240 --> 00:11:30,960
הרשת הקטנה שלנו יושב כולו על גבי פיקסלים שחורים, שיהיה להם ערך של אפס, אבל החצי

136
00:11:30,960 --> 00:11:35,360
הימני של הערכים השליליים כולם יושבים על גבי פיקסלים לבנים, מה יש ערך של אחד.

137
00:11:36,000 --> 00:11:40,960
אז כאשר נכפיל מונחים מתאימים ונחבר אותם יחד התוצאות יהיו מאוד שליליות, והדרך

138
00:11:40,960 --> 00:11:45,120
שבה אני מציג זאת עם התמונה מימין היא לצבוע ערכים שליליים באדום וערכים

139
00:11:45,120 --> 00:11:49,520
חיוביים בכחול. דבר נוסף שכדאי לשים לב אליו הוא שכאשר אתה נמצא על תיקון שכולו

140
00:11:49,520 --> 00:11:55,680
אותו צבע הכל הולך לאפס מכיוון שסכום הערכים ברשת הקטנה שלנו הוא אפס. זה שונה

141
00:11:55,680 --> 00:11:59,680
מאוד משתי הדוגמאות הקודמות שבהן הסכום של הרשת הקטנה שלנו היה אחד, מה שאפשר

142
00:11:59,680 --> 00:12:05,760
לנו לפרש אותו כממוצע נע ומכאן לטשטוש. בסך הכל התהליך הקטן הזה בעצם

143
00:12:05,760 --> 00:12:10,240
מזהה היכן שיש שונות בערך הפיקסלים כשאתה עובר משמאל לימין, וכך הוא

144
00:12:10,240 --> 00:12:13,760
נותן לך סוג של דרך לקלוט את כל הקצוות האנכיים מהתמונה שלך.

145
00:12:16,560 --> 00:12:20,960
ובאופן דומה, אם סובבנו את הרשת הזו כך שתשתנה ככל שתזוז מלמעלה למטה,

146
00:12:20,960 --> 00:12:26,000
זה יתפוס את כל הקצוות האופקיים, מה שבמקרה של תמונת יצור העוגה

147
00:12:26,000 --> 00:12:31,520
הקטנה שלנו אכן מביא לכמה עיניים דמוניות למדי. הרשת הקטנה הזו, אגב, נקראת

148
00:12:31,520 --> 00:12:36,160
לעתים קרובות קרנל, והיופי כאן הוא איך רק על ידי בחירת ליבה אחרת אתה יכול לקבל

149
00:12:36,160 --> 00:12:40,240
אפקטים שונים של עיבוד תמונה, לא רק לטשטש את זיהוי הקצוות שלך אלא גם דברים כמו

150
00:12:40,240 --> 00:12:44,800
חידוד. לאלו מכם ששמעו על רשת עצבית קונבולוציונית, הרעיון שיש להשתמש בנתונים כדי

151
00:12:44,800 --> 00:12:49,600
להבין מה צריכות להיות הגרעינים מלכתחילה כפי שנקבע על ידי כל מה

152
00:12:49,600 --> 00:12:55,120
שהרשת העצבית רוצה לזהות. דבר נוסף שעלי אולי להעלות הוא אורך הפלט.

153
00:12:55,120 --> 00:12:59,040
עבור משהו כמו דוגמה של ממוצע נע, אולי תרצה לחשוב על המונחים רק כאשר

154
00:12:59,040 --> 00:13:04,080
שני החלונות מיושרים זה עם זה באופן מלא, או בדוגמה של עיבוד התמונה

155
00:13:04,080 --> 00:13:09,200
אולי אתה רוצה שהפלט הסופי יהיה באותו גודל כמו המקור. עכשיו פיתולים כפעולה מתמטית

156
00:13:09,200 --> 00:13:13,920
טהורה תמיד מייצרים מערך שגדול יותר משני המערכים שאיתם התחלת, לפחות

157
00:13:13,920 --> 00:13:17,520
בהנחה שלאחד מהם אין אורך של אחד. רק דעו שבהקשרים מסוימים

158
00:13:17,520 --> 00:13:21,440
של מדעי המחשב אתם רוצים לעתים קרובות לקטוע את הפלט הזה בכוונה.

159
00:13:21,520 --> 00:13:29,200
דבר נוסף שכדאי להדגיש הוא שבהקשר של מדעי המחשב הרעיון הזה של להסתובב בליבה הזו

160
00:13:29,200 --> 00:13:34,080
לפני שאתה נותן לו לצעוד על פני המקור לעתים קרובות מרגיש ממש מוזר ופשוט

161
00:13:34,080 --> 00:13:38,960
לא מתבקש, אבל שוב שים לב שזה מה שעובר בירושה מהקשר המתמטי הטהור שבו

162
00:13:38,960 --> 00:13:44,000
כמונו ראיתי עם ההסתברויות שזה דבר טבעי להפליא לעשות. ולמעשה אני יכול להראות לך

163
00:13:44,000 --> 00:13:48,480
עוד דוגמה אחת מתמטית טהורה שבה אפילו למתכנתים צריך להיות אכפת מזה כי זה פותח

164
00:13:48,480 --> 00:13:53,760
את הדלתות לאלגוריתם הרבה יותר מהיר לחשב את כל אלה. כדי להגדיר למה אני

165
00:13:53,760 --> 00:13:58,560
מתכוון במהיר יותר כאן תן לי לחזור ולמשוך שוב איזה פיתון ואני הולך ליצור שני

166
00:13:58,560 --> 00:14:02,880
מערכים גדולים יחסית. בכל אחד מהם יהיו מאה אלף אלמנטים אקראיים ואני הולך

167
00:14:02,880 --> 00:14:08,640
להעריך את זמן הריצה של פונקציית convolve מספריית numpy. ובמקרה הזה הוא

168
00:14:08,640 --> 00:14:12,800
מריץ אותו עבור מספר איטרציות שונות, מנסה למצוא ממוצע, ונראה שבמחשב הזה

169
00:14:12,880 --> 00:14:18,640
הוא לפחות בממוצע של 4. 87 שניות. לעומת זאת, אם אני משתמש

170
00:14:18,640 --> 00:14:24,080
בפונקציה שונה מספריית scipy שנקראת fftconvolve שזה אותו דבר רק מיושם אחרת

171
00:14:24,080 --> 00:14:30,640
שלוקח רק 4. 3 אלפיות שניות בממוצע, אז שיפור של שלושה סדרי גודל.

172
00:14:30,640 --> 00:14:34,800
ושוב למרות שהוא טס תחת שם אחר הוא נותן את אותו פלט שעושה פונקציית

173
00:14:34,800 --> 00:14:38,880
ה-convolve האחרת, הוא פשוט עושה משהו כדי לעשות את זה בצורה חכמה יותר.

174
00:14:38,880 --> 00:14:46,800
זכור איך עם דוגמת ההסתברות אמרתי שדרך אחרת שתוכל לחשוב על הקונבולציה היא

175
00:14:46,800 --> 00:14:51,520
ליצור את הטבלה הזו של כל התוצרים הזוגיים ואז לחבר את התוצרים הזוגיים

176
00:14:51,520 --> 00:14:56,560
לאורך האלכסונים. אין כמובן שום דבר ספציפי להסתברות בכל פעם שאתה מערבב שתי רשימות שונות

177
00:14:56,560 --> 00:15:00,880
של מספרים אתה יכול לחשוב על זה בצורה זו. צור טבלת כפל מסוג זה

178
00:15:00,880 --> 00:15:05,520
עם כל המוצרים בזוגיות ואז כל סכום לאורך האלכסון מתאים לאחת מהפלטים הסופיים

179
00:15:05,520 --> 00:15:11,680
שלך. הקשר אחד שבו השקפה זו טבעית במיוחד הוא כאשר מכפילים יחד

180
00:15:11,680 --> 00:15:16,240
שני פולינומים. לדוגמה, הרשו לי לקחת את הרשת הקטנה שכבר יש לנו ולהחליף את

181
00:15:16,240 --> 00:15:23,920
האיברים העליונים ב-1, 2x ו-3x בריבוע ולהחליף את המונחים האחרים ב-4, 5x ו-6x בריבוע.

182
00:15:23,920 --> 00:15:27,920
עכשיו תחשוב על מה זה אומר כשאנחנו יוצרים את כל המוצרים השונים האלה בזוגיות בין

183
00:15:27,920 --> 00:15:32,960
שתי הרשימות. מה שאתה עושה זה בעצם להרחיב את המכפלה המלאה של

184
00:15:32,960 --> 00:15:38,240
שני הפולינומים שרשמתי ואז כשאתה מוסיף לאורך האלכסון שמתאים לאיסוף כל

185
00:15:38,240 --> 00:15:43,920
האיברים הדומים שזה די מסודר, הרחבת פולינום ואיסוף איברים דומים זה

186
00:15:43,920 --> 00:15:50,640
בדיוק אותו תהליך כמו קונבולציה. אבל זה מאפשר לנו לעשות משהו שהוא די מגניב כי

187
00:15:50,640 --> 00:15:55,360
תחשוב על מה שאנחנו אומרים כאן. אנו אומרים שאם אתה לוקח שתי פונקציות שונות

188
00:15:55,360 --> 00:16:00,560
ומכפיל אותן יחד, שזו פעולה נקודתית פשוטה, זה אותו דבר כאילו אתה חילצת

189
00:16:00,560 --> 00:16:05,920
תחילה את המקדמים מכל אחד מאלה בהנחה שהם פולינומים ואז לוקחים קונבולולוציה

190
00:16:05,920 --> 00:16:11,840
של אלה. שתי רשימות של מקדמים. מה שעושה את זה כל כך מעניין הוא

191
00:16:11,840 --> 00:16:16,560
שהפיתולים מרגישים באופן עקרוני הרבה יותר מסובך מכפל פשוט, ואני לא מתכוון רק

192
00:16:16,560 --> 00:16:21,760
מבחינה רעיונית שקשה יותר לחשוב עליהם, אני מתכוון מבחינה חישובית, זה דורש יותר

193
00:16:21,760 --> 00:16:27,040
שלבים לביצוע קונבולציה מאשר לביצוע תוצר נקודתי של שתי רשימות שונות. לדוגמה, נניח שנתתי

194
00:16:27,040 --> 00:16:31,920
לך שני פולינומים גדולים באמת נניח שכל אחד מהם עם מאה מקדמים שונים, אז אם

195
00:16:32,480 --> 00:16:37,520
הדרך שבה אתה מכפיל אותם הייתה להרחיב את המוצר הזה אתה יודע למלא את

196
00:16:37,520 --> 00:16:43,600
כל הרשת הזו של 100 על 100 של מוצרים בזוגיות שתדרוש ממך בצע 10,000 מוצרים

197
00:16:43,600 --> 00:16:48,560
שונים ואז כשאתה אוסף את כל המונחים הדומים לאורך האלכסונים, זה עוד קבוצה של

198
00:16:48,560 --> 00:16:55,200
כ-10,000 פעולות. באופן כללי יותר בשפה היינו אומרים שהאלגוריתם הוא O של n בריבוע משמעות

199
00:16:55,200 --> 00:17:00,560
עבור שתי רשימות בגודל n באופן שבו מספר סולמות הפעולות הוא ביחס לריבוע של n.

200
00:17:00,560 --> 00:17:06,320
מצד שני אם אני חושב על שני פולינומים במונחים של הפלטים שלהם למשל

201
00:17:06,320 --> 00:17:11,680
דגימת הערכים שלהם בכמה קומץ תשומות אז הכפלתם דורשת רק כמה פעולות כמו

202
00:17:11,680 --> 00:17:17,200
מספר הדגימות שכן שוב זו פעולה נקודתית ועם פולינומים אתה רק צריך דגימות

203
00:17:17,200 --> 00:17:22,400
רבות באופן סופי כדי להיות מסוגלים לשחזר את המקדמים. לדוגמא שני פלטים מספיקים

204
00:17:22,400 --> 00:17:27,920
כדי לציין פולינום ליניארי באופן ייחודי שלוש פלטים יספיקו לציון ייחודי של פולינום ריבועי

205
00:17:27,920 --> 00:17:33,680
ובאופן כללי אם אתה מכיר n פלטים ברורים זה מספיק כדי לציין פולינום ייחודי

206
00:17:33,680 --> 00:17:38,800
שיש לו n מקדמים שונים או אם אתה מעדיף נוכל תנסח את זה בשפת

207
00:17:38,800 --> 00:17:43,680
מערכות משוואות תאר לעצמך שאני אומר לך שיש לי פולינום כלשהו אבל אני לא

208
00:17:43,680 --> 00:17:47,840
אומר לך מה הם המקדמים אלה הם תעלומה עבורך. בדוגמה שלנו אתה עשוי לחשוב על

209
00:17:47,840 --> 00:17:52,960
זה כעל המכפלה שאנו מנסים להבין ואז נניח שאני אומר שפשוט אגיד לך מה יהיו

210
00:17:52,960 --> 00:17:59,600
הפלטים של הפולינום הזה אם תזין קלט שונות כמו 0, 1, 2 , 3, הלאה

211
00:17:59,600 --> 00:18:04,800
והלאה ואני נותן לך מספיק כדי שיהיו לך כמה משוואות כמו שיש לך לא ידועות זו

212
00:18:04,800 --> 00:18:09,840
אפילו במקרה מערכת משוואות ליניארית אז זה נחמד ובאופן עקרוני לפחות זה אמור להספיק כדי

213
00:18:09,840 --> 00:18:14,880
לשחזר את המקדמים.

214
00:18:14,880 --> 00:18:20,160
two lists of numbers you treat them like they're coefficients of two polynomials you sample those

215
00:18:20,160 --> 00:18:26,560
polynomials at enough outputs multiply those samples point-wise and then solve the system

216
00:18:26,560 --> 00:18:32,720
to recover the coefficients as a sneaky backdoor way to find the convolution and as I've stated it

217
00:18:32,720 --> 00:18:38,000
so far at least some of you could rightfully complain grant that is an idiotic plan because

218
00:18:38,000 --> 00:18:43,120
for one thing just calculating all these samples for one of the polynomials we know already takes

219
00:18:43,120 --> 00:18:47,760
on the order of n squared operations not to mention solving that system is certainly going

220
00:18:47,760 --> 00:18:53,520
to be computationally as difficult as just doing the convolution in the first place so like sure

221
00:18:53,520 --> 00:18:58,400
we have this connection between multiplication and convolutions but all of the complexity happens in

222
00:18:58,400 --> 00:19:04,240
translating from one viewpoint to the other but there is a trick and those of you who know about

223
00:19:04,240 --> 00:19:09,200
Fourier transforms and the FFT algorithm might see where this is going if you're unfamiliar with this

224
00:19:09,200 --> 00:19:13,600
topics what I'm about to say might seem completely out of the blue just know that there are certain

225
00:19:13,600 --> 00:19:18,720
paths you could have walked in math that make this more of an expected step basically the idea is

226
00:19:18,720 --> 00:19:23,840
that we have a freedom of choice here if instead of evaluating at some arbitrary set of inputs like

227
00:19:23,840 --> 00:19:30,080
0 1 2 3 on and on you choose to evaluate on a very specially selected set of complex numbers

228
00:19:30,080 --> 00:19:34,400
specifically the ones that sit evenly spaced on the unit circle what are known as the roots of

229
00:19:34,400 --> 00:19:41,600
unity this gives us a friendlier system the basic idea is that by finding a number where taking its

230
00:19:41,600 --> 00:19:46,480
powers falls into this cycling pattern it means that the system we generate is going to have a lot

231
00:19:46,480 --> 00:19:51,360
of redundancy in the different terms that you're calculating and by being clever about how you

232
00:19:51,360 --> 00:19:57,600
leverage that redundancy you can save yourself a lot of work this set of outputs that I've written

233
00:19:57,600 --> 00:20:03,200
has a special name it's called the discrete Fourier transform of the coefficients and if you want to

234
00:20:03,200 --> 00:20:08,160
learn more I actually did another lecture for that same julia mit class all about discrete

235
00:20:08,160 --> 00:20:12,640
Fourier transforms and there's also a really excellent video on the channel reducible talking

236
00:20:12,640 --> 00:20:17,520
about the fast Fourier transform which is an algorithm for computing these more quickly also

237
00:20:17,520 --> 00:20:22,720
veritasium recently did a really good video on fft's so you've got lots of options and that fast

238
00:20:22,720 --> 00:20:28,320
algorithm really is the point for us again because of all this redundancy there exists a method to go

239
00:20:28,320 --> 00:20:33,040
from the coefficients to all of these outputs where instead of doing on the order of n squared

240
00:20:33,040 --> 00:20:38,080
operations you do on the order of n times the log of n operations which is much much better as you

241
00:20:38,080 --> 00:20:43,600
scale to big lists and importantly this fft algorithm goes both ways it also lets you go

242
00:20:43,600 --> 00:20:48,640
from the outputs to the coefficients so bringing it all together let's look back at our algorithm

243
00:20:48,640 --> 00:20:53,200
outline now we can say whenever you're given two long lists of numbers and you want to take their

244
00:20:53,200 --> 00:20:58,960
convolution first compute the fast Fourier transform of each one of them which in the back

245
00:20:58,960 --> 00:21:03,280
of your mind you can just think of as treating them like they're the coefficients of a polynomial

246
00:21:03,280 --> 00:21:08,960
and evaluating it at a very specially selected set of points then multiply together the two results

247
00:21:08,960 --> 00:21:14,480
that you just got point-wise which is nice and fast and then do an inverse fast Fourier transform

248
00:21:14,480 --> 00:21:18,480
and what that gives you is the sneaky backdoor way to compute the convolution that we were looking

249
00:21:18,480 --> 00:21:25,600
for but this time it only involves o of n log n operations that's really cool to me this very

250
00:21:25,600 --> 00:21:30,560
specific context where convolutions show up multiplying two polynomials opens the doors for

251
00:21:30,560 --> 00:21:35,120
an algorithm that's relevant everywhere else where convolutions might come up if you want to add

252
00:21:35,120 --> 00:21:39,600
probability distributions do some large image processing whatever it might be and i just think

253
00:21:39,600 --> 00:21:44,480
that's such a good example of why you should be excited when you see some operation or concept in

254
00:21:44,480 --> 00:21:50,160
math show up in a lot of seemingly unrelated areas if you want a little homework here's

255
00:21:50,160 --> 00:21:54,800
something that's fun to think about explain why when you multiply two different numbers just

256
00:21:54,800 --> 00:21:59,360
ordinary multiplication the way we all learn in elementary school what you're doing is basically

257
00:21:59,360 --> 00:22:04,640
a convolution between the digits of those numbers there's some added steps with carries and the like

258
00:22:04,640 --> 00:22:10,720
but the core step is a convolution in light of the existence of a fast algorithm what that means is

259
00:22:10,720 --> 00:22:16,000
if you have two very large integers then there exists a way to find their product that's faster

260
00:22:16,000 --> 00:22:20,720
than the method we learn in elementary school that instead of requiring o of n squared operations

261
00:22:20,720 --> 00:22:26,320
only requires o of n log n which doesn't even feel like it should be possible the catch is that

262
00:22:26,320 --> 00:22:31,280
before this is actually useful in practice your numbers would have to be absolutely monstrous

263
00:22:31,280 --> 00:22:36,880
but still it's cool that such an algorithm exists and next up we'll turn our attention to the

264
00:22:36,880 --> 00:22:51,040
continuous case with a special focus on probability distributions

