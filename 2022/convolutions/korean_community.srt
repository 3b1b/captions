1
00:00:00,130 --> 00:00:04,810
제가 당신에게 두 개의 다른 숫자 목록
또는 두 개의 다른 함수를 제공하고,

2
00:00:04,810 --> 00:00:08,340
이 두 목록을 결합하여 새로운 숫자 목록을 얻거나

3
00:00:08,340 --> 00:00:12,280
두 함수를 결합하여 새 함수를 얻을 수 있는
모든 방법을 생각해 보라고 가정해봅시다.

4
00:00:12,280 --> 00:00:16,740
마음에 떠오르는 한 가지 간단한 방법은
단순히 항끼리 함께 더하는 것입니다.

5
00:00:16,740 --> 00:00:20,660
마찬가지로, 함수에서도 해당
함수값을 모두 더할 수 있습니다.

6
00:00:20,660 --> 00:00:24,740
비슷한 맥락에서, 두 목록을 구간별로 곱하고
함수로도 동일한 작업을

7
00:00:24,740 --> 00:00:26,500
수행할 수도 있습니다.

8
00:00:26,500 --> 00:00:31,030
그러나 이 두 가지 조합만큼 기본적이지만
일반적으로 덜 언급되는 합성곱(Convolution)으로

9
00:00:31,030 --> 00:00:34,149
알려져 있는 또 다른 종류의 조합이 있습니다.

10
00:00:34,149 --> 00:00:38,260
그러나 앞의 두 경우와 달리,
단순히 숫자에 적용되는

11
00:00:38,260 --> 00:00:40,399
연산에 연관된 것이 아닙니다.

12
00:00:40,399 --> 00:00:45,100
이것은 숫자의 목록 또는 함수의 결합과
같은 맥락에서 진정으로 새로운 것입니다.

13
00:00:45,100 --> 00:00:48,750
이들은 주위 어디든지 나타나있고,
사진 처리에서 아주 흔합니다.

14
00:00:48,750 --> 00:00:53,789
이것은 확률론의 핵심 구조이며,
미분 방정식을 푸는 데 많이 사용되며 

15
00:00:53,789 --> 00:00:58,870
그리고 "합성곱"이라는 용어를 못 봤더라도,
여러분은 다항식을 서로 곱하는 것과 같은 맥락에서

16
00:00:58,870 --> 00:01:00,879
많이 봤을 겁니다.

17
00:01:00,879 --> 00:01:05,290
시각적 설명에 종사하는 사람으로서는,
이것은 특히 훌륭한 주제입니다.

18
00:01:05,290 --> 00:01:10,640
왜냐하면 고립되고 예시가 없는 공식으로 된 정의는
겁 주는 것처럼 보일 수 있기 때문입니다.

19
00:01:10,640 --> 00:01:14,860
하지만 만약 우리가 시간을 내서 이것이
무엇을 말하고 있는지 분석하고 그 전에,

20
00:01:14,860 --> 00:01:19,110
여러분이 왜 이런 것을 원하는지에 대한 동기를 부여한다면,
이것은 믿을 수 없을 정도로 아름다운 작업입니다.

21
00:01:19,110 --> 00:01:22,740
그리고 저도 이 프로젝트를 위한 시각 요소를
준비하는 동안, 실제로 저도 약간은 더 배웠다는 것을

22
00:01:22,740 --> 00:01:24,080
인정합니다.

23
00:01:24,080 --> 00:01:27,610
서로 다른 두 함수를 합성곱하는 경우,
저는 여러분들이 이것의 의미를 상상하는 것과 다른

24
00:01:27,610 --> 00:01:29,640
방법들로 생각하려고 노력했습니다.

25
00:01:29,640 --> 00:01:34,820
그리고 이들 중 하나에서, 저는 정규 분포가
확률론에서 왜 이런 역할을 하는지에 대해,

26
00:01:34,820 --> 00:01:36,710
깨달음을 가졌습니다.

27
00:01:36,710 --> 00:01:40,470
왜 정규 분포가 함수에 대해 그렇게 자연스러운 모양일까요,
저는 제 자신을 앞서가고 있습니다.

28
00:01:40,470 --> 00:01:41,930
이것에는 많은 설정이 있습니다.

29
00:01:41,930 --> 00:01:46,250
이 비디오에서 우리의 주된 초점은
이산적인 사례에 맞춰질 것이고,

30
00:01:46,250 --> 00:01:51,210
특히 이런것들을 계산하기 위한, 매우 예상은 못했지만
매우 영리한 알고리즘을 만드는 것입니다.

31
00:01:51,210 --> 00:01:58,970
그리고 저는 연속적인 사례에 대한
논의를 두 번째 파트에 끌어올 것입니다.

32
00:01:58,970 --> 00:02:02,780
시각적으로 가장 흥미롭기 때문에,
이미지 처리 사례로 시작하고 싶은 유혹이 크지만

33
00:02:02,780 --> 00:02:06,460
이미지 처리 사례가 전체적으로
합성곱을 덜 대표한다는

34
00:02:06,460 --> 00:02:09,190
약간의 까다로움이 있습니다.

35
00:02:09,190 --> 00:02:12,060
그래서, 대신에 확률론으로 시작해봅시다.

36
00:02:12,060 --> 00:02:15,530
그리고 특히, 모든 사람들이 그들의 삶의
어느 순간에 대해 생각해본다고 확신하는

37
00:02:15,530 --> 00:02:17,000
가장 간단한 예 중 하나입니다.

38
00:02:17,000 --> 00:02:21,310
바로, 주사위를 굴리고 다양한 합계를
볼 수 있는 확률을 알아내는

39
00:02:21,310 --> 00:02:22,310
것입니다.

40
00:02:22,310 --> 00:02:23,780
그리고 여러분은 별거 없다고 말할 수 있습니다.

41
00:02:23,780 --> 00:02:24,780
실제로 그렇습니다.

42
00:02:24,780 --> 00:02:29,780
두 개의 주사위 각각에는 6개의 다른 가능한
결과가 있으므로 총 36개의 서로 다른 가능한

43
00:02:29,780 --> 00:02:31,930
결과 쌍을 제공합니다.

44
00:02:31,930 --> 00:02:36,600
그리고 그것들을 모두 살펴보면,
주어진 합계를 가진 쌍이 몇 개인지 셀 수 있습니다.

45
00:02:36,600 --> 00:02:40,800
모든 쌍을 이와 같이 격자에 배열하면,
한 가지 매우 좋은 점은 합계가

46
00:02:40,800 --> 00:02:46,030
일정한 모든 쌍이 서로 다른 대각선 중
하나를 따라 표시된다는 것입니다.

47
00:02:46,030 --> 00:02:50,420
따라서 각 대각선에 존재하는 숫자를
세는 것만으로 특정 합계를 볼 확률이

48
00:02:50,420 --> 00:02:52,370
얼마나 되는지 알 수 있습니다.

49
00:02:52,370 --> 00:02:55,190
그리고 전 말합니다, 아주 좋아, 아주 좋아.

50
00:02:55,190 --> 00:02:59,459
그러나 여러분은 동일한 질문을 시각화할 수 있는
다른 방법을 생각할 수 있나요?

51
00:02:59,459 --> 00:03:03,819
주어진 합계를 갖는 모든 별개의 쌍을
생각할 수 있는, 마음에 떠오르는 다른 그림이

52
00:03:03,819 --> 00:03:05,099
있나요?

53
00:03:05,099 --> 00:03:08,140
그리고 아마도 여러분 중 한 명이 손을 들고
'예아, 난 있습니다.'라고 말할 수도 있습니다.

54
00:03:08,140 --> 00:03:12,290
이 두 가지 다른 확률 세트를 각각 행에 그려보고,

55
00:03:12,290 --> 00:03:14,239
두 번째 행을 뒤집는다고 가정해 보겠습니다.

56
00:03:14,239 --> 00:03:19,629
그런 식으로, 7로 더해지는 모든 서로 다른 쌍은
다음과 같이 세로로 정렬됩니다.

57
00:03:19,629 --> 00:03:23,360
그리고 맨 아래 행을 *왼쪽으로 끝까지 밀면,

58
00:03:23,360 --> 00:03:26,810
합이 2인 *뱀의 눈만 정렬됩니다.
(The Snake Eyes; 2개 주사위에서 1만 나온 상태)

59
00:03:26,810 --> 00:03:31,129
그리고 이것을 오른쪽으로 한 단위 밀면,
정렬되는 쌍은 서로 다른 두 쌍이 되고

60
00:03:31,129 --> 00:03:33,159
합은 3이 됩니다.

61
00:03:33,159 --> 00:03:37,530
그리고 일반적으로
이 하위 배열의 다른 오프셋 값은,

62
00:03:37,530 --> 00:03:45,220
제가 이것을 먼저 뒤집어야 했다는 것을 기억하고,
주어진 합계를 갖는 모든 개별 쌍을 나타냅니다.

63
00:03:45,220 --> 00:03:49,370
확률 질문이 진행될수록,
우리가 하는 모든 것은 이러한 각 범주에

64
00:03:49,370 --> 00:03:52,860
얼마나 많은 결과가 있는지 세는 것이므로
이것은 여전히 특별히 흥미롭지 않습니다.

65
00:03:52,860 --> 00:03:56,950
하지만 이는 각 면이 나올 확률이
같다는 암묵적인 가정에

66
00:03:56,950 --> 00:03:58,579
따른 것입니다.

67
00:03:58,579 --> 00:04:02,310
하지만 균등하지 않은 특별한
주사위 세트가 있다고 말하면 어떻게 될까요?

68
00:04:02,310 --> 00:04:05,990
파란색 주사위에는 각 면이 나올 확률을
나타내는 고유한 숫자 집합이 있고

69
00:04:05,990 --> 00:04:09,959
빨간색 주사위에도 고유한
숫자 집합이 있을 수 있습니다.

70
00:04:09,959 --> 00:04:14,549
이 경우 예를 들어
2가 나올 확률을 알고 싶다면,

71
00:04:14,549 --> 00:04:19,180
파란색 주사위가 1일 확률에
빨간색 주사위가 1일 확률을 곱하면

72
00:04:19,180 --> 00:04:20,220
됩니다.

73
00:04:20,220 --> 00:04:23,919
그리고 3이 나올 확률을 얻으려면,
그것이 가능한 두 개의 별개의 쌍을 보고

74
00:04:23,919 --> 00:04:29,330
해당 확률들을 다시 곱한 다음
이 두 곱들을 함께 

75
00:04:29,330 --> 00:04:30,330
더합니다.

76
00:04:30,330 --> 00:04:34,690
마찬가지로, 4가 나올 확률은
세 가지 다른 확률 쌍을 곱하고

77
00:04:34,690 --> 00:04:37,520
모두 더하는 것입니다.

78
00:04:37,520 --> 00:04:41,770
그리고 어떤 공식을 만든다는 정신으로,
이 위에 있는 확률의 이름을 "𝒂₁, 𝒂₂, 𝒂₃"

79
00:04:41,770 --> 00:04:46,660
등으로 지정하고 밑에 있는 확률의 이름을
"𝒃₁, 𝒃₂, 𝒃₃" 등으로 지정하겠습니다.

80
00:04:46,660 --> 00:04:50,880
그리고 일반적으로, 두 개의
서로 다른 숫자 배열을 사용하여,

81
00:04:50,880 --> 00:04:55,389
두 번째 배열을 뒤집은 다음
다양한 오프셋 값에 정렬하고,

82
00:04:55,389 --> 00:04:59,389
여러 쌍의 곱을 가져와 더하는 이 과정이
합성곱이 뭔지 생각할 수 있는

83
00:04:59,389 --> 00:05:03,200
근본적인 방법입니다.

84
00:05:03,200 --> 00:05:09,680
그래서, 이 과정에 관해 좀 더 정확하게 설명하자면,

85
00:05:09,680 --> 00:05:12,090
우리는 2, 3, 4, 계속해서 최대 12까지
나올 확률을 생성했습니다.

86
00:05:12,090 --> 00:05:17,550
그리고 하나의 값 목록 𝒂와 다른 값 목록
𝒃를 함께 혼합하여 값을 얻었습니다.

87
00:05:17,550 --> 00:05:23,130
전문 용어로, 우리는 이 두 배열의 합성곱이
우리에게 이 새로운 배열을 제공한다고 말합니다.

88
00:05:23,130 --> 00:05:27,880
11개 값의 새로운 배열은,
각 값은 쌍들의 곱의 합처럼 보입니다.

89
00:05:27,880 --> 00:05:32,240
원하는 경우, 동일한 연산에 대해
생각할 수 있는 또 다른 방법은

90
00:05:32,240 --> 00:05:37,190
먼저 모든 쌍들의 곱을 격자로 만든 다음
이러한 모든 대각선을 따라 더하는 것입니다.

91
00:05:37,190 --> 00:05:41,729
다시 말하지만, 이것은 이 두 개의 숫자 배열을
함께 혼합하여 새로운 11개의

92
00:05:41,729 --> 00:05:43,300
숫자 배열을 얻는 방법입니다.

93
00:05:43,300 --> 00:05:47,350
그리고 이것은 *슬라이딩 창으로 했던 동일한 연산이며,
단지 다른 관점일 뿐입니다.
(이전 영상 참고)

94
00:05:47,350 --> 00:05:51,040
약간의 표기법을 적용하면,
다음과 같이 쓰여진 것을 볼 수 있습니다.

95
00:05:51,040 --> 00:05:55,070
이 작은 *로 표시된 𝒂와 𝒃의 합성곱은
새로운 목록입니다.

96
00:05:55,070 --> 00:06:00,259
그리고 그 목록의 n번째 요소는,
합처럼 보이고 그 합은

97
00:06:00,259 --> 00:06:05,180
인덱스의 모든 다른 쌍인 𝒊와 𝒋에 적용되므로
해당 인덱스의 합은 𝒏과 같습니다.

98
00:06:05,180 --> 00:06:09,950
길고 복잡한 말인거 같지만, 예를 들어
𝒏이 6이라면 우리가 살펴볼 쌍들은

99
00:06:09,950 --> 00:06:14,270
1과 5, 2와 4, 3과 3,
4와 2, 5와 1입니다.

100
00:06:14,270 --> 00:06:16,169
이 모든 다른 쌍들은 6으로 더해집니다.

101
00:06:16,169 --> 00:06:20,370
그러나 솔직히, 여러분이 어떻게 기록하든,
표기법은 여러분이 그 과정을

102
00:06:20,370 --> 00:06:23,130
여러분의 머리 속에 간직할 수 있는
시각적인 것보다 중요하지는 않습니다.

103
00:06:23,130 --> 00:06:27,270
여기에서, 제가 여러분에게 물어볼 수 있는
아주 간단한 예를 생각하는 것이 도움이 될 것입니다.

104
00:06:27,270 --> 00:06:31,539
목록 1, 2, 3과 목록 4, 5, 6의 합성곱은 무엇이나요?

105
00:06:31,539 --> 00:06:35,910
여러분은 이 두 목록을 모두 가져와,
두 번째 목록을 뒤집은 다음 왼쪽 끝에서

106
00:06:35,910 --> 00:06:38,270
슬라이딩을 시작하는 것을 상상할 수 있습니다.

107
00:06:38,270 --> 00:06:41,990
그런 다음 정렬되는 값의 쌍은
1과 4이고, 함께 곱하면

108
00:06:41,990 --> 00:06:44,200
결과값의 첫 번째 항이 제공됩니다.

109
00:06:44,200 --> 00:06:49,669
아래 배열을 오른쪽으로 한 단위 밀어서,
정렬되는 쌍은 1, 5, 2 그리고 4입니다.

110
00:06:49,669 --> 00:06:53,080
이 쌍을 곱하고, 서로 더하면
13이 됩니다.

111
00:06:53,080 --> 00:06:55,110
이 결과값의 다음 항입니다.

112
00:06:55,110 --> 00:07:02,199
한 번 더 슬라이드하면,
1×6+2×5+3×4이므로 28이 됩니다.

113
00:07:02,199 --> 00:07:08,930
한 번 더 슬라이드하면, 2×6+3×5인
27이 되고 마지막 항은

114
00:07:08,930 --> 00:07:10,790
3×6처럼 보입니다.

115
00:07:10,790 --> 00:07:14,539
원하는 경우, 좋아하는 프로그래밍 언어와
다양한 수치 연산이 포함된 라이브러리를

116
00:07:14,539 --> 00:07:19,080
가져올 수 있으며, 제가 거짓말을
하고 있지 않다는 것을 확인할 수 있습니다.

117
00:07:19,080 --> 00:07:24,310
4, 5, 6에 대해 1, 2, 3의 합성곱을
취하면 실제로 얻을 수 있는

118
00:07:24,310 --> 00:07:25,310
결과입니다.

119
00:07:25,310 --> 00:07:30,139
우리는 이것이 확률 분포에 추가되는 자연스럽고
바람직한 연산이라는 경우를 한 번

120
00:07:30,139 --> 00:07:31,460
보았습니다.

121
00:07:31,460 --> 00:07:34,110
그리고 또 다른 일반적인 예는 이동 평균입니다.

122
00:07:34,110 --> 00:07:38,610
긴 숫자 목록이 있고,
모두 더하면 1이 되는 더 작은 숫자 목록이

123
00:07:38,610 --> 00:07:39,880
하나 더 있다고 상상해봅시다.

124
00:07:39,880 --> 00:07:43,910
이 경우에는, 5개의 값이 있는
작은 목록이 있고 모두 ⅕로 같습니다.

125
00:07:43,910 --> 00:07:49,360
그런 다음 이 슬라이딩 창 합성곱 과정을 실행하고,
눈을 감은 거와 같이 이 과정을 숨긴다면

126
00:07:49,360 --> 00:07:51,919
맨 처음에 했었던 *일이 발생합니다.
(이전 영상 참고)

127
00:07:51,919 --> 00:07:56,509
우리의 작은 값의 목록이 더 큰 값의
목록과 완전히 겹치면, 이 합성곱의 각 구간이

128
00:07:56,509 --> 00:07:59,069
실제로 무엇을 의미하는지 생각해봅시다.

129
00:07:59,069 --> 00:08:04,569
각 반복에서, 실행하는 연산은
데이터의 각 값에 ⅕을 곱하고

130
00:08:04,569 --> 00:08:06,349
모두 더하는 것입니다.

131
00:08:06,349 --> 00:08:11,039
즉, 이 작은 창에서 데이터의
평균을 구하고 있습니다.

132
00:08:11,039 --> 00:08:15,380
전반적으로, 이 프로세스는 원본 데이터에
비해 부드러운 버전을 제공합니다.

133
00:08:15,380 --> 00:08:18,900
그리고 모두 더하면 1이 되는
다른 숫자 목록으로 수정해도,

134
00:08:18,900 --> 00:08:22,889
이를 여전히 이동 평균으로
해석할 수 있습니다.

135
00:08:22,889 --> 00:08:27,669
여기에 표시된 예에서, 해당 이동 평균은
중앙 값에 더 많은 가중치를

136
00:08:27,669 --> 00:08:28,669
부여합니다.

137
00:08:28,669 --> 00:08:33,459
이것은 또한 데이터의
부드러운 버전을 생성합니다.

138
00:08:33,459 --> 00:08:37,479
이것을 2차원 아날로그에 수행하면,
주어진 이미지를 흐리게 하는 재미있는

139
00:08:37,479 --> 00:08:39,460
알고리즘을 제공합니다.

140
00:08:39,460 --> 00:08:43,770
그리고 제가 보여주려는 애니메이션은,
이미지 처리 과정이 포함된

141
00:08:43,770 --> 00:08:48,950
특정 공개 교육용 수업을 위해 MIT의
Julia Lab과 함께 했던, 제가 원래 만든

142
00:08:48,950 --> 00:08:51,630
강의의 일부에서 수정되었습니다.

143
00:08:51,630 --> 00:08:54,550
거기에서 우리는 이 모든 것 뒤에 있는
코드에 대해 조금 더 자세히 살펴보았습니다.

144
00:08:54,550 --> 00:08:56,700
그래서 궁금하신 분들을 위해,
링크를 남겨드립니다.

145
00:08:56,700 --> 00:08:58,910
그러나 이 모자이크 예에 다시 집중해봅시다.

146
00:08:58,910 --> 00:09:03,390
여기서 진행되고 있는 것은 원래 이미지를
따라 움직이는 이 작은 3×3의 격자가

147
00:09:03,390 --> 00:09:04,390
있습니다.

148
00:09:04,390 --> 00:09:07,050
그리고 확대하면,
각 값은 ⅑입니다.

149
00:09:07,050 --> 00:09:11,890
그리고 각 반복에서 제가 하는 것은,
각 값을 그 위에 있는

150
00:09:11,890 --> 00:09:13,940
해당 픽셀과 곱하는 것입니다.

151
00:09:13,940 --> 00:09:18,100
그리고 물론 컴퓨터 과학에서,
우리는 색상을 빨강, 녹색 및 파랑 구성요소로

152
00:09:18,100 --> 00:09:20,670
나타내는 *세 가지 값의 작은 벡터로 생각합니다.
(RGB)

153
00:09:20,670 --> 00:09:24,640
이 모든 작은 값에
⅑을 곱하고 모두 더하면,

154
00:09:24,640 --> 00:09:28,880
각 색상들의 평균이 되고
오른쪽 이미지의 해당 픽셀이

155
00:09:28,880 --> 00:09:32,010
그 합계로 정의됩니다.

156
00:09:32,010 --> 00:09:36,270
이미지의 모든 단일 픽셀에 대해
이 연산을 수행할 때 전반적인 효과는,

157
00:09:36,270 --> 00:09:40,430
각 번짐이 모든 이웃에 있어,
원본보다 더 흐린 버전을 제공한다는

158
00:09:40,430 --> 00:09:41,930
것입니다.

159
00:09:41,930 --> 00:09:46,649
전문 용어로, 오른쪽에 있는 이미지는
작은 값의 격자와 원본 이미지의 합성곱이라고

160
00:09:46,649 --> 00:09:48,310
말할 수 있습니다.

161
00:09:48,310 --> 00:09:52,970
또는 좀 더 기술적으로 말하자면,
이 작은 격자가 180°로 회전된 합성곱이라고

162
00:09:52,970 --> 00:09:54,960
말해야 할 것 같습니다.

163
00:09:54,960 --> 00:09:58,470
격자가 대칭인 경우는 중요하지 않지만,
순수 수학의 맥락에서,

164
00:09:58,470 --> 00:10:02,709
합성곱의 정의는, 항상 두 번째 배열을
뒤집는 것에 대한

165
00:10:02,709 --> 00:10:05,970
생각을 초대해야 한다는 점을
명심해야 합니다.

166
00:10:05,970 --> 00:10:09,880
이것을 약간 수정하면, 다른 값의 격자를
선택하여 훨씬 더 우아한 모자이크

167
00:10:09,880 --> 00:10:11,430
효과를 얻을 수 있습니다.

168
00:10:11,430 --> 00:10:16,149
이 경우에는, 약간의 5×5 격자가 있지만
그 크기가 그다지 큰 차이는 아닙니다.

169
00:10:16,149 --> 00:10:19,680
확대하면, 중간 값이 가장자리
값보다 훨씬 더 크다는 것을

170
00:10:19,680 --> 00:10:20,839
알 수 있습니다.

171
00:10:20,839 --> 00:10:25,570
그리고 이것이 어디에서 왔냐면, 가우스 분포로
알려진 종형 곡선에서 모두 나온

172
00:10:25,570 --> 00:10:26,570
것 입니다.

173
00:10:26,570 --> 00:10:30,860
이런 식으로, 이 모든 값을 해당 픽셀과 곱하면,

174
00:10:30,860 --> 00:10:35,360
중앙 픽셀에 훨씬 더 많은 가중치를 부여하고
가장자리에 있는 픽셀에는 훨씬 적은 가중치를

175
00:10:35,360 --> 00:10:36,839
부여합니다.

176
00:10:36,839 --> 00:10:41,420
그리고 이전과 마찬가지로,
오른쪽의 해당 픽셀은 이 합계로 정의됩니다.

177
00:10:41,420 --> 00:10:45,390
모든 단일 픽셀에 대해 이 과정을 수행함에 따라,
렌즈를 초점에서 벗어나게 하는 개념을,

178
00:10:45,390 --> 00:10:50,000
훨씬 더 확실하게 시뮬레이션하는
흐림 효과를 제공합니다.

179
00:10:50,000 --> 00:10:53,860
하지만 블러링은 이 아이디어로
할 수 있는 유일한 것이 아닙니다.

180
00:10:53,860 --> 00:10:57,960
예를 들어, 왼쪽에는 양수 그리고
오른쪽에는 음수가 포함된

181
00:10:57,960 --> 00:11:02,310
이 작은 값 격자를 살펴보세요.
각각 파란색과 빨간색으로

182
00:11:02,310 --> 00:11:03,730
색칠하겠습니다.

183
00:11:03,730 --> 00:11:07,700
이것이 최종 이미지에 어떤 영향을 미칠지
예측하고, 이해할 수 있는지 잠시 시간을 내어

184
00:11:07,700 --> 00:11:10,760
확인해보세요.

185
00:11:10,760 --> 00:11:14,990
따라서 이 경우에는, 이미지를 컬러가
아닌 흑백으로 생각하겠습니다.

186
00:11:14,990 --> 00:11:18,519
따라서 각 픽셀은 3개가 아닌
하나의 숫자로 표시됩니다.

187
00:11:18,519 --> 00:11:22,180
주목할 가치가 있는 한 가지는
이 합성곱을 수행할 때, 음수 값을

188
00:11:22,180 --> 00:11:23,180
얻을 수 있다는 것입니다.

189
00:11:23,180 --> 00:11:27,270
예를 들어, 여기 이 지점에서 확대하면,
작은 격자의 왼쪽 절반이

190
00:11:27,270 --> 00:11:30,960
값이 0인 검은색 픽셀
위에 완전히 위치합니다.

191
00:11:30,960 --> 00:11:34,630
그러나 음수 값의 오른쪽 절반은
모두 값이 1인 흰색 픽셀 위에

192
00:11:34,630 --> 00:11:36,260
있습니다.

193
00:11:36,260 --> 00:11:40,510
따라서 해당 항을 곱하고 서로
더하면, 결과는 매우 음수가

194
00:11:40,510 --> 00:11:41,510
됩니다.

195
00:11:41,510 --> 00:11:44,670
오른쪽 이미지와 함께 이것을
표시하는 방법은 음수 값을 빨간색으로,

196
00:11:44,670 --> 00:11:47,130
양수 값을 파란색으로 칠하는 것입니다.

197
00:11:47,130 --> 00:11:50,640
주목해야 할 또 다른 사항은
모두 같은 색상의 부분에 있을 때,

198
00:11:50,640 --> 00:11:55,470
작은 격자의 값의 합계가 0이기 때문에
모든 것이 0이 된다는 것입니다.

199
00:11:55,470 --> 00:11:58,470
이것은 우리의 작은 격자의 합이
1인 이전 두 예제와 매우 다릅니다.

200
00:11:58,470 --> 00:12:03,820
이를 통해 이동 평균으로 해석할 수 있고,
이 이유 때문에 모자이크가 발생합니다.

201
00:12:03,820 --> 00:12:08,000
대체로, 이 작은 과정 기본적으로
왼쪽에서 오른쪽으로 이동할 때

202
00:12:08,000 --> 00:12:10,380
픽셀 값의 변화가 있는 곳을 감지합니다.

203
00:12:10,380 --> 00:12:14,820
따라서 이미지에서 모든 수직 가장자리를
가려낼 수 있는 일종의 방법을 제공합니다.

204
00:12:14,820 --> 00:12:20,820
마찬가지로, 위에서 아래로 이동할 때
격자가 달라지도록 회전하면

205
00:12:20,820 --> 00:12:24,589
모든 수평 가장자리를 가려낼 수 있습니다.

206
00:12:24,589 --> 00:12:28,949
우리의 작은 π 이미지의 경우에는,
예쁜 악마의 눈이

207
00:12:28,949 --> 00:12:30,639
생깁니다.

208
00:12:30,639 --> 00:12:33,260
그런데, 이 작은 격자를, 종종
핵(kernel)이라고 합니다.

209
00:12:33,260 --> 00:12:36,760
그리고 여기서 아름다움은 다른 핵(kernel)을
선택하는 것만으로도, 다른 이미지 처리 효과를

210
00:12:36,760 --> 00:12:38,170
얻을 수 있다는 것입니다.

211
00:12:38,170 --> 00:12:41,170
가장자리를 흐리게 하는 것뿐만 아니라
선명하게 하는 것과 같은 것들도 있습니다.

212
00:12:41,170 --> 00:12:45,399
합성곱 신경망(CNN)에 대해 들어본 적이 있는
사람들에게는, 데이터를 사용하여

213
00:12:45,399 --> 00:12:48,570
처음에 핵(kernel)이 무엇이어야 하는지
파악하는 아이디어가 있습니다.

214
00:12:48,570 --> 00:12:52,960
신경망이 감지하려는 것이
무엇이든 결정됩니다.

215
00:12:52,960 --> 00:12:55,580
제가 언급해야 할 또 다른 사항은
결과값 길이입니다.

216
00:12:55,580 --> 00:12:59,550
이동 평균 예와 같은 경우,
두 창이 서로 완전히 정렬되는 경우에만

217
00:12:59,550 --> 00:13:01,980
구간에 대해 생각하고 싶을 수 있습니다.

218
00:13:01,980 --> 00:13:06,180
또는 이미지 처리 예제에서,
최종 출력이 원본과 동일한 크기를 갖기를

219
00:13:06,180 --> 00:13:07,740
원할 수 있습니다.

220
00:13:07,740 --> 00:13:12,279
이제, 순수한 수학 연산으로서의 합성곱은,
항상 시작했던 두 개의 배열보다

221
00:13:12,279 --> 00:13:13,850
큰 배열을 생성합니다.

222
00:13:13,850 --> 00:13:16,860
적어도 그들 중 하나의 길이가 1이
아니라고 가정합니다.

223
00:13:16,860 --> 00:13:20,850
특정 컴퓨터 과학 맥락에서,
의도적으로 해당 출력을 자르려는 경우가

224
00:13:20,850 --> 00:13:25,030
종종 있습니다.

225
00:13:25,030 --> 00:13:28,610
강조할 가치가 있는 또 다른 사항은
컴퓨터 과학의 맥락에서,

226
00:13:28,610 --> 00:13:32,790
핵이 원본을 가로질러 행진하기 전에,
해당 핵을 뒤집는다는 개념이 종종 

227
00:13:32,790 --> 00:13:35,270
정말 이상하고 불필요하게 느껴진다는 것입니다.

228
00:13:35,270 --> 00:13:39,160
그러나 다시 말하지만, 확률에서 보았던 것처럼,
순수한 수학적 맥락에 연관 돼 있는 것은,

229
00:13:39,160 --> 00:13:43,149
믿을 수 없을 정도로 자연스러운
일이라는 점에 유의하세요.

230
00:13:43,149 --> 00:13:47,100
그리고 사실, 전 여러분에게 프로그래머도 관심을
가져야 할 더 순수한 수학적 예제를 보여줄 수 있습니다.

231
00:13:47,100 --> 00:13:51,690
왜냐하면 이것은 이러한 모든 것들을 더 빠르게
계산할 수 있는 알고리즘의 문을 열어주기 

232
00:13:51,690 --> 00:13:52,690
때문입니다.

233
00:13:52,690 --> 00:13:57,180
여기에서 제가 의미하는 바를 더 빠르게 준비하기 위해,
뒤로 돌아가서 일부 Python을 다시 가져오고

234
00:13:57,180 --> 00:14:00,009
상대적으로 큰 두 개의
서로 다른 배열을 만들 것입니다.

235
00:14:00,009 --> 00:14:05,060
각각에는 10만개의 임의의 원소가 있으며
Numpy 라이브러리에서

236
00:14:05,060 --> 00:14:08,260
합성곱 함수의 실행 시간을 측정할 것입니다.

237
00:14:08,260 --> 00:14:12,110
그리고 이 경우, Python은 여러 다른 반복을 위해
합성곱을 실행하고, 평균을 찾으려고 시도하고,

238
00:14:12,110 --> 00:14:16,560
이 결과는 이 컴퓨터에서 적어도
평균 4.87초인 것처럼 보입니다.

239
00:14:16,560 --> 00:14:22,589
반대로, *FFT합성곱 이라는 SciPy 라이브러리의
다른 함수를 사용하는 경우에는,
(Fast Fourier Transform)

240
00:14:22,589 --> 00:14:28,370
동일한 계산을 다르게 구현하면
평균 4.3밀리초밖에 걸리지 않습니다. 

241
00:14:28,370 --> 00:14:30,980
따라서, 세자리 수 만큼 개선되었습니다.
(1,000 ms = 1s)

242
00:14:30,980 --> 00:14:34,680
그리고 다시, 다른 이름으로 작동하지만,
다른 합성곱 함수와 동일한 출력을

243
00:14:34,680 --> 00:14:40,540
제공하고, 더 영리한 방식으로
작업을 수행할 뿐입니다.

244
00:14:40,540 --> 00:14:42,269
[Music]
FFT합성곱이 뭘까?

245
00:14:42,269 --> 00:14:46,329
그 전에 한 확률론의 예제를 기억해보면,
합성곱에 대해 생각할 수 있는

246
00:14:46,329 --> 00:14:50,720
또 다른 방법은 모든 쌍별 곱의 표를
만든 다음 대각선을 따라 해당 쌍별 곱을

247
00:14:50,720 --> 00:14:52,970
더하는 것이라고 말했습니다.

248
00:14:52,970 --> 00:14:55,829
물론, 확률에 특별한 것은 따로 없습니다.

249
00:14:55,829 --> 00:14:59,640
여러분은 두 개의 서로 다른 숫자 목록을
합성곱할 때마다, 이렇게 생각할 수 있습니다.

250
00:14:59,640 --> 00:15:03,759
모든 쌍별 곱을 이러한 종류의 곱셈 표를
만든 다음 대각선을 따라

251
00:15:03,759 --> 00:15:07,759
더한 것은, 최종 출력 중
하나에 해당합니다.

252
00:15:07,759 --> 00:15:11,889
이 보기가 특히 자연스러운 상황 중
하나는, 두 개의 다항식을 함께 곱할

253
00:15:11,889 --> 00:15:12,980
때입니다.

254
00:15:12,980 --> 00:15:16,920
예를 들어, 우리가 이미 가지고 있는
작은 격자판에서 위쪽 항을

255
00:15:16,920 --> 00:15:24,070
1, 2𝒙, 3𝒙² 으로 바꾸고 다른 항을
4, 5𝒙, 6𝒙² 으로 바꾸겠습니다.

256
00:15:24,070 --> 00:15:27,670
이제 우리가 두 목록 사이에 이러한 서로 다른
모든 쌍별 곱을 생성할 때, 이것이 무엇을 의미하는지

257
00:15:27,670 --> 00:15:29,579
생각해 보세오.

258
00:15:29,579 --> 00:15:33,709
여러분이 하고 있는 것은 본질적으로
제가 기록한 두 다항식의 전체 곱을

259
00:15:33,709 --> 00:15:35,139
확장하는 것입니다.

260
00:15:35,139 --> 00:15:40,949
그런 다음 대각선을 따라 더하면, 이것은 유사한
항들을 모두 모으는 것과 같습니다.

261
00:15:40,949 --> 00:15:44,980
이건 꽤 깔끔합니다. 다항식을 확장하고
유사한 항들을 수집하는 것은

262
00:15:44,980 --> 00:15:48,069
합성곱과 정확히 동일한 과정입니다.

263
00:15:48,069 --> 00:15:51,030
하지만 이것은 우리가 꽤 멋진 일을
할 수 있게 해줍니다.

264
00:15:51,030 --> 00:15:55,060
여기서 우리가 말하는 것을 생각해봅시다.
두 개의 서로 다른 함수를 취하고

265
00:15:55,060 --> 00:15:59,509
함께 곱하면, 간단한 점 연산인 경우

266
00:15:59,509 --> 00:16:05,459
각 함수에서 먼저 계수를 추출한 것과 같습니다.
그것들이 다항식이라고 가정하고

267
00:16:05,459 --> 00:16:09,700
두 계수 목록의 합성곱을 취합니다.

268
00:16:09,700 --> 00:16:14,250
이를 흥미롭게 만드는 것은, 합성곱이 원칙적으로
단순한 곱셈보다 훨씬 더 복잡하게

269
00:16:14,250 --> 00:16:15,970
느껴진다는 것입니다.

270
00:16:15,970 --> 00:16:20,020
개념적으로 생각하기 어렵다는 의미가 아니라,
계산적으로 두 개의 서로 다른 목록의 점곱을

271
00:16:20,020 --> 00:16:24,759
수행하는 것보다 합성곱을 수행하는 데
더 많은 단계가 필요하다는 것을

272
00:16:24,759 --> 00:16:25,930
의미합니다.

273
00:16:25,930 --> 00:16:29,750
예를 들어, 제가 여러분에게 두 개의
정말 큰 다항식을 주었다고 합시다.

274
00:16:29,750 --> 00:16:32,800
100개의 서로 다른 계수로 있다고 가정해봅시다.

275
00:16:32,800 --> 00:16:37,100
그런 다음 이 방법이 이 곱을 확장하는
것이라면, 쌍으로 된 곱의

276
00:16:37,100 --> 00:16:40,640
전체 100×100 격자를 채우는 것입니다.

277
00:16:40,640 --> 00:16:43,850
그렇게 하려면 10,000개의
서로 다른 곱을 수행해야 합니다.

278
00:16:43,850 --> 00:16:47,480
그런 다음 대각선을 따라
유사한 항들을 모두 수집하면

279
00:16:47,480 --> 00:16:50,779
약 10,000개 연산의 또 다른 집합이 됩니다.

280
00:16:50,779 --> 00:16:54,819
좀 더 일반적으로 전문용어에서는, 알고리즘이 *𝑶(𝑵²)이라고 말합니다.
(시간 복잡도의 개념; Big O Notation)

281
00:16:54,819 --> 00:16:59,860
연산 수가 확장되는 방식인,
크기 𝑵의 두 목록에 대한 의미는

282
00:16:59,860 --> 00:17:04,850
𝑵²에 비례합니다. 반면에, 예를 들어
결과값의 관점에서 두 개의 다항식을

283
00:17:04,850 --> 00:17:09,319
생각해보면, 몇 개의 입력에서
그들의 값을 샘플링하는 것입니다.

284
00:17:09,319 --> 00:17:13,990
그런 다음 이들을 곱하는 데는
표본 수만큼의 연산만 필요합니다.

285
00:17:13,990 --> 00:17:18,539
다시 말하지만 이것은 점별 연산이고
다항식을 사용하므로, 계수를 복구할 수 있는

286
00:17:18,539 --> 00:17:20,579
유한한 자그마한 표본만 필요합니다.

287
00:17:20,579 --> 00:17:25,770
예를 들어, 선형 다항식을 유일하게 지정하려면
두 개의 결과값이면 충분합니다.

288
00:17:25,770 --> 00:17:30,669
3개의 결과값은 2차 다항식을
유일하게 지정하는 데 충분하며,

289
00:17:30,669 --> 00:17:35,500
일반적으로 N개의 고유한 결과값을 알고 있는 경우
𝑵개의 다른 계수가 있는 다항식을

290
00:17:35,500 --> 00:17:37,559
유일하게 지정하기에 충분합니다.

291
00:17:37,559 --> 00:17:41,270
또는 원하는 경우, 방정식 시스템의
언어로 표현할 수 있습니다.

292
00:17:41,270 --> 00:17:44,990
내가 당신에게 다항식을 가지고 있지만 계수가
무엇인지 말하지 않는다고 상상해보세요.

293
00:17:44,990 --> 00:17:46,870
이 계수들은 당신에게 미스터리입니다.

294
00:17:46,870 --> 00:17:50,789
이 예에서는, 이것을 우리가 찾아내려는
곱으로 생각할 수 있습니다.

295
00:17:50,789 --> 00:17:54,809
그리고 나서 제가, 여러분이 0, 1, 2, 3…과
같은 다양한 다른 입력을 넣는다면,

296
00:17:54,809 --> 00:17:59,809
이 다항식의 결과값이 무엇인지 말하겠습니다.

297
00:17:59,809 --> 00:18:03,679
그리고 저는 당신이 가지고 있는 미지수만큼
많은 방정식을 충분히 줄 것입니다.

298
00:18:03,679 --> 00:18:07,840
이것은 방정식의 선형 시스템이기
때문에 좋습니다.

299
00:18:07,840 --> 00:18:11,070
그리고 원칙적으로는, 이것은 최소한
계수를 되찾을 정도로 충분해야 합니다.

300
00:18:11,070 --> 00:18:15,440
따라서 대략적인 알고리즘 개요는 두 개의
숫자 목록을 합성곱하고 싶을 때마다,

301
00:18:15,440 --> 00:18:19,549
두 개의 다항식의 계수인 것처럼
생각하는 것입니다.

302
00:18:19,549 --> 00:18:25,890
충분한 결과값에서 해당 다항식을 샘플링하고,
해당 샘플을 점별로 곱한 다음,

303
00:18:25,890 --> 00:18:31,659
시스템을 해결하여 합성곱을 찾기 위한
교활한 백도어 방법으로 계수를 되찾습니다.

304
00:18:31,659 --> 00:18:36,120
그리고 지금까지 말했듯이, 적어도 여러분 중 일부는,
“Grant, 이것은 바보 같은 계획이야!” 라고

305
00:18:36,120 --> 00:18:38,010
마땅히 불평할 수 있습니다.

306
00:18:38,010 --> 00:18:41,980
우선, 우리가 알고 있는 다항식 중 하나에 대해
이러한 모든 샘플을 계산하는 것은,

307
00:18:41,980 --> 00:18:45,620
이미 𝑵²의 연산을 취하기 때문입니다.

308
00:18:45,620 --> 00:18:50,090
말할 것도 없이, 이 시스템을 푸는 것은
확실히 처음에 합성곱을 하는 것만큼

309
00:18:50,090 --> 00:18:52,590
계산적으로 어려울 것입니다.

310
00:18:52,590 --> 00:18:57,250
그래서, 물론, 우리는 곱셈과 합성곱 사이에
이러한 연관성을 가지고 있지만,

311
00:18:57,250 --> 00:19:01,770
모든 복잡성은 한 관점에서
다른 관점으로 옮기는 데서 발생합니다.

312
00:19:01,770 --> 00:19:03,289
그러나 트릭이 있습니다.

313
00:19:03,289 --> 00:19:07,230
그리고 푸리에 변환과 FFT 알고리즘에 대해
알고 있는 분들은, 이것이 어디에 쓰이는 지

314
00:19:07,230 --> 00:19:08,330
아실 겁니다.

315
00:19:08,330 --> 00:19:11,710
이러한 주제에 익숙하지 않은 경우,
제가 말하려는 내용이 완전히 난데없이

316
00:19:11,710 --> 00:19:12,710
보일 수 있습니다.

317
00:19:12,710 --> 00:19:15,850
그냥 여러분이 수학에서 걸었던 특정한 경로들이,
이것을 더 예상되는 단계로 만들 수 있다는 것을

318
00:19:15,850 --> 00:19:17,540
알아두세요.

319
00:19:17,540 --> 00:19:20,580
기본적으로 아이디어는 우리가 여기에서
선택의 자유가 있다는 것입니다.

320
00:19:20,580 --> 00:19:25,680
0, 1, 2, 3…과 같은
임의의 입력 집합으로 계산하는 대신,

321
00:19:25,680 --> 00:19:30,630
매우 특별하게 선택된 복소수 집합에 대해
계산하도록 결정하는 것 입니다.

322
00:19:30,630 --> 00:19:34,060
구체적으로 단위 원 위에 일정한 간격으로
있는 것들, 즉 *1의 거듭제곱근으로
(Roots of Unity)

323
00:19:34,060 --> 00:19:35,520
알려진 것입니다.

324
00:19:35,520 --> 00:19:37,920
이것은 우리에게 더 친근한 시스템을 제공합니다.

325
00:19:37,920 --> 00:19:43,669
기본 아이디어는 제곱을 해도
이 순환 패턴에 있는 숫자를 찾는 것으로,

326
00:19:43,669 --> 00:19:47,950
우리가 생성한 시스템이,
계산할 때 다른 항에서 많은 중복성을

327
00:19:47,950 --> 00:19:50,100
갖게 된다는 것을 의미합니다.

328
00:19:50,100 --> 00:19:53,980
이러한 중복성을 활용하는 방법을
영리하게 생각하면, 많은 연산을

329
00:19:53,980 --> 00:19:56,270
절약할 수 있습니다.

330
00:19:56,270 --> 00:19:58,770
제가 작성한 이 결과값 집합에는
특별한 이름이 있습니다.

331
00:19:58,770 --> 00:20:02,909
바로 계수의 *이산 푸리에 변환이라고 합니다.
(DFT)

332
00:20:02,909 --> 00:20:07,049
더 많은 것을 알고 싶으시다면,
제가 이 동일한 내용을 실제로 Julia MIT 수업에서,

333
00:20:07,049 --> 00:20:09,559
이산 푸리에 변환에 대한 강의를 했습니다.

334
00:20:09,559 --> 00:20:13,150
또한 채널 Reducible에 빠른 푸리에 변환에
대해 설명하는 정말 훌륭한 영상이 있습니다.

335
00:20:13,150 --> 00:20:17,610
FFT는 이런 것들을
더 빨리 계산해주는 알고리즘입니다.

336
00:20:17,610 --> 00:20:22,440
또한 Veritasium도 최근에 FFT에 대한 정말 좋은 영상을
만들었으므로 여러분은 많은 선택들이 있습니다.

337
00:20:22,440 --> 00:20:25,059
그리고 이 빠른 알고리즘이
정말 우리에게 핵심입니다.

338
00:20:25,059 --> 00:20:29,380
다시 말하지만, 이 모든 중복성 때문에,
이 계수들에서 이러한 모든 결과값으로

339
00:20:29,380 --> 00:20:31,150
이동하는 방법이 있습니다.

340
00:20:31,150 --> 00:20:35,440
𝑵² 연산으로 실행하는 대신,
𝑵 log(𝑵)의 연산으로 실행하면

341
00:20:35,440 --> 00:20:39,920
큰 목록으로 확장할 때
훨씬 더 좋습니다.

342
00:20:39,920 --> 00:20:42,850
그리고 중요한 것은, 이 FFT 알고리즘이
양방향으로 작동한다는 것입니다.

343
00:20:42,850 --> 00:20:45,659
또한 결과값에서 계수로
이동할 수 있습니다.

344
00:20:45,659 --> 00:20:49,240
모든 것을 종합했지만,
알고리즘의 개요를 다시 살펴보겠습니다.

345
00:20:49,240 --> 00:20:53,210
이제, 우리는, 두 개의 긴 숫자 목록이 주어질 때
합성곱을 하고 싶을 때마다,

346
00:20:53,210 --> 00:20:58,470
먼저, 각각의 빠른 푸리에 변환을
계산한다고 말할 수 있습니다.

347
00:20:58,470 --> 00:21:01,690
여러분의 마음 한구석에서,
여러분은 이것들을 다항식의 계수처럼

348
00:21:01,690 --> 00:21:06,960
생각하고 매우 특별하게 선택된 점들의 집합에서
이것을 계산하는 것으로 생각할 수 있습니다.

349
00:21:06,960 --> 00:21:11,380
그런 다음, 방금 얻은 두 가지
결과를 함께 점곱하면, 좋고 

350
00:21:11,380 --> 00:21:12,380
빠릅니다.

351
00:21:12,380 --> 00:21:16,419
그런 다음 역의 빠른 푸리에 변환을
실행하면, 우리가 찾던 합성곱을

352
00:21:16,419 --> 00:21:19,320
계산하는 교활한 백도어 방법이 제공됩니다.

353
00:21:19,320 --> 00:21:23,470
그러나 이번에는, 𝑶(𝑵log𝑵) 연산만
하면 됩니다.

354
00:21:23,470 --> 00:21:25,210
정말 멋지네요.

355
00:21:25,210 --> 00:21:30,130
이 매우 특정한 맥락에서, 합성곱이
나타나는 것은 두 개의 다항식을 곱한 것으로,

356
00:21:30,130 --> 00:21:33,860
합성곱이 나타날 수 있는 다른 모든 곳에서
합성곱과 연관된 알고리즘의 문을

357
00:21:33,860 --> 00:21:34,860
열어줍니다.

358
00:21:34,860 --> 00:21:38,520
큰 이미지 처리에 확률 분포를 추가하려는 경우에도,

359
00:21:38,520 --> 00:21:39,520
그리고 무엇이든 가능합니다.

360
00:21:39,520 --> 00:21:42,710
그리고 저는 수학에 있는 몇몇 연산이나
개념들이 전혀 관련 없어 보이는 많은 영역에서

361
00:21:42,710 --> 00:21:48,950
나타나는 것을 확인 했을 때 왜 여러분이 흥분해야
하는지에 대한 좋은 예라고 생각합니다.

362
00:21:48,950 --> 00:21:51,850
여러분이 약간의 과제를 원하신다면,
여기 생각해 볼 만한 재미있는 것이 있습니다.

363
00:21:51,850 --> 00:21:56,610
두 개의 서로 다른 숫자를 곱할 때,
우리 모두가 초등학교에서 배우는

364
00:21:56,610 --> 00:22:01,159
일반적인 곱셈이, 기본적으로
그 숫자들의 합성곱인 이유를

365
00:22:01,159 --> 00:22:02,669
설명해보세요.

366
00:22:02,669 --> 00:22:07,460
몇몇 추가가된 단계가 있지만
핵심 단계는 합성곱입니다.

367
00:22:07,460 --> 00:22:12,419
빠른 알고리즘의 존재에 비추어 볼 때,
이것이 의미하는 바는 두 개의 매우 큰

368
00:22:12,419 --> 00:22:17,010
정수가 있는 경우, 우리가 초등학교에서 배우는
방법보다 더 빠른 곱을 찾을 수 있는 방법이

369
00:22:17,010 --> 00:22:18,210
있다는 것입니다.

370
00:22:18,210 --> 00:22:23,520
𝑶(𝑵²) 연산을 요구하는 대신
𝑶(𝑵 log 𝑵)만 요구합니다. 이건

371
00:22:23,520 --> 00:22:25,490
가능할 것 같다고 느껴지지 않습니다.

372
00:22:25,490 --> 00:22:29,350
문제는 이것이 현실적으로 유용하기 전에,
여러분의 숫자는 정말로

373
00:22:29,350 --> 00:22:31,650
엄청나야 한다는 것입니다.

374
00:22:31,650 --> 00:22:35,310
그러나 여전히 이러한 알고리즘이
존재한다는 것은 멋진 일입니다.

375
00:22:35,310 --> 00:22:39,039
그리고 다음으로, 확률 분포에
특별히 초점을 맞춘 연속적인 사건에

376
00:22:39,039 --> 00:22:40,610
우리의 관심을 돌릴 것입니다.

