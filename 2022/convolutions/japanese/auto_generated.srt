1
00:00:00,000 --> 00:00:02,362
2 つの異なる数値リスト、あるいはおそらく 2 

2
00:00:02,362 --> 00:00:04,429
つの異なる関数を与え、これら 2 つのリ 

3
00:00:04,429 --> 00:00:07,087
ストを組み合わせて新しい数値リストを得る方法、または 

4
00:00:07,087 --> 00:00:08,859
2 つの関数を組み合わせて新しい関 

5
00:00:08,859 --> 00:00:11,320
数を得る方法をすべて考えてもらいたいとします。 。

6
00:00:12,120 --> 00:00:14,386
おそらく思い浮かぶ簡単な方法の 1 つは 

7
00:00:14,386 --> 00:00:16,760
、それらを用語ごとに単純に加算することです。

8
00:00:17,160 --> 00:00:19,920
関数と同様に、対応するすべての出力 を追加できます。

9
00:00:20,540 --> 00:00:23,834
同様に、2 つのリストを項ごとに乗算し、関数で同 

10
00:00:23,834 --> 00:00:25,680
じことを行うこともできます。

11
00:00:26,360 --> 00:00:28,956
しかし、これらの両方と同じくらい基本的であるも 

12
00:00:28,956 --> 00:00:31,336
のの、あまり議論されていない、畳み込みとして

13
00:00:31,336 --> 00:00:33,500
知られる別の種類の組み合わせがあります。

14
00:00:34,080 --> 00:00:36,895
ただし、前の 2 つのケースとは異なり、数値に対して

15
00:00:36,895 --> 00:00:39,820
実行できる操作から単に継承さ れるものではありません。

16
00:00:39,980 --> 00:00:42,287
これは、数値のリストや関数の組み合わせのコン

17
00:00:42,287 --> 00:00:44,700
テキストにおいては、ま ったく新しいものです。

18
00:00:45,320 --> 00:00:49,018
それらはあらゆる場所に現れ、画像処理で遍在し、確率論の中 

19
00:00:49,018 --> 00:00:52,716
核となる構成要素であり、微分方程式を解く際によく使用され、

20
00:00:52,716 --> 00:00:56,286
そうでないとし てもほぼ確実に目にしたことがある文脈の 

21
00:00:56,286 --> 00:00:58,582
1 つです。 この名前では、2 つ 

22
00:00:58,582 --> 00:01:00,240
の多項式を掛け合わせます。

23
00:01:00,740 --> 00:01:03,588
視覚的な説明を仕事にしている者として、これは特に素晴らしい

24
00:01:03,588 --> 00:01:06,436
トピ ックです。 なぜなら、文脈なしに孤立した定型的な定義

25
00:01:06,436 --> 00:01:08,793
は、ある意味威圧的に見えるかもしれないからです。

26
00:01:08,793 --> 00:01:11,641
 しかし、時間をかけてそれが何を言っているのかを実際に解き

27
00:01:11,641 --> 00:01:13,605
明かし、その前に実際にその理由を動機づ 

28
00:01:13,605 --> 00:01:16,453
けることができれば、あなたはこのようなものを望むでしょう、

29
00:01:16,453 --> 00:01:18,320
それは信じられないほど美しい操作です。

30
00:01:18,960 --> 00:01:21,206
そして、正直に言うと、このプロジェクトのビジュアルを

31
00:01:21,206 --> 00:01:23,540
まとめているときに、実際に少し学んだこと があります。

32
00:01:23,540 --> 00:01:26,036
2 つの異なる関数を畳み込む場合、私はそれが何を意味

33
00:01:26,036 --> 00:01:28,533
するのかを皆さんが想像でき るさまざまな方法を考えよ

34
00:01:28,533 --> 00:01:30,357
うとしていたのですが、そのうちの 1 

35
00:01:30,357 --> 00:01:32,854
つについて、なぜ正規分布が 次のような役割を果たすの

36
00:01:32,854 --> 00:01:34,775
かについて少し納得した瞬間がありました。

37
00:01:34,775 --> 00:01:37,271
 確率的にそうなるのですが 、なぜそれが関数にとって

38
00:01:37,271 --> 00:01:38,520
自然な形状なのでしょうか。

39
00:01:39,020 --> 00:01:40,072
しかし、私は先を行っています。 

40
00:01:40,072 --> 00:01:41,520
そのためのセッ トアップはたくさんあります。

41
00:01:41,840 --> 00:01:45,307
このビデオでは、離散的なケース、特にこれらを計算するた 

42
00:01:45,307 --> 00:01:48,031
めの非常に予想外だが非常に賢いアルゴリズムを

43
00:01:48,031 --> 00:01:50,260
構築することに主に焦点を当てま す。

44
00:01:50,260 --> 00:01:54,480
そして、継続的なケースの議論を第 2 部に引き出します。

45
00:01:58,580 --> 00:02:01,788
画像処理の例は視覚的に最も興味深いものであるため、画像処

46
00:02:01,788 --> 00:02:04,997
理の例から始めたくな るのは非常に魅力的ですが、画像処理

47
00:02:04,997 --> 00:02:07,404
の例が全体的に畳み込みをあまり表現してい 

48
00:02:07,404 --> 00:02:10,613
ないようにするいくつかの注意点があるため、代わりに確率論

49
00:02:10,613 --> 00:02:13,821
的に物事を始めまし ょう。 特に、ここにいる誰もが人生の

50
00:02:13,821 --> 00:02:16,916
ある時点で考えたことがあると確信する最も 単純な例の 

51
00:02:16,916 --> 00:02:20,124
1 つは、サイコロを振って、さまざまな異なる金額が出る確

52
00:02:20,124 --> 00:02:21,500
率を計 算することです。

53
00:02:22,460 --> 00:02:23,460
そして、あなたは、問題ではない、問

54
00:02:23,460 --> 00:02:24,460
題ではない、と言うかもしれません。

55
00:02:24,680 --> 00:02:26,633
2 つのサイコロにはそれ ぞれ 6 

56
00:02:26,633 --> 00:02:28,696
つの異なる出目があるため、合計 36 

57
00:02:28,696 --> 00:02:30,649
通りの異なる出目のペアが得られます。

58
00:02:30,649 --> 00:02:33,363
 それ らをすべて確認するだけで、指定された合計を

59
00:02:33,363 --> 00:02:35,860
持つペアがいくつあるかを数えることができます。

60
00:02:36,600 --> 00:02:39,475
このようにすべてのペアをグリッドに配置すると、合計が一

61
00:02:39,475 --> 00:02:42,244
定であるすべてのペアがこれらの異なる対角 線の 1 

62
00:02:42,244 --> 00:02:45,440
つに沿って表示されるという非常に優れた点が 1 つあります。

63
00:02:45,440 --> 00:02:48,780
したがって、これらの対角 線のそれぞれにいくつ存在するかを単

64
00:02:48,780 --> 00:02:52,120
純に数えるだけで、特定の合計が表示される可能性がわかります。

65
00:02:53,220 --> 00:02:55,940
非常に良い、非常に良いと思いますが、同じ質

66
00:02:55,940 --> 00:02:58,660
問を視覚化する他の方法は考え られますか?

67
00:02:59,300 --> 00:03:01,621
特定の合計を持つすべての個別のペアについ

68
00:03:01,621 --> 00:03:04,060
て考える他のイメージが思い浮かび ますか?

69
00:03:04,860 --> 00:03:06,030
そしておそらく、皆さんのうちの 1 

70
00:03:06,030 --> 00:03:07,980
人が手を挙げて、「はい、持っています」と言うかもしれません。

71
00:03:08,280 --> 00:03:10,454
これら 2 つの異なる可 能性のセットをそれぞれ 

72
00:03:10,454 --> 00:03:11,933
1 行に並べて描いたとしましょう。

73
00:03:11,933 --> 00:03:13,760
 ただし、2 番目の行を反転するとします。

74
00:03:13,760 --> 00:03:16,260
そうすれ ば、合計 7 になるさまざま

75
00:03:16,260 --> 00:03:18,760
なペアがすべてこのように縦に並びます。

76
00:03:19,360 --> 00:03:22,820
そして、その一番 下の行を右端までスライドすると、合計で 

77
00:03:22,820 --> 00:03:26,280
2 になるユニークなペア、つまり蛇 の目だけが一致します。

78
00:03:26,620 --> 00:03:29,303
そして、それを 1 単位上に右にずらしてみると、整列するペ

79
00:03:29,303 --> 00:03:32,080
アは 2 つの異なるペアであり、合計すると 3 になります。

80
00:03:32,880 --> 00:03:35,331
そして一般に、この下の配列のさまざまなオフセッ 

81
00:03:35,331 --> 00:03:38,191
ト値により、最初に反転する必要があったことを覚えています

82
00:03:38,191 --> 00:03:40,642
が、指定された合計を持つすべての個別のペアが明 

83
00:03:40,642 --> 00:03:41,460
らかになります。

84
00:03:44,820 --> 00:03:47,426
確率に関する質問に関する限り、これはまだ特に興味深いものでは

85
00:03:47,426 --> 00:03:50,033
ありません。 なぜなら 、私たちがやっているのはこれらの各カ

86
00:03:50,033 --> 00:03:52,640
テゴリーにどれだけの結果があるかを数えているだけだからです。

87
00:03:52,980 --> 00:03:55,550
しかし、それは、これらの顔のそれぞれが出現す

88
00:03:55,550 --> 00:03:58,120
る機会が等しいという暗黙の前提があ ります。

89
00:03:58,360 --> 00:03:59,950
しかし、統一されていない特別なサイコロの

90
00:03:59,950 --> 00:04:01,620
セットがあると言ったらどうなるでしょうか?

91
00:04:02,060 --> 00:04:04,590
おそら く、青いサイコロには、出現する各面の確

92
00:04:04,590 --> 00:04:07,230
率を表す独自の数字のセットがあり、赤いサイコロ 

93
00:04:07,230 --> 00:04:09,760
には、独自の異なる数字のセットがあるでしょう。

94
00:04:10,299 --> 00:04:12,439
その場合、たとえば 2 の目が出 

95
00:04:12,439 --> 00:04:15,333
る確率を計算したい場合は、青いサイコロが 1 

96
00:04:15,333 --> 00:04:18,479
になる確率と、赤いサイコ ロが 1 になる確率を 

97
00:04:18,479 --> 00:04:19,360
1 倍します。

98
00:04:19,360 --> 00:04:21,836
そして、3 が表示される確率につい 

99
00:04:21,836 --> 00:04:25,276
ては、それが可能な場合は 2 つの異なるペアを調べ

100
00:04:25,276 --> 00:04:28,304
、対応する確率を再度乗 算して、それら 2 

101
00:04:28,304 --> 00:04:29,680
つの積を加算します。

102
00:04:30,100 --> 00:04:32,377
同様に、4 が表示される確率には 、3 

103
00:04:32,377 --> 00:04:35,681
つの異なる可能性のペアを掛け合わせ、それらをすべて加算する

104
00:04:35,681 --> 00:04:36,820
ことが含まれ ます。

105
00:04:36,820 --> 00:04:39,866
そして、いくつかの式を設定するという精神で、これらの上

106
00:04:39,866 --> 00:04:42,123
位の確率に a1、a2、a3 などの名 

107
00:04:42,123 --> 00:04:44,493
前を付け、下位の確率に b1、b2、b3 

108
00:04:44,493 --> 00:04:45,960
などの名前を付けましょう。

109
00:04:46,400 --> 00:04:48,545
そして一般に、このプロセ スでは、2 

110
00:04:48,545 --> 00:04:50,351
つの異なる数値配列を取得し、2 

111
00:04:50,351 --> 00:04:52,158
番目の配列を反転して、それらを 

112
00:04:52,158 --> 00:04:54,981
さまざまなオフセット値で並べ、多数のペアごとの積を

113
00:04:54,981 --> 00:04:58,255
取得してそれらを加算し ます。 これは、次の 1 つです。

114
00:04:58,255 --> 00:05:00,740
 畳み込みとは何かについての基本的な考え方。

115
00:05:00,740 --> 00:05:04,800
もう少し正確に説明すると、このプロセスを通じて、2 

116
00:05:04,800 --> 00:05:07,923
つ、3 つ、4 つ、そして最 大 12 

117
00:05:07,923 --> 00:05:11,983
まで表示される確率を生成し、1 つの値のリスト a 

118
00:05:11,983 --> 00:05:15,574
と別の値を混ぜ合わ せてそれらを取得しました。

119
00:05:15,574 --> 00:05:16,980
 値のリスト、b.

120
00:05:17,440 --> 00:05:20,130
専門用語では、これら 2 つのシーケンスの畳み込 

121
00:05:20,130 --> 00:05:22,605
みにより、この新しいシーケンス、つまり 11 

122
00:05:22,605 --> 00:05:25,618
個の値の新しいシーケンスが得られ、それぞれがペアごとの 

123
00:05:25,618 --> 00:05:27,340
積の和のように見えると言えます。

124
00:05:27,340 --> 00:05:31,145
必要に応じて、同じ演算を考える別の方法として、最初にすべて 

125
00:05:31,145 --> 00:05:34,316
のペアごとの積の表を作成し、次にこれらすべての対角

126
00:05:34,316 --> 00:05:36,980
線に沿って合計するという方法もあり ます。

127
00:05:37,460 --> 00:05:39,023
繰り返しますが、これは、これら 2 

128
00:05:39,023 --> 00:05:40,761
つの数値シーケンスを混ぜ合わせて、11 

129
00:05:40,761 --> 00:05:42,760
個の新しい数値シーケン スを取得する方法です。

130
00:05:43,240 --> 00:05:44,801
これは、スライド窓が考えた操作と

131
00:05:44,801 --> 00:05:46,460
同じですが、別の視点にすぎません。

132
00:05:47,140 --> 00:05:49,800
それにちょっとした注釈を付けて、次のように書きます。

133
00:05:50,220 --> 00:05:52,938
この小さなアスタリスクで示 されている a と b 

134
00:05:52,938 --> 00:05:55,553
の畳み込みは新しいリストであり、そのリストの n 

135
00:05:55,553 --> 00:05:57,330
番目の要素は合計のように見えます。

136
00:05:57,330 --> 00:06:00,154
 その 合計は、すべての異なるインデックスのペア i 

137
00:06:00,154 --> 00:06:03,082
と j にまたがります。 つまり、次の合計はそれらのイン

138
00:06:03,082 --> 00:06:04,860
デックスは n に等しくなります。

139
00:06:05,280 --> 00:06:07,881
ちょっと長めの話ですが、たとえば、n が 6 

140
00:06:07,881 --> 00:06:10,483
の場合、ここで検討するペアは、1 と 5、2 

141
00:06:10,483 --> 00:06:12,972
と 4、3 と 3、4 と 2、5 と 1 

142
00:06:12,972 --> 00:06:15,800
であり、すべての異なるペアを合計します。 6まで。

143
00:06:16,620 --> 00:06:18,498
しかし正直なところ、どのように書き留めても、

144
00:06:18,498 --> 00:06:20,717
プロセス中に頭の中に保持するビジュアルに比べれば、 

145
00:06:20,717 --> 00:06:22,340
表記法は二の次の重要性を持っています。

146
00:06:23,280 --> 00:06:26,106
ここで、非常に単純な例を行うと役立つかもしれません。

147
00:06:26,106 --> 00:06:28,606
 リス ト 1、2、3 とリスト 4、5、6 

148
00:06:28,606 --> 00:06:30,780
の畳み込みは何かと尋ねるかもしれません。

149
00:06:31,480 --> 00:06:33,380
これらのリストを 両方とも取得し、2 

150
00:06:33,380 --> 00:06:36,380
番目のリストを裏返し、次にその蓋から左端まで進めていく様子 

151
00:06:36,380 --> 00:06:37,680
を想像するかもしれません。

152
00:06:38,180 --> 00:06:41,195
次に、整列する値のペアは 1 と 4 であり、それら 

153
00:06:41,195 --> 00:06:43,540
を乗算すると、出力の最初の項が得られます。

154
00:06:43,960 --> 00:06:46,585
一番下の配列を 1 単位右にスライドさせま す。

155
00:06:46,585 --> 00:06:49,647
 整列するペアは 1 と 5、および 2 と 4 です。

156
00:06:49,647 --> 00:06:52,163
 これらのペアを掛け合わせて加算すると、出力 

157
00:06:52,163 --> 00:06:54,460
の次のエントリである 13 が得られます。

158
00:06:54,960 --> 00:06:58,260
もう一度スライドしてみると、1 × 6、プラス 2 × 

159
00:06:58,260 --> 00:07:01,560
5、プラス 3 × 4 で、たまたま 28 になります。

160
00:07:02,020 --> 00:07:04,521
もう 1 枚スライドすると、2 × 6、 

161
00:07:04,521 --> 00:07:06,546
プラス 3 × 5、つまり 27 

162
00:07:06,546 --> 00:07:10,120
が得られ、最終的に最後の項は 3 × 6 のようになります。

163
00:07:10,660 --> 00:07:13,361
必要に応じて、お気に入りのプログラミング言語や、さ

164
00:07:13,361 --> 00:07:16,062
まざまな数値演算を含むお気 に入りのライブラリを呼

165
00:07:16,062 --> 00:07:18,980
び出して、私が嘘をついていないことを確認してください。

166
00:07:18,980 --> 00:07:21,662
1、2、3 と 4、5、6 の畳み込みを

167
00:07:21,662 --> 00:07:24,480
行うと、実際にこのような結果が得られます。

168
00:07:25,920 --> 00:07:28,500
これが自然で望ましい操作である確率分布への

169
00:07:28,500 --> 00:07:31,080
加算であるケースを 1 つ見てき ました。

170
00:07:31,080 --> 00:07:33,660
 もう 1 つの一般的な例は移動平均です。

171
00:07:34,080 --> 00:07:36,530
数値の長いリストがあり、すべて 足すと 1 

172
00:07:36,530 --> 00:07:39,760
になる小さな数値の別のリストを取得すると想像してください。

173
00:07:40,100 --> 00:07:42,800
この場合、5 つの値の 小さなリストがあり、それらはすべて 

174
00:07:42,800 --> 00:07:44,060
5 分の 1 に等しいです。

175
00:07:44,060 --> 00:07:45,875
次に、このスライディング ウィ 

176
00:07:45,875 --> 00:07:48,713
ンドウの畳み込みプロセスを実行し、目を閉じてその最

177
00:07:48,713 --> 00:07:50,869
初で何が起こっているかを徹底的に調べ 

178
00:07:50,869 --> 00:07:53,706
、小さい値のリストが大きい値のリストと完全に重なっ

179
00:07:53,706 --> 00:07:56,543
たら、この中の各項が何であるかを考 えてください。

180
00:07:56,543 --> 00:07:58,700
 畳み込みというのは本当に意味します。

181
00:07:59,400 --> 00:08:01,999
各反復では、データの各値を 1/5 

182
00:08:01,999 --> 00:08:05,465
で乗算し、それらをすべて加算することになります。

183
00:08:05,465 --> 00:08:09,075
 つまり、この小 さなウィンドウ内のデータの平均を

184
00:08:09,075 --> 00:08:10,520
取ることになります。

185
00:08:11,100 --> 00:08:13,931
全体として、このプロセ スにより、元のデータの平滑化された

186
00:08:13,931 --> 00:08:16,763
バージョンが得られます。 これを、別の小さな数値リストか 

187
00:08:16,763 --> 00:08:18,325
ら始めて変更することができます。

188
00:08:18,325 --> 00:08:21,255
 その小さなリストの合計が 1 になる限り、それを移動デー 

189
00:08:21,255 --> 00:08:22,720
タとして解釈できます。 平均。

190
00:08:23,400 --> 00:08:26,185
ここに示す例では、移動平均により中心値により 

191
00:08:26,185 --> 00:08:27,760
大きな重みが与えられます。

192
00:08:28,420 --> 00:08:30,800
これにより、データが平滑化されたバージョンになります。

193
00:08:33,140 --> 00:08:35,873
これを 2 次元で類似したものにすると、特定の画

194
00:08:35,873 --> 00:08:38,720
像をぼかすための楽しいアルゴリズムが 得られます。

195
00:08:38,720 --> 00:08:41,131
そして、これから紹介するアニメーションは、画像処

196
00:08:41,131 --> 00:08:43,945
理ユニットを含む特定の OpenCo urseWare 

197
00:08:43,945 --> 00:08:46,357
クラスのために MIT の Julia Lab 

198
00:08:46,357 --> 00:08:47,964
と行った一連の講義の一部として 

199
00:08:47,964 --> 00:08:50,376
元々作成したものを変更したものであると言わなけれ

200
00:08:50,376 --> 00:08:51,080
ばなりません。

201
00:08:51,560 --> 00:08:52,867
そこで、このすべての背後にあるコー 

202
00:08:52,867 --> 00:08:54,391
ドを詳しく調べるためにもう少し作業を行った

203
00:08:54,391 --> 00:08:56,280
ので、興味があればいくつかのリンクを残しておきます。

204
00:08:56,620 --> 00:08:59,361
しか し、このぼやけた例に焦点を戻すと、何が起こっ

205
00:08:59,361 --> 00:09:01,884
ているのかというと、元の画像に沿って進んでい 

206
00:09:01,884 --> 00:09:04,626
る値の小さな 3x3 グリッドがあり、ズームインす

207
00:09:04,626 --> 00:09:06,710
ると、これらの値のそれぞれが 1 9 

208
00:09:06,710 --> 00:09:09,123
であり、私が何をしているのかということです。

209
00:09:09,123 --> 00:09:11,536
 各反復で、それらの値のそれぞれに、その上 

210
00:09:11,536 --> 00:09:13,620
にある対応するピクセルが乗算されます。

211
00:09:13,900 --> 00:09:16,275
そしてもちろん、コンピューター サイエンスで 

212
00:09:16,275 --> 00:09:18,237
は、色を、赤、緑、青の成分を表す 3 

213
00:09:18,237 --> 00:09:20,200
つの値の小さなベクトルとして考えます。

214
00:09:20,560 --> 00:09:22,849
これらすべての小さな値に 1 9 

215
00:09:22,849 --> 00:09:25,677
を乗算して加算すると、各カラー チャネル 

216
00:09:25,677 --> 00:09:29,179
に沿った平均が得られ、右側の画像の対応するピクセルは

217
00:09:29,179 --> 00:09:31,200
その合計として定義され ます。

218
00:09:31,940 --> 00:09:34,844
画像上のすべてのピクセルに対してこれを行うと、全体的な効

219
00:09:34,844 --> 00:09:37,748
果として、それぞれの種類が 隣接するすべてのピクセルにに

220
00:09:37,748 --> 00:09:40,860
じみ出て、元のピクセルよりもぼやけたバージョンが得られます。

221
00:09:41,720 --> 00:09:44,730
専門用語では、右側の画像は、元の画像と値の小さ

222
00:09:44,730 --> 00:09:47,740
なグリッドを畳み込んだもので あると言えます。

223
00:09:48,140 --> 00:09:50,901
あるいは、より専門的に言えば、これは、値の小さなグリッドを 

224
00:09:50,901 --> 00:09:52,927
180 度回転させ たバージョンとの畳み込み

225
00:09:52,927 --> 00:09:54,400
であると言うべきかもしれません。

226
00:09:54,620 --> 00:09:56,570
グリッドが対称であるかどうかは重要 

227
00:09:56,570 --> 00:09:59,171
ではありませんが、純粋な数学のコンテキストから継

228
00:09:59,171 --> 00:10:01,230
承された畳み込みの定義では、常に 2 

229
00:10:01,230 --> 00:10:03,831
番目の配列を反転することを考慮する必要があること

230
00:10:03,831 --> 00:10:05,240
に留意する価値があります。

231
00:10:05,960 --> 00:10:08,481
これを少し変更すると、別の値のグリッドを選択すること

232
00:10:08,481 --> 00:10:11,100
で、よりエレガントなぼかし効果を得ること ができます。

233
00:10:11,440 --> 00:10:13,610
この場合、小さな 5x5 グリッドがあり

234
00:10:13,610 --> 00:10:15,780
ますが、違いはそのサイズではありません。

235
00:10:15,980 --> 00:10:19,260
ズームインすると、中央の値が端に向かう値よりもはるかに大

236
00:10:19,260 --> 00:10:22,541
きいことがわかります。 これは、ガウス分布として知られる

237
00:10:22,541 --> 00:10:25,940
釣鐘曲線からすべてサンプリングされていることが 原因です。

238
00:10:26,800 --> 00:10:29,955
そうすることで、これらすべての値に、その上にある対応する

239
00:10:29,955 --> 00:10:33,111
ピクセルを乗算 するときに、その中央のピクセルに多くの重

240
00:10:33,111 --> 00:10:36,380
みを与え、端のピクセルには重みをあまり 与えなくなります。

241
00:10:36,800 --> 00:10:38,680
そして、前と同様に、右側の対応するピクセ

242
00:10:38,680 --> 00:10:40,560
ルがこの合計になるように定義され ます。

243
00:10:41,320 --> 00:10:44,041
このプロセスをすべてのピクセルに対して実行する

244
00:10:44,041 --> 00:10:46,762
ことで、レンズの焦点を 外したときなどの概念を

245
00:10:46,762 --> 00:10:49,720
より忠実にシミュレートするぼかし効果が得られます。

246
00:10:49,900 --> 00:10:53,360
しかし、このアイデアでできることはぼかしだけではありません。

247
00:10:53,800 --> 00:10:56,643
たとえば、この小さな値 のグリッドを見てください。

248
00:10:56,643 --> 00:10:59,714
 左側にはいくつかの正の数値が、右側にはいくつかの負 

249
00:10:59,714 --> 00:11:02,900
の数値が含まれています。 それぞれ青と赤で色付けします。

250
00:11:03,640 --> 00:11:05,136
これが最終的な画像にどのような影 

251
00:11:05,136 --> 00:11:07,512
響を与えるかを予測して理解できるかどうか、少し時間を取

252
00:11:07,512 --> 00:11:08,480
って確認してください。

253
00:11:10,720 --> 00:11:13,186
したがって、この場合、画 像は色付きではなくグレ

254
00:11:13,186 --> 00:11:15,653
ースケールであると考えているため、各ピクセルは 

255
00:11:15,653 --> 00:11:18,120
3 つの数値ではなく 1 つの数値で表されます。

256
00:11:18,440 --> 00:11:20,702
そして、注目すべき点の 1 つは、この畳み込みを

257
00:11:20,702 --> 00:11:23,060
行うときに負の値 が得られる可能性があることです。

258
00:11:23,060 --> 00:11:26,192
たとえば、この時点でズームインすると、小さなグ 

259
00:11:26,192 --> 00:11:29,194
リッドの左半分は完全に黒いピクセルの上にあり、

260
00:11:29,194 --> 00:11:32,196
その値はゼロになりますが 、負の値の右半分はす

261
00:11:32,196 --> 00:11:35,460
べて白いピクセルの上にあります。 値は 1 です。

262
00:11:36,180 --> 00:11:39,485
したがって、対応する項を乗算して加算すると、結果は

263
00:11:39,485 --> 00:11:42,790
非常に負の値になり ます。 これを右の画像で表示す

264
00:11:42,790 --> 00:11:46,360
る方法は、負の値を赤、正の値を青に色付 けることです。

265
00:11:46,880 --> 00:11:49,212
もう 1 つ注意すべき点は、すべて同じ色のパッ

266
00:11:49,212 --> 00:11:51,544
チを使用している場合、 小さなグリッド内の値の

267
00:11:51,544 --> 00:11:54,080
合計がゼロになるため、すべてがゼロになることです。

268
00:11:55,180 --> 00:11:57,482
これは、小さ なグリッドの合計が 1 だった前の 

269
00:11:57,482 --> 00:11:58,956
2 つの例とは大きく異なります。

270
00:11:58,956 --> 00:12:01,258
 この例では、それを移 動平均として解釈し、したが

271
00:12:01,258 --> 00:12:02,180
ってぼやけています。

272
00:12:03,640 --> 00:12:05,672
全体として、この小さなプロセスは 

273
00:12:05,672 --> 00:12:09,019
基本的に、左から右に移動するときにピクセル値に変化がある

274
00:12:09,019 --> 00:12:12,366
場所を検出す るため、画像からすべての垂直エッジを検出す

275
00:12:12,366 --> 00:12:13,920
る一種の方法を提供します。

276
00:12:16,500 --> 00:12:19,604
同様に、上から下に移動するにつれてグリッドが

277
00:12:19,604 --> 00:12:22,708
変化するようにグリッド を回転すると、すべて

278
00:12:22,708 --> 00:12:26,094
の水平エッジが検出され、小さなパイの生き物の画 

279
00:12:26,094 --> 00:12:29,340
像の場合、かなり悪魔のような目が表示されます。

280
00:12:30,400 --> 00:12:32,933
ちなみに、この小さなグリ ッドはカーネルと呼ばれる

281
00:12:32,933 --> 00:12:35,467
ことが多く、ここでの利点は、別のカーネルを選択する

282
00:12:35,467 --> 00:12:38,001
だけで、エ ッジ検出をぼかすだけでなくシャープ化な

283
00:12:38,001 --> 00:12:40,840
どのさまざまな画像処理効果を得ることができるこ とです。

284
00:12:40,840 --> 00:12:43,449
畳み込みニューラル ネットワークについて聞いたことが

285
00:12:43,449 --> 00:12:45,156
ある方は、ニューラル ネットワー 

286
00:12:45,156 --> 00:12:47,766
クが検出したいものによって決定される、そもそもカーネ

287
00:12:47,766 --> 00:12:49,873
ルがどうあるべきかをデータを使用して判断 

288
00:12:49,873 --> 00:12:51,480
するという概念があると思います。

289
00:12:52,760 --> 00:12:55,520
もう 1 つ取り上げるべき点は、出力の長さで す。

290
00:12:55,820 --> 00:12:58,656
移動平均の例のような場合は、両方のウィンドウが互い

291
00:12:58,656 --> 00:13:01,493
に完全に一致するとき の項のみを考慮する必要がある

292
00:13:01,493 --> 00:13:04,329
かもしれません。 または、画像処理の例では、最終 

293
00:13:04,329 --> 00:13:07,280
出力を元のサイズと同じサイズにしたいかもしれません。

294
00:13:07,280 --> 00:13:10,427
純粋な数学演算としての畳 み込みは、少なくともそのうちの 

295
00:13:10,427 --> 00:13:13,140
1 つの長さが 1 ではないと仮定すると、最初に 

296
00:13:13,140 --> 00:13:16,180
開始した 2 つの配列よりも大きな配列を常に生成します。

297
00:13:16,720 --> 00:13:17,939
特定のコンピューター サイエン 

298
00:13:17,939 --> 00:13:19,539
スのコンテキストでは、その出力を意図的に切

299
00:13:19,539 --> 00:13:21,520
り捨てたいことがよくあることを知っておいてください。

300
00:13:24,720 --> 00:13:27,517
もう 1 つ強調すべき価値があるのは、コンピューター 

301
00:13:27,517 --> 00:13:29,590
サイエンスの文脈では、元のカーネルを実 

302
00:13:29,590 --> 00:13:32,491
行する前にそのカーネルを反転するというこの概念は、非常に

303
00:13:32,491 --> 00:13:34,357
奇妙で必要のないものに感じることが 

304
00:13:34,357 --> 00:13:37,258
よくありますが、それが純粋な数学の文脈から受け継がれてい

305
00:13:37,258 --> 00:13:39,642
るものであることにもう一度注意して ください。

306
00:13:39,642 --> 00:13:42,440
 確率的に見て、それは信じられないほど自然なことです。

307
00:13:43,020 --> 00:13:45,710
そして実際に、もう 1 つ純 粋な数学の例をお見せします。

308
00:13:45,710 --> 00:13:47,937
 これは、これらすべてを計算するためのより高速な

309
00:13:47,937 --> 00:13:50,164
アルゴリズムへの扉 を開くものであるため、プログ

310
00:13:50,164 --> 00:13:52,020
ラマーでもこれに注意する必要があります。

311
00:13:52,620 --> 00:13:55,704
ここで言う「高速化」をセ ットアップするために、戻って 

312
00:13:55,704 --> 00:13:57,466
Python を再度起動し、2 

313
00:13:57,466 --> 00:13:59,780
つの異なる比較的大きな 配列を作成します。

314
00:13:59,940 --> 00:14:02,473
それぞれには 10 万個のランダムな要素が含

315
00:14:02,473 --> 00:14:04,891
まれており、nump y ライブラリから 

316
00:14:04,891 --> 00:14:07,540
convolve 関数の実行時間を評価します。

317
00:14:08,180 --> 00:14:10,920
この場合、複数の 異なる反復で実行し、平均値を

318
00:14:10,920 --> 00:14:13,898
見つけようとします。 このコンピュータでは、少な 

319
00:14:13,898 --> 00:14:16,520
くとも平均値は 4 であるようです。87秒。

320
00:14:16,960 --> 00:14:19,864
対照的に、fftconvolve と いう 

321
00:14:19,864 --> 00:14:23,164
scipy ライブラリの別の関数を使用すると、同じ

322
00:14:23,164 --> 00:14:27,124
ものを別の方法で実装しただけで、 必要な値は 4 だけです。

323
00:14:27,124 --> 00:14:30,160
平均 3 ミリ秒なので、3 桁も改善されます。

324
00:14:30,160 --> 00:14:33,266
また、別の名前で実行されているにもかかわらず、他の 

325
00:14:33,266 --> 00:14:36,252
convolve 関数 が行うのと同じ出力を提供し

326
00:14:36,252 --> 00:14:39,120
ており、より賢い方法で何かを行っているだけです。

327
00:14:42,200 --> 00:14:44,764
確率の例で、畳み込みについて考える別の方法とし

328
00:14:44,764 --> 00:14:46,994
て、すべてのペアごとの積のテーブルを作 

329
00:14:46,994 --> 00:14:49,558
成し、それらのペアごとの積を対角線に沿って合計

330
00:14:49,558 --> 00:14:52,680
するという方法があると述べたことを思い 出してください。

331
00:14:53,660 --> 00:14:55,666
もちろん、このように考えることができる 2 

332
00:14:55,666 --> 00:14:58,310
つの異なる数値リストを 畳み込むときは、確率に特有のものは

333
00:14:58,310 --> 00:14:59,040
何もありません。

334
00:14:59,040 --> 00:15:02,750
すべてのペアごとの積を使用し てこの種の乗算表を作成すると

335
00:15:02,750 --> 00:15:06,460
、対角線に沿った各合計が最終出力の 1 つに対 応します。

336
00:15:07,600 --> 00:15:10,000
この見方が特に自然である状況の 1 

337
00:15:10,000 --> 00:15:12,800
つは、2 つの多項式を乗算す る場合です。

338
00:15:13,300 --> 00:15:16,811
たとえば、すでにある小さなグリッドを使用して、最上位の項を 

339
00:15:16,811 --> 00:15:20,205
1、2x、および 3 x の 2 乗に置き換え、他の項を 

340
00:15:20,205 --> 00:15:23,600
4、5x、および 6x の 2 乗に置き換えてみましょう。

341
00:15:24,000 --> 00:15:26,376
ここで、2 つのリスト間でこれらの異なるペアごとの積を

342
00:15:26,376 --> 00:15:28,840
すべて作成することが何を意味するかを考えて みましょう。

343
00:15:29,040 --> 00:15:32,495
あなたがやっていることは、基本的に、私が書き留めた2つの

344
00:15:32,495 --> 00:15:35,950
多項式の全積を展 開することであり、次に、対角線に沿って

345
00:15:35,950 --> 00:15:39,405
合計すると、すべての類似項を収集することに相 当します。

346
00:15:39,405 --> 00:15:42,861
 これは非常にきれいですが、多項式を拡張して類似項を収集

347
00:15:42,861 --> 00:15:46,440
すると、まさに次の とおりです。 畳み込みと同じ処理です。

348
00:15:47,740 --> 00:15:49,249
しかし、これにより、非常に素晴らしいことが

349
00:15:49,249 --> 00:15:50,471
できるようになります。 なぜなら 

350
00:15:50,471 --> 00:15:52,340
、ここで私たちが言っていることを考えてみてください。

351
00:15:52,340 --> 00:15:55,496
2 つの異なる関数を取得し、それらを乗算す 

352
00:15:55,496 --> 00:15:59,513
る場合、これは単純な点単位の演算ですが、最初にそれらが多

353
00:15:59,513 --> 00:16:03,531
項式であると仮定し てそれぞれの関数から係数を抽出し、次

354
00:16:03,531 --> 00:16:06,974
にそれらの畳み込みを計算したのと同じ ことです。

355
00:16:06,974 --> 00:16:08,840
 係数の 2 つのリスト。

356
00:16:09,620 --> 00:16:12,193
これが非常に興味深いのは、畳み込みは原理的 

357
00:16:12,193 --> 00:16:15,233
に単純な乗算よりもはるかに複雑に感じられることです。

358
00:16:15,233 --> 00:16:17,222
 概念的に考えるのが難しいという 

359
00:16:17,222 --> 00:16:20,380
だけではなく、計算上、畳み込みを実行する方が、演算を実

360
00:16:20,380 --> 00:16:23,654
行するよりも多くのステップ が必要になるということです。

361
00:16:23,654 --> 00:16:25,760
 2 つの異なるリストの点ごとの積。

362
00:16:26,319 --> 00:16:29,474
たとえば、それぞ れが 100 の異なる係数を持つ 

363
00:16:29,474 --> 00:16:32,387
2 つの非常に大きな多項式を与えたとしましょう。

364
00:16:32,387 --> 00:16:35,663
 その場 合、それらを乗算する方法がこの積を拡張するこ

365
00:16:35,663 --> 00:16:38,696
とである場合、このペア積の 100 x 1 00 

366
00:16:38,696 --> 00:16:41,608
グリッド全体を埋める必要があることがわかります。

367
00:16:41,608 --> 00:16:43,671
 10,000 の異なる製品を実 

368
00:16:43,671 --> 00:16:47,311
行し、対角線に沿って同様の用語をすべて収集すると、さらに約 

369
00:16:47,311 --> 00:16:49,860
10,000 の操作のセッ トになります。

370
00:16:50,700 --> 00:16:53,196
より一般的には、このアルゴリズムは、サイズ 

371
00:16:53,196 --> 00:16:55,806
n の 2 つのリストの場合、演算数 が n 

372
00:16:55,806 --> 00:16:58,643
の 2 乗に比例するという意味で、アルゴリズムは 

373
00:16:58,643 --> 00:17:01,140
O of n の 2 乗であると言えま す。

374
00:17:01,820 --> 00:17:05,456
一方、出力の観点から 2 つの多項式について考える場合

375
00:17:05,456 --> 00:17:09,092
、たとえば、いく つかの入力で値をサンプリングし、それ

376
00:17:09,092 --> 00:17:11,786
らを乗算する場合、これも点単位の演算で 

377
00:17:11,786 --> 00:17:15,422
あり、多項式を使用する場合のみ必要となるため、サンプル

378
00:17:15,422 --> 00:17:17,846
の数と同じ数の演算 のみが必要です。

379
00:17:17,846 --> 00:17:20,540
 係数を回復できる有限の多くのサンプル。

380
00:17:20,540 --> 00:17:23,690
たとえば、線形多項式を一意に指定するには、2 

381
00:17:23,690 --> 00:17:25,060
つの出力で十分です。

382
00:17:25,660 --> 00:17:28,114
2 次多項式を一意に指定するには、出力が 

383
00:17:28,114 --> 00:17:29,400
3 つあれば十分です。

384
00:17:29,640 --> 00:17:33,332
一般に、n 個の異なる出力がわかっていれば、n 

385
00:17:33,332 --> 00:17:37,640
個の異なる係数を持つ多項式を一意に指定するには十分です。

386
00:17:37,780 --> 00:17:39,250
あるいは、お好みであれば、これを方程

387
00:17:39,250 --> 00:17:40,720
式系の言語で表現することもできます。

388
00:17:41,200 --> 00:17:43,860
多項式があると言うが、その係数が何であるかはあなたに

389
00:17:43,860 --> 00:17:46,520
は謎なので、私は教えていないことを想像してください。

390
00:17:46,700 --> 00:17:48,750
この例では、これが私たちが理解しようとし

391
00:17:48,750 --> 00:17:50,800
ている製品であると考えることができます。

392
00:17:50,800 --> 00:17:53,876
次に、0、1、2、3 などのさまざまな入力を入力した

393
00:17:53,876 --> 00:17:57,189
場合に、この多項式の出力がどのようになるかを説明します。

394
00:17:57,189 --> 00:18:00,265
そして、できるだけ多くの方程式が得られるように十分な

395
00:18:00,265 --> 00:18:03,460
情報を与えるとします。あなたには未知の部分があります。

396
00:18:04,140 --> 00:18:05,698
それはたまたま線形連立方程式であること

397
00:18:05,698 --> 00:18:07,340
さえあるので、それは素晴らしいことです。

398
00:18:07,780 --> 00:18:09,295
そして、少なくとも原理的には、係数

399
00:18:09,295 --> 00:18:10,900
を回復するにはこれで十分なはずです。

400
00:18:11,740 --> 00:18:13,937
したがって、大まかなアルゴリズムの概要は、2 

401
00:18:13,937 --> 00:18:16,325
つの数値リストを畳み込みたいときは常に、それらを 

402
00:18:16,325 --> 00:18:19,000
2 つの多項式の係数であるかのように扱うことになります。

403
00:18:19,420 --> 00:18:23,133
十分な出力でこれらの多項式をサンプリングし、それらのサ

404
00:18:23,133 --> 00:18:26,846
ンプルを点単位で乗算し、畳み込みを見つけるための卑劣な

405
00:18:26,846 --> 00:18:30,560
バックドア方法としてシステムを解いて係数を回復します。

406
00:18:31,420 --> 00:18:33,365
そして、少なくとも私がこれまで述べてきたように

407
00:18:33,365 --> 00:18:35,310
、皆さんの中には「グラント、それは愚かな計画だ

408
00:18:35,310 --> 00:18:37,340
」と当然のことながら文句を言う人もいるでしょう。

409
00:18:37,580 --> 00:18:40,100
なぜなら、すでにわかっている多項式の 1 

410
00:18:40,100 --> 00:18:43,459
つについてこれらすべてのサンプルを計算するだけでも、n 

411
00:18:43,459 --> 00:18:45,860
乗のオーダーの演算が必要になるためです。

412
00:18:45,860 --> 00:18:48,740
言うまでもなく、その系を解くことは、最初に畳み込

413
00:18:48,740 --> 00:18:52,100
みを行うのと同じくらい計算的に困難になることは確かです。

414
00:18:52,600 --> 00:18:56,470
確かに、乗算と畳み込みの間には関連性がありますが、すべて

415
00:18:56,470 --> 00:19:00,480
の複雑さは、ある視点から別の視点に変換する際に発生します。

416
00:19:01,600 --> 00:19:03,616
しかし、トリックがあります。フーリエ変換と 

417
00:19:03,616 --> 00:19:05,632
FFT アルゴリズムについて知っている人なら

418
00:19:05,632 --> 00:19:07,740
、これがどこに向かうのかわかるかもしれません。

419
00:19:07,740 --> 00:19:09,918
これらのトピックに慣れていない場合は、私がこれから言

420
00:19:09,918 --> 00:19:12,180
おうとしていることは全くの唐突に思えるかもしれません。

421
00:19:12,260 --> 00:19:14,514
数学において、これをより期待されたステップにするこ

422
00:19:14,514 --> 00:19:16,860
とができる特定の道があることを知っておいてください。

423
00:19:17,720 --> 00:19:20,360
基本的に、ここでは私たちには選択の自由があるという考えです。

424
00:19:20,540 --> 00:19:23,593
0、1、2、3 などの入力の任意のセットで

425
00:19:23,593 --> 00:19:26,646
評価する代わりに、非常に特別に選択された複

426
00:19:26,646 --> 00:19:29,700
素数のセットで評価することを選択した場合。

427
00:19:30,240 --> 00:19:32,486
具体的には、単位円上に等間隔に配置されてい

428
00:19:32,486 --> 00:19:34,840
るもの、いわゆる統一の根と呼ばれるものです。

429
00:19:35,200 --> 00:19:36,880
これにより、よりフレンドリーなシステムが実現します。

430
00:19:38,360 --> 00:19:42,385
基本的な考え方は、べき乗がこの循環パターンに該当する数値を見

431
00:19:42,385 --> 00:19:46,409
つけることによって、計算するさまざまな条件において、生成され

432
00:19:46,409 --> 00:19:50,435
るシステムが多くの冗長性を持つことを意味し、その方法を賢くす

433
00:19:50,435 --> 00:19:54,460
ることで、その冗長性を活用すれば、多くの作業を節約できます。

434
00:19:56,020 --> 00:19:59,150
私が作成したこの出力セットには特別な名前が

435
00:19:59,150 --> 00:20:02,280
あり、係数の離散フーリエ変換と呼ばれます。

436
00:20:02,500 --> 00:20:05,651
さらに詳しく知りたい場合は、私は実際に同じ Julia 

437
00:20:05,651 --> 00:20:08,914
MIT クラスで離散フーリエ変換に関する別の講義を行いまし

438
00:20:08,914 --> 00:20:09,140
た。

439
00:20:09,220 --> 00:20:11,096
また、チャンネル reducible 

440
00:20:11,096 --> 00:20:13,663
には、これらをより迅速に計算するためのアルゴリズムで

441
00:20:13,663 --> 00:20:16,231
ある高速フーリエ変換について説明している非常に優れた

442
00:20:16,231 --> 00:20:17,120
ビデオもあります。

443
00:20:17,480 --> 00:20:19,161
また、Veritasium は最近、FFT 

444
00:20:19,161 --> 00:20:21,301
に関する非常に優れたビデオを作成したため、選択肢がたくさ

445
00:20:21,301 --> 00:20:21,760
んあります。

446
00:20:22,260 --> 00:20:23,460
そして、その高速アルゴリズムが私

447
00:20:23,460 --> 00:20:24,660
たちにとって本当に重要なのです。

448
00:20:25,120 --> 00:20:27,889
繰り返しになりますが、このすべての冗長性により、

449
00:20:27,889 --> 00:20:31,005
係数からこれらの出力すべてに到達する方法が存在します。

450
00:20:31,005 --> 00:20:33,660
この方法では、n 乗の演算を行う代わりに、n 

451
00:20:33,660 --> 00:20:36,083
の演算の対数を n 倍することになります。

452
00:20:36,083 --> 00:20:39,200
大きなリストにスケールアップするとさらに良くなります。

453
00:20:39,660 --> 00:20:40,940
そして重要なのは、この FFT 

454
00:20:40,940 --> 00:20:42,540
アルゴリズムは双方向に対応することです。

455
00:20:42,700 --> 00:20:45,480
また、出力から係数に進むこともできます。

456
00:20:46,220 --> 00:20:47,599
それでは、すべてをまとめて、アルゴ

457
00:20:47,599 --> 00:20:49,060
リズムの概要を振り返ってみましょう。

458
00:20:49,420 --> 00:20:52,717
これで、数値の 2 つの長いリストが与えられ、それらの畳

459
00:20:52,717 --> 00:20:56,015
み込みを行いたいときはいつでも、まずそれらのそれぞれの高

460
00:20:56,015 --> 00:20:58,371
速フーリエ変換を計算することができます。

461
00:20:58,371 --> 00:21:01,904
頭の片隅では、それらを次のように扱うと考えることができます。

462
00:21:01,904 --> 00:21:05,202
それらは多項式の係数であり、非常に特別に選択された点のセ

463
00:21:05,202 --> 00:21:06,380
ットで評価されます。

464
00:21:06,899 --> 00:21:09,956
次に、点ごとに得られた 2 つの結果を掛け合わせます 

465
00:21:09,956 --> 00:21:12,900
(これは高速で優れています)。その後、逆高速フーリエ

466
00:21:12,900 --> 00:21:15,843
変換を実行します。これにより、私たちが探していた畳み

467
00:21:15,843 --> 00:21:18,900
込みを計算するための卑劣なバックドア方法が得られます。

468
00:21:19,040 --> 00:21:20,591
ただし、今回は n log n 

469
00:21:20,591 --> 00:21:22,240
回中 O 回の操作のみが必要です。

470
00:21:23,139 --> 00:21:24,740
それは私にとって本当にクールです！

471
00:21:25,120 --> 00:21:28,113
2 つの多項式を乗算するという畳み込みが現れるこの非

472
00:21:28,113 --> 00:21:31,106
常に特殊な状況は、畳み込みが発生する可能性のある他の

473
00:21:31,106 --> 00:21:34,100
あらゆる場所に関連するアルゴリズムへの扉を開きます。

474
00:21:34,180 --> 00:21:36,524
確率分布を追加したい場合は、それが何

475
00:21:36,524 --> 00:21:39,000
であれ、大規模な画像処理を実行します。

476
00:21:39,220 --> 00:21:43,280
これは、一見無関係に見える多くの分野で数学の演算や概念が登

477
00:21:43,280 --> 00:21:47,480
場するのを見たときになぜ興奮するのかを示す好例だと思います。

478
00:21:48,480 --> 00:21:49,946
ちょっとした宿題が必要な場合は、こ

479
00:21:49,946 --> 00:21:51,500
こで考えるのが楽しいものがあります。

480
00:21:51,720 --> 00:21:55,047
2 つの異なる数値を掛けるとき、つまり小学校で習

481
00:21:55,047 --> 00:21:58,375
う普通の掛け算では、基本的にこれらの数値の桁間の

482
00:21:58,375 --> 00:22:01,980
畳み込みが行われることになる理由を説明してください。

483
00:22:02,500 --> 00:22:04,431
キャリーなどの追加ステップがいくつかあり

484
00:22:04,431 --> 00:22:06,460
ますが、中心となるステップは畳み込みです。

485
00:22:07,280 --> 00:22:10,770
高速なアルゴリズムの存在を考慮すると、これが意味するの

486
00:22:10,770 --> 00:22:14,260
は、2 つの非常に大きな整数がある場合、小学校で習う方

487
00:22:14,260 --> 00:22:17,880
法よりも速くその積を求める方法が存在するということです。

488
00:22:18,140 --> 00:22:20,369
これは、O of n の 2 乗演算を必要とする

489
00:22:20,369 --> 00:22:22,133
のではなく、O of n log n 

490
00:22:22,133 --> 00:22:24,920
だけを必要とするものであり、それが可能であるとは思えません。

491
00:22:25,380 --> 00:22:28,043
問題は、これが実際に役立つ前に、数値がま

492
00:22:28,043 --> 00:22:30,840
ったく巨大になる必要があるということです。

493
00:22:31,220 --> 00:22:33,280
しかし、それでも、このようなアルゴリズ

494
00:22:33,280 --> 00:22:35,340
ムが存在することは素晴らしいことです。

495
00:22:35,340 --> 00:22:39,640
次に、確率分布に特に焦点を当てた連続事例に注目していきます。

