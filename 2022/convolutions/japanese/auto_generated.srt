1
00:00:00,000 --> 00:00:02,449
2 つの異なる数値リスト、あるいはおそらく 2

2
00:00:02,449 --> 00:00:04,592
つの異なる関数を与え、これら 2 つのリ

3
00:00:04,592 --> 00:00:07,348
ストを組み合わせて新しい数値リストを得る方法、または

4
00:00:07,348 --> 00:00:09,185
2 つの関数を組み合わせて新しい関

5
00:00:09,185 --> 00:00:11,737
数を得る方法をすべて考えてもらいたいとします。 。

6
00:00:11,737 --> 00:00:13,949
おそらく思い浮かぶ簡単な方法の 1 つは

7
00:00:13,949 --> 00:00:16,267
、それらを用語ごとに単純に加算することです。

8
00:00:16,267 --> 00:00:20,050
関数と同様に、対応するすべての出力 を追加できます。

9
00:00:20,050 --> 00:00:23,957
同様に、2 つのリストを項ごとに乗算し、関数で同

10
00:00:23,957 --> 00:00:26,145
じことを行うこともできます。

11
00:00:26,145 --> 00:00:28,943
しかし、これらの両方と同じくらい基本的であるも

12
00:00:28,943 --> 00:00:31,508
のの、あまり議論されていない、畳み込みとして

13
00:00:31,508 --> 00:00:33,840
知られる別の種類の組み合わせがあります。

14
00:00:33,840 --> 00:00:36,809
ただし、前の 2 つのケースとは異なり、数値に対して

15
00:00:36,809 --> 00:00:39,893
実行できる操作から単に継承さ れるものではありません。

16
00:00:39,893 --> 00:00:42,251
これは、数値のリストや関数の組み合わせのコン

17
00:00:42,251 --> 00:00:44,716
テキストにおいては、ま ったく新しいものです。

18
00:00:44,716 --> 00:00:48,557
それらはあらゆる場所に現れ、画像処理で遍在し、確率論の中

19
00:00:48,557 --> 00:00:52,397
核となる構成要素であり、微分方程式を解く際によく使用され、

20
00:00:52,397 --> 00:00:56,105
そうでないとし てもほぼ確実に目にしたことがある文脈の

21
00:00:56,105 --> 00:00:58,488
1 つです。 この名前では、2 つ

22
00:00:58,488 --> 00:01:00,210
の多項式を掛け合わせます。

23
00:01:00,210 --> 00:01:03,222
視覚的な説明を仕事にしている者として、これは特に素晴らしい

24
00:01:03,222 --> 00:01:06,233
トピ ックです。 なぜなら、文脈なしに孤立した定型的な定義

25
00:01:06,233 --> 00:01:08,726
は、ある意味威圧的に見えるかもしれないからです。

26
00:01:08,726 --> 00:01:11,738
しかし、時間をかけてそれが何を言っているのかを実際に解き

27
00:01:11,738 --> 00:01:13,815
明かし、その前に実際にその理由を動機づ

28
00:01:13,815 --> 00:01:16,826
けることができれば、あなたはこのようなものを望むでしょう、

29
00:01:16,826 --> 00:01:18,800
それは信じられないほど美しい操作です。

30
00:01:18,800 --> 00:01:21,074
そして、正直に言うと、このプロジェクトのビジュアルを

31
00:01:21,074 --> 00:01:23,436
まとめているときに、実際に少し学んだこと があります。

32
00:01:23,436 --> 00:01:25,937
2 つの異なる関数を畳み込む場合、私はそれが何を意味

33
00:01:25,937 --> 00:01:28,439
するのかを皆さんが想像でき るさまざまな方法を考えよ

34
00:01:28,439 --> 00:01:30,267
うとしていたのですが、そのうちの 1

35
00:01:30,267 --> 00:01:32,769
つについて、なぜ正規分布が 次のような役割を果たすの

36
00:01:32,769 --> 00:01:34,693
かについて少し納得した瞬間がありました。

37
00:01:34,693 --> 00:01:37,194
確率的にそうなるのですが 、なぜそれが関数にとって

38
00:01:37,194 --> 00:01:38,445
自然な形状なのでしょうか。

39
00:01:38,445 --> 00:01:39,765
しかし、私は先を行っています。

40
00:01:39,765 --> 00:01:41,580
そのためのセッ トアップはたくさんあります。

41
00:01:41,580 --> 00:01:45,127
このビデオでは、離散的なケース、特にこれらを計算するた

42
00:01:45,127 --> 00:01:47,915
めの非常に予想外だが非常に賢いアルゴリズムを

43
00:01:47,915 --> 00:01:50,196
構築することに主に焦点を当てま す。

44
00:01:50,196 --> 00:01:57,840
そして、継続的なケースの議論を第 2 部に引き出します。

45
00:01:57,840 --> 00:02:01,156
画像処理の例は視覚的に最も興味深いものであるため、画像処

46
00:02:01,156 --> 00:02:04,473
理の例から始めたくな るのは非常に魅力的ですが、画像処理

47
00:02:04,473 --> 00:02:06,960
の例が全体的に畳み込みをあまり表現してい

48
00:02:06,960 --> 00:02:10,277
ないようにするいくつかの注意点があるため、代わりに確率論

49
00:02:10,277 --> 00:02:13,593
的に物事を始めまし ょう。 特に、ここにいる誰もが人生の

50
00:02:13,593 --> 00:02:16,792
ある時点で考えたことがあると確信する最も 単純な例の

51
00:02:16,792 --> 00:02:20,108
1 つは、サイコロを振って、さまざまな異なる金額が出る確

52
00:02:20,108 --> 00:02:21,530
率を計 算することです。

53
00:02:21,530 --> 00:02:22,850
そして、あなたは、問題ではない、問

54
00:02:22,850 --> 00:02:24,170
題ではない、と言うかもしれません。

55
00:02:24,170 --> 00:02:26,279
2 つのサイコロにはそれ ぞれ 6

56
00:02:26,279 --> 00:02:28,505
つの異なる出目があるため、合計 36

57
00:02:28,505 --> 00:02:30,615
通りの異なる出目のペアが得られます。

58
00:02:30,615 --> 00:02:33,544
それ らをすべて確認するだけで、指定された合計を

59
00:02:33,544 --> 00:02:36,240
持つペアがいくつあるかを数えることができます。

60
00:02:36,240 --> 00:02:39,301
このようにすべてのペアをグリッドに配置すると、合計が一

61
00:02:39,301 --> 00:02:42,249
定であるすべてのペアがこれらの異なる対角 線の 1

62
00:02:42,249 --> 00:02:45,650
つに沿って表示されるという非常に優れた点が 1 つあります。

63
00:02:45,650 --> 00:02:49,265
したがって、これらの対角 線のそれぞれにいくつ存在するかを単

64
00:02:49,265 --> 00:02:52,880
純に数えるだけで、特定の合計が表示される可能性がわかります。

65
00:02:52,880 --> 00:02:55,789
非常に良い、非常に良いと思いますが、同じ質

66
00:02:55,789 --> 00:02:58,699
問を視覚化する他の方法は考え られますか?

67
00:02:58,699 --> 00:03:01,160
特定の合計を持つすべての個別のペアについ

68
00:03:01,160 --> 00:03:03,744
て考える他のイメージが思い浮かび ますか?

69
00:03:03,744 --> 00:03:05,171
そしておそらく、皆さんのうちの 1

70
00:03:05,171 --> 00:03:07,550
人が手を挙げて、「はい、持っています」と言うかもしれません。

71
00:03:07,550 --> 00:03:10,128
これら 2 つの異なる可 能性のセットをそれぞれ

72
00:03:10,128 --> 00:03:11,881
1 行に並べて描いたとしましょう。

73
00:03:11,881 --> 00:03:14,046
ただし、2 番目の行を反転するとします。

74
00:03:14,046 --> 00:03:16,503
そうすれ ば、合計 7 になるさまざま

75
00:03:16,503 --> 00:03:18,960
なペアがすべてこのように縦に並びます。

76
00:03:18,960 --> 00:03:22,634
そして、その一番 下の行を右端までスライドすると、合計で

77
00:03:22,634 --> 00:03:26,309
2 になるユニークなペア、つまり蛇 の目だけが一致します。

78
00:03:26,309 --> 00:03:29,542
そして、それを 1 単位上に右にずらしてみると、整列するペ

79
00:03:29,542 --> 00:03:32,886
アは 2 つの異なるペアであり、合計すると 3 になります。

80
00:03:32,886 --> 00:03:35,427
そして一般に、この下の配列のさまざまなオフセッ

81
00:03:35,427 --> 00:03:38,391
ト値により、最初に反転する必要があったことを覚えています

82
00:03:38,391 --> 00:03:40,932
が、指定された合計を持つすべての個別のペアが明

83
00:03:40,932 --> 00:03:41,778
らかになります。

84
00:03:41,778 --> 00:03:45,559
確率に関する質問に関する限り、これはまだ特に興味深いものでは

85
00:03:45,559 --> 00:03:49,339
ありません。 なぜなら 、私たちがやっているのはこれらの各カ

86
00:03:49,339 --> 00:03:53,120
テゴリーにどれだけの結果があるかを数えているだけだからです。

87
00:03:53,120 --> 00:03:55,485
しかし、それは、これらの顔のそれぞれが出現す

88
00:03:55,485 --> 00:03:57,850
る機会が等しいという暗黙の前提があ ります。

89
00:03:57,850 --> 00:03:59,824
しかし、統一されていない特別なサイコロの

90
00:03:59,824 --> 00:04:01,897
セットがあると言ったらどうなるでしょうか?

91
00:04:01,897 --> 00:04:04,474
おそら く、青いサイコロには、出現する各面の確

92
00:04:04,474 --> 00:04:07,163
率を表す独自の数字のセットがあり、赤いサイコロ

93
00:04:07,163 --> 00:04:09,740
には、独自の異なる数字のセットがあるでしょう。

94
00:04:09,740 --> 00:04:12,138
その場合、たとえば 2 の目が出

95
00:04:12,138 --> 00:04:15,382
る確率を計算したい場合は、青いサイコロが 1

96
00:04:15,382 --> 00:04:18,908
になる確率と、赤いサイコ ロが 1 になる確率を

97
00:04:18,908 --> 00:04:19,895
1 倍します。

98
00:04:19,895 --> 00:04:22,316
そして、3 が表示される確率につい

99
00:04:22,316 --> 00:04:25,679
ては、それが可能な場合は 2 つの異なるペアを調べ

100
00:04:25,679 --> 00:04:28,638
、対応する確率を再度乗 算して、それら 2

101
00:04:28,638 --> 00:04:29,983
つの積を加算します。

102
00:04:29,983 --> 00:04:32,276
同様に、4 が表示される確率には 、3

103
00:04:32,276 --> 00:04:35,602
つの異なる可能性のペアを掛け合わせ、それらをすべて加算する

104
00:04:35,602 --> 00:04:36,748
ことが含まれ ます。

105
00:04:36,748 --> 00:04:39,800
そして、いくつかの式を設定するという精神で、これらの上

106
00:04:39,800 --> 00:04:42,060
位の確率に a1、a2、a3 などの名

107
00:04:42,060 --> 00:04:44,433
前を付け、下位の確率に b1、b2、b3

108
00:04:44,433 --> 00:04:45,903
などの名前を付けましょう。

109
00:04:45,903 --> 00:04:48,182
そして一般に、このプロセ スでは、2

110
00:04:48,182 --> 00:04:50,102
つの異なる数値配列を取得し、2

111
00:04:50,102 --> 00:04:52,021
番目の配列を反転して、それらを

112
00:04:52,021 --> 00:04:55,021
さまざまなオフセット値で並べ、多数のペアごとの積を

113
00:04:55,021 --> 00:04:58,500
取得してそれらを加算し ます。 これは、次の 1 つです。

114
00:04:58,500 --> 00:05:01,139
畳み込みとは何かについての基本的な考え方。

115
00:05:01,139 --> 00:05:05,126
もう少し正確に説明すると、このプロセスを通じて、2

116
00:05:05,126 --> 00:05:08,192
つ、3 つ、4 つ、そして最 大 12

117
00:05:08,192 --> 00:05:12,178
まで表示される確率を生成し、1 つの値のリスト a

118
00:05:12,178 --> 00:05:15,704
と別の値を混ぜ合わ せてそれらを取得しました。

119
00:05:15,704 --> 00:05:17,084
値のリスト、b.

120
00:05:17,084 --> 00:05:19,811
専門用語では、これら 2 つのシーケンスの畳み込

121
00:05:19,811 --> 00:05:22,320
みにより、この新しいシーケンス、つまり 11

122
00:05:22,320 --> 00:05:25,374
個の値の新しいシーケンスが得られ、それぞれがペアごとの

123
00:05:25,374 --> 00:05:27,120
積の和のように見えると言えます。

124
00:05:27,120 --> 00:05:30,902
必要に応じて、同じ演算を考える別の方法として、最初にすべて

125
00:05:30,902 --> 00:05:34,054
のペアごとの積の表を作成し、次にこれらすべての対角

126
00:05:34,054 --> 00:05:36,702
線に沿って合計するという方法もあり ます。

127
00:05:36,702 --> 00:05:38,338
繰り返しますが、これは、これら 2

128
00:05:38,338 --> 00:05:40,156
つの数値シーケンスを混ぜ合わせて、11

129
00:05:40,156 --> 00:05:42,247
個の新しい数値シーケン スを取得する方法です。

130
00:05:42,247 --> 00:05:44,532
これは、スライド窓が考えた操作と

131
00:05:44,532 --> 00:05:46,960
同じですが、別の視点にすぎません。

132
00:05:46,960 --> 00:05:50,314
それにちょっとした注釈を付けて、次のように書きます。

133
00:05:50,314 --> 00:05:52,993
この小さなアスタリスクで示 されている a と b

134
00:05:52,993 --> 00:05:55,569
の畳み込みは新しいリストであり、そのリストの n

135
00:05:55,569 --> 00:05:57,320
番目の要素は合計のように見えます。

136
00:05:57,320 --> 00:06:00,102
その 合計は、すべての異なるインデックスのペア i

137
00:06:00,102 --> 00:06:02,987
と j にまたがります。 つまり、次の合計はそれらのイン

138
00:06:02,987 --> 00:06:04,738
デックスは n に等しくなります。

139
00:06:04,738 --> 00:06:07,622
ちょっと長めの話ですが、たとえば、n が 6

140
00:06:07,622 --> 00:06:10,506
の場合、ここで検討するペアは、1 と 5、2

141
00:06:10,506 --> 00:06:13,265
と 4、3 と 3、4 と 2、5 と 1

142
00:06:13,265 --> 00:06:16,400
であり、すべての異なるペアを合計します。 6まで。

143
00:06:16,400 --> 00:06:18,594
しかし正直なところ、どのように書き留めても、

144
00:06:18,594 --> 00:06:21,187
プロセス中に頭の中に保持するビジュアルに比べれば、

145
00:06:21,187 --> 00:06:23,082
表記法は二の次の重要性を持っています。

146
00:06:23,082 --> 00:06:26,053
ここで、非常に単純な例を行うと役立つかもしれません。

147
00:06:26,053 --> 00:06:28,681
リス ト 1、2、3 とリスト 4、5、6

148
00:06:28,681 --> 00:06:30,967
の畳み込みは何かと尋ねるかもしれません。

149
00:06:30,967 --> 00:06:33,078
これらのリストを 両方とも取得し、2

150
00:06:33,078 --> 00:06:36,412
番目のリストを裏返し、次にその蓋から左端まで進めていく様子

151
00:06:36,412 --> 00:06:37,857
を想像するかもしれません。

152
00:06:37,857 --> 00:06:41,207
次に、整列する値のペアは 1 と 4 であり、それら

153
00:06:41,207 --> 00:06:43,813
を乗算すると、出力の最初の項が得られます。

154
00:06:43,813 --> 00:06:46,435
一番下の配列を 1 単位右にスライドさせま す。

155
00:06:46,435 --> 00:06:49,493
整列するペアは 1 と 5、および 2 と 4 です。

156
00:06:49,493 --> 00:06:52,006
これらのペアを掛け合わせて加算すると、出力

157
00:06:52,006 --> 00:06:54,300
の次のエントリである 13 が得られます。

158
00:06:54,300 --> 00:06:57,945
もう一度スライドしてみると、1 × 6、プラス 2 ×

159
00:06:57,945 --> 00:07:01,591
5、プラス 3 × 4 で、たまたま 28 になります。

160
00:07:01,591 --> 00:07:04,361
もう 1 枚スライドすると、2 × 6、

161
00:07:04,361 --> 00:07:06,603
プラス 3 × 5、つまり 27

162
00:07:06,603 --> 00:07:10,560
が得られ、最終的に最後の項は 3 × 6 のようになります。

163
00:07:10,560 --> 00:07:13,237
必要に応じて、お気に入りのプログラミング言語や、さ

164
00:07:13,237 --> 00:07:15,915
まざまな数値演算を含むお気 に入りのライブラリを呼

165
00:07:15,915 --> 00:07:18,807
び出して、私が嘘をついていないことを確認してください。

166
00:07:18,807 --> 00:07:21,769
1、2、3 と 4、5、6 の畳み込みを

167
00:07:21,769 --> 00:07:24,880
行うと、実際にこのような結果が得られます。

168
00:07:24,880 --> 00:07:27,547
これが自然で望ましい操作である確率分布への

169
00:07:27,547 --> 00:07:30,214
加算であるケースを 1 つ見てき ました。

170
00:07:30,214 --> 00:07:32,881
もう 1 つの一般的な例は移動平均です。

171
00:07:32,881 --> 00:07:35,429
数値の長いリストがあり、すべて 足すと 1

172
00:07:35,429 --> 00:07:38,788
になる小さな数値の別のリストを取得すると想像してください。

173
00:07:38,788 --> 00:07:41,920
この場合、5 つの値の 小さなリストがあり、それらはすべて

174
00:07:41,920 --> 00:07:43,381
5 分の 1 に等しいです。

175
00:07:43,381 --> 00:07:45,321
次に、このスライディング ウィ

176
00:07:45,321 --> 00:07:48,353
ンドウの畳み込みプロセスを実行し、目を閉じてその最

177
00:07:48,353 --> 00:07:50,656
初で何が起こっているかを徹底的に調べ

178
00:07:50,656 --> 00:07:53,688
、小さい値のリストが大きい値のリストと完全に重なっ

179
00:07:53,688 --> 00:07:56,719
たら、この中の各項が何であるかを考 えてください。

180
00:07:56,719 --> 00:07:59,023
畳み込みというのは本当に意味します。

181
00:07:59,023 --> 00:08:01,769
各反復では、データの各値を 1/5

182
00:08:01,769 --> 00:08:05,430
で乗算し、それらをすべて加算することになります。

183
00:08:05,430 --> 00:08:09,243
つまり、この小 さなウィンドウ内のデータの平均を

184
00:08:09,243 --> 00:08:10,769
取ることになります。

185
00:08:10,769 --> 00:08:13,704
全体として、このプロセ スにより、元のデータの平滑化された

186
00:08:13,704 --> 00:08:16,640
バージョンが得られます。 これを、別の小さな数値リストか

187
00:08:16,640 --> 00:08:18,260
ら始めて変更することができます。

188
00:08:18,260 --> 00:08:21,297
その小さなリストの合計が 1 になる限り、それを移動デー

189
00:08:21,297 --> 00:08:22,816
タとして解釈できます。 平均。

190
00:08:22,816 --> 00:08:25,988
ここに示す例では、移動平均により中心値により

191
00:08:25,988 --> 00:08:27,781
大きな重みが与えられます。

192
00:08:27,781 --> 00:08:33,200
これにより、データが平滑化されたバージョンになります。

193
00:08:33,200 --> 00:08:35,842
これを 2 次元で類似したものにすると、特定の画

194
00:08:35,842 --> 00:08:38,594
像をぼかすための楽しいアルゴリズムが 得られます。

195
00:08:38,594 --> 00:08:40,992
そして、これから紹介するアニメーションは、画像処

196
00:08:40,992 --> 00:08:43,791
理ユニットを含む特定の OpenCo urseWare

197
00:08:43,791 --> 00:08:46,189
クラスのために MIT の Julia Lab

198
00:08:46,189 --> 00:08:47,788
と行った一連の講義の一部として

199
00:08:47,788 --> 00:08:50,187
元々作成したものを変更したものであると言わなけれ

200
00:08:50,187 --> 00:08:50,887
ばなりません。

201
00:08:50,887 --> 00:08:52,428
そこで、このすべての背後にあるコー

202
00:08:52,428 --> 00:08:54,226
ドを詳しく調べるためにもう少し作業を行った

203
00:08:54,226 --> 00:08:56,452
ので、興味があればいくつかのリンクを残しておきます。

204
00:08:56,452 --> 00:08:59,171
しか し、このぼやけた例に焦点を戻すと、何が起こっ

205
00:08:59,171 --> 00:09:01,673
ているのかというと、元の画像に沿って進んでい

206
00:09:01,673 --> 00:09:04,393
る値の小さな 3x3 グリッドがあり、ズームインす

207
00:09:04,393 --> 00:09:06,459
ると、これらの値のそれぞれが 1 9

208
00:09:06,459 --> 00:09:08,852
であり、私が何をしているのかということです。

209
00:09:08,852 --> 00:09:11,246
各反復で、それらの値のそれぞれに、その上

210
00:09:11,246 --> 00:09:13,312
にある対応するピクセルが乗算されます。

211
00:09:13,312 --> 00:09:15,985
そしてもちろん、コンピューター サイエンスで

212
00:09:15,985 --> 00:09:18,192
は、色を、赤、緑、青の成分を表す 3

213
00:09:18,192 --> 00:09:20,400
つの値の小さなベクトルとして考えます。

214
00:09:20,400 --> 00:09:22,673
これらすべての小さな値に 1 9

215
00:09:22,673 --> 00:09:25,482
を乗算して加算すると、各カラー チャネル

216
00:09:25,482 --> 00:09:28,960
に沿った平均が得られ、右側の画像の対応するピクセルは

217
00:09:28,960 --> 00:09:30,966
その合計として定義され ます。

218
00:09:30,966 --> 00:09:34,454
画像上のすべてのピクセルに対してこれを行うと、全体的な効

219
00:09:34,454 --> 00:09:37,942
果として、それぞれの種類が 隣接するすべてのピクセルにに

220
00:09:37,942 --> 00:09:41,680
じみ出て、元のピクセルよりもぼやけたバージョンが得られます。

221
00:09:41,680 --> 00:09:44,740
専門用語では、右側の画像は、元の画像と値の小さ

222
00:09:44,740 --> 00:09:47,800
なグリッドを畳み込んだもので あると言えます。

223
00:09:47,800 --> 00:09:50,725
あるいは、より専門的に言えば、これは、値の小さなグリッドを

224
00:09:50,725 --> 00:09:52,870
180 度回転させ たバージョンとの畳み込み

225
00:09:52,870 --> 00:09:54,430
であると言うべきかもしれません。

226
00:09:54,430 --> 00:09:56,511
グリッドが対称であるかどうかは重要

227
00:09:56,511 --> 00:09:59,286
ではありませんが、純粋な数学のコンテキストから継

228
00:09:59,286 --> 00:10:01,482
承された畳み込みの定義では、常に 2

229
00:10:01,482 --> 00:10:04,257
番目の配列を反転することを考慮する必要があること

230
00:10:04,257 --> 00:10:05,760
に留意する価値があります。

231
00:10:05,760 --> 00:10:08,359
これを少し変更すると、別の値のグリッドを選択すること

232
00:10:08,359 --> 00:10:11,059
で、よりエレガントなぼかし効果を得ること ができます。

233
00:10:11,059 --> 00:10:13,489
この場合、小さな 5x5 グリッドがあり

234
00:10:13,489 --> 00:10:15,920
ますが、違いはそのサイズではありません。

235
00:10:15,920 --> 00:10:19,243
ズームインすると、中央の値が端に向かう値よりもはるかに大

236
00:10:19,243 --> 00:10:22,567
きいことがわかります。 これは、ガウス分布として知られる

237
00:10:22,567 --> 00:10:26,010
釣鐘曲線からすべてサンプリングされていることが 原因です。

238
00:10:26,010 --> 00:10:29,422
そうすることで、これらすべての値に、その上にある対応する

239
00:10:29,422 --> 00:10:32,834
ピクセルを乗算 するときに、その中央のピクセルに多くの重

240
00:10:32,834 --> 00:10:36,367
みを与え、端のピクセルには重みをあまり 与えなくなります。

241
00:10:36,367 --> 00:10:38,370
そして、前と同様に、右側の対応するピクセ

242
00:10:38,370 --> 00:10:40,373
ルがこの合計になるように定義され ます。

243
00:10:40,373 --> 00:10:43,414
このプロセスをすべてのピクセルに対して実行する

244
00:10:43,414 --> 00:10:46,454
ことで、レンズの焦点を 外したときなどの概念を

245
00:10:46,454 --> 00:10:49,760
より忠実にシミュレートするぼかし効果が得られます。

246
00:10:49,760 --> 00:10:53,474
しかし、このアイデアでできることはぼかしだけではありません。

247
00:10:53,474 --> 00:10:56,473
たとえば、この小さな値 のグリッドを見てください。

248
00:10:56,473 --> 00:10:59,712
左側にはいくつかの正の数値が、右側にはいくつかの負

249
00:10:59,712 --> 00:11:03,071
の数値が含まれています。 それぞれ青と赤で色付けします。

250
00:11:03,071 --> 00:11:05,141
これが最終的な画像にどのような影

251
00:11:05,141 --> 00:11:08,430
響を与えるかを予測して理解できるかどうか、少し時間を取

252
00:11:08,430 --> 00:11:09,769
って確認してください。

253
00:11:09,769 --> 00:11:12,540
したがって、この場合、画 像は色付きではなくグレ

254
00:11:12,540 --> 00:11:15,311
ースケールであると考えているため、各ピクセルは

255
00:11:15,311 --> 00:11:18,082
3 つの数値ではなく 1 つの数値で表されます。

256
00:11:18,082 --> 00:11:20,541
そして、注目すべき点の 1 つは、この畳み込みを

257
00:11:20,541 --> 00:11:23,102
行うときに負の値 が得られる可能性があることです。

258
00:11:23,102 --> 00:11:26,360
たとえば、この時点でズームインすると、小さなグ

259
00:11:26,360 --> 00:11:29,483
リッドの左半分は完全に黒いピクセルの上にあり、

260
00:11:29,483 --> 00:11:32,605
その値はゼロになりますが 、負の値の右半分はす

261
00:11:32,605 --> 00:11:36,000
べて白いピクセルの上にあります。 値は 1 です。

262
00:11:36,000 --> 00:11:39,261
したがって、対応する項を乗算して加算すると、結果は

263
00:11:39,261 --> 00:11:42,523
非常に負の値になり ます。 これを右の画像で表示す

264
00:11:42,523 --> 00:11:46,046
る方法は、負の値を赤、正の値を青に色付 けることです。

265
00:11:46,046 --> 00:11:48,899
もう 1 つ注意すべき点は、すべて同じ色のパッ

266
00:11:48,899 --> 00:11:51,752
チを使用している場合、 小さなグリッド内の値の

267
00:11:51,752 --> 00:11:54,854
合計がゼロになるため、すべてがゼロになることです。

268
00:11:54,854 --> 00:11:57,530
これは、小さ なグリッドの合計が 1 だった前の

269
00:11:57,530 --> 00:11:59,243
2 つの例とは大きく異なります。

270
00:11:59,243 --> 00:12:01,919
この例では、それを移 動平均として解釈し、したが

271
00:12:01,919 --> 00:12:02,990
ってぼやけています。

272
00:12:02,990 --> 00:12:05,672
全体として、この小さなプロセスは

273
00:12:05,672 --> 00:12:10,090
基本的に、左から右に移動するときにピクセル値に変化がある

274
00:12:10,090 --> 00:12:14,508
場所を検出す るため、画像からすべての垂直エッジを検出す

275
00:12:14,508 --> 00:12:16,560
る一種の方法を提供します。

276
00:12:16,560 --> 00:12:19,806
同様に、上から下に移動するにつれてグリッドが

277
00:12:19,806 --> 00:12:23,052
変化するようにグリッド を回転すると、すべて

278
00:12:23,052 --> 00:12:26,593
の水平エッジが検出され、小さなパイの生き物の画

279
00:12:26,593 --> 00:12:29,986
像の場合、かなり悪魔のような目が表示されます。

280
00:12:29,986 --> 00:12:32,589
ちなみに、この小さなグリ ッドはカーネルと呼ばれる

281
00:12:32,589 --> 00:12:35,192
ことが多く、ここでの利点は、別のカーネルを選択する

282
00:12:35,192 --> 00:12:37,794
だけで、エ ッジ検出をぼかすだけでなくシャープ化な

283
00:12:37,794 --> 00:12:40,710
どのさまざまな画像処理効果を得ることができるこ とです。

284
00:12:40,710 --> 00:12:43,385
畳み込みニューラル ネットワークについて聞いたことが

285
00:12:43,385 --> 00:12:45,135
ある方は、ニューラル ネットワー

286
00:12:45,135 --> 00:12:47,810
クが検出したいものによって決定される、そもそもカーネ

287
00:12:47,810 --> 00:12:49,971
ルがどうあるべきかをデータを使用して判断

288
00:12:49,971 --> 00:12:51,618
するという概念があると思います。

289
00:12:51,618 --> 00:12:55,378
もう 1 つ取り上げるべき点は、出力の長さで す。

290
00:12:55,378 --> 00:12:58,443
移動平均の例のような場合は、両方のウィンドウが互い

291
00:12:58,443 --> 00:13:01,507
に完全に一致するとき の項のみを考慮する必要がある

292
00:13:01,507 --> 00:13:04,572
かもしれません。 または、画像処理の例では、最終

293
00:13:04,572 --> 00:13:07,760
出力を元のサイズと同じサイズにしたいかもしれません。

294
00:13:07,760 --> 00:13:10,817
純粋な数学演算としての畳 み込みは、少なくともそのうちの

295
00:13:10,817 --> 00:13:13,453
1 つの長さが 1 ではないと仮定すると、最初に

296
00:13:13,453 --> 00:13:16,405
開始した 2 つの配列よりも大きな配列を常に生成します。

297
00:13:16,405 --> 00:13:17,704
特定のコンピューター サイエン

298
00:13:17,704 --> 00:13:19,409
スのコンテキストでは、その出力を意図的に切

299
00:13:19,409 --> 00:13:21,520
り捨てたいことがよくあることを知っておいてください。

300
00:13:21,520 --> 00:13:24,837
もう 1 つ強調すべき価値があるのは、コンピューター

301
00:13:24,837 --> 00:13:27,294
サイエンスの文脈では、元のカーネルを実

302
00:13:27,294 --> 00:13:30,734
行する前にそのカーネルを反転するというこの概念は、非常に

303
00:13:30,734 --> 00:13:32,946
奇妙で必要のないものに感じることが

304
00:13:32,946 --> 00:13:36,386
よくありますが、それが純粋な数学の文脈から受け継がれてい

305
00:13:36,386 --> 00:13:39,212
るものであることにもう一度注意して ください。

306
00:13:39,212 --> 00:13:42,530
確率的に見て、それは信じられないほど自然なことです。

307
00:13:42,530 --> 00:13:45,472
そして実際に、もう 1 つ純 粋な数学の例をお見せします。

308
00:13:45,472 --> 00:13:47,906
これは、これらすべてを計算するためのより高速な

309
00:13:47,906 --> 00:13:50,341
アルゴリズムへの扉 を開くものであるため、プログ

310
00:13:50,341 --> 00:13:52,370
ラマーでもこれに注意する必要があります。

311
00:13:52,370 --> 00:13:55,475
ここで言う「高速化」をセ ットアップするために、戻って

312
00:13:55,475 --> 00:13:57,250
Python を再度起動し、2

313
00:13:57,250 --> 00:13:59,579
つの異なる比較的大きな 配列を作成します。

314
00:13:59,579 --> 00:14:02,244
それぞれには 10 万個のランダムな要素が含

315
00:14:02,244 --> 00:14:04,789
まれており、nump y ライブラリから

316
00:14:04,789 --> 00:14:07,575
convolve 関数の実行時間を評価します。

317
00:14:07,575 --> 00:14:10,449
この場合、複数の 異なる反復で実行し、平均値を

318
00:14:10,449 --> 00:14:13,573
見つけようとします。 このコンピュータでは、少な

319
00:14:13,573 --> 00:14:16,321
くとも平均値は 4 であるようです。87秒。

320
00:14:16,321 --> 00:14:19,471
対照的に、fftconvolve と いう

321
00:14:19,471 --> 00:14:23,051
scipy ライブラリの別の関数を使用すると、同じ

322
00:14:23,051 --> 00:14:27,346
ものを別の方法で実装しただけで、 必要な値は 4 だけです。

323
00:14:27,346 --> 00:14:30,640
平均 3 ミリ秒なので、3 桁も改善されます。

324
00:14:30,640 --> 00:14:33,496
また、別の名前で実行されているにもかかわらず、他の

325
00:14:33,496 --> 00:14:36,243
convolve 関数 が行うのと同じ出力を提供し

326
00:14:36,243 --> 00:14:38,880
ており、より賢い方法で何かを行っているだけです。

327
00:14:38,880 --> 00:14:42,219
確率の例で、畳み込みについて考える別の方法とし

328
00:14:42,219 --> 00:14:45,123
て、すべてのペアごとの積のテーブルを作

329
00:14:45,123 --> 00:14:48,462
成し、それらのペアごとの積を対角線に沿って合計

330
00:14:48,462 --> 00:14:52,528
するという方法があると述べたことを思い 出してください。

331
00:14:52,528 --> 00:14:55,061
もちろん、このように考えることができる 2

332
00:14:55,061 --> 00:14:58,400
つの異なる数値リストを 畳み込むときは、確率に特有のものは

333
00:14:58,400 --> 00:14:59,321
何もありません。

334
00:14:59,321 --> 00:15:02,851
すべてのペアごとの積を使用し てこの種の乗算表を作成すると

335
00:15:02,851 --> 00:15:06,381
、対角線に沿った各合計が最終出力の 1 つに対 応します。

336
00:15:06,381 --> 00:15:09,173
この見方が特に自然である状況の 1

337
00:15:09,173 --> 00:15:12,431
つは、2 つの多項式を乗算す る場合です。

338
00:15:12,431 --> 00:15:16,348
たとえば、すでにある小さなグリッドを使用して、最上位の項を

339
00:15:16,348 --> 00:15:20,134
1、2x、および 3 x の 2 乗に置き換え、他の項を

340
00:15:20,134 --> 00:15:23,920
4、5x、および 6x の 2 乗に置き換えてみましょう。

341
00:15:23,920 --> 00:15:26,249
ここで、2 つのリスト間でこれらの異なるペアごとの積を

342
00:15:26,249 --> 00:15:28,664
すべて作成することが何を意味するかを考えて みましょう。

343
00:15:28,664 --> 00:15:32,293
あなたがやっていることは、基本的に、私が書き留めた2つの

344
00:15:32,293 --> 00:15:35,921
多項式の全積を展 開することであり、次に、対角線に沿って

345
00:15:35,921 --> 00:15:39,550
合計すると、すべての類似項を収集することに相 当します。

346
00:15:39,550 --> 00:15:43,178
これは非常にきれいですが、多項式を拡張して類似項を収集

347
00:15:43,178 --> 00:15:46,937
すると、まさに次の とおりです。 畳み込みと同じ処理です。

348
00:15:46,937 --> 00:15:48,809
しかし、これにより、非常に素晴らしいことが

349
00:15:48,809 --> 00:15:50,324
できるようになります。 なぜなら

350
00:15:50,324 --> 00:15:52,642
、ここで私たちが言っていることを考えてみてください。

351
00:15:52,642 --> 00:15:55,726
2 つの異なる関数を取得し、それらを乗算す

352
00:15:55,726 --> 00:15:59,650
る場合、これは単純な点単位の演算ですが、最初にそれらが多

353
00:15:59,650 --> 00:16:03,575
項式であると仮定し てそれぞれの関数から係数を抽出し、次

354
00:16:03,575 --> 00:16:06,939
にそれらの畳み込みを計算したのと同じ ことです。

355
00:16:06,939 --> 00:16:08,761
係数の 2 つのリスト。

356
00:16:08,761 --> 00:16:11,520
これが非常に興味深いのは、畳み込みは原理的

357
00:16:11,520 --> 00:16:14,781
に単純な乗算よりもはるかに複雑に感じられることです。

358
00:16:14,781 --> 00:16:16,914
概念的に考えるのが難しいという

359
00:16:16,914 --> 00:16:20,300
だけではなく、計算上、畳み込みを実行する方が、演算を実

360
00:16:20,300 --> 00:16:23,812
行するよりも多くのステップ が必要になるということです。

361
00:16:23,812 --> 00:16:26,070
2 つの異なるリストの点ごとの積。

362
00:16:26,070 --> 00:16:29,232
たとえば、それぞ れが 100 の異なる係数を持つ

363
00:16:29,232 --> 00:16:32,151
2 つの非常に大きな多項式を与えたとしましょう。

364
00:16:32,151 --> 00:16:35,435
その場 合、それらを乗算する方法がこの積を拡張するこ

365
00:16:35,435 --> 00:16:38,476
とである場合、このペア積の 100 x 1 00

366
00:16:38,476 --> 00:16:41,395
グリッド全体を埋める必要があることがわかります。

367
00:16:41,395 --> 00:16:43,463
10,000 の異なる製品を実

368
00:16:43,463 --> 00:16:47,112
行し、対角線に沿って同様の用語をすべて収集すると、さらに約

369
00:16:47,112 --> 00:16:49,666
10,000 の操作のセッ トになります。

370
00:16:49,666 --> 00:16:52,332
より一般的には、このアルゴリズムは、サイズ

371
00:16:52,332 --> 00:16:55,120
n の 2 つのリストの場合、演算数 が n

372
00:16:55,120 --> 00:16:58,149
の 2 乗に比例するという意味で、アルゴリズムは

373
00:16:58,149 --> 00:17:00,816
O of n の 2 乗であると言えま す。

374
00:17:00,816 --> 00:17:04,761
一方、出力の観点から 2 つの多項式について考える場合

375
00:17:04,761 --> 00:17:08,706
、たとえば、いく つかの入力で値をサンプリングし、それ

376
00:17:08,706 --> 00:17:11,628
らを乗算する場合、これも点単位の演算で

377
00:17:11,628 --> 00:17:15,574
あり、多項式を使用する場合のみ必要となるため、サンプル

378
00:17:15,574 --> 00:17:18,204
の数と同じ数の演算 のみが必要です。

379
00:17:18,204 --> 00:17:21,126
係数を回復できる有限の多くのサンプル。

380
00:17:21,126 --> 00:17:24,075
たとえば、線形多項式 を一意に指定するには 2

381
00:17:24,075 --> 00:17:27,639
つの出力で十分です。 二次多項式を一意に指定するには 3

382
00:17:27,639 --> 00:17:29,728
つの出力で十分です。 一般に、n

383
00:17:29,728 --> 00:17:32,800
個の異なる出力がわかっている場合は、n 個の異な

384
00:17:32,800 --> 00:17:35,749
る係数を持つ多項式を一意に指定するには十分です。

385
00:17:35,749 --> 00:17:39,066
または、必要に応じて次のようにす ることもできます。

386
00:17:39,066 --> 00:17:42,015
これを連立方程式の言語で表現してみてください。

387
00:17:42,015 --> 00:17:45,579
多項式があると言 いましたが、その係数が何であるかはあな

388
00:17:45,579 --> 00:17:46,439
たには謎です。

389
00:17:46,439 --> 00:17:48,399
この例では、これを計算しようと

390
00:17:48,399 --> 00:17:50,727
している積であると考えて、0、1、2

391
00:17:50,727 --> 00:17:53,667
などのさまざまな入力を入力した場合にこの多項式

392
00:17:53,667 --> 00:17:56,974
の出力がどのようになるかを説明するだけだと仮定します。

393
00:17:56,974 --> 00:17:59,056
, 3, 以降も、未知数と同じ

394
00:17:59,056 --> 00:18:02,241
だけ多くの方程式が得られるように十分な数を与えます。

395
00:18:02,241 --> 00:18:04,569
それがたまたま線形方程式系であるこ

396
00:18:04,569 --> 00:18:07,999
とさえあるので、それは素晴らしいことであり、原理的には少

397
00:18:07,999 --> 00:18:11,061
なくともこれで係数を回復する のに十分なはずです。

