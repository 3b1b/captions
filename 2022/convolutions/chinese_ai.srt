1
00:00:00,000 --> 00:00:04,480
假设我给你两个不同的数字列表，或者可能是两个不同的函数，并且我要求你思考可以组合这两个列表以获得新的数字列表，或者组合这两个函数以获得新函数的所有方法。

2
00:00:04,480 --> 00:00:08,400


3
00:00:08,400 --> 00:00:14,000
也许想到的一种简单方法就是简单地将它们逐个添加在一起。

4
00:00:14,000 --> 00:00:18,640
与功能类似，您可以添加所有相应的输出。

5
00:00:18,640 --> 00:00:24,000
同样，您也可以将两个列表逐项相乘，并对函数执行相同的操作。

6
00:00:24,000 --> 00:00:28,720
但还有另一种组合与这两种组合一样基本，但很少被讨论，称为卷积。

7
00:00:28,720 --> 00:00:33,840


8
00:00:33,840 --> 00:00:38,240
但与前两种情况不同的是，它不仅仅是从对数字执行的操作继承的。

9
00:00:38,240 --> 00:00:43,360
对于数字列表或组合函数的上下文来说，这是真正的新事物。

10
00:00:43,360 --> 00:00:49,280
它们无处不在，它们在图像处理中无处不在，它是概率论的核心构造，它们在求解微分方程中被大量使用，并且您几乎肯定在其中见过它（如果没有的话）顾名思义，就是将两个多项式相乘。

11
00:00:49,280 --> 00:00:53,760


12
00:00:53,760 --> 00:00:58,240


13
00:00:58,240 --> 00:01:03,440
作为从事视觉解释行业的人，这是一个特别好的话题，因为孤立且没有上下文的公式化定义可能看起来有点令人生畏，但如果我们花时间真正解开它所说的内容，并在此之前真正激发为什么你会想要这样的东西，这是一个非常漂亮的操作。

14
00:01:03,440 --> 00:01:08,800


15
00:01:08,800 --> 00:01:14,080


16
00:01:14,080 --> 00:01:18,800


17
00:01:18,800 --> 00:01:22,880
我必须承认，在为这个项目制作视觉效果时，我实际上学到了一些东西。

18
00:01:22,880 --> 00:01:26,960
在卷积两个不同函数的情况下，我试图想出不同的方式来描述这可能意味着什么，对于其中一个，我有点恍然大悟，为什么正态分布起着这样的作用：它们以概率的形式出现，为什么它是函数的自然形状。

19
00:01:26,960 --> 00:01:30,720


20
00:01:30,720 --> 00:01:35,840


21
00:01:35,840 --> 00:01:40,320
但我有点超前了，有很多设置。

22
00:01:40,320 --> 00:01:44,800
在本视频中，我们的主要重点将放在离散情况上，特别是构建一个非常出乎意料但非常聪明的算法来计算这些情况。

23
00:01:44,800 --> 00:01:49,920


24
00:01:49,920 --> 00:01:54,400
我将对连续案例的讨论拉到第二部分。

25
00:01:57,840 --> 00:02:03,120
很容易打开图像处理示例，因为它们在视觉上是最有趣的，但是有一些挑剔之处使得图像处理案例不太能代表卷积的整体情况，所以让我们从概率开始，特别是最简单的例子之一，我相信这里的每个人都在他们生活中的某个时刻考虑过，那就是掷一对骰子并计算出看到各种不同总和的机会。

26
00:02:03,120 --> 00:02:06,880


27
00:02:06,880 --> 00:02:11,760


28
00:02:11,760 --> 00:02:15,520


29
00:02:15,520 --> 00:02:20,320


30
00:02:20,320 --> 00:02:25,600
你可能会说，不是问题，不是问题。 两个骰子中的每一个都有

31
00:02:25,600 --> 00:02:31,600
6 种不同的可能结果，这给了我们总共

32
00:02:31,600 --> 00:02:35,600
36 种不同的可能结果对，如果我们只查看它们，我们可以计算出有多少对具有给定的总和。

33
00:02:36,240 --> 00:02:41,120
将所有对排列在这样的网格中，一件非常好的事情是，所有具有恒定总和的对都沿着这些不同的对角线之一可见。

34
00:02:41,120 --> 00:02:47,040
因此，只需计算每个对角线上有多少个就可以告诉您看到特定总和的可能性有多大。

35
00:02:47,040 --> 00:02:51,920


36
00:02:52,880 --> 00:02:57,760
我想说，非常好，非常好，但是您能想到任何其他方式来形象化同一问题吗？

37
00:02:57,760 --> 00:03:03,120
可以想到其他图像来思考具有给定总和的所有不同对吗？

38
00:03:03,120 --> 00:03:08,800
也许你们中的一个人举起手说，是的，我有一个。 假设您连续想象这两组不同的可能性，但您翻转了第二行。

39
00:03:08,800 --> 00:03:14,560
这样，所有不同的对加起来就是七对，像这样垂直排列。

40
00:03:14,560 --> 00:03:20,160
如果我们将底行一直滑动到右侧，那么加起来为两个的独特的一对，即蛇眼，是唯一对齐的。

41
00:03:20,160 --> 00:03:24,880


42
00:03:24,880 --> 00:03:29,680
如果我将其放在右侧的一个单位上，则对齐的对是两对不同的，加起来为三对。

43
00:03:29,680 --> 00:03:35,440
一般来说，这个较低数组的不同偏移值（记住我必须首先翻转）显示具有给定总和的所有不同对。

44
00:03:35,440 --> 00:03:40,320


45
00:03:40,320 --> 00:03:48,800
就概率问题而言，这仍然不是特别有趣，因为我们所做的只是计算每个类别中有多少个结果。

46
00:03:48,800 --> 00:03:53,120


47
00:03:53,120 --> 00:03:57,280
但这是基于一个隐含的假设，即这些面孔出现的机会均等。

48
00:03:57,280 --> 00:04:02,240
但如果我告诉你我有一套不统一的特殊骰子怎么办？ 也许蓝色骰子有自己的一组数字来描述每张面出现的概率，而红色骰子有自己独特的一组数字。

49
00:04:02,240 --> 00:04:06,800


50
00:04:06,800 --> 00:04:11,920
在这种情况下，如果您想计算出看到 2

51
00:04:11,920 --> 00:04:17,360
的概率，您可以将蓝色骰子为 1 的概率乘以红色骰子为 1

52
00:04:17,360 --> 00:04:22,000
的概率。 对于看到

53
00:04:22,000 --> 00:04:26,880
3 的机会，您可以在可能的情况下查看两个不同的对，然后再次乘以相应的概率，然后将这两个乘积加在一起。

54
00:04:26,880 --> 00:04:32,240
类似地，看到四的机会涉及将三对不同的可能性相乘并将它们全部加在一起。

55
00:04:32,240 --> 00:04:36,320


56
00:04:36,320 --> 00:04:41,360
本着建立一些公式的精神，让我们将这些最高概率命名为 a1、a2、a3 等，并将最低概率命名为

57
00:04:41,360 --> 00:04:48,000
b1、b2、b3 等。 一般来说，在这个过程中，我们获取两个不同的数字数组，翻转第二个数组，然后将它们排列在各种不同的偏移值处，获取一堆成对的乘积并将它们相加，这就是其中之一思考什么是卷积的基本方法。

58
00:04:48,000 --> 00:04:52,080


59
00:04:52,080 --> 00:04:56,160


60
00:04:56,160 --> 00:05:00,960


61
00:05:00,960 --> 00:05:08,960
因此，为了更准确地说明这一点，通过这个过程，我们只是生成了看到两个、三个、四个、一直到 12

62
00:05:08,960 --> 00:05:13,840
的概率，并且我们通过将一个值列表 a

63
00:05:13,840 --> 00:05:20,080
和另一个值混合在一起来获得它们值列表，b。 用行话来说，我们会说这两个序列的卷积给出了这个新序列，即

64
00:05:20,080 --> 00:05:25,600
11 个值的新序列，每个值看起来都像是成对乘积的总和。

65
00:05:25,600 --> 00:05:30,160
如果您愿意，您可以考虑相同操作的另一种方法是首先创建所有成对乘积的表，然后沿着所有这些对角线相加。

66
00:05:30,160 --> 00:05:36,240


67
00:05:36,240 --> 00:05:41,120
同样，这是一种将这两个数字序列混合在一起以获得 11 个数字的新序列的方法。

68
00:05:41,120 --> 00:05:46,400
和滑动窗想的操作是一样的，只是换个角度。

69
00:05:46,960 --> 00:05:51,280
对其进行一些注释，您可能会看到这样的写法。 a

70
00:05:51,280 --> 00:05:57,200
和 b 的卷积（用这个小星号表示）是一个新列表，该列表的第 n 个元素看起来像一个和，并且该和遍历所有不同的索引对

71
00:05:57,200 --> 00:06:03,440
i 和 j，因此这些索引等于 n。

72
00:06:03,440 --> 00:06:09,440
这有点拗口，但是例如，如果 n 是 6，我们要检查的对是 1 和 5、2 和

73
00:06:09,440 --> 00:06:15,680
4、3 和 3、4 和 2、5 和 1，所有不同的对加起来至 6。

74
00:06:16,400 --> 00:06:20,640
但老实说，无论你怎么写，符号的重要性都比你头脑中的视觉效果要重要。

75
00:06:20,640 --> 00:06:26,320
在这里，也许做一个超级简单的例子会有所帮助，我可能会问你列表 1, 2, 3

76
00:06:26,320 --> 00:06:32,000
与列表 4, 5, 6 的卷积是多少。 您可能会想象将这两个列表都拿出来，翻转第二个列表，然后从其盖子开始一直向左移动。

77
00:06:32,000 --> 00:06:36,160


78
00:06:36,160 --> 00:06:41,200
然后对齐的一对值是 1 和

79
00:06:41,200 --> 00:06:45,680
4，将它们相乘，这就是我们输出的第一项。 将底部数组向右滑动一个单位，对齐的对是 1

80
00:06:45,680 --> 00:06:51,840
和 5、2 和 4，将这些对相乘，将它们加在一起，得到

81
00:06:51,840 --> 00:06:57,600
13，即输出中的下一个条目。 再把东西滑过来，我们需要 1 乘以 6，加上 2 乘以

82
00:06:57,600 --> 00:07:04,400
5，再加上 3 乘以 4，正好是 28。 再一张幻灯片，我们得到 2 乘以 6，加上

83
00:07:04,400 --> 00:07:10,000
3 乘以 5，得到 27，最后一项看起来像 3 乘以 6。

84
00:07:10,560 --> 00:07:14,080
如果您愿意，您可以调出您最喜欢的编程语言，以及您最喜欢的包含各种数值运算的库，并且您可以确认我没有骗您。

85
00:07:14,080 --> 00:07:18,640


86
00:07:18,640 --> 00:07:24,320
如果将 1、2、3 与 4、5、6 进行卷积，这确实是您将得到的结果。

87
00:07:24,880 --> 00:07:29,200
我们已经见过一种情况，这是一种自然且理想的操作，加起来就是概率分布，另一个常见的例子是移动平均线。

88
00:07:29,200 --> 00:07:34,640
想象一下，您有一个很长的数字列表，然后您又取了另一个较小的数字列表，这些数字的总和为

89
00:07:34,640 --> 00:07:39,920
1。 在本例中，我只有一个包含 5

90
00:07:39,920 --> 00:07:45,280
个值的小列表，它们都等于 1 5th。 然后，如果我们进行这个滑动窗口卷积过程，然后闭上眼睛，扫视一开始发生的情况，一旦我们较小的值列表与较大的值列表完全重叠，请考虑其中的每一项卷积的真正含义是。

91
00:07:45,280 --> 00:07:49,760


92
00:07:50,560 --> 00:07:55,120


93
00:07:55,680 --> 00:08:01,120
在每次迭代中，您所做的是将数据中的每个值乘以

94
00:08:01,120 --> 00:08:06,400
1

95
00:08:06,400 --> 00:08:12,080
五分之一，然后将它们全部加在一起，也就是说，您在这个小窗口内取数据的平均值。 总体而言，该过程为您提供了原始数据的平滑版本，您可以从不同的小数字列表开始修改它，只要该小列表加起来为

96
00:08:12,080 --> 00:08:16,800


97
00:08:16,800 --> 00:08:21,280
1，您仍然可以将其解释为移动平均的。

98
00:08:21,280 --> 00:08:25,840
在此所示的示例中，移动平均线将给予中心值更多的权重。

99
00:08:25,840 --> 00:08:30,720
这也会产生数据的平滑版本。

100
00:08:33,200 --> 00:08:37,840
如果你对此进行二维模拟，它会给你一个有趣的算法来模糊给定的图像。

101
00:08:37,840 --> 00:08:43,120
我应该说，我即将展示的动画是根据我最初为我与麻省理工学院的 Julia

102
00:08:43,120 --> 00:08:48,160
实验室一起为某个包含图像处理单元的 OpenCourseWare

103
00:08:48,160 --> 00:08:52,320
课程所做的一组讲座的一部分而制作的动画进行了修改。 在那里，我们做了更多的工作来深入研究所有这些背后的代码，所以如果您好奇，我会给您留下一些链接。

104
00:08:52,320 --> 00:08:56,640
但回到这个模糊的例子，发生的事情是我得到了这个小的

105
00:08:56,640 --> 00:09:01,440
3x3

106
00:09:01,440 --> 00:09:06,480
值网格，它沿着我们的原始图像行进，如果我们放大，这些值中的每一个都是

107
00:09:06,480 --> 00:09:11,120
1 9th，而我正在做的在每次迭代中，将每个值乘以它所在的相应像素。

108
00:09:11,120 --> 00:09:16,080
当然，在计算机科学中，我们将颜色视为三个值的小向量，代表红色、绿色和蓝色分量。

109
00:09:16,080 --> 00:09:20,400


110
00:09:20,400 --> 00:09:25,440
当我将所有这些小值乘以 1

111
00:09:25,440 --> 00:09:30,480
9 并将它们加在一起时，它会给出每个颜色通道的平均值，并且右侧图像的相应像素被定义为该总和。

112
00:09:30,480 --> 00:09:36,320
当我们对图像上的每个像素执行此操作时，总体效果是每种像素都会渗透到其所有邻居中，这给我们提供了比原始版本更模糊的版本。

113
00:09:36,320 --> 00:09:40,880


114
00:09:41,680 --> 00:09:46,640
用行话来说，我们会说右侧的图像是原始图像与一些值网格的卷积。

115
00:09:46,640 --> 00:09:52,000
或者从技术上讲，也许我应该说它是与那个小值网格的 180

116
00:09:52,000 --> 00:09:56,160
度旋转版本的卷积。 当网格对称时并不重要，但值得记住的是，从纯数学上下文继承的卷积定义应该始终邀请您考虑翻转第二个数组。

117
00:09:56,160 --> 00:10:00,720


118
00:10:00,720 --> 00:10:05,760


119
00:10:05,760 --> 00:10:10,240
如果我们稍微修改一下，我们可以通过选择不同的值网格来获得更优雅的模糊效果。

120
00:10:10,240 --> 00:10:15,920
在本例中，我有一个 5x5 的小网格，但区别并不在于它的大小。

121
00:10:15,920 --> 00:10:19,920
如果我们放大，我们会注意到中间的值比边缘的值大得多，这是因为它们都是从钟形曲线（称为高斯分布）中采样的。

122
00:10:19,920 --> 00:10:25,360


123
00:10:25,360 --> 00:10:30,240
这样，当我们将所有这些值乘以它们所在的相应像素时，我们就会为中心像素赋予更多权重，而为边缘像素赋予更少权重。

124
00:10:30,240 --> 00:10:35,200


125
00:10:35,200 --> 00:10:39,920
正如之前一样，右侧对应的像素被定义为这个总和。

126
00:10:39,920 --> 00:10:45,360
当我们对每个像素执行此过程时，它会产生模糊效果，更真实地模拟镜头失焦或类似情况的概念。

127
00:10:45,360 --> 00:10:49,760


128
00:10:49,760 --> 00:10:54,960
但模糊远不是你可以用这个想法做的唯一事情。 例如，看一下这个小值网格，其中左侧有一些正数，右侧有一些负数，我将分别用蓝色和红色着色。

129
00:10:54,960 --> 00:10:59,600


130
00:10:59,600 --> 00:11:04,480
花点时间看看您是否可以预测并理解这将对最终图像产生什么影响。

131
00:11:04,480 --> 00:11:11,680
因此，在这种情况下，我只会将图像视为灰度而不是彩色，因此每个像素仅由一个数字而不是三个数字表示。

132
00:11:11,680 --> 00:11:16,560


133
00:11:16,560 --> 00:11:21,280
值得注意的一件事是，当我们进行卷积时，可能会得到负值。

134
00:11:21,280 --> 00:11:26,240
例如，此时，如果我们放大小网格的左半部分，则完全位于黑色像素的顶部，其值为零，但负值的右半部分全部位于白色像素的顶部，这将值为

135
00:11:26,240 --> 00:11:30,960
1。

136
00:11:30,960 --> 00:11:35,360


137
00:11:36,000 --> 00:11:40,960
因此，当我们将相应项相乘并将它们加在一起时，结果将非常负，而我用右侧图像显示此结果的方式是将负值涂成红色，将正值涂成蓝色。

138
00:11:40,960 --> 00:11:45,120


139
00:11:45,120 --> 00:11:49,520
另一件需要注意的事情是，当你在一个颜色相同的补丁上时，所有的东西都会变为零，因为我们的小网格中的值的总和为零。

140
00:11:49,520 --> 00:11:55,680
这与前两个示例非常不同，前两个示例中我们的小网格的总和为

141
00:11:55,680 --> 00:11:59,680
1，这让我们将其解释为移动平均值，因此是模糊的。

142
00:11:59,680 --> 00:12:05,760
总而言之，这个小过程基本上可以检测当您从左向右移动时像素值存在变化的地方，因此它为您提供了一种从图像中拾取所有垂直边缘的方法。

143
00:12:05,760 --> 00:12:10,240


144
00:12:10,240 --> 00:12:13,760


145
00:12:16,560 --> 00:12:20,960
同样，如果我们旋转该网格，使其随着您从顶部移动到底部而变化，这将在所有水平边缘上出现，在我们的小馅饼生物图像的情况下，这确实会导致一些漂亮的恶魔眼睛。

146
00:12:20,960 --> 00:12:26,000


147
00:12:26,000 --> 00:12:31,520
顺便说一句，这个较小的网格通常称为内核，这里的美妙之处在于，通过选择不同的内核，您可以获得不同的图像处理效果，不仅模糊边缘检测，还可以实现锐化等效果。

148
00:12:31,520 --> 00:12:36,160


149
00:12:36,160 --> 00:12:40,240


150
00:12:40,240 --> 00:12:44,800
对于那些听说过卷积神经网络的人来说，其想法是使用数据来确定内核首先应该是什么，这取决于神经网络想要检测的内容。

151
00:12:44,800 --> 00:12:49,600


152
00:12:49,600 --> 00:12:55,120
我应该提出的另一件事是输出的长度。

153
00:12:55,120 --> 00:12:59,040
对于像移动平均这样的示例，您可能只想考虑两个窗口彼此完全对齐时的术语，或者在图像处理示例中，您可能希望最终输出具有与原始大小相同的大小。

154
00:12:59,040 --> 00:13:04,080


155
00:13:04,080 --> 00:13:09,200
现在，卷积作为一种纯数学运算总是会产生一个比您开始使用的两个数组更大的数组，至少假设其中一个数组的长度不为

156
00:13:09,200 --> 00:13:13,920
1。

157
00:13:13,920 --> 00:13:17,520
只需知道，在某些计算机科学环境中，您经常想要故意截断该输出。

158
00:13:17,520 --> 00:13:21,440


159
00:13:21,520 --> 00:13:29,200
另一件值得强调的事情是，在计算机科学背景下，在让它跨越原始内核之前翻转该内核的概念通常感觉非常奇怪并且没有必要，但再次注意，这是从纯数学背景继承的，就像我们一样从可能性来看，这是一件非常自然的事情。

160
00:13:29,200 --> 00:13:34,080


161
00:13:34,080 --> 00:13:38,960


162
00:13:38,960 --> 00:13:44,000
实际上，我可以向您展示另一个纯数学示例，即使是程序员也应该关心这个示例，因为它为更快的算法来计算所有这些打开了大门。

163
00:13:44,000 --> 00:13:48,480


164
00:13:48,480 --> 00:13:53,760
为了设置我所说的更快的意思，让我返回并再次拉起一些

165
00:13:53,760 --> 00:13:58,560
python，我将创建两个不同的相对较大的数组。

166
00:13:58,560 --> 00:14:02,880
每个都有十万个随机元素，我将评估 numpy

167
00:14:02,880 --> 00:14:08,640
库中卷积函数的运行时间。 在本例中，它运行多次不同的迭代，尝试找到平均值，在这台计算机上看起来至少平均值为

168
00:14:08,640 --> 00:14:12,800
4。

169
00:14:12,880 --> 00:14:18,640
87秒。 相比之下，如果我使用 scipy

170
00:14:18,640 --> 00:14:24,080
库中名为 fftconvolve 的不同函数，它是相同的函数，只是实现方式不同，只需要 4

171
00:14:24,080 --> 00:14:30,640
个函数。 平均为 3 毫秒，提高了三个数量级。

172
00:14:30,640 --> 00:14:34,800
再说一次，即使它以不同的名称飞行，它也提供与其他卷积函数相同的输出，它只是以更聪明的方式做一些事情。

173
00:14:34,800 --> 00:14:38,880


174
00:14:38,880 --> 00:14:46,800
还记得我在概率示例中说过的另一种思考卷积的方法是创建所有成对乘积的表，然后沿对角线将这些成对乘积相加。

175
00:14:46,800 --> 00:14:51,520


176
00:14:51,520 --> 00:14:56,560
当然，当你将两个不同的数字列表进行卷积时，概率没有什么特定的，你可以这样思考。

177
00:14:56,560 --> 00:15:00,880
使用所有成对乘积创建这种乘法表，然后沿对角线的每个和对应于您的最终输出之一。

178
00:15:00,880 --> 00:15:05,520


179
00:15:05,520 --> 00:15:11,680
这种观点特别自然的一种情况是当您将两个多项式相乘时。

180
00:15:11,680 --> 00:15:16,240
例如，让我使用已有的小网格，将顶部项替换为 1、2x 和 3x 平方，并将其他项替换为

181
00:15:16,240 --> 00:15:23,920
4、5x 和 6x 平方。

182
00:15:23,920 --> 00:15:27,920
现在考虑一下当我们在两个列表之间创建所有这些不同的成对乘积时意味着什么。

183
00:15:27,920 --> 00:15:32,960
你所做的本质上是展开我写下的两个多项式的完整乘积，然后当你沿着对应于收集所有相似项的对角线相加时，这非常整齐地展开多项式并收集相似项正是与卷积相同的过程。

184
00:15:32,960 --> 00:15:38,240


185
00:15:38,240 --> 00:15:43,920


186
00:15:43,920 --> 00:15:50,640
但这使我们能够做一些非常酷的事情，因为想想我们在这里所说的。

187
00:15:50,640 --> 00:15:55,360
我们的意思是，如果你采用两个不同的函数并将它们相乘，这是一个简单的逐点运算，这与你首先从每个函数中提取系数（假设它们是多项式）然后对这些函数进行卷积是一样的两个系数列表。

188
00:15:55,360 --> 00:16:00,560


189
00:16:00,560 --> 00:16:05,920


190
00:16:05,920 --> 00:16:11,840
有趣的是，卷积在原则上感觉比简单的乘法复杂得多，我不仅仅意味着在概念上它们更难思考，我的意思是在计算上它需要更多的步骤来执行卷积而不是执行两个不同列表的逐点乘积。

191
00:16:11,840 --> 00:16:16,560


192
00:16:16,560 --> 00:16:21,760


193
00:16:21,760 --> 00:16:27,040
例如，假设我给了你两个非常大的多项式，每个多项式都有一百个不同的系数，那么如果你将它们相乘的方式是展开这个乘积，你知道填充整个

194
00:16:27,040 --> 00:16:31,920
100 x

195
00:16:32,480 --> 00:16:37,520
100 的成对乘积网格，这需要你执行

196
00:16:37,520 --> 00:16:43,600
10,000 种不同的产品，然后当您沿着对角线收集所有相似项时，这是另一组大约

197
00:16:43,600 --> 00:16:48,560
10,000 次操作。

198
00:16:48,560 --> 00:16:55,200
更一般地说，在行话中，我们会说该算法是 O of n

199
00:16:55,200 --> 00:17:00,560
平方，这意味着对于两个大小为 n 的列表，操作数量与 n 的平方成正比。

200
00:17:00,560 --> 00:17:06,320
另一方面，如果我根据输出来考虑两个多项式，例如在一些输入处对它们的值进行采样，那么将它们相乘只需要与样本数一样多的运算，因为这又是一个逐点运算，并且对于多项式，您只需要有限多个样本能够恢复系数。

201
00:17:06,320 --> 00:17:11,680


202
00:17:11,680 --> 00:17:17,200


203
00:17:17,200 --> 00:17:22,400
例如，两个输出足以唯一地指定一个线性多项式，三个输出足以唯一地指定一个二次多项式，一般来说，如果您知道

204
00:17:22,400 --> 00:17:27,920
n

205
00:17:27,920 --> 00:17:33,680
个不同的输出，则足以唯一地指定具有

206
00:17:33,680 --> 00:17:38,800
n

207
00:17:38,800 --> 00:17:43,680
个不同系数的多项式，或者如果您愿意，我们可以用方程组的语言来表达这个假设我告诉你我有一些多项式，但我没有告诉你系数是什么，这些对你来说是个谜。

208
00:17:43,680 --> 00:17:47,840
在我们的示例中，您可能会认为这是我们试图找出的乘积，然后假设我说，如果您输入各种不同的输入（例如

209
00:17:47,840 --> 00:17:52,960


210
00:17:52,960 --> 00:17:59,600
0、1、2），我会告诉您该多项式的输出是什么，3，等等，我给你足够的，这样你就有了与未知数一样多的方程，它甚至碰巧是一个线性方程组，所以这很好，原则上至少这应该足以恢复系数。

211
00:17:59,600 --> 00:18:04,800


212
00:18:04,800 --> 00:18:09,840


213
00:18:09,840 --> 00:18:14,880


214
00:18:14,880 --> 00:18:20,160


215
00:18:20,160 --> 00:18:26,560


216
00:18:26,560 --> 00:18:32,720


217
00:18:32,720 --> 00:18:38,000


218
00:18:38,000 --> 00:18:43,120


219
00:18:43,120 --> 00:18:47,760


220
00:18:47,760 --> 00:18:53,520


221
00:18:53,520 --> 00:18:58,400


222
00:18:58,400 --> 00:19:04,240


223
00:19:04,240 --> 00:19:09,200


224
00:19:09,200 --> 00:19:13,600


225
00:19:13,600 --> 00:19:18,720


226
00:19:18,720 --> 00:19:23,840


227
00:19:23,840 --> 00:19:30,080


228
00:19:30,080 --> 00:19:34,400


229
00:19:34,400 --> 00:19:41,600


230
00:19:41,600 --> 00:19:46,480


231
00:19:46,480 --> 00:19:51,360


232
00:19:51,360 --> 00:19:57,600


233
00:19:57,600 --> 00:20:03,200


234
00:20:03,200 --> 00:20:08,160


235
00:20:08,160 --> 00:20:12,640


236
00:20:12,640 --> 00:20:17,520


237
00:20:17,520 --> 00:20:22,720


238
00:20:22,720 --> 00:20:28,320


239
00:20:28,320 --> 00:20:33,040


240
00:20:33,040 --> 00:20:38,080


241
00:20:38,080 --> 00:20:43,600


242
00:20:43,600 --> 00:20:48,640


243
00:20:48,640 --> 00:20:53,200


244
00:20:53,200 --> 00:20:58,960


245
00:20:58,960 --> 00:21:03,280


246
00:21:03,280 --> 00:21:08,960


247
00:21:08,960 --> 00:21:14,480


248
00:21:14,480 --> 00:21:18,480


249
00:21:18,480 --> 00:21:25,600


250
00:21:25,600 --> 00:21:30,560


251
00:21:30,560 --> 00:21:35,120


252
00:21:35,120 --> 00:21:39,600


253
00:21:39,600 --> 00:21:44,480


254
00:21:44,480 --> 00:21:50,160


255
00:21:50,160 --> 00:21:54,800


256
00:21:54,800 --> 00:21:59,360


257
00:21:59,360 --> 00:22:04,640


258
00:22:04,640 --> 00:22:10,720


259
00:22:10,720 --> 00:22:16,000


260
00:22:16,000 --> 00:22:20,720


261
00:22:20,720 --> 00:22:26,320


262
00:22:26,320 --> 00:22:31,280


263
00:22:31,280 --> 00:22:36,880


264
00:22:36,880 --> 00:22:51,040


