1
00:00:00,000 --> 00:00:04,480
2 つの異なる数値リスト、あるいはおそらく 2 つの異なる関数を与え、これら

2
00:00:04,480 --> 00:00:08,400
2 つのリストを組み合わせて新しい数値リストを得る方法、または 2

3
00:00:08,400 --> 00:00:14,000
つの関数を組み合わせて新しい関数を得る方法をすべて考えてもらいたいとします。 。 おそらく思い浮かぶ簡単な方法の 1

4
00:00:14,000 --> 00:00:18,640
つは、それらを用語ごとに単純に加算することです。 関数と同様に、対応するすべての出力を追加できます。

5
00:00:18,640 --> 00:00:24,000
同様に、2 つのリストを項ごとに乗算し、関数で同じことを行うこともできます。

6
00:00:24,000 --> 00:00:28,720
しかし、これらの両方と同じくらい基本的であるものの、あまり議論されていない、畳み込みとして知られる別の種類の組み合わせがあります。

7
00:00:28,720 --> 00:00:33,840


8
00:00:33,840 --> 00:00:38,240
ただし、前の 2 つのケースとは異なり、数値に対して実行できる操作から単に継承されるものではありません。

9
00:00:38,240 --> 00:00:43,360
これは、数値のリストや関数の組み合わせのコンテキストにおいては、まったく新しいものです。

10
00:00:43,360 --> 00:00:49,280
それらはあらゆる場所に表示され、画像処理で遍在し、確率論の中核となる構成要素であり、微分方程式を解く際によく使用されます。この名前では、2

11
00:00:49,280 --> 00:00:53,760
つの多項式を掛け合わせます。

12
00:00:53,760 --> 00:00:58,240


13
00:00:58,240 --> 00:01:03,440
視覚的な説明を仕事にしている者として、これは特に素晴らしいトピックです。なぜなら、文脈なしに孤立した定型的な定義は、ある意味威圧的に見えるかもしれないからです。しかし、時間をかけてそれが何を言っているのかを実際に解き明かし、その前に実際にその理由を動機づけることができれば、あなたはこのようなものを望むでしょう、それは信じられないほど美しい操作です。

14
00:01:03,440 --> 00:01:08,800


15
00:01:08,800 --> 00:01:14,080


16
00:01:14,080 --> 00:01:18,800


17
00:01:18,800 --> 00:01:22,880
そして、正直に言うと、このプロジェクトのビジュアルをまとめているときに、実際に少し学んだことがあります。

18
00:01:22,880 --> 00:01:26,960
2 つの異なる関数を畳み込む場合、私はそれが何を意味するのかを皆さんが想像できるさまざまな方法を考えようとしていたのですが、そのうちの

19
00:01:26,960 --> 00:01:30,720
1

20
00:01:30,720 --> 00:01:35,840
つについて、なぜ正規分布が次のような役割を果たすのかについて少し納得した瞬間がありました。確率的にそうなるのですが、なぜそれが関数にとって自然な形状なのでしょうか。

21
00:01:35,840 --> 00:01:40,320
しかし、私は先を行っています。そのためのセットアップはたくさんあります。

22
00:01:40,320 --> 00:01:44,800
このビデオでは、離散的なケース、特にこれらを計算するための非常に予想外だが非常に賢いアルゴリズムを構築することに主に焦点を当てます。

23
00:01:44,800 --> 00:01:49,920


24
00:01:49,920 --> 00:01:54,400
そして、継続的なケースの議論を第 2 部に引き出します。

25
00:01:57,840 --> 00:02:03,120
画像処理の例は視覚的に最も興味深いものであるため、画像処理の例から始めたくなるのは非常に魅力的ですが、画像処理の例が全体的に畳み込みをあまり表現していないようにするいくつかの注意点があるため、代わりに確率論的に物事を始めましょう。特に、ここにいる誰もが人生のある時点で考えたことがあると確信する最も単純な例の

26
00:02:03,120 --> 00:02:06,880
1

27
00:02:06,880 --> 00:02:11,760


28
00:02:11,760 --> 00:02:15,520
つは、サイコロを振って、さまざまな異なる金額が出る確率を計算することです。

29
00:02:15,520 --> 00:02:20,320


30
00:02:20,320 --> 00:02:25,600
そして、あなたは、問題ではない、問題ではない、と言うかもしれません。 2

31
00:02:25,600 --> 00:02:31,600
つのサイコロにはそれぞれ 6 つの異なる出目があるため、合計

32
00:02:31,600 --> 00:02:35,600
36 通りの異なる出目のペアが得られます。それらをすべて確認するだけで、指定された合計を持つペアがいくつあるかを数えることができます。

33
00:02:36,240 --> 00:02:41,120
このようにすべてのペアをグリッドに配置すると、合計が一定であるすべてのペアがこれらの異なる対角線の 1 つに沿って表示されるという非常に優れた点が

34
00:02:41,120 --> 00:02:47,040
1 つあります。 したがって、これらの対角線のそれぞれにいくつ存在するかを単純に数えるだけで、特定の合計が表示される可能性がわかります。

35
00:02:47,040 --> 00:02:51,920


36
00:02:52,880 --> 00:02:57,760
非常に良い、非常に良いと思いますが、同じ質問を視覚化する他の方法は考えられますか?

37
00:02:57,760 --> 00:03:03,120
特定の合計を持つすべての個別のペアについて考える他のイメージが思い浮かびますか?

38
00:03:03,120 --> 00:03:08,800
そしておそらく、皆さんのうちの 1 人が手を挙げて、「はい、持っています」と言うかもしれません。 これら 2

39
00:03:08,800 --> 00:03:14,560
つの異なる可能性のセットをそれぞれ 1 行に並べて描いたとしましょう。ただし、2 番目の行を反転するとします。 そうすれば、合計

40
00:03:14,560 --> 00:03:20,160
7 になるさまざまなペアがすべてこのように縦に並びます。 そして、その一番下の行を右端までスライドすると、合計で

41
00:03:20,160 --> 00:03:24,880
2 になるユニークなペア、つまり蛇の目だけが一致します。

42
00:03:24,880 --> 00:03:29,680
そして、それを 1 単位上に右にずらしてみると、整列するペアは 2

43
00:03:29,680 --> 00:03:35,440
つの異なるペアであり、合計すると 3 になります。 そして一般に、この下の配列のさまざまなオフセット値により、最初に反転する必要があったことを覚えていますが、指定された合計を持つすべての個別のペアが明らかになります。

44
00:03:35,440 --> 00:03:40,320


45
00:03:40,320 --> 00:03:48,800
確率に関する質問に関する限り、これはまだ特に興味深いものではありません。なぜなら、私たちがやっているのはこれらの各カテゴリーにどれだけの結果があるかを数えているだけだからです。

46
00:03:48,800 --> 00:03:53,120


47
00:03:53,120 --> 00:03:57,280
しかし、それは、これらの顔のそれぞれが出現する機会が等しいという暗黙の前提があります。

48
00:03:57,280 --> 00:04:02,240
しかし、統一されていない特別なサイコロのセットがあると言ったらどうなるでしょうか? おそらく、青いサイコロには、出現する各面の確率を表す独自の数字のセットがあり、赤いサイコロには、独自の異なる数字のセットがあるでしょう。

49
00:04:02,240 --> 00:04:06,800


50
00:04:06,800 --> 00:04:11,920
その場合、たとえば 2

51
00:04:11,920 --> 00:04:17,360
の目が出る確率を計算したい場合は、青いサイコロが 1 になる確率と、赤いサイコロが 1 になる確率を

52
00:04:17,360 --> 00:04:22,000
1 倍します。 そして、3 が表示される確率については、それが可能な場合は

53
00:04:22,000 --> 00:04:26,880
2 つの異なるペアを調べ、対応する確率を再度乗算して、それら 2

54
00:04:26,880 --> 00:04:32,240
つの積を加算します。 同様に、4

55
00:04:32,240 --> 00:04:36,320
が表示される確率には、3 つの異なる可能性のペアを掛け合わせ、それらをすべて加算することが含まれます。

56
00:04:36,320 --> 00:04:41,360
そして、いくつかの式を設定するという精神で、これらの上位の確率に a1、a2、a3 などの名前を付け、下位の確率に

57
00:04:41,360 --> 00:04:48,000
b1、b2、b3 などの名前を付けましょう。 そして一般に、このプロセスでは、2

58
00:04:48,000 --> 00:04:52,080
つの異なる数値配列を取得し、2

59
00:04:52,080 --> 00:04:56,160
番目の配列を反転して、それらをさまざまなオフセット値で並べ、多数のペアごとの積を取得してそれらを加算します。これは、次の 1

60
00:04:56,160 --> 00:05:00,960
つです。畳み込みとは何かについての基本的な考え方。

61
00:05:00,960 --> 00:05:08,960
もう少し正確に説明すると、このプロセスを通じて、2 つ、3 つ、4 つ、そして最大

62
00:05:08,960 --> 00:05:13,840
12 まで表示される確率を生成し、1 つの値のリスト a

63
00:05:13,840 --> 00:05:20,080
と別の値を混ぜ合わせてそれらを取得しました。値のリスト、b. 専門用語では、これら 2

64
00:05:20,080 --> 00:05:25,600
つのシーケンスの畳み込みにより、この新しいシーケンス、つまり 11 個の値の新しいシーケンスが得られ、それぞれがペアごとの積の和のように見えると言えます。

65
00:05:25,600 --> 00:05:30,160
必要に応じて、同じ演算を考える別の方法として、最初にすべてのペアごとの積の表を作成し、次にこれらすべての対角線に沿って合計するという方法もあります。

66
00:05:30,160 --> 00:05:36,240


67
00:05:36,240 --> 00:05:41,120
繰り返しますが、これは、これら 2 つの数値シーケンスを混ぜ合わせて、11 個の新しい数値シーケンスを取得する方法です。

68
00:05:41,120 --> 00:05:46,400
これは、スライド窓が考えた操作と同じですが、別の視点にすぎません。

69
00:05:46,960 --> 00:05:51,280
それにちょっとした注釈を付けて、次のように書きます。 この小さなアスタリスクで示されている a

70
00:05:51,280 --> 00:05:57,200
と b の畳み込みは新しいリストであり、そのリストの n 番目の要素は合計のように見えます。その合計は、すべての異なるインデックスのペア

71
00:05:57,200 --> 00:06:03,440
i と j にまたがります。つまり、次の合計はそれらのインデックスは n

72
00:06:03,440 --> 00:06:09,440
に等しくなります。 ちょっと長めの話ですが、たとえば、n が 6 の場合、ここで検討するペアは、1 と 5、2 と 4、3

73
00:06:09,440 --> 00:06:15,680
と 3、4 と 2、5 と 1 であり、すべての異なるペアを合計します。 6まで。

74
00:06:16,400 --> 00:06:20,640
しかし正直なところ、どのように書き留めても、プロセス中に頭の中に保持するビジュアルに比べれば、表記法は二の次の重要性を持っています。

75
00:06:20,640 --> 00:06:26,320
ここで、非常に単純な例を行うと役立つかもしれません。リスト 1、2、3 とリスト

76
00:06:26,320 --> 00:06:32,000
4、5、6 の畳み込みは何かと尋ねるかもしれません。 これらのリストを両方とも取得し、2

77
00:06:32,000 --> 00:06:36,160
番目のリストを裏返し、次にその蓋から左端まで進めていく様子を想像するかもしれません。

78
00:06:36,160 --> 00:06:41,200
次に、整列する値のペアは 1 と

79
00:06:41,200 --> 00:06:45,680
4 であり、それらを乗算すると、出力の最初の項が得られます。 一番下の配列を 1 単位右にスライドさせます。整列するペアは

80
00:06:45,680 --> 00:06:51,840
1 と 5、および 2 と 4 です。これらのペアを掛け合わせて加算すると、出力の次のエントリである

81
00:06:51,840 --> 00:06:57,600
13 が得られます。 もう一度スライドしてみると、1 × 6、プラス 2 × 5、プラス

82
00:06:57,600 --> 00:07:04,400
3 × 4 で、たまたま 28 になります。 もう 1 枚スライドすると、2 × 6、プラス

83
00:07:04,400 --> 00:07:10,000
3 × 5、つまり 27 が得られ、最終的に最後の項は 3 × 6 のようになります。

84
00:07:10,560 --> 00:07:14,080
必要に応じて、お気に入りのプログラミング言語や、さまざまな数値演算を含むお気に入りのライブラリを呼び出して、私が嘘をついていないことを確認してください。

85
00:07:14,080 --> 00:07:18,640


86
00:07:18,640 --> 00:07:24,320
1、2、3 と 4、5、6 の畳み込みを行うと、実際にこのような結果が得られます。

87
00:07:24,880 --> 00:07:29,200
これが自然で望ましい操作である確率分布への加算であるケースを 1 つ見てきました。もう

88
00:07:29,200 --> 00:07:34,640
1 つの一般的な例は移動平均です。 数値の長いリストがあり、すべて足すと

89
00:07:34,640 --> 00:07:39,920
1 になる小さな数値の別のリストを取得すると想像してください。 この場合、5 つの値の小さなリストがあり、それらはすべて

90
00:07:39,920 --> 00:07:45,280
5 分の 1 に等しいです。 次に、このスライディング

91
00:07:45,280 --> 00:07:49,760


92
00:07:50,560 --> 00:07:55,120
ウィンドウの畳み込みプロセスを実行し、目を閉じてその最初で何が起こっているかを徹底的に調べ、小さい値のリストが大きい値のリストと完全に重なったら、この中の各項が何であるかを考えてください。畳み込みというのは本当に意味します。

93
00:07:55,680 --> 00:08:01,120
各反復では、データの各値を

94
00:08:01,120 --> 00:08:06,400
1/5

95
00:08:06,400 --> 00:08:12,080
で乗算し、それらをすべて加算することになります。つまり、この小さなウィンドウ内のデータの平均を取ることになります。 全体として、このプロセスにより、元のデータの平滑化されたバージョンが得られます。これを、別の小さな数値リストから始めて変更することができます。その小さなリストの合計が

96
00:08:12,080 --> 00:08:16,800
1

97
00:08:16,800 --> 00:08:21,280
になる限り、それを移動データとして解釈できます。平均。

98
00:08:21,280 --> 00:08:25,840
ここに示す例では、移動平均により中心値により大きな重みが与えられます。

99
00:08:25,840 --> 00:08:30,720
これにより、データが平滑化されたバージョンになります。

100
00:08:33,200 --> 00:08:37,840
これを 2 次元で類似したものにすると、特定の画像をぼかすための楽しいアルゴリズムが得られます。

101
00:08:37,840 --> 00:08:43,120
そして、これから紹介するアニメーションは、画像処理ユニットを含む特定の OpenCourseWare クラスのために

102
00:08:43,120 --> 00:08:48,160
MIT の Julia

103
00:08:48,160 --> 00:08:52,320
Lab と行った一連の講義の一部として元々作成したものを変更したものであると言わなければなりません。 そこで、このすべての背後にあるコードを詳しく調べるためにもう少し作業を行ったので、興味があればいくつかのリンクを残しておきます。

104
00:08:52,320 --> 00:08:56,640
しかし、このぼやけた例に焦点を戻すと、何が起こっているのかというと、元の画像に沿って進んでいる値の小さな

105
00:08:56,640 --> 00:09:01,440
3x3

106
00:09:01,440 --> 00:09:06,480
グリッドがあり、ズームインすると、これらの値のそれぞれが 1

107
00:09:06,480 --> 00:09:11,120
9 であり、私が何をしているのかということです。各反復で、それらの値のそれぞれに、その上にある対応するピクセルが乗算されます。

108
00:09:11,120 --> 00:09:16,080
そしてもちろん、コンピューター サイエンスでは、色を、赤、緑、青の成分を表す

109
00:09:16,080 --> 00:09:20,400
3 つの値の小さなベクトルとして考えます。

110
00:09:20,400 --> 00:09:25,440
これらすべての小さな値に 1 9

111
00:09:25,440 --> 00:09:30,480
を乗算して加算すると、各カラー チャネルに沿った平均が得られ、右側の画像の対応するピクセルはその合計として定義されます。

112
00:09:30,480 --> 00:09:36,320
画像上のすべてのピクセルに対してこれを行うと、全体的な効果として、それぞれの種類が隣接するすべてのピクセルににじみ出て、元のピクセルよりもぼやけたバージョンが得られます。

113
00:09:36,320 --> 00:09:40,880


114
00:09:41,680 --> 00:09:46,640
専門用語では、右側の画像は、元の画像と値の小さなグリッドを畳み込んだものであると言えます。

115
00:09:46,640 --> 00:09:52,000
あるいは、より専門的に言えば、これは、値の小さなグリッドを 180

116
00:09:52,000 --> 00:09:56,160
度回転させたバージョンとの畳み込みであると言うべきかもしれません。 グリッドが対称であるかどうかは重要ではありませんが、純粋な数学のコンテキストから継承された畳み込みの定義では、常に

117
00:09:56,160 --> 00:10:00,720
2

118
00:10:00,720 --> 00:10:05,760
番目の配列を反転することを考慮する必要があることに留意する価値があります。

119
00:10:05,760 --> 00:10:10,240
これを少し変更すると、別の値のグリッドを選択することで、よりエレガントなぼかし効果を得ることができます。

120
00:10:10,240 --> 00:10:15,920
この場合、小さな 5x5 グリッドがありますが、違いはそのサイズではありません。

121
00:10:15,920 --> 00:10:19,920
ズームインすると、中央の値が端に向かう値よりもはるかに大きいことがわかります。これは、ガウス分布として知られる釣鐘曲線からすべてサンプリングされていることが原因です。

122
00:10:19,920 --> 00:10:25,360


123
00:10:25,360 --> 00:10:30,240
そうすることで、これらすべての値に、その上にある対応するピクセルを乗算するときに、その中央のピクセルに多くの重みを与え、端のピクセルには重みをあまり与えなくなります。

124
00:10:30,240 --> 00:10:35,200


125
00:10:35,200 --> 00:10:39,920
そして、前と同じように、右側の対応するピクセルがこの合計になるように定義されます。

126
00:10:39,920 --> 00:10:45,360
このプロセスをすべてのピクセルに対して実行することで、レンズの焦点を外したときなどの概念をより忠実にシミュレートするぼかし効果が得られます。

127
00:10:45,360 --> 00:10:49,760


128
00:10:49,760 --> 00:10:54,960
しかし、このアイデアでできることはぼかしだけではありません。 たとえば、この小さな値のグリッドを見てください。左側にはいくつかの正の数値が、右側にはいくつかの負の数値が含まれています。それぞれ青と赤で色付けします。

129
00:10:54,960 --> 00:10:59,600


130
00:10:59,600 --> 00:11:04,480
これが最終的な画像にどのような影響を与えるかを予測して理解できるかどうか、少し時間を取って確認してください。

131
00:11:04,480 --> 00:11:11,680
したがって、この場合、画像は色付きではなくグレースケールであると考えているため、各ピクセルは

132
00:11:11,680 --> 00:11:16,560
3 つの数字ではなく 1

133
00:11:16,560 --> 00:11:21,280
つの数字で表されます。 そして、注目すべき点の 1

134
00:11:21,280 --> 00:11:26,240
つは、この畳み込みを行うときに負の値が得られる可能性があることです。 たとえば、この時点でズームインすると、小さなグリッドの左半分は完全に黒いピクセルの上にあり、その値はゼロになりますが、負の値の右半分はすべて白いピクセルの上にあります。値は

135
00:11:26,240 --> 00:11:30,960
1

136
00:11:30,960 --> 00:11:35,360
です。

137
00:11:36,000 --> 00:11:40,960
したがって、対応する項を乗算して加算すると、結果は非常に負の値になります。これを右の画像で表示する方法は、負の値を赤、正の値を青に色付けることです。

138
00:11:40,960 --> 00:11:45,120


139
00:11:45,120 --> 00:11:49,520
もう 1

140
00:11:49,520 --> 00:11:55,680
つ注意すべき点は、すべて同じ色のパッチを使用している場合、小さなグリッド内の値の合計がゼロになるため、すべてがゼロになることです。 これは、小さなグリッドの合計が

141
00:11:55,680 --> 00:11:59,680
1 だった前の 2

142
00:11:59,680 --> 00:12:05,760
つの例とは大きく異なります。この例では、それを移動平均として解釈し、したがってぼやけています。 全体として、この小さなプロセスは基本的に、左から右に移動するときにピクセル値に変化がある場所を検出するため、画像からすべての垂直エッジを検出する一種の方法を提供します。

143
00:12:05,760 --> 00:12:10,240


144
00:12:10,240 --> 00:12:13,760


145
00:12:16,560 --> 00:12:20,960
同様に、上から下に移動するにつれてグリッドが変化するようにグリッドを回転すると、すべての水平エッジが検出され、小さなパイの生き物の画像の場合、かなり悪魔のような目が表示されます。

146
00:12:20,960 --> 00:12:26,000


147
00:12:26,000 --> 00:12:31,520
ちなみに、この小さなグリッドはカーネルと呼ばれることが多く、ここでの利点は、別のカーネルを選択するだけで、エッジ検出をぼかすだけでなくシャープ化などのさまざまな画像処理効果を得ることができることです。

148
00:12:31,520 --> 00:12:36,160


149
00:12:36,160 --> 00:12:40,240


150
00:12:40,240 --> 00:12:44,800
畳み込みニューラル ネットワークについて聞いたことがある方は、ニューラル

151
00:12:44,800 --> 00:12:49,600
ネットワークが検出したいものによって決定される、そもそもカーネルがどうあるべきかをデータを使用して判断するという概念があると思います。

152
00:12:49,600 --> 00:12:55,120
もう 1 つ取り上げるべき点は、出力の長さです。

153
00:12:55,120 --> 00:12:59,040
移動平均の例のような場合は、両方のウィンドウが互いに完全に一致するときの項のみを考慮する必要があるかもしれません。または、画像処理の例では、最終出力を元のサイズと同じサイズにしたいかもしれません。

154
00:12:59,040 --> 00:13:04,080


155
00:13:04,080 --> 00:13:09,200
純粋な数学演算としての畳み込みは、少なくともそのうちの

156
00:13:09,200 --> 00:13:13,920
1 つの長さが 1 ではないと仮定すると、最初に開始した

157
00:13:13,920 --> 00:13:17,520
2 つの配列よりも大きな配列を常に生成します。 特定のコンピューター

158
00:13:17,520 --> 00:13:21,440
サイエンスのコンテキストでは、その出力を意図的に切り捨てたいことがよくあることを知っておいてください。

159
00:13:21,520 --> 00:13:29,200
もう 1

160
00:13:29,200 --> 00:13:34,080
つ強調すべき価値があるのは、コンピューター

161
00:13:34,080 --> 00:13:38,960
サイエンスの文脈では、元のカーネルを実行する前にそのカーネルを反転するというこの概念は、非常に奇妙で必要のないものに感じることがよくありますが、それが純粋な数学の文脈から受け継がれているものであることにもう一度注意してください。確率的に見て、それは信じられないほど自然なことです。

162
00:13:38,960 --> 00:13:44,000
そして実際に、もう

163
00:13:44,000 --> 00:13:48,480
1

164
00:13:48,480 --> 00:13:53,760
つ純粋な数学の例をお見せします。これは、これらすべてを計算するためのより高速なアルゴリズムへの扉を開くものであるため、プログラマーでもこれに注意する必要があります。 ここで言う「高速化」をセットアップするために、戻って

165
00:13:53,760 --> 00:13:58,560
Python を再度起動し、2 つの異なる比較的大きな配列を作成します。

166
00:13:58,560 --> 00:14:02,880
それぞれには 10 万個のランダムな要素が含まれており、numpy

167
00:14:02,880 --> 00:14:08,640
ライブラリから convolve 関数の実行時間を評価します。 この場合、複数の異なる反復で実行し、平均値を見つけようとします。このコンピュータでは、少なくとも平均値は

168
00:14:08,640 --> 00:14:12,800
4 であるようです。

169
00:14:12,880 --> 00:14:18,640
87秒。 対照的に、fftconvolve という

170
00:14:18,640 --> 00:14:24,080
scipy ライブラリの別の関数を使用すると、同じものを別の方法で実装しただけで、必要な値は 4

171
00:14:24,080 --> 00:14:30,640
だけです。 平均 3 ミリ秒なので、3 桁も改善されます。

172
00:14:30,640 --> 00:14:34,800
また、別の名前で実行されているにもかかわらず、他の convolve

173
00:14:34,800 --> 00:14:38,880
関数が行うのと同じ出力を提供しており、より賢い方法で何かを行っているだけです。

174
00:14:38,880 --> 00:14:46,800
確率の例で、畳み込みについて考える別の方法として、すべてのペアごとの積のテーブルを作成し、それらのペアごとの積を対角線に沿って合計するという方法があると述べたことを思い出してください。

175
00:14:46,800 --> 00:14:51,520


176
00:14:51,520 --> 00:14:56,560
もちろん、このように考えることができる 2

177
00:14:56,560 --> 00:15:00,880
つの異なる数値リストを畳み込むときは、確率に特有のものは何もありません。 すべてのペアごとの積を使用してこの種の乗算表を作成すると、対角線に沿った各合計が最終出力の

178
00:15:00,880 --> 00:15:05,520
1 つに対応します。

179
00:15:05,520 --> 00:15:11,680
この見方が特に自然である状況の 1 つは、2 つの多項式を乗算する場合です。

180
00:15:11,680 --> 00:15:16,240
たとえば、すでにある小さなグリッドを使用して、最上位の項を 1、2x、および 3x の 2 乗に置き換え、他の項を

181
00:15:16,240 --> 00:15:23,920
4、5x、および 6x の 2 乗に置き換えてみましょう。

182
00:15:23,920 --> 00:15:27,920
ここで、2 つのリスト間でこれらの異なるペアごとの積をすべて作成することが何を意味するかを考えてみましょう。

183
00:15:27,920 --> 00:15:32,960
あなたがやっていることは、基本的に、私が書き留めた2つの多項式の全積を展開することであり、次に、対角線に沿って合計すると、すべての類似項を収集することに相当します。これは非常にきれいですが、多項式を拡張して類似項を収集すると、まさに次のとおりです。畳み込みと同じ処理です。

184
00:15:32,960 --> 00:15:38,240


185
00:15:38,240 --> 00:15:43,920


186
00:15:43,920 --> 00:15:50,640
しかし、これにより、非常に素晴らしいことができるようになります。なぜなら、ここで私たちが言っていることを考えてみてください。

187
00:15:50,640 --> 00:15:55,360
2

188
00:15:55,360 --> 00:16:00,560
つの異なる関数を取得し、それらを乗算する場合、これは単純な点単位の演算ですが、最初にそれらが多項式であると仮定してそれぞれの関数から係数を抽出し、次にそれらの畳み込みを計算したのと同じことです。係数の 2

189
00:16:00,560 --> 00:16:05,920
つのリスト。

190
00:16:05,920 --> 00:16:11,840
これが非常に興味深いのは、畳み込みは原理的に単純な乗算よりもはるかに複雑に感じられることです。概念的に考えるのが難しいというだけではなく、計算上、畳み込みを実行する方が、演算を実行するよりも多くのステップが必要になるということです。

191
00:16:11,840 --> 00:16:16,560
2

192
00:16:16,560 --> 00:16:21,760
つの異なるリストの点ごとの積。

193
00:16:21,760 --> 00:16:27,040
たとえば、それぞれが

194
00:16:27,040 --> 00:16:31,920
100 の異なる係数を持つ 2

195
00:16:32,480 --> 00:16:37,520
つの非常に大きな多項式を与えたとしましょう。その場合、それらを乗算する方法がこの積を拡張することである場合、このペア積の 100 x

196
00:16:37,520 --> 00:16:43,600
100 グリッド全体を埋める必要があることがわかります。 10,000

197
00:16:43,600 --> 00:16:48,560
の異なる製品を実行し、対角線に沿って同様の用語をすべて収集すると、さらに約 10,000 の操作のセットになります。

198
00:16:48,560 --> 00:16:55,200
より一般的には、このアルゴリズムは、サイズ n の 2 つのリストの場合、演算数が n の

199
00:16:55,200 --> 00:17:00,560
2 乗に比例するという意味で、アルゴリズムは O of n の 2 乗であると言えます。

200
00:17:00,560 --> 00:17:06,320
一方、出力の観点から

201
00:17:06,320 --> 00:17:11,680
2

202
00:17:11,680 --> 00:17:17,200
つの多項式について考える場合、たとえば、いくつかの入力で値をサンプリングし、それらを乗算する場合、これも点単位の演算であり、多項式を使用する場合のみ必要となるため、サンプルの数と同じ数の演算のみが必要です。係数を回復できる有限の多くのサンプル。

203
00:17:17,200 --> 00:17:22,400
たとえば、線形多項式を一意に指定するには

204
00:17:22,400 --> 00:17:27,920
2

205
00:17:27,920 --> 00:17:33,680
つの出力で十分です。二次多項式を一意に指定するには 3

206
00:17:33,680 --> 00:17:38,800
つの出力で十分です。一般に、n

207
00:17:38,800 --> 00:17:43,680
個の異なる出力がわかっている場合は、n 個の異なる係数を持つ多項式を一意に指定するには十分です。または、必要に応じて次のようにすることもできます。これを連立方程式の言語で表現してみてください。多項式があると言いましたが、その係数が何であるかはあなたには謎です。

208
00:17:43,680 --> 00:17:47,840
この例では、これを私たちが理解しようとしている積であると考えて、0、1、2

209
00:17:47,840 --> 00:17:52,960
などのさまざまな入力を入力した場合にこの多項式の出力がどのようになるかを説明するだけだと仮定します。

210
00:17:52,960 --> 00:17:59,600
,

211
00:17:59,600 --> 00:18:04,800
3,

212
00:18:04,800 --> 00:18:09,840
以降も、未知数と同じだけ多くの方程式が得られるように十分な数を与えます。それがたまたま線形連立方程式であることさえあるので、それは素晴らしいことであり、原理的には、少なくともこれで係数を回復するには十分なはずです。

213
00:18:09,840 --> 00:18:14,880


214
00:18:14,880 --> 00:18:20,160


215
00:18:20,160 --> 00:18:26,560


216
00:18:26,560 --> 00:18:32,720


217
00:18:32,720 --> 00:18:38,000


218
00:18:38,000 --> 00:18:43,120


219
00:18:43,120 --> 00:18:47,760


220
00:18:47,760 --> 00:18:53,520


221
00:18:53,520 --> 00:18:58,400


222
00:18:58,400 --> 00:19:04,240


223
00:19:04,240 --> 00:19:09,200


224
00:19:09,200 --> 00:19:13,600


225
00:19:13,600 --> 00:19:18,720


226
00:19:18,720 --> 00:19:23,840


227
00:19:23,840 --> 00:19:30,080


228
00:19:30,080 --> 00:19:34,400


229
00:19:34,400 --> 00:19:41,600


230
00:19:41,600 --> 00:19:46,480


231
00:19:46,480 --> 00:19:51,360


232
00:19:51,360 --> 00:19:57,600


233
00:19:57,600 --> 00:20:03,200


234
00:20:03,200 --> 00:20:08,160


235
00:20:08,160 --> 00:20:12,640


236
00:20:12,640 --> 00:20:17,520


237
00:20:17,520 --> 00:20:22,720


238
00:20:22,720 --> 00:20:28,320


239
00:20:28,320 --> 00:20:33,040


240
00:20:33,040 --> 00:20:38,080


241
00:20:38,080 --> 00:20:43,600


242
00:20:43,600 --> 00:20:48,640


243
00:20:48,640 --> 00:20:53,200


244
00:20:53,200 --> 00:20:58,960


245
00:20:58,960 --> 00:21:03,280


246
00:21:03,280 --> 00:21:08,960


247
00:21:08,960 --> 00:21:14,480


248
00:21:14,480 --> 00:21:18,480


249
00:21:18,480 --> 00:21:25,600


250
00:21:25,600 --> 00:21:30,560


251
00:21:30,560 --> 00:21:35,120


252
00:21:35,120 --> 00:21:39,600


253
00:21:39,600 --> 00:21:44,480


254
00:21:44,480 --> 00:21:50,160


255
00:21:50,160 --> 00:21:54,800


256
00:21:54,800 --> 00:21:59,360


257
00:21:59,360 --> 00:22:04,640


258
00:22:04,640 --> 00:22:10,720


259
00:22:10,720 --> 00:22:16,000


260
00:22:16,000 --> 00:22:20,720


261
00:22:20,720 --> 00:22:26,320


262
00:22:26,320 --> 00:22:31,280


263
00:22:31,280 --> 00:22:36,880


264
00:22:36,880 --> 00:22:51,040


