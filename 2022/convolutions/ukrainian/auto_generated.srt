1
00:00:00,000 --> 00:00:03,767
Припустімо, я даю вам два різні списки чисел або, можливо, дві різні функції,

2
00:00:03,767 --> 00:00:07,631
і я прошу вас подумати про всі способи, якими ви можете поєднати ці два списки,

3
00:00:07,631 --> 00:00:11,737
щоб отримати новий список чисел, або поєднати дві функції, щоб отримати нову функцію.

4
00:00:11,737 --> 00:00:14,140
Можливо, один простий спосіб, який спадає на думку,

5
00:00:14,140 --> 00:00:16,267
це просто скласти їх разом термін за терміном.

6
00:00:16,267 --> 00:00:20,050
Так само з функціями ви можете додати всі відповідні виходи.

7
00:00:20,050 --> 00:00:23,273
У подібному ключі ви також можете помножити два списки

8
00:00:23,273 --> 00:00:26,145
термін за терміном і зробити те саме з функціями.

9
00:00:26,145 --> 00:00:29,736
Але є ще один вид комбінації, такий же фундаментальний,

10
00:00:29,736 --> 00:00:33,840
як обидва, але набагато рідше обговорюваний, відомий як згортка.

11
00:00:33,840 --> 00:00:36,524
Але на відміну від попередніх двох випадків, це не те,

12
00:00:36,524 --> 00:00:39,893
що просто успадковано від операції, яку ви можете виконати з числами.

13
00:00:39,893 --> 00:00:44,716
Це щось справді нове для контексту списків чисел або комбінування функцій.

14
00:00:44,716 --> 00:00:48,080
Вони з’являються скрізь, вони всюдисущі в обробці зображень,

15
00:00:48,080 --> 00:00:52,105
це основна конструкція в теорії ймовірності, вони часто використовуються

16
00:00:52,105 --> 00:00:54,696
під час розв’язування диференціальних рівнянь,

17
00:00:54,696 --> 00:00:57,398
і в одному контексті ви майже напевно це бачили,

18
00:00:57,398 --> 00:01:00,210
якщо ні під цією назвою множить два поліноми разом.

19
00:01:00,210 --> 00:01:04,482
Для тих, хто займається візуальними поясненнями, це особливо чудова тема,

20
00:01:04,482 --> 00:01:09,389
тому що шаблонне визначення в ізоляції та без контексту може виглядати дещо лякаюче,

21
00:01:09,389 --> 00:01:13,315
але якщо ми приділимо час, щоб справді розгадати, що воно говорить,

22
00:01:13,315 --> 00:01:17,010
а перед тим фактично мотивувати, чому ви б хотіли щось подібне,

23
00:01:17,010 --> 00:01:18,800
це неймовірно красива операція.

24
00:01:18,800 --> 00:01:21,167
І я повинен визнати, що я дійсно дещо навчився,

25
00:01:21,167 --> 00:01:23,436
збираючи візуальні елементи для цього проекту.

26
00:01:23,436 --> 00:01:27,748
У випадку згортання двох різних функцій я намагався придумати різні способи,

27
00:01:27,748 --> 00:01:32,733
якими можна уявити, що це може означати, і з одним із них у мене виник невеликий момент,

28
00:01:32,733 --> 00:01:36,205
чому нормальні розподіли відіграють таку роль. вони ймовірно,

29
00:01:36,205 --> 00:01:38,445
чому це така природна форма для функції.

30
00:01:38,445 --> 00:01:41,580
Але я забігаю вперед, там багато налаштувань для цього.

31
00:01:41,580 --> 00:01:45,736
У цьому відео наша основна увага буде зосереджена лише на дискретному випадку, і,

32
00:01:45,736 --> 00:01:50,196
зокрема, на розробці дуже несподіваного, але дуже розумного алгоритму для їх обчислення.

33
00:01:50,196 --> 00:01:57,840
І я витягну обговорення безперервного випадку в другу частину.

34
00:01:57,840 --> 00:02:00,922
Дуже спокусливо розпочати приклади обробки зображень,

35
00:02:00,922 --> 00:02:04,804
оскільки вони візуально найбільш інтригуючі, але є кілька тонкощів,

36
00:02:04,804 --> 00:02:08,857
які роблять процес обробки зображень менш репрезентативним для звивин,

37
00:02:08,857 --> 00:02:12,396
тому замість цього давайте почнемо з ймовірності, і, зокрема,

38
00:02:12,396 --> 00:02:15,536
один із найпростіших прикладів, про який, я впевнений,

39
00:02:15,536 --> 00:02:20,388
кожен тут думав колись у своєму житті, а це кидання пари кубиків і визначення шансів

40
00:02:20,388 --> 00:02:21,530
побачити різні суми.

41
00:02:21,530 --> 00:02:24,170
І ви можете сказати, не проблема, не проблема.

42
00:02:24,170 --> 00:02:28,002
Кожен із ваших двох кубиків має шість різних можливих результатів,

43
00:02:28,002 --> 00:02:31,148
що дає нам загалом 36 різних можливих пар результатів,

44
00:02:31,148 --> 00:02:36,240
і якщо ми просто переглянемо їх усі, то зможемо порахувати, скільки пар мають певну суму.

45
00:02:36,240 --> 00:02:41,084
І якщо розташувати всі пари в подібній сітці, то одна дуже приємна річ полягає в тому,

46
00:02:41,084 --> 00:02:45,650
що всі пари, які мають постійну суму, видно вздовж однієї з цих різних діагоналей.

47
00:02:45,650 --> 00:02:50,239
Тож простий підрахунок кількості на кожній із цих діагоналей покаже вам,

48
00:02:50,239 --> 00:02:52,880
наскільки ймовірно ви побачите певну суму.

49
00:02:52,880 --> 00:02:55,615
І я б сказав, дуже добре, дуже добре, але чи можете ви

50
00:02:55,615 --> 00:02:58,699
придумати якісь інші способи візуалізації того самого питання?

51
00:02:58,699 --> 00:03:02,588
Інші образи, які можуть прийти в голову, щоб подумати про всі різні пари,

52
00:03:02,588 --> 00:03:03,744
які мають задану суму?

53
00:03:03,744 --> 00:03:07,550
І, можливо, хтось із вас підніме руку і скаже: «Так, у мене є».

54
00:03:07,550 --> 00:03:12,104
Скажімо, ви уявляєте ці два різні набори можливостей кожен у рядку,

55
00:03:12,104 --> 00:03:14,046
але ви гортаєте другий рядок.

56
00:03:14,046 --> 00:03:16,952
Таким чином усі різні пари, які в сумі становлять сім,

57
00:03:16,952 --> 00:03:18,960
вишиковуються вертикально таким чином.

58
00:03:18,960 --> 00:03:22,847
І якщо ми зсунемо цей нижній рядок до кінця вправо, тоді унікальна пара,

59
00:03:22,847 --> 00:03:26,309
яка в сумі додає два, очі змії, будуть єдиними, які вирівнюються.

60
00:03:26,309 --> 00:03:29,375
І якщо я переставлю це на одну одиницю праворуч, пари,

61
00:03:29,375 --> 00:03:32,886
які вирівнюються, є двома різними парами, які в сумі дають три.

62
00:03:32,886 --> 00:03:37,187
І загалом, різні значення зміщення цього нижнього масиву, які пам’ятають,

63
00:03:37,187 --> 00:03:41,778
що я мав спочатку перевернути, виявляють усі різні пари, які мають задану суму.

64
00:03:41,778 --> 00:03:47,413
Що стосується ймовірнісних питань, це все ще не особливо цікаво, тому що все,

65
00:03:47,413 --> 00:03:53,120
що ми робимо, це підраховуємо, скільки результатів є в кожній із цих категорій.

66
00:03:53,120 --> 00:03:57,850
Але це з неявним припущенням, що для кожного з цих облич є однакові шанси з’явитися.

67
00:03:57,850 --> 00:04:01,897
Але що, якби я сказав вам, що у мене є спеціальний набір неоднорідних кубиків?

68
00:04:01,897 --> 00:04:04,662
Можливо, блакитний кубик має свій власний набір чисел,

69
00:04:04,662 --> 00:04:07,276
що описує ймовірності для кожної грані, що випадає,

70
00:04:07,276 --> 00:04:09,740
а червоний кубик має свій унікальний набір чисел.

71
00:04:09,740 --> 00:04:13,822
У такому випадку, якби ви хотіли обчислити, скажімо, ймовірність побачити двійку,

72
00:04:13,822 --> 00:04:17,107
ви б помножили ймовірність того, що синій кубик дорівнює одиниці,

73
00:04:17,107 --> 00:04:19,895
на ймовірність того, що червоний кубик дорівнює одиниці.

74
00:04:19,895 --> 00:04:25,158
І щоб отримати шанси побачити трійку, ви дивитеся на дві різні пари, де це можливо,

75
00:04:25,158 --> 00:04:29,983
і знову множите відповідні ймовірності, а потім додаєте ці два добутки разом.

76
00:04:29,983 --> 00:04:33,280
Подібним чином шанси побачити четвірку включають множення

77
00:04:33,280 --> 00:04:36,748
разом трьох різних пар можливостей і додавання їх усіх разом.

78
00:04:36,748 --> 00:04:42,227
І в дусі створення деяких формул давайте назвемо ці найвищі ймовірності a1,

79
00:04:42,227 --> 00:04:45,903
a2, a3 і так далі, а нижні — b1, b2, b3 і так далі.

80
00:04:45,903 --> 00:04:51,132
І загалом, цей процес, коли ми беремо два різні масиви чисел, повертаємо другий,

81
00:04:51,132 --> 00:04:54,425
а потім шикуємо їх за різними значеннями зміщення,

82
00:04:54,425 --> 00:05:00,106
беремо купу попарних добутків і додаємо їх, це один із основні способи уявлення про те,

83
00:05:00,106 --> 00:05:01,139
що таке згортка.

84
00:05:01,139 --> 00:05:06,045
Щоб сформулювати це трохи точніше, за допомогою цього процесу ми просто

85
00:05:06,045 --> 00:05:11,429
згенерували ймовірності для того, щоб побачити два, три, чотири, і далі до 12,

86
00:05:11,429 --> 00:05:17,084
і ми отримали їх, змішавши разом один список значень, a та інший список значень, б.

87
00:05:17,084 --> 00:05:21,369
На жаргоні ми б сказали, що згортка цих двох послідовностей дає нам цю нову

88
00:05:21,369 --> 00:05:24,075
послідовність, нову послідовність з 11 значень,

89
00:05:24,075 --> 00:05:27,120
кожне з яких виглядає як деяка сума попарних добутків.

90
00:05:27,120 --> 00:05:31,829
Якщо ви віддаєте перевагу, інший спосіб, яким ви можете подумати про ту саму операцію,

91
00:05:31,829 --> 00:05:36,702
це спочатку створити таблицю всіх попарних добутків, а потім підсумувати всі ці діагоналі.

92
00:05:36,702 --> 00:05:40,060
Знову ж таки, це спосіб змішування цих двох послідовностей чисел,

93
00:05:40,060 --> 00:05:42,247
щоб отримати нову послідовність з 11 чисел.

94
00:05:42,247 --> 00:05:46,960
Це та сама операція, що і розсувні вікна, просто інша перспектива.

95
00:05:46,960 --> 00:05:50,314
Додавши до цього невеликі позначки, ось як ви можете це побачити.

96
00:05:50,314 --> 00:05:55,195
Згортка a і b, позначена цією маленькою зірочкою, є новим списком,

97
00:05:55,195 --> 00:06:01,606
і n-й елемент цього списку виглядає як сума, і ця сума охоплює всі різні пари індексів,

98
00:06:01,606 --> 00:06:04,738
i і j, так що сума ці індекси дорівнюють n.

99
00:06:04,738 --> 00:06:10,757
Це наче ковток, але, наприклад, якщо n дорівнює 6, то пари, які ми розглядаємо,

100
00:06:10,757 --> 00:06:16,400
це 1 і 5, 2 і 4, 3 і 3, 4 і 2, 5 і 1, усі різні пари, які складаються до 6.

101
00:06:16,400 --> 00:06:19,856
Але чесно кажучи, як би ви це не записали, нотація має другорядне значення

102
00:06:19,856 --> 00:06:23,082
порівняно з візуалом, який ви можете тримати в голові під час процесу.

103
00:06:23,082 --> 00:06:26,479
Тут, можливо, допоможе зробити дуже простий приклад,

104
00:06:26,479 --> 00:06:30,967
де я можу запитати вас, яка згортка списку 1, 2, 3 зі списком 4, 5, 6.

105
00:06:30,967 --> 00:06:34,067
Ви можете собі уявити, як ви берете обидва ці списки,

106
00:06:34,067 --> 00:06:37,857
гортаєте другий, а потім починаєте з його кришки до кінця ліворуч.

107
00:06:37,857 --> 00:06:40,334
Тоді пара значень, які вирівнюються, це 1 і 4,

108
00:06:40,334 --> 00:06:43,813
перемножуємо їх разом, і це дає нам перший член нашого результату.

109
00:06:43,813 --> 00:06:46,970
Посуньте цей нижній масив на одну одиницю вправо, пари,

110
00:06:46,970 --> 00:06:50,409
які вирівнюються, це 1 і 5, а також 2 і 4, помножте ці пари,

111
00:06:50,409 --> 00:06:54,300
додайте їх разом, і це дасть нам 13, наступний запис у наших виводах.

112
00:06:54,300 --> 00:06:57,757
Пересуньте все ще раз, і ми візьмемо 1 помножити на 6,

113
00:06:57,757 --> 00:07:01,591
плюс 2 помножити на 5, плюс 3 помножити на 4, що дорівнює 28.

114
00:07:01,591 --> 00:07:05,981
Ще один слайд, і ми отримаємо 2 помножити на 6 плюс 3 помножити на 5,

115
00:07:05,981 --> 00:07:10,560
і це дає нам 27, і нарешті останній член виглядатиме як 3 помножити на 6.

116
00:07:10,560 --> 00:07:13,237
Якщо ви хочете, ви можете вибрати будь-яку вашу улюблену мову

117
00:07:13,237 --> 00:07:16,950
програмування та вашу улюблену бібліотеку, яка містить різноманітні числові операції,

118
00:07:16,950 --> 00:07:18,807
і ви можете підтвердити, що я вам не брешу.

119
00:07:18,807 --> 00:07:24,880
Якщо ви візьмете згортку 1, 2, 3 проти 4, 5, 6, це справді результат, який ви отримаєте.

120
00:07:24,880 --> 00:07:28,168
Ми бачили один випадок, коли це природна і бажана операція,

121
00:07:28,168 --> 00:07:32,881
що додає до розподілу ймовірностей, і іншим поширеним прикладом було б ковзне середнє.

122
00:07:32,881 --> 00:07:37,666
Уявіть, що у вас є довгий список чисел, і ви берете ще один менший список чисел,

123
00:07:37,666 --> 00:07:38,788
які в сумі дають 1.

124
00:07:38,788 --> 00:07:43,381
У цьому випадку я маю невеликий список із 5 значень, і всі вони дорівнюють 15-му.

125
00:07:43,381 --> 00:07:48,595
Тоді, якщо ми зробимо цей процес згортання ковзного вікна, закриємо очі та заховаємо те,

126
00:07:48,595 --> 00:07:53,282
що відбувається на самому початку, як тільки наш менший список значень повністю

127
00:07:53,282 --> 00:07:58,554
збігається з більшим, подумайте про те, що означає кожен термін у цьому згортка насправді

128
00:07:58,554 --> 00:07:59,023
означає.

129
00:07:59,023 --> 00:08:05,245
На кожній ітерації ви множите кожне значення з ваших даних на 15 і додаєте їх усі разом,

130
00:08:05,245 --> 00:08:10,769
що означає, що ви берете середнє значення своїх даних у цьому маленькому вікні.

131
00:08:10,769 --> 00:08:15,011
Загалом, процес дає вам згладжену версію вихідних даних, і ви можете змінити це,

132
00:08:15,011 --> 00:08:18,887
починаючи з іншого невеликого списку чисел, і доки цей невеликий список у

133
00:08:18,887 --> 00:08:22,816
сумі дорівнює 1, ви все одно можете інтерпретувати це як рухливий середній.

134
00:08:22,816 --> 00:08:27,781
У наведеному тут прикладі ковзне середнє надає більшу вагу центральному значенню.

135
00:08:27,781 --> 00:08:33,200
Це також призводить до згладженої версії даних.

136
00:08:33,200 --> 00:08:35,484
Якщо ви зробите такий собі двовимірний аналог,

137
00:08:35,484 --> 00:08:38,594
ви отримаєте цікавий алгоритм для розмивання певного зображення.

138
00:08:38,594 --> 00:08:42,673
І я повинен сказати, що анімації, які я збираюся показати, змінені з того,

139
00:08:42,673 --> 00:08:45,284
що я спочатку створив для частини серії лекцій,

140
00:08:45,284 --> 00:08:48,928
які я проводив у Julia Lab в MIT для певного класу OpenCourseWare,

141
00:08:48,928 --> 00:08:50,887
який включав блок обробки зображень.

142
00:08:50,887 --> 00:08:54,155
Там ми зробили трохи більше, щоб зануритися в код, що стоїть за всім цим,

143
00:08:54,155 --> 00:08:56,452
тому, якщо вам цікаво, я залишу вам кілька посилань.

144
00:08:56,452 --> 00:08:59,656
Але повернемося до цього прикладу розмиття. Що відбувається,

145
00:08:59,656 --> 00:09:04,278
я маю маленьку сітку значень 3x3, яка рухається вздовж нашого оригінального зображення,

146
00:09:04,278 --> 00:09:07,429
і якщо ми збільшимо масштаб, кожне з цих значень буде 19-м,

147
00:09:07,429 --> 00:09:11,947
і що я роблю на кожній ітерації кожне з цих значень множиться на відповідний піксель,

148
00:09:11,947 --> 00:09:13,312
над яким воно знаходиться.

149
00:09:13,312 --> 00:09:17,646
І, звичайно, в інформатиці ми розглядаємо кольори як маленькі вектори трьох значень,

150
00:09:17,646 --> 00:09:20,400
що представляють червоний, зелений і синій компоненти.

151
00:09:20,400 --> 00:09:23,866
Коли я множу всі ці маленькі значення на 19 і додаю їх разом,

152
00:09:23,866 --> 00:09:27,053
це дає нам середнє значення по кожному колірному каналу,

153
00:09:27,053 --> 00:09:30,966
і відповідний піксель для зображення праворуч визначається як ця сума.

154
00:09:30,966 --> 00:09:35,480
Загальний ефект, оскільки ми робимо це для кожного окремого пікселя на зображенні,

155
00:09:35,480 --> 00:09:39,015
полягає в тому, що кожен піксель перетікає в усіх своїх сусідів,

156
00:09:39,015 --> 00:09:41,680
що дає нам більш розмиту версію, ніж оригінальна.

157
00:09:41,680 --> 00:09:44,740
На жаргоні ми б сказали, що зображення праворуч є згорткою

158
00:09:44,740 --> 00:09:47,800
нашого оригінального зображення з невеликою сіткою значень.

159
00:09:47,800 --> 00:09:50,286
Або більш технічно, можливо, я повинен сказати,

160
00:09:50,286 --> 00:09:54,430
що це згортка з поверненою на 180 градусів версією цієї маленької сітки значень.

161
00:09:54,430 --> 00:09:58,685
Не те, щоб це мало значення, коли сітка є симетричною, але просто варто пам’ятати,

162
00:09:58,685 --> 00:10:02,274
що визначення згортки, успадковане з чистого математичного контексту,

163
00:10:02,274 --> 00:10:05,760
має завжди спонукати вас подумати про гортання цього другого масиву.

164
00:10:05,760 --> 00:10:09,734
Якщо ми трохи змінимо це, ми зможемо отримати набагато елегантніший ефект розмиття,

165
00:10:09,734 --> 00:10:11,059
вибравши іншу сітку значень.

166
00:10:11,059 --> 00:10:13,570
У цьому випадку у мене невелика сітка 5x5, але

167
00:10:13,570 --> 00:10:15,920
відмінність полягає не стільки в її розмірі.

168
00:10:15,920 --> 00:10:19,997
Якщо ми збільшимо масштаб, то помітимо, що значення в середині набагато більше,

169
00:10:19,997 --> 00:10:22,494
ніж значення до країв, і це відбувається з того,

170
00:10:22,494 --> 00:10:26,010
що всі вони взяті з дзвоноподібної кривої, відомої як розподіл Гауса.

171
00:10:26,010 --> 00:10:29,619
Таким чином, коли ми множимо всі ці значення на відповідний піксель,

172
00:10:29,619 --> 00:10:33,961
над яким вони сидять, ми надаємо набагато більшої ваги цьому центральному пікселю,

173
00:10:33,961 --> 00:10:36,367
а тим, що знаходяться на краю, набагато менше.

174
00:10:36,367 --> 00:10:40,373
І так само, як і раніше, відповідний піксель праворуч визначається як ця сума.

175
00:10:40,373 --> 00:10:43,552
Оскільки ми виконуємо цей процес для кожного окремого пікселя,

176
00:10:43,552 --> 00:10:46,832
це дає ефект розмиття, який набагато достовірніше імітує поняття

177
00:10:46,832 --> 00:10:49,760
розміщення вашого об’єктива поза фокусом або щось подібне.

178
00:10:49,760 --> 00:10:53,474
Але розмиття - далеко не єдине, що ви можете зробити з цією ідеєю.

179
00:10:53,474 --> 00:10:56,253
Подивіться, наприклад, на цю невелику сітку значень,

180
00:10:56,253 --> 00:11:00,291
яка містить кілька додатних чисел ліворуч і кілька від’ємних чисел праворуч,

181
00:11:00,291 --> 00:11:03,071
які я розфарбую синім і червоним кольором відповідно.

182
00:11:03,071 --> 00:11:07,307
Знайдіть хвилинку, щоб перевірити, чи можете ви передбачити та зрозуміти,

183
00:11:07,307 --> 00:11:09,769
який вплив це матиме на кінцеве зображення.

184
00:11:09,769 --> 00:11:13,534
Тож у цьому випадку я буду думати про зображення як у градаціях сірого,

185
00:11:13,534 --> 00:11:18,082
а не як кольорове, тому кожен піксель буде представлено лише одним числом, а не трьома.

186
00:11:18,082 --> 00:11:21,539
І одна річ, яку варто зауважити, це те, що коли ми виконуємо цю згортку,

187
00:11:21,539 --> 00:11:23,102
можна отримати від’ємні значення.

188
00:11:23,102 --> 00:11:26,966
Наприклад, у цій точці тут, якщо ми збільшимо ліву половину нашої маленької сітки,

189
00:11:26,966 --> 00:11:29,527
вона буде повністю розташована поверх чорних пікселів,

190
00:11:29,527 --> 00:11:32,694
які матимуть нульове значення, але права половина від’ємних значень

191
00:11:32,694 --> 00:11:36,000
буде розташована поверх білих пікселів, що буде мають значення одиниці.

192
00:11:36,000 --> 00:11:39,109
Отже, коли ми перемножуємо відповідні члени та додаємо їх разом,

193
00:11:39,109 --> 00:11:42,362
результати будуть дуже негативними, і я відображаю це на зображенні

194
00:11:42,362 --> 00:11:46,046
праворуч — це фарбую від’ємні значення в червоний колір, а додатні — у синій.

195
00:11:46,046 --> 00:11:49,763
Ще одна річ, яку слід зауважити, це те, що коли ви перебуваєте на патчі,

196
00:11:49,763 --> 00:11:54,141
який має один колір, усе стає нульовим, оскільки сума значень у нашій маленькій сітці

197
00:11:54,141 --> 00:11:54,854
дорівнює нулю.

198
00:11:54,854 --> 00:11:57,405
Це дуже відрізняється від двох попередніх прикладів,

199
00:11:57,405 --> 00:12:01,401
де сума нашої маленької сітки була одиницею, що дозволило нам інтерпретувати її як

200
00:12:01,401 --> 00:12:02,990
ковзне середнє і, отже, розмиття.

201
00:12:02,990 --> 00:12:07,779
Загалом, цей маленький процес виявляє будь-які коливання значення

202
00:12:07,779 --> 00:12:12,641
пікселів під час руху зліва направо, і тому він дає вам своєрідний

203
00:12:12,641 --> 00:12:16,560
спосіб виявити всі вертикальні краї вашого зображення.

204
00:12:16,560 --> 00:12:20,118
І так само, якщо ми обертаємо цю сітку так, щоб вона змінювалася,

205
00:12:20,118 --> 00:12:24,810
коли ви рухаєтеся від верху до низу, це буде підбиратися на всіх горизонтальних краях,

206
00:12:24,810 --> 00:12:29,123
що у випадку з нашим маленьким зображенням пиріжкової істоти призведе до гарних

207
00:12:29,123 --> 00:12:29,986
демонічних очей.

208
00:12:29,986 --> 00:12:33,665
Цю меншу сітку, до речі, часто називають ядром, і принадність тут полягає в тому,

209
00:12:33,665 --> 00:12:37,300
що просто вибравши інше ядро, ви можете отримати різні ефекти обробки зображень,

210
00:12:37,300 --> 00:12:40,710
не лише розмиваючи виявлення країв, але й такі речі, як збільшення різкості.

211
00:12:40,710 --> 00:12:44,657
Для тих із вас, хто чув про згорточну нейронну мережу, ідея полягає в тому,

212
00:12:44,657 --> 00:12:48,709
щоб використовувати дані, щоб з’ясувати, якими мають бути ядра в першу чергу,

213
00:12:48,709 --> 00:12:51,618
як це визначається тим, що нейронна мережа хоче виявити.

214
00:12:51,618 --> 00:12:55,378
Інша річ, яку я, можливо, повинен згадати, це довжина виводу.

215
00:12:55,378 --> 00:12:59,505
Для чогось на кшталт прикладу ковзного середнього ви можете думати лише про терміни,

216
00:12:59,505 --> 00:13:03,827
коли обидва вікна повністю вирівнюються одне з одним, або у прикладі обробки зображення,

217
00:13:03,827 --> 00:13:07,760
можливо, ви хочете, щоб кінцевий результат мав такий самий розмір, як і оригінал.

218
00:13:07,760 --> 00:13:11,218
Тепер згортки як чиста математична операція завжди створюють масив,

219
00:13:11,218 --> 00:13:14,473
більший за два масиви, з яких ви почали, принаймні припускаючи,

220
00:13:14,473 --> 00:13:16,405
що один із них не має довжини одиниці.

221
00:13:16,405 --> 00:13:19,097
Просто знайте, що в певних контекстах інформатики

222
00:13:19,097 --> 00:13:21,520
ви часто хочете навмисно скоротити цей вихід.

223
00:13:21,520 --> 00:13:24,677
Ще одна річ, яку варто підкреслити, полягає в тому,

224
00:13:24,677 --> 00:13:28,442
що в контексті інформатики це поняття гортати ядро перед тим,

225
00:13:28,442 --> 00:13:33,846
як ви дасте йому пройти через оригінал, часто здається дуже дивним і просто непотрібним,

226
00:13:33,846 --> 00:13:39,068
але знову зауважте, що це те, що успадковано від чистого математичного контексту, де,

227
00:13:39,068 --> 00:13:42,530
як ми бачив з ймовірністю, що це неймовірно природна річ.

228
00:13:42,530 --> 00:13:45,794
І фактично я можу показати вам ще один чистий математичний приклад,

229
00:13:45,794 --> 00:13:48,146
про який навіть програмісти повинні піклуватися,

230
00:13:48,146 --> 00:13:52,370
тому що він відкриває двері для набагато швидшого алгоритму для обчислення всього цього.

231
00:13:52,370 --> 00:13:54,716
Щоб налаштувати те, що я маю на увазі під швидшим тут,

232
00:13:54,716 --> 00:13:57,233
дозвольте мені повернутися і знову витягнути якийсь пітон,

233
00:13:57,233 --> 00:13:59,579
і я збираюся створити два різні відносно великі масиви.

234
00:13:59,579 --> 00:14:02,997
У кожному з них буде сто тисяч випадкових елементів,

235
00:14:02,997 --> 00:14:07,575
і я збираюся оцінити час виконання функції convolve з бібліотеки numpy.

236
00:14:07,575 --> 00:14:10,632
І в цьому випадку він запускає його для кількох різних ітерацій,

237
00:14:10,632 --> 00:14:12,936
намагається знайти середнє значення, і виглядає,

238
00:14:12,936 --> 00:14:16,321
що на цьому комп’ютері принаймні середнє значення становить 4.87 секунд.

239
00:14:16,321 --> 00:14:21,094
На відміну від цього, якщо я використовую іншу функцію з бібліотеки scipy

240
00:14:21,094 --> 00:14:25,673
під назвою fftconvolve, яка є тією самою, лише реалізованою по-іншому,

241
00:14:25,673 --> 00:14:30,640
що займає лише 4.У середньому 3 мілісекунди, тобто покращення на три порядки.

242
00:14:30,640 --> 00:14:33,444
І знову ж таки, незважаючи на те, що він літає під іншою назвою,

243
00:14:33,444 --> 00:14:35,989
він видає той самий результат, що й інша функція convolve,

244
00:14:35,989 --> 00:14:38,880
але він просто робить щось, щоб зробити це більш розумним способом.

245
00:14:38,880 --> 00:14:43,429
Пам’ятайте, як у прикладі ймовірності я сказав, що ще один спосіб,

246
00:14:43,429 --> 00:14:48,997
яким ви можете думати про згортку, це створити цю таблицю всіх попарних добутків,

247
00:14:48,997 --> 00:14:52,528
а потім додати ці попарні добутки вздовж діагоналей.

248
00:14:52,528 --> 00:14:55,276
Звичайно, немає нічого конкретного щодо ймовірності,

249
00:14:55,276 --> 00:14:59,321
коли ви складаєте два різні списки чисел, ви можете думати про це таким чином.

250
00:14:59,321 --> 00:15:02,397
Створіть таку таблицю множення з усіма попарними продуктами,

251
00:15:02,397 --> 00:15:06,381
а потім кожна сума по діагоналі відповідає одному з ваших кінцевих результатів.

252
00:15:06,381 --> 00:15:12,431
Один контекст, де цей погляд особливо природний, це коли ви множите разом два поліноми.

253
00:15:12,431 --> 00:15:17,355
Наприклад, дозвольте мені взяти маленьку сітку, яку ми вже маємо,

254
00:15:17,355 --> 00:15:23,920
і замінити верхні члени на 1, 2x і 3x у квадраті, а інші члени на 4, 5x і 6x у квадраті.

255
00:15:23,920 --> 00:15:26,362
А тепер подумайте, що це означає, коли ми створюємо

256
00:15:26,362 --> 00:15:28,664
всі ці різні попарні продукти між двома списками.

257
00:15:28,664 --> 00:15:33,135
Те, що ви робите, по суті, розширюєте повний добуток двох поліномів,

258
00:15:33,135 --> 00:15:36,893
які я записав, а потім, коли ви додаєте вздовж діагоналі,

259
00:15:36,893 --> 00:15:41,299
яка відповідає збору всіх подібних доданків, що є досить акуратним,

260
00:15:41,299 --> 00:15:46,937
розширюючи поліном і збираючи подібні доданки, це точно той самий процес, що й згортка.

261
00:15:46,937 --> 00:15:52,642
Але це дозволяє нам робити щось дуже круте, тому що подумайте про те, що ми тут говоримо.

262
00:15:52,642 --> 00:15:57,170
Ми говоримо, що якщо ви берете дві різні функції та перемножуєте їх разом,

263
00:15:57,170 --> 00:16:00,128
що є простою поточковою операцією, це те ж саме,

264
00:16:00,128 --> 00:16:04,294
що якби ви спочатку витягли коефіцієнти з кожної з них, припускаючи,

265
00:16:04,294 --> 00:16:08,761
що вони є поліномами, а потім зробили згортку цих два списки коефіцієнтів.

266
00:16:08,761 --> 00:16:12,905
Що робить це таким цікавим, так це те, що згортки в принципі здаються набагато

267
00:16:12,905 --> 00:16:16,891
складнішими, ніж просте множення, і я маю на увазі не просто концептуально,

268
00:16:16,891 --> 00:16:21,402
що про них важче думати, я маю на увазі, що з обчислювальної точки зору для виконання

269
00:16:21,402 --> 00:16:26,070
згортки потрібно більше кроків, ніж для виконання поточковий добуток двох різних списків.

270
00:16:26,070 --> 00:16:30,111
Наприклад, скажімо, я дав вам два справді великі поліноми, скажімо,

271
00:16:30,111 --> 00:16:33,975
кожен із сотнею різних коефіцієнтів, тоді, якби ви їх помножили,

272
00:16:33,975 --> 00:16:38,611
щоб розширити цей добуток, який ви знаєте, заповнивши всю цю сітку 100 на 100

273
00:16:38,611 --> 00:16:43,128
попарних добутків, що вимагатиме від вас виконайте 10 000 різних продуктів,

274
00:16:43,128 --> 00:16:46,992
а потім, коли ви збираєте всі подібні терміни вздовж діагоналей,

275
00:16:46,992 --> 00:16:49,666
це ще один набір приблизно з 10 000 операцій.

276
00:16:49,666 --> 00:16:54,188
У більш загальному жаргоні ми б сказали, що алгоритм є O з n у квадраті,

277
00:16:54,188 --> 00:16:57,409
що означає для двох списків розміром n таким чином,

278
00:16:57,409 --> 00:17:00,816
що кількість масштабів операцій пропорційна квадрату n.

279
00:17:00,816 --> 00:17:05,671
З іншого боку, якщо я думаю про два поліноми в термінах їхніх виходів, наприклад,

280
00:17:05,671 --> 00:17:08,513
вибірка їхніх значень на кількох вхідних даних,

281
00:17:08,513 --> 00:17:12,422
тоді їх множення потребує лише стільки операцій, скільки вибірок,

282
00:17:12,422 --> 00:17:17,514
оскільки це знову ж таки поточкова операція, а з поліномами вам потрібно лише кінцеву

283
00:17:17,514 --> 00:17:21,126
кількість вибірок, щоб мати можливість відновити коефіцієнти.

284
00:17:21,152 --> 00:17:25,214
Наприклад, двох виходів достатньо, щоб однозначно визначити лінійний поліном.

285
00:17:25,214 --> 00:17:29,360
Трьох вихідних даних було б достатньо, щоб однозначно визначити квадратичний поліном.

286
00:17:29,360 --> 00:17:33,069
І взагалі, якщо ви знаєте n різних виходів, цього достатньо,

287
00:17:33,069 --> 00:17:36,901
щоб однозначно вказати поліном, який має n різних коефіцієнтів.

288
00:17:36,901 --> 00:17:41,188
Або, якщо хочете, ми могли б сформулювати це мовою систем рівнянь.

289
00:17:41,188 --> 00:17:43,664
Уявіть, що я кажу вам, що у мене є якийсь поліном,

290
00:17:43,664 --> 00:17:46,480
але я не кажу вам, які це коефіцієнти, це для вас загадка.

291
00:17:46,480 --> 00:17:50,666
У нашому прикладі ви можете подумати про це як про продукт, який ми намагаємося з’ясувати.

292
00:17:50,666 --> 00:17:55,710
Тоді припустімо, я кажу, що я просто скажу вам, якими були б результати цього полінома,

293
00:17:55,710 --> 00:18:00,524
якби ви ввели різні вхідні дані, такі як 0, 1, 2, 3, і далі, і я дам вам достатньо,

294
00:18:00,524 --> 00:18:03,791
щоб у вас було стільки рівнянь, скільки у вас є невідомі.

295
00:18:03,791 --> 00:18:07,245
Це навіть лінійна система рівнянь, так що це добре.

296
00:18:07,245 --> 00:18:11,137
Принаймні в принципі цього має бути достатньо для відновлення коефіцієнтів.

297
00:18:11,137 --> 00:18:14,383
Таким чином, приблизний нарис алгоритму буде такий: щоразу,

298
00:18:14,383 --> 00:18:19,253
коли ви хочете згорнути два списки чисел, ви розглядаєте їх як коефіцієнти двох поліномів.

299
00:18:19,253 --> 00:18:22,989
Ви відбираєте ці поліноми з достатньою кількістю виходів,

300
00:18:22,989 --> 00:18:26,726
множите ці зразки поточково, а потім розв’язуєте систему,

301
00:18:26,726 --> 00:18:31,364
щоб відновити коефіцієнти як прихований бекдорний спосіб знайти згортку.

302
00:18:31,364 --> 00:18:35,784
І як я вже казав, принаймні, дехто з вас міг би справедливо скаржитися:

303
00:18:35,784 --> 00:18:37,564
«Гранте, це ідіотський план».

304
00:18:37,564 --> 00:18:42,186
Тому що, з одного боку, просто обчислення всіх цих зразків для одного з поліномів,

305
00:18:42,186 --> 00:18:45,360
які ми знаємо, уже займає порядок n квадратних операцій,

306
00:18:45,360 --> 00:18:48,980
не кажучи вже про те, що розв’язування цієї системи, безперечно,

307
00:18:48,980 --> 00:18:52,656
буде обчислювально таким же складним, як просто виконання згортки.

308
00:18:52,656 --> 00:18:56,527
Отже, звичайно, у нас є зв’язок між множенням і згортками,

309
00:18:56,527 --> 00:19:01,054
але вся складність виникає при перекладі з однієї точки зору на іншу.

310
00:19:01,054 --> 00:19:05,817
Але є хитрість, і ті з вас, хто знає про перетворення Фур’є та алгоритм БПФ,

311
00:19:05,817 --> 00:19:07,673
можуть зрозуміти, куди це йде.

312
00:19:07,673 --> 00:19:10,505
Якщо ви не знайомі з цими темами, те, що я збираюся сказати,

313
00:19:10,505 --> 00:19:12,176
може здатися абсолютно несподіваним.

314
00:19:12,176 --> 00:19:15,697
Просто знайте, що є певні шляхи, якими ви могли б пройти в математиці,

315
00:19:15,697 --> 00:19:17,582
які роблять цей крок більш очікуваним.

316
00:19:17,582 --> 00:19:20,697
В основному ідея полягає в тому, що ми маємо тут свободу вибору.

317
00:19:20,697 --> 00:19:25,583
Якщо замість довільного набору вхідних даних, таких як 0, 1, 2, 3, і далі,

318
00:19:25,583 --> 00:19:30,080
ви обираєте обчислення спеціально вибраного набору комплексних чисел.

319
00:19:30,080 --> 00:19:34,894
Зокрема ті, які рівномірно розташовані на одиничному колі, відомі як корені єдності.

320
00:19:34,894 --> 00:19:37,364
Це дає нам більш дружню систему.

321
00:19:37,364 --> 00:19:40,083
Основна ідея полягає в тому, що, знайшовши число,

322
00:19:40,083 --> 00:19:44,324
у якому відбір його потужностей потрапляє в цей циклічний шаблон, це означає,

323
00:19:44,324 --> 00:19:48,401
що система, яку ми створюємо, матиме багато надлишкових у різних термінах,

324
00:19:48,401 --> 00:19:53,131
які ви обчислюєте, і якщо ми розумно розберемося, як Ви використовуєте цю надмірність,

325
00:19:53,131 --> 00:19:55,252
ви можете заощадити собі багато роботи.

326
00:19:55,252 --> 00:19:58,738
Цей набір результатів, який я написав, має спеціальну назву,

327
00:19:58,738 --> 00:20:02,166
він називається дискретним перетворенням Фур’є коефіцієнтів.

328
00:20:02,166 --> 00:20:05,614
І якщо ви хочете дізнатися більше, я прочитав ще одну лекцію для того самого класу

329
00:20:05,614 --> 00:20:09,103
Джулії в Массачусетському технологічному інституті про дискретні перетворення Фур’є.

330
00:20:09,103 --> 00:20:12,017
Також на каналі reducible є справді чудове відео,

331
00:20:12,017 --> 00:20:17,263
де розповідається про швидке перетворення Фур’є, яке є алгоритмом для швидшого обчислення.

332
00:20:17,263 --> 00:20:20,461
Крім того, Veritasium нещодавно зняв дуже гарне відео про ШПФ,

333
00:20:20,461 --> 00:20:21,984
тому у вас є багато варіантів.

334
00:20:21,984 --> 00:20:24,786
І цей швидкий алгоритм справді є головним для нас.

335
00:20:24,786 --> 00:20:28,255
Знову ж таки, через усю цю надлишковість існує метод переходу від

336
00:20:28,255 --> 00:20:32,722
коефіцієнтів до всіх цих виходів, де замість виконання операцій порядку n квадратів,

337
00:20:32,722 --> 00:20:35,929
ви виконуєте порядок порядку n помножених на log n операцій,

338
00:20:35,929 --> 00:20:39,293
що є набагато набагато краще, якщо ви масштабуєте великі списки.

339
00:20:39,293 --> 00:20:42,386
І що важливо, цей алгоритм FFT працює в обох напрямках.

340
00:20:42,386 --> 00:20:45,515
Це також дозволяє переходити від результатів до коефіцієнтів.

341
00:20:45,515 --> 00:20:49,054
Отже, об’єднавши все це, давайте поглянемо на схему нашого алгоритму.

342
00:20:49,054 --> 00:20:53,358
Тепер ми можемо сказати, що коли вам дають два довгі списки чисел і ви хочете

343
00:20:53,358 --> 00:20:57,662
взяти їх згортку, спочатку обчисліть швидке перетворення Фур’є кожного з них,

344
00:20:57,662 --> 00:21:02,131
що в глибині вашої свідомості ви можете просто подумати як трактувати їх як вони

345
00:21:02,131 --> 00:21:06,766
є коефіцієнтами полінома та оцінюють його за дуже спеціально вибраним набором точок.

346
00:21:06,766 --> 00:21:10,385
Потім помножте два результати, які ви щойно отримали, по точках,

347
00:21:10,385 --> 00:21:14,504
що добре та швидко, а потім виконайте зворотне швидке перетворення Фур’є,

348
00:21:14,504 --> 00:21:18,847
і ви отримаєте прихований бекдорний спосіб обчислення згортки, який ми шукали.

349
00:21:18,847 --> 00:21:22,957
Але цього разу він включає лише O з n log n операцій.

350
00:21:22,957 --> 00:21:24,865
Для мене це дуже круто!

351
00:21:24,865 --> 00:21:29,347
Цей дуже специфічний контекст, де згортки з’являються, множачи два поліноми,

352
00:21:29,347 --> 00:21:34,235
відкриває двері для алгоритму, який актуальний скрізь, де можуть з’являтися згортки.

353
00:21:34,235 --> 00:21:37,923
Якщо ви хочете додати розподіли ймовірностей, виконайте велику обробку зображень,

354
00:21:37,923 --> 00:21:38,822
якою б вона не була.

355
00:21:38,822 --> 00:21:42,170
І я вважаю, що це такий гарний приклад того, чому ви повинні радіти,

356
00:21:42,170 --> 00:21:46,100
коли бачите, що якась операція чи концепція в математиці з’являється в багатьох,

357
00:21:46,100 --> 00:21:47,798
здавалося б, непов’язаних областях.

358
00:21:47,798 --> 00:21:51,967
Якщо ви хочете трохи домашнього завдання, ось щось, про що цікаво подумати.

359
00:21:51,967 --> 00:21:56,487
Поясніть, чому коли ви множите два різні числа, просто звичайне множення,

360
00:21:56,487 --> 00:22:01,924
як ми всі вчимося в початковій школі, те, що ви робите, є згорткою між цифрами цих чисел.

361
00:22:01,924 --> 00:22:06,785
Є деякі додаткові кроки з переносом тощо, але основним кроком є згортка.

362
00:22:06,785 --> 00:22:09,723
У світлі існування швидкого алгоритму це означає,

363
00:22:09,723 --> 00:22:14,539
що якщо у вас є два дуже великі цілі числа, то існує спосіб знайти їхній продукт,

364
00:22:14,539 --> 00:22:18,240
який є швидшим, ніж метод, який ми вивчаємо в початковій школі.

365
00:22:18,240 --> 00:22:23,014
Що замість O з n квадратичних операцій вимагає лише O з n log n,

366
00:22:23,014 --> 00:22:25,291
що навіть не здається можливим.

367
00:22:25,291 --> 00:22:28,906
Заковика в тому, що перш ніж це дійсно стане корисним на практиці,

368
00:22:28,906 --> 00:22:31,280
ваші цифри повинні бути абсолютно жахливими.

369
00:22:31,280 --> 00:22:34,445
Але все одно круто, що такий алгоритм існує.

370
00:22:34,445 --> 00:22:37,335
Далі ми звернемо нашу увагу на неперервний випадок

371
00:22:37,335 --> 00:22:40,000
з особливим акцентом на розподілі ймовірностей.

