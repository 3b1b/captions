1
00:00:00,000 --> 00:00:04,480
Припустімо, я даю вам два різні списки чисел або, можливо, дві різні функції, і я прошу вас

2
00:00:04,480 --> 00:00:08,400
подумати про всі способи, якими ви можете поєднати ці два списки, щоб отримати новий список чисел,

3
00:00:08,400 --> 00:00:14,000
або поєднати дві функції, щоб отримати нову функцію . Можливо, один простий спосіб, який спадає на думку,

4
00:00:14,000 --> 00:00:18,640
це просто скласти їх разом термін за терміном. Так само з функціями ви можете додати

5
00:00:18,640 --> 00:00:24,000
всі відповідні виходи. У подібному ключі ви також можете помножити два списки термін за терміном

6
00:00:24,000 --> 00:00:28,720
і зробити те саме з функціями. Але є ще один вид комбінації, такий

7
00:00:28,720 --> 00:00:33,840
же фундаментальний, як обидва, але набагато рідше обговорюваний, відомий як згортка.

8
00:00:33,840 --> 00:00:38,240
Але на відміну від попередніх двох випадків, це не те, що просто успадковано від операції, яку

9
00:00:38,240 --> 00:00:43,360
ви можете виконати з числами. Це щось справді нове для контексту списків чисел або

10
00:00:43,360 --> 00:00:49,280
комбінування функцій. Вони з’являються скрізь, вони всюдисущі в обробці зображень, це основна

11
00:00:49,280 --> 00:00:53,760
конструкція в теорії ймовірності, вони часто використовуються під час розв’язування диференціальних рівнянь, і

12
00:00:53,760 --> 00:00:58,240
в одному контексті ви майже напевно це бачили, якщо ні під цією назвою

13
00:00:58,240 --> 00:01:03,440
множить два поліноми разом. Для тих, хто займається візуальними поясненнями, це особливо чудова

14
00:01:03,440 --> 00:01:08,800
тема, тому що шаблонне визначення в ізоляції та без контексту може виглядати дещо

15
00:01:08,800 --> 00:01:14,080
лякаюче, але якщо ми приділимо час, щоб справді розгадати, що воно говорить, а перед

16
00:01:14,080 --> 00:01:18,800
тим фактично мотивувати, чому ви б хотіли щось подібне, це неймовірно красива операція.

17
00:01:18,800 --> 00:01:22,880
І я повинен визнати, що я дійсно дещо навчився, збираючи візуальні елементи для цього

18
00:01:22,880 --> 00:01:26,960
проекту. У випадку згортання двох різних функцій я намагався придумати різні способи,

19
00:01:26,960 --> 00:01:30,720
якими можна уявити, що це може означати, і з одним із них у

20
00:01:30,720 --> 00:01:35,840
мене виник невеликий момент, чому нормальні розподіли відіграють таку роль. вони ймовірно,

21
00:01:35,840 --> 00:01:40,320
чому це така природна форма для функції. Але я забігаю вперед, там багато

22
00:01:40,320 --> 00:01:44,800
налаштувань для цього. У цьому відео наша основна увага буде зосереджена лише на дискретному

23
00:01:44,800 --> 00:01:49,920
випадку, і, зокрема, на розробці дуже несподіваного, але дуже розумного алгоритму для їх обчислення.

24
00:01:49,920 --> 00:01:54,400
І я витягну обговорення безперервного випадку в другу частину.

25
00:01:57,840 --> 00:02:03,120
Дуже спокусливо розпочати приклади обробки зображень, оскільки вони візуально найбільш інтригуючі, але

26
00:02:03,120 --> 00:02:06,880
є кілька тонкощів, які роблять процес обробки зображень менш репрезентативним для

27
00:02:06,880 --> 00:02:11,760
звивин, тому замість цього давайте почнемо з ймовірності, і, зокрема, один

28
00:02:11,760 --> 00:02:15,520
із найпростіших прикладів, про який, я впевнений, кожен тут думав колись у

29
00:02:15,520 --> 00:02:20,320
своєму житті, а це кидання пари кубиків і визначення шансів побачити

30
00:02:20,320 --> 00:02:25,600
різні суми. І ви можете сказати, не проблема, не проблема. Кожен із ваших двох кубиків

31
00:02:25,600 --> 00:02:31,600
має шість різних можливих результатів, що дає нам загалом 36 різних можливих пар результатів, і

32
00:02:31,600 --> 00:02:35,600
якщо ми просто переглянемо їх усі, то зможемо порахувати, скільки пар мають певну суму.

33
00:02:36,240 --> 00:02:41,120
І якщо розташувати всі пари в подібній сітці, то одна дуже приємна річ полягає в тому, що

34
00:02:41,120 --> 00:02:47,040
всі пари, які мають постійну суму, видно вздовж однієї з цих різних діагоналей. Тож простий підрахунок кількості

35
00:02:47,040 --> 00:02:51,920
на кожній із цих діагоналей покаже вам, наскільки ймовірно ви побачите певну суму.

36
00:02:52,880 --> 00:02:57,760
І я б сказав, дуже добре, дуже добре, але чи можете ви придумати якісь інші способи візуалізації того

37
00:02:57,760 --> 00:03:03,120
самого питання? Інші образи, які можуть прийти в голову, щоб подумати про всі різні пари, які мають

38
00:03:03,120 --> 00:03:08,800
задану суму? І, можливо, хтось із вас підніме руку і скаже: «Так, у мене є». Скажімо, ви уявляєте ці

39
00:03:08,800 --> 00:03:14,560
два різні набори можливостей кожен у рядку, але ви гортаєте другий рядок. Таким чином

40
00:03:14,560 --> 00:03:20,160
усі різні пари, які в сумі становлять сім, вишиковуються вертикально таким чином. І якщо ми зсунемо

41
00:03:20,160 --> 00:03:24,880
цей нижній рядок до кінця вправо, тоді унікальна пара, яка в сумі додає два, очі змії,

42
00:03:24,880 --> 00:03:29,680
будуть єдиними, які вирівнюються. І якщо я переставлю це на одну одиницю праворуч, пари, які вирівнюються,

43
00:03:29,680 --> 00:03:35,440
є двома різними парами, які в сумі дають три. І загалом, різні значення зміщення цього нижнього

44
00:03:35,440 --> 00:03:40,320
масиву, які пам’ятають, що я мав спочатку перевернути, виявляють усі різні пари, які мають

45
00:03:40,320 --> 00:03:48,800
задану суму. Що стосується ймовірнісних питань, це все ще не особливо цікаво, тому що

46
00:03:48,800 --> 00:03:53,120
все, що ми робимо, це підраховуємо, скільки результатів є в кожній із цих категорій.

47
00:03:53,120 --> 00:03:57,280
Але це з неявним припущенням, що для кожного з цих облич є однакові шанси

48
00:03:57,280 --> 00:04:02,240
з’явитися. Але що, якби я сказав вам, що у мене є спеціальний набір неоднорідних кубиків? Можливо, блакитний

49
00:04:02,240 --> 00:04:06,800
кубик має свій власний набір чисел, що описує ймовірності для кожної грані, що випадає,

50
00:04:06,800 --> 00:04:11,920
а червоний кубик має свій унікальний набір чисел. У такому випадку, якби ви хотіли обчислити,

51
00:04:11,920 --> 00:04:17,360
скажімо, ймовірність побачити двійку, ви б помножили ймовірність того, що синій кубик дорівнює одиниці,

52
00:04:17,360 --> 00:04:22,000
на ймовірність того, що червоний кубик дорівнює одиниці. І щоб отримати шанси побачити трійку, ви

53
00:04:22,000 --> 00:04:26,880
дивитеся на дві різні пари, де це можливо, і знову множите відповідні ймовірності,

54
00:04:26,880 --> 00:04:32,240
а потім додаєте ці два добутки разом. Подібним чином шанси побачити четвірку

55
00:04:32,240 --> 00:04:36,320
включають множення разом трьох різних пар можливостей і додавання їх усіх разом.

56
00:04:36,320 --> 00:04:41,360
І в дусі створення деяких формул давайте назвемо ці найвищі ймовірності a1, a2, a3 і

57
00:04:41,360 --> 00:04:48,000
так далі, а нижні — b1, b2, b3 і так далі. І загалом, цей процес,

58
00:04:48,000 --> 00:04:52,080
коли ми беремо два різні масиви чисел, повертаємо другий, а потім шикуємо

59
00:04:52,080 --> 00:04:56,160
їх за різними значеннями зміщення, беремо купу попарних добутків і додаємо їх,

60
00:04:56,160 --> 00:05:00,960
це один із основні способи уявлення про те, що таке згортка.

61
00:05:00,960 --> 00:05:08,960
Щоб сформулювати це трохи точніше, за допомогою цього процесу ми просто згенерували ймовірності для того, щоб

62
00:05:08,960 --> 00:05:13,840
побачити два, три, чотири, і далі до 12, і ми отримали їх, змішавши разом один

63
00:05:13,840 --> 00:05:20,080
список значень, a та інший список значень, б. На жаргоні ми б сказали, що згортка цих

64
00:05:20,080 --> 00:05:25,600
двох послідовностей дає нам цю нову послідовність, нову послідовність з 11 значень, кожне з яких виглядає

65
00:05:25,600 --> 00:05:30,160
як деяка сума попарних добутків. Якщо ви віддаєте перевагу, інший спосіб, яким ви можете подумати про

66
00:05:30,160 --> 00:05:36,240
ту саму операцію, це спочатку створити таблицю всіх попарних добутків, а потім підсумувати всі ці

67
00:05:36,240 --> 00:05:41,120
діагоналі. Знову ж таки, це спосіб змішування цих двох послідовностей чисел, щоб отримати нову послідовність

68
00:05:41,120 --> 00:05:46,400
з 11 чисел. Це та сама операція, що і розсувні вікна, просто інша перспектива.

69
00:05:46,960 --> 00:05:51,280
Додавши до цього невеликі позначки, ось як ви можете це побачити. Згортка a і b,

70
00:05:51,280 --> 00:05:57,200
позначена цією маленькою зірочкою, є новим списком, і n-й елемент цього списку виглядає як сума,

71
00:05:57,200 --> 00:06:03,440
і ця сума охоплює всі різні пари індексів, i і j, так що сума ці

72
00:06:03,440 --> 00:06:09,440
індекси дорівнюють n. Це наче ковток, але, наприклад, якщо n дорівнює 6, то пари, які ми розглядаємо, це 1 і

73
00:06:09,440 --> 00:06:15,680
5, 2 і 4, 3 і 3, 4 і 2, 5 і 1, усі різні пари, які складаються до 6.

74
00:06:16,400 --> 00:06:20,640
Але чесно кажучи, як би ви це не записали, нотація має другорядне значення порівняно з візуалом, який ви

75
00:06:20,640 --> 00:06:26,320
можете тримати в голові під час процесу. Тут, можливо, допоможе зробити дуже простий приклад, де я можу

76
00:06:26,320 --> 00:06:32,000
запитати вас, яка згортка списку 1, 2, 3 зі списком 4, 5, 6. Ви можете собі

77
00:06:32,000 --> 00:06:36,160
уявити, як ви берете обидва ці списки, гортаєте другий, а потім починаєте з його

78
00:06:36,160 --> 00:06:41,200
кришки до кінця ліворуч. Тоді пара значень, які вирівнюються, це 1 і 4, перемножуємо їх

79
00:06:41,200 --> 00:06:45,680
разом, і це дає нам перший член нашого результату. Посуньте цей нижній масив на одну одиницю вправо, пари,

80
00:06:45,680 --> 00:06:51,840
які вирівнюються, це 1 і 5, а також 2 і 4, помножте ці пари, додайте їх разом, і це

81
00:06:51,840 --> 00:06:57,600
дасть нам 13, наступний запис у наших виводах. Пересуньте все ще раз, і ми візьмемо 1 помножити на 6, плюс

82
00:06:57,600 --> 00:07:04,400
2 помножити на 5, плюс 3 помножити на 4, що дорівнює 28. Ще один слайд, і ми отримаємо 2 помножити на

83
00:07:04,400 --> 00:07:10,000
6 плюс 3 помножити на 5, і це дає нам 27, і нарешті останній член виглядатиме як 3 помножити на 6.

84
00:07:10,560 --> 00:07:14,080
Якщо ви хочете, ви можете вибрати будь-яку вашу улюблену мову програмування та вашу улюблену бібліотеку,

85
00:07:14,080 --> 00:07:18,640
яка містить різноманітні числові операції, і ви можете підтвердити, що я вам не брешу.

86
00:07:18,640 --> 00:07:24,320
Якщо ви візьмете згортку 1, 2, 3 проти 4, 5, 6, це справді результат, який ви отримаєте.

87
00:07:24,880 --> 00:07:29,200
Ми бачили один випадок, коли це природна і бажана операція, що додає до розподілу

88
00:07:29,200 --> 00:07:34,640
ймовірностей, і іншим поширеним прикладом було б ковзне середнє. Уявіть, що у вас є довгий список

89
00:07:34,640 --> 00:07:39,920
чисел, і ви берете ще один менший список чисел, які в сумі дають 1. У цьому випадку я

90
00:07:39,920 --> 00:07:45,280
маю невеликий список із 5 значень, і всі вони дорівнюють 15-му. Тоді, якщо ми зробимо цей

91
00:07:45,280 --> 00:07:49,760
процес згортання ковзного вікна, закриємо очі та заховаємо те, що відбувається на самому початку,

92
00:07:50,560 --> 00:07:55,120
як тільки наш менший список значень повністю збігається з більшим, подумайте про те, що

93
00:07:55,680 --> 00:08:01,120
означає кожен термін у цьому згортка насправді означає. На кожній ітерації ви множите кожне

94
00:08:01,120 --> 00:08:06,400
значення з ваших даних на 15 і додаєте їх усі разом, що означає, що

95
00:08:06,400 --> 00:08:12,080
ви берете середнє значення своїх даних у цьому маленькому вікні. Загалом, процес дає вам

96
00:08:12,080 --> 00:08:16,800
згладжену версію вихідних даних, і ви можете змінити це, починаючи з іншого невеликого списку

97
00:08:16,800 --> 00:08:21,280
чисел, і доки цей невеликий список у сумі дорівнює 1, ви все одно можете інтерпретувати

98
00:08:21,280 --> 00:08:25,840
це як рухливий середній. У наведеному тут прикладі ковзне середнє надає

99
00:08:25,840 --> 00:08:30,720
більшу вагу центральному значенню. Це також призводить до згладженої версії даних.

100
00:08:33,200 --> 00:08:37,840
Якщо ви зробите такий собі двовимірний аналог, ви отримаєте цікавий алгоритм для розмивання певного

101
00:08:37,840 --> 00:08:43,120
зображення. І я повинен сказати, що анімації, які я збираюся показати, змінені з того,

102
00:08:43,120 --> 00:08:48,160
що я спочатку створив для частини серії лекцій, які я проводив у Julia Lab в MIT

103
00:08:48,160 --> 00:08:52,320
для певного класу OpenCourseWare, який включав блок обробки зображень. Там ми зробили трохи більше, щоб зануритися

104
00:08:52,320 --> 00:08:56,640
в код, що стоїть за всім цим, тому, якщо вам цікаво, я залишу вам кілька посилань. Але

105
00:08:56,640 --> 00:09:01,440
повернемося до цього прикладу розмиття. Що відбувається, я маю маленьку сітку значень 3x3, яка

106
00:09:01,440 --> 00:09:06,480
рухається вздовж нашого оригінального зображення, і якщо ми збільшимо масштаб, кожне з цих значень буде

107
00:09:06,480 --> 00:09:11,120
19-м, і що я роблю на кожній ітерації кожне з цих значень множиться на

108
00:09:11,120 --> 00:09:16,080
відповідний піксель, над яким воно знаходиться. І, звичайно, в інформатиці ми розглядаємо кольори

109
00:09:16,080 --> 00:09:20,400
як маленькі вектори трьох значень, що представляють червоний, зелений і синій компоненти.

110
00:09:20,400 --> 00:09:25,440
Коли я множу всі ці маленькі значення на 19 і додаю їх разом, це дає нам

111
00:09:25,440 --> 00:09:30,480
середнє значення по кожному колірному каналу, і відповідний піксель для зображення праворуч визначається як ця

112
00:09:30,480 --> 00:09:36,320
сума. Загальний ефект, оскільки ми робимо це для кожного окремого пікселя на зображенні, полягає в тому,

113
00:09:36,320 --> 00:09:40,880
що кожен піксель перетікає в усіх своїх сусідів, що дає нам більш розмиту версію, ніж оригінальна.

114
00:09:41,680 --> 00:09:46,640
На жаргоні ми б сказали, що зображення праворуч є згорткою нашого оригінального зображення з

115
00:09:46,640 --> 00:09:52,000
невеликою сіткою значень. Або більш технічно, можливо, я повинен сказати, що це згортка з поверненою

116
00:09:52,000 --> 00:09:56,160
на 180 градусів версією цієї маленької сітки значень. Не те, щоб це мало значення,

117
00:09:56,160 --> 00:10:00,720
коли сітка є симетричною, але просто варто пам’ятати, що визначення згортки, успадковане з

118
00:10:00,720 --> 00:10:05,760
чистого математичного контексту, має завжди спонукати вас подумати про гортання цього другого масиву.

119
00:10:05,760 --> 00:10:10,240
Якщо ми трохи змінимо це, ми зможемо отримати набагато елегантніший ефект розмиття, вибравши іншу

120
00:10:10,240 --> 00:10:15,920
сітку значень. У цьому випадку у мене невелика сітка 5x5, але відмінність полягає не стільки в її розмірі.

121
00:10:15,920 --> 00:10:19,920
Якщо ми збільшимо масштаб, то помітимо, що значення в середині набагато більше, ніж значення до

122
00:10:19,920 --> 00:10:25,360
країв, і це відбувається з того, що всі вони взяті з дзвоноподібної кривої, відомої як

123
00:10:25,360 --> 00:10:30,240
розподіл Гауса. Таким чином, коли ми множимо всі ці значення на відповідний піксель, над яким

124
00:10:30,240 --> 00:10:35,200
вони сидять, ми надаємо набагато більшої ваги цьому центральному пікселю, а тим, що знаходяться на

125
00:10:35,200 --> 00:10:39,920
краю, набагато менше. І так само, як і раніше, відповідний піксель праворуч визначається як ця

126
00:10:39,920 --> 00:10:45,360
сума. Оскільки ми виконуємо цей процес для кожного окремого пікселя, це дає ефект розмиття,

127
00:10:45,360 --> 00:10:49,760
який набагато достовірніше імітує поняття розміщення вашого об’єктива поза фокусом або щось подібне.

128
00:10:49,760 --> 00:10:54,960
Але розмиття - далеко не єдине, що ви можете зробити з цією ідеєю. Подивіться, наприклад, на цю

129
00:10:54,960 --> 00:10:59,600
невелику сітку значень, яка містить кілька додатних чисел ліворуч і кілька від’ємних чисел

130
00:10:59,600 --> 00:11:04,480
праворуч, які я розфарбую синім і червоним кольором відповідно. Знайдіть хвилинку, щоб перевірити, чи

131
00:11:04,480 --> 00:11:11,680
можете ви передбачити та зрозуміти, який вплив це матиме на кінцеве зображення. Тож у цьому випадку я

132
00:11:11,680 --> 00:11:16,560
буду думати про зображення як у градаціях сірого, а не як кольорове, тому кожен піксель буде представлено лише

133
00:11:16,560 --> 00:11:21,280
одним числом, а не трьома. І одна річ, яку варто зауважити, це те, що коли ми виконуємо

134
00:11:21,280 --> 00:11:26,240
цю згортку, можна отримати від’ємні значення. Наприклад, у цій точці тут, якщо ми збільшимо ліву половину

135
00:11:26,240 --> 00:11:30,960
нашої маленької сітки, вона буде повністю розташована поверх чорних пікселів, які матимуть нульове значення, але

136
00:11:30,960 --> 00:11:35,360
права половина від’ємних значень буде розташована поверх білих пікселів, що буде мають значення одиниці.

137
00:11:36,000 --> 00:11:40,960
Отже, коли ми перемножуємо відповідні члени та додаємо їх разом, результати будуть дуже негативними, і я

138
00:11:40,960 --> 00:11:45,120
відображаю це на зображенні праворуч — це фарбую від’ємні значення в червоний колір, а додатні

139
00:11:45,120 --> 00:11:49,520
— у синій. Ще одна річ, яку слід зауважити, це те, що коли ви перебуваєте на патчі, який

140
00:11:49,520 --> 00:11:55,680
має один колір, усе стає нульовим, оскільки сума значень у нашій маленькій сітці дорівнює нулю. Це дуже

141
00:11:55,680 --> 00:11:59,680
відрізняється від двох попередніх прикладів, де сума нашої маленької сітки була одиницею, що дозволило нам

142
00:11:59,680 --> 00:12:05,760
інтерпретувати її як ковзне середнє і, отже, розмиття. Загалом, цей маленький процес виявляє будь-які

143
00:12:05,760 --> 00:12:10,240
коливання значення пікселів під час руху зліва направо, і тому він

144
00:12:10,240 --> 00:12:13,760
дає вам своєрідний спосіб виявити всі вертикальні краї вашого зображення.

145
00:12:16,560 --> 00:12:20,960
І так само, якщо ми обертаємо цю сітку так, щоб вона змінювалася, коли ви рухаєтеся

146
00:12:20,960 --> 00:12:26,000
від верху до низу, це буде підбиратися на всіх горизонтальних краях, що у випадку з

147
00:12:26,000 --> 00:12:31,520
нашим маленьким зображенням пиріжкової істоти призведе до гарних демонічних очей. Цю меншу сітку, до речі,

148
00:12:31,520 --> 00:12:36,160
часто називають ядром, і принадність тут полягає в тому, що просто вибравши інше ядро, ви можете

149
00:12:36,160 --> 00:12:40,240
отримати різні ефекти обробки зображень, не лише розмиваючи виявлення країв, але й такі речі, як збільшення

150
00:12:40,240 --> 00:12:44,800
різкості. Для тих із вас, хто чув про згорточну нейронну мережу, ідея полягає в тому,

151
00:12:44,800 --> 00:12:49,600
щоб використовувати дані, щоб з’ясувати, якими мають бути ядра в першу чергу, як це визначається тим,

152
00:12:49,600 --> 00:12:55,120
що нейронна мережа хоче виявити. Інша річ, яку я, можливо, повинен згадати, це довжина виводу.

153
00:12:55,120 --> 00:12:59,040
Для чогось на кшталт прикладу ковзного середнього ви можете думати лише про терміни, коли

154
00:12:59,040 --> 00:13:04,080
обидва вікна повністю вирівнюються одне з одним, або у прикладі обробки зображення, можливо, ви хочете,

155
00:13:04,080 --> 00:13:09,200
щоб кінцевий результат мав такий самий розмір, як і оригінал. Тепер згортки як чиста

156
00:13:09,200 --> 00:13:13,920
математична операція завжди створюють масив, більший за два масиви, з яких ви почали, принаймні

157
00:13:13,920 --> 00:13:17,520
припускаючи, що один із них не має довжини одиниці. Просто знайте, що в

158
00:13:17,520 --> 00:13:21,440
певних контекстах інформатики ви часто хочете навмисно скоротити цей вихід.

159
00:13:21,520 --> 00:13:29,200
Ще одна річ, яку варто підкреслити, полягає в тому, що в контексті інформатики це поняття гортати

160
00:13:29,200 --> 00:13:34,080
ядро перед тим, як ви дасте йому пройти через оригінал, часто здається дуже дивним і

161
00:13:34,080 --> 00:13:38,960
просто непотрібним, але знову зауважте, що це те, що успадковано від чистого математичного контексту, де,

162
00:13:38,960 --> 00:13:44,000
як ми бачив з ймовірністю, що це неймовірно природна річ. І фактично я можу показати

163
00:13:44,000 --> 00:13:48,480
вам ще один чистий математичний приклад, про який навіть програмісти повинні піклуватися, тому що він

164
00:13:48,480 --> 00:13:53,760
відкриває двері для набагато швидшого алгоритму для обчислення всього цього. Щоб налаштувати те, що я

165
00:13:53,760 --> 00:13:58,560
маю на увазі під швидшим тут, дозвольте мені повернутися і знову витягнути якийсь пітон, і я збираюся створити два

166
00:13:58,560 --> 00:14:02,880
різні відносно великі масиви. У кожному з них буде сто тисяч випадкових елементів, і

167
00:14:02,880 --> 00:14:08,640
я збираюся оцінити час виконання функції convolve з бібліотеки numpy. І в цьому

168
00:14:08,640 --> 00:14:12,800
випадку він запускає його для кількох різних ітерацій, намагається знайти середнє значення, і виглядає, що на

169
00:14:12,880 --> 00:14:18,640
цьому комп’ютері принаймні середнє значення становить 4. 87 секунд. На відміну від цього, якщо я використовую

170
00:14:18,640 --> 00:14:24,080
іншу функцію з бібліотеки scipy під назвою fftconvolve, яка є тією самою, лише реалізованою по-іншому,

171
00:14:24,080 --> 00:14:30,640
що займає лише 4. У середньому 3 мілісекунди, тобто покращення на три порядки.

172
00:14:30,640 --> 00:14:34,800
І знову ж таки, незважаючи на те, що він літає під іншою назвою, він видає той самий

173
00:14:34,800 --> 00:14:38,880
результат, що й інша функція convolve, але він просто робить щось, щоб зробити це більш розумним способом.

174
00:14:38,880 --> 00:14:46,800
Пам’ятайте, як у прикладі ймовірності я сказав, що ще один спосіб, яким ви можете думати

175
00:14:46,800 --> 00:14:51,520
про згортку, це створити цю таблицю всіх попарних добутків, а потім додати ці попарні добутки

176
00:14:51,520 --> 00:14:56,560
вздовж діагоналей. Звичайно, немає нічого конкретного щодо ймовірності, коли ви складаєте два різні списки

177
00:14:56,560 --> 00:15:00,880
чисел, ви можете думати про це таким чином. Створіть таку таблицю множення з

178
00:15:00,880 --> 00:15:05,520
усіма попарними продуктами, а потім кожна сума по діагоналі відповідає одному з ваших кінцевих

179
00:15:05,520 --> 00:15:11,680
результатів. Один контекст, де цей погляд особливо природний, це коли ви множите разом

180
00:15:11,680 --> 00:15:16,240
два поліноми. Наприклад, дозвольте мені взяти маленьку сітку, яку ми вже маємо, і замінити верхні члени на

181
00:15:16,240 --> 00:15:23,920
1, 2x і 3x у квадраті, а інші члени на 4, 5x і 6x у квадраті.

182
00:15:23,920 --> 00:15:27,920
А тепер подумайте, що це означає, коли ми створюємо всі ці різні попарні продукти між

183
00:15:27,920 --> 00:15:32,960
двома списками. Те, що ви робите, по суті, розширюєте повний добуток двох поліномів, які

184
00:15:32,960 --> 00:15:38,240
я записав, а потім, коли ви додаєте вздовж діагоналі, яка відповідає збору всіх подібних

185
00:15:38,240 --> 00:15:43,920
доданків, що є досить акуратним, розширюючи поліном і збираючи подібні доданки, це точно

186
00:15:43,920 --> 00:15:50,640
той самий процес, що й згортка. Але це дозволяє нам робити щось дуже круте, тому що

187
00:15:50,640 --> 00:15:55,360
подумайте про те, що ми тут говоримо. Ми говоримо, що якщо ви берете дві різні функції

188
00:15:55,360 --> 00:16:00,560
та перемножуєте їх разом, що є простою поточковою операцією, це те ж саме, що якби

189
00:16:00,560 --> 00:16:05,920
ви спочатку витягли коефіцієнти з кожної з них, припускаючи, що вони є поліномами, а

190
00:16:05,920 --> 00:16:11,840
потім зробили згортку цих два списки коефіцієнтів. Що робить це таким цікавим, так це те, що

191
00:16:11,840 --> 00:16:16,560
згортки в принципі здаються набагато складнішими, ніж просте множення, і я маю на увазі не просто

192
00:16:16,560 --> 00:16:21,760
концептуально, що про них важче думати, я маю на увазі, що з обчислювальної точки зору для

193
00:16:21,760 --> 00:16:27,040
виконання згортки потрібно більше кроків, ніж для виконання поточковий добуток двох різних списків. Наприклад, скажімо, я

194
00:16:27,040 --> 00:16:31,920
дав вам два справді великі поліноми, скажімо, кожен із сотнею різних коефіцієнтів, тоді, якби ви

195
00:16:32,480 --> 00:16:37,520
їх помножили, щоб розширити цей добуток, який ви знаєте, заповнивши всю цю сітку 100 на

196
00:16:37,520 --> 00:16:43,600
100 попарних добутків, що вимагатиме від вас виконайте 10 000 різних продуктів, а потім,

197
00:16:43,600 --> 00:16:48,560
коли ви збираєте всі подібні терміни вздовж діагоналей, це ще один набір приблизно з 10

198
00:16:48,560 --> 00:16:55,200
000 операцій. У більш загальному жаргоні ми б сказали, що алгоритм є O з n у

199
00:16:55,200 --> 00:17:00,560
квадраті, що означає для двох списків розміром n таким чином, що кількість масштабів операцій пропорційна квадрату n.

200
00:17:00,560 --> 00:17:06,320
З іншого боку, якщо я думаю про два поліноми в термінах їхніх виходів, наприклад,

201
00:17:06,320 --> 00:17:11,680
вибірка їхніх значень на кількох вхідних даних, тоді їх множення потребує лише стільки

202
00:17:11,680 --> 00:17:17,200
операцій, скільки вибірок, оскільки це знову ж таки поточкова операція, а з поліномами вам

203
00:17:17,200 --> 00:17:22,400
потрібно лише кінцеву кількість вибірок, щоб мати можливість відновити коефіцієнти. Наприклад, двох виходів достатньо,

204
00:17:22,400 --> 00:17:27,920
щоб однозначно вказати лінійний поліном, трьох виходів буде достатньо, щоб однозначно вказати квадратичний поліном,

205
00:17:27,920 --> 00:17:33,680
і загалом, якщо ви знаєте n різних виходів, цього достатньо, щоб унікально вказати поліном, який

206
00:17:33,680 --> 00:17:38,800
має n різних коефіцієнтів, або, якщо хочете, ми можемо сформулюйте це мовою систем рівнянь,

207
00:17:38,800 --> 00:17:43,680
уявіть, я кажу вам, що у мене є якийсь поліном, але я не скажу

208
00:17:43,680 --> 00:17:47,840
вам, що це за коефіцієнти, для вас це загадка. У нашому прикладі ви можете подумати

209
00:17:47,840 --> 00:17:52,960
про це як про добуток, який ми намагаємося з’ясувати, а потім припустимо, я скажу, що я просто скажу

210
00:17:52,960 --> 00:17:59,600
вам, якими були б виходи цього полінома, якби ви ввели різні вхідні дані, наприклад 0, 1, 2

211
00:17:59,600 --> 00:18:04,800
, 3, і далі, і я даю вам достатньо, щоб у вас було стільки ж рівнянь, скільки

212
00:18:04,800 --> 00:18:09,840
невідомих. Це навіть лінійна система рівнянь, так що це добре, і в принципі принаймні цього має бути

213
00:18:09,840 --> 00:18:14,880
достатньо для відновлення коефіцієнтів.

214
00:18:14,880 --> 00:18:20,160
two lists of numbers you treat them like they're coefficients of two polynomials you sample those

215
00:18:20,160 --> 00:18:26,560
polynomials at enough outputs multiply those samples point-wise and then solve the system

216
00:18:26,560 --> 00:18:32,720
to recover the coefficients as a sneaky backdoor way to find the convolution and as I've stated it

217
00:18:32,720 --> 00:18:38,000
so far at least some of you could rightfully complain grant that is an idiotic plan because

218
00:18:38,000 --> 00:18:43,120
for one thing just calculating all these samples for one of the polynomials we know already takes

219
00:18:43,120 --> 00:18:47,760
on the order of n squared operations not to mention solving that system is certainly going

220
00:18:47,760 --> 00:18:53,520
to be computationally as difficult as just doing the convolution in the first place so like sure

221
00:18:53,520 --> 00:18:58,400
we have this connection between multiplication and convolutions but all of the complexity happens in

222
00:18:58,400 --> 00:19:04,240
translating from one viewpoint to the other but there is a trick and those of you who know about

223
00:19:04,240 --> 00:19:09,200
Fourier transforms and the FFT algorithm might see where this is going if you're unfamiliar with this

224
00:19:09,200 --> 00:19:13,600
topics what I'm about to say might seem completely out of the blue just know that there are certain

225
00:19:13,600 --> 00:19:18,720
paths you could have walked in math that make this more of an expected step basically the idea is

226
00:19:18,720 --> 00:19:23,840
that we have a freedom of choice here if instead of evaluating at some arbitrary set of inputs like

227
00:19:23,840 --> 00:19:30,080
0 1 2 3 on and on you choose to evaluate on a very specially selected set of complex numbers

228
00:19:30,080 --> 00:19:34,400
specifically the ones that sit evenly spaced on the unit circle what are known as the roots of

229
00:19:34,400 --> 00:19:41,600
unity this gives us a friendlier system the basic idea is that by finding a number where taking its

230
00:19:41,600 --> 00:19:46,480
powers falls into this cycling pattern it means that the system we generate is going to have a lot

231
00:19:46,480 --> 00:19:51,360
of redundancy in the different terms that you're calculating and by being clever about how you

232
00:19:51,360 --> 00:19:57,600
leverage that redundancy you can save yourself a lot of work this set of outputs that I've written

233
00:19:57,600 --> 00:20:03,200
has a special name it's called the discrete Fourier transform of the coefficients and if you want to

234
00:20:03,200 --> 00:20:08,160
learn more I actually did another lecture for that same julia mit class all about discrete

235
00:20:08,160 --> 00:20:12,640
Fourier transforms and there's also a really excellent video on the channel reducible talking

236
00:20:12,640 --> 00:20:17,520
about the fast Fourier transform which is an algorithm for computing these more quickly also

237
00:20:17,520 --> 00:20:22,720
veritasium recently did a really good video on fft's so you've got lots of options and that fast

238
00:20:22,720 --> 00:20:28,320
algorithm really is the point for us again because of all this redundancy there exists a method to go

239
00:20:28,320 --> 00:20:33,040
from the coefficients to all of these outputs where instead of doing on the order of n squared

240
00:20:33,040 --> 00:20:38,080
operations you do on the order of n times the log of n operations which is much much better as you

241
00:20:38,080 --> 00:20:43,600
scale to big lists and importantly this fft algorithm goes both ways it also lets you go

242
00:20:43,600 --> 00:20:48,640
from the outputs to the coefficients so bringing it all together let's look back at our algorithm

243
00:20:48,640 --> 00:20:53,200
outline now we can say whenever you're given two long lists of numbers and you want to take their

244
00:20:53,200 --> 00:20:58,960
convolution first compute the fast Fourier transform of each one of them which in the back

245
00:20:58,960 --> 00:21:03,280
of your mind you can just think of as treating them like they're the coefficients of a polynomial

246
00:21:03,280 --> 00:21:08,960
and evaluating it at a very specially selected set of points then multiply together the two results

247
00:21:08,960 --> 00:21:14,480
that you just got point-wise which is nice and fast and then do an inverse fast Fourier transform

248
00:21:14,480 --> 00:21:18,480
and what that gives you is the sneaky backdoor way to compute the convolution that we were looking

249
00:21:18,480 --> 00:21:25,600
for but this time it only involves o of n log n operations that's really cool to me this very

250
00:21:25,600 --> 00:21:30,560
specific context where convolutions show up multiplying two polynomials opens the doors for

251
00:21:30,560 --> 00:21:35,120
an algorithm that's relevant everywhere else where convolutions might come up if you want to add

252
00:21:35,120 --> 00:21:39,600
probability distributions do some large image processing whatever it might be and i just think

253
00:21:39,600 --> 00:21:44,480
that's such a good example of why you should be excited when you see some operation or concept in

254
00:21:44,480 --> 00:21:50,160
math show up in a lot of seemingly unrelated areas if you want a little homework here's

255
00:21:50,160 --> 00:21:54,800
something that's fun to think about explain why when you multiply two different numbers just

256
00:21:54,800 --> 00:21:59,360
ordinary multiplication the way we all learn in elementary school what you're doing is basically

257
00:21:59,360 --> 00:22:04,640
a convolution between the digits of those numbers there's some added steps with carries and the like

258
00:22:04,640 --> 00:22:10,720
but the core step is a convolution in light of the existence of a fast algorithm what that means is

259
00:22:10,720 --> 00:22:16,000
if you have two very large integers then there exists a way to find their product that's faster

260
00:22:16,000 --> 00:22:20,720
than the method we learn in elementary school that instead of requiring o of n squared operations

261
00:22:20,720 --> 00:22:26,320
only requires o of n log n which doesn't even feel like it should be possible the catch is that

262
00:22:26,320 --> 00:22:31,280
before this is actually useful in practice your numbers would have to be absolutely monstrous

263
00:22:31,280 --> 00:22:36,880
but still it's cool that such an algorithm exists and next up we'll turn our attention to the

264
00:22:36,880 --> 00:22:51,040
continuous case with a special focus on probability distributions

