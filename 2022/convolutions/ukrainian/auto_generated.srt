1
00:00:00,000 --> 00:00:03,864
Припустімо, я даю вам два різні списки чисел або, можливо, дві різні функції, і

2
00:00:03,864 --> 00:00:07,824
я прошу вас подумати про всі способи, якими ви можете поєднати ці два списки, щоб

3
00:00:07,824 --> 00:00:11,737
отримати новий список чисел, або поєднати дві функції, щоб отримати нову функцію.

4
00:00:11,737 --> 00:00:14,140
Можливо, один простий спосіб, який спадає на думку,

5
00:00:14,140 --> 00:00:16,267
це просто скласти їх разом термін за терміном.

6
00:00:16,267 --> 00:00:20,050
Так само з функціями ви можете додати всі відповідні виходи.

7
00:00:20,050 --> 00:00:23,273
У подібному ключі ви також можете помножити два списки

8
00:00:23,273 --> 00:00:26,145
термін за терміном і зробити те саме з функціями.

9
00:00:26,145 --> 00:00:29,928
Але є ще один вид комбінації, такий же фундаментальний, як

10
00:00:29,928 --> 00:00:33,840
обидва, але набагато рідше обговорюваний, відомий як згортка.

11
00:00:33,840 --> 00:00:37,013
Але на відміну від попередніх двох випадків, це не те, що просто

12
00:00:37,013 --> 00:00:39,893
успадковано від операції, яку ви можете виконати з числами.

13
00:00:39,893 --> 00:00:44,716
Це щось справді нове для контексту списків чисел або комбінування функцій.

14
00:00:44,716 --> 00:00:48,686
Вони з’являються скрізь, вони всюдисущі в обробці зображень, це основна

15
00:00:48,686 --> 00:00:52,546
конструкція в теорії ймовірності, вони часто використовуються під час

16
00:00:52,546 --> 00:00:56,350
розв’язування диференціальних рівнянь, і в одному контексті ви майже

17
00:00:56,350 --> 00:01:00,210
напевно це бачили, якщо ні під цією назвою множить два поліноми разом.

18
00:01:00,210 --> 00:01:04,771
Для тих, хто займається візуальними поясненнями, це особливо чудова тема, тому

19
00:01:04,771 --> 00:01:09,389
що шаблонне визначення в ізоляції та без контексту може виглядати дещо лякаюче,

20
00:01:09,389 --> 00:01:14,008
але якщо ми приділимо час, щоб справді розгадати, що воно говорить, а перед тим

21
00:01:14,008 --> 00:01:18,800
фактично мотивувати, чому ви б хотіли щось подібне, це неймовірно красива операція.

22
00:01:18,800 --> 00:01:21,167
І я повинен визнати, що я дійсно дещо навчився,

23
00:01:21,167 --> 00:01:23,436
збираючи візуальні елементи для цього проекту.

24
00:01:23,436 --> 00:01:28,420
У випадку згортання двох різних функцій я намагався придумати різні способи, якими можна

25
00:01:28,420 --> 00:01:33,013
уявити, що це може означати, і з одним із них у мене виник невеликий момент, чому

26
00:01:33,013 --> 00:01:37,997
нормальні розподіли відіграють таку роль. вони ймовірно, чому це така природна форма для

27
00:01:37,997 --> 00:01:38,445
функції.

28
00:01:38,445 --> 00:01:41,580
Але я забігаю вперед, там багато налаштувань для цього.

29
00:01:41,580 --> 00:01:45,736
У цьому відео наша основна увага буде зосереджена лише на дискретному випадку, і,

30
00:01:45,736 --> 00:01:50,196
зокрема, на розробці дуже несподіваного, але дуже розумного алгоритму для їх обчислення.

31
00:01:50,196 --> 00:01:57,840
І я витягну обговорення безперервного випадку в другу частину.

32
00:01:57,840 --> 00:02:02,806
Дуже спокусливо розпочати приклади обробки зображень, оскільки вони візуально найбільш

33
00:02:02,806 --> 00:02:07,201
інтригуючі, але є кілька тонкощів, які роблять процес обробки зображень менш

34
00:02:07,201 --> 00:02:11,882
репрезентативним для звивин, тому замість цього давайте почнемо з ймовірності, і,

35
00:02:11,882 --> 00:02:16,449
зокрема, один із найпростіших прикладів, про який, я впевнений, кожен тут думав

36
00:02:16,449 --> 00:02:21,530
колись у своєму житті, а це кидання пари кубиків і визначення шансів побачити різні суми.

37
00:02:21,530 --> 00:02:24,170
І ви можете сказати, не проблема, не проблема.

38
00:02:24,170 --> 00:02:28,174
Кожен із ваших двох кубиків має шість різних можливих результатів, що

39
00:02:28,174 --> 00:02:32,121
дає нам загалом 36 різних можливих пар результатів, і якщо ми просто

40
00:02:32,121 --> 00:02:36,240
переглянемо їх усі, то зможемо порахувати, скільки пар мають певну суму.

41
00:02:36,240 --> 00:02:40,750
І якщо розташувати всі пари в подібній сітці, то одна дуже приємна річ полягає в

42
00:02:40,750 --> 00:02:45,650
тому, що всі пари, які мають постійну суму, видно вздовж однієї з цих різних діагоналей.

43
00:02:45,650 --> 00:02:49,485
Тож простий підрахунок кількості на кожній із цих діагоналей

44
00:02:49,485 --> 00:02:52,880
покаже вам, наскільки ймовірно ви побачите певну суму.

45
00:02:52,880 --> 00:02:55,615
І я б сказав, дуже добре, дуже добре, але чи можете ви

46
00:02:55,615 --> 00:02:58,699
придумати якісь інші способи візуалізації того самого питання?

47
00:02:58,699 --> 00:03:01,537
Інші образи, які можуть прийти в голову, щоб подумати

48
00:03:01,537 --> 00:03:03,744
про всі різні пари, які мають задану суму?

49
00:03:03,744 --> 00:03:07,550
І, можливо, хтось із вас підніме руку і скаже: «Так, у мене є».

50
00:03:07,550 --> 00:03:11,099
Скажімо, ви уявляєте ці два різні набори можливостей

51
00:03:11,099 --> 00:03:14,046
кожен у рядку, але ви гортаєте другий рядок.

52
00:03:14,046 --> 00:03:16,688
Таким чином усі різні пари, які в сумі становлять

53
00:03:16,688 --> 00:03:18,960
сім, вишиковуються вертикально таким чином.

54
00:03:18,960 --> 00:03:22,528
І якщо ми зсунемо цей нижній рядок до кінця вправо, тоді унікальна

55
00:03:22,528 --> 00:03:26,309
пара, яка в сумі додає два, очі змії, будуть єдиними, які вирівнюються.

56
00:03:26,309 --> 00:03:29,598
І якщо я переставлю це на одну одиницю праворуч, пари, які

57
00:03:29,598 --> 00:03:32,886
вирівнюються, є двома різними парами, які в сумі дають три.

58
00:03:32,886 --> 00:03:37,361
І загалом, різні значення зміщення цього нижнього масиву, які пам’ятають, що

59
00:03:37,361 --> 00:03:41,778
я мав спочатку перевернути, виявляють усі різні пари, які мають задану суму.

60
00:03:41,778 --> 00:03:47,413
Що стосується ймовірнісних питань, це все ще не особливо цікаво, тому що все,

61
00:03:47,413 --> 00:03:53,120
що ми робимо, це підраховуємо, скільки результатів є в кожній із цих категорій.

62
00:03:53,120 --> 00:03:57,850
Але це з неявним припущенням, що для кожного з цих облич є однакові шанси з’явитися.

63
00:03:57,850 --> 00:04:01,897
Але що, якби я сказав вам, що у мене є спеціальний набір неоднорідних кубиків?

64
00:04:01,897 --> 00:04:05,768
Можливо, блакитний кубик має свій власний набір чисел, що описує ймовірності

65
00:04:05,768 --> 00:04:09,740
для кожної грані, що випадає, а червоний кубик має свій унікальний набір чисел.

66
00:04:09,740 --> 00:04:12,976
У такому випадку, якби ви хотіли обчислити, скажімо, ймовірність

67
00:04:12,976 --> 00:04:16,211
побачити двійку, ви б помножили ймовірність того, що синій кубик

68
00:04:16,211 --> 00:04:19,895
дорівнює одиниці, на ймовірність того, що червоний кубик дорівнює одиниці.

69
00:04:19,895 --> 00:04:25,158
І щоб отримати шанси побачити трійку, ви дивитеся на дві різні пари, де це можливо,

70
00:04:25,158 --> 00:04:29,983
і знову множите відповідні ймовірності, а потім додаєте ці два добутки разом.

71
00:04:29,983 --> 00:04:33,280
Подібним чином шанси побачити четвірку включають множення

72
00:04:33,280 --> 00:04:36,748
разом трьох різних пар можливостей і додавання їх усіх разом.

73
00:04:36,748 --> 00:04:41,073
І в дусі створення деяких формул давайте назвемо ці найвищі

74
00:04:41,073 --> 00:04:45,903
ймовірності a1, a2, a3 і так далі, а нижні — b1, b2, b3 і так далі.

75
00:04:45,903 --> 00:04:51,132
І загалом, цей процес, коли ми беремо два різні масиви чисел, повертаємо другий,

76
00:04:51,132 --> 00:04:56,362
а потім шикуємо їх за різними значеннями зміщення, беремо купу попарних добутків

77
00:04:56,362 --> 00:05:01,139
і додаємо їх, це один із основні способи уявлення про те, що таке згортка.

78
00:05:01,139 --> 00:05:06,045
Щоб сформулювати це трохи точніше, за допомогою цього процесу ми просто

79
00:05:06,045 --> 00:05:11,429
згенерували ймовірності для того, щоб побачити два, три, чотири, і далі до 12,

80
00:05:11,429 --> 00:05:17,084
і ми отримали їх, змішавши разом один список значень, a та інший список значень, б.

81
00:05:17,084 --> 00:05:21,369
На жаргоні ми б сказали, що згортка цих двох послідовностей дає нам цю нову

82
00:05:21,369 --> 00:05:26,105
послідовність, нову послідовність з 11 значень, кожне з яких виглядає як деяка сума

83
00:05:26,105 --> 00:05:27,120
попарних добутків.

84
00:05:27,120 --> 00:05:31,829
Якщо ви віддаєте перевагу, інший спосіб, яким ви можете подумати про ту саму операцію,

85
00:05:31,829 --> 00:05:36,702
це спочатку створити таблицю всіх попарних добутків, а потім підсумувати всі ці діагоналі.

86
00:05:36,702 --> 00:05:39,703
Знову ж таки, це спосіб змішування цих двох послідовностей

87
00:05:39,703 --> 00:05:42,247
чисел, щоб отримати нову послідовність з 11 чисел.

88
00:05:42,247 --> 00:05:46,960
Це та сама операція, що і розсувні вікна, просто інша перспектива.

89
00:05:46,960 --> 00:05:50,314
Додавши до цього невеликі позначки, ось як ви можете це побачити.

90
00:05:50,314 --> 00:05:55,195
Згортка a і b, позначена цією маленькою зірочкою, є новим списком,

91
00:05:55,195 --> 00:06:00,076
і n-й елемент цього списку виглядає як сума, і ця сума охоплює всі

92
00:06:00,076 --> 00:06:04,738
різні пари індексів, i і j, так що сума ці індекси дорівнюють n.

93
00:06:04,738 --> 00:06:10,757
Це наче ковток, але, наприклад, якщо n дорівнює 6, то пари, які ми розглядаємо,

94
00:06:10,757 --> 00:06:16,400
це 1 і 5, 2 і 4, 3 і 3, 4 і 2, 5 і 1, усі різні пари, які складаються до 6.

95
00:06:16,400 --> 00:06:19,856
Але чесно кажучи, як би ви це не записали, нотація має другорядне значення

96
00:06:19,856 --> 00:06:23,082
порівняно з візуалом, який ви можете тримати в голові під час процесу.

97
00:06:23,082 --> 00:06:27,120
Тут, можливо, допоможе зробити дуже простий приклад, де я можу

98
00:06:27,120 --> 00:06:30,967
запитати вас, яка згортка списку 1, 2, 3 зі списком 4, 5, 6.

99
00:06:30,967 --> 00:06:34,584
Ви можете собі уявити, як ви берете обидва ці списки, гортаєте

100
00:06:34,584 --> 00:06:37,857
другий, а потім починаєте з його кришки до кінця ліворуч.

101
00:06:37,857 --> 00:06:41,019
Тоді пара значень, які вирівнюються, це 1 і 4, перемножуємо

102
00:06:41,019 --> 00:06:43,813
їх разом, і це дає нам перший член нашого результату.

103
00:06:43,813 --> 00:06:47,196
Посуньте цей нижній масив на одну одиницю вправо, пари, які

104
00:06:47,196 --> 00:06:50,860
вирівнюються, це 1 і 5, а також 2 і 4, помножте ці пари, додайте

105
00:06:50,860 --> 00:06:54,300
їх разом, і це дасть нам 13, наступний запис у наших виводах.

106
00:06:54,300 --> 00:06:58,071
Пересуньте все ще раз, і ми візьмемо 1 помножити на 6, плюс

107
00:06:58,071 --> 00:07:01,591
2 помножити на 5, плюс 3 помножити на 4, що дорівнює 28.

108
00:07:01,591 --> 00:07:05,981
Ще один слайд, і ми отримаємо 2 помножити на 6 плюс 3 помножити на 5,

109
00:07:05,981 --> 00:07:10,560
і це дає нам 27, і нарешті останній член виглядатиме як 3 помножити на 6.

110
00:07:10,560 --> 00:07:13,237
Якщо ви хочете, ви можете вибрати будь-яку вашу улюблену мову

111
00:07:13,237 --> 00:07:16,173
програмування та вашу улюблену бібліотеку, яка містить різноманітні

112
00:07:16,173 --> 00:07:18,807
числові операції, і ви можете підтвердити, що я вам не брешу.

113
00:07:18,807 --> 00:07:24,880
Якщо ви візьмете згортку 1, 2, 3 проти 4, 5, 6, це справді результат, який ви отримаєте.

114
00:07:24,880 --> 00:07:28,826
Ми бачили один випадок, коли це природна і бажана операція, що додає до

115
00:07:28,826 --> 00:07:32,881
розподілу ймовірностей, і іншим поширеним прикладом було б ковзне середнє.

116
00:07:32,881 --> 00:07:35,953
Уявіть, що у вас є довгий список чисел, і ви берете

117
00:07:35,953 --> 00:07:38,788
ще один менший список чисел, які в сумі дають 1.

118
00:07:38,788 --> 00:07:43,381
У цьому випадку я маю невеликий список із 5 значень, і всі вони дорівнюють 15-му.

119
00:07:43,381 --> 00:07:48,595
Тоді, якщо ми зробимо цей процес згортання ковзного вікна, закриємо очі та заховаємо те,

120
00:07:48,595 --> 00:07:53,282
що відбувається на самому початку, як тільки наш менший список значень повністю

121
00:07:53,282 --> 00:07:58,554
збігається з більшим, подумайте про те, що означає кожен термін у цьому згортка насправді

122
00:07:58,554 --> 00:07:59,023
означає.

123
00:07:59,023 --> 00:08:04,756
На кожній ітерації ви множите кожне значення з ваших даних на 15 і додаєте їх усі

124
00:08:04,756 --> 00:08:10,769
разом, що означає, що ви берете середнє значення своїх даних у цьому маленькому вікні.

125
00:08:10,769 --> 00:08:14,802
Загалом, процес дає вам згладжену версію вихідних даних, і ви можете змінити

126
00:08:14,802 --> 00:08:18,782
це, починаючи з іншого невеликого списку чисел, і доки цей невеликий список

127
00:08:18,782 --> 00:08:22,816
у сумі дорівнює 1, ви все одно можете інтерпретувати це як рухливий середній.

128
00:08:22,816 --> 00:08:27,781
У наведеному тут прикладі ковзне середнє надає більшу вагу центральному значенню.

129
00:08:27,781 --> 00:08:33,200
Це також призводить до згладженої версії даних.

130
00:08:33,200 --> 00:08:35,629
Якщо ви зробите такий собі двовимірний аналог, ви

131
00:08:35,629 --> 00:08:38,594
отримаєте цікавий алгоритм для розмивання певного зображення.

132
00:08:38,594 --> 00:08:42,673
І я повинен сказати, що анімації, які я збираюся показати, змінені з того,

133
00:08:42,673 --> 00:08:46,753
що я спочатку створив для частини серії лекцій, які я проводив у Julia Lab

134
00:08:46,753 --> 00:08:50,887
в MIT для певного класу OpenCourseWare, який включав блок обробки зображень.

135
00:08:50,887 --> 00:08:53,713
Там ми зробили трохи більше, щоб зануритися в код, що стоїть за

136
00:08:53,713 --> 00:08:56,452
всім цим, тому, якщо вам цікаво, я залишу вам кілька посилань.

137
00:08:56,452 --> 00:09:00,759
Але повернемося до цього прикладу розмиття. Що відбувається, я маю маленьку сітку

138
00:09:00,759 --> 00:09:04,803
значень 3x3, яка рухається вздовж нашого оригінального зображення, і якщо ми

139
00:09:04,803 --> 00:09:09,110
збільшимо масштаб, кожне з цих значень буде 19-м, і що я роблю на кожній ітерації

140
00:09:09,110 --> 00:09:13,312
кожне з цих значень множиться на відповідний піксель, над яким воно знаходиться.

141
00:09:13,312 --> 00:09:16,881
І, звичайно, в інформатиці ми розглядаємо кольори як маленькі вектори

142
00:09:16,881 --> 00:09:20,400
трьох значень, що представляють червоний, зелений і синій компоненти.

143
00:09:20,400 --> 00:09:23,866
Коли я множу всі ці маленькі значення на 19 і додаю їх разом,

144
00:09:23,866 --> 00:09:27,164
це дає нам середнє значення по кожному колірному каналу, і

145
00:09:27,164 --> 00:09:30,966
відповідний піксель для зображення праворуч визначається як ця сума.

146
00:09:30,966 --> 00:09:34,664
Загальний ефект, оскільки ми робимо це для кожного окремого пікселя

147
00:09:34,664 --> 00:09:38,199
на зображенні, полягає в тому, що кожен піксель перетікає в усіх

148
00:09:38,199 --> 00:09:41,680
своїх сусідів, що дає нам більш розмиту версію, ніж оригінальна.

149
00:09:41,680 --> 00:09:44,740
На жаргоні ми б сказали, що зображення праворуч є згорткою

150
00:09:44,740 --> 00:09:47,800
нашого оригінального зображення з невеликою сіткою значень.

151
00:09:47,800 --> 00:09:51,115
Або більш технічно, можливо, я повинен сказати, що це згортка з

152
00:09:51,115 --> 00:09:54,430
поверненою на 180 градусів версією цієї маленької сітки значень.

153
00:09:54,430 --> 00:09:58,121
Не те, щоб це мало значення, коли сітка є симетричною, але просто варто

154
00:09:58,121 --> 00:10:01,710
пам’ятати, що визначення згортки, успадковане з чистого математичного

155
00:10:01,710 --> 00:10:05,760
контексту, має завжди спонукати вас подумати про гортання цього другого масиву.

156
00:10:05,760 --> 00:10:08,362
Якщо ми трохи змінимо це, ми зможемо отримати набагато

157
00:10:08,362 --> 00:10:11,059
елегантніший ефект розмиття, вибравши іншу сітку значень.

158
00:10:11,059 --> 00:10:13,570
У цьому випадку у мене невелика сітка 5x5, але

159
00:10:13,570 --> 00:10:15,920
відмінність полягає не стільки в її розмірі.

160
00:10:15,920 --> 00:10:19,130
Якщо ми збільшимо масштаб, то помітимо, що значення в середині

161
00:10:19,130 --> 00:10:22,494
набагато більше, ніж значення до країв, і це відбувається з того,

162
00:10:22,494 --> 00:10:26,010
що всі вони взяті з дзвоноподібної кривої, відомої як розподіл Гауса.

163
00:10:26,010 --> 00:10:29,619
Таким чином, коли ми множимо всі ці значення на відповідний піксель,

164
00:10:29,619 --> 00:10:32,810
над яким вони сидять, ми надаємо набагато більшої ваги цьому

165
00:10:32,810 --> 00:10:36,367
центральному пікселю, а тим, що знаходяться на краю, набагато менше.

166
00:10:36,367 --> 00:10:40,373
І так само, як і раніше, відповідний піксель праворуч визначається як ця сума.

167
00:10:40,373 --> 00:10:43,552
Оскільки ми виконуємо цей процес для кожного окремого пікселя,

168
00:10:43,552 --> 00:10:46,832
це дає ефект розмиття, який набагато достовірніше імітує поняття

169
00:10:46,832 --> 00:10:49,760
розміщення вашого об’єктива поза фокусом або щось подібне.

170
00:10:49,760 --> 00:10:53,474
Але розмиття - далеко не єдине, що ви можете зробити з цією ідеєю.

171
00:10:53,474 --> 00:10:56,463
Подивіться, наприклад, на цю невелику сітку значень, яка

172
00:10:56,463 --> 00:10:59,767
містить кілька додатних чисел ліворуч і кілька від’ємних чисел

173
00:10:59,767 --> 00:11:03,071
праворуч, які я розфарбую синім і червоним кольором відповідно.

174
00:11:03,071 --> 00:11:06,506
Знайдіть хвилинку, щоб перевірити, чи можете ви передбачити

175
00:11:06,506 --> 00:11:09,769
та зрозуміти, який вплив це матиме на кінцеве зображення.

176
00:11:09,769 --> 00:11:13,952
Тож у цьому випадку я буду думати про зображення як у градаціях сірого, а не як

177
00:11:13,952 --> 00:11:18,082
кольорове, тому кожен піксель буде представлено лише одним числом, а не трьома.

178
00:11:18,082 --> 00:11:20,497
І одна річ, яку варто зауважити, це те, що коли ми

179
00:11:20,497 --> 00:11:23,102
виконуємо цю згортку, можна отримати від’ємні значення.

180
00:11:23,102 --> 00:11:26,175
Наприклад, у цій точці тут, якщо ми збільшимо ліву половину нашої

181
00:11:26,175 --> 00:11:29,527
маленької сітки, вона буде повністю розташована поверх чорних пікселів,

182
00:11:29,527 --> 00:11:32,694
які матимуть нульове значення, але права половина від’ємних значень

183
00:11:32,694 --> 00:11:36,000
буде розташована поверх білих пікселів, що буде мають значення одиниці.

184
00:11:36,000 --> 00:11:39,109
Отже, коли ми перемножуємо відповідні члени та додаємо їх разом,

185
00:11:39,109 --> 00:11:42,362
результати будуть дуже негативними, і я відображаю це на зображенні

186
00:11:42,362 --> 00:11:46,046
праворуч — це фарбую від’ємні значення в червоний колір, а додатні — у синій.

187
00:11:46,046 --> 00:11:50,475
Ще одна річ, яку слід зауважити, це те, що коли ви перебуваєте на патчі, який має один

188
00:11:50,475 --> 00:11:54,854
колір, усе стає нульовим, оскільки сума значень у нашій маленькій сітці дорівнює нулю.

189
00:11:54,854 --> 00:11:58,850
Це дуже відрізняється від двох попередніх прикладів, де сума нашої маленької сітки

190
00:11:58,850 --> 00:12:02,990
була одиницею, що дозволило нам інтерпретувати її як ковзне середнє і, отже, розмиття.

191
00:12:02,990 --> 00:12:07,779
Загалом, цей маленький процес виявляє будь-які коливання значення

192
00:12:07,779 --> 00:12:12,641
пікселів під час руху зліва направо, і тому він дає вам своєрідний

193
00:12:12,641 --> 00:12:16,560
спосіб виявити всі вертикальні краї вашого зображення.

194
00:12:16,560 --> 00:12:21,089
І так само, якщо ми обертаємо цю сітку так, щоб вона змінювалася, коли ви рухаєтеся

195
00:12:21,089 --> 00:12:25,511
від верху до низу, це буде підбиратися на всіх горизонтальних краях, що у випадку

196
00:12:25,511 --> 00:12:29,986
з нашим маленьким зображенням пиріжкової істоти призведе до гарних демонічних очей.

197
00:12:29,986 --> 00:12:33,396
Цю меншу сітку, до речі, часто називають ядром, і принадність тут полягає в

198
00:12:33,396 --> 00:12:36,806
тому, що просто вибравши інше ядро, ви можете отримати різні ефекти обробки

199
00:12:36,806 --> 00:12:40,710
зображень, не лише розмиваючи виявлення країв, але й такі речі, як збільшення різкості.

200
00:12:40,710 --> 00:12:44,346
Для тих із вас, хто чув про згорточну нейронну мережу, ідея полягає в

201
00:12:44,346 --> 00:12:47,930
тому, щоб використовувати дані, щоб з’ясувати, якими мають бути ядра

202
00:12:47,930 --> 00:12:51,618
в першу чергу, як це визначається тим, що нейронна мережа хоче виявити.

203
00:12:51,618 --> 00:12:55,378
Інша річ, яку я, можливо, повинен згадати, це довжина виводу.

204
00:12:55,378 --> 00:12:59,505
Для чогось на кшталт прикладу ковзного середнього ви можете думати лише про терміни,

205
00:12:59,505 --> 00:13:03,827
коли обидва вікна повністю вирівнюються одне з одним, або у прикладі обробки зображення,

206
00:13:03,827 --> 00:13:07,760
можливо, ви хочете, щоб кінцевий результат мав такий самий розмір, як і оригінал.

207
00:13:07,760 --> 00:13:11,981
Тепер згортки як чиста математична операція завжди створюють масив, більший за два

208
00:13:11,981 --> 00:13:16,405
масиви, з яких ви почали, принаймні припускаючи, що один із них не має довжини одиниці.

209
00:13:16,405 --> 00:13:19,097
Просто знайте, що в певних контекстах інформатики

210
00:13:19,097 --> 00:13:21,520
ви часто хочете навмисно скоротити цей вихід.

211
00:13:21,520 --> 00:13:26,499
Ще одна річ, яку варто підкреслити, полягає в тому, що в контексті інформатики це

212
00:13:26,499 --> 00:13:31,782
поняття гортати ядро перед тим, як ви дасте йому пройти через оригінал, часто здається

213
00:13:31,782 --> 00:13:36,822
дуже дивним і просто непотрібним, але знову зауважте, що це те, що успадковано від

214
00:13:36,822 --> 00:13:42,287
чистого математичного контексту, де, як ми бачив з ймовірністю, що це неймовірно природна

215
00:13:42,287 --> 00:13:42,530
річ.

216
00:13:42,530 --> 00:13:45,794
І фактично я можу показати вам ще один чистий математичний приклад,

217
00:13:45,794 --> 00:13:49,202
про який навіть програмісти повинні піклуватися, тому що він відкриває

218
00:13:49,202 --> 00:13:52,370
двері для набагато швидшого алгоритму для обчислення всього цього.

219
00:13:52,370 --> 00:13:55,953
Щоб налаштувати те, що я маю на увазі під швидшим тут, дозвольте мені повернутися і

220
00:13:55,953 --> 00:13:59,579
знову витягнути якийсь пітон, і я збираюся створити два різні відносно великі масиви.

221
00:13:59,579 --> 00:14:03,835
У кожному з них буде сто тисяч випадкових елементів, і я збираюся

222
00:14:03,835 --> 00:14:07,575
оцінити час виконання функції convolve з бібліотеки numpy.

223
00:14:07,575 --> 00:14:11,414
І в цьому випадку він запускає його для кількох різних ітерацій, намагається знайти

224
00:14:11,414 --> 00:14:15,528
середнє значення, і виглядає, що на цьому комп’ютері принаймні середнє значення становить

225
00:14:15,528 --> 00:14:15,619
4.

226
00:14:15,619 --> 00:14:16,321
87 секунд.

227
00:14:16,321 --> 00:14:21,011
На відміну від цього, якщо я використовую іншу функцію з бібліотеки scipy під

228
00:14:21,011 --> 00:14:26,061
назвою fftconvolve, яка є тією самою, лише реалізованою по-іншому, що займає лише 4.

229
00:14:26,061 --> 00:14:30,640
У середньому 3 мілісекунди, тобто покращення на три порядки.

230
00:14:30,640 --> 00:14:33,444
І знову ж таки, незважаючи на те, що він літає під іншою назвою,

231
00:14:33,444 --> 00:14:36,162
він видає той самий результат, що й інша функція convolve, але

232
00:14:36,162 --> 00:14:38,880
він просто робить щось, щоб зробити це більш розумним способом.

233
00:14:38,880 --> 00:14:43,429
Пам’ятайте, як у прикладі ймовірності я сказав, що ще один спосіб,

234
00:14:43,429 --> 00:14:47,707
яким ви можете думати про згортку, це створити цю таблицю всіх

235
00:14:47,707 --> 00:14:52,528
попарних добутків, а потім додати ці попарні добутки вздовж діагоналей.

236
00:14:52,528 --> 00:14:55,691
Звичайно, немає нічого конкретного щодо ймовірності, коли ви

237
00:14:55,691 --> 00:14:59,321
складаєте два різні списки чисел, ви можете думати про це таким чином.

238
00:14:59,321 --> 00:15:02,800
Створіть таку таблицю множення з усіма попарними продуктами, а потім

239
00:15:02,800 --> 00:15:06,381
кожна сума по діагоналі відповідає одному з ваших кінцевих результатів.

240
00:15:06,381 --> 00:15:12,431
Один контекст, де цей погляд особливо природний, це коли ви множите разом два поліноми.

241
00:15:12,431 --> 00:15:18,175
Наприклад, дозвольте мені взяти маленьку сітку, яку ми вже маємо, і замінити

242
00:15:18,175 --> 00:15:23,920
верхні члени на 1, 2x і 3x у квадраті, а інші члени на 4, 5x і 6x у квадраті.

243
00:15:23,920 --> 00:15:26,362
А тепер подумайте, що це означає, коли ми створюємо

244
00:15:26,362 --> 00:15:28,664
всі ці різні попарні продукти між двома списками.

245
00:15:28,664 --> 00:15:33,135
Те, що ви робите, по суті, розширюєте повний добуток двох поліномів,

246
00:15:33,135 --> 00:15:37,865
які я записав, а потім, коли ви додаєте вздовж діагоналі, яка відповідає

247
00:15:37,865 --> 00:15:42,530
збору всіх подібних доданків, що є досить акуратним, розширюючи поліном

248
00:15:42,530 --> 00:15:46,937
і збираючи подібні доданки, це точно той самий процес, що й згортка.

249
00:15:46,937 --> 00:15:52,642
Але це дозволяє нам робити щось дуже круте, тому що подумайте про те, що ми тут говоримо.

250
00:15:52,642 --> 00:15:57,955
Ми говоримо, що якщо ви берете дві різні функції та перемножуєте їх разом, що є простою

251
00:15:57,955 --> 00:16:03,207
поточковою операцією, це те ж саме, що якби ви спочатку витягли коефіцієнти з кожної з

252
00:16:03,207 --> 00:16:07,976
них, припускаючи, що вони є поліномами, а потім зробили згортку цих два списки

253
00:16:07,976 --> 00:16:08,761
коефіцієнтів.

254
00:16:08,761 --> 00:16:12,905
Що робить це таким цікавим, так це те, що згортки в принципі здаються набагато

255
00:16:12,905 --> 00:16:17,258
складнішими, ніж просте множення, і я маю на увазі не просто концептуально, що про

256
00:16:17,258 --> 00:16:21,402
них важче думати, я маю на увазі, що з обчислювальної точки зору для виконання

257
00:16:21,402 --> 00:16:26,070
згортки потрібно більше кроків, ніж для виконання поточковий добуток двох різних списків.

258
00:16:26,070 --> 00:16:30,646
Наприклад, скажімо, я дав вам два справді великі поліноми, скажімо, кожен із

259
00:16:30,646 --> 00:16:35,580
сотнею різних коефіцієнтів, тоді, якби ви їх помножили, щоб розширити цей добуток,

260
00:16:35,580 --> 00:16:40,572
який ви знаєте, заповнивши всю цю сітку 100 на 100 попарних добутків, що вимагатиме

261
00:16:40,572 --> 00:16:45,387
від вас виконайте 10 000 різних продуктів, а потім, коли ви збираєте всі подібні

262
00:16:45,387 --> 00:16:49,666
терміни вздовж діагоналей, це ще один набір приблизно з 10 000 операцій.

263
00:16:49,666 --> 00:16:55,117
У більш загальному жаргоні ми б сказали, що алгоритм є O з n у квадраті, що означає для

264
00:16:55,117 --> 00:17:00,692
двох списків розміром n таким чином, що кількість масштабів операцій пропорційна квадрату

265
00:17:00,692 --> 00:17:00,816
n.

266
00:17:00,816 --> 00:17:05,671
З іншого боку, якщо я думаю про два поліноми в термінах їхніх виходів, наприклад,

267
00:17:05,671 --> 00:17:10,823
вибірка їхніх значень на кількох вхідних даних, тоді їх множення потребує лише стільки

268
00:17:10,823 --> 00:17:15,974
операцій, скільки вибірок, оскільки це знову ж таки поточкова операція, а з поліномами

269
00:17:15,974 --> 00:17:21,126
вам потрібно лише кінцеву кількість вибірок, щоб мати можливість відновити коефіцієнти.

270
00:17:21,126 --> 00:17:26,200
Наприклад, двох виходів достатньо, щоб однозначно вказати лінійний поліном, трьох виходів

271
00:17:26,200 --> 00:17:31,217
буде достатньо, щоб однозначно вказати квадратичний поліном, і загалом, якщо ви знаєте n

272
00:17:31,217 --> 00:17:35,840
різних виходів, цього достатньо, щоб унікально вказати поліном, який має n різних

273
00:17:35,840 --> 00:17:40,858
коефіцієнтів, або, якщо хочете, ми можемо сформулюйте це мовою систем рівнянь, уявіть, я

274
00:17:40,858 --> 00:17:45,819
кажу вам, що у мене є якийсь поліном, але я не скажу вам, що це за коефіцієнти, для вас

275
00:17:45,819 --> 00:17:46,439
це загадка.

276
00:17:46,439 --> 00:17:50,836
У нашому прикладі ви можете подумати про це як про добуток, який ми намагаємося

277
00:17:50,836 --> 00:17:55,727
з’ясувати, а потім припустимо, я скажу, що я просто скажу вам, якими були б виходи цього

278
00:17:55,727 --> 00:18:00,454
полінома, якби ви ввели різні вхідні дані, наприклад 0, 1, 2 , 3, і далі, і я даю вам

279
00:18:00,454 --> 00:18:05,400
достатньо, щоб у вас було стільки ж рівнянь, скільки невідомих. Це навіть лінійна система

280
00:18:05,400 --> 00:18:10,347
рівнянь, так що це добре, і в принципі принаймні цього має бути достатньо для відновлення

281
00:18:10,347 --> 00:18:11,061
коефіцієнтів.

