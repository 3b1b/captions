1
00:00:00,000 --> 00:00:03,763
Предположим, я даю вам два разных списка чисел или, может быть, две разные функции,

2
00:00:03,763 --> 00:00:07,615
и прошу вас подумать обо всех способах, которыми вы можете объединить эти два списка,

3
00:00:07,615 --> 00:00:10,438
чтобы получить новый список чисел, или объединить две функции,

4
00:00:10,438 --> 00:00:11,737
чтобы получить новую функцию.

5
00:00:11,737 --> 00:00:14,475
Возможно, один простой способ, который приходит на ум,

6
00:00:14,475 --> 00:00:16,267
— это просто складывать их почленно.

7
00:00:16,267 --> 00:00:20,050
Аналогично с функциями вы можете добавить все соответствующие выходы.

8
00:00:20,050 --> 00:00:23,258
Подобным же образом вы можете умножить два списка

9
00:00:23,258 --> 00:00:26,145
почленно и проделать то же самое с функциями.

10
00:00:26,145 --> 00:00:29,866
Но есть еще один вид комбинации, столь же фундаментальный,

11
00:00:29,866 --> 00:00:33,840
как и оба, но гораздо менее обсуждаемый, известный как свертка.

12
00:00:33,840 --> 00:00:37,960
Но в отличие от двух предыдущих случаев, это не просто унаследовано от операции,

13
00:00:37,960 --> 00:00:39,893
которую вы можете выполнить с числами.

14
00:00:39,893 --> 00:00:44,716
Это что-то действительно новое для контекста списков чисел или объединения функций.

15
00:00:44,716 --> 00:00:48,754
Они появляются повсюду, они повсеместно используются при обработке изображений,

16
00:00:48,754 --> 00:00:52,438
это основная конструкция теории вероятностей, они часто используются при

17
00:00:52,438 --> 00:00:55,365
решении дифференциальных уравнений, и есть один контекст,

18
00:00:55,365 --> 00:00:59,100
где вы почти наверняка видели это, если не под этим названием перемножает

19
00:00:59,100 --> 00:01:00,210
два многочлена вместе.

20
00:01:00,210 --> 00:01:04,330
Для человека, занимающегося визуальными объяснениями, это особенно интересная тема,

21
00:01:04,330 --> 00:01:08,156
потому что шаблонное определение изолированно и без контекста может выглядеть

22
00:01:08,156 --> 00:01:12,374
отчасти устрашающе, но если мы потратим время на то, чтобы по-настоящему раскрыть то,

23
00:01:12,374 --> 00:01:15,121
что оно говорит, и до этого действительно мотивировать,

24
00:01:15,121 --> 00:01:18,800
почему вам бы хотелось чего-то подобного, это невероятно красивая операция.

25
00:01:18,800 --> 00:01:21,306
И я должен признать, что я действительно кое-чему научился,

26
00:01:21,306 --> 00:01:23,436
пока создавал визуальные эффекты для этого проекта.

27
00:01:23,436 --> 00:01:27,731
В случае свертки двух разных функций я пытался придумать разные способы представить,

28
00:01:27,731 --> 00:01:31,623
что это может означать, и с одним из них у меня возник небольшой ага-момент,

29
00:01:31,623 --> 00:01:36,019
почему нормальное распределение играет ту роль, которую они делают это с вероятностью,

30
00:01:36,019 --> 00:01:38,445
почему это такая естественная форма для функции.

31
00:01:38,445 --> 00:01:41,580
Но я забегаю вперед, для этого есть много настроек.

32
00:01:41,580 --> 00:01:45,658
В этом видео наше основное внимание будет сосредоточено на дискретном случае и,

33
00:01:45,658 --> 00:01:50,196
в частности, на создании очень неожиданного, но очень умного алгоритма для их вычисления.

34
00:01:50,196 --> 00:01:57,840
А обсуждение непрерывного случая я вынесу во вторую часть.

35
00:01:57,840 --> 00:02:00,719
Очень заманчиво начать с примеров обработки изображений,

36
00:02:00,719 --> 00:02:04,052
поскольку они визуально наиболее интригуют, но есть пара мелочей,

37
00:02:04,052 --> 00:02:08,497
которые делают случай обработки изображений менее репрезентативным для сверток в целом,

38
00:02:08,497 --> 00:02:11,882
поэтому вместо этого давайте начнем с вероятности, и, в частности,

39
00:02:11,882 --> 00:02:14,559
один из самых простых примеров, о котором, я уверен,

40
00:02:14,559 --> 00:02:17,893
каждый здесь задумывался в какой-то момент своей жизни, а именно:

41
00:02:17,893 --> 00:02:21,530
бросить пару игральных костей и вычислить шансы увидеть различные суммы.

42
00:02:21,530 --> 00:02:24,170
И вы можете сказать: не проблема, не проблема.

43
00:02:24,170 --> 00:02:28,259
Каждая из ваших двух игральных костей имеет шесть различных возможных результатов,

44
00:02:28,259 --> 00:02:31,756
что дает нам в общей сложности 36 различных возможных пар результатов,

45
00:02:31,756 --> 00:02:34,614
и если мы просто просмотрим их все, мы сможем подсчитать,

46
00:02:34,614 --> 00:02:36,240
сколько пар имеют заданную сумму.

47
00:02:36,240 --> 00:02:41,107
При таком расположении всех пар в сетке есть одна приятная вещь: все пары,

48
00:02:41,107 --> 00:02:45,650
имеющие постоянную сумму, видны вдоль одной из этих разных диагоналей.

49
00:02:45,650 --> 00:02:50,168
Таким образом, простой подсчет количества чисел на каждой из этих диагоналей покажет вам,

50
00:02:50,168 --> 00:02:52,880
насколько вероятно, что вы увидите определенную сумму.

51
00:02:52,880 --> 00:02:55,604
И я бы сказал, очень хорошо, очень хорошо, но можете ли вы

52
00:02:55,604 --> 00:02:58,699
придумать какой-нибудь другой способ визуализировать тот же вопрос?

53
00:02:58,699 --> 00:03:02,650
Другие образы, которые могут прийти на ум, если подумать обо всех различных парах,

54
00:03:02,650 --> 00:03:03,744
имеющих заданную сумму?

55
00:03:03,744 --> 00:03:07,550
И, возможно, кто-то из вас поднимет руку и скажет: «Да, он у меня есть».

56
00:03:07,550 --> 00:03:12,225
Допустим, вы представляете эти два разных набора возможностей каждый подряд,

57
00:03:12,225 --> 00:03:14,046
но переворачиваете второй ряд.

58
00:03:14,046 --> 00:03:18,960
Таким образом, все пары, составляющие в сумме семь, выстраиваются вертикально вот так.

59
00:03:18,960 --> 00:03:22,421
А если мы сдвинем этот нижний ряд до упора вправо, то единственная пара,

60
00:03:22,421 --> 00:03:26,309
которая в сумме дает два, — змеиные глаза, — будет единственной, которая совпадет.

61
00:03:26,309 --> 00:03:29,929
И если я сдвину это на одну единицу вправо, пары, которые выровняются,

62
00:03:29,929 --> 00:03:32,886
окажутся двумя разными парами, сумма которых составит три.

63
00:03:32,886 --> 00:03:37,277
И вообще, разные значения смещения этого нижнего массива, который, как я помню,

64
00:03:37,277 --> 00:03:41,778
сначала пришлось перевернуть, выявляют все отдельные пары, имеющие заданную сумму.

65
00:03:41,778 --> 00:03:47,449
Что касается вопросов вероятности, то это пока не особенно интересно, потому что все,

66
00:03:47,449 --> 00:03:53,120
что мы делаем, — это подсчитываем, сколько исходов имеется в каждой из этих категорий.

67
00:03:53,120 --> 00:03:57,850
Но это при неявном предположении, что у каждого из этих лиц есть равные шансы появиться.

68
00:03:57,850 --> 00:04:00,691
Но что, если я скажу вам, что у меня есть особый набор игральных костей,

69
00:04:00,691 --> 00:04:01,897
который не является одинаковым?

70
00:04:01,897 --> 00:04:04,605
Возможно, синий кубик имеет свой собственный набор чисел,

71
00:04:04,605 --> 00:04:06,846
описывающий вероятность выпадения каждой грани,

72
00:04:06,846 --> 00:04:09,740
а красный кубик имеет свой собственный уникальный набор чисел.

73
00:04:09,740 --> 00:04:13,463
В этом случае, если вы хотите вычислить, скажем, вероятность увидеть двойку,

74
00:04:13,463 --> 00:04:17,042
вы должны умножить вероятность того, что на синем кубике выпадет единица,

75
00:04:17,042 --> 00:04:19,895
на вероятность того, что на красном кубике выпадет единица.

76
00:04:19,895 --> 00:04:23,720
А чтобы узнать шансы увидеть тройку, вы смотрите на две разные пары,

77
00:04:23,720 --> 00:04:27,322
где это возможно, и снова умножаете соответствующие вероятности,

78
00:04:27,322 --> 00:04:29,983
а затем складываете эти два произведения вместе.

79
00:04:29,983 --> 00:04:33,008
Точно так же вероятность увидеть четверку предполагает

80
00:04:33,008 --> 00:04:36,748
перемножение трех разных пар возможностей и сложение их всех вместе.

81
00:04:36,748 --> 00:04:42,035
И в духе составления некоторых формул давайте назовем эти верхние вероятности a1,

82
00:04:42,035 --> 00:04:45,903
a2, a3 и так далее, а нижние назовем b1, b2, b3 и так далее.

83
00:04:45,903 --> 00:04:51,060
И вообще, этот процесс, когда мы берём два разных массива чисел, переворачиваем второй,

84
00:04:51,060 --> 00:04:54,224
а затем выравниваем их с разными значениями смещения,

85
00:04:54,224 --> 00:04:57,154
берём кучу попарных произведений и складываем их,

86
00:04:57,154 --> 00:05:01,139
это один из фундаментальные способы думать о том, что такое свертка.

87
00:05:01,139 --> 00:05:06,742
Чтобы выразить это более точно, в ходе этого процесса мы просто сгенерировали

88
00:05:06,742 --> 00:05:11,410
вероятности увидеть два, три, четыре, и так далее, вплоть до 12,

89
00:05:11,410 --> 00:05:17,084
и мы получили их, смешав один список значений, a и другой. список ценностей, б.

90
00:05:17,084 --> 00:05:20,524
На жаргоне мы бы сказали, что свертка этих двух последовательностей дает

91
00:05:20,524 --> 00:05:23,869
нам новую последовательность, новую последовательность из 11 значений,

92
00:05:23,869 --> 00:05:27,120
каждое из которых выглядит как некоторая сумма попарных произведений.

93
00:05:27,120 --> 00:05:31,760
Если хотите, вы можете выполнить ту же операцию еще одним способом — сначала

94
00:05:31,760 --> 00:05:36,702
создать таблицу всех попарных произведений, а затем сложить их по всем диагоналям.

95
00:05:36,702 --> 00:05:39,740
Опять же, это способ смешать эти две последовательности чисел,

96
00:05:39,740 --> 00:05:42,247
чтобы получить новую последовательность из 11 чисел.

97
00:05:42,247 --> 00:05:45,474
Это та же самая операция, что и в случае с раздвижными окнами,

98
00:05:45,474 --> 00:05:46,960
только с другой точки зрения.

99
00:05:46,960 --> 00:05:50,314
Сделав небольшие примечания, вот как вы можете увидеть это записанным.

100
00:05:50,314 --> 00:05:55,981
Свертка a и b, обозначенная этой маленькой звездочкой, представляет собой новый список,

101
00:05:55,981 --> 00:05:59,007
и n-й элемент этого списка выглядит как сумма,

102
00:05:59,007 --> 00:06:04,738
и эта сумма охватывает все разные пары индексов i и j, так что сумма эти индексы равны n.

103
00:06:04,738 --> 00:06:10,569
Это довольно многословно, но, например, если n равно 6, мы рассматриваем пары:

104
00:06:10,569 --> 00:06:16,400
1 и 5, 2 и 4, 3 и 3, 4 и 2, 5 и 1, все разные пары, которые складываются. до 6.

105
00:06:16,400 --> 00:06:18,404
Но, честно говоря, как бы вы это ни записывали,

106
00:06:18,404 --> 00:06:21,620
обозначения второстепенны по сравнению с визуальным представлением процесса,

107
00:06:21,620 --> 00:06:23,082
которое вы можете держать в голове.

108
00:06:23,082 --> 00:06:27,826
Здесь, возможно, поможет очень простой пример, где я мог бы спросить вас,

109
00:06:27,826 --> 00:06:30,967
какова свертка списка 1, 2, 3 со списком 4, 5, 6.

110
00:06:30,967 --> 00:06:33,871
Вы можете представить, как берете оба этих списка,

111
00:06:33,871 --> 00:06:37,857
переворачиваете второй, а затем начинаете с его крышки до упора влево.

112
00:06:37,857 --> 00:06:40,532
Затем пара значений, которые совпадают, — это 1 и 4,

113
00:06:40,532 --> 00:06:43,813
умножаем их вместе, и это дает нам первый член нашего результата.

114
00:06:43,813 --> 00:06:48,997
Сдвиньте нижний массив на одну единицу вправо, выровняются пары: 1 и 5, а также 2 и 4,

115
00:06:48,997 --> 00:06:54,300
умножьте эти пары, сложите их вместе, и это даст нам 13, следующую запись в нашем выводе.

116
00:06:54,300 --> 00:07:01,591
Сдвиньте элементы еще раз, и мы возьмем 1×6, плюс 2×5, плюс 3×4, что составит 28.

117
00:07:01,591 --> 00:07:06,476
Еще один слайд, и мы получаем 2×6 плюс 3×5, что дает нам 27,

118
00:07:06,476 --> 00:07:10,560
и, наконец, последний член будет выглядеть как 3×6.

119
00:07:10,560 --> 00:07:14,732
Если хотите, вы можете использовать любой ваш любимый язык программирования и любимую

120
00:07:14,732 --> 00:07:18,807
библиотеку, включающую различные числовые операции, и подтвердить, что я вам не лгу.

121
00:07:18,807 --> 00:07:21,843
Если вы возьмете свертку 1, 2, 3 против 4, 5, 6,

122
00:07:21,843 --> 00:07:24,880
вы действительно получите именно такой результат.

123
00:07:24,880 --> 00:07:28,080
Мы видели один случай, когда это естественная и желательная операция,

124
00:07:28,080 --> 00:07:32,012
суммирующая распределения вероятностей, а другим распространенным примером может быть

125
00:07:32,012 --> 00:07:32,881
скользящее среднее.

126
00:07:32,881 --> 00:07:35,472
Представьте, что у вас есть длинный список чисел,

127
00:07:35,472 --> 00:07:38,788
и вы берете другой, меньший список чисел, сумма которых равна 1.

128
00:07:38,788 --> 00:07:43,381
В данном случае у меня есть небольшой список из 5 значений, и все они равны 15-му.

129
00:07:43,381 --> 00:07:48,655
Затем, если мы выполним этот процесс свертки скользящего окна, закроем глаза и заметим,

130
00:07:48,655 --> 00:07:53,989
что происходит в самом начале, когда наш меньший список значений полностью перекрывается

131
00:07:53,989 --> 00:07:59,023
с большим, подумайте о том, что каждый термин в этом действительно означает свертка.

132
00:07:59,023 --> 00:08:04,726
На каждой итерации вы умножаете каждое значение ваших данных на 15 и складываете их

133
00:08:04,726 --> 00:08:10,769
все вместе, то есть вы берете среднее значение ваших данных внутри этого маленького окна.

134
00:08:10,769 --> 00:08:13,887
В целом, этот процесс дает вам сглаженную версию исходных данных,

135
00:08:13,887 --> 00:08:17,099
и вы можете изменить ее, начиная с другого небольшого списка чисел,

136
00:08:17,099 --> 00:08:19,461
и пока весь этот небольшой список в сумме дает 1,

137
00:08:19,461 --> 00:08:22,816
вы все равно можете интерпретировать его как движущееся число. средний.

138
00:08:22,816 --> 00:08:25,298
В показанном здесь примере это скользящее среднее

139
00:08:25,298 --> 00:08:27,781
будет придавать больший вес центральному значению.

140
00:08:27,781 --> 00:08:33,200
Это также приводит к сглаженной версии данных.

141
00:08:33,200 --> 00:08:35,752
Если вы сделаете своего рода двумерный аналог этого,

142
00:08:35,752 --> 00:08:38,594
вы получите забавный алгоритм размытия данного изображения.

143
00:08:38,594 --> 00:08:41,173
И я должен сказать, что анимации, которые я собираюсь показать,

144
00:08:41,173 --> 00:08:44,277
являются модификациями того, что я изначально сделал для части серии лекций,

145
00:08:44,277 --> 00:08:47,501
которые я читал в лаборатории Джулии в Массачусетском технологическом институте

146
00:08:47,501 --> 00:08:50,887
для определенного класса OpenCourseWare, который включал блок обработки изображений.

147
00:08:50,887 --> 00:08:53,848
Там мы еще немного углубились в код всего этого, поэтому,

148
00:08:53,848 --> 00:08:56,452
если вам интересно, я оставлю вам несколько ссылок.

149
00:08:56,452 --> 00:08:58,846
Но если вернуться к этому примеру с размытием,

150
00:08:58,846 --> 00:09:03,176
то у меня есть небольшая сетка значений 3х3, которая проходит вдоль нашего исходного

151
00:09:03,176 --> 00:09:07,098
изображения, и если мы увеличим масштаб, каждое из этих значений будет 19-м,

152
00:09:07,098 --> 00:09:11,529
и что я делаю на каждой итерации каждое из этих значений умножается на соответствующий

153
00:09:11,529 --> 00:09:13,312
пиксель, над которым оно находится.

154
00:09:13,312 --> 00:09:17,799
И, конечно же, в информатике мы думаем о цветах как о маленьких векторах трех значений,

155
00:09:17,799 --> 00:09:20,400
представляющих красный, зеленый и синий компоненты.

156
00:09:20,400 --> 00:09:24,166
Когда я умножаю все эти маленькие значения на 19 и складываю их вместе,

157
00:09:24,166 --> 00:09:27,200
мы получаем среднее значение по каждому цветовому каналу,

158
00:09:27,200 --> 00:09:30,966
и соответствующий пиксель изображения справа определяется как эта сумма.

159
00:09:30,966 --> 00:09:34,984
Общий эффект, когда мы делаем это для каждого отдельного пикселя изображения,

160
00:09:34,984 --> 00:09:39,156
заключается в том, что каждый из них как бы просачивается на всех своих соседей,

161
00:09:39,156 --> 00:09:41,680
что дает нам более размытую версию, чем оригинал.

162
00:09:41,680 --> 00:09:44,809
На жаргоне мы бы сказали, что изображение справа представляет собой

163
00:09:44,809 --> 00:09:47,800
свертку нашего исходного изображения с небольшой сеткой значений.

164
00:09:47,800 --> 00:09:50,354
Или более технически, может быть, я должен сказать,

165
00:09:50,354 --> 00:09:54,430
что это свертка с повернутой на 180 градусов версией этой маленькой сетки значений.

166
00:09:54,430 --> 00:09:58,607
Не то чтобы это имело значение, когда сетка симметрична, но просто стоит иметь в виду,

167
00:09:58,607 --> 00:10:02,255
что определение свертки, унаследованное из чисто математического контекста,

168
00:10:02,255 --> 00:10:05,760
всегда должно побуждать вас задуматься о переворачивании второго массива.

169
00:10:05,760 --> 00:10:09,768
Если мы немного изменим это, мы сможем получить гораздо более элегантный эффект размытия,

170
00:10:09,768 --> 00:10:11,059
выбрав другую сетку значений.

171
00:10:11,059 --> 00:10:15,920
В данном случае у меня есть небольшая сетка 5х5, но разница не столько в ее размере.

172
00:10:15,920 --> 00:10:19,685
Если мы увеличим масштаб, мы заметим, что значение в середине намного больше,

173
00:10:19,685 --> 00:10:22,003
чем значение по краям, и это происходит потому,

174
00:10:22,003 --> 00:10:26,010
что все они выбраны из колоколообразной кривой, известной как распределение Гаусса.

175
00:10:26,010 --> 00:10:29,768
Таким образом, когда мы умножаем все эти значения на соответствующий пиксель,

176
00:10:29,768 --> 00:10:32,947
над которым они расположены, мы придаем гораздо больший вес этому

177
00:10:32,947 --> 00:10:36,367
центральному пикселю и гораздо меньший вес тем, кто находится по краям.

178
00:10:36,367 --> 00:10:40,373
И, как и раньше, соответствующий пиксель справа определяется как эта сумма.

179
00:10:40,373 --> 00:10:43,887
Поскольку мы проделываем этот процесс для каждого отдельного пикселя,

180
00:10:43,887 --> 00:10:46,848
это дает эффект размытия, который гораздо более достоверно

181
00:10:46,848 --> 00:10:49,760
имитирует расфокусировку объектива или что-то в этом роде.

182
00:10:49,760 --> 00:10:53,474
Но размытие — далеко не единственное, что можно сделать с помощью этой идеи.

183
00:10:53,474 --> 00:10:55,979
Например, взгляните на эту небольшую сетку значений,

184
00:10:55,979 --> 00:10:59,052
которая включает несколько положительных чисел слева и несколько

185
00:10:59,052 --> 00:11:03,071
отрицательных чисел справа, которые я раскрасю синим и красным цветом соответственно.

186
00:11:03,071 --> 00:11:06,786
Найдите минутку и посмотрите, сможете ли вы предсказать и понять,

187
00:11:06,786 --> 00:11:09,769
какой эффект это окажет на окончательное изображение.

188
00:11:09,769 --> 00:11:13,784
Итак, в этом случае я буду просто думать об изображении как о цветном,

189
00:11:13,784 --> 00:11:18,082
а не о цветном, поэтому каждый пиксель представлен одним числом вместо трех.

190
00:11:18,082 --> 00:11:20,645
И стоит отметить одну вещь: при выполнении этой

191
00:11:20,645 --> 00:11:23,102
свертки можно получить отрицательные значения.

192
00:11:23,102 --> 00:11:26,735
Например, на этом этапе, если мы увеличим левую половину нашей маленькой сетки,

193
00:11:26,735 --> 00:11:30,595
она полностью окажется поверх черных пикселей, которые будут иметь нулевое значение,

194
00:11:30,595 --> 00:11:34,137
но вся правая половина отрицательных значений окажется поверх белых пикселей,

195
00:11:34,137 --> 00:11:36,000
что будет иметь значение, равное единице.

196
00:11:36,000 --> 00:11:39,179
Поэтому, когда мы умножаем соответствующие термины и складываем их вместе,

197
00:11:39,179 --> 00:11:42,570
результаты будут очень отрицательными, и я показываю это на изображении справа:

198
00:11:42,570 --> 00:11:46,046
окрашиваю отрицательные значения в красный цвет, а положительные значения в синий.

199
00:11:46,046 --> 00:11:48,490
Еще одна вещь, на которую следует обратить внимание:

200
00:11:48,490 --> 00:11:51,026
когда вы находитесь на участке одного и того же цвета,

201
00:11:51,026 --> 00:11:54,854
все обращается к нулю, поскольку сумма значений в нашей маленькой сетке равна нулю.

202
00:11:54,854 --> 00:11:56,982
Это сильно отличается от двух предыдущих примеров,

203
00:11:56,982 --> 00:11:59,151
где сумма нашей маленькой сетки была равна единице,

204
00:11:59,151 --> 00:12:01,822
что позволяет нам интерпретировать ее как скользящее среднее и,

205
00:12:01,822 --> 00:12:02,990
следовательно, как размытие.

206
00:12:02,990 --> 00:12:07,402
В общем, этот небольшой процесс в основном обнаруживает изменения

207
00:12:07,402 --> 00:12:10,543
в значении пикселя при движении слева направо,

208
00:12:10,543 --> 00:12:16,560
и поэтому он дает вам своего рода способ уловить все вертикальные края вашего изображения.

209
00:12:16,560 --> 00:12:19,245
И аналогичным образом, если мы повернем эту сетку так,

210
00:12:19,245 --> 00:12:22,614
чтобы она менялась при движении сверху вниз, это будет отражаться на

211
00:12:22,614 --> 00:12:26,178
всех горизонтальных краях, что в случае с изображением нашего маленького

212
00:12:26,178 --> 00:12:29,986
пирога-существа действительно приводит к появлению довольно демонических глаз.

213
00:12:29,986 --> 00:12:33,471
Эту меньшую сетку, кстати, часто называют ядром, и прелесть здесь в том, что,

214
00:12:33,471 --> 00:12:37,224
просто выбрав другое ядро, вы можете получить разные эффекты обработки изображения,

215
00:12:37,224 --> 00:12:40,710
не только размытие обнаружения краев, но и такие вещи, как повышение резкости.

216
00:12:40,710 --> 00:12:44,495
Для тех из вас, кто слышал о сверточной нейронной сети, идея состоит в том,

217
00:12:44,495 --> 00:12:48,729
чтобы использовать данные, чтобы выяснить, какими должны быть ядра в первую очередь,

218
00:12:48,729 --> 00:12:51,618
что определяется тем, что нейронная сеть хочет обнаружить.

219
00:12:51,618 --> 00:12:55,378
Еще одна вещь, о которой мне, возможно, следует упомянуть, — это длина вывода.

220
00:12:55,378 --> 00:12:59,273
Для чего-то вроде примера со скользящим средним вы можете думать об условиях только

221
00:12:59,273 --> 00:13:01,917
тогда, когда оба окна полностью совпадают друг с другом,

222
00:13:01,917 --> 00:13:04,745
или в примере с обработкой изображения, возможно, вы хотите,

223
00:13:04,745 --> 00:13:07,760
чтобы окончательный результат имел тот же размер, что и оригинал.

224
00:13:07,760 --> 00:13:10,919
Теперь свертки как чисто математическая операция всегда создают массив,

225
00:13:10,919 --> 00:13:14,035
который больше, чем два массива, с которых вы начали, по крайней мере,

226
00:13:14,035 --> 00:13:16,405
при условии, что длина одного из них не равна единице.

227
00:13:16,405 --> 00:13:19,195
Просто знайте, что в некоторых контекстах информатики

228
00:13:19,195 --> 00:13:21,520
вам часто нужно намеренно урезать этот вывод.

229
00:13:21,520 --> 00:13:24,398
Еще одна вещь, которую стоит подчеркнуть, это то,

230
00:13:24,398 --> 00:13:28,139
что в контексте информатики идея переворачивания ядра перед тем,

231
00:13:28,139 --> 00:13:33,147
как позволить ему пройти по оригиналу, часто кажется очень странной и просто ненужной,

232
00:13:33,147 --> 00:13:37,291
но еще раз обратите внимание, что это то, что унаследовано из контекста

233
00:13:37,291 --> 00:13:41,493
чистой математики, где, как мы видел, что с вероятностями это невероятно

234
00:13:41,493 --> 00:13:42,530
естественная вещь.

235
00:13:42,530 --> 00:13:45,901
И на самом деле я могу показать вам еще один чисто математический пример,

236
00:13:45,901 --> 00:13:48,088
который должен интересовать даже программистов,

237
00:13:48,088 --> 00:13:51,322
потому что он открывает двери для гораздо более быстрого алгоритма для

238
00:13:51,322 --> 00:13:52,370
вычисления всего этого.

239
00:13:52,370 --> 00:13:54,786
Чтобы настроить то, что я подразумеваю под словом «быстрее»,

240
00:13:54,786 --> 00:13:57,123
позвольте мне вернуться назад и снова использовать Python,

241
00:13:57,123 --> 00:13:59,579
и я собираюсь создать два разных относительно больших массива.

242
00:13:59,579 --> 00:14:02,890
В каждом из них будет сто тысяч случайных элементов,

243
00:14:02,890 --> 00:14:07,575
и я собираюсь оценить время выполнения функции свертки из библиотеки numpy.

244
00:14:07,575 --> 00:14:12,410
И в этом случае он запускает несколько разных итераций, пытается найти среднее значение,

245
00:14:12,410 --> 00:14:16,321
и похоже, что на этом компьютере оно составляет как минимум 4.87 секунд.

246
00:14:16,321 --> 00:14:21,814
Напротив, если я использую другую функцию из библиотеки scipy под названием fftconvolve,

247
00:14:21,814 --> 00:14:26,505
которая представляет собой то же самое, но реализовано по-другому и требует

248
00:14:26,505 --> 00:14:30,640
всего 4.В среднем 3 миллисекунды, то есть улучшение на три порядка.

249
00:14:30,640 --> 00:14:33,445
И опять же, несмотря на то, что она работает под другим именем,

250
00:14:33,445 --> 00:14:36,031
она выдает тот же результат, что и другая функция свертки,

251
00:14:36,031 --> 00:14:38,880
она просто делает что-то, чтобы сделать это более умным способом.

252
00:14:38,880 --> 00:14:42,327
Помните, как в примере с вероятностью я говорил,

253
00:14:42,327 --> 00:14:48,588
что еще один способ подумать о свертке — это создать таблицу всех попарных произведений,

254
00:14:48,588 --> 00:14:52,528
а затем сложить эти попарные произведения по диагоналям.

255
00:14:52,528 --> 00:14:55,338
Конечно, в вероятности нет ничего особенного, и каждый раз,

256
00:14:55,338 --> 00:14:59,321
когда вы складываете два разных списка чисел, вы можете думать об этом таким образом.

257
00:14:59,321 --> 00:15:02,303
Создайте такую таблицу умножения со всеми попарными произведениями,

258
00:15:02,303 --> 00:15:05,854
и тогда каждая сумма по диагонали будет соответствовать одному из ваших конечных

259
00:15:05,854 --> 00:15:06,381
результатов.

260
00:15:06,381 --> 00:15:10,231
Один из контекстов, где эта точка зрения особенно естественна,

261
00:15:10,231 --> 00:15:12,431
— это перемножение двух многочленов.

262
00:15:12,431 --> 00:15:17,960
Например, позвольте мне взять уже имеющуюся у нас маленькую сетку и заменить

263
00:15:17,960 --> 00:15:23,920
верхние члены на 1, 2x и 3x в квадрате, а остальные члены на 4, 5x и 6x в квадрате.

264
00:15:23,920 --> 00:15:26,224
Теперь подумайте, что это значит, когда мы создаем

265
00:15:26,224 --> 00:15:28,664
все эти разные попарные продукты между двумя списками.

266
00:15:28,664 --> 00:15:33,128
То, что вы делаете, по сути, расширяет полное произведение двух записанных

267
00:15:33,128 --> 00:15:36,759
мною многочленов, а затем, когда вы суммируете по диагонали,

268
00:15:36,759 --> 00:15:40,925
что соответствует сбору всех подобных членов, что довольно аккуратно,

269
00:15:40,925 --> 00:15:45,151
расширение полинома и сбор подобных членов - это именно то, что нужно.

270
00:15:45,151 --> 00:15:46,937
тот же процесс, что и свертка.

271
00:15:46,937 --> 00:15:49,761
Но это позволяет нам сделать что-то очень крутое,

272
00:15:49,761 --> 00:15:52,642
потому что подумайте о том, о чем мы здесь говорим.

273
00:15:52,642 --> 00:15:56,645
Мы говорим, что если вы берете две разные функции и перемножаете их вместе,

274
00:15:56,645 --> 00:16:00,280
что представляет собой простую поточечную операцию, это то же самое,

275
00:16:00,280 --> 00:16:04,284
как если бы вы сначала извлекли коэффициенты из каждой из них, предполагая,

276
00:16:04,284 --> 00:16:08,761
что они являются полиномами, а затем произвели свертку этих два списка коэффициентов.

277
00:16:08,761 --> 00:16:11,212
Что делает это настолько интересным, так это то,

278
00:16:11,212 --> 00:16:14,764
что свертки в принципе кажутся намного сложнее, чем простое умножение,

279
00:16:14,764 --> 00:16:18,866
и я не просто имею в виду, что концептуально о них труднее думать, я имею в виду,

280
00:16:18,866 --> 00:16:22,918
что с вычислительной точки зрения для выполнения свертки требуется больше шагов,

281
00:16:22,918 --> 00:16:26,070
чем для выполнения поточечное произведение двух разных списков.

282
00:16:26,070 --> 00:16:30,140
Например, предположим, я дал вам два действительно больших многочлена, скажем,

283
00:16:30,140 --> 00:16:32,613
каждый с сотней различных коэффициентов, тогда,

284
00:16:32,613 --> 00:16:36,734
если способ их умножения заключался в расширении этого известного вам продукта,

285
00:16:36,734 --> 00:16:40,135
заполняя всю эту сетку попарных произведений размером 100 на 100,

286
00:16:40,135 --> 00:16:44,050
что потребовало бы от вас выполнить 10 000 различных произведений, а затем,

287
00:16:44,050 --> 00:16:46,936
когда вы соберете все одинаковые термины по диагоналям,

288
00:16:46,936 --> 00:16:49,666
получится еще один набор из примерно 10 000 операций.

289
00:16:49,666 --> 00:16:52,173
В более общем смысле на жаргоне мы бы сказали,

290
00:16:52,173 --> 00:16:54,894
что алгоритм представляет собой O из n в квадрате,

291
00:16:54,894 --> 00:16:58,575
что означает для двух списков размера n, то есть количество операций

292
00:16:58,575 --> 00:17:00,816
масштабируется пропорционально квадрату n.

293
00:17:00,816 --> 00:17:05,384
С другой стороны, если я думаю о двух полиномах с точки зрения их выходных данных,

294
00:17:05,384 --> 00:17:08,797
например, о выборке их значений на нескольких входных данных,

295
00:17:08,797 --> 00:17:12,980
то для их умножения требуется столько операций, сколько количество выборок,

296
00:17:12,980 --> 00:17:17,053
поскольку опять же это точечная операция, а с полиномами вам нужно только

297
00:17:17,053 --> 00:17:21,126
конечное число выборок, чтобы иметь возможность восстановить коэффициенты.

298
00:17:21,152 --> 00:17:25,214
Например, двух выходных данных достаточно, чтобы однозначно указать линейный полином.

299
00:17:25,214 --> 00:17:29,360
Трех выходных данных будет достаточно, чтобы однозначно определить квадратичный полином.

300
00:17:29,360 --> 00:17:33,323
И вообще, если вы знаете n различных выходных данных, этого достаточно,

301
00:17:33,323 --> 00:17:36,901
чтобы однозначно указать полином, имеющий n разных коэффициентов.

302
00:17:36,901 --> 00:17:41,188
Или, если хотите, мы могли бы сформулировать это на языке систем уравнений.

303
00:17:41,188 --> 00:17:43,899
Представьте, что я говорю вам, что у меня есть некий полином,

304
00:17:43,899 --> 00:17:46,480
но не говорю, что это за коэффициенты, это для вас загадка.

305
00:17:46,480 --> 00:17:50,666
В нашем примере вы можете думать об этом как о продукте, который мы пытаемся выяснить.

306
00:17:50,666 --> 00:17:55,178
Тогда предположим, что я просто скажу вам, какими будут выходные данные этого полинома,

307
00:17:55,178 --> 00:17:59,126
если вы введете различные входные данные, такие как 0, 1, 2, 3, и так далее,

308
00:17:59,126 --> 00:18:02,202
и я дам вам достаточно, чтобы у вас было столько уравнений,

309
00:18:02,202 --> 00:18:03,791
сколько у вас есть неизвестные.

310
00:18:03,791 --> 00:18:07,245
Это даже линейная система уравнений, и это здорово.

311
00:18:07,245 --> 00:18:09,295
И в принципе, по крайней мере, этого должно быть

312
00:18:09,295 --> 00:18:11,137
достаточно для восстановления коэффициентов.

313
00:18:11,137 --> 00:18:13,916
Таким образом, грубая схема алгоритма будет такой: всякий раз,

314
00:18:13,916 --> 00:18:16,915
когда вы хотите свернуть два списка чисел, вы относитесь к ним так,

315
00:18:16,915 --> 00:18:19,253
как будто они являются коэффициентами двух полиномов.

316
00:18:19,253 --> 00:18:23,329
Вы выбираете эти полиномы на достаточном количестве выходных данных,

317
00:18:23,329 --> 00:18:26,756
умножаете эти выборки поточечно, а затем решаете систему,

318
00:18:26,756 --> 00:18:31,364
чтобы восстановить коэффициенты, используя хитрый черный способ найти свертку.

319
00:18:31,364 --> 00:18:34,282
И, по крайней мере, как я уже говорил, некоторые из вас

320
00:18:34,282 --> 00:18:37,564
могли бы справедливо пожаловаться: «Грант, это идиотский план».

321
00:18:37,564 --> 00:18:41,310
Потому что, во-первых, просто вычисление всех этих выборок для одного

322
00:18:41,310 --> 00:18:45,056
из известных нам полиномов уже требует порядка n операций в квадрате,

323
00:18:45,056 --> 00:18:48,214
не говоря уже о том, что решение этой системы, безусловно,

324
00:18:48,214 --> 00:18:52,656
будет в вычислительном отношении столь же сложным, как и просто выполнение свертки.

325
00:18:52,656 --> 00:18:56,571
Итак, конечно, у нас есть связь между умножением и свертками,

326
00:18:56,571 --> 00:19:01,054
но вся сложность возникает при переводе с одной точки зрения на другую.

327
00:19:01,054 --> 00:19:05,934
Но есть одна хитрость, и те из вас, кто знает о преобразованиях Фурье и алгоритме БПФ,

328
00:19:05,934 --> 00:19:07,673
могут понять, к чему это ведет.

329
00:19:07,673 --> 00:19:10,444
Если вы не знакомы с этими темами, то, что я собираюсь сказать,

330
00:19:10,444 --> 00:19:12,176
может показаться совершенно неожиданным.

331
00:19:12,176 --> 00:19:15,329
Просто знайте, что в математике есть определенные пути,

332
00:19:15,329 --> 00:19:17,582
которые делают этот шаг более ожидаемым.

333
00:19:17,582 --> 00:19:20,697
По сути, идея в том, что у нас здесь есть свобода выбора.

334
00:19:20,697 --> 00:19:25,419
Если вместо оценки произвольного набора входных данных, например 0, 1, 2, 3,

335
00:19:25,419 --> 00:19:30,080
и так далее, вы решите оценить специально выбранный набор комплексных чисел.

336
00:19:30,080 --> 00:19:33,569
В частности, те, которые расположены на равном расстоянии от единичного круга,

337
00:19:33,569 --> 00:19:34,894
так называемые корни единства.

338
00:19:34,894 --> 00:19:37,364
Это дает нам более дружественную систему.

339
00:19:37,364 --> 00:19:40,038
Основная идея заключается в том, что нахождение числа,

340
00:19:40,038 --> 00:19:43,537
при котором принятие его полномочий попадает в этот циклический шаблон,

341
00:19:43,537 --> 00:19:47,232
означает, что система, которую мы создаем, будет иметь большую избыточность

342
00:19:47,232 --> 00:19:51,266
в различных терминах, которые вы рассчитываете, и благодаря умному подходу к тому,

343
00:19:51,266 --> 00:19:55,252
как Если вы воспользуетесь этой избыточностью, вы сможете сэкономить массу работы.

344
00:19:55,252 --> 00:19:59,065
Этот набор выходных данных, который я написал, имеет специальное название:

345
00:19:59,065 --> 00:20:02,166
он называется дискретным преобразованием Фурье коэффициентов.

346
00:20:02,166 --> 00:20:04,429
И если вы хотите узнать больше, я на самом деле прочитал еще

347
00:20:04,429 --> 00:20:07,434
одну лекцию для того же курса Джулии в Массачусетском технологическом институте,

348
00:20:07,434 --> 00:20:09,103
посвященную дискретным преобразованиям Фурье.

349
00:20:09,103 --> 00:20:11,808
А еще на канале Reducible есть действительно отличное видео,

350
00:20:11,808 --> 00:20:14,336
в котором рассказывается о быстром преобразовании Фурье,

351
00:20:14,336 --> 00:20:17,263
которое представляет собой алгоритм для более быстрого вычисления.

352
00:20:17,263 --> 00:20:20,607
Кроме того, компания Veritasium недавно выпустила действительно хорошее видео о БПФ,

353
00:20:20,607 --> 00:20:21,984
так что у вас есть много вариантов.

354
00:20:21,984 --> 00:20:24,786
И этот быстрый алгоритм действительно важен для нас.

355
00:20:24,786 --> 00:20:28,247
Опять же, из-за всей этой избыточности существует метод перехода от

356
00:20:28,247 --> 00:20:32,065
коэффициентов ко всем этим выходным данным, где вместо выполнения операций

357
00:20:32,065 --> 00:20:35,730
порядка n в квадрате вы выполняете порядка n раз больше log n операций,

358
00:20:35,730 --> 00:20:39,293
что намного намного лучше, если вы масштабируетесь до больших списков.

359
00:20:39,293 --> 00:20:42,386
И что важно, этот алгоритм БПФ работает в обе стороны.

360
00:20:42,386 --> 00:20:45,515
Это также позволяет вам перейти от выходных данных к коэффициентам.

361
00:20:45,515 --> 00:20:49,054
Итак, собрав все это вместе, давайте еще раз взглянем на схему нашего алгоритма.

362
00:20:49,054 --> 00:20:53,508
Теперь мы можем сказать, что всякий раз, когда вам даны два длинных списка чисел и вы

363
00:20:53,508 --> 00:20:57,858
хотите выполнить их свертку, сначала вычислите быстрое преобразование Фурье каждого

364
00:20:57,858 --> 00:21:00,655
из них, о чем в глубине души вы можете просто думать,

365
00:21:00,655 --> 00:21:05,005
что относитесь к ним как к они являются коэффициентами многочлена и оценивают его в

366
00:21:05,005 --> 00:21:06,766
специально выбранном наборе точек.

367
00:21:06,766 --> 00:21:10,047
Затем умножьте два результата, которые вы только что получили,

368
00:21:10,047 --> 00:21:14,421
поточечно (это красиво и быстро), а затем выполните обратное быстрое преобразование

369
00:21:14,421 --> 00:21:18,847
Фурье, и это даст вам хитрый лазейочный способ вычисления свертки, которую мы искали.

370
00:21:18,847 --> 00:21:22,957
Но на этот раз это включает только O из n log n операций.

371
00:21:22,957 --> 00:21:24,865
Для меня это очень круто!

372
00:21:24,865 --> 00:21:29,712
Этот очень специфический контекст, в котором появляются свертки, умножающие два полинома,

373
00:21:29,712 --> 00:21:34,235
открывает двери для алгоритма, который применим везде, где могут возникнуть свертки.

374
00:21:34,235 --> 00:21:36,328
Если вы хотите добавить распределения вероятностей,

375
00:21:36,328 --> 00:21:38,822
выполните большую обработку изображений, какой бы она ни была.

376
00:21:38,822 --> 00:21:42,331
И я просто думаю, что это хороший пример того, почему вы должны волноваться,

377
00:21:42,331 --> 00:21:46,249
когда видите, что какая-то операция или концепция в математике проявляется во многих,

378
00:21:46,249 --> 00:21:47,798
казалось бы, несвязанных областях.

379
00:21:47,798 --> 00:21:51,967
Если вам нужно небольшое домашнее задание, вот о чем интересно подумать.

380
00:21:51,967 --> 00:21:56,465
Объясните, почему, когда вы умножаете два разных числа (обычное умножение,

381
00:21:56,465 --> 00:21:59,285
как мы все учимся в начальной школе), по сути,

382
00:21:59,285 --> 00:22:01,924
вы делаете свертку между цифрами этих чисел.

383
00:22:01,924 --> 00:22:05,101
Есть несколько дополнительных шагов с переносами и тому подобное,

384
00:22:05,101 --> 00:22:06,785
но основным шагом является свертка.

385
00:22:06,785 --> 00:22:09,844
В свете существования быстрого алгоритма это означает,

386
00:22:09,844 --> 00:22:12,680
что если у вас есть два очень больших целых числа,

387
00:22:12,680 --> 00:22:16,183
то существует способ найти их произведение быстрее, чем метод,

388
00:22:16,183 --> 00:22:18,240
который мы изучаем в начальной школе.

389
00:22:18,240 --> 00:22:21,646
Вместо того, чтобы требовать операций O из n в квадрате,

390
00:22:21,646 --> 00:22:25,291
требуется только O из n log n, что даже не кажется возможным.

391
00:22:25,291 --> 00:22:29,218
Загвоздка в том, что для того, чтобы это действительно пригодилось на практике,

392
00:22:29,218 --> 00:22:31,280
ваши цифры должны быть просто чудовищными.

393
00:22:31,280 --> 00:22:34,445
Но все равно круто, что такой алгоритм существует.

394
00:22:34,445 --> 00:22:37,167
Далее мы обратим внимание на непрерывный случай,

395
00:22:37,167 --> 00:22:40,000
уделив особое внимание распределениям вероятностей.

