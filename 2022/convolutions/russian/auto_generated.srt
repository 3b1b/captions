1
00:00:00,000 --> 00:00:03,629
Предположим, я даю вам два разных списка чисел или, может быть, две разные функции, 

2
00:00:03,629 --> 00:00:07,345
и прошу вас подумать обо всех способах, которыми вы можете объединить эти два списка, 

3
00:00:07,345 --> 00:00:10,067
чтобы получить новый список чисел, или объединить две функции, 

4
00:00:10,067 --> 00:00:11,320
чтобы получить новую функцию.

5
00:00:12,120 --> 00:00:14,924
Возможно, один простой способ, который приходит на ум, 

6
00:00:14,924 --> 00:00:16,760
— это просто складывать их почленно.

7
00:00:17,160 --> 00:00:19,920
Аналогично с функциями вы можете добавить все соответствующие выходы.

8
00:00:20,540 --> 00:00:23,245
Подобным же образом вы можете умножить два списка 

9
00:00:23,245 --> 00:00:25,680
почленно и проделать то же самое с функциями.

10
00:00:26,360 --> 00:00:29,812
Но есть еще один вид комбинации, столь же фундаментальный, 

11
00:00:29,812 --> 00:00:33,500
как и оба, но гораздо менее обсуждаемый, известный как свертка.

12
00:00:34,080 --> 00:00:37,987
Но в отличие от двух предыдущих случаев, это не просто унаследовано от операции, 

13
00:00:37,987 --> 00:00:39,820
которую вы можете выполнить с числами.

14
00:00:39,980 --> 00:00:44,700
Это что-то действительно новое для контекста списков чисел или объединения функций.

15
00:00:45,320 --> 00:00:49,207
Они появляются повсюду, они повсеместно используются при обработке изображений, 

16
00:00:49,207 --> 00:00:52,755
это основная конструкция теории вероятностей, они часто используются при 

17
00:00:52,755 --> 00:00:55,574
решении дифференциальных уравнений, и есть один контекст, 

18
00:00:55,574 --> 00:00:59,170
где вы почти наверняка видели это, если не под этим названием перемножает 

19
00:00:59,170 --> 00:01:00,240
два многочлена вместе.

20
00:01:00,740 --> 00:01:04,636
Для человека, занимающегося визуальными объяснениями, это особенно интересная тема, 

21
00:01:04,636 --> 00:01:08,254
потому что шаблонное определение изолированно и без контекста может выглядеть 

22
00:01:08,254 --> 00:01:12,243
отчасти устрашающе, но если мы потратим время на то, чтобы по-настоящему раскрыть то, 

23
00:01:12,243 --> 00:01:14,841
что оно говорит, и до этого действительно мотивировать, 

24
00:01:14,841 --> 00:01:18,320
почему вам бы хотелось чего-то подобного, это невероятно красивая операция.

25
00:01:18,960 --> 00:01:21,435
И я должен признать, что я действительно кое-чему научился, 

26
00:01:21,435 --> 00:01:23,540
пока создавал визуальные эффекты для этого проекта.

27
00:01:23,540 --> 00:01:27,827
В случае свертки двух разных функций я пытался придумать разные способы представить, 

28
00:01:27,827 --> 00:01:31,710
что это может означать, и с одним из них у меня возник небольшой ага-момент, 

29
00:01:31,710 --> 00:01:36,098
почему нормальное распределение играет ту роль, которую они делают это с вероятностью, 

30
00:01:36,098 --> 00:01:38,520
почему это такая естественная форма для функции.

31
00:01:39,020 --> 00:01:41,520
Но я забегаю вперед, для этого есть много настроек.

32
00:01:41,840 --> 00:01:45,825
В этом видео наше основное внимание будет сосредоточено на дискретном случае и, 

33
00:01:45,825 --> 00:01:50,260
в частности, на создании очень неожиданного, но очень умного алгоритма для их вычисления.

34
00:01:50,260 --> 00:01:54,480
А обсуждение непрерывного случая я вынесу во вторую часть.

35
00:01:58,580 --> 00:02:01,365
Очень заманчиво начать с примеров обработки изображений, 

36
00:02:01,365 --> 00:02:04,591
поскольку они визуально наиболее интригуют, но есть пара мелочей, 

37
00:02:04,591 --> 00:02:08,891
которые делают случай обработки изображений менее репрезентативным для сверток в целом, 

38
00:02:08,891 --> 00:02:12,165
поэтому вместо этого давайте начнем с вероятности, и, в частности, 

39
00:02:12,165 --> 00:02:14,755
один из самых простых примеров, о котором, я уверен, 

40
00:02:14,755 --> 00:02:17,981
каждый здесь задумывался в какой-то момент своей жизни, а именно: 

41
00:02:17,981 --> 00:02:21,500
бросить пару игральных костей и вычислить шансы увидеть различные суммы.

42
00:02:22,460 --> 00:02:24,460
И вы можете сказать: не проблема, не проблема.

43
00:02:24,680 --> 00:02:28,467
Каждая из ваших двух игральных костей имеет шесть различных возможных результатов, 

44
00:02:28,467 --> 00:02:31,707
что дает нам в общей сложности 36 различных возможных пар результатов, 

45
00:02:31,707 --> 00:02:34,354
и если мы просто просмотрим их все, мы сможем подсчитать, 

46
00:02:34,354 --> 00:02:35,860
сколько пар имеют заданную сумму.

47
00:02:36,600 --> 00:02:41,172
При таком расположении всех пар в сетке есть одна приятная вещь: все пары, 

48
00:02:41,172 --> 00:02:45,440
имеющие постоянную сумму, видны вдоль одной из этих разных диагоналей.

49
00:02:45,440 --> 00:02:49,615
Таким образом, простой подсчет количества чисел на каждой из этих диагоналей покажет вам, 

50
00:02:49,615 --> 00:02:52,120
насколько вероятно, что вы увидите определенную сумму.

51
00:02:53,220 --> 00:02:55,767
И я бы сказал, очень хорошо, очень хорошо, но можете ли вы 

52
00:02:55,767 --> 00:02:58,660
придумать какой-нибудь другой способ визуализировать тот же вопрос?

53
00:02:59,300 --> 00:03:03,027
Другие образы, которые могут прийти на ум, если подумать обо всех различных парах, 

54
00:03:03,027 --> 00:03:04,060
имеющих заданную сумму?

55
00:03:04,860 --> 00:03:07,980
И, возможно, кто-то из вас поднимет руку и скажет: «Да, он у меня есть».

56
00:03:08,280 --> 00:03:12,223
Допустим, вы представляете эти два разных набора возможностей каждый подряд, 

57
00:03:12,223 --> 00:03:13,760
но переворачиваете второй ряд.

58
00:03:13,760 --> 00:03:18,760
Таким образом, все пары, составляющие в сумме семь, выстраиваются вертикально вот так.

59
00:03:19,360 --> 00:03:22,619
А если мы сдвинем этот нижний ряд до упора вправо, то единственная пара, 

60
00:03:22,619 --> 00:03:26,280
которая в сумме дает два, — змеиные глаза, — будет единственной, которая совпадет.

61
00:03:26,620 --> 00:03:29,625
И если я сдвину это на одну единицу вправо, пары, которые выровняются, 

62
00:03:29,625 --> 00:03:32,080
окажутся двумя разными парами, сумма которых составит три.

63
00:03:32,880 --> 00:03:37,117
И вообще, разные значения смещения этого нижнего массива, который, как я помню, 

64
00:03:37,117 --> 00:03:41,460
сначала пришлось перевернуть, выявляют все отдельные пары, имеющие заданную сумму.

65
00:03:44,820 --> 00:03:48,730
Что касается вопросов вероятности, то это пока не особенно интересно, потому что все, 

66
00:03:48,730 --> 00:03:52,640
что мы делаем, — это подсчитываем, сколько исходов имеется в каждой из этих категорий.

67
00:03:52,980 --> 00:03:58,120
Но это при неявном предположении, что у каждого из этих лиц есть равные шансы появиться.

68
00:03:58,360 --> 00:04:00,648
Но что, если я скажу вам, что у меня есть особый набор игральных костей, 

69
00:04:00,648 --> 00:04:01,620
который не является одинаковым?

70
00:04:02,060 --> 00:04:04,718
Возможно, синий кубик имеет свой собственный набор чисел, 

71
00:04:04,718 --> 00:04:06,918
описывающий вероятность выпадения каждой грани, 

72
00:04:06,918 --> 00:04:09,760
а красный кубик имеет свой собственный уникальный набор чисел.

73
00:04:10,299 --> 00:04:13,621
В этом случае, если вы хотите вычислить, скажем, вероятность увидеть двойку, 

74
00:04:13,621 --> 00:04:16,814
вы должны умножить вероятность того, что на синем кубике выпадет единица, 

75
00:04:16,814 --> 00:04:19,360
на вероятность того, что на красном кубике выпадет единица.

76
00:04:19,360 --> 00:04:23,272
А чтобы узнать шансы увидеть тройку, вы смотрите на две разные пары, 

77
00:04:23,272 --> 00:04:26,958
где это возможно, и снова умножаете соответствующие вероятности, 

78
00:04:26,958 --> 00:04:29,680
а затем складываете эти два произведения вместе.

79
00:04:30,100 --> 00:04:33,104
Точно так же вероятность увидеть четверку предполагает 

80
00:04:33,104 --> 00:04:36,820
перемножение трех разных пар возможностей и сложение их всех вместе.

81
00:04:36,820 --> 00:04:42,098
И в духе составления некоторых формул давайте назовем эти верхние вероятности a1, 

82
00:04:42,098 --> 00:04:45,960
a2, a3 и так далее, а нижние назовем b1, b2, b3 и так далее.

83
00:04:46,400 --> 00:04:51,253
И вообще, этот процесс, когда мы берём два разных массива чисел, переворачиваем второй, 

84
00:04:51,253 --> 00:04:54,231
а затем выравниваем их с разными значениями смещения, 

85
00:04:54,231 --> 00:04:56,989
берём кучу попарных произведений и складываем их, 

86
00:04:56,989 --> 00:05:00,740
это один из фундаментальные способы думать о том, что такое свертка.

87
00:05:00,740 --> 00:05:06,445
Чтобы выразить это более точно, в ходе этого процесса мы просто сгенерировали 

88
00:05:06,445 --> 00:05:11,200
вероятности увидеть два, три, четыре, и так далее, вплоть до 12, 

89
00:05:11,200 --> 00:05:16,980
и мы получили их, смешав один список значений, a и другой. список ценностей, б.

90
00:05:17,440 --> 00:05:20,832
На жаргоне мы бы сказали, что свертка этих двух последовательностей дает 

91
00:05:20,832 --> 00:05:24,132
нам новую последовательность, новую последовательность из 11 значений, 

92
00:05:24,132 --> 00:05:27,340
каждое из которых выглядит как некоторая сумма попарных произведений.

93
00:05:27,340 --> 00:05:32,008
Если хотите, вы можете выполнить ту же операцию еще одним способом — сначала 

94
00:05:32,008 --> 00:05:36,980
создать таблицу всех попарных произведений, а затем сложить их по всем диагоналям.

95
00:05:37,460 --> 00:05:40,363
Опять же, это способ смешать эти две последовательности чисел, 

96
00:05:40,363 --> 00:05:42,760
чтобы получить новую последовательность из 11 чисел.

97
00:05:43,240 --> 00:05:45,445
Это та же самая операция, что и в случае с раздвижными окнами, 

98
00:05:45,445 --> 00:05:46,460
только с другой точки зрения.

99
00:05:47,140 --> 00:05:49,800
Сделав небольшие примечания, вот как вы можете увидеть это записанным.

100
00:05:50,220 --> 00:05:55,971
Свертка a и b, обозначенная этой маленькой звездочкой, представляет собой новый список, 

101
00:05:55,971 --> 00:05:59,043
и n-й элемент этого списка выглядит как сумма, 

102
00:05:59,043 --> 00:06:04,860
и эта сумма охватывает все разные пары индексов i и j, так что сумма эти индексы равны n.

103
00:06:05,280 --> 00:06:10,539
Это довольно многословно, но, например, если n равно 6, мы рассматриваем пары: 

104
00:06:10,539 --> 00:06:15,800
1 и 5, 2 и 4, 3 и 3, 4 и 2, 5 и 1, все разные пары, которые складываются. до 6.

105
00:06:16,620 --> 00:06:18,336
Но, честно говоря, как бы вы это ни записывали, 

106
00:06:18,336 --> 00:06:21,088
обозначения второстепенны по сравнению с визуальным представлением процесса, 

107
00:06:21,088 --> 00:06:22,340
которое вы можете держать в голове.

108
00:06:23,280 --> 00:06:27,792
Здесь, возможно, поможет очень простой пример, где я мог бы спросить вас, 

109
00:06:27,792 --> 00:06:30,780
какова свертка списка 1, 2, 3 со списком 4, 5, 6.

110
00:06:31,480 --> 00:06:34,093
Вы можете представить, как берете оба этих списка, 

111
00:06:34,093 --> 00:06:37,680
переворачиваете второй, а затем начинаете с его крышки до упора влево.

112
00:06:38,180 --> 00:06:40,587
Затем пара значений, которые совпадают, — это 1 и 4, 

113
00:06:40,587 --> 00:06:43,540
умножаем их вместе, и это дает нам первый член нашего результата.

114
00:06:43,960 --> 00:06:49,150
Сдвиньте нижний массив на одну единицу вправо, выровняются пары: 1 и 5, а также 2 и 4, 

115
00:06:49,150 --> 00:06:54,460
умножьте эти пары, сложите их вместе, и это даст нам 13, следующую запись в нашем выводе.

116
00:06:54,960 --> 00:07:01,560
Сдвиньте элементы еще раз, и мы возьмем 1×6, плюс 2×5, плюс 3×4, что составит 28.

117
00:07:02,020 --> 00:07:06,431
Еще один слайд, и мы получаем 2×6 плюс 3×5, что дает нам 27, 

118
00:07:06,431 --> 00:07:10,120
и, наконец, последний член будет выглядеть как 3×6.

119
00:07:10,660 --> 00:07:14,868
Если хотите, вы можете использовать любой ваш любимый язык программирования и любимую 

120
00:07:14,868 --> 00:07:18,980
библиотеку, включающую различные числовые операции, и подтвердить, что я вам не лгу.

121
00:07:18,980 --> 00:07:21,730
Если вы возьмете свертку 1, 2, 3 против 4, 5, 6, 

122
00:07:21,730 --> 00:07:24,480
вы действительно получите именно такой результат.

123
00:07:25,920 --> 00:07:29,016
Мы видели один случай, когда это естественная и желательная операция, 

124
00:07:29,016 --> 00:07:32,819
суммирующая распределения вероятностей, а другим распространенным примером может быть 

125
00:07:32,819 --> 00:07:33,660
скользящее среднее.

126
00:07:34,080 --> 00:07:36,571
Представьте, что у вас есть длинный список чисел, 

127
00:07:36,571 --> 00:07:39,760
и вы берете другой, меньший список чисел, сумма которых равна 1.

128
00:07:40,100 --> 00:07:44,060
В данном случае у меня есть небольшой список из 5 значений, и все они равны 15-му.

129
00:07:44,060 --> 00:07:48,996
Затем, если мы выполним этот процесс свертки скользящего окна, закроем глаза и заметим, 

130
00:07:48,996 --> 00:07:53,988
что происходит в самом начале, когда наш меньший список значений полностью перекрывается 

131
00:07:53,988 --> 00:07:58,700
с большим, подумайте о том, что каждый термин в этом действительно означает свертка.

132
00:07:59,400 --> 00:08:04,799
На каждой итерации вы умножаете каждое значение ваших данных на 15 и складываете их 

133
00:08:04,799 --> 00:08:10,520
все вместе, то есть вы берете среднее значение ваших данных внутри этого маленького окна.

134
00:08:11,100 --> 00:08:14,107
В целом, этот процесс дает вам сглаженную версию исходных данных, 

135
00:08:14,107 --> 00:08:17,206
и вы можете изменить ее, начиная с другого небольшого списка чисел, 

136
00:08:17,206 --> 00:08:19,484
и пока весь этот небольшой список в сумме дает 1, 

137
00:08:19,484 --> 00:08:22,720
вы все равно можете интерпретировать его как движущееся число. средний.

138
00:08:23,400 --> 00:08:25,580
В показанном здесь примере это скользящее среднее 

139
00:08:25,580 --> 00:08:27,760
будет придавать больший вес центральному значению.

140
00:08:28,420 --> 00:08:30,800
Это также приводит к сглаженной версии данных.

141
00:08:33,140 --> 00:08:35,780
Если вы сделаете своего рода двумерный аналог этого, 

142
00:08:35,780 --> 00:08:38,720
вы получите забавный алгоритм размытия данного изображения.

143
00:08:38,720 --> 00:08:41,313
И я должен сказать, что анимации, которые я собираюсь показать, 

144
00:08:41,313 --> 00:08:44,433
являются модификациями того, что я изначально сделал для части серии лекций, 

145
00:08:44,433 --> 00:08:47,675
которые я читал в лаборатории Джулии в Массачусетском технологическом институте 

146
00:08:47,675 --> 00:08:51,080
для определенного класса OpenCourseWare, который включал блок обработки изображений.

147
00:08:51,560 --> 00:08:54,071
Там мы еще немного углубились в код всего этого, поэтому, 

148
00:08:54,071 --> 00:08:56,280
если вам интересно, я оставлю вам несколько ссылок.

149
00:08:56,620 --> 00:08:59,033
Но если вернуться к этому примеру с размытием, 

150
00:08:59,033 --> 00:09:03,399
то у меня есть небольшая сетка значений 3х3, которая проходит вдоль нашего исходного 

151
00:09:03,399 --> 00:09:07,354
изображения, и если мы увеличим масштаб, каждое из этих значений будет 19-м, 

152
00:09:07,354 --> 00:09:11,822
и что я делаю на каждой итерации каждое из этих значений умножается на соответствующий 

153
00:09:11,822 --> 00:09:13,620
пиксель, над которым оно находится.

154
00:09:13,900 --> 00:09:17,888
И, конечно же, в информатике мы думаем о цветах как о маленьких векторах трех значений, 

155
00:09:17,888 --> 00:09:20,200
представляющих красный, зеленый и синий компоненты.

156
00:09:20,560 --> 00:09:24,352
Когда я умножаю все эти маленькие значения на 19 и складываю их вместе, 

157
00:09:24,352 --> 00:09:27,407
мы получаем среднее значение по каждому цветовому каналу, 

158
00:09:27,407 --> 00:09:31,200
и соответствующий пиксель изображения справа определяется как эта сумма.

159
00:09:31,940 --> 00:09:35,285
Общий эффект, когда мы делаем это для каждого отдельного пикселя изображения, 

160
00:09:35,285 --> 00:09:38,758
заключается в том, что каждый из них как бы просачивается на всех своих соседей, 

161
00:09:38,758 --> 00:09:40,860
что дает нам более размытую версию, чем оригинал.

162
00:09:41,720 --> 00:09:44,797
На жаргоне мы бы сказали, что изображение справа представляет собой 

163
00:09:44,797 --> 00:09:47,740
свертку нашего исходного изображения с небольшой сеткой значений.

164
00:09:48,140 --> 00:09:50,551
Или более технически, может быть, я должен сказать, 

165
00:09:50,551 --> 00:09:54,400
что это свертка с повернутой на 180 градусов версией этой маленькой сетки значений.

166
00:09:54,620 --> 00:09:58,535
Не то чтобы это имело значение, когда сетка симметрична, но просто стоит иметь в виду, 

167
00:09:58,535 --> 00:10:01,955
что определение свертки, унаследованное из чисто математического контекста, 

168
00:10:01,955 --> 00:10:05,240
всегда должно побуждать вас задуматься о переворачивании второго массива.

169
00:10:05,960 --> 00:10:09,847
Если мы немного изменим это, мы сможем получить гораздо более элегантный эффект размытия, 

170
00:10:09,847 --> 00:10:11,100
выбрав другую сетку значений.

171
00:10:11,440 --> 00:10:15,780
В данном случае у меня есть небольшая сетка 5х5, но разница не столько в ее размере.

172
00:10:15,980 --> 00:10:19,697
Если мы увеличим масштаб, мы заметим, что значение в середине намного больше, 

173
00:10:19,697 --> 00:10:21,984
чем значение по краям, и это происходит потому, 

174
00:10:21,984 --> 00:10:25,940
что все они выбраны из колоколообразной кривой, известной как распределение Гаусса.

175
00:10:26,800 --> 00:10:30,275
Таким образом, когда мы умножаем все эти значения на соответствующий пиксель, 

176
00:10:30,275 --> 00:10:33,216
над которым они расположены, мы придаем гораздо больший вес этому 

177
00:10:33,216 --> 00:10:36,380
центральному пикселю и гораздо меньший вес тем, кто находится по краям.

178
00:10:36,800 --> 00:10:40,560
И, как и раньше, соответствующий пиксель справа определяется как эта сумма.

179
00:10:41,320 --> 00:10:44,464
Поскольку мы проделываем этот процесс для каждого отдельного пикселя, 

180
00:10:44,464 --> 00:10:47,114
это дает эффект размытия, который гораздо более достоверно 

181
00:10:47,114 --> 00:10:49,720
имитирует расфокусировку объектива или что-то в этом роде.

182
00:10:49,900 --> 00:10:53,360
Но размытие — далеко не единственное, что можно сделать с помощью этой идеи.

183
00:10:53,800 --> 00:10:56,175
Например, взгляните на эту небольшую сетку значений, 

184
00:10:56,175 --> 00:10:59,089
которая включает несколько положительных чисел слева и несколько 

185
00:10:59,089 --> 00:11:02,900
отрицательных чисел справа, которые я раскрасю синим и красным цветом соответственно.

186
00:11:03,640 --> 00:11:06,324
Найдите минутку и посмотрите, сможете ли вы предсказать и понять, 

187
00:11:06,324 --> 00:11:08,480
какой эффект это окажет на окончательное изображение.

188
00:11:10,720 --> 00:11:14,294
Итак, в этом случае я буду просто думать об изображении как о цветном, 

189
00:11:14,294 --> 00:11:18,120
а не о цветном, поэтому каждый пиксель представлен одним числом вместо трех.

190
00:11:18,440 --> 00:11:20,799
И стоит отметить одну вещь: при выполнении этой 

191
00:11:20,799 --> 00:11:23,060
свертки можно получить отрицательные значения.

192
00:11:23,060 --> 00:11:26,552
Например, на этом этапе, если мы увеличим левую половину нашей маленькой сетки, 

193
00:11:26,552 --> 00:11:30,264
она полностью окажется поверх черных пикселей, которые будут иметь нулевое значение, 

194
00:11:30,264 --> 00:11:33,669
но вся правая половина отрицательных значений окажется поверх белых пикселей, 

195
00:11:33,669 --> 00:11:35,460
что будет иметь значение, равное единице.

196
00:11:36,180 --> 00:11:39,401
Поэтому, когда мы умножаем соответствующие термины и складываем их вместе, 

197
00:11:39,401 --> 00:11:42,837
результаты будут очень отрицательными, и я показываю это на изображении справа: 

198
00:11:42,837 --> 00:11:46,360
окрашиваю отрицательные значения в красный цвет, а положительные значения в синий.

199
00:11:46,880 --> 00:11:48,877
Еще одна вещь, на которую следует обратить внимание: 

200
00:11:48,877 --> 00:11:50,951
когда вы находитесь на участке одного и того же цвета, 

201
00:11:50,951 --> 00:11:54,080
все обращается к нулю, поскольку сумма значений в нашей маленькой сетке равна нулю.

202
00:11:55,180 --> 00:11:57,010
Это сильно отличается от двух предыдущих примеров, 

203
00:11:57,010 --> 00:11:58,877
где сумма нашей маленькой сетки была равна единице, 

204
00:11:58,877 --> 00:12:01,174
что позволяет нам интерпретировать ее как скользящее среднее и, 

205
00:12:01,174 --> 00:12:02,180
следовательно, как размытие.

206
00:12:03,640 --> 00:12:06,982
В общем, этот небольшой процесс в основном обнаруживает изменения 

207
00:12:06,982 --> 00:12:09,362
в значении пикселя при движении слева направо, 

208
00:12:09,362 --> 00:12:13,920
и поэтому он дает вам своего рода способ уловить все вертикальные края вашего изображения.

209
00:12:16,500 --> 00:12:19,068
И аналогичным образом, если мы повернем эту сетку так, 

210
00:12:19,068 --> 00:12:22,289
чтобы она менялась при движении сверху вниз, это будет отражаться на 

211
00:12:22,289 --> 00:12:25,698
всех горизонтальных краях, что в случае с изображением нашего маленького 

212
00:12:25,698 --> 00:12:29,340
пирога-существа действительно приводит к появлению довольно демонических глаз.

213
00:12:30,400 --> 00:12:33,793
Эту меньшую сетку, кстати, часто называют ядром, и прелесть здесь в том, что, 

214
00:12:33,793 --> 00:12:37,447
просто выбрав другое ядро, вы можете получить разные эффекты обработки изображения, 

215
00:12:37,447 --> 00:12:40,840
не только размытие обнаружения краев, но и такие вещи, как повышение резкости.

216
00:12:40,840 --> 00:12:44,532
Для тех из вас, кто слышал о сверточной нейронной сети, идея состоит в том, 

217
00:12:44,532 --> 00:12:48,662
чтобы использовать данные, чтобы выяснить, какими должны быть ядра в первую очередь, 

218
00:12:48,662 --> 00:12:51,480
что определяется тем, что нейронная сеть хочет обнаружить.

219
00:12:52,760 --> 00:12:55,520
Еще одна вещь, о которой мне, возможно, следует упомянуть, — это длина вывода.

220
00:12:55,820 --> 00:12:59,425
Для чего-то вроде примера со скользящим средним вы можете думать об условиях только 

221
00:12:59,425 --> 00:13:01,871
тогда, когда оба окна полностью совпадают друг с другом, 

222
00:13:01,871 --> 00:13:04,490
или в примере с обработкой изображения, возможно, вы хотите, 

223
00:13:04,490 --> 00:13:07,280
чтобы окончательный результат имел тот же размер, что и оригинал.

224
00:13:07,280 --> 00:13:10,532
Теперь свертки как чисто математическая операция всегда создают массив, 

225
00:13:10,532 --> 00:13:13,740
который больше, чем два массива, с которых вы начали, по крайней мере, 

226
00:13:13,740 --> 00:13:16,180
при условии, что длина одного из них не равна единице.

227
00:13:16,720 --> 00:13:19,338
Просто знайте, что в некоторых контекстах информатики 

228
00:13:19,338 --> 00:13:21,520
вам часто нужно намеренно урезать этот вывод.

229
00:13:24,720 --> 00:13:27,147
Еще одна вещь, которую стоит подчеркнуть, это то, 

230
00:13:27,147 --> 00:13:30,303
что в контексте информатики идея переворачивания ядра перед тем, 

231
00:13:30,303 --> 00:13:34,526
как позволить ему пройти по оригиналу, часто кажется очень странной и просто ненужной, 

232
00:13:34,526 --> 00:13:38,022
но еще раз обратите внимание, что это то, что унаследовано из контекста 

233
00:13:38,022 --> 00:13:41,566
чистой математики, где, как мы видел, что с вероятностями это невероятно 

234
00:13:41,566 --> 00:13:42,440
естественная вещь.

235
00:13:43,020 --> 00:13:46,103
И на самом деле я могу показать вам еще один чисто математический пример, 

236
00:13:46,103 --> 00:13:48,103
который должен интересовать даже программистов, 

237
00:13:48,103 --> 00:13:51,061
потому что он открывает двери для гораздо более быстрого алгоритма для 

238
00:13:51,061 --> 00:13:52,020
вычисления всего этого.

239
00:13:52,620 --> 00:13:55,019
Чтобы настроить то, что я подразумеваю под словом «быстрее», 

240
00:13:55,019 --> 00:13:57,340
позвольте мне вернуться назад и снова использовать Python, 

241
00:13:57,340 --> 00:13:59,780
и я собираюсь создать два разных относительно больших массива.

242
00:13:59,940 --> 00:14:03,086
В каждом из них будет сто тысяч случайных элементов, 

243
00:14:03,086 --> 00:14:07,540
и я собираюсь оценить время выполнения функции свертки из библиотеки numpy.

244
00:14:08,180 --> 00:14:12,790
И в этом случае он запускает несколько разных итераций, пытается найти среднее значение, 

245
00:14:12,790 --> 00:14:16,520
и похоже, что на этом компьютере оно составляет как минимум 4.87 секунд.

246
00:14:16,960 --> 00:14:22,023
Напротив, если я использую другую функцию из библиотеки scipy под названием fftconvolve, 

247
00:14:22,023 --> 00:14:26,347
которая представляет собой то же самое, но реализовано по-другому и требует 

248
00:14:26,347 --> 00:14:30,160
всего 4.В среднем 3 миллисекунды, то есть улучшение на три порядка.

249
00:14:30,160 --> 00:14:33,210
И опять же, несмотря на то, что она работает под другим именем, 

250
00:14:33,210 --> 00:14:36,022
она выдает тот же результат, что и другая функция свертки, 

251
00:14:36,022 --> 00:14:39,120
она просто делает что-то, чтобы сделать это более умным способом.

252
00:14:42,200 --> 00:14:44,847
Помните, как в примере с вероятностью я говорил, 

253
00:14:44,847 --> 00:14:49,654
что еще один способ подумать о свертке — это создать таблицу всех попарных произведений, 

254
00:14:49,654 --> 00:14:52,680
а затем сложить эти попарные произведения по диагоналям.

255
00:14:53,660 --> 00:14:55,886
Конечно, в вероятности нет ничего особенного, и каждый раз, 

256
00:14:55,886 --> 00:14:59,040
когда вы складываете два разных списка чисел, вы можете думать об этом таким образом.

257
00:14:59,040 --> 00:15:02,173
Создайте такую таблицу умножения со всеми попарными произведениями, 

258
00:15:02,173 --> 00:15:05,906
и тогда каждая сумма по диагонали будет соответствовать одному из ваших конечных 

259
00:15:05,906 --> 00:15:06,460
результатов.

260
00:15:07,600 --> 00:15:10,909
Один из контекстов, где эта точка зрения особенно естественна, 

261
00:15:10,909 --> 00:15:12,800
— это перемножение двух многочленов.

262
00:15:13,300 --> 00:15:18,256
Например, позвольте мне взять уже имеющуюся у нас маленькую сетку и заменить 

263
00:15:18,256 --> 00:15:23,600
верхние члены на 1, 2x и 3x в квадрате, а остальные члены на 4, 5x и 6x в квадрате.

264
00:15:24,000 --> 00:15:26,350
Теперь подумайте, что это значит, когда мы создаем 

265
00:15:26,350 --> 00:15:28,840
все эти разные попарные продукты между двумя списками.

266
00:15:29,040 --> 00:15:33,290
То, что вы делаете, по сути, расширяет полное произведение двух записанных 

267
00:15:33,290 --> 00:15:36,748
мною многочленов, а затем, когда вы суммируете по диагонали, 

268
00:15:36,748 --> 00:15:40,715
что соответствует сбору всех подобных членов, что довольно аккуратно, 

269
00:15:40,715 --> 00:15:44,739
расширение полинома и сбор подобных членов - это именно то, что нужно. 

270
00:15:44,739 --> 00:15:46,440
тот же процесс, что и свертка.

271
00:15:47,740 --> 00:15:50,017
Но это позволяет нам сделать что-то очень крутое, 

272
00:15:50,017 --> 00:15:52,340
потому что подумайте о том, о чем мы здесь говорим.

273
00:15:52,340 --> 00:15:56,438
Мы говорим, что если вы берете две разные функции и перемножаете их вместе, 

274
00:15:56,438 --> 00:16:00,158
что представляет собой простую поточечную операцию, это то же самое, 

275
00:16:00,158 --> 00:16:04,256
как если бы вы сначала извлекли коэффициенты из каждой из них, предполагая, 

276
00:16:04,256 --> 00:16:08,840
что они являются полиномами, а затем произвели свертку этих два списка коэффициентов.

277
00:16:09,620 --> 00:16:11,905
Что делает это настолько интересным, так это то, 

278
00:16:11,905 --> 00:16:15,217
что свертки в принципе кажутся намного сложнее, чем простое умножение, 

279
00:16:15,217 --> 00:16:19,042
и я не просто имею в виду, что концептуально о них труднее думать, я имею в виду, 

280
00:16:19,042 --> 00:16:22,821
что с вычислительной точки зрения для выполнения свертки требуется больше шагов, 

281
00:16:22,821 --> 00:16:25,760
чем для выполнения поточечное произведение двух разных списков.

282
00:16:26,319 --> 00:16:30,380
Например, предположим, я дал вам два действительно больших многочлена, скажем, 

283
00:16:30,380 --> 00:16:32,847
каждый с сотней различных коэффициентов, тогда, 

284
00:16:32,847 --> 00:16:36,959
если способ их умножения заключался в расширении этого известного вам продукта, 

285
00:16:36,959 --> 00:16:40,351
заполняя всю эту сетку попарных произведений размером 100 на 100, 

286
00:16:40,351 --> 00:16:44,257
что потребовало бы от вас выполнить 10 000 различных произведений, а затем, 

287
00:16:44,257 --> 00:16:47,135
когда вы соберете все одинаковые термины по диагоналям, 

288
00:16:47,135 --> 00:16:49,860
получится еще один набор из примерно 10 000 операций.

289
00:16:50,700 --> 00:16:53,047
В более общем смысле на жаргоне мы бы сказали, 

290
00:16:53,047 --> 00:16:55,595
что алгоритм представляет собой O из n в квадрате, 

291
00:16:55,595 --> 00:16:59,042
что означает для двух списков размера n, то есть количество операций 

292
00:16:59,042 --> 00:17:01,140
масштабируется пропорционально квадрату n.

293
00:17:01,820 --> 00:17:06,030
С другой стороны, если я думаю о двух полиномах с точки зрения их выходных данных, 

294
00:17:06,030 --> 00:17:09,176
например, о выборке их значений на нескольких входных данных, 

295
00:17:09,176 --> 00:17:13,031
то для их умножения требуется столько операций, сколько количество выборок, 

296
00:17:13,031 --> 00:17:16,785
поскольку опять же это точечная операция, а с полиномами вам нужно только 

297
00:17:16,785 --> 00:17:20,540
конечное число выборок, чтобы иметь возможность восстановить коэффициенты.

298
00:17:20,540 --> 00:17:25,060
Например, двух выходных данных достаточно, чтобы однозначно указать линейный полином.

299
00:17:25,660 --> 00:17:29,400
Трех выходных данных будет достаточно, чтобы однозначно определить квадратичный полином.

300
00:17:29,640 --> 00:17:33,844
И вообще, если вы знаете n различных выходных данных, этого достаточно, 

301
00:17:33,844 --> 00:17:37,640
чтобы однозначно указать полином, имеющий n разных коэффициентов.

302
00:17:37,780 --> 00:17:40,720
Или, если хотите, мы могли бы сформулировать это на языке систем уравнений.

303
00:17:41,200 --> 00:17:43,925
Представьте, что я говорю вам, что у меня есть некий полином, 

304
00:17:43,925 --> 00:17:46,520
но не говорю, что это за коэффициенты, это для вас загадка.

305
00:17:46,700 --> 00:17:50,800
В нашем примере вы можете думать об этом как о продукте, который мы пытаемся выяснить.

306
00:17:50,800 --> 00:17:55,151
Тогда предположим, что я просто скажу вам, какими будут выходные данные этого полинома, 

307
00:17:55,151 --> 00:17:58,959
если вы введете различные входные данные, такие как 0, 1, 2, 3, и так далее, 

308
00:17:58,959 --> 00:18:01,926
и я дам вам достаточно, чтобы у вас было столько уравнений, 

309
00:18:01,926 --> 00:18:03,460
сколько у вас есть неизвестные.

310
00:18:04,140 --> 00:18:07,340
Это даже линейная система уравнений, и это здорово.

311
00:18:07,780 --> 00:18:09,423
И в принципе, по крайней мере, этого должно быть 

312
00:18:09,423 --> 00:18:10,900
достаточно для восстановления коэффициентов.

313
00:18:11,740 --> 00:18:14,225
Таким образом, грубая схема алгоритма будет такой: всякий раз, 

314
00:18:14,225 --> 00:18:16,908
когда вы хотите свернуть два списка чисел, вы относитесь к ним так, 

315
00:18:16,908 --> 00:18:19,000
как будто они являются коэффициентами двух полиномов.

316
00:18:19,420 --> 00:18:23,169
Вы выбираете эти полиномы на достаточном количестве выходных данных, 

317
00:18:23,169 --> 00:18:26,321
умножаете эти выборки поточечно, а затем решаете систему, 

318
00:18:26,321 --> 00:18:30,560
чтобы восстановить коэффициенты, используя хитрый черный способ найти свертку.

319
00:18:31,420 --> 00:18:34,205
И, по крайней мере, как я уже говорил, некоторые из вас 

320
00:18:34,205 --> 00:18:37,340
могли бы справедливо пожаловаться: «Грант, это идиотский план».

321
00:18:37,580 --> 00:18:41,184
Потому что, во-первых, просто вычисление всех этих выборок для одного 

322
00:18:41,184 --> 00:18:44,788
из известных нам полиномов уже требует порядка n операций в квадрате, 

323
00:18:44,788 --> 00:18:47,826
не говоря уже о том, что решение этой системы, безусловно, 

324
00:18:47,826 --> 00:18:52,100
будет в вычислительном отношении столь же сложным, как и просто выполнение свертки.

325
00:18:52,600 --> 00:18:56,273
Итак, конечно, у нас есть связь между умножением и свертками, 

326
00:18:56,273 --> 00:19:00,480
но вся сложность возникает при переводе с одной точки зрения на другую.

327
00:19:01,600 --> 00:19:06,126
Но есть одна хитрость, и те из вас, кто знает о преобразованиях Фурье и алгоритме БПФ, 

328
00:19:06,126 --> 00:19:07,740
могут понять, к чему это ведет.

329
00:19:07,740 --> 00:19:10,472
Если вы не знакомы с этими темами, то, что я собираюсь сказать, 

330
00:19:10,472 --> 00:19:12,180
может показаться совершенно неожиданным.

331
00:19:12,260 --> 00:19:14,943
Просто знайте, что в математике есть определенные пути, 

332
00:19:14,943 --> 00:19:16,860
которые делают этот шаг более ожидаемым.

333
00:19:17,720 --> 00:19:20,360
По сути, идея в том, что у нас здесь есть свобода выбора.

334
00:19:20,540 --> 00:19:25,149
Если вместо оценки произвольного набора входных данных, например 0, 1, 2, 3, 

335
00:19:25,149 --> 00:19:29,700
и так далее, вы решите оценить специально выбранный набор комплексных чисел.

336
00:19:30,240 --> 00:19:33,573
В частности, те, которые расположены на равном расстоянии от единичного круга, 

337
00:19:33,573 --> 00:19:34,840
так называемые корни единства.

338
00:19:35,200 --> 00:19:36,880
Это дает нам более дружественную систему.

339
00:19:38,360 --> 00:19:40,766
Основная идея заключается в том, что нахождение числа, 

340
00:19:40,766 --> 00:19:43,916
при котором принятие его полномочий попадает в этот циклический шаблон, 

341
00:19:43,916 --> 00:19:47,241
означает, что система, которую мы создаем, будет иметь большую избыточность 

342
00:19:47,241 --> 00:19:50,872
в различных терминах, которые вы рассчитываете, и благодаря умному подходу к тому, 

343
00:19:50,872 --> 00:19:54,460
как Если вы воспользуетесь этой избыточностью, вы сможете сэкономить массу работы.

344
00:19:56,020 --> 00:19:59,472
Этот набор выходных данных, который я написал, имеет специальное название: 

345
00:19:59,472 --> 00:20:02,280
он называется дискретным преобразованием Фурье коэффициентов.

346
00:20:02,500 --> 00:20:04,665
И если вы хотите узнать больше, я на самом деле прочитал еще 

347
00:20:04,665 --> 00:20:07,542
одну лекцию для того же курса Джулии в Массачусетском технологическом институте, 

348
00:20:07,542 --> 00:20:09,140
посвященную дискретным преобразованиям Фурье.

349
00:20:09,220 --> 00:20:11,839
А еще на канале Reducible есть действительно отличное видео, 

350
00:20:11,839 --> 00:20:14,286
в котором рассказывается о быстром преобразовании Фурье, 

351
00:20:14,286 --> 00:20:17,120
которое представляет собой алгоритм для более быстрого вычисления.

352
00:20:17,480 --> 00:20:20,511
Кроме того, компания Veritasium недавно выпустила действительно хорошее видео о БПФ, 

353
00:20:20,511 --> 00:20:21,760
так что у вас есть много вариантов.

354
00:20:22,260 --> 00:20:24,660
И этот быстрый алгоритм действительно важен для нас.

355
00:20:25,120 --> 00:20:28,479
Опять же, из-за всей этой избыточности существует метод перехода от 

356
00:20:28,479 --> 00:20:32,184
коэффициентов ко всем этим выходным данным, где вместо выполнения операций 

357
00:20:32,184 --> 00:20:35,741
порядка n в квадрате вы выполняете порядка n раз больше log n операций, 

358
00:20:35,741 --> 00:20:39,200
что намного намного лучше, если вы масштабируетесь до больших списков.

359
00:20:39,660 --> 00:20:42,540
И что важно, этот алгоритм БПФ работает в обе стороны.

360
00:20:42,700 --> 00:20:45,480
Это также позволяет вам перейти от выходных данных к коэффициентам.

361
00:20:46,220 --> 00:20:49,060
Итак, собрав все это вместе, давайте еще раз взглянем на схему нашего алгоритма.

362
00:20:49,420 --> 00:20:53,684
Теперь мы можем сказать, что всякий раз, когда вам даны два длинных списка чисел и вы 

363
00:20:53,684 --> 00:20:57,850
хотите выполнить их свертку, сначала вычислите быстрое преобразование Фурье каждого 

364
00:20:57,850 --> 00:21:00,528
из них, о чем в глубине души вы можете просто думать, 

365
00:21:00,528 --> 00:21:04,693
что относитесь к ним как к они являются коэффициентами многочлена и оценивают его в 

366
00:21:04,693 --> 00:21:06,380
специально выбранном наборе точек.

367
00:21:06,899 --> 00:21:10,158
Затем умножьте два результата, которые вы только что получили, 

368
00:21:10,158 --> 00:21:14,503
поточечно (это красиво и быстро), а затем выполните обратное быстрое преобразование 

369
00:21:14,503 --> 00:21:18,900
Фурье, и это даст вам хитрый лазейочный способ вычисления свертки, которую мы искали.

370
00:21:19,040 --> 00:21:22,240
Но на этот раз это включает только O из n log n операций.

371
00:21:23,139 --> 00:21:24,740
Для меня это очень круто!

372
00:21:25,120 --> 00:21:29,764
Этот очень специфический контекст, в котором появляются свертки, умножающие два полинома, 

373
00:21:29,764 --> 00:21:34,100
открывает двери для алгоритма, который применим везде, где могут возникнуть свертки.

374
00:21:34,180 --> 00:21:36,378
Если вы хотите добавить распределения вероятностей, 

375
00:21:36,378 --> 00:21:39,000
выполните большую обработку изображений, какой бы она ни была.

376
00:21:39,220 --> 00:21:42,448
И я просто думаю, что это хороший пример того, почему вы должны волноваться, 

377
00:21:42,448 --> 00:21:46,054
когда видите, что какая-то операция или концепция в математике проявляется во многих, 

378
00:21:46,054 --> 00:21:47,480
казалось бы, несвязанных областях.

379
00:21:48,480 --> 00:21:51,500
Если вам нужно небольшое домашнее задание, вот о чем интересно подумать.

380
00:21:51,720 --> 00:21:56,355
Объясните, почему, когда вы умножаете два разных числа (обычное умножение, 

381
00:21:56,355 --> 00:21:59,260
как мы все учимся в начальной школе), по сути, 

382
00:21:59,260 --> 00:22:01,980
вы делаете свертку между цифрами этих чисел.

383
00:22:02,500 --> 00:22:05,087
Есть несколько дополнительных шагов с переносами и тому подобное, 

384
00:22:05,087 --> 00:22:06,460
но основным шагом является свертка.

385
00:22:07,280 --> 00:22:10,110
В свете существования быстрого алгоритма это означает, 

386
00:22:10,110 --> 00:22:12,734
что если у вас есть два очень больших целых числа, 

387
00:22:12,734 --> 00:22:15,976
то существует способ найти их произведение быстрее, чем метод, 

388
00:22:15,976 --> 00:22:17,880
который мы изучаем в начальной школе.

389
00:22:18,140 --> 00:22:21,415
Вместо того, чтобы требовать операций O из n в квадрате, 

390
00:22:21,415 --> 00:22:24,920
требуется только O из n log n, что даже не кажется возможным.

391
00:22:25,380 --> 00:22:28,960
Загвоздка в том, что для того, чтобы это действительно пригодилось на практике, 

392
00:22:28,960 --> 00:22:30,840
ваши цифры должны быть просто чудовищными.

393
00:22:31,220 --> 00:22:35,340
Но все равно круто, что такой алгоритм существует.

394
00:22:35,340 --> 00:22:37,447
Далее мы обратим внимание на непрерывный случай, 

395
00:22:37,447 --> 00:22:39,640
уделив особое внимание распределениям вероятностей.

