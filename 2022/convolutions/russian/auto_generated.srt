1
00:00:00,000 --> 00:00:04,480
Предположим, я даю вам два разных списка чисел или, может быть, две разные функции, и прошу вас

2
00:00:04,480 --> 00:00:08,400
подумать обо всех способах, которыми вы можете объединить эти два списка, чтобы получить новый список чисел,

3
00:00:08,400 --> 00:00:14,000
или объединить две функции, чтобы получить новую функцию. . Возможно, один простой способ, который приходит на

4
00:00:14,000 --> 00:00:18,640
ум, — это просто складывать их почленно. Аналогично с функциями вы можете добавить

5
00:00:18,640 --> 00:00:24,000
все соответствующие выходы. Подобным же образом вы можете умножить два списка почленно и

6
00:00:24,000 --> 00:00:28,720
проделать то же самое с функциями. Но есть еще один вид комбинации, столь

7
00:00:28,720 --> 00:00:33,840
же фундаментальный, как и оба, но гораздо менее обсуждаемый, известный как свертка.

8
00:00:33,840 --> 00:00:38,240
Но в отличие от двух предыдущих случаев, это не просто унаследовано от операции, которую вы

9
00:00:38,240 --> 00:00:43,360
можете выполнить с числами. Это что-то действительно новое для контекста списков чисел или

10
00:00:43,360 --> 00:00:49,280
объединения функций. Они появляются повсюду, они повсеместно используются при обработке изображений, это

11
00:00:49,280 --> 00:00:53,760
основная конструкция теории вероятностей, они часто используются при решении дифференциальных уравнений, и есть

12
00:00:53,760 --> 00:00:58,240
один контекст, где вы почти наверняка видели это, если не под этим названием

13
00:00:58,240 --> 00:01:03,440
перемножает два многочлена вместе. Для человека, занимающегося визуальными объяснениями, это особенно интересная тема,

14
00:01:03,440 --> 00:01:08,800
потому что шаблонное определение изолированно и без контекста может выглядеть отчасти устрашающе, но если

15
00:01:08,800 --> 00:01:14,080
мы потратим время на то, чтобы по-настоящему раскрыть то, что оно говорит, и до

16
00:01:14,080 --> 00:01:18,800
этого действительно мотивировать, почему вам бы хотелось чего-то подобного, это невероятно красивая операция.

17
00:01:18,800 --> 00:01:22,880
И я должен признать, что я действительно кое-чему научился, пока создавал визуальные эффекты для этого

18
00:01:22,880 --> 00:01:26,960
проекта. В случае свертки двух разных функций я пытался придумать разные способы представить,

19
00:01:26,960 --> 00:01:30,720
что это может означать, и с одним из них у меня возник небольшой

20
00:01:30,720 --> 00:01:35,840
ага-момент, почему нормальное распределение играет ту роль, которую они делают это с вероятностью,

21
00:01:35,840 --> 00:01:40,320
почему это такая естественная форма для функции. Но я забегаю вперед, для этого

22
00:01:40,320 --> 00:01:44,800
есть много настроек. В этом видео наше основное внимание будет сосредоточено на дискретном случае

23
00:01:44,800 --> 00:01:49,920
и, в частности, на создании очень неожиданного, но очень умного алгоритма для их вычисления.

24
00:01:49,920 --> 00:01:54,400
А обсуждение непрерывного случая я вынесу во вторую часть.

25
00:01:57,840 --> 00:02:03,120
Очень заманчиво начать с примеров обработки изображений, поскольку они визуально наиболее интригуют, но

26
00:02:03,120 --> 00:02:06,880
есть пара мелочей, которые делают случай обработки изображений менее репрезентативным для сверток в

27
00:02:06,880 --> 00:02:11,760
целом, поэтому вместо этого давайте начнем с вероятности, и, в частности, один

28
00:02:11,760 --> 00:02:15,520
из самых простых примеров, о котором, я уверен, каждый здесь задумывался в какой-то

29
00:02:15,520 --> 00:02:20,320
момент своей жизни, а именно: бросить пару игральных костей и вычислить шансы увидеть

30
00:02:20,320 --> 00:02:25,600
различные суммы. И вы можете сказать: не проблема, не проблема. Каждая из ваших двух игральных

31
00:02:25,600 --> 00:02:31,600
костей имеет шесть различных возможных результатов, что дает нам в общей сложности 36 различных возможных пар

32
00:02:31,600 --> 00:02:35,600
результатов, и если мы просто просмотрим их все, мы сможем подсчитать, сколько пар имеют заданную сумму.

33
00:02:36,240 --> 00:02:41,120
При таком расположении всех пар в сетке есть одна приятная вещь: все пары, имеющие

34
00:02:41,120 --> 00:02:47,040
постоянную сумму, видны вдоль одной из этих разных диагоналей. Таким образом, простой подсчет

35
00:02:47,040 --> 00:02:51,920
количества чисел на каждой из этих диагоналей покажет вам, насколько вероятно, что вы увидите определенную сумму.

36
00:02:52,880 --> 00:02:57,760
И я бы сказал, очень хорошо, очень хорошо, но можете ли вы придумать какой-нибудь другой способ визуализировать тот

37
00:02:57,760 --> 00:03:03,120
же вопрос? Другие образы, которые могут прийти на ум, если подумать обо всех различных парах, имеющих заданную

38
00:03:03,120 --> 00:03:08,800
сумму? И, возможно, кто-то из вас поднимет руку и скажет: «Да, он у меня есть». Допустим, вы представляете

39
00:03:08,800 --> 00:03:14,560
эти два разных набора возможностей каждый подряд, но переворачиваете второй ряд. Таким образом,

40
00:03:14,560 --> 00:03:20,160
все пары, составляющие в сумме семь, выстраиваются вертикально вот так. А если мы сдвинем

41
00:03:20,160 --> 00:03:24,880
этот нижний ряд до упора вправо, то единственная пара, которая в сумме дает два, — змеиные глаза,

42
00:03:24,880 --> 00:03:29,680
— будет единственной, которая совпадет. И если я сдвину это на одну единицу вправо, пары, которые выровняются,

43
00:03:29,680 --> 00:03:35,440
окажутся двумя разными парами, сумма которых составит три. И вообще, разные значения смещения этого нижнего

44
00:03:35,440 --> 00:03:40,320
массива, который, как я помню, сначала пришлось перевернуть, выявляют все отдельные пары, имеющие

45
00:03:40,320 --> 00:03:48,800
заданную сумму. Что касается вопросов вероятности, то это пока не особенно интересно, потому что все,

46
00:03:48,800 --> 00:03:53,120
что мы делаем, — это подсчитываем, сколько исходов имеется в каждой из этих категорий.

47
00:03:53,120 --> 00:03:57,280
Но это при неявном предположении, что у каждого из этих лиц есть равные шансы

48
00:03:57,280 --> 00:04:02,240
появиться. Но что, если я скажу вам, что у меня есть особый набор игральных костей, который не является одинаковым? Возможно,

49
00:04:02,240 --> 00:04:06,800
синий кубик имеет свой собственный набор чисел, описывающий вероятность выпадения каждой грани, а красный

50
00:04:06,800 --> 00:04:11,920
кубик имеет свой собственный уникальный набор чисел. В этом случае, если вы хотите вычислить,

51
00:04:11,920 --> 00:04:17,360
скажем, вероятность увидеть двойку, вы должны умножить вероятность того, что на синем кубике выпадет единица, на

52
00:04:17,360 --> 00:04:22,000
вероятность того, что на красном кубике выпадет единица. А чтобы узнать шансы увидеть тройку, вы

53
00:04:22,000 --> 00:04:26,880
смотрите на две разные пары, где это возможно, и снова умножаете соответствующие вероятности,

54
00:04:26,880 --> 00:04:32,240
а затем складываете эти два произведения вместе. Точно так же вероятность увидеть

55
00:04:32,240 --> 00:04:36,320
четверку предполагает перемножение трех разных пар возможностей и сложение их всех вместе.

56
00:04:36,320 --> 00:04:41,360
И в духе составления некоторых формул давайте назовем эти верхние вероятности a1, a2, a3 и

57
00:04:41,360 --> 00:04:48,000
так далее, а нижние назовем b1, b2, b3 и так далее. И вообще, этот процесс,

58
00:04:48,000 --> 00:04:52,080
когда мы берём два разных массива чисел, переворачиваем второй, а затем выравниваем

59
00:04:52,080 --> 00:04:56,160
их с разными значениями смещения, берём кучу попарных произведений и складываем их,

60
00:04:56,160 --> 00:05:00,960
это один из фундаментальные способы думать о том, что такое свертка.

61
00:05:00,960 --> 00:05:08,960
Чтобы выразить это более точно, в ходе этого процесса мы просто сгенерировали вероятности увидеть два,

62
00:05:08,960 --> 00:05:13,840
три, четыре, и так далее, вплоть до 12, и мы получили их, смешав один список

63
00:05:13,840 --> 00:05:20,080
значений, a и другой. список ценностей, б. На жаргоне мы бы сказали, что свертка этих

64
00:05:20,080 --> 00:05:25,600
двух последовательностей дает нам новую последовательность, новую последовательность из 11 значений, каждое из которых выглядит

65
00:05:25,600 --> 00:05:30,160
как некоторая сумма попарных произведений. Если хотите, вы можете выполнить ту же операцию еще одним

66
00:05:30,160 --> 00:05:36,240
способом — сначала создать таблицу всех попарных произведений, а затем сложить их по всем

67
00:05:36,240 --> 00:05:41,120
диагоналям. Опять же, это способ смешать эти две последовательности чисел, чтобы получить новую последовательность

68
00:05:41,120 --> 00:05:46,400
из 11 чисел. Это та же самая операция, что и в случае с раздвижными окнами, только с другой точки зрения.

69
00:05:46,960 --> 00:05:51,280
Сделав небольшие примечания, вот как вы можете увидеть это записанным. Свертка a и b,

70
00:05:51,280 --> 00:05:57,200
обозначенная этой маленькой звездочкой, представляет собой новый список, и n-й элемент этого списка выглядит как сумма,

71
00:05:57,200 --> 00:06:03,440
и эта сумма охватывает все разные пары индексов i и j, так что сумма эти

72
00:06:03,440 --> 00:06:09,440
индексы равны n. Это довольно многословно, но, например, если n равно 6, мы рассматриваем пары: 1 и 5,

73
00:06:09,440 --> 00:06:15,680
2 и 4, 3 и 3, 4 и 2, 5 и 1, все разные пары, которые складываются. до 6.

74
00:06:16,400 --> 00:06:20,640
Но, честно говоря, как бы вы это ни записывали, обозначения второстепенны по сравнению с визуальным представлением процесса,

75
00:06:20,640 --> 00:06:26,320
которое вы можете держать в голове. Здесь, возможно, поможет очень простой пример, где я мог бы

76
00:06:26,320 --> 00:06:32,000
спросить вас, какова свертка списка 1, 2, 3 со списком 4, 5, 6. Вы можете представить,

77
00:06:32,000 --> 00:06:36,160
как берете оба этих списка, переворачиваете второй, а затем начинаете с его

78
00:06:36,160 --> 00:06:41,200
крышки до упора влево. Затем пара значений, которые совпадают, — это 1 и 4, умножаем их

79
00:06:41,200 --> 00:06:45,680
вместе, и это дает нам первый член нашего результата. Сдвиньте нижний массив на одну единицу вправо, выровняются

80
00:06:45,680 --> 00:06:51,840
пары: 1 и 5, а также 2 и 4, умножьте эти пары, сложите их вместе, и это даст

81
00:06:51,840 --> 00:06:57,600
нам 13, следующую запись в нашем выводе. Сдвиньте элементы еще раз, и мы возьмем 1×6,

82
00:06:57,600 --> 00:07:04,400
плюс 2×5, плюс 3×4, что составит 28. Еще один слайд, и мы получаем 2×6

83
00:07:04,400 --> 00:07:10,000
плюс 3×5, что дает нам 27, и, наконец, последний член будет выглядеть как 3×6.

84
00:07:10,560 --> 00:07:14,080
Если хотите, вы можете использовать любой ваш любимый язык программирования и любимую

85
00:07:14,080 --> 00:07:18,640
библиотеку, включающую различные числовые операции, и подтвердить, что я вам не лгу.

86
00:07:18,640 --> 00:07:24,320
Если вы возьмете свертку 1, 2, 3 против 4, 5, 6, вы действительно получите именно такой результат.

87
00:07:24,880 --> 00:07:29,200
Мы видели один случай, когда это естественная и желательная операция, суммирующая распределения вероятностей,

88
00:07:29,200 --> 00:07:34,640
а другим распространенным примером может быть скользящее среднее. Представьте, что у вас есть длинный

89
00:07:34,640 --> 00:07:39,920
список чисел, и вы берете другой, меньший список чисел, сумма которых равна 1. В данном случае у

90
00:07:39,920 --> 00:07:45,280
меня есть небольшой список из 5 значений, и все они равны 15-му. Затем, если мы выполним этот

91
00:07:45,280 --> 00:07:49,760
процесс свертки скользящего окна, закроем глаза и заметим, что происходит в самом начале,

92
00:07:50,560 --> 00:07:55,120
когда наш меньший список значений полностью перекрывается с большим, подумайте о том, что

93
00:07:55,680 --> 00:08:01,120
каждый термин в этом действительно означает свертка. На каждой итерации вы умножаете каждое

94
00:08:01,120 --> 00:08:06,400
значение ваших данных на 15 и складываете их все вместе, то есть вы

95
00:08:06,400 --> 00:08:12,080
берете среднее значение ваших данных внутри этого маленького окна. В целом, этот процесс

96
00:08:12,080 --> 00:08:16,800
дает вам сглаженную версию исходных данных, и вы можете изменить ее, начиная с другого небольшого списка

97
00:08:16,800 --> 00:08:21,280
чисел, и пока весь этот небольшой список в сумме дает 1, вы все равно можете интерпретировать

98
00:08:21,280 --> 00:08:25,840
его как движущееся число. средний. В показанном здесь примере это скользящее среднее будет придавать

99
00:08:25,840 --> 00:08:30,720
больший вес центральному значению. Это также приводит к сглаженной версии данных.

100
00:08:33,200 --> 00:08:37,840
Если вы сделаете своего рода двумерный аналог этого, вы получите забавный алгоритм размытия данного

101
00:08:37,840 --> 00:08:43,120
изображения. И я должен сказать, что анимации, которые я собираюсь показать, являются модификациями того, что

102
00:08:43,120 --> 00:08:48,160
я изначально сделал для части серии лекций, которые я читал в лаборатории Джулии в Массачусетском технологическом

103
00:08:48,160 --> 00:08:52,320
институте для определенного класса OpenCourseWare, который включал блок обработки изображений. Там мы еще немного углубились

104
00:08:52,320 --> 00:08:56,640
в код всего этого, поэтому, если вам интересно, я оставлю вам несколько ссылок. Но

105
00:08:56,640 --> 00:09:01,440
если вернуться к этому примеру с размытием, то у меня есть небольшая сетка значений 3х3,

106
00:09:01,440 --> 00:09:06,480
которая проходит вдоль нашего исходного изображения, и если мы увеличим масштаб, каждое из этих значений

107
00:09:06,480 --> 00:09:11,120
будет 19-м, и что я делаю на каждой итерации каждое из этих значений умножается на

108
00:09:11,120 --> 00:09:16,080
соответствующий пиксель, над которым оно находится. И, конечно же, в информатике мы думаем о

109
00:09:16,080 --> 00:09:20,400
цветах как о маленьких векторах трех значений, представляющих красный, зеленый и синий компоненты.

110
00:09:20,400 --> 00:09:25,440
Когда я умножаю все эти маленькие значения на 19 и складываю их вместе, мы получаем

111
00:09:25,440 --> 00:09:30,480
среднее значение по каждому цветовому каналу, и соответствующий пиксель изображения справа определяется как эта

112
00:09:30,480 --> 00:09:36,320
сумма. Общий эффект, когда мы делаем это для каждого отдельного пикселя изображения, заключается в том, что каждый

113
00:09:36,320 --> 00:09:40,880
из них как бы просачивается на всех своих соседей, что дает нам более размытую версию, чем оригинал.

114
00:09:41,680 --> 00:09:46,640
На жаргоне мы бы сказали, что изображение справа представляет собой свертку нашего исходного изображения с

115
00:09:46,640 --> 00:09:52,000
небольшой сеткой значений. Или более технически, может быть, я должен сказать, что это свертка с повернутой

116
00:09:52,000 --> 00:09:56,160
на 180 градусов версией этой маленькой сетки значений. Не то чтобы это имело значение,

117
00:09:56,160 --> 00:10:00,720
когда сетка симметрична, но просто стоит иметь в виду, что определение свертки, унаследованное

118
00:10:00,720 --> 00:10:05,760
из чисто математического контекста, всегда должно побуждать вас задуматься о переворачивании второго массива.

119
00:10:05,760 --> 00:10:10,240
Если мы немного изменим это, мы сможем получить гораздо более элегантный эффект размытия, выбрав другую

120
00:10:10,240 --> 00:10:15,920
сетку значений. В данном случае у меня есть небольшая сетка 5х5, но разница не столько в ее размере.

121
00:10:15,920 --> 00:10:19,920
Если мы увеличим масштаб, мы заметим, что значение в середине намного больше, чем значение по

122
00:10:19,920 --> 00:10:25,360
краям, и это происходит потому, что все они выбраны из колоколообразной кривой, известной как распределение

123
00:10:25,360 --> 00:10:30,240
Гаусса. Таким образом, когда мы умножаем все эти значения на соответствующий пиксель, над которым они

124
00:10:30,240 --> 00:10:35,200
расположены, мы придаем гораздо больший вес этому центральному пикселю и гораздо меньший вес тем, кто

125
00:10:35,200 --> 00:10:39,920
находится по краям. И, как и раньше, соответствующий пиксель справа определяется как эта

126
00:10:39,920 --> 00:10:45,360
сумма. Поскольку мы проделываем этот процесс для каждого отдельного пикселя, это дает эффект

127
00:10:45,360 --> 00:10:49,760
размытия, который гораздо более достоверно имитирует расфокусировку объектива или что-то в этом роде.

128
00:10:49,760 --> 00:10:54,960
Но размытие — далеко не единственное, что можно сделать с помощью этой идеи. Например, взгляните на эту

129
00:10:54,960 --> 00:10:59,600
небольшую сетку значений, которая включает несколько положительных чисел слева и несколько отрицательных чисел

130
00:10:59,600 --> 00:11:04,480
справа, которые я раскрасю синим и красным цветом соответственно. Найдите минутку и посмотрите, сможете

131
00:11:04,480 --> 00:11:11,680
ли вы предсказать и понять, какой эффект это окажет на окончательное изображение. Итак, в этом случае я

132
00:11:11,680 --> 00:11:16,560
буду просто думать об изображении как о цветном, а не о цветном, поэтому каждый пиксель

133
00:11:16,560 --> 00:11:21,280
представлен одним числом вместо трех. И стоит отметить одну вещь: при выполнении этой свертки

134
00:11:21,280 --> 00:11:26,240
можно получить отрицательные значения. Например, на этом этапе, если мы увеличим левую половину нашей

135
00:11:26,240 --> 00:11:30,960
маленькой сетки, она полностью окажется поверх черных пикселей, которые будут иметь нулевое значение, но вся

136
00:11:30,960 --> 00:11:35,360
правая половина отрицательных значений окажется поверх белых пикселей, что будет иметь значение, равное единице.

137
00:11:36,000 --> 00:11:40,960
Поэтому, когда мы умножаем соответствующие термины и складываем их вместе, результаты будут очень отрицательными, и

138
00:11:40,960 --> 00:11:45,120
я показываю это на изображении справа: окрашиваю отрицательные значения в красный цвет, а положительные

139
00:11:45,120 --> 00:11:49,520
значения в синий. Еще одна вещь, на которую следует обратить внимание: когда вы находитесь на участке одного и

140
00:11:49,520 --> 00:11:55,680
того же цвета, все обращается к нулю, поскольку сумма значений в нашей маленькой сетке равна нулю. Это сильно отличается

141
00:11:55,680 --> 00:11:59,680
от двух предыдущих примеров, где сумма нашей маленькой сетки была равна единице, что позволяет нам интерпретировать

142
00:11:59,680 --> 00:12:05,760
ее как скользящее среднее и, следовательно, как размытие. В общем, этот небольшой процесс в

143
00:12:05,760 --> 00:12:10,240
основном обнаруживает изменения в значении пикселя при движении слева направо, и поэтому

144
00:12:10,240 --> 00:12:13,760
он дает вам своего рода способ уловить все вертикальные края вашего изображения.

145
00:12:16,560 --> 00:12:20,960
И аналогичным образом, если мы повернем эту сетку так, чтобы она менялась при движении

146
00:12:20,960 --> 00:12:26,000
сверху вниз, это будет отражаться на всех горизонтальных краях, что в случае с изображением

147
00:12:26,000 --> 00:12:31,520
нашего маленького пирога-существа действительно приводит к появлению довольно демонических глаз. Эту меньшую сетку, кстати, часто

148
00:12:31,520 --> 00:12:36,160
называют ядром, и прелесть здесь в том, что, просто выбрав другое ядро, вы можете получить

149
00:12:36,160 --> 00:12:40,240
разные эффекты обработки изображения, не только размытие обнаружения краев, но и такие вещи, как повышение

150
00:12:40,240 --> 00:12:44,800
резкости. Для тех из вас, кто слышал о сверточной нейронной сети, идея состоит в том,

151
00:12:44,800 --> 00:12:49,600
чтобы использовать данные, чтобы выяснить, какими должны быть ядра в первую очередь, что определяется тем,

152
00:12:49,600 --> 00:12:55,120
что нейронная сеть хочет обнаружить. Еще одна вещь, о которой мне, возможно, следует упомянуть, — это длина

153
00:12:55,120 --> 00:12:59,040
вывода. Для чего-то вроде примера со скользящим средним вы можете думать об условиях только тогда, когда

154
00:12:59,040 --> 00:13:04,080
оба окна полностью совпадают друг с другом, или в примере с обработкой изображения, возможно, вы

155
00:13:04,080 --> 00:13:09,200
хотите, чтобы окончательный результат имел тот же размер, что и оригинал. Теперь свертки как чисто математическая

156
00:13:09,200 --> 00:13:13,920
операция всегда создают массив, который больше, чем два массива, с которых вы начали, по крайней мере,

157
00:13:13,920 --> 00:13:17,520
при условии, что длина одного из них не равна единице. Просто знайте, что в

158
00:13:17,520 --> 00:13:21,440
некоторых контекстах информатики вам часто нужно намеренно урезать этот вывод.

159
00:13:21,520 --> 00:13:29,200
Еще одна вещь, которую стоит подчеркнуть, это то, что в контексте информатики идея переворачивания ядра

160
00:13:29,200 --> 00:13:34,080
перед тем, как позволить ему пройти по оригиналу, часто кажется очень странной и просто ненужной,

161
00:13:34,080 --> 00:13:38,960
но еще раз обратите внимание, что это то, что унаследовано из контекста чистой математики, где,

162
00:13:38,960 --> 00:13:44,000
как мы видел, что с вероятностями это невероятно естественная вещь. И на самом деле я

163
00:13:44,000 --> 00:13:48,480
могу показать вам еще один чисто математический пример, который должен интересовать даже программистов, потому что он

164
00:13:48,480 --> 00:13:53,760
открывает двери для гораздо более быстрого алгоритма для вычисления всего этого. Чтобы настроить то, что я

165
00:13:53,760 --> 00:13:58,560
подразумеваю под словом «быстрее», позвольте мне вернуться назад и снова использовать Python, и я собираюсь создать два

166
00:13:58,560 --> 00:14:02,880
разных относительно больших массива. В каждом из них будет сто тысяч случайных элементов, и

167
00:14:02,880 --> 00:14:08,640
я собираюсь оценить время выполнения функции свертки из библиотеки numpy. И в этом

168
00:14:08,640 --> 00:14:12,800
случае он запускает несколько разных итераций, пытается найти среднее значение, и похоже, что на этом

169
00:14:12,880 --> 00:14:18,640
компьютере оно составляет как минимум 4. 87 секунд. Напротив, если я использую другую функцию

170
00:14:18,640 --> 00:14:24,080
из библиотеки scipy под названием fftconvolve, которая представляет собой то же самое, но реализовано по-другому

171
00:14:24,080 --> 00:14:30,640
и требует всего 4. В среднем 3 миллисекунды, то есть улучшение на три порядка.

172
00:14:30,640 --> 00:14:34,800
И опять же, несмотря на то, что она работает под другим именем, она выдает тот же

173
00:14:34,800 --> 00:14:38,880
результат, что и другая функция свертки, она просто делает что-то, чтобы сделать это более умным способом.

174
00:14:38,880 --> 00:14:46,800
Помните, как в примере с вероятностью я говорил, что еще один способ подумать о

175
00:14:46,800 --> 00:14:51,520
свертке — это создать таблицу всех попарных произведений, а затем сложить эти попарные произведения

176
00:14:51,520 --> 00:14:56,560
по диагоналям. Конечно, в вероятности нет ничего особенного, и каждый раз, когда вы складываете два

177
00:14:56,560 --> 00:15:00,880
разных списка чисел, вы можете думать об этом таким образом. Создайте такую таблицу умножения со всеми

178
00:15:00,880 --> 00:15:05,520
попарными произведениями, и тогда каждая сумма по диагонали будет соответствовать одному из ваших конечных

179
00:15:05,520 --> 00:15:11,680
результатов. Один из контекстов, где эта точка зрения особенно естественна, — это перемножение

180
00:15:11,680 --> 00:15:16,240
двух многочленов. Например, позвольте мне взять уже имеющуюся у нас маленькую сетку и заменить верхние члены на

181
00:15:16,240 --> 00:15:23,920
1, 2x и 3x в квадрате, а остальные члены на 4, 5x и 6x в квадрате.

182
00:15:23,920 --> 00:15:27,920
Теперь подумайте, что это значит, когда мы создаем все эти разные попарные продукты между

183
00:15:27,920 --> 00:15:32,960
двумя списками. То, что вы делаете, по сути, расширяет полное произведение двух записанных мною многочленов,

184
00:15:32,960 --> 00:15:38,240
а затем, когда вы суммируете по диагонали, что соответствует сбору всех подобных членов, что

185
00:15:38,240 --> 00:15:43,920
довольно аккуратно, расширение полинома и сбор подобных членов - это именно то, что нужно.

186
00:15:43,920 --> 00:15:50,640
тот же процесс, что и свертка. Но это позволяет нам сделать что-то очень крутое, потому что подумайте

187
00:15:50,640 --> 00:15:55,360
о том, о чем мы здесь говорим. Мы говорим, что если вы берете две разные функции

188
00:15:55,360 --> 00:16:00,560
и перемножаете их вместе, что представляет собой простую поточечную операцию, это то же самое, как если

189
00:16:00,560 --> 00:16:05,920
бы вы сначала извлекли коэффициенты из каждой из них, предполагая, что они являются полиномами, а

190
00:16:05,920 --> 00:16:11,840
затем произвели свертку этих два списка коэффициентов. Что делает это настолько интересным, так это то, что

191
00:16:11,840 --> 00:16:16,560
свертки в принципе кажутся намного сложнее, чем простое умножение, и я не просто имею в виду,

192
00:16:16,560 --> 00:16:21,760
что концептуально о них труднее думать, я имею в виду, что с вычислительной точки зрения для

193
00:16:21,760 --> 00:16:27,040
выполнения свертки требуется больше шагов, чем для выполнения поточечное произведение двух разных списков. Например, предположим, я

194
00:16:27,040 --> 00:16:31,920
дал вам два действительно больших многочлена, скажем, каждый с сотней различных коэффициентов, тогда, если способ

195
00:16:32,480 --> 00:16:37,520
их умножения заключался в расширении этого известного вам продукта, заполняя всю эту сетку попарных произведений размером

196
00:16:37,520 --> 00:16:43,600
100 на 100, что потребовало бы от вас выполнить 10 000 различных произведений, а затем,

197
00:16:43,600 --> 00:16:48,560
когда вы соберете все одинаковые термины по диагоналям, получится еще один набор из примерно 10

198
00:16:48,560 --> 00:16:55,200
000 операций. В более общем смысле на жаргоне мы бы сказали, что алгоритм представляет собой O из

199
00:16:55,200 --> 00:17:00,560
n в квадрате, что означает для двух списков размера n, то есть количество операций масштабируется пропорционально квадрату n.

200
00:17:00,560 --> 00:17:06,320
С другой стороны, если я думаю о двух полиномах с точки зрения их выходных

201
00:17:06,320 --> 00:17:11,680
данных, например, о выборке их значений на нескольких входных данных, то для их умножения требуется

202
00:17:11,680 --> 00:17:17,200
столько операций, сколько количество выборок, поскольку опять же это точечная операция, а с полиномами вам

203
00:17:17,200 --> 00:17:22,400
нужно только конечное число выборок, чтобы иметь возможность восстановить коэффициенты. Например, двух выходных данных

204
00:17:22,400 --> 00:17:27,920
достаточно, чтобы однозначно указать линейный полином, трех выходных данных будет достаточно, чтобы однозначно указать квадратичный многочлен,

205
00:17:27,920 --> 00:17:33,680
и в целом, если вы знаете n различных выходных данных, этого достаточно, чтобы однозначно указать полином,

206
00:17:33,680 --> 00:17:38,800
который имеет n различных коэффициентов, или, если вы предпочитаете, мы могли бы сформулируйте это на языке

207
00:17:38,800 --> 00:17:43,680
систем уравнений. Представьте себе, я говорю вам, что у меня есть некоторый многочлен, но я не

208
00:17:43,680 --> 00:17:47,840
говорю вам, что это за коэффициенты, для вас это загадка. В нашем примере вы можете думать об

209
00:17:47,840 --> 00:17:52,960
этом как о продукте, который мы пытаемся вычислить, а затем предположим, что я говорю, что просто скажу вам, какими

210
00:17:52,960 --> 00:17:59,600
были бы выходные данные этого полинома, если бы вы ввели различные входные данные, например 0, 1, 2. ,

211
00:17:59,600 --> 00:18:04,800
3, и так далее, и я даю вам достаточно, чтобы у вас было столько же уравнений, сколько и неизвестных,

212
00:18:04,800 --> 00:18:09,840
это даже бывает линейная система уравнений, так что это хорошо, и в принципе, по крайней мере, этого должно быть

213
00:18:09,840 --> 00:18:14,880
достаточно для восстановления коэффициентов.

214
00:18:14,880 --> 00:18:20,160


215
00:18:20,160 --> 00:18:26,560


216
00:18:26,560 --> 00:18:32,720


217
00:18:32,720 --> 00:18:38,000


218
00:18:38,000 --> 00:18:43,120


219
00:18:43,120 --> 00:18:47,760


220
00:18:47,760 --> 00:18:53,520


221
00:18:53,520 --> 00:18:58,400


222
00:18:58,400 --> 00:19:04,240


223
00:19:04,240 --> 00:19:09,200


224
00:19:09,200 --> 00:19:13,600


225
00:19:13,600 --> 00:19:18,720


226
00:19:18,720 --> 00:19:23,840


227
00:19:23,840 --> 00:19:30,080


228
00:19:30,080 --> 00:19:34,400


229
00:19:34,400 --> 00:19:41,600


230
00:19:41,600 --> 00:19:46,480


231
00:19:46,480 --> 00:19:51,360


232
00:19:51,360 --> 00:19:57,600


233
00:19:57,600 --> 00:20:03,200


234
00:20:03,200 --> 00:20:08,160


235
00:20:08,160 --> 00:20:12,640


236
00:20:12,640 --> 00:20:17,520


237
00:20:17,520 --> 00:20:22,720


238
00:20:22,720 --> 00:20:28,320


239
00:20:28,320 --> 00:20:33,040


240
00:20:33,040 --> 00:20:38,080


241
00:20:38,080 --> 00:20:43,600


242
00:20:43,600 --> 00:20:48,640


243
00:20:48,640 --> 00:20:53,200


244
00:20:53,200 --> 00:20:58,960


245
00:20:58,960 --> 00:21:03,280


246
00:21:03,280 --> 00:21:08,960


247
00:21:08,960 --> 00:21:14,480


248
00:21:14,480 --> 00:21:18,480


249
00:21:18,480 --> 00:21:25,600


250
00:21:25,600 --> 00:21:30,560


251
00:21:30,560 --> 00:21:35,120


252
00:21:35,120 --> 00:21:39,600


253
00:21:39,600 --> 00:21:44,480


254
00:21:44,480 --> 00:21:50,160


255
00:21:50,160 --> 00:21:54,800


256
00:21:54,800 --> 00:21:59,360


257
00:21:59,360 --> 00:22:04,640


258
00:22:04,640 --> 00:22:10,720


259
00:22:10,720 --> 00:22:16,000


260
00:22:16,000 --> 00:22:20,720


261
00:22:20,720 --> 00:22:26,320


262
00:22:26,320 --> 00:22:31,280


263
00:22:31,280 --> 00:22:36,880


264
00:22:36,880 --> 00:22:51,040


