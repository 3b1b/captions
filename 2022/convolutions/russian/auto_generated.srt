1
00:00:00,000 --> 00:00:03,852
Предположим, я даю вам два разных списка чисел или, может быть, две разные функции, и

2
00:00:03,852 --> 00:00:07,615
прошу вас подумать обо всех способах, которыми вы можете объединить эти два списка,

3
00:00:07,615 --> 00:00:11,378
чтобы получить новый список чисел, или объединить две функции, чтобы получить новую

4
00:00:11,378 --> 00:00:11,737
функцию.

5
00:00:11,737 --> 00:00:14,126
Возможно, один простой способ, который приходит

6
00:00:14,126 --> 00:00:16,267
на ум, — это просто складывать их почленно.

7
00:00:16,267 --> 00:00:20,050
Аналогично с функциями вы можете добавить все соответствующие выходы.

8
00:00:20,050 --> 00:00:23,258
Подобным же образом вы можете умножить два списка

9
00:00:23,258 --> 00:00:26,145
почленно и проделать то же самое с функциями.

10
00:00:26,145 --> 00:00:29,866
Но есть еще один вид комбинации, столь же фундаментальный,

11
00:00:29,866 --> 00:00:33,840
как и оба, но гораздо менее обсуждаемый, известный как свертка.

12
00:00:33,840 --> 00:00:36,637
Но в отличие от двух предыдущих случаев, это не просто

13
00:00:36,637 --> 00:00:39,893
унаследовано от операции, которую вы можете выполнить с числами.

14
00:00:39,893 --> 00:00:44,716
Это что-то действительно новое для контекста списков чисел или объединения функций.

15
00:00:44,716 --> 00:00:48,754
Они появляются повсюду, они повсеместно используются при обработке изображений,

16
00:00:48,754 --> 00:00:52,438
это основная конструкция теории вероятностей, они часто используются при

17
00:00:52,438 --> 00:00:56,021
решении дифференциальных уравнений, и есть один контекст, где вы почти

18
00:00:56,021 --> 00:01:00,210
наверняка видели это, если не под этим названием перемножает два многочлена вместе.

19
00:01:00,210 --> 00:01:04,036
Для человека, занимающегося визуальными объяснениями, это особенно интересная

20
00:01:04,036 --> 00:01:07,665
тема, потому что шаблонное определение изолированно и без контекста может

21
00:01:07,665 --> 00:01:11,050
выглядеть отчасти устрашающе, но если мы потратим время на то, чтобы

22
00:01:11,050 --> 00:01:14,434
по-настоящему раскрыть то, что оно говорит, и до этого действительно

23
00:01:14,434 --> 00:01:18,800
мотивировать, почему вам бы хотелось чего-то подобного, это невероятно красивая операция.

24
00:01:18,800 --> 00:01:20,888
И я должен признать, что я действительно кое-чему

25
00:01:20,888 --> 00:01:23,436
научился, пока создавал визуальные эффекты для этого проекта.

26
00:01:23,436 --> 00:01:27,074
В случае свертки двух разных функций я пытался придумать разные способы

27
00:01:27,074 --> 00:01:31,016
представить, что это может означать, и с одним из них у меня возник небольшой

28
00:01:31,016 --> 00:01:34,655
ага-момент, почему нормальное распределение играет ту роль, которую они

29
00:01:34,655 --> 00:01:38,445
делают это с вероятностью, почему это такая естественная форма для функции.

30
00:01:38,445 --> 00:01:41,580
Но я забегаю вперед, для этого есть много настроек.

31
00:01:41,580 --> 00:01:45,760
В этом видео наше основное внимание будет сосредоточено на дискретном случае и, в

32
00:01:45,760 --> 00:01:50,196
частности, на создании очень неожиданного, но очень умного алгоритма для их вычисления.

33
00:01:50,196 --> 00:01:57,840
А обсуждение непрерывного случая я вынесу во вторую часть.

34
00:01:57,840 --> 00:02:01,931
Очень заманчиво начать с примеров обработки изображений, поскольку они визуально

35
00:02:01,931 --> 00:02:05,669
наиболее интригуют, но есть пара мелочей, которые делают случай обработки

36
00:02:05,669 --> 00:02:09,558
изображений менее репрезентативным для сверток в целом, поэтому вместо этого

37
00:02:09,558 --> 00:02:13,498
давайте начнем с вероятности, и, в частности, один из самых простых примеров,

38
00:02:13,498 --> 00:02:17,388
о котором, я уверен, каждый здесь задумывался в какой-то момент своей жизни,

39
00:02:17,388 --> 00:02:21,530
а именно: бросить пару игральных костей и вычислить шансы увидеть различные суммы.

40
00:02:21,530 --> 00:02:24,170
И вы можете сказать: не проблема, не проблема.

41
00:02:24,170 --> 00:02:28,259
Каждая из ваших двух игральных костей имеет шесть различных возможных результатов,

42
00:02:28,259 --> 00:02:32,249
что дает нам в общей сложности 36 различных возможных пар результатов, и если мы

43
00:02:32,249 --> 00:02:36,240
просто просмотрим их все, мы сможем подсчитать, сколько пар имеют заданную сумму.

44
00:02:36,240 --> 00:02:40,718
При таком расположении всех пар в сетке есть одна приятная вещь: все

45
00:02:40,718 --> 00:02:45,650
пары, имеющие постоянную сумму, видны вдоль одной из этих разных диагоналей.

46
00:02:45,650 --> 00:02:49,516
Таким образом, простой подсчет количества чисел на каждой из этих диагоналей

47
00:02:49,516 --> 00:02:52,880
покажет вам, насколько вероятно, что вы увидите определенную сумму.

48
00:02:52,880 --> 00:02:55,604
И я бы сказал, очень хорошо, очень хорошо, но можете ли вы

49
00:02:55,604 --> 00:02:58,699
придумать какой-нибудь другой способ визуализировать тот же вопрос?

50
00:02:58,699 --> 00:03:01,412
Другие образы, которые могут прийти на ум, если подумать

51
00:03:01,412 --> 00:03:03,744
обо всех различных парах, имеющих заданную сумму?

52
00:03:03,744 --> 00:03:07,550
И, возможно, кто-то из вас поднимет руку и скажет: «Да, он у меня есть».

53
00:03:07,550 --> 00:03:10,525
Допустим, вы представляете эти два разных набора

54
00:03:10,525 --> 00:03:14,046
возможностей каждый подряд, но переворачиваете второй ряд.

55
00:03:14,046 --> 00:03:18,960
Таким образом, все пары, составляющие в сумме семь, выстраиваются вертикально вот так.

56
00:03:18,960 --> 00:03:22,421
А если мы сдвинем этот нижний ряд до упора вправо, то единственная пара,

57
00:03:22,421 --> 00:03:26,309
которая в сумме дает два, — змеиные глаза, — будет единственной, которая совпадет.

58
00:03:26,309 --> 00:03:29,266
И если я сдвину это на одну единицу вправо, пары, которые

59
00:03:29,266 --> 00:03:32,886
выровняются, окажутся двумя разными парами, сумма которых составит три.

60
00:03:32,886 --> 00:03:37,277
И вообще, разные значения смещения этого нижнего массива, который, как я помню,

61
00:03:37,277 --> 00:03:41,778
сначала пришлось перевернуть, выявляют все отдельные пары, имеющие заданную сумму.

62
00:03:41,778 --> 00:03:47,449
Что касается вопросов вероятности, то это пока не особенно интересно, потому что все,

63
00:03:47,449 --> 00:03:53,120
что мы делаем, — это подсчитываем, сколько исходов имеется в каждой из этих категорий.

64
00:03:53,120 --> 00:03:57,850
Но это при неявном предположении, что у каждого из этих лиц есть равные шансы появиться.

65
00:03:57,850 --> 00:03:59,757
Но что, если я скажу вам, что у меня есть особый

66
00:03:59,757 --> 00:04:01,897
набор игральных костей, который не является одинаковым?

67
00:04:01,897 --> 00:04:05,725
Возможно, синий кубик имеет свой собственный набор чисел, описывающий вероятность

68
00:04:05,725 --> 00:04:09,740
выпадения каждой грани, а красный кубик имеет свой собственный уникальный набор чисел.

69
00:04:09,740 --> 00:04:13,077
В этом случае, если вы хотите вычислить, скажем, вероятность увидеть

70
00:04:13,077 --> 00:04:16,607
двойку, вы должны умножить вероятность того, что на синем кубике выпадет

71
00:04:16,607 --> 00:04:19,895
единица, на вероятность того, что на красном кубике выпадет единица.

72
00:04:19,895 --> 00:04:23,387
А чтобы узнать шансы увидеть тройку, вы смотрите на две разные

73
00:04:23,387 --> 00:04:26,602
пары, где это возможно, и снова умножаете соответствующие

74
00:04:26,602 --> 00:04:29,983
вероятности, а затем складываете эти два произведения вместе.

75
00:04:29,983 --> 00:04:33,008
Точно так же вероятность увидеть четверку предполагает

76
00:04:33,008 --> 00:04:36,748
перемножение трех разных пар возможностей и сложение их всех вместе.

77
00:04:36,748 --> 00:04:41,003
И в духе составления некоторых формул давайте назовем эти верхние

78
00:04:41,003 --> 00:04:45,903
вероятности a1, a2, a3 и так далее, а нижние назовем b1, b2, b3 и так далее.

79
00:04:45,903 --> 00:04:51,060
И вообще, этот процесс, когда мы берём два разных массива чисел, переворачиваем второй,

80
00:04:51,060 --> 00:04:56,158
а затем выравниваем их с разными значениями смещения, берём кучу попарных произведений

81
00:04:56,158 --> 00:05:01,139
и складываем их, это один из фундаментальные способы думать о том, что такое свертка.

82
00:05:01,139 --> 00:05:06,742
Чтобы выразить это более точно, в ходе этого процесса мы просто сгенерировали

83
00:05:06,742 --> 00:05:11,769
вероятности увидеть два, три, четыре, и так далее, вплоть до 12, и мы

84
00:05:11,769 --> 00:05:17,084
получили их, смешав один список значений, a и другой. список ценностей, б.

85
00:05:17,084 --> 00:05:20,524
На жаргоне мы бы сказали, что свертка этих двух последовательностей дает

86
00:05:20,524 --> 00:05:23,869
нам новую последовательность, новую последовательность из 11 значений,

87
00:05:23,869 --> 00:05:27,120
каждое из которых выглядит как некоторая сумма попарных произведений.

88
00:05:27,120 --> 00:05:31,760
Если хотите, вы можете выполнить ту же операцию еще одним способом — сначала

89
00:05:31,760 --> 00:05:36,702
создать таблицу всех попарных произведений, а затем сложить их по всем диагоналям.

90
00:05:36,702 --> 00:05:39,402
Опять же, это способ смешать эти две последовательности

91
00:05:39,402 --> 00:05:42,247
чисел, чтобы получить новую последовательность из 11 чисел.

92
00:05:42,247 --> 00:05:45,064
Это та же самая операция, что и в случае с раздвижными

93
00:05:45,064 --> 00:05:46,960
окнами, только с другой точки зрения.

94
00:05:46,960 --> 00:05:50,314
Сделав небольшие примечания, вот как вы можете увидеть это записанным.

95
00:05:50,314 --> 00:05:55,079
Свертка a и b, обозначенная этой маленькой звездочкой, представляет собой

96
00:05:55,079 --> 00:05:59,780
новый список, и n-й элемент этого списка выглядит как сумма, и эта сумма

97
00:05:59,780 --> 00:06:04,738
охватывает все разные пары индексов i и j, так что сумма эти индексы равны n.

98
00:06:04,738 --> 00:06:10,569
Это довольно многословно, но, например, если n равно 6, мы рассматриваем пары:

99
00:06:10,569 --> 00:06:16,400
1 и 5, 2 и 4, 3 и 3, 4 и 2, 5 и 1, все разные пары, которые складываются. до 6.

100
00:06:16,400 --> 00:06:19,615
Но, честно говоря, как бы вы это ни записывали, обозначения второстепенны по

101
00:06:19,615 --> 00:06:23,082
сравнению с визуальным представлением процесса, которое вы можете держать в голове.

102
00:06:23,082 --> 00:06:26,928
Здесь, возможно, поможет очень простой пример, где я мог бы

103
00:06:26,928 --> 00:06:30,967
спросить вас, какова свертка списка 1, 2, 3 со списком 4, 5, 6.

104
00:06:30,967 --> 00:06:34,782
Вы можете представить, как берете оба этих списка, переворачиваете

105
00:06:34,782 --> 00:06:37,857
второй, а затем начинаете с его крышки до упора влево.

106
00:06:37,857 --> 00:06:40,986
Затем пара значений, которые совпадают, — это 1 и 4, умножаем

107
00:06:40,986 --> 00:06:43,813
их вместе, и это дает нам первый член нашего результата.

108
00:06:43,813 --> 00:06:48,997
Сдвиньте нижний массив на одну единицу вправо, выровняются пары: 1 и 5, а также 2 и 4,

109
00:06:48,997 --> 00:06:54,300
умножьте эти пары, сложите их вместе, и это даст нам 13, следующую запись в нашем выводе.

110
00:06:54,300 --> 00:07:01,591
Сдвиньте элементы еще раз, и мы возьмем 1×6, плюс 2×5, плюс 3×4, что составит 28.

111
00:07:01,591 --> 00:07:06,155
Еще один слайд, и мы получаем 2×6 плюс 3×5, что дает нам

112
00:07:06,155 --> 00:07:10,560
27, и, наконец, последний член будет выглядеть как 3×6.

113
00:07:10,560 --> 00:07:14,732
Если хотите, вы можете использовать любой ваш любимый язык программирования и любимую

114
00:07:14,732 --> 00:07:18,807
библиотеку, включающую различные числовые операции, и подтвердить, что я вам не лгу.

115
00:07:18,807 --> 00:07:21,843
Если вы возьмете свертку 1, 2, 3 против 4, 5, 6,

116
00:07:21,843 --> 00:07:24,880
вы действительно получите именно такой результат.

117
00:07:24,880 --> 00:07:28,629
Мы видели один случай, когда это естественная и желательная операция, суммирующая

118
00:07:28,629 --> 00:07:32,515
распределения вероятностей, а другим распространенным примером может быть скользящее

119
00:07:32,515 --> 00:07:32,881
среднее.

120
00:07:32,881 --> 00:07:35,731
Представьте, что у вас есть длинный список чисел, и вы

121
00:07:35,731 --> 00:07:38,788
берете другой, меньший список чисел, сумма которых равна 1.

122
00:07:38,788 --> 00:07:43,381
В данном случае у меня есть небольшой список из 5 значений, и все они равны 15-му.

123
00:07:43,381 --> 00:07:48,655
Затем, если мы выполним этот процесс свертки скользящего окна, закроем глаза и заметим,

124
00:07:48,655 --> 00:07:53,989
что происходит в самом начале, когда наш меньший список значений полностью перекрывается

125
00:07:53,989 --> 00:07:59,023
с большим, подумайте о том, что каждый термин в этом действительно означает свертка.

126
00:07:59,023 --> 00:08:04,726
На каждой итерации вы умножаете каждое значение ваших данных на 15 и складываете их

127
00:08:04,726 --> 00:08:10,769
все вместе, то есть вы берете среднее значение ваших данных внутри этого маленького окна.

128
00:08:10,769 --> 00:08:14,879
В целом, этот процесс дает вам сглаженную версию исходных данных, и вы можете изменить

129
00:08:14,879 --> 00:08:18,800
ее, начиная с другого небольшого списка чисел, и пока весь этот небольшой список в

130
00:08:18,800 --> 00:08:22,816
сумме дает 1, вы все равно можете интерпретировать его как движущееся число. средний.

131
00:08:22,816 --> 00:08:25,298
В показанном здесь примере это скользящее среднее

132
00:08:25,298 --> 00:08:27,781
будет придавать больший вес центральному значению.

133
00:08:27,781 --> 00:08:33,200
Это также приводит к сглаженной версии данных.

134
00:08:33,200 --> 00:08:35,897
Если вы сделаете своего рода двумерный аналог этого, вы

135
00:08:35,897 --> 00:08:38,594
получите забавный алгоритм размытия данного изображения.

136
00:08:38,594 --> 00:08:41,536
И я должен сказать, что анимации, которые я собираюсь показать, являются

137
00:08:41,536 --> 00:08:44,599
модификациями того, что я изначально сделал для части серии лекций, которые

138
00:08:44,599 --> 00:08:47,662
я читал в лаборатории Джулии в Массачусетском технологическом институте для

139
00:08:47,662 --> 00:08:50,887
определенного класса OpenCourseWare, который включал блок обработки изображений.

140
00:08:50,887 --> 00:08:53,848
Там мы еще немного углубились в код всего этого, поэтому,

141
00:08:53,848 --> 00:08:56,452
если вам интересно, я оставлю вам несколько ссылок.

142
00:08:56,452 --> 00:09:00,425
Но если вернуться к этому примеру с размытием, то у меня есть небольшая сетка

143
00:09:00,425 --> 00:09:04,806
значений 3х3, которая проходит вдоль нашего исходного изображения, и если мы увеличим

144
00:09:04,806 --> 00:09:09,135
масштаб, каждое из этих значений будет 19-м, и что я делаю на каждой итерации каждое

145
00:09:09,135 --> 00:09:13,312
из этих значений умножается на соответствующий пиксель, над которым оно находится.

146
00:09:13,312 --> 00:09:17,034
И, конечно же, в информатике мы думаем о цветах как о маленьких векторах

147
00:09:17,034 --> 00:09:20,400
трех значений, представляющих красный, зеленый и синий компоненты.

148
00:09:20,400 --> 00:09:23,747
Когда я умножаю все эти маленькие значения на 19 и складываю их

149
00:09:23,747 --> 00:09:27,200
вместе, мы получаем среднее значение по каждому цветовому каналу,

150
00:09:27,200 --> 00:09:30,966
и соответствующий пиксель изображения справа определяется как эта сумма.

151
00:09:30,966 --> 00:09:34,314
Общий эффект, когда мы делаем это для каждого отдельного пикселя

152
00:09:34,314 --> 00:09:37,971
изображения, заключается в том, что каждый из них как бы просачивается

153
00:09:37,971 --> 00:09:41,680
на всех своих соседей, что дает нам более размытую версию, чем оригинал.

154
00:09:41,680 --> 00:09:44,809
На жаргоне мы бы сказали, что изображение справа представляет собой

155
00:09:44,809 --> 00:09:47,800
свертку нашего исходного изображения с небольшой сеткой значений.

156
00:09:47,800 --> 00:09:51,140
Или более технически, может быть, я должен сказать, что это свертка

157
00:09:51,140 --> 00:09:54,430
с повернутой на 180 градусов версией этой маленькой сетки значений.

158
00:09:54,430 --> 00:09:58,223
Не то чтобы это имело значение, когда сетка симметрична, но просто стоит иметь

159
00:09:58,223 --> 00:10:01,727
в виду, что определение свертки, унаследованное из чисто математического

160
00:10:01,727 --> 00:10:05,760
контекста, всегда должно побуждать вас задуматься о переворачивании второго массива.

161
00:10:05,760 --> 00:10:08,254
Если мы немного изменим это, мы сможем получить гораздо

162
00:10:08,254 --> 00:10:11,059
более элегантный эффект размытия, выбрав другую сетку значений.

163
00:10:11,059 --> 00:10:15,920
В данном случае у меня есть небольшая сетка 5х5, но разница не столько в ее размере.

164
00:10:15,920 --> 00:10:19,299
Если мы увеличим масштаб, мы заметим, что значение в середине намного

165
00:10:19,299 --> 00:10:22,582
больше, чем значение по краям, и это происходит потому, что все они

166
00:10:22,582 --> 00:10:26,010
выбраны из колоколообразной кривой, известной как распределение Гаусса.

167
00:10:26,010 --> 00:10:29,334
Таким образом, когда мы умножаем все эти значения на соответствующий

168
00:10:29,334 --> 00:10:32,658
пиксель, над которым они расположены, мы придаем гораздо больший вес

169
00:10:32,658 --> 00:10:36,367
этому центральному пикселю и гораздо меньший вес тем, кто находится по краям.

170
00:10:36,367 --> 00:10:40,373
И, как и раньше, соответствующий пиксель справа определяется как эта сумма.

171
00:10:40,373 --> 00:10:43,435
Поскольку мы проделываем этот процесс для каждого отдельного

172
00:10:43,435 --> 00:10:46,296
пикселя, это дает эффект размытия, который гораздо более

173
00:10:46,296 --> 00:10:49,760
достоверно имитирует расфокусировку объектива или что-то в этом роде.

174
00:10:49,760 --> 00:10:53,474
Но размытие — далеко не единственное, что можно сделать с помощью этой идеи.

175
00:10:53,474 --> 00:10:56,783
Например, взгляните на эту небольшую сетку значений, которая включает

176
00:10:56,783 --> 00:10:59,998
несколько положительных чисел слева и несколько отрицательных чисел

177
00:10:59,998 --> 00:11:03,071
справа, которые я раскрасю синим и красным цветом соответственно.

178
00:11:03,071 --> 00:11:06,336
Найдите минутку и посмотрите, сможете ли вы предсказать и

179
00:11:06,336 --> 00:11:09,769
понять, какой эффект это окажет на окончательное изображение.

180
00:11:09,769 --> 00:11:13,897
Итак, в этом случае я буду просто думать об изображении как о цветном, а

181
00:11:13,897 --> 00:11:18,082
не о цветном, поэтому каждый пиксель представлен одним числом вместо трех.

182
00:11:18,082 --> 00:11:20,645
И стоит отметить одну вещь: при выполнении этой

183
00:11:20,645 --> 00:11:23,102
свертки можно получить отрицательные значения.

184
00:11:23,102 --> 00:11:26,417
Например, на этом этапе, если мы увеличим левую половину нашей маленькой

185
00:11:26,417 --> 00:11:29,505
сетки, она полностью окажется поверх черных пикселей, которые будут

186
00:11:29,505 --> 00:11:32,684
иметь нулевое значение, но вся правая половина отрицательных значений

187
00:11:32,684 --> 00:11:36,000
окажется поверх белых пикселей, что будет иметь значение, равное единице.

188
00:11:36,000 --> 00:11:39,179
Поэтому, когда мы умножаем соответствующие термины и складываем их вместе,

189
00:11:39,179 --> 00:11:42,570
результаты будут очень отрицательными, и я показываю это на изображении справа:

190
00:11:42,570 --> 00:11:46,046
окрашиваю отрицательные значения в красный цвет, а положительные значения в синий.

191
00:11:46,046 --> 00:11:48,905
Еще одна вещь, на которую следует обратить внимание: когда вы

192
00:11:48,905 --> 00:11:51,810
находитесь на участке одного и того же цвета, все обращается к

193
00:11:51,810 --> 00:11:54,854
нулю, поскольку сумма значений в нашей маленькой сетке равна нулю.

194
00:11:54,854 --> 00:11:57,649
Это сильно отличается от двух предыдущих примеров, где сумма нашей

195
00:11:57,649 --> 00:12:00,612
маленькой сетки была равна единице, что позволяет нам интерпретировать

196
00:12:00,612 --> 00:12:02,990
ее как скользящее среднее и, следовательно, как размытие.

197
00:12:02,990 --> 00:12:07,402
В общем, этот небольшой процесс в основном обнаруживает изменения

198
00:12:07,402 --> 00:12:11,747
в значении пикселя при движении слева направо, и поэтому он дает

199
00:12:11,747 --> 00:12:16,560
вам своего рода способ уловить все вертикальные края вашего изображения.

200
00:12:16,560 --> 00:12:19,733
И аналогичным образом, если мы повернем эту сетку так, чтобы она

201
00:12:19,733 --> 00:12:22,858
менялась при движении сверху вниз, это будет отражаться на всех

202
00:12:22,858 --> 00:12:26,178
горизонтальных краях, что в случае с изображением нашего маленького

203
00:12:26,178 --> 00:12:29,986
пирога-существа действительно приводит к появлению довольно демонических глаз.

204
00:12:29,986 --> 00:12:33,471
Эту меньшую сетку, кстати, часто называют ядром, и прелесть здесь в том, что,

205
00:12:33,471 --> 00:12:37,224
просто выбрав другое ядро, вы можете получить разные эффекты обработки изображения,

206
00:12:37,224 --> 00:12:40,710
не только размытие обнаружения краев, но и такие вещи, как повышение резкости.

207
00:12:40,710 --> 00:12:44,246
Для тех из вас, кто слышал о сверточной нейронной сети, идея состоит в

208
00:12:44,246 --> 00:12:47,832
том, чтобы использовать данные, чтобы выяснить, какими должны быть ядра

209
00:12:47,832 --> 00:12:51,618
в первую очередь, что определяется тем, что нейронная сеть хочет обнаружить.

210
00:12:51,618 --> 00:12:55,378
Еще одна вещь, о которой мне, возможно, следует упомянуть, — это длина вывода.

211
00:12:55,378 --> 00:12:59,273
Для чего-то вроде примера со скользящим средним вы можете думать об условиях только

212
00:12:59,273 --> 00:13:03,169
тогда, когда оба окна полностью совпадают друг с другом, или в примере с обработкой

213
00:13:03,169 --> 00:13:07,249
изображения, возможно, вы хотите, чтобы окончательный результат имел тот же размер, что

214
00:13:07,249 --> 00:13:07,760
и оригинал.

215
00:13:07,760 --> 00:13:10,568
Теперь свертки как чисто математическая операция всегда создают

216
00:13:10,568 --> 00:13:13,421
массив, который больше, чем два массива, с которых вы начали, по

217
00:13:13,421 --> 00:13:16,405
крайней мере, при условии, что длина одного из них не равна единице.

218
00:13:16,405 --> 00:13:19,195
Просто знайте, что в некоторых контекстах информатики

219
00:13:19,195 --> 00:13:21,520
вам часто нужно намеренно урезать этот вывод.

220
00:13:21,520 --> 00:13:26,009
Еще одна вещь, которую стоит подчеркнуть, это то, что в контексте информатики

221
00:13:26,009 --> 00:13:30,384
идея переворачивания ядра перед тем, как позволить ему пройти по оригиналу,

222
00:13:30,384 --> 00:13:34,298
часто кажется очень странной и просто ненужной, но еще раз обратите

223
00:13:34,298 --> 00:13:38,385
внимание, что это то, что унаследовано из контекста чистой математики,

224
00:13:38,385 --> 00:13:42,530
где, как мы видел, что с вероятностями это невероятно естественная вещь.

225
00:13:42,530 --> 00:13:45,901
И на самом деле я могу показать вам еще один чисто математический пример,

226
00:13:45,901 --> 00:13:49,181
который должен интересовать даже программистов, потому что он открывает

227
00:13:49,181 --> 00:13:52,370
двери для гораздо более быстрого алгоритма для вычисления всего этого.

228
00:13:52,370 --> 00:13:54,786
Чтобы настроить то, что я подразумеваю под словом «быстрее»,

229
00:13:54,786 --> 00:13:57,123
позвольте мне вернуться назад и снова использовать Python,

230
00:13:57,123 --> 00:13:59,579
и я собираюсь создать два разных относительно больших массива.

231
00:13:59,579 --> 00:14:03,764
В каждом из них будет сто тысяч случайных элементов, и я собираюсь

232
00:14:03,764 --> 00:14:07,575
оценить время выполнения функции свертки из библиотеки numpy.

233
00:14:07,575 --> 00:14:11,357
И в этом случае он запускает несколько разных итераций, пытается найти

234
00:14:11,357 --> 00:14:15,619
среднее значение, и похоже, что на этом компьютере оно составляет как минимум 4.

235
00:14:15,619 --> 00:14:16,321
87 секунд.

236
00:14:16,321 --> 00:14:21,332
Напротив, если я использую другую функцию из библиотеки scipy под названием fftconvolve,

237
00:14:21,332 --> 00:14:26,061
которая представляет собой то же самое, но реализовано по-другому и требует всего 4.

238
00:14:26,061 --> 00:14:30,640
В среднем 3 миллисекунды, то есть улучшение на три порядка.

239
00:14:30,640 --> 00:14:33,445
И опять же, несмотря на то, что она работает под другим именем,

240
00:14:33,445 --> 00:14:36,206
она выдает тот же результат, что и другая функция свертки, она

241
00:14:36,206 --> 00:14:38,880
просто делает что-то, чтобы сделать это более умным способом.

242
00:14:38,880 --> 00:14:43,241
Помните, как в примере с вероятностью я говорил, что еще один

243
00:14:43,241 --> 00:14:47,603
способ подумать о свертке — это создать таблицу всех попарных

244
00:14:47,603 --> 00:14:52,528
произведений, а затем сложить эти попарные произведения по диагоналям.

245
00:14:52,528 --> 00:14:55,760
Конечно, в вероятности нет ничего особенного, и каждый раз, когда вы

246
00:14:55,760 --> 00:14:59,321
складываете два разных списка чисел, вы можете думать об этом таким образом.

247
00:14:59,321 --> 00:15:02,960
Создайте такую таблицу умножения со всеми попарными произведениями, и тогда каждая

248
00:15:02,960 --> 00:15:06,381
сумма по диагонали будет соответствовать одному из ваших конечных результатов.

249
00:15:06,381 --> 00:15:09,436
Один из контекстов, где эта точка зрения особенно

250
00:15:09,436 --> 00:15:12,431
естественна, — это перемножение двух многочленов.

251
00:15:12,431 --> 00:15:17,960
Например, позвольте мне взять уже имеющуюся у нас маленькую сетку и заменить

252
00:15:17,960 --> 00:15:23,920
верхние члены на 1, 2x и 3x в квадрате, а остальные члены на 4, 5x и 6x в квадрате.

253
00:15:23,920 --> 00:15:26,224
Теперь подумайте, что это значит, когда мы создаем

254
00:15:26,224 --> 00:15:28,664
все эти разные попарные продукты между двумя списками.

255
00:15:28,664 --> 00:15:33,128
То, что вы делаете, по сути, расширяет полное произведение двух записанных

256
00:15:33,128 --> 00:15:37,830
мною многочленов, а затем, когда вы суммируете по диагонали, что соответствует

257
00:15:37,830 --> 00:15:42,235
сбору всех подобных членов, что довольно аккуратно, расширение полинома и

258
00:15:42,235 --> 00:15:46,937
сбор подобных членов - это именно то, что нужно. тот же процесс, что и свертка.

259
00:15:46,937 --> 00:15:49,761
Но это позволяет нам сделать что-то очень крутое,

260
00:15:49,761 --> 00:15:52,642
потому что подумайте о том, о чем мы здесь говорим.

261
00:15:52,642 --> 00:15:56,645
Мы говорим, что если вы берете две разные функции и перемножаете их вместе,

262
00:15:56,645 --> 00:16:00,754
что представляет собой простую поточечную операцию, это то же самое, как если

263
00:16:00,754 --> 00:16:04,705
бы вы сначала извлекли коэффициенты из каждой из них, предполагая, что они

264
00:16:04,705 --> 00:16:08,761
являются полиномами, а затем произвели свертку этих два списка коэффициентов.

265
00:16:08,761 --> 00:16:13,163
Что делает это настолько интересным, так это то, что свертки в принципе кажутся намного

266
00:16:13,163 --> 00:16:17,315
сложнее, чем простое умножение, и я не просто имею в виду, что концептуально о них

267
00:16:17,315 --> 00:16:21,718
труднее думать, я имею в виду, что с вычислительной точки зрения для выполнения свертки

268
00:16:21,718 --> 00:16:26,070
требуется больше шагов, чем для выполнения поточечное произведение двух разных списков.

269
00:16:26,070 --> 00:16:30,140
Например, предположим, я дал вам два действительно больших многочлена, скажем,

270
00:16:30,140 --> 00:16:33,901
каждый с сотней различных коэффициентов, тогда, если способ их умножения

271
00:16:33,901 --> 00:16:37,919
заключался в расширении этого известного вам продукта, заполняя всю эту сетку

272
00:16:37,919 --> 00:16:41,990
попарных произведений размером 100 на 100, что потребовало бы от вас выполнить

273
00:16:41,990 --> 00:16:45,751
10 000 различных произведений, а затем, когда вы соберете все одинаковые

274
00:16:45,751 --> 00:16:49,666
термины по диагоналям, получится еще один набор из примерно 10 000 операций.

275
00:16:49,666 --> 00:16:53,560
В более общем смысле на жаргоне мы бы сказали, что алгоритм представляет

276
00:16:53,560 --> 00:16:57,241
собой O из n в квадрате, что означает для двух списков размера n, то

277
00:16:57,241 --> 00:17:00,816
есть количество операций масштабируется пропорционально квадрату n.

278
00:17:00,816 --> 00:17:04,944
С другой стороны, если я думаю о двух полиномах с точки зрения их выходных

279
00:17:04,944 --> 00:17:08,962
данных, например, о выборке их значений на нескольких входных данных, то

280
00:17:08,962 --> 00:17:12,980
для их умножения требуется столько операций, сколько количество выборок,

281
00:17:12,980 --> 00:17:17,053
поскольку опять же это точечная операция, а с полиномами вам нужно только

282
00:17:17,053 --> 00:17:21,126
конечное число выборок, чтобы иметь возможность восстановить коэффициенты.

283
00:17:21,126 --> 00:17:24,729
Например, двух выходных данных достаточно, чтобы однозначно указать линейный

284
00:17:24,729 --> 00:17:28,144
полином, трех выходных данных будет достаточно, чтобы однозначно указать

285
00:17:28,144 --> 00:17:31,841
квадратичный многочлен, и в целом, если вы знаете n различных выходных данных,

286
00:17:31,841 --> 00:17:35,490
этого достаточно, чтобы однозначно указать полином, который имеет n различных

287
00:17:35,490 --> 00:17:39,046
коэффициентов, или, если вы предпочитаете, мы могли бы сформулируйте это на

288
00:17:39,046 --> 00:17:42,415
языке систем уравнений. Представьте себе, я говорю вам, что у меня есть

289
00:17:42,415 --> 00:17:46,439
некоторый многочлен, но я не говорю вам, что это за коэффициенты, для вас это загадка.

290
00:17:46,439 --> 00:17:50,655
В нашем примере вы можете думать об этом как о продукте, который мы пытаемся вычислить,

291
00:17:50,655 --> 00:17:54,870
а затем предположим, что я говорю, что просто скажу вам, какими были бы выходные данные

292
00:17:54,870 --> 00:17:58,894
этого полинома, если бы вы ввели различные входные данные, например 0, 1, 2. , 3, и

293
00:17:58,894 --> 00:18:02,918
так далее, и я даю вам достаточно, чтобы у вас было столько же уравнений, сколько и

294
00:18:02,918 --> 00:18:06,798
неизвестных, это даже бывает линейная система уравнений, так что это хорошо, и в

295
00:18:06,798 --> 00:18:11,061
принципе, по крайней мере, этого должно быть достаточно для восстановления коэффициентов.

