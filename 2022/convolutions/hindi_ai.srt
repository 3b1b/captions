1
00:00:00,000 --> 00:00:04,480
मान लीजिए कि मैं आपको संख्याओं की दो अलग-अलग सूचियाँ देता हूँ, या शायद दो अलग-अलग फ़ंक्शन देता हूँ, और मैं आपसे उन सभी तरीकों के

2
00:00:04,480 --> 00:00:08,400
बारे में सोचने के लिए कहता हूँ जिनसे आप संख्याओं की एक नई सूची प्राप्त करने के लिए उन दो सूचियों को जोड़ सकते हैं,

3
00:00:08,400 --> 00:00:14,000
या एक नया फ़ंक्शन प्राप्त करने के लिए दो फ़ंक्शनों को जोड़ सकते हैं। . शायद एक आसान तरीका जो दिमाग में आता है वह

4
00:00:14,000 --> 00:00:18,640
यह है कि उन्हें शब्द दर शब्द एक साथ जोड़ दिया जाए। इसी प्रकार फ़ंक्शंस के साथ, आप सभी संबंधित

5
00:00:18,640 --> 00:00:24,000
आउटपुट जोड़ सकते हैं। इसी तरह, आप दोनों सूचियों को पद दर पद गुणा भी कर सकते हैं और

6
00:00:24,000 --> 00:00:28,720
फ़ंक्शंस के साथ भी यही काम कर सकते हैं। लेकिन इन दोनों की तरह एक और प्रकार का संयोजन

7
00:00:28,720 --> 00:00:33,840
भी मौलिक है, लेकिन बहुत कम चर्चा की जाती है, जिसे कनवल्शन के रूप में जाना जाता है।

8
00:00:33,840 --> 00:00:38,240
लेकिन पिछले दो मामलों के विपरीत, यह ऐसा कुछ नहीं है जो केवल एक ऑपरेशन से विरासत में मिला है जिसे

9
00:00:38,240 --> 00:00:43,360
आप संख्याओं में कर सकते हैं। संख्याओं की सूची या संयोजन कार्यों के संदर्भ में यह वास्तव में

10
00:00:43,360 --> 00:00:49,280
कुछ नया है। वे हर जगह दिखाई देते हैं, वे छवि प्रसंस्करण में सर्वव्यापी हैं, यह संभाव्यता के

11
00:00:49,280 --> 00:00:53,760
सिद्धांत में एक मुख्य निर्माण है, अंतर समीकरणों को हल करने में उनका बहुत उपयोग किया जाता है,

12
00:00:53,760 --> 00:00:58,240
और एक संदर्भ जहां आपने इसे लगभग निश्चित रूप से देखा है, यदि नहीं इस नाम से, दो बहुपदों

13
00:00:58,240 --> 00:01:03,440
को एक साथ गुणा करना है। दृश्य स्पष्टीकरण के व्यवसाय में किसी के रूप में, यह एक विशेष रूप

14
00:01:03,440 --> 00:01:08,800
से महान विषय है, क्योंकि अलगाव में और संदर्भ के बिना सूत्रबद्ध परिभाषा डराने वाली लग सकती है, लेकिन

15
00:01:08,800 --> 00:01:14,080
अगर हम वास्तव में यह क्या कह रहे हैं उसे खोलने के लिए समय लेते हैं, और उससे पहले

16
00:01:14,080 --> 00:01:18,800
वास्तव में प्रेरित करते हैं कि क्यों आप ऐसा कुछ चाहेंगे, यह एक अविश्वसनीय रूप से सुंदर ऑपरेशन है।

17
00:01:18,800 --> 00:01:22,880
और मुझे यह स्वीकार करना होगा कि इस परियोजना के लिए दृश्यों को एक साथ रखते समय मैंने वास्तव में

18
00:01:22,880 --> 00:01:26,960
कुछ सीखा। दो अलग-अलग कार्यों को संयोजित करने के मामले में, मैं अलग-अलग तरीकों के बारे में सोचने की कोशिश कर

19
00:01:26,960 --> 00:01:30,720
रहा था जिनसे आप कल्पना कर सकते हैं कि इसका क्या मतलब हो सकता है, और उनमें से एक के साथ

20
00:01:30,720 --> 00:01:35,840
मेरे मन में थोड़ा अहा पल आया कि ऐसा क्यों है कि सामान्य वितरण भूमिका निभाते हैं वे संभाव्यता में ऐसा

21
00:01:35,840 --> 00:01:40,320
करते हैं, किसी फ़ंक्शन के लिए यह इतना स्वाभाविक आकार क्यों है। लेकिन मैं खुद से आगे निकल रहा हूं, इसके

22
00:01:40,320 --> 00:01:44,800
लिए बहुत सारी व्यवस्थाएं मौजूद हैं। इस वीडियो में, हमारा प्राथमिक ध्यान केवल अलग-अलग मामले पर होगा, और विशेष

23
00:01:44,800 --> 00:01:49,920
रूप से इनकी गणना के लिए एक बहुत ही अप्रत्याशित लेकिन बहुत ही चतुर एल्गोरिदम का निर्माण करना

24
00:01:49,920 --> 00:01:54,400
होगा। और मैं सतत मामले की चर्चा को दूसरे भाग में ले जाऊंगा।

25
00:01:57,840 --> 00:02:03,120
छवि प्रसंस्करण उदाहरणों के साथ शुरुआत करना बहुत आकर्षक है, क्योंकि वे दृष्टिगत रूप से सबसे दिलचस्प हैं,

26
00:02:03,120 --> 00:02:06,880
लेकिन कुछ बारीकियां हैं जो छवि प्रसंस्करण मामले को समग्र रूप से संकल्पों का कम प्रतिनिधि बनाती हैं,

27
00:02:06,880 --> 00:02:11,760
इसलिए इसके बजाय संभावनाओं के साथ चीजों को शुरू करें, और विशेष रूप से सबसे सरल उदाहरणों में

28
00:02:11,760 --> 00:02:15,520
से एक, जिसके बारे में मुझे यकीन है कि यहां हर किसी ने अपने जीवन में कभी न

29
00:02:15,520 --> 00:02:20,320
कभी सोचा होगा, जो पासों की एक जोड़ी को घुमाना और विभिन्न अलग-अलग योगों को देखने की संभावनाओं

30
00:02:20,320 --> 00:02:25,600
का पता लगाना है। और आप कह सकते हैं, कोई समस्या नहीं, कोई समस्या नहीं। आपके दोनों पासों में से प्रत्येक

31
00:02:25,600 --> 00:02:31,600
के छह अलग-अलग संभावित परिणाम हैं, जो हमें परिणामों के कुल 36 अलग-अलग संभावित जोड़े देते हैं, और यदि हम

32
00:02:31,600 --> 00:02:35,600
उन सभी को देखते हैं तो हम गिन सकते हैं कि कितने जोड़ों में एक दिया गया योग है।

33
00:02:36,240 --> 00:02:41,120
और सभी जोड़ियों को इस तरह एक ग्रिड में व्यवस्थित करने पर, एक बहुत अच्छी बात यह है कि जिन सभी जोड़ियों का

34
00:02:41,120 --> 00:02:47,040
योग स्थिर होता है वे इन विभिन्न विकर्णों में से एक के साथ दिखाई देते हैं। तो बस यह गिनने से कि

35
00:02:47,040 --> 00:02:51,920
उनमें से प्रत्येक विकर्ण पर कितने मौजूद हैं, आपको पता चल जाएगा कि आपको एक विशेष योग देखने की कितनी संभावना है।

36
00:02:52,880 --> 00:02:57,760
और मैं कहूंगा, बहुत अच्छा, बहुत अच्छा, लेकिन क्या आप किसी अन्य तरीके के बारे में सोच सकते हैं जिससे आप उसी प्रश्न

37
00:02:57,760 --> 00:03:03,120
की कल्पना कर सकें? अन्य छवियां जो उन सभी विशिष्ट जोड़ियों के बारे में सोचने के लिए दिमाग में आ सकती हैं जिनका एक निश्चित

38
00:03:03,120 --> 00:03:08,800
योग है? और हो सकता है कि आप में से कोई अपना हाथ उठाए और कहे, हाँ, मेरे पास एक है। मान लीजिए कि आप एक पंक्ति

39
00:03:08,800 --> 00:03:14,560
में संभावनाओं के इन दो अलग-अलग सेटों की कल्पना करते हैं, लेकिन आप उस दूसरी पंक्ति के चारों ओर घूमते हैं। इस तरह

40
00:03:14,560 --> 00:03:20,160
से सभी अलग-अलग जोड़े जो सात तक जुड़ते हैं, इस तरह लंबवत पंक्ति में आते हैं। और यदि हम उस निचली

41
00:03:20,160 --> 00:03:24,880
पंक्ति को पूरी तरह से दाहिनी ओर सरकाते हैं, तो अद्वितीय जोड़ी जो दो को जोड़ती है, साँप की

42
00:03:24,880 --> 00:03:29,680
आँखें, ही संरेखित होती हैं। और यदि मैं इसे दाहिनी ओर एक इकाई पर झुकाऊं, तो जो जोड़े संरेखित होते हैं

43
00:03:29,680 --> 00:03:35,440
वे दो अलग-अलग जोड़े होते हैं जिनका योग तीन होता है। और सामान्य तौर पर, इस निचले सरणी के अलग-अलग ऑफसेट

44
00:03:35,440 --> 00:03:40,320
मान, जो याद रखें कि मुझे पहले पलटना था, उन सभी अलग-अलग जोड़ियों को प्रकट करता है जिनमें एक दिया गया

45
00:03:40,320 --> 00:03:48,800
योग होता है। जहां तक संभाव्यता प्रश्नों का सवाल है, यह अभी भी विशेष रूप से दिलचस्प नहीं

46
00:03:48,800 --> 00:03:53,120
है, क्योंकि हम केवल यह गिन रहे हैं कि इनमें से प्रत्येक श्रेणी में कितने परिणाम हैं।

47
00:03:53,120 --> 00:03:57,280
लेकिन यह इस अंतर्निहित धारणा के साथ है कि इनमें से प्रत्येक चेहरे के सामने आने की समान

48
00:03:57,280 --> 00:04:02,240
संभावना है। लेकिन क्या होगा अगर मैं आपसे कहूं कि मेरे पास पासों का एक विशेष सेट है जो एक समान नहीं है? हो सकता

49
00:04:02,240 --> 00:04:06,800
है कि नीले पासे में संख्याओं का अपना सेट हो जो प्रत्येक चेहरे के आने की संभावनाओं का वर्णन करता हो,

50
00:04:06,800 --> 00:04:11,920
और लाल पासे में संख्याओं का अपना विशिष्ट विशिष्ट सेट हो। उस स्थिति में, यदि आप दो देखने की

51
00:04:11,920 --> 00:04:17,360
संभावना का पता लगाना चाहते हैं, तो आप नीले पासे के एक होने की प्रायिकता को लाल पासे

52
00:04:17,360 --> 00:04:22,000
के एक होने की प्रायिकता से गुणा कर देंगे। और तीन देखने की संभावना के लिए, आप

53
00:04:22,000 --> 00:04:26,880
दो अलग-अलग जोड़ियों को देखें जहां यह संभव है, और फिर से, संबंधित संभावनाओं को गुणा करें,

54
00:04:26,880 --> 00:04:32,240
और फिर उन दो उत्पादों को एक साथ जोड़ें। इसी प्रकार, चार को देखने की संभावना में

55
00:04:32,240 --> 00:04:36,320
संभावनाओं के तीन अलग-अलग युग्मों को एक साथ गुणा करना और उन सभी को एक साथ जोड़ना शामिल

56
00:04:36,320 --> 00:04:41,360
है। और कुछ सूत्र स्थापित करने की भावना से, आइए इन शीर्ष संभावनाओं को a1, a2, a3, इत्यादि नाम

57
00:04:41,360 --> 00:04:48,000
दें, और नीचे वाली संभावनाओं को b1, b2, b3, इत्यादि नाम दें। और सामान्य तौर पर, यह प्रक्रिया,

58
00:04:48,000 --> 00:04:52,080
जहां हम संख्याओं के दो अलग-अलग सरणी ले रहे हैं, दूसरे को चारों ओर घुमा रहे हैं, और फिर

59
00:04:52,080 --> 00:04:56,160
उन्हें विभिन्न ऑफसेट मानों पर पंक्तिबद्ध कर रहे हैं, जोड़ीदार उत्पादों का एक समूह ले रहे हैं और उन्हें

60
00:04:56,160 --> 00:05:00,960
जोड़ रहे हैं, यह इनमें से एक है कनवल्शन क्या है इसके बारे में सोचने के बुनियादी तरीके।

61
00:05:00,960 --> 00:05:08,960
तो बस इसे थोड़ा और सटीक रूप से बताने के लिए, इस प्रक्रिया के माध्यम से, हमने दो, तीन, चार,

62
00:05:08,960 --> 00:05:13,840
आगे और फिर 12 तक देखने की संभावनाएं उत्पन्न कीं, और हमने मूल्यों की एक सूची, ए, और एक अन्य को

63
00:05:13,840 --> 00:05:20,080
एक साथ मिलाकर उन्हें प्राप्त किया। मूल्यों की सूची, बी. भाषा में, हम कहेंगे कि उन दो अनुक्रमों का

64
00:05:20,080 --> 00:05:25,600
कनवल्शन हमें यह नया अनुक्रम देता है, 11 मानों का नया अनुक्रम, जिनमें से प्रत्येक जोड़ीदार उत्पादों के

65
00:05:25,600 --> 00:05:30,160
कुछ योग जैसा दिखता है। यदि आप चाहें, तो उसी ऑपरेशन के बारे में दूसरा तरीका यह

66
00:05:30,160 --> 00:05:36,240
सोच सकते हैं कि पहले सभी जोड़ीवार उत्पादों की एक तालिका बनाएं, और फिर इन सभी विकर्णों को

67
00:05:36,240 --> 00:05:41,120
जोड़ें। फिर, यह संख्याओं के इन दो अनुक्रमों को एक साथ मिलाने का एक तरीका है जिससे हमें 11 संख्याओं का एक नया

68
00:05:41,120 --> 00:05:46,400
अनुक्रम प्राप्त होता है। यह वही ऑपरेशन है जैसा कि स्लाइडिंग विंडोज़ ने सोचा था, बस एक और परिप्रेक्ष्य।

69
00:05:46,960 --> 00:05:51,280
इसमें थोड़ा सा नोटेशन डालते हुए, यहां बताया गया है कि आप इसे कैसे लिखा हुआ देख सकते हैं। ए और बी का कनवल्शन,

70
00:05:51,280 --> 00:05:57,200
इस छोटे तारांकन के साथ दर्शाया गया है, एक नई सूची है, और उस सूची का एनवां तत्व एक योग की तरह दिखता

71
00:05:57,200 --> 00:06:03,440
है, और वह योग सूचकांकों के सभी अलग-अलग जोड़े, आई और जे पर जाता है, ताकि योग का योग हो वे सूचकांक

72
00:06:03,440 --> 00:06:09,440
n के बराबर हैं। यह एक प्रकार का कौर है, लेकिन उदाहरण के लिए, यदि n 6 था, तो हम जिन जोड़ियों पर जा रहे हैं

73
00:06:09,440 --> 00:06:15,680
वे 1 और 5, 2 और 4, 3 और 3, 4 और 2, 5 और 1 हैं, सभी अलग-अलग जोड़े हैं जो जुड़ते हैं से 6.

74
00:06:16,400 --> 00:06:20,640
लेकिन ईमानदारी से कहूं तो, आप इसे किसी भी तरह से लिखें, प्रक्रिया के दौरान आपके दिमाग में जो दृश्य रहता

75
00:06:20,640 --> 00:06:26,320
है, उसके मुकाबले नोटेशन का महत्व गौण होता है। यहां, शायद यह एक अत्यंत सरल उदाहरण देने में मदद करेगा, जहां मैं आपसे

76
00:06:26,320 --> 00:06:32,000
पूछ सकता हूं कि सूची 4, 5, 6 के साथ सूची 1, 2, 3 का कनवल्शन क्या है। आप इन दोनों सूचियों

77
00:06:32,000 --> 00:06:36,160
को लेते हुए, दूसरी सूची के चारों ओर पलटते हुए, और फिर इसके ढक्कन से शुरू करके बाईं ओर

78
00:06:36,160 --> 00:06:41,200
तक की कल्पना कर सकते हैं। फिर मानों की जोड़ी जो संरेखित होती है वह 1 और 4 है, उन्हें एक

79
00:06:41,200 --> 00:06:45,680
साथ गुणा करें, और इससे हमें हमारे आउटपुट का पहला पद मिलता है। उस निचली सरणी को एक इकाई दाईं ओर स्लाइड करें, जो

80
00:06:45,680 --> 00:06:51,840
जोड़े संरेखित हैं वे 1 और 5, और 2 और 4 हैं, उन जोड़ियों को गुणा करें, उन्हें एक साथ जोड़ें, और इससे हमें

81
00:06:51,840 --> 00:06:57,600
13 मिलता है, जो हमारे आउटपुट में अगली प्रविष्टि है। चीज़ों को एक बार फिर सरकाएँ, और हम 1 गुना 6, प्लस

82
00:06:57,600 --> 00:07:04,400
2 गुना 5, प्लस 3 गुना 4, जो होता है 28 लेंगे। एक और स्लाइड, और हमें 2 गुना 6, प्लस

83
00:07:04,400 --> 00:07:10,000
3 गुना 5 मिलता है, और इससे हमें 27 मिलता है, और अंत में अंतिम पद 3 गुना 6 जैसा दिखेगा।

84
00:07:10,560 --> 00:07:14,080
यदि आप चाहें, तो आप जो भी आपकी पसंदीदा प्रोग्रामिंग भाषा है, और आपकी पसंदीदा लाइब्रेरी जिसमें विभिन्न संख्यात्मक ऑपरेशन

85
00:07:14,080 --> 00:07:18,640
शामिल हैं, को खींच सकते हैं, और आप पुष्टि कर सकते हैं कि मैं आपसे झूठ नहीं बोल रहा हूं।

86
00:07:18,640 --> 00:07:24,320
यदि आप 4, 5, 6 के विरुद्ध 1, 2, 3 का कनवल्शन लेते हैं, तो आपको वास्तव में यही परिणाम मिलेगा।

87
00:07:24,880 --> 00:07:29,200
हमने एक मामला देखा है जहां यह एक प्राकृतिक और वांछनीय ऑपरेशन है, जो संभाव्यता वितरण को

88
00:07:29,200 --> 00:07:34,640
जोड़ता है, और एक अन्य सामान्य उदाहरण एक चलती औसत होगी। कल्पना कीजिए कि आपके पास संख्याओं की कुछ

89
00:07:34,640 --> 00:07:39,920
लंबी सूची है, और आप संख्याओं की एक और छोटी सूची लेते हैं जिनका योग 1 होता है। इस मामले में, मेरे पास केवल

90
00:07:39,920 --> 00:07:45,280
5 मानों की एक छोटी सी सूची है, और वे सभी 1/5वें के बराबर हैं। फिर यदि हम यह स्लाइडिंग विंडो कनवल्शन प्रक्रिया

91
00:07:45,280 --> 00:07:49,760
करते हैं, और अपनी आंखें बंद कर लेते हैं और गलीचे के नीचे देखते हैं कि इसकी शुरुआत में क्या होता

92
00:07:50,560 --> 00:07:55,120
है, एक बार जब मूल्यों की हमारी छोटी सूची पूरी तरह से बड़े के साथ ओवरलैप हो जाती है, तो सोचें

93
00:07:55,680 --> 00:08:01,120
कि इसमें प्रत्येक शब्द क्या है कनवल्शन का वास्तव में मतलब है। प्रत्येक पुनरावृत्ति पर, आप जो कर रहे हैं वह

94
00:08:01,120 --> 00:08:06,400
आपके डेटा के प्रत्येक मान को 1/5वें से गुणा करना है, और उन सभी को एक साथ जोड़ना है, जिसका

95
00:08:06,400 --> 00:08:12,080
अर्थ है कि आप इस छोटी विंडो के अंदर अपने डेटा का औसत ले रहे हैं। कुल मिलाकर, यह प्रक्रिया आपको

96
00:08:12,080 --> 00:08:16,800
मूल डेटा का एक सुव्यवस्थित संस्करण प्रदान करती है, और आप इसे संख्याओं की एक अलग छोटी सूची से शुरू करके संशोधित

97
00:08:16,800 --> 00:08:21,280
कर सकते हैं, और जब तक वह छोटी सूची 1 तक जुड़ जाती है, तब भी आप इसे एक गतिशील के

98
00:08:21,280 --> 00:08:25,840
रूप में व्याख्या कर सकते हैं औसत। यहां दिखाए गए उदाहरण में, वह चलती औसत केंद्रीय मूल्य

99
00:08:25,840 --> 00:08:30,720
की ओर अधिक भार देगी। इसके परिणामस्वरूप डेटा का एक सुचारु संस्करण भी प्राप्त होता है।

100
00:08:33,200 --> 00:08:37,840
यदि आप इसका द्वि-आयामी एनालॉग बनाते हैं, तो यह आपको किसी दी गई छवि को धुंधला करने के लिए एक मज़ेदार

101
00:08:37,840 --> 00:08:43,120
एल्गोरिदम देता है। और मुझे कहना चाहिए कि जो एनिमेशन मैं दिखाने जा रहा हूं, वे मूल रूप से मेरे द्वारा एमआईटी

102
00:08:43,120 --> 00:08:48,160
में जूलिया लैब के साथ एक निश्चित ओपनकोर्सवेयर क्लास के लिए किए गए व्याख्यानों के एक सेट के हिस्से के लिए

103
00:08:48,160 --> 00:08:52,320
बनाए गए कुछ से संशोधित हैं, जिसमें एक छवि प्रसंस्करण इकाई शामिल थी। वहां हमने इस सब के पीछे के कोड

104
00:08:52,320 --> 00:08:56,640
को समझने के लिए थोड़ा और काम किया, इसलिए यदि आप उत्सुक हैं तो मैं आपके लिए कुछ लिंक छोड़ दूंगा। लेकिन

105
00:08:56,640 --> 00:09:01,440
इस धुंधले उदाहरण पर ध्यान केंद्रित करते हुए, जो हो रहा है वह यह है कि मुझे मूल्यों का यह छोटा 3x3 ग्रिड

106
00:09:01,440 --> 00:09:06,480
मिला है जो हमारी मूल छवि के साथ चल रहा है, और यदि हम ज़ूम इन करते हैं, तो उनमें से प्रत्येक

107
00:09:06,480 --> 00:09:11,120
मान 1 9वां है, और मैं क्या कर रहा हूं प्रत्येक पुनरावृत्ति पर उनमें से प्रत्येक मान को उस संबंधित पिक्सेल से

108
00:09:11,120 --> 00:09:16,080
गुणा किया जाता है जिसके ऊपर वह बैठता है। और निश्चित रूप से कंप्यूटर विज्ञान में हम रंगों को तीन

109
00:09:16,080 --> 00:09:20,400
मानों के छोटे वैक्टर के रूप में सोचते हैं, जो लाल, हरे और नीले घटकों का प्रतिनिधित्व करते हैं।

110
00:09:20,400 --> 00:09:25,440
जब मैं इन सभी छोटे मानों को 1 9वें से गुणा करता हूं और उन्हें एक साथ जोड़ता हूं, तो यह हमें प्रत्येक रंग

111
00:09:25,440 --> 00:09:30,480
चैनल के साथ एक औसत देता है, और दाईं ओर की छवि के लिए संबंधित पिक्सेल को उस योग के रूप में परिभाषित किया

112
00:09:30,480 --> 00:09:36,320
जाता है। समग्र प्रभाव, जैसा कि हम छवि पर हर एक पिक्सेल के लिए करते हैं, यह है कि प्रत्येक एक

113
00:09:36,320 --> 00:09:40,880
प्रकार का उसके सभी पड़ोसियों में खून बहता है, जो हमें मूल की तुलना में धुंधला संस्करण देता है।

114
00:09:41,680 --> 00:09:46,640
भाषा में हम कहेंगे कि दाईं ओर की छवि मूल्यों की एक छोटी ग्रिड के साथ हमारी मूल छवि

115
00:09:46,640 --> 00:09:52,000
का एक संयोजन है। या अधिक तकनीकी रूप से शायद मुझे यह कहना चाहिए कि यह मूल्यों के उस छोटे

116
00:09:52,000 --> 00:09:56,160
ग्रिड के 180 डिग्री घुमाए गए संस्करण के साथ कनवल्शन है। ऐसा नहीं है कि ग्रिड सममित होने पर यह मायने

117
00:09:56,160 --> 00:10:00,720
रखता है, लेकिन यह ध्यान में रखने योग्य है कि एक कनवल्शन की परिभाषा, जैसा कि शुद्ध गणित संदर्भ से विरासत में

118
00:10:00,720 --> 00:10:05,760
मिली है, आपको हमेशा उस दूसरे सरणी के चारों ओर फ़्लिप करने के बारे में सोचने के लिए आमंत्रित करना चाहिए।

119
00:10:05,760 --> 00:10:10,240
यदि हम इसे थोड़ा संशोधित करते हैं तो हम मूल्यों का एक अलग ग्रिड चुनकर अधिक सुंदर धुंधला प्रभाव प्राप्त कर

120
00:10:10,240 --> 00:10:15,920
सकते हैं। इस मामले में मेरे पास एक छोटा सा 5x5 ग्रिड है, लेकिन अंतर इसके आकार का नहीं है।

121
00:10:15,920 --> 00:10:19,920
यदि हम ज़ूम इन करते हैं तो हम देखते हैं कि बीच का मान किनारों के मान से बहुत बड़ा है, और यह

122
00:10:19,920 --> 00:10:25,360
कहां से आ रहा है, वे सभी एक घंटी वक्र से नमूने लिए गए हैं, जिसे गाऊसी वितरण के रूप में जाना

123
00:10:25,360 --> 00:10:30,240
जाता है। इस तरह जब हम इन सभी मानों को संबंधित पिक्सेल से गुणा करते हैं जिसके ऊपर वे बैठे

124
00:10:30,240 --> 00:10:35,200
हैं, तो हम उस केंद्रीय पिक्सेल को बहुत अधिक महत्व दे रहे हैं और किनारे पर मौजूद मानों को बहुत

125
00:10:35,200 --> 00:10:39,920
कम दे रहे हैं। और पहले की तरह ही दाईं ओर संबंधित पिक्सेल को इस योग के रूप में परिभाषित किया गया

126
00:10:39,920 --> 00:10:45,360
है। जैसा कि हम इस प्रक्रिया को हर एक पिक्सेल के लिए करते हैं, यह एक धुंधला प्रभाव देता है जो

127
00:10:45,360 --> 00:10:49,760
आपके लेंस को फोकस से बाहर या ऐसा कुछ करने की धारणा को अधिक प्रामाणिक रूप से अनुकरण करता है।

128
00:10:49,760 --> 00:10:54,960
लेकिन धुंधलापन एकमात्र ऐसी चीज़ नहीं है जो आप इस विचार के साथ कर सकते हैं। उदाहरण के लिए, मानों के इस

129
00:10:54,960 --> 00:10:59,600
छोटे ग्रिड पर एक नज़र डालें, जिसमें बाईं ओर कुछ सकारात्मक संख्याएँ और दाईं ओर कुछ नकारात्मक

130
00:10:59,600 --> 00:11:04,480
संख्याएँ शामिल हैं, जिन्हें मैं क्रमशः नीले और लाल रंग से रंगूँगा। यह देखने के लिए कुछ समय लें कि

131
00:11:04,480 --> 00:11:11,680
क्या आप अनुमान लगा सकते हैं और समझ सकते हैं कि इसका अंतिम छवि पर क्या प्रभाव पड़ेगा। तो इस मामले में मैं

132
00:11:11,680 --> 00:11:16,560
छवि को रंगीन के बजाय ग्रेस्केल के रूप में सोचूंगा, इसलिए प्रत्येक पिक्सेल को तीन के बजाय केवल

133
00:11:16,560 --> 00:11:21,280
एक संख्या द्वारा दर्शाया जाएगा। और ध्यान देने योग्य एक बात यह है कि जैसे ही हम यह कनवल्शन करते

134
00:11:21,280 --> 00:11:26,240
हैं तो नकारात्मक मान प्राप्त करना संभव है। उदाहरण के लिए, यहां इस बिंदु पर यदि हम ज़ूम इन करते हैं तो

135
00:11:26,240 --> 00:11:30,960
हमारे छोटे ग्रिड का बायां आधा हिस्सा पूरी तरह से काले पिक्सेल के शीर्ष पर बैठता है, जिसका मान शून्य होगा,

136
00:11:30,960 --> 00:11:35,360
लेकिन नकारात्मक मानों का दायां आधा भाग सफेद पिक्सेल के शीर्ष पर बैठता है, जो कि होगा एक का मूल्य है.

137
00:11:36,000 --> 00:11:40,960
इसलिए जब हम संगत शब्दों को गुणा करते हैं और उन्हें एक साथ जोड़ते हैं तो परिणाम बहुत नकारात्मक होंगे, और जिस तरह

138
00:11:40,960 --> 00:11:45,120
से मैं इसे दाईं ओर की छवि के साथ प्रदर्शित कर रहा हूं वह नकारात्मक मानों को लाल और सकारात्मक मानों को

139
00:11:45,120 --> 00:11:49,520
नीला रंग देना है। ध्यान देने वाली एक और बात यह है कि जब आप एक पैच पर होते हैं जो सभी समान रंग

140
00:11:49,520 --> 00:11:55,680
का होता है तो सब कुछ शून्य हो जाता है क्योंकि हमारे छोटे ग्रिड में मानों का योग शून्य होता है। यह पिछले दो

141
00:11:55,680 --> 00:11:59,680
उदाहरणों से बहुत अलग है जहां हमारे छोटे ग्रिड का योग एक था, जो हमें इसे चलती औसत के रूप

142
00:11:59,680 --> 00:12:05,760
में व्याख्या करने देता है और इसलिए धुंधला हो जाता है। कुल मिलाकर यह छोटी सी प्रक्रिया मूल रूप से

143
00:12:05,760 --> 00:12:10,240
पता लगाती है कि जब आप बाएं से दाएं जाते हैं तो पिक्सेल मान में कहां भिन्नता होती

144
00:12:10,240 --> 00:12:13,760
है, और इसलिए यह आपको अपनी छवि से सभी ऊर्ध्वाधर किनारों को लेने का एक तरीका देता है।

145
00:12:16,560 --> 00:12:20,960
और इसी तरह अगर हम उस ग्रिड को चारों ओर घुमाते हैं ताकि जब आप ऊपर से नीचे की

146
00:12:20,960 --> 00:12:26,000
ओर बढ़ें तो यह अलग-अलग हो, यह सभी क्षैतिज किनारों को पकड़ लेगा, जो कि हमारी छोटी पाई

147
00:12:26,000 --> 00:12:31,520
प्राणी छवि के मामले में कुछ सुंदर राक्षसी आँखों में परिणत होता है। वैसे, इस छोटे ग्रिड को अक्सर कर्नेल

148
00:12:31,520 --> 00:12:36,160
कहा जाता है, और यहां की सुंदरता यह है कि कैसे एक अलग कर्नेल चुनकर आप अलग-अलग छवि प्रसंस्करण प्रभाव प्राप्त

149
00:12:36,160 --> 00:12:40,240
कर सकते हैं, न केवल आपके किनारे का पता लगाने को धुंधला कर सकते हैं बल्कि तेज करने जैसी चीजें भी कर

150
00:12:40,240 --> 00:12:44,800
सकते हैं। आपमें से जिन लोगों ने कनवल्शनल न्यूरल नेटवर्क के बारे में सुना है, उनके लिए विचार यह है कि डेटा

151
00:12:44,800 --> 00:12:49,600
का उपयोग करके यह पता लगाया जाए कि सबसे पहले कर्नेल क्या होना चाहिए, जैसा कि न्यूरल नेटवर्क जो भी पता

152
00:12:49,600 --> 00:12:55,120
लगाना चाहता है, उससे निर्धारित होता है। एक और चीज़ जो शायद मुझे सामने लानी चाहिए वह है आउटपुट की

153
00:12:55,120 --> 00:12:59,040
लंबाई। चलती औसत उदाहरण जैसी किसी चीज़ के लिए आप केवल उन शर्तों के बारे में सोचना चाहेंगे

154
00:12:59,040 --> 00:13:04,080
जब दोनों विंडो पूरी तरह से एक-दूसरे के साथ संरेखित हों, या छवि प्रसंस्करण उदाहरण में शायद

155
00:13:04,080 --> 00:13:09,200
आप चाहते हैं कि अंतिम आउटपुट का आकार मूल के समान हो। अब एक शुद्ध गणित ऑपरेशन के रूप

156
00:13:09,200 --> 00:13:13,920
में कनवल्शन हमेशा एक सरणी उत्पन्न करता है जो आपके द्वारा शुरू की गई दो सरणी से बड़ी होती है, कम से

157
00:13:13,920 --> 00:13:17,520
कम यह मानते हुए कि उनमें से एक की लंबाई एक के बराबर नहीं है। बस यह जान लें कि

158
00:13:17,520 --> 00:13:21,440
कुछ कंप्यूटर विज्ञान संदर्भों में आप अक्सर जानबूझकर उस आउटपुट को छोटा करना चाहते हैं।

159
00:13:21,520 --> 00:13:29,200
हाइलाइट करने लायक एक और बात यह है कि कंप्यूटर विज्ञान के संदर्भ में मूल के पार जाने से

160
00:13:29,200 --> 00:13:34,080
पहले उस कर्नेल के चारों ओर फ़्लिप करने की यह धारणा अक्सर वास्तव में अजीब और अनावश्यक लगती है,

161
00:13:34,080 --> 00:13:38,960
लेकिन फिर से ध्यान दें कि यह शुद्ध गणित संदर्भ से विरासत में मिला है जहां हम जैसे हैं

162
00:13:38,960 --> 00:13:44,000
संभावनाओं के साथ देखा जाए तो यह अविश्वसनीय रूप से स्वाभाविक बात है। और वास्तव में मैं आपको एक

163
00:13:44,000 --> 00:13:48,480
और शुद्ध गणित का उदाहरण दिखा सकता हूं जहां प्रोग्रामर को भी इसकी परवाह करनी चाहिए क्योंकि यह इन

164
00:13:48,480 --> 00:13:53,760
सभी की गणना करने के लिए बहुत तेज़ एल्गोरिदम के द्वार खोलता है। यहां तेजी से मेरा जो मतलब है

165
00:13:53,760 --> 00:13:58,560
उसे स्थापित करने के लिए मुझे वापस जाने दें और कुछ अजगर को फिर से खींचने दें और मैं दो अलग-अलग अपेक्षाकृत बड़े

166
00:13:58,560 --> 00:14:02,880
ऐरे बनाने जा रहा हूं। प्रत्येक में एक लाख यादृच्छिक तत्व होंगे और मैं numpy लाइब्रेरी

167
00:14:02,880 --> 00:14:08,640
से कन्वोल्व फ़ंक्शन के रनटाइम का आकलन करने जा रहा हूं। और इस मामले में

168
00:14:08,640 --> 00:14:12,800
यह इसे कई अलग-अलग पुनरावृत्तियों के लिए चलाता है, एक औसत खोजने की कोशिश करता है, और ऐसा लगता है कि

169
00:14:12,880 --> 00:14:18,640
इस कंप्यूटर पर कम से कम इसका औसत 4 है। 87 सेकंड. इसके विपरीत यदि मैं scipy लाइब्रेरी से एक अलग फ़ंक्शन

170
00:14:18,640 --> 00:14:24,080
का उपयोग करता हूं जिसे fftconvolve कहा जाता है जो कि एक ही चीज़ है जिसे बस अलग तरीके से लागू किया जाता

171
00:14:24,080 --> 00:14:30,640
है जिसमें केवल 4 लगते हैं। औसतन 3 मिलीसेकंड, इसलिए परिमाण में सुधार के तीन क्रम।

172
00:14:30,640 --> 00:14:34,800
और फिर भले ही यह एक अलग नाम के तहत उड़ान भरता है, यह वही आउटपुट दे रहा है

173
00:14:34,800 --> 00:14:38,880
जो अन्य कन्वोल्व फ़ंक्शन देता है, यह बस इसे चतुर तरीके से करने के लिए कुछ कर रहा है।

174
00:14:38,880 --> 00:14:46,800
याद रखें कि संभाव्यता उदाहरण के साथ मैंने कहा था कि कनवल्शन के बारे में सोचने का एक और

175
00:14:46,800 --> 00:14:51,520
तरीका यह था कि सभी जोड़ीदार उत्पादों की यह तालिका बनाएं और फिर विकर्णों के साथ उन जोड़ीदार

176
00:14:51,520 --> 00:14:56,560
उत्पादों को जोड़ें। निश्चित रूप से संभाव्यता के लिए कुछ भी विशिष्ट नहीं है, जब भी आप संख्याओं की दो अलग-अलग सूचियाँ

177
00:14:56,560 --> 00:15:00,880
बना रहे हों तो आप इसके बारे में इस तरह से सोच सकते हैं। सभी जोड़ीवार उत्पादों के साथ इस प्रकार

178
00:15:00,880 --> 00:15:05,520
की गुणन तालिका बनाएं और फिर विकर्ण के साथ प्रत्येक योग आपके अंतिम आउटपुट में से एक से मेल

179
00:15:05,520 --> 00:15:11,680
खाता है। एक संदर्भ जहां यह दृश्य विशेष रूप से स्वाभाविक है जब आप दो बहुपदों को एक साथ

180
00:15:11,680 --> 00:15:16,240
गुणा करते हैं। उदाहरण के लिए, मैं हमारे पास पहले से मौजूद छोटे ग्रिड को लेता हूं और शीर्ष पदों को 1,

181
00:15:16,240 --> 00:15:23,920
2x और 3x वर्ग से बदल देता हूं और अन्य पदों को 4, 5x और 6x वर्ग से बदल देता हूं।

182
00:15:23,920 --> 00:15:27,920
अब सोचें कि जब हम दो सूचियों के बीच इन सभी अलग-अलग जोड़ीवार उत्पादों को बना रहे हैं तो इसका क्या

183
00:15:27,920 --> 00:15:32,960
मतलब है। आप जो कर रहे हैं वह अनिवार्य रूप से मेरे द्वारा लिखे गए दो बहुपदों के पूर्ण उत्पाद

184
00:15:32,960 --> 00:15:38,240
का विस्तार करना है और फिर जब आप विकर्ण के साथ जोड़ते हैं जो सभी समान पदों को एकत्रित करने

185
00:15:38,240 --> 00:15:43,920
के अनुरूप होता है जो कि एक बहुपद का विस्तार करने और समान पदों को एकत्रित करने के लिए बहुत

186
00:15:43,920 --> 00:15:50,640
साफ-सुथरा होता है। कनवल्शन के समान ही प्रक्रिया। लेकिन यह हमें कुछ ऐसा करने की इजाजत देता है जो बहुत अच्छा

187
00:15:50,640 --> 00:15:55,360
है क्योंकि सोचें कि हम यहां क्या कह रहे हैं। हम कह रहे हैं कि यदि आप दो अलग-अलग फ़ंक्शन लेते हैं

188
00:15:55,360 --> 00:16:00,560
और आप उन्हें एक साथ गुणा करते हैं जो कि एक सरल बिंदुवार ऑपरेशन है, तो यह वही बात

189
00:16:00,560 --> 00:16:05,920
है जैसे कि आपने पहले उनमें से प्रत्येक से गुणांक निकाला था, यह मानते हुए कि वे बहुपद हैं और

190
00:16:05,920 --> 00:16:11,840
फिर उनका कनवल्शन लिया है गुणांकों की दो सूचियाँ। जो चीज़ इसे इतना दिलचस्प बनाती है वह यह है कि

191
00:16:11,840 --> 00:16:16,560
सिद्धांत रूप में कनवल्शन सरल गुणन की तुलना में बहुत अधिक जटिल लगता है और मेरा मतलब यह नहीं है

192
00:16:16,560 --> 00:16:21,760
कि वैचारिक रूप से उनके बारे में सोचना कठिन है, मेरा मतलब है कि कम्प्यूटेशनल रूप से कनवल्शन को

193
00:16:21,760 --> 00:16:27,040
निष्पादित करने के लिए अधिक चरणों की आवश्यकता होती है। दो अलग-अलग सूचियों का बिंदुवार उत्पाद। उदाहरण के लिए, मान

194
00:16:27,040 --> 00:16:31,920
लें कि मैंने आपको दो बहुत बड़े बहुपद दिए हैं, मान लीजिए कि प्रत्येक एक सौ अलग-अलग गुणांकों के साथ है, तो

195
00:16:32,480 --> 00:16:37,520
यदि आप जिस तरह से उन्हें गुणा करते हैं, वह इस उत्पाद का विस्तार करना है, तो आप जानते हैं कि इस

196
00:16:37,520 --> 00:16:43,600
संपूर्ण 100 गुणा 100 ग्रिड को जोड़ीवार उत्पादों में भरना है, जिसके लिए आपको इसकी आवश्यकता होगी। 10,000 अलग-अलग उत्पाद निष्पादित

197
00:16:43,600 --> 00:16:48,560
करें और फिर जब आप विकर्णों के साथ सभी समान शब्द एकत्र कर रहे हों तो यह लगभग 10,000 परिचालनों का एक

198
00:16:48,560 --> 00:16:55,200
और सेट है। अधिक आम तौर पर भाषा में हम कहेंगे कि एल्गोरिथ्म n वर्ग का O है, जिसका अर्थ n

199
00:16:55,200 --> 00:17:00,560
आकार की दो सूचियों के लिए है, जिस तरह से ऑपरेशन स्केल की संख्या n के वर्ग के अनुपात में है।

200
00:17:00,560 --> 00:17:06,320
दूसरी ओर, यदि मैं दो बहुपदों के बारे में उनके आउटपुट के संदर्भ में सोचता हूं, उदाहरण के लिए कुछ

201
00:17:06,320 --> 00:17:11,680
मुट्ठी भर इनपुट पर उनके मानों का नमूना लेना, तो उन्हें गुणा करने के लिए केवल उतने ही ऑपरेशन की आवश्यकता

202
00:17:11,680 --> 00:17:17,200
होती है जितनी नमूनों की संख्या, क्योंकि फिर से यह एक बिंदुवार ऑपरेशन है और बहुपद के साथ आपको केवल इसकी

203
00:17:17,200 --> 00:17:22,400
आवश्यकता होती है गुणांकों को पुनर्प्राप्त करने में सक्षम होने के लिए बहुत सारे नमूने। उदाहरण के लिए, दो आउटपुट एक

204
00:17:22,400 --> 00:17:27,920
रैखिक बहुपद को विशिष्ट रूप से निर्दिष्ट करने के लिए पर्याप्त हैं, तीन आउटपुट एक द्विघात बहुपद को विशिष्ट रूप से निर्दिष्ट

205
00:17:27,920 --> 00:17:33,680
करने के लिए पर्याप्त होंगे और सामान्य तौर पर यदि आप n अलग-अलग आउटपुट जानते हैं, तो यह एक बहुपद को विशिष्ट

206
00:17:33,680 --> 00:17:38,800
रूप से निर्दिष्ट करने के लिए पर्याप्त है जिसमें n अलग-अलग गुणांक हैं या यदि आप चाहें तो हम कर सकते हैं।

207
00:17:38,800 --> 00:17:43,680
समीकरणों की प्रणालियों की भाषा में यह वाक्यांश कल्पना कीजिए, मैं आपको बताता हूं कि मेरे पास कुछ बहुपद हैं, लेकिन मैं

208
00:17:43,680 --> 00:17:47,840
आपको यह नहीं बताता कि गुणांक क्या हैं, वे आपके लिए एक रहस्य हैं। हमारे उदाहरण में आप इसे उस उत्पाद के

209
00:17:47,840 --> 00:17:52,960
रूप में सोच सकते हैं जिसे हम जानने का प्रयास कर रहे हैं और फिर मान लीजिए कि मैं कहता हूं कि मैं आपको

210
00:17:52,960 --> 00:17:59,600
केवल यह बताऊंगा कि यदि आपने 0, 1, 2 जैसे विभिन्न इनपुट इनपुट किए हैं तो इस बहुपद के आउटपुट क्या होंगे। ,

211
00:17:59,600 --> 00:18:04,800
3, लगातार और आगे और मैं आपको पर्याप्त देता हूं ताकि आपके पास उतने ही समीकरण हों जितने आपके पास अज्ञात हैं, यह

212
00:18:04,800 --> 00:18:09,840
समीकरणों की एक रैखिक प्रणाली भी होती है, इसलिए यह अच्छा है और सिद्धांत रूप में कम से कम यह गुणांक को पुनर्प्राप्त करने

213
00:18:09,840 --> 00:18:14,880
के लिए पर्याप्त होना चाहिए।

214
00:18:14,880 --> 00:18:20,160


215
00:18:20,160 --> 00:18:26,560


216
00:18:26,560 --> 00:18:32,720


217
00:18:32,720 --> 00:18:38,000


218
00:18:38,000 --> 00:18:43,120


219
00:18:43,120 --> 00:18:47,760


220
00:18:47,760 --> 00:18:53,520


221
00:18:53,520 --> 00:18:58,400


222
00:18:58,400 --> 00:19:04,240


223
00:19:04,240 --> 00:19:09,200


224
00:19:09,200 --> 00:19:13,600


225
00:19:13,600 --> 00:19:18,720


226
00:19:18,720 --> 00:19:23,840


227
00:19:23,840 --> 00:19:30,080


228
00:19:30,080 --> 00:19:34,400


229
00:19:34,400 --> 00:19:41,600


230
00:19:41,600 --> 00:19:46,480


231
00:19:46,480 --> 00:19:51,360


232
00:19:51,360 --> 00:19:57,600


233
00:19:57,600 --> 00:20:03,200


234
00:20:03,200 --> 00:20:08,160


235
00:20:08,160 --> 00:20:12,640


236
00:20:12,640 --> 00:20:17,520


237
00:20:17,520 --> 00:20:22,720


238
00:20:22,720 --> 00:20:28,320


239
00:20:28,320 --> 00:20:33,040


240
00:20:33,040 --> 00:20:38,080


241
00:20:38,080 --> 00:20:43,600


242
00:20:43,600 --> 00:20:48,640


243
00:20:48,640 --> 00:20:53,200


244
00:20:53,200 --> 00:20:58,960


245
00:20:58,960 --> 00:21:03,280


246
00:21:03,280 --> 00:21:08,960


247
00:21:08,960 --> 00:21:14,480


248
00:21:14,480 --> 00:21:18,480


249
00:21:18,480 --> 00:21:25,600


250
00:21:25,600 --> 00:21:30,560


251
00:21:30,560 --> 00:21:35,120


252
00:21:35,120 --> 00:21:39,600


253
00:21:39,600 --> 00:21:44,480


254
00:21:44,480 --> 00:21:50,160


255
00:21:50,160 --> 00:21:54,800


256
00:21:54,800 --> 00:21:59,360


257
00:21:59,360 --> 00:22:04,640


258
00:22:04,640 --> 00:22:10,720


259
00:22:10,720 --> 00:22:16,000


260
00:22:16,000 --> 00:22:20,720


261
00:22:20,720 --> 00:22:26,320


262
00:22:26,320 --> 00:22:31,280


263
00:22:31,280 --> 00:22:36,880


264
00:22:36,880 --> 00:22:51,040


