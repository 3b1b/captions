1
00:00:00,000 --> 00:00:03,773
假设我给你两个不同的数字列表，或者可能是两个不同的函

2
00:00:03,773 --> 00:00:07,546
数，并且 我要求你思考可以组合这两个列表以获得新的数

3
00:00:07,546 --> 00:00:11,320
字列表，或者组合 这两个函数以获得新函数的所有方法。

4
00:00:12,120 --> 00:00:16,760
也许想到的一种简单方法就是 简单地将它们逐个添加在一起。

5
00:00:17,160 --> 00:00:19,920
与功能类似，您可以添加所有 相应的输出。

6
00:00:20,540 --> 00:00:25,680
同样，您也可以将两个列表逐项相乘，并 对函数执行相同的操作。

7
00:00:26,360 --> 00:00:29,930
但还有另一种组合与这两 种组合一

8
00:00:29,930 --> 00:00:33,500
样基本，但很少被讨论，称为卷积。

9
00:00:34,080 --> 00:00:38,523
但与前两种情况不同的是，它不仅仅是从对数字执行 

10
00:00:38,523 --> 00:00:39,820
的操作继承的。

11
00:00:39,980 --> 00:00:44,700
对于数字列表或组合函数的上下文来说，这是真 正的新事物。

12
00:00:45,320 --> 00:00:49,092
它们无处不在，它们在图像处理中无处不在，它 

13
00:00:49,092 --> 00:00:53,894
是概率论的核心构造，它们在求解微分方程中被大量使用，并 

14
00:00:53,894 --> 00:00:58,525
且您几乎肯定在其中见过它（如果没有的话）顾名思义，就 

15
00:00:58,525 --> 00:01:00,240
是将两个多项式相乘。

16
00:01:00,740 --> 00:01:03,995
作为从事视觉解释行业的人，这是一个特别 

17
00:01:03,995 --> 00:01:08,878
好的主题，因为孤立且没有上下文的公式化定义可能看起来有点令 

18
00:01:08,878 --> 00:01:13,762
人生畏，但如果我们花时间真正解开它所说的内容，并在此之前真 

19
00:01:13,762 --> 00:01:18,320
正激发为什么你会想要这样的东西，这是一个非常漂亮的操作。

20
00:01:18,960 --> 00:01:23,123
我必须承认，在为这个项目制作视觉效果时，我实际上学到了一些 

21
00:01:23,123 --> 00:01:23,540
东西。

22
00:01:23,540 --> 00:01:27,405
在卷积两个不同函数的情况下，我试图想出不同的方 

23
00:01:27,405 --> 00:01:31,754
式来描述这可能意味着什么，对于其中一个，我有点恍然大 

24
00:01:31,754 --> 00:01:36,103
悟，为什么正态分布起着这样的作用：它们以概率的形式出 

25
00:01:36,103 --> 00:01:38,520
现，为什么它是函数的自然形状。

26
00:01:39,020 --> 00:01:41,520
但我有点超前了，有 很多设置。

27
00:01:41,840 --> 00:01:45,335
在本视频中，我们的主要重点将放在离散情况上 

28
00:01:45,335 --> 00:01:50,101
，特别是构建一个非常出乎意料但非常聪明的算法来计算这些情况 

29
00:01:50,101 --> 00:01:50,260
。

30
00:01:50,260 --> 00:01:54,480
我将对连续案例的讨论拉到第二部分。

31
00:01:58,580 --> 00:02:03,060
很容易打开图像处理示例，因为它们在视觉上是最有趣的 

32
00:02:03,060 --> 00:02:07,368
，但是有一些挑剔之处使得图像处理案例不太能代表卷 

33
00:02:07,368 --> 00:02:11,849
积的整体情况，所以让我们从概率开始，特别是最简单的 

34
00:02:11,849 --> 00:02:16,157
例子之一，我相信这里的每个人都在他们生活中的某个 

35
00:02:16,157 --> 00:02:20,638
时刻考虑过，那就是掷一对骰子并计算出看到各种不同总 

36
00:02:20,638 --> 00:02:21,500
和的机会。

37
00:02:22,460 --> 00:02:24,460
你可能会说，不是问题，不是问题。

38
00:02:24,680 --> 00:02:28,406
两个骰子中的每一个 都有 6 种不同的可能结果，这

39
00:02:28,406 --> 00:02:31,089
给了我们总共 36 种不同的可能结 

40
00:02:31,089 --> 00:02:34,816
果对，如果我们只查看它们，我们可以计算出有多少对具

41
00:02:34,816 --> 00:02:35,860
有给定的总和。

42
00:02:36,600 --> 00:02:41,799
将所有对排列在这样的网格中，一件非常好的事情是，所有具有恒 

43
00:02:41,799 --> 00:02:45,440
定总和的对都沿着这些不同的对角线之一可见。

44
00:02:45,440 --> 00:02:48,780
因此，只需计算每 个对角线上有多少个就

45
00:02:48,780 --> 00:02:52,120
可以告诉您看到特定总和的可能性有多大。

46
00:02:53,220 --> 00:02:57,882
我想说，非常好，非常好，但是您能想到任何其他方式来形象化同 

47
00:02:57,882 --> 00:02:58,660
一问题吗？

48
00:02:59,300 --> 00:03:04,060
可以想到其他图像来思考具有给定总和的所有不同对 吗？

49
00:03:04,860 --> 00:03:07,980
也许你们中的一个人举起手说，是的，我有一个。

50
00:03:08,280 --> 00:03:13,760
假设您连续想 象这两组不同的可能性，但您翻转了第二行。

51
00:03:13,760 --> 00:03:18,760
这样， 所有不同的对加起来就是七对，像这样垂直排列。

52
00:03:19,360 --> 00:03:22,739
如果我们将底 行一直滑动到右侧，那么加起来

53
00:03:22,739 --> 00:03:26,280
为两个的独特的一对，即蛇眼 ，是唯一对齐的。

54
00:03:26,620 --> 00:03:29,805
如果我将其放在右侧的一个单位上，则对齐的 

55
00:03:29,805 --> 00:03:32,080
对是两对不同的，加起来为三对。

56
00:03:32,880 --> 00:03:37,074
一般来说，这个较低数组的 不同偏移值（记住我

57
00:03:37,074 --> 00:03:41,460
必须首先翻转）显示具有给定总和的所有 不同对。

58
00:03:44,820 --> 00:03:48,543
就概率问题而言，这仍然不是特别有趣，因 

59
00:03:48,543 --> 00:03:52,640
为我们所做的只是计算每个类别中有多少个结果。

60
00:03:52,980 --> 00:03:58,120
但这是基于一个隐含的假设，即这些面孔出现的机会均 等。

61
00:03:58,360 --> 00:04:01,620
但如果我告诉你我有一套不统一的特殊骰子怎么办？

62
00:04:02,060 --> 00:04:07,310
也许 蓝色骰子有自己的一组数字来描述每张面出现的概率，而红 

63
00:04:07,310 --> 00:04:09,760
色骰子有自己独特的一组数字。

64
00:04:10,299 --> 00:04:13,655
在这种情况下，如果您想计 算出看到 2 

65
00:04:13,655 --> 00:04:18,353
的概率，您可以将蓝色骰子为 1 的概率 乘以红色骰子为 

66
00:04:18,353 --> 00:04:19,360
1 的概率。

67
00:04:19,360 --> 00:04:24,429
对于看到 3 的机会，您可 以在可能的情况下查看两个不同

68
00:04:24,429 --> 00:04:29,680
的对，然后再次乘以相应的概 率，然后将这两个乘积加在一起。

69
00:04:30,100 --> 00:04:33,460
类似地，看到四的机会 涉及将三对不同

70
00:04:33,460 --> 00:04:36,820
的可能性相乘并将它们全部加在一起 。

71
00:04:36,820 --> 00:04:40,917
本着建立一些公式的精神，让我们将这些最高概率命名为 

72
00:04:40,917 --> 00:04:45,644
a1、a2、a3 等，并将最低概率命名为 b1、b2、b3 

73
00:04:45,644 --> 00:04:45,960
等。

74
00:04:46,400 --> 00:04:49,866
一般来说，在这个过 程中，我们获取两个不同的

75
00:04:49,866 --> 00:04:53,333
数字数组，翻转第二个数组，然 后将它们排列在

76
00:04:53,333 --> 00:04:56,642
各种不同的偏移值处，获取一堆成对的乘积并 

77
00:04:56,642 --> 00:05:00,740
将它们相加，这就是其中之一思考什么是卷积的基本方法。

78
00:05:00,740 --> 00:05:06,031
因此，为了更准确地说明这一点，通过这个过程，我们只是生成了

79
00:05:06,031 --> 00:05:09,498
看到两个、三 个、四个、一直到 12 

80
00:05:09,498 --> 00:05:13,695
的概率，并且我们通过将一个值列表 a 和另一 

81
00:05:13,695 --> 00:05:16,980
个值混合在一起来获得它们值列表，b。

82
00:05:17,440 --> 00:05:22,560
用行话来说，我们会说这两个序列 的卷积给出了这个新序列，即 

83
00:05:22,560 --> 00:05:27,340
11 个值的新序列，每个值看起来都 像是成对乘积的总和。

84
00:05:27,340 --> 00:05:31,120
如果您愿意，您可以考虑相同操作的另一种 

85
00:05:31,120 --> 00:05:36,601
方法是首先创建所有成对产品的表，然后沿着所有这些对角线相 

86
00:05:36,601 --> 00:05:36,980
加。

87
00:05:37,460 --> 00:05:40,721
同样，这是一种将这两个数字序列混合在一起以获得 

88
00:05:40,721 --> 00:05:42,760
11 个数字的 新序列的方法。

89
00:05:43,240 --> 00:05:46,460
和滑动窗想的操作是一样的，只是换个角度。

90
00:05:47,140 --> 00:05:49,800
对其进行一些注释，您可能会看到这样的写法。

91
00:05:50,220 --> 00:05:54,978
a 和 b 的卷 积（用这个小星号表示）是一个新列表

92
00:05:54,978 --> 00:05:59,736
，该列表的第 n 个元素看起 来像一个和，并且该和遍

93
00:05:59,736 --> 00:06:04,860
历所有不同的索引对 i 和 j，因此这些索 引等于 n。

94
00:06:05,280 --> 00:06:09,517
这有点拗口，但是例如，如果 n 是 6，我们要检查的对是 

95
00:06:09,517 --> 00:06:12,731
1 和 5、2 和 4、3 和 3、4 和 

96
00:06:12,731 --> 00:06:15,800
2、5 和 1，所有不同的对加起来至 6。

97
00:06:16,620 --> 00:06:20,825
但老实说，无论你怎么写，符号的重要性都比你头脑中 

98
00:06:20,825 --> 00:06:22,340
的视觉效果要重要。

99
00:06:23,280 --> 00:06:26,457
在这里，也许做一个超级简单的例子会有所帮助，我可 

100
00:06:26,457 --> 00:06:29,635
能会问你列表 1, 2, 3 与列表 4, 5, 

101
00:06:29,635 --> 00:06:30,780
6 的卷积是多少。

102
00:06:31,480 --> 00:06:34,580
您可能会想 象将这两个列表都拿出来，翻转第

103
00:06:34,580 --> 00:06:37,680
二个列表，然后从其盖子开 始一直向左移动。

104
00:06:38,180 --> 00:06:41,242
然后对齐的一对值是 1 和 4，将它们 

105
00:06:41,242 --> 00:06:43,540
相乘，这就是我们输出的第一项。

106
00:06:43,960 --> 00:06:47,352
将底部数组向右滑动一个单位，对 齐的对是 

107
00:06:47,352 --> 00:06:52,198
1 和 5、2 和 4，将这些对相乘，将它们加在一起，得到 

108
00:06:52,198 --> 00:06:54,460
13，即输出中的下一个条目。

109
00:06:54,960 --> 00:06:58,122
再把东西滑过来，我们需要 1 乘以 6，加上 

110
00:06:58,122 --> 00:07:01,560
2 乘以 5，再加上 3 乘以 4，正好是 28。

111
00:07:02,020 --> 00:07:05,914
再一张幻灯片，我们得到 2 乘 以 6，加上 3 

112
00:07:05,914 --> 00:07:10,120
乘以 5，得到 27，最后一项看起来像 3 乘以 6。

113
00:07:10,660 --> 00:07:14,898
如果您愿意，您可以调出您最喜欢的编程语言，以及您最喜 

114
00:07:14,898 --> 00:07:18,980
欢的包含各种数值运算的库，并且您可以确认我没有骗您。

115
00:07:18,980 --> 00:07:21,808
如果将 1、2、3 与 4、5、6 

116
00:07:21,808 --> 00:07:24,480
进行卷积，这确实是您将得到的结果。

117
00:07:25,920 --> 00:07:29,790
我们已经见过一种情况，这是一种自然且理想的操作，加

118
00:07:29,790 --> 00:07:33,660
起来就是概 率分布，另一个常见的例子是移动平均线。

119
00:07:34,080 --> 00:07:36,919
想象一下，您有一个很长的数字 列表，然后您又取

120
00:07:36,919 --> 00:07:39,760
了另一个较小的数字列表，这些数字的总和为 1。

121
00:07:40,100 --> 00:07:41,910
在本例中，我只有一 个包含 5 

122
00:07:41,910 --> 00:07:44,060
个值的小列表，它们都等于 1 5th。

123
00:07:44,060 --> 00:07:48,940
然后，如果我们进行这 个滑动窗口卷积过程，然后闭上眼睛

124
00:07:48,940 --> 00:07:53,820
，扫视一开始发生的情 况，一旦我们较小的值列表与较大的

125
00:07:53,820 --> 00:07:58,700
值列表完全重叠，请考 虑其中的每一项卷积的真正含义是。

126
00:07:59,400 --> 00:08:03,505
在每次迭代中，您所做的是 将数据中的每个值乘以 

127
00:08:03,505 --> 00:08:06,756
1 五分之一，然后将它们全部加在一起 

128
00:08:06,756 --> 00:08:10,520
，也就是说，您在这个小窗口内取数据的平均值。

129
00:08:11,100 --> 00:08:14,920
总体而言，该过 程为您提供了原始数据的平滑版本，

130
00:08:14,920 --> 00:08:19,695
您可以从不同的小数字列 表开始修改它，只要该小列表加起来为 

131
00:08:19,695 --> 00:08:22,720
1，您仍然可以将其 解释为移动平均的。

132
00:08:23,400 --> 00:08:27,760
在此所示的示例中，移动平均线将给予 中心值更多的权重。

133
00:08:28,420 --> 00:08:30,800
这也会产生数据的平滑版本。

134
00:08:33,140 --> 00:08:38,043
如果你对此进行二维模拟，它会给你一个有趣的算法来模糊给定 

135
00:08:38,043 --> 00:08:38,720
的图像。

136
00:08:38,720 --> 00:08:42,582
我应该说，我即将展示的动画是根据我最初为我与麻省理工学院的 

137
00:08:42,582 --> 00:08:45,801
Jul ia 实验室一起为某个包含图像处理单元的 

138
00:08:45,801 --> 00:08:47,990
OpenCourseWare 课 

139
00:08:47,990 --> 00:08:51,080
程所做的一组讲座的一部分而制作的动画进行了修改。

140
00:08:51,560 --> 00:08:53,920
在那里，我们做了更多的工作 来深入研究所有这些背

141
00:08:53,920 --> 00:08:56,280
后的代码，所以如果您好奇，我会给您留下一些链接。

142
00:08:56,620 --> 00:09:01,120
但回 到这个模糊的例子，发生的事情是我得到了这个小的 

143
00:09:01,120 --> 00:09:05,286
3x3 值网格，它沿着我们的原始图像行进，如果我们

144
00:09:05,286 --> 00:09:08,120
放大，这些值中的 每一个都是 1 

145
00:09:08,120 --> 00:09:11,620
9th，而我正在做的在每次迭代中，将每个 

146
00:09:11,620 --> 00:09:13,620
值乘以它所在的相应像素。

147
00:09:13,900 --> 00:09:17,050
当然，在计算机科学中，我们将 颜色视为三

148
00:09:17,050 --> 00:09:20,200
个值的小向量，代表红色、绿色和蓝色分量。

149
00:09:20,560 --> 00:09:23,305
当我将所有这些小值乘以 1 9 

150
00:09:23,305 --> 00:09:26,738
并将它们加在一起时，它会给 出每个颜色通

151
00:09:26,738 --> 00:09:31,200
道的平均值，并且右侧图像的相应像素被定义为该总 和。

152
00:09:31,940 --> 00:09:36,400
当我们对图像上的每个像素执行此操作时，总体效果是每种像素都 

153
00:09:36,400 --> 00:09:40,860
会渗透到其所有邻居中，这给我们提供了比原始版本更模糊的版本。

154
00:09:41,720 --> 00:09:46,769
用行话来说，我们会说右侧的图像是原始图像与一些值网 

155
00:09:46,769 --> 00:09:47,740
格的卷积。

156
00:09:48,140 --> 00:09:51,831
或者从技术上讲，也许我应该说它是与那个小值网 

157
00:09:51,831 --> 00:09:54,400
格的 180 度旋转版本的卷积。

158
00:09:54,620 --> 00:09:59,930
当网格对称时并不重 要，但值得记住的是，从纯数学上下

159
00:09:59,930 --> 00:10:05,240
文继承的卷 积定义应该始终邀请您考虑翻转第二个数组。

160
00:10:05,960 --> 00:10:08,530
如果我们稍微修改一下，我们可以通过选择

161
00:10:08,530 --> 00:10:11,100
不同的值网格来获得更优雅的模 糊效果。

162
00:10:11,440 --> 00:10:13,540
在本例中，我有一个 5x5 的

163
00:10:13,540 --> 00:10:15,780
小网格，但区别并不在于它的大小。

164
00:10:15,980 --> 00:10:20,775
如果我们放大，我们会注意到中间的值比边缘的值大得多 

165
00:10:20,775 --> 00:10:25,940
，这是因为它们都是从钟形曲线（称为高斯分布）中采 样的。

166
00:10:26,800 --> 00:10:30,905
这样，当我们将所有这些值乘以它们所在的相应像素 

167
00:10:30,905 --> 00:10:35,353
时，我们就会为中心像素赋予更多权重，而为边缘像素赋 

168
00:10:35,353 --> 00:10:36,380
予更少权重。

169
00:10:36,800 --> 00:10:40,560
正如之前一样，右侧对应的像素被定义为这个总 和。

170
00:10:41,320 --> 00:10:45,520
当我们对每个像素执行此过程时，它会产生模糊 

171
00:10:45,520 --> 00:10:49,720
效果，更真实地模拟镜头失焦或类似情况的概念。

172
00:10:49,900 --> 00:10:53,360
但模糊远不是你可以用这个想法做的唯一事情。

173
00:10:53,800 --> 00:10:58,349
例如，看一下这 个小值网格，其中左侧有一些正数

174
00:10:58,349 --> 00:11:02,900
，右侧有一些负 数，我将分别用蓝色和红色着色。

175
00:11:03,640 --> 00:11:05,981
花点时间看看您是否 可以预测并

176
00:11:05,981 --> 00:11:08,480
理解这将对最终图像产生什么影响。

177
00:11:10,720 --> 00:11:14,420
因此，在这种情况下 ，我只会将图像视为灰度而不是彩

178
00:11:14,420 --> 00:11:18,120
色，因此每个像素仅由一个数字而 不是三个数字表示。

179
00:11:18,440 --> 00:11:23,060
值得注意的一件事是，当我们进行卷积时 ，可能会得到负值。

180
00:11:23,060 --> 00:11:26,160
例如，此时，如果我们放大小网格的 

181
00:11:26,160 --> 00:11:30,901
左半部分，则完全位于黑色像素的顶部，其值为零，但负 

182
00:11:30,901 --> 00:11:35,460
值的右半部分全部位于白色像素的顶部，这将值为 1。

183
00:11:36,180 --> 00:11:40,866
因此，当我们将相应项相乘并将它们加在一起时，结果将非常负 

184
00:11:40,866 --> 00:11:45,552
，而我用右侧图像显示此结果的方式是将负值涂成红色，将正值 

185
00:11:45,552 --> 00:11:46,360
涂成蓝色。

186
00:11:46,880 --> 00:11:50,480
另一件需要注意的事情是，当你在一个颜色相同的补丁上时， 

187
00:11:50,480 --> 00:11:54,080
所有的东西都会变为零，因为我们的小网格中的值的总和为零。

188
00:11:55,180 --> 00:11:58,998
这与前两个 示例非常不同，前两个示例中我们的小网格的总和为 

189
00:11:58,998 --> 00:12:02,180
1，这让我们将 其解释为移动平均值，因此是模糊的。

190
00:12:03,640 --> 00:12:06,961
总而言之，这个小过程基本 上可以检测当您从

191
00:12:06,961 --> 00:12:09,966
左向右移动时像素值存在变化的地方，因 

192
00:12:09,966 --> 00:12:13,920
此它为您提供了一种从图像中拾取所有垂直边缘的方法。

193
00:12:16,500 --> 00:12:21,335
同样，如果我们旋转该网格，使其随着您从顶部移动到底部而变 

194
00:12:21,335 --> 00:12:26,171
化，这将在所有水平边缘上出现，在我们的小馅饼生物图像的情 

195
00:12:26,171 --> 00:12:29,340
况下，这确实会导致一些漂亮的恶魔眼睛。

196
00:12:30,400 --> 00:12:33,880
顺便说一句，这个较 小的网格通常称为内核，这里的美妙

197
00:12:33,880 --> 00:12:36,155
之处在于，通过选择不同的内核，您 

198
00:12:36,155 --> 00:12:39,635
可以获得不同的图像处理效果，不仅模糊边缘检测，还可以

199
00:12:39,635 --> 00:12:40,840
实现锐化等 效果。

200
00:12:40,840 --> 00:12:45,133
对于那些听说过卷积神经网络的人来说，其想法是 

201
00:12:45,133 --> 00:12:49,986
使用数据来确定内核首先应该是什么，这取决于神经网络 

202
00:12:49,986 --> 00:12:51,480
想要检测的内容。

203
00:12:52,760 --> 00:12:55,520
我应该提出的另一件事是输出的长度 。

204
00:12:55,820 --> 00:12:59,912
对于像移动平均这样的示例，您可能只想考虑两个窗口 

205
00:12:59,912 --> 00:13:04,333
彼此完全对齐时的术语，或者在图像处理示例中，您可能希 

206
00:13:04,333 --> 00:13:07,280
望最终输出具有与原始大小相同的大小。

207
00:13:07,280 --> 00:13:11,730
现在，卷积作为一 种纯数学运算总是会产生一个比您开始使用的

208
00:13:11,730 --> 00:13:16,180
两个数组更大的数组 ，至少假设其中一个数组的长度不为 1。

209
00:13:16,720 --> 00:13:19,042
只需知道，在某些 计算机科学环

210
00:13:19,042 --> 00:13:21,520
境中，您经常想要故意截断该输出。

211
00:13:24,720 --> 00:13:29,584
另一件值得强调的事情是，在计算机科学背景下，在让它跨越 

212
00:13:29,584 --> 00:13:34,448
原始内核之前翻转该内核的概念通常感觉非常奇怪并且没有必 

213
00:13:34,448 --> 00:13:39,312
要，但再次注意，这是从纯数学背景继承的，就像我们一样从 

214
00:13:39,312 --> 00:13:42,440
可能性来看，这是一件非常自然的事情。

215
00:13:43,020 --> 00:13:47,520
实际上，我可以向您 展示另一个纯数学示例，即使是程序员也应该

216
00:13:47,520 --> 00:13:52,020
关心这个示例，因 为它为更快的算法来计算所有这些打开了大门。

217
00:13:52,620 --> 00:13:56,337
为了设置我所说的更 快的意思，让我返回并再次拉起一些 

218
00:13:56,337 --> 00:13:59,780
python，我将创建两个不同的相 对较大的数组。

219
00:13:59,940 --> 00:14:03,631
每个都有十万个随机元素，我将评估 

220
00:14:03,631 --> 00:14:07,540
numpy 库中卷积函数的运行时间。

221
00:14:08,180 --> 00:14:12,264
在本例中， 它运行多次不同的迭代，尝试找到平均值

222
00:14:12,264 --> 00:14:16,520
，在这台计算机上 看起来至少平均值为 4。87秒。

223
00:14:16,960 --> 00:14:20,336
相比之下，如果我使用 scipy 库中名为 

224
00:14:20,336 --> 00:14:24,634
fftconvolve 的不同函数，它是相同的函数，只是

225
00:14:24,634 --> 00:14:27,397
实现方式不同 ，只需要 4 个函数。

226
00:14:27,397 --> 00:14:30,160
平均为 3 毫秒，提高了三个数量级。

227
00:14:30,160 --> 00:14:34,731
同样，即使它以不同的名称运行，它也提供与其他卷积 

228
00:14:34,731 --> 00:14:39,120
函数相同的输出，它只是以更聪明的方式做一些事情。

229
00:14:42,200 --> 00:14:47,143
还记得我在概率示例中说过的另一种思考卷积的方法是 

230
00:14:47,143 --> 00:14:52,680
创建所有成对乘积的表，然后沿对角线将这些成对乘 积相加。

231
00:14:53,660 --> 00:14:56,753
当然，当你将两个不同的数字列表进行卷积时，概 

232
00:14:56,753 --> 00:14:59,040
率没有什么特定的，你可以这样思考。

233
00:14:59,040 --> 00:15:02,750
使用所有成对乘积创建 这种乘法表，然后沿

234
00:15:02,750 --> 00:15:06,460
对角线的每个和对应于您的最终输出 之一。

235
00:15:07,600 --> 00:15:12,800
这种观点特别自然的一种情况是当您将两个多项式 相乘时。

236
00:15:13,300 --> 00:15:18,178
例如，让我使用已有的小网格，将顶部项替换为 1、2x 

237
00:15:18,178 --> 00:15:23,600
和 3x 平方，并将其他项替换为 4、5x 和 6x 平方。

238
00:15:24,000 --> 00:15:26,354
现在考虑一下当我们在两个列表之间创建

239
00:15:26,354 --> 00:15:28,840
所有这些不同的成对乘积时意味 着什么。

240
00:15:29,040 --> 00:15:33,607
你所做的本质上是展开我写下的两个多项式的 

241
00:15:33,607 --> 00:15:39,045
完整乘积，然后当你沿着对应于收集所有相似项的对角 

242
00:15:39,045 --> 00:15:44,265
线相加时，这非常整齐地展开多项式并收集相似项正 

243
00:15:44,265 --> 00:15:46,440
是与卷积相同的过程。

244
00:15:47,740 --> 00:15:50,410
但这使我们能够做一些非常酷的事情， 

245
00:15:50,410 --> 00:15:52,340
因为想想我们在这里所说的。

246
00:15:52,340 --> 00:15:55,714
我们的意思是，如果你采用两个不同的 

247
00:15:55,714 --> 00:16:00,965
函数并将它们相乘，这是一个简单的逐点运算，这与你首先从 

248
00:16:00,965 --> 00:16:06,402
每个函数中提取系数（假设它们是多项式）然后对这些函数进行 

249
00:16:06,402 --> 00:16:08,840
卷积是一样的两个系数列表。

250
00:16:09,620 --> 00:16:15,000
有趣的是，卷积在原则上感觉 比简单的乘法复杂得多，我不仅

251
00:16:15,000 --> 00:16:20,380
仅意味着在概念上它们 更难思考，我的意思是在计算上它需要

252
00:16:20,380 --> 00:16:25,760
更多的步骤来执行 卷积而不是执行两个不同列表的逐点乘积。

253
00:16:26,319 --> 00:16:30,897
例如，假设我 给了你两个非常大的多项式，每个多项式都有一

254
00:16:30,897 --> 00:16:35,474
百个不同的系数，那么如果 你将它们相乘的方式是展开这个乘

255
00:16:35,474 --> 00:16:38,907
积，你知道填充整个 100 x 1 00 

256
00:16:38,907 --> 00:16:43,811
的成对乘积网格，这需要你执行 10,000 种不同的产品， 

257
00:16:43,811 --> 00:16:48,061
然后当您沿着对角线收集所有相似项时，这是另一组大约 

258
00:16:48,061 --> 00:16:49,860
10,000 次操作。

259
00:16:50,700 --> 00:16:53,912
更一般地说，在行话中，我们会说该算法是 

260
00:16:53,912 --> 00:16:57,606
O of n 平 方，这意味着对于两个大小为 

261
00:16:57,606 --> 00:17:01,140
n 的列表，操作数量与 n 的平方成正比 。

262
00:17:01,820 --> 00:17:06,404
另一方面，如果我根据输出来考虑两个多项式，例如在

263
00:17:06,404 --> 00:17:10,988
一些输入处对它们的值进行采样，那么将它们相乘只需

264
00:17:10,988 --> 00:17:15,573
要与样本数一样多的运算，因为这又是一个逐点运算，

265
00:17:15,573 --> 00:17:20,540
并且对于多项式，您只需要有限多个样本能够恢复系数。 

266
00:17:20,540 --> 00:17:25,060
例如，两个输出足以唯一地指定线性多项式。

267
00:17:25,660 --> 00:17:29,400
三个输出足以唯一地指定二次多项式。

268
00:17:29,640 --> 00:17:33,546
一般来说，如果您知道 n 个不同的输出，就

269
00:17:33,546 --> 00:17:37,640
足以唯一地指定具有 n 个不同系数的多项式。

270
00:17:37,780 --> 00:17:40,720
或者，如果您愿意，我们可以用方程组的语言来表达它。

271
00:17:41,200 --> 00:17:43,860
想象一下，我告诉你我有一些多项式，但我没

272
00:17:43,860 --> 00:17:46,520
有告诉你系数是什么，这些对你来说是个谜。

273
00:17:46,700 --> 00:17:50,800
在我们的示例中，您可能会认为这是我们正在尝试找出的产品。

274
00:17:50,800 --> 00:17:54,485
然后假设我说，如果您输入各种不同的输入（例如 

275
00:17:54,485 --> 00:17:58,652
0、1、2、3 等等），我会告诉您该多项式的输出是什

276
00:17:58,652 --> 00:18:03,460
么，并且我给您足够的信息，以便您有尽可能多的方程你有未知数。

277
00:18:04,140 --> 00:18:07,340
它甚至恰好是一个线性方程组，所以这很好。

278
00:18:07,780 --> 00:18:10,900
至少原则上，这应该足以恢复系数。

279
00:18:11,740 --> 00:18:15,370
因此，粗略的算法概述是，每当您想要对两个数字列

280
00:18:15,370 --> 00:18:19,000
表进行卷积时，您都将它们视为两个多项式的系数。

281
00:18:19,420 --> 00:18:24,895
您以足够的输出对这些多项式进行采样，将这些样本逐点相乘，然

282
00:18:24,895 --> 00:18:30,560
后求解系统以恢复系数，作为找到卷积的一种偷偷摸摸的后门方法。

283
00:18:31,420 --> 00:18:34,380
至少到目前为止我已经说过了，你们中的一些人可

284
00:18:34,380 --> 00:18:37,340
以合理地抱怨“格兰特，这是一个愚蠢的计划”。

285
00:18:37,580 --> 00:18:42,347
因为首先，仅计算我们已知的多项式之一的所有这

286
00:18:42,347 --> 00:18:47,115
些样本就已经进行了 n 次方运算，更不用说解

287
00:18:47,115 --> 00:18:52,100
决该系统在计算上肯定会像首先进行卷积一样困难。

288
00:18:52,600 --> 00:18:56,540
所以，就像，乘法和卷积之间肯定有这种联系，但所有

289
00:18:56,540 --> 00:19:00,480
的复杂性都发生在从一个观点到另一个观点的转换中。

290
00:19:01,600 --> 00:19:04,508
但有一个技巧，那些了解傅立叶变换和 

291
00:19:04,508 --> 00:19:07,740
FFT 算法的人可能会明白这是怎么回事。

292
00:19:07,740 --> 00:19:09,960
如果您不熟悉这些主题，那么我接下来

293
00:19:09,960 --> 00:19:12,180
要说的内容可能看起来完全出乎意料。

294
00:19:12,260 --> 00:19:14,560
只要知道，在数学中你可以走一些特定的

295
00:19:14,560 --> 00:19:16,860
道路，这使得这更像是一个预期的步骤。

296
00:19:17,720 --> 00:19:20,360
基本上，我们的想法是我们在这里有选择的自由。

297
00:19:20,540 --> 00:19:25,030
如果您选择对一组非常特别选择的复数进行评估，而不是

298
00:19:25,030 --> 00:19:29,700
对任意一组输入（如 0、1、2、3 等等）进行评估。

299
00:19:30,240 --> 00:19:34,840
特别是那些均匀分布在单位圆上的，即所谓的单位根。

300
00:19:35,200 --> 00:19:36,880
这为我们提供了一个更友好的系统。

301
00:19:38,360 --> 00:19:43,663
基本思想是，通过找到一个数字，使其幂落入这种循环模式，这

302
00:19:43,663 --> 00:19:48,967
意味着我们生成的系统将在您计算的不同项中具有大量冗余，并

303
00:19:48,967 --> 00:19:54,460
且通过聪明地了解如何计算利用这种冗余，您可以节省大量工作。

304
00:19:56,020 --> 00:20:02,280
我编写的这组输出有一个特殊的名称，称为系数的离散傅立叶变换。

305
00:20:02,500 --> 00:20:05,234
如果你想了解更多，我实际上为 Julia 

306
00:20:05,234 --> 00:20:09,140
麻省理工学院的同一个课程做了另一场关于离散傅里叶变换的讲座。

307
00:20:09,220 --> 00:20:13,170
在频道 reducible 上还有一个非常棒的视频，讨论

308
00:20:13,170 --> 00:20:17,120
了快速傅立叶变换，这是一种可以更快地计算这些变换的算法。

309
00:20:17,480 --> 00:20:19,762
另外，Veritasium 最近制作了一个关于 

310
00:20:19,762 --> 00:20:21,760
FFT 的非常好的视频，因此您有很多选择。

311
00:20:22,260 --> 00:20:24,660
这种快速算法确实是我们的重点。

312
00:20:25,120 --> 00:20:29,759
同样，由于所有这些冗余，存在一种从系数到所有这些输出的方法

313
00:20:29,759 --> 00:20:34,240
，其中不是按 n 平方运算的顺序进行，而是按 n 乘以 

314
00:20:34,240 --> 00:20:38,879
n 运算的对数的顺序进行，这要多得多当你扩展到大列表时会更

315
00:20:38,879 --> 00:20:39,200
好。

316
00:20:39,660 --> 00:20:42,540
重要的是，这种 fft 算法是双向的。

317
00:20:42,700 --> 00:20:45,480
它还可以让您从输出转到系数。

318
00:20:46,220 --> 00:20:49,060
因此，将所有内容放在一起，让我们回顾一下我们的算法大纲。

319
00:20:49,420 --> 00:20:53,616
现在我们可以说，每当你给定两个一长串数字并且你想

320
00:20:53,616 --> 00:20:57,812
要对它们进行卷积时，首先计算它们每个的快速傅立叶

321
00:20:57,812 --> 00:21:02,008
变换，在你的脑海中你可以认为将它们视为它们是多项

322
00:21:02,008 --> 00:21:06,380
式的系数，并在一组非常特别选择的点上对其进行评估。

323
00:21:06,899 --> 00:21:10,770
然后将刚刚获得的两个结果逐点相乘，这既好

324
00:21:10,770 --> 00:21:14,641
又快，然后进行快速傅立叶逆变换，这给了您

325
00:21:14,641 --> 00:21:18,900
计算我们正在寻找的卷积的偷偷摸摸的后门方法。

326
00:21:19,040 --> 00:21:22,240
但这次只涉及 O of n log n 操作。

327
00:21:23,139 --> 00:21:24,740
这对我来说真的很酷！

328
00:21:25,120 --> 00:21:29,521
卷积出现的这种非常具体的上下文，将两个多项式相乘，

329
00:21:29,521 --> 00:21:34,100
为一种与其他可能出现卷积的地方相关的算法打开了大门。

330
00:21:34,180 --> 00:21:39,000
如果您想添加概率分布，请进行一些大型图像处理，无论它是什么。

331
00:21:39,220 --> 00:21:43,350
我只是认为这是一个很好的例子，说明为什么当你看到数学中的某

332
00:21:43,350 --> 00:21:47,480
些运算或概念出现在许多看似不相关的领域时，你应该感到兴奋。

333
00:21:48,480 --> 00:21:51,500
如果你想要做一点作业，这里有一些值得思考的有趣的事情。

334
00:21:51,720 --> 00:21:56,756
解释为什么当你将两个不同的数字相乘时，只是我们在小学学

335
00:21:56,756 --> 00:22:01,980
习的普通乘法，你所做的基本上是这些数字的数字之间的卷积。

336
00:22:02,500 --> 00:22:06,460
增加了一些进位等步骤，但核心步骤是卷积。

337
00:22:07,280 --> 00:22:12,580
鉴于快速算法的存在，这意味着如果你有两个非常大的整数，那么

338
00:22:12,580 --> 00:22:17,880
存在一种比我们在小学学到的方法更快的方法来找到它们的乘积。

339
00:22:18,140 --> 00:22:21,451
这不需要 O of n 平方运算，只需要 

340
00:22:21,451 --> 00:22:24,920
O of n log n，这甚至感觉不可能。

341
00:22:25,380 --> 00:22:30,840
问题是，在这在实践中真正有用之前，你的数字必须绝对是巨大的。

342
00:22:31,220 --> 00:22:35,340
不过，这样的算法存在还是很酷的。

343
00:22:35,340 --> 00:22:39,640
接下来，我们将把注意力转向连续情况，特别关注概率分布。

