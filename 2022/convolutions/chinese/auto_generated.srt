1
00:00:00,000 --> 00:00:03,927
假设我给你两个不同的数字列表，或者可能是两个不同的函

2
00:00:03,927 --> 00:00:07,854
数，并且 我要求你思考可以组合这两个列表以获得新的数

3
00:00:07,854 --> 00:00:11,782
字列表，或者组合 这两个函数以获得新函数的所有方法。

4
00:00:11,782 --> 00:00:16,320
也许想到的一种简单方法就是 简单地将它们逐个添加在一起。

5
00:00:16,320 --> 00:00:20,131
与功能类似，您可以添加所有 相应的输出。

6
00:00:20,131 --> 00:00:26,202
同样，您也可以将两个列表逐项相乘，并 对函数执行相同的操作。

7
00:00:26,202 --> 00:00:30,021
但还有另一种组合与这两 种组合一

8
00:00:30,021 --> 00:00:33,840
样基本，但很少被讨论，称为卷积。

9
00:00:33,840 --> 00:00:38,581
但与前两种情况不同的是，它不仅仅是从对数字执行

10
00:00:38,581 --> 00:00:39,964
的操作继承的。

11
00:00:39,964 --> 00:00:44,809
对于数字列表或组合函数的上下文来说，这是真 正的新事物。

12
00:00:44,809 --> 00:00:48,721
它们无处不在，它们在图像处理中无处不在，它

13
00:00:48,721 --> 00:00:53,699
是概率论的核心构造，它们在求解微分方程中被大量使用，并

14
00:00:53,699 --> 00:00:58,499
且您几乎肯定在其中见过它（如果没有的话）顾名思义，就

15
00:00:58,499 --> 00:01:00,277
是将两个多项式相乘。

16
00:01:00,277 --> 00:01:03,707
作为从事视觉解释行业的人，这是一个特别

17
00:01:03,707 --> 00:01:08,852
好的主题，因为孤立且没有上下文的公式化定义可能看起来有点令

18
00:01:08,852 --> 00:01:13,997
人生畏，但如果我们花时间真正解开它所说的内容，并在此之前真

19
00:01:13,997 --> 00:01:18,800
正激发为什么你会想要这样的东西，这是一个非常漂亮的操作。

20
00:01:18,800 --> 00:01:23,086
我必须承认，在为这个项目制作视觉效果时，我实际上学到了一些

21
00:01:23,086 --> 00:01:23,514
东西。

22
00:01:23,514 --> 00:01:27,377
在卷积两个不同函数的情况下，我试图想出不同的方

23
00:01:27,377 --> 00:01:31,723
式来描述这可能意味着什么，对于其中一个，我有点恍然大

24
00:01:31,723 --> 00:01:36,068
悟，为什么正态分布起着这样的作用：它们以概率的形式出

25
00:01:36,068 --> 00:01:38,483
现，为什么它是函数的自然形状。

26
00:01:38,483 --> 00:01:41,645
但我有点超前了，有 很多设置。

27
00:01:41,645 --> 00:01:45,235
在本视频中，我们的主要重点将放在离散情况上

28
00:01:45,235 --> 00:01:50,130
，特别是构建一个非常出乎意料但非常聪明的算法来计算这些情况

29
00:01:50,130 --> 00:01:50,293
。

30
00:01:50,293 --> 00:01:54,400
我将对连续案例的讨论拉到第二部分。

31
00:01:54,400 --> 00:01:59,717
很容易打开图像处理示例，因为它们在视觉上是最有趣的

32
00:01:59,717 --> 00:02:04,830
，但是有一些挑剔之处使得图像处理案例不太能代表卷

33
00:02:04,830 --> 00:02:10,147
积的整体情况，所以让我们从概率开始，特别是最简单的

34
00:02:10,147 --> 00:02:15,260
例子之一，我相信这里的每个人都在他们生活中的某个

35
00:02:15,260 --> 00:02:20,577
时刻考虑过，那就是掷一对骰子并计算出看到各种不同总

36
00:02:20,577 --> 00:02:21,600
和的机会。

37
00:02:21,600 --> 00:02:24,213
你可能会说，不是问题，不是问题。

38
00:02:24,213 --> 00:02:28,008
两个骰子中的每一个 都有 6 种不同的可能结果，这

39
00:02:28,008 --> 00:02:30,741
给了我们总共 36 种不同的可能结

40
00:02:30,741 --> 00:02:34,537
果对，如果我们只查看它们，我们可以计算出有多少对具

41
00:02:34,537 --> 00:02:35,600
有给定的总和。

42
00:02:35,600 --> 00:02:41,528
将所有对排列在这样的网格中，一件非常好的事情是，所有具有恒

43
00:02:41,528 --> 00:02:45,678
定总和的对都沿着这些不同的对角线之一可见。

44
00:02:45,678 --> 00:02:48,799
因此，只需计算每 个对角线上有多少个就

45
00:02:48,799 --> 00:02:51,920
可以告诉您看到特定总和的可能性有多大。

46
00:02:51,920 --> 00:02:57,807
我想说，非常好，非常好，但是您能想到任何其他方式来形象化同

47
00:02:57,807 --> 00:02:58,788
一问题吗？

48
00:02:58,788 --> 00:03:03,836
可以想到其他图像来思考具有给定总和的所有不同对 吗？

49
00:03:03,836 --> 00:03:07,586
也许你们中的一个人举起手说，是的，我有一个。

50
00:03:07,586 --> 00:03:14,056
假设您连续想 象这两组不同的可能性，但您翻转了第二行。

51
00:03:14,056 --> 00:03:18,984
这样， 所有不同的对加起来就是七对，像这样垂直排列。

52
00:03:18,984 --> 00:03:22,596
如果我们将底 行一直滑动到右侧，那么加起来

53
00:03:22,596 --> 00:03:26,380
为两个的独特的一对，即蛇眼 ，是唯一对齐的。

54
00:03:26,380 --> 00:03:30,205
如果我将其放在右侧的一个单位上，则对齐的

55
00:03:30,205 --> 00:03:32,938
对是两对不同的，加起来为三对。

56
00:03:32,938 --> 00:03:37,332
一般来说，这个较低数组的 不同偏移值（记住我

57
00:03:37,332 --> 00:03:41,926
必须首先翻转）显示具有给定总和的所有 不同对。

58
00:03:41,926 --> 00:03:47,256
就概率问题而言，这仍然不是特别有趣，因

59
00:03:47,256 --> 00:03:53,120
为我们所做的只是计算每个类别中有多少个结果。

60
00:03:53,120 --> 00:03:57,941
但这是基于一个隐含的假设，即这些面孔出现的机会均 等。

61
00:03:57,941 --> 00:04:01,909
但如果我告诉你我有一套不统一的特殊骰子怎么办？

62
00:04:01,909 --> 00:04:07,277
也许 蓝色骰子有自己的一组数字来描述每张面出现的概率，而红

63
00:04:07,277 --> 00:04:09,782
色骰子有自己独特的一组数字。

64
00:04:09,782 --> 00:04:13,545
在这种情况下，如果您想计 算出看到 2

65
00:04:13,545 --> 00:04:18,814
的概率，您可以将蓝色骰子为 1 的概率 乘以红色骰子为

66
00:04:18,814 --> 00:04:19,943
1 的概率。

67
00:04:19,943 --> 00:04:24,898
对于看到 3 的机会，您可 以在可能的情况下查看两个不同

68
00:04:24,898 --> 00:04:30,029
的对，然后再次乘以相应的概 率，然后将这两个乘积加在一起。

69
00:04:30,029 --> 00:04:33,437
类似地，看到四的机会 涉及将三对不同

70
00:04:33,437 --> 00:04:36,845
的可能性相乘并将它们全部加在一起 。

71
00:04:36,845 --> 00:04:40,924
本着建立一些公式的精神，让我们将这些最高概率命名为

72
00:04:40,924 --> 00:04:45,632
a1、a2、a3 等，并将最低概率命名为 b1、b2、b3

73
00:04:45,632 --> 00:04:45,946
等。

74
00:04:45,946 --> 00:04:49,661
一般来说，在这个过 程中，我们获取两个不同的

75
00:04:49,661 --> 00:04:53,375
数字数组，翻转第二个数组，然 后将它们排列在

76
00:04:53,375 --> 00:04:56,921
各种不同的偏移值处，获取一堆成对的乘积并

77
00:04:56,921 --> 00:05:01,311
将它们相加，这就是其中之一思考什么是卷积的基本方法。

78
00:05:01,311 --> 00:05:06,470
因此，为了更准确地说明这一点，通过这个过程，我们只是生成了

79
00:05:06,470 --> 00:05:09,850
看到两个、三 个、四个、一直到 12

80
00:05:09,850 --> 00:05:13,941
的概率，并且我们通过将一个值列表 a 和另一

81
00:05:13,941 --> 00:05:17,143
个值混合在一起来获得它们值列表，b。

82
00:05:17,143 --> 00:05:22,339
用行话来说，我们会说这两个序列 的卷积给出了这个新序列，即

83
00:05:22,339 --> 00:05:27,188
11 个值的新序列，每个值看起来都 像是成对乘积的总和。

84
00:05:27,188 --> 00:05:30,955
如果您愿意，您可以考虑相同操作的另一种

85
00:05:30,955 --> 00:05:36,416
方法是首先创建所有成对产品的表，然后沿着所有这些对角线相

86
00:05:36,416 --> 00:05:36,793
加。

87
00:05:36,793 --> 00:05:40,191
同样，这是一种将这两个数字序列混合在一起以获得

88
00:05:40,191 --> 00:05:42,315
11 个数字的 新序列的方法。

89
00:05:42,315 --> 00:05:46,400
和滑动窗想的操作是一样的，只是换个角度。

90
00:05:46,400 --> 00:05:50,335
对其进行一些注释，您可能会看到这样的写法。

91
00:05:50,335 --> 00:05:55,047
a 和 b 的卷 积（用这个小星号表示）是一个新列表

92
00:05:55,047 --> 00:05:59,759
，该列表的第 n 个元素看起 来像一个和，并且该和遍

93
00:05:59,759 --> 00:06:04,833
历所有不同的索引对 i 和 j，因此这些索 引等于 n。

94
00:06:04,833 --> 00:06:09,202
这有点拗口，但是例如，如果 n 是 6，我们要检查的对是

95
00:06:09,202 --> 00:06:12,516
1 和 5、2 和 4、3 和 3、4 和

96
00:06:12,516 --> 00:06:15,680
2、5 和 1，所有不同的对加起来至 6。

97
00:06:15,680 --> 00:06:21,169
但老实说，无论你怎么写，符号的重要性都比你头脑中

98
00:06:21,169 --> 00:06:23,145
的视觉效果要重要。

99
00:06:23,145 --> 00:06:26,468
在这里，也许做一个超级简单的例子会有所帮助，我可

100
00:06:26,468 --> 00:06:29,791
能会问你列表 1, 2, 3 与列表 4, 5,

101
00:06:29,791 --> 00:06:30,987
6 的卷积是多少。

102
00:06:30,987 --> 00:06:34,457
您可能会想 象将这两个列表都拿出来，翻转第

103
00:06:34,457 --> 00:06:37,926
二个列表，然后从其盖子开 始一直向左移动。

104
00:06:37,926 --> 00:06:41,312
然后对齐的一对值是 1 和 4，将它们

105
00:06:41,312 --> 00:06:43,851
相乘，这就是我们输出的第一项。

106
00:06:43,851 --> 00:06:47,248
将底部数组向右滑动一个单位，对 齐的对是

107
00:06:47,248 --> 00:06:52,102
1 和 5、2 和 4，将这些对相乘，将它们加在一起，得到

108
00:06:52,102 --> 00:06:54,367
13，即输出中的下一个条目。

109
00:06:54,367 --> 00:06:57,857
再把东西滑过来，我们需要 1 乘以 6，加上

110
00:06:57,857 --> 00:07:01,651
2 乘以 5，再加上 3 乘以 4，正好是 28。

111
00:07:01,651 --> 00:07:05,664
再一张幻灯片，我们得到 2 乘 以 6，加上 3

112
00:07:05,664 --> 00:07:10,000
乘以 5，得到 27，最后一项看起来像 3 乘以 6。

113
00:07:10,000 --> 00:07:14,539
如果您愿意，您可以调出您最喜欢的编程语言，以及您最喜

114
00:07:14,539 --> 00:07:18,910
欢的包含各种数值运算的库，并且您可以确认我没有骗您。

115
00:07:18,910 --> 00:07:21,692
如果将 1、2、3 与 4、5、6

116
00:07:21,692 --> 00:07:24,320
进行卷积，这确实是您将得到的结果。

117
00:07:24,320 --> 00:07:28,618
我们已经见过一种情况，这是一种自然且理想的操作，加

118
00:07:28,618 --> 00:07:32,916
起来就是概 率分布，另一个常见的例子是移动平均线。

119
00:07:32,916 --> 00:07:35,863
想象一下，您有一个很长的数字 列表，然后您又取

120
00:07:35,863 --> 00:07:38,811
了另一个较小的数字列表，这些数字的总和为 1。

121
00:07:38,811 --> 00:07:40,918
在本例中，我只有一 个包含 5

122
00:07:40,918 --> 00:07:43,420
个值的小列表，它们都等于 1 5th。

123
00:07:43,420 --> 00:07:48,635
然后，如果我们进行这 个滑动窗口卷积过程，然后闭上眼睛

124
00:07:48,635 --> 00:07:53,850
，扫视一开始发生的情 况，一旦我们较小的值列表与较大的

125
00:07:53,850 --> 00:07:59,066
值列表完全重叠，请考 虑其中的每一项卷积的真正含义是。

126
00:07:59,066 --> 00:08:03,397
在每次迭代中，您所做的是 将数据中的每个值乘以

127
00:08:03,397 --> 00:08:06,826
1 五分之一，然后将它们全部加在一起

128
00:08:06,826 --> 00:08:10,797
，也就是说，您在这个小窗口内取数据的平均值。

129
00:08:10,797 --> 00:08:14,769
总体而言，该过 程为您提供了原始数据的平滑版本，

130
00:08:14,769 --> 00:08:19,733
您可以从不同的小数字列 表开始修改它，只要该小列表加起来为

131
00:08:19,733 --> 00:08:22,878
1，您仍然可以将其 解释为移动平均的。

132
00:08:22,878 --> 00:08:27,822
在此所示的示例中，移动平均线将给予 中心值更多的权重。

133
00:08:27,822 --> 00:08:30,720
这也会产生数据的平滑版本。

134
00:08:30,720 --> 00:08:37,725
如果你对此进行二维模拟，它会给你一个有趣的算法来模糊给定

135
00:08:37,725 --> 00:08:38,691
的图像。

136
00:08:38,691 --> 00:08:42,512
我应该说，我即将展示的动画是根据我最初为我与麻省理工学院的

137
00:08:42,512 --> 00:08:45,696
Jul ia 实验室一起为某个包含图像处理单元的

138
00:08:45,696 --> 00:08:47,861
OpenCourseWare 课

139
00:08:47,861 --> 00:08:50,918
程所做的一组讲座的一部分而制作的动画进行了修改。

140
00:08:50,918 --> 00:08:53,687
在那里，我们做了更多的工作 来深入研究所有这些背

141
00:08:53,687 --> 00:08:56,456
后的代码，所以如果您好奇，我会给您留下一些链接。

142
00:08:56,456 --> 00:09:00,933
但回 到这个模糊的例子，发生的事情是我得到了这个小的

143
00:09:00,933 --> 00:09:05,078
3x3 值网格，它沿着我们的原始图像行进，如果我们

144
00:09:05,078 --> 00:09:07,897
放大，这些值中的 每一个都是 1

145
00:09:07,897 --> 00:09:11,380
9th，而我正在做的在每次迭代中，将每个

146
00:09:11,380 --> 00:09:13,369
值乘以它所在的相应像素。

147
00:09:13,369 --> 00:09:16,884
当然，在计算机科学中，我们将 颜色视为三

148
00:09:16,884 --> 00:09:20,400
个值的小向量，代表红色、绿色和蓝色分量。

149
00:09:20,400 --> 00:09:23,155
当我将所有这些小值乘以 1 9

150
00:09:23,155 --> 00:09:26,598
并将它们加在一起时，它会给 出每个颜色通

151
00:09:26,598 --> 00:09:31,075
道的平均值，并且右侧图像的相应像素被定义为该总 和。

152
00:09:31,075 --> 00:09:35,977
当我们对图像上的每个像素执行此操作时，总体效果是每种像素都

153
00:09:35,977 --> 00:09:40,880
会渗透到其所有邻居中，这给我们提供了比原始版本更模糊的版本。

154
00:09:40,880 --> 00:09:46,755
用行话来说，我们会说右侧的图像是原始图像与一些值网

155
00:09:46,755 --> 00:09:47,885
格的卷积。

156
00:09:47,885 --> 00:09:51,767
或者从技术上讲，也许我应该说它是与那个小值网

157
00:09:51,767 --> 00:09:54,468
格的 180 度旋转版本的卷积。

158
00:09:54,468 --> 00:10:00,114
当网格对称时并不重 要，但值得记住的是，从纯数学上下

159
00:10:00,114 --> 00:10:05,760
文继承的卷 积定义应该始终邀请您考虑翻转第二个数组。

160
00:10:05,760 --> 00:10:08,454
如果我们稍微修改一下，我们可以通过选择

161
00:10:08,454 --> 00:10:11,148
不同的值网格来获得更优雅的模 糊效果。

162
00:10:11,148 --> 00:10:13,457
在本例中，我有一个 5x5 的

163
00:10:13,457 --> 00:10:15,920
小网格，但区别并不在于它的大小。

164
00:10:15,920 --> 00:10:20,822
如果我们放大，我们会注意到中间的值比边缘的值大得多

165
00:10:20,822 --> 00:10:26,102
，这是因为它们都是从钟形曲线（称为高斯分布）中采 样的。

166
00:10:26,102 --> 00:10:30,532
这样，当我们将所有这些值乘以它们所在的相应像素

167
00:10:30,532 --> 00:10:35,332
时，我们就会为中心像素赋予更多权重，而为边缘像素赋

168
00:10:35,332 --> 00:10:36,439
予更少权重。

169
00:10:36,439 --> 00:10:40,475
正如之前一样，右侧对应的像素被定义为这个总 和。

170
00:10:40,475 --> 00:10:45,117
当我们对每个像素执行此过程时，它会产生模糊

171
00:10:45,117 --> 00:10:49,760
效果，更真实地模拟镜头失焦或类似情况的概念。

172
00:10:49,760 --> 00:10:53,504
但模糊远不是你可以用这个想法做的唯一事情。

173
00:10:53,504 --> 00:10:58,301
例如，看一下这 个小值网格，其中左侧有一些正数

174
00:10:58,301 --> 00:11:03,099
，右侧有一些负 数，我将分别用蓝色和红色着色。

175
00:11:03,099 --> 00:11:06,345
花点时间看看您是否 可以预测并

176
00:11:06,345 --> 00:11:09,808
理解这将对最终图像产生什么影响。

177
00:11:09,808 --> 00:11:13,978
因此，在这种情况下 ，我只会将图像视为灰度而不是彩

178
00:11:13,978 --> 00:11:18,149
色，因此每个像素仅由一个数字而 不是三个数字表示。

179
00:11:18,149 --> 00:11:23,164
值得注意的一件事是，当我们进行卷积时 ，可能会得到负值。

180
00:11:23,164 --> 00:11:26,213
例如，此时，如果我们放大小网格的

181
00:11:26,213 --> 00:11:30,876
左半部分，则完全位于黑色像素的顶部，其值为零，但负

182
00:11:30,876 --> 00:11:35,360
值的右半部分全部位于白色像素的顶部，这将值为 1。

183
00:11:35,360 --> 00:11:40,312
因此，当我们将相应项相乘并将它们加在一起时，结果将非常负

184
00:11:40,312 --> 00:11:45,264
，而我用右侧图像显示此结果的方式是将负值涂成红色，将正值

185
00:11:45,264 --> 00:11:46,117
涂成蓝色。

186
00:11:46,117 --> 00:11:50,494
另一件需要注意的事情是，当你在一个颜色相同的补丁上时，

187
00:11:50,494 --> 00:11:54,871
所有的东西都会变为零，因为我们的小网格中的值的总和为零。

188
00:11:54,871 --> 00:11:59,332
这与前两个 示例非常不同，前两个示例中我们的小网格的总和为

189
00:11:59,332 --> 00:12:03,050
1，这让我们将 其解释为移动平均值，因此是模糊的。

190
00:12:03,050 --> 00:12:06,510
总而言之，这个小过程基本 上可以检测当您从

191
00:12:06,510 --> 00:12:09,640
左向右移动时像素值存在变化的地方，因

192
00:12:09,640 --> 00:12:13,760
此它为您提供了一种从图像中拾取所有垂直边缘的方法。

193
00:12:13,760 --> 00:12:19,883
同样，如果我们旋转该网格，使其随着您从顶部移动到底部而变

194
00:12:19,883 --> 00:12:26,007
化，这将在所有水平边缘上出现，在我们的小馅饼生物图像的情

195
00:12:26,007 --> 00:12:30,020
况下，这确实会导致一些漂亮的恶魔眼睛。

196
00:12:30,020 --> 00:12:33,610
顺便说一句，这个较 小的网格通常称为内核，这里的美妙

197
00:12:33,610 --> 00:12:35,958
之处在于，通过选择不同的内核，您

198
00:12:35,958 --> 00:12:39,549
可以获得不同的图像处理效果，不仅模糊边缘检测，还可以

199
00:12:39,549 --> 00:12:40,792
实现锐化等 效果。

200
00:12:40,792 --> 00:12:45,190
对于那些听说过卷积神经网络的人来说，其想法是

201
00:12:45,190 --> 00:12:50,162
使用数据来确定内核首先应该是什么，这取决于神经网络

202
00:12:50,162 --> 00:12:51,691
想要检测的内容。

203
00:12:51,691 --> 00:12:55,457
我应该提出的另一件事是输出的长度 。

204
00:12:55,457 --> 00:12:59,861
对于像移动平均这样的示例，您可能只想考虑两个窗口

205
00:12:59,861 --> 00:13:04,618
彼此完全对齐时的术语，或者在图像处理示例中，您可能希

206
00:13:04,618 --> 00:13:07,789
望最终输出具有与原始大小相同的大小。

207
00:13:07,789 --> 00:13:12,110
现在，卷积作为一 种纯数学运算总是会产生一个比您开始使用的

208
00:13:12,110 --> 00:13:16,431
两个数组更大的数组 ，至少假设其中一个数组的长度不为 1。

209
00:13:16,431 --> 00:13:18,855
只需知道，在某些 计算机科学环

210
00:13:18,855 --> 00:13:21,440
境中，您经常想要故意截断该输出。

211
00:13:21,440 --> 00:13:27,237
另一件值得强调的事情是，在计算机科学背景下，在让它跨越

212
00:13:27,237 --> 00:13:33,035
原始内核之前翻转该内核的概念通常感觉非常奇怪并且没有必

213
00:13:33,035 --> 00:13:38,832
要，但再次注意，这是从纯数学背景继承的，就像我们一样从

214
00:13:38,832 --> 00:13:42,560
可能性来看，这是一件非常自然的事情。

215
00:13:42,560 --> 00:13:47,479
实际上，我可以向您 展示另一个纯数学示例，即使是程序员也应该

216
00:13:47,479 --> 00:13:52,399
关心这个示例，因 为它为更快的算法来计算所有这些打开了大门。

217
00:13:52,399 --> 00:13:56,164
为了设置我所说的更 快的意思，让我返回并再次拉起一些

218
00:13:56,164 --> 00:13:59,651
python，我将创建两个不同的相 对较大的数组。

219
00:13:59,651 --> 00:14:03,511
每个都有十万个随机元素，我将评估

220
00:14:03,511 --> 00:14:07,598
numpy 库中卷积函数的运行时间。

221
00:14:07,598 --> 00:14:11,911
在本例中， 它运行多次不同的迭代，尝试找到平均值

222
00:14:11,911 --> 00:14:16,403
，在这台计算机上 看起来至少平均值为 4。87秒。

223
00:14:16,403 --> 00:14:20,045
相比之下，如果我使用 scipy 库中名为

224
00:14:20,045 --> 00:14:24,680
fftconvolve 的不同函数，它是相同的函数，只是

225
00:14:24,680 --> 00:14:27,660
实现方式不同 ，只需要 4 个函数。

226
00:14:27,660 --> 00:14:30,640
平均为 3 毫秒，提高了三个数量级。

227
00:14:30,640 --> 00:14:34,844
同样，即使它以不同的名称运行，它也提供与其他卷积

228
00:14:34,844 --> 00:14:38,880
函数相同的输出，它只是以更聪明的方式做一些事情。

229
00:14:38,880 --> 00:14:45,356
还记得我在概率示例中说过的另一种思考卷积的方法是

230
00:14:45,356 --> 00:14:52,611
创建所有成对乘积的表，然后沿对角线将这些成对乘 积相加。

231
00:14:52,611 --> 00:14:56,487
当然，当你将两个不同的数字列表进行卷积时，概

232
00:14:56,487 --> 00:14:59,352
率没有什么特定的，你可以这样思考。

233
00:14:59,352 --> 00:15:02,922
使用所有成对乘积创建 这种乘法表，然后沿

234
00:15:02,922 --> 00:15:06,492
对角线的每个和对应于您的最终输出 之一。

235
00:15:06,492 --> 00:15:12,513
这种观点特别自然的一种情况是当您将两个多项式 相乘时。

236
00:15:12,513 --> 00:15:17,916
例如，让我使用已有的小网格，将顶部项替换为 1、2x

237
00:15:17,916 --> 00:15:23,920
和 3x 平方，并将其他项替换为 4、5x 和 6x 平方。

238
00:15:23,920 --> 00:15:26,274
现在考虑一下当我们在两个列表之间创建

239
00:15:26,274 --> 00:15:28,760
所有这些不同的成对乘积时意味 着什么。

240
00:15:28,760 --> 00:15:33,550
你所做的本质上是展开我写下的两个多项式的

241
00:15:33,550 --> 00:15:39,254
完整乘积，然后当你沿着对应于收集所有相似项的对角

242
00:15:39,254 --> 00:15:44,729
线相加时，这非常整齐地展开多项式并收集相似项正

243
00:15:44,729 --> 00:15:47,011
是与卷积相同的过程。

244
00:15:47,011 --> 00:15:50,312
但这使我们能够做一些非常酷的事情，

245
00:15:50,312 --> 00:15:52,696
因为想想我们在这里所说的。

246
00:15:52,696 --> 00:15:55,994
我们的意思是，如果你采用两个不同的

247
00:15:55,994 --> 00:16:01,125
函数并将它们相乘，这是一个简单的逐点运算，这与你首先从

248
00:16:01,125 --> 00:16:06,439
每个函数中提取系数（假设它们是多项式）然后对这些函数进行

249
00:16:06,439 --> 00:16:08,821
卷积是一样的两个系数列表。

250
00:16:08,821 --> 00:16:14,577
有趣的是，卷积在原则上感觉 比简单的乘法复杂得多，我不仅

251
00:16:14,577 --> 00:16:20,333
仅意味着在概念上它们 更难思考，我的意思是在计算上它需要

252
00:16:20,333 --> 00:16:26,089
更多的步骤来执行 卷积而不是执行两个不同列表的逐点乘积。

253
00:16:26,089 --> 00:16:30,694
例如，假设我 给了你两个非常大的多项式，每个多项式都有一

254
00:16:30,694 --> 00:16:35,299
百个不同的系数，那么如果 你将它们相乘的方式是展开这个乘

255
00:16:35,299 --> 00:16:38,753
积，你知道填充整个 100 x 1 00

256
00:16:38,753 --> 00:16:43,687
的成对乘积网格，这需要你执行 10,000 种不同的产品，

257
00:16:43,687 --> 00:16:47,963
然后当您沿着对角线收集所有相似项时，这是另一组大约

258
00:16:47,963 --> 00:16:49,773
10,000 次操作。

259
00:16:49,773 --> 00:16:53,207
更一般地说，在行话中，我们会说该算法是

260
00:16:53,207 --> 00:16:57,157
O of n 平 方，这意味着对于两个大小为

261
00:16:57,157 --> 00:17:00,935
n 的列表，操作数量与 n 的平方成正比 。

262
00:17:00,935 --> 00:17:05,886
另一方面，如果我根据输出来考虑两个多项式，例如在

263
00:17:05,886 --> 00:17:10,837
一些输入处对它们的值进行采样，那么将它们相乘只需

264
00:17:10,837 --> 00:17:15,788
要与样本数一样多的运算，因为这又是一个逐点运算，

265
00:17:15,788 --> 00:17:21,152
并且对于多项式，您只需要有限多个样本能够恢复系数。

266
00:17:21,152 --> 00:17:25,214
例如，两个输出足以唯一地指定线性多项式。

267
00:17:25,214 --> 00:17:29,360
三个输出足以唯一地指定二次多项式。

268
00:17:29,360 --> 00:17:33,130
一般来说，如果您知道 n 个不同的输出，就足

269
00:17:33,130 --> 00:17:36,901
以唯一地指定具有 n 个不同系数的多项式。

270
00:17:36,901 --> 00:17:41,188
或者，如果您愿意，我们可以用方程组的语言来表达它。

271
00:17:41,188 --> 00:17:43,769
想象一下，我告诉你我有一些多项式，但我没

272
00:17:43,769 --> 00:17:46,480
有告诉你系数是什么，这些对你来说是个谜。

273
00:17:46,480 --> 00:17:50,666
在我们的示例中，您可能会认为这是我们正在尝试找出的产品。

274
00:17:50,666 --> 00:17:54,440
然后假设我说，如果您输入各种不同的输入（例如

275
00:17:54,440 --> 00:17:58,705
0、1、2、3 等等），我会告诉您该多项式的输出是什

276
00:17:58,705 --> 00:18:03,627
么，并且我给您足够的信息，以便您有尽可能多的方程你有未知数。

277
00:18:03,627 --> 00:18:03,791


278
00:18:03,791 --> 00:18:07,245
它甚至恰好是一个线性方程组，所以这很好。

279
00:18:07,245 --> 00:18:11,137
至少原则上，这应该足以恢复系数。

280
00:18:11,137 --> 00:18:15,109
因此，粗略的算法概述是，每当您想要对两个数字列

281
00:18:15,109 --> 00:18:19,253
表进行卷积时，您都将它们视为两个多项式的系数。

282
00:18:19,253 --> 00:18:25,309
您以足够的输出对这些多项式进行采样，将这些样本逐点相乘，然后

283
00:18:25,309 --> 00:18:31,364
求解系统以恢复系数，作为找到卷积的一种偷偷摸摸的后门方法。

284
00:18:31,364 --> 00:18:34,395
至少到目前为止我已经说过了，你们中的一些人可

285
00:18:34,395 --> 00:18:37,564
以合理地抱怨“格兰特，这是一个愚蠢的计划”。

286
00:18:37,564 --> 00:18:42,595
因为一方面，仅计算我们已知的多项式之一的所有这

287
00:18:42,595 --> 00:18:47,625
些样本就已经进行了 n 次方运算，更不用说解决

288
00:18:47,625 --> 00:18:52,656
该系统在计算上肯定会像首先进行卷积一样困难。

289
00:18:52,656 --> 00:18:56,776
所以，就像，我们肯定在乘法和卷积之间存在这种联系，但

290
00:18:56,776 --> 00:19:01,054
所有的复杂性都发生在从一个观点到另一个观点的转换中。

291
00:19:01,054 --> 00:19:04,109
但有一个技巧，那些了解傅立叶变换和

292
00:19:04,109 --> 00:19:07,673
FFT 算法的人可能会明白这是怎么回事。

293
00:19:07,673 --> 00:19:09,860
如果您不熟悉这些主题，那么我接下来

294
00:19:09,860 --> 00:19:12,176
要说的内容可能看起来完全出乎意料。

295
00:19:12,176 --> 00:19:14,806
只要知道，在数学中你可以走一些特定的

296
00:19:14,806 --> 00:19:17,582
道路，这使得这更像是一个预期的步骤。

297
00:19:17,582 --> 00:19:20,697
基本上，我们的想法是我们在这里有选择的自由。

298
00:19:20,697 --> 00:19:25,388
如果您选择对一组非常特别选择的复数进行评估，而不是对

299
00:19:25,388 --> 00:19:30,080
任意一组输入（如 0、1、2、3 等等）进行评估。

300
00:19:30,080 --> 00:19:34,894
特别是那些均匀分布在单位圆上的，即所谓的单位根。

301
00:19:34,894 --> 00:19:37,364
这为我们提供了一个更友好的系统。

302
00:19:37,364 --> 00:19:43,188
基本思想是，通过找到一个数字，使其幂落入这种循环模式，这

303
00:19:43,188 --> 00:19:49,012
意味着我们生成的系统将在您计算的不同项中具有大量冗余，并

304
00:19:49,012 --> 00:19:55,252
且通过聪明地了解如何计算利用这种冗余，您可以节省大量工作。

305
00:19:55,252 --> 00:20:01,943
我编写的这组输出有一个特殊的名称，称为系数的离散傅立叶变换。

306
00:20:01,943 --> 00:20:02,166


307
00:20:02,166 --> 00:20:04,968
如果你想了解更多，我实际上为 Julia

308
00:20:04,968 --> 00:20:08,969
麻省理工学院的同一个课程做了另一场关于离散傅立叶变换的讲座。

309
00:20:08,969 --> 00:20:09,103


310
00:20:09,103 --> 00:20:13,111
在频道 reducible 上还有一个非常棒的视频，讨论

311
00:20:13,111 --> 00:20:17,263
了快速傅立叶变换，这是一种可以更快地计算这些变换的算法。

312
00:20:17,263 --> 00:20:19,726
另外，Veritasium 最近制作了一个关于

313
00:20:19,726 --> 00:20:21,984
FFT 的非常好的视频，因此您有很多选择。

314
00:20:21,984 --> 00:20:24,786
这种快速算法确实是我们的重点。

315
00:20:24,786 --> 00:20:29,513
同样，由于所有这些冗余，存在一种从系数到所有这些输出的方法

316
00:20:29,513 --> 00:20:34,077
，其中不是按 n 平方运算的顺序进行，而是按 n 乘以

317
00:20:34,077 --> 00:20:38,804
n 运算的对数的顺序进行，这要多得多当你扩展到大列表时会更

318
00:20:38,804 --> 00:20:39,293
好。

319
00:20:39,293 --> 00:20:42,386
重要的是，这种 fft 算法是双向的。

320
00:20:42,386 --> 00:20:45,515
它还可以让您从输出转到系数。

321
00:20:45,515 --> 00:20:49,054
因此，将所有内容放在一起，让我们回顾一下我们的算法大纲。

322
00:20:49,054 --> 00:20:53,482
现在我们可以说，每当你给定两个一长串数字并且你想

323
00:20:53,482 --> 00:20:57,910
要对它们进行卷积时，首先计算它们每个的快速傅立叶

324
00:20:57,910 --> 00:21:02,338
变换，在你的脑海中你可以认为将它们视为它们是多项

325
00:21:02,338 --> 00:21:06,766
式的系数，并在一组专门选择的点上对其进行评估。

326
00:21:06,766 --> 00:21:10,793
然后将刚刚获得的两个结果逐点相乘，这既好又

327
00:21:10,793 --> 00:21:14,820
快，然后进行快速傅立叶逆变换，这给了您计算

328
00:21:14,820 --> 00:21:18,847
我们正在寻找的卷积的偷偷摸摸的后门方法。

329
00:21:18,847 --> 00:21:22,957
但这次只涉及 O of n log n 操作。

330
00:21:22,957 --> 00:21:24,865
这对我来说真的很酷！

331
00:21:24,865 --> 00:21:29,550
卷积出现的这种非常具体的上下文，将两个多项式相乘，为

332
00:21:29,550 --> 00:21:34,235
一种与其他可能出现卷积的地方相关的算法打开了大门。

333
00:21:34,235 --> 00:21:38,674
如果您想添加概率分布，请进行一些大型图像处理，无论它是什么。

334
00:21:38,674 --> 00:21:38,822


335
00:21:38,822 --> 00:21:43,234
我只是认为这是一个很好的例子，说明为什么当你看到数学中的某

336
00:21:43,234 --> 00:21:47,798
些运算或概念出现在许多看似不相关的领域时，你应该感到兴奋。

337
00:21:47,798 --> 00:21:51,967
如果你想要做一点作业，这里有一些值得思考的有趣的事情。

338
00:21:51,967 --> 00:21:56,945
解释为什么当你将两个不同的数字相乘时，只是我们在小学学习

339
00:21:56,945 --> 00:22:01,924
的普通乘法，你所做的基本上是这些数字的数字之间的卷积。

340
00:22:01,924 --> 00:22:06,785
增加了一些进位等步骤，但核心步骤是卷积。

341
00:22:06,785 --> 00:22:12,416
鉴于快速算法的存在，这意味着如果你有两个非常大的整数，那么

342
00:22:12,416 --> 00:22:18,240
存在一种比我们在小学学到的方法更快的方法来找到它们的乘积。

343
00:22:18,240 --> 00:22:21,605
这不需要 O of n 平方运算，只需要

344
00:22:21,605 --> 00:22:25,291
O of n log n，这甚至感觉不可能。

345
00:22:25,291 --> 00:22:31,086
问题是，在这在实践中真正有用之前，你的数字必须绝对是巨大的。

346
00:22:31,086 --> 00:22:31,280


347
00:22:31,280 --> 00:22:34,445
不过，这样的算法存在还是很酷的。

348
00:22:34,445 --> 00:22:50,400
接下来，我们将把注意力转向连续情况，特别关注概率分布。

