1
00:00:00,000 --> 00:00:04,480
假设我给你两个不同的数字列表，或者可能是两个不同的函数，并且

2
00:00:04,480 --> 00:00:08,400
我要求你思考可以组合这两个列表以获得新的数字列表，或者组合

3
00:00:08,400 --> 00:00:14,000
这两个函数以获得新函数的所有方法。也许想到的一种简单方法就是

4
00:00:14,000 --> 00:00:18,640
简单地将它们逐个添加在一起。与功能类似，您可以添加所有

5
00:00:18,640 --> 00:00:24,000
相应的输出。同样，您也可以将两个列表逐项相乘，并

6
00:00:24,000 --> 00:00:28,720
对函数执行相同的操作。但还有另一种组合与这两

7
00:00:28,720 --> 00:00:33,840
种组合一样基本，但很少被讨论，称为卷积。

8
00:00:33,840 --> 00:00:38,240
但与前两种情况不同的是，它不仅仅是从对数字执行

9
00:00:38,240 --> 00:00:43,360
的操作继承的。对于数字列表或组合函数的上下文来说，这是真

10
00:00:43,360 --> 00:00:49,280
正的新事物。它们无处不在，它们在图像处理中无处不在，它

11
00:00:49,280 --> 00:00:53,760
是概率论的核心构造，它们在求解微分方程中被大量使用，并

12
00:00:53,760 --> 00:00:58,240
且您几乎肯定在其中见过它（如果没有的话）顾名思义，就

13
00:00:58,240 --> 00:01:03,440
是将两个多项式相乘。作为从事视觉解释行业的人，这是一个特别

14
00:01:03,440 --> 00:01:08,800
好的主题，因为孤立且没有上下文的公式化定义可能看起来有点令

15
00:01:08,800 --> 00:01:14,080
人生畏，但如果我们花时间真正解开它所说的内容，并在此之前真

16
00:01:14,080 --> 00:01:18,800
正激发为什么你会想要这样的东西，这是一个非常漂亮的操作。

17
00:01:18,800 --> 00:01:22,880
我必须承认，在为这个项目制作视觉效果时，我实际上学到了一些

18
00:01:22,880 --> 00:01:26,960
东西。在卷积两个不同函数的情况下，我试图想出不同的方

19
00:01:26,960 --> 00:01:30,720
式来描述这可能意味着什么，对于其中一个，我有点恍然大

20
00:01:30,720 --> 00:01:35,840
悟，为什么正态分布起着这样的作用：它们以概率的形式出

21
00:01:35,840 --> 00:01:40,320
现，为什么它是函数的自然形状。但我有点超前了，有

22
00:01:40,320 --> 00:01:44,800
很多设置。在本视频中，我们的主要重点将放在离散情况上

23
00:01:44,800 --> 00:01:49,920
，特别是构建一个非常出乎意料但非常聪明的算法来计算这些情况

24
00:01:49,920 --> 00:01:54,400
。我将对连续案例的讨论拉到第二部分。

25
00:01:57,840 --> 00:02:03,120
很容易打开图像处理示例，因为它们在视觉上是最有趣的

26
00:02:03,120 --> 00:02:06,880
，但是有一些挑剔之处使得图像处理案例不太能代表卷

27
00:02:06,880 --> 00:02:11,760
积的整体情况，所以让我们从概率开始，特别是最简单的

28
00:02:11,760 --> 00:02:15,520
例子之一，我相信这里的每个人都在他们生活中的某个

29
00:02:15,520 --> 00:02:20,320
时刻考虑过，那就是掷一对骰子并计算出看到各种不同总

30
00:02:20,320 --> 00:02:25,600
和的机会。你可能会说，不是问题，不是问题。两个骰子中的每一个

31
00:02:25,600 --> 00:02:31,600
都有 6 种不同的可能结果，这给了我们总共 36 种不同的可能结

32
00:02:31,600 --> 00:02:35,600
果对，如果我们只查看它们，我们可以计算出有多少对具有给定的总和。

33
00:02:36,240 --> 00:02:41,120
将所有对排列在这样的网格中，一件非常好的事情是，所有具有恒

34
00:02:41,120 --> 00:02:47,040
定总和的对都沿着这些不同的对角线之一可见。因此，只需计算每

35
00:02:47,040 --> 00:02:51,920
个对角线上有多少个就可以告诉您看到特定总和的可能性有多大。

36
00:02:52,880 --> 00:02:57,760
我想说，非常好，非常好，但是您能想到任何其他方式来形象化同

37
00:02:57,760 --> 00:03:03,120
一问题吗？可以想到其他图像来思考具有给定总和的所有不同对

38
00:03:03,120 --> 00:03:08,800
吗？也许你们中的一个人举起手说，是的，我有一个。假设您连续想

39
00:03:08,800 --> 00:03:14,560
象这两组不同的可能性，但您翻转了第二行。这样，

40
00:03:14,560 --> 00:03:20,160
所有不同的对加起来就是七对，像这样垂直排列。如果我们将底

41
00:03:20,160 --> 00:03:24,880
行一直滑动到右侧，那么加起来为两个的独特的一对，即蛇眼

42
00:03:24,880 --> 00:03:29,680
，是唯一对齐的。如果我将其放在右侧的一个单位上，则对齐的

43
00:03:29,680 --> 00:03:35,440
对是两对不同的，加起来为三对。一般来说，这个较低数组的

44
00:03:35,440 --> 00:03:40,320
不同偏移值（记住我必须首先翻转）显示具有给定总和的所有

45
00:03:40,320 --> 00:03:48,800
不同对。就概率问题而言，这仍然不是特别有趣，因

46
00:03:48,800 --> 00:03:53,120
为我们所做的只是计算每个类别中有多少个结果。

47
00:03:53,120 --> 00:03:57,280
但这是基于一个隐含的假设，即这些面孔出现的机会均

48
00:03:57,280 --> 00:04:02,240
等。但如果我告诉你我有一套不统一的特殊骰子怎么办？也许

49
00:04:02,240 --> 00:04:06,800
蓝色骰子有自己的一组数字来描述每张面出现的概率，而红

50
00:04:06,800 --> 00:04:11,920
色骰子有自己独特的一组数字。在这种情况下，如果您想计

51
00:04:11,920 --> 00:04:17,360
算出看到 2 的概率，您可以将蓝色骰子为 1 的概率

52
00:04:17,360 --> 00:04:22,000
乘以红色骰子为 1 的概率。对于看到 3 的机会，您可

53
00:04:22,000 --> 00:04:26,880
以在可能的情况下查看两个不同的对，然后再次乘以相应的概

54
00:04:26,880 --> 00:04:32,240
率，然后将这两个乘积加在一起。类似地，看到四的机会

55
00:04:32,240 --> 00:04:36,320
涉及将三对不同的可能性相乘并将它们全部加在一起

56
00:04:36,320 --> 00:04:41,360
。本着建立一些公式的精神，让我们将这些最高概率命名为 a1、a2、a3

57
00:04:41,360 --> 00:04:48,000
等，并将最低概率命名为 b1、b2、b3 等。一般来说，在这个过

58
00:04:48,000 --> 00:04:52,080
程中，我们获取两个不同的数字数组，翻转第二个数组，然

59
00:04:52,080 --> 00:04:56,160
后将它们排列在各种不同的偏移值处，获取一堆成对的乘积并

60
00:04:56,160 --> 00:05:00,960
将它们相加，这就是其中之一思考什么是卷积的基本方法。

61
00:05:00,960 --> 00:05:08,960
因此，为了更准确地说明这一点，通过这个过程，我们只是生成了看到两个、三

62
00:05:08,960 --> 00:05:13,840
个、四个、一直到 12 的概率，并且我们通过将一个值列表 a 和另一

63
00:05:13,840 --> 00:05:20,080
个值混合在一起来获得它们值列表，b。用行话来说，我们会说这两个序列

64
00:05:20,080 --> 00:05:25,600
的卷积给出了这个新序列，即 11 个值的新序列，每个值看起来都

65
00:05:25,600 --> 00:05:30,160
像是成对乘积的总和。如果您愿意，您可以考虑相同操作的另一种

66
00:05:30,160 --> 00:05:36,240
方法是首先创建所有成对产品的表，然后沿着所有这些对角线相

67
00:05:36,240 --> 00:05:41,120
加。同样，这是一种将这两个数字序列混合在一起以获得 11 个数字的

68
00:05:41,120 --> 00:05:46,400
新序列的方法。和滑动窗想的操作是一样的，只是换个角度。

69
00:05:46,960 --> 00:05:51,280
对其进行一些注释，您可能会看到这样的写法。a 和 b 的卷

70
00:05:51,280 --> 00:05:57,200
积（用这个小星号表示）是一个新列表，该列表的第 n 个元素看起

71
00:05:57,200 --> 00:06:03,440
来像一个和，并且该和遍历所有不同的索引对 i 和 j，因此这些索

72
00:06:03,440 --> 00:06:09,440
引等于 n。这有点拗口，但是例如，如果 n 是 6，我们要检查的对是 1 和

73
00:06:09,440 --> 00:06:15,680
5、2 和 4、3 和 3、4 和 2、5 和 1，所有不同的对加起来至 6。

74
00:06:16,400 --> 00:06:20,640
但老实说，无论你怎么写，符号的重要性都比你头脑中

75
00:06:20,640 --> 00:06:26,320
的视觉效果要重要。在这里，也许做一个超级简单的例子会有所帮助，我可

76
00:06:26,320 --> 00:06:32,000
能会问你列表 1, 2, 3 与列表 4, 5, 6 的卷积是多少。您可能会想

77
00:06:32,000 --> 00:06:36,160
象将这两个列表都拿出来，翻转第二个列表，然后从其盖子开

78
00:06:36,160 --> 00:06:41,200
始一直向左移动。然后对齐的一对值是 1 和 4，将它们

79
00:06:41,200 --> 00:06:45,680
相乘，这就是我们输出的第一项。将底部数组向右滑动一个单位，对

80
00:06:45,680 --> 00:06:51,840
齐的对是 1 和 5、2 和 4，将这些对相乘，将它们加在一起，得到

81
00:06:51,840 --> 00:06:57,600
13，即输出中的下一个条目。再把东西滑过来，我们需要 1 乘以 6，加上 2

82
00:06:57,600 --> 00:07:04,400
乘以 5，再加上 3 乘以 4，正好是 28。再一张幻灯片，我们得到 2 乘

83
00:07:04,400 --> 00:07:10,000
以 6，加上 3 乘以 5，得到 27，最后一项看起来像 3 乘以 6。

84
00:07:10,560 --> 00:07:14,080
如果您愿意，您可以调出您最喜欢的编程语言，以及您最喜

85
00:07:14,080 --> 00:07:18,640
欢的包含各种数值运算的库，并且您可以确认我没有骗您。

86
00:07:18,640 --> 00:07:24,320
如果将 1、2、3 与 4、5、6 进行卷积，这确实是您将得到的结果。

87
00:07:24,880 --> 00:07:29,200
我们已经见过一种情况，这是一种自然且理想的操作，加起来就是概

88
00:07:29,200 --> 00:07:34,640
率分布，另一个常见的例子是移动平均线。想象一下，您有一个很长的数字

89
00:07:34,640 --> 00:07:39,920
列表，然后您又取了另一个较小的数字列表，这些数字的总和为 1。在本例中，我只有一

90
00:07:39,920 --> 00:07:45,280
个包含 5 个值的小列表，它们都等于 1 5th。然后，如果我们进行这

91
00:07:45,280 --> 00:07:49,760
个滑动窗口卷积过程，然后闭上眼睛，扫视一开始发生的情

92
00:07:50,560 --> 00:07:55,120
况，一旦我们较小的值列表与较大的值列表完全重叠，请考

93
00:07:55,680 --> 00:08:01,120
虑其中的每一项卷积的真正含义是。在每次迭代中，您所做的是

94
00:08:01,120 --> 00:08:06,400
将数据中的每个值乘以 1 五分之一，然后将它们全部加在一起

95
00:08:06,400 --> 00:08:12,080
，也就是说，您在这个小窗口内取数据的平均值。总体而言，该过

96
00:08:12,080 --> 00:08:16,800
程为您提供了原始数据的平滑版本，您可以从不同的小数字列

97
00:08:16,800 --> 00:08:21,280
表开始修改它，只要该小列表加起来为 1，您仍然可以将其

98
00:08:21,280 --> 00:08:25,840
解释为移动平均的。在此所示的示例中，移动平均线将给予

99
00:08:25,840 --> 00:08:30,720
中心值更多的权重。这也会产生数据的平滑版本。

100
00:08:33,200 --> 00:08:37,840
如果你对此进行二维模拟，它会给你一个有趣的算法来模糊给定

101
00:08:37,840 --> 00:08:43,120
的图像。我应该说，我即将展示的动画是根据我最初为我与麻省理工学院的 Jul

102
00:08:43,120 --> 00:08:48,160
ia 实验室一起为某个包含图像处理单元的 OpenCourseWare 课

103
00:08:48,160 --> 00:08:52,320
程所做的一组讲座的一部分而制作的动画进行了修改。在那里，我们做了更多的工作

104
00:08:52,320 --> 00:08:56,640
来深入研究所有这些背后的代码，所以如果您好奇，我会给您留下一些链接。但回

105
00:08:56,640 --> 00:09:01,440
到这个模糊的例子，发生的事情是我得到了这个小的 3x3

106
00:09:01,440 --> 00:09:06,480
值网格，它沿着我们的原始图像行进，如果我们放大，这些值中的

107
00:09:06,480 --> 00:09:11,120
每一个都是 1 9th，而我正在做的在每次迭代中，将每个

108
00:09:11,120 --> 00:09:16,080
值乘以它所在的相应像素。当然，在计算机科学中，我们将

109
00:09:16,080 --> 00:09:20,400
颜色视为三个值的小向量，代表红色、绿色和蓝色分量。

110
00:09:20,400 --> 00:09:25,440
当我将所有这些小值乘以 1 9 并将它们加在一起时，它会给

111
00:09:25,440 --> 00:09:30,480
出每个颜色通道的平均值，并且右侧图像的相应像素被定义为该总

112
00:09:30,480 --> 00:09:36,320
和。当我们对图像上的每个像素执行此操作时，总体效果是每种像素都

113
00:09:36,320 --> 00:09:40,880
会渗透到其所有邻居中，这给我们提供了比原始版本更模糊的版本。

114
00:09:41,680 --> 00:09:46,640
用行话来说，我们会说右侧的图像是原始图像与一些值网

115
00:09:46,640 --> 00:09:52,000
格的卷积。或者从技术上讲，也许我应该说它是与那个小值网

116
00:09:52,000 --> 00:09:56,160
格的 180 度旋转版本的卷积。当网格对称时并不重

117
00:09:56,160 --> 00:10:00,720
要，但值得记住的是，从纯数学上下文继承的卷

118
00:10:00,720 --> 00:10:05,760
积定义应该始终邀请您考虑翻转第二个数组。

119
00:10:05,760 --> 00:10:10,240
如果我们稍微修改一下，我们可以通过选择不同的值网格来获得更优雅的模

120
00:10:10,240 --> 00:10:15,920
糊效果。在本例中，我有一个 5x5 的小网格，但区别并不在于它的大小。

121
00:10:15,920 --> 00:10:19,920
如果我们放大，我们会注意到中间的值比边缘的值大得多

122
00:10:19,920 --> 00:10:25,360
，这是因为它们都是从钟形曲线（称为高斯分布）中采

123
00:10:25,360 --> 00:10:30,240
样的。这样，当我们将所有这些值乘以它们所在的相应像素

124
00:10:30,240 --> 00:10:35,200
时，我们就会为中心像素赋予更多权重，而为边缘像素赋

125
00:10:35,200 --> 00:10:39,920
予更少权重。正如之前一样，右侧对应的像素被定义为这个总

126
00:10:39,920 --> 00:10:45,360
和。当我们对每个像素执行此过程时，它会产生模糊

127
00:10:45,360 --> 00:10:49,760
效果，更真实地模拟镜头失焦或类似情况的概念。

128
00:10:49,760 --> 00:10:54,960
但模糊远不是你可以用这个想法做的唯一事情。例如，看一下这

129
00:10:54,960 --> 00:10:59,600
个小值网格，其中左侧有一些正数，右侧有一些负

130
00:10:59,600 --> 00:11:04,480
数，我将分别用蓝色和红色着色。花点时间看看您是否

131
00:11:04,480 --> 00:11:11,680
可以预测并理解这将对最终图像产生什么影响。因此，在这种情况下

132
00:11:11,680 --> 00:11:16,560
，我只会将图像视为灰度而不是彩色，因此每个像素仅由一个数字而

133
00:11:16,560 --> 00:11:21,280
不是三个数字表示。值得注意的一件事是，当我们进行卷积时

134
00:11:21,280 --> 00:11:26,240
，可能会得到负值。例如，此时，如果我们放大小网格的

135
00:11:26,240 --> 00:11:30,960
左半部分，则完全位于黑色像素的顶部，其值为零，但负

136
00:11:30,960 --> 00:11:35,360
值的右半部分全部位于白色像素的顶部，这将值为 1。

137
00:11:36,000 --> 00:11:40,960
因此，当我们将相应项相乘并将它们加在一起时，结果将非常负

138
00:11:40,960 --> 00:11:45,120
，而我用右侧图像显示此结果的方式是将负值涂成红色，将正值

139
00:11:45,120 --> 00:11:49,520
涂成蓝色。另一件需要注意的事情是，当你在一个颜色相同的补丁上时，

140
00:11:49,520 --> 00:11:55,680
所有的东西都会变为零，因为我们的小网格中的值的总和为零。这与前两个

141
00:11:55,680 --> 00:11:59,680
示例非常不同，前两个示例中我们的小网格的总和为 1，这让我们将

142
00:11:59,680 --> 00:12:05,760
其解释为移动平均值，因此是模糊的。总而言之，这个小过程基本

143
00:12:05,760 --> 00:12:10,240
上可以检测当您从左向右移动时像素值存在变化的地方，因

144
00:12:10,240 --> 00:12:13,760
此它为您提供了一种从图像中拾取所有垂直边缘的方法。

145
00:12:16,560 --> 00:12:20,960
同样，如果我们旋转该网格，使其随着您从顶部移动到底部而变

146
00:12:20,960 --> 00:12:26,000
化，这将在所有水平边缘上出现，在我们的小馅饼生物图像的情

147
00:12:26,000 --> 00:12:31,520
况下，这确实会导致一些漂亮的恶魔眼睛。顺便说一句，这个较

148
00:12:31,520 --> 00:12:36,160
小的网格通常称为内核，这里的美妙之处在于，通过选择不同的内核，您

149
00:12:36,160 --> 00:12:40,240
可以获得不同的图像处理效果，不仅模糊边缘检测，还可以实现锐化等

150
00:12:40,240 --> 00:12:44,800
效果。对于那些听说过卷积神经网络的人来说，其想法是

151
00:12:44,800 --> 00:12:49,600
使用数据来确定内核首先应该是什么，这取决于神经网络

152
00:12:49,600 --> 00:12:55,120
想要检测的内容。我应该提出的另一件事是输出的长度

153
00:12:55,120 --> 00:12:59,040
。对于像移动平均这样的示例，您可能只想考虑两个窗口

154
00:12:59,040 --> 00:13:04,080
彼此完全对齐时的术语，或者在图像处理示例中，您可能希

155
00:13:04,080 --> 00:13:09,200
望最终输出具有与原始大小相同的大小。现在，卷积作为一

156
00:13:09,200 --> 00:13:13,920
种纯数学运算总是会产生一个比您开始使用的两个数组更大的数组

157
00:13:13,920 --> 00:13:17,520
，至少假设其中一个数组的长度不为 1。只需知道，在某些

158
00:13:17,520 --> 00:13:21,440
计算机科学环境中，您经常想要故意截断该输出。

159
00:13:21,520 --> 00:13:29,200
另一件值得强调的事情是，在计算机科学背景下，在让它跨越

160
00:13:29,200 --> 00:13:34,080
原始内核之前翻转该内核的概念通常感觉非常奇怪并且没有必

161
00:13:34,080 --> 00:13:38,960
要，但再次注意，这是从纯数学背景继承的，就像我们一样从

162
00:13:38,960 --> 00:13:44,000
可能性来看，这是一件非常自然的事情。实际上，我可以向您

163
00:13:44,000 --> 00:13:48,480
展示另一个纯数学示例，即使是程序员也应该关心这个示例，因

164
00:13:48,480 --> 00:13:53,760
为它为更快的算法来计算所有这些打开了大门。为了设置我所说的更

165
00:13:53,760 --> 00:13:58,560
快的意思，让我返回并再次拉起一些 python，我将创建两个不同的相

166
00:13:58,560 --> 00:14:02,880
对较大的数组。每个都有十万个随机元素，我将评估

167
00:14:02,880 --> 00:14:08,640
numpy 库中卷积函数的运行时间。在本例中，

168
00:14:08,640 --> 00:14:12,800
它运行多次不同的迭代，尝试找到平均值，在这台计算机上

169
00:14:12,880 --> 00:14:18,640
看起来至少平均值为 4。87秒。相比之下，如果我使用 scipy

170
00:14:18,640 --> 00:14:24,080
库中名为 fftconvolve 的不同函数，它是相同的函数，只是实现方式不同

171
00:14:24,080 --> 00:14:30,640
，只需要 4 个函数。平均为 3 毫秒，提高了三个数量级。

172
00:14:30,640 --> 00:14:34,800
同样，即使它以不同的名称运行，它也提供与其他卷积

173
00:14:34,800 --> 00:14:38,880
函数相同的输出，它只是以更聪明的方式做一些事情。

174
00:14:38,880 --> 00:14:46,800
还记得我在概率示例中说过的另一种思考卷积的方法是

175
00:14:46,800 --> 00:14:51,520
创建所有成对乘积的表，然后沿对角线将这些成对乘

176
00:14:51,520 --> 00:14:56,560
积相加。当然，当你将两个不同的数字列表进行卷积时，概

177
00:14:56,560 --> 00:15:00,880
率没有什么特定的，你可以这样思考。使用所有成对乘积创建

178
00:15:00,880 --> 00:15:05,520
这种乘法表，然后沿对角线的每个和对应于您的最终输出

179
00:15:05,520 --> 00:15:11,680
之一。这种观点特别自然的一种情况是当您将两个多项式

180
00:15:11,680 --> 00:15:16,240
相乘时。例如，让我使用已有的小网格，将顶部项替换为 1、2x

181
00:15:16,240 --> 00:15:23,920
和 3x 平方，并将其他项替换为 4、5x 和 6x 平方。

182
00:15:23,920 --> 00:15:27,920
现在考虑一下当我们在两个列表之间创建所有这些不同的成对乘积时意味

183
00:15:27,920 --> 00:15:32,960
着什么。你所做的本质上是展开我写下的两个多项式的

184
00:15:32,960 --> 00:15:38,240
完整乘积，然后当你沿着对应于收集所有相似项的对角

185
00:15:38,240 --> 00:15:43,920
线相加时，这非常整齐地展开多项式并收集相似项正

186
00:15:43,920 --> 00:15:50,640
是与卷积相同的过程。但这使我们能够做一些非常酷的事情，

187
00:15:50,640 --> 00:15:55,360
因为想想我们在这里所说的。我们的意思是，如果你采用两个不同的

188
00:15:55,360 --> 00:16:00,560
函数并将它们相乘，这是一个简单的逐点运算，这与你首先从

189
00:16:00,560 --> 00:16:05,920
每个函数中提取系数（假设它们是多项式）然后对这些函数进行

190
00:16:05,920 --> 00:16:11,840
卷积是一样的两个系数列表。有趣的是，卷积在原则上感觉

191
00:16:11,840 --> 00:16:16,560
比简单的乘法复杂得多，我不仅仅意味着在概念上它们

192
00:16:16,560 --> 00:16:21,760
更难思考，我的意思是在计算上它需要更多的步骤来执行

193
00:16:21,760 --> 00:16:27,040
卷积而不是执行两个不同列表的逐点乘积。例如，假设我

194
00:16:27,040 --> 00:16:31,920
给了你两个非常大的多项式，每个多项式都有一百个不同的系数，那么如果

195
00:16:32,480 --> 00:16:37,520
你将它们相乘的方式是展开这个乘积，你知道填充整个 100 x 1

196
00:16:37,520 --> 00:16:43,600
00 的成对乘积网格，这需要你执行 10,000 种不同的产品，

197
00:16:43,600 --> 00:16:48,560
然后当您沿着对角线收集所有相似项时，这是另一组大约 10,000

198
00:16:48,560 --> 00:16:55,200
次操作。更一般地说，在行话中，我们会说该算法是 O of n 平

199
00:16:55,200 --> 00:17:00,560
方，这意味着对于两个大小为 n 的列表，操作数量与 n 的平方成正比

200
00:17:00,560 --> 00:17:06,320
。另一方面，如果我根据输出来考虑两个多项式，例如在一

201
00:17:06,320 --> 00:17:11,680
些输入处对它们的值进行采样，那么将它们相乘只需要与样本

202
00:17:11,680 --> 00:17:17,200
数一样多的运算，因为这又是一个逐点运算，并且对于多项

203
00:17:17,200 --> 00:17:22,400
式，您只需要有限多个样本能够恢复系数。例如，两个输出足

204
00:17:22,400 --> 00:17:27,920
以唯一地指定一个线性多项式，三个输出足以唯一地指定一个二次

205
00:17:27,920 --> 00:17:33,680
多项式，一般来说，如果您知道 n 个不同的输出，则足以唯一地

206
00:17:33,680 --> 00:17:38,800
指定具有 n 个不同系数的多项式，或者如果您愿意，我们可以

207
00:17:38,800 --> 00:17:43,680
用方程组的语言来表达这个假设我告诉你我有一些多项式，但我没有

208
00:17:43,680 --> 00:17:47,840
告诉你系数是什么，这些对你来说是个谜。在我们的示例中，您可

209
00:17:47,840 --> 00:17:52,960
能会认为这是我们试图找出的乘积，然后假设我说，如果您输入各种

210
00:17:52,960 --> 00:17:59,600
不同的输入（例如 0、1、2），我会告诉您该多项式的输出是什

211
00:17:59,600 --> 00:18:04,800
么，3，等等，我给你足够的，这样你就有了与未知数一样多的方程

212
00:18:04,800 --> 00:18:09,840
，它甚至碰巧是一个线性方程组，所以这很好，原则上至少这应该

213
00:18:09,840 --> 00:18:14,880
足以恢复系数。

214
00:18:14,880 --> 00:18:20,160


215
00:18:20,160 --> 00:18:26,560


216
00:18:26,560 --> 00:18:32,720


217
00:18:32,720 --> 00:18:38,000


218
00:18:38,000 --> 00:18:43,120


219
00:18:43,120 --> 00:18:47,760


220
00:18:47,760 --> 00:18:53,520


221
00:18:53,520 --> 00:18:58,400


222
00:18:58,400 --> 00:19:04,240


223
00:19:04,240 --> 00:19:09,200


224
00:19:09,200 --> 00:19:13,600


225
00:19:13,600 --> 00:19:18,720


226
00:19:18,720 --> 00:19:23,840


227
00:19:23,840 --> 00:19:30,080


228
00:19:30,080 --> 00:19:34,400


229
00:19:34,400 --> 00:19:41,600


230
00:19:41,600 --> 00:19:46,480


231
00:19:46,480 --> 00:19:51,360


232
00:19:51,360 --> 00:19:57,600


233
00:19:57,600 --> 00:20:03,200


234
00:20:03,200 --> 00:20:08,160


235
00:20:08,160 --> 00:20:12,640


236
00:20:12,640 --> 00:20:17,520


237
00:20:17,520 --> 00:20:22,720


238
00:20:22,720 --> 00:20:28,320


239
00:20:28,320 --> 00:20:33,040


240
00:20:33,040 --> 00:20:38,080


241
00:20:38,080 --> 00:20:43,600


242
00:20:43,600 --> 00:20:48,640


243
00:20:48,640 --> 00:20:53,200


244
00:20:53,200 --> 00:20:58,960


245
00:20:58,960 --> 00:21:03,280


246
00:21:03,280 --> 00:21:08,960


247
00:21:08,960 --> 00:21:14,480


248
00:21:14,480 --> 00:21:18,480


249
00:21:18,480 --> 00:21:25,600


250
00:21:25,600 --> 00:21:30,560


251
00:21:30,560 --> 00:21:35,120


252
00:21:35,120 --> 00:21:39,600


253
00:21:39,600 --> 00:21:44,480


254
00:21:44,480 --> 00:21:50,160


255
00:21:50,160 --> 00:21:54,800


256
00:21:54,800 --> 00:21:59,360


257
00:21:59,360 --> 00:22:04,640


258
00:22:04,640 --> 00:22:10,720


259
00:22:10,720 --> 00:22:16,000


260
00:22:16,000 --> 00:22:20,720


261
00:22:20,720 --> 00:22:26,320


262
00:22:26,320 --> 00:22:31,280


263
00:22:31,280 --> 00:22:36,880


264
00:22:36,880 --> 00:22:51,040


