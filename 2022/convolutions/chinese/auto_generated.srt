1
00:00:00,000 --> 00:00:04,063
假设我给你两个不同的数字列表，或者可能是两个不同的函数，

2
00:00:04,063 --> 00:00:08,127
并且 我要求你思考可以组合这两个列表以获得新的数字列表，

3
00:00:08,127 --> 00:00:11,320
或者组合 这两个函数以获得新函数的所有方法。

4
00:00:12,120 --> 00:00:16,760
也许想到的一种简单方法就是 简单地将它们逐个添加在一起。

5
00:00:17,160 --> 00:00:19,920
与功能类似，您可以添加所有 相应的输出。

6
00:00:20,540 --> 00:00:25,680
同样，您也可以将两个列表逐项相乘，并 对函数执行相同的操作。

7
00:00:26,360 --> 00:00:30,822
但还有另一种组合与这两 种组合一样基本，

8
00:00:30,822 --> 00:00:33,500
但很少被讨论，称为卷积。

9
00:00:34,080 --> 00:00:38,523
但与前两种情况不同的是，它不仅仅是从对数字执行 

10
00:00:38,523 --> 00:00:39,820
的操作继承的。

11
00:00:39,980 --> 00:00:44,700
对于数字列表或组合函数的上下文来说，这是真 正的新事物。

12
00:00:45,320 --> 00:00:48,749
它们无处不在，它们在图像处理中无处不在，

13
00:00:48,749 --> 00:00:53,551
它 是概率论的核心构造，它们在求解微分方程中被大量使用，

14
00:00:53,551 --> 00:00:58,182
并 且您几乎肯定在其中见过它（如果没有的话）顾名思义，

15
00:00:58,182 --> 00:01:00,240
就 是将两个多项式相乘。

16
00:01:00,740 --> 00:01:04,809
作为从事视觉解释行业的人，这是一个特别 好的主题，

17
00:01:04,809 --> 00:01:09,530
因为孤立且没有上下文的公式化定义可能看起来有点令 人生畏，

18
00:01:09,530 --> 00:01:12,622
但如果我们花时间真正解开它所说的内容，

19
00:01:12,622 --> 00:01:16,366
并在此之前真 正激发为什么你会想要这样的东西，

20
00:01:16,366 --> 00:01:18,320
这是一个非常漂亮的操作。

21
00:01:18,960 --> 00:01:21,735
我必须承认，在为这个项目制作视觉效果时，

22
00:01:21,735 --> 00:01:23,540
我实际上学到了一些 东西。

23
00:01:23,540 --> 00:01:27,405
在卷积两个不同函数的情况下，我试图想出不同的方 

24
00:01:27,405 --> 00:01:30,627
式来描述这可能意味着什么，对于其中一个，

25
00:01:30,627 --> 00:01:34,332
我有点恍然大 悟，为什么正态分布起着这样的作用

26
00:01:34,332 --> 00:01:38,520
：它们以概率的形式出 现，为什么它是函数的自然形状。

27
00:01:39,020 --> 00:01:41,520
但我有点超前了，有 很多设置。

28
00:01:41,840 --> 00:01:45,493
在本视频中，我们的主要重点将放在离散情况上 ，

29
00:01:45,493 --> 00:01:50,260
特别是构建一个非常出乎意料但非常聪明的算法来计算这些情况 。

30
00:01:50,260 --> 00:01:54,480
我将对连续案例的讨论拉到第二部分。

31
00:01:58,580 --> 00:02:03,232
很容易打开图像处理示例，因为它们在视觉上是最有趣的 ，

32
00:02:03,232 --> 00:02:07,368
但是有一些挑剔之处使得图像处理案例不太能代表卷 

33
00:02:07,368 --> 00:02:10,470
积的整体情况，所以让我们从概率开始，

34
00:02:10,470 --> 00:02:14,951
特别是最简单的 例子之一，我相信这里的每个人都在他们

35
00:02:14,951 --> 00:02:19,432
生活中的某个 时刻考虑过，那就是掷一对骰子并计算出看

36
00:02:19,432 --> 00:02:21,500
到各种不同总 和的机会。

37
00:02:22,460 --> 00:02:24,460
你可能会说，不是问题，不是问题。

38
00:02:24,680 --> 00:02:28,257
两个骰子中的每一个 都有 6 种不同的可能结果，

39
00:02:28,257 --> 00:02:31,537
这给了我们总共 36 种不同的可能结 果对，

40
00:02:31,537 --> 00:02:35,860
如果我们只查看它们，我们可以计算出有多少对具有给定的总和。

41
00:02:36,600 --> 00:02:40,760
将所有对排列在这样的网格中，一件非常好的事情是，

42
00:02:40,760 --> 00:02:45,440
所有具有恒 定总和的对都沿着这些不同的对角线之一可见。

43
00:02:45,440 --> 00:02:48,780
因此，只需计算每 个对角线上有多少个就

44
00:02:48,780 --> 00:02:52,120
可以告诉您看到特定总和的可能性有多大。

45
00:02:53,220 --> 00:02:57,882
我想说，非常好，非常好，但是您能想到任何其他方式来形象化同 

46
00:02:57,882 --> 00:02:58,660
一问题吗？

47
00:02:59,300 --> 00:03:04,060
可以想到其他图像来思考具有给定总和的所有不同对 吗？

48
00:03:04,860 --> 00:03:07,980
也许你们中的一个人举起手说，是的，我有一个。

49
00:03:08,280 --> 00:03:13,760
假设您连续想 象这两组不同的可能性，但您翻转了第二行。

50
00:03:13,760 --> 00:03:18,760
这样， 所有不同的对加起来就是七对，像这样垂直排列。

51
00:03:19,360 --> 00:03:21,934
如果我们将底 行一直滑动到右侧，

52
00:03:21,934 --> 00:03:26,280
那么加起来为两个的独特的一对，即蛇眼 ，是唯一对齐的。

53
00:03:26,620 --> 00:03:29,046
如果我将其放在右侧的一个单位上，

54
00:03:29,046 --> 00:03:32,080
则对齐的 对是两对不同的，加起来为三对。

55
00:03:32,880 --> 00:03:37,074
一般来说，这个较低数组的 不同偏移值（记住我

56
00:03:37,074 --> 00:03:41,460
必须首先翻转）显示具有给定总和的所有 不同对。

57
00:03:44,820 --> 00:03:48,171
就概率问题而言，这仍然不是特别有趣，

58
00:03:48,171 --> 00:03:52,640
因 为我们所做的只是计算每个类别中有多少个结果。

59
00:03:52,980 --> 00:03:58,120
但这是基于一个隐含的假设，即这些面孔出现的机会均 等。

60
00:03:58,360 --> 00:04:01,620
但如果我告诉你我有一套不统一的特殊骰子怎么办？

61
00:04:02,060 --> 00:04:06,784
也许 蓝色骰子有自己的一组数字来描述每张面出现的概率，

62
00:04:06,784 --> 00:04:09,760
而红 色骰子有自己独特的一组数字。

63
00:04:10,299 --> 00:04:14,326
在这种情况下，如果您想计 算出看到 2 的概率，

64
00:04:14,326 --> 00:04:19,360
您可以将蓝色骰子为 1 的概率 乘以红色骰子为 1 的概率。

65
00:04:19,360 --> 00:04:24,429
对于看到 3 的机会，您可 以在可能的情况下查看两个不同

66
00:04:24,429 --> 00:04:29,680
的对，然后再次乘以相应的概 率，然后将这两个乘积加在一起。

67
00:04:30,100 --> 00:04:33,460
类似地，看到四的机会 涉及将三对不同

68
00:04:33,460 --> 00:04:36,820
的可能性相乘并将它们全部加在一起 。

69
00:04:36,820 --> 00:04:40,917
本着建立一些公式的精神，让我们将这些最高概率命名为 

70
00:04:40,917 --> 00:04:45,644
a1、a2、a3 等，并将最低概率命名为 b1、b2、b3 

71
00:04:45,644 --> 00:04:45,960
等。

72
00:04:46,400 --> 00:04:50,654
一般来说，在这个过 程中，我们获取两个不同的数字数组，

73
00:04:50,654 --> 00:04:54,909
翻转第二个数组，然 后将它们排列在各种不同的偏移值处，

74
00:04:54,909 --> 00:04:57,588
获取一堆成对的乘积并 将它们相加，

75
00:04:57,588 --> 00:05:00,740
这就是其中之一思考什么是卷积的基本方法。

76
00:05:00,740 --> 00:05:04,754
因此，为了更准确地说明这一点，通过这个过程，

77
00:05:04,754 --> 00:05:10,228
我们只是生成了看到两个、三 个、四个、一直到 12 的概率，

78
00:05:10,228 --> 00:05:13,695
并且我们通过将一个值列表 a 和另一 

79
00:05:13,695 --> 00:05:16,980
个值混合在一起来获得它们值列表，b。

80
00:05:17,440 --> 00:05:22,219
用行话来说，我们会说这两个序列 的卷积给出了这个新序列，

81
00:05:22,219 --> 00:05:27,340
即 11 个值的新序列，每个值看起来都 像是成对乘积的总和。

82
00:05:27,340 --> 00:05:31,120
如果您愿意，您可以考虑相同操作的另一种 

83
00:05:31,120 --> 00:05:34,144
方法是首先创建所有成对产品的表，

84
00:05:34,144 --> 00:05:36,980
然后沿着所有这些对角线相 加。

85
00:05:37,460 --> 00:05:40,721
同样，这是一种将这两个数字序列混合在一起以获得 

86
00:05:40,721 --> 00:05:42,760
11 个数字的 新序列的方法。

87
00:05:43,240 --> 00:05:46,460
和滑动窗想的操作是一样的，只是换个角度。

88
00:05:47,140 --> 00:05:49,800
对其进行一些注释，您可能会看到这样的写法。

89
00:05:50,220 --> 00:05:55,161
a 和 b 的卷 积（用这个小星号表示）是一个新列表，

90
00:05:55,161 --> 00:05:58,821
该列表的第 n 个元素看起 来像一个和，

91
00:05:58,821 --> 00:06:02,664
并且该和遍历所有不同的索引对 i 和 j，

92
00:06:02,664 --> 00:06:04,860
因此这些索 引等于 n。

93
00:06:05,280 --> 00:06:08,202
这有点拗口，但是例如，如果 n 是 6，

94
00:06:08,202 --> 00:06:11,562
我们要检查的对是 1 和 5、2 和 4、3 

95
00:06:11,562 --> 00:06:15,800
和 3、4 和 2、5 和 1，所有不同的对加起来至 6。

96
00:06:16,620 --> 00:06:20,825
但老实说，无论你怎么写，符号的重要性都比你头脑中 

97
00:06:20,825 --> 00:06:22,340
的视觉效果要重要。

98
00:06:23,280 --> 00:06:26,076
在这里，也许做一个超级简单的例子会有所帮助，

99
00:06:26,076 --> 00:06:29,635
我可 能会问你列表 1, 2, 3 与列表 4, 5, 

100
00:06:29,635 --> 00:06:30,780
6 的卷积是多少。

101
00:06:31,480 --> 00:06:34,137
您可能会想 象将这两个列表都拿出来，

102
00:06:34,137 --> 00:06:37,680
翻转第二个列表，然后从其盖子开 始一直向左移动。

103
00:06:38,180 --> 00:06:40,630
然后对齐的一对值是 1 和 4，

104
00:06:40,630 --> 00:06:43,540
将它们 相乘，这就是我们输出的第一项。

105
00:06:43,960 --> 00:06:47,352
将底部数组向右滑动一个单位，对 齐的对是 

106
00:06:47,352 --> 00:06:50,421
1 和 5、2 和 4，将这些对相乘，

107
00:06:50,421 --> 00:06:54,460
将它们加在一起，得到 13，即输出中的下一个条目。

108
00:06:54,960 --> 00:06:57,709
再把东西滑过来，我们需要 1 乘以 6，

109
00:06:57,709 --> 00:07:01,560
加上 2 乘以 5，再加上 3 乘以 4，正好是 28。

110
00:07:02,020 --> 00:07:06,693
再一张幻灯片，我们得到 2 乘 以 6，加上 3 乘以 5，

111
00:07:06,693 --> 00:07:10,120
得到 27，最后一项看起来像 3 乘以 6。

112
00:07:10,660 --> 00:07:13,956
如果您愿意，您可以调出您最喜欢的编程语言，

113
00:07:13,956 --> 00:07:16,939
以及您最喜 欢的包含各种数值运算的库，

114
00:07:16,939 --> 00:07:18,980
并且您可以确认我没有骗您。

115
00:07:18,980 --> 00:07:22,594
如果将 1、2、3 与 4、5、6 进行卷积，

116
00:07:22,594 --> 00:07:24,480
这确实是您将得到的结果。

117
00:07:25,920 --> 00:07:29,635
我们已经见过一种情况，这是一种自然且理想的操作，

118
00:07:29,635 --> 00:07:33,660
加起来就是概 率分布，另一个常见的例子是移动平均线。

119
00:07:34,080 --> 00:07:36,302
想象一下，您有一个很长的数字 列表，

120
00:07:36,302 --> 00:07:39,760
然后您又取了另一个较小的数字列表，这些数字的总和为 1。

121
00:07:40,100 --> 00:07:42,702
在本例中，我只有一 个包含 5 个值的小列表，

122
00:07:42,702 --> 00:07:44,060
它们都等于 1 5th。

123
00:07:44,060 --> 00:07:49,120
然后，如果我们进行这 个滑动窗口卷积过程，然后闭上眼睛，

124
00:07:49,120 --> 00:07:54,000
扫视一开始发生的情 况，一旦我们较小的值列表与较大的值

125
00:07:54,000 --> 00:07:58,700
列表完全重叠，请考 虑其中的每一项卷积的真正含义是。

126
00:07:59,400 --> 00:08:03,505
在每次迭代中，您所做的是 将数据中的每个值乘以 

127
00:08:03,505 --> 00:08:06,927
1 五分之一，然后将它们全部加在一起 ，

128
00:08:06,927 --> 00:08:10,520
也就是说，您在这个小窗口内取数据的平均值。

129
00:08:11,100 --> 00:08:14,920
总体而言，该过 程为您提供了原始数据的平滑版本，

130
00:08:14,920 --> 00:08:17,944
您可以从不同的小数字列 表开始修改它，

131
00:08:17,944 --> 00:08:22,720
只要该小列表加起来为 1，您仍然可以将其 解释为移动平均的。

132
00:08:23,400 --> 00:08:27,760
在此所示的示例中，移动平均线将给予 中心值更多的权重。

133
00:08:28,420 --> 00:08:30,800
这也会产生数据的平滑版本。

134
00:08:33,140 --> 00:08:38,043
如果你对此进行二维模拟，它会给你一个有趣的算法来模糊给定 

135
00:08:38,043 --> 00:08:38,720
的图像。

136
00:08:38,720 --> 00:08:42,582
我应该说，我即将展示的动画是根据我最初为我与麻省理工学院的 

137
00:08:42,582 --> 00:08:45,801
Jul ia 实验室一起为某个包含图像处理单元的 

138
00:08:45,801 --> 00:08:47,990
OpenCourseWare 课 

139
00:08:47,990 --> 00:08:51,080
程所做的一组讲座的一部分而制作的动画进行了修改。

140
00:08:51,560 --> 00:08:54,411
在那里，我们做了更多的工作 来深入研究所有这些背后的代码，

141
00:08:54,411 --> 00:08:56,280
所以如果您好奇，我会给您留下一些链接。

142
00:08:56,620 --> 00:09:01,120
但回 到这个模糊的例子，发生的事情是我得到了这个小的 

143
00:09:01,120 --> 00:09:05,786
3x3 值网格，它沿着我们的原始图像行进，如果我们放大，

144
00:09:05,786 --> 00:09:08,786
这些值中的 每一个都是 1 9th，

145
00:09:08,786 --> 00:09:13,620
而我正在做的在每次迭代中，将每个 值乘以它所在的相应像素。

146
00:09:13,900 --> 00:09:18,152
当然，在计算机科学中，我们将 颜色视为三个值的小向量，

147
00:09:18,152 --> 00:09:20,200
代表红色、绿色和蓝色分量。

148
00:09:20,560 --> 00:09:25,021
当我将所有这些小值乘以 1 9 并将它们加在一起时，

149
00:09:25,021 --> 00:09:27,767
它会给 出每个颜色通道的平均值，

150
00:09:27,767 --> 00:09:31,200
并且右侧图像的相应像素被定义为该总 和。

151
00:09:31,940 --> 00:09:34,764
当我们对图像上的每个像素执行此操作时，

152
00:09:34,764 --> 00:09:38,035
总体效果是每种像素都 会渗透到其所有邻居中，

153
00:09:38,035 --> 00:09:40,860
这给我们提供了比原始版本更模糊的版本。

154
00:09:41,720 --> 00:09:46,769
用行话来说，我们会说右侧的图像是原始图像与一些值网 

155
00:09:46,769 --> 00:09:47,740
格的卷积。

156
00:09:48,140 --> 00:09:51,831
或者从技术上讲，也许我应该说它是与那个小值网 

157
00:09:51,831 --> 00:09:54,400
格的 180 度旋转版本的卷积。

158
00:09:54,620 --> 00:09:58,704
当网格对称时并不重 要，但值得记住的是，

159
00:09:58,704 --> 00:10:04,014
从纯数学上下文继承的卷 积定义应该始终邀请您考虑翻转

160
00:10:04,014 --> 00:10:05,240
第二个数组。

161
00:10:05,960 --> 00:10:08,530
如果我们稍微修改一下，我们可以通过选择

162
00:10:08,530 --> 00:10:11,100
不同的值网格来获得更优雅的模 糊效果。

163
00:10:11,440 --> 00:10:14,099
在本例中，我有一个 5x5 的小网格，

164
00:10:14,099 --> 00:10:15,780
但区别并不在于它的大小。

165
00:10:15,980 --> 00:10:20,960
如果我们放大，我们会注意到中间的值比边缘的值大得多 ，

166
00:10:20,960 --> 00:10:25,940
这是因为它们都是从钟形曲线（称为高斯分布）中采 样的。

167
00:10:26,800 --> 00:10:31,247
这样，当我们将所有这些值乘以它们所在的相应像素 时，

168
00:10:31,247 --> 00:10:36,380
我们就会为中心像素赋予更多权重，而为边缘像素赋 予更少权重。

169
00:10:36,800 --> 00:10:40,560
正如之前一样，右侧对应的像素被定义为这个总 和。

170
00:10:41,320 --> 00:10:46,092
当我们对每个像素执行此过程时，它会产生模糊 效果，

171
00:10:46,092 --> 00:10:49,720
更真实地模拟镜头失焦或类似情况的概念。

172
00:10:49,900 --> 00:10:53,360
但模糊远不是你可以用这个想法做的唯一事情。

173
00:10:53,800 --> 00:10:58,547
例如，看一下这 个小值网格，其中左侧有一些正数，

174
00:10:58,547 --> 00:11:02,900
右侧有一些负 数，我将分别用蓝色和红色着色。

175
00:11:03,640 --> 00:11:05,981
花点时间看看您是否 可以预测并

176
00:11:05,981 --> 00:11:08,480
理解这将对最终图像产生什么影响。

177
00:11:10,720 --> 00:11:14,716
因此，在这种情况下 ，我只会将图像视为灰度而不是彩色，

178
00:11:14,716 --> 00:11:18,120
因此每个像素仅由一个数字而 不是三个数字表示。

179
00:11:18,440 --> 00:11:23,060
值得注意的一件事是，当我们进行卷积时 ，可能会得到负值。

180
00:11:23,060 --> 00:11:27,071
例如，此时，如果我们放大小网格的 左半部分，

181
00:11:27,071 --> 00:11:30,354
则完全位于黑色像素的顶部，其值为零，

182
00:11:30,354 --> 00:11:35,460
但负 值的右半部分全部位于白色像素的顶部，这将值为 1。

183
00:11:36,180 --> 00:11:39,734
因此，当我们将相应项相乘并将它们加在一起时，

184
00:11:39,734 --> 00:11:43,128
结果将非常负 ，而我用右侧图像显示此结果的

185
00:11:43,128 --> 00:11:46,360
方式是将负值涂成红色，将正值 涂成蓝色。

186
00:11:46,880 --> 00:11:50,351
另一件需要注意的事情是，当你在一个颜色相同的补丁上时，

187
00:11:50,351 --> 00:11:54,080
 所有的东西都会变为零，因为我们的小网格中的值的总和为零。

188
00:11:55,180 --> 00:11:58,998
这与前两个 示例非常不同，前两个示例中我们的小网格的总和为 

189
00:11:58,998 --> 00:12:02,180
1，这让我们将 其解释为移动平均值，因此是模糊的。

190
00:12:03,640 --> 00:12:06,961
总而言之，这个小过程基本 上可以检测当您从

191
00:12:06,961 --> 00:12:09,649
左向右移动时像素值存在变化的地方，

192
00:12:09,649 --> 00:12:13,920
因 此它为您提供了一种从图像中拾取所有垂直边缘的方法。

193
00:12:16,500 --> 00:12:21,335
同样，如果我们旋转该网格，使其随着您从顶部移动到底部而变 

194
00:12:21,335 --> 00:12:26,171
化，这将在所有水平边缘上出现，在我们的小馅饼生物图像的情 

195
00:12:26,171 --> 00:12:29,340
况下，这确实会导致一些漂亮的恶魔眼睛。

196
00:12:30,400 --> 00:12:33,210
顺便说一句，这个较 小的网格通常称为内核，

197
00:12:33,210 --> 00:12:35,887
这里的美妙之处在于，通过选择不同的内核，

198
00:12:35,887 --> 00:12:39,233
您 可以获得不同的图像处理效果，不仅模糊边缘检测，

199
00:12:39,233 --> 00:12:40,840
还可以实现锐化等 效果。

200
00:12:40,840 --> 00:12:44,200
对于那些听说过卷积神经网络的人来说，

201
00:12:44,200 --> 00:12:48,306
其想法是 使用数据来确定内核首先应该是什么，

202
00:12:48,306 --> 00:12:51,480
这取决于神经网络 想要检测的内容。

203
00:12:52,760 --> 00:12:55,520
我应该提出的另一件事是输出的长度 。

204
00:12:55,820 --> 00:12:59,912
对于像移动平均这样的示例，您可能只想考虑两个窗口 

205
00:12:59,912 --> 00:13:03,514
彼此完全对齐时的术语，或者在图像处理示例中，

206
00:13:03,514 --> 00:13:07,280
您可能希 望最终输出具有与原始大小相同的大小。

207
00:13:07,280 --> 00:13:11,730
现在，卷积作为一 种纯数学运算总是会产生一个比您开始使用的

208
00:13:11,730 --> 00:13:16,180
两个数组更大的数组 ，至少假设其中一个数组的长度不为 1。

209
00:13:16,720 --> 00:13:19,507
只需知道，在某些 计算机科学环境中，

210
00:13:19,507 --> 00:13:21,520
您经常想要故意截断该输出。

211
00:13:24,720 --> 00:13:28,541
另一件值得强调的事情是，在计算机科学背景下，

212
00:13:28,541 --> 00:13:32,885
在让它跨越 原始内核之前翻转该内核的概念通常感觉非

213
00:13:32,885 --> 00:13:37,923
常奇怪并且没有必 要，但再次注意，这是从纯数学背景继承的，

214
00:13:37,923 --> 00:13:42,440
就像我们一样从 可能性来看，这是一件非常自然的事情。

215
00:13:43,020 --> 00:13:46,170
实际上，我可以向您 展示另一个纯数学示例，

216
00:13:46,170 --> 00:13:48,570
即使是程序员也应该关心这个示例，

217
00:13:48,570 --> 00:13:52,020
因 为它为更快的算法来计算所有这些打开了大门。

218
00:13:52,620 --> 00:13:56,337
为了设置我所说的更 快的意思，让我返回并再次拉起一些 

219
00:13:56,337 --> 00:13:59,780
python，我将创建两个不同的相 对较大的数组。

220
00:13:59,940 --> 00:14:03,631
每个都有十万个随机元素，我将评估 

221
00:14:03,631 --> 00:14:07,540
numpy 库中卷积函数的运行时间。

222
00:14:08,180 --> 00:14:12,435
在本例中， 它运行多次不同的迭代，尝试找到平均值，

223
00:14:12,435 --> 00:14:16,520
在这台计算机上 看起来至少平均值为 4。87秒。

224
00:14:16,960 --> 00:14:20,336
相比之下，如果我使用 scipy 库中名为 

225
00:14:20,336 --> 00:14:24,327
fftconvolve 的不同函数，它是相同的函数，

226
00:14:24,327 --> 00:14:28,778
只是实现方式不同 ，只需要 4 个函数。平均为 3 毫秒，

227
00:14:28,778 --> 00:14:30,160
提高了三个数量级。

228
00:14:30,160 --> 00:14:34,731
同样，即使它以不同的名称运行，它也提供与其他卷积 

229
00:14:34,731 --> 00:14:39,120
函数相同的输出，它只是以更聪明的方式做一些事情。

230
00:14:42,200 --> 00:14:47,143
还记得我在概率示例中说过的另一种思考卷积的方法是 

231
00:14:47,143 --> 00:14:52,680
创建所有成对乘积的表，然后沿对角线将这些成对乘 积相加。

232
00:14:53,660 --> 00:14:56,484
当然，当你将两个不同的数字列表进行卷积时，

233
00:14:56,484 --> 00:14:59,040
概 率没有什么特定的，你可以这样思考。

234
00:14:59,040 --> 00:15:02,193
使用所有成对乘积创建 这种乘法表，

235
00:15:02,193 --> 00:15:06,460
然后沿对角线的每个和对应于您的最终输出 之一。

236
00:15:07,600 --> 00:15:12,800
这种观点特别自然的一种情况是当您将两个多项式 相乘时。

237
00:15:13,300 --> 00:15:18,178
例如，让我使用已有的小网格，将顶部项替换为 1、2x 

238
00:15:18,178 --> 00:15:23,600
和 3x 平方，并将其他项替换为 4、5x 和 6x 平方。

239
00:15:24,000 --> 00:15:26,354
现在考虑一下当我们在两个列表之间创建

240
00:15:26,354 --> 00:15:28,840
所有这些不同的成对乘积时意味 着什么。

241
00:15:29,040 --> 00:15:34,694
你所做的本质上是展开我写下的两个多项式的 完整乘积，

242
00:15:34,694 --> 00:15:40,132
然后当你沿着对应于收集所有相似项的对角 线相加时，

243
00:15:40,132 --> 00:15:46,440
这非常整齐地展开多项式并收集相似项正 是与卷积相同的过程。

244
00:15:47,740 --> 00:15:50,262
但这使我们能够做一些非常酷的事情，

245
00:15:50,262 --> 00:15:52,340
 因为想想我们在这里所说的。

246
00:15:52,340 --> 00:15:57,402
我们的意思是，如果你采用两个不同的 函数并将它们相乘，

247
00:15:57,402 --> 00:16:00,965
这是一个简单的逐点运算，这与你首先从 

248
00:16:00,965 --> 00:16:06,402
每个函数中提取系数（假设它们是多项式）然后对这些函数进行 

249
00:16:06,402 --> 00:16:08,840
卷积是一样的两个系数列表。

250
00:16:09,620 --> 00:16:14,423
有趣的是，卷积在原则上感觉 比简单的乘法复杂得多，

251
00:16:14,423 --> 00:16:18,074
我不仅仅意味着在概念上它们 更难思考，

252
00:16:18,074 --> 00:16:22,109
我的意思是在计算上它需要更多的步骤来执行 

253
00:16:22,109 --> 00:16:25,760
卷积而不是执行两个不同列表的逐点乘积。

254
00:16:26,319 --> 00:16:29,589
例如，假设我 给了你两个非常大的多项式，

255
00:16:29,589 --> 00:16:32,205
每个多项式都有一百个不同的系数，

256
00:16:32,205 --> 00:16:35,801
那么如果 你将它们相乘的方式是展开这个乘积，

257
00:16:35,801 --> 00:16:40,215
你知道填充整个 100 x 1 00 的成对乘积网格，

258
00:16:40,215 --> 00:16:43,648
这需要你执行 10,000 种不同的产品，

259
00:16:43,648 --> 00:16:46,754
 然后当您沿着对角线收集所有相似项时，

260
00:16:46,754 --> 00:16:49,860
这是另一组大约 10,000 次操作。

261
00:16:50,700 --> 00:16:53,912
更一般地说，在行话中，我们会说该算法是 

262
00:16:53,912 --> 00:16:58,570
O of n 平 方，这意味着对于两个大小为 n 的列表，

263
00:16:58,570 --> 00:17:01,140
操作数量与 n 的平方成正比 。

264
00:17:01,820 --> 00:17:05,831
另一方面，如果我根据输出来考虑两个多项式，

265
00:17:05,831 --> 00:17:09,269
例如在一些输入处对它们的值进行采样，

266
00:17:09,269 --> 00:17:13,281
那么将它们相乘只需要与样本数一样多的运算，

267
00:17:13,281 --> 00:17:17,101
因为这又是一个逐点运算，并且对于多项式，

268
00:17:17,101 --> 00:17:20,540
您只需要有限多个样本能够恢复系数。 

269
00:17:20,540 --> 00:17:25,060
例如，两个输出足以唯一地指定线性多项式。

270
00:17:25,660 --> 00:17:29,400
三个输出足以唯一地指定二次多项式。

271
00:17:29,640 --> 00:17:33,360
一般来说，如果您知道 n 个不同的输出，

272
00:17:33,360 --> 00:17:37,640
就足以唯一地指定具有 n 个不同系数的多项式。

273
00:17:37,780 --> 00:17:40,720
或者，如果您愿意，我们可以用方程组的语言来表达它。

274
00:17:41,200 --> 00:17:43,460
想象一下，我告诉你我有一些多项式，

275
00:17:43,460 --> 00:17:46,520
但我没有告诉你系数是什么，这些对你来说是个谜。

276
00:17:46,700 --> 00:17:50,800
在我们的示例中，您可能会认为这是我们正在尝试找出的产品。

277
00:17:50,800 --> 00:17:54,485
然后假设我说，如果您输入各种不同的输入（例如 

278
00:17:54,485 --> 00:17:58,972
0、1、2、3 等等），我会告诉您该多项式的输出是什么，

279
00:17:58,972 --> 00:18:03,460
并且我给您足够的信息，以便您有尽可能多的方程你有未知数。

280
00:18:04,140 --> 00:18:07,340
它甚至恰好是一个线性方程组，所以这很好。

281
00:18:07,780 --> 00:18:10,900
至少原则上，这应该足以恢复系数。

282
00:18:11,740 --> 00:18:16,474
因此，粗略的算法概述是，每当您想要对两个数字列表进行卷积时，

283
00:18:16,474 --> 00:18:19,000
您都将它们视为两个多项式的系数。

284
00:18:19,420 --> 00:18:24,706
您以足够的输出对这些多项式进行采样，将这些样本逐点相乘，

285
00:18:24,706 --> 00:18:30,182
然后求解系统以恢复系数，作为找到卷积的一种偷偷摸摸的后门方

286
00:18:30,182 --> 00:18:30,560
法。

287
00:18:31,420 --> 00:18:34,380
至少到目前为止我已经说过了，你们中的一些人可

288
00:18:34,380 --> 00:18:37,340
以合理地抱怨“格兰特，这是一个愚蠢的计划”。

289
00:18:37,580 --> 00:18:42,347
因为首先，仅计算我们已知的多项式之一的所有这

290
00:18:42,347 --> 00:18:46,031
些样本就已经进行了 n 次方运算，

291
00:18:46,031 --> 00:18:52,100
更不用说解决该系统在计算上肯定会像首先进行卷积一样困难。

292
00:18:52,600 --> 00:18:56,047
所以，就像，乘法和卷积之间肯定有这种联系，

293
00:18:56,047 --> 00:19:00,480
但所有的复杂性都发生在从一个观点到另一个观点的转换中。

294
00:19:01,600 --> 00:19:04,508
但有一个技巧，那些了解傅立叶变换和 

295
00:19:04,508 --> 00:19:07,740
FFT 算法的人可能会明白这是怎么回事。

296
00:19:07,740 --> 00:19:09,960
如果您不熟悉这些主题，那么我接下来

297
00:19:09,960 --> 00:19:12,180
要说的内容可能看起来完全出乎意料。

298
00:19:12,260 --> 00:19:14,943
只要知道，在数学中你可以走一些特定的道路，

299
00:19:14,943 --> 00:19:16,860
这使得这更像是一个预期的步骤。

300
00:19:17,720 --> 00:19:20,360
基本上，我们的想法是我们在这里有选择的自由。

301
00:19:20,540 --> 00:19:24,491
如果您选择对一组非常特别选择的复数进行评估，

302
00:19:24,491 --> 00:19:29,700
而不是对任意一组输入（如 0、1、2、3 等等）进行评估。

303
00:19:30,240 --> 00:19:34,840
特别是那些均匀分布在单位圆上的，即所谓的单位根。

304
00:19:35,200 --> 00:19:36,880
这为我们提供了一个更友好的系统。

305
00:19:38,360 --> 00:19:43,474
基本思想是，通过找到一个数字，使其幂落入这种循环模式，

306
00:19:43,474 --> 00:19:48,777
这意味着我们生成的系统将在您计算的不同项中具有大量冗余，

307
00:19:48,777 --> 00:19:54,460
并且通过聪明地了解如何计算利用这种冗余，您可以节省大量工作。

308
00:19:56,020 --> 00:20:02,280
我编写的这组输出有一个特殊的名称，称为系数的离散傅立叶变换。

309
00:20:02,500 --> 00:20:05,234
如果你想了解更多，我实际上为 Julia 

310
00:20:05,234 --> 00:20:09,140
麻省理工学院的同一个课程做了另一场关于离散傅里叶变换的讲座。

311
00:20:09,220 --> 00:20:12,887
在频道 reducible 上还有一个非常棒的视频，

312
00:20:12,887 --> 00:20:17,120
讨论了快速傅立叶变换，这是一种可以更快地计算这些变换的算法。

313
00:20:17,480 --> 00:20:19,762
另外，Veritasium 最近制作了一个关于 

314
00:20:19,762 --> 00:20:21,760
FFT 的非常好的视频，因此您有很多选择。

315
00:20:22,260 --> 00:20:24,660
这种快速算法确实是我们的重点。

316
00:20:25,120 --> 00:20:29,920
同样，由于所有这些冗余，存在一种从系数到所有这些输出的方法，

317
00:20:29,920 --> 00:20:32,800
其中不是按 n 平方运算的顺序进行，

318
00:20:32,800 --> 00:20:36,320
而是按 n 乘以 n 运算的对数的顺序进行，

319
00:20:36,320 --> 00:20:39,200
这要多得多当你扩展到大列表时会更好。

320
00:20:39,660 --> 00:20:42,540
重要的是，这种 fft 算法是双向的。

321
00:20:42,700 --> 00:20:45,480
它还可以让您从输出转到系数。

322
00:20:46,220 --> 00:20:49,060
因此，将所有内容放在一起，让我们回顾一下我们的算法大纲。

323
00:20:49,420 --> 00:20:53,616
现在我们可以说，每当你给定两个一长串数字并且你想

324
00:20:53,616 --> 00:20:58,337
要对它们进行卷积时，首先计算它们每个的快速傅立叶变换，

325
00:20:58,337 --> 00:21:02,883
在你的脑海中你可以认为将它们视为它们是多项式的系数，

326
00:21:02,883 --> 00:21:06,380
并在一组非常特别选择的点上对其进行评估。

327
00:21:06,899 --> 00:21:10,190
然后将刚刚获得的两个结果逐点相乘，

328
00:21:10,190 --> 00:21:13,867
这既好又快，然后进行快速傅立叶逆变换，

329
00:21:13,867 --> 00:21:18,900
这给了您计算我们正在寻找的卷积的偷偷摸摸的后门方法。

330
00:21:19,040 --> 00:21:22,240
但这次只涉及 O of n log n 操作。

331
00:21:23,139 --> 00:21:24,740
这对我来说真的很酷！

332
00:21:25,120 --> 00:21:29,521
卷积出现的这种非常具体的上下文，将两个多项式相乘，

333
00:21:29,521 --> 00:21:34,100
为一种与其他可能出现卷积的地方相关的算法打开了大门。

334
00:21:34,180 --> 00:21:39,000
如果您想添加概率分布，请进行一些大型图像处理，无论它是什么。

335
00:21:39,220 --> 00:21:43,350
我只是认为这是一个很好的例子，说明为什么当你看到数学中的某

336
00:21:43,350 --> 00:21:47,480
些运算或概念出现在许多看似不相关的领域时，你应该感到兴奋。

337
00:21:48,480 --> 00:21:51,500
如果你想要做一点作业，这里有一些值得思考的有趣的事情。

338
00:21:51,720 --> 00:21:55,264
解释为什么当你将两个不同的数字相乘时，

339
00:21:55,264 --> 00:22:00,301
只是我们在小学学习的普通乘法，你所做的基本上是这些数字

340
00:22:00,301 --> 00:22:01,980
的数字之间的卷积。

341
00:22:02,500 --> 00:22:06,460
增加了一些进位等步骤，但核心步骤是卷积。

342
00:22:07,280 --> 00:22:12,214
鉴于快速算法的存在，这意味着如果你有两个非常大的整数，

343
00:22:12,214 --> 00:22:17,514
那么存在一种比我们在小学学到的方法更快的方法来找到它们的乘

344
00:22:17,514 --> 00:22:17,880
积。

345
00:22:18,140 --> 00:22:20,820
这不需要 O of n 平方运算，

346
00:22:20,820 --> 00:22:24,920
只需要 O of n log n，这甚至感觉不可能。

347
00:22:25,380 --> 00:22:30,840
问题是，在这在实践中真正有用之前，你的数字必须绝对是巨大的。

348
00:22:31,220 --> 00:22:35,340
不过，这样的算法存在还是很酷的。

349
00:22:35,340 --> 00:22:39,640
接下来，我们将把注意力转向连续情况，特别关注概率分布。

