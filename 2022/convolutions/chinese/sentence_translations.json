[
 {
  "input": "Suppose I give you two different lists of numbers, or maybe two different functions, and I ask you to think of all the ways you might combine those two lists to get a new list of numbers, or combine the two functions to get a new function.",
  "translatedText": "假设有两个不同的数组 或两个不同的函数 让你想出各种运算方式 来把两个数组组合在一起 得到新数组 或者把两个函数组合起来  得到新函数",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 0.0,
  "end": 11.32
 },
 {
  "input": "Maybe one simple way that comes to mind is to simply add them together term by term.",
  "translatedText": "最简单的方法可能就是 一个个地把他们加起来",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 12.12,
  "end": 16.76
 },
 {
  "input": "Likewise with the functions, you can add all the corresponding outputs.",
  "translatedText": "同样 对函数来说则是把结果对应相加",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 17.16,
  "end": 19.92
 },
 {
  "input": "In a similar vein, you could also multiply the two lists term by term and do the same thing with the functions.",
  "translatedText": "类似的 你也可以把两个数组中的数逐个相乘 对函数也是如此",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 20.54,
  "end": 25.68
 },
 {
  "input": "But there's another kind of combination just as fundamental as both of those, but a lot less commonly discussed, known as a convolution.",
  "translatedText": "但有其实另一种组合方式 和之前提过的方式一样基础 但讨论得不多 它被称作“卷积”",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 26.36,
  "end": 33.5
 },
 {
  "input": "But unlike the previous two cases, it's not something that's merely inherited from an operation you can do to numbers.",
  "translatedText": "但和前面两种组合方式不同的是 它并非来源于某种数字运算",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 34.08,
  "end": 39.82
 },
 {
  "input": "It's something genuinely new for the context of lists of numbers or combining functions.",
  "translatedText": "而是一种用来组合数组和函数的新方法",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 39.98,
  "end": 44.7
 },
 {
  "input": "They show up all over the place, they are ubiquitous in image processing, it's a core construct in the theory of probability, they're used a lot in solving differential equations, and one context where you've almost certainly seen it, if not by this name, is multiplying two polynomials together.",
  "translatedText": "这一方法随处可见 在数字图像处理中尤为明显 它是概率论中的一个核心结构 在求解微分方程时被大量使用 而在多项式相乘的情形中  你一定见过它 只是可能不叫这个名字",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 45.32,
  "end": 60.24
 },
 {
  "input": "As someone in the business of visual explanations, this is an especially great topic, because the formulaic definition in isolation and without context can look kind of intimidating, but if we take the time to really unpack what it's saying, and before that actually motivate why you would want something like this, it's an incredibly beautiful operation.",
  "translatedText": "对一个用可视化方式传播知识的人来说 这是一个非常好的选题 因为光看没有上下文的公式化定义 卷积是会有点唬人 但是如果我告诉你卷积好处都有啥 再给你好好剖析下它的定义 你就会发现这个运算十分美妙",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 60.74,
  "end": 78.32
 },
 {
  "input": "And I have to admit, I actually learned a little something while putting together the visuals for this project.",
  "translatedText": "不得不承认 在制作这期视频的过程中 我自己也切实地学到了一些知识",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 78.96,
  "end": 83.54
 },
 {
  "input": "In the case of convolving two different functions, I was trying to think of different ways you might picture what that could mean, and with one of them I had a little bit of an aha moment for why it is that normal distributions play the role that they do in probability, why it's such a natural shape for a function.",
  "translatedText": "在讲到对两个函数进行卷积的例子时 我在思考用不同的方式将其可视化 其中一个方式 让我豁然开朗 我一下子明白了  为何正态分布在概率论中如此重要 它的函数图像的形状为何如此自然",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 83.54,
  "end": 98.52
 },
 {
  "input": "But I'm getting ahead of myself, there's a lot of setup for that one.",
  "translatedText": "扯远了 在讲这个之前还有很多准备工作要做",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 99.02,
  "end": 101.52
 },
 {
  "input": "In this video, our primary focus is just going to be on the discrete case, and in particular building up to a very unexpected but very clever algorithm for computing these.",
  "translatedText": "在这个视频中我们主要关注离散的卷积  逐步构建出一种让人拍案叫绝的计算方法",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 101.84,
  "end": 110.26
 },
 {
  "input": "And I'll pull out the discussion for the continuous case into a second part.",
  "translatedText": "而连续的卷积我们则放在下期视频里来讨论",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 110.26,
  "end": 114.48
 },
 {
  "input": "It's very tempting to open up with the image processing examples, since they're visually the most intriguing, but there are a couple bits of finickiness that make the image processing case less representative of convolutions overall, so instead let's kick things off with probability, and in particular one of the simplest examples that I'm sure everyone here has thought about at some point in their life, which is rolling a pair of dice and figuring out the chances of seeing various different sums.",
  "translatedText": "虽然用数字图像处理的例子作为开篇听起来很不错 毕竟它在可视方面是最能引起人兴趣的 但在一些细微之处 图像处理的例子不太能展现卷积的全貌 所以我们还是从概率论开始吧 有这么一个最最简单的例子 相信各位观众或早或晚都曾听过 就是掷两枚骰子 计算两枚骰子的各个点数和的出现的概率",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 118.58,
  "end": 141.5
 },
 {
  "input": "And you might say, not a problem, not a problem.",
  "translatedText": "你可能会说 就这",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 142.46,
  "end": 144.46
 },
 {
  "input": "Each of your two dice has six different possible outcomes, which gives us a total of 36 distinct possible pairs of outcomes, and if we just look through them all we can count up how many pairs have a given sum.",
  "translatedText": "每个骰子都有 6 种不同的结果 总共就是六六三十六种配对可能 我们一个个数一遍 就可以数出每个和有多少种组合",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 144.68,
  "end": 155.86
 },
 {
  "input": "And arranging all the pairs in a grid like this, one pretty nice thing is that all of the pairs that have a constant sum are visible along one of these different diagonals.",
  "translatedText": "把所有的组合这样填在表格里 有个很妙的事情是 相同点数和的组合 都排在同一条对角线上",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 156.6,
  "end": 165.44
 },
 {
  "input": "So simply counting how many exist on each of those diagonals will tell you how likely you are to see a particular sum.",
  "translatedText": "所以只要数出对角线上面有多少个组合 就可以知道 出现某个点数和的概率是多少",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 165.44,
  "end": 172.12
 },
 {
  "input": "And I'd say, very good, very good, but can you think of any other ways that you might visualize the same question?",
  "translatedText": "我会说：还不赖  但你能换一种方式展现这个问题吗",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 173.22,
  "end": 178.66
 },
 {
  "input": "Other images that can come to mind to think of all the distinct pairs that have a given sum?",
  "translatedText": "有没有想到其它 数出某个加和的所有点数组合方式的画面",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 179.3,
  "end": 184.06
 },
 {
  "input": "And maybe one of you raises your hand and says, yeah, I've got one.",
  "translatedText": "可能有聪明的观众想说「我有想法了」",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 184.86,
  "end": 187.98
 },
 {
  "input": "Let's say you picture these two different sets of possibilities each in a row, but you flip around that second row.",
  "translatedText": "把两枚骰子的所有可能结果 分别放到一行 然后把第二行翻转",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 188.28,
  "end": 193.76
 },
 {
  "input": "That way all of the different pairs which add up to seven line up vertically like this.",
  "translatedText": "这样所有点数和为 7 的组合 就会这样纵向对齐",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 193.76,
  "end": 198.76
 },
 {
  "input": "And if we slide that bottom row all the way to the right, then the unique pair that adds up to two, the snake eyes, are the only ones that align, and if I schlunk that over one unit to the right, the pairs which align are the two different pairs that add up to three.",
  "translatedText": "如果我们把最下面的一行一直向右滑动，那么唯一对齐的就是加起来为 2 的那对蛇眼，如果我把它向右滑动一个单位，那么对齐的就是加起来为 3 的那两对不同的蛇眼。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 199.36,
  "end": 212.08
 },
 {
  "input": "And in general, different offset values of this lower array, which remember I had to flip around first, reveal all the distinct pairs that have a given sum.",
  "translatedText": "总的来说 红色数组的不同偏移量 （别忘了下面这行是翻转过的） 对应了两个骰子的点数加和",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 212.88,
  "end": 221.46
 },
 {
  "input": "As far as probability questions go, this still isn't especially interesting because all we're doing is counting how many outcomes there are in each of these categories.",
  "translatedText": "就概率问题而言，这仍然不是特别有趣，因为我们所做的只是计算每个类别中有多少种结果。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 224.82,
  "end": 232.64
 },
 {
  "input": "But that is with the implicit assumption that there's an equal chance for each of these faces to come up.",
  "translatedText": "但这里面其实隐藏了一个假设 就是骰子的每面向上的概率是相同的",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 232.98,
  "end": 238.12
 },
 {
  "input": "But what if I told you I have a special set of dice that's not uniform?",
  "translatedText": "如果我现在改用非标的骰子",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 238.36,
  "end": 241.62
 },
 {
  "input": "Maybe the blue die has its own set of numbers describing the probabilities for each face coming up, and the red die has its own unique distinct set of numbers.",
  "translatedText": "用一个数组来描述蓝骰子每面向上的概率 同样地 红骰子也有这样一个数组",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 242.06,
  "end": 249.76
 },
 {
  "input": "In that case, if you wanted to figure out, say, the probability of seeing a 2, you would multiply the probability that the blue die is a 1 times the probability that the red die is a 1.",
  "translatedText": "在这种情况下，如果您想计算出看到 2 的概率，比如说，您可以用蓝色骰子是 1 的概率乘以红色骰子是 1 的概率。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 250.3,
  "end": 259.86
 },
 {
  "input": "And for the chances of seeing a 3, you look at the two distinct pairs where that's possible, and again multiply the corresponding probabilities and then add those two products together.",
  "translatedText": "至于出现 3 的几率，您可以查看有可能出现 3 的两个不同配对，然后再次乘以相应的概率，再将这两个乘积相加。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 260.28,
  "end": 269.68
 },
 {
  "input": "Similarly, the chances of seeing a 4 involves multiplying together three different pairs of possibilities and adding them all together.",
  "translatedText": "同样，看到 \"4 \"的几率也是将三对不同的可能性相乘再相加。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 270.1,
  "end": 276.82
 },
 {
  "input": "And in the spirit of setting up some formulas, let's name these top probabilities a 1, a 2, a 3, and so on, and name the bottom ones b 1, b 2, b 3, and so on.",
  "translatedText": "本着建立一些公式的精神，让我们把上面的概率命名为 a 1、a 2、a 3 等，把下面的概率命名为 b 1、b 2、b 3 等。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 276.82,
  "end": 285.96
 },
 {
  "input": "And in general, this process where we're taking two different arrays of numbers, flipping the second one around, and then lining them up at various different offset values, taking a bunch of pairwise products and adding them up, that's one of the fundamental ways to think about what a convolution is.",
  "translatedText": "一般来说，在这个过程中，我们需要两个不同的数字数组，将第二个数组翻转，然后在不同的偏移值处将它们排成一排，取一堆成对的乘积并将它们相加，这就是思考卷积的基本方法之一。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 286.4,
  "end": 301.62
 },
 {
  "input": "So just to spell it out a little more exactly, through this process, we just generated probabilities for seeing 2, 3, 4, on and on up to 12, and we got them by mixing together one list of values, a, and another list of values, b.",
  "translatedText": "因此，为了更准确地说明这一点，通过这个过程，我们刚刚生成了看到 2、3、4 直至 12 的概率，而我们是通过将一列值 a 和另一列值 b 混合在一起得到这些概率的。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 304.86,
  "end": 316.98
 },
 {
  "input": "In the lingo, we'd say the convolution of those two sequences gives us this new sequence, the new sequence of 11 values, each of which looks like some sum of pairwise products.",
  "translatedText": "说得专业一点就是 两组数的卷积生成了新的这组数 新的数列包含 11 个值 每个值都是两数组中若干数对之积的加和",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 317.44,
  "end": 327.34
 },
 {
  "input": "If you prefer, another way you could think about the same operation is to first create a table of all the pairwise products, and then add up along all these diagonals.",
  "translatedText": "另一种思考卷积的方式是 列一个表格 计算各个组合的乘积 然后沿着各个对角线相加",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 327.34,
  "end": 336.98
 },
 {
  "input": "Again, that's a way of mixing together these two sequences of numbers to get us a new sequence of 11 numbers.",
  "translatedText": "就把两组数混合了起来 得到了一组 11 个数",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 337.46,
  "end": 342.76
 },
 {
  "input": "It's the same operation as the sliding windows thought, just another perspective.",
  "translatedText": "这个做法和滑动数列类似 只是换了一种思考方式",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 343.24,
  "end": 346.46
 },
 {
  "input": "Putting a little notation to it, here's how you might see it written down.",
  "translatedText": "用上一些符号就可以写成这样",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 347.14,
  "end": 349.8
 },
 {
  "input": "The convolution of a and b, denoted with this little asterisk, is a new list, and the nth element of that list looks like a sum, and that sum goes over all different pairs of indices, i and j, so that the sum of those indices is equal to n.",
  "translatedText": "A 和 B 的卷积的符号是「*」 其结果是一个列表 它的第 n 项定义为  把下标 i j 之和为 n 的诸元素的乘积累加起来",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 350.22,
  "end": 364.86
 },
 {
  "input": "It's kind of a mouthful, but for example, if n was 6, the pairs we're going over are 1 and 5, 2 and 4, 3 and 3, 4 and 2, 5 and 1, all the different pairs that add up to 6.",
  "translatedText": "这可能有点啰嗦 但我还是要举个例子 如果 n=6 i 和 j 的组合 (i, j) 就是 (1, 5) (2, 4) (3, 3) (4, 2) (5, 1) 这些组合加起来都是 6",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 365.28,
  "end": 375.8
 },
 {
  "input": "But honestly, however you write it down, the notation is secondary in importance to the visual you might hold in your head for the process.",
  "translatedText": "但是老实说 不管你怎么写 符号在脑中留下的印象都不会太深",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 376.62,
  "end": 382.34
 },
 {
  "input": "Here, maybe it helps to do a super simple example, where I might ask you what's the convolution of the list 1, 2, 3 with the list 4, 5, 6.",
  "translatedText": "在这里，也许做一个超级简单的例子会有帮助，我可以问你列表 1、2、3 与列表 4、5、6 的卷积是多少。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 383.28,
  "end": 390.78
 },
 {
  "input": "You might picture taking both of these lists, flipping around that second one, and then starting with its lid all the way over to the left.",
  "translatedText": "你就可以想象这两个数组并排放着 翻转第二个 然后把它（尾部）滑到最左边",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 391.48,
  "end": 397.68
 },
 {
  "input": "Then the pair of values which align are 1 and 4, multiply them together, and that gives us our first term of our output.",
  "translatedText": "这时候对齐的就只有 1 和 4 把它们乘在一起得到输出的第一项",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 398.18,
  "end": 403.54
 },
 {
  "input": "Slide that bottom array one unit to the right, the pairs which align are 1, 5 and 2 and 4, multiply those pairs, add them together, and that gives us 13, the next entry in our output.",
  "translatedText": "将底部数组向右滑动一个单位，对齐的数对是 1、5 和 2、4，将这些数对相乘，再相加，就得到了 13，也就是我们输出的下一个条目。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 403.96,
  "end": 414.46
 },
 {
  "input": "Slide things over once more, and we'll take 1 times 6 plus 2 times 5 plus 3 times 4, which happens to be 28.",
  "translatedText": "再滑动一次，我们取 1 乘以 6 再乘以 2 乘以 5 再乘以 3 乘以 4，刚好是 28。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 414.96,
  "end": 421.56
 },
 {
  "input": "One more slide and we get 2 times 6 plus 3 times 5, and that gives us 27.",
  "translatedText": "再滑动一次，我们就得到了 2 乘以 6 再乘以 3 乘以 5，结果是 27。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 422.02,
  "end": 427.02
 },
 {
  "input": "And finally the last term will look like 3 times 6.",
  "translatedText": "最后一个词看起来就像 3 乘以 6。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 427.5,
  "end": 430.12
 },
 {
  "input": "If you'd like, you can pull up whatever your favorite programming language is and your favorite library that includes various numerical operations, and you can confirm I'm not lying to you.",
  "translatedText": "如果你愿意，可以调出你最喜欢的编程语言和你最喜欢的包含各种数字运算的库，你就可以确认我没有骗你。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 430.66,
  "end": 438.98
 },
 {
  "input": "If you take the convolution of 1, 2, 3 against 4, 5, 6, this is indeed the result that you'll get.",
  "translatedText": "如果将 1、2、3 与 4、5、6 进行卷积，就会得到这样的结果。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 438.98,
  "end": 444.48
 },
 {
  "input": "We've seen one case where this is a natural and desirable operation, adding up to probability distributions, and another common example would be a moving average.",
  "translatedText": "我们已经在求和得出概率分布的例子中 看到了这个运算是多么的自然和美妙 而另一个常见例子是滑动平均",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 445.92,
  "end": 453.66
 },
 {
  "input": "Imagine you have some long list of numbers, and you take another smaller list of numbers that all add up to 1.",
  "translatedText": "假设有一个长数组 和另一个所有数之和为 1 的短数组",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 454.08,
  "end": 459.76
 },
 {
  "input": "In this case, I just have a little list of 5 values and they're all equal to 1 5th.",
  "translatedText": "在这种情况下，我只有一个包含 5 个值的小列表，它们都等于 1 5。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 460.1,
  "end": 464.06
 },
 {
  "input": "Then if we do this sliding window convolution process, and kind of close our eyes and sweep under the rug what happens at the very beginning of it, once our smaller list of values entirely overlaps with the bigger one, think about what each term in this convolution really means.",
  "translatedText": "接下来 如果我们重复这个滑动窗口卷积的过程 （最开始窗口出界的问题你就当没看见） 当短数组和长数组完全重叠时 思考下卷积的每项代表着什么",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 464.06,
  "end": 478.7
 },
 {
  "input": "At each iteration, what you're doing is multiplying each of the values from your data by 1 5th and adding them all together, which is to say you're taking an average of your data inside this little window.",
  "translatedText": "在每次迭代时，你要做的是将数据中的每个值乘以 1 5，然后将它们加在一起，也就是说，你要取这个小窗口内数据的平均值。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 479.4,
  "end": 490.52
 },
 {
  "input": "Overall, the process gives you a smoothed out version of the original data, and you could modify this starting with a different little list of numbers, and as long as that little list all adds up to 1, you can still interpret it as a moving average.",
  "translatedText": "总的来说 这个过程给了你一个原数据的平滑版本 你可以修改它  使其从一个不同的短数组开始 只要短数组之和还是 1 你就仍可以把它解释为滑动平均",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 491.1,
  "end": 502.72
 },
 {
  "input": "In the example shown here, that moving average would be giving more weight towards the central value.",
  "translatedText": "在这个例子中 滑动平均会给中间值更大的权重",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 503.4,
  "end": 507.76
 },
 {
  "input": "This also results in a smoothed out version of the data.",
  "translatedText": "其结果也是原数据的平滑版本",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 508.42,
  "end": 510.8
 },
 {
  "input": "If you do kind of a two-dimensional analog of this, it gives you a fun algorithm for blurring a given image.",
  "translatedText": "如果你在二维上进行类似的操作 就会得到一个把图片变模糊的有趣方法",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 513.14,
  "end": 518.72
 },
 {
  "input": "And I should say the animations I'm about to show are modified from something I originally made for part of a set of lectures I did with the Julia lab at MIT for a certain open courseware class that included an image processing unit.",
  "translatedText": "我想说的是，我接下来要展示的动画，是我在麻省理工学院朱莉娅实验室为一门公开课制作的，其中包括一个图像处理单元。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 518.72,
  "end": 531.08
 },
 {
  "input": "There we did a little bit more to dive into the code behind all of this, so if you're curious, I'll leave you some links.",
  "translatedText": "我们还做了一些更深入的代码研究，如果你好奇的话，我可以给你留下一些链接。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 531.56,
  "end": 536.28
 },
 {
  "input": "But focusing back on this blurring example, what's going on is I've got this little 3x3 grid of values that's marching along our original image, and if we zoom in, each one of those values is 1 9th, and what I'm doing at each iteration is multiplying each of those values by the corresponding pixel that it sits on top of.",
  "translatedText": "讲回到模糊图片的这个例子上 我们在做的事是 用一个 3×3 的网格沿着原图像移动 放大后  每个数都是 1/9 在每次迭代的时候 将这些数值乘以它底下对应的像素值",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 536.62,
  "end": 553.62
 },
 {
  "input": "And of course in computer science, we think of colors as little vectors of three values, representing the red, green, and blue components.",
  "translatedText": "当然，在计算机科学中，我们认为颜色是由红、绿、蓝三个数值组成的小矢量。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 553.9,
  "end": 560.2
 },
 {
  "input": "When I multiply all these little values by 1 9th and I add them together, it gives us an average along each color channel, and the corresponding pixel for the image on the right is defined to be that sum.",
  "translatedText": "把每个向量都乘以 1/9 然后求和 就得到了每个颜色通道的平均值 那么右图中对应的像素就是这个加和",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 560.56,
  "end": 571.2
 },
 {
  "input": "The overall effect, as we do this for every single pixel on the image, is that each one kind of bleeds into all of its neighbors, which gives us a blurrier version than the original.",
  "translatedText": "对每个像素都这么计算 得到的效果是 每个像素都混杂了一部分到相邻的像素中 这就得到了一个比原图更模糊的版本",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 571.94,
  "end": 580.86
 },
 {
  "input": "In the lingo, we'd say that the image on the right is a convolution of our original image with a little grid of values.",
  "translatedText": "用专业术语来说，我们可以说右边的图像是原始图像与小网格值的卷积。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 581.72,
  "end": 587.74
 },
 {
  "input": "Or more technically, maybe I should say that it's the convolution with a 180 degree rotated version of that little grid of values.",
  "translatedText": "或者说得更专业一些，也许我应该说，这是对那个小数值网格进行 180 度旋转后的卷积。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 588.14,
  "end": 594.4
 },
 {
  "input": "Not that it matters when the grid is symmetric, but it's just worth keeping in mind that the definition of a convolution, as inherited from the pure math context, should always invite you to think about flipping around that second array.",
  "translatedText": "当然这在网格对称时没什么分别 但还是值得注意一下 卷积的定义是从纯数学语境继承下来的 你要牢记这个定义 把第二个数组翻转",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 594.62,
  "end": 605.24
 },
 {
  "input": "If we modify this slightly, we can get a much more elegant blurring effect by choosing a different grid of values.",
  "translatedText": "如果我们稍加修改，就可以通过选择不同的数值网格来获得更优雅的模糊效果。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 605.96,
  "end": 611.1
 },
 {
  "input": "In this case, I have a little 5x5 grid, but the distinction is not so much its size.",
  "translatedText": "在这种情况下，我有一个 5x5 的小网格，但区别并不在于它的大小。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 611.44,
  "end": 615.78
 },
 {
  "input": "If we zoom in, we notice that the value in the middle is a lot bigger than the value towards the edges.",
  "translatedText": "如果我们放大，就会发现中间的数值比边缘的数值大很多。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 615.98,
  "end": 620.54
 },
 {
  "input": "And where this is coming from is they're all sampled from a bell curve, known as a Gaussian distribution.",
  "translatedText": "这是因为它们都是从钟形曲线中采样的，也就是所谓的高斯分布。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 621.18,
  "end": 625.94
 },
 {
  "input": "That way, when we multiply all of these values by the corresponding pixel that they're sitting on top of, we're giving a lot more weight to that central pixel, and much less towards the ones out at the edge.",
  "translatedText": "这样，当我们将所有这些值乘以它们所在的相应像素时，我们就会给中心像素更多的权重，而给边缘像素的权重就会小得多。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 626.8,
  "end": 636.38
 },
 {
  "input": "And just as before, the corresponding pixel on the right is defined to be this sum.",
  "translatedText": "和之前一样，右边相应的像素也被定义为这个和。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 636.8,
  "end": 640.56
 },
 {
  "input": "As we do this process for every single pixel, it gives a blurring effect, which much more authentically simulates the notion of putting your lens out of focus, or something like that.",
  "translatedText": "当我们对每个像素都进行处理时，就会产生模糊效果，从而更真实地模拟出镜头失焦的概念，或者类似的效果。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 641.32,
  "end": 649.72
 },
 {
  "input": "But blurring is far from the only thing that you can do with this idea.",
  "translatedText": "但是这个方法能做到的事情 远远不止模糊图片",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 649.9,
  "end": 653.36
 },
 {
  "input": "For instance, take a look at this little grid of values, which involves some positive numbers on the left, and some negative numbers on the right, which I'll color with blue and red respectively.",
  "translatedText": "例如，看看这个小网格，左边是一些正数，右边是一些负数，我将分别用蓝色和红色标出。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 653.8,
  "end": 662.9
 },
 {
  "input": "Take a moment to see if you can predict and understand what effect this will have on the final image.",
  "translatedText": "思考一下 看看你能否预测并理解 这个网格会如何影响最终图像",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 663.64,
  "end": 668.48
 },
 {
  "input": "So in this case, I'll just be thinking of the image as grayscale instead of colored, so each of the pixels is just represented by one number instead of three.",
  "translatedText": "因此，在这种情况下，我会把图像看作灰度图像而不是彩色图像，所以每个像素只用一个数字表示，而不是三个数字。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 670.72,
  "end": 678.12
 },
 {
  "input": "And one thing worth noticing is that as we do this convolution, it's possible to get negative values.",
  "translatedText": "值得注意的是，当我们进行卷积时，有可能得到负值。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 678.44,
  "end": 683.06
 },
 {
  "input": "For example, at this point here, if we zoom in, the left half of our little grid sits entirely on top of black pixels, which would have a value of zero, but the right half of negative values all sit on top of white pixels, which would have a value of one.",
  "translatedText": "例如，在这一点上，如果我们放大，我们的小网格的左半部分完全位于黑色像素之上，其值为 0，但负值的右半部分全部位于白色像素之上，其值为 1。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 683.06,
  "end": 695.46
 },
 {
  "input": "So when we multiply corresponding terms and add them together, the results will be very negative.",
  "translatedText": "因此，当我们将相应的项相乘并相加时，结果将是非常负的。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 696.18,
  "end": 700.82
 },
 {
  "input": "And the way I'm displaying this with the image on the right is to color negative values red and positive values blue.",
  "translatedText": "我用右边的图片显示的方法是将负值染成红色，正值染成蓝色。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 701.16,
  "end": 706.36
 },
 {
  "input": "Another thing to notice is that when you're on a patch that's all the same color, everything goes to zero, since the sum of the values in our little grid is zero.",
  "translatedText": "另外需要注意的是，当你所在的补丁颜色相同时，一切都会归零，因为我们小网格中的数值总和为零。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 706.88,
  "end": 714.08
 },
 {
  "input": "This is very different from the previous two examples where the sum of our little grid was one, which let us interpret it as a moving average and hence a blur.",
  "translatedText": "这和之前的两个例子大为不同 因为之前的例子里网格里数值的加和为 1 我们可以将其考虑为滑动平均 也就是模糊了图像",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 715.18,
  "end": 722.18
 },
 {
  "input": "All in all, this little process basically detects wherever there's variation in the pixel value as you move from left to right, and so it gives you a kind of way to pick up on all the vertical edges from your image.",
  "translatedText": "总之，这个小程序基本上可以检测到从左到右移动过程中像素值的任何变化，因此它提供了一种从图像中提取所有垂直边缘的方法。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 723.64,
  "end": 733.92
 },
 {
  "input": "And similarly, if we rotated that grid around so that it varies as you move from the top to the bottom, this will be picking up on all the horizontal edges, which in the case of our little pie creature image does result in some pretty demonic eyes.",
  "translatedText": "同样，如果我们旋转网格，使其在从上到下移动的过程中发生变化，这将会捕捉到所有的水平边缘，在我们的小馅饼生物图像中，这将会产生一些非常迷人的眼睛。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 736.5,
  "end": 749.34
 },
 {
  "input": "This smaller grid, by the way, is often called a kernel, and the beauty here is how just by choosing a different kernel, you can get different image processing effects, not just blurring your edge detection, but also things like sharpening.",
  "translatedText": "顺便说一下，这个较小的网格通常被称为内核，其美妙之处在于，只要选择不同的内核，就能获得不同的图像处理效果，不仅能模糊边缘检测，还能进行锐化等处理。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 750.4,
  "end": 760.84
 },
 {
  "input": "For those of you who have heard of a convolutional neural network, the idea there is to use data to figure out what the kernels should be in the first place, as determined by whatever the neural network wants to detect.",
  "translatedText": "对于那些听说过卷积神经网络的人来说，它的原理是利用数据来计算出神经网络想要检测的内容所决定的内核。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 760.84,
  "end": 771.48
 },
 {
  "input": "Another thing I should maybe bring up is the length of the output.",
  "translatedText": "另一个应该提一嘴的事情是输出的长度",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 772.76,
  "end": 775.52
 },
 {
  "input": "For something like the moving average example, you might only want to think about the terms when both of the windows fully align with each other.",
  "translatedText": "对于像移动平均线这样的例子，你可能只想考虑两个窗口完全一致时的术语。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 775.82,
  "end": 781.9
 },
 {
  "input": "Or in the image processing example, maybe you want the final output to have the same size as the original.",
  "translatedText": "或者在图像处理示例中，您可能希望最终输出的图像与原始图像大小相同。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 782.12,
  "end": 787.28
 },
 {
  "input": "Now, convolutions as a pure math operation always produce an array that's bigger than the two arrays that you started with, at least assuming one of them doesn't have a length of one.",
  "translatedText": "现在，卷积作为一种纯粹的数学运算，总会产生一个比你开始使用的两个数组更大的数组，至少假设其中一个数组的长度不是 1。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 787.28,
  "end": 796.18
 },
 {
  "input": "Just know that in certain computer science contexts, you often want to deliberately truncate that output.",
  "translatedText": "要知道，在某些计算机科学环境中，你经常需要故意截断输出。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 796.72,
  "end": 801.52
 },
 {
  "input": "Another thing worth highlighting is that in the computer science context, this notion of flipping around that kernel before you let it march across the original often feels really weird and just uncalled for, but again, note that that's what's inherited from the pure math context, where like we saw with the probabilities, it's an incredibly natural thing to do.",
  "translatedText": "另一件值得强调的事情是，在计算机科学的语境中，这种在让内核穿越原核之前翻转内核的概念常常让人感觉非常奇怪，而且毫无必要，但请注意，这是从纯数学语境中继承下来的，就像我们在概率中看到的那样，这是一件非常自然的事情。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 804.72,
  "end": 822.44
 },
 {
  "input": "And actually, I can show you one more pure math example where even the programmers should care about this one, because it opens the doors for a much faster algorithm to compute all of these.",
  "translatedText": "实际上，我还可以给你举一个纯数学的例子，程序员也应该关心这个例子，因为它为更快地计算所有这些算法打开了大门。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 823.02,
  "end": 832.02
 },
 {
  "input": "To set up what I mean by faster here, let me go back and pull up some Python again, and I'm going to create two different relatively big arrays.",
  "translatedText": "为了说明我这里所说的更快是什么意思，让我再回去调出 Python，创建两个不同的相对较大的数组。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 832.62,
  "end": 839.78
 },
 {
  "input": "Each one will have a hundred thousand random elements in it, and I'm going to assess the runtime, of the convolve function from the NumPy library.",
  "translatedText": "我将评估 NumPy 库中 convolve 函数的运行时间。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 839.94,
  "end": 847.54
 },
 {
  "input": "And in this case, it runs it for multiple different iterations, tries to find an average, and it looks like, on this computer at least, it averages at 4.87 seconds.",
  "translatedText": "在这种情况下，它会运行多个不同的迭代，试图找出一个平均值，看起来，至少在这台电脑上，平均值为 4.87 秒。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 848.18,
  "end": 856.52
 },
 {
  "input": "By contrast, if I use a different function from the SciPy library called fftConvolve, which is the same thing just implemented differently, that only takes 4.3 milliseconds on average, so three orders of magnitude improvement.",
  "translatedText": "相比之下，如果我使用 SciPy 库中名为 fftConvolve 的另一个函数（这是一个相同的函数，只是实现方式不同），平均只需要 4.3 毫秒，因此提高了三个数量级。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 856.96,
  "end": 870.16
 },
 {
  "input": "And again, even though it flies under a different name, it's giving the same output that the other convolve function does, it's just doing something to go about it in a cleverer way.",
  "translatedText": "再说一遍，尽管它的名字不同，但它的输出结果与其他卷积函数是一样的，只是做了一些更巧妙的处理。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 870.16,
  "end": 879.12
 },
 {
  "input": "Remember how with the probability example, I said another way you could think about the convolution was to create this table of all the pairwise products, and then add up those pairwise products along the diagonals.",
  "translatedText": "还记得在概率论的例子中，我说过另一种思考卷积的方法是创建一个包含所有成对乘积的表格，然后沿着对角线将这些成对乘积相加。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 882.2,
  "end": 892.68
 },
 {
  "input": "There's of course nothing specific to probability.",
  "translatedText": "当然，这与概率无关。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 893.66,
  "end": 895.5
 },
 {
  "input": "Any time you're convolving two different lists of numbers, you can think about it this way.",
  "translatedText": "任何时候，如果你要对两个不同的数字列表进行运算，都可以这样考虑。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 895.66,
  "end": 899.04
 },
 {
  "input": "Create this kind of multiplication table with all pairwise products, and then each sum along the diagonal corresponds to one of your final outputs.",
  "translatedText": "创建这种包含所有成对乘积的乘法表，然后对角线上的每个和都对应一个最终输出。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 899.04,
  "end": 906.46
 },
 {
  "input": "One context where this view is especially natural is when you multiply together two polynomials.",
  "translatedText": "有一种情况会让这种视角显得非常自然 就是当将两个多项式相乘时",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 907.6,
  "end": 912.8
 },
 {
  "input": "For example, let me take the little grid we already have and replace the top terms with 1, 2x, and 3x squared, and replace the other terms with 4, 5x, and 6x squared.",
  "translatedText": "例如，让我用我们已有的小网格，用 1、2x 和 3x 的平方来替换最上面的项，用 4、5x 和 6x 的平方来替换其他项。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 913.3,
  "end": 923.6
 },
 {
  "input": "Now, think about what it means when we're creating all of these different pairwise products between the two lists.",
  "translatedText": "现在，想想我们在两个列表之间创建所有这些不同的成对乘积意味着什么。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 924.0,
  "end": 928.84
 },
 {
  "input": "What you're doing is essentially expanding out the full product of the two polynomials I have written down, and then when you add up along the diagonal, that corresponds to collecting all like terms.",
  "translatedText": "你所做的实质上是将我写下的两个多项式的全积展开，然后沿对角线相加，这相当于收集所有同类项。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 929.04,
  "end": 939.9
 },
 {
  "input": "Which is pretty neat.",
  "translatedText": "这很不错。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 940.6,
  "end": 941.5
 },
 {
  "input": "Expanding a polynomial and collecting like terms is exactly the same process as a convolution.",
  "translatedText": "展开多项式并收集同类项的过程与卷积完全相同。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 941.74,
  "end": 946.44
 },
 {
  "input": "But this allows us to do something that's pretty cool, because think about what we're saying here.",
  "translatedText": "但这让我们可以做一些很酷的事情，因为想想我们在这里说什么。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 947.74,
  "end": 952.34
 },
 {
  "input": "We're saying if you take two different functions and you multiply them together, which is a simple pointwise operation, that's the same thing as if you had first extracted the coefficients from each one of those, assuming they're polynomials, and then taken a convolution of those two lists of coefficients.",
  "translatedText": "我们的意思是说，如果你把两个不同的函数相乘（这是一个简单的点式运算），就等同于你先从每个函数中提取系数（假设它们是多项式），然后对这两个系数列表进行卷积。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 952.34,
  "end": 968.84
 },
 {
  "input": "What makes that so interesting is that convolutions feel, in principle, a lot more complicated than simple multiplication.",
  "translatedText": "之所以如此有趣，是因为从原理上讲，卷积的感觉比简单的乘法要复杂得多。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 969.62,
  "end": 975.36
 },
 {
  "input": "And I don't just mean conceptually they're harder to think about.",
  "translatedText": "我不只是指概念上更难思考。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 975.82,
  "end": 978.46
 },
 {
  "input": "I mean, computationally, it requires more steps to perform a convolution than it does to perform a pointwise product of two different lists.",
  "translatedText": "我的意思是，在计算上，执行卷积所需的步骤比执行两个不同列表的点积所需的步骤要多。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 978.84,
  "end": 985.76
 },
 {
  "input": "For example, let's say I gave you two really big polynomials, say each one with a hundred different coefficients.",
  "translatedText": "例如，假设我给你两个非常大的多项式，每个多项式都有一百个不同的系数。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 986.32,
  "end": 991.9
 },
 {
  "input": "Then if the way you multiply them was to expand out this product, you know, filling in this entire 100 by 100 grid of pairwise products, that would require you to perform 10,000 different products.",
  "translatedText": "那么，如果你把它们相乘的方法是扩大这个乘积，你知道，填满整个 100 乘 100 的成对乘积网格，那你就需要执行 10,000 个不同的乘积。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 992.74,
  "end": 1003.24
 },
 {
  "input": "And then, when you're collecting all the like terms along the diagonals, that's another set of around 10,000 operations.",
  "translatedText": "然后，当你沿着对角线收集所有同类项时，这又是一组大约 10 000 次的运算。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1003.74,
  "end": 1009.86
 },
 {
  "input": "More generally, in the lingo, we'd say the algorithm is O of n squared, meaning for two lists of size n, the way that the number of operations scales is in proportion to the square of n.",
  "translatedText": "一般来说，用行话说，我们会说这种算法是 n 的 O 次方，意思是对于大小为 n 的两个列表，运算次数的比例与 n 的平方成正比。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1010.7,
  "end": 1021.14
 },
 {
  "input": "On the other hand, if I think of two polynomials in terms of their outputs, for example, sampling their values at some handful of inputs, then multiplying them only requires as many operations as the number of samples, since again, it's a pointwise operation.",
  "translatedText": "另一方面，如果我从输出的角度来考虑两个多项式，例如，在少数几个输入端对它们的值进行采样，那么它们相乘所需的运算次数就和采样次数一样多，因为这同样是一个点对点的运算。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1021.82,
  "end": 1035.62
 },
 {
  "input": "And with polynomials, you only need finitely many samples to be able to recover the coefficients.",
  "translatedText": "而对于多项式，只需要有限个样本就能复原系数。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1036.18,
  "end": 1040.54
 },
 {
  "input": "For example, two outputs are enough to uniquely specify a linear polynomial, three outputs would be enough to uniquely specify a quadratic polynomial, and in general, if you know n distinct outputs, that's enough to uniquely specify a polynomial that has n different coefficients.",
  "translatedText": "例如，两个输出端足以唯一指定一个线性多项式，三个输出端足以唯一指定一个二次多项式，一般来说，如果知道 n 个不同的输出端，就足以唯一指定一个有 n 个不同系数的多项式。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1040.54,
  "end": 1056.74
 },
 {
  "input": "Or, if you prefer, we could phrase this in the language of systems of equations.",
  "translatedText": "或者，如果你愿意，我们也可以用方程组的语言来表述。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1057.44,
  "end": 1060.72
 },
 {
  "input": "Imagine I tell you I have some polynomial, but I don't tell you what the coefficients are.",
  "translatedText": "想象一下，我告诉你我有一些多项式，但我没有告诉你系数是多少。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1061.2,
  "end": 1065.2
 },
 {
  "input": "Those are a mystery to you.",
  "translatedText": "这些对你来说是个谜。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1065.26,
  "end": 1066.52
 },
 {
  "input": "In our example, you might think of this as the product that we're trying to figure out.",
  "translatedText": "在我们的例子中，你可以把它想象成我们正在努力弄清楚的产品。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1066.7,
  "end": 1070.18
 },
 {
  "input": "And then, suppose I say, I'll just tell you what the outputs of this polynomial would be if you inputted various different inputs, like 0, 1, 2, 3, on and on, and I give you enough so that you have as many equations as you have unknowns.",
  "translatedText": "然后，假设我说，我会告诉你如果输入 0、1、2、3 等各种不同的输入，这个多项式的输出会是什么。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1070.18,
  "end": 1083.46
 },
 {
  "input": "It even happens to be a linear system of equations, so that's nice, and in principle, at least, this should be enough to recover the coefficients.",
  "translatedText": "它甚至恰好是一个线性方程组，所以这很好，至少在原则上，这应该足以恢复系数。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1084.14,
  "end": 1090.9
 },
 {
  "input": "So the rough algorithm outline then would be, whenever you want to convolve two lists of numbers, you treat them like they're coefficients of two polynomials, you sample those polynomials at enough outputs, multiply those samples point-wise, and then solve this system to recover the coefficients as a sneaky backdoor way to find the convolution.",
  "translatedText": "因此，粗略的算法大纲是，每当你想卷积两个数字列表时，就把它们当作两个多项式的系数，在足够的输出端对这些多项式进行采样，与这些采样点相乘，然后求解这个系统，恢复系数，以此作为一种偷偷摸摸的后门方法来找到卷积。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1091.74,
  "end": 1110.56
 },
 {
  "input": "And, as I've stated it so far, at least, some of you could rightfully complain, grant, that is an idiotic plan, because, for one thing, just calculating all these samples for one of the polynomials we know already takes on the order of n-squared operations.",
  "translatedText": "而且，正如我迄今为止所说的那样，至少你们中的一些人可以理直气壮地抱怨说：\"同意，这是一个愚蠢的计划，因为，首先，仅仅计算我们已经知道的一个多项式的所有这些样本，就需要 n 次方的运算。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1111.42,
  "end": 1125.12
 },
 {
  "input": "Not to mention, solving that system is certainly going to be computationally as difficult as just doing the convolution in the first place.",
  "translatedText": "更不用说，解决这个系统的计算难度肯定不亚于一开始就进行卷积。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1125.6,
  "end": 1132.1
 },
 {
  "input": "So, like, sure, we have this connection between multiplication and convolutions, but all of the complexity happens in translating from one viewpoint to the other.",
  "translatedText": "因此，乘法和卷积之间当然有联系，但所有的复杂性都发生在从一个观点转换到另一个观点的过程中。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1132.6,
  "end": 1140.48
 },
 {
  "input": "But there is a trick, and those of you who know about Fourier transforms and the FFT algorithm might see where this is going.",
  "translatedText": "当然 这里有一个技巧 有些同学如果了解傅里叶变换和 FFT 算法的话 可能已经看懂这是咋回事了",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1141.6,
  "end": 1147.74
 },
 {
  "input": "If you're unfamiliar with those topics, what I'm about to say might seem completely out of the blue.",
  "translatedText": "如果你对这些话题不熟悉，我接下来要说的可能会让你觉得完全没有头绪。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1147.74,
  "end": 1152.18
 },
 {
  "input": "Just know that there are certain paths you could have walked in math that make this more of an expected step.",
  "translatedText": "现在你只需要知道 存在某种数学方法 一旦了解了以后  很多事情就变得顺理成章了",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1152.26,
  "end": 1156.86
 },
 {
  "input": "Basically, the idea is that we have a freedom of choice here.",
  "translatedText": "从根本上说，我们在这里有选择的自由。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1157.72,
  "end": 1160.36
 },
 {
  "input": "If instead of evaluating at some arbitrary set of inputs, like 0, 1, 2, 3, on and on, you choose to evaluate on a very specially selected set of complex numbers, specifically the ones that sit evenly spaced on the unit circle, what are known as the roots of unity, this gives us a friendlier system.",
  "translatedText": "如果不在 0、1、2、3 等任意一组输入上求值，而是在一组经过特别挑选的复数上求值，特别是在单位圆上均匀分布的复数，也就是所谓的合一根上求值，就会得到一个更友好的系统。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1160.54,
  "end": 1176.88
 },
 {
  "input": "The basic idea is that by finding a number where taking its powers falls into this cycling pattern, it means that the system we generate is going to have a lot of redundancy in the different terms that you're calculating, and by being clever about how you leverage that redundancy, you can save yourself a lot of work.",
  "translatedText": "基本思路就是 找到一个取幂时输出总在单位圆上循环的数就行了 于是 我们生成的系统 在计算的不同项中会出现很多的冗余 巧妙地利用这些冗余 可以帮我们省下很多功夫",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1178.36,
  "end": 1194.46
 },
 {
  "input": "This set of outputs that I've written has a special name.",
  "translatedText": "我写的这组输出有一个特殊的名字。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1196.02,
  "end": 1198.56
 },
 {
  "input": "It's called the discrete Fourier transform of the coefficients, and if you want to learn more, I actually did another lecture for that same Julia MIT class all about discrete Fourier transforms, and there's also a really excellent video on the channel Reducible talking about the fast Fourier transform, which is an algorithm for computing these more quickly.",
  "translatedText": "如果你想了解更多，实际上我还为茱莉亚-麻省理工学院的同一门课做了另一个关于离散傅立叶变换的讲座，Reducible 频道上也有一个非常出色的视频，讲述了快速傅立叶变换，这是一种可以更快计算这些系数的算法。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1198.9,
  "end": 1217.12
 },
 {
  "input": "Also Veritasium recently did a really good video on FFTs, so you've got lots of options.",
  "translatedText": "此外，Veritasium 最近还制作了一个关于 FFT 的视频，非常不错，所以你有很多选择。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1217.48,
  "end": 1221.76
 },
 {
  "input": "And that fast algorithm really is the point for us.",
  "translatedText": "而这种快速算法确实是我们的重点",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1222.26,
  "end": 1224.66
 },
 {
  "input": "Again, because of all this redundancy, there exists a method to go from the coefficients to all of these outputs, where instead of doing on the order of n squared operations, you do on the order of n times the log of n operations, which is much much better as you scale to big lists.",
  "translatedText": "同样，由于所有这些冗余，存在一种从系数到所有这些输出的方法，在这种方法中，你不用进行 n 次平方的运算，而是进行 n 次对数的运算，当你扩展到大列表时，这种方法要好得多。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1225.12,
  "end": 1239.2
 },
 {
  "input": "And, importantly, this FFT algorithm goes both ways.",
  "translatedText": "重要的是，这种 FFT 算法是双向的。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1239.66,
  "end": 1242.54
 },
 {
  "input": "It also lets you go from the outputs to the coefficients.",
  "translatedText": "你也可以从输出对应到系数",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1242.7,
  "end": 1245.48
 },
 {
  "input": "So, bringing it all together, let's look back at our algorithm outline.",
  "translatedText": "现在，让我们回顾一下我们的算法大纲。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1246.22,
  "end": 1249.06
 },
 {
  "input": "Now we can say, whenever you're given two long lists of numbers, and you want to take their convolution, first compute the fast Fourier transform of each one of them, which, in the back of your mind, you can just think of as treating them like they're the coefficients of a polynomial, and evaluating it at a very specially selected set of points.",
  "translatedText": "现在我们可以说，只要给你两个长长的数字列表，而你又想计算它们的卷积，首先计算其中每个数字的快速傅立叶变换，在你的脑海中，你可以把它想象成把它们当作一个多项式的系数，并在一组特别选定的点上进行求值。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1249.42,
  "end": 1266.38
 },
 {
  "input": "Then, multiply together the two results that you just got, point-wise, which is nice and fast, and then do an inverse fast Fourier transform, and what that gives you is the sneaky backdoor way to compute the convolution that we were looking for.",
  "translatedText": "然后，将刚刚得到的两个结果乘以点，这样做又快又好，然后进行反快速傅立叶变换，这样就可以偷偷地通过后门计算出我们正在寻找的卷积。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1266.9,
  "end": 1278.9
 },
 {
  "input": "But this time, it only involves O of n log n operations.",
  "translatedText": "但这次只涉及 O of n log n 运算。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1279.04,
  "end": 1282.24
 },
 {
  "input": "That's really cool to me.",
  "translatedText": "这对我来说真的很酷。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1283.14,
  "end": 1284.74
 },
 {
  "input": "This very specific context where convolutions show up, multiplying two polynomials, opens the doors for an algorithm that's relevant everywhere else where convolutions might come up.",
  "translatedText": "尽管用到卷积的情景仅仅是多项式相乘 但它引出了 FFT 任何使用卷积的地方 都能看到 FFT 的身影",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1285.12,
  "end": 1294.1
 },
 {
  "input": "If you want to add probability distributions, do some large image processing, whatever it might be, and I just think that's such a good example of why you should be excited when you see some operation or concept in math show up in a lot of seemingly unrelated areas.",
  "translatedText": "如果你想添加概率分布，做一些大型图像处理，不管是什么，我只是觉得这是一个很好的例子，说明为什么当你看到数学中的一些运算或概念出现在很多看似不相关的领域时，你应该感到兴奋。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1294.18,
  "end": 1307.48
 },
 {
  "input": "If you want a little homework, here's something that's fun to think about.",
  "translatedText": "如果你想做一点功课，这里有一些有趣的思考。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1308.48,
  "end": 1311.5
 },
 {
  "input": "Explain why when you multiply two different numbers, just ordinary multiplication the way we all learn in elementary school, what you're doing is basically a convolution between the digits of those numbers.",
  "translatedText": "请解释：当你将两个不同的数字相乘时 就是我们在小学都学过的普通乘法那种 为什么你所做的事 大体相当于求“两数各个数位”的卷积",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1311.72,
  "end": 1321.98
 },
 {
  "input": "There's some added steps with carries and the like, but the core step is a convolution.",
  "translatedText": "还有一些额外的步骤，如转位等，但核心步骤是卷积。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1322.5,
  "end": 1326.46
 },
 {
  "input": "In light of the existence of a fast algorithm, what that means is if you have two very large integers, then there exists a way to find their product that's faster than the method we learn in elementary school, that instead of requiring O of n squared operations, only requires O of n log n, which doesn't even feel like it should be possible.",
  "translatedText": "鉴于快速算法的存在，这意味着如果你有两个非常大的整数，那么就存在一种求它们的乘积的方法，这种方法比我们在小学学习的方法更快，它不需要 O 的 n 次方运算，而只需要 O 的 n log n，这甚至让人觉得不可能。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1327.28,
  "end": 1344.92
 },
 {
  "input": "The catch is that before this is actually useful in practice, your numbers would have to be absolutely monstrous.",
  "translatedText": "要注意的是 要让这件事变得值得 你的两个乘数必须大得可怕",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1345.38,
  "end": 1350.84
 },
 {
  "input": "But still, it's cool that such an algorithm exists.",
  "translatedText": "不管怎样这种算法存在的本身就非常美妙",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1351.22,
  "end": 1353.86
 },
 {
  "input": "And next up, we'll turn our attention to the continuous case with a special focus on probability distributions.",
  "translatedText": "接下来，我们将把注意力转向连续情况，特别关注概率分布。",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1355.16,
  "end": 1359.64
 }
]