[
 {
  "input": "Suppose I give you two different lists of numbers, or maybe two different functions, and I ask you to think of all the ways you might combine those two lists to get a new list of numbers, or combine the two functions to get a new function. ",
  "translatedText": "假设有两个不同的数组 或两个不同的函数 让你想出各种运算方式 来把两个数组组合在一起 得到新数组 或者把两个函数组合起来  得到新函数",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 0,
  "end": 11.32
 },
 {
  "input": "Maybe one simple way that comes to mind is to simply add them together term by term. ",
  "translatedText": "最简单的方法可能就是 一个个地把他们加起来",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 12.12,
  "end": 16.76
 },
 {
  "input": "Likewise with the functions, you can add all the corresponding outputs. ",
  "translatedText": "同样 对函数来说则是把结果对应相加",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 17.16,
  "end": 19.92
 },
 {
  "input": "In a similar vein, you could also multiply the two lists term by term and do the same thing with the functions. ",
  "translatedText": "类似的 你也可以把两个数组中的数逐个相乘 对函数也是如此",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 20.54,
  "end": 25.68
 },
 {
  "input": "But there's another kind of combination just as fundamental as both of those, but a lot less commonly discussed, known as a convolution. ",
  "translatedText": "但有其实另一种组合方式 和之前提过的方式一样基础 但讨论得不多 它被称作“卷积”",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 26.36,
  "end": 33.5
 },
 {
  "input": "But unlike the previous two cases, it's not something that's merely inherited from an operation you can do to numbers. ",
  "translatedText": "但和前面两种组合方式不同的是 它并非来源于某种数字运算",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 34.08,
  "end": 39.82
 },
 {
  "input": "It's something genuinely new for the context of lists of numbers or combining functions. ",
  "translatedText": "而是一种用来组合数组和函数的新方法",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 39.98,
  "end": 44.7
 },
 {
  "input": "They show up all over the place, they are ubiquitous in image processing, it's a core construct in the theory of probability, they're used a lot in solving differential equations, and one context where you've almost certainly seen it, if not by this name, is multiplying two polynomials together. ",
  "translatedText": "这一方法随处可见 在数字图像处理中尤为明显 它是概率论中的一个核心结构 在求解微分方程时被大量使用 而在多项式相乘的情形中  你一定见过它 只是可能不叫这个名字",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 45.32,
  "end": 60.24
 },
 {
  "input": "As someone in the business of visual explanations, this is an especially great topic, because the formulaic definition in isolation and without context can look kind of intimidating, but if we take the time to really unpack what it's saying, and before that actually motivate why you would want something like this, it's an incredibly beautiful operation. ",
  "translatedText": "对一个用可视化方式传播知识的人来说 这是一个非常好的选题 因为光看没有上下文的公式化定义 卷积是会有点唬人 但是如果我告诉你卷积好处都有啥 再给你好好剖析下它的定义 你就会发现这个运算十分美妙",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 60.74,
  "end": 78.32
 },
 {
  "input": "And I have to admit, I actually learned a little something while putting together the visuals for this project. ",
  "translatedText": "不得不承认 在制作这期视频的过程中 我自己也切实地学到了一些知识",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 78.96,
  "end": 83.54
 },
 {
  "input": "In the case of convolving two different functions, I was trying to think of different ways you might picture what that could mean, and with one of them I had a little bit of an aha moment for why it is that normal distributions play the role that they do in probability, why it's such a natural shape for a function. ",
  "translatedText": "在讲到对两个函数进行卷积的例子时 我在思考用不同的方式将其可视化 其中一个方式 让我豁然开朗 我一下子明白了  为何正态分布在概率论中如此重要 它的函数图像的形状为何如此自然",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 83.54,
  "end": 98.52
 },
 {
  "input": "But I'm getting ahead of myself, there's a lot of setup for that one. ",
  "translatedText": "扯远了 在讲这个之前还有很多准备工作要做",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 99.02,
  "end": 101.52
 },
 {
  "input": "In this video, our primary focus is just going to be on the discrete case, and in particular building up to a very unexpected but very clever algorithm for computing these. ",
  "translatedText": "在这个视频中我们主要关注离散的卷积  逐步构建出一种让人拍案叫绝的计算方法",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 101.84,
  "end": 110.26
 },
 {
  "input": "And I'll pull out the discussion for the continuous case into a second part. ",
  "translatedText": "而连续的卷积我们则放在下期视频里来讨论",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 110.26,
  "end": 114.48
 },
 {
  "input": "It's very tempting to open up with the image processing examples, since they're visually the most intriguing, but there are a couple bits of finickiness that make the image processing case less representative of convolutions overall, so instead let's kick things off with probability, and in particular one of the simplest examples that I'm sure everyone here has thought about at some point in their life, which is rolling a pair of dice and figuring out the chances of seeing various different sums. ",
  "translatedText": "虽然用数字图像处理的例子作为开篇听起来很不错 毕竟它在可视方面是最能引起人兴趣的 但在一些细微之处 图像处理的例子不太能展现卷积的全貌 所以我们还是从概率论开始吧 有这么一个最最简单的例子 相信各位观众或早或晚都曾听过 就是掷两枚骰子 计算两枚骰子的各个点数和的出现的概率",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 118.58,
  "end": 141.5
 },
 {
  "input": "And you might say, not a problem, not a problem. ",
  "translatedText": "你可能会说 就这",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 142.46,
  "end": 144.46
 },
 {
  "input": "Each of your two dice has six different possible outcomes, which gives us a total of 36 distinct possible pairs of outcomes, and if we just look through them all we can count up how many pairs have a given sum. ",
  "translatedText": "每个骰子都有 6 种不同的结果 总共就是六六三十六种配对可能 我们一个个数一遍 就可以数出每个和有多少种组合",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 144.68,
  "end": 155.86
 },
 {
  "input": "And arranging all the pairs in a grid like this, one pretty nice thing is that all of the pairs that have a constant sum are visible along one of these different diagonals. ",
  "translatedText": "把所有的组合这样填在表格里 有个很妙的事情是 相同点数和的组合 都排在同一条对角线上",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 156.6,
  "end": 165.44
 },
 {
  "input": "So simply counting how many exist on each of those diagonals will tell you how likely you are to see a particular sum. ",
  "translatedText": "所以只要数出对角线上面有多少个组合 就可以知道 出现某个点数和的概率是多少",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 165.44,
  "end": 172.12
 },
 {
  "input": "And I'd say, very good, very good, but can you think of any other ways that you might visualize the same question? ",
  "translatedText": "我会说：还不赖  但你能换一种方式展现这个问题吗",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 173.22,
  "end": 178.66
 },
 {
  "input": "Other images that can come to mind to think of all the distinct pairs that have a given sum? ",
  "translatedText": "有没有想到其它 数出某个加和的所有点数组合方式的画面",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 179.3,
  "end": 184.06
 },
 {
  "input": "And maybe one of you raises your hand and says, yeah, I've got one. ",
  "translatedText": "可能有聪明的观众想说「我有想法了」",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 184.86,
  "end": 187.98
 },
 {
  "input": "Let's say you picture these two different sets of possibilities each in a row, but you flip around that second row. ",
  "translatedText": "把两枚骰子的所有可能结果 分别放到一行 然后把第二行翻转",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 188.28,
  "end": 193.76
 },
 {
  "input": "That way all of the different pairs which add up to seven line up vertically like this. ",
  "translatedText": "这样所有点数和为 7 的组合 就会这样纵向对齐",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 193.76,
  "end": 198.76
 },
 {
  "input": "And if we slide that bottom row all the way to the right, then the unique pair that adds up to two, the snake eyes, are the only ones that align. ",
  "translatedText": "如果我们把下面这行往左滑到头 那么 加和为2的唯一一组结果 就是唯一对齐的情况了",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 199.36,
  "end": 206.28
 },
 {
  "input": "And if I schlunk that over one unit to the right, the pairs which align are the two different pairs that add up to three. ",
  "translatedText": "如果我在往右推一个单位 就会出现两对和为 3 的组合",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 206.62,
  "end": 212.08
 },
 {
  "input": "And in general, different offset values of this lower array, which remember I had to flip around first, reveal all the distinct pairs that have a given sum. ",
  "translatedText": "总的来说 红色数组的不同偏移量 （别忘了下面这行是翻转过的） 对应了两个骰子的点数加和",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 212.88,
  "end": 221.46
 },
 {
  "input": "As far as probability questions go, this still isn't especially interesting, because all we're doing is counting how many outcomes there are in each of these categories. ",
  "translatedText": "到目前为止 这个概率问题还不算太有趣 因为我们只是数出了 每种点数和有多少种组合方式",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 224.82,
  "end": 232.64
 },
 {
  "input": "But that is with the implicit assumption that there's an equal chance for each of these faces to come up. ",
  "translatedText": "但这里面其实隐藏了一个假设 就是骰子的每面向上的概率是相同的",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 232.98,
  "end": 238.12
 },
 {
  "input": "But what if I told you I have a special set of dice that's not uniform? ",
  "translatedText": "如果我现在改用非标的骰子",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 238.36,
  "end": 241.62
 },
 {
  "input": "Maybe the blue die has its own set of numbers describing the probabilities for each face coming up, and the red die has its own unique distinct set of numbers. ",
  "translatedText": "用一个数组来描述蓝骰子每面向上的概率 同样地 红骰子也有这样一个数组",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 242.06,
  "end": 249.76
 },
 {
  "input": "In that case, if you wanted to figure out, say, the probability of seeing a two, you would multiply the probability that the blue die is a one times the probability that the red die is a one. ",
  "translatedText": "这样如果你想算出和为 2 的出现概率 就要用蓝骰子出现 1 的概率 乘红骰子出现 1 的概率",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 250.3,
  "end": 259.86
 },
 {
  "input": "And for the chances of seeing a three, you look at the two distinct pairs where that's possible, and again, multiply the corresponding probabilities, and then add those two products together. ",
  "translatedText": "如果要计算和为 3 的概率 则需要把对应组合里 点数出现的概率分别相乘 然后再把乘积相加",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 260.28,
  "end": 269.68
 },
 {
  "input": "Similarly, the chances of seeing a four involves multiplying together three different pairs of possibilities and adding them all together. ",
  "translatedText": "类似地 要计算和为 4 的情况 就要把三个不同组合里点数的出现概率相乘 再把他们相加",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 270.1,
  "end": 276.82
 },
 {
  "input": "And in the spirit of setting up some formulas, let's name these top probabilities a1, a2, a3, and so on, and name the bottom ones b1, b2, b3, and so on. ",
  "translatedText": "秉着要把它公式化的精神 我们把上面那行的概率记为 a₁ a₂ a₃... 把下面一行的概率记为 b₁ b₂ b₃...",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 276.82,
  "end": 285.96
 },
 {
  "input": "And in general, this process, where we're taking two different arrays of numbers, flipping the second one around, and then lining them up at various different offset values, taking a bunch of pairwise products and adding them up, that's one of the fundamental ways to think about what a convolution is. ",
  "translatedText": "拿出两列不同的数组{\\fsp-29}、 把第二组翻转过来{\\fsp-29}、 然后用不同偏移值把它们对齐{\\fsp-29}、 得到一组乘积之后再把他们加起来 这整个过程 便是卷积最基本的思考方式",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 286.4,
  "end": 301.62
 },
 {
  "input": "So just to spell it out a little more exactly, through this process, we just generated probabilities for seeing two, three, four, on and on up to 12, and we got them by mixing together one list of values, a, and another list of values, b. ",
  "translatedText": "说得更精确一些 我们通过这个过程 生成了点数和为 2 3 4 ... 12 的概率  这个过程通过某种运算将 A 和 B 数组的值交汇",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 304.86,
  "end": 316.98
 },
 {
  "input": "In the lingo, we'd say the convolution of those two sequences gives us this new sequence, the new sequence of 11 values, each of which looks like some sum of pairwise products. ",
  "translatedText": "说得专业一点就是 两组数的卷积生成了新的这组数 新的数列包含 11 个值 每个值都是两数组中若干数对之积的加和",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 317.44,
  "end": 327.34
 },
 {
  "input": "If you prefer, another way you could think about the same operation is to first create a table of all the pairwise products, and then add up along all these diagonals. ",
  "translatedText": "另一种思考卷积的方式是 列一个表格 计算各个组合的乘积 然后沿着各个对角线相加",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 327.34,
  "end": 336.98
 },
 {
  "input": "Again, that's a way of mixing together these two sequences of numbers to get us a new sequence of 11 numbers. ",
  "translatedText": "就把两组数混合了起来 得到了一组 11 个数",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 337.46,
  "end": 342.76
 },
 {
  "input": "It's the same operation as the sliding windows thought, just another perspective. ",
  "translatedText": "这个做法和滑动数列类似 只是换了一种思考方式",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 343.24,
  "end": 346.46
 },
 {
  "input": "Putting a little notation to it, here's how you might see it written down. ",
  "translatedText": "用上一些符号就可以写成这样",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 347.14,
  "end": 349.8
 },
 {
  "input": "The convolution of a and b, denoted with this little asterisk, is a new list, and the nth element of that list looks like a sum, and that sum goes over all different pairs of indices, i and j, so that the sum of those indices is equal to n. ",
  "translatedText": "A 和 B 的卷积的符号是「*」 其结果是一个列表 它的第 n 项定义为  把下标 i j 之和为 n 的诸元素的乘积累加起来",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 350.22,
  "end": 364.86
 },
 {
  "input": "It's kind of a mouthful, but for example, if n was 6, the pairs we're going over are 1 and 5, 2 and 4, 3 and 3, 4 and 2, 5 and 1, all the different pairs that add up to 6. ",
  "translatedText": "这可能有点啰嗦 但我还是要举个例子 如果 n=6 i 和 j 的组合 (i, j) 就是 (1, 5) (2, 4) (3, 3) (4, 2) (5, 1) 这些组合加起来都是 6",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 365.28,
  "end": 375.8
 },
 {
  "input": "But honestly, however you write it down, the notation is secondary in importance to the visual you might hold in your head for the process. ",
  "translatedText": "但是老实说 不管你怎么写 符号在脑中留下的印象都不会太深",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 376.62,
  "end": 382.34
 },
 {
  "input": "Here, maybe it helps to do a super simple example, where I might ask you what's the convolution of the list 1, 2, 3, with the list 4, 5, 6. ",
  "translatedText": "这有一个超简单的例子可能会有所帮助 我要问你 数组 (1, 2, 3) 和 (4, 5, 6) 的卷积是什么",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 383.28,
  "end": 390.78
 },
 {
  "input": "You might picture taking both of these lists, flipping around that second one, and then starting with its lid all the way over to the left. ",
  "translatedText": "你就可以想象这两个数组并排放着 翻转第二个 然后把它（尾部）滑到最左边",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 391.48,
  "end": 397.68
 },
 {
  "input": "Then the pair of values which align are 1 and 4, multiply them together, and that gives us our first term of our output. ",
  "translatedText": "这时候对齐的就只有 1 和 4 把它们乘在一起得到输出的第一项",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 398.18,
  "end": 403.54
 },
 {
  "input": "Slide that bottom array one unit to the right, the pairs which align are 1 and 5, and 2 and 4, multiply those pairs, add them together, and that gives us 13, the next entry in our output. ",
  "translatedText": "把第二个数组往右滑一个单位 对齐的就会有 1 和 5、2 和 4 把这两对相乘  然后把乘积加在一起就得到了下一项 13",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 403.96,
  "end": 414.46
 },
 {
  "input": "Slide things over once more, and we'll take 1 times 6, plus 2 times 5, plus 3 times 4, which happens to be 28. ",
  "translatedText": "再滑一下 就可以得到 1×6+2×5+3×4 算出来就是 28",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 414.96,
  "end": 421.56
 },
 {
  "input": "One more slide, and we get 2 times 6, plus 3 times 5, and that gives us 27, and finally the last term will look like 3 times 6. ",
  "translatedText": "再滑一下 就得到了 2×6+3×5=27 最后再滑一下就是 3×6",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 422.02,
  "end": 430.12
 },
 {
  "input": "If you'd like, you can pull up whatever your favorite programming language is, and your favorite library that includes various numerical operations, and you can confirm I'm not lying to you. ",
  "translatedText": "你可以用自己最喜欢的编程语言 和数值计算库跑一下 就知道我没骗你了",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 430.66,
  "end": 438.98
 },
 {
  "input": "If you take the convolution of 1, 2, 3, against 4, 5, 6, this is indeed the result that you'll get. ",
  "translatedText": "如果计算 (1, 2, 3) 和 (4, 5, 6) 的卷积 你就会得到这个结果",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 438.98,
  "end": 444.48
 },
 {
  "input": "We've seen one case where this is a natural and desirable operation, adding up to probability distributions, and another common example would be a moving average. ",
  "translatedText": "我们已经在求和得出概率分布的例子中 看到了这个运算是多么的自然和美妙 而另一个常见例子是滑动平均",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 445.92,
  "end": 453.66
 },
 {
  "input": "Imagine you have some long list of numbers, and you take another smaller list of numbers that all add up to 1. ",
  "translatedText": "假设有一个长数组 和另一个所有数之和为 1 的短数组",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 454.08,
  "end": 459.76
 },
 {
  "input": "In this case, I just have a little list of 5 values, and they're all equal to 1 5th. ",
  "translatedText": "这里就让短数组只有五个值好了 且每个值都等于 1/5",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 460.1,
  "end": 464.06
 },
 {
  "input": "Then if we do this sliding window convolution process, and kind of close our eyes and sweep under the rug what happens at the very beginning of it, once our smaller list of values entirely overlaps with the bigger one, think about what each term in this convolution really means. ",
  "translatedText": "接下来 如果我们重复这个滑动窗口卷积的过程 （最开始窗口出界的问题你就当没看见） 当短数组和长数组完全重叠时 思考下卷积的每项代表着什么",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 464.06,
  "end": 478.7
 },
 {
  "input": "At each iteration, what you're doing is multiplying each of the values from your data by 1 5th, and adding them all together, which is to say you're taking an average of your data inside this little window. ",
  "translatedText": "每次迭代的时候 你实际上是 在把数据里的每个数乘上 1/5 然后将它们加起来 也就是说 你在求这个小窗口里数据的平均值",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 479.4,
  "end": 490.52
 },
 {
  "input": "Overall, the process gives you a smoothed out version of the original data, and you could modify this starting with a different little list of numbers, and as long as that little list all adds up to 1, you can still interpret it as a moving average. ",
  "translatedText": "总的来说 这个过程给了你一个原数据的平滑版本 你可以修改它  使其从一个不同的短数组开始 只要短数组之和还是 1 你就仍可以把它解释为滑动平均",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 491.1,
  "end": 502.72
 },
 {
  "input": "In the example shown here, that moving average would be giving more weight towards the central value. ",
  "translatedText": "在这个例子中 滑动平均会给中间值更大的权重",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 503.4,
  "end": 507.76
 },
 {
  "input": "This also results in a smoothed out version of the data. ",
  "translatedText": "其结果也是原数据的平滑版本",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 508.42,
  "end": 510.8
 },
 {
  "input": "If you do kind of a two-dimensional analog of this, it gives you a fun algorithm for blurring a given image. ",
  "translatedText": "如果你在二维上进行类似的操作 就会得到一个把图片变模糊的有趣方法",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 513.14,
  "end": 518.72
 },
 {
  "input": "And I should say the animations I'm about to show are modified from something I originally made for part of a set of lectures I did with the Julia Lab at MIT for a certain OpenCourseWare class that included an image processing unit. ",
  "translatedText": "我应该指出 我接下来将要展示的动画 是由我和 Julia Lab 在麻省理工做的 一系列公开课里的内容修改而来的 其中就包含了一节图像处理相关的内容",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 518.72,
  "end": 531.08
 },
 {
  "input": "There we did a little bit more to dive into the code behind all of this, so if you're curious I'll leave you some links. ",
  "translatedText": "那个视频里对图像处理背后的代码讲解得更为深入 你感兴趣的话 可以看看评论区的链接",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 531.56,
  "end": 536.28
 },
 {
  "input": "But focusing back on this blurring example, what's going on is I've got this little 3x3 grid of values that's marching along our original image, and if we zoom in, each one of those values is 1 9th, and what I'm doing at each iteration is multiplying each of those values by the corresponding pixel that it sits on top of. ",
  "translatedText": "讲回到模糊图片的这个例子上 我们在做的事是 用一个 3×3 的网格沿着原图像移动 放大后  每个数都是 1/9 在每次迭代的时候 将这些数值乘以它底下对应的像素值",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 536.62,
  "end": 553.62
 },
 {
  "input": "And of course in computer science we think of colors as little vectors of three values, representing the red, green, and blue components. ",
  "translatedText": "当然在计算机科学中 我们把颜色当成三维向量 三个分量分别代表红、绿、蓝",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 553.9,
  "end": 560.2
 },
 {
  "input": "When I multiply all these little values by 1 9th and I add them together, it gives us an average along each color channel, and the corresponding pixel for the image on the right is defined to be that sum. ",
  "translatedText": "把每个向量都乘以 1/9 然后求和 就得到了每个颜色通道的平均值 那么右图中对应的像素就是这个加和",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 560.56,
  "end": 571.2
 },
 {
  "input": "The overall effect, as we do this for every single pixel on the image, is that each one kind of bleeds into all of its neighbors, which gives us a blurrier version than the original. ",
  "translatedText": "对每个像素都这么计算 得到的效果是 每个像素都混杂了一部分到相邻的像素中 这就得到了一个比原图更模糊的版本",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 571.94,
  "end": 580.86
 },
 {
  "input": "In the lingo we'd say that the image on the right is a convolution of our original image with a little grid of values. ",
  "translatedText": "用术语来说 右图就是原图和小网格的卷积",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 581.72,
  "end": 587.74
 },
 {
  "input": "Or more technically maybe I should say that it's the convolution with a 180 degree rotated version of that little grid of values. ",
  "translatedText": "严格上讲 应该是 和旋转 180 度的网格的卷积",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 588.14,
  "end": 594.4
 },
 {
  "input": "Not that it matters when the grid is symmetric, but it's just worth keeping in mind that the definition of a convolution, as inherited from the pure math context, should always invite you to think about flipping around that second array. ",
  "translatedText": "当然这在网格对称时没什么分别 但还是值得注意一下 卷积的定义是从纯数学语境继承下来的 你要牢记这个定义 把第二个数组翻转",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 594.62,
  "end": 605.24
 },
 {
  "input": "If we modify this slightly we can get a much more elegant blurring effect by choosing a different grid of values. ",
  "translatedText": "如果我们稍微修改一下这个例子 我们可以通过选择给网格赋予不同的数值 来得到更为美观的模糊效果",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 605.96,
  "end": 611.1
 },
 {
  "input": "In this case I have a little 5x5 grid, but the distinction is not so much its size. ",
  "translatedText": "这个例子中 有一个 5×5 网格 但是其大小不是主要的不同",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 611.44,
  "end": 615.78
 },
 {
  "input": "If we zoom in we notice that the value in the middle is a lot bigger than the value towards the edges, and where this is coming from is they're all sampled from a bell curve, known as a Gaussian distribution. ",
  "translatedText": "如果放大 我们可以看到中间的值 比边上的值大很多 究其根源  这些值都从一个钟形曲线中采样得来 这个曲线叫做高斯分布",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 615.98,
  "end": 625.94
 },
 {
  "input": "That way when we multiply all of these values by the corresponding pixel that they're sitting on top of, we're giving a lot more weight to that central pixel and much less towards the ones out at the edge. ",
  "translatedText": "这样 当我们将这些数乘以 它们下面对应的像素时 我们把更多的权重给了中间像素 而只把很少的权重给了边上的像素",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 626.8,
  "end": 636.38
 },
 {
  "input": "And just as before the corresponding pixel on the right is defined to be this sum. ",
  "translatedText": "和之前一样 右图中对应的像素就是这个加和",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 636.8,
  "end": 640.56
 },
 {
  "input": "As we do this process for every single pixel it gives a blurring effect which much more authentically simulates the notion of putting your lens out of focus or something like that. ",
  "translatedText": "随着我们对每个像素都重复这个过程 我们得到了一个模糊效果 它更真实地模拟了镜头失焦之类的场景",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 641.32,
  "end": 649.72
 },
 {
  "input": "But blurring is far from the only thing that you can do with this idea. ",
  "translatedText": "但是这个方法能做到的事情 远远不止模糊图片",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 649.9,
  "end": 653.36
 },
 {
  "input": "For instance take a look at this little grid of values, which involves some positive numbers on the left and some negative numbers on the right, which I'll color with blue and red respectively. ",
  "translatedText": "比如这个数值网格 正数在左 负数在右 我们来把它们分别填充为蓝色和红色",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 653.8,
  "end": 662.9
 },
 {
  "input": "Take a moment to see if you can predict and understand what effect this will have on the final image. ",
  "translatedText": "思考一下 看看你能否预测并理解 这个网格会如何影响最终图像",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 663.64,
  "end": 668.48
 },
 {
  "input": "So in this case I'll just be thinking of the image as grayscale instead of colored, so each of the pixels is just represented by one number instead of three. ",
  "translatedText": "这里只把图像考虑为灰度图而不是彩色图 这样每个像素就可以只用一个数来表示 而不是三个",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 670.72,
  "end": 678.12
 },
 {
  "input": "And one thing worth noticing is that as we do this convolution it's possible to get negative values. ",
  "translatedText": "值得一提的是 计算卷积的过程中 是有可能得到负值的",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 678.44,
  "end": 683.06
 },
 {
  "input": "For example at this point here if we zoom in the left half of our little grid sits entirely on top of black pixels, which would have a value of zero, but the right half of negative values all sit on top of white pixels, which would have a value of one. ",
  "translatedText": "比如这里 放大可以看见 网格左半边都在黑色像素上 所以会得到 0 而网格右半边的负值都在白色像素上 所以会得到 1",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 683.06,
  "end": 695.46
 },
 {
  "input": "So when we multiply corresponding terms and add them together the results will be very negative, and the way I'm displaying this with the image on the right is to color negative values red and positive values blue. ",
  "translatedText": "所以把对应项相乘再把结果相加 会得到负数值 我在右图中表示这点的方法 是把负数填充为红色 把正数填充为蓝色",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 696.18,
  "end": 706.36
 },
 {
  "input": "Another thing to notice is that when you're on a patch that's all the same color everything goes to zero since the sum of the values in our little grid is zero. ",
  "translatedText": "另外需要注意 当所有小块都是同一颜色时 结果是 0 这是因为网格中所有值相加为 0",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 706.88,
  "end": 714.08
 },
 {
  "input": "This is very different from the previous two examples where the sum of our little grid was one, which let us interpret it as a moving average and hence a blur. ",
  "translatedText": "这和之前的两个例子大为不同 因为之前的例子里网格里数值的加和为 1 我们可以将其考虑为滑动平均 也就是模糊了图像",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 715.18,
  "end": 722.18
 },
 {
  "input": "All in all this little process basically detects wherever there's variation in the pixel value as you move from left to right, and so it gives you a kind of way to pick up on all the vertical edges from your image. ",
  "translatedText": "总而言之 这个过程是在 检测像素值从左到右是否有变化 所以它可以判别出图像中的所有竖向的边界",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 723.64,
  "end": 733.92
 },
 {
  "input": "And similarly if we rotated that grid around so that it varies as you move from the top to the bottom this will be picking up on all the horizontal edges, which in the case of our little pie creature image does result in some pretty demonic eyes. ",
  "translatedText": "用同样的逻辑 如果我们旋转这个网格 使得它从上到下变化 那么它就可以判别出图像中的所有横向的边界   在这个例子中  它把 π 酱的眼睛变得像个大反派",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 736.5,
  "end": 749.34
 },
 {
  "input": "This smaller grid by the way is often called a kernel, and the beauty here is how just by choosing a different kernel you can get different image processing effects, not just blurring your edge detection but also things like sharpening. ",
  "translatedText": "顺便一提 这个小网格一般叫做“核” 巧妙之处在于  仅仅通过选择不同的核 就可以产生不同的图像处理效果 不只是模糊化边缘检测  图像的锐化也是可以的",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 750.4,
  "end": 760.84
 },
 {
  "input": "For those of you who have heard of a convolutional neural network the idea there is to use data to figure out what the kernels should be in the first place as determined by whatever the neural network wants to detect. ",
  "translatedText": "如果你听说过卷积神经网络的话 它的思路就是用数据来算出 应该选取什么样的核 这取决于想用神经网络来检测的目标",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 760.84,
  "end": 771.48
 },
 {
  "input": "Another thing I should maybe bring up is the length of the output. ",
  "translatedText": "另一个应该提一嘴的事情是输出的长度",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 772.76,
  "end": 775.52
 },
 {
  "input": "For something like the moving average example you might only want to think about the terms when both of the windows fully align with each other, or in the image processing example maybe you want the final output to have the same size as the original. ",
  "translatedText": "对滑动平均之类的情况  可能只需要考虑取样窗口完全对应的情况就好了 或者在图像处理的应用中 可能你想要保持输出图像的尺寸和原图像相同",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 775.82,
  "end": 787.28
 },
 {
  "input": "Now convolutions as a pure math operation always produce an array that's bigger than the two arrays that you started with, at least assuming one of them doesn't have a length of one. ",
  "translatedText": "其实 纯数学过程上的卷积 产生的数组总是比两个初始数组更长 至少在数组长度都大于 1 的时候是这样的",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 787.28,
  "end": 796.18
 },
 {
  "input": "Just know that in certain computer science contexts you often want to deliberately truncate that output. ",
  "translatedText": "你只需知道在某些计算机科学的背景下 你需要刻意截掉一些输出值",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 796.72,
  "end": 801.52
 },
 {
  "input": "Another thing worth highlighting is that in the computer science context this notion of flipping around that kernel before you let it march across the original often feels really weird and just uncalled for, but again note that that's what's inherited from the pure math context where like we saw with the probabilities it's an incredibly natural thing to do. ",
  "translatedText": "另外值得一提的是 在计算机科学的语境下 将核翻转后再遍历原数组 经常感觉非常奇怪且没必要 但是  这一样是从纯数学背景中继承而来的 而就像在概率的例子中所见的 这个翻转再正常不过了",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 804.72,
  "end": 822.44
 },
 {
  "input": "And actually I can show you one more pure math example where even the programmers should care about this one because it opens the doors for a much faster algorithm to compute all of these. ",
  "translatedText": "其实 我还可以再展示一个纯数学的例子 即使是纯程序员也应该关心此例 因为它引入了一个计算卷积时快得多的算法",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 823.02,
  "end": 832.02
 },
 {
  "input": "To set up what I mean by faster here let me go back and pull up some python again and I'm going to create two different relatively big arrays. ",
  "translatedText": "为了解释我说的快得多是什么意思 我来掏出 Python 再写点东西 这次我会建两个不同的长数组",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 832.62,
  "end": 839.78
 },
 {
  "input": "Each one will have a hundred thousand random elements in it and I'm going to assess the runtime of the convolve function from the numpy library. ",
  "translatedText": "每个中会有 100,000 个随机元素 监测一下 NumPy 库中 convolve 函数的运行时间 {\\pos(1045, 1060)}{\\fs40}卷积",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.94,
  "end": 847.54
 },
 {
  "input": "And in this case it runs it for multiple different iterations, tries to find an average, and it looks like on this computer at least it averages at 4.87 seconds. ",
  "translatedText": "在这个案例中 它输出的是多次迭代中的平均用时 至少在这台计算机上  看起来平均用时是 4.87 秒",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 848.18,
  "end": 856.52
 },
 {
  "input": "By contrast if I use a different function from the scipy library called fftconvolve which is the same thing just implemented differently that only takes 4.3 milliseconds on average, so three orders of magnitude improvement. ",
  "translatedText": "然而 如果我改用 SciPy 库中的 fftconvolve 函数 {\\pos(1310, 1060)}{\\fs40}快速傅里叶变换卷积 它们功能一样  只是实现方法不一样 这次计算平均只用了 4.3 毫秒 这可是 3 个数量级的优化",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 856.96,
  "end": 870.16
 },
 {
  "input": "And again even though it flies under a different name it's giving the same output that the other convolve function does, it's just doing something to go about it in a cleverer way. ",
  "translatedText": "再强调一下 即使它们的名字不同 但它和另一个卷积函数给出的输出是相同的 只是用了某种更巧妙的计算方法",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 870.16,
  "end": 879.12
 },
 {
  "input": "Remember how with the probability example I said another way you could think about the convolution was to create this table of all the pairwise products and then add up those pairwise products along the diagonals. ",
  "translatedText": "还记得刚才那个概率论的例子吗 我提到了另一种考虑卷积的方式 就是建立这个表格来计算各组合的乘积 然后沿着每条对角线求和",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 882.2,
  "end": 892.68
 },
 {
  "input": "There's of course nothing specific to probability anytime you're convolving two different lists of numbers you can think about it this way. ",
  "translatedText": "当然 这办法不只在概率论里用得上 只要是要求两个数组的卷积时 你都能这么思考",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 893.66,
  "end": 899.04
 },
 {
  "input": "Create this kind of multiplication table with all pairwise products and then each sum along the diagonal corresponds to one of your final outputs. ",
  "translatedText": "先建一个表格来计算组合乘积 再沿每条对角线求和 就对应着每一个输出结果",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 899.04,
  "end": 906.46
 },
 {
  "input": "One context where this view is especially natural is when you multiply together two polynomials. ",
  "translatedText": "有一种情况会让这种视角显得非常自然 就是当将两个多项式相乘时",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 907.6,
  "end": 912.8
 },
 {
  "input": "For example let me take the little grid we already have and replace the top terms with 1, 2x, and 3x squared and replace the other terms with 4, 5x, and 6x squared. ",
  "translatedText": "比如用这个我们已经有的网格 将上方的项替换为 1, 2x 和 3x² 将左侧的项替换为 4, 5x 和 6x²",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 913.3,
  "end": 923.6
 },
 {
  "input": "Now think about what it means when we're creating all of these different pairwise products between the two lists. ",
  "translatedText": "然后来思考一下 这些组合的乘积意味着什么",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 924,
  "end": 928.84
 },
 {
  "input": "What you're doing is essentially expanding out the full product of the two polynomials I have written down and then when you add up along the diagonal that corresponds to collecting all like terms which is pretty neat expanding a polynomial and collecting like terms is exactly the same process as a convolution. ",
  "translatedText": "其实本质上你在做一个多项式展开 即求两个多项式的全乘积 当你沿对角线求和 其实就是在合并同类项 非常简洁优雅 扩展多项式然后合并同类项 其实和卷积的过程是一模一样的",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 929.04,
  "end": 946.44
 },
 {
  "input": "But this allows us to do something that's pretty cool because think about what we're saying here. ",
  "translatedText": "基于此我们可以做些更棒的事情 稍微回想一下我们在做的事情",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 947.74,
  "end": 952.34
 },
 {
  "input": "We're saying if you take two different functions and you multiply them together which is a simple pointwise operation that's the same thing as if you had first extracted the coefficients from each one of those assuming they're polynomials and then taken a convolution of those two lists of coefficients. ",
  "translatedText": "我们是将两个不同的函数 进行相乘 也就是进行一个简单的逐点运算 这相当于 假设他们为多项式 首先提取多项式的系数 然后对这些系数组成的数组进行卷积",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 952.34,
  "end": 968.84
 },
 {
  "input": "What makes that so interesting is that convolutions feel in principle a lot more complicated than simple multiplication and I don't just mean conceptually they're harder to think about I mean computationally it requires more steps to perform a convolution than it does to perform a pointwise product of two different lists. ",
  "translatedText": "非常有意思的是 卷积看起来要比直接相乘复杂那么一点儿 我不光是说它在概念上更难理解 我的意思是相比较对两个数组进行逐点乘积来说 卷积需要更多的步骤来执行计算",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 969.62,
  "end": 985.76
 },
 {
  "input": "For example, let's say I gave you two really big polynomials, say each one with a hundred different coefficients. Then if the way you multiply them was to expand out this product, you know, filling in this entire 100 by 100 grid of pairwise products, that would require you to perform 10,000 different products. And then, when you're collecting all the like terms along the diagonals, that's another set of around 10,000 operations. ",
  "translatedText": "打个比方 我这有俩很长很长的多项式 每个有 100 个项和相应的系数 如果你通过相乘系数的办法来展开多项式 你就要填满这个 100×100 的数组乘积网格 这意味着你得先做一万次乘法运算 然后当沿着对角线合并同类项时 你得再执行大约一万次操作",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 986.32,
  "end": 1009.86
 },
 {
  "input": "More generally in the lingo we'd say the algorithm is O of n squared meaning for two lists of size n the way that the number of operations scales is in proportion to the square of n. ",
  "translatedText": "更专业一点 我们可以说这是 O(N²) 的算法 意思是说  两个含 N 个数的数组 需要执行操作的次数与 N² 成正比",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1010.7,
  "end": 1021.14
 },
 {
  "input": "On the other hand if I think of two polynomials in terms of their outputs for example sampling their values at some handful of inputs then multiplying them only requires as many operations as the number of samples since again it's a pointwise operation and with polynomials you only need finitely many samples to be able to recover the coefficients. ",
  "translatedText": "然而 如果我只考虑多项式的函数输出值 比如只对少数几个输入值进行采样计算 那么乘法运算的执行次数就等于样本数量 因为这也是一个逐点操作 并且说回多项式的情况 只需有限的样本量就足以重现系数",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1021.82,
  "end": 1040.54
 },
 {
  "input": "For example two outputs are enough to uniquely specify a linear polynomial.",
  "translatedText": "比如 两个函数输出值就能确定一个唯一的线性多项式",
  "n_reviews": 0,
  "start": 1040.54,
  "end": 1045.06
 },
 {
  "input": "Three outputs would be enough to uniquely specify a quadratic polynomial.",
  "translatedText": "三个函数输出值就能确定一个唯一的二次多项式",
  "n_reviews": 0,
  "start": 1045.66,
  "end": 1049.4
 },
 {
  "input": "And in general if you know n distinct outputs that's enough to uniquely specify a polynomial that has n different coefficients.",
  "translatedText": "而且一般来说 如果你知道 N 个函数输出值 就足以确定一个唯一的 N-1 次多项式",
  "n_reviews": 0,
  "start": 1049.64,
  "end": 1056.74
 },
 {
  "input": "Or if you prefer we could phrase this in the language of systems of equations.",
  "translatedText": "或者我们也可以用方程组的形式来表述",
  "n_reviews": 0,
  "start": 1057.44,
  "end": 1060.72
 },
 {
  "input": "Imagine I tell you I have some polynomial but I don't tell you what the coefficients are, those are a mystery to you.",
  "translatedText": "假设我有一些多项式 但是我不告诉你它们的系数是什么 它们对你来说是未知的",
  "n_reviews": 0,
  "start": 1061.2,
  "end": 1066.52
 },
 {
  "input": "In our example you might think of this as the product that we're trying to figure out.",
  "translatedText": "在我们的例子里 你可能会认为这其实就是我们要求出的乘积",
  "n_reviews": 0,
  "start": 1066.7,
  "end": 1070.18
 },
 {
  "input": "Then suppose I say I'll just tell you what the outputs of this polynomial would be if you inputted various different inputs like 0, 1, 2, 3, on and on, and I give you enough so that you have as many equations as you have unknowns.",
  "translatedText": "如果假设 我只告诉你这个多项式的输出值 假如你指定了不同的输入值如 0 1 2 3 ... 等等 并且我给你提供 与未知系数的个数相同数量的方程式",
  "n_reviews": 0,
  "start": 1070.18,
  "end": 1083.46
 },
 {
  "input": "It even happens to be a linear system of equations, so that's nice.",
  "translatedText": "简直太棒了 它甚至恰好是一个线性方程组",
  "n_reviews": 0,
  "start": 1084.14,
  "end": 1087.34
 },
 {
  "input": "And in principle at least, this should be enough to recover the coefficients.",
  "translatedText": "原则上 这已经足够用来恢复系数了",
  "n_reviews": 0,
  "start": 1087.78,
  "end": 1090.9
 },
 {
  "input": "So the rough algorithm outline then would be whenever you want to convolve two lists of numbers you treat them like they're coefficients of two polynomials.",
  "translatedText": "所以粗略的算法大纲为 当需要对两个数组进行卷积时 可以把它们视为两个多项式的系数",
  "n_reviews": 0,
  "start": 1091.74,
  "end": 1099
 },
 {
  "input": "You sample those polynomials at enough outputs, multiply those samples point-wise, and then solve the system to recover the coefficients as a sneaky backdoor way to find the convolution.",
  "translatedText": "对这些多项式的输出值尽可能多地采样 对这些样本逐点相乘 然后求解并恢复出系数 这就是为卷积找了个捷径",
  "n_reviews": 0,
  "start": 1099.42,
  "end": 1110.56
 },
 {
  "input": "And as I've stated it so far at least, some of you could rightfully complain \"Grant, that is an idiotic plan\".",
  "translatedText": "目前为止 正如我所说的那样 有些同学可能会抱怨说  Grant  这点子可太蠢了",
  "n_reviews": 0,
  "start": 1111.42,
  "end": 1117.34
 },
 {
  "input": "Because for one thing just calculating all these samples for one of the polynomials we know already takes on the order of n squared operations, not to mention solving that system is certainly going to be computationally as difficult as just doing the convolution in the first place.",
  "translatedText": "因为一方面 只是计算其中一个已知多项式的所有样本 算法的时间复杂度就已经到了 O(N²) 了 更别说要对整个系统进行计算了 那和一开始就做卷积没有啥区别",
  "n_reviews": 0,
  "start": 1117.58,
  "end": 1132.1
 },
 {
  "input": "So, like, sure we have this connection between multiplication and convolutions, but all of the complexity happens in translating from one viewpoint to the other.",
  "translatedText": "是的 在函数相乘和做卷积之间存在着联系 但是所有的复杂性都发生在视角转化的过程中",
  "n_reviews": 0,
  "start": 1132.6,
  "end": 1140.48
 },
 {
  "input": "But there is a trick, and those of you who know about Fourier transforms and the FFT algorithm might see where this is going.",
  "translatedText": "当然 这里有一个技巧 有些同学如果了解傅里叶变换和 FFT 算法的话 可能已经看懂这是咋回事了",
  "n_reviews": 0,
  "start": 1141.6,
  "end": 1147.74
 },
 {
  "input": "If you're unfamiliar with these topics, what I'm about to say might seem completely out of the blue.",
  "translatedText": "但如果你对这些话题不熟悉的话 接下来要讲的东西可能会让你有点摸不着头脑",
  "n_reviews": 0,
  "start": 1147.74,
  "end": 1152.18
 },
 {
  "input": "Just know that there are certain paths you could have walked in math that make this more of an expected step.",
  "translatedText": "现在你只需要知道 存在某种数学方法 一旦了解了以后  很多事情就变得顺理成章了",
  "n_reviews": 0,
  "start": 1152.26,
  "end": 1156.86
 },
 {
  "input": "Basically the idea is that we have a freedom of choice here.",
  "translatedText": "基本思路就是这里我们有一些自由的选择",
  "n_reviews": 0,
  "start": 1157.72,
  "end": 1160.36
 },
 {
  "input": "If instead of evaluating at some arbitrary set of inputs like 0, 1, 2, 3, on and on, you choose to evaluate on a very specially selected set of complex numbers.",
  "translatedText": "如果不像原来那样 输入任意数字集合如 0 1 2 3 等等来计算 而是替换为输入特定的复数来求解",
  "n_reviews": 0,
  "start": 1160.54,
  "end": 1169.7
 },
 {
  "input": "Specifically the ones that sit evenly spaced on the unit circle, what are known as the roots of unity.",
  "translatedText": "尤其是在单位圆上均匀分布的那些 所谓的单位根的话",
  "n_reviews": 0,
  "start": 1170.24,
  "end": 1174.84
 },
 {
  "input": "This gives us a friendlier system.",
  "translatedText": "我们就得到了一个更友好的系统",
  "n_reviews": 0,
  "start": 1175.2,
  "end": 1176.88
 },
 {
  "input": "The basic idea is that by finding a number where taking its powers falls into this cycling pattern, it means that the system we generate is going to have a lot of redundancy in the different terms that you're calculating, and by being clever about how you leverage that redundancy, you can save yourself a lot of work.",
  "translatedText": "基本思路就是 找到一个取幂时输出总在单位圆上循环的数就行了 于是 我们生成的系统 在计算的不同项中会出现很多的冗余 巧妙地利用这些冗余 可以帮我们省下很多功夫",
  "n_reviews": 0,
  "start": 1178.36,
  "end": 1194.46
 },
 {
  "input": "This set of outputs that I've written has a special name, it's called the discrete Fourier transform of the coefficients.",
  "translatedText": "这个输出集合有一个特定名字 叫作系数的离散傅里叶变换",
  "n_reviews": 0,
  "start": 1196.02,
  "end": 1202.28
 },
 {
  "input": "And if you want to learn more I actually did another lecture for that same Julia MIT class all about discrete Fourier transforms.",
  "translatedText": "如果你想了解更多 我还在同一门 Julia MIT 课程上过另一堂课 都是关于离散傅里叶变换的",
  "n_reviews": 0,
  "start": 1202.5,
  "end": 1209.14
 },
 {
  "input": "And there's also a really excellent video on the channel reducible talking about the fast Fourier transform, which is an algorithm for computing these more quickly.",
  "translatedText": "Reducible 频道也有一期很棒的视频 介绍了快速傅里叶变换 (FFT) 这种算法可以让以上这些计算变得更快",
  "n_reviews": 0,
  "start": 1209.22,
  "end": 1217.12
 },
 {
  "input": "Also Veritasium recently did a really good video on FFT's, so you've got lots of options.",
  "translatedText": "真理元素最近也做了一支关于 FFT 的优质视频 总有一期能满足你",
  "n_reviews": 0,
  "start": 1217.48,
  "end": 1221.76
 },
 {
  "input": "And that fast algorithm really is the point for us.",
  "translatedText": "而这种快速算法确实是我们的重点",
  "n_reviews": 0,
  "start": 1222.26,
  "end": 1224.66
 },
 {
  "input": "Again because of all this redundancy there exists a method to go from the coefficients to all of these outputs, where instead of doing on the order of n squared operations, you do on the order of n times the log of n operations, which is much much better as you scale to big lists.",
  "translatedText": "再强调一下 多亏了这些冗余 我们才能更快速地把系数  转换到这些输出点 原来需要复杂度为 O(N²) 的操作 现在只需 O(N log N) 输入数组越大  这个方法的优势就越明显",
  "n_reviews": 0,
  "start": 1225.12,
  "end": 1239.2
 },
 {
  "input": "And importantly this fft algorithm goes both ways.",
  "translatedText": "更重要的是 FFT 还可以反过来用",
  "n_reviews": 0,
  "start": 1239.66,
  "end": 1242.54
 },
 {
  "input": "It also lets you go from the outputs to the coefficients.",
  "translatedText": "你也可以从输出对应到系数",
  "n_reviews": 0,
  "start": 1242.7,
  "end": 1245.48
 },
 {
  "input": "So bringing it all together, let's look back at our algorithm outline.",
  "translatedText": "有了以上的知识 我们来回顾一下我们的算法大纲",
  "n_reviews": 0,
  "start": 1246.22,
  "end": 1249.06
 },
 {
  "input": "Now we can say whenever you're given two long lists of numbers and you want to take their convolution, first compute the fast Fourier transform of each one of them, which in the back of your mind you can just think of as treating them like they're the coefficients of a polynomial and evaluating it at a very specially selected set of points.",
  "translatedText": "只要我们有两个长数组 想要计算它们的卷积的话 首先分别计算它们的快速傅里叶变换 在你的脑海中 你可以把这些数看作是 多项式的系数 再将他们作为一系列具有特殊性质的点来处理",
  "n_reviews": 0,
  "start": 1249.42,
  "end": 1266.38
 },
 {
  "input": "Then multiply together the two results that you just got point-wise, which is nice and fast, and then do an inverse fast Fourier transform, and what that gives you is the sneaky backdoor way to compute the convolution that we were looking for.",
  "translatedText": "然后将两个结果逐点相乘 这还挺容易的 然后做一个快速傅里叶逆变换  我们就得到了一个计算卷积的取巧方法",
  "n_reviews": 0,
  "start": 1266.9,
  "end": 1278.9
 },
 {
  "input": "But this time it only involves O of n log n operations.",
  "translatedText": "但是这回 它的复杂度仅为 O(N log N)",
  "n_reviews": 0,
  "start": 1279.04,
  "end": 1282.24
 },
 {
  "input": "That's really cool to me!",
  "translatedText": "太神奇了",
  "n_reviews": 0,
  "start": 1283.14,
  "end": 1284.74
 },
 {
  "input": "This very specific context where convolutions show up, multiplying two polynomials, opens the doors for an algorithm that's relevant everywhere else where convolutions might come up.",
  "translatedText": "尽管用到卷积的情景仅仅是多项式相乘 但它引出了 FFT 任何使用卷积的地方 都能看到 FFT 的身影",
  "n_reviews": 0,
  "start": 1285.12,
  "end": 1294.1
 },
 {
  "input": "If you want to add probability distributions, do some large image processing, whatever it might be.",
  "translatedText": "比如 在一些大型图像处理中 添加一些概率分布之类的东西",
  "n_reviews": 0,
  "start": 1294.18,
  "end": 1299
 },
 {
  "input": "And I just think that's such a good example of why you should be excited when you see some operation or concept in math show up in a lot of seemingly unrelated areas.",
  "translatedText": "这有力地证明了 一个值得我们兴奋的情形在于   看似无关的几个领域  出现了相同的数学运算或概念",
  "n_reviews": 0,
  "start": 1299.22,
  "end": 1307.48
 },
 {
  "input": "If you want a little homework here's something that's fun to think about.",
  "translatedText": "想要课后练习的话 我留一道思考题",
  "n_reviews": 0,
  "start": 1308.48,
  "end": 1311.5
 },
 {
  "input": "Explain why when you multiply two different numbers, just ordinary multiplication the way we all learn in elementary school, what you're doing is basically a convolution between the digits of those numbers.",
  "translatedText": "请解释：当你将两个不同的数字相乘时 就是我们在小学都学过的普通乘法那种 为什么你所做的事 大体相当于求“两数各个数位”的卷积",
  "n_reviews": 0,
  "start": 1311.72,
  "end": 1321.98
 },
 {
  "input": "There are some added steps with carries and the like, but the core step is a convolution.",
  "translatedText": "会用到进位之类的额外步骤 不过核心步骤还是卷积",
  "n_reviews": 0,
  "start": 1322.5,
  "end": 1326.46
 },
 {
  "input": "In light of the existence of a fast algorithm, what that means is if you have two very large integers, then there exists a way to find their product that's faster than the method we learn in elementary school.",
  "translatedText": "而由于这个快速算法的存在 这就意味着如果你要乘两个非常大的整数 那么就有这么一种找到它们乘积的办法 要比我们在小学时学的方法要快得多",
  "n_reviews": 0,
  "start": 1327.28,
  "end": 1337.88
 },
 {
  "input": "That instead of requiring O of n squared operations only requires O of n log n, which doesn't even feel like it should be possible.",
  "translatedText": "复杂度从 O(N²) 一下降到了 O(N log N) 有一种这本来没理由做得到的感觉",
  "n_reviews": 0,
  "start": 1338.14,
  "end": 1344.92
 },
 {
  "input": "The catch is that before this is actually useful in practice, your numbers would have to be absolutely monstrous.",
  "translatedText": "要注意的是 要让这件事变得值得 你的两个乘数必须大得可怕",
  "n_reviews": 0,
  "start": 1345.38,
  "end": 1350.84
 },
 {
  "input": "But still, it's cool that such an algorithm exists.",
  "translatedText": "不管怎样这种算法存在的本身就非常美妙",
  "n_reviews": 0,
  "start": 1351.22,
  "end": 1353.86
 },
 {
  "input": "Next up we'll turn our attention to the continuous case with a special focus on probability distributions.",
  "translatedText": "下一期 我们要把目光转向连续卷积 并且会特别讨论概率分布的情况",
  "n_reviews": 0,
  "start": 1355.16,
  "end": 1359.64
 }
]
