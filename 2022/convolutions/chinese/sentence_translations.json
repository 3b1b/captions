[
 {
  "input": "Suppose I give you two different lists of numbers, or maybe two different functions, and I ask you to think of all the ways you might combine those two lists to get a new list of numbers, or combine the two functions to get a new function.",
  "model": "nmt",
  "translatedText": "假设我给你两个不同的数字列表，或者可能是两个不同的函数，并且 我要求你思考可以组合这两个列表以获得新的数字列表，或者组合 这两个函数以获得新函数的所有方法。",
  "time_range": [
   0.0,
   11.737373737373737
  ]
 },
 {
  "input": "Maybe one simple way that comes to mind is to simply add them together term by term.",
  "model": "nmt",
  "translatedText": "也许想到的一种简单方法就是 简单地将它们逐个添加在一起。",
  "time_range": [
   11.737373737373737,
   16.26727272727273
  ]
 },
 {
  "input": "Likewise with the functions, you can add all the corresponding outputs.",
  "model": "nmt",
  "translatedText": "与功能类似，您可以添加所有 相应的输出。",
  "time_range": [
   16.26727272727273,
   20.050526315789476
  ]
 },
 {
  "input": "In a similar vein, you could also multiply the two lists term by term and do the same thing with the functions.",
  "model": "nmt",
  "translatedText": "同样，您也可以将两个列表逐项相乘，并 对函数执行相同的操作。",
  "time_range": [
   20.050526315789476,
   26.14545454545454
  ]
 },
 {
  "input": "But there's another kind of combination just as fundamental as both of those, but a lot less commonly discussed, known as a convolution.",
  "model": "nmt",
  "translatedText": "但还有另一种组合与这两 种组合一样基本，但很少被讨论，称为卷积。",
  "time_range": [
   26.14545454545454,
   33.84
  ]
 },
 {
  "input": "But unlike the previous two cases, it's not something that's merely inherited from an operation you can do to numbers.",
  "model": "nmt",
  "translatedText": "但与前两种情况不同的是，它不仅仅是从对数字执行 的操作继承的。",
  "time_range": [
   33.84,
   39.89333333333333
  ]
 },
 {
  "input": "It's something genuinely new for the context of lists of numbers or combining functions.",
  "model": "nmt",
  "translatedText": "对于数字列表或组合函数的上下文来说，这是真 正的新事物。",
  "time_range": [
   39.89333333333333,
   44.71666666666667
  ]
 },
 {
  "input": "They show up all over the place, they are ubiquitous in image processing, it's a core construct in the theory of probability, they're used a lot in solving differential equations, and one context where you've almost certainly seen it, if not by this name, is multiplying two polynomials together.",
  "model": "nmt",
  "translatedText": "它们无处不在，它们在图像处理中无处不在，它 是概率论的核心构造，它们在求解微分方程中被大量使用，并 且您几乎肯定在其中见过它（如果没有的话）顾名思义，就 是将两个多项式相乘。",
  "time_range": [
   44.71666666666667,
   60.210526315789465
  ]
 },
 {
  "input": "As someone in the business of visual explanations, this is an especially great topic, because the formulaic definition in isolation and without context can look kind of intimidating, but if we take the time to really unpack what it's saying, and before that actually motivate why you would want something like this, it's an incredibly beautiful operation.",
  "model": "nmt",
  "translatedText": "作为从事视觉解释行业的人，这是一个特别 好的主题，因为孤立且没有上下文的公式化定义可能看起来有点令 人生畏，但如果我们花时间真正解开它所说的内容，并在此之前真 正激发为什么你会想要这样的东西，这是一个非常漂亮的操作。",
  "time_range": [
   60.210526315789465,
   78.8
  ]
 },
 {
  "input": "And I have to admit, I actually learned a little something while putting together the visuals for this project.",
  "model": "nmt",
  "translatedText": "我必须承认，在为这个项目制作视觉效果时，我实际上学到了一些 东西。",
  "time_range": [
   78.8,
   83.43636363636364
  ]
 },
 {
  "input": "In the case of convolving two different functions, I was trying to think of different ways you might picture what that could mean, and with one of them I had a little bit of an aha moment for why it is that normal distributions play the role that they do in probability, why it's such a natural shape for a function.",
  "model": "nmt",
  "translatedText": "在卷积两个不同函数的情况下，我试图想出不同的方 式来描述这可能意味着什么，对于其中一个，我有点恍然大 悟，为什么正态分布起着这样的作用：它们以概率的形式出 现，为什么它是函数的自然形状。",
  "time_range": [
   83.43636363636364,
   98.44571428571427
  ]
 },
 {
  "input": "But I'm getting ahead of myself, there's a lot of setup for that one.",
  "model": "nmt",
  "translatedText": "但我有点超前了，有 很多设置。",
  "time_range": [
   98.44571428571427,
   101.57999999999998
  ]
 },
 {
  "input": "In this video, our primary focus is just going to be on the discrete case, and in particular building up to a very unexpected but very clever algorithm for computing these.",
  "model": "nmt",
  "translatedText": "在本视频中，我们的主要重点将放在离散情况上 ，特别是构建一个非常出乎意料但非常聪明的算法来计算这些情况。",
  "time_range": [
   101.57999999999998,
   110.19654320987655
  ]
 },
 {
  "input": "And I'll pull out the discussion for the continuous case into a second part.",
  "model": "nmt",
  "translatedText": "我将对连续案例的讨论拉到第二部分。",
  "time_range": [
   110.19654320987655,
   117.84
  ]
 },
 {
  "input": "It's very tempting to open up with the image processing examples, since they're visually the most intriguing, but there are a couple bits of finickiness that make the image processing case less representative of convolutions overall, so instead let's kick things off with probability, and in particular one of the simplest examples that I'm sure everyone here has thought about at some point in their life, which is rolling a pair of dice and figuring out the chances of seeing various different sums.",
  "model": "nmt",
  "translatedText": "很容易打开图像处理示例，因为它们在视觉上是最有趣的 ，但是有一些挑剔之处使得图像处理案例不太能代表卷 积的整体情况，所以让我们从概率开始，特别是最简单的 例子之一，我相信这里的每个人都在他们生活中的某个 时刻考虑过，那就是掷一对骰子并计算出看到各种不同总 和的机会。",
  "time_range": [
   117.84,
   141.53
  ]
 },
 {
  "input": "And you might say, not a problem, not a problem.",
  "model": "nmt",
  "translatedText": "你可能会说，不是问题，不是问题。",
  "time_range": [
   141.53,
   144.17000000000002
  ]
 },
 {
  "input": "Each of your two dice has six different possible outcomes, which gives us a total of 36 distinct possible pairs of outcomes, and if we just look through them all we can count up how many pairs have a given sum.",
  "model": "nmt",
  "translatedText": "两个骰子中的每一个 都有 6 种不同的可能结果，这给了我们总共 36 种不同的可能结 果对，如果我们只查看它们，我们可以计算出有多少对具有给定的总和。",
  "time_range": [
   144.17000000000002,
   156.24
  ]
 },
 {
  "input": "And arranging all the pairs in a grid like this, one pretty nice thing is that all of the pairs that have a constant sum are visible along one of these different diagonals.",
  "model": "nmt",
  "translatedText": "将所有对排列在这样的网格中，一件非常好的事情是，所有具有恒 定总和的对都沿着这些不同的对角线之一可见。",
  "time_range": [
   156.24,
   165.65061224489793
  ]
 },
 {
  "input": "So simply counting how many exist on each of those diagonals will tell you how likely you are to see a particular sum.",
  "model": "nmt",
  "translatedText": "因此，只需计算每 个对角线上有多少个就可以告诉您看到特定总和的可能性有多大。",
  "time_range": [
   165.65061224489793,
   172.88
  ]
 },
 {
  "input": "And I'd say, very good, very good, but can you think of any other ways that you might visualize the same question?",
  "model": "nmt",
  "translatedText": "我想说，非常好，非常好，但是您能想到任何其他方式来形象化同 一问题吗？",
  "time_range": [
   172.88,
   178.699381443299
  ]
 },
 {
  "input": "Other images that can come to mind to think of all the distinct pairs that have a given sum?",
  "model": "nmt",
  "translatedText": "可以想到其他图像来思考具有给定总和的所有不同对 吗？",
  "time_range": [
   178.699381443299,
   183.7448
  ]
 },
 {
  "input": "And maybe one of you raises your hand and says, yeah, I've got one.",
  "model": "nmt",
  "translatedText": "也许你们中的一个人举起手说，是的，我有一个。",
  "time_range": [
   183.7448,
   187.55040000000002
  ]
 },
 {
  "input": "Let's say you picture these two different sets of possibilities each in a row, but you flip around that second row.",
  "model": "nmt",
  "translatedText": "假设您连续想 象这两组不同的可能性，但您翻转了第二行。",
  "time_range": [
   187.55040000000002,
   194.04673267326731
  ]
 },
 {
  "input": "That way all of the different pairs which add up to seven line up vertically like this.",
  "model": "nmt",
  "translatedText": "这样， 所有不同的对加起来就是七对，像这样垂直排列。",
  "time_range": [
   194.04673267326731,
   198.95999999999998
  ]
 },
 {
  "input": "And if we slide that bottom row all the way to the right, then the unique pair that adds up to two, the snake eyes, are the only ones that align.",
  "model": "nmt",
  "translatedText": "如果我们将底 行一直滑动到右侧，那么加起来为两个的独特的一对，即蛇眼 ，是唯一对齐的。",
  "time_range": [
   198.95999999999998,
   206.30978723404257
  ]
 },
 {
  "input": "And if I schlunk that over one unit to the right, the pairs which align are the two different pairs that add up to three.",
  "model": "nmt",
  "translatedText": "如果我将其放在右侧的一个单位上，则对齐的 对是两对不同的，加起来为三对。",
  "time_range": [
   206.30978723404257,
   212.88659793814435
  ]
 },
 {
  "input": "And in general, different offset values of this lower array, which remember I had to flip around first, reveal all the distinct pairs that have a given sum.",
  "model": "nmt",
  "translatedText": "一般来说，这个较低数组的 不同偏移值（记住我必须首先翻转）显示具有给定总和的所有 不同对。",
  "time_range": [
   212.88659793814435,
   221.77892473118277
  ]
 },
 {
  "input": "As far as probability questions go, this still isn't especially interesting, because all we're doing is counting how many outcomes there are in each of these categories.",
  "model": "nmt",
  "translatedText": "就概率问题而言，这仍然不是特别有趣，因 为我们所做的只是计算每个类别中有多少个结果。",
  "time_range": [
   221.77892473118277,
   233.12
  ]
 },
 {
  "input": "But that is with the implicit assumption that there's an equal chance for each of these faces to come up.",
  "model": "nmt",
  "translatedText": "但这是基于一个隐含的假设，即这些面孔出现的机会均 等。",
  "time_range": [
   233.12,
   237.85011494252873
  ]
 },
 {
  "input": "But what if I told you I have a special set of dice that's not uniform?",
  "model": "nmt",
  "translatedText": "但如果我告诉你我有一套不统一的特殊骰子怎么办？",
  "time_range": [
   237.85011494252873,
   241.89793103448275
  ]
 },
 {
  "input": "Maybe the blue die has its own set of numbers describing the probabilities for each face coming up, and the red die has its own unique distinct set of numbers.",
  "model": "nmt",
  "translatedText": "也许 蓝色骰子有自己的一组数字来描述每张面出现的概率，而红 色骰子有自己独特的一组数字。",
  "time_range": [
   241.89793103448275,
   249.740198019802
  ]
 },
 {
  "input": "In that case, if you wanted to figure out, say, the probability of seeing a two, you would multiply the probability that the blue die is a one times the probability that the red die is a one.",
  "model": "nmt",
  "translatedText": "在这种情况下，如果您想计 算出看到 2 的概率，您可以将蓝色骰子为 1 的概率 乘以红色骰子为 1 的概率。",
  "time_range": [
   249.740198019802,
   259.89581395348836
  ]
 },
 {
  "input": "And for the chances of seeing a three, you look at the two distinct pairs where that's possible, and again, multiply the corresponding probabilities, and then add those two products together.",
  "model": "nmt",
  "translatedText": "对于看到 3 的机会，您可 以在可能的情况下查看两个不同的对，然后再次乘以相应的概 率，然后将这两个乘积加在一起。",
  "time_range": [
   259.89581395348836,
   269.9831578947369
  ]
 },
 {
  "input": "Similarly, the chances of seeing a four involves multiplying together three different pairs of possibilities and adding them all together.",
  "model": "nmt",
  "translatedText": "类似地，看到四的机会 涉及将三对不同的可能性相乘并将它们全部加在一起。",
  "time_range": [
   269.9831578947369,
   276.74893617021274
  ]
 },
 {
  "input": "And in the spirit of setting up some formulas, let's name these top probabilities a1, a2, a3, and so on, and name the bottom ones b1, b2, b3, and so on.",
  "model": "nmt",
  "translatedText": "本着建立一些公式的精神，让我们将这些最高概率命名为 a1、a2、a3 等，并将最低概率命名为 b1、b2、b3 等。",
  "time_range": [
   276.74893617021274,
   285.90315789473686
  ]
 },
 {
  "input": "And in general, this process, where we're taking two different arrays of numbers, flipping the second one around, and then lining them up at various different offset values, taking a bunch of pairwise products and adding them up, that's one of the fundamental ways to think about what a convolution is.",
  "model": "nmt",
  "translatedText": "一般来说，在这个过 程中，我们获取两个不同的数字数组，翻转第二个数组，然 后将它们排列在各种不同的偏移值处，获取一堆成对的乘积并 将它们相加，这就是其中之一思考什么是卷积的基本方法。",
  "time_range": [
   285.90315789473686,
   301.13977528089885
  ]
 },
 {
  "input": "So just to spell it out a little more exactly, through this process, we just generated probabilities for seeing two, three, four, on and on up to 12, and we got them by mixing together one list of values, a, and another list of values, b.",
  "model": "nmt",
  "translatedText": "因此，为了更准确地说明这一点，通过这个过程，我们只是生成了看到两个、三 个、四个、一直到 12 的概率，并且我们通过将一个值列表 a 和另一 个值混合在一起来获得它们值列表，b。",
  "time_range": [
   301.13977528089885,
   317.0848
  ]
 },
 {
  "input": "In the lingo, we'd say the convolution of those two sequences gives us this new sequence, the new sequence of 11 values, each of which looks like some sum of pairwise products.",
  "model": "nmt",
  "translatedText": "用行话来说，我们会说这两个序列 的卷积给出了这个新序列，即 11 个值的新序列，每个值看起来都 像是成对乘积的总和。",
  "time_range": [
   317.0848,
   327.12
  ]
 },
 {
  "input": "If you prefer, another way you could think about the same operation is to first create a table of all the pairwise products, and then add up along all these diagonals.",
  "model": "nmt",
  "translatedText": "如果您愿意，您可以考虑相同操作的另一种 方法是首先创建所有成对产品的表，然后沿着所有这些对角线相 加。",
  "time_range": [
   327.12,
   336.7023157894737
  ]
 },
 {
  "input": "Again, that's a way of mixing together these two sequences of numbers to get us a new sequence of 11 numbers.",
  "model": "nmt",
  "translatedText": "同样，这是一种将这两个数字序列混合在一起以获得 11 个数字的 新序列的方法。",
  "time_range": [
   336.7023157894737,
   342.2477669902912
  ]
 },
 {
  "input": "It's the same operation as the sliding windows thought, just another perspective.",
  "model": "nmt",
  "translatedText": "和滑动窗想的操作是一样的，只是换个角度。",
  "time_range": [
   342.2477669902912,
   346.96
  ]
 },
 {
  "input": "Putting a little notation to it, here's how you might see it written down.",
  "model": "nmt",
  "translatedText": "对其进行一些注释，您可能会看到这样的写法。",
  "time_range": [
   346.96,
   350.3148936170212
  ]
 },
 {
  "input": "The convolution of a and b, denoted with this little asterisk, is a new list, and the nth element of that list looks like a sum, and that sum goes over all different pairs of indices, i and j, so that the sum of those indices is equal to n.",
  "model": "nmt",
  "translatedText": "a 和 b 的卷 积（用这个小星号表示）是一个新列表，该列表的第 n 个元素看起 来像一个和，并且该和遍历所有不同的索引对 i 和 j，因此这些索 引等于 n。",
  "time_range": [
   350.3148936170212,
   364.738969072165
  ]
 },
 {
  "input": "It's kind of a mouthful, but for example, if n was 6, the pairs we're going over are 1 and 5, 2 and 4, 3 and 3, 4 and 2, 5 and 1, all the different pairs that add up to 6.",
  "model": "nmt",
  "translatedText": "这有点拗口，但是例如，如果 n 是 6，我们要检查的对是 1 和 5、2 和 4、3 和 3、4 和 2、5 和 1，所有不同的对加起来至 6。",
  "time_range": [
   364.738969072165,
   376.4
  ]
 },
 {
  "input": "But honestly, however you write it down, the notation is secondary in importance to the visual you might hold in your head for the process.",
  "model": "nmt",
  "translatedText": "但老实说，无论你怎么写，符号的重要性都比你头脑中 的视觉效果要重要。",
  "time_range": [
   376.4,
   383.0824
  ]
 },
 {
  "input": "Here, maybe it helps to do a super simple example, where I might ask you what's the convolution of the list 1, 2, 3, with the list 4, 5, 6.",
  "model": "nmt",
  "translatedText": "在这里，也许做一个超级简单的例子会有所帮助，我可 能会问你列表 1, 2, 3 与列表 4, 5, 6 的卷积是多少。",
  "time_range": [
   383.0824,
   390.9672727272727
  ]
 },
 {
  "input": "You might picture taking both of these lists, flipping around that second one, and then starting with its lid all the way over to the left.",
  "model": "nmt",
  "translatedText": "您可能会想 象将这两个列表都拿出来，翻转第二个列表，然后从其盖子开 始一直向左移动。",
  "time_range": [
   390.9672727272727,
   397.8576842105264
  ]
 },
 {
  "input": "Then the pair of values which align are 1 and 4, multiply them together, and that gives us our first term of our output.",
  "model": "nmt",
  "translatedText": "然后对齐的一对值是 1 和 4，将它们 相乘，这就是我们输出的第一项。",
  "time_range": [
   397.8576842105264,
   403.8133333333333
  ]
 },
 {
  "input": "Slide that bottom array one unit to the right, the pairs which align are 1 and 5, and 2 and 4, multiply those pairs, add them together, and that gives us 13, the next entry in our output.",
  "model": "nmt",
  "translatedText": "将底部数组向右滑动一个单位，对 齐的对是 1 和 5、2 和 4，将这些对相乘，将它们加在一起，得到 13，即输出中的下一个条目。",
  "time_range": [
   403.8133333333333,
   414.29999999999995
  ]
 },
 {
  "input": "Slide things over once more, and we'll take 1 times 6, plus 2 times 5, plus 3 times 4, which happens to be 28.",
  "model": "nmt",
  "translatedText": "再把东西滑过来，我们需要 1 乘以 6，加上 2 乘以 5，再加上 3 乘以 4，正好是 28。",
  "time_range": [
   414.29999999999995,
   421.59130434782605
  ]
 },
 {
  "input": "One more slide, and we get 2 times 6, plus 3 times 5, and that gives us 27, and finally the last term will look like 3 times 6.",
  "model": "nmt",
  "translatedText": "再一张幻灯片，我们得到 2 乘 以 6，加上 3 乘以 5，得到 27，最后一项看起来像 3 乘以 6。",
  "time_range": [
   421.59130434782605,
   430.56
  ]
 },
 {
  "input": "If you'd like, you can pull up whatever your favorite programming language is, and your favorite library that includes various numerical operations, and you can confirm I'm not lying to you.",
  "model": "nmt",
  "translatedText": "如果您愿意，您可以调出您最喜欢的编程语言，以及您最喜 欢的包含各种数值运算的库，并且您可以确认我没有骗您。",
  "time_range": [
   430.56,
   438.8070588235294
  ]
 },
 {
  "input": "If you take the convolution of 1, 2, 3, against 4, 5, 6, this is indeed the result that you'll get.",
  "model": "nmt",
  "translatedText": "如果将 1、2、3 与 4、5、6 进行卷积，这确实是您将得到的结果。",
  "time_range": [
   438.8070588235294,
   444.88
  ]
 },
 {
  "input": "We've seen one case where this is a natural and desirable operation, adding up to probability distributions, and another common example would be a moving average.",
  "model": "nmt",
  "translatedText": "我们已经见过一种情况，这是一种自然且理想的操作，加起来就是概 率分布，另一个常见的例子是移动平均线。",
  "time_range": [
   444.88,
   452.8816161616162
  ]
 },
 {
  "input": "Imagine you have some long list of numbers, and you take another smaller list of numbers that all add up to 1.",
  "model": "nmt",
  "translatedText": "想象一下，您有一个很长的数字 列表，然后您又取了另一个较小的数字列表，这些数字的总和为 1。",
  "time_range": [
   452.8816161616162,
   458.78857142857146
  ]
 },
 {
  "input": "In this case, I just have a little list of 5 values, and they're all equal to 1 5th.",
  "model": "nmt",
  "translatedText": "在本例中，我只有一 个包含 5 个值的小列表，它们都等于 1 5th。",
  "time_range": [
   458.78857142857146,
   463.38166666666666
  ]
 },
 {
  "input": "Then if we do this sliding window convolution process, and kind of close our eyes and sweep under the rug what happens at the very beginning of it, once our smaller list of values entirely overlaps with the bigger one, think about what each term in this convolution really means.",
  "model": "nmt",
  "translatedText": "然后，如果我们进行这 个滑动窗口卷积过程，然后闭上眼睛，扫视一开始发生的情 况，一旦我们较小的值列表与较大的值列表完全重叠，请考 虑其中的每一项卷积的真正含义是。",
  "time_range": [
   463.38166666666666,
   479.0233333333333
  ]
 },
 {
  "input": "At each iteration, what you're doing is multiplying each of the values from your data by 1 5th, and adding them all together, which is to say you're taking an average of your data inside this little window.",
  "model": "nmt",
  "translatedText": "在每次迭代中，您所做的是 将数据中的每个值乘以 1 五分之一，然后将它们全部加在一起 ，也就是说，您在这个小窗口内取数据的平均值。",
  "time_range": [
   479.0233333333333,
   490.76923076923083
  ]
 },
 {
  "input": "Overall, the process gives you a smoothed out version of the original data, and you could modify this starting with a different little list of numbers, and as long as that little list all adds up to 1, you can still interpret it as a moving average.",
  "model": "nmt",
  "translatedText": "总体而言，该过 程为您提供了原始数据的平滑版本，您可以从不同的小数字列 表开始修改它，只要该小列表加起来为 1，您仍然可以将其 解释为移动平均的。",
  "time_range": [
   490.76923076923083,
   502.816
  ]
 },
 {
  "input": "In the example shown here, that moving average would be giving more weight towards the central value.",
  "model": "nmt",
  "translatedText": "在此所示的示例中，移动平均线将给予 中心值更多的权重。",
  "time_range": [
   502.816,
   507.78150537634406
  ]
 },
 {
  "input": "This also results in a smoothed out version of the data.",
  "model": "nmt",
  "translatedText": "这也会产生数据的平滑版本。",
  "time_range": [
   507.78150537634406,
   513.2
  ]
 },
 {
  "input": "If you do kind of a two-dimensional analog of this, it gives you a fun algorithm for blurring a given image.",
  "model": "nmt",
  "translatedText": "如果你对此进行二维模拟，它会给你一个有趣的算法来模糊给定 的图像。",
  "time_range": [
   513.2,
   518.5942857142858
  ]
 },
 {
  "input": "And I should say the animations I'm about to show are modified from something I originally made for part of a set of lectures I did with the Julia Lab at MIT for a certain OpenCourseWare class that included an image processing unit.",
  "model": "nmt",
  "translatedText": "我应该说，我即将展示的动画是根据我最初为我与麻省理工学院的 Jul ia 实验室一起为某个包含图像处理单元的 OpenCourseWare 课 程所做的一组讲座的一部分而制作的动画进行了修改。",
  "time_range": [
   518.5942857142858,
   530.8871111111112
  ]
 },
 {
  "input": "There we did a little bit more to dive into the code behind all of this, so if you're curious I'll leave you some links.",
  "model": "nmt",
  "translatedText": "在那里，我们做了更多的工作 来深入研究所有这些背后的代码，所以如果您好奇，我会给您留下一些链接。",
  "time_range": [
   530.8871111111112,
   536.4521739130435
  ]
 },
 {
  "input": "But focusing back on this blurring example, what's going on is I've got this little 3x3 grid of values that's marching along our original image, and if we zoom in, each one of those values is 1 9th, and what I'm doing at each iteration is multiplying each of those values by the corresponding pixel that it sits on top of.",
  "model": "nmt",
  "translatedText": "但回 到这个模糊的例子，发生的事情是我得到了这个小的 3x3 值网格，它沿着我们的原始图像行进，如果我们放大，这些值中的 每一个都是 1 9th，而我正在做的在每次迭代中，将每个 值乘以它所在的相应像素。",
  "time_range": [
   536.4521739130435,
   553.3128421052633
  ]
 },
 {
  "input": "And of course in computer science we think of colors as little vectors of three values, representing the red, green, and blue components.",
  "model": "nmt",
  "translatedText": "当然，在计算机科学中，我们将 颜色视为三个值的小向量，代表红色、绿色和蓝色分量。",
  "time_range": [
   553.3128421052633,
   560.4
  ]
 },
 {
  "input": "When I multiply all these little values by 1 9th and I add them together, it gives us an average along each color channel, and the corresponding pixel for the image on the right is defined to be that sum.",
  "model": "nmt",
  "translatedText": "当我将所有这些小值乘以 1 9 并将它们加在一起时，它会给 出每个颜色通道的平均值，并且右侧图像的相应像素被定义为该总 和。",
  "time_range": [
   560.4,
   570.9666666666666
  ]
 },
 {
  "input": "The overall effect, as we do this for every single pixel on the image, is that each one kind of bleeds into all of its neighbors, which gives us a blurrier version than the original.",
  "model": "nmt",
  "translatedText": "当我们对图像上的每个像素执行此操作时，总体效果是每种像素都 会渗透到其所有邻居中，这给我们提供了比原始版本更模糊的版本。",
  "time_range": [
   570.9666666666666,
   581.68
  ]
 },
 {
  "input": "In the lingo we'd say that the image on the right is a convolution of our original image with a little grid of values.",
  "model": "nmt",
  "translatedText": "用行话来说，我们会说右侧的图像是原始图像与一些值网 格的卷积。",
  "time_range": [
   581.68,
   587.800412371134
  ]
 },
 {
  "input": "Or more technically maybe I should say that it's the convolution with a 180 degree rotated version of that little grid of values.",
  "model": "nmt",
  "translatedText": "或者从技术上讲，也许我应该说它是与那个小值网 格的 180 度旋转版本的卷积。",
  "time_range": [
   587.800412371134,
   594.4305617977527
  ]
 },
 {
  "input": "Not that it matters when the grid is symmetric, but it's just worth keeping in mind that the definition of a convolution, as inherited from the pure math context, should always invite you to think about flipping around that second array.",
  "model": "nmt",
  "translatedText": "当网格对称时并不重 要，但值得记住的是，从纯数学上下文继承的卷 积定义应该始终邀请您考虑翻转第二个数组。",
  "time_range": [
   594.4305617977527,
   605.76
  ]
 },
 {
  "input": "If we modify this slightly we can get a much more elegant blurring effect by choosing a different grid of values.",
  "model": "nmt",
  "translatedText": "如果我们稍微修改一下，我们可以通过选择不同的值网格来获得更优雅的模 糊效果。",
  "time_range": [
   605.76,
   611.059793814433
  ]
 },
 {
  "input": "In this case I have a little 5x5 grid, but the distinction is not so much its size.",
  "model": "nmt",
  "translatedText": "在本例中，我有一个 5x5 的小网格，但区别并不在于它的大小。",
  "time_range": [
   611.059793814433,
   615.92
  ]
 },
 {
  "input": "If we zoom in we notice that the value in the middle is a lot bigger than the value towards the edges, and where this is coming from is they're all sampled from a bell curve, known as a Gaussian distribution.",
  "model": "nmt",
  "translatedText": "如果我们放大，我们会注意到中间的值比边缘的值大得多 ，这是因为它们都是从钟形曲线（称为高斯分布）中采 样的。",
  "time_range": [
   615.92,
   626.0106666666667
  ]
 },
 {
  "input": "That way when we multiply all of these values by the corresponding pixel that they're sitting on top of, we're giving a lot more weight to that central pixel and much less towards the ones out at the edge.",
  "model": "nmt",
  "translatedText": "这样，当我们将所有这些值乘以它们所在的相应像素 时，我们就会为中心像素赋予更多权重，而为边缘像素赋 予更少权重。",
  "time_range": [
   626.0106666666667,
   636.3678350515464
  ]
 },
 {
  "input": "And just as before the corresponding pixel on the right is defined to be this sum.",
  "model": "nmt",
  "translatedText": "正如之前一样，右侧对应的像素被定义为这个总 和。",
  "time_range": [
   636.3678350515464,
   640.3733333333332
  ]
 },
 {
  "input": "As we do this process for every single pixel it gives a blurring effect which much more authentically simulates the notion of putting your lens out of focus or something like that.",
  "model": "nmt",
  "translatedText": "当我们对每个像素执行此过程时，它会产生模糊 效果，更真实地模拟镜头失焦或类似情况的概念。",
  "time_range": [
   640.3733333333332,
   649.76
  ]
 },
 {
  "input": "But blurring is far from the only thing that you can do with this idea.",
  "model": "nmt",
  "translatedText": "但模糊远不是你可以用这个想法做的唯一事情。",
  "time_range": [
   649.76,
   653.4742857142857
  ]
 },
 {
  "input": "For instance take a look at this little grid of values, which involves some positive numbers on the left and some negative numbers on the right, which I'll color with blue and red respectively.",
  "model": "nmt",
  "translatedText": "例如，看一下这 个小值网格，其中左侧有一些正数，右侧有一些负 数，我将分别用蓝色和红色着色。",
  "time_range": [
   653.4742857142857,
   663.0713402061855
  ]
 },
 {
  "input": "Take a moment to see if you can predict and understand what effect this will have on the final image.",
  "model": "nmt",
  "translatedText": "花点时间看看您是否 可以预测并理解这将对最终图像产生什么影响。",
  "time_range": [
   663.0713402061855,
   669.7697959183673
  ]
 },
 {
  "input": "So in this case I'll just be thinking of the image as grayscale instead of colored, so each of the pixels is just represented by one number instead of three.",
  "model": "nmt",
  "translatedText": "因此，在这种情况下 ，我只会将图像视为灰度而不是彩色，因此每个像素仅由一个数字而 不是三个数字表示。",
  "time_range": [
   669.7697959183673,
   678.0825806451612
  ]
 },
 {
  "input": "And one thing worth noticing is that as we do this convolution it's possible to get negative values.",
  "model": "nmt",
  "translatedText": "值得注意的一件事是，当我们进行卷积时 ，可能会得到负值。",
  "time_range": [
   678.0825806451612,
   683.1020408163265
  ]
 },
 {
  "input": "For example at this point here if we zoom in the left half of our little grid sits entirely on top of black pixels, which would have a value of zero, but the right half of negative values all sit on top of white pixels, which would have a value of one.",
  "model": "nmt",
  "translatedText": "例如，此时，如果我们放大小网格的 左半部分，则完全位于黑色像素的顶部，其值为零，但负 值的右半部分全部位于白色像素的顶部，这将值为 1。",
  "time_range": [
   683.1020408163265,
   696.0
  ]
 },
 {
  "input": "So when we multiply corresponding terms and add them together the results will be very negative, and the way I'm displaying this with the image on the right is to color negative values red and positive values blue.",
  "model": "nmt",
  "translatedText": "因此，当我们将相应项相乘并将它们加在一起时，结果将非常负 ，而我用右侧图像显示此结果的方式是将负值涂成红色，将正值 涂成蓝色。",
  "time_range": [
   696.0,
   706.0463157894737
  ]
 },
 {
  "input": "Another thing to notice is that when you're on a patch that's all the same color everything goes to zero since the sum of the values in our little grid is zero.",
  "model": "nmt",
  "translatedText": "另一件需要注意的事情是，当你在一个颜色相同的补丁上时， 所有的东西都会变为零，因为我们的小网格中的值的总和为零。",
  "time_range": [
   706.0463157894737,
   714.8544329896907
  ]
 },
 {
  "input": "This is very different from the previous two examples where the sum of our little grid was one, which let us interpret it as a moving average and hence a blur.",
  "model": "nmt",
  "translatedText": "这与前两个 示例非常不同，前两个示例中我们的小网格的总和为 1，这让我们将 其解释为移动平均值，因此是模糊的。",
  "time_range": [
   714.8544329896907,
   722.9902222222222
  ]
 },
 {
  "input": "All in all this little process basically detects wherever there's variation in the pixel value as you move from left to right, and so it gives you a kind of way to pick up on all the vertical edges from your image.",
  "model": "nmt",
  "translatedText": "总而言之，这个小过程基本 上可以检测当您从左向右移动时像素值存在变化的地方，因 此它为您提供了一种从图像中拾取所有垂直边缘的方法。",
  "time_range": [
   722.9902222222222,
   736.56
  ]
 },
 {
  "input": "And similarly if we rotated that grid around so that it varies as you move from the top to the bottom this will be picking up on all the horizontal edges, which in the case of our little pie creature image does result in some pretty demonic eyes.",
  "model": "nmt",
  "translatedText": "同样，如果我们旋转该网格，使其随着您从顶部移动到底部而变 化，这将在所有水平边缘上出现，在我们的小馅饼生物图像的情 况下，这确实会导致一些漂亮的恶魔眼睛。",
  "time_range": [
   736.56,
   749.9866666666667
  ]
 },
 {
  "input": "This smaller grid by the way is often called a kernel, and the beauty here is how just by choosing a different kernel you can get different image processing effects, not just blurring your edge detection but also things like sharpening.",
  "model": "nmt",
  "translatedText": "顺便说一句，这个较 小的网格通常称为内核，这里的美妙之处在于，通过选择不同的内核，您 可以获得不同的图像处理效果，不仅模糊边缘检测，还可以实现锐化等 效果。",
  "time_range": [
   749.9866666666667,
   760.7101030927836
  ]
 },
 {
  "input": "For those of you who have heard of a convolutional neural network the idea there is to use data to figure out what the kernels should be in the first place as determined by whatever the neural network wants to detect.",
  "model": "nmt",
  "translatedText": "对于那些听说过卷积神经网络的人来说，其想法是 使用数据来确定内核首先应该是什么，这取决于神经网络 想要检测的内容。",
  "time_range": [
   760.7101030927836,
   771.6180645161292
  ]
 },
 {
  "input": "Another thing I should maybe bring up is the length of the output.",
  "model": "nmt",
  "translatedText": "我应该提出的另一件事是输出的长度。",
  "time_range": [
   771.6180645161292,
   775.3784615384616
  ]
 },
 {
  "input": "For something like the moving average example you might only want to think about the terms when both of the windows fully align with each other, or in the image processing example maybe you want the final output to have the same size as the original.",
  "model": "nmt",
  "translatedText": "对于像移动平均这样的示例，您可能只想考虑两个窗口 彼此完全对齐时的术语，或者在图像处理示例中，您可能希 望最终输出具有与原始大小相同的大小。",
  "time_range": [
   775.3784615384616,
   787.7600000000001
  ]
 },
 {
  "input": "Now convolutions as a pure math operation always produce an array that's bigger than the two arrays that you started with, at least assuming one of them doesn't have a length of one.",
  "model": "nmt",
  "translatedText": "现在，卷积作为一 种纯数学运算总是会产生一个比您开始使用的两个数组更大的数组 ，至少假设其中一个数组的长度不为 1。",
  "time_range": [
   787.7600000000001,
   796.4057142857143
  ]
 },
 {
  "input": "Just know that in certain computer science contexts you often want to deliberately truncate that output.",
  "model": "nmt",
  "translatedText": "只需知道，在某些 计算机科学环境中，您经常想要故意截断该输出。",
  "time_range": [
   796.4057142857143,
   801.52
  ]
 },
 {
  "input": "Another thing worth highlighting is that in the computer science context this notion of flipping around that kernel before you let it march across the original often feels really weird and just uncalled for, but again note that that's what's inherited from the pure math context where like we saw with the probabilities it's an incredibly natural thing to do.",
  "model": "nmt",
  "translatedText": "另一件值得强调的事情是，在计算机科学背景下，在让它跨越 原始内核之前翻转该内核的概念通常感觉非常奇怪并且没有必 要，但再次注意，这是从纯数学背景继承的，就像我们一样从 可能性来看，这是一件非常自然的事情。",
  "time_range": [
   801.52,
   822.5300000000001
  ]
 },
 {
  "input": "And actually I can show you one more pure math example where even the programmers should care about this one because it opens the doors for a much faster algorithm to compute all of these.",
  "model": "nmt",
  "translatedText": "实际上，我可以向您 展示另一个纯数学示例，即使是程序员也应该关心这个示例，因 为它为更快的算法来计算所有这些打开了大门。",
  "time_range": [
   822.5300000000001,
   832.3705263157894
  ]
 },
 {
  "input": "To set up what I mean by faster here let me go back and pull up some python again and I'm going to create two different relatively big arrays.",
  "model": "nmt",
  "translatedText": "为了设置我所说的更 快的意思，让我返回并再次拉起一些 python，我将创建两个不同的相 对较大的数组。",
  "time_range": [
   832.3705263157894,
   839.5793258426966
  ]
 },
 {
  "input": "Each one will have a hundred thousand random elements in it and I'm going to assess the runtime of the convolve function from the numpy library.",
  "model": "nmt",
  "translatedText": "每个都有十万个随机元素，我将评估 numpy 库中卷积函数的运行时间。",
  "time_range": [
   839.5793258426966,
   847.575652173913
  ]
 },
 {
  "input": "And in this case it runs it for multiple different iterations, tries to find an average, and it looks like on this computer at least it averages at 4.",
  "model": "nmt",
  "translatedText": "在本例中， 它运行多次不同的迭代，尝试找到平均值，在这台计算机上 看起来至少平均值为 4。 87秒。",
  "time_range": [
   847.575652173913,
   855.6195121951218
  ]
 },
 {
  "input": "87 seconds.",
  "model": "nmt",
  "translatedText": "",
  "time_range": [
   855.6195121951218,
   856.3219512195121
  ]
 },
 {
  "input": "By contrast if I use a different function from the scipy library called fftconvolve which is the same thing just implemented differently that only takes 4.",
  "model": "nmt",
  "translatedText": "相比之下，如果我使用 scipy 库中名为 fftconvolve 的不同函数，它是相同的函数，只是实现方式不同 ，只需要 4 个函数。",
  "time_range": [
   856.3219512195121,
   866.0616666666667
  ]
 },
 {
  "input": "3 milliseconds on average, so three orders of magnitude improvement.",
  "model": "nmt",
  "translatedText": "平均为 3 毫秒，提高了三个数量级。",
  "time_range": [
   866.0616666666667,
   870.64
  ]
 },
 {
  "input": "And again even though it flies under a different name it's giving the same output that the other convolve function does, it's just doing something to go about it in a cleverer way.",
  "model": "nmt",
  "translatedText": "同样，即使它以不同的名称运行，它也提供与其他卷积 函数相同的输出，它只是以更聪明的方式做一些事情。",
  "time_range": [
   870.64,
   878.88
  ]
 },
 {
  "input": "Remember how with the probability example I said another way you could think about the convolution was to create this table of all the pairwise products and then add up those pairwise products along the diagonals.",
  "model": "nmt",
  "translatedText": "还记得我在概率示例中说过的另一种思考卷积的方法是 创建所有成对乘积的表，然后沿对角线将这些成对乘 积相加。",
  "time_range": [
   878.88,
   892.5279999999999
  ]
 },
 {
  "input": "There's of course nothing specific to probability anytime you're convolving two different lists of numbers you can think about it this way.",
  "model": "nmt",
  "translatedText": "当然，当你将两个不同的数字列表进行卷积时，概 率没有什么特定的，你可以这样思考。",
  "time_range": [
   892.5279999999999,
   899.3212371134019
  ]
 },
 {
  "input": "Create this kind of multiplication table with all pairwise products and then each sum along the diagonal corresponds to one of your final outputs.",
  "model": "nmt",
  "translatedText": "使用所有成对乘积创建 这种乘法表，然后沿对角线的每个和对应于您的最终输出 之一。",
  "time_range": [
   899.3212371134019,
   906.3810752688172
  ]
 },
 {
  "input": "One context where this view is especially natural is when you multiply together two polynomials.",
  "model": "nmt",
  "translatedText": "这种观点特别自然的一种情况是当您将两个多项式 相乘时。",
  "time_range": [
   906.3810752688172,
   912.4316483516483
  ]
 },
 {
  "input": "For example let me take the little grid we already have and replace the top terms with 1, 2x, and 3x squared and replace the other terms with 4, 5x, and 6x squared.",
  "model": "nmt",
  "translatedText": "例如，让我使用已有的小网格，将顶部项替换为 1、2x 和 3x 平方，并将其他项替换为 4、5x 和 6x 平方。",
  "time_range": [
   912.4316483516483,
   923.92
  ]
 },
 {
  "input": "Now think about what it means when we're creating all of these different pairwise products between the two lists.",
  "model": "nmt",
  "translatedText": "现在考虑一下当我们在两个列表之间创建所有这些不同的成对乘积时意味 着什么。",
  "time_range": [
   923.92,
   928.6645454545454
  ]
 },
 {
  "input": "What you're doing is essentially expanding out the full product of the two polynomials I have written down and then when you add up along the diagonal that corresponds to collecting all like terms which is pretty neat expanding a polynomial and collecting like terms is exactly the same process as a convolution.",
  "model": "nmt",
  "translatedText": "你所做的本质上是展开我写下的两个多项式的 完整乘积，然后当你沿着对应于收集所有相似项的对角 线相加时，这非常整齐地展开多项式并收集相似项正 是与卷积相同的过程。",
  "time_range": [
   928.6645454545454,
   946.9371428571429
  ]
 },
 {
  "input": "But this allows us to do something that's pretty cool because think about what we're saying here.",
  "model": "nmt",
  "translatedText": "但这使我们能够做一些非常酷的事情， 因为想想我们在这里所说的。",
  "time_range": [
   946.9371428571429,
   952.6424242424243
  ]
 },
 {
  "input": "We're saying if you take two different functions and you multiply them together which is a simple pointwise operation that's the same thing as if you had first extracted the coefficients from each one of those assuming they're polynomials and then taken a convolution of those two lists of coefficients.",
  "model": "nmt",
  "translatedText": "我们的意思是，如果你采用两个不同的 函数并将它们相乘，这是一个简单的逐点运算，这与你首先从 每个函数中提取系数（假设它们是多项式）然后对这些函数进行 卷积是一样的两个系数列表。",
  "time_range": [
   952.6424242424243,
   968.7615999999999
  ]
 },
 {
  "input": "What makes that so interesting is that convolutions feel in principle a lot more complicated than simple multiplication and I don't just mean conceptually they're harder to think about I mean computationally it requires more steps to perform a convolution than it does to perform a pointwise product of two different lists.",
  "model": "nmt",
  "translatedText": "有趣的是，卷积在原则上感觉 比简单的乘法复杂得多，我不仅仅意味着在概念上它们 更难思考，我的意思是在计算上它需要更多的步骤来执行 卷积而不是执行两个不同列表的逐点乘积。",
  "time_range": [
   968.7615999999999,
   986.0702040816327
  ]
 },
 {
  "input": "For example let's say I gave you two really big polynomials say each one with a hundred different coefficients then if the way you multiply them was to expand out this product you know filling in this entire 100 by 100 grid of pairwise products that would require you to perform 10,000 different products and then when you're collecting all the like terms along the diagonals that's another set of around 10,000 operations.",
  "model": "nmt",
  "translatedText": "例如，假设我 给了你两个非常大的多项式，每个多项式都有一百个不同的系数，那么如果 你将它们相乘的方式是展开这个乘积，你知道填充整个 100 x 1 00 的成对乘积网格，这需要你执行 10,000 种不同的产品， 然后当您沿着对角线收集所有相似项时，这是另一组大约 10,000 次操作。",
  "time_range": [
   986.0702040816327,
   1009.6666666666665
  ]
 },
 {
  "input": "More generally in the lingo we'd say the algorithm is O of n squared meaning for two lists of size n the way that the number of operations scales is in proportion to the square of n.",
  "model": "nmt",
  "translatedText": "更一般地说，在行话中，我们会说该算法是 O of n 平 方，这意味着对于两个大小为 n 的列表，操作数量与 n 的平方成正比。",
  "time_range": [
   1009.6666666666665,
   1020.816
  ]
 },
 {
  "input": "On the other hand if I think of two polynomials in terms of their outputs for example sampling their values at some handful of inputs then multiplying them only requires as many operations as the number of samples since again it's a pointwise operation and with polynomials you only need finitely many samples to be able to recover the coefficients.",
  "model": "nmt",
  "translatedText": "另一方面，如果我根据输出来考虑两个多项式，例如在一 些输入处对它们的值进行采样，那么将它们相乘只需要与样本 数一样多的运算，因为这又是一个逐点运算，并且对于多项 式，您只需要有限多个样本能够恢复系数。",
  "time_range": [
   1020.816,
   1041.126530612245
  ]
 },
 {
  "input": "For example two outputs are enough to uniquely specify a linear polynomial three outputs would be enough to uniquely specify a quadratic polynomial and in general if you know n distinct outputs that's enough to uniquely specify a polynomial that has n different coefficients or if you prefer we could phrase this in the language of systems of equations imagine I tell you I have some polynomial but I don't tell you what the coefficients are those are a mystery to you.",
  "model": "nmt",
  "translatedText": "例如，两个输出足 以唯一地指定一个线性多项式，三个输出足以唯一地指定一个二次 多项式，一般来说，如果您知道 n 个不同的输出，则足以唯一地 指定具有 n 个不同系数的多项式，或者如果您愿意，我们可以 用方程组的语言来表达这个假设我告诉你我有一些多项式，但我没有 告诉你系数是什么，这些对你来说是个谜。",
  "time_range": [
   1041.126530612245,
   1066.439603960396
  ]
 },
 {
  "input": "In our example you might think of this as the product that we're trying to figure out and then suppose I say I'll just tell you what the outputs of this polynomial would be if you inputted various different inputs like 0, 1, 2, 3, on and on and I give you enough so that you have as many equations as you have unknowns it even happens to be a linear system of equations so that's nice and in principle at least this should be enough to recover the coefficients.",
  "model": "nmt",
  "translatedText": "在我们的示例中，您可 能会认为这是我们试图找出的乘积，然后假设我说，如果您输入各种 不同的输入（例如 0、1、2），我会告诉您该多项式的输出是什 么，3，等等，我给你足够的，这样你就有了与未知数一样多的方程 ，它甚至碰巧是一个线性方程组，所以这很好，原则上至少这应该 足以恢复系数。",
  "time_range": [
   1066.439603960396,
   1091.0618181818181
  ]
 }
]