1
00:00:00,000 --> 00:00:03,823
فرض کنید من دو لیست مختلف از اعداد، یا شاید دو تابع متفاوت را به شما می‌دهم، و از شما

2
00:00:03,823 --> 00:00:07,825
می‌خواهم به تمام روش‌هایی فکر کنید که می‌توانید این دو فهرست را برای به دست آوردن یک لیست

3
00:00:07,825 --> 00:00:11,782
جدید از اعداد ترکیب کنید، یا این دو تابع را برای به دست آوردن یک تابع جدید ترکیب کنید. .

4
00:00:11,782 --> 00:00:16,270
شاید یکی از راه‌های ساده‌ای که به ذهن می‌رسد این باشد که آن‌ها را به سادگی با هم جمع کنیم.

5
00:00:16,270 --> 00:00:16,320


6
00:00:16,320 --> 00:00:20,131
به همین ترتیب با توابع، می توانید تمام خروجی های مربوطه را اضافه کنید.

7
00:00:20,131 --> 00:00:26,202
در روشی مشابه، می‌توانید دو فهرست را در ترم ضرب کنید و همین کار را با توابع انجام دهید.

8
00:00:26,202 --> 00:00:30,047
اما نوع دیگری از ترکیب وجود دارد که به همان اندازه هر دوی آنها اساسی است،

9
00:00:30,047 --> 00:00:33,840
اما بسیار کمتر مورد بحث قرار می گیرد، که به عنوان پیچیدگی شناخته می شود.

10
00:00:33,840 --> 00:00:36,679
اما برخلاف دو مورد قبلی، این چیزی نیست که صرفاً از

11
00:00:36,679 --> 00:00:39,964
عملیاتی به ارث رسیده باشد که بتوانید روی اعداد انجام دهید.

12
00:00:39,964 --> 00:00:44,809
این چیزی واقعاً جدید برای زمینه فهرست اعداد یا ترکیب توابع است.

13
00:00:44,809 --> 00:00:49,906
آنها در همه جا ظاهر می شوند، در پردازش تصویر در همه جا حاضر هستند، این یک ساختار اصلی

14
00:00:49,906 --> 00:00:55,062
در نظریه احتمال است، آنها در حل معادلات دیفرانسیل بسیار استفاده می شوند، و زمینه ای که

15
00:00:55,062 --> 00:01:00,277
تقریباً مطمئناً آن را دیده اید، اگر نه. با این نام، دو چند جمله ای را با هم ضرب می کند.

16
00:01:00,277 --> 00:01:04,821
به عنوان کسی که در تجارت توضیحات بصری فعالیت می کند، این موضوع بسیار عالی است،

17
00:01:04,821 --> 00:01:09,481
زیرا تعریف فرمولی به صورت مجزا و بدون زمینه می تواند ترسناک به نظر برسد، اما اگر

18
00:01:09,481 --> 00:01:13,910
وقت بگذاریم تا واقعاً آنچه را که می گوید باز کنیم و قبل از آن در واقع انگیزه

19
00:01:13,910 --> 00:01:18,800
ایجاد کنیم که چرا شما چیزی شبیه به این را می خواهید، این یک عمل فوق العاده زیبا است.

20
00:01:18,800 --> 00:01:21,157
و باید اعتراف کنم، در واقع در کنار هم قرار دادن

21
00:01:21,157 --> 00:01:23,514
تصاویری برای این پروژه، چیزهای کوچکی یاد گرفتم.

22
00:01:23,514 --> 00:01:28,484
در مورد در هم آمیختن دو تابع مختلف، سعی می کردم به راه های مختلفی فکر کنم که بتوانید

23
00:01:28,484 --> 00:01:33,337
معنی آن را تصور کنید، و با یکی از آنها کمی آها داشتم که چرا توزیع های عادی نقشی را

24
00:01:33,337 --> 00:01:38,483
ایفا می کنند. آنها به احتمال زیاد انجام می دهند، چرا این یک شکل طبیعی برای یک تابع است.

25
00:01:38,483 --> 00:01:41,645
اما من دارم از خودم جلو می گیرم، تنظیمات زیادی برای آن وجود دارد.

26
00:01:41,645 --> 00:01:45,999
در این ویدیو، تمرکز اصلی ما فقط بر روی موارد گسسته است، و به ویژه ایجاد

27
00:01:45,999 --> 00:01:50,293
یک الگوریتم بسیار غیرمنتظره اما بسیار هوشمندانه برای محاسبه این موارد.

28
00:01:50,293 --> 00:01:54,400
و من بحث برای مورد مستمر را به بخش دوم می کشم.

29
00:01:54,400 --> 00:01:59,690
بسیار وسوسه انگیز است که نمونه های پردازش تصویر را باز کنیم، زیرا آنها از نظر

30
00:01:59,690 --> 00:02:05,252
بصری جذاب ترین هستند، اما چند نکته ظریف وجود دارد که باعث می شود کیس پردازش تصویر

31
00:02:05,252 --> 00:02:11,221
کمتر نماینده کانولوشن ها باشد، بنابراین در عوض اجازه دهید کارها را با احتمال شروع کنیم.

32
00:02:11,221 --> 00:02:16,648
و به ویژه یکی از ساده‌ترین نمونه‌هایی که مطمئنم همه اینجا در مقطعی از زندگی خود

33
00:02:16,648 --> 00:02:21,600
به آن فکر کرده‌اند، یعنی انداختن یک جفت تاس و کشف شانس دیدن مبالغ مختلف.

34
00:02:21,600 --> 00:02:24,213
و ممکن است بگویید، مشکل نیست، مشکل نیست.

35
00:02:24,213 --> 00:02:29,939
هر یک از دو تاس شما دارای شش نتیجه ممکن متفاوت است که در مجموع 36 جفت نتیجه ممکن متمایز

36
00:02:29,939 --> 00:02:35,600
را به ما می دهد، و اگر فقط به همه آنها نگاه کنیم، می توانیم تعداد جفت ها را حساب کنیم.

37
00:02:35,600 --> 00:02:40,547
و مرتب کردن همه جفت ها در یک شبکه مانند این، یک چیز بسیار خوب این است که همه جفت

38
00:02:40,547 --> 00:02:45,678
هایی که دارای مجموع ثابت هستند در امتداد یکی از این قطرهای مختلف قابل مشاهده هستند.

39
00:02:45,678 --> 00:02:48,850
بنابراین به سادگی شمارش تعداد موجود در هر یک از آن مورب ها به

40
00:02:48,850 --> 00:02:51,920
شما نشان می دهد که چقدر احتمال دارد یک مجموع خاص را ببینید.

41
00:02:58,788 --> 00:03:00,046
و من می‌توانم بگویم، بسیار خوب، بسیار خوب، اما آیا می‌توانید راه‌های

42
00:03:00,046 --> 00:03:01,303
دیگری برای تجسم همان سؤال در نظر بگیرید؟ تصاویر دیگری که می تواند به

43
00:03:01,303 --> 00:03:02,524
ذهن متبادر شود تا به تمام جفت های متمایز که دارای مجموع معین هستند

44
00:03:02,524 --> 00:03:03,836
فکر کنید؟ و شاید یکی از شما دستش را بلند کند و بگوید، بله، من یکی دارم.

45
00:03:07,586 --> 00:03:10,704
فرض کنید این دو مجموعه متفاوت از احتمالات را هر کدام

46
00:03:10,704 --> 00:03:14,056
پشت سر هم تصویر می کنید، اما آن ردیف دوم را ورق می زنید.

47
00:03:14,056 --> 00:03:16,393
به این ترتیب تمام جفت‌های مختلف که مجموعاً به

48
00:03:16,393 --> 00:03:18,984
هفت می‌رسد، به‌طور عمودی به این شکل قرار می‌گیرند.

49
00:03:18,984 --> 00:03:22,858
و اگر آن ردیف پایین را تا انتها به سمت راست بلغزانیم، آنگاه جفت منحصربه‌فردی

50
00:03:22,858 --> 00:03:26,380
که به دو عدد می‌رسد، چشم‌های مار، تنها آن‌هایی هستند که همسو می‌شوند.

51
00:03:26,380 --> 00:03:29,575
و اگر آن را بیش از یک واحد به سمت راست پرت کنم، جفت هایی

52
00:03:29,575 --> 00:03:32,938
که تراز می شوند دو جفت مختلف هستند که مجموع آنها سه می شود.

53
00:03:32,938 --> 00:03:37,349
و به طور کلی، مقادیر مختلف افست این آرایه پایین‌تر، که به یاد داشته باشید ابتدا

54
00:03:37,349 --> 00:03:41,926
باید به اطراف برگردم، همه جفت‌های متمایز را نشان می‌دهد که دارای مجموع معین هستند.

55
00:03:41,926 --> 00:03:47,351
تا آنجایی که سوالات احتمالی مطرح می شود، این هنوز به خصوص جالب نیست، زیرا تمام

56
00:03:47,351 --> 00:03:53,120
کاری که ما انجام می دهیم این است که تعداد نتایج در هر یک از این دسته ها را بشماریم.

57
00:03:53,120 --> 00:03:57,941
اما این با این فرض ضمنی است که شانس برابری برای هر یک از این چهره ها وجود دارد.

58
00:04:01,909 --> 00:04:04,500
اما اگر به شما بگویم یک مجموعه تاس خاص دارم که یکنواخت نیست چه؟ شاید قالب آبی

59
00:04:04,500 --> 00:04:07,158
مجموعه ای از اعداد خاص خود را داشته باشد که احتمالات را برای هر چهره ای که بالا

60
00:04:07,158 --> 00:04:09,782
می آید توصیف می کند، و قالب قرمز مجموعه اعداد متمایز منحصر به فرد خود را دارد.

61
00:04:09,782 --> 00:04:14,900
در آن صورت، اگر می‌خواهید مثلاً احتمال دیدن یک دو را بفهمید، احتمال

62
00:04:14,900 --> 00:04:19,943
اینکه قالب آبی یک عدد است را ضرب کنید در احتمال یک بودن قالب قرمز.

63
00:04:19,943 --> 00:04:24,885
و برای شانس دیدن سه، شما به دو جفت متمایز در جایی که ممکن است نگاه کنید،

64
00:04:24,885 --> 00:04:30,029
و دوباره، احتمالات مربوطه را ضرب کنید، و سپس آن دو محصول را با هم جمع کنید.

65
00:04:30,029 --> 00:04:33,472
به طور مشابه، شانس دیدن یک چهار شامل ضرب کردن سه

66
00:04:33,472 --> 00:04:36,845
جفت احتمال مختلف و جمع کردن همه آنها با هم است.

67
00:04:36,845 --> 00:04:41,503
و با روح تنظیم چند فرمول، این احتمالات بالا را a1، a2، a3 و غیره

68
00:04:41,503 --> 00:04:45,946
نامگذاری می کنیم و موارد پایین را b1، b2، b3 و غیره می نامیم.

69
00:04:45,946 --> 00:04:49,879
و به طور کلی، این فرآیند، که در آن ما دو آرایه مختلف از اعداد را می گیریم،

70
00:04:49,879 --> 00:04:53,760
دومی را به اطراف برمی گردانیم، و سپس آنها را در مقادیر مختلف افست ردیف می

71
00:04:53,760 --> 00:04:57,483
کنیم، دسته ای از محصولات جفتی را می گیریم و آنها را با هم جمع می کنیم،

72
00:04:57,483 --> 00:05:01,311
این یکی از موارد است. راه های اساسی برای فکر کردن به اینکه پیچیدگی چیست.

73
00:05:01,311 --> 00:05:06,563
بنابراین فقط برای توضیح دقیق تر، از طریق این فرآیند، ما فقط احتمالاتی

74
00:05:06,563 --> 00:05:11,891
را برای دیدن دو، سه، چهار، روی و روی تا 12 ایجاد کردیم و با ترکیب کردن

75
00:05:11,891 --> 00:05:17,143
یک لیست از مقادیر، a و دیگری، آنها را به دست آوردیم. فهرست مقادیر، ب.

76
00:05:17,143 --> 00:05:21,920
در زبان انگلیسی، می‌توان گفت که پیچیدگی آن دو دنباله، این توالی جدید را به ما

77
00:05:21,920 --> 00:05:27,188
می‌دهد، دنباله جدیدی از 11 مقدار، که هر کدام شبیه به مجموعه‌ای از محصولات زوجی هستند.

78
00:05:27,188 --> 00:05:31,876
اگر ترجیح می دهید، راه دیگری که می توانید در مورد همان عملیات فکر کنید این است که

79
00:05:31,876 --> 00:05:36,793
ابتدا جدولی از تمام محصولات جفتی ایجاد کنید و سپس در امتداد همه این مورب ها جمع کنید.

80
00:05:36,793 --> 00:05:39,478
باز هم، این راهی است که این دو دنباله اعداد را با هم

81
00:05:39,478 --> 00:05:42,315
مخلوط می کنیم تا دنباله ای جدید از 11 عدد به دست آوریم.

82
00:05:42,315 --> 00:05:46,400
این همان عملیاتی است که پنجره های کشویی فکر می کردند، فقط یک چشم انداز دیگر.

83
00:05:46,400 --> 00:05:50,335
با قرار دادن یک نماد کوچک روی آن، در اینجا نحوه نوشتن آن را مشاهده می کنید.

84
00:05:50,335 --> 00:05:55,002
پیچیدگی a و b که با این ستاره کوچک نشان داده می شود، یک لیست جدید

85
00:05:55,002 --> 00:05:59,812
است و عنصر n از آن لیست شبیه یک جمع است و این مجموع روی همه جفت های

86
00:05:59,812 --> 00:06:04,833
مختلف شاخص ها، i و j می رود، به طوری که مجموع این شاخص ها برابر n است.

87
00:06:04,833 --> 00:06:10,150
این نوعی لقمه است، اما به عنوان مثال، اگر n 6 بود، جفت هایی که می رویم 1 و

88
00:06:10,150 --> 00:06:15,680
5، 2 و 4، 3 و 3، 4 و 2، 5 و 1 هستند، همه جفت های مختلفی که جمع می شوند. به 6.

89
00:06:15,680 --> 00:06:19,439
اما صادقانه بگویم، هر طور که آن را بنویسید، نماد از نظر اهمیت در درجه

90
00:06:19,439 --> 00:06:23,145
دوم اهمیت بصری است که ممکن است برای این فرآیند در ذهن خود نگه دارید.

91
00:06:23,145 --> 00:06:27,004
در اینجا، شاید انجام یک مثال بسیار ساده کمک کند، جایی که ممکن

92
00:06:27,004 --> 00:06:30,987
است از شما بپرسم که پیچیدگی لیست 1، 2، 3، با لیست 4، 5، 6 چیست.

93
00:06:30,987 --> 00:06:34,486
ممکن است تصور کنید که هر دوی این لیست ها را گرفته اید، لیست

94
00:06:34,486 --> 00:06:37,926
دوم را ورق می زنید و سپس با درب آن به سمت چپ شروع می کنید.

95
00:06:37,926 --> 00:06:40,859
سپس جفت مقادیری که 1 و 4 هستند، آنها را با هم ضرب

96
00:06:40,859 --> 00:06:43,851
می کنیم و این اولین جمله خروجی ما را به ما می دهد.

97
00:06:43,851 --> 00:06:49,171
آرایه پایینی را یک واحد به سمت راست بلغزانید، جفت هایی که 1 و 5 و 2 و 4 هستند، آن جفت

98
00:06:49,171 --> 00:06:54,367
ها را ضرب کنید، آنها را با هم جمع کنید، و این به ما 13 می دهد، ورودی بعدی در خروجی.

99
00:06:54,367 --> 00:06:57,951
یک بار دیگر چیزها را روی صفحه بکشید، و ما 1 ضربدر 6، به علاوه

100
00:06:57,951 --> 00:07:01,651
2 ضربدر 5، به علاوه 3 ضربدر 4 را می گیریم که اتفاقاً 28 می شود.

101
00:07:01,651 --> 00:07:05,825
یک اسلاید دیگر، و ما 2 ضربدر 6، به اضافه 3 ضرب در 5 می گیریم، و این

102
00:07:05,825 --> 00:07:10,000
به ما 27 می دهد، و در نهایت ترم آخر مانند 3 ضرب در 6 به نظر می رسد.

103
00:07:10,000 --> 00:07:12,922
اگر بخواهید، می‌توانید هر زبان برنامه‌نویسی مورد علاقه‌تان و

104
00:07:12,922 --> 00:07:15,892
کتابخانه مورد علاقه‌تان را که شامل عملیات‌های عددی مختلف است،

105
00:07:15,892 --> 00:07:18,910
بالا بکشید، و می‌توانید تأیید کنید که من به شما دروغ نمی‌گویم.

106
00:07:18,910 --> 00:07:21,586
اگر انحراف 1، 2، 3 را در مقابل 4، 5، 6 بگیرید،

107
00:07:21,586 --> 00:07:24,320
این در واقع نتیجه ای است که به دست خواهید آورد.

108
00:07:24,320 --> 00:07:28,681
ما یک مورد را دیده‌ایم که در آن این یک عملیات طبیعی و مطلوب است و به

109
00:07:28,681 --> 00:07:32,916
توزیع‌های احتمال اضافه می‌شود، و مثال رایج دیگر میانگین متحرک است.

110
00:07:32,916 --> 00:07:36,027
تصور کنید یک لیست طولانی از اعداد دارید و یک لیست کوچکتر

111
00:07:36,027 --> 00:07:38,811
از اعداد را انتخاب می کنید که مجموع آنها 1 می شود.

112
00:07:38,811 --> 00:07:43,420
در این مورد، من فقط یک لیست کوچک از 5 مقدار دارم، و همه آنها برابر با 1 5 هستند.

113
00:07:43,420 --> 00:07:48,758
سپس اگر این فرآیند پیچش پنجره کشویی را انجام دهیم، و به نوعی چشمانمان را ببندیم و آنچه

114
00:07:48,758 --> 00:07:53,850
را که در همان ابتدای آن اتفاق می‌افتد، زیر فرش بکشیم، وقتی فهرست کوچک‌تر مقادیر ما

115
00:07:53,850 --> 00:07:59,066
کاملاً با مقادیر بزرگ‌تر همپوشانی پیدا کرد، به این فکر کنید که هر عبارت در این چیست.

116
00:07:59,066 --> 00:08:02,940
پیچیدگی واقعاً یعنی در هر تکرار، کاری که انجام می‌دهید این است که هر یک

117
00:08:02,940 --> 00:08:06,707
از مقادیر داده‌های خود را در 1 5 ضرب می‌کنید، و همه آنها را با هم جمع

118
00:08:06,707 --> 00:08:10,797
می‌کنید، به این معنی که میانگین داده‌های خود را در این پنجره کوچک می‌گیرید.

119
00:08:10,797 --> 00:08:14,859
به طور کلی، این فرآیند یک نسخه هموار از داده های اصلی را به شما ارائه می دهد،

120
00:08:14,859 --> 00:08:18,868
و می توانید این را با یک لیست کوچک متفاوت از اعداد تغییر دهید، و تا زمانی که

121
00:08:18,868 --> 00:08:22,878
آن لیست کوچک به 1 برسد، همچنان می توانید آن را به عنوان یک متحرک تفسیر کنید.

122
00:08:22,878 --> 00:08:25,276
میانگین. در مثالی که در اینجا نشان داده شده است،

123
00:08:25,276 --> 00:08:27,822
میانگین متحرک وزن بیشتری به سمت مقدار مرکزی می دهد.

124
00:08:27,822 --> 00:08:30,720
این همچنین منجر به یک نسخه هموار از داده ها می شود.

125
00:08:30,720 --> 00:08:34,454
اگر یک آنالوگ دو بعدی از آن انجام دهید، یک الگوریتم

126
00:08:34,454 --> 00:08:38,691
سرگرم کننده برای محو کردن یک تصویر داده شده به شما می دهد.

127
00:08:38,691 --> 00:08:42,878
و باید بگویم انیمیشن‌هایی که می‌خواهم نشان دهم از چیزی که من در ابتدا برای

128
00:08:42,878 --> 00:08:46,786
بخشی از مجموعه سخنرانی‌هایی که با آزمایشگاه جولیا در MIT برای یک کلاس

129
00:08:46,786 --> 00:08:50,918
OpenCourseWare انجام دادم اصلاح شده‌اند که شامل یک واحد پردازش تصویر بود.

130
00:08:50,918 --> 00:08:53,452
در آنجا ما کمی بیشتر کار کردیم تا به کد پشت همه اینها

131
00:08:53,452 --> 00:08:56,456
بپردازیم، بنابراین اگر کنجکاو هستید چند لینک برای شما می گذارم.

132
00:08:56,456 --> 00:09:00,601
اما با تمرکز بر روی این مثال تار، اتفاقی که می افتد این است که من این شبکه

133
00:09:00,601 --> 00:09:04,636
کوچک 3x3 از مقادیر را دارم که در امتداد تصویر اصلی ما حرکت می کند، و اگر

134
00:09:04,636 --> 00:09:08,837
بزرگنمایی کنیم، هر یک از آن مقادیر 1 9 است، و کاری که من انجام می دهم در هر

135
00:09:08,837 --> 00:09:13,369
تکرار، هر یک از آن مقادیر را در پیکسل مربوطه ای که بالای آن قرار دارد ضرب می کند.

136
00:09:13,369 --> 00:09:16,939
و البته در علوم کامپیوتر ما رنگ ها را بردارهای کوچکی از سه مقدار

137
00:09:16,939 --> 00:09:20,400
در نظر می گیریم که نشان دهنده مولفه های قرمز، سبز و آبی هستند.

138
00:09:20,400 --> 00:09:23,978
وقتی همه این مقادیر کوچک را در 19 ضرب می‌کنم و آنها را با هم

139
00:09:23,978 --> 00:09:27,556
جمع می‌کنم، میانگینی را در امتداد هر کانال رنگی به ما می‌دهد

140
00:09:27,556 --> 00:09:31,075
و پیکسل مربوطه برای تصویر سمت راست همان مجموع تعریف می‌شود.

141
00:09:31,075 --> 00:09:35,948
اثر کلی، همانطور که ما این کار را برای هر پیکسل روی تصویر انجام می‌دهیم، این است که

142
00:09:35,948 --> 00:09:40,880
هر یک به همه همسایگان خود وارد می‌شود، که نسخه‌ای مبهم‌تر از نسخه اصلی به ما می‌دهد.

143
00:09:40,880 --> 00:09:47,885
در زبان ما می گوییم که تصویر سمت راست پیچیدگی تصویر اصلی ما با شبکه کوچکی از مقادیر است.

144
00:09:47,885 --> 00:09:51,208
یا از نظر فنی تر، شاید باید بگویم که این پیچیدگی با

145
00:09:51,208 --> 00:09:54,468
یک نسخه چرخشی 180 درجه از آن شبکه کوچک مقادیر است.

146
00:09:54,468 --> 00:09:58,272
نه اینکه متقارن بودن شبکه مهم باشد، اما فقط باید در نظر داشت که

147
00:09:58,272 --> 00:10:02,134
تعریف کانولوشن، همانطور که از زمینه ریاضی خالص به ارث رسیده است،

148
00:10:02,134 --> 00:10:05,760
همیشه باید شما را به فکر کردن در مورد آن آرایه دوم دعوت کند.

149
00:10:05,760 --> 00:10:08,430
اگر این را کمی تغییر دهیم، می‌توانیم با انتخاب شبکه‌ای

150
00:10:08,430 --> 00:10:11,148
متفاوت از مقادیر، جلوه تاری بسیار زیباتری به دست آوریم.

151
00:10:11,148 --> 00:10:15,920
در این مورد من یک شبکه کوچک 5x5 دارم، اما تمایز آن به اندازه آن نیست.

152
00:10:15,920 --> 00:10:19,360
اگر بزرگنمایی کنیم متوجه می‌شویم که مقدار در وسط بسیار بزرگتر از مقدار به

153
00:10:19,360 --> 00:10:22,708
سمت لبه‌ها است، و از جایی که این مقدار می‌آید این است که همه آنها از یک

154
00:10:22,708 --> 00:10:26,102
منحنی زنگی، که به عنوان توزیع گاوسی شناخته می‌شود، نمونه‌برداری شده‌اند.

155
00:10:26,102 --> 00:10:29,472
به این ترتیب وقتی همه این مقادیر را در پیکسل متناظری که در

156
00:10:29,472 --> 00:10:32,841
بالای آن قرار دارند ضرب می کنیم، وزن بسیار بیشتری به پیکسل

157
00:10:32,841 --> 00:10:36,439
مرکزی می دهیم و به پیکسل هایی که در لبه قرار دارند بسیار کمتر.

158
00:10:36,439 --> 00:10:40,475
و درست مانند قبل پیکسل مربوطه در سمت راست به این مجموع تعریف شده است.

159
00:10:40,475 --> 00:10:45,037
همانطور که ما این فرآیند را برای هر پیکسل انجام می‌دهیم، جلوه‌ای تار ایجاد می‌کند که

160
00:10:45,037 --> 00:10:49,760
به‌طور واقعی‌تر تصور خارج کردن لنز شما از فوکوس یا چیزی شبیه به آن را شبیه‌سازی می‌کند.

161
00:10:49,760 --> 00:10:53,504
اما محو کردن تنها کاری است که می توانید با این ایده انجام دهید.

162
00:10:53,504 --> 00:10:58,215
به عنوان مثال به این شبکه کوچک مقادیر، که شامل تعدادی اعداد مثبت در سمت چپ و برخی

163
00:10:58,215 --> 00:11:03,099
اعداد منفی در سمت راست است، نگاهی بیندازید، که من به ترتیب با آبی و قرمز رنگ می‌کنم.

164
00:11:03,099 --> 00:11:06,541
چند لحظه وقت بگذارید تا ببینید آیا می توانید پیش بینی کنید

165
00:11:06,541 --> 00:11:09,808
و بفهمید که چه تاثیری بر تصویر نهایی خواهد داشت یا خیر.

166
00:11:09,808 --> 00:11:14,004
بنابراین در این مورد، من فقط تصویر را به‌جای رنگی، به‌عنوان مقیاس خاکستری در نظر

167
00:11:14,004 --> 00:11:18,149
می‌گیرم، بنابراین هر یک از پیکسل‌ها فقط با یک عدد به جای سه نمایش داده می‌شوند.

168
00:11:18,149 --> 00:11:20,657
و نکته ای که ارزش توجه دارد این است که با انجام

169
00:11:20,657 --> 00:11:23,164
این پیچیدگی امکان دریافت مقادیر منفی وجود دارد.

170
00:11:23,164 --> 00:11:27,146
به عنوان مثال، در این نقطه، اگر در نیمه چپ بزرگنمایی کنیم، شبکه

171
00:11:27,146 --> 00:11:31,066
کوچک ما کاملاً روی پیکسل‌های سیاه قرار می‌گیرد که مقدار آن صفر

172
00:11:31,066 --> 00:11:35,360
است، اما نیمه سمت راست مقادیر منفی روی پیکسل‌های سفید قرار می‌گیرند.

173
00:11:35,360 --> 00:11:38,884
ارزش یک دارند بنابراین وقتی عبارت‌های متناظر را ضرب می‌کنیم و آنها را با هم

174
00:11:38,884 --> 00:11:42,547
جمع می‌کنیم، نتایج بسیار منفی خواهد بود، و روشی که من این را با تصویر سمت راست

175
00:11:42,547 --> 00:11:46,117
نشان می‌دهم این است که مقادیر منفی را قرمز و مقادیر مثبت را آبی رنگ می‌کنیم.

176
00:11:46,117 --> 00:11:50,432
نکته دیگری که باید به آن توجه کنید این است که وقتی روی یک وصله همرنگ

177
00:11:50,432 --> 00:11:54,871
هستید همه چیز به صفر می رسد زیرا مجموع مقادیر در شبکه کوچک ما صفر است.

178
00:11:54,871 --> 00:11:58,960
این بسیار متفاوت از دو مثال قبلی است که در آن مجموع شبکه کوچک ما یک بود، که

179
00:11:58,960 --> 00:12:03,050
به ما اجازه می دهد آن را به عنوان میانگین متحرک و در نتیجه تاری تفسیر کنیم.

180
00:12:03,050 --> 00:12:06,708
در مجموع، این فرآیند کوچک اساساً هر جا که تغییری در مقدار پیکسل وجود

181
00:12:06,708 --> 00:12:10,154
داشته باشد، هنگام حرکت از چپ به راست، شناسایی می‌کند، و بنابراین

182
00:12:10,154 --> 00:12:13,760
نوعی روش برای برداشتن تمام لبه‌های عمودی تصویر به شما ارائه می‌دهد.

183
00:12:13,760 --> 00:12:19,180
و به طور مشابه، اگر شبکه را به اطراف بچرخانیم تا با حرکت از بالا

184
00:12:19,180 --> 00:12:24,766
به پایین تغییر کند، تمام لبه‌های افقی جمع می‌شود، که در مورد تصویر

185
00:12:24,766 --> 00:12:30,020
موجود کوچک پای ما، منجر به چشم‌های شیطانی بسیار زیبایی می‌شود.

186
00:12:30,020 --> 00:12:33,610
به هر حال، این شبکه کوچک‌تر اغلب هسته نامیده می‌شود، و زیبایی اینجاست که چگونه فقط

187
00:12:33,610 --> 00:12:37,245
با انتخاب یک هسته متفاوت می‌توانید جلوه‌های پردازش تصویر متفاوتی را دریافت کنید، نه

188
00:12:37,245 --> 00:12:40,792
تنها تشخیص لبه‌های خود را محو کنید، بلکه چیزهایی مانند شارپ کردن را نیز محو کنید.

189
00:12:40,792 --> 00:12:44,425
برای کسانی از شما که نام یک شبکه عصبی کانولوشنال را شنیده‌اید، این

190
00:12:44,425 --> 00:12:47,950
ایده این است که از داده‌ها برای فهمیدن اینکه هسته‌ها در وهله اول

191
00:12:47,950 --> 00:12:51,691
باید چه باشند، همانطور که شبکه عصبی می‌خواهد تشخیص دهد، مشخص می‌شود.

192
00:12:51,691 --> 00:12:55,457
نکته دیگری که شاید باید مطرح کنم طول خروجی است.

193
00:12:55,457 --> 00:12:59,567
برای چیزی مانند مثال میانگین متحرک، ممکن است بخواهید فقط زمانی که هر

194
00:12:59,567 --> 00:13:03,738
دو پنجره به طور کامل با یکدیگر هماهنگ هستند، به شرایط فکر کنید، یا در

195
00:13:03,738 --> 00:13:07,789
مثال پردازش تصویر ممکن است بخواهید خروجی نهایی با اندازه اصلی باشد.

196
00:13:07,789 --> 00:13:10,733
اکنون کانولوشن‌ها به‌عنوان یک عملیات ریاضی محض همیشه آرایه‌ای

197
00:13:10,733 --> 00:13:13,582
را تولید می‌کنند که بزرگ‌تر از دو آرایه‌ای است که شما با آن

198
00:13:13,582 --> 00:13:16,431
شروع کرده‌اید، حداقل با فرض اینکه طول یکی از آنها یک نباشد.

199
00:13:16,431 --> 00:13:21,440
فقط بدانید که در زمینه‌های خاص علم کامپیوتر اغلب می‌خواهید عمداً آن خروجی را کوتاه کنید.

200
00:13:21,440 --> 00:13:25,618
نکته دیگری که ارزش برجسته کردن دارد این است که در زمینه علم کامپیوتر، این

201
00:13:25,618 --> 00:13:29,741
تصور از ورق زدن آن هسته قبل از اینکه اجازه دهید آن را در سراسر نسخه اصلی

202
00:13:29,741 --> 00:13:33,750
قرار دهید، اغلب بسیار عجیب و غریب و غیرقابل استفاده به نظر می رسد، اما

203
00:13:33,750 --> 00:13:37,985
دوباره توجه داشته باشید که این همان چیزی است که از زمینه ریاضی خالص به ارث

204
00:13:37,985 --> 00:13:42,560
رسیده است، جایی که مانند ما با احتمالات دیدم که این یک کار فوق العاده طبیعی است.

205
00:13:42,560 --> 00:13:45,822
و در واقع می توانم یک مثال ریاضی خالص دیگر را به شما نشان دهم که

206
00:13:45,822 --> 00:13:49,136
در آن حتی برنامه نویسان نیز باید به این مورد اهمیت دهند زیرا درها

207
00:13:49,136 --> 00:13:52,399
را برای الگوریتم بسیار سریعتری برای محاسبه همه اینها باز می کند.

208
00:13:52,399 --> 00:13:55,825
برای تنظیم سریعتر منظورم، اجازه دهید به عقب برگردم و دوباره

209
00:13:55,825 --> 00:13:59,651
تعدادی پایتون را بالا بکشم و دو آرایه نسبتا بزرگ متفاوت ایجاد کنم.

210
00:13:59,651 --> 00:14:03,691
هر کدام صد هزار عنصر تصادفی در خود خواهند داشت و من قصد دارم

211
00:14:03,691 --> 00:14:07,598
زمان اجرای تابع convolve را از کتابخانه numpy ارزیابی کنم.

212
00:14:07,598 --> 00:14:12,213
و در این مورد آن را برای چندین تکرار مختلف اجرا می‌کند، سعی می‌کند میانگینی

213
00:14:12,213 --> 00:14:16,403
را پیدا کند و به نظر می‌رسد که در این رایانه حداقل میانگین آن 4 است.

214
00:14:16,403 --> 00:14:20,808
87 ثانیه در مقابل، اگر من از یک تابع متفاوت از کتابخانه scipy به نام

215
00:14:20,808 --> 00:14:25,468
fftconvolve استفاده کنم که همان چیزی است که فقط به طور متفاوت پیاده سازی

216
00:14:25,468 --> 00:14:30,640
شده است که فقط 4 طول می کشد. به طور متوسط 3 میلی ثانیه، بنابراین سه مرتبه بهبود.

217
00:14:30,640 --> 00:14:34,836
و دوباره حتی اگر با نام دیگری پرواز می کند، همان خروجی را می دهد که تابع convolve

218
00:14:34,836 --> 00:14:38,880
دیگر انجام می دهد، فقط کاری انجام می دهد تا آن را به روشی هوشمندانه انجام دهد.

219
00:14:38,880 --> 00:14:43,276
به یاد داشته باشید که چگونه با مثال احتمالی که گفتم روش دیگری که

220
00:14:43,276 --> 00:14:47,538
می‌توانید در مورد کانولوشن فکر کنید این بود که این جدول از همه

221
00:14:47,538 --> 00:14:52,611
محصولات زوجی ایجاد کنید و سپس آن محصولات زوجی را در امتداد قطرها جمع کنید.

222
00:14:52,611 --> 00:14:55,862
البته هیچ چیز خاصی در مورد احتمال وجود ندارد هر زمان که شما دو لیست

223
00:14:55,862 --> 00:14:59,352
مختلف از اعداد را در هم می پیچید و می توانید از این طریق به آن فکر کنید.

224
00:14:59,352 --> 00:15:02,982
این نوع جدول ضرب را با همه حاصل های جفتی ایجاد کنید و سپس هر

225
00:15:02,982 --> 00:15:06,492
جمع در طول مورب با یکی از خروجی های نهایی شما مطابقت دارد.

226
00:15:06,492 --> 00:15:09,532
یکی از زمینه هایی که این دیدگاه به ویژه طبیعی است،

227
00:15:09,532 --> 00:15:12,513
زمانی است که دو چند جمله ای را با هم ضرب می کنید.

228
00:15:12,513 --> 00:15:16,420
به عنوان مثال، اجازه دهید شبکه کوچکی را که در حال حاضر داریم،

229
00:15:16,420 --> 00:15:20,264
در نظر بگیرم و عبارت های بالا را با 1، 2x، و 3x مربع جایگزین

230
00:15:20,264 --> 00:15:23,920
کنیم و سایر عبارت ها را با 4، 5x، و 6x مربع جایگزین کنیم.

231
00:15:23,920 --> 00:15:26,273
حالا به این فکر کنید که وقتی ما در حال ایجاد همه این

232
00:15:26,273 --> 00:15:28,760
محصولات جفتی مختلف بین این دو لیست هستیم، به چه معناست.

233
00:15:28,760 --> 00:15:34,772
کاری که شما انجام می‌دهید اساساً گسترش حاصلضرب کامل دو چند جمله‌ای است که من یادداشت

234
00:15:34,772 --> 00:15:40,927
کرده‌ام و سپس هنگامی که در امتداد قطری که مربوط به جمع‌آوری همه عبارت‌های مشابه است که

235
00:15:40,927 --> 00:15:47,011
بسیار منظم است، جمع آوری یک چند جمله‌ای و جمع‌آوری عبارت‌های مشابه، دقیقاً برابر است.

236
00:15:47,011 --> 00:15:49,738
همان فرآیند کانولوشن اما این به ما امکان می‌دهد کاری انجام

237
00:15:49,738 --> 00:15:52,696
دهیم که بسیار جالب است زیرا به آنچه در اینجا می‌گوییم فکر کنید.

238
00:15:52,696 --> 00:15:57,963
ما می گوییم اگر شما دو تابع مختلف را بگیرید و آنها را با هم ضرب کنید، این یک عمل

239
00:15:57,963 --> 00:16:03,360
نقطه ای ساده است، این همان چیزی است که اگر ابتدا ضرایب را از هر یک از آنها استخراج

240
00:16:03,360 --> 00:16:08,821
کرده باشید، با فرض اینکه چند جمله ای هستند و سپس کانولوشنی از آن ها را گرفته باشید.

241
00:16:08,821 --> 00:16:13,019
دو لیست از ضرایب چیزی که آن را بسیار جالب می کند این است که کانولوشن ها اصولاً

242
00:16:13,019 --> 00:16:17,269
بسیار پیچیده تر از ضرب ساده به نظر می رسند و منظور من فقط از نظر مفهومی نیست که

243
00:16:17,269 --> 00:16:21,360
فکر کردن به آنها سخت تر است، منظورم این است که از نظر محاسباتی برای انجام یک

244
00:16:21,360 --> 00:16:26,089
کانولوشن به مراحل بیشتری نیاز دارد تا انجام یک کانولوشن. محصول نقطه ای از دو لیست مختلف.

245
00:16:26,089 --> 00:16:30,898
به عنوان مثال، فرض کنید من به شما دو چند جمله‌ای بسیار بزرگ دادم، مثلاً هر کدام

246
00:16:30,898 --> 00:16:35,466
با صد ضرایب مختلف، سپس اگر روش ضرب آنها به این صورت بود که این محصول را بسط

247
00:16:35,466 --> 00:16:40,215
دهید، می‌دانید که تمام این شبکه 100 در 100 از محصولات زوجی را پر می‌کنید که به

248
00:16:40,215 --> 00:16:44,723
شما نیاز دارد. 10000 محصول مختلف را انجام دهید و سپس هنگامی که تمام عبارات

249
00:16:44,723 --> 00:16:49,773
مشابه را در امتداد مورب ها جمع آوری می کنید، مجموعه دیگری از حدود 10000 عملیات است.

250
00:16:49,773 --> 00:16:55,354
به طور کلی تر، در زبان انگلیسی می گوییم که الگوریتم O از n معنای مربع برای دو

251
00:16:55,354 --> 00:17:00,935
لیست با اندازه n است، به طوری که تعداد مقیاس های عملیات متناسب با مربع n است.

252
00:17:00,935 --> 00:17:05,972
از سوی دیگر، اگر من به دو چند جمله ای از نظر خروجی فکر کنم، مثلاً مقادیر

253
00:17:05,972 --> 00:17:10,940
آنها را در تعداد انگشت شماری از ورودی ها نمونه برداری کنم، ضرب آنها فقط

254
00:17:10,940 --> 00:17:15,908
به تعداد نمونه ها نیاز دارد، زیرا دوباره این یک عملیات نقطه ای است و با

255
00:17:15,908 --> 00:17:21,152
چند جمله ای ها فقط به آن نیاز دارید. تعداد محدودی نمونه برای بازیابی ضرایب.

256
00:17:21,152 --> 00:17:25,214
به عنوان مثال، دو خروجی برای تعیین منحصر به فرد یک چند جمله ای خطی کافی است.

257
00:17:25,214 --> 00:17:29,360
سه خروجی برای مشخص کردن یک چند جمله ای درجه دوم کافی است.

258
00:17:29,360 --> 00:17:32,993
و به طور کلی، اگر n خروجی مجزا را بشناسید، برای مشخص

259
00:17:32,993 --> 00:17:36,901
کردن یک چند جمله ای که دارای n ضریب متفاوت است، کافی است.

260
00:17:36,901 --> 00:17:41,188
یا اگر ترجیح می دهید می توانیم این را به زبان سیستم های معادلات بیان کنیم.

261
00:17:41,188 --> 00:17:43,885
تصور کنید من به شما می گویم چند جمله ای دارم اما به

262
00:17:43,885 --> 00:17:46,480
شما نمی گویم ضرایب چیست، اینها برای شما یک معماست.

263
00:17:46,480 --> 00:17:50,666
در مثال ما ممکن است به این به عنوان محصولی فکر کنید که ما سعی در کشف آن داریم.

264
00:17:50,666 --> 00:17:54,965
سپس فرض کنید من می گویم اگر شما ورودی های مختلفی مانند 0، 1، 2، 3، و on را

265
00:17:54,965 --> 00:17:59,263
وارد کنید، فقط به شما می گویم خروجی های این چند جمله ای چه خواهد بود، و من

266
00:17:59,263 --> 00:18:03,791
به اندازه کافی به شما می دهم تا به تعداد معادله داشته باشید. شما مجهولاتی دارید

267
00:18:03,791 --> 00:18:07,245
حتی اتفاقاً یک سیستم خطی از معادلات است، بنابراین خوب است.

268
00:18:07,245 --> 00:18:11,137
و در اصل حداقل این باید برای بازیابی ضرایب کافی باشد.

269
00:18:11,137 --> 00:18:15,195
بنابراین، طرح کلی الگوریتم تقریبی به این صورت خواهد بود که هر زمان که می‌خواهید دو

270
00:18:15,195 --> 00:18:19,253
لیست از اعداد را در هم بگنجانید، با آن‌ها مانند ضرایب دو چند جمله‌ای رفتار می‌کنید.

271
00:18:19,253 --> 00:18:23,171
شما از آن چند جمله‌ای‌ها در خروجی‌های کافی نمونه‌گیری می‌کنید، آن

272
00:18:23,171 --> 00:18:27,268
نمونه‌ها را به صورت نقطه‌ای ضرب می‌کنید، و سپس سیستم را برای بازیابی

273
00:18:27,268 --> 00:18:31,364
ضرایب به‌عنوان یک راه درب پشتی یواشکی برای یافتن کانولوشن حل می‌کنید.

274
00:18:31,364 --> 00:18:34,643
و همانطور که حداقل تا کنون گفته‌ام، برخی از شما به حق می‌توانید

275
00:18:34,643 --> 00:18:37,564
شکایت کنید که &quot;گرانت، این یک نقشه احمقانه است&quot;.

276
00:18:37,564 --> 00:18:42,570
از آنجا که فقط محاسبه همه این نمونه‌ها برای یکی از چند جمله‌ای‌هایی

277
00:18:42,570 --> 00:18:47,576
که قبلاً می‌دانیم، ترتیب n عمل مربع را می‌گیرد، حل آن سیستم مطمئناً

278
00:18:47,576 --> 00:18:52,656
از نظر محاسباتی به اندازه انجام کانولوشن در وهله اول دشوار خواهد بود.

279
00:18:52,656 --> 00:18:56,823
بنابراین، مطمئناً ما این ارتباط بین ضرب و کانولوشن را داریم، اما

280
00:18:56,823 --> 00:19:01,054
همه پیچیدگی ها در ترجمه از یک دیدگاه به دیدگاه دیگر اتفاق می افتد.

281
00:19:01,054 --> 00:19:04,364
اما یک ترفند وجود دارد، و کسانی از شما که در مورد تبدیل فوریه

282
00:19:04,364 --> 00:19:07,673
و الگوریتم FFT می‌دانید، ممکن است ببینید که این به کجا می‌رود.

283
00:19:07,673 --> 00:19:12,176
اگر با این موضوعات آشنا نیستید، آنچه می خواهم بگویم ممکن است کاملاً غیرمعمول به نظر برسد.

284
00:19:12,176 --> 00:19:14,991
فقط بدانید که مسیرهای خاصی وجود دارد که می توانستید در ریاضیات

285
00:19:14,991 --> 00:19:17,582
پیموده باشید که این را به یک قدم مورد انتظار تبدیل می کند.

286
00:19:17,582 --> 00:19:20,697
اساساً ایده این است که ما در اینجا آزادی انتخاب داریم.

287
00:19:20,697 --> 00:19:25,358
اگر به‌جای ارزیابی در مجموعه‌ای دلخواه از ورودی‌ها مانند 0، 1، 2، 3، و روشن،

288
00:19:25,358 --> 00:19:30,080
انتخاب کنید که روی مجموعه‌ای از اعداد مختلط انتخاب شده بسیار خاص ارزیابی کنید.

289
00:19:30,080 --> 00:19:32,463
به ویژه آنهایی که به طور مساوی روی دایره واحد قرار

290
00:19:32,463 --> 00:19:34,894
می گیرند، آنچه به عنوان ریشه های وحدت شناخته می شود.

291
00:19:34,894 --> 00:19:37,364
این به ما سیستم دوستانه تری می دهد.

292
00:19:37,364 --> 00:19:41,919
ایده اصلی این است که با یافتن عددی که در آن قدرت‌های آن در این الگوی دوچرخه‌سواری

293
00:19:41,919 --> 00:19:46,308
قرار می‌گیرد، به این معنی است که سیستمی که ما تولید می‌کنیم در شرایط مختلفی که

294
00:19:46,308 --> 00:19:50,697
شما محاسبه می‌کنید، افزونگی زیادی خواهد داشت، و با هوشمندی در مورد نحوه محاسبه

295
00:19:50,697 --> 00:19:55,252
شما از این افزونگی استفاده می کنید، می توانید کارهای زیادی را برای خود ذخیره کنید.

296
00:19:55,252 --> 00:20:02,166
این مجموعه خروجی هایی که من نوشتم اسم خاصی دارد، به آن تبدیل فوریه گسسته ضرایب می گویند.

297
00:20:02,166 --> 00:20:05,577
و اگر می خواهید بیشتر بیاموزید، من در واقع یک سخنرانی دیگر

298
00:20:05,577 --> 00:20:09,103
برای همان کلاس جولیا MIT درباره تبدیل فوریه گسسته انجام دادم.

299
00:20:09,103 --> 00:20:13,154
و همچنین یک ویدیوی بسیار عالی در کانال قابل تقلیل وجود دارد که در مورد

300
00:20:13,154 --> 00:20:17,263
تبدیل فوریه سریع صحبت می کند، که الگوریتمی برای محاسبه سریعتر اینها است.

301
00:20:17,263 --> 00:20:19,669
همچنین Veritasium اخیراً یک ویدیوی واقعاً خوب در FFT

302
00:20:19,669 --> 00:20:21,984
انجام داده است، بنابراین شما گزینه‌های زیادی دارید.

303
00:20:21,984 --> 00:20:24,786
و این الگوریتم سریع واقعاً برای ما مهم است.

304
00:20:24,786 --> 00:20:29,702
دوباره به دلیل این همه افزونگی، روشی برای رفتن از ضرایب به همه این خروجی ها وجود

305
00:20:29,702 --> 00:20:34,437
دارد، جایی که به جای انجام مرتبه n عملیات مربع، به ترتیب n برابر log عملیات n

306
00:20:34,437 --> 00:20:39,293
انجام می دهید، که بسیار است. وقتی به لیست های بزرگ مقیاس می کنید بسیار بهتر است.

307
00:20:39,293 --> 00:20:42,386
و مهمتر از همه، این الگوریتم fft به هر دو سمت پیش می رود.

308
00:20:42,386 --> 00:20:45,515
همچنین به شما امکان می دهد از خروجی ها به ضرایب بروید.

309
00:20:45,515 --> 00:20:49,054
بنابراین با کنار هم قرار دادن همه اینها، بیایید به طرح کلی الگوریتم خود نگاه کنیم.

310
00:20:49,054 --> 00:20:53,495
حالا می‌توانیم بگوییم هر زمان که دو لیست طولانی از اعداد به شما داده شد و می‌خواهید

311
00:20:53,495 --> 00:20:57,884
پیچیدگی آن‌ها را انتخاب کنید، ابتدا تبدیل فوریه سریع هر یک از آنها را محاسبه کنید،

312
00:20:57,884 --> 00:21:01,585
که در پس ذهن خود می‌توانید تصور کنید که با آن‌ها مانند رفتار می‌کنید.

313
00:21:01,585 --> 00:21:05,920
آنها ضرایب یک چند جمله ای هستند و آن را در مجموعه ای از نقاط انتخاب شده بسیار خاص

314
00:21:05,920 --> 00:21:06,766
ارزیابی می کنند.

315
00:21:06,766 --> 00:21:10,758
سپس دو نتیجه‌ای را که به‌تازگی به دست آورده‌اید از نظر نقطه‌ای ضرب کنید، که

316
00:21:10,758 --> 00:21:14,802
خوب و سریع است، و سپس یک تبدیل فوریه سریع معکوس انجام دهید، و چیزی که به شما

317
00:21:14,802 --> 00:21:18,847
می‌دهد، روش درب پشتی یواشکی برای محاسبه کانولوشن است که ما به دنبال آن بودیم.

318
00:21:18,847 --> 00:21:22,957
اما این بار فقط شامل O از n عملیات log n می شود.

319
00:21:22,957 --> 00:21:24,865
این واقعا برای من جالب است!

320
00:21:24,865 --> 00:21:29,443
این زمینه بسیار خاص که در آن پیچیدگی‌ها ظاهر می‌شوند، با ضرب دو چند جمله‌ای، درها را

321
00:21:29,443 --> 00:21:34,235
برای الگوریتمی باز می‌کند که در هر جای دیگری که ممکن است پیچیدگی‌ها ظاهر شوند، مرتبط است.

322
00:21:34,235 --> 00:21:36,529
اگر می‌خواهید توزیع‌های احتمالی را اضافه کنید،

323
00:21:36,529 --> 00:21:38,822
هر چه که باشد، پردازش تصویر بزرگ را انجام دهید.

324
00:21:38,822 --> 00:21:43,228
و من فکر می‌کنم این مثال خوبی است برای اینکه چرا وقتی می‌بینید عملیات یا مفهومی

325
00:21:43,228 --> 00:21:47,798
در ریاضیات در بسیاری از زمینه‌های به ظاهر نامرتبط ظاهر می‌شود، باید هیجان‌زده شوید.

326
00:21:47,798 --> 00:21:51,967
اگر کمی تکلیف می خواهید اینجا چیزی است که فکر کردن به آن سرگرم کننده است.

327
00:21:51,967 --> 00:21:56,862
توضیح دهید که چرا وقتی دو عدد مختلف را ضرب می کنید، فقط ضرب معمولی به روشی که همه ما در

328
00:21:56,862 --> 00:22:01,702
مدرسه ابتدایی یاد می گیریم، کاری که انجام می دهید اساساً یک پیچیدگی بین ارقام آن اعداد

329
00:22:01,702 --> 00:22:01,924
است.

330
00:22:01,924 --> 00:22:06,785
برخی از مراحل اضافه شده با حمل و مانند آن وجود دارد، اما مرحله اصلی یک پیچیدگی است.

331
00:22:06,785 --> 00:22:10,604
با توجه به وجود یک الگوریتم سریع، معنای آن این است که اگر دو

332
00:22:10,604 --> 00:22:14,297
عدد صحیح بسیار بزرگ دارید، راهی برای یافتن محصول آنها وجود

333
00:22:14,297 --> 00:22:18,240
دارد که سریعتر از روشی است که ما در مدرسه ابتدایی یاد می‌گیریم.

334
00:22:18,240 --> 00:22:21,731
که به جای نیاز به O از n عملیات مربع فقط به O از n

335
00:22:21,731 --> 00:22:25,291
log n نیاز دارد، که حتی به نظر نمی رسد که ممکن باشد.

336
00:22:25,291 --> 00:22:28,472
نکته مهم این است که قبل از اینکه این در عمل واقعاً

337
00:22:28,472 --> 00:22:31,280
مفید باشد، اعداد شما باید کاملاً هیولا باشند.

338
00:22:31,280 --> 00:22:34,445
اما با این حال، وجود چنین الگوریتمی جالب است.

339
00:22:34,445 --> 00:22:40,000
در ادامه توجه خود را به حالت پیوسته با تمرکز ویژه بر توزیع احتمال معطوف خواهیم کرد.

