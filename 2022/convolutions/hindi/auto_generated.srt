1
00:00:00,000 --> 00:00:02,354
मान लीजिए कि मैं आपको संख्याओं की दो अलग-अलग सूचियाँ देता हूँ,

2
00:00:02,354 --> 00:00:05,158
या शायद दो अलग-अलग फ़ंक्शन देता हूँ, और मैं आपसे उन सभी तरीकों के बारे में

3
00:00:05,158 --> 00:00:08,036
सोचने के लिए कहता हूँ जिनसे आप संख्याओं की एक नई सूची प्राप्त करने के लिए उन

4
00:00:08,036 --> 00:00:11,027
दो सूचियों को जोड़ सकते हैं, या एक नया फ़ंक्शन प्राप्त करने के लिए दो फ़ंक्शनों

5
00:00:11,027 --> 00:00:11,737
को जोड़ सकते हैं। .

6
00:00:11,737 --> 00:00:14,100
शायद एक आसान तरीका जो दिमाग में आता है वह यह है

7
00:00:14,100 --> 00:00:16,267
कि उन्हें शब्द दर शब्द एक साथ जोड़ दिया जाए।

8
00:00:16,267 --> 00:00:20,050
इसी प्रकार फ़ंक्शंस के साथ, आप सभी संबंधित आउटपुट जोड़ सकते हैं।

9
00:00:20,050 --> 00:00:23,037
इसी तरह, आप दोनों सूचियों को पद दर पद गुणा भी कर

10
00:00:23,037 --> 00:00:26,145
सकते हैं और फ़ंक्शंस के साथ भी यही काम कर सकते हैं।

11
00:00:26,145 --> 00:00:29,659
लेकिन इन दोनों की तरह एक और प्रकार का संयोजन भी मौलिक है,

12
00:00:29,659 --> 00:00:33,840
लेकिन बहुत कम चर्चा की जाती है, जिसे कनवल्शन के रूप में जाना जाता है।

13
00:00:33,840 --> 00:00:36,890
लेकिन पिछले दो मामलों के विपरीत, यह ऐसा कुछ नहीं है जो केवल एक

14
00:00:36,890 --> 00:00:39,893
ऑपरेशन से विरासत में मिला है जिसे आप संख्याओं में कर सकते हैं।

15
00:00:39,893 --> 00:00:44,716
संख्याओं की सूची या संयोजन कार्यों के संदर्भ में यह वास्तव में कुछ नया है।

16
00:00:44,716 --> 00:00:48,220
वे हर जगह दिखाई देते हैं, वे छवि प्रसंस्करण में सर्वव्यापी हैं,

17
00:00:48,220 --> 00:00:50,958
यह संभाव्यता के सिद्धांत में एक मुख्य निर्माण है,

18
00:00:50,958 --> 00:00:54,188
अंतर समीकरणों को हल करने में उनका बहुत उपयोग किया जाता है,

19
00:00:54,188 --> 00:00:58,349
और एक संदर्भ जहां आपने इसे लगभग निश्चित रूप से देखा है, यदि नहीं इस नाम से,

20
00:00:58,349 --> 00:01:00,210
दो बहुपदों को एक साथ गुणा करना है।

21
00:01:00,210 --> 00:01:04,654
दृश्य स्पष्टीकरण के व्यवसाय में किसी के रूप में, यह एक विशेष रूप से महान विषय है,

22
00:01:04,654 --> 00:01:08,827
क्योंकि अलगाव में और संदर्भ के बिना सूत्रबद्ध परिभाषा डराने वाली लग सकती है,

23
00:01:08,827 --> 00:01:12,838
लेकिन अगर हम वास्तव में यह क्या कह रहे हैं उसे खोलने के लिए समय लेते हैं,

24
00:01:12,838 --> 00:01:16,632
और उससे पहले वास्तव में प्रेरित करते हैं कि क्यों आप ऐसा कुछ चाहेंगे,

25
00:01:16,632 --> 00:01:18,800
यह एक अविश्वसनीय रूप से सुंदर ऑपरेशन है।

26
00:01:18,800 --> 00:01:21,073
और मुझे यह स्वीकार करना होगा कि इस परियोजना के लिए

27
00:01:21,073 --> 00:01:23,436
दृश्यों को एक साथ रखते समय मैंने वास्तव में कुछ सीखा।

28
00:01:23,436 --> 00:01:25,549
दो अलग-अलग कार्यों को संयोजित करने के मामले में,

29
00:01:25,549 --> 00:01:29,302
मैं अलग-अलग तरीकों के बारे में सोचने की कोशिश कर रहा था जिनसे आप कल्पना कर सकते हैं कि

30
00:01:29,302 --> 00:01:32,968
इसका क्या मतलब हो सकता है, और उनमें से एक के साथ मेरे मन में थोड़ा अहा पल आया कि ऐसा

31
00:01:32,968 --> 00:01:36,202
क्यों है कि सामान्य वितरण भूमिका निभाते हैं वे संभाव्यता में ऐसा करते हैं,

32
00:01:36,202 --> 00:01:38,445
किसी फ़ंक्शन के लिए यह इतना स्वाभाविक आकार क्यों है।

33
00:01:38,445 --> 00:01:41,580
लेकिन मैं खुद से आगे निकल रहा हूं, इसके लिए बहुत सारी व्यवस्थाएं मौजूद हैं।

34
00:01:41,580 --> 00:01:44,823
इस वीडियो में, हमारा प्राथमिक ध्यान केवल अलग-अलग मामले पर होगा,

35
00:01:44,823 --> 00:01:49,132
और विशेष रूप से इनकी गणना के लिए एक बहुत ही अप्रत्याशित लेकिन बहुत ही चतुर एल्गोरिदम

36
00:01:49,132 --> 00:01:50,196
का निर्माण करना होगा।

37
00:01:50,196 --> 00:01:57,840
और मैं सतत मामले की चर्चा को दूसरे भाग में ले जाऊंगा।

38
00:01:57,840 --> 00:02:00,745
छवि प्रसंस्करण उदाहरणों के साथ शुरुआत करना बहुत आकर्षक है,

39
00:02:00,745 --> 00:02:04,488
क्योंकि वे दृष्टिगत रूप से सबसे दिलचस्प हैं, लेकिन कुछ बारीकियाँ हैं जो छवि

40
00:02:04,488 --> 00:02:07,887
प्रसंस्करण मामले को समग्र रूप से संकल्पों का कम प्रतिनिधि बनाती हैं,

41
00:02:07,887 --> 00:02:10,497
इसलिए इसके बजाय संभावनाओं के साथ चीजों को शुरू करें,

42
00:02:10,497 --> 00:02:14,487
और विशेष रूप से सबसे सरल उदाहरणों में से एक, जिसके बारे में मुझे यकीन है कि यहां

43
00:02:14,487 --> 00:02:18,427
हर किसी ने अपने जीवन में कभी न कभी सोचा होगा, जो कि पासों की एक जोड़ी को घुमाना

44
00:02:18,427 --> 00:02:21,530
और विभिन्न अलग-अलग योगों को देखने की संभावनाओं का पता लगाना है।

45
00:02:21,530 --> 00:02:24,170
और आप कह सकते हैं, कोई समस्या नहीं, कोई समस्या नहीं।

46
00:02:24,170 --> 00:02:27,948
आपके दोनों पासों में से प्रत्येक के छह अलग-अलग संभावित परिणाम हैं,

47
00:02:27,948 --> 00:02:31,276
जो हमें परिणामों के कुल 36 अलग-अलग संभावित जोड़े देते हैं,

48
00:02:31,276 --> 00:02:36,240
और यदि हम उन सभी को देखते हैं तो हम गिन सकते हैं कि कितने जोड़ों में एक दिया गया योग है।

49
00:02:36,240 --> 00:02:39,289
और सभी जोड़ियों को इस तरह एक ग्रिड में व्यवस्थित करने पर,

50
00:02:39,289 --> 00:02:42,759
एक बहुत अच्छी बात यह है कि जिन सभी जोड़ियों का योग स्थिर होता है,

51
00:02:42,759 --> 00:02:45,650
वे इन विभिन्न विकर्णों में से एक के साथ दिखाई देते हैं।

52
00:02:45,650 --> 00:02:49,292
तो बस यह गिनने से कि उनमें से प्रत्येक विकर्ण पर कितने मौजूद हैं,

53
00:02:49,292 --> 00:02:52,880
आपको पता चल जाएगा कि आपको एक विशेष योग देखने की कितनी संभावना है।

54
00:02:52,880 --> 00:02:55,657
और मैं कहूंगा, बहुत अच्छा, बहुत अच्छा, लेकिन क्या आप किसी अन्य

55
00:02:55,657 --> 00:02:58,699
तरीके के बारे में सोच सकते हैं जिससे आप उसी प्रश्न की कल्पना कर सकें?

56
00:02:58,699 --> 00:03:01,060
अन्य छवियां जो उन सभी विशिष्ट जोड़ियों के बारे में

57
00:03:01,060 --> 00:03:03,744
सोचने के लिए दिमाग में आ सकती हैं जिनका एक निश्चित योग है?

58
00:03:03,744 --> 00:03:07,550
और हो सकता है कि आप में से कोई अपना हाथ उठाए और कहे, हाँ, मेरे पास एक है।

59
00:03:07,550 --> 00:03:11,698
मान लीजिए कि आप एक पंक्ति में संभावनाओं के इन दो अलग-अलग सेटों की कल्पना करते हैं,

60
00:03:11,698 --> 00:03:14,046
लेकिन आप उस दूसरी पंक्ति के चारों ओर घूमते हैं।

61
00:03:14,046 --> 00:03:18,960
इस तरह सभी अलग-अलग जोड़े जो सात तक जुड़ते हैं, इस तरह लंबवत पंक्ति में आते हैं।

62
00:03:18,960 --> 00:03:22,364
और यदि हम उस निचली पंक्ति को पूरी तरह से दाहिनी ओर सरकाते हैं,

63
00:03:22,364 --> 00:03:26,309
तो अद्वितीय जोड़ी जो दो को जोड़ती है, साँप की आँखें, ही संरेखित होती हैं।

64
00:03:26,309 --> 00:03:29,704
और यदि मैं इसे दाहिनी ओर एक इकाई पर झुकाऊं, तो जो जोड़े संरेखित

65
00:03:29,704 --> 00:03:32,886
होते हैं वे दो अलग-अलग जोड़े होते हैं जिनका योग तीन होता है।

66
00:03:32,886 --> 00:03:37,826
और सामान्य तौर पर, इस निचले सरणी के अलग-अलग ऑफसेट मान, जो याद रखें कि मुझे पहले पलटना था,

67
00:03:37,826 --> 00:03:41,778
उन सभी अलग-अलग जोड़ियों को प्रकट करता है जिनमें एक दिया गया योग होता है।

68
00:03:41,778 --> 00:03:47,413
जहां तक संभाव्यता प्रश्नों का सवाल है, यह अभी भी विशेष रूप से दिलचस्प नहीं है,

69
00:03:47,413 --> 00:03:53,120
क्योंकि हम केवल यह गिन रहे हैं कि इनमें से प्रत्येक श्रेणी में कितने परिणाम हैं।

70
00:03:53,120 --> 00:03:55,436
लेकिन यह इस अंतर्निहित धारणा के साथ है कि इनमें

71
00:03:55,436 --> 00:03:57,850
से प्रत्येक चेहरे के सामने आने की समान संभावना है।

72
00:03:57,850 --> 00:04:01,897
लेकिन क्या होगा अगर मैं आपसे कहूं कि मेरे पास पासों का एक विशेष सेट है जो एक समान नहीं है?

73
00:04:01,897 --> 00:04:05,723
हो सकता है कि नीले पासे में संख्याओं का अपना सेट हो जो प्रत्येक चेहरे के आने की

74
00:04:05,723 --> 00:04:09,740
संभावनाओं का वर्णन करता हो, और लाल पासे में संख्याओं का अपना विशिष्ट विशिष्ट सेट हो।

75
00:04:09,740 --> 00:04:13,955
उस स्थिति में, यदि आप दो देखने की संभावना का पता लगाना चाहते हैं,

76
00:04:13,955 --> 00:04:19,001
तो आप नीले पासे के एक होने की प्रायिकता को लाल पासे के एक होने की प्रायिकता से

77
00:04:19,001 --> 00:04:19,895
गुणा कर देंगे।

78
00:04:19,895 --> 00:04:24,908
और तीन देखने की संभावना के लिए, आप दो अलग-अलग जोड़ियों को देखें जहां यह संभव है,

79
00:04:24,908 --> 00:04:29,983
और फिर से, संबंधित संभावनाओं को गुणा करें, और फिर उन दो उत्पादों को एक साथ जोड़ें।

80
00:04:29,983 --> 00:04:33,392
इसी प्रकार, चार को देखने की संभावना में संभावनाओं के तीन अलग-अलग

81
00:04:33,392 --> 00:04:36,748
युग्मों को एक साथ गुणा करना और उन सभी को एक साथ जोड़ना शामिल है।

82
00:04:36,748 --> 00:04:41,264
और कुछ सूत्र स्थापित करने की भावना से, आइए इन शीर्ष संभावनाओं को a1, a2,

83
00:04:41,264 --> 00:04:45,903
a3, इत्यादि नाम दें, और नीचे वाली संभावनाओं को b1, b2, b3, इत्यादि नाम दें।

84
00:04:45,903 --> 00:04:49,897
और सामान्य तौर पर, यह प्रक्रिया, जहां हम संख्याओं के दो अलग-अलग सरणी ले रहे हैं,

85
00:04:49,897 --> 00:04:53,841
दूसरे को चारों ओर घुमा रहे हैं, और फिर उन्हें विभिन्न ऑफसेट मानों पर पंक्तिबद्ध

86
00:04:53,841 --> 00:04:57,589
कर रहे हैं, जोड़ीदार उत्पादों का एक समूह ले रहे हैं और उन्हें जोड़ रहे हैं,

87
00:04:57,589 --> 00:05:01,139
यह इनमें से एक है कनवल्शन क्या है इसके बारे में सोचने के बुनियादी तरीके।

88
00:05:01,139 --> 00:05:06,566
तो बस इसे थोड़ा और सटीक रूप से बताने के लिए, इस प्रक्रिया के माध्यम से, हमने दो,

89
00:05:06,566 --> 00:05:12,261
तीन, चार, आगे और फिर 12 तक देखने की संभावनाएं उत्पन्न कीं, और हमने मानों की एक सूची,

90
00:05:12,261 --> 00:05:17,084
ए, और एक अन्य को एक साथ मिलाकर उन्हें प्राप्त किया। मूल्यों की सूची, बी.

91
00:05:17,084 --> 00:05:21,860
भाषा में, हम कहेंगे कि उन दो अनुक्रमों का कनवल्शन हमें यह नया अनुक्रम देता है,

92
00:05:21,860 --> 00:05:27,120
11 मानों का नया अनुक्रम, जिनमें से प्रत्येक जोड़ीदार उत्पादों के कुछ योग जैसा दिखता है।

93
00:05:27,120 --> 00:05:31,942
यदि आप चाहें, तो उसी ऑपरेशन के बारे में दूसरा तरीका यह सोच सकते हैं कि पहले

94
00:05:31,942 --> 00:05:36,702
सभी जोड़ीवार उत्पादों की एक तालिका बनाएं, और फिर इन सभी विकर्णों को जोड़ें।

95
00:05:36,702 --> 00:05:39,319
फिर, यह संख्याओं के इन दो अनुक्रमों को एक साथ मिलाने का एक

96
00:05:39,319 --> 00:05:42,247
तरीका है जिससे हमें 11 संख्याओं का एक नया अनुक्रम प्राप्त होता है।

97
00:05:42,247 --> 00:05:46,960
यह वही ऑपरेशन है जैसा कि स्लाइडिंग विंडोज़ ने सोचा था, बस एक और परिप्रेक्ष्य।

98
00:05:46,960 --> 00:05:50,314
इसमें थोड़ा सा नोटेशन डालते हुए, यहां बताया गया है कि आप इसे कैसे लिखा हुआ देख सकते हैं।

99
00:05:50,314 --> 00:05:54,935
ए और बी का कनवल्शन, इस छोटे तारांकन के साथ दर्शाया गया है, एक नई सूची है,

100
00:05:54,935 --> 00:05:57,995
और उस सूची का एनवां तत्व एक योग की तरह दिखता है,

101
00:05:57,995 --> 00:06:01,929
और वह योग सूचकांकों के सभी अलग-अलग जोड़े, आई और जे पर जाता है,

102
00:06:01,929 --> 00:06:04,738
ताकि योग का योग हो वे सूचकांक n के बराबर हैं।

103
00:06:04,738 --> 00:06:08,473
यह एक प्रकार का कौर है, लेकिन उदाहरण के लिए, यदि n 6 था,

104
00:06:08,473 --> 00:06:13,714
तो जिन जोड़ियों पर हम जा रहे हैं वे 1 और 5, 2 और 4, 3 और 3, 4 और 2, 5 और 1 हैं,

105
00:06:13,714 --> 00:06:16,400
सभी अलग-अलग जोड़े हैं जो जुड़ते हैं से 6.

106
00:06:16,400 --> 00:06:18,911
लेकिन ईमानदारी से कहूं तो, आप इसे किसी भी तरह से लिखें,

107
00:06:18,911 --> 00:06:21,243
प्रक्रिया के दौरान आपके दिमाग में जो दृश्य रहता है,

108
00:06:21,243 --> 00:06:23,082
उसके मुकाबले नोटेशन का महत्व गौण होता है।

109
00:06:23,082 --> 00:06:26,247
यहां, शायद यह एक अत्यंत सरल उदाहरण देने में मदद करेगा,

110
00:06:26,247 --> 00:06:30,967
जहां मैं आपसे पूछ सकता हूं कि सूची 4, 5, 6 के साथ सूची 1, 2, 3 का कनवल्शन क्या है।

111
00:06:30,967 --> 00:06:34,491
आप इन दोनों सूचियों को लेते हुए, दूसरी सूची के चारों ओर पलटते हुए,

112
00:06:34,491 --> 00:06:37,857
और फिर इसके ढक्कन से शुरू करके बाईं ओर तक की कल्पना कर सकते हैं।

113
00:06:37,857 --> 00:06:40,375
फिर मानों की जोड़ी जो संरेखित होती है वह 1 और 4 है,

114
00:06:40,375 --> 00:06:43,813
उन्हें एक साथ गुणा करें, और इससे हमें हमारे आउटपुट का पहला पद मिलता है।

115
00:06:43,813 --> 00:06:47,803
उस निचली सरणी को एक इकाई दाईं ओर स्लाइड करें, जो जोड़े संरेखित हैं वे 1 और 5,

116
00:06:47,803 --> 00:06:51,026
और 2 और 4 हैं, उन जोड़ियों को गुणा करें, उन्हें एक साथ जोड़ें,

117
00:06:51,026 --> 00:06:54,300
और इससे हमें 13 मिलता है, जो हमारे आउटपुट में अगली प्रविष्टि है।

118
00:06:54,300 --> 00:06:58,905
चीज़ों को एक बार फिर सरकाएँ, और हम 1 गुना 6, प्लस 2 गुना 5,

119
00:06:58,905 --> 00:07:01,591
प्लस 3 गुना 4, जो होता है 28 लेंगे।

120
00:07:01,591 --> 00:07:05,674
एक और स्लाइड, और हमें 2 गुना 6, प्लस 3 गुना 5 मिलता है,

121
00:07:05,674 --> 00:07:10,560
और इससे हमें 27 मिलता है, और अंत में अंतिम पद 3 गुना 6 जैसा दिखेगा।

122
00:07:10,560 --> 00:07:12,990
यदि आप चाहें, तो आप जो भी आपकी पसंदीदा प्रोग्रामिंग भाषा है,

123
00:07:12,990 --> 00:07:15,779
और आपकी पसंदीदा लाइब्रेरी जिसमें विभिन्न संख्यात्मक ऑपरेशन शामिल हैं,

124
00:07:15,779 --> 00:07:18,807
को खींच सकते हैं, और आप पुष्टि कर सकते हैं कि मैं आपसे झूठ नहीं बोल रहा हूं।

125
00:07:18,807 --> 00:07:22,437
यदि आप 4, 5, 6 के विरुद्ध 1, 2, 3 का कनवल्शन लेते हैं,

126
00:07:22,437 --> 00:07:24,880
तो आपको वास्तव में यही परिणाम मिलेगा।

127
00:07:24,880 --> 00:07:28,568
हमने एक मामला देखा है जहां यह एक प्राकृतिक और वांछनीय ऑपरेशन है,

128
00:07:28,568 --> 00:07:32,881
जो संभाव्यता वितरण को जोड़ता है, और एक अन्य सामान्य उदाहरण एक चलती औसत होगी।

129
00:07:32,881 --> 00:07:35,607
कल्पना करें कि आपके पास संख्याओं की कुछ लंबी सूची है,

130
00:07:35,607 --> 00:07:38,788
और आप संख्याओं की एक और छोटी सूची लेते हैं जिनका योग 1 होता है।

131
00:07:38,788 --> 00:07:43,381
इस मामले में, मेरे पास केवल 5 मानों की एक छोटी सी सूची है, और वे सभी 1/5वें के बराबर हैं।

132
00:07:43,381 --> 00:07:46,426
फिर यदि हम यह स्लाइडिंग विंडो कनवल्शन प्रक्रिया करते हैं,

133
00:07:46,426 --> 00:07:51,150
और अपनी आंखें बंद कर लेते हैं और गलीचे के नीचे देखते हैं कि इसकी शुरुआत में क्या होता है,

134
00:07:51,150 --> 00:07:55,349
एक बार जब मूल्यों की हमारी छोटी सूची पूरी तरह से बड़े के साथ ओवरलैप हो जाती है,

135
00:07:55,349 --> 00:07:59,023
तो सोचें कि इसमें प्रत्येक शब्द क्या है कनवल्शन का वास्तव में मतलब है।

136
00:07:59,023 --> 00:08:02,977
प्रत्येक पुनरावृत्ति पर, आप जो कर रहे हैं वह आपके डेटा के प्रत्येक

137
00:08:02,977 --> 00:08:06,637
मान को 1/5वें से गुणा करना है, और उन सभी को एक साथ जोड़ना है,

138
00:08:06,637 --> 00:08:10,769
जिसका अर्थ है कि आप इस छोटी विंडो के अंदर अपने डेटा का औसत ले रहे हैं।

139
00:08:10,769 --> 00:08:14,610
कुल मिलाकर, यह प्रक्रिया आपको मूल डेटा का एक सुव्यवस्थित संस्करण प्रदान करती है,

140
00:08:14,610 --> 00:08:18,073
और आप इसे संख्याओं की एक अलग छोटी सूची से शुरू करके संशोधित कर सकते हैं,

141
00:08:18,073 --> 00:08:22,057
और जब तक वह छोटी सूची 1 तक जुड़ जाती है, तब भी आप इसे एक गतिशील के रूप में व्याख्या

142
00:08:22,057 --> 00:08:22,816
कर सकते हैं औसत।

143
00:08:22,816 --> 00:08:27,781
यहां दिखाए गए उदाहरण में, वह चलती औसत केंद्रीय मूल्य की ओर अधिक भार देगी।

144
00:08:27,781 --> 00:08:33,200
इसके परिणामस्वरूप डेटा का एक सुचारु संस्करण भी प्राप्त होता है।

145
00:08:33,200 --> 00:08:35,942
यदि आप इसका द्वि-आयामी एनालॉग बनाते हैं, तो यह आपको किसी दी

146
00:08:35,942 --> 00:08:38,594
गई छवि को धुंधला करने के लिए एक मज़ेदार एल्गोरिदम देता है।

147
00:08:38,594 --> 00:08:41,341
और मुझे यह कहना चाहिए कि जो एनिमेशन मैं दिखाने जा रहा हूं,

148
00:08:41,341 --> 00:08:45,439
वे मूल रूप से मेरे द्वारा एमआईटी में जूलिया लैब के साथ एक निश्चित ओपनकोर्सवेयर क्लास के

149
00:08:45,439 --> 00:08:49,071
लिए किए गए व्याख्यानों के एक सेट के हिस्से के लिए बनाए गए कुछ से संशोधित हैं,

150
00:08:49,071 --> 00:08:50,887
जिसमें एक छवि प्रसंस्करण इकाई शामिल थी।

151
00:08:50,887 --> 00:08:53,802
वहां हमने इस सब के पीछे के कोड को समझने के लिए थोड़ा और काम किया,

152
00:08:53,802 --> 00:08:56,452
इसलिए यदि आप उत्सुक हैं तो मैं आपके लिए कुछ लिंक छोड़ दूंगा।

153
00:08:56,452 --> 00:08:58,902
लेकिन इस धुंधले उदाहरण पर ध्यान केंद्रित करते हुए,

154
00:08:58,902 --> 00:09:03,081
जो हो रहा है वह यह है कि मुझे मूल्यों का यह छोटा 3x3 ग्रिड मिला है जो हमारी मूल छवि के

155
00:09:03,081 --> 00:09:06,876
साथ चल रहा है, और यदि हम ज़ूम इन करते हैं, तो उनमें से प्रत्येक मान 1 9वां है,

156
00:09:06,876 --> 00:09:10,863
और मैं क्या कर रहा हूं प्रत्येक पुनरावृत्ति पर उनमें से प्रत्येक मान को उस संबंधित

157
00:09:10,863 --> 00:09:13,312
पिक्सेल से गुणा किया जाता है जिसके ऊपर वह बैठता है।

158
00:09:13,312 --> 00:09:16,927
और निश्चित रूप से कंप्यूटर विज्ञान में हम रंगों को तीन मानों के छोटे वैक्टर

159
00:09:16,927 --> 00:09:20,400
के रूप में सोचते हैं, जो लाल, हरे और नीले घटकों का प्रतिनिधित्व करते हैं।

160
00:09:20,400 --> 00:09:24,344
जब मैं इन सभी छोटे मानों को 1 9वें से गुणा करता हूं और उन्हें एक साथ जोड़ता हूं,

161
00:09:24,344 --> 00:09:26,876
तो यह हमें प्रत्येक रंग चैनल के साथ एक औसत देता है,

162
00:09:26,876 --> 00:09:30,966
और दाईं ओर की छवि के लिए संबंधित पिक्सेल को उस योग के रूप में परिभाषित किया जाता है।

163
00:09:30,966 --> 00:09:34,758
समग्र प्रभाव, जैसा कि हम छवि पर हर एक पिक्सेल के लिए करते हैं,

164
00:09:34,758 --> 00:09:38,791
यह है कि प्रत्येक एक प्रकार का उसके सभी पड़ोसियों में खून बहता है,

165
00:09:38,791 --> 00:09:41,680
जो हमें मूल की तुलना में धुंधला संस्करण देता है।

166
00:09:41,680 --> 00:09:44,647
भाषा में हम कहेंगे कि दाईं ओर की छवि मूल्यों की

167
00:09:44,647 --> 00:09:47,800
एक छोटी ग्रिड के साथ हमारी मूल छवि का एक संयोजन है।

168
00:09:47,800 --> 00:09:51,115
या अधिक तकनीकी रूप से शायद मुझे यह कहना चाहिए कि यह मूल्यों के

169
00:09:51,115 --> 00:09:54,430
उस छोटे ग्रिड के 180 डिग्री घुमाए गए संस्करण के साथ कनवल्शन है।

170
00:09:54,430 --> 00:09:56,785
ऐसा नहीं है कि ग्रिड सममित होने पर यह मायने रखता है,

171
00:09:56,785 --> 00:09:59,406
लेकिन यह ध्यान में रखने योग्य है कि एक कनवल्शन की परिभाषा,

172
00:09:59,406 --> 00:10:01,583
जैसा कि शुद्ध गणित संदर्भ से विरासत में मिली है,

173
00:10:01,583 --> 00:10:05,271
आपको हमेशा उस दूसरे सरणी के चारों ओर फ़्लिप करने के बारे में सोचने के लिए आमंत्रित

174
00:10:05,271 --> 00:10:05,760
करना चाहिए।

175
00:10:05,760 --> 00:10:08,432
यदि हम इसे थोड़ा संशोधित करते हैं तो हम मूल्यों का एक अलग

176
00:10:08,432 --> 00:10:11,059
ग्रिड चुनकर अधिक सुंदर धुंधला प्रभाव प्राप्त कर सकते हैं।

177
00:10:11,059 --> 00:10:15,920
इस मामले में मेरे पास एक छोटा सा 5x5 ग्रिड है, लेकिन अंतर इसके आकार का नहीं है।

178
00:10:15,920 --> 00:10:20,439
यदि हम ज़ूम इन करते हैं तो हम देखते हैं कि बीच का मान किनारों के मान से बहुत बड़ा है,

179
00:10:20,439 --> 00:10:23,855
और यह कहां से आ रहा है, वे सभी एक घंटी वक्र से नमूने लिए गए हैं,

180
00:10:23,855 --> 00:10:26,010
जिसे गाऊसी वितरण के रूप में जाना जाता है।

181
00:10:26,010 --> 00:10:30,693
इस तरह जब हम इन सभी मानों को संबंधित पिक्सेल से गुणा करते हैं जिसके ऊपर वे बैठे हैं,

182
00:10:30,693 --> 00:10:33,943
तो हम उस केंद्रीय पिक्सेल को बहुत अधिक महत्व दे रहे हैं और

183
00:10:33,943 --> 00:10:36,367
किनारे पर मौजूद मानों को बहुत कम दे रहे हैं।

184
00:10:36,367 --> 00:10:40,373
और ठीक पहले की तरह दाईं ओर संबंधित पिक्सेल को इस योग के रूप में परिभाषित किया गया है।

185
00:10:40,373 --> 00:10:43,397
जैसा कि हम इस प्रक्रिया को हर एक पिक्सेल के लिए करते हैं,

186
00:10:43,397 --> 00:10:48,091
यह एक धुंधला प्रभाव देता है जो आपके लेंस को फोकस से बाहर या ऐसा कुछ करने की धारणा को अधिक

187
00:10:48,091 --> 00:10:49,760
प्रामाणिक रूप से अनुकरण करता है।

188
00:10:49,760 --> 00:10:53,474
लेकिन धुंधलापन एकमात्र ऐसी चीज़ नहीं है जो आप इस विचार के साथ कर सकते हैं।

189
00:10:53,474 --> 00:10:56,379
उदाहरण के लिए, मानों के इस छोटे ग्रिड पर एक नज़र डालें,

190
00:10:56,379 --> 00:11:00,685
जिसमें बाईं ओर कुछ सकारात्मक संख्याएँ और दाईं ओर कुछ नकारात्मक संख्याएँ शामिल हैं,

191
00:11:00,685 --> 00:11:03,071
जिन्हें मैं क्रमशः नीले और लाल रंग से रंगूँगा।

192
00:11:03,071 --> 00:11:06,274
यह देखने के लिए कुछ समय लें कि क्या आप अनुमान लगा सकते

193
00:11:06,274 --> 00:11:09,769
हैं और समझ सकते हैं कि इसका अंतिम छवि पर क्या प्रभाव पड़ेगा।

194
00:11:09,769 --> 00:11:13,840
तो इस मामले में मैं छवि को रंगीन के बजाय ग्रेस्केल के रूप में सोचूंगा,

195
00:11:13,840 --> 00:11:18,082
इसलिए प्रत्येक पिक्सेल को तीन के बजाय केवल एक संख्या द्वारा दर्शाया जाएगा।

196
00:11:18,082 --> 00:11:20,472
और ध्यान देने योग्य एक बात यह है कि जैसे ही हम यह

197
00:11:20,472 --> 00:11:23,102
कनवल्शन करते हैं तो नकारात्मक मान प्राप्त करना संभव है।

198
00:11:23,102 --> 00:11:27,433
उदाहरण के लिए, यहां इस बिंदु पर यदि हम ज़ूम इन करते हैं तो हमारे छोटे ग्रिड का बायां आधा

199
00:11:27,433 --> 00:11:31,132
हिस्सा पूरी तरह से काले पिक्सेल के शीर्ष पर बैठता है, जिसका मान शून्य होगा,

200
00:11:31,132 --> 00:11:34,734
लेकिन नकारात्मक मानों का दायां आधा भाग सफेद पिक्सेल के शीर्ष पर बैठता है,

201
00:11:34,734 --> 00:11:36,000
जो कि होगा एक का मूल्य है.

202
00:11:36,000 --> 00:11:39,435
इसलिए जब हम संगत शब्दों को गुणा करते हैं और उन्हें एक साथ जोड़ते हैं तो परिणाम

203
00:11:39,435 --> 00:11:42,741
बहुत नकारात्मक होंगे, और जिस तरह से मैं इसे दाईं ओर की छवि के साथ प्रदर्शित

204
00:11:42,741 --> 00:11:46,046
कर रहा हूं वह नकारात्मक मानों को लाल और सकारात्मक मानों को नीला रंग देना है।

205
00:11:46,046 --> 00:11:50,398
ध्यान देने वाली एक और बात यह है कि जब आप एक पैच पर होते हैं जो सभी समान रंग का होता

206
00:11:50,398 --> 00:11:54,854
है तो सब कुछ शून्य हो जाता है क्योंकि हमारे छोटे ग्रिड में मानों का योग शून्य होता है।

207
00:11:54,854 --> 00:11:58,683
यह पिछले दो उदाहरणों से बहुत अलग है जहां हमारे छोटे ग्रिड का योग एक था,

208
00:11:58,683 --> 00:12:02,990
जो हमें इसे चलती औसत के रूप में व्याख्या करने देता है और इसलिए धुंधला हो जाता है।

209
00:12:02,990 --> 00:12:07,579
कुल मिलाकर यह छोटी सी प्रक्रिया मूल रूप से पता लगाती है कि जब आप बाएं

210
00:12:07,579 --> 00:12:11,381
से दाएं जाते हैं तो पिक्सेल मान में कहां भिन्नता होती है,

211
00:12:11,381 --> 00:12:16,560
और इसलिए यह आपको अपनी छवि से सभी ऊर्ध्वाधर किनारों को लेने का एक तरीका देता है।

212
00:12:16,560 --> 00:12:21,055
और इसी तरह अगर हम उस ग्रिड को चारों ओर घुमाते हैं ताकि जब आप ऊपर से नीचे की

213
00:12:21,055 --> 00:12:24,840
ओर बढ़ें तो यह अलग-अलग हो, यह सभी क्षैतिज किनारों को पकड़ लेगा,

214
00:12:24,840 --> 00:12:29,986
जो कि हमारी छोटी पाई प्राणी छवि के मामले में कुछ सुंदर राक्षसी आँखों में परिणत होता है।

215
00:12:29,986 --> 00:12:32,080
वैसे, इस छोटे ग्रिड को अक्सर कर्नेल कहा जाता है,

216
00:12:32,080 --> 00:12:35,754
और यहां की सुंदरता यह है कि कैसे एक अलग कर्नेल चुनकर आप अलग-अलग छवि प्रसंस्करण प्रभाव

217
00:12:35,754 --> 00:12:39,214
प्राप्त कर सकते हैं, न केवल आपके किनारे का पता लगाने को धुंधला कर सकते हैं बल्कि

218
00:12:39,214 --> 00:12:40,710
तेज करने जैसी चीजें भी कर सकते हैं।

219
00:12:40,710 --> 00:12:43,806
आपमें से जिन लोगों ने कनवल्शनल न्यूरल नेटवर्क के बारे में सुना है,

220
00:12:43,806 --> 00:12:47,504
उनके लिए विचार यह है कि डेटा का उपयोग करके यह पता लगाया जाए कि सबसे पहले कर्नेल

221
00:12:47,504 --> 00:12:51,618
क्या होना चाहिए, जैसा कि न्यूरल नेटवर्क जो भी पता लगाना चाहता है, उससे निर्धारित होता है।

222
00:12:51,618 --> 00:12:55,378
एक और चीज़ जो शायद मुझे सामने लानी चाहिए वह है आउटपुट की लंबाई।

223
00:12:55,378 --> 00:12:59,468
चलती औसत उदाहरण जैसी किसी चीज़ के लिए आप केवल उन शर्तों के बारे में सोचना

224
00:12:59,468 --> 00:13:03,006
चाहेंगे जब दोनों विंडो पूरी तरह से एक-दूसरे के साथ संरेखित हों,

225
00:13:03,006 --> 00:13:07,760
या छवि प्रसंस्करण उदाहरण में शायद आप चाहते हैं कि अंतिम आउटपुट का आकार मूल के समान हो।

226
00:13:07,760 --> 00:13:10,717
अब एक शुद्ध गणित ऑपरेशन के रूप में कनवल्शन हमेशा एक सरणी उत्पन्न

227
00:13:10,717 --> 00:13:13,402
करता है जो आपके द्वारा शुरू की गई दो सरणी से बड़ी होती है,

228
00:13:13,402 --> 00:13:16,405
कम से कम यह मानते हुए कि उनमें से एक की लंबाई एक के बराबर नहीं है।

229
00:13:16,405 --> 00:13:18,962
बस यह जान लें कि कुछ कंप्यूटर विज्ञान संदर्भों में

230
00:13:18,962 --> 00:13:21,520
आप अक्सर जानबूझकर उस आउटपुट को छोटा करना चाहते हैं।

231
00:13:21,520 --> 00:13:26,803
हाइलाइट करने लायक एक और बात यह है कि कंप्यूटर विज्ञान के संदर्भ में मूल के पार जाने

232
00:13:26,803 --> 00:13:31,773
से पहले उस कर्नेल के चारों ओर फ़्लिप करने की यह धारणा अक्सर वास्तव में अजीब और

233
00:13:31,773 --> 00:13:37,057
अनावश्यक लगती है, लेकिन फिर से ध्यान दें कि यह शुद्ध गणित संदर्भ से विरासत में मिला

234
00:13:37,057 --> 00:13:42,530
है जहां हम जैसे हैं संभावनाओं के साथ देखा जाए तो यह अविश्वसनीय रूप से स्वाभाविक बात है।

235
00:13:42,530 --> 00:13:45,738
और वास्तव में मैं आपको एक और शुद्ध गणित का उदाहरण दिखा सकता

236
00:13:45,738 --> 00:13:49,054
हूं जहां प्रोग्रामर को भी इसकी परवाह करनी चाहिए क्योंकि यह इन

237
00:13:49,054 --> 00:13:52,370
सभी की गणना करने के लिए बहुत तेज़ एल्गोरिदम के द्वार खोलता है।

238
00:13:52,370 --> 00:13:55,929
यहां तेजी से मेरा जो मतलब है उसे स्थापित करने के लिए मुझे वापस जाने दें और कुछ

239
00:13:55,929 --> 00:13:59,579
अजगर को फिर से खींचने दें और मैं दो अलग-अलग अपेक्षाकृत बड़े ऐरे बनाने जा रहा हूं।

240
00:13:59,579 --> 00:14:03,238
प्रत्येक में एक लाख यादृच्छिक तत्व होंगे और मैं numpy

241
00:14:03,238 --> 00:14:07,575
लाइब्रेरी से कन्वोल्व फ़ंक्शन के रनटाइम का आकलन करने जा रहा हूं।

242
00:14:07,575 --> 00:14:11,138
और इस मामले में यह इसे कई अलग-अलग पुनरावृत्तियों के लिए चलाता है,

243
00:14:11,138 --> 00:14:15,836
एक औसत खोजने की कोशिश करता है, और ऐसा लगता है कि इस कंप्यूटर पर कम से कम इसका औसत 4 है।

244
00:14:15,836 --> 00:14:16,321
87 सेकंड.

245
00:14:16,321 --> 00:14:20,993
इसके विपरीत यदि मैं scipy लाइब्रेरी से एक अलग फ़ंक्शन का उपयोग करता हूं जिसे

246
00:14:20,993 --> 00:14:25,847
fftconvolve कहा जाता है जो कि एक ही चीज़ है जिसे बस अलग तरीके से लागू किया जाता

247
00:14:25,847 --> 00:14:30,640
है जिसमें केवल 4 लगते हैं।औसतन 3 मिलीसेकंड, इसलिए परिमाण में सुधार के तीन क्रम।

248
00:14:30,640 --> 00:14:33,247
और फिर भले ही यह एक अलग नाम के तहत उड़ान भरता है,

249
00:14:33,247 --> 00:14:36,272
यह वही आउटपुट दे रहा है जो अन्य कन्वोल्व फ़ंक्शन देता है,

250
00:14:36,272 --> 00:14:38,880
यह बस इसे चतुर तरीके से करने के लिए कुछ कर रहा है।

251
00:14:38,880 --> 00:14:43,244
याद रखें कि संभाव्यता उदाहरण के साथ मैंने कहा था कि कनवल्शन के

252
00:14:43,244 --> 00:14:47,678
बारे में सोचने का एक और तरीका यह था कि सभी जोड़ीदार उत्पादों की

253
00:14:47,678 --> 00:14:52,528
यह तालिका बनाएं और फिर विकर्णों के साथ उन जोड़ीदार उत्पादों को जोड़ें।

254
00:14:52,528 --> 00:14:55,047
निश्चित रूप से संभाव्यता के लिए कुछ भी विशिष्ट नहीं है,

255
00:14:55,047 --> 00:14:58,421
जब भी आप संख्याओं की दो अलग-अलग सूचियाँ बना रहे हों तो आप इसके बारे में इस

256
00:14:58,421 --> 00:14:59,321
तरह से सोच सकते हैं।

257
00:14:59,321 --> 00:15:02,773
सभी जोड़ीवार उत्पादों के साथ इस प्रकार की गुणन तालिका बनाएं और फिर

258
00:15:02,773 --> 00:15:06,381
विकर्ण के साथ प्रत्येक योग आपके अंतिम आउटपुट में से एक से मेल खाता है।

259
00:15:06,381 --> 00:15:09,506
एक संदर्भ जहां यह दृश्य विशेष रूप से स्वाभाविक

260
00:15:09,506 --> 00:15:12,431
है जब आप दो बहुपदों को एक साथ गुणा करते हैं।

261
00:15:12,431 --> 00:15:18,419
उदाहरण के लिए, मैं हमारे पास पहले से मौजूद छोटे ग्रिड को लेता हूं और शीर्ष पदों को 1,

262
00:15:18,419 --> 00:15:23,920
2x और 3x वर्ग से बदल देता हूं और अन्य पदों को 4, 5x और 6x वर्ग से बदल देता हूं।

263
00:15:23,920 --> 00:15:26,224
अब सोचें कि जब हम दो सूचियों के बीच इन सभी अलग-अलग

264
00:15:26,224 --> 00:15:28,664
जोड़ीवार उत्पादों को बना रहे हैं तो इसका क्या मतलब है।

265
00:15:28,664 --> 00:15:33,129
आप जो कर रहे हैं वह अनिवार्य रूप से मेरे द्वारा लिखे गए दो बहुपदों के पूर्ण

266
00:15:33,129 --> 00:15:37,595
उत्पाद का विस्तार करना है और फिर जब आप विकर्ण के साथ जोड़ते हैं जो सभी समान

267
00:15:37,595 --> 00:15:42,178
पदों को एकत्रित करने के अनुरूप होता है जो कि एक बहुपद का विस्तार करने और समान

268
00:15:42,178 --> 00:15:46,937
पदों को एकत्रित करने के लिए बहुत साफ-सुथरा होता है। कनवल्शन के समान ही प्रक्रिया।

269
00:15:46,937 --> 00:15:49,872
लेकिन यह हमें कुछ ऐसा करने की अनुमति देता है जो बहुत

270
00:15:49,872 --> 00:15:52,642
अच्छा है क्योंकि सोचें कि हम यहां क्या कह रहे हैं।

271
00:15:52,642 --> 00:15:56,657
हम कह रहे हैं कि यदि आप दो अलग-अलग फ़ंक्शन लेते हैं और आप उन्हें एक

272
00:15:56,657 --> 00:15:59,668
साथ गुणा करते हैं जो कि एक सरल बिंदुवार ऑपरेशन है,

273
00:15:59,668 --> 00:16:04,038
तो यह वही बात है जैसे कि आपने पहले उनमें से प्रत्येक से गुणांक निकाला था,

274
00:16:04,038 --> 00:16:08,761
यह मानते हुए कि वे बहुपद हैं और फिर उनका कनवल्शन लिया है गुणांकों की दो सूचियाँ।

275
00:16:08,761 --> 00:16:13,009
जो चीज़ इसे इतना दिलचस्प बनाती है वह यह है कि सिद्धांत रूप में कनवल्शन सरल गुणन

276
00:16:13,009 --> 00:16:17,415
की तुलना में बहुत अधिक जटिल लगता है और मेरा मतलब यह नहीं है कि वैचारिक रूप से उनके

277
00:16:17,415 --> 00:16:21,716
बारे में सोचना कठिन है, मेरा मतलब है कि कम्प्यूटेशनल रूप से कनवल्शन को निष्पादित

278
00:16:21,716 --> 00:16:26,070
करने के लिए अधिक चरणों की आवश्यकता होती है। दो अलग-अलग सूचियों का बिंदुवार उत्पाद।

279
00:16:26,070 --> 00:16:29,433
उदाहरण के लिए, मान लें कि मैंने आपको दो बहुत बड़े बहुपद दिए हैं,

280
00:16:29,433 --> 00:16:32,331
मान लीजिए कि प्रत्येक एक सौ अलग-अलग गुणांकों के साथ है,

281
00:16:32,331 --> 00:16:36,264
तो यदि आप जिस तरह से उन्हें गुणा करते हैं, वह इस उत्पाद का विस्तार करना है,

282
00:16:36,264 --> 00:16:40,559
तो आप जानते हैं कि इस संपूर्ण 100 गुणा 100 ग्रिड को जोड़ीवार उत्पादों में भरना है,

283
00:16:40,559 --> 00:16:44,440
जिसके लिए आपको इसकी आवश्यकता होगी। 10,000 अलग-अलग उत्पाद निष्पादित करें और

284
00:16:44,440 --> 00:16:48,321
फिर जब आप विकर्णों के साथ सभी समान शब्द एकत्र कर रहे हों तो यह लगभग 10,000

285
00:16:48,321 --> 00:16:49,666
परिचालनों का एक और सेट है।

286
00:16:49,666 --> 00:16:53,914
अधिक आम तौर पर भाषा में हम कहेंगे कि एल्गोरिथ्म n वर्ग का O है,

287
00:16:53,914 --> 00:16:59,355
जिसका अर्थ n आकार की दो सूचियों के लिए है, जिस तरह से ऑपरेशन स्केल की संख्या n के

288
00:16:59,355 --> 00:17:00,816
वर्ग के अनुपात में है।

289
00:17:00,816 --> 00:17:04,899
दूसरी ओर, यदि मैं दो बहुपदों के बारे में उनके आउटपुट के संदर्भ में सोचता हूं,

290
00:17:04,899 --> 00:17:08,196
उदाहरण के लिए कुछ मुट्ठी भर इनपुट पर उनके मानों का नमूना लेना,

291
00:17:08,196 --> 00:17:12,384
तो उन्हें गुणा करने के लिए केवल उतने ही ऑपरेशन की आवश्यकता होती है जितनी नमूनों

292
00:17:12,384 --> 00:17:16,415
की संख्या, क्योंकि फिर से यह एक बिंदुवार ऑपरेशन है और बहुपद के साथ आपको केवल

293
00:17:16,415 --> 00:17:21,126
इसकी आवश्यकता होती है गुणांकों को पुनर्प्राप्त करने में सक्षम होने के लिए बहुत सारे नमूने।

294
00:17:21,152 --> 00:17:23,359
उदाहरण के लिए दो आउटपुट एक रैखिक बहुपद को विशिष्ट

295
00:17:23,359 --> 00:17:25,214
रूप से निर्दिष्ट करने के लिए पर्याप्त हैं।

296
00:17:25,214 --> 00:17:29,360
एक द्विघात बहुपद को विशिष्ट रूप से निर्दिष्ट करने के लिए तीन आउटपुट पर्याप्त होंगे।

297
00:17:29,360 --> 00:17:32,961
और सामान्य तौर पर यदि आप n भिन्न आउटपुट जानते हैं तो यह n भिन्न

298
00:17:32,961 --> 00:17:36,901
गुणांक वाले बहुपद को विशिष्ट रूप से निर्दिष्ट करने के लिए पर्याप्त है।

299
00:17:36,901 --> 00:17:41,188
या यदि आप चाहें तो हम इसे समीकरण प्रणालियों की भाषा में व्यक्त कर सकते हैं।

300
00:17:41,188 --> 00:17:43,814
कल्पना कीजिए कि मैं आपको बताता हूं कि मेरे पास कुछ बहुपद हैं लेकिन

301
00:17:43,814 --> 00:17:46,480
मैं आपको यह नहीं बताता कि गुणांक क्या हैं, वे आपके लिए एक रहस्य हैं।

302
00:17:46,480 --> 00:17:48,573
हमारे उदाहरण में आप इसे उस उत्पाद के रूप में सोच

303
00:17:48,573 --> 00:17:50,666
सकते हैं जिसका हम पता लगाने का प्रयास कर रहे हैं।

304
00:17:50,666 --> 00:17:55,023
फिर मान लीजिए कि मैं कहता हूं कि मैं आपको सिर्फ यह बताऊंगा कि इस बहुपद के आउटपुट

305
00:17:55,023 --> 00:17:59,058
क्या होंगे यदि आपने 0, 1, 2, 3, ऑन और ऑन जैसे विभिन्न इनपुट इनपुट किए हैं,

306
00:17:59,058 --> 00:18:03,791
और मैं आपको पर्याप्त देता हूं ताकि आपके पास अधिक से अधिक समीकरण हों आपके पास अज्ञात हैं.

307
00:18:03,791 --> 00:18:07,245
यह समीकरणों की एक रैखिक प्रणाली भी होती है, इसलिए यह अच्छा है।

308
00:18:07,245 --> 00:18:11,137
और कम से कम सिद्धांत रूप में, यह गुणांकों को पुनर्प्राप्त करने के लिए पर्याप्त होना चाहिए।

309
00:18:11,137 --> 00:18:15,270
तो मोटे एल्गोरिथम की रूपरेखा यह होगी कि जब भी आप संख्याओं की दो सूचियों को जोड़ना

310
00:18:15,270 --> 00:18:19,253
चाहते हैं तो आप उनके साथ ऐसे व्यवहार करते हैं जैसे वे दो बहुपदों के गुणांक हों।

311
00:18:19,253 --> 00:18:24,243
आप पर्याप्त आउटपुट पर उन बहुपदों का नमूना लेते हैं, उन नमूनों को बिंदुवार गुणा करते हैं,

312
00:18:24,243 --> 00:18:28,168
और फिर कनवल्शन खोजने के लिए एक गुप्त पिछले दरवाजे के तरीके के रूप में

313
00:18:28,168 --> 00:18:31,364
गुणांक को पुनर्प्राप्त करने के लिए सिस्टम को हल करते हैं।

314
00:18:31,364 --> 00:18:34,396
और जैसा कि मैंने कम से कम अब तक कहा है, आप में से कुछ लोग उचित रूप

315
00:18:34,396 --> 00:18:37,564
से शिकायत कर सकते हैं &quot;अनुदान, यह एक मूर्खतापूर्ण योजना है&quot;।

316
00:18:37,564 --> 00:18:41,351
क्योंकि एक बात के लिए, हम जानते हैं कि बहुपदों में से किसी एक के लिए

317
00:18:41,351 --> 00:18:45,466
इन सभी नमूनों की गणना करना पहले से ही एन वर्ग संचालन के क्रम पर आधारित है,

318
00:18:45,466 --> 00:18:49,308
उस प्रणाली को हल करने का उल्लेख नहीं करना निश्चित रूप से कम्प्यूटेशनल

319
00:18:49,308 --> 00:18:52,656
रूप से उतना ही कठिन होगा जितना कि पहले स्थान पर कनवल्शन करना।

320
00:18:52,656 --> 00:18:56,628
तो, जैसे, निश्चित रूप से हमारे पास गुणन और संकल्प के बीच यह संबंध है,

321
00:18:56,628 --> 00:19:01,054
लेकिन सारी जटिलता एक दृष्टिकोण से दूसरे दृष्टिकोण में अनुवाद करने में होती है।

322
00:19:01,054 --> 00:19:04,315
लेकिन एक तरकीब है, और आपमें से जो लोग फूरियर ट्रांसफॉर्म और एफएफटी

323
00:19:04,315 --> 00:19:07,673
एल्गोरिदम के बारे में जानते हैं वे देख सकते हैं कि यह कहां जा रहा है।

324
00:19:07,673 --> 00:19:09,901
यदि आप इन विषयों से अपरिचित हैं, तो मैं जो कहने

325
00:19:09,901 --> 00:19:12,176
जा रहा हूं वह पूरी तरह से अप्रत्याशित लग सकता है।

326
00:19:12,176 --> 00:19:14,825
बस यह जान लें कि गणित में कुछ ऐसे रास्ते हैं जिन

327
00:19:14,825 --> 00:19:17,582
पर आप चल सकते हैं जो इसे एक अपेक्षित कदम बनाते हैं।

328
00:19:17,582 --> 00:19:20,697
मूलतः विचार यह है कि यहां हमें चयन की स्वतंत्रता है।

329
00:19:20,697 --> 00:19:25,600
यदि 0, 1, 2, 3, ऑन और ऑन जैसे इनपुट के कुछ मनमाने सेट पर मूल्यांकन करने के बजाय,

330
00:19:25,600 --> 00:19:30,080
आप जटिल संख्याओं के एक विशेष रूप से चयनित सेट पर मूल्यांकन करना चुनते हैं।

331
00:19:30,080 --> 00:19:32,744
विशेष रूप से वे जो इकाई वृत्त पर समान दूरी पर स्थित हैं,

332
00:19:32,744 --> 00:19:34,894
जिन्हें एकता की जड़ों के रूप में जाना जाता है।

333
00:19:34,894 --> 00:19:37,364
यह हमें एक मित्रतापूर्ण प्रणाली प्रदान करता है।

334
00:19:37,364 --> 00:19:42,268
मूल विचार यह है कि एक संख्या ढूँढ़ने से जहाँ उसकी शक्तियाँ इस चक्रण पैटर्न में आती हैं,

335
00:19:42,268 --> 00:19:46,726
इसका मतलब है कि हम जो प्रणाली उत्पन्न करते हैं उसमें उन विभिन्न शब्दों में बहुत

336
00:19:46,726 --> 00:19:49,568
अधिक अतिरेक होने वाला है जिनकी आप गणना कर रहे हैं,

337
00:19:49,568 --> 00:19:53,301
और इस बारे में चतुर होने से कि कैसे आप उस अतिरेक का लाभ उठाते हैं,

338
00:19:53,301 --> 00:19:55,252
आप अपना बहुत सारा काम बचा सकते हैं।

339
00:19:55,252 --> 00:19:58,970
मेरे द्वारा लिखे गए आउटपुट के इस सेट का एक विशेष नाम है,

340
00:19:58,970 --> 00:20:02,166
इसे गुणांकों का असतत फूरियर रूपांतरण कहा जाता है।

341
00:20:02,166 --> 00:20:05,635
और यदि आप और अधिक जानना चाहते हैं तो मैंने वास्तव में उसी जूलिया एमआईटी

342
00:20:05,635 --> 00:20:09,103
कक्षा के लिए असतत फूरियर परिवर्तनों के बारे में एक और व्याख्यान दिया था।

343
00:20:09,103 --> 00:20:13,183
और चैनल रिड्यूसिबल पर तेज़ फूरियर ट्रांसफॉर्म के बारे में बात करने वाला एक बहुत ही

344
00:20:13,183 --> 00:20:17,263
उत्कृष्ट वीडियो भी है, जो इन्हें और अधिक तेज़ी से गणना करने के लिए एक एल्गोरिदम है।

345
00:20:17,263 --> 00:20:20,480
इसके अलावा वेरिटासियम ने हाल ही में एफएफटी पर एक बहुत अच्छा वीडियो बनाया है,

346
00:20:20,480 --> 00:20:21,984
इसलिए आपके पास बहुत सारे विकल्प हैं।

347
00:20:21,984 --> 00:20:24,786
और वह तेज़ एल्गोरिदम वास्तव में हमारे लिए महत्वपूर्ण है।

348
00:20:24,786 --> 00:20:29,065
फिर से इस सभी अतिरेक के कारण गुणांक से इन सभी आउटपुट तक जाने की एक विधि मौजूद है,

349
00:20:29,065 --> 00:20:31,674
जहां एन स्क्वैयर ऑपरेशंस के क्रम पर करने के बजाय,

350
00:20:31,674 --> 00:20:34,440
आप एन ऑपरेशंस के लॉग के एन गुना के क्रम पर करते हैं,

351
00:20:34,440 --> 00:20:37,936
जो कि बहुत अधिक है जैसे-जैसे आप बड़ी सूचियों में आगे बढ़ते जाएंगे,

352
00:20:37,936 --> 00:20:39,293
यह और भी बेहतर होता जाएगा।

353
00:20:39,293 --> 00:20:42,386
और महत्वपूर्ण बात यह है कि यह एफएफटी एल्गोरिदम दोनों तरीकों से चलता है।

354
00:20:42,386 --> 00:20:45,515
यह आपको आउटपुट से गुणांक तक जाने की सुविधा भी देता है।

355
00:20:45,515 --> 00:20:49,054
तो इन सबको एक साथ लाते हुए, आइए अपनी एल्गोरिदम रूपरेखा पर एक नज़र डालें।

356
00:20:49,054 --> 00:20:53,340
अब हम कह सकते हैं कि जब भी आपको संख्याओं की दो लंबी सूचियाँ दी जाती हैं और आप उनका

357
00:20:53,340 --> 00:20:57,884
कनवल्शन लेना चाहते हैं, तो पहले उनमें से प्रत्येक के तेज़ फूरियर रूपांतरण की गणना करें,

358
00:20:57,884 --> 00:21:02,170
जिसे आप अपने दिमाग के पीछे बस उनके साथ व्यवहार करने के बारे में सोच सकते हैं वे एक

359
00:21:02,170 --> 00:21:06,766
बहुपद के गुणांक हैं और इसका मूल्यांकन बहुत विशेष रूप से चयनित बिंदुओं के सेट पर करते हैं।

360
00:21:06,766 --> 00:21:10,195
फिर उन दो परिणामों को एक साथ गुणा करें जो आपको अभी-अभी मिले हैं,

361
00:21:10,195 --> 00:21:13,677
जो कि अच्छा और तेज़ है, और फिर एक उलटा तेज़ फूरियर रूपांतरण करें,

362
00:21:13,677 --> 00:21:17,633
और जो आपको कनवल्शन की गणना करने के लिए एक गुप्त पिछले दरवाजे का तरीका देता

363
00:21:17,633 --> 00:21:18,847
है जिसे हम ढूंढ रहे थे।

364
00:21:18,847 --> 00:21:22,957
लेकिन इस बार इसमें केवल n लॉग n ऑपरेशनों में से O शामिल है।

365
00:21:22,957 --> 00:21:24,865
यह मेरे लिए सचमुच बहुत अच्छा है!

366
00:21:24,865 --> 00:21:29,522
यह बहुत ही विशिष्ट संदर्भ जहां दो बहुपदों को गुणा करते हुए कनवल्शन दिखाई देता है,

367
00:21:29,522 --> 00:21:34,235
एक एल्गोरिदम के लिए दरवाजे खोलता है जो हर जगह प्रासंगिक है जहां कनवल्शन आ सकते हैं।

368
00:21:34,235 --> 00:21:37,925
यदि आप संभाव्यता वितरण जोड़ना चाहते हैं, तो कुछ बड़ी छवि प्रसंस्करण करें,

369
00:21:37,925 --> 00:21:38,822
चाहे वह कुछ भी हो।

370
00:21:38,822 --> 00:21:43,365
और मुझे लगता है कि यह इस बात का एक अच्छा उदाहरण है कि जब आप गणित में कुछ ऑपरेशन या

371
00:21:43,365 --> 00:21:47,798
अवधारणा को कई असंबंधित क्षेत्रों में देखते हैं तो आपको उत्साहित क्यों होना चाहिए।

372
00:21:47,798 --> 00:21:51,967
यदि आप थोड़ा होमवर्क चाहते हैं तो यहां कुछ ऐसा है जिसके बारे में सोचना मजेदार है।

373
00:21:51,967 --> 00:21:54,724
समझाएं कि जब आप दो अलग-अलग संख्याओं को गुणा करते हैं,

374
00:21:54,724 --> 00:21:58,299
तो बस सामान्य गुणन जिस तरह से हम सभी प्राथमिक विद्यालय में सीखते हैं,

375
00:21:58,299 --> 00:22:01,924
आप जो कर रहे हैं वह मूल रूप से उन संख्याओं के अंकों के बीच एक संलयन है।

376
00:22:01,924 --> 00:22:06,785
कैरी वगैरह के साथ कुछ अतिरिक्त चरण हैं, लेकिन मुख्य चरण एक कनवल्शन है।

377
00:22:06,785 --> 00:22:10,585
एक तेज़ एल्गोरिदम के अस्तित्व के आलोक में, इसका मतलब यह है कि यदि

378
00:22:10,585 --> 00:22:14,384
आपके पास दो बहुत बड़े पूर्णांक हैं, तो उनके उत्पाद को खोजने का एक

379
00:22:14,384 --> 00:22:18,240
तरीका मौजूद है जो प्राथमिक विद्यालय में सीखी गई विधि से भी तेज़ है।

380
00:22:18,240 --> 00:22:22,718
इसके लिए n वर्ग संचालन के O की आवश्यकता के बजाय केवल n log n के O की आवश्यकता होती है,

381
00:22:22,718 --> 00:22:25,291
जिससे यह भी महसूस नहीं होता कि यह संभव होना चाहिए।

382
00:22:25,291 --> 00:22:29,128
समस्या यह है कि इससे पहले कि यह वास्तव में व्यवहार में उपयोगी हो,

383
00:22:29,128 --> 00:22:31,280
आपकी संख्या बिल्कुल भयानक होनी चाहिए।

384
00:22:31,280 --> 00:22:34,445
लेकिन फिर भी, यह अच्छा है कि ऐसा एल्गोरिदम मौजूद है।

385
00:22:34,445 --> 00:22:42,336
आगे हम संभाव्यता वितरण पर विशेष ध्यान देने के

386
00:22:42,336 --> 00:22:50,400
साथ निरंतर मामले पर अपना ध्यान केंद्रित करेंगे।

