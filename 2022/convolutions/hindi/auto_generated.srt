1
00:00:00,000 --> 00:00:02,271
मान लीजिए कि मैं आपको संख्याओं की दो अलग-अलग सूचियाँ देता हूँ, 

2
00:00:02,271 --> 00:00:04,975
या शायद दो अलग-अलग फ़ंक्शन देता हूँ, और मैं आपसे उन सभी तरीकों के बारे में 

3
00:00:04,975 --> 00:00:07,750
सोचने के लिए कहता हूँ जिनसे आप संख्याओं की एक नई सूची प्राप्त करने के लिए उन 

4
00:00:07,750 --> 00:00:10,635
दो सूचियों को जोड़ सकते हैं, या एक नया फ़ंक्शन प्राप्त करने के लिए दो फ़ंक्शनों 

5
00:00:10,635 --> 00:00:11,320
को जोड़ सकते हैं। .

6
00:00:12,120 --> 00:00:14,540
शायद एक आसान तरीका जो दिमाग में आता है वह यह है 

7
00:00:14,540 --> 00:00:16,760
कि उन्हें शब्द दर शब्द एक साथ जोड़ दिया जाए।

8
00:00:17,160 --> 00:00:19,920
इसी प्रकार फ़ंक्शंस के साथ, आप सभी संबंधित आउटपुट जोड़ सकते हैं।

9
00:00:20,540 --> 00:00:23,058
इसी तरह, आप दोनों सूचियों को पद दर पद गुणा भी कर 

10
00:00:23,058 --> 00:00:25,680
सकते हैं और फ़ंक्शंस के साथ भी यही काम कर सकते हैं।

11
00:00:26,360 --> 00:00:29,620
लेकिन इन दोनों की तरह एक और प्रकार का संयोजन भी मौलिक है, 

12
00:00:29,620 --> 00:00:33,500
लेकिन बहुत कम चर्चा की जाती है, जिसे कनवल्शन के रूप में जाना जाता है।

13
00:00:34,080 --> 00:00:36,972
लेकिन पिछले दो मामलों के विपरीत, यह ऐसा कुछ नहीं है जो केवल एक 

14
00:00:36,972 --> 00:00:39,820
ऑपरेशन से विरासत में मिला है जिसे आप संख्याओं में कर सकते हैं।

15
00:00:39,980 --> 00:00:44,700
संख्याओं की सूची या संयोजन कार्यों के संदर्भ में यह वास्तव में कुछ नया है।

16
00:00:45,320 --> 00:00:48,694
वे हर जगह दिखाई देते हैं, वे छवि प्रसंस्करण में सर्वव्यापी हैं, 

17
00:00:48,694 --> 00:00:51,330
यह संभाव्यता के सिद्धांत में एक मुख्य निर्माण है, 

18
00:00:51,330 --> 00:00:54,440
अंतर समीकरणों को हल करने में उनका बहुत उपयोग किया जाता है, 

19
00:00:54,440 --> 00:00:58,447
और एक संदर्भ जहां आपने इसे लगभग निश्चित रूप से देखा है, यदि नहीं इस नाम से, 

20
00:00:58,447 --> 00:01:00,240
दो बहुपदों को एक साथ गुणा करना है।

21
00:01:00,740 --> 00:01:04,942
दृश्य स्पष्टीकरण के व्यवसाय में किसी के रूप में, यह एक विशेष रूप से महान विषय है, 

22
00:01:04,942 --> 00:01:08,889
क्योंकि अलगाव में और संदर्भ के बिना सूत्रबद्ध परिभाषा डराने वाली लग सकती है, 

23
00:01:08,889 --> 00:01:12,682
लेकिन अगर हम वास्तव में यह क्या कह रहे हैं उसे खोलने के लिए समय लेते हैं, 

24
00:01:12,682 --> 00:01:16,269
और उससे पहले वास्तव में प्रेरित करते हैं कि क्यों आप ऐसा कुछ चाहेंगे, 

25
00:01:16,269 --> 00:01:18,320
यह एक अविश्वसनीय रूप से सुंदर ऑपरेशन है।

26
00:01:18,960 --> 00:01:21,205
और मुझे यह स्वीकार करना होगा कि इस परियोजना के लिए 

27
00:01:21,205 --> 00:01:23,540
दृश्यों को एक साथ रखते समय मैंने वास्तव में कुछ सीखा।

28
00:01:23,540 --> 00:01:25,649
दो अलग-अलग कार्यों को संयोजित करने के मामले में, 

29
00:01:25,649 --> 00:01:29,394
मैं अलग-अलग तरीकों के बारे में सोचने की कोशिश कर रहा था जिनसे आप कल्पना कर सकते हैं कि 

30
00:01:29,394 --> 00:01:33,053
इसका क्या मतलब हो सकता है, और उनमें से एक के साथ मेरे मन में थोड़ा अहा पल आया कि ऐसा 

31
00:01:33,053 --> 00:01:36,281
क्यों है कि सामान्य वितरण भूमिका निभाते हैं वे संभाव्यता में ऐसा करते हैं, 

32
00:01:36,281 --> 00:01:38,520
किसी फ़ंक्शन के लिए यह इतना स्वाभाविक आकार क्यों है।

33
00:01:39,020 --> 00:01:41,520
लेकिन मैं खुद से आगे निकल रहा हूं, इसके लिए बहुत सारी व्यवस्थाएं मौजूद हैं।

34
00:01:41,840 --> 00:01:45,009
इस वीडियो में, हमारा प्राथमिक ध्यान केवल अलग-अलग मामले पर होगा, 

35
00:01:45,009 --> 00:01:49,219
और विशेष रूप से इनकी गणना के लिए एक बहुत ही अप्रत्याशित लेकिन बहुत ही चतुर एल्गोरिदम 

36
00:01:49,219 --> 00:01:50,260
का निर्माण करना होगा।

37
00:01:50,260 --> 00:01:54,480
और मैं सतत मामले की चर्चा को दूसरे भाग में ले जाऊंगा।

38
00:01:58,580 --> 00:02:01,391
छवि प्रसंस्करण उदाहरणों के साथ शुरुआत करना बहुत आकर्षक है, 

39
00:02:01,391 --> 00:02:05,012
क्योंकि वे दृष्टिगत रूप से सबसे दिलचस्प हैं, लेकिन कुछ बारीकियाँ हैं जो छवि 

40
00:02:05,012 --> 00:02:08,300
प्रसंस्करण मामले को समग्र रूप से संकल्पों का कम प्रतिनिधि बनाती हैं, 

41
00:02:08,300 --> 00:02:10,826
इसलिए इसके बजाय संभावनाओं के साथ चीजों को शुरू करें, 

42
00:02:10,826 --> 00:02:14,685
और विशेष रूप से सबसे सरल उदाहरणों में से एक, जिसके बारे में मुझे यकीन है कि यहां 

43
00:02:14,685 --> 00:02:18,498
हर किसी ने अपने जीवन में कभी न कभी सोचा होगा, जो कि पासों की एक जोड़ी को घुमाना 

44
00:02:18,498 --> 00:02:21,500
और विभिन्न अलग-अलग योगों को देखने की संभावनाओं का पता लगाना है।

45
00:02:22,460 --> 00:02:24,460
और आप कह सकते हैं, कोई समस्या नहीं, कोई समस्या नहीं।

46
00:02:24,680 --> 00:02:28,180
आपके दोनों पासों में से प्रत्येक के छह अलग-अलग संभावित परिणाम हैं, 

47
00:02:28,180 --> 00:02:31,262
जो हमें परिणामों के कुल 36 अलग-अलग संभावित जोड़े देते हैं, 

48
00:02:31,262 --> 00:02:35,860
और यदि हम उन सभी को देखते हैं तो हम गिन सकते हैं कि कितने जोड़ों में एक दिया गया योग है।

49
00:02:36,600 --> 00:02:39,464
और सभी जोड़ियों को इस तरह एक ग्रिड में व्यवस्थित करने पर, 

50
00:02:39,464 --> 00:02:42,723
एक बहुत अच्छी बात यह है कि जिन सभी जोड़ियों का योग स्थिर होता है, 

51
00:02:42,723 --> 00:02:45,440
वे इन विभिन्न विकर्णों में से एक के साथ दिखाई देते हैं।

52
00:02:45,440 --> 00:02:48,805
तो बस यह गिनने से कि उनमें से प्रत्येक विकर्ण पर कितने मौजूद हैं, 

53
00:02:48,805 --> 00:02:52,120
आपको पता चल जाएगा कि आपको एक विशेष योग देखने की कितनी संभावना है।

54
00:02:53,220 --> 00:02:55,816
और मैं कहूंगा, बहुत अच्छा, बहुत अच्छा, लेकिन क्या आप किसी अन्य 

55
00:02:55,816 --> 00:02:58,660
तरीके के बारे में सोच सकते हैं जिससे आप उसी प्रश्न की कल्पना कर सकें?

56
00:02:59,300 --> 00:03:01,527
अन्य छवियां जो उन सभी विशिष्ट जोड़ियों के बारे में 

57
00:03:01,527 --> 00:03:04,060
सोचने के लिए दिमाग में आ सकती हैं जिनका एक निश्चित योग है?

58
00:03:04,860 --> 00:03:07,980
और हो सकता है कि आप में से कोई अपना हाथ उठाए और कहे, हाँ, मेरे पास एक है।

59
00:03:08,280 --> 00:03:11,778
मान लीजिए कि आप एक पंक्ति में संभावनाओं के इन दो अलग-अलग सेटों की कल्पना करते हैं, 

60
00:03:11,778 --> 00:03:13,760
लेकिन आप उस दूसरी पंक्ति के चारों ओर घूमते हैं।

61
00:03:13,760 --> 00:03:18,760
इस तरह सभी अलग-अलग जोड़े जो सात तक जुड़ते हैं, इस तरह लंबवत पंक्ति में आते हैं।

62
00:03:19,360 --> 00:03:22,565
और यदि हम उस निचली पंक्ति को पूरी तरह से दाहिनी ओर सरकाते हैं, 

63
00:03:22,565 --> 00:03:26,280
तो अद्वितीय जोड़ी जो दो को जोड़ती है, साँप की आँखें, ही संरेखित होती हैं।

64
00:03:26,620 --> 00:03:29,438
और यदि मैं इसे दाहिनी ओर एक इकाई पर झुकाऊं, तो जो जोड़े संरेखित 

65
00:03:29,438 --> 00:03:32,080
होते हैं वे दो अलग-अलग जोड़े होते हैं जिनका योग तीन होता है।

66
00:03:32,880 --> 00:03:37,646
और सामान्य तौर पर, इस निचले सरणी के अलग-अलग ऑफसेट मान, जो याद रखें कि मुझे पहले पलटना था, 

67
00:03:37,646 --> 00:03:41,460
उन सभी अलग-अलग जोड़ियों को प्रकट करता है जिनमें एक दिया गया योग होता है।

68
00:03:44,820 --> 00:03:48,705
जहां तक संभाव्यता प्रश्नों का सवाल है, यह अभी भी विशेष रूप से दिलचस्प नहीं है, 

69
00:03:48,705 --> 00:03:52,640
क्योंकि हम केवल यह गिन रहे हैं कि इनमें से प्रत्येक श्रेणी में कितने परिणाम हैं।

70
00:03:52,980 --> 00:03:55,497
लेकिन यह इस अंतर्निहित धारणा के साथ है कि इनमें 

71
00:03:55,497 --> 00:03:58,120
से प्रत्येक चेहरे के सामने आने की समान संभावना है।

72
00:03:58,360 --> 00:04:01,620
लेकिन क्या होगा अगर मैं आपसे कहूं कि मेरे पास पासों का एक विशेष सेट है जो एक समान नहीं है?

73
00:04:02,060 --> 00:04:05,816
हो सकता है कि नीले पासे में संख्याओं का अपना सेट हो जो प्रत्येक चेहरे के आने की 

74
00:04:05,816 --> 00:04:09,760
संभावनाओं का वर्णन करता हो, और लाल पासे में संख्याओं का अपना विशिष्ट विशिष्ट सेट हो।

75
00:04:10,299 --> 00:04:14,060
उस स्थिति में, यदि आप दो देखने की संभावना का पता लगाना चाहते हैं, 

76
00:04:14,060 --> 00:04:18,562
तो आप नीले पासे के एक होने की प्रायिकता को लाल पासे के एक होने की प्रायिकता से 

77
00:04:18,562 --> 00:04:19,360
गुणा कर देंगे।

78
00:04:19,360 --> 00:04:24,488
और तीन देखने की संभावना के लिए, आप दो अलग-अलग जोड़ियों को देखें जहां यह संभव है, 

79
00:04:24,488 --> 00:04:29,680
और फिर से, संबंधित संभावनाओं को गुणा करें, और फिर उन दो उत्पादों को एक साथ जोड़ें।

80
00:04:30,100 --> 00:04:33,486
इसी प्रकार, चार को देखने की संभावना में संभावनाओं के तीन अलग-अलग 

81
00:04:33,486 --> 00:04:36,820
युग्मों को एक साथ गुणा करना और उन सभी को एक साथ जोड़ना शामिल है।

82
00:04:36,820 --> 00:04:41,328
और कुछ सूत्र स्थापित करने की भावना से, आइए इन शीर्ष संभावनाओं को a1, a2, 

83
00:04:41,328 --> 00:04:45,960
a3, इत्यादि नाम दें, और नीचे वाली संभावनाओं को b1, b2, b3, इत्यादि नाम दें।

84
00:04:46,400 --> 00:04:50,159
और सामान्य तौर पर, यह प्रक्रिया, जहां हम संख्याओं के दो अलग-अलग सरणी ले रहे हैं, 

85
00:04:50,159 --> 00:04:53,871
दूसरे को चारों ओर घुमा रहे हैं, और फिर उन्हें विभिन्न ऑफसेट मानों पर पंक्तिबद्ध 

86
00:04:53,871 --> 00:04:57,398
कर रहे हैं, जोड़ीदार उत्पादों का एक समूह ले रहे हैं और उन्हें जोड़ रहे हैं, 

87
00:04:57,398 --> 00:05:00,740
यह इनमें से एक है कनवल्शन क्या है इसके बारे में सोचने के बुनियादी तरीके।

88
00:05:00,740 --> 00:05:06,267
तो बस इसे थोड़ा और सटीक रूप से बताने के लिए, इस प्रक्रिया के माध्यम से, हमने दो, 

89
00:05:06,267 --> 00:05:12,067
तीन, चार, आगे और फिर 12 तक देखने की संभावनाएं उत्पन्न कीं, और हमने मानों की एक सूची, 

90
00:05:12,067 --> 00:05:16,980
ए, और एक अन्य को एक साथ मिलाकर उन्हें प्राप्त किया। मूल्यों की सूची, बी.

91
00:05:17,440 --> 00:05:22,151
भाषा में, हम कहेंगे कि उन दो अनुक्रमों का कनवल्शन हमें यह नया अनुक्रम देता है, 

92
00:05:22,151 --> 00:05:27,340
11 मानों का नया अनुक्रम, जिनमें से प्रत्येक जोड़ीदार उत्पादों के कुछ योग जैसा दिखता है।

93
00:05:27,340 --> 00:05:32,191
यदि आप चाहें, तो उसी ऑपरेशन के बारे में दूसरा तरीका यह सोच सकते हैं कि पहले 

94
00:05:32,191 --> 00:05:36,980
सभी जोड़ीवार उत्पादों की एक तालिका बनाएं, और फिर इन सभी विकर्णों को जोड़ें।

95
00:05:37,460 --> 00:05:39,961
फिर, यह संख्याओं के इन दो अनुक्रमों को एक साथ मिलाने का एक 

96
00:05:39,961 --> 00:05:42,760
तरीका है जिससे हमें 11 संख्याओं का एक नया अनुक्रम प्राप्त होता है।

97
00:05:43,240 --> 00:05:46,460
यह वही ऑपरेशन है जैसा कि स्लाइडिंग विंडोज़ ने सोचा था, बस एक और परिप्रेक्ष्य।

98
00:05:47,140 --> 00:05:49,800
इसमें थोड़ा सा नोटेशन डालते हुए, यहां बताया गया है कि आप इसे कैसे लिखा हुआ देख सकते हैं।

99
00:05:50,220 --> 00:05:54,909
ए और बी का कनवल्शन, इस छोटे तारांकन के साथ दर्शाया गया है, एक नई सूची है, 

100
00:05:54,909 --> 00:05:58,015
और उस सूची का एनवां तत्व एक योग की तरह दिखता है, 

101
00:05:58,015 --> 00:06:02,008
और वह योग सूचकांकों के सभी अलग-अलग जोड़े, आई और जे पर जाता है, 

102
00:06:02,008 --> 00:06:04,860
ताकि योग का योग हो वे सूचकांक n के बराबर हैं।

103
00:06:05,280 --> 00:06:08,648
यह एक प्रकार का कौर है, लेकिन उदाहरण के लिए, यदि n 6 था, 

104
00:06:08,648 --> 00:06:13,376
तो जिन जोड़ियों पर हम जा रहे हैं वे 1 और 5, 2 और 4, 3 और 3, 4 और 2, 5 और 1 हैं, 

105
00:06:13,376 --> 00:06:15,800
सभी अलग-अलग जोड़े हैं जो जुड़ते हैं से 6.

106
00:06:16,620 --> 00:06:18,769
लेकिन ईमानदारी से कहूं तो, आप इसे किसी भी तरह से लिखें, 

107
00:06:18,769 --> 00:06:20,766
प्रक्रिया के दौरान आपके दिमाग में जो दृश्य रहता है, 

108
00:06:20,766 --> 00:06:22,340
उसके मुकाबले नोटेशन का महत्व गौण होता है।

109
00:06:23,280 --> 00:06:26,290
यहां, शायद यह एक अत्यंत सरल उदाहरण देने में मदद करेगा, 

110
00:06:26,290 --> 00:06:30,780
जहां मैं आपसे पूछ सकता हूं कि सूची 4, 5, 6 के साथ सूची 1, 2, 3 का कनवल्शन क्या है।

111
00:06:31,480 --> 00:06:34,650
आप इन दोनों सूचियों को लेते हुए, दूसरी सूची के चारों ओर पलटते हुए, 

112
00:06:34,650 --> 00:06:37,680
और फिर इसके ढक्कन से शुरू करके बाईं ओर तक की कल्पना कर सकते हैं।

113
00:06:38,180 --> 00:06:40,446
फिर मानों की जोड़ी जो संरेखित होती है वह 1 और 4 है, 

114
00:06:40,446 --> 00:06:43,540
उन्हें एक साथ गुणा करें, और इससे हमें हमारे आउटपुट का पहला पद मिलता है।

115
00:06:43,960 --> 00:06:47,955
उस निचली सरणी को एक इकाई दाईं ओर स्लाइड करें, जो जोड़े संरेखित हैं वे 1 और 5, 

116
00:06:47,955 --> 00:06:51,181
और 2 और 4 हैं, उन जोड़ियों को गुणा करें, उन्हें एक साथ जोड़ें, 

117
00:06:51,181 --> 00:06:54,460
और इससे हमें 13 मिलता है, जो हमारे आउटपुट में अगली प्रविष्टि है।

118
00:06:54,960 --> 00:06:59,128
चीज़ों को एक बार फिर सरकाएँ, और हम 1 गुना 6, प्लस 2 गुना 5, 

119
00:06:59,128 --> 00:07:01,560
प्लस 3 गुना 4, जो होता है 28 लेंगे।

120
00:07:02,020 --> 00:07:05,707
एक और स्लाइड, और हमें 2 गुना 6, प्लस 3 गुना 5 मिलता है, 

121
00:07:05,707 --> 00:07:10,120
और इससे हमें 27 मिलता है, और अंत में अंतिम पद 3 गुना 6 जैसा दिखेगा।

122
00:07:10,660 --> 00:07:13,111
यदि आप चाहें, तो आप जो भी आपकी पसंदीदा प्रोग्रामिंग भाषा है, 

123
00:07:13,111 --> 00:07:15,925
और आपकी पसंदीदा लाइब्रेरी जिसमें विभिन्न संख्यात्मक ऑपरेशन शामिल हैं, 

124
00:07:15,925 --> 00:07:18,980
को खींच सकते हैं, और आप पुष्टि कर सकते हैं कि मैं आपसे झूठ नहीं बोल रहा हूं।

125
00:07:18,980 --> 00:07:22,268
यदि आप 4, 5, 6 के विरुद्ध 1, 2, 3 का कनवल्शन लेते हैं, 

126
00:07:22,268 --> 00:07:24,480
तो आपको वास्तव में यही परिणाम मिलेगा।

127
00:07:25,920 --> 00:07:29,488
हमने एक मामला देखा है जहां यह एक प्राकृतिक और वांछनीय ऑपरेशन है, 

128
00:07:29,488 --> 00:07:33,660
जो संभाव्यता वितरण को जोड़ता है, और एक अन्य सामान्य उदाहरण एक चलती औसत होगी।

129
00:07:34,080 --> 00:07:36,701
कल्पना करें कि आपके पास संख्याओं की कुछ लंबी सूची है, 

130
00:07:36,701 --> 00:07:39,760
और आप संख्याओं की एक और छोटी सूची लेते हैं जिनका योग 1 होता है।

131
00:07:40,100 --> 00:07:44,060
इस मामले में, मेरे पास केवल 5 मानों की एक छोटी सी सूची है, और वे सभी 1/5वें के बराबर हैं।

132
00:07:44,060 --> 00:07:46,909
फिर यदि हम यह स्लाइडिंग विंडो कनवल्शन प्रक्रिया करते हैं, 

133
00:07:46,909 --> 00:07:51,330
और अपनी आंखें बंद कर लेते हैं और गलीचे के नीचे देखते हैं कि इसकी शुरुआत में क्या होता है, 

134
00:07:51,330 --> 00:07:55,261
एक बार जब मूल्यों की हमारी छोटी सूची पूरी तरह से बड़े के साथ ओवरलैप हो जाती है, 

135
00:07:55,261 --> 00:07:58,700
तो सोचें कि इसमें प्रत्येक शब्द क्या है कनवल्शन का वास्तव में मतलब है।

136
00:07:59,400 --> 00:08:03,143
प्रत्येक पुनरावृत्ति पर, आप जो कर रहे हैं वह आपके डेटा के प्रत्येक 

137
00:08:03,143 --> 00:08:06,608
मान को 1/5वें से गुणा करना है, और उन सभी को एक साथ जोड़ना है, 

138
00:08:06,608 --> 00:08:10,520
जिसका अर्थ है कि आप इस छोटी विंडो के अंदर अपने डेटा का औसत ले रहे हैं।

139
00:08:11,100 --> 00:08:14,805
कुल मिलाकर, यह प्रक्रिया आपको मूल डेटा का एक सुव्यवस्थित संस्करण प्रदान करती है, 

140
00:08:14,805 --> 00:08:18,145
और आप इसे संख्याओं की एक अलग छोटी सूची से शुरू करके संशोधित कर सकते हैं, 

141
00:08:18,145 --> 00:08:21,988
और जब तक वह छोटी सूची 1 तक जुड़ जाती है, तब भी आप इसे एक गतिशील के रूप में व्याख्या 

142
00:08:21,988 --> 00:08:22,720
कर सकते हैं औसत।

143
00:08:23,400 --> 00:08:27,760
यहां दिखाए गए उदाहरण में, वह चलती औसत केंद्रीय मूल्य की ओर अधिक भार देगी।

144
00:08:28,420 --> 00:08:30,800
इसके परिणामस्वरूप डेटा का एक सुचारु संस्करण भी प्राप्त होता है।

145
00:08:33,140 --> 00:08:35,977
यदि आप इसका द्वि-आयामी एनालॉग बनाते हैं, तो यह आपको किसी दी 

146
00:08:35,977 --> 00:08:38,720
गई छवि को धुंधला करने के लिए एक मज़ेदार एल्गोरिदम देता है।

147
00:08:38,720 --> 00:08:41,482
और मुझे यह कहना चाहिए कि जो एनिमेशन मैं दिखाने जा रहा हूं, 

148
00:08:41,482 --> 00:08:45,602
वे मूल रूप से मेरे द्वारा एमआईटी में जूलिया लैब के साथ एक निश्चित ओपनकोर्सवेयर क्लास के 

149
00:08:45,602 --> 00:08:49,254
लिए किए गए व्याख्यानों के एक सेट के हिस्से के लिए बनाए गए कुछ से संशोधित हैं, 

150
00:08:49,254 --> 00:08:51,080
जिसमें एक छवि प्रसंस्करण इकाई शामिल थी।

151
00:08:51,560 --> 00:08:54,032
वहां हमने इस सब के पीछे के कोड को समझने के लिए थोड़ा और काम किया, 

152
00:08:54,032 --> 00:08:56,280
इसलिए यदि आप उत्सुक हैं तो मैं आपके लिए कुछ लिंक छोड़ दूंगा।

153
00:08:56,620 --> 00:08:59,090
लेकिन इस धुंधले उदाहरण पर ध्यान केंद्रित करते हुए, 

154
00:08:59,090 --> 00:09:03,303
जो हो रहा है वह यह है कि मुझे मूल्यों का यह छोटा 3x3 ग्रिड मिला है जो हमारी मूल छवि के 

155
00:09:03,303 --> 00:09:07,129
साथ चल रहा है, और यदि हम ज़ूम इन करते हैं, तो उनमें से प्रत्येक मान 1 9वां है, 

156
00:09:07,129 --> 00:09:11,149
और मैं क्या कर रहा हूं प्रत्येक पुनरावृत्ति पर उनमें से प्रत्येक मान को उस संबंधित 

157
00:09:11,149 --> 00:09:13,620
पिक्सेल से गुणा किया जाता है जिसके ऊपर वह बैठता है।

158
00:09:13,900 --> 00:09:17,113
और निश्चित रूप से कंप्यूटर विज्ञान में हम रंगों को तीन मानों के छोटे वैक्टर 

159
00:09:17,113 --> 00:09:20,200
के रूप में सोचते हैं, जो लाल, हरे और नीले घटकों का प्रतिनिधित्व करते हैं।

160
00:09:20,560 --> 00:09:24,531
जब मैं इन सभी छोटे मानों को 1 9वें से गुणा करता हूं और उन्हें एक साथ जोड़ता हूं, 

161
00:09:24,531 --> 00:09:27,081
तो यह हमें प्रत्येक रंग चैनल के साथ एक औसत देता है, 

162
00:09:27,081 --> 00:09:31,200
और दाईं ओर की छवि के लिए संबंधित पिक्सेल को उस योग के रूप में परिभाषित किया जाता है।

163
00:09:31,940 --> 00:09:35,097
समग्र प्रभाव, जैसा कि हम छवि पर हर एक पिक्सेल के लिए करते हैं, 

164
00:09:35,097 --> 00:09:38,454
यह है कि प्रत्येक एक प्रकार का उसके सभी पड़ोसियों में खून बहता है, 

165
00:09:38,454 --> 00:09:40,860
जो हमें मूल की तुलना में धुंधला संस्करण देता है।

166
00:09:41,720 --> 00:09:44,638
भाषा में हम कहेंगे कि दाईं ओर की छवि मूल्यों की 

167
00:09:44,638 --> 00:09:47,740
एक छोटी ग्रिड के साथ हमारी मूल छवि का एक संयोजन है।

168
00:09:48,140 --> 00:09:51,270
या अधिक तकनीकी रूप से शायद मुझे यह कहना चाहिए कि यह मूल्यों के 

169
00:09:51,270 --> 00:09:54,400
उस छोटे ग्रिड के 180 डिग्री घुमाए गए संस्करण के साथ कनवल्शन है।

170
00:09:54,620 --> 00:09:56,827
ऐसा नहीं है कि ग्रिड सममित होने पर यह मायने रखता है, 

171
00:09:56,827 --> 00:09:59,284
लेकिन यह ध्यान में रखने योग्य है कि एक कनवल्शन की परिभाषा, 

172
00:09:59,284 --> 00:10:01,325
जैसा कि शुद्ध गणित संदर्भ से विरासत में मिली है, 

173
00:10:01,325 --> 00:10:04,781
आपको हमेशा उस दूसरे सरणी के चारों ओर फ़्लिप करने के बारे में सोचने के लिए आमंत्रित 

174
00:10:04,781 --> 00:10:05,240
करना चाहिए।

175
00:10:05,960 --> 00:10:08,552
यदि हम इसे थोड़ा संशोधित करते हैं तो हम मूल्यों का एक अलग 

176
00:10:08,552 --> 00:10:11,100
ग्रिड चुनकर अधिक सुंदर धुंधला प्रभाव प्राप्त कर सकते हैं।

177
00:10:11,440 --> 00:10:15,780
इस मामले में मेरे पास एक छोटा सा 5x5 ग्रिड है, लेकिन अंतर इसके आकार का नहीं है।

178
00:10:15,980 --> 00:10:20,441
यदि हम ज़ूम इन करते हैं तो हम देखते हैं कि बीच का मान किनारों के मान से बहुत बड़ा है, 

179
00:10:20,441 --> 00:10:23,813
और यह कहां से आ रहा है, वे सभी एक घंटी वक्र से नमूने लिए गए हैं, 

180
00:10:23,813 --> 00:10:25,940
जिसे गाऊसी वितरण के रूप में जाना जाता है।

181
00:10:26,800 --> 00:10:31,131
इस तरह जब हम इन सभी मानों को संबंधित पिक्सेल से गुणा करते हैं जिसके ऊपर वे बैठे हैं, 

182
00:10:31,131 --> 00:10:34,137
तो हम उस केंद्रीय पिक्सेल को बहुत अधिक महत्व दे रहे हैं और 

183
00:10:34,137 --> 00:10:36,380
किनारे पर मौजूद मानों को बहुत कम दे रहे हैं।

184
00:10:36,800 --> 00:10:40,560
और ठीक पहले की तरह दाईं ओर संबंधित पिक्सेल को इस योग के रूप में परिभाषित किया गया है।

185
00:10:41,320 --> 00:10:44,026
जैसा कि हम इस प्रक्रिया को हर एक पिक्सेल के लिए करते हैं, 

186
00:10:44,026 --> 00:10:48,226
यह एक धुंधला प्रभाव देता है जो आपके लेंस को फोकस से बाहर या ऐसा कुछ करने की धारणा को अधिक 

187
00:10:48,226 --> 00:10:49,720
प्रामाणिक रूप से अनुकरण करता है।

188
00:10:49,900 --> 00:10:53,360
लेकिन धुंधलापन एकमात्र ऐसी चीज़ नहीं है जो आप इस विचार के साथ कर सकते हैं।

189
00:10:53,800 --> 00:10:56,554
उदाहरण के लिए, मानों के इस छोटे ग्रिड पर एक नज़र डालें, 

190
00:10:56,554 --> 00:11:00,637
जिसमें बाईं ओर कुछ सकारात्मक संख्याएँ और दाईं ओर कुछ नकारात्मक संख्याएँ शामिल हैं, 

191
00:11:00,637 --> 00:11:02,900
जिन्हें मैं क्रमशः नीले और लाल रंग से रंगूँगा।

192
00:11:03,640 --> 00:11:05,954
यह देखने के लिए कुछ समय लें कि क्या आप अनुमान लगा सकते 

193
00:11:05,954 --> 00:11:08,480
हैं और समझ सकते हैं कि इसका अंतिम छवि पर क्या प्रभाव पड़ेगा।

194
00:11:10,720 --> 00:11:14,343
तो इस मामले में मैं छवि को रंगीन के बजाय ग्रेस्केल के रूप में सोचूंगा, 

195
00:11:14,343 --> 00:11:18,120
इसलिए प्रत्येक पिक्सेल को तीन के बजाय केवल एक संख्या द्वारा दर्शाया जाएगा।

196
00:11:18,440 --> 00:11:20,640
और ध्यान देने योग्य एक बात यह है कि जैसे ही हम यह 

197
00:11:20,640 --> 00:11:23,060
कनवल्शन करते हैं तो नकारात्मक मान प्राप्त करना संभव है।

198
00:11:23,060 --> 00:11:27,224
उदाहरण के लिए, यहां इस बिंदु पर यदि हम ज़ूम इन करते हैं तो हमारे छोटे ग्रिड का बायां आधा 

199
00:11:27,224 --> 00:11:30,780
हिस्सा पूरी तरह से काले पिक्सेल के शीर्ष पर बैठता है, जिसका मान शून्य होगा, 

200
00:11:30,780 --> 00:11:34,243
लेकिन नकारात्मक मानों का दायां आधा भाग सफेद पिक्सेल के शीर्ष पर बैठता है, 

201
00:11:34,243 --> 00:11:35,460
जो कि होगा एक का मूल्य है.

202
00:11:36,180 --> 00:11:39,661
इसलिए जब हम संगत शब्दों को गुणा करते हैं और उन्हें एक साथ जोड़ते हैं तो परिणाम 

203
00:11:39,661 --> 00:11:43,010
बहुत नकारात्मक होंगे, और जिस तरह से मैं इसे दाईं ओर की छवि के साथ प्रदर्शित 

204
00:11:43,010 --> 00:11:46,360
कर रहा हूं वह नकारात्मक मानों को लाल और सकारात्मक मानों को नीला रंग देना है।

205
00:11:46,880 --> 00:11:50,437
ध्यान देने वाली एक और बात यह है कि जब आप एक पैच पर होते हैं जो सभी समान रंग का होता 

206
00:11:50,437 --> 00:11:54,080
है तो सब कुछ शून्य हो जाता है क्योंकि हमारे छोटे ग्रिड में मानों का योग शून्य होता है।

207
00:11:55,180 --> 00:11:58,474
यह पिछले दो उदाहरणों से बहुत अलग है जहां हमारे छोटे ग्रिड का योग एक था, 

208
00:11:58,474 --> 00:12:02,180
जो हमें इसे चलती औसत के रूप में व्याख्या करने देता है और इसलिए धुंधला हो जाता है।

209
00:12:03,640 --> 00:12:07,116
कुल मिलाकर यह छोटी सी प्रक्रिया मूल रूप से पता लगाती है कि जब आप बाएं 

210
00:12:07,116 --> 00:12:09,996
से दाएं जाते हैं तो पिक्सेल मान में कहां भिन्नता होती है, 

211
00:12:09,996 --> 00:12:13,920
और इसलिए यह आपको अपनी छवि से सभी ऊर्ध्वाधर किनारों को लेने का एक तरीका देता है।

212
00:12:16,500 --> 00:12:20,798
और इसी तरह अगर हम उस ग्रिड को चारों ओर घुमाते हैं ताकि जब आप ऊपर से नीचे की 

213
00:12:20,798 --> 00:12:24,418
ओर बढ़ें तो यह अलग-अलग हो, यह सभी क्षैतिज किनारों को पकड़ लेगा, 

214
00:12:24,418 --> 00:12:29,340
जो कि हमारी छोटी पाई प्राणी छवि के मामले में कुछ सुंदर राक्षसी आँखों में परिणत होता है।

215
00:12:30,400 --> 00:12:32,438
वैसे, इस छोटे ग्रिड को अक्सर कर्नेल कहा जाता है, 

216
00:12:32,438 --> 00:12:36,015
और यहां की सुंदरता यह है कि कैसे एक अलग कर्नेल चुनकर आप अलग-अलग छवि प्रसंस्करण प्रभाव 

217
00:12:36,015 --> 00:12:39,384
प्राप्त कर सकते हैं, न केवल आपके किनारे का पता लगाने को धुंधला कर सकते हैं बल्कि 

218
00:12:39,384 --> 00:12:40,840
तेज करने जैसी चीजें भी कर सकते हैं।

219
00:12:40,840 --> 00:12:43,860
आपमें से जिन लोगों ने कनवल्शनल न्यूरल नेटवर्क के बारे में सुना है, 

220
00:12:43,860 --> 00:12:47,467
उनके लिए विचार यह है कि डेटा का उपयोग करके यह पता लगाया जाए कि सबसे पहले कर्नेल 

221
00:12:47,467 --> 00:12:51,480
क्या होना चाहिए, जैसा कि न्यूरल नेटवर्क जो भी पता लगाना चाहता है, उससे निर्धारित होता है।

222
00:12:52,760 --> 00:12:55,520
एक और चीज़ जो शायद मुझे सामने लानी चाहिए वह है आउटपुट की लंबाई।

223
00:12:55,820 --> 00:12:59,605
चलती औसत उदाहरण जैसी किसी चीज़ के लिए आप केवल उन शर्तों के बारे में सोचना 

224
00:12:59,605 --> 00:13:02,880
चाहेंगे जब दोनों विंडो पूरी तरह से एक-दूसरे के साथ संरेखित हों, 

225
00:13:02,880 --> 00:13:07,280
या छवि प्रसंस्करण उदाहरण में शायद आप चाहते हैं कि अंतिम आउटपुट का आकार मूल के समान हो।

226
00:13:07,280 --> 00:13:10,324
अब एक शुद्ध गणित ऑपरेशन के रूप में कनवल्शन हमेशा एक सरणी उत्पन्न 

227
00:13:10,324 --> 00:13:13,088
करता है जो आपके द्वारा शुरू की गई दो सरणी से बड़ी होती है, 

228
00:13:13,088 --> 00:13:16,180
कम से कम यह मानते हुए कि उनमें से एक की लंबाई एक के बराबर नहीं है।

229
00:13:16,720 --> 00:13:19,120
बस यह जान लें कि कुछ कंप्यूटर विज्ञान संदर्भों में 

230
00:13:19,120 --> 00:13:21,520
आप अक्सर जानबूझकर उस आउटपुट को छोटा करना चाहते हैं।

231
00:13:24,720 --> 00:13:29,176
हाइलाइट करने लायक एक और बात यह है कि कंप्यूटर विज्ञान के संदर्भ में मूल के पार जाने 

232
00:13:29,176 --> 00:13:33,367
से पहले उस कर्नेल के चारों ओर फ़्लिप करने की यह धारणा अक्सर वास्तव में अजीब और 

233
00:13:33,367 --> 00:13:37,824
अनावश्यक लगती है, लेकिन फिर से ध्यान दें कि यह शुद्ध गणित संदर्भ से विरासत में मिला 

234
00:13:37,824 --> 00:13:42,440
है जहां हम जैसे हैं संभावनाओं के साथ देखा जाए तो यह अविश्वसनीय रूप से स्वाभाविक बात है।

235
00:13:43,020 --> 00:13:45,954
और वास्तव में मैं आपको एक और शुद्ध गणित का उदाहरण दिखा सकता 

236
00:13:45,954 --> 00:13:48,987
हूं जहां प्रोग्रामर को भी इसकी परवाह करनी चाहिए क्योंकि यह इन 

237
00:13:48,987 --> 00:13:52,020
सभी की गणना करने के लिए बहुत तेज़ एल्गोरिदम के द्वार खोलता है।

238
00:13:52,620 --> 00:13:56,155
यहां तेजी से मेरा जो मतलब है उसे स्थापित करने के लिए मुझे वापस जाने दें और कुछ 

239
00:13:56,155 --> 00:13:59,780
अजगर को फिर से खींचने दें और मैं दो अलग-अलग अपेक्षाकृत बड़े ऐरे बनाने जा रहा हूं।

240
00:13:59,940 --> 00:14:03,417
प्रत्येक में एक लाख यादृच्छिक तत्व होंगे और मैं numpy 

241
00:14:03,417 --> 00:14:07,540
लाइब्रेरी से कन्वोल्व फ़ंक्शन के रनटाइम का आकलन करने जा रहा हूं।

242
00:14:08,180 --> 00:14:11,577
और इस मामले में यह इसे कई अलग-अलग पुनरावृत्तियों के लिए चलाता है, 

243
00:14:11,577 --> 00:14:16,056
एक औसत खोजने की कोशिश करता है, और ऐसा लगता है कि इस कंप्यूटर पर कम से कम इसका औसत 4 है।

244
00:14:16,056 --> 00:14:16,520
87 सेकंड.

245
00:14:16,960 --> 00:14:21,266
इसके विपरीत यदि मैं scipy लाइब्रेरी से एक अलग फ़ंक्शन का उपयोग करता हूं जिसे 

246
00:14:21,266 --> 00:14:25,741
fftconvolve कहा जाता है जो कि एक ही चीज़ है जिसे बस अलग तरीके से लागू किया जाता 

247
00:14:25,741 --> 00:14:30,160
है जिसमें केवल 4 लगते हैं।औसतन 3 मिलीसेकंड, इसलिए परिमाण में सुधार के तीन क्रम।

248
00:14:30,160 --> 00:14:32,995
और फिर भले ही यह एक अलग नाम के तहत उड़ान भरता है, 

249
00:14:32,995 --> 00:14:36,284
यह वही आउटपुट दे रहा है जो अन्य कन्वोल्व फ़ंक्शन देता है, 

250
00:14:36,284 --> 00:14:39,120
यह बस इसे चतुर तरीके से करने के लिए कुछ कर रहा है।

251
00:14:42,200 --> 00:14:45,551
याद रखें कि संभाव्यता उदाहरण के साथ मैंने कहा था कि कनवल्शन के 

252
00:14:45,551 --> 00:14:48,956
बारे में सोचने का एक और तरीका यह था कि सभी जोड़ीदार उत्पादों की 

253
00:14:48,956 --> 00:14:52,680
यह तालिका बनाएं और फिर विकर्णों के साथ उन जोड़ीदार उत्पादों को जोड़ें।

254
00:14:53,660 --> 00:14:55,655
निश्चित रूप से संभाव्यता के लिए कुछ भी विशिष्ट नहीं है, 

255
00:14:55,655 --> 00:14:58,327
जब भी आप संख्याओं की दो अलग-अलग सूचियाँ बना रहे हों तो आप इसके बारे में इस 

256
00:14:58,327 --> 00:14:59,040
तरह से सोच सकते हैं।

257
00:14:59,040 --> 00:15:02,668
सभी जोड़ीवार उत्पादों के साथ इस प्रकार की गुणन तालिका बनाएं और फिर 

258
00:15:02,668 --> 00:15:06,460
विकर्ण के साथ प्रत्येक योग आपके अंतिम आउटपुट में से एक से मेल खाता है।

259
00:15:07,600 --> 00:15:10,285
एक संदर्भ जहां यह दृश्य विशेष रूप से स्वाभाविक 

260
00:15:10,285 --> 00:15:12,800
है जब आप दो बहुपदों को एक साथ गुणा करते हैं।

261
00:15:13,300 --> 00:15:18,668
उदाहरण के लिए, मैं हमारे पास पहले से मौजूद छोटे ग्रिड को लेता हूं और शीर्ष पदों को 1, 

262
00:15:18,668 --> 00:15:23,600
2x और 3x वर्ग से बदल देता हूं और अन्य पदों को 4, 5x और 6x वर्ग से बदल देता हूं।

263
00:15:24,000 --> 00:15:26,350
अब सोचें कि जब हम दो सूचियों के बीच इन सभी अलग-अलग 

264
00:15:26,350 --> 00:15:28,840
जोड़ीवार उत्पादों को बना रहे हैं तो इसका क्या मतलब है।

265
00:15:29,040 --> 00:15:33,292
आप जो कर रहे हैं वह अनिवार्य रूप से मेरे द्वारा लिखे गए दो बहुपदों के पूर्ण 

266
00:15:33,292 --> 00:15:37,544
उत्पाद का विस्तार करना है और फिर जब आप विकर्ण के साथ जोड़ते हैं जो सभी समान 

267
00:15:37,544 --> 00:15:41,908
पदों को एकत्रित करने के अनुरूप होता है जो कि एक बहुपद का विस्तार करने और समान 

268
00:15:41,908 --> 00:15:46,440
पदों को एकत्रित करने के लिए बहुत साफ-सुथरा होता है। कनवल्शन के समान ही प्रक्रिया।

269
00:15:47,740 --> 00:15:50,106
लेकिन यह हमें कुछ ऐसा करने की अनुमति देता है जो बहुत 

270
00:15:50,106 --> 00:15:52,340
अच्छा है क्योंकि सोचें कि हम यहां क्या कह रहे हैं।

271
00:15:52,340 --> 00:15:56,449
हम कह रहे हैं कि यदि आप दो अलग-अलग फ़ंक्शन लेते हैं और आप उन्हें एक 

272
00:15:56,449 --> 00:15:59,532
साथ गुणा करते हैं जो कि एक सरल बिंदुवार ऑपरेशन है, 

273
00:15:59,532 --> 00:16:04,004
तो यह वही बात है जैसे कि आपने पहले उनमें से प्रत्येक से गुणांक निकाला था, 

274
00:16:04,004 --> 00:16:08,840
यह मानते हुए कि वे बहुपद हैं और फिर उनका कनवल्शन लिया है गुणांकों की दो सूचियाँ।

275
00:16:09,620 --> 00:16:13,580
जो चीज़ इसे इतना दिलचस्प बनाती है वह यह है कि सिद्धांत रूप में कनवल्शन सरल गुणन 

276
00:16:13,580 --> 00:16:17,690
की तुलना में बहुत अधिक जटिल लगता है और मेरा मतलब यह नहीं है कि वैचारिक रूप से उनके 

277
00:16:17,690 --> 00:16:21,700
बारे में सोचना कठिन है, मेरा मतलब है कि कम्प्यूटेशनल रूप से कनवल्शन को निष्पादित 

278
00:16:21,700 --> 00:16:25,760
करने के लिए अधिक चरणों की आवश्यकता होती है। दो अलग-अलग सूचियों का बिंदुवार उत्पाद।

279
00:16:26,319 --> 00:16:29,675
उदाहरण के लिए, मान लें कि मैंने आपको दो बहुत बड़े बहुपद दिए हैं, 

280
00:16:29,675 --> 00:16:32,566
मान लीजिए कि प्रत्येक एक सौ अलग-अलग गुणांकों के साथ है, 

281
00:16:32,566 --> 00:16:36,489
तो यदि आप जिस तरह से उन्हें गुणा करते हैं, वह इस उत्पाद का विस्तार करना है, 

282
00:16:36,489 --> 00:16:40,774
तो आप जानते हैं कि इस संपूर्ण 100 गुणा 100 ग्रिड को जोड़ीवार उत्पादों में भरना है, 

283
00:16:40,774 --> 00:16:44,646
जिसके लिए आपको इसकी आवश्यकता होगी। 10,000 अलग-अलग उत्पाद निष्पादित करें और 

284
00:16:44,646 --> 00:16:48,517
फिर जब आप विकर्णों के साथ सभी समान शब्द एकत्र कर रहे हों तो यह लगभग 10,000 

285
00:16:48,517 --> 00:16:49,860
परिचालनों का एक और सेट है।

286
00:16:50,700 --> 00:16:54,677
अधिक आम तौर पर भाषा में हम कहेंगे कि एल्गोरिथ्म n वर्ग का O है, 

287
00:16:54,677 --> 00:16:59,772
जिसका अर्थ n आकार की दो सूचियों के लिए है, जिस तरह से ऑपरेशन स्केल की संख्या n के 

288
00:16:59,772 --> 00:17:01,140
वर्ग के अनुपात में है।

289
00:17:01,820 --> 00:17:05,583
दूसरी ओर, यदि मैं दो बहुपदों के बारे में उनके आउटपुट के संदर्भ में सोचता हूं, 

290
00:17:05,583 --> 00:17:08,622
उदाहरण के लिए कुछ मुट्ठी भर इनपुट पर उनके मानों का नमूना लेना, 

291
00:17:08,622 --> 00:17:12,482
तो उन्हें गुणा करने के लिए केवल उतने ही ऑपरेशन की आवश्यकता होती है जितनी नमूनों 

292
00:17:12,482 --> 00:17:16,197
की संख्या, क्योंकि फिर से यह एक बिंदुवार ऑपरेशन है और बहुपद के साथ आपको केवल 

293
00:17:16,197 --> 00:17:20,540
इसकी आवश्यकता होती है गुणांकों को पुनर्प्राप्त करने में सक्षम होने के लिए बहुत सारे नमूने।

294
00:17:20,540 --> 00:17:22,996
उदाहरण के लिए दो आउटपुट एक रैखिक बहुपद को विशिष्ट 

295
00:17:22,996 --> 00:17:25,060
रूप से निर्दिष्ट करने के लिए पर्याप्त हैं।

296
00:17:25,660 --> 00:17:29,400
एक द्विघात बहुपद को विशिष्ट रूप से निर्दिष्ट करने के लिए तीन आउटपुट पर्याप्त होंगे।

297
00:17:29,640 --> 00:17:33,460
और सामान्य तौर पर यदि आप n भिन्न आउटपुट जानते हैं तो यह n भिन्न 

298
00:17:33,460 --> 00:17:37,640
गुणांक वाले बहुपद को विशिष्ट रूप से निर्दिष्ट करने के लिए पर्याप्त है।

299
00:17:37,780 --> 00:17:40,720
या यदि आप चाहें तो हम इसे समीकरण प्रणालियों की भाषा में व्यक्त कर सकते हैं।

300
00:17:41,200 --> 00:17:43,840
कल्पना कीजिए कि मैं आपको बताता हूं कि मेरे पास कुछ बहुपद हैं लेकिन 

301
00:17:43,840 --> 00:17:46,520
मैं आपको यह नहीं बताता कि गुणांक क्या हैं, वे आपके लिए एक रहस्य हैं।

302
00:17:46,700 --> 00:17:48,750
हमारे उदाहरण में आप इसे उस उत्पाद के रूप में सोच 

303
00:17:48,750 --> 00:17:50,800
सकते हैं जिसका हम पता लगाने का प्रयास कर रहे हैं।

304
00:17:50,800 --> 00:17:55,002
फिर मान लीजिए कि मैं कहता हूं कि मैं आपको सिर्फ यह बताऊंगा कि इस बहुपद के आउटपुट 

305
00:17:55,002 --> 00:17:58,894
क्या होंगे यदि आपने 0, 1, 2, 3, ऑन और ऑन जैसे विभिन्न इनपुट इनपुट किए हैं, 

306
00:17:58,894 --> 00:18:03,460
और मैं आपको पर्याप्त देता हूं ताकि आपके पास अधिक से अधिक समीकरण हों आपके पास अज्ञात हैं.

307
00:18:04,140 --> 00:18:07,340
यह समीकरणों की एक रैखिक प्रणाली भी होती है, इसलिए यह अच्छा है।

308
00:18:07,780 --> 00:18:10,900
और कम से कम सिद्धांत रूप में, यह गुणांकों को पुनर्प्राप्त करने के लिए पर्याप्त होना चाहिए।

309
00:18:11,740 --> 00:18:15,437
तो मोटे एल्गोरिथम की रूपरेखा यह होगी कि जब भी आप संख्याओं की दो सूचियों को जोड़ना 

310
00:18:15,437 --> 00:18:19,000
चाहते हैं तो आप उनके साथ ऐसे व्यवहार करते हैं जैसे वे दो बहुपदों के गुणांक हों।

311
00:18:19,420 --> 00:18:24,010
आप पर्याप्त आउटपुट पर उन बहुपदों का नमूना लेते हैं, उन नमूनों को बिंदुवार गुणा करते हैं, 

312
00:18:24,010 --> 00:18:27,620
और फिर कनवल्शन खोजने के लिए एक गुप्त पिछले दरवाजे के तरीके के रूप में 

313
00:18:27,620 --> 00:18:30,560
गुणांक को पुनर्प्राप्त करने के लिए सिस्टम को हल करते हैं।

314
00:18:31,420 --> 00:18:34,315
और जैसा कि मैंने कम से कम अब तक कहा है, आप में से कुछ लोग उचित रूप 

315
00:18:34,315 --> 00:18:37,340
से शिकायत कर सकते हैं &quot;अनुदान, यह एक मूर्खतापूर्ण योजना है&quot;।

316
00:18:37,580 --> 00:18:41,223
क्योंकि एक बात के लिए, हम जानते हैं कि बहुपदों में से किसी एक के लिए 

317
00:18:41,223 --> 00:18:45,183
इन सभी नमूनों की गणना करना पहले से ही एन वर्ग संचालन के क्रम पर आधारित है, 

318
00:18:45,183 --> 00:18:48,879
उस प्रणाली को हल करने का उल्लेख नहीं करना निश्चित रूप से कम्प्यूटेशनल 

319
00:18:48,879 --> 00:18:52,100
रूप से उतना ही कठिन होगा जितना कि पहले स्थान पर कनवल्शन करना।

320
00:18:52,600 --> 00:18:56,327
तो, जैसे, निश्चित रूप से हमारे पास गुणन और संकल्प के बीच यह संबंध है, 

321
00:18:56,327 --> 00:19:00,480
लेकिन सारी जटिलता एक दृष्टिकोण से दूसरे दृष्टिकोण में अनुवाद करने में होती है।

322
00:19:01,600 --> 00:19:04,624
लेकिन एक तरकीब है, और आपमें से जो लोग फूरियर ट्रांसफॉर्म और एफएफटी 

323
00:19:04,624 --> 00:19:07,740
एल्गोरिदम के बारे में जानते हैं वे देख सकते हैं कि यह कहां जा रहा है।

324
00:19:07,740 --> 00:19:09,937
यदि आप इन विषयों से अपरिचित हैं, तो मैं जो कहने 

325
00:19:09,937 --> 00:19:12,180
जा रहा हूं वह पूरी तरह से अप्रत्याशित लग सकता है।

326
00:19:12,260 --> 00:19:14,514
बस यह जान लें कि गणित में कुछ ऐसे रास्ते हैं जिन 

327
00:19:14,514 --> 00:19:16,860
पर आप चल सकते हैं जो इसे एक अपेक्षित कदम बनाते हैं।

328
00:19:17,720 --> 00:19:20,360
मूलतः विचार यह है कि यहां हमें चयन की स्वतंत्रता है।

329
00:19:20,540 --> 00:19:25,326
यदि 0, 1, 2, 3, ऑन और ऑन जैसे इनपुट के कुछ मनमाने सेट पर मूल्यांकन करने के बजाय, 

330
00:19:25,326 --> 00:19:29,700
आप जटिल संख्याओं के एक विशेष रूप से चयनित सेट पर मूल्यांकन करना चुनते हैं।

331
00:19:30,240 --> 00:19:32,785
विशेष रूप से वे जो इकाई वृत्त पर समान दूरी पर स्थित हैं, 

332
00:19:32,785 --> 00:19:34,840
जिन्हें एकता की जड़ों के रूप में जाना जाता है।

333
00:19:35,200 --> 00:19:36,880
यह हमें एक मित्रतापूर्ण प्रणाली प्रदान करता है।

334
00:19:38,360 --> 00:19:42,773
मूल विचार यह है कि एक संख्या ढूँढ़ने से जहाँ उसकी शक्तियाँ इस चक्रण पैटर्न में आती हैं, 

335
00:19:42,773 --> 00:19:46,786
इसका मतलब है कि हम जो प्रणाली उत्पन्न करते हैं उसमें उन विभिन्न शब्दों में बहुत 

336
00:19:46,786 --> 00:19:49,344
अधिक अतिरेक होने वाला है जिनकी आप गणना कर रहे हैं, 

337
00:19:49,344 --> 00:19:52,704
और इस बारे में चतुर होने से कि कैसे आप उस अतिरेक का लाभ उठाते हैं, 

338
00:19:52,704 --> 00:19:54,460
आप अपना बहुत सारा काम बचा सकते हैं।

339
00:19:56,020 --> 00:19:59,386
मेरे द्वारा लिखे गए आउटपुट के इस सेट का एक विशेष नाम है, 

340
00:19:59,386 --> 00:20:02,280
इसे गुणांकों का असतत फूरियर रूपांतरण कहा जाता है।

341
00:20:02,500 --> 00:20:05,820
और यदि आप और अधिक जानना चाहते हैं तो मैंने वास्तव में उसी जूलिया एमआईटी 

342
00:20:05,820 --> 00:20:09,140
कक्षा के लिए असतत फूरियर परिवर्तनों के बारे में एक और व्याख्यान दिया था।

343
00:20:09,220 --> 00:20:13,170
और चैनल रिड्यूसिबल पर तेज़ फूरियर ट्रांसफॉर्म के बारे में बात करने वाला एक बहुत ही 

344
00:20:13,170 --> 00:20:17,120
उत्कृष्ट वीडियो भी है, जो इन्हें और अधिक तेज़ी से गणना करने के लिए एक एल्गोरिदम है।

345
00:20:17,480 --> 00:20:20,396
इसके अलावा वेरिटासियम ने हाल ही में एफएफटी पर एक बहुत अच्छा वीडियो बनाया है, 

346
00:20:20,396 --> 00:20:21,760
इसलिए आपके पास बहुत सारे विकल्प हैं।

347
00:20:22,260 --> 00:20:24,660
और वह तेज़ एल्गोरिदम वास्तव में हमारे लिए महत्वपूर्ण है।

348
00:20:25,120 --> 00:20:29,273
फिर से इस सभी अतिरेक के कारण गुणांक से इन सभी आउटपुट तक जाने की एक विधि मौजूद है, 

349
00:20:29,273 --> 00:20:31,805
जहां एन स्क्वैयर ऑपरेशंस के क्रम पर करने के बजाय, 

350
00:20:31,805 --> 00:20:34,489
आप एन ऑपरेशंस के लॉग के एन गुना के क्रम पर करते हैं, 

351
00:20:34,489 --> 00:20:37,883
जो कि बहुत अधिक है जैसे-जैसे आप बड़ी सूचियों में आगे बढ़ते जाएंगे, 

352
00:20:37,883 --> 00:20:39,200
यह और भी बेहतर होता जाएगा।

353
00:20:39,660 --> 00:20:42,540
और महत्वपूर्ण बात यह है कि यह एफएफटी एल्गोरिदम दोनों तरीकों से चलता है।

354
00:20:42,700 --> 00:20:45,480
यह आपको आउटपुट से गुणांक तक जाने की सुविधा भी देता है।

355
00:20:46,220 --> 00:20:49,060
तो इन सबको एक साथ लाते हुए, आइए अपनी एल्गोरिदम रूपरेखा पर एक नज़र डालें।

356
00:20:49,420 --> 00:20:53,524
अब हम कह सकते हैं कि जब भी आपको संख्याओं की दो लंबी सूचियाँ दी जाती हैं और आप उनका 

357
00:20:53,524 --> 00:20:57,875
कनवल्शन लेना चाहते हैं, तो पहले उनमें से प्रत्येक के तेज़ फूरियर रूपांतरण की गणना करें, 

358
00:20:57,875 --> 00:21:01,979
जिसे आप अपने दिमाग के पीछे बस उनके साथ व्यवहार करने के बारे में सोच सकते हैं वे एक 

359
00:21:01,979 --> 00:21:06,380
बहुपद के गुणांक हैं और इसका मूल्यांकन बहुत विशेष रूप से चयनित बिंदुओं के सेट पर करते हैं।

360
00:21:06,899 --> 00:21:10,306
फिर उन दो परिणामों को एक साथ गुणा करें जो आपको अभी-अभी मिले हैं, 

361
00:21:10,306 --> 00:21:13,764
जो कि अच्छा और तेज़ है, और फिर एक उलटा तेज़ फूरियर रूपांतरण करें, 

362
00:21:13,764 --> 00:21:17,694
और जो आपको कनवल्शन की गणना करने के लिए एक गुप्त पिछले दरवाजे का तरीका देता 

363
00:21:17,694 --> 00:21:18,900
है जिसे हम ढूंढ रहे थे।

364
00:21:19,040 --> 00:21:22,240
लेकिन इस बार इसमें केवल n लॉग n ऑपरेशनों में से O शामिल है।

365
00:21:23,139 --> 00:21:24,740
यह मेरे लिए सचमुच बहुत अच्छा है!

366
00:21:25,120 --> 00:21:29,582
यह बहुत ही विशिष्ट संदर्भ जहां दो बहुपदों को गुणा करते हुए कनवल्शन दिखाई देता है, 

367
00:21:29,582 --> 00:21:34,100
एक एल्गोरिदम के लिए दरवाजे खोलता है जो हर जगह प्रासंगिक है जहां कनवल्शन आ सकते हैं।

368
00:21:34,180 --> 00:21:38,056
यदि आप संभाव्यता वितरण जोड़ना चाहते हैं, तो कुछ बड़ी छवि प्रसंस्करण करें, 

369
00:21:38,056 --> 00:21:39,000
चाहे वह कुछ भी हो।

370
00:21:39,220 --> 00:21:43,400
और मुझे लगता है कि यह इस बात का एक अच्छा उदाहरण है कि जब आप गणित में कुछ ऑपरेशन या 

371
00:21:43,400 --> 00:21:47,480
अवधारणा को कई असंबंधित क्षेत्रों में देखते हैं तो आपको उत्साहित क्यों होना चाहिए।

372
00:21:48,480 --> 00:21:51,500
यदि आप थोड़ा होमवर्क चाहते हैं तो यहां कुछ ऐसा है जिसके बारे में सोचना मजेदार है।

373
00:21:51,720 --> 00:21:54,561
समझाएं कि जब आप दो अलग-अलग संख्याओं को गुणा करते हैं, 

374
00:21:54,561 --> 00:21:58,244
तो बस सामान्य गुणन जिस तरह से हम सभी प्राथमिक विद्यालय में सीखते हैं, 

375
00:21:58,244 --> 00:22:01,980
आप जो कर रहे हैं वह मूल रूप से उन संख्याओं के अंकों के बीच एक संलयन है।

376
00:22:02,500 --> 00:22:06,460
कैरी वगैरह के साथ कुछ अतिरिक्त चरण हैं, लेकिन मुख्य चरण एक कनवल्शन है।

377
00:22:07,280 --> 00:22:10,795
एक तेज़ एल्गोरिदम के अस्तित्व के आलोक में, इसका मतलब यह है कि यदि 

378
00:22:10,795 --> 00:22:14,311
आपके पास दो बहुत बड़े पूर्णांक हैं, तो उनके उत्पाद को खोजने का एक 

379
00:22:14,311 --> 00:22:17,880
तरीका मौजूद है जो प्राथमिक विद्यालय में सीखी गई विधि से भी तेज़ है।

380
00:22:18,140 --> 00:22:22,445
इसके लिए n वर्ग संचालन के O की आवश्यकता के बजाय केवल n log n के O की आवश्यकता होती है, 

381
00:22:22,445 --> 00:22:24,920
जिससे यह भी महसूस नहीं होता कि यह संभव होना चाहिए।

382
00:22:25,380 --> 00:22:28,878
समस्या यह है कि इससे पहले कि यह वास्तव में व्यवहार में उपयोगी हो, 

383
00:22:28,878 --> 00:22:30,840
आपकी संख्या बिल्कुल भयानक होनी चाहिए।

384
00:22:31,220 --> 00:22:35,340
लेकिन फिर भी, यह अच्छा है कि ऐसा एल्गोरिदम मौजूद है।

385
00:22:35,340 --> 00:22:37,466
आगे हम संभाव्यता वितरण पर विशेष ध्यान देने के 

386
00:22:37,466 --> 00:22:39,640
साथ निरंतर मामले पर अपना ध्यान केंद्रित करेंगे।

