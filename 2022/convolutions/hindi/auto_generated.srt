1
00:00:00,000 --> 00:00:02,766
मान लीजिए कि मैं आपको संख्याओं की दो अलग-अलग सूचियाँ देता हूँ, या शायद दो

2
00:00:02,766 --> 00:00:05,644
अलग-अलग फ़ंक्शन देता हूँ, और मैं आपसे उन सभी तरीकों के बारे में सोचने के लिए

3
00:00:05,644 --> 00:00:08,560
कहता हूँ जिनसे आप संख्याओं की एक नई सूची प्राप्त करने के लिए उन दो सूचियों को

4
00:00:08,560 --> 00:00:11,737
जोड़ सकते हैं, या एक नया फ़ंक्शन प्राप्त करने के लिए दो फ़ंक्शनों को जोड़ सकते हैं। .

5
00:00:11,737 --> 00:00:14,100
शायद एक आसान तरीका जो दिमाग में आता है वह यह है

6
00:00:14,100 --> 00:00:16,267
कि उन्हें शब्द दर शब्द एक साथ जोड़ दिया जाए।

7
00:00:16,267 --> 00:00:20,050
इसी प्रकार फ़ंक्शंस के साथ, आप सभी संबंधित आउटपुट जोड़ सकते हैं।

8
00:00:20,050 --> 00:00:23,037
इसी तरह, आप दोनों सूचियों को पद दर पद गुणा भी कर

9
00:00:23,037 --> 00:00:26,145
सकते हैं और फ़ंक्शंस के साथ भी यही काम कर सकते हैं।

10
00:00:26,145 --> 00:00:30,023
लेकिन इन दोनों की तरह एक और प्रकार का संयोजन भी मौलिक है, लेकिन

11
00:00:30,023 --> 00:00:33,840
बहुत कम चर्चा की जाती है, जिसे कनवल्शन के रूप में जाना जाता है।

12
00:00:33,840 --> 00:00:36,890
लेकिन पिछले दो मामलों के विपरीत, यह ऐसा कुछ नहीं है जो केवल एक

13
00:00:36,890 --> 00:00:39,893
ऑपरेशन से विरासत में मिला है जिसे आप संख्याओं में कर सकते हैं।

14
00:00:39,893 --> 00:00:44,716
संख्याओं की सूची या संयोजन कार्यों के संदर्भ में यह वास्तव में कुछ नया है।

15
00:00:44,716 --> 00:00:48,384
वे हर जगह दिखाई देते हैं, वे छवि प्रसंस्करण में सर्वव्यापी हैं, यह

16
00:00:48,384 --> 00:00:52,326
संभाव्यता के सिद्धांत में एक मुख्य निर्माण है, अंतर समीकरणों को हल करने

17
00:00:52,326 --> 00:00:55,940
में उनका बहुत उपयोग किया जाता है, और एक संदर्भ जहां आपने इसे लगभग

18
00:00:55,940 --> 00:01:00,210
निश्चित रूप से देखा है, यदि नहीं इस नाम से, दो बहुपदों को एक साथ गुणा करना है।

19
00:01:00,210 --> 00:01:04,654
दृश्य स्पष्टीकरण के व्यवसाय में किसी के रूप में, यह एक विशेष रूप से महान विषय है,

20
00:01:04,654 --> 00:01:09,152
क्योंकि अलगाव में और संदर्भ के बिना सूत्रबद्ध परिभाषा डराने वाली लग सकती है, लेकिन

21
00:01:09,152 --> 00:01:13,922
अगर हम वास्तव में यह क्या कह रहे हैं उसे खोलने के लिए समय लेते हैं, और उससे पहले वास्तव

22
00:01:13,922 --> 00:01:18,800
में प्रेरित करते हैं कि क्यों आप ऐसा कुछ चाहेंगे, यह एक अविश्वसनीय रूप से सुंदर ऑपरेशन है।

23
00:01:18,800 --> 00:01:21,073
और मुझे यह स्वीकार करना होगा कि इस परियोजना के लिए

24
00:01:21,073 --> 00:01:23,436
दृश्यों को एक साथ रखते समय मैंने वास्तव में कुछ सीखा।

25
00:01:23,436 --> 00:01:27,145
दो अलग-अलग कार्यों को संयोजित करने के मामले में, मैं अलग-अलग तरीकों के बारे में सोचने

26
00:01:27,145 --> 00:01:30,854
की कोशिश कर रहा था जिनसे आप कल्पना कर सकते हैं कि इसका क्या मतलब हो सकता है, और उनमें

27
00:01:30,854 --> 00:01:34,693
से एक के साथ मेरे मन में थोड़ा अहा पल आया कि ऐसा क्यों है कि सामान्य वितरण भूमिका निभाते

28
00:01:34,693 --> 00:01:38,445
हैं वे संभाव्यता में ऐसा करते हैं, किसी फ़ंक्शन के लिए यह इतना स्वाभाविक आकार क्यों है।

29
00:01:38,445 --> 00:01:41,580
लेकिन मैं खुद से आगे निकल रहा हूं, इसके लिए बहुत सारी व्यवस्थाएं मौजूद हैं।

30
00:01:41,580 --> 00:01:45,888
इस वीडियो में, हमारा प्राथमिक ध्यान केवल अलग-अलग मामले पर होगा, और विशेष रूप से इनकी

31
00:01:45,888 --> 00:01:50,196
गणना के लिए एक बहुत ही अप्रत्याशित लेकिन बहुत ही चतुर एल्गोरिदम का निर्माण करना होगा।

32
00:01:50,196 --> 00:01:57,840
और मैं सतत मामले की चर्चा को दूसरे भाग में ले जाऊंगा।

33
00:01:57,840 --> 00:02:01,730
छवि प्रसंस्करण उदाहरणों के साथ शुरुआत करना बहुत आकर्षक है, क्योंकि वे दृष्टिगत

34
00:02:01,730 --> 00:02:05,769
रूप से सबसे दिलचस्प हैं, लेकिन कुछ बारीकियाँ हैं जो छवि प्रसंस्करण मामले को समग्र

35
00:02:05,769 --> 00:02:09,808
रूप से संकल्पों का कम प्रतिनिधि बनाती हैं, इसलिए इसके बजाय संभावनाओं के साथ चीजों

36
00:02:09,808 --> 00:02:13,699
को शुरू करें, और विशेष रूप से सबसे सरल उदाहरणों में से एक, जिसके बारे में मुझे

37
00:02:13,699 --> 00:02:17,639
यकीन है कि यहां हर किसी ने अपने जीवन में कभी न कभी सोचा होगा, जो कि पासों की एक

38
00:02:17,639 --> 00:02:21,530
जोड़ी को घुमाना और विभिन्न अलग-अलग योगों को देखने की संभावनाओं का पता लगाना है।

39
00:02:21,530 --> 00:02:24,170
और आप कह सकते हैं, कोई समस्या नहीं, कोई समस्या नहीं।

40
00:02:24,170 --> 00:02:28,118
आपके दोनों पासों में से प्रत्येक के छह अलग-अलग संभावित परिणाम हैं, जो

41
00:02:28,118 --> 00:02:32,009
हमें परिणामों के कुल 36 अलग-अलग संभावित जोड़े देते हैं, और यदि हम उन

42
00:02:32,009 --> 00:02:36,240
सभी को देखते हैं तो हम गिन सकते हैं कि कितने जोड़ों में एक दिया गया योग है।

43
00:02:36,240 --> 00:02:40,919
और सभी जोड़ियों को इस तरह एक ग्रिड में व्यवस्थित करने पर, एक बहुत अच्छी बात यह है कि जिन

44
00:02:40,919 --> 00:02:45,650
सभी जोड़ियों का योग स्थिर होता है, वे इन विभिन्न विकर्णों में से एक के साथ दिखाई देते हैं।

45
00:02:45,650 --> 00:02:49,292
तो बस यह गिनने से कि उनमें से प्रत्येक विकर्ण पर कितने मौजूद हैं,

46
00:02:49,292 --> 00:02:52,880
आपको पता चल जाएगा कि आपको एक विशेष योग देखने की कितनी संभावना है।

47
00:02:52,880 --> 00:02:55,657
और मैं कहूंगा, बहुत अच्छा, बहुत अच्छा, लेकिन क्या आप किसी अन्य

48
00:02:55,657 --> 00:02:58,699
तरीके के बारे में सोच सकते हैं जिससे आप उसी प्रश्न की कल्पना कर सकें?

49
00:02:58,699 --> 00:03:01,060
अन्य छवियां जो उन सभी विशिष्ट जोड़ियों के बारे में

50
00:03:01,060 --> 00:03:03,744
सोचने के लिए दिमाग में आ सकती हैं जिनका एक निश्चित योग है?

51
00:03:03,744 --> 00:03:07,550
और हो सकता है कि आप में से कोई अपना हाथ उठाए और कहे, हाँ, मेरे पास एक है।

52
00:03:07,550 --> 00:03:10,848
मान लीजिए कि आप एक पंक्ति में संभावनाओं के इन दो अलग-अलग सेटों की

53
00:03:10,848 --> 00:03:14,046
कल्पना करते हैं, लेकिन आप उस दूसरी पंक्ति के चारों ओर घूमते हैं।

54
00:03:14,046 --> 00:03:18,960
इस तरह सभी अलग-अलग जोड़े जो सात तक जुड़ते हैं, इस तरह लंबवत पंक्ति में आते हैं।

55
00:03:18,960 --> 00:03:22,526
और यदि हम उस निचली पंक्ति को पूरी तरह से दाहिनी ओर सरकाते हैं, तो

56
00:03:22,526 --> 00:03:26,309
अद्वितीय जोड़ी जो दो को जोड़ती है, साँप की आँखें, ही संरेखित होती हैं।

57
00:03:26,309 --> 00:03:29,704
और यदि मैं इसे दाहिनी ओर एक इकाई पर झुकाऊं, तो जो जोड़े संरेखित

58
00:03:29,704 --> 00:03:32,886
होते हैं वे दो अलग-अलग जोड़े होते हैं जिनका योग तीन होता है।

59
00:03:32,886 --> 00:03:37,277
और सामान्य तौर पर, इस निचले सरणी के अलग-अलग ऑफसेट मान, जो याद रखें कि मुझे पहले

60
00:03:37,277 --> 00:03:41,778
पलटना था, उन सभी अलग-अलग जोड़ियों को प्रकट करता है जिनमें एक दिया गया योग होता है।

61
00:03:41,778 --> 00:03:47,413
जहां तक संभाव्यता प्रश्नों का सवाल है, यह अभी भी विशेष रूप से दिलचस्प नहीं है,

62
00:03:47,413 --> 00:03:53,120
क्योंकि हम केवल यह गिन रहे हैं कि इनमें से प्रत्येक श्रेणी में कितने परिणाम हैं।

63
00:03:53,120 --> 00:03:55,436
लेकिन यह इस अंतर्निहित धारणा के साथ है कि इनमें

64
00:03:55,436 --> 00:03:57,850
से प्रत्येक चेहरे के सामने आने की समान संभावना है।

65
00:03:57,850 --> 00:04:01,897
लेकिन क्या होगा अगर मैं आपसे कहूं कि मेरे पास पासों का एक विशेष सेट है जो एक समान नहीं है?

66
00:04:01,897 --> 00:04:05,723
हो सकता है कि नीले पासे में संख्याओं का अपना सेट हो जो प्रत्येक चेहरे के आने की

67
00:04:05,723 --> 00:04:09,740
संभावनाओं का वर्णन करता हो, और लाल पासे में संख्याओं का अपना विशिष्ट विशिष्ट सेट हो।

68
00:04:09,740 --> 00:04:14,658
उस स्थिति में, यदि आप दो देखने की संभावना का पता लगाना चाहते हैं, तो आप नीले

69
00:04:14,658 --> 00:04:19,895
पासे के एक होने की प्रायिकता को लाल पासे के एक होने की प्रायिकता से गुणा कर देंगे।

70
00:04:19,895 --> 00:04:24,908
और तीन देखने की संभावना के लिए, आप दो अलग-अलग जोड़ियों को देखें जहां यह संभव है,

71
00:04:24,908 --> 00:04:29,983
और फिर से, संबंधित संभावनाओं को गुणा करें, और फिर उन दो उत्पादों को एक साथ जोड़ें।

72
00:04:29,983 --> 00:04:33,392
इसी प्रकार, चार को देखने की संभावना में संभावनाओं के तीन अलग-अलग

73
00:04:33,392 --> 00:04:36,748
युग्मों को एक साथ गुणा करना और उन सभी को एक साथ जोड़ना शामिल है।

74
00:04:36,748 --> 00:04:41,264
और कुछ सूत्र स्थापित करने की भावना से, आइए इन शीर्ष संभावनाओं को a1, a2,

75
00:04:41,264 --> 00:04:45,903
a3, इत्यादि नाम दें, और नीचे वाली संभावनाओं को b1, b2, b3, इत्यादि नाम दें।

76
00:04:45,903 --> 00:04:49,650
और सामान्य तौर पर, यह प्रक्रिया, जहां हम संख्याओं के दो अलग-अलग सरणी ले रहे

77
00:04:49,650 --> 00:04:53,299
हैं, दूसरे को चारों ओर घुमा रहे हैं, और फिर उन्हें विभिन्न ऑफसेट मानों पर

78
00:04:53,299 --> 00:04:57,145
पंक्तिबद्ध कर रहे हैं, जोड़ीदार उत्पादों का एक समूह ले रहे हैं और उन्हें जोड़

79
00:04:57,145 --> 00:05:01,139
रहे हैं, यह इनमें से एक है कनवल्शन क्या है इसके बारे में सोचने के बुनियादी तरीके।

80
00:05:01,139 --> 00:05:06,298
तो बस इसे थोड़ा और सटीक रूप से बताने के लिए, इस प्रक्रिया के माध्यम से, हमने

81
00:05:06,298 --> 00:05:11,658
दो, तीन, चार, आगे और फिर 12 तक देखने की संभावनाएं उत्पन्न कीं, और हमने मानों की

82
00:05:11,658 --> 00:05:17,084
एक सूची, ए, और एक अन्य को एक साथ मिलाकर उन्हें प्राप्त किया। मूल्यों की सूची, बी.

83
00:05:17,084 --> 00:05:22,041
भाषा में, हम कहेंगे कि उन दो अनुक्रमों का कनवल्शन हमें यह नया अनुक्रम देता है, 11

84
00:05:22,041 --> 00:05:27,120
मानों का नया अनुक्रम, जिनमें से प्रत्येक जोड़ीदार उत्पादों के कुछ योग जैसा दिखता है।

85
00:05:27,120 --> 00:05:31,942
यदि आप चाहें, तो उसी ऑपरेशन के बारे में दूसरा तरीका यह सोच सकते हैं कि पहले

86
00:05:31,942 --> 00:05:36,702
सभी जोड़ीवार उत्पादों की एक तालिका बनाएं, और फिर इन सभी विकर्णों को जोड़ें।

87
00:05:36,702 --> 00:05:39,319
फिर, यह संख्याओं के इन दो अनुक्रमों को एक साथ मिलाने का एक

88
00:05:39,319 --> 00:05:42,247
तरीका है जिससे हमें 11 संख्याओं का एक नया अनुक्रम प्राप्त होता है।

89
00:05:42,247 --> 00:05:46,960
यह वही ऑपरेशन है जैसा कि स्लाइडिंग विंडोज़ ने सोचा था, बस एक और परिप्रेक्ष्य।

90
00:05:46,960 --> 00:05:50,314
इसमें थोड़ा सा नोटेशन डालते हुए, यहां बताया गया है कि आप इसे कैसे लिखा हुआ देख सकते हैं।

91
00:05:50,314 --> 00:05:55,122
ए और बी का कनवल्शन, इस छोटे तारांकन के साथ दर्शाया गया है, एक नई सूची है, और

92
00:05:55,122 --> 00:05:59,681
उस सूची का एनवां तत्व एक योग की तरह दिखता है, और वह योग सूचकांकों के सभी

93
00:05:59,681 --> 00:06:04,738
अलग-अलग जोड़े, आई और जे पर जाता है, ताकि योग का योग हो वे सूचकांक n के बराबर हैं।

94
00:06:04,738 --> 00:06:10,634
यह एक प्रकार का कौर है, लेकिन उदाहरण के लिए, यदि n 6 था, तो जिन जोड़ियों पर हम जा रहे हैं

95
00:06:10,634 --> 00:06:16,400
वे 1 और 5, 2 और 4, 3 और 3, 4 और 2, 5 और 1 हैं, सभी अलग-अलग जोड़े हैं जो जुड़ते हैं से 6.

96
00:06:16,400 --> 00:06:19,763
लेकिन ईमानदारी से कहूं तो, आप इसे किसी भी तरह से लिखें, प्रक्रिया के दौरान

97
00:06:19,763 --> 00:06:23,082
आपके दिमाग में जो दृश्य रहता है, उसके मुकाबले नोटेशन का महत्व गौण होता है।

98
00:06:23,082 --> 00:06:27,053
यहां, शायद यह एक अत्यंत सरल उदाहरण देने में मदद करेगा, जहां मैं आपसे

99
00:06:27,053 --> 00:06:30,967
पूछ सकता हूं कि सूची 4, 5, 6 के साथ सूची 1, 2, 3 का कनवल्शन क्या है।

100
00:06:30,967 --> 00:06:34,491
आप इन दोनों सूचियों को लेते हुए, दूसरी सूची के चारों ओर पलटते हुए,

101
00:06:34,491 --> 00:06:37,857
और फिर इसके ढक्कन से शुरू करके बाईं ओर तक की कल्पना कर सकते हैं।

102
00:06:37,857 --> 00:06:40,859
फिर मानों की जोड़ी जो संरेखित होती है वह 1 और 4 है, उन्हें एक

103
00:06:40,859 --> 00:06:43,813
साथ गुणा करें, और इससे हमें हमारे आउटपुट का पहला पद मिलता है।

104
00:06:43,813 --> 00:06:47,240
उस निचली सरणी को एक इकाई दाईं ओर स्लाइड करें, जो जोड़े संरेखित हैं

105
00:06:47,240 --> 00:06:50,616
वे 1 और 5, और 2 और 4 हैं, उन जोड़ियों को गुणा करें, उन्हें एक साथ

106
00:06:50,616 --> 00:06:54,300
जोड़ें, और इससे हमें 13 मिलता है, जो हमारे आउटपुट में अगली प्रविष्टि है।

107
00:06:54,300 --> 00:06:58,137
चीज़ों को एक बार फिर सरकाएँ, और हम 1 गुना 6, प्लस

108
00:06:58,137 --> 00:07:01,591
2 गुना 5, प्लस 3 गुना 4, जो होता है 28 लेंगे।

109
00:07:01,591 --> 00:07:05,893
एक और स्लाइड, और हमें 2 गुना 6, प्लस 3 गुना 5 मिलता है, और

110
00:07:05,893 --> 00:07:10,560
इससे हमें 27 मिलता है, और अंत में अंतिम पद 3 गुना 6 जैसा दिखेगा।

111
00:07:10,560 --> 00:07:13,309
यदि आप चाहें, तो आप जो भी आपकी पसंदीदा प्रोग्रामिंग भाषा है, और आपकी

112
00:07:13,309 --> 00:07:16,097
पसंदीदा लाइब्रेरी जिसमें विभिन्न संख्यात्मक ऑपरेशन शामिल हैं, को खींच

113
00:07:16,097 --> 00:07:18,807
सकते हैं, और आप पुष्टि कर सकते हैं कि मैं आपसे झूठ नहीं बोल रहा हूं।

114
00:07:18,807 --> 00:07:22,107
यदि आप 4, 5, 6 के विरुद्ध 1, 2, 3 का कनवल्शन लेते

115
00:07:22,107 --> 00:07:24,880
हैं, तो आपको वास्तव में यही परिणाम मिलेगा।

116
00:07:24,880 --> 00:07:28,738
हमने एक मामला देखा है जहां यह एक प्राकृतिक और वांछनीय ऑपरेशन है, जो

117
00:07:28,738 --> 00:07:32,881
संभाव्यता वितरण को जोड़ता है, और एक अन्य सामान्य उदाहरण एक चलती औसत होगी।

118
00:07:32,881 --> 00:07:35,759
कल्पना करें कि आपके पास संख्याओं की कुछ लंबी सूची है, और

119
00:07:35,759 --> 00:07:38,788
आप संख्याओं की एक और छोटी सूची लेते हैं जिनका योग 1 होता है।

120
00:07:38,788 --> 00:07:43,381
इस मामले में, मेरे पास केवल 5 मानों की एक छोटी सी सूची है, और वे सभी 1/5वें के बराबर हैं।

121
00:07:43,381 --> 00:07:47,160
फिर यदि हम यह स्लाइडिंग विंडो कनवल्शन प्रक्रिया करते हैं, और अपनी आंखें

122
00:07:47,160 --> 00:07:50,940
बंद कर लेते हैं और गलीचे के नीचे देखते हैं कि इसकी शुरुआत में क्या होता

123
00:07:50,940 --> 00:07:54,876
है, एक बार जब मूल्यों की हमारी छोटी सूची पूरी तरह से बड़े के साथ ओवरलैप हो

124
00:07:54,876 --> 00:07:59,023
जाती है, तो सोचें कि इसमें प्रत्येक शब्द क्या है कनवल्शन का वास्तव में मतलब है।

125
00:07:59,023 --> 00:08:02,977
प्रत्येक पुनरावृत्ति पर, आप जो कर रहे हैं वह आपके डेटा के प्रत्येक

126
00:08:02,977 --> 00:08:06,991
मान को 1/5वें से गुणा करना है, और उन सभी को एक साथ जोड़ना है, जिसका

127
00:08:06,991 --> 00:08:10,769
अर्थ है कि आप इस छोटी विंडो के अंदर अपने डेटा का औसत ले रहे हैं।

128
00:08:10,769 --> 00:08:14,753
कुल मिलाकर, यह प्रक्रिया आपको मूल डेटा का एक सुव्यवस्थित संस्करण प्रदान करती है, और

129
00:08:14,753 --> 00:08:18,642
आप इसे संख्याओं की एक अलग छोटी सूची से शुरू करके संशोधित कर सकते हैं, और जब तक वह

130
00:08:18,642 --> 00:08:22,816
छोटी सूची 1 तक जुड़ जाती है, तब भी आप इसे एक गतिशील के रूप में व्याख्या कर सकते हैं औसत।

131
00:08:22,816 --> 00:08:27,781
यहां दिखाए गए उदाहरण में, वह चलती औसत केंद्रीय मूल्य की ओर अधिक भार देगी।

132
00:08:27,781 --> 00:08:33,200
इसके परिणामस्वरूप डेटा का एक सुचारु संस्करण भी प्राप्त होता है।

133
00:08:33,200 --> 00:08:35,942
यदि आप इसका द्वि-आयामी एनालॉग बनाते हैं, तो यह आपको किसी दी

134
00:08:35,942 --> 00:08:38,594
गई छवि को धुंधला करने के लिए एक मज़ेदार एल्गोरिदम देता है।

135
00:08:38,594 --> 00:08:42,552
और मुझे यह कहना चाहिए कि जो एनिमेशन मैं दिखाने जा रहा हूं, वे मूल रूप से मेरे द्वारा

136
00:08:42,552 --> 00:08:46,649
एमआईटी में जूलिया लैब के साथ एक निश्चित ओपनकोर्सवेयर क्लास के लिए किए गए व्याख्यानों के

137
00:08:46,649 --> 00:08:50,747
एक सेट के हिस्से के लिए बनाए गए कुछ से संशोधित हैं, जिसमें एक छवि प्रसंस्करण इकाई शामिल

138
00:08:50,747 --> 00:08:50,887
थी।

139
00:08:50,887 --> 00:08:53,537
वहां हमने इस सब के पीछे के कोड को समझने के लिए थोड़ा और काम

140
00:08:53,537 --> 00:08:56,452
किया, इसलिए यदि आप उत्सुक हैं तो मैं आपके लिए कुछ लिंक छोड़ दूंगा।

141
00:08:56,452 --> 00:09:00,727
लेकिन इस धुंधले उदाहरण पर ध्यान केंद्रित करते हुए, जो हो रहा है वह यह है कि मुझे मूल्यों

142
00:09:00,727 --> 00:09:04,906
का यह छोटा 3x3 ग्रिड मिला है जो हमारी मूल छवि के साथ चल रहा है, और यदि हम ज़ूम इन करते

143
00:09:04,906 --> 00:09:09,133
हैं, तो उनमें से प्रत्येक मान 1 9वां है, और मैं क्या कर रहा हूं प्रत्येक पुनरावृत्ति पर

144
00:09:09,133 --> 00:09:13,312
उनमें से प्रत्येक मान को उस संबंधित पिक्सेल से गुणा किया जाता है जिसके ऊपर वह बैठता है।

145
00:09:13,312 --> 00:09:16,927
और निश्चित रूप से कंप्यूटर विज्ञान में हम रंगों को तीन मानों के छोटे वैक्टर

146
00:09:16,927 --> 00:09:20,400
के रूप में सोचते हैं, जो लाल, हरे और नीले घटकों का प्रतिनिधित्व करते हैं।

147
00:09:20,400 --> 00:09:23,759
जब मैं इन सभी छोटे मानों को 1 9वें से गुणा करता हूं और उन्हें एक साथ

148
00:09:23,759 --> 00:09:27,265
जोड़ता हूं, तो यह हमें प्रत्येक रंग चैनल के साथ एक औसत देता है, और दाईं

149
00:09:27,265 --> 00:09:30,966
ओर की छवि के लिए संबंधित पिक्सेल को उस योग के रूप में परिभाषित किया जाता है।

150
00:09:30,966 --> 00:09:36,022
समग्र प्रभाव, जैसा कि हम छवि पर हर एक पिक्सेल के लिए करते हैं, यह है कि प्रत्येक एक

151
00:09:36,022 --> 00:09:41,198
प्रकार का उसके सभी पड़ोसियों में खून बहता है, जो हमें मूल की तुलना में धुंधला संस्करण

152
00:09:41,198 --> 00:09:41,680
देता है।

153
00:09:41,680 --> 00:09:44,647
भाषा में हम कहेंगे कि दाईं ओर की छवि मूल्यों की

154
00:09:44,647 --> 00:09:47,800
एक छोटी ग्रिड के साथ हमारी मूल छवि का एक संयोजन है।

155
00:09:47,800 --> 00:09:51,115
या अधिक तकनीकी रूप से शायद मुझे यह कहना चाहिए कि यह मूल्यों के

156
00:09:51,115 --> 00:09:54,430
उस छोटे ग्रिड के 180 डिग्री घुमाए गए संस्करण के साथ कनवल्शन है।

157
00:09:54,430 --> 00:09:58,251
ऐसा नहीं है कि ग्रिड सममित होने पर यह मायने रखता है, लेकिन यह ध्यान में रखने योग्य है

158
00:09:58,251 --> 00:10:02,072
कि एक कनवल्शन की परिभाषा, जैसा कि शुद्ध गणित संदर्भ से विरासत में मिली है, आपको हमेशा

159
00:10:02,072 --> 00:10:05,760
उस दूसरे सरणी के चारों ओर फ़्लिप करने के बारे में सोचने के लिए आमंत्रित करना चाहिए।

160
00:10:05,760 --> 00:10:08,432
यदि हम इसे थोड़ा संशोधित करते हैं तो हम मूल्यों का एक अलग

161
00:10:08,432 --> 00:10:11,059
ग्रिड चुनकर अधिक सुंदर धुंधला प्रभाव प्राप्त कर सकते हैं।

162
00:10:11,059 --> 00:10:15,920
इस मामले में मेरे पास एक छोटा सा 5x5 ग्रिड है, लेकिन अंतर इसके आकार का नहीं है।

163
00:10:15,920 --> 00:10:19,336
यदि हम ज़ूम इन करते हैं तो हम देखते हैं कि बीच का मान किनारों के

164
00:10:19,336 --> 00:10:22,752
मान से बहुत बड़ा है, और यह कहां से आ रहा है, वे सभी एक घंटी वक्र

165
00:10:22,752 --> 00:10:26,010
से नमूने लिए गए हैं, जिसे गाऊसी वितरण के रूप में जाना जाता है।

166
00:10:26,010 --> 00:10:29,426
इस तरह जब हम इन सभी मानों को संबंधित पिक्सेल से गुणा करते हैं

167
00:10:29,426 --> 00:10:32,841
जिसके ऊपर वे बैठे हैं, तो हम उस केंद्रीय पिक्सेल को बहुत अधिक

168
00:10:32,841 --> 00:10:36,367
महत्व दे रहे हैं और किनारे पर मौजूद मानों को बहुत कम दे रहे हैं।

169
00:10:36,367 --> 00:10:40,373
और ठीक पहले की तरह दाईं ओर संबंधित पिक्सेल को इस योग के रूप में परिभाषित किया गया है।

170
00:10:40,373 --> 00:10:45,014
जैसा कि हम इस प्रक्रिया को हर एक पिक्सेल के लिए करते हैं, यह एक धुंधला प्रभाव देता है जो

171
00:10:45,014 --> 00:10:49,603
आपके लेंस को फोकस से बाहर या ऐसा कुछ करने की धारणा को अधिक प्रामाणिक रूप से अनुकरण करता

172
00:10:49,603 --> 00:10:49,760
है।

173
00:10:49,760 --> 00:10:53,474
लेकिन धुंधलापन एकमात्र ऐसी चीज़ नहीं है जो आप इस विचार के साथ कर सकते हैं।

174
00:10:53,474 --> 00:10:56,742
उदाहरण के लिए, मानों के इस छोटे ग्रिड पर एक नज़र डालें, जिसमें

175
00:10:56,742 --> 00:11:00,114
बाईं ओर कुछ सकारात्मक संख्याएँ और दाईं ओर कुछ नकारात्मक संख्याएँ

176
00:11:00,114 --> 00:11:03,071
शामिल हैं, जिन्हें मैं क्रमशः नीले और लाल रंग से रंगूँगा।

177
00:11:03,071 --> 00:11:06,274
यह देखने के लिए कुछ समय लें कि क्या आप अनुमान लगा सकते

178
00:11:06,274 --> 00:11:09,769
हैं और समझ सकते हैं कि इसका अंतिम छवि पर क्या प्रभाव पड़ेगा।

179
00:11:09,769 --> 00:11:13,840
तो इस मामले में मैं छवि को रंगीन के बजाय ग्रेस्केल के रूप में सोचूंगा,

180
00:11:13,840 --> 00:11:18,082
इसलिए प्रत्येक पिक्सेल को तीन के बजाय केवल एक संख्या द्वारा दर्शाया जाएगा।

181
00:11:18,082 --> 00:11:20,472
और ध्यान देने योग्य एक बात यह है कि जैसे ही हम यह

182
00:11:20,472 --> 00:11:23,102
कनवल्शन करते हैं तो नकारात्मक मान प्राप्त करना संभव है।

183
00:11:23,102 --> 00:11:27,433
उदाहरण के लिए, यहां इस बिंदु पर यदि हम ज़ूम इन करते हैं तो हमारे छोटे ग्रिड का बायां आधा

184
00:11:27,433 --> 00:11:31,424
हिस्सा पूरी तरह से काले पिक्सेल के शीर्ष पर बैठता है, जिसका मान शून्य होगा, लेकिन

185
00:11:31,424 --> 00:11:35,561
नकारात्मक मानों का दायां आधा भाग सफेद पिक्सेल के शीर्ष पर बैठता है, जो कि होगा एक का

186
00:11:35,561 --> 00:11:36,000
मूल्य है.

187
00:11:36,000 --> 00:11:39,435
इसलिए जब हम संगत शब्दों को गुणा करते हैं और उन्हें एक साथ जोड़ते हैं तो परिणाम

188
00:11:39,435 --> 00:11:42,741
बहुत नकारात्मक होंगे, और जिस तरह से मैं इसे दाईं ओर की छवि के साथ प्रदर्शित

189
00:11:42,741 --> 00:11:46,046
कर रहा हूं वह नकारात्मक मानों को लाल और सकारात्मक मानों को नीला रंग देना है।

190
00:11:46,046 --> 00:11:50,398
ध्यान देने वाली एक और बात यह है कि जब आप एक पैच पर होते हैं जो सभी समान रंग का होता

191
00:11:50,398 --> 00:11:54,854
है तो सब कुछ शून्य हो जाता है क्योंकि हमारे छोटे ग्रिड में मानों का योग शून्य होता है।

192
00:11:54,854 --> 00:11:58,842
यह पिछले दो उदाहरणों से बहुत अलग है जहां हमारे छोटे ग्रिड का योग एक था, जो

193
00:11:58,842 --> 00:12:02,990
हमें इसे चलती औसत के रूप में व्याख्या करने देता है और इसलिए धुंधला हो जाता है।

194
00:12:02,990 --> 00:12:07,579
कुल मिलाकर यह छोटी सी प्रक्रिया मूल रूप से पता लगाती है कि जब आप बाएं

195
00:12:07,579 --> 00:12:12,167
से दाएं जाते हैं तो पिक्सेल मान में कहां भिन्नता होती है, और इसलिए यह

196
00:12:12,167 --> 00:12:16,560
आपको अपनी छवि से सभी ऊर्ध्वाधर किनारों को लेने का एक तरीका देता है।

197
00:12:16,560 --> 00:12:21,055
और इसी तरह अगर हम उस ग्रिड को चारों ओर घुमाते हैं ताकि जब आप ऊपर से नीचे की

198
00:12:21,055 --> 00:12:25,550
ओर बढ़ें तो यह अलग-अलग हो, यह सभी क्षैतिज किनारों को पकड़ लेगा, जो कि हमारी

199
00:12:25,550 --> 00:12:29,986
छोटी पाई प्राणी छवि के मामले में कुछ सुंदर राक्षसी आँखों में परिणत होता है।

200
00:12:29,986 --> 00:12:33,489
वैसे, इस छोटे ग्रिड को अक्सर कर्नेल कहा जाता है, और यहां की सुंदरता यह है कि कैसे

201
00:12:33,489 --> 00:12:36,950
एक अलग कर्नेल चुनकर आप अलग-अलग छवि प्रसंस्करण प्रभाव प्राप्त कर सकते हैं, न केवल

202
00:12:36,950 --> 00:12:40,710
आपके किनारे का पता लगाने को धुंधला कर सकते हैं बल्कि तेज करने जैसी चीजें भी कर सकते हैं।

203
00:12:40,710 --> 00:12:44,222
आपमें से जिन लोगों ने कनवल्शनल न्यूरल नेटवर्क के बारे में सुना है, उनके लिए

204
00:12:44,222 --> 00:12:47,735
विचार यह है कि डेटा का उपयोग करके यह पता लगाया जाए कि सबसे पहले कर्नेल क्या

205
00:12:47,735 --> 00:12:51,618
होना चाहिए, जैसा कि न्यूरल नेटवर्क जो भी पता लगाना चाहता है, उससे निर्धारित होता है।

206
00:12:51,618 --> 00:12:55,378
एक और चीज़ जो शायद मुझे सामने लानी चाहिए वह है आउटपुट की लंबाई।

207
00:12:55,378 --> 00:12:59,468
चलती औसत उदाहरण जैसी किसी चीज़ के लिए आप केवल उन शर्तों के बारे में सोचना

208
00:12:59,468 --> 00:13:03,393
चाहेंगे जब दोनों विंडो पूरी तरह से एक-दूसरे के साथ संरेखित हों, या छवि

209
00:13:03,393 --> 00:13:07,760
प्रसंस्करण उदाहरण में शायद आप चाहते हैं कि अंतिम आउटपुट का आकार मूल के समान हो।

210
00:13:07,760 --> 00:13:10,717
अब एक शुद्ध गणित ऑपरेशन के रूप में कनवल्शन हमेशा एक सरणी उत्पन्न

211
00:13:10,717 --> 00:13:13,538
करता है जो आपके द्वारा शुरू की गई दो सरणी से बड़ी होती है, कम

212
00:13:13,538 --> 00:13:16,405
से कम यह मानते हुए कि उनमें से एक की लंबाई एक के बराबर नहीं है।

213
00:13:16,405 --> 00:13:18,962
बस यह जान लें कि कुछ कंप्यूटर विज्ञान संदर्भों में

214
00:13:18,962 --> 00:13:21,520
आप अक्सर जानबूझकर उस आउटपुट को छोटा करना चाहते हैं।

215
00:13:21,520 --> 00:13:26,803
हाइलाइट करने लायक एक और बात यह है कि कंप्यूटर विज्ञान के संदर्भ में मूल के पार जाने

216
00:13:26,803 --> 00:13:31,773
से पहले उस कर्नेल के चारों ओर फ़्लिप करने की यह धारणा अक्सर वास्तव में अजीब और

217
00:13:31,773 --> 00:13:37,057
अनावश्यक लगती है, लेकिन फिर से ध्यान दें कि यह शुद्ध गणित संदर्भ से विरासत में मिला

218
00:13:37,057 --> 00:13:42,530
है जहां हम जैसे हैं संभावनाओं के साथ देखा जाए तो यह अविश्वसनीय रूप से स्वाभाविक बात है।

219
00:13:42,530 --> 00:13:45,738
और वास्तव में मैं आपको एक और शुद्ध गणित का उदाहरण दिखा सकता

220
00:13:45,738 --> 00:13:49,054
हूं जहां प्रोग्रामर को भी इसकी परवाह करनी चाहिए क्योंकि यह इन

221
00:13:49,054 --> 00:13:52,370
सभी की गणना करने के लिए बहुत तेज़ एल्गोरिदम के द्वार खोलता है।

222
00:13:52,370 --> 00:13:55,929
यहां तेजी से मेरा जो मतलब है उसे स्थापित करने के लिए मुझे वापस जाने दें और कुछ

223
00:13:55,929 --> 00:13:59,579
अजगर को फिर से खींचने दें और मैं दो अलग-अलग अपेक्षाकृत बड़े ऐरे बनाने जा रहा हूं।

224
00:13:59,579 --> 00:14:03,238
प्रत्येक में एक लाख यादृच्छिक तत्व होंगे और मैं numpy

225
00:14:03,238 --> 00:14:07,575
लाइब्रेरी से कन्वोल्व फ़ंक्शन के रनटाइम का आकलन करने जा रहा हूं।

226
00:14:07,575 --> 00:14:11,413
और इस मामले में यह इसे कई अलग-अलग पुनरावृत्तियों के लिए चलाता है, एक औसत

227
00:14:11,413 --> 00:14:15,619
खोजने की कोशिश करता है, और ऐसा लगता है कि इस कंप्यूटर पर कम से कम इसका औसत 4 है।

228
00:14:15,619 --> 00:14:16,321
87 सेकंड.

229
00:14:16,321 --> 00:14:19,674
इसके विपरीत यदि मैं scipy लाइब्रेरी से एक अलग फ़ंक्शन का उपयोग

230
00:14:19,674 --> 00:14:23,027
करता हूं जिसे fftconvolve कहा जाता है जो कि एक ही चीज़ है जिसे

231
00:14:23,027 --> 00:14:26,061
बस अलग तरीके से लागू किया जाता है जिसमें केवल 4 लगते हैं।

232
00:14:26,061 --> 00:14:30,640
औसतन 3 मिलीसेकंड, इसलिए परिमाण में सुधार के तीन क्रम।

233
00:14:30,640 --> 00:14:34,655
और फिर भले ही यह एक अलग नाम के तहत उड़ान भरता है, यह वही आउटपुट दे रहा है जो

234
00:14:34,655 --> 00:14:38,880
अन्य कन्वोल्व फ़ंक्शन देता है, यह बस इसे चतुर तरीके से करने के लिए कुछ कर रहा है।

235
00:14:38,880 --> 00:14:43,244
याद रखें कि संभाव्यता उदाहरण के साथ मैंने कहा था कि कनवल्शन के

236
00:14:43,244 --> 00:14:47,678
बारे में सोचने का एक और तरीका यह था कि सभी जोड़ीदार उत्पादों की

237
00:14:47,678 --> 00:14:52,528
यह तालिका बनाएं और फिर विकर्णों के साथ उन जोड़ीदार उत्पादों को जोड़ें।

238
00:14:52,528 --> 00:14:55,857
निश्चित रूप से संभाव्यता के लिए कुछ भी विशिष्ट नहीं है, जब भी आप संख्याओं

239
00:14:55,857 --> 00:14:59,321
की दो अलग-अलग सूचियाँ बना रहे हों तो आप इसके बारे में इस तरह से सोच सकते हैं।

240
00:14:59,321 --> 00:15:02,773
सभी जोड़ीवार उत्पादों के साथ इस प्रकार की गुणन तालिका बनाएं और फिर

241
00:15:02,773 --> 00:15:06,381
विकर्ण के साथ प्रत्येक योग आपके अंतिम आउटपुट में से एक से मेल खाता है।

242
00:15:06,381 --> 00:15:09,506
एक संदर्भ जहां यह दृश्य विशेष रूप से स्वाभाविक

243
00:15:09,506 --> 00:15:12,431
है जब आप दो बहुपदों को एक साथ गुणा करते हैं।

244
00:15:12,431 --> 00:15:18,210
उदाहरण के लिए, मैं हमारे पास पहले से मौजूद छोटे ग्रिड को लेता हूं और शीर्ष पदों को

245
00:15:18,210 --> 00:15:23,920
1, 2x और 3x वर्ग से बदल देता हूं और अन्य पदों को 4, 5x और 6x वर्ग से बदल देता हूं।

246
00:15:23,920 --> 00:15:26,224
अब सोचें कि जब हम दो सूचियों के बीच इन सभी अलग-अलग

247
00:15:26,224 --> 00:15:28,664
जोड़ीवार उत्पादों को बना रहे हैं तो इसका क्या मतलब है।

248
00:15:28,664 --> 00:15:33,129
आप जो कर रहे हैं वह अनिवार्य रूप से मेरे द्वारा लिखे गए दो बहुपदों के पूर्ण

249
00:15:33,129 --> 00:15:37,595
उत्पाद का विस्तार करना है और फिर जब आप विकर्ण के साथ जोड़ते हैं जो सभी समान

250
00:15:37,595 --> 00:15:42,178
पदों को एकत्रित करने के अनुरूप होता है जो कि एक बहुपद का विस्तार करने और समान

251
00:15:42,178 --> 00:15:46,937
पदों को एकत्रित करने के लिए बहुत साफ-सुथरा होता है। कनवल्शन के समान ही प्रक्रिया।

252
00:15:46,937 --> 00:15:49,872
लेकिन यह हमें कुछ ऐसा करने की अनुमति देता है जो बहुत

253
00:15:49,872 --> 00:15:52,642
अच्छा है क्योंकि सोचें कि हम यहां क्या कह रहे हैं।

254
00:15:52,642 --> 00:15:56,657
हम कह रहे हैं कि यदि आप दो अलग-अलग फ़ंक्शन लेते हैं और आप उन्हें एक

255
00:15:56,657 --> 00:16:00,672
साथ गुणा करते हैं जो कि एक सरल बिंदुवार ऑपरेशन है, तो यह वही बात है

256
00:16:00,672 --> 00:16:04,569
जैसे कि आपने पहले उनमें से प्रत्येक से गुणांक निकाला था, यह मानते

257
00:16:04,569 --> 00:16:08,761
हुए कि वे बहुपद हैं और फिर उनका कनवल्शन लिया है गुणांकों की दो सूचियाँ।

258
00:16:08,761 --> 00:16:13,009
जो चीज़ इसे इतना दिलचस्प बनाती है वह यह है कि सिद्धांत रूप में कनवल्शन सरल गुणन

259
00:16:13,009 --> 00:16:17,415
की तुलना में बहुत अधिक जटिल लगता है और मेरा मतलब यह नहीं है कि वैचारिक रूप से उनके

260
00:16:17,415 --> 00:16:21,716
बारे में सोचना कठिन है, मेरा मतलब है कि कम्प्यूटेशनल रूप से कनवल्शन को निष्पादित

261
00:16:21,716 --> 00:16:26,070
करने के लिए अधिक चरणों की आवश्यकता होती है। दो अलग-अलग सूचियों का बिंदुवार उत्पाद।

262
00:16:26,070 --> 00:16:29,951
उदाहरण के लिए, मान लें कि मैंने आपको दो बहुत बड़े बहुपद दिए हैं, मान लीजिए

263
00:16:29,951 --> 00:16:33,780
कि प्रत्येक एक सौ अलग-अलग गुणांकों के साथ है, तो यदि आप जिस तरह से उन्हें

264
00:16:33,780 --> 00:16:37,816
गुणा करते हैं, वह इस उत्पाद का विस्तार करना है, तो आप जानते हैं कि इस संपूर्ण

265
00:16:37,816 --> 00:16:41,594
100 गुणा 100 ग्रिड को जोड़ीवार उत्पादों में भरना है, जिसके लिए आपको इसकी

266
00:16:41,594 --> 00:16:45,578
आवश्यकता होगी। 10,000 अलग-अलग उत्पाद निष्पादित करें और फिर जब आप विकर्णों के

267
00:16:45,578 --> 00:16:49,666
साथ सभी समान शब्द एकत्र कर रहे हों तो यह लगभग 10,000 परिचालनों का एक और सेट है।

268
00:16:49,666 --> 00:16:55,307
अधिक आम तौर पर भाषा में हम कहेंगे कि एल्गोरिथ्म n वर्ग का O है, जिसका अर्थ n आकार की

269
00:16:55,307 --> 00:17:00,816
दो सूचियों के लिए है, जिस तरह से ऑपरेशन स्केल की संख्या n के वर्ग के अनुपात में है।

270
00:17:00,816 --> 00:17:04,899
दूसरी ओर, यदि मैं दो बहुपदों के बारे में उनके आउटपुट के संदर्भ में सोचता हूं,

271
00:17:04,899 --> 00:17:08,982
उदाहरण के लिए कुछ मुट्ठी भर इनपुट पर उनके मानों का नमूना लेना, तो उन्हें गुणा

272
00:17:08,982 --> 00:17:12,960
करने के लिए केवल उतने ही ऑपरेशन की आवश्यकता होती है जितनी नमूनों की संख्या,

273
00:17:12,960 --> 00:17:17,148
क्योंकि फिर से यह एक बिंदुवार ऑपरेशन है और बहुपद के साथ आपको केवल इसकी आवश्यकता

274
00:17:17,148 --> 00:17:21,126
होती है गुणांकों को पुनर्प्राप्त करने में सक्षम होने के लिए बहुत सारे नमूने।

275
00:17:21,126 --> 00:17:24,682
उदाहरण के लिए, दो आउटपुट एक रैखिक बहुपद को विशिष्ट रूप से निर्दिष्ट करने के

276
00:17:24,682 --> 00:17:28,378
लिए पर्याप्त हैं, तीन आउटपुट एक द्विघात बहुपद को विशिष्ट रूप से निर्दिष्ट करने

277
00:17:28,378 --> 00:17:32,028
के लिए पर्याप्त होंगे और सामान्य तौर पर यदि आप n अलग-अलग आउटपुट जानते हैं, तो

278
00:17:32,028 --> 00:17:35,444
यह एक बहुपद को विशिष्ट रूप से निर्दिष्ट करने के लिए पर्याप्त है जिसमें n

279
00:17:35,444 --> 00:17:39,046
अलग-अलग गुणांक हैं या यदि आप चाहें तो हम कर सकते हैं। समीकरणों की प्रणालियों

280
00:17:39,046 --> 00:17:42,743
की भाषा में यह वाक्यांश कल्पना कीजिए, मैं आपको बताता हूं कि मेरे पास कुछ बहुपद

281
00:17:42,743 --> 00:17:46,439
हैं, लेकिन मैं आपको यह नहीं बताता कि गुणांक क्या हैं, वे आपके लिए एक रहस्य हैं।

282
00:17:46,439 --> 00:17:50,493
हमारे उदाहरण में आप इसे उस उत्पाद के रूप में सोच सकते हैं जिसे हम जानने का प्रयास

283
00:17:50,493 --> 00:17:54,647
कर रहे हैं और फिर मान लीजिए कि मैं कहता हूं कि मैं आपको केवल यह बताऊंगा कि यदि आपने

284
00:17:54,647 --> 00:17:58,602
0, 1, 2 जैसे विभिन्न इनपुट इनपुट किए हैं तो इस बहुपद के आउटपुट क्या होंगे। , 3,

285
00:17:58,602 --> 00:18:02,706
लगातार और आगे और मैं आपको पर्याप्त देता हूं ताकि आपके पास उतने ही समीकरण हों जितने

286
00:18:02,706 --> 00:18:06,760
आपके पास अज्ञात हैं, यह समीकरणों की एक रैखिक प्रणाली भी होती है इसलिए यह अच्छा है

287
00:18:06,760 --> 00:18:11,061
और सिद्धांत रूप में कम से कम यह गुणांक को पुनर्प्राप्त करने के लिए पर्याप्त होना चाहिए।

