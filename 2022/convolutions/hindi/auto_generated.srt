1
00:00:00,000 --> 00:00:02,915
मान लीजिए कि मैं आपको संख्याओं की दो अलग-अलग सूचियाँ देता हूँ, या शायद दो अलग-

2
00:00:02,915 --> 00:00:05,831
अलग फ़ंक्शन देता हूँ, और मैं आपसे उन सभी तरीकों के बारे में सोचने के लिए कहता

3
00:00:05,831 --> 00:00:09,083
हूँ जिनसे आप संख्याओं की एक नई सूची प्राप्त करने के लिए उन दो सूचियों को जोड़ सकते हैं,

4
00:00:09,083 --> 00:00:11,737
या एक नया फ़ंक्शन प्राप्त करने के लिए दो फ़ंक्शनों को जोड़ सकते हैं। .

5
00:00:11,737 --> 00:00:14,100
शायद एक आसान तरीका जो दिमाग में आता है वह यह है

6
00:00:14,100 --> 00:00:16,267
कि उन्हें शब्द दर शब्द एक साथ जोड़ दिया जाए।

7
00:00:16,267 --> 00:00:20,050
इसी प्रकार फ़ंक्शंस के साथ, आप सभी संबंधित आउटपुट जोड़ सकते हैं।

8
00:00:20,050 --> 00:00:23,037
इसी तरह, आप दोनों सूचियों को पद दर पद गुणा भी कर

9
00:00:23,037 --> 00:00:26,145
सकते हैं और फ़ंक्शंस के साथ भी यही काम कर सकते हैं।

10
00:00:26,145 --> 00:00:29,598
लेकिन इन दोनों की तरह एक और प्रकार का संयोजन भी मौलिक है,

11
00:00:29,598 --> 00:00:33,840
लेकिन बहुत कम चर्चा की जाती है, जिसे कनवल्शन के रूप में जाना जाता है।

12
00:00:33,840 --> 00:00:36,890
लेकिन पिछले दो मामलों के विपरीत, यह ऐसा कुछ नहीं है जो केवल एक

13
00:00:36,890 --> 00:00:39,893
ऑपरेशन से विरासत में मिला है जिसे आप संख्याओं में कर सकते हैं।

14
00:00:39,893 --> 00:00:44,716
संख्याओं की सूची या संयोजन कार्यों के संदर्भ में यह वास्तव में कुछ नया है।

15
00:00:44,716 --> 00:00:48,165
वे हर जगह दिखाई देते हैं, वे छवि प्रसंस्करण में सर्वव्यापी हैं,

16
00:00:48,165 --> 00:00:50,903
यह संभाव्यता के सिद्धांत में एक मुख्य निर्माण है,

17
00:00:50,903 --> 00:00:54,133
अंतर समीकरणों को हल करने में उनका बहुत उपयोग किया जाता है,

18
00:00:54,133 --> 00:00:58,294
और एक संदर्भ जहां आपने इसे लगभग निश्चित रूप से देखा है, यदि नहीं इस नाम से,

19
00:00:58,294 --> 00:01:00,210
दो बहुपदों को एक साथ गुणा करना है।

20
00:01:00,210 --> 00:01:04,600
दृश्य स्पष्टीकरण के व्यवसाय में किसी के रूप में, यह एक विशेष रूप से महान विषय है,

21
00:01:04,600 --> 00:01:08,773
क्योंकि अलगाव में और संदर्भ के बिना सूत्रबद्ध परिभाषा डराने वाली लग सकती है,

22
00:01:08,773 --> 00:01:12,784
लेकिन अगर हम वास्तव में यह क्या कह रहे हैं उसे खोलने के लिए समय लेते हैं,

23
00:01:12,784 --> 00:01:16,577
और उससे पहले वास्तव में प्रेरित करते हैं कि क्यों आप ऐसा कुछ चाहेंगे,

24
00:01:16,577 --> 00:01:18,800
यह एक अविश्वसनीय रूप से सुंदर ऑपरेशन है।

25
00:01:18,800 --> 00:01:21,073
और मुझे यह स्वीकार करना होगा कि इस परियोजना के लिए

26
00:01:21,073 --> 00:01:23,436
दृश्यों को एक साथ रखते समय मैंने वास्तव में कुछ सीखा।

27
00:01:23,436 --> 00:01:25,894
दो अलग-अलग कार्यों को संयोजित करने के मामले में, मैं अलग-

28
00:01:25,894 --> 00:01:29,733
अलग तरीकों के बारे में सोचने की कोशिश कर रहा था जिनसे आप कल्पना कर सकते हैं कि इसका क्या

29
00:01:29,733 --> 00:01:33,485
मतलब हो सकता है, और उनमें से एक के साथ मेरे मन में थोड़ा अहा पल आया कि ऐसा क्यों है कि

30
00:01:33,485 --> 00:01:36,159
सामान्य वितरण भूमिका निभाते हैं वे संभाव्यता में ऐसा करते हैं,

31
00:01:36,159 --> 00:01:38,445
किसी फ़ंक्शन के लिए यह इतना स्वाभाविक आकार क्यों है।

32
00:01:38,445 --> 00:01:41,580
लेकिन मैं खुद से आगे निकल रहा हूं, इसके लिए बहुत सारी व्यवस्थाएं मौजूद हैं।

33
00:01:41,580 --> 00:01:44,773
इस वीडियो में, हमारा प्राथमिक ध्यान केवल अलग-अलग मामले पर होगा,

34
00:01:44,773 --> 00:01:49,132
और विशेष रूप से इनकी गणना के लिए एक बहुत ही अप्रत्याशित लेकिन बहुत ही चतुर एल्गोरिदम

35
00:01:49,132 --> 00:01:50,196
का निर्माण करना होगा।

36
00:01:50,196 --> 00:01:57,840
और मैं सतत मामले की चर्चा को दूसरे भाग में ले जाऊंगा।

37
00:01:57,840 --> 00:02:00,696
छवि प्रसंस्करण उदाहरणों के साथ शुरुआत करना बहुत आकर्षक है,

38
00:02:00,696 --> 00:02:04,488
क्योंकि वे दृष्टिगत रूप से सबसे दिलचस्प हैं, लेकिन कुछ बारीकियाँ हैं जो छवि

39
00:02:04,488 --> 00:02:07,838
प्रसंस्करण मामले को समग्र रूप से संकल्पों का कम प्रतिनिधि बनाती हैं,

40
00:02:07,838 --> 00:02:10,448
इसलिए इसके बजाय संभावनाओं के साथ चीजों को शुरू करें,

41
00:02:10,448 --> 00:02:14,487
और विशेष रूप से सबसे सरल उदाहरणों में से एक, जिसके बारे में मुझे यकीन है कि यहां

42
00:02:14,487 --> 00:02:18,427
हर किसी ने अपने जीवन में कभी न कभी सोचा होगा, जो कि पासों की एक जोड़ी को घुमाना

43
00:02:18,427 --> 00:02:21,530
और विभिन्न अलग-अलग योगों को देखने की संभावनाओं का पता लगाना है।

44
00:02:21,530 --> 00:02:24,170
और आप कह सकते हैं, कोई समस्या नहीं, कोई समस्या नहीं।

45
00:02:24,170 --> 00:02:27,892
आपके दोनों पासों में से प्रत्येक के छह अलग-अलग संभावित परिणाम हैं,

46
00:02:27,892 --> 00:02:31,220
जो हमें परिणामों के कुल 36 अलग-अलग संभावित जोड़े देते हैं,

47
00:02:31,220 --> 00:02:36,240
और यदि हम उन सभी को देखते हैं तो हम गिन सकते हैं कि कितने जोड़ों में एक दिया गया योग है।

48
00:02:36,240 --> 00:02:39,236
और सभी जोड़ियों को इस तरह एक ग्रिड में व्यवस्थित करने पर,

49
00:02:39,236 --> 00:02:42,706
एक बहुत अच्छी बात यह है कि जिन सभी जोड़ियों का योग स्थिर होता है,

50
00:02:42,706 --> 00:02:45,650
वे इन विभिन्न विकर्णों में से एक के साथ दिखाई देते हैं।

51
00:02:45,650 --> 00:02:49,237
तो बस यह गिनने से कि उनमें से प्रत्येक विकर्ण पर कितने मौजूद हैं,

52
00:02:49,237 --> 00:02:52,880
आपको पता चल जाएगा कि आपको एक विशेष योग देखने की कितनी संभावना है।

53
00:02:52,880 --> 00:02:55,657
और मैं कहूंगा, बहुत अच्छा, बहुत अच्छा, लेकिन क्या आप किसी अन्य

54
00:02:55,657 --> 00:02:58,699
तरीके के बारे में सोच सकते हैं जिससे आप उसी प्रश्न की कल्पना कर सकें?

55
00:02:58,699 --> 00:03:01,060
अन्य छवियां जो उन सभी विशिष्ट जोड़ियों के बारे में

56
00:03:01,060 --> 00:03:03,744
सोचने के लिए दिमाग में आ सकती हैं जिनका एक निश्चित योग है?

57
00:03:03,744 --> 00:03:07,550
और हो सकता है कि आप में से कोई अपना हाथ उठाए और कहे, हाँ, मेरे पास एक है।

58
00:03:07,550 --> 00:03:10,198
मान लीजिए कि आप एक पंक्ति में संभावनाओं के इन दो अलग-

59
00:03:10,198 --> 00:03:14,046
अलग सेटों की कल्पना करते हैं, लेकिन आप उस दूसरी पंक्ति के चारों ओर घूमते हैं।

60
00:03:14,046 --> 00:03:18,960
इस तरह सभी अलग-अलग जोड़े जो सात तक जुड़ते हैं, इस तरह लंबवत पंक्ति में आते हैं।

61
00:03:18,960 --> 00:03:22,310
और यदि हम उस निचली पंक्ति को पूरी तरह से दाहिनी ओर सरकाते हैं,

62
00:03:22,310 --> 00:03:26,309
तो अद्वितीय जोड़ी जो दो को जोड़ती है, साँप की आँखें, ही संरेखित होती हैं।

63
00:03:26,309 --> 00:03:30,712
और यदि मैं इसे दाहिनी ओर एक इकाई पर झुकाऊं, तो जो जोड़े संरेखित होते हैं वे दो अलग-

64
00:03:30,712 --> 00:03:32,886
अलग जोड़े होते हैं जिनका योग तीन होता है।

65
00:03:32,886 --> 00:03:37,771
और सामान्य तौर पर, इस निचले सरणी के अलग-अलग ऑफसेट मान, जो याद रखें कि मुझे पहले पलटना था,

66
00:03:37,771 --> 00:03:41,778
उन सभी अलग-अलग जोड़ियों को प्रकट करता है जिनमें एक दिया गया योग होता है।

67
00:03:41,778 --> 00:03:47,342
जहां तक संभाव्यता प्रश्नों का सवाल है, यह अभी भी विशेष रूप से दिलचस्प नहीं है,

68
00:03:47,342 --> 00:03:53,120
क्योंकि हम केवल यह गिन रहे हैं कि इनमें से प्रत्येक श्रेणी में कितने परिणाम हैं।

69
00:03:53,120 --> 00:03:55,436
लेकिन यह इस अंतर्निहित धारणा के साथ है कि इनमें

70
00:03:55,436 --> 00:03:57,850
से प्रत्येक चेहरे के सामने आने की समान संभावना है।

71
00:03:57,850 --> 00:04:01,897
लेकिन क्या होगा अगर मैं आपसे कहूं कि मेरे पास पासों का एक विशेष सेट है जो एक समान नहीं है?

72
00:04:01,897 --> 00:04:05,723
हो सकता है कि नीले पासे में संख्याओं का अपना सेट हो जो प्रत्येक चेहरे के आने की

73
00:04:05,723 --> 00:04:09,740
संभावनाओं का वर्णन करता हो, और लाल पासे में संख्याओं का अपना विशिष्ट विशिष्ट सेट हो।

74
00:04:09,740 --> 00:04:13,891
उस स्थिति में, यदि आप दो देखने की संभावना का पता लगाना चाहते हैं,

75
00:04:13,891 --> 00:04:19,001
तो आप नीले पासे के एक होने की प्रायिकता को लाल पासे के एक होने की प्रायिकता से

76
00:04:19,001 --> 00:04:19,895
गुणा कर देंगे।

77
00:04:19,895 --> 00:04:24,846
और तीन देखने की संभावना के लिए, आप दो अलग-अलग जोड़ियों को देखें जहां यह संभव है,

78
00:04:24,846 --> 00:04:29,983
और फिर से, संबंधित संभावनाओं को गुणा करें, और फिर उन दो उत्पादों को एक साथ जोड़ें।

79
00:04:29,983 --> 00:04:33,182
इसी प्रकार, चार को देखने की संभावना में संभावनाओं के तीन अलग-

80
00:04:33,182 --> 00:04:36,748
अलग युग्मों को एक साथ गुणा करना और उन सभी को एक साथ जोड़ना शामिल है।

81
00:04:36,748 --> 00:04:41,202
और कुछ सूत्र स्थापित करने की भावना से, आइए इन शीर्ष संभावनाओं को a1, a2,

82
00:04:41,202 --> 00:04:45,903
a3, इत्यादि नाम दें, और नीचे वाली संभावनाओं को b1, b2, b3, इत्यादि नाम दें।

83
00:04:45,903 --> 00:04:49,847
और सामान्य तौर पर, यह प्रक्रिया, जहां हम संख्याओं के दो अलग-अलग सरणी ले रहे हैं,

84
00:04:49,847 --> 00:04:53,841
दूसरे को चारों ओर घुमा रहे हैं, और फिर उन्हें विभिन्न ऑफसेट मानों पर पंक्तिबद्ध

85
00:04:53,841 --> 00:04:57,540
कर रहे हैं, जोड़ीदार उत्पादों का एक समूह ले रहे हैं और उन्हें जोड़ रहे हैं,

86
00:04:57,540 --> 00:05:01,139
यह इनमें से एक है कनवल्शन क्या है इसके बारे में सोचने के बुनियादी तरीके।

87
00:05:01,139 --> 00:05:06,499
तो बस इसे थोड़ा और सटीक रूप से बताने के लिए, इस प्रक्रिया के माध्यम से, हमने दो,

88
00:05:06,499 --> 00:05:12,194
तीन, चार, आगे और फिर 12 तक देखने की संभावनाएं उत्पन्न कीं, और हमने मानों की एक सूची,

89
00:05:12,194 --> 00:05:17,084
ए, और एक अन्य को एक साथ मिलाकर उन्हें प्राप्त किया। मूल्यों की सूची, बी.

90
00:05:17,084 --> 00:05:21,800
भाषा में, हम कहेंगे कि उन दो अनुक्रमों का कनवल्शन हमें यह नया अनुक्रम देता है,

91
00:05:21,800 --> 00:05:27,120
11 मानों का नया अनुक्रम, जिनमें से प्रत्येक जोड़ीदार उत्पादों के कुछ योग जैसा दिखता है।

92
00:05:27,120 --> 00:05:31,942
यदि आप चाहें, तो उसी ऑपरेशन के बारे में दूसरा तरीका यह सोच सकते हैं कि पहले

93
00:05:31,942 --> 00:05:36,702
सभी जोड़ीवार उत्पादों की एक तालिका बनाएं, और फिर इन सभी विकर्णों को जोड़ें।

94
00:05:36,702 --> 00:05:39,319
फिर, यह संख्याओं के इन दो अनुक्रमों को एक साथ मिलाने का एक

95
00:05:39,319 --> 00:05:42,247
तरीका है जिससे हमें 11 संख्याओं का एक नया अनुक्रम प्राप्त होता है।

96
00:05:42,247 --> 00:05:46,960
यह वही ऑपरेशन है जैसा कि स्लाइडिंग विंडोज़ ने सोचा था, बस एक और परिप्रेक्ष्य।

97
00:05:46,960 --> 00:05:50,314
इसमें थोड़ा सा नोटेशन डालते हुए, यहां बताया गया है कि आप इसे कैसे लिखा हुआ देख सकते हैं।

98
00:05:50,314 --> 00:05:54,873
ए और बी का कनवल्शन, इस छोटे तारांकन के साथ दर्शाया गया है, एक नई सूची है,

99
00:05:54,873 --> 00:05:59,930
और उस सूची का एनवां तत्व एक योग की तरह दिखता है, और वह योग सूचकांकों के सभी अलग-

100
00:05:59,930 --> 00:06:04,738
अलग जोड़े, आई और जे पर जाता है, ताकि योग का योग हो वे सूचकांक n के बराबर हैं।

101
00:06:04,738 --> 00:06:08,407
यह एक प्रकार का कौर है, लेकिन उदाहरण के लिए, यदि n 6 था,

102
00:06:08,407 --> 00:06:14,238
तो जिन जोड़ियों पर हम जा रहे हैं वे 1 और 5, 2 और 4, 3 और 3, 4 और 2, 5 और 1 हैं, सभी अलग-

103
00:06:14,238 --> 00:06:16,400
अलग जोड़े हैं जो जुड़ते हैं से 6.

104
00:06:16,400 --> 00:06:18,866
लेकिन ईमानदारी से कहूं तो, आप इसे किसी भी तरह से लिखें,

105
00:06:18,866 --> 00:06:21,198
प्रक्रिया के दौरान आपके दिमाग में जो दृश्य रहता है,

106
00:06:21,198 --> 00:06:23,082
उसके मुकाबले नोटेशन का महत्व गौण होता है।

107
00:06:23,082 --> 00:06:26,190
यहां, शायद यह एक अत्यंत सरल उदाहरण देने में मदद करेगा,

108
00:06:26,190 --> 00:06:30,967
जहां मैं आपसे पूछ सकता हूं कि सूची 4, 5, 6 के साथ सूची 1, 2, 3 का कनवल्शन क्या है।

109
00:06:30,967 --> 00:06:34,438
आप इन दोनों सूचियों को लेते हुए, दूसरी सूची के चारों ओर पलटते हुए,

110
00:06:34,438 --> 00:06:37,857
और फिर इसके ढक्कन से शुरू करके बाईं ओर तक की कल्पना कर सकते हैं।

111
00:06:37,857 --> 00:06:40,327
फिर मानों की जोड़ी जो संरेखित होती है वह 1 और 4 है,

112
00:06:40,327 --> 00:06:43,813
उन्हें एक साथ गुणा करें, और इससे हमें हमारे आउटपुट का पहला पद मिलता है।

113
00:06:43,813 --> 00:06:47,752
उस निचली सरणी को एक इकाई दाईं ओर स्लाइड करें, जो जोड़े संरेखित हैं वे 1 और 5,

114
00:06:47,752 --> 00:06:50,974
और 2 और 4 हैं, उन जोड़ियों को गुणा करें, उन्हें एक साथ जोड़ें,

115
00:06:50,974 --> 00:06:54,300
और इससे हमें 13 मिलता है, जो हमारे आउटपुट में अगली प्रविष्टि है।

116
00:06:54,300 --> 00:06:58,828
चीज़ों को एक बार फिर सरकाएँ, और हम 1 गुना 6, प्लस 2 गुना 5,

117
00:06:58,828 --> 00:07:01,591
प्लस 3 गुना 4, जो होता है 28 लेंगे।

118
00:07:01,591 --> 00:07:05,601
एक और स्लाइड, और हमें 2 गुना 6, प्लस 3 गुना 5 मिलता है,

119
00:07:05,601 --> 00:07:10,560
और इससे हमें 27 मिलता है, और अंत में अंतिम पद 3 गुना 6 जैसा दिखेगा।

120
00:07:10,560 --> 00:07:12,950
यदि आप चाहें, तो आप जो भी आपकी पसंदीदा प्रोग्रामिंग भाषा है,

121
00:07:12,950 --> 00:07:15,739
और आपकी पसंदीदा लाइब्रेरी जिसमें विभिन्न संख्यात्मक ऑपरेशन शामिल हैं,

122
00:07:15,739 --> 00:07:18,807
को खींच सकते हैं, और आप पुष्टि कर सकते हैं कि मैं आपसे झूठ नहीं बोल रहा हूं।

123
00:07:18,807 --> 00:07:22,371
यदि आप 4, 5, 6 के विरुद्ध 1, 2, 3 का कनवल्शन लेते हैं,

124
00:07:22,371 --> 00:07:24,880
तो आपको वास्तव में यही परिणाम मिलेगा।

125
00:07:24,880 --> 00:07:28,511
हमने एक मामला देखा है जहां यह एक प्राकृतिक और वांछनीय ऑपरेशन है,

126
00:07:28,511 --> 00:07:32,881
जो संभाव्यता वितरण को जोड़ता है, और एक अन्य सामान्य उदाहरण एक चलती औसत होगी।

127
00:07:32,881 --> 00:07:35,557
कल्पना करें कि आपके पास संख्याओं की कुछ लंबी सूची है,

128
00:07:35,557 --> 00:07:38,788
और आप संख्याओं की एक और छोटी सूची लेते हैं जिनका योग 1 होता है।

129
00:07:38,788 --> 00:07:43,381
इस मामले में, मेरे पास केवल 5 मानों की एक छोटी सी सूची है, और वे सभी 1/5वें के बराबर हैं।

130
00:07:43,381 --> 00:07:46,373
फिर यदि हम यह स्लाइडिंग विंडो कनवल्शन प्रक्रिया करते हैं,

131
00:07:46,373 --> 00:07:51,097
और अपनी आंखें बंद कर लेते हैं और गलीचे के नीचे देखते हैं कि इसकी शुरुआत में क्या होता है,

132
00:07:51,097 --> 00:07:55,296
एक बार जब मूल्यों की हमारी छोटी सूची पूरी तरह से बड़े के साथ ओवरलैप हो जाती है,

133
00:07:55,296 --> 00:07:59,023
तो सोचें कि इसमें प्रत्येक शब्द क्या है कनवल्शन का वास्तव में मतलब है।

134
00:07:59,023 --> 00:08:03,509
प्रत्येक पुनरावृत्ति पर, आप जो कर रहे हैं वह आपके डेटा के प्रत्येक मान को 1/

135
00:08:03,509 --> 00:08:06,578
5वें से गुणा करना है, और उन सभी को एक साथ जोड़ना है,

136
00:08:06,578 --> 00:08:10,769
जिसका अर्थ है कि आप इस छोटी विंडो के अंदर अपने डेटा का औसत ले रहे हैं।

137
00:08:10,769 --> 00:08:14,563
कुल मिलाकर, यह प्रक्रिया आपको मूल डेटा का एक सुव्यवस्थित संस्करण प्रदान करती है,

138
00:08:14,563 --> 00:08:18,025
और आप इसे संख्याओं की एक अलग छोटी सूची से शुरू करके संशोधित कर सकते हैं,

139
00:08:18,025 --> 00:08:22,057
और जब तक वह छोटी सूची 1 तक जुड़ जाती है, तब भी आप इसे एक गतिशील के रूप में व्याख्या

140
00:08:22,057 --> 00:08:22,816
कर सकते हैं औसत।

141
00:08:22,816 --> 00:08:27,781
यहां दिखाए गए उदाहरण में, वह चलती औसत केंद्रीय मूल्य की ओर अधिक भार देगी।

142
00:08:27,781 --> 00:08:33,200
इसके परिणामस्वरूप डेटा का एक सुचारु संस्करण भी प्राप्त होता है।

143
00:08:33,200 --> 00:08:35,942
यदि आप इसका द्वि-आयामी एनालॉग बनाते हैं, तो यह आपको किसी दी

144
00:08:35,942 --> 00:08:38,594
गई छवि को धुंधला करने के लिए एक मज़ेदार एल्गोरिदम देता है।

145
00:08:38,594 --> 00:08:41,294
और मुझे यह कहना चाहिए कि जो एनिमेशन मैं दिखाने जा रहा हूं,

146
00:08:41,294 --> 00:08:45,439
वे मूल रूप से मेरे द्वारा एमआईटी में जूलिया लैब के साथ एक निश्चित ओपनकोर्सवेयर क्लास के

147
00:08:45,439 --> 00:08:49,024
लिए किए गए व्याख्यानों के एक सेट के हिस्से के लिए बनाए गए कुछ से संशोधित हैं,

148
00:08:49,024 --> 00:08:50,887
जिसमें एक छवि प्रसंस्करण इकाई शामिल थी।

149
00:08:50,887 --> 00:08:53,757
वहां हमने इस सब के पीछे के कोड को समझने के लिए थोड़ा और काम किया,

150
00:08:53,757 --> 00:08:56,452
इसलिए यदि आप उत्सुक हैं तो मैं आपके लिए कुछ लिंक छोड़ दूंगा।

151
00:08:56,452 --> 00:08:58,853
लेकिन इस धुंधले उदाहरण पर ध्यान केंद्रित करते हुए,

152
00:08:58,853 --> 00:09:03,081
जो हो रहा है वह यह है कि मुझे मूल्यों का यह छोटा 3x3 ग्रिड मिला है जो हमारी मूल छवि के

153
00:09:03,081 --> 00:09:06,827
साथ चल रहा है, और यदि हम ज़ूम इन करते हैं, तो उनमें से प्रत्येक मान 1 9वां है,

154
00:09:06,827 --> 00:09:10,863
और मैं क्या कर रहा हूं प्रत्येक पुनरावृत्ति पर उनमें से प्रत्येक मान को उस संबंधित

155
00:09:10,863 --> 00:09:13,312
पिक्सेल से गुणा किया जाता है जिसके ऊपर वह बैठता है।

156
00:09:13,312 --> 00:09:16,927
और निश्चित रूप से कंप्यूटर विज्ञान में हम रंगों को तीन मानों के छोटे वैक्टर

157
00:09:16,927 --> 00:09:20,400
के रूप में सोचते हैं, जो लाल, हरे और नीले घटकों का प्रतिनिधित्व करते हैं।

158
00:09:20,400 --> 00:09:24,295
जब मैं इन सभी छोटे मानों को 1 9वें से गुणा करता हूं और उन्हें एक साथ जोड़ता हूं,

159
00:09:24,295 --> 00:09:26,827
तो यह हमें प्रत्येक रंग चैनल के साथ एक औसत देता है,

160
00:09:26,827 --> 00:09:30,966
और दाईं ओर की छवि के लिए संबंधित पिक्सेल को उस योग के रूप में परिभाषित किया जाता है।

161
00:09:30,966 --> 00:09:34,698
समग्र प्रभाव, जैसा कि हम छवि पर हर एक पिक्सेल के लिए करते हैं,

162
00:09:34,698 --> 00:09:38,730
यह है कि प्रत्येक एक प्रकार का उसके सभी पड़ोसियों में खून बहता है,

163
00:09:38,730 --> 00:09:41,680
जो हमें मूल की तुलना में धुंधला संस्करण देता है।

164
00:09:41,680 --> 00:09:44,647
भाषा में हम कहेंगे कि दाईं ओर की छवि मूल्यों की

165
00:09:44,647 --> 00:09:47,800
एक छोटी ग्रिड के साथ हमारी मूल छवि का एक संयोजन है।

166
00:09:47,800 --> 00:09:51,115
या अधिक तकनीकी रूप से शायद मुझे यह कहना चाहिए कि यह मूल्यों के

167
00:09:51,115 --> 00:09:54,430
उस छोटे ग्रिड के 180 डिग्री घुमाए गए संस्करण के साथ कनवल्शन है।

168
00:09:54,430 --> 00:09:56,740
ऐसा नहीं है कि ग्रिड सममित होने पर यह मायने रखता है,

169
00:09:56,740 --> 00:09:59,362
लेकिन यह ध्यान में रखने योग्य है कि एक कनवल्शन की परिभाषा,

170
00:09:59,362 --> 00:10:01,539
जैसा कि शुद्ध गणित संदर्भ से विरासत में मिली है,

171
00:10:01,539 --> 00:10:05,271
आपको हमेशा उस दूसरे सरणी के चारों ओर फ़्लिप करने के बारे में सोचने के लिए आमंत्रित

172
00:10:05,271 --> 00:10:05,760
करना चाहिए।

173
00:10:05,760 --> 00:10:08,432
यदि हम इसे थोड़ा संशोधित करते हैं तो हम मूल्यों का एक अलग

174
00:10:08,432 --> 00:10:11,059
ग्रिड चुनकर अधिक सुंदर धुंधला प्रभाव प्राप्त कर सकते हैं।

175
00:10:11,059 --> 00:10:15,920
इस मामले में मेरे पास एक छोटा सा 5x5 ग्रिड है, लेकिन अंतर इसके आकार का नहीं है।

176
00:10:15,920 --> 00:10:20,387
यदि हम ज़ूम इन करते हैं तो हम देखते हैं कि बीच का मान किनारों के मान से बहुत बड़ा है,

177
00:10:20,387 --> 00:10:23,803
और यह कहां से आ रहा है, वे सभी एक घंटी वक्र से नमूने लिए गए हैं,

178
00:10:23,803 --> 00:10:26,010
जिसे गाऊसी वितरण के रूप में जाना जाता है।

179
00:10:26,010 --> 00:10:30,638
इस तरह जब हम इन सभी मानों को संबंधित पिक्सेल से गुणा करते हैं जिसके ऊपर वे बैठे हैं,

180
00:10:30,638 --> 00:10:33,943
तो हम उस केंद्रीय पिक्सेल को बहुत अधिक महत्व दे रहे हैं और

181
00:10:33,943 --> 00:10:36,367
किनारे पर मौजूद मानों को बहुत कम दे रहे हैं।

182
00:10:36,367 --> 00:10:40,373
और ठीक पहले की तरह दाईं ओर संबंधित पिक्सेल को इस योग के रूप में परिभाषित किया गया है।

183
00:10:40,373 --> 00:10:43,345
जैसा कि हम इस प्रक्रिया को हर एक पिक्सेल के लिए करते हैं,

184
00:10:43,345 --> 00:10:47,830
यह एक धुंधला प्रभाव देता है जो आपके लेंस को फोकस से बाहर या ऐसा कुछ करने की धारणा को

185
00:10:47,830 --> 00:10:49,760
अधिक प्रामाणिक रूप से अनुकरण करता है।

186
00:10:49,760 --> 00:10:53,474
लेकिन धुंधलापन एकमात्र ऐसी चीज़ नहीं है जो आप इस विचार के साथ कर सकते हैं।

187
00:10:53,474 --> 00:10:56,327
उदाहरण के लिए, मानों के इस छोटे ग्रिड पर एक नज़र डालें,

188
00:10:56,327 --> 00:11:00,633
जिसमें बाईं ओर कुछ सकारात्मक संख्याएँ और दाईं ओर कुछ नकारात्मक संख्याएँ शामिल हैं,

189
00:11:00,633 --> 00:11:03,071
जिन्हें मैं क्रमशः नीले और लाल रंग से रंगूँगा।

190
00:11:03,071 --> 00:11:06,274
यह देखने के लिए कुछ समय लें कि क्या आप अनुमान लगा सकते

191
00:11:06,274 --> 00:11:09,769
हैं और समझ सकते हैं कि इसका अंतिम छवि पर क्या प्रभाव पड़ेगा।

192
00:11:09,769 --> 00:11:13,782
तो इस मामले में मैं छवि को रंगीन के बजाय ग्रेस्केल के रूप में सोचूंगा,

193
00:11:13,782 --> 00:11:18,082
इसलिए प्रत्येक पिक्सेल को तीन के बजाय केवल एक संख्या द्वारा दर्शाया जाएगा।

194
00:11:18,082 --> 00:11:20,472
और ध्यान देने योग्य एक बात यह है कि जैसे ही हम यह

195
00:11:20,472 --> 00:11:23,102
कनवल्शन करते हैं तो नकारात्मक मान प्राप्त करना संभव है।

196
00:11:23,102 --> 00:11:27,433
उदाहरण के लिए, यहां इस बिंदु पर यदि हम ज़ूम इन करते हैं तो हमारे छोटे ग्रिड का बायां आधा

197
00:11:27,433 --> 00:11:31,084
हिस्सा पूरी तरह से काले पिक्सेल के शीर्ष पर बैठता है, जिसका मान शून्य होगा,

198
00:11:31,084 --> 00:11:34,685
लेकिन नकारात्मक मानों का दायां आधा भाग सफेद पिक्सेल के शीर्ष पर बैठता है,

199
00:11:34,685 --> 00:11:36,000
जो कि होगा एक का मूल्य है.

200
00:11:36,000 --> 00:11:39,435
इसलिए जब हम संगत शब्दों को गुणा करते हैं और उन्हें एक साथ जोड़ते हैं तो परिणाम

201
00:11:39,435 --> 00:11:42,741
बहुत नकारात्मक होंगे, और जिस तरह से मैं इसे दाईं ओर की छवि के साथ प्रदर्शित

202
00:11:42,741 --> 00:11:46,046
कर रहा हूं वह नकारात्मक मानों को लाल और सकारात्मक मानों को नीला रंग देना है।

203
00:11:46,046 --> 00:11:50,398
ध्यान देने वाली एक और बात यह है कि जब आप एक पैच पर होते हैं जो सभी समान रंग का होता

204
00:11:50,398 --> 00:11:54,854
है तो सब कुछ शून्य हो जाता है क्योंकि हमारे छोटे ग्रिड में मानों का योग शून्य होता है।

205
00:11:54,854 --> 00:11:58,629
यह पिछले दो उदाहरणों से बहुत अलग है जहां हमारे छोटे ग्रिड का योग एक था,

206
00:11:58,629 --> 00:12:02,990
जो हमें इसे चलती औसत के रूप में व्याख्या करने देता है और इसलिए धुंधला हो जाता है।

207
00:12:02,990 --> 00:12:07,579
कुल मिलाकर यह छोटी सी प्रक्रिया मूल रूप से पता लगाती है कि जब आप बाएं

208
00:12:07,579 --> 00:12:11,315
से दाएं जाते हैं तो पिक्सेल मान में कहां भिन्नता होती है,

209
00:12:11,315 --> 00:12:16,560
और इसलिए यह आपको अपनी छवि से सभी ऊर्ध्वाधर किनारों को लेने का एक तरीका देता है।

210
00:12:16,560 --> 00:12:21,055
और इसी तरह अगर हम उस ग्रिड को चारों ओर घुमाते हैं ताकि जब आप ऊपर से नीचे की

211
00:12:21,055 --> 00:12:24,781
ओर बढ़ें तो यह अलग-अलग हो, यह सभी क्षैतिज किनारों को पकड़ लेगा,

212
00:12:24,781 --> 00:12:29,986
जो कि हमारी छोटी पाई प्राणी छवि के मामले में कुछ सुंदर राक्षसी आँखों में परिणत होता है।

213
00:12:29,986 --> 00:12:32,037
वैसे, इस छोटे ग्रिड को अक्सर कर्नेल कहा जाता है,

214
00:12:32,037 --> 00:12:34,643
और यहां की सुंदरता यह है कि कैसे एक अलग कर्नेल चुनकर आप अलग-

215
00:12:34,643 --> 00:12:36,608
अलग छवि प्रसंस्करण प्रभाव प्राप्त कर सकते हैं,

216
00:12:36,608 --> 00:12:40,197
न केवल आपके किनारे का पता लगाने को धुंधला कर सकते हैं बल्कि तेज करने जैसी चीजें भी

217
00:12:40,197 --> 00:12:40,710
कर सकते हैं।

218
00:12:40,710 --> 00:12:43,760
आपमें से जिन लोगों ने कनवल्शनल न्यूरल नेटवर्क के बारे में सुना है,

219
00:12:43,760 --> 00:12:47,504
उनके लिए विचार यह है कि डेटा का उपयोग करके यह पता लगाया जाए कि सबसे पहले कर्नेल

220
00:12:47,504 --> 00:12:51,618
क्या होना चाहिए, जैसा कि न्यूरल नेटवर्क जो भी पता लगाना चाहता है, उससे निर्धारित होता है।

221
00:12:51,618 --> 00:12:55,378
एक और चीज़ जो शायद मुझे सामने लानी चाहिए वह है आउटपुट की लंबाई।

222
00:12:55,378 --> 00:12:59,468
चलती औसत उदाहरण जैसी किसी चीज़ के लिए आप केवल उन शर्तों के बारे में सोचना

223
00:12:59,468 --> 00:13:02,951
चाहेंगे जब दोनों विंडो पूरी तरह से एक-दूसरे के साथ संरेखित हों,

224
00:13:02,951 --> 00:13:07,760
या छवि प्रसंस्करण उदाहरण में शायद आप चाहते हैं कि अंतिम आउटपुट का आकार मूल के समान हो।

225
00:13:07,760 --> 00:13:10,717
अब एक शुद्ध गणित ऑपरेशन के रूप में कनवल्शन हमेशा एक सरणी उत्पन्न

226
00:13:10,717 --> 00:13:13,356
करता है जो आपके द्वारा शुरू की गई दो सरणी से बड़ी होती है,

227
00:13:13,356 --> 00:13:16,405
कम से कम यह मानते हुए कि उनमें से एक की लंबाई एक के बराबर नहीं है।

228
00:13:16,405 --> 00:13:18,962
बस यह जान लें कि कुछ कंप्यूटर विज्ञान संदर्भों में

229
00:13:18,962 --> 00:13:21,520
आप अक्सर जानबूझकर उस आउटपुट को छोटा करना चाहते हैं।

230
00:13:21,520 --> 00:13:26,803
हाइलाइट करने लायक एक और बात यह है कि कंप्यूटर विज्ञान के संदर्भ में मूल के पार जाने

231
00:13:26,803 --> 00:13:31,773
से पहले उस कर्नेल के चारों ओर फ़्लिप करने की यह धारणा अक्सर वास्तव में अजीब और

232
00:13:31,773 --> 00:13:37,057
अनावश्यक लगती है, लेकिन फिर से ध्यान दें कि यह शुद्ध गणित संदर्भ से विरासत में मिला

233
00:13:37,057 --> 00:13:42,530
है जहां हम जैसे हैं संभावनाओं के साथ देखा जाए तो यह अविश्वसनीय रूप से स्वाभाविक बात है।

234
00:13:42,530 --> 00:13:45,738
और वास्तव में मैं आपको एक और शुद्ध गणित का उदाहरण दिखा सकता

235
00:13:45,738 --> 00:13:49,054
हूं जहां प्रोग्रामर को भी इसकी परवाह करनी चाहिए क्योंकि यह इन

236
00:13:49,054 --> 00:13:52,370
सभी की गणना करने के लिए बहुत तेज़ एल्गोरिदम के द्वार खोलता है।

237
00:13:52,370 --> 00:13:55,929
यहां तेजी से मेरा जो मतलब है उसे स्थापित करने के लिए मुझे वापस जाने दें और कुछ

238
00:13:55,929 --> 00:13:59,579
अजगर को फिर से खींचने दें और मैं दो अलग-अलग अपेक्षाकृत बड़े ऐरे बनाने जा रहा हूं।

239
00:13:59,579 --> 00:14:03,238
प्रत्येक में एक लाख यादृच्छिक तत्व होंगे और मैं numpy

240
00:14:03,238 --> 00:14:07,575
लाइब्रेरी से कन्वोल्व फ़ंक्शन के रनटाइम का आकलन करने जा रहा हूं।

241
00:14:07,575 --> 00:14:10,992
और इस मामले में यह इसे कई अलग-अलग पुनरावृत्तियों के लिए चलाता है,

242
00:14:10,992 --> 00:14:15,619
एक औसत खोजने की कोशिश करता है, और ऐसा लगता है कि इस कंप्यूटर पर कम से कम इसका औसत 4 है।

243
00:14:15,619 --> 00:14:16,321
87 सेकंड.

244
00:14:16,321 --> 00:14:19,674
इसके विपरीत यदि मैं scipy लाइब्रेरी से एक अलग फ़ंक्शन का उपयोग

245
00:14:19,674 --> 00:14:23,027
करता हूं जिसे fftconvolve कहा जाता है जो कि एक ही चीज़ है जिसे

246
00:14:23,027 --> 00:14:26,061
बस अलग तरीके से लागू किया जाता है जिसमें केवल 4 लगते हैं।

247
00:14:26,061 --> 00:14:30,640
औसतन 3 मिलीसेकंड, इसलिए परिमाण में सुधार के तीन क्रम।

248
00:14:30,640 --> 00:14:33,195
और फिर भले ही यह एक अलग नाम के तहत उड़ान भरता है,

249
00:14:33,195 --> 00:14:36,220
यह वही आउटपुट दे रहा है जो अन्य कन्वोल्व फ़ंक्शन देता है,

250
00:14:36,220 --> 00:14:38,880
यह बस इसे चतुर तरीके से करने के लिए कुछ कर रहा है।

251
00:14:38,880 --> 00:14:43,244
याद रखें कि संभाव्यता उदाहरण के साथ मैंने कहा था कि कनवल्शन के

252
00:14:43,244 --> 00:14:47,678
बारे में सोचने का एक और तरीका यह था कि सभी जोड़ीदार उत्पादों की

253
00:14:47,678 --> 00:14:52,528
यह तालिका बनाएं और फिर विकर्णों के साथ उन जोड़ीदार उत्पादों को जोड़ें।

254
00:14:52,528 --> 00:14:56,307
निश्चित रूप से संभाव्यता के लिए कुछ भी विशिष्ट नहीं है, जब भी आप संख्याओं की दो अलग-

255
00:14:56,307 --> 00:14:59,321
अलग सूचियाँ बना रहे हों तो आप इसके बारे में इस तरह से सोच सकते हैं।

256
00:14:59,321 --> 00:15:02,773
सभी जोड़ीवार उत्पादों के साथ इस प्रकार की गुणन तालिका बनाएं और फिर

257
00:15:02,773 --> 00:15:06,381
विकर्ण के साथ प्रत्येक योग आपके अंतिम आउटपुट में से एक से मेल खाता है।

258
00:15:06,381 --> 00:15:09,506
एक संदर्भ जहां यह दृश्य विशेष रूप से स्वाभाविक

259
00:15:09,506 --> 00:15:12,431
है जब आप दो बहुपदों को एक साथ गुणा करते हैं।

260
00:15:12,431 --> 00:15:18,349
उदाहरण के लिए, मैं हमारे पास पहले से मौजूद छोटे ग्रिड को लेता हूं और शीर्ष पदों को 1,

261
00:15:18,349 --> 00:15:23,920
2x और 3x वर्ग से बदल देता हूं और अन्य पदों को 4, 5x और 6x वर्ग से बदल देता हूं।

262
00:15:23,920 --> 00:15:26,043
अब सोचें कि जब हम दो सूचियों के बीच इन सभी अलग-

263
00:15:26,043 --> 00:15:28,664
अलग जोड़ीवार उत्पादों को बना रहे हैं तो इसका क्या मतलब है।

264
00:15:28,664 --> 00:15:33,129
आप जो कर रहे हैं वह अनिवार्य रूप से मेरे द्वारा लिखे गए दो बहुपदों के पूर्ण

265
00:15:33,129 --> 00:15:37,595
उत्पाद का विस्तार करना है और फिर जब आप विकर्ण के साथ जोड़ते हैं जो सभी समान

266
00:15:37,595 --> 00:15:42,178
पदों को एकत्रित करने के अनुरूप होता है जो कि एक बहुपद का विस्तार करने और समान

267
00:15:42,178 --> 00:15:46,937
पदों को एकत्रित करने के लिए बहुत साफ-सुथरा होता है। कनवल्शन के समान ही प्रक्रिया।

268
00:15:46,937 --> 00:15:49,872
लेकिन यह हमें कुछ ऐसा करने की अनुमति देता है जो बहुत

269
00:15:49,872 --> 00:15:52,642
अच्छा है क्योंकि सोचें कि हम यहां क्या कह रहे हैं।

270
00:15:52,642 --> 00:15:56,657
हम कह रहे हैं कि यदि आप दो अलग-अलग फ़ंक्शन लेते हैं और आप उन्हें एक

271
00:15:56,657 --> 00:15:59,609
साथ गुणा करते हैं जो कि एक सरल बिंदुवार ऑपरेशन है,

272
00:15:59,609 --> 00:16:03,978
तो यह वही बात है जैसे कि आपने पहले उनमें से प्रत्येक से गुणांक निकाला था,

273
00:16:03,978 --> 00:16:08,761
यह मानते हुए कि वे बहुपद हैं और फिर उनका कनवल्शन लिया है गुणांकों की दो सूचियाँ।

274
00:16:08,761 --> 00:16:13,009
जो चीज़ इसे इतना दिलचस्प बनाती है वह यह है कि सिद्धांत रूप में कनवल्शन सरल गुणन

275
00:16:13,009 --> 00:16:17,415
की तुलना में बहुत अधिक जटिल लगता है और मेरा मतलब यह नहीं है कि वैचारिक रूप से उनके

276
00:16:17,415 --> 00:16:21,716
बारे में सोचना कठिन है, मेरा मतलब है कि कम्प्यूटेशनल रूप से कनवल्शन को निष्पादित

277
00:16:21,716 --> 00:16:26,070
करने के लिए अधिक चरणों की आवश्यकता होती है। दो अलग-अलग सूचियों का बिंदुवार उत्पाद।

278
00:16:26,070 --> 00:16:29,381
उदाहरण के लिए, मान लें कि मैंने आपको दो बहुत बड़े बहुपद दिए हैं,

279
00:16:29,381 --> 00:16:32,279
मान लीजिए कि प्रत्येक एक सौ अलग-अलग गुणांकों के साथ है,

280
00:16:32,279 --> 00:16:36,212
तो यदि आप जिस तरह से उन्हें गुणा करते हैं, वह इस उत्पाद का विस्तार करना है,

281
00:16:36,212 --> 00:16:40,507
तो आप जानते हैं कि इस संपूर्ण 100 गुणा 100 ग्रिड को जोड़ीवार उत्पादों में भरना है,

282
00:16:40,507 --> 00:16:42,939
जिसके लिए आपको इसकी आवश्यकता होगी। 10,000 अलग-

283
00:16:42,939 --> 00:16:46,820
अलग उत्पाद निष्पादित करें और फिर जब आप विकर्णों के साथ सभी समान शब्द एकत्र

284
00:16:46,820 --> 00:16:49,666
कर रहे हों तो यह लगभग 10,000 परिचालनों का एक और सेट है।

285
00:16:49,666 --> 00:16:53,847
अधिक आम तौर पर भाषा में हम कहेंगे कि एल्गोरिथ्म n वर्ग का O है,

286
00:16:53,847 --> 00:16:59,355
जिसका अर्थ n आकार की दो सूचियों के लिए है, जिस तरह से ऑपरेशन स्केल की संख्या n के

287
00:16:59,355 --> 00:17:00,816
वर्ग के अनुपात में है।

288
00:17:00,816 --> 00:17:04,846
दूसरी ओर, यदि मैं दो बहुपदों के बारे में उनके आउटपुट के संदर्भ में सोचता हूं,

289
00:17:04,846 --> 00:17:08,144
उदाहरण के लिए कुछ मुट्ठी भर इनपुट पर उनके मानों का नमूना लेना,

290
00:17:08,144 --> 00:17:12,018
तो उन्हें गुणा करने के लिए केवल उतने ही ऑपरेशन की आवश्यकता होती है जितनी

291
00:17:12,018 --> 00:17:16,153
नमूनों की संख्या, क्योंकि फिर से यह एक बिंदुवार ऑपरेशन है और बहुपद के साथ आपको

292
00:17:16,153 --> 00:17:20,079
केवल इसकी आवश्यकता होती है गुणांकों को पुनर्प्राप्त करने में सक्षम होने के

293
00:17:20,079 --> 00:17:21,126
लिए बहुत सारे नमूने।

294
00:17:21,126 --> 00:17:24,682
उदाहरण के लिए, दो आउटपुट एक रैखिक बहुपद को विशिष्ट रूप से निर्दिष्ट करने के

295
00:17:24,682 --> 00:17:28,378
लिए पर्याप्त हैं, तीन आउटपुट एक द्विघात बहुपद को विशिष्ट रूप से निर्दिष्ट करने

296
00:17:28,378 --> 00:17:31,841
के लिए पर्याप्त होंगे और सामान्य तौर पर यदि आप n अलग-अलग आउटपुट जानते हैं,

297
00:17:31,841 --> 00:17:35,631
तो यह एक बहुपद को विशिष्ट रूप से निर्दिष्ट करने के लिए पर्याप्त है जिसमें n अलग-

298
00:17:35,631 --> 00:17:37,923
अलग गुणांक हैं या यदि आप चाहें तो हम कर सकते हैं।

299
00:17:37,923 --> 00:17:40,778
समीकरणों की प्रणालियों की भाषा में यह वाक्यांश कल्पना कीजिए,

300
00:17:40,778 --> 00:17:42,930
मैं आपको बताता हूं कि मेरे पास कुछ बहुपद हैं,

301
00:17:42,930 --> 00:17:46,439
लेकिन मैं आपको यह नहीं बताता कि गुणांक क्या हैं, वे आपके लिए एक रहस्य हैं।

302
00:17:46,439 --> 00:17:50,493
हमारे उदाहरण में आप इसे उस उत्पाद के रूप में सोच सकते हैं जिसे हम जानने का प्रयास

303
00:17:50,493 --> 00:17:54,745
कर रहे हैं और फिर मान लीजिए कि मैं कहता हूं कि मैं आपको केवल यह बताऊंगा कि यदि आपने 0,

304
00:17:54,745 --> 00:17:58,552
1, 2 जैसे विभिन्न इनपुट इनपुट किए हैं तो इस बहुपद के आउटपुट क्या होंगे। , 3,

305
00:17:58,552 --> 00:18:02,706
लगातार और आगे और मैं आपको पर्याप्त देता हूं ताकि आपके पास उतने ही समीकरण हों जितने

306
00:18:02,706 --> 00:18:06,760
आपके पास अज्ञात हैं, यह समीकरणों की एक रैखिक प्रणाली भी होती है इसलिए यह अच्छा है

307
00:18:06,760 --> 00:18:11,061
और सिद्धांत रूप में कम से कम यह गुणांक को पुनर्प्राप्त करने के लिए पर्याप्त होना चाहिए।

