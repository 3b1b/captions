1
00:00:00,000 --> 00:00:02,980
有时感觉宇宙只是在捉弄你。

2
00:00:03,340 --> 00:00:07,027
我在屏幕上显示了一系列计算，不用担心，一会 

3
00:00:07,027 --> 00:00:10,380
儿我们将解压并可视化每个计算的真正含义。

4
00:00:10,920 --> 00:00:14,652
我想让你注意的是，序列如何遵循一个非常可预测的、

5
00:00:14,652 --> 00:00:18,540
看似随机的模式，以及每次计算如何恰 好等于 pi。

6
00:00:19,080 --> 00:00:22,253
如果您出于某种原因只是在计算机上随意评估 

7
00:00:22,253 --> 00:00:25,880
这些，您可能会认为这是一种会永远持续下去的模式。

8
00:00:25,880 --> 00:00:27,100
但事实并非如此。

9
00:00:27,400 --> 00:00:30,870
在某个时刻它会停止，并且您得到的值 

10
00:00:30,870 --> 00:00:34,340
不再等于 pi，而是仅略小于 pi。

11
00:00:38,780 --> 00:00:40,940
好吧，让我们深入研究一下这里发生了什么。

12
00:00:41,300 --> 00:00:45,080
今天故事的主角是 x 除以 x 的函数正弦。

13
00:00:45,460 --> 00:00:49,953
这实际上在数学和工程中很常见，它有自己的名字，sinc 

14
00:00:49,953 --> 00:00:54,446
，你可能会想到它的方式是从正常的振荡正弦曲线开始，然后 

15
00:00:54,446 --> 00:00:58,780
当你远离正弦曲线时将其压扁。通过 x 乘以 1 为零。

16
00:00:59,300 --> 00:01:01,446
精明的人可能会问 x 等于 0 

17
00:01:01,446 --> 00:01:04,800
时会发生什么，因为当你将其代入时，它看起来就像是 

18
00:01:04,800 --> 00:01:05,740
0 除以 0。

19
00:01:06,400 --> 00:01:10,661
然后，你们当中更精明的人（也许是刚从微积分课上毕业的人）可 

20
00:01:10,661 --> 00:01:14,780
能会指出，对于越来越接近 0 的值，函数会越来越接近 1。

21
00:01:15,260 --> 00:01:17,951
因此，如果我们简单地将 sinc 函数重新定义为 

22
00:01:17,951 --> 00:01:20,320
0 等于 1，您就会得到一条漂亮的连续曲线。

23
00:01:20,320 --> 00:01:24,649
所有这些都是顺便说一下，因为我们真正关心的是这条曲线

24
00:01:24,649 --> 00:01:29,145
从负无穷大到无 穷大的积分，你可以认为它意味着曲线和 

25
00:01:29,145 --> 00:01:33,474
x 轴之间的面积，或者更准 确地说是有符号的面积，这

26
00:01:33,474 --> 00:01:36,971
意味着您将 x 轴上图形的正数部分所包围 

27
00:01:36,971 --> 00:01:40,634
的所有面积相加，并减去图形的负数部分和 x 

28
00:01:40,634 --> 00:01:42,300
轴所包围的所有部分。

29
00:01:42,740 --> 00:01:46,808
就像我们在开始时看到的那样，碰巧它的计算结果恰好是 

30
00:01:46,808 --> 00:01:50,250
pi，这很好，但 也有点奇怪，并且不完全清楚

31
00:01:50,250 --> 00:01:53,380
如何使用常用的微积分工具来处理这个问题。

32
00:01:53,980 --> 00:01:56,560
在视频的最后，我将分享如何做到这一点的技巧。

33
00:01:56,840 --> 00:02:00,529
继续我打开的序列，下一步是获取 sinc 

34
00:02:00,529 --> 00:02:03,516
函数的副本，在其中插入 x 除以 

35
00:02:03,516 --> 00:02:08,259
3，它基本上看起来像相同的图形，但水平拉伸了 3 倍。

36
00:02:08,900 --> 00:02:12,656
当我们将这两个函数相乘时，我们会得到一个更 

37
00:02:12,656 --> 00:02:16,413
复杂的波，其质量似乎更集中在中间，并且对于 

38
00:02:16,413 --> 00:02:20,000
任何常用函数，您都会期望这完全改变了面积。

39
00:02:20,380 --> 00:02:23,680
您不能只是随机修改这样的积分，并且期望不会发生任何变化。

40
00:02:24,260 --> 00:02:28,780
所以这个结果也等于 pi 已经有点奇怪了，没有任何改变。

41
00:02:29,080 --> 00:02:31,180
这是您应该添加到列表中的另一个谜团。

42
00:02:31,660 --> 00:02:35,209
该序列的下一步是采用 5 倍的 sinc 

43
00:02:35,209 --> 00:02:37,914
函数的更延伸版本，将其乘以我们 

44
00:02:37,914 --> 00:02:41,971
已有的值，然后再次查看整个曲线下方的带符号区域，

45
00:02:41,971 --> 00:02:44,000
该区域再次等于 pi 。

46
00:02:44,860 --> 00:02:46,480
就这样继续下去。

47
00:02:46,580 --> 00:02:48,693
在每次迭代中，我们都会拉伸一个新

48
00:02:48,693 --> 00:02:50,940
的奇数，并将其乘以我们所拥有的值。

49
00:02:51,640 --> 00:02:55,432
您可能会注意到的一件事是，除了输入 x 等于 

50
00:02:55,432 --> 00:02:59,720
0 之外，该函数的每个部分都逐渐乘以小于 1 的值。

51
00:03:00,340 --> 00:03:04,044
所以你会期望，随着序列的进展，事物会被越来越压 

52
00:03:04,044 --> 00:03:07,440
扁，如果有的话，你会期望该区域变得越来越小。

53
00:03:08,360 --> 00:03:12,376
最终确实发生了这样的情况，但奇怪的是它在很

54
00:03:12,376 --> 00:03:17,157
长时间内保持如此稳定， 当然更相关的是，当它在值 

55
00:03:17,157 --> 00:03:20,600
15 处崩溃时，它的破坏量是最小的。

56
00:03:21,180 --> 00:03:24,845
在你认为这是一些数值误差的结果之前，也许是因为

57
00:03:24,845 --> 00:03:28,510
我们正在用浮点 算术做一些事情，如果你更精确地

58
00:03:28,510 --> 00:03:31,059
计算出这个结果，这是最后一个积 

59
00:03:31,059 --> 00:03:35,840
分的精确值，它是一个特定的分数pi 的分子和分母都是荒谬的。

60
00:03:35,980 --> 00:03:38,700
它们的价值都在 4000 亿左右。

61
00:03:40,460 --> 00:03:43,525
因此，这种模式是由一对父子 Jonathan 

62
00:03:43,525 --> 00:03:45,790
和 David B orwein 

63
00:03:45,790 --> 00:03:49,255
在一篇论文中描述的，这非常有趣，他们提到当一位研究 

64
00:03:49,255 --> 00:03:52,453
员同事使用计算机代数系统计算这些积分时，他认为这

65
00:03:52,453 --> 00:03:53,520
必须是某种错误。

66
00:03:53,860 --> 00:03:58,120
但这不是一个错误，而是一个真实的现象，而且比实际情况更奇怪。

67
00:03:58,440 --> 00:04:02,458
如果我们采用所有这些积分并包含另一个因子，x 

68
00:04:02,458 --> 00:04:06,827
的 2 余弦，您会再次认为这完全改变了它们的值， 

69
00:04:06,827 --> 00:04:11,195
您不能只是将新事物随机乘以这样的积分，它仍然等于 

70
00:04:11,195 --> 00:04:15,040
pi更长，直到到达数字 113 时它才中断。

71
00:04:15,200 --> 00:04:19,680
当它破裂时，其程度是你能想象到的最微不足道、绝对微妙的程度。

72
00:04:20,440 --> 00:04:24,080
所以自然的问题是，这里到底发生了什么？

73
00:04:24,380 --> 00:04:27,680
幸运的是，这一切实际上有一个非常令人满意的解释。

74
00:04:28,180 --> 00:04:31,179
我认为我要解决这个问题的方法是向您展示一种现象

75
00:04:31,179 --> 00:04:34,179
，乍一看似乎完全不相关， 但它显示了类似的模式

76
00:04:34,179 --> 00:04:37,440
，其中您的值在达到数字 113 之前一直保持稳定。

77
00:04:37,440 --> 00:04:40,580
当你到达数字 15 时，它就略有下降。

78
00:04:41,300 --> 00:04:44,980
然后，我将展示为什么这种看似无关的现象实际上 

79
00:04:44,980 --> 00:04:48,340
与我们所有的积分表达式相同，但经过了伪装。

80
00:04:49,120 --> 00:04:52,963
因此，将我们的注意力转向看起来完全不同的东西，考虑 

81
00:04:52,963 --> 00:04:56,806
一个我将调用 x 的 rect 的函数，如果输入介 

82
00:04:56,806 --> 00:05:00,649
于负二分之一和二分之一之间，则该函数定义为等于 1 

83
00:05:00,649 --> 00:05:01,980
，否则等于 0 。

84
00:05:02,220 --> 00:05:04,520
所以这个功能基本上就是这个无聊的步骤。

85
00:05:04,520 --> 00:05:09,322
这将是我们定义的函数序列中的第一个，因此我将其称为 x 

86
00:05:09,322 --> 00:05:14,296
的 f1，并且序列中的每个新函数都将是前一个函数的移动平均

87
00:05:14,296 --> 00:05:14,640
值。

88
00:05:15,800 --> 00:05:20,506
例如，定义第二次迭代的方式是采用宽度为三分之一 

89
00:05:20,506 --> 00:05:25,016
的滑动窗口，对于特定的输入 x，当窗口以该输 

90
00:05:25,016 --> 00:05:29,526
入 x 为中心时，我的新函数中的值如下所示， 

91
00:05:29,526 --> 00:05:33,840
被定义为等于该窗口内上面第一个函数的平均值。

92
00:05:33,840 --> 00:05:36,902
例如，当窗口距离左侧足够远时，窗口内的每 

93
00:05:36,902 --> 00:05:39,820
个值都是 0，因此底部的图形显示为 0。

94
00:05:40,280 --> 00:05:43,734
一旦该窗口开始稍微超过平台期，平均值就会 

95
00:05:43,734 --> 00:05:46,860
略大于 0，您可以在下图中看到这一点。

96
00:05:47,280 --> 00:05:51,767
请注意，当正好有一半窗口位于 1 处的稳定状态并且一半位 

97
00:05:51,767 --> 00:05:56,100
于 0 处时，底部图表中的相应值是二分之一，您就明白了。

98
00:05:56,660 --> 00:06:00,445
我希望您关注的重要一点是，当该窗口完全处于上面 

99
00:06:00,445 --> 00:06:03,914
的稳定状态（所有值均为 1）时，平均值也是 

100
00:06:03,914 --> 00:06:07,700
1 ，因此我们在底部的函数上得到了这个稳定状态。

101
00:06:08,300 --> 00:06:11,625
我们将这个底部函数称为 x 的 f2 

102
00:06:11,625 --> 00:06:15,300
， 我希望您考虑的是第二个函数的平台长度。

103
00:06:15,480 --> 00:06:16,440
应该多宽？

104
00:06:17,020 --> 00:06:20,564
如果您想一下，顶部高原的左边缘和底 

105
00:06:20,564 --> 00:06:24,109
部高原的左边缘之间的距离将恰好是窗 

106
00:06:24,109 --> 00:06:27,260
口宽度的一半，即三分之一的一半。

107
00:06:27,640 --> 00:06:32,235
与右侧类似，平台边缘之间的距离是窗口宽度的一半，因此 

108
00:06:32,235 --> 00:06:36,660
总体来说是 1 减去窗口宽度，即 1 减去三分之一。

109
00:06:37,380 --> 00:06:41,208
我们要计算的值，即在崩溃之前看起来稳定一段时 

110
00:06:41,208 --> 00:06:45,037
间的值，是该函数在输入 0 处的值，在这两次 

111
00:06:45,037 --> 00:06:48,700
迭代中，该值都等于 1，因为它位于该平台内。

112
00:06:49,200 --> 00:06:52,331
对于下一次迭代，我们将采用最后一个函数的移 

113
00:06:52,331 --> 00:06:55,320
动平均值，但这次使用宽度为五分之一的窗口。

114
00:06:55,320 --> 00:06:58,604
想想为什么当你在这个窗口中滑动时，你会 

115
00:06:58,604 --> 00:07:01,560
得到前一个函数的平滑版本，这很有趣。

116
00:07:01,640 --> 00:07:06,463
再说一次，我希望您关注的重要事情是，当该窗口完全位于前一 

117
00:07:06,463 --> 00:07:11,120
个函数的稳定区间内时，那么根据定义，底部函数将等于 1。

118
00:07:11,120 --> 00:07:15,364
这次，底部平台的长度将是前一个平台的长度，1 

119
00:07:15,364 --> 00:07:19,240
减去三分之一，再减去窗口宽度，即五分之一。

120
00:07:19,600 --> 00:07:23,461
推理与之前相同，为了从窗口中间位于顶 

121
00:07:23,461 --> 00:07:27,322
部高原的点到整个窗口位于该高原内部的 

122
00:07:27,322 --> 00:07:30,980
位置，是窗口宽度的一半，同样在右侧。

123
00:07:30,980 --> 00:07:34,240
再次强调，当输入为 0 时，要记录 

124
00:07:34,240 --> 00:07:37,320
的值是该函数的输出，即恰好为 1。

125
00:07:38,580 --> 00:07:41,880
下一次迭代是窗口宽度为七分之一的移动平均值。

126
00:07:42,100 --> 00:07:44,040
平台变小了七分之一。

127
00:07:44,500 --> 00:07:48,060
再用 1 over 9 进行一次迭代，平台就会变小相应的量。

128
00:07:48,600 --> 00:07:50,780
随着我们继续前进，高原变得越来越薄。

129
00:07:51,820 --> 00:07:55,263
另外，请注意，在高原之外，该函数非常非常接近 

130
00:07:55,263 --> 00:07:58,856
1，因为它始终是 1 处的高原和相邻函数之间的 

131
00:07:58,856 --> 00:08:02,300
平均值的结果，而相邻函数本身非常非常接近 1。

132
00:08:02,300 --> 00:08:06,505
当我们进入迭代时，所有这些都会中断，此时我们正 

133
00:08:06,505 --> 00:08:10,360
在滑动一个宽度为整个事物的十五分之一的窗口。

134
00:08:10,760 --> 00:08:14,660
到那时，之前的平台实际上比窗口本身还薄。

135
00:08:14,820 --> 00:08:19,680
因此，即使输入 x 等于 0，该移动平均值也必须略小于 1。

136
00:08:19,680 --> 00:08:23,147
这里数字 15 的唯一特别之处在于，当我 

137
00:08:23,147 --> 00:08:26,615
们不断添加这些奇数分数的倒数时，三分之一 

138
00:08:26,615 --> 00:08:30,082
加五分之一加七分之一，等等，一旦我们达到 

139
00:08:30,082 --> 00:08:33,220
十五分之一，这个总和就变成了大于 1。

140
00:08:33,580 --> 00:08:37,440
在我们收缩平台的背景下，从宽度为 1 的平台开 

141
00:08:37,440 --> 00:08:41,140
始，它现在收缩得如此之大，以至于它会完全消失。

142
00:08:41,799 --> 00:08:46,573
关键是，这是我们通过看似随机的过程定义的一系列函数，如 

143
00:08:46,573 --> 00:08:51,175
果我要求您在输入 0 处计算所有这些函数的值，您会得 

144
00:08:51,175 --> 00:08:55,607
到一个最初看起来稳定的模式，它是1 1 1 1 1 

145
00:08:55,607 --> 00:09:00,040
1，但当我们进行第八次迭代时，它略有不足，只是勉强。

146
00:09:00,680 --> 00:09:03,611
这与我们之前看到的积分是类似的，而且我声称不

147
00:09:03,611 --> 00:09:06,542
仅仅是类似，我们在 pi pi pi pi 

148
00:09:06,542 --> 00:09:09,740
pi 处有一个稳定的值，直到它几乎没有达到要求。

149
00:09:10,180 --> 00:09:15,265
碰巧的是，我们的移动平均过程中的这个比 1 略小的 

150
00:09:15,265 --> 00:09:19,960
常数正是我们的积分系列中位于 pi 前面的因子。

151
00:09:20,340 --> 00:09:24,840
因此，这两种情况不仅在性质上相似，而且在数量上也相同。

152
00:09:25,540 --> 00:09:29,169
当涉及到我们在积分内添加 x 项的 2 余弦 

153
00:09:29,169 --> 00:09:32,641
时，这会导致该模式在崩溃之前持续更长时间， 

154
00:09:32,641 --> 00:09:36,271
在类比中，这将对应于相同的设置，但是其中我们 

155
00:09:36,271 --> 00:09:40,690
开始的函数有一个更长的平台，从 x 等于负 1 延伸到 

156
00:09:40,690 --> 00:09:42,900
1，这意味着它的长度是 2。

157
00:09:42,900 --> 00:09:47,022
因此，当您重复执行移动平均过程时，用越来越小的窗 

158
00:09:47,022 --> 00:09:50,980
口来侵蚀它，它们需要更长的时间才能侵蚀整个平台。

159
00:09:51,700 --> 00:09:55,592
更具体地说，相关的计算是问你需要多长时间 

160
00:09:55,592 --> 00:09:59,300
将这些奇数的倒数相加，直到总和大于 2？

161
00:09:59,720 --> 00:10:04,125
事实证明，你必须一直走到数字 113，这对应 

162
00:10:04,125 --> 00:10:08,340
于积分模式一直持续到你达到 113 的事实。

163
00:10:09,099 --> 00:10:12,449
顺便说一下，我要强调的是，这些奇数的倒数，1 个三分之 

164
00:10:12,449 --> 00:10:15,680
一，1 个五分之一，1 个七分之一，并没有什么特别的。

165
00:10:15,680 --> 00:10:18,955
这恰好是鲍温夫妇在论文中强调的价值观序列 

166
00:10:18,955 --> 00:10:21,920
，这使得该序列在书呆子圈子中小有名气。

167
00:10:22,440 --> 00:10:26,584
更一般地说，我们可以将任何正数序列插入到这些 sinc 

168
00:10:26,584 --> 00:10:30,876
函数 中，只要这些数字的总和小于 1，我们的表达式就等于 

169
00:10:30,876 --> 00:10:31,320
pi。

170
00:10:31,700 --> 00:10:35,180
但一旦它们变得大于 1，我们的表达式就会下降到略低于 pi。

171
00:10:35,180 --> 00:10:37,599
如果您相信我认为这些移动平均线有

172
00:10:37,599 --> 00:10:40,020
类比，您就有希望明白其中的原因。

173
00:10:41,840 --> 00:10:47,800
但当然，最紧迫的问题是这两 种情况到底为什么有联系？

174
00:10:48,240 --> 00:10:51,934
从这里开始，这个论证确实引入了两个稍 

175
00:10:51,934 --> 00:10:55,240
微复杂的机制，即傅里叶变换和卷积。

176
00:10:55,860 --> 00:10:59,381
我想要解决这个问题的方法是用这个视频的剩余部 

177
00:10:59,381 --> 00:11:02,903
分让您对争论将如何进行有一个高层次的了解，而 

178
00:11:02,903 --> 00:11:06,424
不必假设您熟悉这两个主题中的任何一个，然后解 

179
00:11:06,424 --> 00:11:09,640
释为什么专用于卷积的视频中的细节是真实的。

180
00:11:10,200 --> 00:11:14,248
特别是所谓的卷积定理，因为它非常美丽，而且它 

181
00:11:14,248 --> 00:11:18,120
的用处远远超出了这个特定的、非常深奥的问题。

182
00:11:21,080 --> 00:11:25,914
首先，我们不关注 x 除以 x 的这个函数正弦值，我们想 

183
00:11:25,914 --> 00:11:30,749
要展示为什么其曲线下方的有符号面积等于 pi，而是进行一 

184
00:11:30,749 --> 00:11:35,584
个简单的替换，将输入 x 替换为 pi 乘以 x ，其效 

185
00:11:35,584 --> 00:11:40,418
果是将图形水平压缩 pi 倍，因此面积缩小 pi 倍，这 

186
00:11:40,418 --> 00:11:44,920
意味着我们的新目标是展示为什么右侧的积分恰好等于 1。

187
00:11:45,500 --> 00:11:49,101
顺便说一句，在某些工程环境中，人们使用名称 si 

188
00:11:49,101 --> 00:11:52,702
nc 来指代内部带有 pi 的函数，因为拥有标准 

189
00:11:52,702 --> 00:11:56,160
化函数通常非常好，这意味着它下面的面积等于 1。

190
00:11:56,160 --> 00:11:59,112
关键是，在右侧显示这个积分与在左侧 

191
00:11:59,112 --> 00:12:01,900
显示积分完全相同，只是变量的变化。

192
00:12:02,580 --> 00:12:06,450
同样，对于我们序列中的所有其他积分，遍历它们中 

193
00:12:06,450 --> 00:12:10,320
的每一个，将 x 替换为 pi 乘以 x，从这 

194
00:12:10,320 --> 00:12:14,190
里开始，所有这些积分不仅类似于移动平均示例，而 

195
00:12:14,190 --> 00:12:17,900
且都其中有两种不同的方法来计算完全相同的事物。

196
00:12:18,500 --> 00:12:21,623
这种联系归结为这样一个事实：这个 sinc 函数 

197
00:12:21,623 --> 00:12:24,746
，或者内部带有 pi 的工程师 sinc 函数， 

198
00:12:24,746 --> 00:12:27,620
与使用所谓的傅里叶变换的 rect 函数相关。

199
00:12:28,260 --> 00:12:32,560
现在，如果您从未听说过傅里叶 变换，您可以采取一些措施。

200
00:12:32,740 --> 00:12:36,415
通常描述的方式是，如果您想将函数分解为一 

201
00:12:36,415 --> 00:12:39,915
堆纯频率的总和，或者在无限函数的情况下 

202
00:12:39,915 --> 00:12:43,415
，一堆纯频率的连续积分，傅里叶变换会告 

203
00:12:43,415 --> 00:12:46,740
诉您所有这些组成部分的所有强度和阶段。

204
00:12:47,120 --> 00:12:50,600
但你真正需要知道的是，它是一种接受一个 

205
00:12:50,600 --> 00:12:53,907
函数并输出一个新函数的东西，你经常认 

206
00:12:53,907 --> 00:12:57,387
为它是用另一种语言重新表述原始函数的信 

207
00:12:57,387 --> 00:13:00,520
息，就像你是从一个新的角度来看待它。

208
00:13:01,320 --> 00:13:04,987
例如，就像我说的，用这种新语言编写的 sinc 函数 

209
00:13:04,987 --> 00:13:08,520
在其中进行傅里叶变换，看起来就像我们的顶帽矩形函数。

210
00:13:09,100 --> 00:13:12,365
反之亦然，顺便说一下，对于关于 y 轴对称的函数 

211
00:13:12,365 --> 00:13:15,500
来说，傅里叶变换是一件好事，它是它自己的逆函数。

212
00:13:15,860 --> 00:13:20,158
实际上，我们需要展示的更普遍的事实是，当您转换 

213
00:13:20,158 --> 00:13:23,920
sinc 函数的拉伸版本时，将其水平拉伸 

214
00:13:23,920 --> 00:13:28,040
k 倍，您得到的是拉伸和压缩版本这个矩形函数。

215
00:13:28,600 --> 00:13:31,705
但当然，所有这些都只是毫无意义的词语和 

216
00:13:31,705 --> 00:13:34,500
术语，除非你在翻译时确实能做点什么。

217
00:13:35,100 --> 00:13:39,293
为什么傅里叶变换对数学如此有用，其背后的真正想 

218
00:13:39,293 --> 00:13:43,487
法是，当您对特定函数进行陈述和问题时，然后查看 

219
00:13:43,487 --> 00:13:47,681
它们相对于该函数的变换版本的对应内容，这些陈述 

220
00:13:47,681 --> 00:13:51,700
和在这种新语言中，问题通常看起来非常非常不同。

221
00:13:51,700 --> 00:13:54,980
有时它会让问题更容易回答。

222
00:13:55,660 --> 00:14:00,216
例如，一个非常好的小事实，我们要展示的事情列表中的 

223
00:14:00,216 --> 00:14:04,597
另一件事是，如果您想计算某个函数从负无穷大到无穷 

224
00:14:04,597 --> 00:14:09,154
大的积分，则整个曲线下的这个带符号区域是相同的就像 

225
00:14:09,154 --> 00:14:13,360
简单地评估该函数在输入零处的傅里叶变换版本一样。

226
00:14:13,820 --> 00:14:16,860
这是一个实际上会直接从定义中跳出来的事实。

227
00:14:16,860 --> 00:14:20,729
它代表了一种更普遍的氛围，即右侧 

228
00:14:20,729 --> 00:14:24,598
傅里叶变换函数的每个单独输出都对 

229
00:14:24,598 --> 00:14:28,240
应于左侧原始函数的某种全局信息。

230
00:14:28,720 --> 00:14:32,916
在我们的具体情况下，这意味着如果你相信我这个 sin 

231
00:14:32,916 --> 00:14:36,957
c 函数和 rect 函数与这样的傅立叶变换相关， 

232
00:14:36,957 --> 00:14:41,154
它解释了积分，否则计算起来非常棘手，因为它说的是所有 

233
00:14:41,154 --> 00:14:45,040
有符号区域与评估 rect 为零相同，后者只是一。

234
00:14:46,140 --> 00:14:49,340
现在，你可以抱怨，这肯定只是把问题隐藏起来。

235
00:14:49,700 --> 00:14:52,253
当然，计算这个傅立叶变换，无论看起来是 

236
00:14:52,253 --> 00:14:54,680
什么样子，都会像计算原始积分一样困难。

237
00:14:55,040 --> 00:14:58,640
但我们的想法是，计算这些傅里叶变换有很多提示和技巧。

238
00:14:59,300 --> 00:15:03,720
此外，当你这样做时，它会告诉你比积分更多的信息。

239
00:15:03,880 --> 00:15:05,860
通过计算你可以得到很多好处。

240
00:15:05,860 --> 00:15:10,348
现在，另一个能够解释我们正在寻找的联系的关键事实是，如 

241
00:15:10,348 --> 00:15:14,836
果你有两个不同的函数并且你取它们的乘积，然后你取该乘积 

242
00:15:14,836 --> 00:15:19,164
的傅立叶变换的总和，那么这将是相同的事情就好像您单独 

243
00:15:19,164 --> 00:15:23,652
对原始函数进行傅里叶变换，然后使用一种新的运算将它们组 

244
00:15:23,652 --> 00:15:27,820
合起来，我们将在下一个视频中讨论这种运算，称为卷积。

245
00:15:28,500 --> 00:15:33,107
现在，尽管卷积有很多需要解释的地方，但结果是，在我们使 

246
00:15:33,107 --> 00:15:37,550
用这些矩形函数的特定情况下，采用卷积看起来就像我们一 

247
00:15:37,550 --> 00:15:41,992
直在讨论的移动平均线之一，结合起来根据我们之前的事实 

248
00:15:41,992 --> 00:15:46,600
，在一个上下文中积分看起来就像在另一个上下文中求值为零 

249
00:15:46,600 --> 00:15:51,043
，如果你相信我，在一个上下文中的乘法对应于这个新操作 

250
00:15:51,043 --> 00:15:55,485
，即卷积，对于我们的示例，您应该将其视为移动平均值， 

251
00:15:55,485 --> 00:16:00,093
即将解释为什么可以根据这些渐进移动平均线来考虑将越来越 

252
00:16:00,093 --> 00:16:04,536
多的这些 sinc 函数相乘，并始终评估为零，这反过 

253
00:16:04,536 --> 00:16:08,978
来又给出了一个非常可爱的直觉，说明为什么您会在最终出 

254
00:16:08,978 --> 00:16:13,586
现问题之前期望如此稳定的值随着高原边缘越来越接近中心而 

255
00:16:13,586 --> 00:16:14,080
下降。

256
00:16:15,540 --> 00:16:18,954
顺便说一句，最后一个关键事实有一个特殊的名称， 

257
00:16:18,954 --> 00:16:21,800
称为卷积定理，我们将再次更深入地讨论它。

258
00:16:22,960 --> 00:16:27,622
我认识到，通 过列出三个神奇的事实并说一切都由此而来来

259
00:16:27,622 --> 00:16:32,284
结束事情可能有 点令人不满意，但希望这能让您稍微了解为

260
00:16:32,284 --> 00:16:37,120
什么像傅立叶变换 这样的强大工具对于棘手的问题如此有用。

261
00:16:37,600 --> 00:16:40,493
这是一种提供视角 转变的系统方

262
00:16:40,493 --> 00:16:43,580
法，使困难问题有时看起来更容易。

263
00:16:44,040 --> 00:16:46,410
如果不出意 外的话，它希望能提供一

264
00:16:46,410 --> 00:16:48,780
些学习卷积定理等美丽事物的动力 。

265
00:16:49,420 --> 00:16:53,600
作为另一个小预告，这个卷积定理的另一个有趣的 

266
00:16:53,600 --> 00:16:57,961
结果是，它为一种算法打开了大门，让你可以非常快 

267
00:16:57,961 --> 00:17:01,960
速地计算两个大数的乘积，比你想象的要快得多。

268
00:17:03,000 --> 00:17:04,599
那么，我们将在下一个视频中见到您。

