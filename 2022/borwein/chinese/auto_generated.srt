1
00:00:00,000 --> 00:00:02,840
有时感觉宇宙只是在捉弄你。

2
00:00:02,840 --> 00:00:06,716
我在屏幕上显示了一系列计算，不用担心，一会

3
00:00:06,716 --> 00:00:10,240
儿我们将解压并可视化每个计算的真正含义。

4
00:00:10,240 --> 00:00:14,236
我想让你注意的是，序列如何遵循一个非常可预测的、

5
00:00:14,236 --> 00:00:18,400
看似随机的模式，以及每次计算如何恰 好等于 pi。

6
00:00:18,400 --> 00:00:21,778
如果您出于某种原因只是在计算机上随意评估

7
00:00:21,778 --> 00:00:25,640
这些，您可能会认为这是一种会永远持续下去的模式。

8
00:00:25,640 --> 00:00:26,901
但事实并非如此。

9
00:00:26,901 --> 00:00:30,790
在某个时刻它会停止，并且您得到的值

10
00:00:30,790 --> 00:00:34,680
不再等于 pi，而是仅略小于 pi。

11
00:00:34,680 --> 00:00:40,880
好吧，让我们深入研究一下这里发生了什么。

12
00:00:40,880 --> 00:00:44,680
今天故事的主角是 x 除以 x 的函数正弦。

13
00:00:44,680 --> 00:00:49,483
这实际上在数学和工程中很常见，它有自己的名字，sinc

14
00:00:49,483 --> 00:00:54,287
，你可能会想到它的方式是从正常的振荡正弦曲线开始，然后

15
00:00:54,287 --> 00:00:58,920
当你远离正弦曲线时将其压扁。通过 x 乘以 1 为零。

16
00:00:58,920 --> 00:01:01,066
精明的人可能会问 x 等于 0

17
00:01:01,066 --> 00:01:04,420
时会发生什么，因为当你将其代入时，它看起来就像是

18
00:01:04,420 --> 00:01:05,360
0 除以 0。

19
00:01:05,360 --> 00:01:10,078
然后，你们当中更精明的人（也许是刚从微积分课上毕业的人）可

20
00:01:10,078 --> 00:01:14,640
能会指出，对于越来越接近 0 的值，函数会越来越接近 1。

21
00:01:14,640 --> 00:01:17,597
因此，如果我们简单地将 sinc 函数重新定义为

22
00:01:17,597 --> 00:01:20,200
0 等于 1，您就会得到一条漂亮的连续曲线。

23
00:01:20,200 --> 00:01:24,493
所有这些都是顺便说一下，因为我们真正关心的是这条曲线

24
00:01:24,493 --> 00:01:28,953
从负无穷大到无 穷大的积分，你可以认为它意味着曲线和

25
00:01:28,953 --> 00:01:33,246
x 轴之间的面积，或者更准 确地说是有符号的面积，这

26
00:01:33,246 --> 00:01:36,715
意味着您将 x 轴上图形的正数部分所包围

27
00:01:36,715 --> 00:01:40,348
的所有面积相加，并减去图形的负数部分和 x

28
00:01:40,348 --> 00:01:42,000
轴所包围的所有部分。

29
00:01:42,000 --> 00:01:46,236
就像我们在开始时看到的那样，碰巧它的计算结果恰好是

30
00:01:46,236 --> 00:01:49,821
pi，这很好，但 也有点奇怪，并且不完全清楚

31
00:01:49,821 --> 00:01:53,080
如何使用常用的微积分工具来处理这个问题。

32
00:01:53,080 --> 00:01:56,320
在视频的最后，我将分享如何做到这一点的技巧。

33
00:01:56,320 --> 00:02:00,158
继续我打开的序列，下一步是获取 sinc

34
00:02:00,158 --> 00:02:03,265
函数的副本，在其中插入 x 除以

35
00:02:03,265 --> 00:02:08,200
3，它基本上看起来像相同的图形，但水平拉伸了 3 倍。

36
00:02:08,200 --> 00:02:12,112
当我们将这两个函数相乘时，我们会得到一个更

37
00:02:12,112 --> 00:02:16,025
复杂的波，其质量似乎更集中在中间，并且对于

38
00:02:16,025 --> 00:02:19,760
任何常用函数，您都会期望这完全改变了面积。

39
00:02:19,760 --> 00:02:23,360
您不能只是随机修改这样的积分，并且期望不会发生任何变化。

40
00:02:23,360 --> 00:02:28,360
所以这个结果也等于 pi 已经有点奇怪了，没有任何改变。

41
00:02:28,360 --> 00:02:31,040
这是您应该添加到列表中的另一个谜团。

42
00:02:31,040 --> 00:02:34,837
该序列的下一步是采用 5 倍的 sinc

43
00:02:34,837 --> 00:02:37,730
函数的更延伸版本，将其乘以我们

44
00:02:37,730 --> 00:02:42,070
已有的值，然后再次查看整个曲线下方的带符号区域，

45
00:02:42,070 --> 00:02:44,240
该区域再次等于 pi 。

46
00:02:44,240 --> 00:02:46,440
就这样继续下去。

47
00:02:46,440 --> 00:02:48,534
在每次迭代中，我们都会拉伸一个新

48
00:02:48,534 --> 00:02:50,760
的奇数，并将其乘以我们所拥有的值。

49
00:02:50,760 --> 00:02:54,909
您可能会注意到的一件事是，除了输入 x 等于

50
00:02:54,909 --> 00:02:59,600
0 之外，该函数的每个部分都逐渐乘以小于 1 的值。

51
00:02:59,600 --> 00:03:03,627
所以你会期望，随着序列的进展，事物会被越来越压

52
00:03:03,627 --> 00:03:07,320
扁，如果有的话，你会期望该区域变得越来越小。

53
00:03:07,320 --> 00:03:11,743
最终确实发生了这样的情况，但奇怪的是它在很

54
00:03:11,743 --> 00:03:17,008
长时间内保持如此稳定， 当然更相关的是，当它在值

55
00:03:17,008 --> 00:03:20,800
15 处崩溃时，它的破坏量是最小的。

56
00:03:20,800 --> 00:03:24,540
在你认为这是一些数值误差的结果之前，也许是因为

57
00:03:24,540 --> 00:03:28,280
我们正在用浮点 算术做一些事情，如果你更精确地

58
00:03:28,280 --> 00:03:30,881
计算出这个结果，这是最后一个积

59
00:03:30,881 --> 00:03:35,760
分的精确值，它是一个特定的分数pi 的分子和分母都是荒谬的。

60
00:03:35,760 --> 00:03:38,600
它们的价值都在 4000 亿左右。

61
00:03:38,600 --> 00:03:41,866
因此，这种模式是由一对父子 Jonathan

62
00:03:41,866 --> 00:03:44,281
和 David B orwein

63
00:03:44,281 --> 00:03:47,974
在一篇论文中描述的，这非常有趣，他们提到当一位研究

64
00:03:47,974 --> 00:03:51,383
员同事使用计算机代数系统计算这些积分时，他认为这

65
00:03:51,383 --> 00:03:52,520
必须是某种错误。

66
00:03:52,520 --> 00:03:57,080
但这不是一个错误，而是一个真实的现象，而且比实际情况更奇怪。

67
00:03:57,080 --> 00:04:01,157
如果我们采用所有这些积分并包含另一个因子，x

68
00:04:01,157 --> 00:04:05,588
的 2 余弦，您会再次认为这完全改变了它们的值，

69
00:04:05,588 --> 00:04:10,020
您不能只是将新事物随机乘以这样的积分，它仍然等于

70
00:04:10,020 --> 00:04:13,920
pi更长，直到到达数字 113 时它才中断。

71
00:04:13,920 --> 00:04:18,680
当它破裂时，其程度是你能想象到的最微不足道、绝对微妙的程度。

72
00:04:18,680 --> 00:04:22,880
所以自然的问题是，这里到底发生了什么？

73
00:04:22,880 --> 00:04:26,560
幸运的是，这一切实际上有一个非常令人满意的解释。

74
00:04:26,560 --> 00:04:30,032
我认为我要解决这个问题的方法是向您展示一种现象

75
00:04:30,032 --> 00:04:33,505
，乍一看似乎完全不相关， 但它显示了类似的模式

76
00:04:33,505 --> 00:04:37,280
，其中您的值在达到数字 113 之前一直保持稳定。

77
00:04:37,280 --> 00:04:41,120
当你到达数字 15 时，它就略有下降。

78
00:04:41,120 --> 00:04:45,218
然后，我将展示为什么这种看似无关的现象实际上

79
00:04:45,218 --> 00:04:48,960
与我们所有的积分表达式相同，但经过了伪装。

80
00:04:48,960 --> 00:04:52,952
因此，将我们的注意力转向看起来完全不同的东西，考虑

81
00:04:52,952 --> 00:04:56,944
一个我将调用 x 的 rect 的函数，如果输入介

82
00:04:56,944 --> 00:05:00,936
于负二分之一和二分之一之间，则该函数定义为等于 1

83
00:05:00,936 --> 00:05:02,317
，否则等于 0 。

84
00:05:02,317 --> 00:05:05,040
所以这个功能基本上就是这个无聊的步骤。

85
00:05:05,040 --> 00:05:10,051
这将是我们定义的函数序列中的第一个，因此我将其称为 x

86
00:05:10,051 --> 00:05:15,242
的 f1，并且序列中的每个新函数都将是前一个函数的移动平均

87
00:05:15,242 --> 00:05:15,600
值。

88
00:05:15,600 --> 00:05:20,420
例如，定义第二次迭代的方式是采用宽度为三分之一

89
00:05:20,420 --> 00:05:25,040
的滑动窗口，对于特定的输入 x，当窗口以该输

90
00:05:25,040 --> 00:05:29,660
入 x 为中心时，我的新函数中的值如下所示，

91
00:05:29,660 --> 00:05:34,080
被定义为等于该窗口内上面第一个函数的平均值。

92
00:05:34,080 --> 00:05:37,194
例如，当窗口距离左侧足够远时，窗口内的每

93
00:05:37,194 --> 00:05:40,160
个值都是 0，因此底部的图形显示为 0。

94
00:05:40,160 --> 00:05:43,814
一旦该窗口开始稍微超过平台期，平均值就会

95
00:05:43,814 --> 00:05:47,120
略大于 0，您可以在下图中看到这一点。

96
00:05:47,120 --> 00:05:51,922
请注意，当正好有一半窗口位于 1 处的稳定状态并且一半位

97
00:05:51,922 --> 00:05:56,560
于 0 处时，底部图表中的相应值是二分之一，您就明白了。

98
00:05:56,560 --> 00:06:00,537
我希望您关注的重要一点是，当该窗口完全处于上面

99
00:06:00,537 --> 00:06:04,182
的稳定状态（所有值均为 1）时，平均值也是

100
00:06:04,182 --> 00:06:08,160
1 ，因此我们在底部的函数上得到了这个稳定状态。

101
00:06:08,160 --> 00:06:11,580
我们将这个底部函数称为 x 的 f2

102
00:06:11,580 --> 00:06:15,360
， 我希望您考虑的是第二个函数的平台长度。

103
00:06:15,360 --> 00:06:16,320
应该多宽？

104
00:06:16,320 --> 00:06:20,224
如果您想一下，顶部高原的左边缘和底

105
00:06:20,224 --> 00:06:24,129
部高原的左边缘之间的距离将恰好是窗

106
00:06:24,129 --> 00:06:27,600
口宽度的一半，即三分之一的一半。

107
00:06:27,600 --> 00:06:32,246
与右侧类似，平台边缘之间的距离是窗口宽度的一半，因此

108
00:06:32,246 --> 00:06:36,720
总体来说是 1 减去窗口宽度，即 1 减去三分之一。

109
00:06:36,720 --> 00:06:40,914
我们要计算的值，即在崩溃之前看起来稳定一段时

110
00:06:40,914 --> 00:06:45,108
间的值，是该函数在输入 0 处的值，在这两次

111
00:06:45,108 --> 00:06:49,120
迭代中，该值都等于 1，因为它位于该平台内。

112
00:06:49,120 --> 00:06:52,558
对于下一次迭代，我们将采用最后一个函数的移

113
00:06:52,558 --> 00:06:55,840
动平均值，但这次使用宽度为五分之一的窗口。

114
00:06:55,840 --> 00:06:59,040
想想为什么当你在这个窗口中滑动时，你会

115
00:06:59,040 --> 00:07:01,920
得到前一个函数的平滑版本，这很有趣。

116
00:07:01,920 --> 00:07:06,722
再说一次，我希望您关注的重要事情是，当该窗口完全位于前一

117
00:07:06,722 --> 00:07:11,360
个函数的稳定区间内时，那么根据定义，底部函数将等于 1。

118
00:07:11,360 --> 00:07:15,625
这次，底部平台的长度将是前一个平台的长度，1

119
00:07:15,625 --> 00:07:19,520
减去三分之一，再减去窗口宽度，即五分之一。

120
00:07:19,520 --> 00:07:23,455
推理与之前相同，为了从窗口中间位于顶

121
00:07:23,455 --> 00:07:27,391
部高原的点到整个窗口位于该高原内部的

122
00:07:27,391 --> 00:07:31,120
位置，是窗口宽度的一半，同样在右侧。

123
00:07:31,120 --> 00:07:34,246
再次强调，当输入为 0 时，要记录

124
00:07:34,246 --> 00:07:37,200
的值是该函数的输出，即恰好为 1。

125
00:07:37,200 --> 00:07:41,840
下一次迭代是窗口宽度为七分之一的移动平均值。

126
00:07:41,840 --> 00:07:44,320
平台变小了七分之一。

127
00:07:44,320 --> 00:07:48,400
再用 1 over 9 进行一次迭代，平台就会变小相应的量。

128
00:07:48,400 --> 00:07:50,720
随着我们继续前进，高原变得越来越薄。

129
00:07:50,720 --> 00:07:54,478
另外，请注意，在高原之外，该函数非常非常接近

130
00:07:54,478 --> 00:07:58,401
1，因为它始终是 1 处的高原和相邻函数之间的

131
00:07:58,401 --> 00:08:02,160
平均值的结果，而相邻函数本身非常非常接近 1。

132
00:08:02,160 --> 00:08:06,166
当我们进入迭代时，所有这些都会中断，此时我们正

133
00:08:06,166 --> 00:08:09,840
在滑动一个宽度为整个事物的十五分之一的窗口。

134
00:08:09,840 --> 00:08:14,400
到那时，之前的平台实际上比窗口本身还薄。

135
00:08:14,400 --> 00:08:20,240
因此，即使输入 x 等于 0，该移动平均值也必须略小于 1。

136
00:08:20,240 --> 00:08:23,640
这里数字 15 的唯一特别之处在于，当我

137
00:08:23,640 --> 00:08:27,041
们不断添加这些奇数分数的倒数时，三分之一

138
00:08:27,041 --> 00:08:30,442
加五分之一加七分之一，等等，一旦我们达到

139
00:08:30,442 --> 00:08:33,520
十五分之一，这个总和就变成了大于 1。

140
00:08:33,520 --> 00:08:37,400
在我们收缩平台的背景下，从宽度为 1 的平台开

141
00:08:37,400 --> 00:08:41,120
始，它现在收缩得如此之大，以至于它会完全消失。

142
00:08:41,120 --> 00:08:46,060
关键是，这是我们通过看似随机的过程定义的一系列函数，如

143
00:08:46,060 --> 00:08:50,824
果我要求您在输入 0 处计算所有这些函数的值，您会得

144
00:08:50,824 --> 00:08:55,412
到一个最初看起来稳定的模式，它是1 1 1 1 1

145
00:08:55,412 --> 00:09:00,000
1，但当我们进行第八次迭代时，它略有不足，只是勉强。

146
00:09:00,000 --> 00:09:03,287
这与我们之前看到的积分是类似的，而且我声称不

147
00:09:03,287 --> 00:09:06,574
仅仅是类似，我们在 pi pi pi pi

148
00:09:06,574 --> 00:09:10,160
pi 处有一个稳定的值，直到它几乎没有达到要求。

149
00:09:10,160 --> 00:09:15,401
碰巧的是，我们的移动平均过程中的这个比 1 略小的

150
00:09:15,401 --> 00:09:20,240
常数正是我们的积分系列中位于 pi 前面的因子。

151
00:09:20,240 --> 00:09:24,720
因此，这两种情况不仅在性质上相似，而且在数量上也相同。

152
00:09:24,720 --> 00:09:28,584
当涉及到我们在积分内添加 x 项的 2 余弦

153
00:09:28,584 --> 00:09:32,280
时，这会导致该模式在崩溃之前持续更长时间，

154
00:09:32,280 --> 00:09:36,144
在类比中，这将对应于相同的设置，但是其中我们

155
00:09:36,144 --> 00:09:40,848
开始的函数有一个更长的平台，从 x 等于负 1 延伸到

156
00:09:40,848 --> 00:09:43,200
1，这意味着它的长度是 2。

157
00:09:43,200 --> 00:09:47,159
因此，当您重复执行移动平均过程时，用越来越小的窗

158
00:09:47,159 --> 00:09:50,960
口来侵蚀它，它们需要更长的时间才能侵蚀整个平台。

159
00:09:50,960 --> 00:09:55,344
更具体地说，相关的计算是问你需要多长时间

160
00:09:55,344 --> 00:09:59,520
将这些奇数的倒数相加，直到总和大于 2？

161
00:09:59,520 --> 00:10:04,058
事实证明，你必须一直走到数字 113，这对应

162
00:10:04,058 --> 00:10:08,400
于积分模式一直持续到你达到 113 的事实。

163
00:10:08,400 --> 00:10:12,024
顺便说一下，我要强调的是，这些奇数的倒数，1 个三分之

164
00:10:12,024 --> 00:10:15,520
一，1 个五分之一，1 个七分之一，并没有什么特别的。

165
00:10:15,520 --> 00:10:19,048
这恰好是鲍温夫妇在论文中强调的价值观序列

166
00:10:19,048 --> 00:10:22,240
，这使得该序列在书呆子圈子中小有名气。

167
00:10:22,240 --> 00:10:26,570
更一般地说，我们可以将任何正数序列插入到这些 sinc

168
00:10:26,570 --> 00:10:31,056
函数 中，只要这些数字的总和小于 1，我们的表达式就等于

169
00:10:31,056 --> 00:10:31,520
pi。

170
00:10:31,520 --> 00:10:35,440
但一旦它们变得大于 1，我们的表达式就会下降到略低于 pi。

171
00:10:35,440 --> 00:10:37,560
如果您相信我认为这些移动平均线有

172
00:10:37,560 --> 00:10:39,680
类比，您就有希望明白其中的原因。

173
00:10:39,680 --> 00:10:46,240
但当然，最紧迫的问题是这两 种情况到底为什么有联系？

174
00:10:46,240 --> 00:10:50,208
从这里开始，这个论证确实引入了两个稍

175
00:10:50,208 --> 00:10:53,760
微复杂的机制，即傅里叶变换和卷积。

176
00:10:53,760 --> 00:10:57,440
我想要解决这个问题的方法是用这个视频的剩余部

177
00:10:57,440 --> 00:11:01,120
分让您对争论将如何进行有一个高层次的了解，而

178
00:11:01,120 --> 00:11:04,800
不必假设您熟悉这两个主题中的任何一个，然后解

179
00:11:04,800 --> 00:11:08,160
释为什么专用于卷积的视频中的细节是真实的。

180
00:11:08,160 --> 00:11:12,289
特别是所谓的卷积定理，因为它非常美丽，而且它

181
00:11:12,289 --> 00:11:16,240
的用处远远超出了这个特定的、非常深奥的问题。

182
00:11:16,240 --> 00:11:21,739
首先，我们不关注 x 除以 x 的这个函数正弦值，我们想

183
00:11:21,739 --> 00:11:27,239
要展示为什么其曲线下方的有符号面积等于 pi，而是进行一

184
00:11:27,239 --> 00:11:32,739
个简单的替换，将输入 x 替换为 pi 乘以 x ，其效

185
00:11:32,739 --> 00:11:38,239
果是将图形水平压缩 pi 倍，因此面积缩小 pi 倍，这

186
00:11:38,239 --> 00:11:43,360
意味着我们的新目标是展示为什么右侧的积分恰好等于 1。

187
00:11:43,360 --> 00:11:47,170
顺便说一句，在某些工程环境中，人们使用名称 si

188
00:11:47,170 --> 00:11:50,981
nc 来指代内部带有 pi 的函数，因为拥有标准

189
00:11:50,981 --> 00:11:54,640
化函数通常非常好，这意味着它下面的面积等于 1。

190
00:11:54,640 --> 00:11:57,602
关键是，在右侧显示这个积分与在左侧

191
00:11:57,602 --> 00:12:00,400
显示积分完全相同，只是变量的变化。

192
00:12:00,400 --> 00:12:04,381
同样，对于我们序列中的所有其他积分，遍历它们中

193
00:12:04,381 --> 00:12:08,362
的每一个，将 x 替换为 pi 乘以 x，从这

194
00:12:08,362 --> 00:12:12,344
里开始，所有这些积分不仅类似于移动平均示例，而

195
00:12:12,344 --> 00:12:16,160
且都其中有两种不同的方法来计算完全相同的事物。

196
00:12:16,160 --> 00:12:19,639
这种联系归结为这样一个事实：这个 sinc 函数

197
00:12:19,639 --> 00:12:23,118
，或者内部带有 pi 的工程师 sinc 函数，

198
00:12:23,118 --> 00:12:26,320
与使用所谓的傅里叶变换的 rect 函数相关。

199
00:12:26,320 --> 00:12:32,560
现在，如果您从未听说过傅里叶 变换，您可以采取一些措施。

200
00:12:32,560 --> 00:12:36,340
通常描述的方式是，如果您想将函数分解为一

201
00:12:36,340 --> 00:12:39,940
堆纯频率的总和，或者在无限函数的情况下

202
00:12:39,940 --> 00:12:43,540
，一堆纯频率的连续积分，傅里叶变换会告

203
00:12:43,540 --> 00:12:46,960
诉您所有这些组成部分的所有强度和阶段。

204
00:12:46,960 --> 00:12:50,471
但你真正需要知道的是，它是一种接受一个

205
00:12:50,471 --> 00:12:53,807
函数并输出一个新函数的东西，你经常认

206
00:12:53,807 --> 00:12:57,319
为它是用另一种语言重新表述原始函数的信

207
00:12:57,319 --> 00:13:00,480
息，就像你是从一个新的角度来看待它。

208
00:13:00,480 --> 00:13:04,759
例如，就像我说的，用这种新语言编写的 sinc 函数

209
00:13:04,759 --> 00:13:08,880
在其中进行傅里叶变换，看起来就像我们的顶帽矩形函数。

210
00:13:08,880 --> 00:13:12,390
反之亦然，顺便说一下，对于关于 y 轴对称的函数

211
00:13:12,390 --> 00:13:15,760
来说，傅里叶变换是一件好事，它是它自己的逆函数。

212
00:13:15,760 --> 00:13:20,221
实际上，我们需要展示的更普遍的事实是，当您转换

213
00:13:20,221 --> 00:13:24,124
sinc 函数的拉伸版本时，将其水平拉伸

214
00:13:24,124 --> 00:13:28,400
k 倍，您得到的是拉伸和压缩版本这个矩形函数。

215
00:13:28,400 --> 00:13:31,810
但当然，所有这些都只是毫无意义的词语和

216
00:13:31,810 --> 00:13:34,880
术语，除非你在翻译时确实能做点什么。

217
00:13:34,880 --> 00:13:39,164
为什么傅里叶变换对数学如此有用，其背后的真正想

218
00:13:39,164 --> 00:13:43,449
法是，当您对特定函数进行陈述和问题时，然后查看

219
00:13:43,449 --> 00:13:47,733
它们相对于该函数的变换版本的对应内容，这些陈述

220
00:13:47,733 --> 00:13:51,840
和在这种新语言中，问题通常看起来非常非常不同。

221
00:13:51,840 --> 00:13:54,880
有时它会让问题更容易回答。

222
00:13:54,880 --> 00:13:59,637
例如，一个非常好的小事实，我们要展示的事情列表中的

223
00:13:59,637 --> 00:14:04,211
另一件事是，如果您想计算某个函数从负无穷大到无穷

224
00:14:04,211 --> 00:14:08,968
大的积分，则整个曲线下的这个带符号区域是相同的就像

225
00:14:08,968 --> 00:14:13,360
简单地评估该函数在输入零处的傅里叶变换版本一样。

226
00:14:13,360 --> 00:14:17,200
这是一个实际上会直接从定义中跳出来的事实。

227
00:14:17,200 --> 00:14:21,062
它代表了一种更普遍的氛围，即右侧

228
00:14:21,062 --> 00:14:24,924
傅里叶变换函数的每个单独输出都对

229
00:14:24,924 --> 00:14:28,560
应于左侧原始函数的某种全局信息。

230
00:14:28,560 --> 00:14:32,797
在我们的具体情况下，这意味着如果你相信我这个 sin

231
00:14:32,797 --> 00:14:36,878
c 函数和 rect 函数与这样的傅立叶变换相关，

232
00:14:36,878 --> 00:14:41,116
它解释了积分，否则计算起来非常棘手，因为它说的是所有

233
00:14:41,116 --> 00:14:45,040
有符号区域与评估 rect 为零相同，后者只是一。

234
00:14:45,040 --> 00:14:48,480
现在，你可以抱怨，这肯定只是把问题隐藏起来。

235
00:14:48,480 --> 00:14:51,392
当然，计算这个傅立叶变换，无论看起来是

236
00:14:51,392 --> 00:14:54,160
什么样子，都会像计算原始积分一样困难。

237
00:14:54,160 --> 00:14:58,480
但我们的想法是，计算这些傅里叶变换有很多提示和技巧。

238
00:14:58,480 --> 00:15:03,040
此外，当你这样做时，它会告诉你比积分更多的信息。

239
00:15:03,040 --> 00:15:05,680
通过计算你可以得到很多好处。

240
00:15:05,680 --> 00:15:10,290
现在，另一个能够解释我们正在寻找的联系的关键事实是，如

241
00:15:10,290 --> 00:15:14,901
果你有两个不同的函数并且你取它们的乘积，然后你取该乘积

242
00:15:14,901 --> 00:15:19,347
的傅立叶变换的总和，那么这将是相同的事情就好像您单独

243
00:15:19,347 --> 00:15:23,958
对原始函数进行傅里叶变换，然后使用一种新的运算将它们组

244
00:15:23,958 --> 00:15:28,240
合起来，我们将在下一个视频中讨论这种运算，称为卷积。

245
00:15:28,240 --> 00:15:32,893
现在，尽管卷积有很多需要解释的地方，但结果是，在我们使

246
00:15:32,893 --> 00:15:37,380
用这些矩形函数的特定情况下，采用卷积看起来就像我们一

247
00:15:37,380 --> 00:15:41,867
直在讨论的移动平均线之一，结合起来根据我们之前的事实

248
00:15:41,867 --> 00:15:46,520
，在一个上下文中积分看起来就像在另一个上下文中求值为零

249
00:15:46,520 --> 00:15:51,007
，如果你相信我，在一个上下文中的乘法对应于这个新操作

250
00:15:51,007 --> 00:15:55,494
，即卷积，对于我们的示例，您应该将其视为移动平均值，

251
00:15:55,494 --> 00:16:00,147
即将解释为什么可以根据这些渐进移动平均线来考虑将越来越

252
00:16:00,147 --> 00:16:04,634
多的这些 sinc 函数相乘，并始终评估为零，这反过

253
00:16:04,634 --> 00:16:09,121
来又给出了一个非常可爱的直觉，说明为什么您会在最终出

254
00:16:09,121 --> 00:16:13,775
现问题之前期望如此稳定的值随着高原边缘越来越接近中心而

255
00:16:13,775 --> 00:16:14,273
下降。

256
00:16:14,273 --> 00:16:18,881
顺便说一句，最后一个关键事实有一个特殊的名称，

257
00:16:18,881 --> 00:16:22,721
称为卷积定理，我们将再次更深入地讨论它。

258
00:16:22,721 --> 00:16:27,635
我认识到，通 过列出三个神奇的事实并说一切都由此而来来

259
00:16:27,635 --> 00:16:32,549
结束事情可能有 点令人不满意，但希望这能让您稍微了解为

260
00:16:32,549 --> 00:16:37,645
什么像傅立叶变换 这样的强大工具对于棘手的问题如此有用。

261
00:16:37,645 --> 00:16:40,534
这是一种提供视角 转变的系统方

262
00:16:40,534 --> 00:16:43,615
法，使困难问题有时看起来更容易。

263
00:16:43,615 --> 00:16:46,271
如果不出意 外的话，它希望能提供一

264
00:16:46,271 --> 00:16:48,928
些学习卷积定理等美丽事物的动力 。

265
00:16:48,928 --> 00:16:53,232
作为另一个小预告，这个卷积定理的另一个有趣的

266
00:16:53,232 --> 00:16:57,723
结果是，它为一种算法打开了大门，让你可以非常快

267
00:16:57,723 --> 00:17:01,840
速地计算两个大数的乘积，比你想象的要快得多。

268
00:17:01,840 --> 00:17:05,840
那么，我们将在下一个视频中见到您。

