1
00:00:00,000 --> 00:00:02,980
有时感觉宇宙只是在捉弄你。

2
00:00:03,340 --> 00:00:06,524
我在屏幕上显示了一系列计算，不用担心，

3
00:00:06,524 --> 00:00:10,380
一会 儿我们将解压并可视化每个计算的真正含义。

4
00:00:10,920 --> 00:00:14,652
我想让你注意的是，序列如何遵循一个非常可预测的、

5
00:00:14,652 --> 00:00:18,540
看似随机的模式，以及每次计算如何恰 好等于 pi。

6
00:00:19,080 --> 00:00:22,706
如果您出于某种原因只是在计算机上随意评估 这些，

7
00:00:22,706 --> 00:00:25,880
您可能会认为这是一种会永远持续下去的模式。

8
00:00:25,880 --> 00:00:27,100
但事实并非如此。

9
00:00:27,400 --> 00:00:32,412
在某个时刻它会停止，并且您得到的值 不再等于 pi，

10
00:00:32,412 --> 00:00:34,340
而是仅略小于 pi。

11
00:00:38,780 --> 00:00:40,940
好吧，让我们深入研究一下这里发生了什么。

12
00:00:41,300 --> 00:00:45,080
今天故事的主角是 x 除以 x 的函数正弦。

13
00:00:45,460 --> 00:00:50,113
这实际上在数学和工程中很常见，它有自己的名字，sinc ，

14
00:00:50,113 --> 00:00:53,965
你可能会想到它的方式是从正常的振荡正弦曲线开始，

15
00:00:53,965 --> 00:00:58,780
然后 当你远离正弦曲线时将其压扁。通过 x 乘以 1 为零。

16
00:00:59,300 --> 00:01:02,385
精明的人可能会问 x 等于 0 时会发生什么，

17
00:01:02,385 --> 00:01:05,740
因为当你将其代入时，它看起来就像是 0 除以 0。

18
00:01:06,400 --> 00:01:10,661
然后，你们当中更精明的人（也许是刚从微积分课上毕业的人）可 

19
00:01:10,661 --> 00:01:14,780
能会指出，对于越来越接近 0 的值，函数会越来越接近 1。

20
00:01:15,260 --> 00:01:17,951
因此，如果我们简单地将 sinc 函数重新定义为 

21
00:01:17,951 --> 00:01:20,320
0 等于 1，您就会得到一条漂亮的连续曲线。

22
00:01:20,320 --> 00:01:24,649
所有这些都是顺便说一下，因为我们真正关心的是这条曲线

23
00:01:24,649 --> 00:01:29,145
从负无穷大到无 穷大的积分，你可以认为它意味着曲线和 

24
00:01:29,145 --> 00:01:33,308
x 轴之间的面积，或者更准 确地说是有符号的面积，

25
00:01:33,308 --> 00:01:38,303
这意味着您将 x 轴上图形的正数部分所包围 的所有面积相加，

26
00:01:38,303 --> 00:01:42,300
并减去图形的负数部分和 x 轴所包围的所有部分。

27
00:01:42,740 --> 00:01:47,277
就像我们在开始时看到的那样，碰巧它的计算结果恰好是 pi，

28
00:01:47,277 --> 00:01:50,720
这很好，但 也有点奇怪，并且不完全清楚如何使

29
00:01:50,720 --> 00:01:53,380
用常用的微积分工具来处理这个问题。

30
00:01:53,980 --> 00:01:56,560
在视频的最后，我将分享如何做到这一点的技巧。

31
00:01:56,840 --> 00:02:01,583
继续我打开的序列，下一步是获取 sinc 函数的副本，

32
00:02:01,583 --> 00:02:06,327
在其中插入 x 除以 3，它基本上看起来像相同的图形，

33
00:02:06,327 --> 00:02:08,259
但水平拉伸了 3 倍。

34
00:02:08,900 --> 00:02:13,510
当我们将这两个函数相乘时，我们会得到一个更 复杂的波，

35
00:02:13,510 --> 00:02:17,609
其质量似乎更集中在中间，并且对于 任何常用函数，

36
00:02:17,609 --> 00:02:20,000
您都会期望这完全改变了面积。

37
00:02:20,380 --> 00:02:23,680
您不能只是随机修改这样的积分，并且期望不会发生任何变化。

38
00:02:24,260 --> 00:02:28,780
所以这个结果也等于 pi 已经有点奇怪了，没有任何改变。

39
00:02:29,080 --> 00:02:31,180
这是您应该添加到列表中的另一个谜团。

40
00:02:31,660 --> 00:02:36,731
该序列的下一步是采用 5 倍的 sinc 函数的更延伸版本，

41
00:02:36,731 --> 00:02:40,788
将其乘以我们 已有的值，然后再次查看整个曲线下方

42
00:02:40,788 --> 00:02:44,000
的带符号区域，该区域再次等于 pi 。

43
00:02:44,860 --> 00:02:46,480
就这样继续下去。

44
00:02:46,580 --> 00:02:49,222
在每次迭代中，我们都会拉伸一个新的奇数，

45
00:02:49,222 --> 00:02:50,940
并将其乘以我们所拥有的值。

46
00:02:51,640 --> 00:02:56,257
您可能会注意到的一件事是，除了输入 x 等于 0 之外，

47
00:02:56,257 --> 00:02:59,720
该函数的每个部分都逐渐乘以小于 1 的值。

48
00:03:00,340 --> 00:03:04,353
所以你会期望，随着序列的进展，事物会被越来越压 扁，

49
00:03:04,353 --> 00:03:07,440
如果有的话，你会期望该区域变得越来越小。

50
00:03:08,360 --> 00:03:12,376
最终确实发生了这样的情况，但奇怪的是它在很

51
00:03:12,376 --> 00:03:16,201
长时间内保持如此稳定， 当然更相关的是，

52
00:03:16,201 --> 00:03:20,600
当它在值 15 处崩溃时，它的破坏量是最小的。

53
00:03:21,180 --> 00:03:24,048
在你认为这是一些数值误差的结果之前，

54
00:03:24,048 --> 00:03:27,394
也许是因为我们正在用浮点 算术做一些事情，

55
00:03:27,394 --> 00:03:32,015
如果你更精确地计算出这个结果，这是最后一个积 分的精确值，

56
00:03:32,015 --> 00:03:35,840
它是一个特定的分数pi 的分子和分母都是荒谬的。

57
00:03:35,980 --> 00:03:38,700
它们的价值都在 4000 亿左右。

58
00:03:40,460 --> 00:03:43,525
因此，这种模式是由一对父子 Jonathan 

59
00:03:43,525 --> 00:03:47,123
和 David B orwein 在一篇论文中描述的，

60
00:03:47,123 --> 00:03:49,255
这非常有趣，他们提到当一位研究 

61
00:03:49,255 --> 00:03:51,920
员同事使用计算机代数系统计算这些积分时，

62
00:03:51,920 --> 00:03:53,520
他认为这必须是某种错误。

63
00:03:53,860 --> 00:03:58,120
但这不是一个错误，而是一个真实的现象，而且比实际情况更奇怪。

64
00:03:58,440 --> 00:04:02,109
如果我们采用所有这些积分并包含另一个因子，

65
00:04:02,109 --> 00:04:06,652
x 的 2 余弦，您会再次认为这完全改变了它们的值，

66
00:04:06,652 --> 00:04:10,147
 您不能只是将新事物随机乘以这样的积分，

67
00:04:10,147 --> 00:04:15,040
它仍然等于 pi更长，直到到达数字 113 时它才中断。

68
00:04:15,200 --> 00:04:19,680
当它破裂时，其程度是你能想象到的最微不足道、绝对微妙的程度。

69
00:04:20,440 --> 00:04:24,080
所以自然的问题是，这里到底发生了什么？

70
00:04:24,380 --> 00:04:27,680
幸运的是，这一切实际上有一个非常令人满意的解释。

71
00:04:28,180 --> 00:04:31,310
我认为我要解决这个问题的方法是向您展示一种现象，

72
00:04:31,310 --> 00:04:34,309
乍一看似乎完全不相关， 但它显示了类似的模式，

73
00:04:34,309 --> 00:04:37,440
其中您的值在达到数字 113 之前一直保持稳定。

74
00:04:37,440 --> 00:04:40,580
当你到达数字 15 时，它就略有下降。

75
00:04:41,300 --> 00:04:44,980
然后，我将展示为什么这种看似无关的现象实际上 

76
00:04:44,980 --> 00:04:48,340
与我们所有的积分表达式相同，但经过了伪装。

77
00:04:49,120 --> 00:04:52,519
因此，将我们的注意力转向看起来完全不同的东西，

78
00:04:52,519 --> 00:04:55,919
考虑 一个我将调用 x 的 rect 的函数，

79
00:04:55,919 --> 00:04:58,875
如果输入介 于负二分之一和二分之一之间，

80
00:04:58,875 --> 00:05:01,980
则该函数定义为等于 1 ，否则等于 0 。

81
00:05:02,220 --> 00:05:04,520
所以这个功能基本上就是这个无聊的步骤。

82
00:05:04,520 --> 00:05:07,607
这将是我们定义的函数序列中的第一个，

83
00:05:07,607 --> 00:05:12,581
因此我将其称为 x 的 f1，并且序列中的每个新函数都将是

84
00:05:12,581 --> 00:05:14,640
前一个函数的移动平均值。

85
00:05:15,800 --> 00:05:21,682
例如，定义第二次迭代的方式是采用宽度为三分之一 的滑动窗口，

86
00:05:21,682 --> 00:05:26,780
对于特定的输入 x，当窗口以该输 入 x 为中心时，

87
00:05:26,780 --> 00:05:31,290
我的新函数中的值如下所示， 被定义为等于该窗口

88
00:05:31,290 --> 00:05:33,840
内上面第一个函数的平均值。

89
00:05:33,840 --> 00:05:37,923
例如，当窗口距离左侧足够远时，窗口内的每 个值都是 0，

90
00:05:37,923 --> 00:05:39,820
因此底部的图形显示为 0。

91
00:05:40,280 --> 00:05:44,721
一旦该窗口开始稍微超过平台期，平均值就会 略大于 0，

92
00:05:44,721 --> 00:05:46,860
您可以在下图中看到这一点。

93
00:05:47,280 --> 00:05:51,767
请注意，当正好有一半窗口位于 1 处的稳定状态并且一半位 

94
00:05:51,767 --> 00:05:56,100
于 0 处时，底部图表中的相应值是二分之一，您就明白了。

95
00:05:56,660 --> 00:06:00,445
我希望您关注的重要一点是，当该窗口完全处于上面 

96
00:06:00,445 --> 00:06:04,388
的稳定状态（所有值均为 1）时，平均值也是 1 ，

97
00:06:04,388 --> 00:06:07,700
因此我们在底部的函数上得到了这个稳定状态。

98
00:06:08,300 --> 00:06:11,800
我们将这个底部函数称为 x 的 f2 ，

99
00:06:11,800 --> 00:06:15,300
 我希望您考虑的是第二个函数的平台长度。

100
00:06:15,480 --> 00:06:16,440
应该多宽？

101
00:06:17,020 --> 00:06:20,564
如果您想一下，顶部高原的左边缘和底 

102
00:06:20,564 --> 00:06:25,487
部高原的左边缘之间的距离将恰好是窗 口宽度的一半，

103
00:06:25,487 --> 00:06:27,260
即三分之一的一半。

104
00:06:27,640 --> 00:06:31,724
与右侧类似，平台边缘之间的距离是窗口宽度的一半，

105
00:06:31,724 --> 00:06:36,660
因此 总体来说是 1 减去窗口宽度，即 1 减去三分之一。

106
00:06:37,380 --> 00:06:41,874
我们要计算的值，即在崩溃之前看起来稳定一段时 间的值，

107
00:06:41,874 --> 00:06:45,703
是该函数在输入 0 处的值，在这两次 迭代中，

108
00:06:45,703 --> 00:06:48,700
该值都等于 1，因为它位于该平台内。

109
00:06:49,200 --> 00:06:53,042
对于下一次迭代，我们将采用最后一个函数的移 动平均值，

110
00:06:53,042 --> 00:06:55,320
但这次使用宽度为五分之一的窗口。

111
00:06:55,320 --> 00:06:58,111
想想为什么当你在这个窗口中滑动时，

112
00:06:58,111 --> 00:07:01,560
你会 得到前一个函数的平滑版本，这很有趣。

113
00:07:01,640 --> 00:07:04,633
再说一次，我希望您关注的重要事情是，

114
00:07:04,633 --> 00:07:09,456
当该窗口完全位于前一 个函数的稳定区间内时，那么根据定义，

115
00:07:09,456 --> 00:07:11,120
底部函数将等于 1。

116
00:07:11,120 --> 00:07:14,995
这次，底部平台的长度将是前一个平台的长度，

117
00:07:14,995 --> 00:07:19,240
1 减去三分之一，再减去窗口宽度，即五分之一。

118
00:07:19,600 --> 00:07:23,461
推理与之前相同，为了从窗口中间位于顶 

119
00:07:23,461 --> 00:07:27,931
部高原的点到整个窗口位于该高原内部的 位置，

120
00:07:27,931 --> 00:07:30,980
是窗口宽度的一半，同样在右侧。

121
00:07:30,980 --> 00:07:36,051
再次强调，当输入为 0 时，要记录 的值是该函数的输出，

122
00:07:36,051 --> 00:07:37,320
即恰好为 1。

123
00:07:38,580 --> 00:07:41,880
下一次迭代是窗口宽度为七分之一的移动平均值。

124
00:07:42,100 --> 00:07:44,040
平台变小了七分之一。

125
00:07:44,500 --> 00:07:48,060
再用 1 over 9 进行一次迭代，平台就会变小相应的量。

126
00:07:48,600 --> 00:07:50,780
随着我们继续前进，高原变得越来越薄。

127
00:07:51,820 --> 00:07:55,562
另外，请注意，在高原之外，该函数非常非常接近 1，

128
00:07:55,562 --> 00:07:59,904
因为它始终是 1 处的高原和相邻函数之间的 平均值的结果，

129
00:07:59,904 --> 00:08:02,300
而相邻函数本身非常非常接近 1。

130
00:08:02,300 --> 00:08:05,453
当我们进入迭代时，所有这些都会中断，

131
00:08:05,453 --> 00:08:10,360
此时我们正 在滑动一个宽度为整个事物的十五分之一的窗口。

132
00:08:10,760 --> 00:08:14,660
到那时，之前的平台实际上比窗口本身还薄。

133
00:08:14,820 --> 00:08:19,680
因此，即使输入 x 等于 0，该移动平均值也必须略小于 1。

134
00:08:19,680 --> 00:08:22,652
这里数字 15 的唯一特别之处在于，

135
00:08:22,652 --> 00:08:25,789
当我 们不断添加这些奇数分数的倒数时，

136
00:08:25,789 --> 00:08:28,926
三分之一 加五分之一加七分之一，等等，

137
00:08:28,926 --> 00:08:33,220
一旦我们达到 十五分之一，这个总和就变成了大于 1。

138
00:08:33,580 --> 00:08:37,762
在我们收缩平台的背景下，从宽度为 1 的平台开 始，

139
00:08:37,762 --> 00:08:41,140
它现在收缩得如此之大，以至于它会完全消失。

140
00:08:41,799 --> 00:08:46,232
关键是，这是我们通过看似随机的过程定义的一系列函数，

141
00:08:46,232 --> 00:08:50,493
如 果我要求您在输入 0 处计算所有这些函数的值，

142
00:08:50,493 --> 00:08:53,562
您会得 到一个最初看起来稳定的模式，

143
00:08:53,562 --> 00:08:58,164
它是1 1 1 1 1 1，但当我们进行第八次迭代时，

144
00:08:58,164 --> 00:09:00,040
它略有不足，只是勉强。

145
00:09:00,680 --> 00:09:02,811
这与我们之前看到的积分是类似的，

146
00:09:02,811 --> 00:09:05,742
而且我声称不仅仅是类似，我们在 pi pi 

147
00:09:05,742 --> 00:09:09,740
pi pi pi 处有一个稳定的值，直到它几乎没有达到要求。

148
00:09:10,180 --> 00:09:15,265
碰巧的是，我们的移动平均过程中的这个比 1 略小的 

149
00:09:15,265 --> 00:09:19,960
常数正是我们的积分系列中位于 pi 前面的因子。

150
00:09:20,340 --> 00:09:24,840
因此，这两种情况不仅在性质上相似，而且在数量上也相同。

151
00:09:25,540 --> 00:09:29,485
当涉及到我们在积分内添加 x 项的 2 余弦 时，

152
00:09:29,485 --> 00:09:33,430
这会导致该模式在崩溃之前持续更长时间， 在类比中，

153
00:09:33,430 --> 00:09:36,271
这将对应于相同的设置，但是其中我们 

154
00:09:36,271 --> 00:09:41,006
开始的函数有一个更长的平台，从 x 等于负 1 延伸到 1，

155
00:09:41,006 --> 00:09:42,900
这意味着它的长度是 2。

156
00:09:42,900 --> 00:09:45,703
因此，当您重复执行移动平均过程时，

157
00:09:45,703 --> 00:09:49,660
用越来越小的窗 口来侵蚀它，它们需要更长的时间才

158
00:09:49,660 --> 00:09:50,980
能侵蚀整个平台。

159
00:09:51,700 --> 00:09:55,592
更具体地说，相关的计算是问你需要多长时间 

160
00:09:55,592 --> 00:09:59,300
将这些奇数的倒数相加，直到总和大于 2？

161
00:09:59,720 --> 00:10:03,359
事实证明，你必须一直走到数字 113，

162
00:10:03,359 --> 00:10:08,340
这对应 于积分模式一直持续到你达到 113 的事实。

163
00:10:09,099 --> 00:10:12,689
顺便说一下，我要强调的是，这些奇数的倒数，1 个三分之 一，

164
00:10:12,689 --> 00:10:15,680
1 个五分之一，1 个七分之一，并没有什么特别的。

165
00:10:15,680 --> 00:10:19,111
这恰好是鲍温夫妇在论文中强调的价值观序列 ，

166
00:10:19,111 --> 00:10:21,920
这使得该序列在书呆子圈子中小有名气。

167
00:10:22,440 --> 00:10:26,584
更一般地说，我们可以将任何正数序列插入到这些 sinc 

168
00:10:26,584 --> 00:10:29,396
函数 中，只要这些数字的总和小于 1，

169
00:10:29,396 --> 00:10:31,320
我们的表达式就等于 pi。

170
00:10:31,700 --> 00:10:35,180
但一旦它们变得大于 1，我们的表达式就会下降到略低于 pi。

171
00:10:35,180 --> 00:10:38,053
如果您相信我认为这些移动平均线有类比，

172
00:10:38,053 --> 00:10:40,020
您就有希望明白其中的原因。

173
00:10:41,840 --> 00:10:47,800
但当然，最紧迫的问题是这两 种情况到底为什么有联系？

174
00:10:48,240 --> 00:10:53,295
从这里开始，这个论证确实引入了两个稍 微复杂的机制，

175
00:10:53,295 --> 00:10:55,240
即傅里叶变换和卷积。

176
00:10:55,860 --> 00:10:59,381
我想要解决这个问题的方法是用这个视频的剩余部 

177
00:10:59,381 --> 00:11:02,596
分让您对争论将如何进行有一个高层次的了解，

178
00:11:02,596 --> 00:11:05,812
而 不必假设您熟悉这两个主题中的任何一个，

179
00:11:05,812 --> 00:11:09,640
然后解 释为什么专用于卷积的视频中的细节是真实的。

180
00:11:10,200 --> 00:11:13,544
特别是所谓的卷积定理，因为它非常美丽，

181
00:11:13,544 --> 00:11:18,120
而且它 的用处远远超出了这个特定的、非常深奥的问题。

182
00:11:21,080 --> 00:11:25,247
首先，我们不关注 x 除以 x 的这个函数正弦值，

183
00:11:25,247 --> 00:11:29,749
我们想 要展示为什么其曲线下方的有符号面积等于 pi，

184
00:11:29,749 --> 00:11:34,583
而是进行一 个简单的替换，将输入 x 替换为 pi 乘以 

185
00:11:34,583 --> 00:11:38,084
x ，其效 果是将图形水平压缩 pi 倍，

186
00:11:38,084 --> 00:11:42,752
因此面积缩小 pi 倍，这 意味着我们的新目标是展示为什

187
00:11:42,752 --> 00:11:44,920
么右侧的积分恰好等于 1。

188
00:11:45,500 --> 00:11:49,101
顺便说一句，在某些工程环境中，人们使用名称 si 

189
00:11:49,101 --> 00:11:51,694
nc 来指代内部带有 pi 的函数，

190
00:11:51,694 --> 00:11:53,999
因为拥有标准 化函数通常非常好，

191
00:11:53,999 --> 00:11:56,160
这意味着它下面的面积等于 1。

192
00:11:56,160 --> 00:12:00,588
关键是，在右侧显示这个积分与在左侧 显示积分完全相同，

193
00:12:00,588 --> 00:12:01,900
只是变量的变化。

194
00:12:02,580 --> 00:12:05,482
同样，对于我们序列中的所有其他积分，

195
00:12:05,482 --> 00:12:09,836
遍历它们中 的每一个，将 x 替换为 pi 乘以 x，

196
00:12:09,836 --> 00:12:13,868
从这 里开始，所有这些积分不仅类似于移动平均示例，

197
00:12:13,868 --> 00:12:17,900
而 且都其中有两种不同的方法来计算完全相同的事物。

198
00:12:18,500 --> 00:12:21,748
这种联系归结为这样一个事实：这个 sinc 函数 ，

199
00:12:21,748 --> 00:12:24,621
或者内部带有 pi 的工程师 sinc 函数，

200
00:12:24,621 --> 00:12:27,620
 与使用所谓的傅里叶变换的 rect 函数相关。

201
00:12:28,260 --> 00:12:32,560
现在，如果您从未听说过傅里叶 变换，您可以采取一些措施。

202
00:12:32,740 --> 00:12:37,814
通常描述的方式是，如果您想将函数分解为一 堆纯频率的总和，

203
00:12:37,814 --> 00:12:42,015
或者在无限函数的情况下 ，一堆纯频率的连续积分，

204
00:12:42,015 --> 00:12:46,740
傅里叶变换会告 诉您所有这些组成部分的所有强度和阶段。

205
00:12:47,120 --> 00:12:50,600
但你真正需要知道的是，它是一种接受一个 

206
00:12:50,600 --> 00:12:53,907
函数并输出一个新函数的东西，你经常认 

207
00:12:53,907 --> 00:12:57,735
为它是用另一种语言重新表述原始函数的信 息，

208
00:12:57,735 --> 00:13:00,520
就像你是从一个新的角度来看待它。

209
00:13:01,320 --> 00:13:04,987
例如，就像我说的，用这种新语言编写的 sinc 函数 

210
00:13:04,987 --> 00:13:08,520
在其中进行傅里叶变换，看起来就像我们的顶帽矩形函数。

211
00:13:09,100 --> 00:13:12,757
反之亦然，顺便说一下，对于关于 y 轴对称的函数 来说，

212
00:13:12,757 --> 00:13:15,500
傅里叶变换是一件好事，它是它自己的逆函数。

213
00:13:15,860 --> 00:13:19,263
实际上，我们需要展示的更普遍的事实是，

214
00:13:19,263 --> 00:13:22,666
当您转换 sinc 函数的拉伸版本时，

215
00:13:22,666 --> 00:13:28,040
将其水平拉伸 k 倍，您得到的是拉伸和压缩版本这个矩形函数。

216
00:13:28,600 --> 00:13:32,171
但当然，所有这些都只是毫无意义的词语和 术语，

217
00:13:32,171 --> 00:13:34,500
除非你在翻译时确实能做点什么。

218
00:13:35,100 --> 00:13:39,817
为什么傅里叶变换对数学如此有用，其背后的真正想 法是，

219
00:13:39,817 --> 00:13:42,613
当您对特定函数进行陈述和问题时，

220
00:13:42,613 --> 00:13:46,807
然后查看 它们相对于该函数的变换版本的对应内容，

221
00:13:46,807 --> 00:13:51,700
这些陈述 和在这种新语言中，问题通常看起来非常非常不同。

222
00:13:51,700 --> 00:13:54,980
有时它会让问题更容易回答。

223
00:13:55,660 --> 00:14:00,216
例如，一个非常好的小事实，我们要展示的事情列表中的 

224
00:14:00,216 --> 00:14:05,473
另一件事是，如果您想计算某个函数从负无穷大到无穷 大的积分，

225
00:14:05,473 --> 00:14:09,154
则整个曲线下的这个带符号区域是相同的就像 

226
00:14:09,154 --> 00:14:13,360
简单地评估该函数在输入零处的傅里叶变换版本一样。

227
00:14:13,820 --> 00:14:16,860
这是一个实际上会直接从定义中跳出来的事实。

228
00:14:16,860 --> 00:14:20,729
它代表了一种更普遍的氛围，即右侧 

229
00:14:20,729 --> 00:14:24,598
傅里叶变换函数的每个单独输出都对 

230
00:14:24,598 --> 00:14:28,240
应于左侧原始函数的某种全局信息。

231
00:14:28,720 --> 00:14:32,916
在我们的具体情况下，这意味着如果你相信我这个 sin 

232
00:14:32,916 --> 00:14:36,802
c 函数和 rect 函数与这样的傅立叶变换相关，

233
00:14:36,802 --> 00:14:39,755
 它解释了积分，否则计算起来非常棘手，

234
00:14:39,755 --> 00:14:44,107
因为它说的是所有 有符号区域与评估 rect 为零相同，

235
00:14:44,107 --> 00:14:45,040
后者只是一。

236
00:14:46,140 --> 00:14:49,340
现在，你可以抱怨，这肯定只是把问题隐藏起来。

237
00:14:49,700 --> 00:14:52,892
当然，计算这个傅立叶变换，无论看起来是 什么样子，

238
00:14:52,892 --> 00:14:54,680
都会像计算原始积分一样困难。

239
00:14:55,040 --> 00:14:58,640
但我们的想法是，计算这些傅里叶变换有很多提示和技巧。

240
00:14:59,300 --> 00:15:03,720
此外，当你这样做时，它会告诉你比积分更多的信息。

241
00:15:03,880 --> 00:15:05,860
通过计算你可以得到很多好处。

242
00:15:05,860 --> 00:15:10,027
现在，另一个能够解释我们正在寻找的联系的关键事实是，

243
00:15:10,027 --> 00:15:13,554
如 果你有两个不同的函数并且你取它们的乘积，

244
00:15:13,554 --> 00:15:16,439
然后你取该乘积 的傅立叶变换的总和，

245
00:15:16,439 --> 00:15:21,248
那么这将是相同的事情就好像您单独 对原始函数进行傅里叶变换，

246
00:15:21,248 --> 00:15:24,293
然后使用一种新的运算将它们组 合起来，

247
00:15:24,293 --> 00:15:27,820
我们将在下一个视频中讨论这种运算，称为卷积。

248
00:15:28,500 --> 00:15:32,284
现在，尽管卷积有很多需要解释的地方，但结果是，

249
00:15:32,284 --> 00:15:35,411
在我们使 用这些矩形函数的特定情况下，

250
00:15:35,411 --> 00:15:39,689
采用卷积看起来就像我们一 直在讨论的移动平均线之一，

251
00:15:39,689 --> 00:15:44,132
结合起来根据我们之前的事实 ，在一个上下文中积分看起来

252
00:15:44,132 --> 00:15:47,916
就像在另一个上下文中求值为零 ，如果你相信我，

253
00:15:47,916 --> 00:15:51,865
在一个上下文中的乘法对应于这个新操作 ，即卷积，

254
00:15:51,865 --> 00:15:55,321
对于我们的示例，您应该将其视为移动平均值，

255
00:15:55,321 --> 00:16:00,093
 即将解释为什么可以根据这些渐进移动平均线来考虑将越来越 

256
00:16:00,093 --> 00:16:03,877
多的这些 sinc 函数相乘，并始终评估为零，

257
00:16:03,877 --> 00:16:07,004
这反过 来又给出了一个非常可爱的直觉，

258
00:16:07,004 --> 00:16:11,447
说明为什么您会在最终出 现问题之前期望如此稳定的值随着

259
00:16:11,447 --> 00:16:14,080
高原边缘越来越接近中心而 下降。

260
00:16:15,540 --> 00:16:18,812
顺便说一句，最后一个关键事实有一个特殊的名称，

261
00:16:18,812 --> 00:16:21,800
 称为卷积定理，我们将再次更深入地讨论它。

262
00:16:22,960 --> 00:16:27,622
我认识到，通 过列出三个神奇的事实并说一切都由此而来来

263
00:16:27,622 --> 00:16:32,284
结束事情可能有 点令人不满意，但希望这能让您稍微了解为

264
00:16:32,284 --> 00:16:37,120
什么像傅立叶变换 这样的强大工具对于棘手的问题如此有用。

265
00:16:37,600 --> 00:16:40,879
这是一种提供视角 转变的系统方法，

266
00:16:40,879 --> 00:16:43,580
使困难问题有时看起来更容易。

267
00:16:44,040 --> 00:16:46,410
如果不出意 外的话，它希望能提供一

268
00:16:46,410 --> 00:16:48,780
些学习卷积定理等美丽事物的动力 。

269
00:16:49,420 --> 00:16:54,326
作为另一个小预告，这个卷积定理的另一个有趣的 结果是，

270
00:16:54,326 --> 00:16:57,961
它为一种算法打开了大门，让你可以非常快 

271
00:16:57,961 --> 00:17:01,960
速地计算两个大数的乘积，比你想象的要快得多。

272
00:17:03,000 --> 00:17:04,599
那么，我们将在下一个视频中见到您。

