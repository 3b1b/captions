1
00:00:00,000 --> 00:00:01,379
時々、宇宙があなたにちょっかいをか

2
00:00:01,379 --> 00:00:02,840
けているように感じることがあります。

3
00:00:02,840 --> 00:00:05,269
画面には一連の計算が表示されていますが、心配

4
00:00:05,269 --> 00:00:07,699
しないでください。すぐ に、それぞれの計算が

5
00:00:07,699 --> 00:00:10,240
実際に何を言っているのかを解いて視覚化します。

6
00:00:10,240 --> 00:00:12,896
注目していただきたいのは、シーケンスが、たとえランダムで

7
00:00:12,896 --> 00:00:15,553
あっても、非常に予測可能なパターンに従っていることと、各

8
00:00:15,553 --> 00:00:18,400
計算がどのようにして pi に等 しくなるかということです。

9
00:00:18,400 --> 00:00:20,813
そして、何らかの理由でこれらをコンピューター

10
00:00:20,813 --> 00:00:23,226
上でただいじって評価していたとしたら、これは

11
00:00:23,226 --> 00:00:25,640
永遠に続くパターンだと思うかもしれません。

12
00:00:25,640 --> 00:00:26,901
しかし、そうではありません。

13
00:00:26,901 --> 00:00:31,467
ある時点で停止し、pi に等しくなるのではなく、pi

14
00:00:31,467 --> 00:00:34,680
よりかろうじて小さい値が得られます。

15
00:00:34,680 --> 00:00:40,880
さて、ここで何が起こっているのかを掘り下げてみましょう。

16
00:00:40,880 --> 00:00:44,680
今日の物語の主人公は、x を x で割った関数の正弦です。

17
00:00:44,680 --> 00:00:48,179
これは実際、数学や工学の分野でよく登場するため、sinc

18
00:00:48,179 --> 00:00:50,472
という独自の名前が付 けられています。

19
00:00:50,472 --> 00:00:53,972
通常の振動正弦曲線から始めて、それから遠ざかるにつれてそれ

20
00:00:53,972 --> 00:00:56,868
を押 しつぶすというような考え方が考えられます。

21
00:00:56,868 --> 00:00:58,920
x に 1 を乗じてゼロにします。

22
00:00:58,920 --> 00:01:00,392
そして、賢明な方は、x が 0

23
00:01:00,392 --> 00:01:02,600
に等しい場合に何が起こるか尋ねるかもしれません。

24
00:01:02,600 --> 00:01:05,360
これを代入すると、0 を 0 で割ったように見えるからです。

25
00:01:05,360 --> 00:01:08,453
そして、皆さんの中でさらに聡明な人、おそらく微積分

26
00:01:08,453 --> 00:01:10,928
の授業を終えたばかりの人 は、値が 0

27
00:01:10,928 --> 00:01:14,640
に近づくほど、関数は 1 に近づくことを指摘できるでしょう。

28
00:01:14,640 --> 00:01:17,132
したがって、単純に sinc 関数を 0 から 1

29
00:01:17,132 --> 00:01:19,912
に等しくなるように再定義すると、素晴らしい連続曲線が得られ

30
00:01:19,912 --> 00:01:20,200
ます。

31
00:01:20,200 --> 00:01:23,742
これらすべては少しずつです。実際に関心があるのは、こ

32
00:01:23,742 --> 00:01:26,876
の曲線の負の無限大から無限大 までの積分です。

33
00:01:26,876 --> 00:01:30,418
これは、曲線と X 軸の間の領域、より正確には符号付

34
00:01:30,418 --> 00:01:33,280
きの領域を 意味すると考えられます。面積。

35
00:01:33,280 --> 00:01:36,686
つまり、X 軸のグラフの正の部分で囲まれたすべて

36
00:01:36,686 --> 00:01:40,228
の面積を加算し、グラフと X 軸の負の部分で囲まれた

37
00:01:40,228 --> 00:01:42,000
すべての部分を減算します。

38
00:01:42,000 --> 00:01:43,931
最初に見たように、これが正確に pi

39
00:01:43,931 --> 00:01:45,761
と評価される場合がたまたまあります。

40
00:01:45,761 --> 00:01:48,404
これは素晴らしいことですが、少し奇 妙でもあります。

41
00:01:48,404 --> 00:01:51,148
通常の微積分ツールを使用してこれにどのようにアプローチ

42
00:01:51,148 --> 00:01:53,080
するかは完全には明らかではありません。

43
00:01:53,080 --> 00:01:56,320
ビデオの終わりの方で、これを行う方法のコツを紹介します。

44
00:01:56,320 --> 00:01:59,095
冒頭で説明したシーケンスを進めて、次のステップは

45
00:01:59,095 --> 00:02:01,427
sinc 関数のコピーを取得することです。

46
00:02:01,427 --> 00:02:03,869
ここで x を 3 で割った値を代入します。

47
00:02:03,869 --> 00:02:06,756
基本的には同じグラフのように見えますが、水平方向に

48
00:02:06,756 --> 00:02:08,200
3 倍に引き伸ばされます。

49
00:02:08,200 --> 00:02:12,140
これら 2 つの関数を掛け合わせると、質量が中央に向かって

50
00:02:12,140 --> 00:02:15,556
集中しているように見える、より複雑な波が得られます。

51
00:02:15,556 --> 00:02:19,365
通常の 関数では、これにより領域が完全に変化すると予想され

52
00:02:19,365 --> 00:02:19,760
ます。

53
00:02:19,760 --> 00:02:21,513
このように積分をランダムに変更して、何

54
00:02:21,513 --> 00:02:23,360
も変わらないと期待することはできません。

55
00:02:23,360 --> 00:02:25,860
したがって、この結果が pi と等しいこと、つま

56
00:02:25,860 --> 00:02:28,360
り何も変わっていないことは、すでに少し奇妙です。

57
00:02:28,360 --> 00:02:31,040
これもリストに追加すべきもう 1 つの謎です。

58
00:02:31,040 --> 00:02:34,057
そして、シーケンスの次のステップでは、sinc

59
00:02:34,057 --> 00:02:37,828
関数のさらに拡張されたバージョンを 5 倍にし、それをすで

60
00:02:37,828 --> 00:02:41,097
に得ている値で乗算し、曲線全体の下の符号付き領域を再

61
00:02:41,097 --> 00:02:44,240
度調べます。これは再び pi に等しくなります。。

62
00:02:44,240 --> 00:02:46,440
そして、このように続きます。

63
00:02:46,440 --> 00:02:48,600
反復のたびに、新しい奇数だけ拡張

64
00:02:48,600 --> 00:02:50,760
し、それを現在の値に乗算します。

65
00:02:50,760 --> 00:02:53,588
気づくかもしれない点の 1 つは、入力 x が

66
00:02:53,588 --> 00:02:56,771
0 に等しい場合を除いて、 この関数のすべての部分が

67
00:02:56,771 --> 00:02:59,600
1 より小さい値で徐々に乗算されていることです。

68
00:02:59,600 --> 00:03:02,134
したがって、シーケンスが進むにつれて、物事が

69
00:03:02,134 --> 00:03:04,669
どんどん押しつぶされて いき、どちらかという

70
00:03:04,669 --> 00:03:07,320
とエリアが小さくなることは予想されるでしょう。

71
00:03:07,320 --> 00:03:10,690
最終的にはまさにそのとおりになりますが、奇妙な

72
00:03:10,690 --> 00:03:14,206
のは、非常に長い間安定したままであり、もちろん

73
00:03:14,206 --> 00:03:17,576
より適切なことに、値 15 でブレイクするとき

74
00:03:17,576 --> 00:03:20,800
も、ほんのわずかな量でブレイクすることです。

75
00:03:20,800 --> 00:03:24,474
そして、これが何らかの数値エラーの結果であると考える前に

76
00:03:24,474 --> 00:03:28,017
、おそらく浮動小数点 演算で何かを行っているためです。

77
00:03:28,017 --> 00:03:30,904
これをより正確に計算すると、最後の積分の正

78
00:03:30,904 --> 00:03:33,922
確な値は次のとおりです。これは特定の分数です。

79
00:03:33,922 --> 00:03:35,760
分子と分母が不合理な円周率。

80
00:03:35,760 --> 00:03:38,600
どちらも約4000億です。

81
00:03:38,600 --> 00:03:40,462
このパターンは、ジョナサンとデビッド

82
00:03:40,462 --> 00:03:42,913
ボーワインの父子ペアによる論文で説明されています。

83
00:03:42,913 --> 00:03:45,658
これは 非常に興味深いもので、研究仲間がコンピュータ代数

84
00:03:45,658 --> 00:03:48,010
システムを使用してこれらの積分を計算していたと

85
00:03:48,010 --> 00:03:50,755
き、これは次のとおりである必要があると仮定したことについ

86
00:03:50,755 --> 00:03:52,520
て彼らが言及しました。ある種のバグ。

87
00:03:52,520 --> 00:03:54,800
しかし、これはバグではなく、実際の現象で

88
00:03:54,800 --> 00:03:57,080
あり、実際にはそれよりも奇妙になります。

89
00:03:57,080 --> 00:04:00,354
これらすべての積分を取得し、さらに別の係数 x の 2

90
00:04:00,354 --> 00:04:03,628
コサインを含める と、やはり値が完全に変わると思われるで

91
00:04:03,628 --> 00:04:05,616
しょうが、このように新しいものを

92
00:04:05,616 --> 00:04:08,189
ランダムに積分して積分することはできません。

93
00:04:08,189 --> 00:04:10,411
ずっと pi と等しくなり 続けます。

94
00:04:10,411 --> 00:04:13,920
それよりも長くなり、113 番に到達するまで中断されません。

95
00:04:13,920 --> 00:04:16,235
そして、それが壊れるときは、想像でき

96
00:04:16,235 --> 00:04:18,680
るほどわずかで、まったく微妙な量です。

97
00:04:18,680 --> 00:04:20,720
そこで自然な疑問は、いったいここで

98
00:04:20,720 --> 00:04:22,880
何が起こっているのかということです。

99
00:04:22,880 --> 00:04:24,720
そして幸運なことに、これらすべてにつ

100
00:04:24,720 --> 00:04:26,560
いて実際に満足のいく説明があります。

101
00:04:26,560 --> 00:04:30,133
これについて私が考えている方法は、最初はまったく関係がない

102
00:04:30,133 --> 00:04:33,213
ように見えますが、同様のパタ ーンを示し、113

103
00:04:33,213 --> 00:04:36,787
という数字に到達するまで値が非常に安定している現象を示すこ

104
00:04:36,787 --> 00:04:37,280
とです。

105
00:04:37,280 --> 00:04:39,138
15 という数字に到達すると、

106
00:04:39,138 --> 00:04:41,120
ほんのわずかな量だけ変化します。

107
00:04:41,120 --> 00:04:45,185
そしてその後、この一見無関係に見える現象が隠れてすべて

108
00:04:45,185 --> 00:04:48,960
の積分式と同じであるが、隠れている理由を説明します。

109
00:04:48,960 --> 00:04:52,188
そこで、まったく違うように見えることに注目して、rect

110
00:04:52,188 --> 00:04:55,082
of x を呼 び出す関数について考えてみましょう。

111
00:04:55,082 --> 00:04:57,531
この関数は、入力が負の 1/2 と 1/2

112
00:04:57,531 --> 00:05:00,536
の間にある場合は 1 に等しく、それ以外の場合は 0

113
00:05:00,536 --> 00:05:02,317
に等し いと定義されています。。

114
00:05:02,317 --> 00:05:05,040
基本的に、関数はこの退屈なステップです。

115
00:05:05,040 --> 00:05:09,017
これは、定義する一連の関数の最初のものになるため、これを

116
00:05:09,017 --> 00:05:12,445
f1 of x と 呼びます。シーケンス内の各新し

117
00:05:12,445 --> 00:05:15,600
い関数は、前の関数の一種の移動平均になります。

118
00:05:15,600 --> 00:05:18,798
たとえば、この 2 回目の反復を定義する方法は、幅が

119
00:05:18,798 --> 00:05:21,286
3 分の 1 であるこの スライディング

120
00:05:21,286 --> 00:05:23,418
ウィンドウを取得し、特定の入力 x

121
00:05:23,418 --> 00:05:25,669
に対して、ウィンドウがその 入力 x

122
00:05:25,669 --> 00:05:28,749
の中心にあるとき、以下に示す新しい関数の値を取得する

123
00:05:28,749 --> 00:05:31,829
ことです。, は、そのウィンドウ内で上の最初の関数の

124
00:05:31,829 --> 00:05:34,080
平均値と等しくなるように定義されます。

125
00:05:34,080 --> 00:05:36,041
たとえば、ウィンドウが十分に左にある場合

126
00:05:36,041 --> 00:05:37,806
、ウィンドウ内のすべて の値は 0

127
00:05:37,806 --> 00:05:40,160
になるため、下のグラフには 0 が表示されます。

128
00:05:40,160 --> 00:05:43,760
そのウィンドウがプラトーを少し超え始めるとすぐに、平均値は

129
00:05:43,760 --> 00:05:47,120
0 より少し大きくなり、以下のグラフでそれがわかります。

130
00:05:47,120 --> 00:05:49,540
そして、ウィンドウのちょうど半分が 1

131
00:05:49,540 --> 00:05:51,961
のプラトーを超え、その半分が 0 にな

132
00:05:51,961 --> 00:05:54,744
ると、下のグラフの対応する値が 2 分の 1

133
00:05:54,744 --> 00:05:56,560
になり、ポイントがわかります。

134
00:05:56,560 --> 00:06:00,606
注目していただきたい重要な点は、ウィンドウが完全に上のプラ

135
00:06:00,606 --> 00:06:04,383
トーにあり、すべての値が 1 である場合、平均値も 1

136
00:06:04,383 --> 00:06:08,160
になるため、下部の関数でこのプラトーが得られることです。

137
00:06:08,160 --> 00:06:11,210
この一番下の関数を x の f2 と呼びましょう。

138
00:06:11,210 --> 00:06:13,407
考えてい ただきたいのは、その 2

139
00:06:13,407 --> 00:06:15,360
番目の関数のプラトーの長さです。

140
00:06:15,360 --> 00:06:16,320
どのくらいの幅にすればよいでしょうか？

141
00:06:16,320 --> 00:06:20,135
少し考えてみると、上の台地の左端と下の台地の

142
00:06:20,135 --> 00:06:23,950
左端の間の距離は、ウィンドウの幅のちょうど半

143
00:06:23,950 --> 00:06:27,600
分、つまり 3 分の 1 の半分になります。

144
00:06:27,600 --> 00:06:30,640
同様に右側では、プラトーのエッジ間の距離はウィンドウ幅の半分

145
00:06:30,640 --> 00:06:33,680
であるため、全体としては 1 からそのウィンドウ幅を引いたも

146
00:06:33,680 --> 00:06:36,720
の、つまり 1 から 3 分の 1 を引いたものになります。

147
00:06:36,720 --> 00:06:39,820
これから計算する値、つまり壊れるまでしばらく安定

148
00:06:39,820 --> 00:06:43,695
しているように見 える値は、入力 0 でのこの関数の値です。

149
00:06:43,695 --> 00:06:46,795
この関数の値は、プラ トー内にあるため、これらの

150
00:06:46,795 --> 00:06:49,120
反復の両方で 1 に等しくなります。

151
00:06:49,120 --> 00:06:52,609
次の反復では、最後の関数の移動平均を取得しますが、今

152
00:06:52,609 --> 00:06:55,840
回は幅が 5 分の 1 のウィンドウを使用します。

153
00:06:55,840 --> 00:06:58,935
このウィンドウをスライドすると、前の関数の滑らかなバー

154
00:06:58,935 --> 00:07:01,920
ジョンが得られる理由を考えるのは、ちょっと楽しいです。

155
00:07:01,920 --> 00:07:05,066
繰り返しになりますが、注目していただきたい重要な点は、

156
00:07:05,066 --> 00:07:08,213
そのウィンドウが完全に前の 関数のプラトー内にある場合

157
00:07:08,213 --> 00:07:11,360
、定義上、一番下の関数が 1 に等しくなる仕組みです。

158
00:07:11,360 --> 00:07:13,971
今回は、下部の台地の長さは、前の台地の長さから

159
00:07:13,971 --> 00:07:16,691
1 から 3 分の 1 を 引いたものから、ウィン

160
00:07:16,691 --> 00:07:19,520
ドウの幅から 5 分の 1 を引いたものになります。

161
00:07:19,520 --> 00:07:23,480
推論は前と同じで、ウィンドウの中央が上部の台地にある点

162
00:07:23,480 --> 00:07:27,441
から、ウィンドウ全体がその台地の内側にあり、ウィンドウ

163
00:07:27,441 --> 00:07:31,120
の幅の半分で、同様に右側にある場所まで移動します。。

164
00:07:31,120 --> 00:07:34,268
もう一度言いますが、記録する値は、入力が 0 の場合のこ

165
00:07:34,268 --> 00:07:37,200
の関数の出力であり、この場合も正確に 1 になります。

166
00:07:37,200 --> 00:07:39,594
次の反復は、ウィンドウ幅が 7

167
00:07:39,594 --> 00:07:41,840
分の 1 である移動平均です。

168
00:07:41,840 --> 00:07:44,320
プラトーは 1 対 7 だけ小さくなります。

169
00:07:44,320 --> 00:07:46,304
1 対 9 でもう 1 回反復すると

170
00:07:46,304 --> 00:07:48,400
、プラトーはその分だけ小さくなります。

171
00:07:48,400 --> 00:07:50,720
さらに進んでいくと、プラトーはどんどん薄くなっていきます。

172
00:07:50,720 --> 00:07:53,274
また、プラトーのすぐ外側で、関数が実際に 1

173
00:07:53,274 --> 00:07:55,495
に非常に近いことにも注 目してください。

174
00:07:55,495 --> 00:07:58,494
これは、常に 1 のプラトーと隣接するプラトーとの間

175
00:07:58,494 --> 00:08:00,938
の平均の結果であり、それら自体が実際に 1

176
00:08:00,938 --> 00:08:02,160
に非常に近いからです。

177
00:08:02,160 --> 00:08:06,065
このすべてが中断されるのは、幅が 15 分の 1 のウィン

178
00:08:06,065 --> 00:08:09,840
ドウを全体にわたってスライドさせる反復に到達したときです。

179
00:08:09,840 --> 00:08:12,120
この時点で、前のプラトーは実際には

180
00:08:12,120 --> 00:08:14,400
ウィンドウ自体よりも薄くなります。

181
00:08:14,400 --> 00:08:17,787
したがって、入力 x が 0 であっても、この移動平均は

182
00:08:17,787 --> 00:08:20,240
1 よりわずかに小さくなければなりません。

183
00:08:20,240 --> 00:08:23,704
ここでの 15 という数字の唯一の特別な点は、これらの奇数

184
00:08:23,704 --> 00:08:26,822
の分数の逆数、3 分の 1 と 5 分の 1 と 7

185
00:08:26,822 --> 00:08:29,940
分 の 1 を繰り返し加算し続けると、15 分の 1

186
00:08:29,940 --> 00:08:32,711
に達す るとその合計が大きくなるということです。

187
00:08:32,711 --> 00:08:33,520
1より大きい。

188
00:08:33,520 --> 00:08:36,510
そして、縮小するプラトーのコンテキストでは、幅

189
00:08:36,510 --> 00:08:39,001
1 のプラト ーから始まり、現在は完全に

190
00:08:39,001 --> 00:08:41,120
消えてしまうほどに縮小しています。

191
00:08:41,120 --> 00:08:44,819
重要なのは、これを一見ランダムな手順で定義した関数のシーケ

192
00:08:44,819 --> 00:08:47,881
ンスとして、これ らすべての関数の値を入力 0

193
00:08:47,881 --> 00:08:50,815
で計算するように依頼すると、最初は安定してい

194
00:08:50,815 --> 00:08:53,876
るように見えるパターンが得られるということです。

195
00:08:53,876 --> 00:08:56,172
1 1 1 1 1 1 ですが、8

196
00:08:56,172 --> 00:09:00,000
回目の反復に到達するまでに、わずかに、かろうじて不足します。

197
00:09:00,000 --> 00:09:02,413
これは、pi pi pi pi pi

198
00:09:02,413 --> 00:09:05,207
で安定した値が、ぎりぎり下回るまで安定した

199
00:09:05,207 --> 00:09:08,509
値を示す、前に見た積分に似ていますが、似ているだけで

200
00:09:08,509 --> 00:09:10,160
はない、と私は主張します。

201
00:09:10,160 --> 00:09:13,421
そして偶然にも、移動平均プロセスで得られた

202
00:09:13,421 --> 00:09:16,682
1 よりわずかに小さいこ の定数は、まさに一

203
00:09:16,682 --> 00:09:20,240
連の積分において pi の前に位置する係数です。

204
00:09:20,240 --> 00:09:22,416
したがって、2 つの状況は質的に似

205
00:09:22,416 --> 00:09:24,720
ているだけでなく、量的にも同じです。

206
00:09:24,720 --> 00:09:28,575
そして、積分値の中に x 項の 2 コサインを追加すると

207
00:09:28,575 --> 00:09:32,165
、パターンが破綻するまでずっと長く続くことになります。

208
00:09:32,165 --> 00:09:36,020
類推すると、これは同じセットアップに相当しますが、最初の

209
00:09:36,020 --> 00:09:39,743
関数にはさらに長いプラトーがあり、x が負の 1 から

210
00:09:39,743 --> 00:09:43,200
1 まで伸びています。つまり、その長さは 2 です。

211
00:09:43,200 --> 00:09:45,751
したがって、この繰り返しの移動平均プロセスを実行

212
00:09:45,751 --> 00:09:48,302
して、ウィンドウをどんど ん小さくしていき、プラ

213
00:09:48,302 --> 00:09:50,960
トー全体に食い込むまでにかなりの時間がかかります。

214
00:09:50,960 --> 00:09:54,681
より具体的には、関連する計算は、これらの奇数の逆数を合計が

215
00:09:54,681 --> 00:09:57,535
2 より 大きくなるまでどれくらいの時間加算す

216
00:09:57,535 --> 00:09:59,520
る必要があるかを尋ねることです。

217
00:09:59,520 --> 00:10:02,408
そして、113 という数字に到達するまで行かなければな

218
00:10:02,408 --> 00:10:05,297
らないことがわかりました。こ れは、そこにある積分パタ

219
00:10:05,297 --> 00:10:08,400
ーンが 113 に到達するまで続くという事実に対応します。

220
00:10:08,400 --> 00:10:12,091
ところで、これらの奇数の逆数、1/3、1/1、1/5、

221
00:10:12,091 --> 00:10:15,520
1 には特別なことは何もないことを強調しておきます。

222
00:10:15,520 --> 00:10:19,004
それはたまたま、ボーワイン夫妻が論文で強調した一連の値

223
00:10:19,004 --> 00:10:22,240
であり、その一連がオタク界隈で少し有名になったのだ。

224
00:10:22,240 --> 00:10:24,302
より一般的には、これらの sinc

225
00:10:24,302 --> 00:10:26,937
関数に任意の正の数値シーケンスを挿入すること

226
00:10:26,937 --> 00:10:30,145
ができ、それらの数値の合計が 1 未満である限り、式は

227
00:10:30,145 --> 00:10:31,520
pi と等しくなります。

228
00:10:31,520 --> 00:10:34,202
しかし、それらが 1 より大きくなるとすぐに、式は

229
00:10:34,202 --> 00:10:35,440
pi を少し下回ります。

230
00:10:35,440 --> 00:10:37,510
これらの移動平均と類似点があると私が信じて

231
00:10:37,510 --> 00:10:39,680
いるのであれば、その理由が分かると思います。

232
00:10:39,680 --> 00:10:43,145
しかし、もちろん、燃えるような疑問は、いったいなぜこの

233
00:10:43,145 --> 00:10:46,240
2 つの状況が相互に関係があるのかということです。

234
00:10:46,240 --> 00:10:50,163
ここから、この議論には、フーリエ変換と畳み込み

235
00:10:50,163 --> 00:10:53,760
という 2 つの少し重い機構が導入されます。

236
00:10:53,760 --> 00:10:56,640
これについて私が説明したいのは、このビデオの残りの部

237
00:10:56,640 --> 00:10:59,520
分を費やして 、これら 2 つのトピックのいずれかに

238
00:10:59,520 --> 00:11:02,400
精通しているとは必ずしも想 定せずに、議論がどのよう

239
00:11:02,400 --> 00:11:05,501
に進むかについての概要を理解してから説明 することです。

240
00:11:05,501 --> 00:11:08,160
畳み込みに特化したビデオで詳細が真実である理由。

241
00:11:08,160 --> 00:11:12,344
特に、畳み込み定理と呼ばれるものは、信じられないほど美し

242
00:11:12,344 --> 00:11:16,240
く、この特定の非常に難解な質問を超えて役立つためです。

243
00:11:16,240 --> 00:11:18,718
まず、この関数の正弦 x を x

244
00:11:18,718 --> 00:11:23,092
で除算することに焦点を当て、その曲線の下 の符号付き領域が

245
00:11:23,092 --> 00:11:27,029
pi に等しい理由を示す代わりに、入力 x を pi

246
00:11:27,029 --> 00:11:30,383
と x の積で置き換える単純な置換を行います。

247
00:11:30,383 --> 00:11:34,174
これには、グラフを pi 倍 だけ水平方向に押しつぶ

248
00:11:34,174 --> 00:11:37,819
す効果があるため、領域は pi 倍に縮小されます。

249
00:11:37,819 --> 00:11:41,318
つ まり、新しい目標は、右側の積分が正確に 1

250
00:11:41,318 --> 00:11:43,360
に等しい理由を示すことです。

251
00:11:43,360 --> 00:11:46,126
ちなみに、一部のエンジニアリングの文脈では、この関数

252
00:11:46,126 --> 00:11:48,148
の内側に pi を 付けて sinc

253
00:11:48,148 --> 00:11:51,021
という名前を使用します。正規化された関数、つまり関数

254
00:11:51,021 --> 00:11:53,788
の下の面積が 1 に等しいことは非常に優れていること

255
00:11:53,788 --> 00:11:54,640
が多いためです。

256
00:11:54,640 --> 00:11:56,498
重要なのは、この積分を右側に示すことは、

257
00:11:56,498 --> 00:11:58,356
積分を左側に示すことと まったく同じであ

258
00:11:58,356 --> 00:12:00,400
り、変数を変更するだけであるということです。

259
00:12:00,400 --> 00:12:03,009
そして、シーケンス内の他のすべての積分についても同

260
00:12:03,009 --> 00:12:05,514
様に、それぞれを調べて、 x を pi と x

261
00:12:05,514 --> 00:12:08,332
の積で置き換えます。ここから、これらすべての積分は移

262
00:12:08,332 --> 00:12:10,941
動平均の例に類似しているだけでなく、両方の積分が類

263
00:12:10,941 --> 00:12:12,715
似しているという主張にな ります。

264
00:12:12,715 --> 00:12:15,116
これらのうち、まったく同じものを計算する 2

265
00:12:15,116 --> 00:12:16,160
つの異なる方法です。

266
00:12:16,160 --> 00:12:19,092
そして、この関係は、この sinc 関数、または内部に

267
00:12:19,092 --> 00:12:21,082
pi を 含むエンジニアの sinc

268
00:12:21,082 --> 00:12:23,806
関数が、いわゆるフーリエ変換を使用す る rect

269
00:12:23,806 --> 00:12:26,320
関数に関連付けられているという事実に帰着します。

270
00:12:26,320 --> 00:12:29,503
フーリエ変換について聞いたことがない場合でも、フ

271
00:12:29,503 --> 00:12:32,560
ーリエ変換についてできることがいくつかあります。

272
00:12:32,560 --> 00:12:36,255
よく説明されるのは、関数を純粋な周波数の束の合計として分

273
00:12:36,255 --> 00:12:39,823
解したい場合、または無限関数の場合は純粋な周波数の束の

274
00:12:39,823 --> 00:12:43,519
連続積分である場合、フーリエ変換で次のことがわかるという

275
00:12:43,519 --> 00:12:46,960
ものです。それらすべての構成部品のすべての強さと位相。

276
00:12:46,960 --> 00:12:50,340
しかし、ここで本当に知っておく必要があるのは、これは 1

277
00:12:50,340 --> 00:12:53,720
つの関数を取り込んで新しい関数を吐き出すものであり、多く

278
00:12:53,720 --> 00:12:57,216
の場合、それは元の関数の情報を別の言語で言い換えたものであ

279
00:12:57,216 --> 00:13:00,480
ると考えられるということです。新しい視点から見てみます。

280
00:13:00,480 --> 00:13:03,280
たとえば、先ほども述べたように、フーリエ変換を行

281
00:13:03,280 --> 00:13:05,846
うこの新しい言語で書かれ たこの sinc

282
00:13:05,846 --> 00:13:08,880
関数は、トップ ハット Rect 関数に似ています。

283
00:13:08,880 --> 00:13:12,387
ちなみに、これは y 軸に関して対称な関数のフーリ

284
00:13:12,387 --> 00:13:15,760
エ変換の良い点であり、それ自体が逆変換になります。

285
00:13:15,760 --> 00:13:19,010
そして実際には、もう少し一般的な事実として、sinc

286
00:13:19,010 --> 00:13:21,899
関数の引き伸ばし たバージョンを変換すると、k

287
00:13:21,899 --> 00:13:24,307
倍水平に引き伸ばされて、引き伸ばされて

288
00:13:24,307 --> 00:13:27,316
押しつぶされたバージョンが得られるということです。

289
00:13:27,316 --> 00:13:28,400
このrect関数。

290
00:13:28,400 --> 00:13:31,755
しかし、もちろん、これらはすべて、この翻訳を実際に行うこ

291
00:13:31,755 --> 00:13:34,880
とができない限り、単なる意味のない単語や専門用語です。

292
00:13:34,880 --> 00:13:38,225
フーリエ変換が数学にとってなぜこれほど役立つのかという本当

293
00:13:38,225 --> 00:13:41,571
の考え方は、特 定の関数に関するステートメントや質問を取り

294
00:13:41,571 --> 00:13:43,417
上げ、その関数の変換されたバー

295
00:13:43,417 --> 00:13:46,763
ジョンに関してそれらが何に対応しているかを調べるとき、それ

296
00:13:46,763 --> 00:13:50,109
らのステートメ ントとこの新しい言語では、質問は非常に異な

297
00:13:50,109 --> 00:13:51,840
って見えることがよくあります。

298
00:13:51,840 --> 00:13:53,316
そして場合によっては、質問への答え

299
00:13:53,316 --> 00:13:54,880
がはるかに簡単になることがあります。

300
00:13:54,880 --> 00:13:58,297
たとえば、非常に優れた小さな事実の 1 つ、もう 1

301
00:13:58,297 --> 00:14:01,968
つ、示すべき事柄の リストにあることは、ある関数の積分を負

302
00:14:01,968 --> 00:14:04,246
の無限大から無限大まで計算したい場

303
00:14:04,246 --> 00:14:07,917
合、その曲線全体の下のこの符号付き領域は同じであるというこ

304
00:14:07,917 --> 00:14:11,587
とです。つまり 、入力ゼロでその関数のフーリエ変換バージョ

305
00:14:11,587 --> 00:14:13,360
ンを単純に評価するだけです。

306
00:14:13,360 --> 00:14:17,200
これは実際には定義から飛び出してくる事実です。

307
00:14:17,200 --> 00:14:21,082
そして、これは、右側のフーリエ変換された関数の個々の

308
00:14:21,082 --> 00:14:24,965
出力が左側の元の関数に関するある種のグローバル情報に

309
00:14:24,965 --> 00:14:28,560
対応するという、より一般的な雰囲気を表しています。

310
00:14:28,560 --> 00:14:31,401
私たちの特定のケースでは、この sinc 関数と rect

311
00:14:31,401 --> 00:14:34,148
関数がこのようなフーリエ変 換に関連しているということを信

312
00:14:34,148 --> 00:14:36,894
じていただけるのであれば、それは積分を説明していますが、

313
00:14:36,894 --> 00:14:39,451
そうでなければ計算するのが非常に難しいことになります。

314
00:14:39,451 --> 00:14:42,009
なぜなら、すべての符号付き領域を 示しているからです。

315
00:14:42,009 --> 00:14:44,755
これは、rect を 1 であるゼロで評価するのと同じこと

316
00:14:44,755 --> 00:14:45,040
です。

317
00:14:45,040 --> 00:14:46,721
さて、あなたは文句を言うかもしれませんが、確

318
00:14:46,721 --> 00:14:48,480
かにこれは敷居の下に問題を移動させるだけです。

319
00:14:48,480 --> 00:14:50,312
確かに、このフーリエ変換を計算することは

320
00:14:50,312 --> 00:14:52,144
、それがどのようなもの であっても、元の

321
00:14:52,144 --> 00:14:54,160
積分を計算するのと同じくらい難しいでしょう。

322
00:14:54,160 --> 00:14:56,269
しかし、これらのフーリエ変換を計算するため

323
00:14:56,269 --> 00:14:58,480
のヒントやコツがたくさんあるという考えです。

324
00:14:58,480 --> 00:15:00,704
そしてさらに、それを実行すると、その積分

325
00:15:00,704 --> 00:15:03,040
だけではなく、より多くの情報が得られます。

326
00:15:03,040 --> 00:15:05,680
計算を行うことで、かなりの利益が得られます。

327
00:15:05,680 --> 00:15:08,959
さて、私たちが探している関連性を説明するもう 1

328
00:15:08,959 --> 00:15:12,631
つの重要な事実は、 2 つの異なる関数があり、その積をと

329
00:15:12,631 --> 00:15:14,861
り、その積のフーリエ変換の合計を

330
00:15:14,861 --> 00:15:17,746
とった場合、それは同じになるということです。

331
00:15:17,746 --> 00:15:21,419
あたかも元の関数のフー リエ変換を個別に取得し、畳み込み

332
00:15:21,419 --> 00:15:23,911
として知られる新しい種類の演算を使用

333
00:15:23,911 --> 00:15:27,584
してそれらを組み合わせたかのように、次のビデオで詳しく説

334
00:15:27,584 --> 00:15:28,240
明します。

335
00:15:28,240 --> 00:15:31,520
さて、畳み込みについては説明すべきことがたくさんありますが

336
00:15:31,520 --> 00:15:34,800
、結論としては、これら の長方形関数を使用した特定のケース

337
00:15:34,800 --> 00:15:37,967
では、畳み込みは、これまでずっと話してきた移 動平均の

338
00:15:37,967 --> 00:15:41,247
1 つを組み合わせたものとまったく同じであるということにな

339
00:15:41,247 --> 00:15:44,527
ります。あ るコンテキストでの積分は、別のコンテキストでゼ

340
00:15:44,527 --> 00:15:46,449
ロで評価するように見えるという前

341
00:15:46,449 --> 00:15:49,729
述の事実に加えて、信じていただければ、あるコンテキストでの

342
00:15:49,729 --> 00:15:52,670
乗算は、この新しい演 算である畳み込みに対応します。

343
00:15:52,670 --> 00:15:55,611
この例では、単純に移動平均と考える必要があります 。

344
00:15:55,611 --> 00:15:58,891
これらの sinc 関数をどんどん乗算すると、これらの漸進

345
00:15:58,891 --> 00:16:02,171
的移動平均と常にゼロ で評価されるという観点から考えること

346
00:16:02,171 --> 00:16:04,659
ができる理由を説明します。これにより、最終

347
00:16:04,659 --> 00:16:07,939
的に何かが壊れる前になぜそのような安定した値が期待されるの

348
00:16:07,939 --> 00:16:10,654
かについて、非常に素 晴らしい直感が得られます。

349
00:16:10,654 --> 00:16:13,708
台地の端が少しずつ中心に近づくにつれて、下に向かって

350
00:16:13,708 --> 00:16:14,273
いきます。

351
00:16:14,273 --> 00:16:18,497
ちなみに、この最後の重要な事実には特別な名前があり、畳み込み

352
00:16:18,497 --> 00:16:22,721
定 理と呼ばれます。これについても、さらに詳しく説明します。

353
00:16:22,721 --> 00:16:25,706
3 つの魔法の事実 を並べ立てて、すべてはそこから

354
00:16:25,706 --> 00:16:28,930
導かれると言ってここで話を終えるのは少し満足できない

355
00:16:28,930 --> 00:16:31,914
かもしれないことは承知していますが、フーリエ変換の

356
00:16:31,914 --> 00:16:34,063
ような強力なツールがなぜ難しい問題

357
00:16:34,063 --> 00:16:37,645
に非常に役立つのかを少しでも垣間見ることができれば幸いです。

358
00:16:37,645 --> 00:16:40,630
これは、難しい問題が 簡単に見えるよう

359
00:16:40,630 --> 00:16:43,615
に視点を変えるための体系的な方法です。

360
00:16:43,615 --> 00:16:46,215
少なくとも、畳 み込み定理のような美しいものに

361
00:16:46,215 --> 00:16:48,928
ついて学ぶ動機を与えることができれば幸いで す。

362
00:16:48,928 --> 00:16:52,126
もう 1 つの小さなティーザーとして、この畳み込み定理

363
00:16:52,126 --> 00:16:54,258
のもう 1 つ の楽しい結果は、2

364
00:16:54,258 --> 00:16:57,575
つの大きな数の積を非常に迅速に (可能であると考えられ

365
00:16:57,575 --> 00:17:00,773
ているよりもはるかに速く) 計算できるアルゴリズムへの

366
00:17:00,773 --> 00:17:01,840
扉を開くことです。

367
00:17:01,840 --> 00:17:05,840
それでは、次のビデオでお会いしましょう。

