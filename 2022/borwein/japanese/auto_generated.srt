1
00:00:00,000 --> 00:00:01,447
時々、宇宙があなたにちょっかいをか

2
00:00:01,447 --> 00:00:02,980
けているように感じることがあります。

3
00:00:03,340 --> 00:00:05,651
画面には一連の計算が表示されていますが、心配

4
00:00:05,651 --> 00:00:07,963
しないでください。すぐ に、それぞれの計算が

5
00:00:07,963 --> 00:00:10,380
実際に何を言っているのかを解いて視覚化します。

6
00:00:10,920 --> 00:00:13,400
注目していただきたいのは、シーケンスが、たとえランダムで

7
00:00:13,400 --> 00:00:15,881
あっても、非常に予測可能なパターンに従っていることと、各

8
00:00:15,881 --> 00:00:18,540
計算がどのようにして pi に等 しくなるかということです。

9
00:00:19,080 --> 00:00:21,346
そして、何らかの理由でこれらをコンピューター

10
00:00:21,346 --> 00:00:23,613
上でただいじって評価していたとしたら、これは

11
00:00:23,613 --> 00:00:25,880
永遠に続くパターンだと思うかもしれません。 

12
00:00:25,880 --> 00:00:27,100
しかし、そうではありません。 

13
00:00:27,400 --> 00:00:31,473
ある時点で停止し、pi に等しくなるのではなく、pi 

14
00:00:31,473 --> 00:00:34,340
よりかろうじて小さい値が得られます。 

15
00:00:38,780 --> 00:00:40,940
さて、ここで何が起こっているのかを掘り下げてみましょう。

16
00:00:41,300 --> 00:00:45,080
今日の物語の主人公は、x を x で割った関数の正弦です。

17
00:00:45,460 --> 00:00:48,733
これは実際、数学や工学の分野でよく登場するため、sinc 

18
00:00:48,733 --> 00:00:50,878
という独自の名前が付 けられています。

19
00:00:50,878 --> 00:00:54,151
通常の振動正弦曲線から始めて、それから遠ざかるにつれてそれ

20
00:00:54,151 --> 00:00:56,861
を押 しつぶすというような考え方が考えられます。

21
00:00:56,861 --> 00:00:58,780
x に 1 を乗じてゼロにします。

22
00:00:59,300 --> 00:01:00,772
そして、賢明な方は、x が 0 

23
00:01:00,772 --> 00:01:02,979
に等しい場合に何が起こるか尋ねるかもしれません。

24
00:01:02,979 --> 00:01:05,740
これを代入すると、0 を 0 で割ったように見えるからです。

25
00:01:06,400 --> 00:01:09,193
そして、皆さんの中でさらに聡明な人、おそらく微積分

26
00:01:09,193 --> 00:01:11,428
の授業を終えたばかりの人 は、値が 0 

27
00:01:11,428 --> 00:01:14,780
に近づくほど、関数は 1 に近づくことを指摘できるでしょう。

28
00:01:15,260 --> 00:01:17,528
したがって、単純に sinc 関数を 0 から 1 

29
00:01:17,528 --> 00:01:20,058
に等しくなるように再定義すると、素晴らしい連続曲線が得られ

30
00:01:20,058 --> 00:01:20,320
ます。

31
00:01:20,320 --> 00:01:23,891
これらすべては少しずつです。実際に関心があるのは、こ

32
00:01:23,891 --> 00:01:27,051
の曲線の負の無限大から無限大 までの積分です。

33
00:01:27,051 --> 00:01:30,623
これは、曲線と X 軸の間の領域、より正確には符号付

34
00:01:30,623 --> 00:01:33,508
きの領域を 意味すると考えられます。面積。

35
00:01:33,508 --> 00:01:36,942
つまり、X 軸のグラフの正の部分で囲まれたすべて 

36
00:01:36,942 --> 00:01:40,514
の面積を加算し、グラフと X 軸の負の部分で囲まれた

37
00:01:40,514 --> 00:01:42,300
すべての部分を減算します。

38
00:01:42,740 --> 00:01:44,594
最初に見たように、これが正確に pi 

39
00:01:44,594 --> 00:01:46,351
と評価される場合がたまたまあります。

40
00:01:46,351 --> 00:01:48,889
これは素晴らしいことですが、少し奇 妙でもあります。

41
00:01:48,889 --> 00:01:51,525
通常の微積分ツールを使用してこれにどのようにアプローチ

42
00:01:51,525 --> 00:01:53,380
するかは完全には明らかではありません。

43
00:01:53,980 --> 00:01:56,560
ビデオの終わりの方で、これを行う方法のコツを紹介します。

44
00:01:56,840 --> 00:01:59,508
冒頭で説明したシーケンスを進めて、次のステップは 

45
00:01:59,508 --> 00:02:01,749
sinc 関数のコピーを取得することです。

46
00:02:01,749 --> 00:02:04,097
ここで x を 3 で割った値を代入します。

47
00:02:04,097 --> 00:02:06,872
基本的には同じグラフのように見えますが、水平方向に 

48
00:02:06,872 --> 00:02:08,259
3 倍に引き伸ばされます。

49
00:02:08,900 --> 00:02:12,684
これら 2 つの関数を掛け合わせると、質量が中央に向かって 

50
00:02:12,684 --> 00:02:15,963
集中しているように見える、より複雑な波が得られます。

51
00:02:15,963 --> 00:02:19,621
通常の 関数では、これにより領域が完全に変化すると予想され

52
00:02:19,621 --> 00:02:20,000
ます。

53
00:02:20,380 --> 00:02:21,987
このように積分をランダムに変更して、何

54
00:02:21,987 --> 00:02:23,680
も変わらないと期待することはできません。

55
00:02:24,260 --> 00:02:26,519
したがって、この結果が pi と等しいこと、つま

56
00:02:26,519 --> 00:02:28,780
り何も変わっていないことは、すでに少し奇妙です。

57
00:02:29,080 --> 00:02:31,180
これもリストに追加すべきもう 1 つの謎です。

58
00:02:31,660 --> 00:02:34,480
そして、シーケンスの次のステップでは、sinc 

59
00:02:34,480 --> 00:02:38,006
関数のさらに拡張されたバージョンを 5 倍にし、それをすで 

60
00:02:38,006 --> 00:02:41,061
に得ている値で乗算し、曲線全体の下の符号付き領域を再

61
00:02:41,061 --> 00:02:44,000
度調べます。これは再び pi に等しくなります。。

62
00:02:44,860 --> 00:02:46,480
そして、このように続きます。

63
00:02:46,580 --> 00:02:48,760
反復のたびに、新しい奇数だけ拡張

64
00:02:48,760 --> 00:02:50,940
し、それを現在の値に乗算します。

65
00:02:51,640 --> 00:02:54,225
気づくかもしれない点の 1 つは、入力 x が 

66
00:02:54,225 --> 00:02:57,134
0 に等しい場合を除いて、 この関数のすべての部分が 

67
00:02:57,134 --> 00:02:59,720
1 より小さい値で徐々に乗算されていることです。

68
00:03:00,340 --> 00:03:02,671
したがって、シーケンスが進むにつれて、物事が

69
00:03:02,671 --> 00:03:05,002
どんどん押しつぶされて いき、どちらかという

70
00:03:05,002 --> 00:03:07,440
とエリアが小さくなることは予想されるでしょう。

71
00:03:08,360 --> 00:03:11,420
最終的にはまさにそのとおりになりますが、奇妙な

72
00:03:11,420 --> 00:03:14,613
のは、非常に長い間安定したままであり、もちろん 

73
00:03:14,613 --> 00:03:17,673
より適切なことに、値 15 でブレイクするとき

74
00:03:17,673 --> 00:03:20,600
も、ほんのわずかな量でブレイクすることです。

75
00:03:21,180 --> 00:03:24,780
そして、これが何らかの数値エラーの結果であると考える前に

76
00:03:24,780 --> 00:03:28,252
、おそらく浮動小数点 演算で何かを行っているためです。

77
00:03:28,252 --> 00:03:31,081
これをより正確に計算すると、最後の積分の正 

78
00:03:31,081 --> 00:03:34,039
確な値は次のとおりです。これは特定の分数です。

79
00:03:34,039 --> 00:03:35,840
分子と分母が不合理な円周率。

80
00:03:35,980 --> 00:03:38,700
どちらも約4000億です。

81
00:03:40,460 --> 00:03:42,207
このパターンは、ジョナサンとデビッド 

82
00:03:42,207 --> 00:03:44,506
ボーワインの父子ペアによる論文で説明されています。

83
00:03:44,506 --> 00:03:47,081
これは 非常に興味深いもので、研究仲間がコンピュータ代数

84
00:03:47,081 --> 00:03:49,289
システムを使用してこれらの積分を計算していたと 

85
00:03:49,289 --> 00:03:51,864
き、これは次のとおりである必要があると仮定したことについ

86
00:03:51,864 --> 00:03:53,520
て彼らが言及しました。ある種のバグ。

87
00:03:53,860 --> 00:03:55,990
しかし、これはバグではなく、実際の現象で

88
00:03:55,990 --> 00:03:58,120
あり、実際にはそれよりも奇妙になります。

89
00:03:58,440 --> 00:04:01,667
これらすべての積分を取得し、さらに別の係数 x の 2 

90
00:04:01,667 --> 00:04:04,895
コサインを含める と、やはり値が完全に変わると思われるで

91
00:04:04,895 --> 00:04:06,855
しょうが、このように新しいものを 

92
00:04:06,855 --> 00:04:09,391
ランダムに積分して積分することはできません。

93
00:04:09,391 --> 00:04:11,581
ずっと pi と等しくなり 続けます。

94
00:04:11,581 --> 00:04:15,040
それよりも長くなり、113 番に到達するまで中断されません。

95
00:04:15,200 --> 00:04:17,379
そして、それが壊れるときは、想像でき

96
00:04:17,379 --> 00:04:19,680
るほどわずかで、まったく微妙な量です。

97
00:04:20,440 --> 00:04:22,207
そこで自然な疑問は、いったいここで

98
00:04:22,207 --> 00:04:24,080
何が起こっているのかということです。

99
00:04:24,380 --> 00:04:26,030
そして幸運なことに、これらすべてにつ

100
00:04:26,030 --> 00:04:27,680
いて実際に満足のいく説明があります。

101
00:04:28,180 --> 00:04:31,266
これについて私が考えている方法は、最初はまったく関係がない

102
00:04:31,266 --> 00:04:33,927
ように見えますが、同様のパタ ーンを示し、113 

103
00:04:33,927 --> 00:04:37,014
という数字に到達するまで値が非常に安定している現象を示すこ

104
00:04:37,014 --> 00:04:37,440
とです。

105
00:04:37,440 --> 00:04:38,959
15 という数字に到達すると、

106
00:04:38,959 --> 00:04:40,580
ほんのわずかな量だけ変化します。

107
00:04:41,300 --> 00:04:44,950
そしてその後、この一見無関係に見える現象が隠れてすべて 

108
00:04:44,950 --> 00:04:48,340
の積分式と同じであるが、隠れている理由を説明します。

109
00:04:49,120 --> 00:04:52,227
そこで、まったく違うように見えることに注目して、rect 

110
00:04:52,227 --> 00:04:55,014
of x を呼 び出す関数について考えてみましょう。

111
00:04:55,014 --> 00:04:57,371
この関数は、入力が負の 1/2 と 1/2 

112
00:04:57,371 --> 00:05:00,265
の間にある場合は 1 に等しく、それ以外の場合は 0 

113
00:05:00,265 --> 00:05:01,980
に等し いと定義されています。。

114
00:05:02,220 --> 00:05:04,520
基本的に、関数はこの退屈なステップです。

115
00:05:04,520 --> 00:05:08,331
これは、定義する一連の関数の最初のものになるため、これを 

116
00:05:08,331 --> 00:05:11,617
f1 of x と 呼びます。シーケンス内の各新し

117
00:05:11,617 --> 00:05:14,640
い関数は、前の関数の一種の移動平均になります。

118
00:05:15,800 --> 00:05:18,922
たとえば、この 2 回目の反復を定義する方法は、幅が 

119
00:05:18,922 --> 00:05:21,350
3 分の 1 であるこの スライディング 

120
00:05:21,350 --> 00:05:23,432
ウィンドウを取得し、特定の入力 x 

121
00:05:23,432 --> 00:05:25,629
に対して、ウィンドウがその 入力 x 

122
00:05:25,629 --> 00:05:28,636
の中心にあるとき、以下に示す新しい関数の値を取得する

123
00:05:28,636 --> 00:05:31,642
ことです。, は、そのウィンドウ内で上の最初の関数の

124
00:05:31,642 --> 00:05:33,840
平均値と等しくなるように定義されます。

125
00:05:33,840 --> 00:05:35,769
たとえば、ウィンドウが十分に左にある場合

126
00:05:35,769 --> 00:05:37,505
、ウィンドウ内のすべて の値は 0 

127
00:05:37,505 --> 00:05:39,820
になるため、下のグラフには 0 が表示されます。

128
00:05:40,280 --> 00:05:43,683
そのウィンドウがプラトーを少し超え始めるとすぐに、平均値は 

129
00:05:43,683 --> 00:05:46,860
0 より少し大きくなり、以下のグラフでそれがわかります。

130
00:05:47,280 --> 00:05:49,541
そして、ウィンドウのちょうど半分が 1 

131
00:05:49,541 --> 00:05:51,803
のプラトーを超え、その半分が 0 にな 

132
00:05:51,803 --> 00:05:54,403
ると、下のグラフの対応する値が 2 分の 1 

133
00:05:54,403 --> 00:05:56,100
になり、ポイントがわかります。

134
00:05:56,660 --> 00:06:00,511
注目していただきたい重要な点は、ウィンドウが完全に上のプラ 

135
00:06:00,511 --> 00:06:04,105
トーにあり、すべての値が 1 である場合、平均値も 1 

136
00:06:04,105 --> 00:06:07,700
になるため、下部の関数でこのプラトーが得られることです。

137
00:06:08,300 --> 00:06:11,266
この一番下の関数を x の f2 と呼びましょう。

138
00:06:11,266 --> 00:06:13,401
考えてい ただきたいのは、その 2 

139
00:06:13,401 --> 00:06:15,300
番目の関数のプラトーの長さです。

140
00:06:15,480 --> 00:06:16,440
どのくらいの幅にすればよいでしょうか？

141
00:06:17,020 --> 00:06:20,483
少し考えてみると、上の台地の左端と下の台地の 

142
00:06:20,483 --> 00:06:23,947
左端の間の距離は、ウィンドウの幅のちょうど半 

143
00:06:23,947 --> 00:06:27,260
分、つまり 3 分の 1 の半分になります。

144
00:06:27,640 --> 00:06:30,646
同様に右側では、プラトーのエッジ間の距離はウィンドウ幅の半分

145
00:06:30,646 --> 00:06:33,653
であるため、全体としては 1 からそのウィンドウ幅を引いたも

146
00:06:33,653 --> 00:06:36,660
の、つまり 1 から 3 分の 1 を引いたものになります。

147
00:06:37,380 --> 00:06:40,210
これから計算する値、つまり壊れるまでしばらく安定

148
00:06:40,210 --> 00:06:43,747
しているように見 える値は、入力 0 でのこの関数の値です。

149
00:06:43,747 --> 00:06:46,577
この関数の値は、プラ トー内にあるため、これらの

150
00:06:46,577 --> 00:06:48,700
反復の両方で 1 に等しくなります。

151
00:06:49,200 --> 00:06:52,377
次の反復では、最後の関数の移動平均を取得しますが、今 

152
00:06:52,377 --> 00:06:55,320
回は幅が 5 分の 1 のウィンドウを使用します。

153
00:06:55,320 --> 00:06:58,496
このウィンドウをスライドすると、前の関数の滑らかなバー 

154
00:06:58,496 --> 00:07:01,560
ジョンが得られる理由を考えるのは、ちょっと楽しいです。

155
00:07:01,640 --> 00:07:04,800
繰り返しになりますが、注目していただきたい重要な点は、

156
00:07:04,800 --> 00:07:07,960
そのウィンドウが完全に前の 関数のプラトー内にある場合

157
00:07:07,960 --> 00:07:11,120
、定義上、一番下の関数が 1 に等しくなる仕組みです。

158
00:07:11,120 --> 00:07:13,718
今回は、下部の台地の長さは、前の台地の長さから 

159
00:07:13,718 --> 00:07:16,425
1 から 3 分の 1 を 引いたものから、ウィン

160
00:07:16,425 --> 00:07:19,240
ドウの幅から 5 分の 1 を引いたものになります。

161
00:07:19,600 --> 00:07:23,485
推論は前と同じで、ウィンドウの中央が上部の台地にある点 

162
00:07:23,485 --> 00:07:27,371
から、ウィンドウ全体がその台地の内側にあり、ウィンドウ 

163
00:07:27,371 --> 00:07:30,980
の幅の半分で、同様に右側にある場所まで移動します。。

164
00:07:30,980 --> 00:07:34,263
もう一度言いますが、記録する値は、入力が 0 の場合のこ 

165
00:07:34,263 --> 00:07:37,320
の関数の出力であり、この場合も正確に 1 になります。

166
00:07:38,580 --> 00:07:40,283
次の反復は、ウィンドウ幅が 7 

167
00:07:40,283 --> 00:07:41,880
分の 1 である移動平均です。

168
00:07:42,100 --> 00:07:44,040
プラトーは 1 対 7 だけ小さくなります。

169
00:07:44,500 --> 00:07:46,231
1 対 9 でもう 1 回反復すると

170
00:07:46,231 --> 00:07:48,060
、プラトーはその分だけ小さくなります。

171
00:07:48,600 --> 00:07:50,780
さらに進んでいくと、プラトーはどんどん薄くなっていきます。

172
00:07:51,820 --> 00:07:54,160
また、プラトーのすぐ外側で、関数が実際に 1 

173
00:07:54,160 --> 00:07:56,195
に非常に近いことにも注 目してください。

174
00:07:56,195 --> 00:07:58,942
これは、常に 1 のプラトーと隣接するプラトーとの間 

175
00:07:58,942 --> 00:08:01,180
の平均の結果であり、それら自体が実際に 1 

176
00:08:01,180 --> 00:08:02,300
に非常に近いからです。

177
00:08:02,300 --> 00:08:06,398
このすべてが中断されるのは、幅が 15 分の 1 のウィン 

178
00:08:06,398 --> 00:08:10,360
ドウを全体にわたってスライドさせる反復に到達したときです。

179
00:08:10,760 --> 00:08:12,710
この時点で、前のプラトーは実際には

180
00:08:12,710 --> 00:08:14,660
ウィンドウ自体よりも薄くなります。

181
00:08:14,820 --> 00:08:17,638
したがって、入力 x が 0 であっても、この移動平均は 

182
00:08:17,638 --> 00:08:19,680
1 よりわずかに小さくなければなりません。

183
00:08:19,680 --> 00:08:23,212
ここでの 15 という数字の唯一の特別な点は、これらの奇数 

184
00:08:23,212 --> 00:08:26,391
の分数の逆数、3 分の 1 と 5 分の 1 と 7 

185
00:08:26,391 --> 00:08:29,570
分 の 1 を繰り返し加算し続けると、15 分の 1 

186
00:08:29,570 --> 00:08:32,395
に達す るとその合計が大きくなるということです。

187
00:08:32,395 --> 00:08:33,220
1より大きい。

188
00:08:33,580 --> 00:08:36,554
そして、縮小するプラトーのコンテキストでは、幅 

189
00:08:36,554 --> 00:08:39,033
1 のプラト ーから始まり、現在は完全に

190
00:08:39,033 --> 00:08:41,140
消えてしまうほどに縮小しています。

191
00:08:41,799 --> 00:08:45,374
重要なのは、これを一見ランダムな手順で定義した関数のシーケ

192
00:08:45,374 --> 00:08:48,331
ンスとして、これ らすべての関数の値を入力 0 

193
00:08:48,331 --> 00:08:51,166
で計算するように依頼すると、最初は安定してい 

194
00:08:51,166 --> 00:08:54,124
るように見えるパターンが得られるということです。

195
00:08:54,124 --> 00:08:56,342
1 1 1 1 1 1 ですが、8 

196
00:08:56,342 --> 00:09:00,040
回目の反復に到達するまでに、わずかに、かろうじて不足します。

197
00:09:00,680 --> 00:09:02,831
これは、pi pi pi pi pi 

198
00:09:02,831 --> 00:09:05,323
で安定した値が、ぎりぎり下回るまで安定した 

199
00:09:05,323 --> 00:09:08,267
値を示す、前に見た積分に似ていますが、似ているだけで

200
00:09:08,267 --> 00:09:09,740
はない、と私は主張します。

201
00:09:10,180 --> 00:09:13,344
そして偶然にも、移動平均プロセスで得られた 

202
00:09:13,344 --> 00:09:16,508
1 よりわずかに小さいこ の定数は、まさに一

203
00:09:16,508 --> 00:09:19,960
連の積分において pi の前に位置する係数です。

204
00:09:20,340 --> 00:09:22,525
したがって、2 つの状況は質的に似

205
00:09:22,525 --> 00:09:24,840
ているだけでなく、量的にも同じです。

206
00:09:25,540 --> 00:09:29,161
そして、積分値の中に x 項の 2 コサインを追加すると 

207
00:09:29,161 --> 00:09:32,533
、パターンが破綻するまでずっと長く続くことになります。

208
00:09:32,533 --> 00:09:36,155
類推すると、これは同じセットアップに相当しますが、最初の 

209
00:09:36,155 --> 00:09:39,652
関数にはさらに長いプラトーがあり、x が負の 1 から 

210
00:09:39,652 --> 00:09:42,900
1 まで伸びています。つまり、その長さは 2 です。

211
00:09:42,900 --> 00:09:45,556
したがって、この繰り返しの移動平均プロセスを実行

212
00:09:45,556 --> 00:09:48,212
して、ウィンドウをどんど ん小さくしていき、プラ

213
00:09:48,212 --> 00:09:50,980
トー全体に食い込むまでにかなりの時間がかかります。

214
00:09:51,700 --> 00:09:55,004
より具体的には、関連する計算は、これらの奇数の逆数を合計が 

215
00:09:55,004 --> 00:09:57,537
2 より 大きくなるまでどれくらいの時間加算す

216
00:09:57,537 --> 00:09:59,300
る必要があるかを尋ねることです。

217
00:09:59,720 --> 00:10:02,524
そして、113 という数字に到達するまで行かなければな

218
00:10:02,524 --> 00:10:05,328
らないことがわかりました。こ れは、そこにある積分パタ

219
00:10:05,328 --> 00:10:08,340
ーンが 113 に到達するまで続くという事実に対応します。

220
00:10:09,099 --> 00:10:12,511
ところで、これらの奇数の逆数、1/3、1/1、1/5、 

221
00:10:12,511 --> 00:10:15,680
1 には特別なことは何もないことを強調しておきます。

222
00:10:15,680 --> 00:10:18,915
それはたまたま、ボーワイン夫妻が論文で強調した一連の値 

223
00:10:18,915 --> 00:10:21,920
であり、その一連がオタク界隈で少し有名になったのだ。

224
00:10:22,440 --> 00:10:24,413
より一般的には、これらの sinc 

225
00:10:24,413 --> 00:10:26,934
関数に任意の正の数値シーケンスを挿入すること 

226
00:10:26,934 --> 00:10:30,004
ができ、それらの数値の合計が 1 未満である限り、式は 

227
00:10:30,004 --> 00:10:31,320
pi と等しくなります。

228
00:10:31,700 --> 00:10:34,081
しかし、それらが 1 より大きくなるとすぐに、式は 

229
00:10:34,081 --> 00:10:35,180
pi を少し下回ります。

230
00:10:35,180 --> 00:10:37,543
これらの移動平均と類似点があると私が信じて

231
00:10:37,543 --> 00:10:40,020
いるのであれば、その理由が分かると思います。

232
00:10:41,840 --> 00:10:44,988
しかし、もちろん、燃えるような疑問は、いったいなぜこの 

233
00:10:44,988 --> 00:10:47,800
2 つの状況が相互に関係があるのかということです。

234
00:10:48,240 --> 00:10:51,892
ここから、この議論には、フーリエ変換と畳み込み 

235
00:10:51,892 --> 00:10:55,240
という 2 つの少し重い機構が導入されます。

236
00:10:55,860 --> 00:10:58,616
これについて私が説明したいのは、このビデオの残りの部

237
00:10:58,616 --> 00:11:01,372
分を費やして 、これら 2 つのトピックのいずれかに

238
00:11:01,372 --> 00:11:04,127
精通しているとは必ずしも想 定せずに、議論がどのよう

239
00:11:04,127 --> 00:11:07,096
に進むかについての概要を理解してから説明 することです。

240
00:11:07,096 --> 00:11:09,640
畳み込みに特化したビデオで詳細が真実である理由。

241
00:11:10,200 --> 00:11:14,301
特に、畳み込み定理と呼ばれるものは、信じられないほど美し 

242
00:11:14,301 --> 00:11:18,120
く、この特定の非常に難解な質問を超えて役立つためです。

243
00:11:21,080 --> 00:11:23,258
まず、この関数の正弦 x を x 

244
00:11:23,258 --> 00:11:27,104
で除算することに焦点を当て、その曲線の下 の符号付き領域が 

245
00:11:27,104 --> 00:11:30,564
pi に等しい理由を示す代わりに、入力 x を pi 

246
00:11:30,564 --> 00:11:33,512
と x の積で置き換える単純な置換を行います。

247
00:11:33,512 --> 00:11:36,845
これには、グラフを pi 倍 だけ水平方向に押しつぶ

248
00:11:36,845 --> 00:11:40,049
す効果があるため、領域は pi 倍に縮小されます。

249
00:11:40,049 --> 00:11:43,125
つ まり、新しい目標は、右側の積分が正確に 1 

250
00:11:43,125 --> 00:11:44,920
に等しい理由を示すことです。

251
00:11:45,500 --> 00:11:48,114
ちなみに、一部のエンジニアリングの文脈では、この関数

252
00:11:48,114 --> 00:11:50,025
の内側に pi を 付けて sinc 

253
00:11:50,025 --> 00:11:52,740
という名前を使用します。正規化された関数、つまり関数 

254
00:11:52,740 --> 00:11:55,355
の下の面積が 1 に等しいことは非常に優れていること

255
00:11:55,355 --> 00:11:56,160
が多いためです。

256
00:11:56,160 --> 00:11:58,011
重要なのは、この積分を右側に示すことは、

257
00:11:58,011 --> 00:11:59,863
積分を左側に示すことと まったく同じであ

258
00:11:59,863 --> 00:12:01,900
り、変数を変更するだけであるということです。

259
00:12:02,580 --> 00:12:05,116
そして、シーケンス内の他のすべての積分についても同

260
00:12:05,116 --> 00:12:07,551
様に、それぞれを調べて、 x を pi と x 

261
00:12:07,551 --> 00:12:10,290
の積で置き換えます。ここから、これらすべての積分は移 

262
00:12:10,290 --> 00:12:12,827
動平均の例に類似しているだけでなく、両方の積分が類

263
00:12:12,827 --> 00:12:14,551
似しているという主張にな ります。

264
00:12:14,551 --> 00:12:16,885
これらのうち、まったく同じものを計算する 2 

265
00:12:16,885 --> 00:12:17,900
つの異なる方法です。

266
00:12:18,500 --> 00:12:21,132
そして、この関係は、この sinc 関数、または内部に 

267
00:12:21,132 --> 00:12:22,918
pi を 含むエンジニアの sinc 

268
00:12:22,918 --> 00:12:25,363
関数が、いわゆるフーリエ変換を使用す る rect 

269
00:12:25,363 --> 00:12:27,620
関数に関連付けられているという事実に帰着します。

270
00:12:28,260 --> 00:12:30,453
フーリエ変換について聞いたことがない場合でも、フ 

271
00:12:30,453 --> 00:12:32,560
ーリエ変換についてできることがいくつかあります。

272
00:12:32,740 --> 00:12:36,332
よく説明されるのは、関数を純粋な周波数の束の合計として分 

273
00:12:36,332 --> 00:12:39,801
解したい場合、または無限関数の場合は純粋な周波数の束の 

274
00:12:39,801 --> 00:12:43,394
連続積分である場合、フーリエ変換で次のことがわかるという 

275
00:12:43,394 --> 00:12:46,740
ものです。それらすべての構成部品のすべての強さと位相。

276
00:12:47,120 --> 00:12:50,470
しかし、ここで本当に知っておく必要があるのは、これは 1 

277
00:12:50,470 --> 00:12:53,819
つの関数を取り込んで新しい関数を吐き出すものであり、多く 

278
00:12:53,819 --> 00:12:57,285
の場合、それは元の関数の情報を別の言語で言い換えたものであ 

279
00:12:57,285 --> 00:13:00,520
ると考えられるということです。新しい視点から見てみます。

280
00:13:01,320 --> 00:13:03,720
たとえば、先ほども述べたように、フーリエ変換を行

281
00:13:03,720 --> 00:13:05,920
うこの新しい言語で書かれ たこの sinc 

282
00:13:05,920 --> 00:13:08,520
関数は、トップ ハット Rect 関数に似ています。

283
00:13:09,100 --> 00:13:12,362
ちなみに、これは y 軸に関して対称な関数のフーリ 

284
00:13:12,362 --> 00:13:15,500
エ変換の良い点であり、それ自体が逆変換になります。

285
00:13:15,860 --> 00:13:18,992
そして実際には、もう少し一般的な事実として、sinc 

286
00:13:18,992 --> 00:13:21,776
関数の引き伸ばし たバージョンを変換すると、k 

287
00:13:21,776 --> 00:13:24,096
倍水平に引き伸ばされて、引き伸ばされて 

288
00:13:24,096 --> 00:13:26,996
押しつぶされたバージョンが得られるということです。

289
00:13:26,996 --> 00:13:28,040
このrect関数。

290
00:13:28,600 --> 00:13:31,655
しかし、もちろん、これらはすべて、この翻訳を実際に行うこ 

291
00:13:31,655 --> 00:13:34,500
とができない限り、単なる意味のない単語や専門用語です。

292
00:13:35,100 --> 00:13:38,374
フーリエ変換が数学にとってなぜこれほど役立つのかという本当

293
00:13:38,374 --> 00:13:41,649
の考え方は、特 定の関数に関するステートメントや質問を取り

294
00:13:41,649 --> 00:13:43,456
上げ、その関数の変換されたバー 

295
00:13:43,456 --> 00:13:46,731
ジョンに関してそれらが何に対応しているかを調べるとき、それ

296
00:13:46,731 --> 00:13:50,006
らのステートメ ントとこの新しい言語では、質問は非常に異な

297
00:13:50,006 --> 00:13:51,700
って見えることがよくあります。

298
00:13:51,700 --> 00:13:53,293
そして場合によっては、質問への答え

299
00:13:53,293 --> 00:13:54,980
がはるかに簡単になることがあります。

300
00:13:55,660 --> 00:13:58,933
たとえば、非常に優れた小さな事実の 1 つ、もう 1 

301
00:13:58,933 --> 00:14:02,449
つ、示すべき事柄の リストにあることは、ある関数の積分を負

302
00:14:02,449 --> 00:14:04,631
の無限大から無限大まで計算したい場 

303
00:14:04,631 --> 00:14:08,146
合、その曲線全体の下のこの符号付き領域は同じであるというこ

304
00:14:08,146 --> 00:14:11,662
とです。つまり 、入力ゼロでその関数のフーリエ変換バージョ

305
00:14:11,662 --> 00:14:13,360
ンを単純に評価するだけです。

306
00:14:13,820 --> 00:14:16,860
これは実際には定義から飛び出してくる事実です。

307
00:14:16,860 --> 00:14:20,749
そして、これは、右側のフーリエ変換された関数の個々の 

308
00:14:20,749 --> 00:14:24,638
出力が左側の元の関数に関するある種のグローバル情報に 

309
00:14:24,638 --> 00:14:28,240
対応するという、より一般的な雰囲気を表しています。

310
00:14:28,720 --> 00:14:31,533
私たちの特定のケースでは、この sinc 関数と rect 

311
00:14:31,533 --> 00:14:34,253
関数がこのようなフーリエ変 換に関連しているということを信

312
00:14:34,253 --> 00:14:36,973
じていただけるのであれば、それは積分を説明していますが、 

313
00:14:36,973 --> 00:14:39,506
そうでなければ計算するのが非常に難しいことになります。

314
00:14:39,506 --> 00:14:42,038
なぜなら、すべての符号付き領域を 示しているからです。

315
00:14:42,038 --> 00:14:44,758
これは、rect を 1 であるゼロで評価するのと同じこと

316
00:14:44,758 --> 00:14:45,040
です。

317
00:14:46,140 --> 00:14:47,704
さて、あなたは文句を言うかもしれませんが、確

318
00:14:47,704 --> 00:14:49,340
かにこれは敷居の下に問題を移動させるだけです。

319
00:14:49,700 --> 00:14:51,306
確かに、このフーリエ変換を計算することは

320
00:14:51,306 --> 00:14:52,912
、それがどのようなもの であっても、元の

321
00:14:52,912 --> 00:14:54,680
積分を計算するのと同じくらい難しいでしょう。

322
00:14:55,040 --> 00:14:56,798
しかし、これらのフーリエ変換を計算するため

323
00:14:56,798 --> 00:14:58,640
のヒントやコツがたくさんあるという考えです。

324
00:14:59,300 --> 00:15:01,456
そしてさらに、それを実行すると、その積分

325
00:15:01,456 --> 00:15:03,720
だけではなく、より多くの情報が得られます。

326
00:15:03,880 --> 00:15:05,860
計算を行うことで、かなりの利益が得られます。

327
00:15:05,860 --> 00:15:09,051
さて、私たちが探している関連性を説明するもう 1 

328
00:15:09,051 --> 00:15:12,626
つの重要な事実は、 2 つの異なる関数があり、その積をと

329
00:15:12,626 --> 00:15:14,797
り、その積のフーリエ変換の合計を 

330
00:15:14,797 --> 00:15:17,606
とった場合、それは同じになるということです。

331
00:15:17,606 --> 00:15:21,180
あたかも元の関数のフー リエ変換を個別に取得し、畳み込み

332
00:15:21,180 --> 00:15:23,606
として知られる新しい種類の演算を使用 

333
00:15:23,606 --> 00:15:27,181
してそれらを組み合わせたかのように、次のビデオで詳しく説

334
00:15:27,181 --> 00:15:27,820
明します。

335
00:15:28,500 --> 00:15:31,747
さて、畳み込みについては説明すべきことがたくさんありますが

336
00:15:31,747 --> 00:15:34,995
、結論としては、これら の長方形関数を使用した特定のケース

337
00:15:34,995 --> 00:15:38,131
では、畳み込みは、これまでずっと話してきた移 動平均の 

338
00:15:38,131 --> 00:15:41,378
1 つを組み合わせたものとまったく同じであるということにな

339
00:15:41,378 --> 00:15:44,626
ります。あ るコンテキストでの積分は、別のコンテキストでゼ

340
00:15:44,626 --> 00:15:46,530
ロで評価するように見えるという前 

341
00:15:46,530 --> 00:15:49,778
述の事実に加えて、信じていただければ、あるコンテキストでの

342
00:15:49,778 --> 00:15:52,689
乗算は、この新しい演 算である畳み込みに対応します。

343
00:15:52,689 --> 00:15:55,601
この例では、単純に移動平均と考える必要があります 。

344
00:15:55,601 --> 00:15:58,849
これらの sinc 関数をどんどん乗算すると、これらの漸進

345
00:15:58,849 --> 00:16:02,097
的移動平均と常にゼロ で評価されるという観点から考えること

346
00:16:02,097 --> 00:16:04,560
ができる理由を説明します。これにより、最終 

347
00:16:04,560 --> 00:16:07,808
的に何かが壊れる前になぜそのような安定した値が期待されるの

348
00:16:07,808 --> 00:16:10,496
かについて、非常に素 晴らしい直感が得られます。

349
00:16:10,496 --> 00:16:13,520
台地の端が少しずつ中心に近づくにつれて、下に向かって 

350
00:16:13,520 --> 00:16:14,080
いきます。

351
00:16:15,540 --> 00:16:18,670
ちなみに、この最後の重要な事実には特別な名前があり、畳み込み

352
00:16:18,670 --> 00:16:21,800
定 理と呼ばれます。これについても、さらに詳しく説明します。

353
00:16:22,960 --> 00:16:25,792
3 つの魔法の事実 を並べ立てて、すべてはそこから

354
00:16:25,792 --> 00:16:28,850
導かれると言ってここで話を終えるのは少し満足できない 

355
00:16:28,850 --> 00:16:31,682
かもしれないことは承知していますが、フーリエ変換の

356
00:16:31,682 --> 00:16:33,721
ような強力なツールがなぜ難しい問題 

357
00:16:33,721 --> 00:16:37,120
に非常に役立つのかを少しでも垣間見ることができれば幸いです。

358
00:16:37,600 --> 00:16:40,590
これは、難しい問題が 簡単に見えるよう

359
00:16:40,590 --> 00:16:43,580
に視点を変えるための体系的な方法です。

360
00:16:44,040 --> 00:16:46,359
少なくとも、畳 み込み定理のような美しいものに

361
00:16:46,359 --> 00:16:48,780
ついて学ぶ動機を与えることができれば幸いで す。

362
00:16:49,420 --> 00:16:52,526
もう 1 つの小さなティーザーとして、この畳み込み定理

363
00:16:52,526 --> 00:16:54,597
のもう 1 つ の楽しい結果は、2 

364
00:16:54,597 --> 00:16:57,818
つの大きな数の積を非常に迅速に (可能であると考えられ 

365
00:16:57,818 --> 00:17:00,924
ているよりもはるかに速く) 計算できるアルゴリズムへの

366
00:17:00,924 --> 00:17:01,960
扉を開くことです。

367
00:17:03,000 --> 00:17:04,599
それでは、次のビデオでお会いしましょう。

