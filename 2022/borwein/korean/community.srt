1
00:00:00,000 --> 00:00:05,100
때로는 우주가 여러분을 괴롭히고 있는
것처럼 느낄 수 있습니다. 여기 화면에 일련의

2
00:00:05,100 --> 00:00:09,180
계산들이 있습니다. 그런데, 걱정하지 마세요.
잠시 후에 각각이 실제로 뜻하는

3
00:00:09,180 --> 00:00:12,600
내용을 분석하고 시각화할 것입니다. 여러분이
주목해 주셨으면 하는 것은 어떻게 이 배열들이

4
00:00:12,600 --> 00:00:18,000
예측 가능한 규칙을 따르는지, 무작위한 규칙을
따르는지, 그리고 각 계산이 어떻게 동일하게 π로 나타나는지

5
00:00:18,000 --> 00:00:22,860
입니다. 그리고 만약 여러분이 어떠한 이유로 이것들을
컴퓨터를 가지고 계산하는 데 시간을 쓰고 있다면,

6
00:00:22,860 --> 00:00:28,020
여러분은 이 과정이 영원히 같은 규칙이라고 생각할 수
있습니다. 하지만 그렇지 않습니다. 어느 시점부터,

7
00:00:28,020 --> 00:00:34,440
이러한 규칙은 멈추고 π와 같아지는게 아닌,
π보다 겨우 간신히 작은 값을 얻습니다.

8
00:00:39,600 --> 00:00:43,620
자, 여기서 무슨 일이 일어나고 있는지 알아보겠습니다.
오늘 이야기의 주인공은 sin(𝒙)를 𝒙로 나눈 

9
00:00:43,620 --> 00:00:48,060
함수입니다. 이 함수는
수학과 공학에서 "sinc"라는 이름을

10
00:00:48,060 --> 00:00:52,140
가질 만큼 충분히 흔하게 나타나는데,
여러분이 이것에 대해 생각할 수 있는 방법은

11
00:00:52,140 --> 00:00:56,160
일반적인 진동하는 사인 곡선에
1/𝒙 를 곱하여 0에서 멀어질수록

12
00:00:56,160 --> 00:01:01,080
곡선이 아래로 눌려지는 것입니다.
그러면 여러분 중 영리한 사람은

13
00:01:01,080 --> 00:01:05,880
𝒙에 0을 넣으면 어떻게 되는지 물을 수 있습니다.
0을 넣으면 0 / 0 꼴이 되고,

14
00:01:05,880 --> 00:01:10,440
여기서 미적분을 끝낸
더 영리한 사람은

15
00:01:10,440 --> 00:01:14,820
𝒙값이 0으로 가까워질수록 함수값은 1에
가까워진다고 지적할 수도 있습니다. (𝑺𝒒𝒖𝒆𝒆𝒛𝒆 𝑻𝒉𝒆𝒐𝒓𝒆𝒎; 조임 정리)

16
00:01:14,820 --> 00:01:20,880
따라서 0에서의 sinc 함숫값을 1로 재정의하면,
멋진 연속 곡선을 얻을 수 있습니다.

17
00:01:20,880 --> 00:01:25,200
우리가 실제로 관심을 갖는 것은
음의 무한대에서 무한대로의 이 곡선의 적분이기

18
00:01:25,200 --> 00:01:29,820
때문에 이 정도 쯤은 사소합니다.
곡선과 𝒙축 사이의 면적,

19
00:01:29,820 --> 00:01:34,800
더 정확하게는 부호가 있는 면적을
의미한다고 생각하면 됩니다.

20
00:01:34,800 --> 00:01:38,700
즉, 𝒙축에서 그래프의 양수 부분으로
돼 있는 모든 면적을 더하고,

21
00:01:38,700 --> 00:01:42,420
𝒙축에서 그래프의 음수 부분으로
돼 있는 모든 면적을 뺍니다.

22
00:01:42,420 --> 00:01:47,100
처음에 우리가 보았듯이,
이것은 정확히 π로 계산이 됩니다.

23
00:01:47,100 --> 00:01:51,420
이는 훌륭하면서도 약간 이상하며,
그리고 일반적인 미적분학 도구로 이 문제를 어떻게

24
00:01:51,420 --> 00:01:54,780
접근할 지, 방법이 완전히 명확하지 않습니다.
동영상의 마지막 부분에서,

25
00:01:54,780 --> 00:01:56,580
어떻게 이것을 계산할 수 있는지에 대한
트릭을 공유하겠습니다.

26
00:01:56,580 --> 00:02:00,780
제가 시작한 배열을 계속 진행하고,
다음 단계는 𝒙/3을 대입한

27
00:02:00,780 --> 00:02:06,000
sinc 함수를 가져오는 것입니다.
기본적으로 같은 그래프처럼 보이지만

28
00:02:06,000 --> 00:02:11,100
가로로 3배 늘어납니다.
이 두 함수를 함께 곱하면,

29
00:02:11,100 --> 00:02:15,780
각각의 함수들보다 질량이 중간에 더 집중된
것처럼 보이는 훨씬 더 복잡한 파동이 생성되며,

30
00:02:15,780 --> 00:02:20,040
여러분은 이것이 면적을 완전히
바꿀 것이라고 예상할 수 있습니다.

31
00:02:20,040 --> 00:02:23,760
이와 같이 적분을 무작위로 수정하고,
아무 것도 변경되지 않을 것으로 기대할 수는 없습니다.

32
00:02:23,760 --> 00:02:28,500
그런데 이미, 이 결과가 π와 같다는 것이
조금 이상합니다. 아무것도 바뀌지 않았다는 

33
00:02:28,500 --> 00:02:32,700
것입니다. 이것은 여러분의 리스트에 추가해야
할 또 다른 미스터리입니다. 그리고 이 배열의 다음 단계는

34
00:02:32,700 --> 00:02:36,600
sinc 함수의 훨씬 더 확장된 버전인
5를 인수로 취하는 것 입니다.

35
00:02:36,600 --> 00:02:42,480
그리고 우리가 이미 가지고 있는 것을 곱한 다음,
다시 전체 곡선에 있는 부호 면적을 보면,

36
00:02:42,480 --> 00:02:47,340
이것은 다시 π와 같습니다.
그리고 계속 이렇게 됩니다. 반복할 때마다

37
00:02:47,340 --> 00:02:50,940
새로운 홀수를 늘리고
우리가 가지고 있는 것에 곱합니다.

38
00:02:50,940 --> 00:02:55,920
한 가지 알아차릴 수 있는 것은
𝒙 = 0 일 때를 제외하고,

39
00:02:55,920 --> 00:02:59,700
이 함수의 모든 부분이 1보다
작은 값으로 계속해서 곱해지는 것 입니다.

40
00:03:00,300 --> 00:03:04,440
따라서 배열이 진행됨에 따라 그래프가
점점 더 찌그러질 것으로 예상할 수 있으며,

41
00:03:04,440 --> 00:03:08,940
어떤 경우에는 면적이 더 작아질 것으로
예상할 수 있습니다. 결국은,

42
00:03:08,940 --> 00:03:14,880
이것은 당연히 언젠가는 일어나는 일이지만, 이상한 점은
이것이 너무 오랫동안 안정적으로 유지된다는 것입니다.

43
00:03:14,880 --> 00:03:20,700
물론 더 정확하게는 값이 15일 때 작아지는데,
아주 적은 양으로 작아집니다.

44
00:03:20,700 --> 00:03:24,300
그리고 이것이 어떤 수치적 오류의
결과라고 생각하기 전에, 아마도

45
00:03:24,300 --> 00:03:28,260
우리가 부동소수점 연산으로 무언가를 하고 있기
때문일 것입니다. 좀 더 정확하게 계산해 보면,

46
00:03:28,260 --> 00:03:33,900
여기 마지막 부분에 정확한 값이 있습니다.
분자와 분모에 π가 있는

47
00:03:33,900 --> 00:03:38,940
터무니없이 보이는 분수입니다.
둘 다 약 400의 10억의 10억의 10억 입니다.
(40양; 40*{100조}²; 7 * 아보가드로수 * 1만; 4.67*10²⁹)

48
00:03:40,380 --> 00:03:43,740
그래서, 이 규칙은 한 가정의 아버지와 아들인
𝑱𝒐𝒏𝒂𝒕𝒉𝒂𝒏과 𝑫𝒂𝒗𝒊𝒅 𝑩𝒐𝒓𝒘𝒆𝒊𝒏이

49
00:03:43,740 --> 00:03:47,340
한 논문에서 설명했습니다.
매우 재미있는 내용인데,

50
00:03:47,340 --> 00:03:50,880
동료 연구원이 컴퓨터 대수학 시스템을
사용하여 이러한 적분을 계산할 때

51
00:03:50,880 --> 00:03:56,400
이것이 일종의 버그일 것이라고
가정했지만 버그가 아니었습니다. 실제 현상입니다.

52
00:03:56,400 --> 00:04:00,840
그리고 이것은 실제로 더 이상합니다.
만약 우리가 이 모든 적분을 계산하고

53
00:04:00,840 --> 00:04:06,060
또 다른 인자 2cos(𝒙)를 넣는다면,
여러분은 이 값이 완전히 변경된다고 생각할 것입니다

54
00:04:06,060 --> 00:04:10,560
여러분은 여기에 무작위로 새로운 것을 곱할 수 없습니다.
2cos(𝒙)를 넣으면 계속해서 훨씬 더

55
00:04:10,560 --> 00:04:16,080
오랫동안 같은 π를 유지하고 숫자 113에
도달하기 전 까진 깨지지 않습니다.

56
00:04:16,080 --> 00:04:19,620
그리고 값이 깨졌을 때, 그것은 여러분이
상상할 수 있는 아주 보잘 것없는 미미한 양입니다.

57
00:04:20,340 --> 00:04:25,080
그래서, 자연스러운 질문은 - 도대체 여기서
무슨 일이 일어나고 있는 걸까요? 그리고

58
00:04:25,080 --> 00:04:28,740
운 좋게도 실제로 이 모든 것에 대한 정말
만족스러운 설명이 있습니다. 제가

59
00:04:28,740 --> 00:04:32,160
이 문제에 대해 보여줄 방법은
처음에는 전혀 관련이 없어 

60
00:04:32,160 --> 00:04:36,420
보이지만,  비슷한 패턴을 보이는
것입니다. 15에 도달할 때 까지는 정말로 

61
00:04:36,420 --> 00:04:40,680
안정적인 값을 가진 다음
아주 작은 양만큼 흔들리는 것입니다.

62
00:04:40,680 --> 00:04:44,100
그런 다음, 겉보기에 관련이 없어
보이는 이 현상이 왜 우리의 모든

63
00:04:44,100 --> 00:04:49,260
적분 표현과 비밀리에 동일하지만
숨겨져 있는지 보여드리겠습니다.

64
00:04:49,260 --> 00:04:53,280
따라서 완전히 다르게 보이는 것에
주의를 돌려보면, 즉, 𝒙의 값이

65
00:04:53,280 --> 00:04:59,040
-½ ~ ½ 일때 함수값이 1,
다를 때는 함수값이 0인

66
00:04:59,580 --> 00:05:04,680
rect(𝒙) 함수를 고려해봅시다.
함수는 기본적으로 별거 없는 단계입니다.

67
00:05:04,680 --> 00:05:10,260
이것은 우리가 정의한 일련의 함수에서
첫 번째가 될 것이므로 𝒇₁(𝒙)라고 부르고,

68
00:05:10,260 --> 00:05:14,700
이 일련 중 각각의 새로운 함수는
이전 함수의 이동 평균의 일종이 될 것입니다.

69
00:05:15,660 --> 00:05:20,280
예를 들어, 두 번째 반복이
정의되는 방법은 특정한 입력 𝒙에 대해

70
00:05:20,280 --> 00:05:26,820
너비가 ⅓인 슬라이딩 창을 취하는 것이고,
창이 입력 𝒙의 중앙에 있을 때,

71
00:05:26,820 --> 00:05:32,280
아래에 그려진 새로운 함수의 값은
첫 번째 함수에서, 창에 해당하는 함수 값의 평균과

72
00:05:32,280 --> 00:05:36,960
같도록 정의합니다. 예를 들어,
창이 왼쪽으로 충분히 멀리 떨어져 있으면

73
00:05:36,960 --> 00:05:41,880
그 안의 모든 값이 0이므로 맨 아래의 그래프는
0을 표시합니다. 해당 창이 고원을

74
00:05:41,880 --> 00:05:46,440
약간 넘어가기 시작하면, 평균 값이
0보다 약간 크며 아래 그래프에서

75
00:05:46,440 --> 00:05:51,120
볼 수 있습니다. 그리고 창의 절반이 값이
1인 고원에 있고, 나머지 절반이 0이면,

76
00:05:51,120 --> 00:05:56,220
하단 그래프에 대응하는 값은 1의 절반이고,
여러분은 요점을 파악할 수 있습니다.

77
00:05:56,220 --> 00:06:01,740
제가 여러분이 주목해 주셨으면 하는 중요한 것은
어떻게 창이 모든 값이 1인 고원 위에 있을 때,

78
00:06:01,740 --> 00:06:06,900
평균값도 1이 되는가 하는 것입니다.
결론은, 우리는 이 고원을

79
00:06:06,900 --> 00:06:11,760
밑에 있는 함수에서도 얻습니다. 이 하단에 있는
함수를 𝒇₂(𝒙)라고 하고, 제가 여러분이 생각하기를

80
00:06:11,760 --> 00:06:16,680
바라는 것은 두 번째 함수에 대한 고원의
길이입니다. 길이가 얼마나 되어야 할까요?

81
00:06:16,680 --> 00:06:22,140
잠시 생각해보면, 위에 있는
고원의 왼쪽 끝과 아래에 있는

82
00:06:22,140 --> 00:06:26,940
고원의 왼쪽 끝 사이의 거리는 정확히
창 너비의 절반이 될 것입니다. 따라서,

83
00:06:26,940 --> 00:06:32,100
⅓의 절반이 오른쪽에도 같듯이,
고원의 양끝의 거리는 창 너비의

84
00:06:32,100 --> 00:06:36,780
절반입니다. 따라서 전체적으로,
1에서 해당 창 너비를 빼는데, 1-⅓이 됩니다.

85
00:06:37,380 --> 00:06:40,800
우리가 계산할 값, 즉 값이
깨지기 전에 안정적으로

86
00:06:40,800 --> 00:06:45,660
보여할 것은 𝒙=0 일 때의
함숫값 입니다. 이 함숫값은

87
00:06:45,660 --> 00:06:50,280
이 두 반복들에서 값이 1로 같은데, 왜냐하면
고원 내부에 있기 때문입니다. 다음 반복에서는,

88
00:06:50,280 --> 00:06:54,060
방금 전 함수의 이동 평균을
취하지만 이번에는 너비가

89
00:06:54,060 --> 00:06:58,740
⅟₅인 창을 사용합니다.
이 창을 슬라이드하면서 이 주위가

90
00:06:58,740 --> 00:07:03,540
이전 함수에 비해 부드러운 버전을 얻는
이유에 대해 생각하는 것은 일종의 재미입니다.

91
00:07:03,540 --> 00:07:07,800
그리고 다시 한 번 말씀드리지만 중요한 점은
해당 창이 완전히 이전 함수의 고원 안에 있는

92
00:07:07,800 --> 00:07:11,760
경우입니다. 그러면 정의에 따라
맨 아래 함숫값은 1과 같습니다.

93
00:07:11,760 --> 00:07:16,260
이번에는, 밑에 있는 고원의
길이는 이전 것의 길이인

94
00:07:16,260 --> 00:07:21,960
1- ⅓에서 ⅕인 창 너비를 뺀 값이 됩니다.
추론은 이전과 동일합니다.

95
00:07:21,960 --> 00:07:25,740
창의 중앙이 고원의 끝 부분에서,
창 전체가 해당 고원 내부에

96
00:07:25,740 --> 00:07:29,340
있는 지점으로 이동하기까지의
거리는 창 너비의 절반이고,

97
00:07:29,340 --> 00:07:33,600
마찬가지로 오른쪽 부분도
그렇고, 𝒙=0일 때의 함수값도 

98
00:07:33,600 --> 00:07:37,200
그 전 추론과 동일합니다.
다시 말하지만, 정확히 1입니다.

99
00:07:38,460 --> 00:07:43,140
다음 반복은 창 너비가 ⅐인
이동 평균입니다. 고원은 ⅐만큼

100
00:07:43,140 --> 00:07:49,020
작아집니다. ⅑로 한 번 더 반복하면,
고원은 그 양만큼 작아집니다.

101
00:07:49,020 --> 00:07:54,600
그리고 계속 진행하면서, 고원은 점점 더
얇아지고 또한 고원의 바로 바깥쪽에 있는

102
00:07:54,600 --> 00:07:59,040
부분이 1에 정말 가까워지는
것을 알 수 있습니다.

103
00:07:59,040 --> 00:08:02,700
이 부분은 값이 1인 고원과 그 근방의
평균인데 정말로 1에 가깝습니다.

104
00:08:03,300 --> 00:08:06,960
이 모든 것이 깨지는 지점은
슬라이딩 창의

105
00:08:06,960 --> 00:08:10,260
너비가 ⅟₁₅인 반복에
도달할 때 입니다.

106
00:08:10,920 --> 00:08:15,300
이 시점에서, 이전 고원은 실제로
창 자체보다 얇습니다. 따라서

107
00:08:15,300 --> 00:08:21,480
𝒙=0 에서도, 이 이동 평균은
1보다 약간 작아야 합니다.

108
00:08:21,480 --> 00:08:26,100
그리고 여기서 숫자 15의 특별한 점은
이 홀수들의 역수를 계속해서

109
00:08:26,100 --> 00:08:31,320
더한다는 것입니다. ⅓ + ⅕ + ⅐,
계속해서 1/15에 도달하면 합은

110
00:08:31,320 --> 00:08:36,600
1보다 커지며, 너비가 1인
고원이 축소되는 과정이,

111
00:08:36,600 --> 00:08:41,700
이제 고원 전체가 사라질
정도로 축소되었습니다.

112
00:08:41,700 --> 00:08:46,860
요점은, 우리가 겉보기에는 무작위적인
절차로 정의한 일련의 함수에서,

113
00:08:46,860 --> 00:08:50,520
제가 여러분에게 𝒙=0에서 이러한
모든 함수의 값을 계산하도록 요청하면

114
00:08:50,520 --> 00:08:55,920
처음에는 안정적으로 보이는 패턴을 얻게
됩니다. 1, 1, 1, 1, 1, 1, 1, 하지만

115
00:08:55,920 --> 00:09:00,180
여덟 번째 반복에 도달할 즈음에는
거의 미묘하게 부족합니다.

116
00:09:00,900 --> 00:09:05,400
이것은 유사하며, 저는 우리가 이전에 보았던
적분과 유사하다고 주장하는 것 입니다.

117
00:09:05,400 --> 00:09:10,560
여기서 π, π, π, π, π는 거의 부족할
때까지 안정적인 값을 갖습니다.

118
00:09:10,560 --> 00:09:15,600
그리고 1보다 약간 작은
이동 평균 과정의 이 상수는

119
00:09:15,600 --> 00:09:20,640
일련의 적분에서 π 앞에
있는 수와 같습니다. 따라서,

120
00:09:20,640 --> 00:09:24,900
두 상황은 질적으로 유사할 뿐만
아니라 양적으로도 동일합니다.

121
00:09:24,900 --> 00:09:29,880
그리고 적분 내부에 2cos(𝒙)를 추가하여,

122
00:09:29,880 --> 00:09:34,080
패턴이 고장나기 전을 훨씬
더 오래 지속되도록 하는 경우,

123
00:09:34,080 --> 00:09:37,620
이 유사점에서 어떻게 값이 대응할 지는
동일한 설정이지만, 여기서 우리가 시작하는 함수는

124
00:09:37,620 --> 00:09:43,740
𝒙=-1에서 1까지 늘어나는 더 긴 고원을 가지게
됩니다. 즉 길이가 2인 고원을 의미합니다. 따라서,

125
00:09:43,740 --> 00:09:48,060
이 반복적인 이동 평균 과정을 수행하면서,
점점 더 작은 창으로 그것을 먹어치우면,

126
00:09:48,060 --> 00:09:53,040
이들이 전체 고원을 먹는 데 훨씬 더 오랜
시간이 걸립니다. 보다 구체적으로,

127
00:09:53,040 --> 00:09:58,200
이와 관련있는 계산은 다음과 같은 질문을 하는 것입니다.
합이 2보다 커질 때까지 홀수의 역수를 얼마나

128
00:09:58,200 --> 00:10:03,900
더 추가해야 할까요? 그리고 여러분은 숫자 113 까지
도달해야 한다고 밝혀졌습니다. 이 뜻은

129
00:10:03,900 --> 00:10:08,700
113에 도달할 때까지 적분 패턴이
계속된다는 사실에 해당합니다.

130
00:10:09,240 --> 00:10:13,320
그런데, 저는 이러한 홀수의 역수에는
특별한 것이 없음을 강조합니다.

131
00:10:13,320 --> 00:10:17,760
⅓, ⅕, ⅐ - 𝑩𝒐𝒓𝒘𝒆𝒊𝒏𝒔이 논문에서
강조한 배열의 값으로 인해,

132
00:10:17,760 --> 00:10:21,660
해당 배열이 괴상한 원에서
약간 유명해졌습니다.

133
00:10:21,660 --> 00:10:26,520
더 일반적으로, 우리는 sinc 함수에
임의의 양수 수열을 넣을 수 있으며

134
00:10:26,520 --> 00:10:31,440
해당 숫자의 합이 1보다 작으면
표현식은 π와 같지만,

135
00:10:31,440 --> 00:10:36,300
1보다 커지면 표현식이 π보다 작아집니다.
그리고 이러한 이동 평균과

136
00:10:36,300 --> 00:10:39,840
유사한 점이 있다고 생각한다면
그 이유를 알 수 있기를 바랍니다.

137
00:10:42,060 --> 00:10:46,740
그러나 물론 화급한 질문은
도대체 왜 이 두 상황이 서로 관련이 있어야

138
00:10:46,740 --> 00:10:51,540
하느냐는 것입니다. 여기에서,
이 논증은 약간 무거운 기술 두 개를 

139
00:10:51,540 --> 00:10:57,060
가져옵니다. 바로, "푸리에 변환" 그리고 "합성곱"입니다.
그리고 제가 이것에 대해 말하고 싶은 방법은,

140
00:10:57,060 --> 00:11:00,960
이 영상의 나머지 부분을 여러분이 이 두 가지 주제 중
어느 하나에 익숙하다고 가정하지 않고, 

141
00:11:00,960 --> 00:11:04,620
논증이 어떻게 진행될지에 대한
높은 수준의 감각을 제공하는 것입니다.

142
00:11:04,620 --> 00:11:08,880
그리고 나서 왜 이러한 디테일들이
합성곱 전용 영상에서 사실인지 설명하는 것입니다.

143
00:11:08,880 --> 00:11:13,380
특히 "𝑻𝒉𝒆 𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏 𝑻𝒉𝒆𝒐𝒓𝒆𝒎"이라고 불리는 것은

144
00:11:13,380 --> 00:11:18,120
믿을 수 없을 정도로 아름답고 이러한
매우 난해한 질문을 넘어 훨씬 유용하기 때문입니다.

145
00:11:20,640 --> 00:11:26,820
시작하기 위해, 이 함수 sin(𝒙)/𝒙에 초점을 맞추는 대신,
즉 곡선 아래의 부호 면적이

146
00:11:26,820 --> 00:11:31,020
π와 같은 이유를 보여주고자 하는 대신,
입력 𝒙를 π*𝒙로 바꾸는 간단한

147
00:11:31,020 --> 00:11:36,180
치환을 할 것입니다. 이는 그래프의
가로를 π만큼 찌그러뜨리는

148
00:11:36,180 --> 00:11:40,380
효과가 있으므로 넓이는 π만큼 축소됩니다.

149
00:11:40,380 --> 00:11:44,940
즉, 우리의 새로운 목표는 오른쪽의 이 적분이
정확히 1과 같은 이유를 보여주는 것입니다.

150
00:11:44,940 --> 00:11:50,520
그건 그렇고, 일부 공학 측면에서,
사람들은 내부에 π가 있는 이 함수를 지칭하기 위해

151
00:11:50,520 --> 00:11:55,080
"sinc"라는 이름을 사용합니다. 왜냐하면 면적이
1인 거와 같이, 정규화된 함수를 갖는 것은 종종

152
00:11:55,080 --> 00:11:59,340
매우 좋기 때문입니다. 요점은,
오른쪽에 표시된 적분은,

153
00:11:59,340 --> 00:12:03,480
왼쪽에 표시된 적분과 정확히 동일하며,
그저 변수의 변환일 뿐입니다. 그리고 마찬가지로

154
00:12:03,480 --> 00:12:09,600
우리 배열의 모든 것들에서,
각각을 살펴보고 𝒙를 π*𝒙로 바꿔봅시다.

155
00:12:09,600 --> 00:12:13,680
여기에서 주장하는 것은 이 모든 적분이
이동 평균 예제와 유사할 뿐만 아니라,

156
00:12:13,680 --> 00:12:18,900
둘 다 서로 같은 것을 계산하는
별개의 두 가지 계산 방법입니다. 그리고

157
00:12:18,900 --> 00:12:23,220
sinc 함수와 π가 있는
엔지니어 sinc 함수의 내부적인 연관성은

158
00:12:23,220 --> 00:12:27,720
푸리에 변환으로 알고있는
rect함수와 연관돼있다고 할 수 있습니다.

159
00:12:27,720 --> 00:12:32,160
이제 푸리에 변환에 대해 들어본 적이 없으시다면,
이 채널에 이에 관한 몇 가지 다른 영상들이 있습니다. (많시부)

160
00:12:32,160 --> 00:12:35,700
자주 설명되는 방식은,
함수를 순수 파동의 합으로 나누거나,

161
00:12:35,700 --> 00:12:39,960
또는 무한 함수의 경우, 

162
00:12:39,960 --> 00:12:44,040
순수 파동의 연속적인 적분인 푸리에 변환은

163
00:12:44,040 --> 00:12:47,700
모든 구성 부분의 강도와 단계를
여러분에게 알려줍니다.

164
00:12:47,700 --> 00:12:52,500
그러나 여기에서 정말로 알아야 할 것은
하나의 함수를 취하고

165
00:12:52,500 --> 00:12:56,580
새로운 함수를 만드는 것인데, 여러분은
원래 함수의 정보를 다른 언어로

166
00:12:56,580 --> 00:13:00,600
바꾸는 것처럼 생각하는 경우가 많습니다.
마치 이것을 새로운 관점에서 바라보는 것처럼 말이죠.

167
00:13:00,600 --> 00:13:05,520
예를 들어, 제가 말했듯이, 푸리에 변환을
취하는 이 새로운 언어로 작성된 이 sinc 함수는

168
00:13:05,520 --> 00:13:10,860
우리의 top hat rect 함수처럼 보입니다.
그리고 그 반대의 경우도 마찬가지입니다.

169
00:13:10,860 --> 00:13:14,940
이것은 푸리에 변환의 좋은 것인
𝒚축에 대칭인 함수입니다.

170
00:13:14,940 --> 00:13:19,620
즉, 역함수이며, 실제로 우리가
보여야 할 약간 더 일반적인 사실은

171
00:13:19,620 --> 00:13:23,340
우리의 sinc 함수의 확장된
버전을 변환할 때입니다.

172
00:13:23,340 --> 00:13:28,200
함수를 𝒌만큼 수평으로 늘리면, 이 rect 함수는
늘어나거나 찌그러진 버전이 됩니다.

173
00:13:28,200 --> 00:13:32,880
그러나, 물론 이러한 번역을 할 때
실제로 무언가를 할 수 없다면 이 모든 것은

174
00:13:32,880 --> 00:13:37,860
의미 없는 단어와 용어일 뿐입니다.
푸리에 변환이 수학에 매우 유용한 이유에

175
00:13:37,860 --> 00:13:41,280
대한 진짜 아이디어는
특정 함수에 대한

176
00:13:41,280 --> 00:13:46,320
진술과 질문을 받을 때,
그리고 함수의 변환된 버전과

177
00:13:46,320 --> 00:13:50,340
관련한 진술 및 질문들이
이 새로운 언어에서는

178
00:13:50,340 --> 00:13:55,020
종종 매우 다르게 보이며
때로는 질문에 답하기가 훨씬 쉽습니다.

179
00:13:55,020 --> 00:13:59,280
예를 들어, 우리의 리스트에
있는 것 중 보여드릴

180
00:13:59,280 --> 00:14:03,660
아주 좋은 사실 하나는,
음의 무한대에서 무한대까지 몇몇 함수의

181
00:14:03,660 --> 00:14:08,760
적분을 계산하려는 경우는,
즉 곡선 아래의 이 부호 면적은, 

182
00:14:08,760 --> 00:14:14,700
푸리에 변환이 된 함수에서
𝒙=0 값을 계산하는 것과 같습니다.

183
00:14:14,700 --> 00:14:19,020
이러한 정의에서 바로 튀어나온 사실은
오른쪽의 푸리에 변환 함수의

184
00:14:19,020 --> 00:14:23,700
모든 각각의 함숫값이
왼쪽의 원래 함수에 대한 일종의

185
00:14:23,700 --> 00:14:28,260
모든 정보에 해당한다는,
더 일반적인 경우를 대표합니다.

186
00:14:28,260 --> 00:14:32,880
우리의 특정한 경우,
만약 여러분이 이 sinc 함수와

187
00:14:32,880 --> 00:14:35,700
rect 함수가 이렇게 푸리에 변환과
관련이 있다고 여긴다면,

188
00:14:35,700 --> 00:14:39,900
이것은 적분을 설명하는데는
매우 까다롭습니다. 왜냐하면

189
00:14:39,900 --> 00:14:45,120
모든 부호 면적은 함숫값이 1인, 즉 𝒙=0에서의
rect 함수를 계산하는 것과 같기 때문입니다.

190
00:14:46,200 --> 00:14:50,520
이제, 여러분은 불평할 수도 있습니다
확실히 이 부분은 뭔가를 숨긴 것 같습니다. 확실히  

191
00:14:50,520 --> 00:14:54,240
이 푸리에 변환을 계산하는 것은,
원래 적분을 계산하는 것만큼 어려울

192
00:14:54,240 --> 00:14:58,140
것입니다. 그러나 아이디어는 이러한 푸리에 변환을
계산하기 위한 많은 팁과 트릭이 있다는 것입니다.

193
00:14:58,140 --> 00:15:02,940
게다가 이렇게 계산을 할 때, 적분을
할 때 보다 훨씬 더 많은 정보를

194
00:15:02,940 --> 00:15:06,420
알려줍니다. 여러분은 더 많은 계산을 함으로써
더 많은 결과를 얻을 수 있습니다.

195
00:15:06,420 --> 00:15:11,040
자, 연결성에 관해서
우리가 찾는 또 다른 핵심 사실은

196
00:15:11,040 --> 00:15:15,180
만약 당신이 두 개의 다른 함수를 가지고 있고,
그 함수들끼리 곱을 하고,

197
00:15:15,180 --> 00:15:19,920
그 다음 푸리에 변환을 취하는 것은,
원래 각각의 함수에 푸리에 변환을

198
00:15:19,920 --> 00:15:24,120
개별적으로 취한 다음,
제가 다음 영상에서 다룰 새로운

199
00:15:24,120 --> 00:15:27,780
연산자인 합성곱(𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏)을
사용해서 그것들을 결합하는 것과 같다는 것 입니다. 

200
00:15:27,780 --> 00:15:32,640
자, 합성곱에 대해서 설명해야 할 것이
많지만, 결론은

201
00:15:32,640 --> 00:15:38,580
이러한 직사각형 함수의 특정 경우에
합성곱을 취하는 것이,

202
00:15:38,580 --> 00:15:42,360
우리가 지금까지 다뤄온 이동 평균 중
하나처럼 보인다는 것입니다.

203
00:15:42,360 --> 00:15:47,280
“한 상황”에서의 적분이,
“다른 상황”에서는 x=0 일 때의 계산되는 것처럼

204
00:15:47,280 --> 00:15:52,680
보인다는 이전의 사실과 결합하면,
우리의 예시에서 이동평균으로 생각되는,

205
00:15:52,680 --> 00:15:55,920
“한 상황”에서의 곱하는 것은 새로운 연산,
합성곱(𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏)에 해당한다는 것이며,

206
00:15:55,920 --> 00:16:00,600
이는 이러한 sinc 함수를 점점 더 많이 곱하는 것을,
이러한 𝒙=0 에서의 값을 계산하는

207
00:16:00,600 --> 00:16:04,920
점진적인 이동 평균의 관점으로
생각할 수 있는 이유를 설명할 것입니다.

208
00:16:04,920 --> 00:16:09,780
결국 이것은 결국 고원의 가장자리가
점점 중심에 가까워지면서 무언가가

209
00:16:09,780 --> 00:16:14,100
무너지기 전에 왜 그렇게 안정적인 값을 기대할 수 있는지에
대해 정말 멋진 직관을 제공할 수 있습니다.

210
00:16:15,480 --> 00:16:19,980
그런데 이 마지막 핵심 사실은
특별한 이름을 가지고 있습니다.

211
00:16:19,980 --> 00:16:21,960
𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏 𝑻𝒉𝒆𝒐𝒓𝒆𝒎이라고 하며,
우리가 훨씬 더 깊이 탐구할 것입니다.

212
00:16:22,800 --> 00:16:27,960
저는 여기서 세 가지 마법같은 사실을 제시하고
"모든 것은 그것들에서 비롯된다"고

213
00:16:27,960 --> 00:16:31,920
말함으로써, 일을 끝내는 것은
약간 불만족스러울 수 있다는 것을 알고 있습니다.

214
00:16:31,920 --> 00:16:37,200
하지만 이것이 푸리에 변환과 같은 강력한 도구가 이러한 까다로운
문제에 왜 그렇게 유용한지 깨닫기를 바랍니다.

215
00:16:37,740 --> 00:16:42,600
어려운 문제가 때때로 더 쉬워 보일 수 있는
관점의 전환을 제공하는

216
00:16:42,600 --> 00:16:46,500
체계적인 방법입니다. 다른 것은 아니지만,
𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏 𝑻𝒉𝒆𝒐𝒓𝒆𝒎과 같은

217
00:16:46,500 --> 00:16:49,080
아름다운 것들에 대해 배울 수 있는
동기가 제공됐기를 바랍니다.

218
00:16:49,080 --> 00:16:53,640
또 하나의 작은 티저로서,
이 𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏 𝑻𝒉𝒆𝒐𝒓𝒆𝒎의

219
00:16:53,640 --> 00:16:57,840
또 다른 재미있는 결과는
두 개의 큰 수의 곱을

220
00:16:57,840 --> 00:17:01,980
매우 빠르게 계산할 수 있는
알고리즘의 문을 열어준다는 것입니다.

221
00:17:02,940 --> 00:17:04,740
그럼, 다음 영상(합성곱)에서 뵙겠습니다.

