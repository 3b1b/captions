1
00:00:00,000 --> 00:00:01,490
가끔은 우주가 나를 괴롭히는 

2
00:00:01,490 --> 00:00:02,980
것처럼 느껴질 때가 있습니다.

3
00:00:03,340 --> 00:00:05,784
여기 화면에 일련의 계산이 표시되어 있는데, 

4
00:00:05,784 --> 00:00:08,228
잠시 후에 각 계산이 실제로 무엇을 말하는지 

5
00:00:08,228 --> 00:00:10,380
풀어보고 시각화할 테니 걱정하지 마세요.

6
00:00:10,920 --> 00:00:13,362
제가 주목하고 싶은 것은 이 수열이 무작위로 

7
00:00:13,362 --> 00:00:15,706
보이지만 매우 예측 가능한 패턴을 따르고, 

8
00:00:15,706 --> 00:00:18,540
각 계산이 어떻게 파이와 같아지는지에 대한 것입니다.

9
00:00:19,080 --> 00:00:22,479
컴퓨터로 이런 것들을 평가하는 데만 급급하다면 이런 

10
00:00:22,479 --> 00:00:25,880
패턴이 영원히 지속될 것이라고 생각할 수도 있습니다.

11
00:00:25,880 --> 00:00:27,100
하지만 그렇지 않습니다.

12
00:00:27,400 --> 00:00:30,515
어느 시점에서 멈추고 파이와 같지 않고 

13
00:00:30,515 --> 00:00:34,340
파이보다 간신히, 간신히 적은 값을 얻게 됩니다.

14
00:00:38,780 --> 00:00:39,892
자, 이제 무슨 일이 벌어지고 

15
00:00:39,892 --> 00:00:40,940
있는지 자세히 살펴보겠습니다.

16
00:00:41,300 --> 00:00:43,250
오늘 이야기의 주인공은 x를 

17
00:00:43,250 --> 00:00:45,080
x로 나눈 사인 함수입니다.

18
00:00:45,460 --> 00:00:48,189
이것은 실제로 수학과 공학에서 자주 등장하는 

19
00:00:48,189 --> 00:00:51,464
개념으로, sinc라는 고유한 이름을 가지고 있으며, 

20
00:00:51,464 --> 00:00:53,976
일반적인 진동 사인 곡선으로 시작한 다음 

21
00:00:53,976 --> 00:00:56,596
0에서 멀어질수록 1에 x를 곱하여 곡선을 

22
00:00:56,596 --> 00:00:58,780
쪼개는 방식으로 생각할 수 있습니다.

23
00:00:59,300 --> 00:01:01,473
여러분 중 영리한 분들은 x가 0이 되면 어떻게 

24
00:01:01,473 --> 00:01:02,922
되는지 궁금해하실 수도 있는데, 

25
00:01:02,922 --> 00:01:04,934
이 값을 연결하면 0을 0으로 나누는 것처럼 

26
00:01:04,934 --> 00:01:05,740
보이기 때문입니다.

27
00:01:06,400 --> 00:01:09,126
미적분학 수업을 막 끝낸 좀 더 영리한 분이라면 

28
00:01:09,126 --> 00:01:11,852
0에 점점 더 가까워지는 값에 대해 함수가 1에 

29
00:01:11,852 --> 00:01:14,780
점점 더 가까워진다는 점을 지적할 수 있을 것입니다.

30
00:01:15,260 --> 00:01:17,688
따라서 sinc 함수를 0에서 1로 간단히 

31
00:01:17,688 --> 00:01:20,320
재정의하면 멋진 연속 곡선을 얻을 수 있습니다.

32
00:01:20,320 --> 00:01:24,224
우리가 실제로 관심을 갖는 것은 음의 무한대에서 

33
00:01:24,224 --> 00:01:26,682
무한대까지의 곡선의 적분인데, 

34
00:01:26,682 --> 00:01:29,285
이는 곡선과 X축 사이의 면적, 

35
00:01:29,285 --> 00:01:32,033
더 정확하게는 부호가 붙은 면적, 

36
00:01:32,033 --> 00:01:35,937
즉 그래프의 양의 부분으로 묶인 부분을 X축에서 

37
00:01:35,937 --> 00:01:39,697
모두 더하고 음의 부분과 X축으로 묶인 부분을 

38
00:01:39,697 --> 00:01:42,300
모두 뺀다고 생각할 수 있습니다.

39
00:01:42,740 --> 00:01:45,322
처음에 살펴본 것처럼, 이것이 정확히 파이로 

40
00:01:45,322 --> 00:01:47,801
평가되는 경우가 발생하는데, 이는 멋지기도 

41
00:01:47,801 --> 00:01:50,280
하고 약간 이상하기도 하며 일반적인 미적분 

42
00:01:50,280 --> 00:01:53,380
도구로 어떻게 접근해야 할지 완전히 명확하지 않습니다.

43
00:01:53,980 --> 00:01:55,236
동영상 말미에 이 작업을 수행하는 

44
00:01:55,236 --> 00:01:56,560
방법에 대한 비결을 알려드리겠습니다.

45
00:01:56,840 --> 00:02:00,558
제가 열었던 시퀀스를 계속 진행하면서 다음 단계는 

46
00:02:00,558 --> 00:02:04,409
기본적으로 동일한 그래프처럼 보이지만 가로로 3만큼 

47
00:02:04,409 --> 00:02:08,259
늘어나는 sinc 함수의 복사본을 가져오는 것입니다.

48
00:02:08,900 --> 00:02:11,478
이 두 함수를 곱하면 질량이 가운데로 더 

49
00:02:11,478 --> 00:02:13,945
집중되는 것처럼 보이는 훨씬 더 복잡한 

50
00:02:13,945 --> 00:02:16,524
파동을 얻을 수 있으며, 일반적인 함수를 

51
00:02:16,524 --> 00:02:19,215
사용하면 영역이 완전히 바뀔 것으로 예상할 

52
00:02:19,215 --> 00:02:20,000
수 있습니다.

53
00:02:20,380 --> 00:02:21,838
이런 적분을 임의로 수정하고 아무 

54
00:02:21,838 --> 00:02:23,680
변화가 없을 것이라고 기대할 수는 없습니다.

55
00:02:24,260 --> 00:02:26,421
따라서 이 결과도 파이와 같고 아무것도 

56
00:02:26,421 --> 00:02:28,780
변하지 않았다는 것이 이미 조금 이상합니다.

57
00:02:29,080 --> 00:02:31,180
이것도 목록에 추가해야 할 또 다른 미스터리입니다.

58
00:02:31,660 --> 00:02:34,807
그리고 시퀀스의 다음 단계는 sinc 함수의 

59
00:02:34,807 --> 00:02:37,326
더 늘어난 버전에 5를 곱한 다음, 

60
00:02:37,326 --> 00:02:40,222
이미 가지고 있는 값에 곱하고 다시 전체 

61
00:02:40,222 --> 00:02:44,000
곡선 아래의 부호가 있는 영역을 살펴보는 것이었습니다.

62
00:02:44,860 --> 00:02:46,480
그리고 이런 식으로 계속 진행됩니다.

63
00:02:46,580 --> 00:02:48,874
반복할 때마다 새로운 홀수를 늘려서 

64
00:02:48,874 --> 00:02:50,940
현재 가지고 있는 값에 곱합니다.

65
00:02:51,640 --> 00:02:54,085
한 가지 눈에 띄는 점은 입력 x가 0인 

66
00:02:54,085 --> 00:02:56,530
경우를 제외하고는 이 함수의 모든 부분에 

67
00:02:56,530 --> 00:02:59,720
1보다 작은 값이 점진적으로 곱해지고 있다는 점입니다.

68
00:03:00,340 --> 00:03:02,633
따라서 시퀀스가 진행됨에 따라 사물이 

69
00:03:02,633 --> 00:03:04,818
점점 더 쪼그라들고, 오히려 영역이 

70
00:03:04,818 --> 00:03:07,440
점점 더 작아질 것으로 예상할 수 있습니다.

71
00:03:08,360 --> 00:03:11,319
결국 그렇게 되지만, 기이한 점은 너무 

72
00:03:11,319 --> 00:03:14,278
오랫동안 안정적으로 유지된다는 점이며, 

73
00:03:14,278 --> 00:03:17,102
물론 더 중요한 것은 15라는 값에서 

74
00:03:17,102 --> 00:03:20,600
깨질 때 아주 미세한 차이로 깨진다는 점입니다.

75
00:03:21,180 --> 00:03:24,778
부동 소수점 연산으로 무언가를 하고 있기 때문에 

76
00:03:24,778 --> 00:03:28,110
이것이 수치 오류의 결과라고 생각하기 전에, 

77
00:03:28,110 --> 00:03:31,841
좀 더 정확하게 계산해 보면 마지막 적분의 정확한 

78
00:03:31,841 --> 00:03:35,840
값은 분자와 분모가 터무니없는 파이의 특정 분수입니다.

79
00:03:35,980 --> 00:03:38,700
둘 다 약 4,000억입니다.

80
00:03:40,460 --> 00:03:43,754
이 패턴은 조나단과 데이비드 보와인이라는 아버지와 

81
00:03:43,754 --> 00:03:46,225
아들이 함께 쓴 논문에서 설명했는데, 

82
00:03:46,225 --> 00:03:49,519
동료 연구자가 컴퓨터 대수 시스템을 사용해 적분을 

83
00:03:49,519 --> 00:03:52,343
계산할 때 이 패턴이 일종의 버그일 거라고 

84
00:03:52,343 --> 00:03:53,520
생각했다고 합니다.

85
00:03:53,860 --> 00:03:56,260
하지만 이것은 버그가 아니라 실제 현상입니다.

86
00:03:56,680 --> 00:03:58,120
사실 그보다 더 이상한 일이 벌어지고 있습니다.

87
00:03:58,440 --> 00:04:02,206
이 모든 적분에서 또 다른 요소인 2의 코사인을 

88
00:04:02,206 --> 00:04:06,112
포함하면 값이 완전히 바뀐다고 생각할 수 있지만, 

89
00:04:06,112 --> 00:04:10,157
이렇게 새로운 것을 무작위로 적분에 곱하면 훨씬 더 

90
00:04:10,157 --> 00:04:14,203
오랫동안 파이와 같고 113이라는 숫자에 이르러서야 

91
00:04:14,203 --> 00:04:15,040
끊어집니다.

92
00:04:15,200 --> 00:04:17,489
그리고 그것이 깨질 때는 상상할 수 있는 

93
00:04:17,489 --> 00:04:19,680
가장 작고 절대적으로 미묘한 정도입니다.

94
00:04:20,440 --> 00:04:24,080
그렇다면 도대체 무슨 일이 벌어지고 있는 걸까요?

95
00:04:24,380 --> 00:04:25,846
다행히도 이 모든 것에 대한 

96
00:04:25,846 --> 00:04:27,680
만족스러운 설명이 실제로 존재합니다.

97
00:04:28,180 --> 00:04:31,069
제가 생각하는 방법은 처음에는 전혀 관련이 

98
00:04:31,069 --> 00:04:34,199
없어 보이지만 숫자 15에 도달할 때까지 매우 

99
00:04:34,199 --> 00:04:37,329
안정적인 값을 유지하다가 아주 조금만 흔들리는 

100
00:04:37,329 --> 00:04:40,580
비슷한 패턴을 보이는 현상을 보여드리는 것입니다.

101
00:04:41,300 --> 00:04:43,583
그런 다음 이 겉보기에 관련이 없어 보이는 

102
00:04:43,583 --> 00:04:45,961
현상이 왜 우리의 모든 적분 표현과 비밀리에 

103
00:04:45,961 --> 00:04:48,340
동일하지만 변장하고 있는지 보여 드리겠습니다.

104
00:04:49,120 --> 00:04:52,406
이제 완전히 다른 것으로 관심을 돌려서, 

105
00:04:52,406 --> 00:04:56,407
입력값이 음의 1/2과 1/2 사이에 있으면 1이 

106
00:04:56,407 --> 00:05:00,551
되고 그렇지 않으면 0이 되는 x의 rect 함수를 

107
00:05:00,551 --> 00:05:01,980
생각해 보겠습니다.

108
00:05:02,220 --> 00:05:04,520
따라서 이 기능은 기본적으로 지루한 단계입니다.

109
00:05:04,520 --> 00:05:07,022
이것은 우리가 정의하는 함수 시퀀스의 첫 

110
00:05:07,022 --> 00:05:09,307
번째 함수가 될 것이므로, 이를 x의 

111
00:05:09,307 --> 00:05:11,919
f1이라고 부르고, 시퀀스의 각 새 함수는 

112
00:05:11,919 --> 00:05:14,640
이전 함수의 일종의 이동 평균이 될 것입니다.

113
00:05:15,800 --> 00:05:19,460
예를 들어 두 번째 반복을 정의하는 방법은 너비가 

114
00:05:19,460 --> 00:05:23,120
1/3인 이 슬라이딩 창을 가지고 특정 입력 x에 

115
00:05:23,120 --> 00:05:26,780
대해 창이 해당 입력 x의 중앙에 위치하면 아래에 

116
00:05:26,780 --> 00:05:30,179
그려진 새 함수의 값이 해당 창 내부에서 위의 

117
00:05:30,179 --> 00:05:33,840
첫 번째 함수의 평균값과 같도록 정의하는 것입니다.

118
00:05:33,840 --> 00:05:35,833
예를 들어 창이 왼쪽으로 충분히 멀리 

119
00:05:35,833 --> 00:05:37,636
떨어져 있으면 그 안의 모든 값이 

120
00:05:37,636 --> 00:05:39,820
0이므로 하단의 그래프에 0이 표시됩니다.

121
00:05:40,280 --> 00:05:42,190
그 기간이 조금 지나기 시작하면 

122
00:05:42,190 --> 00:05:44,419
평균값이 0보다 조금 더 높아지는데, 

123
00:05:44,419 --> 00:05:46,860
아래 그래프에서 이를 확인할 수 있습니다.

124
00:05:47,280 --> 00:05:50,140
그리고 정확히 절반의 창이 1의 고원 위에 

125
00:05:50,140 --> 00:05:52,881
있고 절반이 0에 있을 때 하단 그래프의 

126
00:05:52,881 --> 00:05:56,100
해당 값은 1의 절반이며 요점을 알 수 있습니다.

127
00:05:56,660 --> 00:05:59,509
제가 여러분에게 집중하고 싶은 중요한 점은 

128
00:05:59,509 --> 00:06:02,120
위의 모든 값이 1인 고원 지대에 있는 

129
00:06:02,120 --> 00:06:04,732
창이 완전히 있을 때 평균값도 1이므로 

130
00:06:04,732 --> 00:06:07,700
하단의 함수에서 이 고원을 얻는다는 점입니다.

131
00:06:08,300 --> 00:06:11,261
이 하단 함수를 x의 f2라고 부르고, 

132
00:06:11,261 --> 00:06:15,300
두 번째 함수의 고원의 길이에 대해 생각해 보겠습니다.

133
00:06:15,480 --> 00:06:16,440
얼마나 넓어야 하나요?

134
00:06:17,020 --> 00:06:20,344
잠시 생각해보면 상단 고원의 왼쪽 가장자리와 

135
00:06:20,344 --> 00:06:23,403
하단 고원의 왼쪽 가장자리 사이의 거리는 

136
00:06:23,403 --> 00:06:27,260
정확히 창 너비의 절반이므로 1/3의 절반이 됩니다.

137
00:06:27,640 --> 00:06:30,293
오른쪽에서도 마찬가지로 고원 가장자리 

138
00:06:30,293 --> 00:06:32,820
사이의 거리는 창 너비의 절반입니다.

139
00:06:33,200 --> 00:06:35,417
따라서 전체적으로 창 너비에서 1을 뺀 값, 

140
00:06:35,417 --> 00:06:36,660
즉 1/3을 뺀 값입니다.

141
00:06:37,380 --> 00:06:40,152
우리가 계산할 값, 즉 깨지기 전까지 잠시 

142
00:06:40,152 --> 00:06:42,808
동안 안정적으로 보이는 값은 입력 0에서 

143
00:06:42,808 --> 00:06:45,696
이 함수의 값이며, 이 두 반복에서 이 값은 

144
00:06:45,696 --> 00:06:48,700
모두 그 고원 안에 있기 때문에 1과 같습니다.

145
00:06:49,200 --> 00:06:51,971
다음 반복에서는 마지막 함수의 이동 평균을 

146
00:06:51,971 --> 00:06:55,320
구하되 이번에는 너비가 1/5인 창을 사용하겠습니다.

147
00:06:55,320 --> 00:06:58,731
이 창을 슬라이드하면 왜 이전 함수의 매끄러운 

148
00:06:58,731 --> 00:07:02,274
버전이 나타나는지 생각해 보는 것도 재미있으며, 

149
00:07:02,274 --> 00:07:05,292
다시 한 번 강조하고 싶은 것은 이 창이 

150
00:07:05,292 --> 00:07:08,310
이전 함수의 고원 안에 완전히 들어올 때 

151
00:07:08,310 --> 00:07:11,460
정의상 아래쪽 함수가 1과 같다는 점입니다.

152
00:07:11,980 --> 00:07:15,489
이번에는 하단의 고원의 길이가 이전 고원의 길이에서 

153
00:07:15,489 --> 00:07:18,756
1/3을 뺀 1에서 창 너비 1/5을 뺀 길이가 

154
00:07:18,756 --> 00:07:19,240
됩니다.

155
00:07:19,600 --> 00:07:22,881
추론은 이전과 동일하게 창의 중앙이 그 위쪽 

156
00:07:22,881 --> 00:07:26,425
고원에 있는 지점에서 창 전체가 그 고원 안쪽의 

157
00:07:26,425 --> 00:07:30,232
창 너비의 절반, 마찬가지로 오른쪽에 있는 지점으로 

158
00:07:30,232 --> 00:07:33,644
이동하고 다시 한번 입력이 0일 때 이 함수의 

159
00:07:33,644 --> 00:07:37,320
출력값이 정확히 1이 되는 것을 기록하는 것입니다.

160
00:07:38,580 --> 00:07:41,880
다음 반복은 창 너비가 7분의 1인 이동 평균입니다.

161
00:07:42,100 --> 00:07:44,040
고원은 1에서 7만큼 작아집니다.

162
00:07:44,500 --> 00:07:46,391
1을 9로 한 번 더 반복하면 

163
00:07:46,391 --> 00:07:48,060
고원이 그 만큼 작아집니다.

164
00:07:48,600 --> 00:07:49,818
그리고 계속 진행하면서 그 간격은 

165
00:07:49,818 --> 00:07:50,780
점점 더 얇아지고 있습니다.

166
00:07:51,820 --> 00:07:55,372
또한 고원 바로 밖에서 함수가 1에 매우 근접한 

167
00:07:55,372 --> 00:07:58,924
것을 알 수 있는데, 이는 항상 1의 고원과 그 

168
00:07:58,924 --> 00:08:02,740
이웃의 평균이 1에 매우 근접한 결과이기 때문입니다.

169
00:08:03,440 --> 00:08:06,717
이 모든 것이 중단되는 지점은 전체에 걸쳐 너비 

170
00:08:06,717 --> 00:08:10,360
1 15의 창을 슬라이딩하는 반복에 도달했을 때입니다.

171
00:08:10,760 --> 00:08:12,953
이 시점에서 이전 고원은 실제로 

172
00:08:12,953 --> 00:08:14,660
창 자체보다 더 얇습니다.

173
00:08:14,820 --> 00:08:17,562
따라서 입력 x가 0인 경우에도 이 

174
00:08:17,562 --> 00:08:20,580
이동 평균은 1보다 약간 작아야 합니다.

175
00:08:20,780 --> 00:08:24,387
여기서 숫자 15의 특별한 점은 홀수 분수의 역수, 

176
00:08:24,387 --> 00:08:27,621
즉 3분의 1 더하기 5분의 1 더하기 7분의 

177
00:08:27,621 --> 00:08:30,856
1을 계속 더하다 보면 15분의 1에 도달하면 

178
00:08:30,856 --> 00:08:33,220
그 합이 1보다 커진다는 점입니다.

179
00:08:33,580 --> 00:08:37,128
그리고 폭 1의 고원으로 시작했던 고원은 

180
00:08:37,128 --> 00:08:41,140
이제 완전히 사라질 정도로 많이 축소되었습니다.

181
00:08:41,799 --> 00:08:44,505
요점은 이것이 무작위로 보이는 절차에 의해 

182
00:08:44,505 --> 00:08:47,098
정의된 함수 시퀀스로서, 입력 0에서 이 

183
00:08:47,098 --> 00:08:49,803
모든 함수의 값을 계산하라고 하면 처음에는 

184
00:08:49,803 --> 00:08:52,960
안정적으로 보이는 패턴을 얻을 수 있다는 것입니다.

185
00:08:53,120 --> 00:08:56,724
1 1 1 1 1 1 1 1 1이지만 8번째 

186
00:08:56,724 --> 00:09:00,040
반복에 도달하면 간신히 약간 부족해집니다.

187
00:09:00,680 --> 00:09:03,771
이는 앞서 살펴본 적분에서 파이 파이 파이 파이에서 

188
00:09:03,771 --> 00:09:06,435
약간 부족할 때까지 안정적인 값을 갖는 것과 

189
00:09:06,435 --> 00:09:09,100
유사하며, 저는 단지 유사하다고 주장하는 것 

190
00:09:09,100 --> 00:09:09,740
이상입니다.

191
00:09:10,180 --> 00:09:13,177
공교롭게도 이동 평균 프로세스에서 

192
00:09:13,177 --> 00:09:16,174
1보다 약간 작은 이 상수가 바로 

193
00:09:16,174 --> 00:09:19,960
적분 계열에서 파이 앞에 놓이는 요소입니다.

194
00:09:20,340 --> 00:09:22,590
따라서 두 상황은 질적으로 유사할 

195
00:09:22,590 --> 00:09:24,840
뿐만 아니라 양적으로도 동일합니다.

196
00:09:25,540 --> 00:09:29,062
그리고 적분 내부에 x 항의 2 코사인을 추가하여 

197
00:09:29,062 --> 00:09:32,710
패턴이 끊어지기 전에 훨씬 더 오래 지속되는 경우, 

198
00:09:32,710 --> 00:09:35,855
비유하자면 동일한 설정이지만 우리가 시작하는 

199
00:09:35,855 --> 00:09:39,126
함수가 더 긴 고원을 가지며 x가 음수 1에서 

200
00:09:39,126 --> 00:09:42,900
1까지 늘어나므로 그 길이가 2가 되는 것과 같습니다.

201
00:09:42,900 --> 00:09:45,593
따라서 이러한 이동 평균 과정을 반복하면서 점점 

202
00:09:45,593 --> 00:09:48,087
더 작은 창으로 이동 평균을 먹어치우면 전체 

203
00:09:48,087 --> 00:09:50,980
고원을 먹어치우는 데 훨씬 더 오랜 시간이 걸립니다.

204
00:09:51,700 --> 00:09:54,013
보다 구체적으로, 관련 계산은 홀수의 

205
00:09:54,013 --> 00:09:56,656
역수를 더하면 그 합이 2보다 커질 때까지 

206
00:09:56,656 --> 00:09:59,300
얼마나 오래 더해야 하는지를 묻는 것입니다.

207
00:09:59,720 --> 00:10:02,742
그리고 숫자 113에 도달 할 때까지 가야한다는 

208
00:10:02,742 --> 00:10:05,317
것이 밝혀졌으며, 이는 113에 도달 할 

209
00:10:05,317 --> 00:10:08,340
때까지 적분 패턴이 계속된다는 사실과 일치합니다.

210
00:10:09,100 --> 00:10:12,330
그건 그렇고, 홀수의 역수 인 1 3, 1 5, 

211
00:10:12,330 --> 00:10:15,680
1 7에는 특별한 것이 없다는 점을 강조해야합니다.

212
00:10:15,680 --> 00:10:18,741
이 수열은 보바인 부부가 논문에서 강조한 값의 

213
00:10:18,741 --> 00:10:21,920
시퀀스로, 마니아들 사이에서 약간 유명해졌습니다.

214
00:10:22,440 --> 00:10:25,437
보다 일반적으로, 우리는 이러한 sinc 함수에 

215
00:10:25,437 --> 00:10:27,879
임의의 양의 수열을 삽입할 수 있으며, 

216
00:10:27,879 --> 00:10:30,876
그 수열의 합이 1보다 작으면 식은 파이와 같게 

217
00:10:30,876 --> 00:10:31,320
됩니다.

218
00:10:31,700 --> 00:10:33,357
그러나 1보다 커지는 순간, 우리의 

219
00:10:33,357 --> 00:10:35,180
표현은 파이보다 약간 아래로 떨어집니다.

220
00:10:35,180 --> 00:10:37,857
이러한 이동 평균에 비유가 있다고 생각하신다면 

221
00:10:37,857 --> 00:10:40,020
그 이유를 이해하실 수 있을 것입니다.

222
00:10:41,840 --> 00:10:44,819
물론, 이 두 가지 상황이 도대체 왜 서로 관련이 

223
00:10:44,819 --> 00:10:47,800
있어야 하는지에 대한 의문은 여전히 남아 있습니다.

224
00:10:48,240 --> 00:10:51,963
여기에서 인수는 푸리에 변환과 컨볼루션이라는 

225
00:10:51,963 --> 00:10:55,240
다소 무거운 두 가지 기계를 도입합니다.

226
00:10:55,860 --> 00:10:59,247
이 두 가지 주제에 대해 잘 알고 있다고 가정하지 

227
00:10:59,247 --> 00:11:02,513
않고 이 동영상의 남은 시간 동안 논쟁이 어떻게 

228
00:11:02,513 --> 00:11:05,296
진행될지에 대해 개략적으로 설명한 다음, 

229
00:11:05,296 --> 00:11:08,320
컨볼루션, 특히 컨볼루션 정리라는 것이 매우 

230
00:11:08,320 --> 00:11:11,224
아름답고 이 구체적이고 난해한 질문을 훨씬 

231
00:11:11,224 --> 00:11:14,248
넘어서는 유용한 개념이기 때문에 왜 그 세부 

232
00:11:14,248 --> 00:11:17,394
사항이 사실인지 설명하는 것이 제가 하고 싶은 

233
00:11:17,394 --> 00:11:18,120
방식입니다.

234
00:11:21,080 --> 00:11:24,894
우선, 곡선 아래의 부호가 있는 영역이 왜 파이와 

235
00:11:24,894 --> 00:11:28,708
같은지 보여주기 위해 x를 x로 나눈 사인 함수에 

236
00:11:28,708 --> 00:11:32,523
초점을 맞추는 대신, 입력 x를 파이 곱하기 x로 

237
00:11:32,523 --> 00:11:36,610
대체하는 간단한 치환을 통해 그래프를 가로로 파이만큼 

238
00:11:36,610 --> 00:11:40,288
쪼개는 효과가 있으므로 영역이 파이만큼 축소되어 

239
00:11:40,288 --> 00:11:44,238
오른쪽의 적분이 정확히 1과 같은 이유를 보여줄 수 

240
00:11:44,238 --> 00:11:44,920
있습니다.

241
00:11:45,500 --> 00:11:47,493
그런데 일부 엔지니어링 맥락에서 사람들은 

242
00:11:47,493 --> 00:11:49,746
이 함수의 내부에 파이가 있는 함수를 지칭하기 

243
00:11:49,746 --> 00:11:51,566
위해 sinc라는 이름을 사용하는데, 

244
00:11:51,566 --> 00:11:53,560
이는 그 아래 면적이 1과 같다는 의미의 

245
00:11:53,560 --> 00:11:56,160
정규화된 함수를 갖는 것이 종종 매우 좋기 때문입니다.

246
00:11:56,160 --> 00:11:58,014
요점은 오른쪽에 적분을 표시하는 것과 

247
00:11:58,014 --> 00:11:59,780
왼쪽에 적분을 표시하는 것은 변수의 

248
00:11:59,780 --> 00:12:01,900
변화만 있을 뿐 완전히 동일하다는 것입니다.

249
00:12:02,580 --> 00:12:05,206
그리고 시퀀스의 다른 모든 것들에 대해서도 

250
00:12:05,206 --> 00:12:08,379
마찬가지로, 각각을 살펴보고 x를 파이 곱하기 x로 

251
00:12:08,379 --> 00:12:11,334
바꾸면 여기서 이 모든 적분은 이동 평균 예제와 

252
00:12:11,334 --> 00:12:14,398
유사할 뿐만 아니라 이 두 가지 모두 정확히 같은 

253
00:12:14,398 --> 00:12:17,243
것을 계산하는 두 가지 다른 방법이라는 주장이 

254
00:12:17,243 --> 00:12:17,900
제기됩니다.

255
00:12:18,500 --> 00:12:21,369
그리고 이 sinc 함수, 즉 내부에 파이가 있는 

256
00:12:21,369 --> 00:12:24,238
엔지니어 sinc 함수는 푸리에 변환이라고 알려진 

257
00:12:24,238 --> 00:12:27,005
것을 사용하는 직교 함수와 관련이 있다는 사실로 

258
00:12:27,005 --> 00:12:27,620
연결됩니다.

259
00:12:28,260 --> 00:12:30,372
푸리에 변환에 대해 들어본 적이 없다면 이 채널에 

260
00:12:30,372 --> 00:12:32,560
푸리에 변환에 관한 몇 가지 다른 동영상이 있습니다.

261
00:12:32,740 --> 00:12:36,176
흔히 푸리에 변환을 순수 주파수의 합으로 함수를 

262
00:12:36,176 --> 00:12:39,612
분해하거나 무한 함수의 경우 순수 주파수의 연속 

263
00:12:39,612 --> 00:12:42,921
적분으로 함수를 분해하려는 경우 푸리에 변환은 

264
00:12:42,921 --> 00:12:46,740
모든 구성 부분에 대한 모든 강도와 위상을 알려줍니다.

265
00:12:47,120 --> 00:12:50,153
하지만 여기서 정말 알아야 할 것은 하나의 

266
00:12:50,153 --> 00:12:53,567
함수를 받아들여 새로운 함수를 뱉어내는 것으로, 

267
00:12:53,567 --> 00:12:56,727
원래 함수의 정보를 새로운 관점에서 바라보는 

268
00:12:56,727 --> 00:13:00,520
것처럼 다른 언어로 표현하는 것이라고 생각하면 됩니다.

269
00:13:01,320 --> 00:13:03,755
예를 들어, 앞서 말했듯이 푸리에 변환을 

270
00:13:03,755 --> 00:13:06,190
취하는 이 새로운 언어로 작성된 sinc 

271
00:13:06,190 --> 00:13:08,520
함수는 탑햇 직사각형 함수와 비슷합니다.

272
00:13:09,100 --> 00:13:10,200
그 반대도 마찬가지입니다.

273
00:13:10,260 --> 00:13:13,301
이것은 Y축에 대해 대칭인 함수에 대한 푸리에 

274
00:13:13,301 --> 00:13:16,108
변환의 좋은 점이며, 그 자체로 역수이며, 

275
00:13:16,108 --> 00:13:19,150
실제로 우리가 보여줄 약간 더 일반적인 사실은 

276
00:13:19,150 --> 00:13:21,840
sinc 함수의 늘어진 버전을 변환할 때 

277
00:13:21,840 --> 00:13:24,881
수평으로 k만큼 늘어나는 경우 이 직교 함수의 

278
00:13:24,881 --> 00:13:28,040
늘어지고 찌그러진 버전이 어떻게 얻어지는지입니다.

279
00:13:28,600 --> 00:13:31,496
물론 이 모든 것은 번역을 통해 실제로 무언가를 

280
00:13:31,496 --> 00:13:34,500
할 수 없다면 의미 없는 단어와 용어에 불과합니다.

281
00:13:35,100 --> 00:13:38,108
푸리에 변환이 수학에 유용한 이유는 특정 

282
00:13:38,108 --> 00:13:41,116
함수에 대한 진술과 질문을 받은 다음 그 

283
00:13:41,116 --> 00:13:44,255
함수의 변환된 버전과 관련하여 해당 진술과 

284
00:13:44,255 --> 00:13:47,132
질문이 무엇인지 살펴볼 때, 이 새로운 

285
00:13:47,132 --> 00:13:50,533
언어에서는 그 진술과 질문이 매우 다르게 보일 

286
00:13:50,533 --> 00:13:53,541
때가 많으며 때로는 질문에 답하기가 훨씬 

287
00:13:53,541 --> 00:13:54,980
쉬워진다는 점입니다.

288
00:13:55,660 --> 00:13:58,878
예를 들어, 우리가 보여줄 또 하나의 멋진 

289
00:13:58,878 --> 00:14:02,498
사실은 음의 무한대에서 무한대까지의 어떤 함수의 

290
00:14:02,498 --> 00:14:05,984
적분, 즉 곡선 전체 아래 부호가 있는 영역을 

291
00:14:05,984 --> 00:14:09,605
계산하려는 경우 입력 0에서 해당 함수의 푸리에 

292
00:14:09,605 --> 00:14:13,360
변환 버전을 단순히 평가하는 것과 같다는 것입니다.

293
00:14:13,820 --> 00:14:17,702
이것은 실제로 정의에서 바로 튀어나오는 사실이며, 

294
00:14:17,702 --> 00:14:21,307
오른쪽의 푸리에 변환 함수의 모든 개별 출력은 

295
00:14:21,307 --> 00:14:24,773
왼쪽의 원래 함수에 대한 일종의 전역 정보에 

296
00:14:24,773 --> 00:14:28,240
해당한다는 보다 일반적인 분위기를 나타냅니다.

297
00:14:28,720 --> 00:14:32,835
이 동기화 함수와 직교 함수가 이렇게 푸리에 변환과 

298
00:14:32,835 --> 00:14:36,525
관련이 있다고 생각하면, 부호화된 모든 영역이 

299
00:14:36,525 --> 00:14:40,498
0에서 직교를 평가하는 것과 같다고 말하기 때문에 

300
00:14:40,498 --> 00:14:44,330
계산하기 매우 까다로운 적분을 설명할 수 있다는 

301
00:14:44,330 --> 00:14:45,040
뜻입니다.

302
00:14:46,140 --> 00:14:47,394
이제 불만을 제기할 수도 있겠지만, 

303
00:14:47,394 --> 00:14:49,026
이것은 단지 양탄자 밑으로 범프를 옮기는 것일 

304
00:14:49,026 --> 00:14:49,340
뿐입니다.

305
00:14:49,700 --> 00:14:52,143
푸리에 변환을 계산하는 것은 그 모양이 어떻든 

306
00:14:52,143 --> 00:14:54,680
원래 적분을 계산하는 것만큼이나 어려울 것입니다.

307
00:14:55,040 --> 00:14:57,933
하지만 이러한 푸리에 변환을 계산하는 데는 많은 

308
00:14:57,933 --> 00:15:00,826
팁과 요령이 있으며, 계산을 하면 적분보다 훨씬 

309
00:15:00,826 --> 00:15:03,720
더 많은 정보를 알려준다는 것을 알 수 있습니다.

310
00:15:03,880 --> 00:15:06,380
계산을 통해 투자 대비 많은 효과를 얻을 수 있습니다.

311
00:15:07,200 --> 00:15:10,571
이제 우리가 찾고 있는 연결을 설명할 또 다른 

312
00:15:10,571 --> 00:15:14,073
핵심 사실은 서로 다른 두 함수가 있고 그 곱을 

313
00:15:14,073 --> 00:15:17,445
취한 다음 그 곱의 푸리에 변환을 취하면 원래 

314
00:15:17,445 --> 00:15:20,946
함수의 푸리에 변환을 개별적으로 취한 다음 다음 

315
00:15:20,946 --> 00:15:23,799
동영상에서 설명할 새로운 종류의 연산, 

316
00:15:23,799 --> 00:15:27,171
즉 컨볼루션을 사용하여 결합한 것과 동일하다는 

317
00:15:27,171 --> 00:15:27,820
것입니다.

318
00:15:28,500 --> 00:15:31,283
이제 컨볼루션에 대해 설명할 것이 많지만, 

319
00:15:31,283 --> 00:15:34,530
결론은 이러한 직사각형 함수가 있는 특정 사례에서 

320
00:15:34,530 --> 00:15:37,662
컨볼루션을 취하는 것이 지금까지 계속 이야기했던 

321
00:15:37,662 --> 00:15:40,909
이동 평균 중 하나처럼 보인다는 점과 한 맥락에서 

322
00:15:40,909 --> 00:15:44,389
적분이 다른 맥락에서 0에서 평가하는 것처럼 보인다는 

323
00:15:44,389 --> 00:15:47,636
이전 사실을 결합하면 한 맥락에서 곱하는 것이 이 

324
00:15:47,636 --> 00:15:50,652
새로운 연산에 해당한다고 믿으신다면 컨볼루션을 

325
00:15:50,652 --> 00:15:53,551
취하는 것이 이동 평균 중 하나와 비슷하다는 

326
00:15:53,551 --> 00:15:57,030
것입니다, 컨볼루션은 이동 평균으로 생각하면 되는데, 

327
00:15:57,030 --> 00:16:00,394
이 예에서는 왜 점점 더 많은 sinc 함수를 함께 

328
00:16:00,394 --> 00:16:03,525
곱하는 것이 이러한 점진적 이동 평균의 관점에서 

329
00:16:03,525 --> 00:16:06,193
생각될 수 있고 항상 0에서 평가되는지, 

330
00:16:06,193 --> 00:16:09,324
결국 고원의 가장자리가 점점 중앙에 가까워지면서 

331
00:16:09,324 --> 00:16:12,340
무언가가 무너지기 전에 안정적인 값을 기대하는 

332
00:16:12,340 --> 00:16:14,080
이유를 설명할 수 있습니다.

333
00:16:15,540 --> 00:16:16,881
그런데 이 마지막 중요한 사실에는 

334
00:16:16,881 --> 00:16:17,800
특별한 이름이 있습니다.

335
00:16:17,900 --> 00:16:19,517
이를 컨볼루션 정리라고 하며, 

336
00:16:19,517 --> 00:16:21,800
앞으로 훨씬 더 깊이 있게 다룰 내용입니다.

337
00:16:22,960 --> 00:16:25,834
여기서 세 가지 마법 같은 사실을 나열하고 모든 

338
00:16:25,834 --> 00:16:28,283
것이 그것으로부터 나온다고 말하는 것으로 

339
00:16:28,283 --> 00:16:31,157
마무리하는 것이 다소 불만족스러울 수도 있지만, 

340
00:16:31,157 --> 00:16:33,713
푸리에 변환과 같은 강력한 도구가 까다로운 

341
00:16:33,713 --> 00:16:36,587
문제에 유용한 이유를 조금이나마 엿볼 수 있기를 

342
00:16:36,587 --> 00:16:37,120
바랍니다.

343
00:16:37,600 --> 00:16:40,651
어려운 문제가 때때로 더 쉬워 보일 수 있는 

344
00:16:40,651 --> 00:16:43,580
관점의 전환을 제공하는 체계적인 방법입니다.

345
00:16:44,040 --> 00:16:46,369
다른 것이 아니라면, 컨볼루션 정리와 같은 아름다운 

346
00:16:46,369 --> 00:16:48,780
것에 대해 배울 수 있는 동기 부여가 되기를 바랍니다.

347
00:16:49,420 --> 00:16:53,388
이 컨볼루션 정리의 또 다른 재미있는 결과는 

348
00:16:53,388 --> 00:16:57,356
두 개의 큰 수의 곱을 생각보다 훨씬 빠르게 

349
00:16:57,356 --> 00:17:01,960
계산할 수 있는 알고리즘의 문을 열어준다는 점입니다.

350
00:17:03,000 --> 00:17:04,599
그럼 다음 영상에서 뵙겠습니다.

