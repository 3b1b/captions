[
 {
  "input": "Sometimes it feels like the universe is just messing with you.",
  "translatedText": "",
  "from_community_srt": "때로는 우주가 여러분을 괴롭히고 있는 것처럼 느낄 수 있습니다.",
  "n_reviews": 0,
  "start": 0.0,
  "end": 2.98
 },
 {
  "input": "I have up on screen here a sequence of computations, and don't worry, in a moment we're gonna unpack and visualize what each one is really saying.",
  "translatedText": "",
  "from_community_srt": "여기 화면에 일련의 계산들이 있습니다. 그런데, 걱정하지 마세요. 잠시 후에 각각이 실제로 뜻하는 내용을 분석하고 시각화할 것입니다.",
  "n_reviews": 0,
  "start": 3.34,
  "end": 10.38
 },
 {
  "input": "What I want you to notice is how the sequence follows a very predictable, if random, seeming pattern, and how each computation happens to equal pi.",
  "translatedText": "",
  "from_community_srt": "여러분이 주목해 주셨으면 하는 것은 어떻게 이 배열들이 예측 가능한 규칙을 따르는지, 무작위한 규칙을 따르는지, 그리고 각 계산이 어떻게 동일하게 π로 나타나는지 입니다.",
  "n_reviews": 0,
  "start": 10.92,
  "end": 18.54
 },
 {
  "input": "And if you were just messing around evaluating these on a computer for some reason, you might think that this was a pattern that would go on forever.",
  "translatedText": "",
  "from_community_srt": "그리고 만약 여러분이 어떠한 이유로 이것들을 컴퓨터를 가지고 계산하는 데 시간을 쓰고 있다면, 여러분은 이 과정이 영원히 같은 규칙이라고 생각할 수 있습니다.",
  "n_reviews": 0,
  "start": 19.08,
  "end": 25.88
 },
 {
  "input": "But it doesn't.",
  "translatedText": "",
  "from_community_srt": "하지만 그렇지 않습니다.",
  "n_reviews": 0,
  "start": 25.88,
  "end": 27.1
 },
 {
  "input": "At some point it stops, and instead of equaling pi, you get a value which is just barely, barely less than pi.",
  "translatedText": "",
  "from_community_srt": "어느 시점부터, 이러한 규칙은 멈추고 π와 같아지는게 아닌, π보다 겨우 간신히 작은 값을 얻습니다.",
  "n_reviews": 0,
  "start": 27.4,
  "end": 34.34
 },
 {
  "input": "All right, let's dig into what's going on here.",
  "translatedText": "",
  "from_community_srt": "자, 여기서 무슨 일이 일어나고 있는지 알아보겠습니다.",
  "n_reviews": 0,
  "start": 38.78,
  "end": 40.94
 },
 {
  "input": "The main character in the story today is the function sine of x divided by x.",
  "translatedText": "",
  "from_community_srt": "오늘 이야기의 주인공은 sin(𝒙)를 𝒙로 나눈 함수입니다.",
  "n_reviews": 0,
  "start": 41.3,
  "end": 45.08
 },
 {
  "input": "This actually comes up commonly enough in math and engineering that it gets its own name, sinc, and the way you might think about it is by starting with a normal oscillating sine curve, and then sort of squishing it down as you get far away from zero by multiplying it by 1 over x.",
  "translatedText": "",
  "from_community_srt": "이 함수는 수학과 공학에서 \"sinc\"라는 이름을 가질 만큼 충분히 흔하게 나타나는데, 여러분이 이것에 대해 생각할 수 있는 방법은 일반적인 진동하는 사인 곡선에 1/𝒙 를 곱하여 0에서 멀어질수록 곡선이 아래로 눌려지는 것입니다.",
  "n_reviews": 0,
  "start": 45.46,
  "end": 58.78
 },
 {
  "input": "And the astute among you might ask about what happens at x equals 0, since when you plug that in it looks like dividing 0 by 0.",
  "translatedText": "",
  "from_community_srt": "그러면 여러분 중 영리한 사람은 𝒙에 0을 넣으면 어떻게 되는지 물을 수 있습니다.",
  "n_reviews": 0,
  "start": 59.3,
  "end": 65.74
 },
 {
  "input": "And then the even more astute among you, maybe fresh out of a calculus class, could point out that for values closer and closer to 0, the function gets closer and closer to 1.",
  "translatedText": "",
  "from_community_srt": "0을 넣으면 0 / 0 꼴이 되고, 여기서 미적분을 끝낸 더 영리한 사람은 𝒙값이 0으로 가까워질수록 함수값은 1에 가까워진다고 지적할 수도 있습니다. (𝑺𝒒𝒖𝒆𝒆𝒛𝒆 𝑻𝒉𝒆𝒐𝒓𝒆𝒎;",
  "n_reviews": 0,
  "start": 66.4,
  "end": 74.78
 },
 {
  "input": "So if we simply redefine the sinc function at 0 to equal 1, you get a nice continuous curve.",
  "translatedText": "",
  "from_community_srt": "조임 정리) 따라서 0에서의 sinc 함숫값을 1로 재정의하면, 멋진 연속 곡선을 얻을 수 있습니다.",
  "n_reviews": 0,
  "start": 75.26,
  "end": 80.32
 },
 {
  "input": "All of that is a little by the by because the thing we actually care about is the integral of this curve from negative infinity to infinity, which you'd think of as meaning the area between the curve and the x-axis, or more precisely the signed area, meaning you add all the area bound by the positive parts of the graph in the x-axis, and you subtract all of the parts bound by the negative parts of the graph and the x-axis.",
  "translatedText": "",
  "from_community_srt": "우리가 실제로 관심을 갖는 것은 음의 무한대에서 무한대로의 이 곡선의 적분이기 때문에 이 정도 쯤은 사소합니다. 곡선과 𝒙축 사이의 면적, 더 정확하게는 부호가 있는 면적을 의미한다고 생각하면 됩니다. 즉, 𝒙축에서 그래프의 양수 부분으로 돼 있는 모든 면적을 더하고, 𝒙축에서 그래프의 음수 부분으로 돼 있는 모든 면적을 뺍니다.",
  "n_reviews": 0,
  "start": 80.32,
  "end": 102.3
 },
 {
  "input": "Like we saw at the start, it happens to be the case that this evaluates to be exactly pi, which is nice and also a little weird, and it's not entirely clear how you would approach this with the usual tools of calculus.",
  "translatedText": "",
  "from_community_srt": "처음에 우리가 보았듯이, 이것은 정확히 π로 계산이 됩니다. 이는 훌륭하면서도 약간 이상하며, 그리고 일반적인 미적분학 도구로 이 문제를 어떻게 접근할 지, 방법이 완전히 명확하지 않습니다.",
  "n_reviews": 0,
  "start": 102.74,
  "end": 113.38
 },
 {
  "input": "Towards the end of the video, I'll share the trick for how you would do this.",
  "translatedText": "",
  "from_community_srt": "동영상의 마지막 부분에서, 어떻게 이것을 계산할 수 있는지에 대한 트릭을 공유하겠습니다.",
  "n_reviews": 0,
  "start": 113.98,
  "end": 116.56
 },
 {
  "input": "Progressing on with the sequence I opened with, the next step is to take a copy of the sinc function, where you plug in x divided by 3, which will basically look like the same graph, but stretched out horizontally by a factor of 3.",
  "translatedText": "",
  "from_community_srt": "제가 시작한 배열을 계속 진행하고, 다음 단계는 𝒙/3을 대입한 sinc 함수를 가져오는 것입니다. 기본적으로 같은 그래프처럼 보이지만 가로로 3배 늘어납니다.",
  "n_reviews": 0,
  "start": 116.84,
  "end": 128.26
 },
 {
  "input": "When we multiply these two functions together, we get a much more complicated wave whose mass seems to be more concentrated towards the middle, and with any usual functions you would expect this completely changes the area.",
  "translatedText": "",
  "from_community_srt": "이 두 함수를 함께 곱하면, 각각의 함수들보다 질량이 중간에 더 집중된 것처럼 보이는 훨씬 더 복잡한 파동이 생성되며, 여러분은 이것이 면적을 완전히 바꿀 것이라고 예상할 수 있습니다.",
  "n_reviews": 0,
  "start": 128.9,
  "end": 140.0
 },
 {
  "input": "You can't just randomly modify an integral like this and expect nothing to change.",
  "translatedText": "",
  "from_community_srt": "이와 같이 적분을 무작위로 수정하고, 아무 것도 변경되지 않을 것으로 기대할 수는 없습니다.",
  "n_reviews": 0,
  "start": 140.38,
  "end": 143.68
 },
 {
  "input": "So already it's a little bit weird that this result also equals pi, that nothing has changed.",
  "translatedText": "",
  "from_community_srt": "그런데 이미, 이 결과가 π와 같다는 것이 조금 이상합니다. 아무것도 바뀌지 않았다는 것입니다.",
  "n_reviews": 0,
  "start": 144.26,
  "end": 148.78
 },
 {
  "input": "That's another mystery you should add to your list.",
  "translatedText": "",
  "from_community_srt": "이것은 여러분의 리스트에 추가해야 할 또 다른 미스터리입니다.",
  "n_reviews": 0,
  "start": 149.08,
  "end": 151.18
 },
 {
  "input": "And the next step in the sequence was to take an even more stretched out version of the sinc function by a factor of 5, multiply that by what we already have, and again look at the signed area underneath the whole curve, which again equals pi.",
  "translatedText": "",
  "from_community_srt": "그리고 이 배열의 다음 단계는 sinc 함수의 훨씬 더 확장된 버전인 5를 인수로 취하는 것 입니다. 그리고 우리가 이미 가지고 있는 것을 곱한 다음, 다시 전체 곡선에 있는 부호 면적을 보면, 이것은 다시 π와 같습니다.",
  "n_reviews": 0,
  "start": 151.66,
  "end": 164.0
 },
 {
  "input": "And it continues on like this.",
  "translatedText": "",
  "from_community_srt": "그리고 계속 이렇게 됩니다.",
  "n_reviews": 0,
  "start": 164.86,
  "end": 166.48
 },
 {
  "input": "With each iteration, we stretch out by a new odd number and multiply that into what we have.",
  "translatedText": "",
  "from_community_srt": "반복할 때마다 새로운 홀수를 늘리고 우리가 가지고 있는 것에 곱합니다.",
  "n_reviews": 0,
  "start": 166.58,
  "end": 170.94
 },
 {
  "input": "One thing you might notice is how except at the input x equals 0, every single part of this function is progressively getting multiplied by something that's smaller than 1.",
  "translatedText": "",
  "from_community_srt": "한 가지 알아차릴 수 있는 것은 𝒙 = 0 일 때를 제외하고, 이 함수의 모든 부분이 1보다 작은 값으로 계속해서 곱해지는 것 입니다.",
  "n_reviews": 0,
  "start": 171.64,
  "end": 179.72
 },
 {
  "input": "So you would expect, as the sequence progresses, for things to get squished down more and more, and if anything you would expect the area to be getting smaller.",
  "translatedText": "",
  "from_community_srt": "따라서 배열이 진행됨에 따라 그래프가 점점 더 찌그러질 것으로 예상할 수 있으며, 어떤 경우에는 면적이 더 작아질 것으로 예상할 수 있습니다.",
  "n_reviews": 0,
  "start": 180.34,
  "end": 187.44
 },
 {
  "input": "Eventually that is exactly what happens, but what's bizarre is that it stays so stable for so long, and of course more pertinently, that when it does break at the value 15, it does so by the tiniest tiny amount.",
  "translatedText": "",
  "from_community_srt": "결국은, 이것은 당연히 언젠가는 일어나는 일이지만, 이상한 점은 이것이 너무 오랫동안 안정적으로 유지된다는 것입니다. 물론 더 정확하게는 값이 15일 때 작아지는데, 아주 적은 양으로 작아집니다.",
  "n_reviews": 0,
  "start": 188.36,
  "end": 200.6
 },
 {
  "input": "And before you go thinking this is the result of some numerical error, maybe because we're doing something with floating-point arithmetic, if you work this out more precisely, here is the exact value of that last integral, which is a certain fraction of pi where the numerator and the denominator are absurd.",
  "translatedText": "",
  "from_community_srt": "그리고 이것이 어떤 수치적 오류의 결과라고 생각하기 전에, 아마도 우리가 부동소수점 연산으로 무언가를 하고 있기 때문일 것입니다. 좀 더 정확하게 계산해 보면, 여기 마지막 부분에 정확한 값이 있습니다. 분자와 분모에 π가 있는 터무니없이 보이는 분수입니다. 둘 다 약 400의 10억의 10억의 10억 입니다.",
  "n_reviews": 0,
  "start": 201.18,
  "end": 215.84
 },
 {
  "input": "They're both around 400 billion billion billion.",
  "translatedText": "",
  "from_community_srt": "(40양; 40*{100조}²; 7 * 아보가드로수 * 1만;",
  "n_reviews": 0,
  "start": 215.98,
  "end": 218.7
 },
 {
  "input": "So this pattern was described in a paper by a father-son pair, Jonathan and David Borwein, which is very fun, and they mentioned how when a fellow researcher was computing these integrals using a computer algebra system, he assumed that this had to be some kind of bug.",
  "translatedText": "",
  "from_community_srt": "4.67*10²⁹) 그래서, 이 규칙은 한 가정의 아버지와 아들인 𝑱𝒐𝒏𝒂𝒕𝒉𝒂𝒏과 𝑫𝒂𝒗𝒊𝒅 𝑩𝒐𝒓𝒘𝒆𝒊𝒏이 한 논문에서 설명했습니다. 매우 재미있는 내용인데, 동료 연구원이 컴퓨터 대수학 시스템을 사용하여 이러한 적분을 계산할 때 이것이 일종의 버그일 것이라고 가정했지만 버그가 아니었습니다.",
  "n_reviews": 0,
  "start": 220.46,
  "end": 233.52
 },
 {
  "input": "But it's not a bug, it is a real phenomenon.",
  "translatedText": "",
  "from_community_srt": "실제 현상입니다.",
  "n_reviews": 0,
  "start": 233.86,
  "end": 236.26
 },
 {
  "input": "And it gets weirder than that actually.",
  "translatedText": "",
  "from_community_srt": "그리고 이것은 실제로 더 이상합니다.",
  "n_reviews": 0,
  "start": 236.68,
  "end": 238.12
 },
 {
  "input": "If we take all these integrals and include yet another factor, 2 cosine of x, which again you would think changes their values entirely, you can't just randomly multiply new things into an integral like this, it continues to equal pi for much much longer, and it's not until you get to the number 113 that it breaks.",
  "translatedText": "",
  "from_community_srt": "만약 우리가 이 모든 적분을 계산하고 또 다른 인자 2cos(𝒙)를 넣는다면, 여러분은 이 값이 완전히 변경된다고 생각할 것입니다 여러분은 여기에 무작위로 새로운 것을 곱할 수 없습니다. 2cos(𝒙)를 넣으면 계속해서 훨씬 더 오랫동안 같은 π를 유지하고 숫자 113에 도달하기 전 까진 깨지지 않습니다.",
  "n_reviews": 0,
  "start": 238.44,
  "end": 255.04
 },
 {
  "input": "And when it breaks, it's by the most puny, absolutely subtle amount that you could imagine.",
  "translatedText": "",
  "from_community_srt": "그리고 값이 깨졌을 때, 그것은 여러분이 상상할 수 있는 아주 보잘 것없는 미미한 양입니다.",
  "n_reviews": 0,
  "start": 255.2,
  "end": 259.68
 },
 {
  "input": "So the natural question is what on earth is going on here?",
  "translatedText": "",
  "from_community_srt": "그래서, 자연스러운 질문은 - 도대체 여기서 무슨 일이 일어나고 있는 걸까요?",
  "n_reviews": 0,
  "start": 260.44,
  "end": 264.08
 },
 {
  "input": "And luckily there actually is a really satisfying explanation for all this.",
  "translatedText": "",
  "from_community_srt": "그리고 운 좋게도 실제로 이 모든 것에 대한 정말 만족스러운 설명이 있습니다.",
  "n_reviews": 0,
  "start": 264.38,
  "end": 267.68
 },
 {
  "input": "The way I think I'll go about this is to show you a phenomenon that first looks completely unrelated, but it shows a similar pattern where you have a value that stays really stable until you get to the number 15, and then it falters by just a tiny amount.",
  "translatedText": "",
  "from_community_srt": "제가 이 문제에 대해 보여줄 방법은 처음에는 전혀 관련이 없어 보이지만, 비슷한 패턴을 보이는 것입니다. 15에 도달할 때 까지는 정말로 안정적인 값을 가진 다음 아주 작은 양만큼 흔들리는 것입니다.",
  "n_reviews": 0,
  "start": 268.18,
  "end": 280.58
 },
 {
  "input": "And then after that I'll show why this seemingly unrelated phenomenon is secretly the same as all our integral expressions, but in disguise.",
  "translatedText": "",
  "from_community_srt": "그런 다음, 겉보기에 관련이 없어 보이는 이 현상이 왜 우리의 모든 적분 표현과 비밀리에 동일하지만 숨겨져 있는지 보여드리겠습니다.",
  "n_reviews": 0,
  "start": 281.3,
  "end": 288.34
 },
 {
  "input": "So, turning our attention to what seems completely different, consider a function that I'm going to be calling rect of x, which is defined to equal 1 if the input is between negative 1 half and 1 half, and otherwise it's equal to 0.",
  "translatedText": "",
  "from_community_srt": "따라서 완전히 다르게 보이는 것에 주의를 돌려보면, 즉, 𝒙의 값이 -½ ~ ½ 일때 함수값이 1, 다를 때는 함수값이 0인 rect(𝒙) 함수를 고려해봅시다.",
  "n_reviews": 0,
  "start": 289.12,
  "end": 301.98
 },
 {
  "input": "So the function is this boring step, basically.",
  "translatedText": "",
  "from_community_srt": "함수는 기본적으로 별거 없는 단계입니다.",
  "n_reviews": 0,
  "start": 302.22,
  "end": 304.52
 },
 {
  "input": "This will be the first in a sequence of functions that we define, so I'll call it f1 of x, and each new function in our sequence is going to be a kind of moving average of the previous function.",
  "translatedText": "",
  "from_community_srt": "이것은 우리가 정의한 일련의 함수에서 첫 번째가 될 것이므로 𝒇₁(𝒙)라고 부르고, 이 일련 중 각각의 새로운 함수는 이전 함수의 이동 평균의 일종이 될 것입니다.",
  "n_reviews": 0,
  "start": 304.52,
  "end": 314.64
 },
 {
  "input": "So for example, the way the second iteration will be defined is to take this sliding window whose width is 1 third, and for a particular input x, when the window is centered at that input x, the value in my new function drawn below is defined to be equal to the average value of the first function above inside that window.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 두 번째 반복이 정의되는 방법은 특정한 입력 𝒙에 대해 너비가 ⅓인 슬라이딩 창을 취하는 것이고, 창이 입력 𝒙의 중앙에 있을 때, 아래에 그려진 새로운 함수의 값은 첫 번째 함수에서, 창에 해당하는 함수 값의 평균과 같도록 정의합니다.",
  "n_reviews": 0,
  "start": 315.8,
  "end": 333.84
 },
 {
  "input": "So for example, when the window is far enough to the left, every value inside it is 0, so the graph on the bottom is showing 0.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 창이 왼쪽으로 충분히 멀리 떨어져 있으면 그 안의 모든 값이 0이므로 맨 아래의 그래프는 0을 표시합니다.",
  "n_reviews": 0,
  "start": 333.84,
  "end": 339.82
 },
 {
  "input": "As soon as that window starts to go over the plateau a little bit, the average value is a little more than 0, and you see that in the graph below.",
  "translatedText": "",
  "from_community_srt": "해당 창이 고원을 약간 넘어가기 시작하면, 평균 값이 0보다 약간 크며 아래 그래프에서 볼 수 있습니다.",
  "n_reviews": 0,
  "start": 340.28,
  "end": 346.86
 },
 {
  "input": "And notice that when exactly half the window is over that plateau at 1 and half of it is at 0, the corresponding value in the bottom graph is 1 half, and you get the point.",
  "translatedText": "",
  "from_community_srt": "그리고 창의 절반이 값이 1인 고원에 있고, 나머지 절반이 0이면, 하단 그래프에 대응하는 값은 1의 절반이고, 여러분은 요점을 파악할 수 있습니다.",
  "n_reviews": 0,
  "start": 347.28,
  "end": 356.1
 },
 {
  "input": "The important thing I want you to focus on is how when that window is entirely in the plateau above, where all the values are 1, then the average value is also 1, so we get this plateau on our function at the bottom.",
  "translatedText": "",
  "from_community_srt": "제가 여러분이 주목해 주셨으면 하는 중요한 것은 어떻게 창이 모든 값이 1인 고원 위에 있을 때, 평균값도 1이 되는가 하는 것입니다. 결론은, 우리는 이 고원을 밑에 있는 함수에서도 얻습니다.",
  "n_reviews": 0,
  "start": 356.66,
  "end": 367.7
 },
 {
  "input": "Let's call this bottom function f2 of x, and what I want you to think about is the length of the plateau for that second function.",
  "translatedText": "",
  "from_community_srt": "이 하단에 있는 함수를 𝒇₂(𝒙)라고 하고, 제가 여러분이 생각하기를 바라는 것은 두 번째 함수에 대한 고원의 길이입니다.",
  "n_reviews": 0,
  "start": 368.3,
  "end": 375.3
 },
 {
  "input": "How wide should it be?",
  "translatedText": "",
  "n_reviews": 0,
  "start": 375.48,
  "end": 376.44
 },
 {
  "input": "If you think about it for a moment, the distance between the left edge of the top plateau and the left edge of the bottom plateau will be exactly half of the width of the window, so half of 1 third.",
  "translatedText": "",
  "from_community_srt": "길이가 얼마나 되어야 할까요? 잠시 생각해보면, 위에 있는 고원의 왼쪽 끝과 아래에 있는 고원의 왼쪽 끝 사이의 거리는 정확히 창 너비의 절반이 될 것입니다.",
  "n_reviews": 0,
  "start": 377.02,
  "end": 387.26
 },
 {
  "input": "And similarly on the right side, the distance between the edges of the plateaus is half of the window width.",
  "translatedText": "",
  "from_community_srt": "따라서, ⅓의 절반이 오른쪽에도 같듯이, 고원의 양끝의 거리는 창 너비의 절반입니다.",
  "n_reviews": 0,
  "start": 387.64,
  "end": 392.82
 },
 {
  "input": "So overall it's 1 minus that window width, which is 1 minus 1 third.",
  "translatedText": "",
  "from_community_srt": "따라서 전체적으로, 1에서 해당 창 너비를 빼는데, 1-⅓이 됩니다.",
  "n_reviews": 0,
  "start": 393.2,
  "end": 396.66
 },
 {
  "input": "The value we're going to be computing, the thing that will look stable for a while before it breaks, is the value of this function at the input 0, which in both of these iterations is equal to 1 because it's inside that plateau.",
  "translatedText": "",
  "from_community_srt": "우리가 계산할 값, 즉 값이 깨지기 전에 안정적으로 보여할 것은 𝒙=0 일 때의 함숫값 입니다. 이 함숫값은 이 두 반복들에서 값이 1로 같은데, 왜냐하면 고원 내부에 있기 때문입니다.",
  "n_reviews": 0,
  "start": 397.38,
  "end": 408.7
 },
 {
  "input": "For the next iteration, we're going to take a moving average of that last function, but this time with the window whose width is 1 fifth.",
  "translatedText": "",
  "from_community_srt": "다음 반복에서는, 방금 전 함수의 이동 평균을 취하지만 이번에는 너비가 ⅟₅인 창을 사용합니다.",
  "n_reviews": 0,
  "start": 409.2,
  "end": 415.32
 },
 {
  "input": "It's kind of fun to think about why as you slide around this window you get a smoothed out version of the previous function, and again, the significant thing I want you to focus on is how when that window is entirely inside the plateau of the previous function, then by definition the bottom function is going to equal 1.",
  "translatedText": "",
  "from_community_srt": "이 창을 슬라이드하면서 이 주위가 이전 함수에 비해 부드러운 버전을 얻는 이유에 대해 생각하는 것은 일종의 재미입니다. 그리고 다시 한 번 말씀드리지만 중요한 점은 해당 창이 완전히 이전 함수의 고원 안에 있는 경우입니다. 그러면 정의에 따라 맨 아래 함숫값은 1과 같습니다.",
  "n_reviews": 0,
  "start": 415.32,
  "end": 431.46
 },
 {
  "input": "This time the length of that plateau on the bottom will be the length of the previous one, 1 minus 1 third, minus the window width, 1 fifth.",
  "translatedText": "",
  "from_community_srt": "이번에는, 밑에 있는 고원의 길이는 이전 것의 길이인 1- ⅓에서 ⅕인 창 너비를 뺀 값이 됩니다.",
  "n_reviews": 0,
  "start": 431.98,
  "end": 439.24
 },
 {
  "input": "The reasoning is the same as before in order to go from the point where the middle of the window is on that top plateau to where the entirety of the window is inside that plateau is half the window width and likewise on the right side, and once more the value to record is the output of this function when the input is 0, which again is exactly 1.",
  "translatedText": "",
  "from_community_srt": "추론은 이전과 동일합니다. 창의 중앙이 고원의 끝 부분에서, 창 전체가 해당 고원 내부에 있는 지점으로 이동하기까지의 거리는 창 너비의 절반이고, 마찬가지로 오른쪽 부분도 그렇고, 𝒙=0일 때의 함수값도 그 전 추론과 동일합니다. 다시 말하지만, 정확히 1입니다.",
  "n_reviews": 0,
  "start": 439.6,
  "end": 457.32
 },
 {
  "input": "The next iteration is a moving average with a window width of 1 seventh.",
  "translatedText": "",
  "from_community_srt": "다음 반복은 창 너비가 ⅐인 이동 평균입니다.",
  "n_reviews": 0,
  "start": 458.58,
  "end": 461.88
 },
 {
  "input": "The plateau gets smaller by that 1 over 7.",
  "translatedText": "",
  "from_community_srt": "고원은 ⅐만큼 작아집니다.",
  "n_reviews": 0,
  "start": 462.1,
  "end": 464.04
 },
 {
  "input": "Doing one more iteration with 1 over 9, the plateau gets smaller by that amount.",
  "translatedText": "",
  "from_community_srt": "⅑로 한 번 더 반복하면, 고원은 그 양만큼 작아집니다.",
  "n_reviews": 0,
  "start": 464.5,
  "end": 468.06
 },
 {
  "input": "And as we keep going the plateau gets thinner and thinner.",
  "translatedText": "",
  "from_community_srt": "그리고 계속 진행하면서,",
  "n_reviews": 0,
  "start": 468.6,
  "end": 470.78
 },
 {
  "input": "And also notice how just outside of the plateau the function is really really close to 1 because it's always been the result of an average between the plateau at 1 and the neighbors, which themselves are really really close to 1.",
  "translatedText": "",
  "from_community_srt": "고원은 점점 더 얇아지고 또한 고원의 바로 바깥쪽에 있는 부분이 1에 정말 가까워지는 것을 알 수 있습니다. 이 부분은 값이 1인 고원과 그 근방의 평균인데 정말로 1에 가깝습니다.",
  "n_reviews": 0,
  "start": 471.82,
  "end": 482.74
 },
 {
  "input": "The point at which all of this breaks is once we get to the iteration where we're sliding a window with width 1 15th across the whole thing.",
  "translatedText": "",
  "from_community_srt": "이 모든 것이 깨지는 지점은 슬라이딩 창의 너비가 ⅟₁₅인 반복에 도달할 때 입니다.",
  "n_reviews": 0,
  "start": 483.44,
  "end": 490.36
 },
 {
  "input": "At that point the previous plateau is actually thinner than the window itself.",
  "translatedText": "",
  "from_community_srt": "이 시점에서, 이전 고원은 실제로 창 자체보다 얇습니다.",
  "n_reviews": 0,
  "start": 490.76,
  "end": 494.66
 },
 {
  "input": "So even at the input x equals 0, this moving average will have to be ever so slightly smaller than 1.",
  "translatedText": "",
  "from_community_srt": "따라서 𝒙=0 에서도, 이 이동 평균은 1보다 약간 작아야 합니다.",
  "n_reviews": 0,
  "start": 494.82,
  "end": 500.58
 },
 {
  "input": "And the only thing that's special about the number 15 here is that as we keep adding the reciprocals of these odd fractions, 1 third plus 1 fifth plus 1 seventh on and on, it's once we get to 1 15th that that sum grows to be bigger than 1.",
  "translatedText": "",
  "from_community_srt": "그리고 여기서 숫자 15의 특별한 점은 이 홀수들의 역수를 계속해서 더한다는 것입니다. ⅓ + ⅕ + ⅐, 계속해서 1/15에 도달하면 합은 1보다 커지며,",
  "n_reviews": 0,
  "start": 500.78,
  "end": 513.22
 },
 {
  "input": "And in the context of our shrinking plateaus, having started with a plateau of width 1, it's now shrunk down so much that it'll disappear entirely.",
  "translatedText": "",
  "from_community_srt": "너비가 1인 고원이 축소되는 과정이, 이제 고원 전체가 사라질 정도로 축소되었습니다.",
  "n_reviews": 0,
  "start": 513.58,
  "end": 521.14
 },
 {
  "input": "The point is with this as a sequence of functions that we've defined by a seemingly random procedure, if I ask you to compute the values of all of these functions at the input 0, you get a pattern which initially looks stable.",
  "translatedText": "",
  "from_community_srt": "요점은, 우리가 겉보기에는 무작위적인 절차로 정의한 일련의 함수에서, 제가 여러분에게 𝒙=0에서 이러한 모든 함수의 값을 계산하도록 요청하면 처음에는 안정적으로 보이는 패턴을 얻게 됩니다.",
  "n_reviews": 0,
  "start": 521.8,
  "end": 532.96
 },
 {
  "input": "It's 1 1 1 1 1 1 1, but by the time we get to the eighth iteration it falls short ever so slightly, just barely.",
  "translatedText": "",
  "from_community_srt": "1, 1, 1, 1, 1, 1, 1, 하지만 여덟 번째 반복에 도달할 즈음에는 거의 미묘하게 부족합니다.",
  "n_reviews": 0,
  "start": 533.12,
  "end": 540.04
 },
 {
  "input": "This is analogous, and I claim more than just analogous, to the integrals we saw earlier, where we have a stable value at pi pi pi pi pi until it falls short just barely.",
  "translatedText": "",
  "from_community_srt": "이것은 유사하며, 저는 우리가 이전에 보았던 적분과 유사하다고 주장하는 것 입니다. 여기서 π, π, π, π, π는 거의 부족할 때까지 안정적인 값을 갖습니다.",
  "n_reviews": 0,
  "start": 540.68,
  "end": 549.74
 },
 {
  "input": "And as it happens, this constant from our moving average process that's ever so slightly smaller than 1 is exactly the factor that sits in front of pi in our series of integrals.",
  "translatedText": "",
  "from_community_srt": "그리고 1보다 약간 작은 이동 평균 과정의 이 상수는 일련의 적분에서 π 앞에 있는 수와 같습니다.",
  "n_reviews": 0,
  "start": 550.18,
  "end": 559.96
 },
 {
  "input": "So the two situations aren't just qualitatively similar, they're quantitatively the same as well.",
  "translatedText": "",
  "from_community_srt": "따라서, 두 상황은 질적으로 유사할 뿐만 아니라 양적으로도 동일합니다.",
  "n_reviews": 0,
  "start": 560.34,
  "end": 564.84
 },
 {
  "input": "And when it comes to the case where we add the 2 cosine of x term inside the integral, which caused the pattern to last a lot longer before it broke down, in the analogy what that will correspond to is the same setup, but where the function we start with has an even longer plateau, stretching from x equals negative 1 up to 1, meaning its length is 2.",
  "translatedText": "",
  "from_community_srt": "그리고 적분 내부에 2cos(𝒙)를 추가하여, 패턴이 고장나기 전을 훨씬 더 오래 지속되도록 하는 경우, 이 유사점에서 어떻게 값이 대응할 지는 동일한 설정이지만, 여기서 우리가 시작하는 함수는 𝒙=-1에서 1까지 늘어나는 더 긴 고원을 가지게 됩니다. 즉 길이가 2인 고원을 의미합니다.",
  "n_reviews": 0,
  "start": 565.54,
  "end": 582.9
 },
 {
  "input": "So as you do this repeated moving average process, eating into it with these smaller and smaller windows, it takes a lot longer for them to eat into the whole plateau.",
  "translatedText": "",
  "from_community_srt": "따라서, 이 반복적인 이동 평균 과정을 수행하면서, 점점 더 작은 창으로 그것을 먹어치우면, 이들이 전체 고원을 먹는 데 훨씬 더 오랜 시간이 걸립니다.",
  "n_reviews": 0,
  "start": 582.9,
  "end": 590.98
 },
 {
  "input": "More specifically, the relevant computation is to ask how long do you have to add these reciprocals of odd numbers until that sum becomes bigger than 2?",
  "translatedText": "",
  "from_community_srt": "보다 구체적으로, 이와 관련있는 계산은 다음과 같은 질문을 하는 것입니다. 합이 2보다 커질 때까지 홀수의 역수를 얼마나 더 추가해야 할까요?",
  "n_reviews": 0,
  "start": 591.7,
  "end": 599.3
 },
 {
  "input": "And it turns out that you have to go until you hit the number 113, which will correspond to the fact that the integral pattern there continues until you hit 113.",
  "translatedText": "",
  "from_community_srt": "그리고 여러분은 숫자 113 까지 도달해야 한다고 밝혀졌습니다. 이 뜻은 113에 도달할 때까지 적분 패턴이 계속된다는 사실에 해당합니다.",
  "n_reviews": 0,
  "start": 599.72,
  "end": 608.34
 },
 {
  "input": "And by the way, I should emphasize that there is nothing special about these reciprocals of odd numbers, 1 3rd, 1 5th, 1 7th.",
  "translatedText": "",
  "from_community_srt": "그런데, 저는 이러한 홀수의 역수에는 특별한 것이 없음을 강조합니다. ⅓, ⅕,",
  "n_reviews": 0,
  "start": 609.1,
  "end": 615.68
 },
 {
  "input": "That just happens to be the sequence of values highlighted by the Borweins in their paper that made the sequence mildly famous in nerd circles.",
  "translatedText": "",
  "from_community_srt": "⅐ - 𝑩𝒐𝒓𝒘𝒆𝒊𝒏𝒔이 논문에서 강조한 배열의 값으로 인해, 해당 배열이 괴상한 원에서 약간 유명해졌습니다.",
  "n_reviews": 0,
  "start": 615.68,
  "end": 621.92
 },
 {
  "input": "More generally, we could be inserting any sequence of positive numbers into those sinc functions, and as long as the sum of those numbers is less than 1, our expression will equal pi.",
  "translatedText": "",
  "from_community_srt": "더 일반적으로, 우리는 sinc 함수에 임의의 양수 수열을 넣을 수 있으며 해당 숫자의 합이 1보다 작으면 표현식은 π와 같지만, 1보다 커지면 표현식이 π보다 작아집니다.",
  "n_reviews": 0,
  "start": 622.44,
  "end": 631.32
 },
 {
  "input": "But as soon as they become bigger than 1, our expression drops a little below pi.",
  "translatedText": "",
  "n_reviews": 0,
  "start": 631.7,
  "end": 635.18
 },
 {
  "input": "And if you believe me that there's an analogy with these moving averages, you can hopefully see why.",
  "translatedText": "",
  "from_community_srt": "그리고 이러한 이동 평균과 유사한 점이 있다고 생각한다면 그 이유를 알 수 있기를 바랍니다.",
  "n_reviews": 0,
  "start": 635.18,
  "end": 640.02
 },
 {
  "input": "But of course, the burning question is why on earth should these two situations have anything to do with each other?",
  "translatedText": "",
  "from_community_srt": "그러나 물론 화급한 질문은 도대체 왜 이 두 상황이 서로 관련이 있어야 하느냐는 것입니다.",
  "n_reviews": 0,
  "start": 641.84,
  "end": 647.8
 },
 {
  "input": "From here, the argument does bring in two mildly heavy bits of machinery, namely Fourier transforms and convolutions.",
  "translatedText": "",
  "from_community_srt": "여기에서, 이 논증은 약간 무거운 기술 두 개를 가져옵니다. 바로, \"푸리에 변환\" 그리고 \"합성곱\"입니다.",
  "n_reviews": 0,
  "start": 648.24,
  "end": 655.24
 },
 {
  "input": "And the way I'd like to go about this is to spend the remainder of this video giving you a high-level sense of how the argument will go, without necessarily assuming you're familiar with either of those two topics, and then to explain why the details are true in a video that's dedicated to convolutions, in particular something called the convolution theorem, since it's incredibly beautiful and it's useful well beyond this specific, very esoteric question.",
  "translatedText": "",
  "from_community_srt": "그리고 제가 이것에 대해 말하고 싶은 방법은, 이 영상의 나머지 부분을 여러분이 이 두 가지 주제 중 어느 하나에 익숙하다고 가정하지 않고, 논증이 어떻게 진행될지에 대한 높은 수준의 감각을 제공하는 것입니다. 그리고 나서 왜 이러한 디테일들이 합성곱 전용 영상에서 사실인지 설명하는 것입니다. 특히 \"𝑻𝒉𝒆 𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏 𝑻𝒉𝒆𝒐𝒓𝒆𝒎\"이라고 불리는 것은 믿을 수 없을 정도로 아름답고 이러한 매우 난해한 질문을 넘어 훨씬 유용하기 때문입니다.",
  "n_reviews": 0,
  "start": 655.86,
  "end": 678.12
 },
 {
  "input": "To start, instead of focusing on this function sine of x divided by x, where we want to show why the signed area underneath its curve is equal to pi, we'll make a simple substitution where we replace the input x with pi times x, which has the effect of squishing the graph horizontally by a factor of pi, and so the area gets scaled down by a factor of pi, meaning our new goal is to show why this integral on the right is equal to exactly 1.",
  "translatedText": "",
  "from_community_srt": "시작하기 위해, 이 함수 sin(𝒙)/𝒙에 초점을 맞추는 대신, 즉 곡선 아래의 부호 면적이 π와 같은 이유를 보여주고자 하는 대신, 입력 𝒙를 π*𝒙로 바꾸는 간단한 치환을 할 것입니다. 이는 그래프의 가로를 π만큼 찌그러뜨리는 효과가 있으므로 넓이는 π만큼 축소됩니다. 즉, 우리의 새로운 목표는 오른쪽의 이 적분이 정확히 1과 같은 이유를 보여주는 것입니다.",
  "n_reviews": 0,
  "start": 681.08,
  "end": 704.92
 },
 {
  "input": "By the way, in some engineering contexts, people use the name sinc to refer to this function with the pi on the inside, since it's often very nice to have a normalized function, meaning the area under it is equal to 1.",
  "translatedText": "",
  "from_community_srt": "그건 그렇고, 일부 공학 측면에서, 사람들은 내부에 π가 있는 이 함수를 지칭하기 위해 \"sinc\"라는 이름을 사용합니다. 왜냐하면 면적이 1인 거와 같이, 정규화된 함수를 갖는 것은 종종 매우 좋기 때문입니다.",
  "n_reviews": 0,
  "start": 705.5,
  "end": 716.16
 },
 {
  "input": "The point is, showing this integral on the right is exactly the same thing as showing the integral on the left, it's just a change of variables.",
  "translatedText": "",
  "from_community_srt": "요점은, 오른쪽에 표시된 적분은, 왼쪽에 표시된 적분과 정확히 동일하며,",
  "n_reviews": 0,
  "start": 716.16,
  "end": 721.9
 },
 {
  "input": "And likewise for all of the other ones in our sequence, go through each of them, replace the x with a pi times x, and from here the claim is that all these integrals are not just analogous to the moving average examples, but that both of these are two distinct ways of computing exactly the same thing.",
  "translatedText": "",
  "from_community_srt": "그저 변수의 변환일 뿐입니다. 그리고 마찬가지로 우리 배열의 모든 것들에서, 각각을 살펴보고 𝒙를 π*𝒙로 바꿔봅시다. 여기에서 주장하는 것은 이 모든 적분이 이동 평균 예제와 유사할 뿐만 아니라, 둘 다 서로 같은 것을 계산하는 별개의 두 가지 계산 방법입니다.",
  "n_reviews": 0,
  "start": 722.58,
  "end": 737.9
 },
 {
  "input": "And the connection comes down to the fact that this sinc function, or the engineer sinc function with the pi on the inside, is related to the rect function using what's known as a Fourier transform.",
  "translatedText": "",
  "from_community_srt": "그리고 sinc 함수와 π가 있는 엔지니어 sinc 함수의 내부적인 연관성은 푸리에 변환으로 알고있는 rect함수와 연관돼있다고 할 수 있습니다.",
  "n_reviews": 0,
  "start": 738.5,
  "end": 747.62
 },
 {
  "input": "Now, if you've never heard of a Fourier transform, there are a few other videos on this channel all about it.",
  "translatedText": "",
  "from_community_srt": "이제 푸리에 변환에 대해 들어본 적이 없으시다면, 이 채널에 이에 관한 몇 가지 다른 영상들이 있습니다.",
  "n_reviews": 0,
  "start": 748.26,
  "end": 752.56
 },
 {
  "input": "The way it's often described is that if you want to break down a function as the sum of a bunch of pure frequencies, or in the case of an infinite function, a continuous integral of a bunch of pure frequencies, the Fourier transform will tell you all the strength and phases for all those constituent parts.",
  "translatedText": "",
  "from_community_srt": "(많시부) 자주 설명되는 방식은, 함수를 순수 파동의 합으로 나누거나, 또는 무한 함수의 경우, 순수 파동의 연속적인 적분인 푸리에 변환은 모든 구성 부분의 강도와 단계를 여러분에게 알려줍니다.",
  "n_reviews": 0,
  "start": 752.74,
  "end": 766.74
 },
 {
  "input": "But all you really need to know here is that it is something which takes in one function and spits out a new function, and you often think of it as kind of rephrasing the information of your original function in a different language, like you're looking at it from a new perspective.",
  "translatedText": "",
  "from_community_srt": "그러나 여기에서 정말로 알아야 할 것은 하나의 함수를 취하고 새로운 함수를 만드는 것인데, 여러분은 원래 함수의 정보를 다른 언어로 바꾸는 것처럼 생각하는 경우가 많습니다. 마치 이것을 새로운 관점에서 바라보는 것처럼 말이죠.",
  "n_reviews": 0,
  "start": 767.12,
  "end": 780.52
 },
 {
  "input": "For example, like I said, this sinc function written in this new language where you take a Fourier transform looks like our top hat rect function.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 제가 말했듯이, 푸리에 변환을 취하는 이 새로운 언어로 작성된 이 sinc 함수는 우리의 top hat rect 함수처럼 보입니다.",
  "n_reviews": 0,
  "start": 781.32,
  "end": 788.52
 },
 {
  "input": "And vice versa, by the way.",
  "translatedText": "",
  "from_community_srt": "그리고 그 반대의 경우도 마찬가지입니다.",
  "n_reviews": 0,
  "start": 789.1,
  "end": 790.2
 },
 {
  "input": "This is a nice thing about Fourier transforms for functions that are symmetric about the y-axis, it is its own inverse, and actually the slightly more general fact that we'll need to show is how when you transform the stretched out version of our sinc function, where you stretch it horizontally by a factor of k, what you get is a stretched and squished version of this rect function.",
  "translatedText": "",
  "from_community_srt": "이것은 푸리에 변환의 좋은 것인 𝒚축에 대칭인 함수입니다. 즉, 역함수이며, 실제로 우리가 보여야 할 약간 더 일반적인 사실은 우리의 sinc 함수의 확장된 버전을 변환할 때입니다. 함수를 𝒌만큼 수평으로 늘리면, 이 rect 함수는 늘어나거나 찌그러진 버전이 됩니다.",
  "n_reviews": 0,
  "start": 790.26,
  "end": 808.04
 },
 {
  "input": "But of course, all of these are just meaningless words and terminology, unless you can actually do something upon making this translation.",
  "translatedText": "",
  "from_community_srt": "그러나, 물론 이러한 번역을 할 때 실제로 무언가를 할 수 없다면 이 모든 것은 의미 없는 단어와 용어일 뿐입니다.",
  "n_reviews": 0,
  "start": 808.6,
  "end": 814.5
 },
 {
  "input": "And the real idea behind why Fourier transforms are such a useful thing for math is that when you take statements and questions about a particular function, and then you look at what they correspond to with respect to the transformed version of that function, those statements and questions often look very very different in this new language, and sometimes it makes the questions a lot easier to answer.",
  "translatedText": "",
  "from_community_srt": "푸리에 변환이 수학에 매우 유용한 이유에 대한 진짜 아이디어는 특정 함수에 대한 진술과 질문을 받을 때, 그리고 함수의 변환된 버전과 관련한 진술 및 질문들이 이 새로운 언어에서는 종종 매우 다르게 보이며 때로는 질문에 답하기가 훨씬 쉽습니다.",
  "n_reviews": 0,
  "start": 815.1,
  "end": 834.98
 },
 {
  "input": "For example, one very nice little fact, another thing on our list of things to show, is that if you want to compute the integral of some function from negative infinity to infinity, this signed area under the entirety of its curve, it's the same thing as simply evaluating the Fourier transformed version of that function at the input zero.",
  "translatedText": "",
  "from_community_srt": "예를 들어, 우리의 리스트에 있는 것 중 보여드릴 아주 좋은 사실 하나는, 음의 무한대에서 무한대까지 몇몇 함수의 적분을 계산하려는 경우는, 즉 곡선 아래의 이 부호 면적은, 푸리에 변환이 된 함수에서 𝒙=0 값을 계산하는 것과 같습니다.",
  "n_reviews": 0,
  "start": 835.66,
  "end": 853.36
 },
 {
  "input": "This is a fact that will actually just pop right out of the definition, and it's representative of a more general vibe that every individual output of the Fourier transform function on the right corresponds to some kind of global information about the original function on the left.",
  "translatedText": "",
  "from_community_srt": "이러한 정의에서 바로 튀어나온 사실은 오른쪽의 푸리에 변환 함수의 모든 각각의 함숫값이 왼쪽의 원래 함수에 대한 일종의 모든 정보에 해당한다는, 더 일반적인 경우를 대표합니다.",
  "n_reviews": 0,
  "start": 853.82,
  "end": 868.24
 },
 {
  "input": "In our specific case, it means if you believe me that this sync function and the rect function are related with a Fourier transform like this, it explains the integral, which is otherwise a very tricky thing to compute, because it's saying all that signed area is the same thing as evaluating rect at zero, which is just one.",
  "translatedText": "",
  "from_community_srt": "우리의 특정한 경우, 만약 여러분이 이 sinc 함수와 rect 함수가 이렇게 푸리에 변환과 관련이 있다고 여긴다면, 이것은 적분을 설명하는데는 매우 까다롭습니다. 왜냐하면 모든 부호 면적은 함숫값이 1인, 즉 𝒙=0에서의 rect 함수를 계산하는 것과 같기 때문입니다.",
  "n_reviews": 0,
  "start": 868.72,
  "end": 885.04
 },
 {
  "input": "Now, you could complain, surely this just moves the bump under the rug.",
  "translatedText": "",
  "from_community_srt": "이제, 여러분은 불평할 수도 있습니다 확실히 이 부분은 뭔가를 숨긴 것 같습니다.",
  "n_reviews": 0,
  "start": 886.14,
  "end": 889.34
 },
 {
  "input": "Surely computing this Fourier transform, whatever that looks like, would be as hard as computing the original integral.",
  "translatedText": "",
  "from_community_srt": "확실히 이 푸리에 변환을 계산하는 것은, 원래 적분을 계산하는 것만큼 어려울 것입니다.",
  "n_reviews": 0,
  "start": 889.7,
  "end": 894.68
 },
 {
  "input": "But the idea is that there's lots of tips and tricks for computing these Fourier transforms, and moreover, that when you do, it tells you a lot more information than just that integral.",
  "translatedText": "",
  "from_community_srt": "그러나 아이디어는 이러한 푸리에 변환을 계산하기 위한 많은 팁과 트릭이 있다는 것입니다. 게다가 이렇게 계산을 할 때, 적분을 할 때 보다 훨씬 더 많은 정보를 알려줍니다.",
  "n_reviews": 0,
  "start": 895.04,
  "end": 903.72
 },
 {
  "input": "You get a lot of bang for your buck out of doing the computation.",
  "translatedText": "",
  "from_community_srt": "여러분은 더 많은 계산을 함으로써 더 많은 결과를 얻을 수 있습니다.",
  "n_reviews": 0,
  "start": 903.88,
  "end": 906.38
 },
 {
  "input": "Now, the other key fact that will explain the connection we're hunting for is that if you have two different functions and you take their product, and then you take the Fourier transform of that product, it will be the same thing as if you individually took the Fourier transforms of your original function, and then combined them using a new kind of operation that we'll talk all about in the next video, known as a convolution.",
  "translatedText": "",
  "from_community_srt": "자, 연결성에 관해서 우리가 찾는 또 다른 핵심 사실은 만약 당신이 두 개의 다른 함수를 가지고 있고, 그 함수들끼리 곱을 하고, 그 다음 푸리에 변환을 취하는 것은, 원래 각각의 함수에 푸리에 변환을 개별적으로 취한 다음, 제가 다음 영상에서 다룰 새로운 연산자인 합성곱(𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏)을 사용해서 그것들을 결합하는 것과 같다는 것 입니다.",
  "n_reviews": 0,
  "start": 907.2,
  "end": 927.82
 },
 {
  "input": "Now, even though there's a lot to be explained with convolutions, the upshot will be that in our specific case with these rectangular functions, taking a convolution looks just like one of the moving averages that we've been talking about this whole time, combined with our previous fact that integrating in one context looks like evaluating at zero in another context, if you believe me that multiplying in one context corresponds to this new operation, convolutions, which for our example you should just think of as moving averages, that will explain why multiplying more and more of these sinc functions together can be thought about in terms of these progressive moving averages and always evaluating at zero, which in turn gives a really lovely intuition for why you would expect such a stable value before eventually something breaks down as the edges of the plateau inch closer and closer to the center.",
  "translatedText": "",
  "from_community_srt": "자, 합성곱에 대해서 설명해야 할 것이 많지만, 결론은 이러한 직사각형 함수의 특정 경우에 합성곱을 취하는 것이, 우리가 지금까지 다뤄온 이동 평균 중 하나처럼 보인다는 것입니다. “한 상황”에서의 적분이, “다른 상황”에서는 x=0 일 때의 계산되는 것처럼 보인다는 이전의 사실과 결합하면, 우리의 예시에서 이동평균으로 생각되는, “한 상황”에서의 곱하는 것은 새로운 연산, 합성곱(𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏)에 해당한다는 것이며, 이는 이러한 sinc 함수를 점점 더 많이 곱하는 것을, 이러한 𝒙=0 에서의 값을 계산하는 점진적인 이동 평균의 관점으로 생각할 수 있는 이유를 설명할 것입니다. 결국 이것은 결국 고원의 가장자리가 점점 중심에 가까워지면서 무언가가 무너지기 전에 왜 그렇게 안정적인 값을 기대할 수 있는지에 대해 정말 멋진 직관을 제공할 수 있습니다.",
  "n_reviews": 0,
  "start": 928.5,
  "end": 974.08
 },
 {
  "input": "This last key fact, by the way, has a special name.",
  "translatedText": "",
  "from_community_srt": "그런데 이 마지막 핵심 사실은 특별한 이름을 가지고 있습니다.",
  "n_reviews": 0,
  "start": 975.54,
  "end": 977.8
 },
 {
  "input": "It's called the convolution theorem, and again, it's something that we'll go into much more deeply.",
  "translatedText": "",
  "from_community_srt": "𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏 𝑻𝒉𝒆𝒐𝒓𝒆𝒎이라고 하며, 우리가 훨씬 더 깊이 탐구할 것입니다.",
  "n_reviews": 0,
  "start": 977.9,
  "end": 981.8
 },
 {
  "input": "I recognize that it's maybe a little unsatisfying to end things here by laying down three magical facts and saying everything follows from those, but hopefully this gives you a little glimpse of why powerful tools like Fourier transforms can be so useful for tricky problems.",
  "translatedText": "",
  "from_community_srt": "저는 여기서 세 가지 마법같은 사실을 제시하고 \"모든 것은 그것들에서 비롯된다\"고 말함으로써, 일을 끝내는 것은 약간 불만족스러울 수 있다는 것을 알고 있습니다. 하지만 이것이 푸리에 변환과 같은 강력한 도구가 이러한 까다로운 문제에 왜 그렇게 유용한지 깨닫기를 바랍니다.",
  "n_reviews": 0,
  "start": 982.96,
  "end": 997.12
 },
 {
  "input": "It's a systematic way to provide a shift in perspective where hard problems can sometimes look easier.",
  "translatedText": "",
  "from_community_srt": "어려운 문제가 때때로 더 쉬워 보일 수 있는 관점의 전환을 제공하는 체계적인 방법입니다.",
  "n_reviews": 0,
  "start": 997.6,
  "end": 1003.58
 },
 {
  "input": "If nothing else, it hopefully provides some motivation to learn about these beautiful things like the convolution theorem.",
  "translatedText": "",
  "from_community_srt": "다른 것은 아니지만, 𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏 𝑻𝒉𝒆𝒐𝒓𝒆𝒎과 같은 아름다운 것들에 대해 배울 수 있는 동기가 제공됐기를 바랍니다.",
  "n_reviews": 0,
  "start": 1004.04,
  "end": 1008.78
 },
 {
  "input": "As one more tiny teaser, another fun consequence of this convolution theorem will be that it opens the doors for an algorithm that lets you compute the product of two large numbers very quickly, like way faster than you think should be even possible.",
  "translatedText": "",
  "from_community_srt": "또 하나의 작은 티저로서, 이 𝑪𝒐𝒏𝒗𝒐𝒍𝒖𝒕𝒊𝒐𝒏 𝑻𝒉𝒆𝒐𝒓𝒆𝒎의 또 다른 재미있는 결과는 두 개의 큰 수의 곱을 매우 빠르게 계산할 수 있는 알고리즘의 문을 열어준다는 것입니다.",
  "n_reviews": 0,
  "start": 1009.42,
  "end": 1021.96
 },
 {
  "input": "So with that, I'll see you in the next video.",
  "translatedText": "",
  "from_community_srt": "그럼, 다음 영상(합성곱)에서 뵙겠습니다.",
  "n_reviews": 0,
  "start": 1023.0,
  "end": 1024.6
 }
]