1
00:00:00,000 --> 00:00:02,840
有时感觉宇宙只是在捉弄你。

2
00:00:02,840 --> 00:00:07,720
我在屏幕上显示了一系列计算，不用担心，一会儿我们将解压并可视化每个计算的真正含义。

3
00:00:07,720 --> 00:00:10,240


4
00:00:10,480 --> 00:00:16,960
我想让你注意的是，序列如何遵循一个非常可预测的、看似随机的模式，以及每次计算如何恰好等于 pi。

5
00:00:17,280 --> 00:00:22,880
如果您出于某种原因只是在计算机上随意评估这些，您可能会认为这是一种会永远持续下去的模式。

6
00:00:22,920 --> 00:00:25,640


7
00:00:25,960 --> 00:00:32,200
但事实并非如此。 在某个时刻它会停止，并且您得到的值不再等于 pi，而是仅略小于

8
00:00:32,680 --> 00:00:34,680
pi。

9
00:00:38,880 --> 00:00:40,880
好吧，让我们深入了解一下这里发生了什么。

10
00:00:40,880 --> 00:00:44,680
今天故事的主角是 x 除以 x 的函数正弦。

11
00:00:45,120 --> 00:00:48,600
这实际上在数学和工程中很常见，它有自己的名字，sinc，你可能会想到它的方式是从正常的振荡正弦曲线开始，然后当你远离正弦曲线时将其压扁。通过将 x

12
00:00:48,880 --> 00:00:52,280
乘以 1

13
00:00:52,600 --> 00:00:58,920
来归零。

14
00:00:59,040 --> 00:01:05,360
精明的人可能会问 x 等于 0 时会发生什么，因为当你将其代入时，它看起来就像是 0 除以 0。

15
00:01:05,360 --> 00:01:09,160
然后，你们当中更精明的人（也许是刚从微积分课上毕业的人）可能会指出，对于越来越接近 0

16
00:01:09,480 --> 00:01:14,640
的值，函数会越来越接近 1。

17
00:01:14,880 --> 00:01:20,200
因此，如果我们简单地将 sinc 函数重新定义为 0 等于 1，您就会得到一条漂亮的连续曲线。

18
00:01:20,520 --> 00:01:27,080
所有这些都是顺便说一下，因为我们真正关心的是这条曲线从负无穷大到无穷大的积分，你可以认为它意味着曲线和 x

19
00:01:27,320 --> 00:01:33,800
轴之间的面积，或者更准确地说是有符号的面积，这意味着您将 x

20
00:01:34,000 --> 00:01:37,760
轴上图形的正数部分所包围的所有面积相加，并减去图形的负数部分和 x

21
00:01:38,000 --> 00:01:42,000
轴所包围的所有部分。

22
00:01:42,320 --> 00:01:46,760
就像我们在开始时看到的那样，碰巧它的计算结果恰好是

23
00:01:47,000 --> 00:01:53,080
pi，这很好，但也有点奇怪，并且不完全清楚如何使用常用的微积分工具来处理这个问题。

24
00:01:53,600 --> 00:01:56,320
在视频的最后，我将分享如何做到这一点的技巧。

25
00:01:56,720 --> 00:02:02,960
继续我打开的序列，下一步是获取 sinc 函数的副本，在其中插入 x

26
00:02:03,400 --> 00:02:08,200
除以 3，它基本上看起来像相同的图形，但水平拉伸了 3 倍。

27
00:02:08,520 --> 00:02:10,920
当我们将这两个函数相乘时，我们会得到一个更复杂的波，其质量似乎更集中在中间，并且对于任何常用函数，您都会期望这完全改变了面积。

28
00:02:11,120 --> 00:02:16,000


29
00:02:16,040 --> 00:02:19,760


30
00:02:19,960 --> 00:02:23,360
您不能只是随机修改这样的积分，并且期望不会发生任何变化。

31
00:02:23,760 --> 00:02:28,360
所以这个结果也等于 pi 已经有点奇怪了，没有任何改变。

32
00:02:28,760 --> 00:02:31,040
这是您应该添加到列表中的另一个谜团。

33
00:02:31,040 --> 00:02:36,480
该序列的下一步是采用 5 倍的 sinc

34
00:02:36,960 --> 00:02:44,240
函数的更延伸版本，将其乘以我们已有的值，然后再次查看整个曲线下方的带符号区域，该区域再次等于 pi 。

35
00:02:45,000 --> 00:02:50,760
就这样继续下去。 在每次迭代中，我们都会拉伸一个新的奇数，并将其乘以我们所拥有的值。

36
00:02:51,240 --> 00:02:54,600
您可能会注意到的一件事是，除了输入 x 等于 0

37
00:02:55,000 --> 00:02:59,600
之外，该函数的每个部分都逐渐乘以小于 1 的值。

38
00:03:00,040 --> 00:03:04,440
所以你会期望，随着序列的进展，事物会被越来越压扁，如果有的话，你会期望该区域变得越来越小。

39
00:03:04,720 --> 00:03:07,320


40
00:03:08,400 --> 00:03:13,560
最终确实发生了这样的情况，但奇怪的是它在很长时间内保持如此稳定，当然更相关的是，当它在值 15

41
00:03:13,560 --> 00:03:20,800
处崩溃时，它的破坏量是最小的。

42
00:03:21,080 --> 00:03:23,840
在你认为这是一些数值误差的结果之前，也许是因为我们正在用浮点算术做一些事情，如果你更精确地计算出这个结果，这是最后一个积分的精确值，它是一个特定的分数pi

43
00:03:23,840 --> 00:03:27,960
的分子和分母都是荒谬的。

44
00:03:28,200 --> 00:03:35,760


45
00:03:35,760 --> 00:03:38,600
它们的价值都在 4000 亿左右。

46
00:03:39,280 --> 00:03:44,880
因此，这种模式是由一对父子 Jonathan

47
00:03:44,880 --> 00:03:50,120
和 David

48
00:03:50,120 --> 00:03:52,520
Borwein 在一篇论文中描述的，这非常有趣，他们提到当一位研究员同事使用计算机代数系统计算这些积分时，他认为这必须是某种错误。

49
00:03:52,520 --> 00:03:57,080
但这不是一个错误，而是一个真实的现象，而且比实际情况更奇怪。

50
00:03:57,080 --> 00:04:01,560
如果我们采用所有这些积分并包含另一个因子，x 的

51
00:04:01,560 --> 00:04:04,400
2 余弦，您会再次认为这完全改变了它们的值，您不能只是将新事物随机乘以这样的积分，它仍然等于

52
00:04:04,400 --> 00:04:07,520
pi更长，直到到达数字 113

53
00:04:07,520 --> 00:04:13,920
时它才中断。

54
00:04:13,920 --> 00:04:18,680
当它破裂时，其程度是你能想象到的最微不足道、绝对微妙的程度。

55
00:04:18,680 --> 00:04:22,880
所以自然的问题是，这里到底发生了什么？

56
00:04:22,880 --> 00:04:26,560
幸运的是，这一切实际上有一个非常令人满意的解释。

57
00:04:26,560 --> 00:04:31,440
我认为我要解决这个问题的方法是向您展示一种现象，乍一看似乎完全不相关，但它显示了类似的模式，其中您的值在达到数字 113

58
00:04:31,440 --> 00:04:37,280
之前一直保持稳定。

59
00:04:37,280 --> 00:04:41,120
当你到达数字 15 时，它就略有下降。

60
00:04:41,120 --> 00:04:44,960
然后，我将展示为什么这种看似无关的现象实际上与我们所有的积分表达式相同，但经过了伪装。

61
00:04:44,960 --> 00:04:48,960


62
00:04:48,960 --> 00:04:51,840
因此，将我们的注意力转向看起来完全不同的东西，考虑一个我将调用 x 的

63
00:04:51,840 --> 00:04:55,120
rect 的函数，如果输入介于负二分之一和二分之一之间，则该函数定义为等于

64
00:04:55,120 --> 00:05:00,560
1，否则等于 0 。

65
00:05:00,560 --> 00:05:05,040
所以这个功能基本上就是这个无聊的步骤。

66
00:05:05,040 --> 00:05:09,600
这将是我们定义的函数序列中的第一个，因此我将其称为 x

67
00:05:09,600 --> 00:05:15,600
的 f1，并且序列中的每个新函数都将是前一个函数的移动平均值。

68
00:05:15,600 --> 00:05:21,520
例如，定义第二次迭代的方式是采用宽度为三分之一的滑动窗口，对于特定的输入

69
00:05:21,520 --> 00:05:26,160
x，当窗口以该输入

70
00:05:26,160 --> 00:05:28,960
x

71
00:05:28,960 --> 00:05:34,080
为中心时，我的新函数中的值如下所示，被定义为等于该窗口内上面第一个函数的平均值。

72
00:05:34,080 --> 00:05:38,000
例如，当窗口距离左侧足够远时，窗口内的每个值都是 0，因此底部的图形显示为

73
00:05:38,000 --> 00:05:40,160
0。

74
00:05:40,160 --> 00:05:43,120
一旦该窗口开始稍微超过平台期，平均值就会略大于

75
00:05:43,120 --> 00:05:47,120
0，您可以在下图中看到这一点。

76
00:05:47,120 --> 00:05:52,320
请注意，当正好有一半窗口位于 1 处的稳定状态并且一半位于

77
00:05:52,320 --> 00:05:56,560
0 处时，底部图表中的相应值是二分之一，您就明白了。

78
00:05:56,560 --> 00:06:01,840
我希望您关注的重要一点是，当该窗口完全处于上面的稳定状态（所有值均为

79
00:06:01,840 --> 00:06:05,360
1）时，平均值也是

80
00:06:05,360 --> 00:06:08,160
1，因此我们在底部的函数上得到了这个稳定状态。

81
00:06:08,160 --> 00:06:10,720
我们将这个底部函数称为 x 的

82
00:06:10,720 --> 00:06:15,360
f2 ，我希望您考虑的是第二个函数的平台长度。

83
00:06:15,360 --> 00:06:16,320
应该多宽？

84
00:06:16,960 --> 00:06:21,520
如果您想一下，顶部高原的左边缘和底部高原的左边缘之间的距离将恰好是窗口宽度的一半，即三分之一的一半。

85
00:06:21,520 --> 00:06:26,000


86
00:06:26,000 --> 00:06:27,600


87
00:06:27,600 --> 00:06:31,440
与右侧类似，平台边缘之间的距离是窗口宽度的一半，因此总体来说是 1 减去窗口宽度，即

88
00:06:31,440 --> 00:06:36,720
1 减去三分之一。

89
00:06:37,360 --> 00:06:41,520
我们要计算的值，即在崩溃之前看起来稳定一段时间的值，是该函数在输入 0

90
00:06:42,080 --> 00:06:44,640
处的值，在这两次迭代中，该值都等于

91
00:06:44,640 --> 00:06:49,120
1，因为它位于该平台内。

92
00:06:49,120 --> 00:06:52,880
对于下一次迭代，我们将采用最后一个函数的移动平均值，但这次使用宽度为五分之一的窗口。

93
00:06:52,880 --> 00:06:55,840


94
00:06:55,840 --> 00:06:58,880
想想为什么当你在这个窗口中滑动时，你会得到前一个函数的平滑版本，这很有趣。

95
00:06:58,880 --> 00:07:01,920


96
00:07:01,920 --> 00:07:06,400
再说一次，我希望您关注的重要事情是，当该窗口完全位于前一个函数的稳定区间内时，那么根据定义，底部函数将等于

97
00:07:06,400 --> 00:07:11,360
1。

98
00:07:11,920 --> 00:07:16,160
这次，底部平台的长度将是前一个平台的长度，1

99
00:07:16,160 --> 00:07:19,520
减去三分之一，再减去窗口宽度，即五分之一。

100
00:07:19,520 --> 00:07:22,880
推理与之前相同，为了从窗口中间位于顶部高原的点到整个窗口位于该高原内部的位置，是窗口宽度的一半，同样在右侧。

101
00:07:22,880 --> 00:07:28,000


102
00:07:28,000 --> 00:07:31,120


103
00:07:31,120 --> 00:07:35,600
再次强调，当输入为 0

104
00:07:35,600 --> 00:07:37,200
时，要记录的值是该函数的输出，即恰好为 1。

105
00:07:38,400 --> 00:07:41,840
下一次迭代是窗口宽度为七分之一的移动平均值。

106
00:07:41,840 --> 00:07:44,320
平台变小了七分之一。

107
00:07:44,320 --> 00:07:48,400
再用 1 over 9 进行一次迭代，平台就会变小相应的量。

108
00:07:48,400 --> 00:07:50,720
随着我们继续前进，高原变得越来越薄。

109
00:07:51,680 --> 00:07:56,240
另外，请注意，在高原之外，该函数非常非常接近 1，因为它始终是

110
00:07:56,240 --> 00:08:00,480
1 处的高原和相邻函数之间的平均值的结果，而相邻函数本身非常非常接近

111
00:08:00,480 --> 00:08:02,160
1。

112
00:08:02,960 --> 00:08:07,520
当我们进入迭代时，所有这些都会中断，此时我们正在滑动一个宽度为整个事物的十五分之一的窗口。

113
00:08:07,520 --> 00:08:09,840


114
00:08:10,560 --> 00:08:14,400
到那时，之前的平台实际上比窗口本身还薄。

115
00:08:14,400 --> 00:08:20,240
因此，即使输入 x 等于 0，该移动平均值也必须略小于 1。

116
00:08:20,960 --> 00:08:24,000
这里数字

117
00:08:24,000 --> 00:08:26,720
15

118
00:08:26,720 --> 00:08:29,520
的唯一特别之处在于，当我们不断添加这些奇数分数的倒数时，三分之一加五分之一加七分之一，等等，一旦我们达到十五分之一，这个总和就变成了大于

119
00:08:29,520 --> 00:08:33,520
1。

120
00:08:33,520 --> 00:08:38,160
在我们收缩平台的背景下，从宽度为 1

121
00:08:38,160 --> 00:08:41,120
的平台开始，它现在收缩得如此之大，以至于它会完全消失。

122
00:08:41,680 --> 00:08:47,040
关键是，这是我们通过看似随机的过程定义的一系列函数，如果我要求您在输入 0

123
00:08:47,040 --> 00:08:50,800
处计算所有这些函数的值，您会得到一个最初看起来稳定的模式，它是1 1

124
00:08:50,800 --> 00:08:55,280
1 1

125
00:08:55,280 --> 00:09:00,000
1 1，但当我们进行第八次迭代时，它略有不足，只是勉强。

126
00:09:00,800 --> 00:09:05,440
这与我们之前看到的积分是类似的，而且我声称不仅仅是类似，我们在 pi pi pi

127
00:09:05,440 --> 00:09:10,160
pi pi 处有一个稳定的值，直到它几乎没有达到要求。

128
00:09:10,160 --> 00:09:15,440
碰巧的是，我们的移动平均过程中的这个比 1 略小的常数正是我们的积分系列中位于

129
00:09:15,440 --> 00:09:20,240
pi 前面的因子。

130
00:09:20,240 --> 00:09:24,720
因此，这两种情况不仅在性质上相似，而且在数量上也相同。

131
00:09:25,360 --> 00:09:29,840
当涉及到我们在积分内添加 x 项的

132
00:09:29,840 --> 00:09:33,040
2 余弦时，这会导致该模式在崩溃之前持续更长时间，在类比中，这将对应于相同的设置，但是其中我们开始的函数有一个更长的平台，从

133
00:09:33,040 --> 00:09:36,240
x 等于负

134
00:09:36,240 --> 00:09:39,120
1 延伸到

135
00:09:39,120 --> 00:09:43,200
1，这意味着它的长度是 2。

136
00:09:43,200 --> 00:09:46,960
因此，当您重复执行移动平均过程时，用越来越小的窗口来侵蚀它，它们需要更长的时间才能侵蚀整个平台。

137
00:09:46,960 --> 00:09:50,960


138
00:09:51,520 --> 00:09:55,920
更具体地说，相关的计算是问你需要多长时间将这些奇数的倒数相加，直到总和大于

139
00:09:55,920 --> 00:09:59,520
2？

140
00:09:59,520 --> 00:10:03,360
事实证明，你必须一直走到数字 113，这对应于积分模式一直持续到你达到

141
00:10:03,360 --> 00:10:08,400
113 的事实。

142
00:10:09,280 --> 00:10:12,400
顺便说一下，我要强调的是，这些奇数的倒数，1 个三分之一，1

143
00:10:12,400 --> 00:10:15,520
个五分之一，1 个七分之一，并没有什么特别的。

144
00:10:15,520 --> 00:10:19,440
这恰好是鲍温夫妇在论文中强调的价值观序列，这使得该序列在书呆子圈子中小有名气。

145
00:10:19,440 --> 00:10:22,240


146
00:10:22,240 --> 00:10:26,960
更一般地说，我们可以将任何正数序列插入到这些 sinc 函数中，只要这些数字的总和小于

147
00:10:26,960 --> 00:10:31,520
1，我们的表达式就等于 pi。

148
00:10:31,520 --> 00:10:35,440
但一旦它们变得大于 1，我们的表达式就会下降到略低于 pi。

149
00:10:35,440 --> 00:10:39,680
如果您相信我认为这些移动平均线有类比，您就有希望明白其中的原因。

150
00:10:40,240 --> 00:10:44,960
但当然，最紧迫的问题是这两种情况到底为什么有联系？

151
00:10:44,960 --> 00:10:46,240


152
00:10:46,240 --> 00:10:50,560
从这里开始，这个论证确实引入了两个稍微复杂的机制，即傅里叶变换和卷积。

153
00:10:50,560 --> 00:10:53,760


154
00:10:53,760 --> 00:10:57,760
我想要解决这个问题的方法是用这个视频的剩余部分让您对争论将如何进行有一个高层次的了解，而不必假设您熟悉这两个主题中的任何一个，然后解释为什么专用于卷积的视频中的细节是真实的。

155
00:10:57,760 --> 00:11:02,000


156
00:11:02,000 --> 00:11:06,160


157
00:11:06,160 --> 00:11:08,160


158
00:11:08,240 --> 00:11:12,320
特别是所谓的卷积定理，因为它非常美丽，而且它的用处远远超出了这个特定的、非常深奥的问题。

159
00:11:12,320 --> 00:11:16,240


160
00:11:19,600 --> 00:11:24,160
首先，我们不关注 x 除以 x

161
00:11:24,160 --> 00:11:28,800
的这个函数正弦值，我们想要展示为什么其曲线下方的有符号面积等于 pi，而是进行一个简单的替换，将输入 x

162
00:11:28,800 --> 00:11:33,760
替换为 pi 乘以 x

163
00:11:33,760 --> 00:11:38,560
，其效果是将图形水平压缩 pi 倍，因此面积缩小

164
00:11:38,560 --> 00:11:43,360
pi 倍，这意味着我们的新目标是展示为什么右侧的积分恰好等于 1。

165
00:11:43,360 --> 00:11:47,760
顺便说一句，在某些工程环境中，人们使用名称 sinc

166
00:11:47,760 --> 00:11:51,840
来指代内部带有 pi

167
00:11:51,840 --> 00:11:54,640
的函数，因为拥有标准化函数通常非常好，这意味着它下面的面积等于 1。

168
00:11:54,640 --> 00:11:57,680
关键是，在右侧显示这个积分与在左侧显示积分完全相同，只是变量的变化。

169
00:11:57,680 --> 00:12:00,400


170
00:12:00,480 --> 00:12:04,080
同样，对于我们序列中的所有其他积分，遍历它们中的每一个，将 x

171
00:12:04,080 --> 00:12:09,680
替换为

172
00:12:09,680 --> 00:12:14,240
pi 乘以

173
00:12:14,240 --> 00:12:16,160
x，从这里开始，所有这些积分不仅类似于移动平均示例，而且都其中有两种不同的方法来计算完全相同的事物。

174
00:12:16,160 --> 00:12:20,560
这种联系归结为这样一个事实：这个 sinc 函数，或者内部带有

175
00:12:20,560 --> 00:12:24,960
pi 的工程师 sinc

176
00:12:24,960 --> 00:12:26,320
函数，与使用所谓的傅里叶变换的 rect 函数相关。

177
00:12:26,320 --> 00:12:29,440
现在，如果您从未听说过傅里叶变换，您可以采取一些措施。

178
00:12:29,440 --> 00:12:32,560


179
00:12:32,560 --> 00:12:36,880
通常描述的方式是，如果您想将函数分解为一堆纯频率的总和，或者在无限函数的情况下，一堆纯频率的连续积分，傅里叶变换会告诉您所有这些组成部分的所有强度和阶段。

180
00:12:36,880 --> 00:12:41,040


181
00:12:41,040 --> 00:12:44,880


182
00:12:44,880 --> 00:12:46,960


183
00:12:46,960 --> 00:12:51,280
但你真正需要知道的是，它是一种接受一个函数并输出一个新函数的东西，你经常认为它是用另一种语言重新表述原始函数的信息，就像你是从一个新的角度来看待它。

184
00:12:51,280 --> 00:12:56,080


185
00:12:56,080 --> 00:12:59,760


186
00:12:59,760 --> 00:13:00,480


187
00:13:01,040 --> 00:13:05,200
例如，就像我说的，用这种新语言编写的 sinc

188
00:13:05,200 --> 00:13:08,880
函数在其中进行傅里叶变换，看起来就像我们的顶帽矩形函数。

189
00:13:08,880 --> 00:13:12,480
反之亦然，顺便说一下，对于关于 y

190
00:13:12,480 --> 00:13:15,760
轴对称的函数来说，傅里叶变换是一件好事，它是它自己的逆函数。

191
00:13:15,760 --> 00:13:20,080
实际上，我们需要展示的更普遍的事实是，当您转换 sinc

192
00:13:20,080 --> 00:13:23,840
函数的拉伸版本时，将其水平拉伸 k

193
00:13:23,840 --> 00:13:28,400
倍，您得到的是拉伸和压缩版本这个矩形函数。

194
00:13:28,400 --> 00:13:32,400
但当然，所有这些都只是毫无意义的词语和术语，除非你在翻译时确实能做点什么。

195
00:13:32,400 --> 00:13:34,880


196
00:13:34,880 --> 00:13:39,760
为什么傅里叶变换对数学如此有用，其背后的真正想法是，当您对特定函数进行陈述和问题时，然后查看它们相对于该函数的变换版本的对应内容，这些陈述和在这种新语言中，问题通常看起来非常非常不同。

197
00:13:39,760 --> 00:13:43,840


198
00:13:43,840 --> 00:13:48,240


199
00:13:48,240 --> 00:13:51,840


200
00:13:51,840 --> 00:13:54,880
有时它会让问题更容易回答。

201
00:13:55,440 --> 00:13:59,840
例如，一个非常好的小事实，我们要展示的事情列表中的另一件事是，如果您想计算某个函数从负无穷大到无穷大的积分，则整个曲线下的这个带符号区域是相同的就像简单地评估该函数在输入零处的傅里叶变换版本一样。

202
00:13:59,840 --> 00:14:04,000


203
00:14:04,000 --> 00:14:09,760


204
00:14:09,760 --> 00:14:13,360


205
00:14:13,920 --> 00:14:17,200
这是一个实际上会直接从定义中跳出来的事实。

206
00:14:17,200 --> 00:14:22,160
它代表了一种更普遍的氛围，即右侧傅里叶变换函数的每个单独输出都对应于左侧原始函数的某种全局信息。

207
00:14:22,160 --> 00:14:26,640


208
00:14:26,640 --> 00:14:28,560


209
00:14:28,560 --> 00:14:33,520
在我们的具体情况下，这意味着如果你相信我这个 sinc

210
00:14:33,520 --> 00:14:37,840
函数和 rect

211
00:14:37,840 --> 00:14:41,760
函数与这样的傅立叶变换相关，它解释了积分，否则计算起来非常棘手，因为它说的是所有有符号区域与评估 rect

212
00:14:41,760 --> 00:14:45,040
为零相同，后者只是一。

213
00:14:45,440 --> 00:14:48,480
现在，你可以抱怨，这肯定只是把问题隐藏起来。

214
00:14:48,480 --> 00:14:52,960
当然，计算这个傅立叶变换，无论看起来是什么样子，都会像计算原始积分一样困难。

215
00:14:52,960 --> 00:14:54,160


216
00:14:54,160 --> 00:14:58,480
但我们的想法是，计算这些傅里叶变换有很多提示和技巧。

217
00:14:58,480 --> 00:15:03,040
此外，当你这样做时，它会告诉你比积分更多的信息。

218
00:15:03,040 --> 00:15:05,680
通过计算你可以得到很多好处。

219
00:15:06,320 --> 00:15:10,160
现在，另一个能够解释我们正在寻找的联系的关键事实是，如果你有两个不同的函数并且你取它们的乘积，然后你取该乘积的傅立叶变换的总和，那么这将是相同的事情就好像您单独对原始函数进行傅里叶变换，然后使用一种新的运算将它们组合起来，我们将在下一个视频中讨论这种运算，称为卷积。

220
00:15:10,160 --> 00:15:14,880


221
00:15:14,880 --> 00:15:19,440


222
00:15:19,440 --> 00:15:23,600


223
00:15:23,600 --> 00:15:28,240


224
00:15:28,240 --> 00:15:32,000
现在，尽管卷积有很多需要解释的地方，但结果是，在我们使用这些矩形函数的特定情况下，采用卷积看起来就像我们一直在讨论的移动平均线之一，结合起来根据我们之前的事实，在一个上下文中积分看起来就像在另一个上下文中求值为零，如果你相信我，在一个上下文中的乘法对应于这个新操作，即卷积，对于我们的示例，您应该将其视为移动平均值，即将解释为什么可以根据这些渐进移动平均线来考虑将越来越多的这些

225
00:15:32,000 --> 00:15:37,680


226
00:15:37,680 --> 00:15:41,600


227
00:15:41,600 --> 00:15:46,080
sinc

228
00:15:46,080 --> 00:15:51,360


229
00:15:51,360 --> 00:15:55,280


230
00:15:55,280 --> 00:16:00,240
函数相乘，并始终评估为零，这反过来又给出了一个非常可爱的直觉，说明为什么您会在最终出现问题之前期望如此稳定的值随着高原边缘越来越接近中心而下降。

231
00:16:00,240 --> 00:16:04,960


232
00:16:04,960 --> 00:16:09,280


233
00:16:09,280 --> 00:16:13,440


234
00:16:13,440 --> 00:16:18,720
顺便说一句，最后一个关键事实有一个特殊的名称，称为卷积定理，我们将再次更深入地讨论它。

235
00:16:18,720 --> 00:16:23,680
我认识到，通过列出三个神奇的事实并说一切都由此而来来结束事情可能有点令人不满意，但希望这能让您稍微了解为什么像傅立叶变换这样的强大工具对于棘手的问题如此有用。

236
00:16:23,680 --> 00:16:28,560


237
00:16:28,560 --> 00:16:33,200


238
00:16:33,200 --> 00:16:39,280
这是一种提供视角转变的系统方法，使困难问题有时看起来更容易。

239
00:16:39,280 --> 00:16:44,560
如果不出意外的话，它希望能提供一些学习卷积定理等美丽事物的动力。

240
00:16:44,560 --> 00:16:48,400


241
00:16:48,400 --> 00:16:53,920
作为另一个小预告，这个卷积定理的另一个有趣的结果是，它为一种算法打开了大门，让你可以非常快速地计算两个大数的乘积，比你想象的要快得多。

242
00:16:53,920 --> 00:16:58,480


243
00:16:58,480 --> 00:17:01,840


244
00:17:02,800 --> 00:17:05,840
那么，我们将在下一个视频中见到您。

