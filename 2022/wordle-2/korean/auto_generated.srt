1
00:00:00,000 --> 00:00:01,777
지난 주에 저는 정보 이론을 사용하여 

2
00:00:01,777 --> 00:00:03,470
Wordle 게임을 해결하는 방법, 

3
00:00:03,470 --> 00:00:05,587
또는 적어도 해결해 보는 방법에 대한 영상을 

4
00:00:05,587 --> 00:00:06,180
올렸습니다. 

5
00:00:06,580 --> 00:00:08,500
그리고 저는 이것을 간단히 덧붙이고 싶었습니다. 

6
00:00:08,500 --> 00:00:09,780
이것을 부록이라 불러야 할까요? 

7
00:00:10,080 --> 00:00:10,660
고백? 

8
00:00:11,020 --> 00:00:12,498
기본적으로 저는 단지 제가 실수한 

9
00:00:12,498 --> 00:00:13,900
부분을 설명하고 싶을 뿐입니다. 

10
00:00:14,460 --> 00:00:17,063
Wordle을 다시 만들고 모든 알고리즘을 실행하여 

11
00:00:17,063 --> 00:00:19,396
문제를 해결하고 성능을 테스트하기 위해 실행한 

12
00:00:19,396 --> 00:00:22,000
코드에 아주 작은 버그가 있는 것으로 나타났습니다. 

13
00:00:22,600 --> 00:00:25,295
그리고 이는 매우 적은 비율의 사례에 영향을 미치는 

14
00:00:25,295 --> 00:00:27,804
버그 중 하나이므로 놓치기 쉬웠고 대부분의 경우 

15
00:00:27,804 --> 00:00:30,500
실제로 중요하지 않은 아주 작은 영향만 미쳤습니다. 

16
00:00:31,220 --> 00:00:33,881
기본적으로 이는 여러 개의 서로 다른 문자가 포함된 

17
00:00:33,881 --> 00:00:36,360
추측에 색상을 할당하는 방법과 관련이 있습니다. 

18
00:00:36,520 --> 00:00:38,357
예를 들어, 속도를 추측했는데 정답이 

19
00:00:38,357 --> 00:00:40,107
'준수'라면 추측에서 

20
00:00:40,107 --> 00:00:42,120
나온 두 e에 어떤 색을 칠해야 할까요? 

21
00:00:43,060 --> 00:00:45,126
Wordle 규칙에 따라 작동하는 방식은 

22
00:00:45,126 --> 00:00:47,013
첫 번째 e가 노란색으로 표시되고 두 

23
00:00:47,013 --> 00:00:49,080
번째 e가 회색으로 표시된다는 것입니다. 

24
00:00:49,600 --> 00:00:51,655
당신은 그 첫 번째 것이 참 답의 어떤 것과 

25
00:00:51,655 --> 00:00:53,300
일치하는 것으로 생각할 수도 있고, 

26
00:00:53,300 --> 00:00:55,520
회색조는 두 번째 e가 없다는 것을 의미합니다. 

27
00:00:55,520 --> 00:00:59,273
대조적으로, 대답이 지우기와 같은 것이라면 두 e는 

28
00:00:59,273 --> 00:01:03,026
모두 노란색으로 표시되어 첫 번째 e가 다른 위치에 

29
00:01:03,026 --> 00:01:06,780
있고 두 번째 e도 다른 위치에 있음을 나타냅니다. 

30
00:01:07,300 --> 00:01:10,289
마찬가지로 e 중 하나가 히트하고 녹색인 

31
00:01:10,289 --> 00:01:13,280
경우 실제 답에 두 번째 e가 없는 경우 

32
00:01:13,280 --> 00:01:16,400
두 번째 e는 회색이 되지만 두 번째 e가 

33
00:01:16,400 --> 00:01:20,040
있고 다른 위치에 있는 경우에는 노란색이 됩니다. 

34
00:01:20,700 --> 00:01:24,924
위치. 간단히 말해서, 어딘가에서 실수로 

35
00:01:24,924 --> 00:01:29,700
이러한 규칙과 약간 다른 동작을 도입했습니다. 

36
00:01:29,700 --> 00:01:30,140
솔직히 정말 멍청했어요. 

37
00:01:30,140 --> 00:01:32,706
기본적으로 프로젝트 중간 어느 시점에서 나는 일부 

38
00:01:32,706 --> 00:01:35,365
계산 속도를 높이고 싶었고 주어진 단어 쌍 사이에서 

39
00:01:35,365 --> 00:01:38,023
이 패턴의 값을 계산하는 방법에 대한 약간의 트릭을 

40
00:01:38,023 --> 00:01:40,498
시도하고 있었지만 방금 그렇게 하지 않았습니다. 

41
00:01:40,498 --> 00:01:43,248
실제로 깊이 생각하지 않고 약간의 변화를 도입했습니다.

42
00:01:43,248 --> 00:01:43,340
 

43
00:01:43,340 --> 00:01:45,804
아이러니한 부분은 결국 작업을 가장 빠르게 만드는 

44
00:01:45,804 --> 00:01:48,269
실제 방법은 모든 패턴을 미리 계산하여 모든 것이 

45
00:01:48,269 --> 00:01:50,558
조회일 뿐이므로 각 작업을 수행하는 데 시간이 

46
00:01:50,558 --> 00:01:52,759
얼마나 걸리는지는 중요하지 않다는 것입니다. 

47
00:01:52,759 --> 00:01:55,311
특히 버그가 있는 코드를 읽기 위해 열심히 작성하고 

48
00:01:55,311 --> 00:01:55,840
있습니다. 

49
00:01:56,400 --> 00:01:57,240
아시다시피, 당신은 살고 배웁니다. 

50
00:01:58,040 --> 00:02:00,190
이것이 실제 비디오에 어떤 영향을 미치는지에 관해서는 

51
00:02:00,190 --> 00:02:02,340
실제로 변경되는 내용이 거의 없다는 것을 의미합니다. 

52
00:02:02,660 --> 00:02:04,306
물론 정보가 무엇인지, 엔트로피가 

53
00:02:04,306 --> 00:02:06,560
무엇인지에 대한 주요 교훈은 모두 동일합니다. 

54
00:02:06,860 --> 00:02:09,912
때때로 특정 단어와 관련된 일부 분포를 

55
00:02:09,912 --> 00:02:13,243
화면에 표시하는 경우 다양한 패턴과 관련된 

56
00:02:13,243 --> 00:02:16,850
일부 버킷에는 실제 답변이 더 많거나 적으므로 

57
00:02:16,850 --> 00:02:20,320
해당 분포가 실제로 약간 다를 수 있습니다. 

58
00:02:20,840 --> 00:02:22,961
그럼에도 불구하고 이 극단적인 경우에 부딪히는 

59
00:02:22,961 --> 00:02:25,083
여러 글자가 있는 단어를 표시하는 경우는 매우 

60
00:02:25,083 --> 00:02:26,960
드물기 때문에 실제로 나타나지 않습니다. 

61
00:02:27,680 --> 00:02:30,495
그러나 변하는 몇 안 되는 본질적인 것 중 

62
00:02:30,495 --> 00:02:33,427
하나는 틀림없이 상당히 중요한 것 중 하나는 

63
00:02:33,427 --> 00:02:36,360
단어 답변 목록에 대해 가능한 최적의 점수를 

64
00:02:36,360 --> 00:02:39,410
찾고자 하는 경우 그러한 알고리즘이 어떤 시작 

65
00:02:39,410 --> 00:02:42,460
추측을 사용하는지에 대한 최종 결론이었습니다. 

66
00:02:43,080 --> 00:02:45,310
비디오에서 나는 내가 찾을 수 있는 최고의 

67
00:02:45,310 --> 00:02:47,541
성능은 크레인이라는 단어로 시작하는 것에서 

68
00:02:47,541 --> 00:02:49,957
나왔다고 말했는데, 이는 알고리즘이 아주 약간 

69
00:02:49,957 --> 00:02:52,560
다른 게임을 하고 있다는 점에서만 사실이었습니다. 

70
00:02:53,160 --> 00:02:55,462
문제를 수정하고 모두 다시 실행한 후에는 이 

71
00:02:55,462 --> 00:02:57,765
특정 목록에 대한 이론적으로 최적의 첫 번째 

72
00:02:57,765 --> 00:03:00,160
추측이 무엇인지에 대한 다른 대답이 있습니다. 

73
00:03:01,000 --> 00:03:03,738
그리고 보세요, 이 비디오의 요점이 임의의 

74
00:03:03,738 --> 00:03:06,476
온라인 게임에 대한 기술적으로 최적의 답을 

75
00:03:06,476 --> 00:03:09,100
찾는 것이 아니라는 것을 알고 있습니다. 

76
00:03:09,460 --> 00:03:12,465
영상의 요점은 뻔뻔하게도 인터넷 트렌드에 편승하여 

77
00:03:12,465 --> 00:03:15,256
정보 이론 수업을 통해 사람들을 몰래 공격하는 

78
00:03:15,256 --> 00:03:15,900
것입니다. 

79
00:03:16,320 --> 00:03:17,185
그리고 그것은 모두 좋습니다. 

80
00:03:17,185 --> 00:03:18,000
나는 그 부분을 지지합니다. 

81
00:03:18,200 --> 00:03:20,200
하지만 저는 인터넷이 어떻게 작동하는지 알고 있으며, 

82
00:03:20,200 --> 00:03:21,799
많은 사람들이 가장 중요하게 생각하는 점은 

83
00:03:21,799 --> 00:03:23,800
게임 단어를 위한 최고의 시작 방법이 무엇인지였습니다.

84
00:03:23,800 --> 00:03:24,600
 그리고 알겠습니다. 

85
00:03:25,280 --> 00:03:27,304
미리보기 이미지에 넣었기 때문에 그 부분에 

86
00:03:27,304 --> 00:03:29,582
들어갔습니다. 하지만 여기에 약간의 수정 사항을 

87
00:03:29,582 --> 00:03:31,860
추가하고 싶다면 용서해 주실 수 있을 것입니다. 

88
00:03:31,980 --> 00:03:33,976
그리고 실제로 이 모든 것을 다시 언급해야 하는 

89
00:03:33,976 --> 00:03:35,899
더 의미 있는 이유는 제가 최종 분석에 무엇이 

90
00:03:35,899 --> 00:03:37,896
포함되었는지에 대해 실제로 이야기한 적이 없다는 

91
00:03:37,896 --> 00:03:38,340
것입니다. 

92
00:03:38,840 --> 00:03:40,520
그리고 그것은 그 자체로 하위 레슨으로서 

93
00:03:40,520 --> 00:03:42,420
흥미롭기 때문에 여기서 해볼 가치가 있습니다. 

94
00:03:43,140 --> 00:03:45,990
기억하시겠지만, 지난 비디오의 대부분의 시간은 

95
00:03:45,990 --> 00:03:49,170
가능한 모든 답의 공식 목록을 사용하지 않은 단어를 

96
00:03:49,170 --> 00:03:52,460
해결하기 위한 알고리즘을 작성하는 데 소비되었습니다. 

97
00:03:52,980 --> 00:03:54,754
내 취향에는 테스트 세트에 과적합된 

98
00:03:54,754 --> 00:03:56,528
것 같은 느낌이 들며, 더 재미있는 

99
00:03:56,528 --> 00:03:58,480
것은 탄력적인 것을 구축하는 것입니다. 

100
00:03:58,900 --> 00:04:01,895
이것이 우리가 영어의 상대적인 단어 빈도를 

101
00:04:01,895 --> 00:04:04,890
살펴보는 전체 과정을 거쳐 각 단어가 최종 

102
00:04:04,890 --> 00:04:08,635
답변에 포함될 가능성에 대한 개념을 찾아낸 이유입니다.

103
00:04:08,635 --> 00:04:08,760
 

104
00:04:09,400 --> 00:04:12,141
그러나 우리가 여기서 하고 있는 일, 

105
00:04:12,141 --> 00:04:15,014
즉 절대적인 최고 성능 기간을 찾으려는 

106
00:04:15,014 --> 00:04:18,017
경우에는 공식 목록을 통합하고 뻔뻔스럽게 

107
00:04:18,017 --> 00:04:20,759
테스트 세트에 과대적합하고 있습니다. 

108
00:04:20,759 --> 00:04:23,893
포함 여부에 따라 각 항목에 균일한 확률을 

109
00:04:23,893 --> 00:04:25,460
할당할 수 있습니다. 

110
00:04:26,440 --> 00:04:28,827
기억하신다면, 이 모든 것의 첫 번째 단계는 

111
00:04:28,827 --> 00:04:31,310
특정한 시작 추측, 아마도 제가 가장 좋아하는 

112
00:04:31,310 --> 00:04:33,601
크레인과 같은 것에 대해 가능한 각 패턴을 

113
00:04:33,601 --> 00:04:36,180
볼 가능성이 얼마나 되는지 말하는 것이었습니다. 

114
00:04:36,680 --> 00:04:38,891
그리고 우리가 단어 답변 목록에 뻔뻔스럽게 

115
00:04:38,891 --> 00:04:41,010
과대적합하는 이러한 맥락에서 관련된 모든 

116
00:04:41,010 --> 00:04:43,221
것은 이러한 패턴 각각에 대해 가능한 답변 

117
00:04:43,221 --> 00:04:45,340
중 얼마나 많은 수를 계산하는 것입니다. 

118
00:04:45,980 --> 00:04:48,861
그리고 물론 우리 시간의 대부분은 기본적으로 

119
00:04:48,861 --> 00:04:51,857
각 버킷을 통과하여 얻을 수 있는 정보의 양을 

120
00:04:51,857 --> 00:04:54,854
말하는 이 추측에서 얻을 수 있는 정보의 양을 

121
00:04:54,854 --> 00:04:57,735
정량화하기 위해 이런 종류의 재미있어 보이는 

122
00:04:57,735 --> 00:05:00,731
공식에 소비되었습니다. 주어진 패턴을 관찰하면 

123
00:05:00,731 --> 00:05:03,382
가능성의 공간을 몇 번이나 절반으로 줄일 

124
00:05:03,382 --> 00:05:06,840
것인지를 표현하는 기발한 방법인 이 로그 표현입니다. 

125
00:05:07,600 --> 00:05:10,297
우리는 이들 모두의 가중 평균을 취하여 이 첫 번째 

126
00:05:10,297 --> 00:05:13,087
추측에서 얼마나 많은 것을 배울 수 있을지 측정합니다.

127
00:05:13,087 --> 00:05:13,180
 

128
00:05:13,560 --> 00:05:16,990
잠시 후에 우리는 이것보다 더 깊이 들어갈 것입니다. 

129
00:05:16,990 --> 00:05:20,306
그러나 시작할 수 있는 13,000개의 다른 단어를 

130
00:05:20,306 --> 00:05:23,394
모두 검색하고 어떤 단어가 가장 기대되는 정보를 

131
00:05:23,394 --> 00:05:26,253
가지고 있는지 묻는다면 가능한 최선의 대답은 

132
00:05:26,253 --> 00:05:29,569
솟아오르는 것입니다. 실제로는 실제 단어처럼 보이지 

133
00:05:29,569 --> 00:05:33,000
않지만 아기 매를 지칭하는 구식 용어인 것 같습니다. 

134
00:05:34,040 --> 00:05:37,385
이 지표에 따른 상위 15개 오프너는 다음과 같이 

135
00:05:37,385 --> 00:05:40,730
보이지만 실제 점수가 무엇인지 추정하기 위해 예상 

136
00:05:40,730 --> 00:05:43,955
정보의 휴리스틱을 사용하여 한 단계만 보고 있기 

137
00:05:43,955 --> 00:05:47,540
때문에 이것이 반드시 최고의 오프닝 추측은 아닙니다. 

138
00:05:47,920 --> 00:05:49,800
하지만 두 단계로 철저한 검색을 수행할 

139
00:05:49,800 --> 00:05:51,680
수 있을 만큼 충분한 패턴이 없습니다. 

140
00:05:52,160 --> 00:05:55,040
예를 들어, soar로 열었고 우연히 발견한 패턴이 

141
00:05:55,040 --> 00:05:58,019
가장 가능성이 높은 패턴인 모두 회색이었다고 가정하고 

142
00:05:58,019 --> 00:06:00,800
해당 지점에서 동일한 분석을 실행할 수 있습니다. 

143
00:06:01,320 --> 00:06:04,285
Kitty와 같이 제안된 두 번째 추측에 대해, 

144
00:06:04,285 --> 00:06:07,141
soar에 대한 모든 회색을 생성하는 단어로만 

145
00:06:07,141 --> 00:06:10,106
제한되는 제한된 경우의 모든 패턴에 대한 분포는 

146
00:06:10,106 --> 00:06:13,182
무엇입니까? 그런 다음 예상되는 이 값을 사용하여 

147
00:06:13,182 --> 00:06:15,269
해당 분포의 평탄도를 측정합니다. 

148
00:06:15,269 --> 00:06:18,344
두 번째 추측으로 사용할 수 있는 13,000개의 

149
00:06:18,344 --> 00:06:21,420
가능한 단어 모두에 대해 정보 공식을 적용합니다. 

150
00:06:22,120 --> 00:06:24,811
이를 통해 우리는 해당 시나리오에서 최적의 두 

151
00:06:24,811 --> 00:06:27,709
번째 추측과 그로부터 얻을 것으로 예상되는 정보의 

152
00:06:27,709 --> 00:06:30,608
양을 찾을 수 있습니다. 그리고 볼 수 있는 모든 

153
00:06:30,608 --> 00:06:33,299
가능한 패턴에 대해 헹구고 반복하여 이 작업을 

154
00:06:33,299 --> 00:06:36,198
수행하면 다음을 얻습니다. 가능한 최선의 두 번째 

155
00:06:36,198 --> 00:06:39,200
추측이 모두 포함된 전체 지도와 각각의 예상 정보. 

156
00:06:43,180 --> 00:06:46,618
거기에서 모든 두 번째 단계 값의 가중 평균을 

157
00:06:46,618 --> 00:06:50,188
취하고 해당 버킷에 빠질 가능성에 따라 가중치를 

158
00:06:50,188 --> 00:06:53,229
적용하면 추측이 치솟은 후 얻을 수 있는 

159
00:06:53,229 --> 00:06:56,800
정보의 양을 측정할 수 있습니다. 두번째 단계. 

160
00:06:57,380 --> 00:06:59,580
이 2단계 측정항목을 순위를 정하는 새로운 

161
00:06:59,580 --> 00:07:01,780
수단으로 사용하면 목록이 약간 흔들립니다. 

162
00:07:02,080 --> 00:07:04,770
Soar는 더 이상 1위가 아니며 14위로 다시 

163
00:07:04,770 --> 00:07:07,660
떨어지며, 대신 정상에 오른 것은 죽임을 당합니다. 

164
00:07:08,640 --> 00:07:11,493
다시 말하지만, 그다지 현실감이 없으며 

165
00:07:11,493 --> 00:07:14,476
잔디를 자르는 데 사용되는 삽을 가리키는 

166
00:07:14,476 --> 00:07:17,200
영국 용어인 것 같습니다. 좋습니다. 

167
00:07:17,200 --> 00:07:19,892
하지만 보시다시피 이 두 단계 후에 누가 가장 많은 

168
00:07:19,892 --> 00:07:22,400
정보를 얻을 수 있는지에 대한 모든 최고 경쟁자 

169
00:07:22,400 --> 00:07:25,000
사이에서는 정말 치열한 경쟁이 벌어지고 있습니다. 

170
00:07:25,700 --> 00:07:28,374
그럼에도 불구하고 이것이 반드시 최선의 시작 추측은 

171
00:07:28,374 --> 00:07:30,864
아닙니다. 정보는 경험적일 뿐이고 실제로 게임을 

172
00:07:30,864 --> 00:07:33,354
플레이할 경우 실제 점수를 알려주는 것은 아니기 

173
00:07:33,354 --> 00:07:34,000
때문입니다. 

174
00:07:34,580 --> 00:07:38,046
내가 한 일은 이 목록의 상위 250개에 대한 모든 

175
00:07:38,046 --> 00:07:41,512
가능한 답을 가지고 2315개의 가능한 단어 게임을 

176
00:07:41,512 --> 00:07:44,620
모두 플레이하는 시뮬레이션을 실행한 것입니다. 

177
00:07:46,460 --> 00:07:50,911
그리고 이렇게 함으로써, 그들이 실제로 어떻게 

178
00:07:50,911 --> 00:07:55,363
수행하는지를 보면, 가능한 최고의 점수로 아주 

179
00:07:55,363 --> 00:07:59,815
미미하게 끝나는 것은 Salé로 밝혀졌습니다. 

180
00:07:59,815 --> 00:08:04,438
이는 가벼운 중세 헬멧인 Salé의 대체 철자인 

181
00:08:04,438 --> 00:08:05,980
Salé입니다. 

182
00:08:06,980 --> 00:08:09,924
좋아요, 저처럼 그것이 여러분에게 너무 가짜라고 

183
00:08:09,924 --> 00:08:12,978
느껴지신다면 Trace와 Crate가 거의 동일한 

184
00:08:12,978 --> 00:08:16,250
성능을 제공한다는 사실을 알게 되어 기뻐하실 것입니다.

185
00:08:16,250 --> 00:08:16,360
 

186
00:08:16,360 --> 00:08:19,110
각각은 분명히 실제 단어라는 이점이 있으므로 

187
00:08:19,110 --> 00:08:21,750
둘 다 실제 단어 답변이기 때문에 첫 번째 

188
00:08:21,750 --> 00:08:24,060
추측에서 정답을 얻을 날이 있습니다. 

189
00:08:25,020 --> 00:08:27,468
최고의 2단계 엔트로피를 기반으로 한 정렬에서 

190
00:08:27,468 --> 00:08:29,823
가장 낮은 평균 점수를 기반으로 한 정렬로의 

191
00:08:29,823 --> 00:08:32,460
이동도 목록을 뒤흔들지만 그다지 많지는 않습니다. 

192
00:08:32,659 --> 00:08:34,901
예를 들어, Salé는 상위권에 오르기 

193
00:08:34,901 --> 00:08:36,838
전 이전에 3위였으며 Crate와 

194
00:08:36,838 --> 00:08:39,080
Trace는 모두 4위와 5위였습니다. 

195
00:08:39,640 --> 00:08:41,480
궁금하다면 여기에서 약간의 무차별 대입을 

196
00:08:41,480 --> 00:08:43,720
수행하여 약간 더 나은 성능을 얻을 수 있습니다. 

197
00:08:44,100 --> 00:08:46,490
Jonathan Olson이 작성한 매우 멋진 

198
00:08:46,490 --> 00:08:48,696
블로그 게시물이 있습니다. 여기에서 최적의 

199
00:08:48,696 --> 00:08:51,086
알고리즘을 기반으로 몇 가지 시작 단어에 대한 

200
00:08:51,086 --> 00:08:53,660
최적의 다음 추측이 무엇인지 탐색할 수 있습니다. 

201
00:08:55,180 --> 00:08:56,894
하지만 이 모든 것에서 물러나서, 

202
00:08:56,894 --> 00:08:59,240
일부 사람들은 게임을 이렇게 과도하게 분석하고 

203
00:08:59,240 --> 00:09:01,857
최적의 오프닝 추측을 찾으려고 노력하는 것이 게임을 

204
00:09:01,857 --> 00:09:02,940
망친다고 말했습니다. 

205
00:09:02,940 --> 00:09:05,107
아시다시피, 학습한 후 시작 추측을 

206
00:09:05,107 --> 00:09:07,167
사용하면 좀 더러운 느낌이 들고, 

207
00:09:07,167 --> 00:09:09,660
그렇지 않으면 비효율적인 느낌이 듭니다. 

208
00:09:09,800 --> 00:09:11,832
하지만 문제는 이것이 인간이 게임을 플레이하기 

209
00:09:11,832 --> 00:09:14,100
위한 최고의 오프너라고 생각하지 않는다는 것입니다. 

210
00:09:14,100 --> 00:09:16,763
우선, 표시된 각 패턴에 대한 최적의 

211
00:09:16,763 --> 00:09:19,680
두 번째 추측이 무엇인지 알아야 합니다. 

212
00:09:20,260 --> 00:09:23,361
그리고 더 중요한 것은 이 모든 것이 공식 단어 답변 

213
00:09:23,361 --> 00:09:26,360
목록에 터무니없이 과적합된 환경에 있다는 것입니다. 

214
00:09:26,580 --> 00:09:28,560
예를 들어 New York Times가 

215
00:09:28,560 --> 00:09:30,720
그 목록의 내용을 변경하기로 결정하는 순간 

216
00:09:30,720 --> 00:09:32,880
이 모든 것이 창 밖으로 사라질 것입니다. 

217
00:09:33,580 --> 00:09:35,671
우리 인간이 게임을 플레이하는 방식은 이러한 

218
00:09:35,671 --> 00:09:37,680
알고리즘이 수행하는 방식과 매우 다릅니다. 

219
00:09:38,020 --> 00:09:40,214
우리는 단어 목록을 기억하지 않고 철저한 

220
00:09:40,214 --> 00:09:42,408
검색을 수행하지 않으며 모음이 무엇인지, 

221
00:09:42,408 --> 00:09:45,080
모음이 어떻게 배치되는지와 같은 직관을 얻습니다. 

222
00:09:45,640 --> 00:09:48,351
이 비디오를 시청하는 분들이 기술적으로 가장 

223
00:09:48,351 --> 00:09:51,062
좋은 오프닝 추측이 무엇인지 즉시 잊어버리고 

224
00:09:51,062 --> 00:09:53,773
대신 정보를 수량화하는 방법이나 욕심이 많을 

225
00:09:53,773 --> 00:09:56,484
때 조심해야 하는 사실 등을 기억해 주신다면 

226
00:09:56,484 --> 00:09:59,412
실제로 가장 기쁠 것입니다. 알고리즘은 더 깊은 

227
00:09:59,412 --> 00:10:02,015
검색에서 얻을 수 있는 세계 최고의 성능에 

228
00:10:02,015 --> 00:10:03,100
미치지 못합니다. 

229
00:10:03,700 --> 00:10:05,776
적어도 내 취향에 따르면, 게임을 하기 위해 

230
00:10:05,776 --> 00:10:08,185
알고리즘을 작성하는 즐거움은 실제로 내가 인간으로서 

231
00:10:08,185 --> 00:10:10,676
그 게임을 즐기는 방식에 거의 영향을 미치지 않습니다.

232
00:10:10,676 --> 00:10:10,760
 

233
00:10:11,300 --> 00:10:13,126
이 모든 것에 대한 알고리즘을 작성하는 목적은 

234
00:10:13,126 --> 00:10:14,953
우리가 게임을 하는 방식에 영향을 미치는 것이 

235
00:10:14,953 --> 00:10:16,780
아니라 여전히 재미있는 단어 게임일 뿐입니다. 

236
00:10:17,100 --> 00:10:19,054
다른 곳에서 보다 의미 있는 맥락에서 알고리즘을 

237
00:10:19,054 --> 00:10:20,720
작성하기 위해 근육을 단련하는 것입니다. 

