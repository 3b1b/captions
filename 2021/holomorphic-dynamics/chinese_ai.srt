1
00:00:00,000 --> 00:00:04,240
今天我想告诉你们一个叫做全纯动力学的数学知识。

2
00:00:04,240 --> 00:00:08,000
这是研究曼德尔布罗特集等事物的领域，事实上，我今天的主要目标之一是向您展示这个标志性的形状，数学的典型代表，如何以比最初的定义所暗示的更普遍的方式出现。

3
00:00:08,000 --> 00:00:12,720


4
00:00:12,720 --> 00:00:16,480


5
00:00:17,200 --> 00:00:21,200
现在，这个领域也与我们在上一个视频中讨论的牛顿分形密切相关，我们在本视频结束时的另一个目标将是帮助解决我们在那里遇到的一些松散的问题。

6
00:00:21,200 --> 00:00:25,200


7
00:00:25,200 --> 00:00:27,840


8
00:00:30,000 --> 00:00:39,200
首先，全纯这个词可能看起来有点奇怪。 它指的是具有复数输入和复数输出的函数，您也可以对其求导。

9
00:00:39,200 --> 00:00:44,480


10
00:00:45,040 --> 00:00:49,280
基本上，在这种情况下导数的含义是，当您放大函数在给定点附近、该点及其邻居的行为方式时，它看起来大致就像缩放和旋转，就像乘以某个复杂的常数。

11
00:00:49,280 --> 00:00:54,720


12
00:00:54,720 --> 00:00:59,520
我们稍后会详细讨论这一点，但现在知道它包括您可以写下的大多数普通函数，例如多项式、指数、三角函数等等。

13
00:00:59,600 --> 00:01:03,520


14
00:01:03,520 --> 00:01:06,560


15
00:01:07,280 --> 00:01:12,400
这里标题中的相关动态来自于询问当您一遍又一遍地重复应用这些函数之一时会发生什么，即评估某些输入，然后评估您刚刚得到的相同函数，然后再次执行此操作，一次又一次。

16
00:01:12,400 --> 00:01:17,440


17
00:01:17,440 --> 00:01:20,480


18
00:01:21,440 --> 00:01:25,200


19
00:01:26,000 --> 00:01:29,360
有时由此产生的点的模式会陷入循环。

20
00:01:30,400 --> 00:01:33,840
其他时候，序列只会接近某种极限点。

21
00:01:35,040 --> 00:01:39,040
或者，序列可能会变得越来越大，最终飞向无穷远，数学家也认为这接近极限点，即无穷远点。

22
00:01:39,040 --> 00:01:42,640


23
00:01:42,640 --> 00:01:48,080
而有时，它们却完全没有模式，行为也很混乱。

24
00:01:49,840 --> 00:01:53,600
令人惊讶的是，对于您可能写下的各种函数，当您尝试做一些事情来可视化这些不同的可能行为出现时，它通常会导致一些极其复杂的分形图案。

25
00:01:54,160 --> 00:01:58,880


26
00:01:58,880 --> 00:02:02,160


27
00:02:03,280 --> 00:02:07,200
看过上一个视频的人已经看到了一个很好的例子。

28
00:02:07,200 --> 00:02:11,760
有一种称为牛顿法的算法，它找到某个多项式 p 的根，其工作方式基本上是重复迭代表达式 x 减去

29
00:02:11,760 --> 00:02:15,120
x 的 p 除以 x

30
00:02:15,120 --> 00:02:19,120
的 p 素数，p 素数是导数。

31
00:02:19,920 --> 00:02:24,080
当您的初始种子值位于该多项式的根的松散附近（x 的 p

32
00:02:24,080 --> 00:02:29,200
等于 0 的值）时，此过程会生成一个真正快速收敛到该根的值序列。

33
00:02:29,200 --> 00:02:34,000
这使得它成为实践中有用的算法。 但随后我们尝试在复平面中执行此操作，查看许多可能的种子值并询问这些种子值中的每一个最终可能位于复平面中的哪个根上。

34
00:02:34,000 --> 00:02:39,600


35
00:02:39,600 --> 00:02:44,720
然后，我们将一种颜色与每个根相关联，然后根据从该像素开始的种子值最终落在哪个根上，对平面的每个像素进行着色。

36
00:02:44,720 --> 00:02:50,000


37
00:02:50,000 --> 00:02:55,680
我们得到的结果是一些极其复杂的图片，颜色之间有粗糙的分形边界。

38
00:02:55,680 --> 00:02:59,200


39
00:03:02,240 --> 00:03:05,760
现在，在这个示例中，如果您查看我们实际迭代的函数，例如多项式的某些特定选择，例如

40
00:03:05,760 --> 00:03:09,840
z

41
00:03:09,840 --> 00:03:14,000
立方减一，您可以重写整个表达式，使其看起来像一个多项式除以另一个多项式。

42
00:03:14,800 --> 00:03:19,600
数学家将这类函数称为有理函数。 如果您忘记了这是由牛顿方法产生的事实，您可以合理地问当您迭代任何其他有理函数时会发生什么。

43
00:03:19,600 --> 00:03:24,240


44
00:03:24,240 --> 00:03:29,120
事实上，这正是数学家皮埃尔·法图和加斯顿·朱莉娅在第一次世界大战后几年所做的事情。

45
00:03:29,120 --> 00:03:33,760
他们建立了一个令人惊讶的丰富理论，说明当你迭代这些有理函数时会发生什么，这一点尤其令人印象深刻，因为他们没有计算机可以像你我一样将这些可视化。

46
00:03:33,760 --> 00:03:38,560


47
00:03:38,560 --> 00:03:43,120


48
00:03:43,120 --> 00:03:48,960
记住这两个名字，稍后会出现。 到目前为止，您可能像这样研究的有理函数的最流行的示例以及随之而来的分形是最简单的函数之一，z

49
00:03:48,960 --> 00:03:53,200
平方加 c，其中 c

50
00:03:53,760 --> 00:04:00,320
是某个常数。 我猜想这对你们中的许多人来说至少有些熟悉，但在这里快速总结一下这个故事肯定没有什么坏处，因为它可以帮助为以后的事情奠定基础。

51
00:04:00,320 --> 00:04:04,640


52
00:04:04,640 --> 00:04:10,080
对于这个游戏，我们将把

53
00:04:10,080 --> 00:04:14,800
c 视为一个可以更改的值，并且它将显示为这个可移动的黄点。

54
00:04:14,800 --> 00:04:21,280
对于实际的迭代过程，我们总是从 z 的初始值为零开始。

55
00:04:21,280 --> 00:04:28,560
因此，迭代此函数一次后，执行 z 平方加 c，得到 c。 如果第二次迭代，将该值代入函数，您将得到

56
00:04:28,560 --> 00:04:34,480
c 平方加 c。 当我在此处更改值

57
00:04:34,560 --> 00:04:40,320
c 时，您可以看到第二个值如何同步移动。 然后我们可以插入第二个值来获取

58
00:04:40,320 --> 00:04:45,520
z3，插入第三个值来获取 z4，并继续这样，可视化我们的值链。

59
00:04:45,520 --> 00:04:52,320
因此，如果我继续对前多个值执行多次不同的操作，对于 c

60
00:04:52,320 --> 00:04:58,080
的某些选择，这个过程仍然是有限的。 您仍然可以在屏幕上看到这一切。

61
00:04:58,080 --> 00:05:02,800
有时它看起来像是爆炸了，你实际上可以证明，如果它变得大到二，它就会爆炸到无穷大。

62
00:05:02,800 --> 00:05:10,800
如果你将平面上保持黑色边界的点着色，并根据过程冲向无穷大的速度为发散值分配其他颜色渐变，你会得到所有数学中最具标志性的图像之一，曼德尔布罗特集。

63
00:05:10,800 --> 00:05:16,800


64
00:05:16,800 --> 00:05:22,160


65
00:05:22,160 --> 00:05:28,080
顺便说一下，这个轨迹的交互式点和棒可视化很大程度上受到了 Ben Spark

66
00:05:28,080 --> 00:05:32,160
的插图和他制作的关于 Mandelbrot 集的 Numberphile

67
00:05:32,160 --> 00:05:36,320
视频的启发，这很棒，你应该观看它。 老实说，我认为这太有趣了，无法在这里重新实现。

68
00:05:36,320 --> 00:05:41,440
我还强烈推荐关于 ako 的互动文章。 为那些还没有阅读过这些内容的人提供有关所有这些内容的信息。

69
00:05:41,440 --> 00:05:45,680
Ben

70
00:05:45,680 --> 00:05:50,320
Spark 插图的优点在于它阐明了 Mandelbrot 集的每个不同部分实际代表的含义。

71
00:05:50,320 --> 00:05:56,400
这个最大的心形部分包括 c 的值，以便该过程最终收敛到某个极限。

72
00:05:56,400 --> 00:06:01,760
左边的大圆圈表示进程陷入两个值之间的循环的值，然后顶部和底部的圆圈显示进程陷入三个值的循环的值，依此类推。

73
00:06:01,760 --> 00:06:06,560


74
00:06:06,560 --> 00:06:11,440
这些小岛中的每一个都有其自己的意义。

75
00:06:11,440 --> 00:06:18,240
另请注意，曼德尔布罗特集和我们之前看到的牛顿分形的构造方式之间存在重要差异，而不仅仅是不同的基础函数。

76
00:06:18,240 --> 00:06:22,400


77
00:06:22,400 --> 00:06:27,440
对于 Mandelbrot

78
00:06:27,440 --> 00:06:33,520
集，我们有一个一致的种子值 z 等于 0，但我们要调整的是参数 c，从而更改函数本身。

79
00:06:33,520 --> 00:06:38,960
所以你看到的就是我们所说的参数空间。 但对于牛顿分形，我们有一个不变的函数，但我们与每个像素关联的是该过程的不同种子值。

80
00:06:38,960 --> 00:06:44,480


81
00:06:44,480 --> 00:06:50,880
当然，我们可以用地图 z 平方加 c

82
00:06:50,880 --> 00:06:55,600
来玩同样的游戏，我们可以将 c 固定为某个常数，然后让像素代表不同的可能初始值 z 为零。

83
00:06:55,600 --> 00:07:01,120
因此，曼德尔布罗特集合的每个像素对应一个唯一的函数，而右侧的每个图像仅对应一个函数。

84
00:07:01,120 --> 00:07:06,880
当我们改变参数 c

85
00:07:06,880 --> 00:07:12,400
时，它会改变右侧的整个图像。 再次澄清一下，所应用的规则是，如果过程保持有界，我们将像素着色为黑色，然后根据它们发散到无穷大的速度，对发散到无穷大的像素应用某种渐变。

86
00:07:12,400 --> 00:07:17,200


87
00:07:17,200 --> 00:07:22,320


88
00:07:23,280 --> 00:07:27,760
原则上，考虑起来有点令人费解，存在一些由 c

89
00:07:27,760 --> 00:07:32,800
和 z

90
00:07:32,800 --> 00:07:36,320
的所有组合组成的四维空间，而我们在这里所做的就是查看那个难以想象的单个二维切片。图案。

91
00:07:37,600 --> 00:07:43,600
你经常会听到或读到右边的图像被称为 Julia 集或

92
00:07:43,600 --> 00:07:47,200
Julia 分形，当我第一次了解所有这些东西时，我承认我有点误解这就是这个术语。 Julia

93
00:07:47,200 --> 00:07:52,320
集具体指的是 z 平方加

94
00:07:52,320 --> 00:07:57,040
c 的情况，而且它还指的是内部的黑色区域。 然而，朱莉娅集这个术语有一个更笼统的定义，它仅指这些区域的边界，而不是内部。

95
00:07:57,040 --> 00:08:01,600


96
00:08:01,600 --> 00:08:07,200
为了为更具体的定义奠定基础，并朝着我在开始时提到的第一个目标取得一些进展，值得退后一步，实际上只是将自己想象成一名数学家，发现所有这一切。

97
00:08:07,200 --> 00:08:11,520


98
00:08:11,520 --> 00:08:16,080
你实际上会做什么来围绕这个构建理论？

99
00:08:16,080 --> 00:08:21,200
看一些漂亮的图片是一回事，但如果你真的想了解这一切，你会问什么样的问题呢？

100
00:08:21,200 --> 00:08:24,720


101
00:08:25,840 --> 00:08:30,080
一般来说，如果你想理解一些复杂的东西，一个好的起点是询问系统中是否有任何部分有一些简单的行为，最好是最简单的行为，在我们的例子中，这可能意味着询问什么时候过程只是保持固定在原地，这意味着 z

102
00:08:30,080 --> 00:08:34,720
的 f

103
00:08:34,720 --> 00:08:40,400
等于 z。

104
00:08:40,400 --> 00:08:45,840
我想你会同意这是一组非常无聊的动态。

105
00:08:46,400 --> 00:08:51,360
我们将具有此属性的值称为函数的不动点。 对于由牛顿法产生的函数，根据设计，它们在相关多项式的根处有一个固定点。

106
00:08:51,360 --> 00:08:56,560


107
00:08:56,560 --> 00:09:02,800
您可以自己验证，如果 z 的 p 等于 0，那么整个表达式就等于

108
00:09:02,800 --> 00:09:07,600
z。 这就是固定点的含义。 如果您喜欢练习，您可能会喜欢暂停片刻并计算此 Mandelbrot

109
00:09:07,600 --> 00:09:12,720
集合函数 z 平方加 c 的不动点。

110
00:09:12,720 --> 00:09:20,480
更一般地，任何有理函数总是有不动点，因为询问这个表达式何时等于

111
00:09:20,480 --> 00:09:25,040
z

112
00:09:25,040 --> 00:09:29,440
总是可以重新排列为寻找某个多项式表达式的根，并且根据代数基本定理，这必须有解，通常与该表达式中的最高程度。

113
00:09:29,440 --> 00:09:33,760


114
00:09:34,800 --> 00:09:39,600
顺便说一句，这意味着您也可以使用牛顿法找到这些不动点，也许这对我们来说有点太元了。

115
00:09:39,760 --> 00:09:41,920


116
00:09:42,640 --> 00:09:46,720
现在仅仅询问固定点可能很容易，但是理解完整动态以及我们正在查看的图表的一个关键思想是理解稳定性。

117
00:09:46,720 --> 00:09:53,040
如果附近的点倾向于被吸引到某个固定点，我们就说该固定点具有吸引力；如果它们被推开，则我们说该固定点具有排斥性。

118
00:09:53,040 --> 00:09:58,800


119
00:09:58,800 --> 00:10:04,080
这是您实际上可以使用函数的导数显式计算的东西。

120
00:10:04,080 --> 00:10:09,680
象征性地，当你对复杂函数求导数时，它看起来与实数函数完全相同，尽管像 z 平方这样的函数的导数是 2

121
00:10:09,680 --> 00:10:14,400
乘以 z 的导数。

122
00:10:14,400 --> 00:10:20,160
但从几何角度来看，有一种非常可爱的方式来解释这意味着什么。 例如，在输入

123
00:10:20,160 --> 00:10:25,760
1 处，该特定函数的导数计算结果为

124
00:10:25,760 --> 00:10:30,720
2，这告诉我们，如果您查看该输入周围的一个非常小的邻域，并且您可以跟踪该小邻域中的所有点所发生的情况，当您应用该函数（在本例中为 z

125
00:10:30,720 --> 00:10:34,720
平方）时，它看起来就像乘以 2

126
00:10:34,720 --> 00:10:40,880
一样。 这就是 2 的导数的含义。

127
00:10:40,880 --> 00:10:48,160
再举一个例子，让我们看看输入 i。 我们知道这个函数将输入移动到负值 1，即

128
00:10:48,160 --> 00:10:54,000
i 的平方。 但是，它在该值处的导数是 2

129
00:10:54,000 --> 00:10:59,840
倍 i 的附加信息为我们提供了附加图片，当您放大该点时，并查看函数在这个微小邻域上的作用，它看起来像是乘以

130
00:10:59,840 --> 00:11:05,680
2i，这在本例中，它看起来像是 90

131
00:11:05,680 --> 00:11:10,240
度旋转并扩大了 2 倍。

132
00:11:10,240 --> 00:11:18,480
为了分析稳定性，我们在这里唯一关心的是增长和收缩因素，旋转部分并不重要。

133
00:11:18,480 --> 00:11:23,360
因此，如果您计算函数在其固定点处的导数，并且该结果的绝对值小于

134
00:11:23,360 --> 00:11:29,120
1，则表明该固定点具有吸引力，附近的点倾向于向该固定点靠近。

135
00:11:29,120 --> 00:11:33,680


136
00:11:34,320 --> 00:11:39,040
如果该导数的绝对值大于 1，则表明该不动点具有排斥性，它会推开其邻居。

137
00:11:39,040 --> 00:11:44,640
例如，如果您计算出牛顿映射表达式的导数，并稍微简化一些事情，那么您将得到以下结果。

138
00:11:44,640 --> 00:11:49,040


139
00:11:50,320 --> 00:11:55,520
因此，如果 z 是一个固定点，在本文中意味着它是多项式 p 的根之一，则该导数不仅小于

140
00:11:55,520 --> 00:12:01,920
1，而且等于 0。 这些有时被称为超吸引固定点，因为这意味着这些点周围的邻域不仅缩小，而且缩小很多。

141
00:12:01,920 --> 00:12:06,160


142
00:12:06,160 --> 00:12:12,880
再说一次，这也是设计使然，因为牛顿方法的目的是产生尽可能快地落向根的迭代。

143
00:12:12,880 --> 00:12:18,880
拉出我们的

144
00:12:18,880 --> 00:12:23,600
z 平方加 c

145
00:12:23,600 --> 00:12:29,600
的例子，如果你做了第一个练习来找到它的不动点，下一步就会问，什么时候至少有一个这些不动点吸引？ 对于什么 c 值来说这是正确的？

146
00:12:29,600 --> 00:12:35,360
然后，如果这还不够挑战，请尝试使用您发现的结果来表明该条件对应于曼德尔布罗特集的主要心形形状。

147
00:12:35,360 --> 00:12:40,480


148
00:12:40,480 --> 00:12:42,960
这是你可以明确计算的东西，这非常酷。

149
00:12:45,120 --> 00:12:49,360
自然的下一步是询问周期，这才是事情真正开始变得有趣的地方。

150
00:12:49,360 --> 00:12:56,400
如果 z 的 f 不是

151
00:12:56,400 --> 00:13:01,920
z，而是其他值，然后该值又回到 z，则意味着您已陷入二循环。 您可以通过计算 f of f of

152
00:13:01,920 --> 00:13:09,280
z ，然后将其设置为等于 z 来显式找到此类两个循环。 例如，对于 z 平方加 c 映射，f

153
00:13:09,280 --> 00:13:15,360
of f of z 展开如下所示。 有点乱，但你知道，这并不算太糟糕。

154
00:13:15,360 --> 00:13:19,360
需要强调的主要一点是，它归结为求解某个四次方程。

155
00:13:19,920 --> 00:13:23,920
您应该注意，不动点也将是该方程的解，因此从技术上讲，这两个循环是该方程的解减去原始定点方程的解。

156
00:13:23,920 --> 00:13:28,880


157
00:13:28,880 --> 00:13:35,280
同样，您可以使用相同的想法通过将 f 与其自身组合 n 次不同的次数来查找 n

158
00:13:35,280 --> 00:13:41,760
个循环。 您很快就会得到的明确表达式变得极其混乱，但仍然可以阐明根据这个假设过程您期望有多少个周期。

159
00:13:41,760 --> 00:13:46,960


160
00:13:46,960 --> 00:13:52,480
如果我们坚持使用简单的 z 平方加

161
00:13:52,480 --> 00:13:57,680
c 示例，当您将其与自身组合时，您将得到一个四次多项式，然后是一个八次多项式，然后是

162
00:13:57,680 --> 00:14:03,200
16 次多项式，依此类推，呈指数增长多项式的阶数。 所以原则上，如果我问你一百万个周期有多少个循环，你可以知道这相当于解决一些绝对疯狂的次数为二到一百万的多项式表达式。

163
00:14:03,200 --> 00:14:08,320


164
00:14:08,400 --> 00:14:13,520


165
00:14:13,520 --> 00:14:18,800
再说一次，根据代数的基本定理，你会期望在复平面上找到大约二到一百万个点的东西，这些点正是以这种方式循环的。

166
00:14:18,800 --> 00:14:24,480


167
00:14:25,440 --> 00:14:30,320
更一般地说，对于任何有理图，您始终能够找到其行为落入周期为 n 的循环中的值。

168
00:14:30,320 --> 00:14:36,000
它最终归结为解决一些可能疯狂的多项式表达式。

169
00:14:36,000 --> 00:14:41,440
就像这个例子一样，这样的周期点的数量将随着 n 呈指数增长。

170
00:14:41,440 --> 00:14:46,880
我在上一个关于牛顿分形的视频中并没有真正讨论过这一点，但认为即使对于这样的过程也有无限多个点落入某种循环中，这有点奇怪。

171
00:14:46,880 --> 00:14:51,200


172
00:14:51,200 --> 00:14:56,960
但在几乎所有情况下，这些点都位于这些彩色区域之间的边界上，并且它们在实践中并没有真正出现，因为落在其中一个点上的概率为零。

173
00:14:56,960 --> 00:15:01,040


174
00:15:01,040 --> 00:15:06,240
实际上落入其中一个的重要因素是其中一个周期是否具有吸引力，从某种意义上说，该周期中某个值周围的点的邻域往往会被拉向该周期。

175
00:15:06,240 --> 00:15:11,360


176
00:15:11,360 --> 00:15:17,840
对于对数值方法感兴趣的人来说，一个高度相关的问题是，牛顿映射过程是否存在吸引循环，因为如果存在，则意味着您最初的猜测被困在该循环中并且永远找不到的可能性非零一个根。

177
00:15:17,840 --> 00:15:22,960


178
00:15:22,960 --> 00:15:27,760


179
00:15:27,760 --> 00:15:33,600
这里的答案实际上是肯定的。 更明确地说，如果您尝试找到

180
00:15:33,600 --> 00:15:39,520
z 的立方减去 2z 加 2

181
00:15:39,520 --> 00:15:45,440
的根，并且您使用牛顿法，请观察从值 0 开始的小簇会发生什么。 它有点来回反弹。

182
00:15:45,440 --> 00:15:50,240
好吧，在这种情况下，我们开始的簇有点太大，所以一些外部点被喷掉了。

183
00:15:50,240 --> 00:15:54,560
但如果我们从一个较小的集群开始，情况会是这样的。

184
00:15:54,560 --> 00:16:00,160
请注意所有点是如何真正收缩到 0 到 1 之间的循环的。

185
00:16:00,160 --> 00:16:04,960
你不太可能用随机种子来击中这个，但这绝对是可能的。

186
00:16:05,920 --> 00:16:10,320
顺便说一句，为了验证这样的循环是否具有吸引力，您可以做的练习是计算 f 的 f

187
00:16:10,320 --> 00:16:16,320
的 z 的导数，然后检查在输入零时，该导数的大小小于 1

188
00:16:16,320 --> 00:16:21,200
。 让我有点惊讶的是，当你尝试想象哪些三次多项式具有吸引环时会发生什么。

189
00:16:21,200 --> 00:16:26,880


190
00:16:26,880 --> 00:16:32,000
希望如果牛顿的方法能够很好地找到根源，那么那些吸引循环的情况应该很少见。

191
00:16:32,000 --> 00:16:37,680
首先，为了更好地可视化我们正在查看的一个示例，我们可以绘制与之前相同的分形，根据从该点开始的种子值趋向于哪个根对每个点进行着色。

192
00:16:37,680 --> 00:16:42,560


193
00:16:42,560 --> 00:16:47,680
但这一次我们将添加一个着色点条件，即如果种子值根本不够接近根，我们将把像素着色为黑色。

194
00:16:47,680 --> 00:16:52,480


195
00:16:53,600 --> 00:16:58,480
请注意，如果我调整根，这意味着我们正在尝试不同的三次多项式，实际上很难找到任何地方来放置它们，以便我们看到任何黑色像素。

196
00:16:58,480 --> 00:17:03,440


197
00:17:04,000 --> 00:17:09,840
我可以在这里找到这个小小的甜蜜点，但这绝对是罕见的。 现在我想要的是某种方法，以显示哪些具有吸引循环的方式，使用单个图像一次性可视化每个可能的三次多项式。

198
00:17:09,840 --> 00:17:15,840


199
00:17:15,840 --> 00:17:21,360
幸运的是，事实证明有一种非常简单的方法可以测试这些多项式之一是否具有吸引环。

200
00:17:21,360 --> 00:17:26,480
您所要做的就是查看种子值，该值位于三个根的平均值，即此处的质心。

201
00:17:26,480 --> 00:17:32,400
事实证明，这并不明显，如果有一个吸引周期，你可以保证这个种子值会落入那个吸引周期。

202
00:17:32,400 --> 00:17:37,040


203
00:17:37,040 --> 00:17:43,040
也就是说，如果有黑点的话，这就是其中之一。

204
00:17:43,040 --> 00:17:48,080
如果你想知道这个神奇的事实从何而来，它源于我们的好朋友法图的一个定理。

205
00:17:48,080 --> 00:17:53,520
他表明，如果这些有理图之一具有吸引循环，您可以查看迭代函数的导数等于零的值，并且这些值中至少有一个必须落入循环中。

206
00:17:53,520 --> 00:17:58,400


207
00:17:58,400 --> 00:18:04,080
这可能看起来有点奇怪，但粗略的直觉是，如果一个周期要有吸引力，那么至少其中一个值应该有一个非常小的导数，这就是收缩的来源。

208
00:18:04,080 --> 00:18:09,440


209
00:18:09,440 --> 00:18:13,920


210
00:18:13,920 --> 00:18:19,200
这反过来意味着循环中的该值位于导数不仅很小而且等于零的某个点附近，并且该点最终足够接近以被吸入循环中。

211
00:18:19,200 --> 00:18:24,160


212
00:18:24,160 --> 00:18:30,000
这一事实也证明了为什么对于 Mandelbrot 集合，我们只使用一个种子值

213
00:18:30,000 --> 00:18:34,640
z 等于 0，它仍然足以让我们得到一幅非常完整和有趣的图片。

214
00:18:34,640 --> 00:18:40,080
如果找到一个稳定的循环，那么那个种子值肯定会找到它。

215
00:18:40,080 --> 00:18:46,000
我觉得也许我今天布置的作业和练习有点太多了，但如果你对此感兴趣，另一个令人高兴的事情就是回顾一下我们在牛顿方法中发现的函数的导数表达式，并使用

216
00:18:46,000 --> 00:18:50,560
Fatou

217
00:18:50,560 --> 00:18:56,240
的这个精彩定理来展示我们关于三次多项式的神奇事实，即只需检查根的中点就足够了。

218
00:18:56,240 --> 00:19:01,920


219
00:19:01,920 --> 00:19:06,720
但老实说，所有这些都是您不必担心的细节。

220
00:19:06,720 --> 00:19:10,880
结果是，我们可以通过仅查看单个点而不是所有点来测试这些多项式之一是否具有吸引循环。

221
00:19:10,880 --> 00:19:16,400
正因为如此，我们实际上可以生成一个非常酷的图表。

222
00:19:16,400 --> 00:19:21,120
其工作方式是将两个根固定到位，假设将它们放在 z

223
00:19:21,120 --> 00:19:26,480
等于负一，z 等于正一，然后我们将围绕第三个根移动，我将其称为

224
00:19:26,480 --> 00:19:32,720
lambda。 请记住，我们要寻找的关键特征是质心点何时为黑色。

225
00:19:32,720 --> 00:19:38,400
因此，我要做的是在右侧绘制第二个图，其中每个像素对应于 lambda

226
00:19:38,400 --> 00:19:44,880
的一种可能选择。 我们要做的是根据三个根的中点的颜色为该像素着色。

227
00:19:44,880 --> 00:19:50,480
如果这感觉有点令人困惑，那完全没关系，这里有很多层次在起作用。

228
00:19:50,480 --> 00:19:55,520
请记住，右侧的每个像素都对应于由该参数

229
00:19:55,520 --> 00:20:01,280
lambda 确定的唯一多项式。

230
00:20:02,000 --> 00:20:05,600
事实上，您可以将其称为参数空间。 听起来有点熟？

231
00:20:13,840 --> 00:20:20,000
当且仅当对应多项式的牛顿法过程产生吸引循环时，该参数空间中的点才被着色为黑色。

232
00:20:20,000 --> 00:20:25,040
再次强调，如果这需要一点时间来消化，请不要担心。

233
00:20:25,120 --> 00:20:30,400
现在，乍一看，这张图上可能根本没有任何黑点，这是个好消息。

234
00:20:30,400 --> 00:20:35,920
这意味着在大多数情况下牛顿法不会陷入这样的循环。

235
00:20:35,920 --> 00:20:41,200
但是，我想我已经对此进行了足够的预览，您可以确切地知道这是怎么回事，如果我们放大，我们可以找到一个黑色区域，并且该黑色区域看起来与曼德尔布罗特集完全相同。

236
00:20:41,200 --> 00:20:46,800


237
00:20:46,800 --> 00:20:52,960
再一次，提出一个问题，我们在哪里调整这些函数之一的参数，会产生这种标志性的心形和气泡形状。

238
00:20:52,960 --> 00:20:59,440
结果是，这个形状并不像您想象的那样特定于 z

239
00:20:59,440 --> 00:21:04,560
平方加 c 示例。 它似乎与带有这样的过程的参数空间的一些更普遍和普遍的东西有关。

240
00:21:04,560 --> 00:21:08,880


241
00:21:11,680 --> 00:21:17,360
尽管如此，一个紧迫的问题是为什么我们会得到分形。 在上一个视频中，我谈到了牛顿法的图表如何具有这种非常奇特的属性，如果您在彩色区域的边界周围画一个小圆圈，那么该圆圈实际上必须包含图片中的所有可用颜色。

242
00:21:17,360 --> 00:21:22,640


243
00:21:22,640 --> 00:21:28,160


244
00:21:28,160 --> 00:21:33,360
对于任何有理地图来说，这都是更普遍的事实。 如果您要根据限制行为点所属的区域（例如哪个限制点或哪个限制循环，或者它是否趋于无穷大）为区域分配颜色，那么您绘制的小圆圈要么包含仅具有这些限制行为之一的点，或者它们包含所有点。

245
00:21:33,360 --> 00:21:38,720


246
00:21:38,720 --> 00:21:44,800


247
00:21:44,800 --> 00:21:50,000
从来没有介于两者之间的任何事情。

248
00:21:50,000 --> 00:21:55,440
因此，在至少有三种颜色的情况下，此属性意味着我们的边界永远不可能是平滑的，因为沿着平滑的线段，您可以绘制一个足够小的圆，仅接触两种颜色，而不是所有颜色。

249
00:21:55,440 --> 00:22:00,400


250
00:22:00,400 --> 00:22:05,280
从经验上看，这就是我们所看到的，无论放大多大，这些边界总是很粗糙。

251
00:22:05,280 --> 00:22:10,400
此外，您可能会注意到，当我们放大时，您始终可以看到框架内的所有可用颜色。

252
00:22:10,400 --> 00:22:17,280
这并不能解释只有两种限制行为的情况下的粗略界限，但它仍然是我在视频中留下的一个值得整理的松散的结局，这是引入两个重要术语的一个很好的借口，朱莉娅集和法图集。

253
00:22:17,280 --> 00:22:21,680


254
00:22:21,680 --> 00:22:26,000


255
00:22:26,000 --> 00:22:32,960
如果一个点最终落入某种稳定的可预测模式，我们就说它是迭代函数 Fatou

256
00:22:32,960 --> 00:22:38,560
集的一部分。 对于我们见过的所有地图来说，这几乎包括了所有内容。

257
00:22:38,560 --> 00:22:44,640
朱莉娅集是其他一切，在我们所看到的图片中，它们是彩色区域之间的粗略边界，当您从一个稳定吸引子过渡到另一个稳定吸引子时会发生什么。

258
00:22:44,640 --> 00:22:49,920


259
00:22:49,920 --> 00:22:55,440
例如，Julia 集将包括所有排斥周期和排斥固定点。

260
00:22:55,440 --> 00:23:01,120
朱莉娅集合中的一个典型点虽然不会是一个循环，但它会永远反弹，没有明确的模式。

261
00:23:01,120 --> 00:23:06,480
现在，如果你观察

262
00:23:06,480 --> 00:23:11,520
Fatou

263
00:23:11,520 --> 00:23:16,800
集中的一个点，并在它周围画一个足够小的圆盘，当你遵循这个过程时，当你陷入任何相关的稳定行为时，小圆盘最终会缩小。 除非你要无穷大，但你可以将其视为磁盘在无穷大附近缩小，但这也许只是让事情变得混乱。

264
00:23:16,800 --> 00:23:20,720


265
00:23:20,720 --> 00:23:28,240
相比之下，如果你在 Julia

266
00:23:28,240 --> 00:23:33,360
集合上的一个点周围画一个小圆盘，它往往会随着时间的推移而扩大，因为该圆内的点会消失并做自己的事情。

267
00:23:33,360 --> 00:23:40,560
换句话说，朱莉娅集的点往往表现得很混乱。 他们附近的邻居，即使是非常接近的邻居，最终也会陷入性质不同的行为。

268
00:23:40,560 --> 00:23:45,280


269
00:23:46,320 --> 00:23:51,920
但这不仅仅是磁盘扩展的问题。 一个非常令人惊讶的结果是前面提到的多色属性的关键，那就是如果你让这个过程进行下去，那个小圆盘最终会膨胀得如此之大，以至于它会击中复杂平面上的每个点，最多有两个例外。

270
00:23:51,920 --> 00:23:56,720


271
00:23:56,720 --> 00:24:02,480


272
00:24:03,360 --> 00:24:06,800
这就是 Julia 集合的“东西无处不在”原则。

273
00:24:07,760 --> 00:24:12,080
好吧，实际上并不是这么叫的。 在我阅读的源代码中，它被称为蒙特尔定理的推论。

274
00:24:12,080 --> 00:24:16,880
但应该这样称呼。 从某种意义上说，这告诉我们朱莉娅集的点不仅是混乱的，而且是尽可能混乱的。

275
00:24:16,880 --> 00:24:22,480


276
00:24:22,480 --> 00:24:28,880
在这里，让我向您展示使用牛顿图进行的一个小模拟，其中有几千个点的集群，所有这些点都从 Julia

277
00:24:28,880 --> 00:24:34,320
集上的一个点开始的一个很小的距离（百万分之一）内开始。

278
00:24:34,320 --> 00:24:45,760
当然，“东西到处都是”原则是指在该距离内有无数个点，并且它们最终会扩展到平面上的所有点，除了可能的两个点。

279
00:24:45,760 --> 00:24:49,760


280
00:24:49,760 --> 00:24:54,640
但这个小集群仍然应该给出总体思路。

281
00:24:54,640 --> 00:24:59,680
那个小圆盘上的一个有限的小样本似乎在各个方向上被喷射到各处。

282
00:24:59,680 --> 00:25:05,840
对于我们的目的来说，这意味着如果我们的地图存在一些有吸引力的行为，例如吸引固定点或吸引循环，则可以保证

283
00:25:05,840 --> 00:25:10,240
Julia

284
00:25:10,240 --> 00:25:14,800
集上该点周围那个小圆盘的值，无论如何它曾经很小，最终会陷入那种吸引行为。

285
00:25:14,800 --> 00:25:20,080


286
00:25:20,800 --> 00:25:25,520
如果我们有一个具有三个或更多吸引行为的案例，这可以解释为什么 Julia

287
00:25:25,600 --> 00:25:30,960
集不平滑，为什么它必须很复杂。 即便如此，这可能并不完全令人满意，因为它把罐子又向前推进了一步，引发了一个问题：为什么这种东西无处不在的原则首先是正确的。

288
00:25:30,960 --> 00:25:35,600


289
00:25:35,600 --> 00:25:40,160
就像我提到的，它来自蒙特尔定理，我选择不深入讨论细节，因为老实说，要涵盖的内容很多。

290
00:25:40,160 --> 00:25:44,800


291
00:25:44,800 --> 00:25:49,280
我能找到的证明最终依赖于称为 J

292
00:25:49,280 --> 00:25:53,760
函数的东西，它本身就是一个完整复杂的故事。 当然，我会在描述中为任何渴望了解更多信息的人留下链接和资源，如果您知道一种更简单的方法来了解为什么这个原理是正确的，我绝对会洗耳恭听。

293
00:25:53,760 --> 00:25:58,320


294
00:25:58,320 --> 00:26:03,280
我还应该说，作为一个简短的附注，即使我们到目前为止看到的图片有一个

295
00:26:03,280 --> 00:26:08,000
Julia 集，其面积为零，它是这些区域之间的边界，有一些例子，其中

296
00:26:08,000 --> 00:26:12,560
Julia

297
00:26:12,560 --> 00:26:19,520
集是整个飞机上，一切都表现得很混乱，有点狂野。 本节的主要内容是混沌与分形之间的联系。

298
00:26:19,520 --> 00:26:25,120
乍一看，这些似乎只是彼此相似，你知道，牛顿方法对于某些种子值来说是一种混乱的过程，并且这种混乱通过遵循特定点的轨迹以一种方式可见，而另一种方式则可见。方式是通过我们图表的复杂性来实现的，但这些感觉就像是性质不同的混乱。

299
00:26:25,120 --> 00:26:29,680


300
00:26:29,680 --> 00:26:34,960


301
00:26:34,960 --> 00:26:40,480


302
00:26:40,480 --> 00:26:45,920
也许这是一个很好的比喻，但仅此而已。 然而，这里的巧妙之处在于，当您量化某些点的混乱程度时，这种量化使我们能够通过此边界属性对粗糙分形形状进行实际解释。

303
00:26:45,920 --> 00:26:50,640


304
00:26:50,640 --> 00:26:56,080


305
00:26:56,080 --> 00:27:02,080
你经常会看到混沌和分形在数学中结合在一起，至少对我来说，只要这种结合具有逻辑联系，而不是作为两个碰巧重合的现象，它是令人满意的。

306
00:27:02,080 --> 00:27:06,960


307
00:27:06,960 --> 00:27:09,760


