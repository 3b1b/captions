1
00:00:00,000 --> 00:00:08,620
CD や

2
00:00:08,620 --> 00:00:10,900
DVD に傷を付けても、保存されているものを再生できる方法を考えたことはありますか?

3
00:00:10,900 --> 00:00:15,280
スクラッチはディスク上の 1

4
00:00:15,280 --> 00:00:20,500
と

5
00:00:20,500 --> 00:00:26,540
0

6
00:00:26,540 --> 00:00:28,400
に実際に影響を与えるため、保存されていたものとは異なるデータを読み取りますが、実際にスクラッチが発生しない限り、読み取られたビットは、エンコードされたファイルとまったく同じファイルにデコードされます。それらすべてのエラーにもかかわらず、ビットごとにコピーしました。

7
00:00:28,400 --> 00:00:32,800
エラーに強い方法でデータを保存すること、そして同様に重要なことですが、データを送信することを可能にする数学的賢さは山ほどあります。

8
00:00:32,800 --> 00:00:36,840


9
00:00:36,840 --> 00:00:41,480
そうですね、実際、これを行う方法を思いつくのに、それほど賢さは必要ありません。

10
00:00:41,480 --> 00:00:42,480


11
00:00:42,480 --> 00:00:47,660
ビデオ、サウンド、テキスト、コード、画像など、あらゆるファイルは、最終的には 1 と

12
00:00:47,660 --> 00:00:50,960
0 のシーケンスです。

13
00:00:50,960 --> 00:00:55,340
反転したビットを修正するための簡単な戦略は、各ビットのコピーを 3

14
00:00:55,340 --> 00:00:57,780
つ保存することです。

15
00:00:57,780 --> 00:01:02,240
次に、このファイルを読み取るマシンは、これら 3 つのコピーを比較し、矛盾がある場合は常に 3

16
00:01:02,240 --> 00:01:07,440
つのうち最良の 2 つを選択します。

17
00:01:07,440 --> 00:01:11,560
しかし、これが意味するのは、スペースの 3 分の 2 を冗長性のために使用することです。

18
00:01:11,560 --> 00:01:15,360
そして、それでも、そのスペースがすべて放棄されたにもかかわらず、複数のビットが反転された場合に何が起こるかについて強力な保証はありません。

19
00:01:15,360 --> 00:01:18,120


20
00:01:18,120 --> 00:01:21,960
さらに興味深い問題は、スペースをできるだけ少なくしながらエラーを修正できるようにするにはどうすればよいかということです。

21
00:01:21,960 --> 00:01:24,740


22
00:01:24,740 --> 00:01:28,500
たとえば、このビデオで説明する方法を使用すると、データを 256 ビット ブロックに保存できます。各ブロックは

23
00:01:28,500 --> 00:01:35,840
9 ビットを使用します。 ある種の冗長性として機能し、残りの

24
00:01:35,840 --> 00:01:41,000
247 ビットは、必要な意味のあるメッセージやデータを自由に伝送できます。

25
00:01:41,000 --> 00:01:44,740
そして、ここでビットが反転した場合でも、このブロックだけを見るだけで、マシンはエラーがあったことと、エラーがどこにあったかを正確に特定できるため、それを修正する方法がわかります。

26
00:01:44,740 --> 00:01:49,640
。

27
00:01:49,640 --> 00:01:53,120


28
00:01:53,140 --> 00:01:55,540
正直に言うと、それは魔法のように感じます。

29
00:01:55,540 --> 00:01:59,400
そして、この特定のスキームでは、2 つのビットが反転された場合、マシンは少なくとも

30
00:01:59,400 --> 00:02:03,180
2 つのエラーがあったことを検出できますが、それらを修正する方法はわかりません。

31
00:02:03,180 --> 00:02:08,140
さまざまなサイズのブロックに対してこれがどのように拡張されるかについては、後で少し説明します。

32
00:02:08,140 --> 00:02:12,620
このようなエラーを修正できる方法は、エラー修正コードとして十分に知られています。

33
00:02:12,620 --> 00:02:13,880


34
00:02:13,880 --> 00:02:18,220
過去 1

35
00:02:18,220 --> 00:02:23,000
世紀の大部分において、この分野は驚くほど奥深い数学の実に豊富な情報源であり、私たちが毎日使用するデバイスに組み込まれています。

36
00:02:23,000 --> 00:02:27,740
ここでの目標は、ハミング コードとして知られる最も初期の例の

37
00:02:27,740 --> 00:02:29,660
1 つを徹底的に理解することです。

38
00:02:29,660 --> 00:02:32,620
ちなみに、このビデオの構成について私が考えているのは、できるだけ直接説明するというよりも、ところどころに少し優しい指導を加えながら、自分で考え出すよう促すことです。

39
00:02:32,620 --> 00:02:37,060


40
00:02:37,060 --> 00:02:40,220


41
00:02:40,220 --> 00:02:44,100
したがって、ある時点でどうなるか分かったと感じたら、その瞬間を一時停止し、私が言う前に計画がどのようになるかを積極的に予測してください。

42
00:02:44,100 --> 00:02:47,180


43
00:02:47,180 --> 00:02:51,500
また、ハードウェア レベルまで理解してもらいたい場合は、Ben

44
00:02:51,500 --> 00:02:55,160
Eater がこのビデオと併せて、実際にブレッドボードにハミング

45
00:02:55,160 --> 00:02:59,520
コードを実装する方法を示すビデオを作成しました。これは非常に満足のいくものです。

46
00:02:59,520 --> 00:03:03,120
ハミング コードは、リード

47
00:03:03,120 --> 00:03:08,040
ソロモン

48
00:03:08,040 --> 00:03:14,240
アルゴリズムのような最新のコードほど広く使用されていないことを知っておく必要があります。しかし、このタスクが最初はいかに不可能に感じられるか、そして一度は完全に合理的であるように見えるというコントラストには、ある種の魔法があります。ハミングについて学びます。

49
00:03:14,240 --> 00:03:19,080
エラー修正の基本原理は、考えられるすべてのメッセージの膨大な空間の中で、一部のサブセットのみが有効なメッセージとみなされるということです。

50
00:03:19,300 --> 00:03:22,860


51
00:03:22,860 --> 00:03:29,100
例えとして、正しく綴られた単語と間違って綴られた単語について考えてみましょう。

52
00:03:29,100 --> 00:03:33,340
有効なメッセージが変更されるたびに、受信者は、タイプミスの場合と同様に、表示された内容を最も近い有効な隣接メッセージに修正する責任があります。

53
00:03:33,340 --> 00:03:38,380


54
00:03:38,380 --> 00:03:43,100
ただし、このようなメッセージを効率的に分類するための具体的なアルゴリズムを考え出すには、ある程度の賢さが必要です。

55
00:03:43,100 --> 00:03:47,160


56
00:03:47,160 --> 00:03:52,060
物語は 1940

57
00:03:52,060 --> 00:03:55,900
年代に始まります。当時、若いリチャード・ハミングはベル研究所で働いていました。彼の仕事の一部には、アクセスが制限されていた非常に大型で高価なパンチカード

58
00:03:55,900 --> 00:03:57,420
コンピューターの使用が含まれていました。

59
00:03:57,420 --> 00:04:01,200
そして、彼がやり続けたプログラムは失敗し続けました。なぜなら、時折、少し読み間違えられるからです。

60
00:04:01,200 --> 00:04:03,140


61
00:04:03,140 --> 00:04:07,140
欲求不満は発明の坩堝であるため、彼はうんざりして世界初の誤り訂正符号を発明しました。

62
00:04:07,140 --> 00:04:09,280


63
00:04:09,280 --> 00:04:13,020
ハミング

64
00:04:13,020 --> 00:04:16,620
コードをフレーム化するにはさまざまな方法がありますが、最初のパスとして、ハミング自身が考えた方法を試してみましょう。

65
00:04:16,620 --> 00:04:21,400
シンプルではありますが、単純すぎない 16 ビットのブロックの例を使用してみましょう。

66
00:04:21,400 --> 00:04:25,700
これらのビットの位置に 0 から 15 までの番号を付けます。

67
00:04:25,700 --> 00:04:30,520
保存したい実際のデータはこれらのビットのうち 12 ビットのみを構成し、位置のうちの

68
00:04:30,520 --> 00:04:33,920
4 つは一種の冗長性として予約されています。

69
00:04:33,920 --> 00:04:38,120
ここでの冗長という言葉は単にコピーを意味するものではありません。結局のところ、これらの 4

70
00:04:38,120 --> 00:04:40,200
ビットではデータをやみくもにコピーするのに十分な余地がありません。

71
00:04:40,200 --> 00:04:44,880
代わりに、新しい情報を追加するのではなく、回復力を追加する、より微妙で賢い種類の冗長性が必要になります。

72
00:04:44,880 --> 00:04:48,740


73
00:04:48,740 --> 00:04:52,620
これら 4

74
00:04:52,620 --> 00:04:56,400
つの特別なビットが、おそらく最後などでうまくパッケージ化されることを期待するかもしれませんが、ご覧のとおり、これらを 2

75
00:04:56,400 --> 00:05:00,320
のべき乗の位置に配置することで、最後までに非常にエレガントなものが得られます。

76
00:05:00,320 --> 00:05:05,420
また、より大きなブロックに対してこれがどのように拡張されるかについてのちょっとしたヒントも得られるかもしれません。

77
00:05:05,420 --> 00:05:09,220
また、技術的には、最終的にはわずか 11 ビットのデータになるため、位置

78
00:05:09,220 --> 00:05:14,260
0 で何が起こっているかについて若干のニュアンスがあることがわかりますが、今のところは心配しないでください。

79
00:05:14,280 --> 00:05:18,640
他のエラー修正アルゴリズムと同様に、これには 2

80
00:05:18,640 --> 00:05:23,200
人のプレイヤーが関与します。送信者はこれら 4

81
00:05:23,200 --> 00:05:26,360
つの特別なビットを設定する責任を負い、受信者は何らかのチェックを実行してエラーを修正する責任を負います。

82
00:05:26,360 --> 00:05:30,040
もちろん、送信者と受信者という言葉は実際にはすべてのチェックを行うマシンまたはソフトウェアを指し、メッセージの概念はストレージなどを含む非常に広い意味を指します。

83
00:05:30,040 --> 00:05:34,040


84
00:05:34,040 --> 00:05:35,480


85
00:05:35,480 --> 00:05:39,320
結局のところ、データを保存することは、ある場所から別の場所へではなく、過去から未来へメッセージを送信することと同じことです。

86
00:05:39,320 --> 00:05:42,640


87
00:05:42,640 --> 00:05:46,700
これがセットアップですが、本題に入る前に、ハミングが発見した当時にハミングの頭の中に新たにあった、関連するアイデアについて話す必要があります。これは、シングル

88
00:05:46,700 --> 00:05:51,080
ビット

89
00:05:51,080 --> 00:05:55,520
エラーを検出できるが、修正はできないという既知の方法です。ビジネスではパリティチェックとして使用されます。

90
00:05:55,520 --> 00:05:57,300


91
00:05:57,300 --> 00:06:01,300
パリティ チェックでは、送信側が調整を担当する

92
00:06:01,300 --> 00:06:04,940
1 つのビットのみを分離し、残りは自由にメッセージを送信できます。

93
00:06:04,940 --> 00:06:10,380
この特別なビットの唯一の役割は、メッセージ内の 1

94
00:06:10,380 --> 00:06:12,100
の合計数が偶数であることを確認することです。

95
00:06:12,100 --> 00:06:16,920
たとえば、現時点では 1 の合計数は 7

96
00:06:16,920 --> 00:06:20,960
で、これは奇数であるため、送信者はその特別なビットを 1 に反転してカウントを偶数にする必要があります。

97
00:06:20,960 --> 00:06:25,320
ただし、ブロックがすでに偶数個の 1 で始まっていた場合、この特別なビットは

98
00:06:25,320 --> 00:06:27,480
0 に保たれます。

99
00:06:27,480 --> 00:06:31,640
これは非常にシンプルで、一見シンプルですが、メッセージ内のどこかに変更があるというアイデアを抽出して、わずかな情報に反映させる非常にエレガントな方法です。

100
00:06:31,640 --> 00:06:37,760


101
00:06:37,760 --> 00:06:43,680
このメッセージのビットが 0 から 1、または 1

102
00:06:43,680 --> 00:06:48,140
から 0 に反転すると、1 の合計数が偶数から奇数に変化することに注意してください。

103
00:06:48,140 --> 00:06:52,000
したがって、あなたが受信者である場合、このメッセージを見て、奇数の

104
00:06:52,000 --> 00:06:56,580
1

105
00:06:56,580 --> 00:06:58,700
が表示されれば、たとえどこでエラーが発生したかは分からなくても、何らかのエラーが発生したことを確実に知ることができます。

106
00:06:58,700 --> 00:07:02,820
専門用語では、ビットのグループに偶数個の 1 が含まれるか奇数個の

107
00:07:02,820 --> 00:07:04,940
1 が含まれるかをパリティと呼びます。

108
00:07:04,940 --> 00:07:09,140
数値を使用して、パリティが 0 または

109
00:07:09,140 --> 00:07:11,320
1 であると表現することもできます。通常は、その考えに基づいて数学を始めると、この方がより役立ちます。

110
00:07:11,320 --> 00:07:15,200
送信側がパリティを制御するために使用するこの特別なビットは、パリティ

111
00:07:15,200 --> 00:07:18,020
ビットと呼ばれます。

112
00:07:18,020 --> 00:07:22,460
実際、明確にしておきたいのは、受信側が奇数のパリティを認識した場合、それは必ずしも 1

113
00:07:22,460 --> 00:07:26,920
つのエラーがあったことを意味するわけではなく、3 つのエラー、5

114
00:07:26,920 --> 00:07:29,560
つのエラー、またはその他の奇数のエラーがあった可能性がありますが、受信者は確実に知ることができます。 0ではなかったということ。

115
00:07:29,560 --> 00:07:34,880
一方、2 つのエラーがあった場合、または偶数のエラーがあった場合、最終的な

116
00:07:34,880 --> 00:07:39,560
1 のカウントは依然として偶数であるため、受信側は、偶数のカウントが必ずしもメッセージにエラーがないことを意味すると完全に確信することはできません。

117
00:07:39,560 --> 00:07:43,360
。

118
00:07:43,360 --> 00:07:47,860
たった 2

119
00:07:47,860 --> 00:07:49,760
ビットの反転で台無しになるメッセージは非常に弱いと不満を言うかもしれませんが、それはまったくその通りです。

120
00:07:49,760 --> 00:07:54,480
ただし、受信したメッセージが送信者が意図したものであることを 100%

121
00:07:54,480 --> 00:07:59,720
確信できるエラー検出または修正方法はないことに留意してください。

122
00:07:59,720 --> 00:08:03,760
結局のところ、十分なランダム

123
00:08:03,760 --> 00:08:05,920
ノイズがあれば、まったくの偶然で、ある有効なメッセージが別の有効なメッセージに常に変更される可能性があります。

124
00:08:05,920 --> 00:08:10,520
代わりに、目標は、特定の最大エラー数まで堅牢なスキームを考え出すこと、またはおそらくこのような誤検知の確率を減らすことです。

125
00:08:10,520 --> 00:08:16,480


126
00:08:16,480 --> 00:08:20,940
パリティ

127
00:08:20,940 --> 00:08:25,640
チェック自体は非常に弱いですが、メッセージ全体にわたる変更のアイデアを単一のビットにまで絞り出すことで、より洗練されたスキームのための強力な構成要素を提供します。

128
00:08:25,640 --> 00:08:28,000


129
00:08:28,000 --> 00:08:32,880
たとえば、ハミング氏は、エラーが発生したことだけでなく、どこでエラーが発生したかを特定する方法を探していました。彼の重要な洞察は、メッセージ全体ではなく、慎重に選択された特定のサブセットにパリティ

130
00:08:32,880 --> 00:08:37,160
チェックを適用すると、次のようにできるということでした。より洗練された一連の質問により、単一ビット

131
00:08:37,160 --> 00:08:42,040
エラーの位置が特定されます。

132
00:08:42,040 --> 00:08:46,840


133
00:08:46,840 --> 00:08:51,280
全体的な感覚は、可能性の空間を半分に切り取る「はい」または「いいえ」の質問をする 20

134
00:08:51,280 --> 00:08:54,300
の質問のゲームをプレイしているようなものです。

135
00:08:54,300 --> 00:08:58,840
たとえば、これらの 8

136
00:08:58,840 --> 00:08:59,840
ビット、すべての奇数番号の位置についてのみパリティ チェックを実行するとします。

137
00:09:00,400 --> 00:09:04,560
その後、エラーが検出されると、エラーが具体的にどこにあるのか、つまり、エラーが奇数の位置にあることについて、もう少し詳しい情報が受信機に提供されます。

138
00:09:04,560 --> 00:09:09,160


139
00:09:09,160 --> 00:09:14,360
これらの 8

140
00:09:14,360 --> 00:09:17,240
ビットでエラーが検出されない場合は、エラーがまったくないか、偶数の位置にあることを意味します。

141
00:09:17,240 --> 00:09:21,560
パリティ

142
00:09:21,560 --> 00:09:25,460
チェックをビットの半分に制限すると効果が薄れると思うかもしれませんが、他の適切に選択されたチェックと組み合わせて実行すると、直感に反してさらに強力なものが得られます。

143
00:09:25,460 --> 00:09:29,720


144
00:09:29,720 --> 00:09:34,440
実際にパリティ

145
00:09:34,440 --> 00:09:37,600
チェックを設定するには、グループ全体のパリティを制御する特別なビットを割り当てる必要があることに注意してください。

146
00:09:37,600 --> 00:09:39,920
ここでは位置 1 を選択しましょう。

147
00:09:39,920 --> 00:09:43,960
示されている例では、これらの 8

148
00:09:43,960 --> 00:09:48,220
ビットのパリティは現在奇数であるため、送信側はそのパリティ ビットを切り替える必要があり、現在は偶数になっています。

149
00:09:48,220 --> 00:09:51,040
これは、実行する 4 つのパリティ チェックのうちの 1 つだけです。

150
00:09:51,040 --> 00:09:55,560
2 番目のチェックは、少なくともここで描画したように、グリッドの右半分の

151
00:09:55,560 --> 00:09:56,880
8 ビットの中にあります。

152
00:09:56,880 --> 00:10:02,520
今回は位置 2 をパリティ ビットとして使用する可能性があるため、これらの

153
00:10:02,520 --> 00:10:07,160
8 ビットにはすでに偶数パリティがあり、送信者はビット番号 2 を変更しないままで問題ありません。

154
00:10:07,160 --> 00:10:11,040
次に、反対側で、受信側がこのグループのパリティをチェックし、それが奇数であることが判明した場合、エラーが右側の 8

155
00:10:11,040 --> 00:10:15,960
ビットのどこかにあることがわかります。

156
00:10:15,960 --> 00:10:21,260
それ以外の場合は、エラーがないか、左半分のどこかにエラーがあることを意味します。

157
00:10:21,260 --> 00:10:24,040
あるいは、エラーが 2 つあった可能性もあると思いますが、今のところは、ブロック全体で最大

158
00:10:24,040 --> 00:10:27,080
1 つのエラーがあると仮定します。

159
00:10:27,080 --> 00:10:29,160
それを超えると物事は完全に壊れます。

160
00:10:29,160 --> 00:10:32,920
ここで、次の 2 つのチェックを検討する前に、最初の

161
00:10:32,920 --> 00:10:35,880
2 つのチェックを一緒に考えると何ができるようになるのかを少し考えてみましょう。

162
00:10:35,880 --> 00:10:40,240
奇数列と右半分でエラーを検出したとします。

163
00:10:40,240 --> 00:10:43,940
これは必然的に、エラーが最後の列のどこかにあることを意味します。

164
00:10:43,940 --> 00:10:48,280
奇数列にエラーがなく、右半分にエラーがあった場合は、それが最後から 2

165
00:10:48,280 --> 00:10:50,520
番目の列にあることがわかります。

166
00:10:50,520 --> 00:10:54,640
同様に、奇数列にエラーがあり、右半分にはエラーがない場合は、2

167
00:10:54,640 --> 00:10:56,560
列目のどこかにエラーがあることがわかります。

168
00:10:56,560 --> 00:11:00,560
これら 2

169
00:11:00,560 --> 00:11:03,760
つのパリティ チェックのどちらでも何も検出されなかった場合、エラーが存在する可能性がある唯一の場所はその左端の列であることを意味します。

170
00:11:03,760 --> 00:11:06,480
ただし、単にエラーがまったくないことを意味する場合もあります。

171
00:11:06,480 --> 00:11:10,800
これは、2 つのパリティ

172
00:11:10,800 --> 00:11:11,800
チェックによって列を特定できると言うための、かなり面倒な方法です。

173
00:11:11,800 --> 00:11:14,000
ここから、おそらく次のことが推測できるでしょう。

174
00:11:14,000 --> 00:11:16,240
行について以外は基本的に同じことを行います。

175
00:11:16,240 --> 00:11:21,040
位置 4 をパリティ ビットとして使用して、奇数行のパリティ チェックが行われます。

176
00:11:21,040 --> 00:11:25,480
したがって、この例では、そのグループはすでに偶数パリティを持っているため、ビット 4 は

177
00:11:25,480 --> 00:11:26,480
0 に設定されます。

178
00:11:26,480 --> 00:11:31,280
最後に、位置 8 をパリティ ビットとして使用して、下位

179
00:11:31,280 --> 00:11:32,280
2 行のパリティ チェックが行われます。

180
00:11:32,280 --> 00:11:35,840
この場合、グループに偶数パリティを与えるために、送信者はビット 8

181
00:11:35,840 --> 00:11:37,840
をオンにする必要があるようです。

182
00:11:37,840 --> 00:11:41,360
最初の 2 つのチェックで列を特定できるのと同じように、次の

183
00:11:41,360 --> 00:11:43,000
2 つのチェックで行を特定できます。

184
00:11:43,000 --> 00:11:48,400
例として、送信中に、たとえば位置 3 でエラーが発生したと想像してください。

185
00:11:48,400 --> 00:11:52,620
これは最初のパリティ グループに影響し、2

186
00:11:52,620 --> 00:11:56,340
番目のパリティ グループにも影響するため、受信側は右側の列のどこかにエラーがあることがわかります。

187
00:11:56,340 --> 00:12:01,380
しかし、それは 3 番目のグループには影響せず、4 番目のグループにも影響を与えません。

188
00:12:01,380 --> 00:12:05,460
これにより、受信側は最初の行 (必然的に位置 3

189
00:12:05,460 --> 00:12:08,660
を意味します) までのエラーを特定できるため、エラーを修正できます。

190
00:12:08,660 --> 00:12:12,640
これら 4

191
00:12:12,680 --> 00:12:17,320
つの質問への答えによって、たとえそれがどこであったとしても、常に特定の場所を突き止めることができるということを、少し時間をかけて自分に納得させてみるのも楽しいかもしれません。

192
00:12:17,320 --> 00:12:22,640
実際、賢明な方は、これらの質問と二進数の数え方との間に関連性があることに気づくかもしれません。

193
00:12:22,640 --> 00:12:23,640


194
00:12:23,640 --> 00:12:27,840
もしそうなら、私が台無しにする前に、もう一度強調して、立ち止まって、自分でそのつながりを描いてみてください。

195
00:12:27,840 --> 00:12:30,880


196
00:12:30,880 --> 00:12:35,560
パリティ

197
00:12:35,560 --> 00:12:36,560
ビット自体が影響を受けるとどうなるか気になる場合は、試してみてください。

198
00:12:36,560 --> 00:12:40,720
これら 4 つの特別なビットのエラーが、他のものと同じように、同じ

199
00:12:40,720 --> 00:12:47,440
4 つの質問グループを使用してどのように追跡されるのかを少し考えてください。

200
00:12:47,440 --> 00:12:50,500
結局のところ、私たちが望んでいるのはメッセージ

201
00:12:50,500 --> 00:12:53,640
ビットを保護することであり、エラー訂正ビットはそのまま使われているだけなので、これはあまり問題ではありません。

202
00:12:53,640 --> 00:12:57,120
しかし、これらのビットも保護することは、副産物として自然に計画から外れます。

203
00:12:57,120 --> 00:12:59,260


204
00:12:59,260 --> 00:13:02,380
これがどのようにスケールされるかを予想するのも楽しいかもしれません。

205
00:13:02,380 --> 00:13:08,040
たとえば、場所を特定するためにサイズ 256

206
00:13:08,040 --> 00:13:15,680
ビットのブロックを使用した場合、特定の場所にたどり着くまでにバイナリ検索を行うには、8 つの「はい」または「いいえ」の質問だけが必要です。

207
00:13:15,680 --> 00:13:19,680
各質問では、適切なパリティ チェックを設定するために

208
00:13:19,680 --> 00:13:23,340
1 ビットだけを放棄する必要があることを覚えておいてください。

209
00:13:23,340 --> 00:13:26,960
すでにご覧になっている方もいるかもしれませんが、これらの質問の内容を 1 ～

210
00:13:26,960 --> 00:13:29,960
2 分で見つける体系的な方法については後ほど説明します。

211
00:13:29,960 --> 00:13:33,440
このスケッチが、ここで開発しているものの効率性を理解していただくのに十分であることを願っています。

212
00:13:33,440 --> 00:13:34,440


213
00:13:34,440 --> 00:13:38,440
最初のものは、強調表示されている 8

214
00:13:38,440 --> 00:13:41,720
つのパリティ ビットを除いて、任意のものにすることができ、必要なメッセージやデータを運ぶことができます。

215
00:13:41,720 --> 00:13:45,480
8

216
00:13:45,480 --> 00:13:53,640
ビットはメッセージの残りの部分によって完全に決定されるという意味で冗長ですが、メッセージ全体を単にコピーするよりもはるかに賢明な方法です。

217
00:13:53,640 --> 00:13:58,000
それでも、ほとんど諦めずに、どんなシングルビットエラーでも特定して修正することができるでしょう。

218
00:13:58,000 --> 00:13:59,000


219
00:13:59,000 --> 00:14:00,400
よくほとんど。

220
00:14:00,400 --> 00:14:05,920
さて、ここでの 1 つの問題は、4

221
00:14:05,920 --> 00:14:10,240
つのパリティ チェックのいずれもエラーを検出しなかった場合、つまり、送信者の意図どおり、特別に選択された

222
00:14:10,240 --> 00:14:15,520
8 ビットのサブセットがすべて偶数パリティを持つことを意味し、それはエラーがまったくなかったことを意味するかどうかです。 、または位置

223
00:14:15,520 --> 00:14:17,760
0 に絞り込まれます。

224
00:14:17,760 --> 00:14:23,040
ご覧のとおり、はいまたはいいえの質問が 4 つあるため、パリティ チェックには

225
00:14:23,040 --> 00:14:28,000
16 の可能な結果があり、ブロック内の 16 の位置のうち

226
00:14:28,000 --> 00:14:33,000
1 つを正確に特定するには最初は完璧に思えますが、17 番目の結果、つまりエラーなしを伝える必要もあります。状態。

227
00:14:33,000 --> 00:14:37,860
ここでの解決策は実際には非常に簡単で、0 番目のビットを完全に忘れるだけです。

228
00:14:37,860 --> 00:14:41,920
したがって、4 つのパリティ

229
00:14:41,920 --> 00:14:44,320
チェックを実行し、それらがすべて偶数であることが確認できれば、それは間違いなくエラーがないことを意味します。

230
00:14:44,320 --> 00:14:49,240
これが意味するのは、16 ビット ブロックを扱うのではなく、15 ビット ブロックを扱うということです。この場合、ビットのうち

231
00:14:49,240 --> 00:14:54,040
11 ビットがメッセージを伝送するために自由に使用され、そのうちの 4 ビットは冗長性のために存在します。

232
00:14:54,080 --> 00:14:58,400
これにより、業界の人々が 15-11

233
00:14:58,400 --> 00:14:59,400
ハミング コードと呼ぶものが完成しました。

234
00:14:59,400 --> 00:15:03,920
そうは言っても、ブロック サイズが 2

235
00:15:03,920 --> 00:15:08,880
のきれいな累乗であるのは良いことであり、その 0 番目のビットを保持して、それに少し追加の作業をさせる賢い方法があります。

236
00:15:08,880 --> 00:15:13,600
これをブロック全体にわたるパリティ ビットとして使用すると、修正はできなくても、実際に 2

237
00:15:13,600 --> 00:15:16,320
ビット エラーを検出できるようになります。

238
00:15:16,320 --> 00:15:17,440
仕組みは次のとおりです。

239
00:15:17,440 --> 00:15:21,740
これら 4 つの特別なエラー訂正ビットを設定した後、通常のパリティ

240
00:15:21,740 --> 00:15:25,540
チェックと同様に、ブロック全体のパリティが偶数になるように 0 番目のビットを設定します。

241
00:15:25,540 --> 00:15:29,780
ここで、単一ビット エラーがある場合、ブロック全体のパリティが奇数に切り替わりますが、4

242
00:15:29,780 --> 00:15:33,940
つのエラー修正チェックのおかげで、いずれにせよそれをキャッチできます。

243
00:15:33,940 --> 00:15:38,100
ただし、エラーが 2

244
00:15:38,100 --> 00:15:42,660
つある場合、全体のパリティは偶数に戻りますが、受信側では、これら 4

245
00:15:42,660 --> 00:15:45,820
つのパリティ チェックで何が起こっているかにより、少なくとも何らかのエラーが発生していることがわかります。

246
00:15:45,820 --> 00:15:49,780
そのため、全体としては偶数パリティであるにもかかわらず、他のチェックでゼロ以外の何かが発生していることに気付いた場合は、少なくとも 2

247
00:15:49,820 --> 00:15:52,980
つのエラーがあったことがわかります。

248
00:15:52,980 --> 00:15:54,420
それは賢くないですか？

249
00:15:54,420 --> 00:15:58,500
これらの 2 ビット

250
00:15:58,500 --> 00:16:02,340
エラーを修正することはできませんが、少し面倒な 0 番目のビットを動作に戻すだけで、エラーを検出できます。

251
00:16:02,340 --> 00:16:06,540
これは非常に標準的なもので、拡張ハミング コードとして知られています。

252
00:16:06,540 --> 00:16:10,860
技術的に言えば、少なくとも 16 ビット

253
00:16:10,860 --> 00:16:13,580
ブロックの例については、ハミング コードが何を行うかについて完全に説明できました。

254
00:16:13,580 --> 00:16:17,300
ただし、最初から最後まで 1

255
00:16:17,300 --> 00:16:21,980
つの完全な例を自分で実行して、理解度を確認し、ここまでのすべてを定着させる方が満足できると思います。

256
00:16:21,980 --> 00:16:25,100
ただし、私はあなたと一緒にそれを段階的に確認していきますので、あなた自身を確認してください。

257
00:16:25,100 --> 00:16:29,180
メッセージを設定するには、それが空間を介して変換するリテラル メッセージであっても、長期間保存したいデータであっても、最初のステップはメッセージを

258
00:16:29,180 --> 00:16:34,100
11

259
00:16:34,100 --> 00:16:35,700
ビットのチャンクに分割することです。

260
00:16:35,700 --> 00:16:40,340
各チャンクは、エラー耐性のある 16 ビット ブロックにパッケージ化されます。

261
00:16:40,340 --> 00:16:43,740
では、これを例として実際にやってみましょう。

262
00:16:43,740 --> 00:16:45,340
さあ、実際にやってみましょう！

263
00:16:45,380 --> 00:16:47,380
立ち止まってこのブロックを組み立ててみましょう。

264
00:16:52,980 --> 00:16:53,980
はい、準備はできましたか？

265
00:16:53,980 --> 00:16:58,500
位置 0 と他の

266
00:16:58,500 --> 00:17:05,700
2 の累乗はエラー訂正義務のために予約されているので、残りのすべてのスポットにメッセージ ビットを順番に配置することから始めます。

267
00:17:05,700 --> 00:17:09,700
このグループには偶数パリティが必要ですが、すでにそうされているため、位置 1 のパリティ

268
00:17:09,700 --> 00:17:13,140
ビットを 0 に設定する必要があります。

269
00:17:13,140 --> 00:17:17,700
次のグループは奇数パリティで始まるため、そのパリティ ビットを

270
00:17:17,700 --> 00:17:19,260
1 に設定する必要があります。

271
00:17:19,260 --> 00:17:23,740
その後のグループは奇数パリティで始まるため、やはりそのパリティ ビットを

272
00:17:23,740 --> 00:17:24,740
1 に設定する必要があります。

273
00:17:24,740 --> 00:17:29,500
また、最後のグループにも奇数パリティがあり、8 番目のビットを

274
00:17:29,500 --> 00:17:31,500
1 に設定します。

275
00:17:31,500 --> 00:17:36,460
そして最後のステップとして、ブロック全体が偶数パリティを持つようになりました。これは、ビット番号 0 (包括的なパリティ ビット)

276
00:17:36,460 --> 00:17:41,500
を 0 に設定できることを意味します。

277
00:17:41,500 --> 00:17:45,660
したがって、このブロックが送信されると、4 つの特別なサブセットとブロック全体のパリティはすべて偶数、つまり

278
00:17:45,660 --> 00:17:48,980
0 になります。

279
00:17:48,980 --> 00:17:53,620
演習の 2 番目の部分として、あなたに受信者の役割を果たしてもらいましょう。

280
00:17:53,620 --> 00:17:57,580
もちろん、それはあなたがこのメッセージが何であるかをまだ知らないことを意味します。もしかしたら覚えている人もいるかもしれませんが、まだ覚えていないと仮定しましょう。

281
00:17:57,580 --> 00:18:00,180


282
00:18:00,180 --> 00:18:05,820
私がやろうとしているのは、そのブロック内のビットの 0、1、または

283
00:18:05,820 --> 00:18:08,340
2 を変更して、私が何をしたのかを理解してもらうことです。

284
00:18:08,340 --> 00:18:13,460
もう一度立ち止まって、問題を解決してみてください。

285
00:18:13,460 --> 00:18:23,960
さて、受信者として最初のパリティ

286
00:18:23,960 --> 00:18:29,820
グループをチェックすると、それが偶数であることがわかり、存在するエラーは偶数列にある必要があります。

287
00:18:29,820 --> 00:18:34,620
次のチェックでは奇数が得られ、少なくとも 1

288
00:18:34,620 --> 00:18:38,760
つのエラーがあることがわかり、この特定の列に絞り込まれます。

289
00:18:38,760 --> 00:18:42,900
3 番目のチェックは均等であり、可能性をさらに切り詰めます。

290
00:18:42,900 --> 00:18:46,780
そして、最後のパリティ チェックは奇妙で、下部のどこかにエラーがあることがわかりますが、今では位置

291
00:18:46,780 --> 00:18:51,700
10 にあるはずであることがわかります。

292
00:18:51,700 --> 00:18:56,140
さらに、ブロック全体のパリティは奇数であるため、フリップが 2 回ではなく

293
00:18:56,140 --> 00:18:58,220
1 回であるという確信が得られます。

294
00:18:58,220 --> 00:19:01,600
3 つ以上の場合、すべての賭けは無効になります。

295
00:19:01,600 --> 00:19:06,520
ビット番号 10

296
00:19:06,520 --> 00:19:11,620
を修正した後、修正に使用されなかった 11

297
00:19:11,620 --> 00:19:16,160
ビットを取り出すと、元のメッセージの関連セグメントが得られます。巻き戻して比較すると、まさに例の開始点と同じになります。

298
00:19:16,160 --> 00:19:19,260
これらすべてを手動で行う方法がわかったので、次は、このロジックすべての中核部分を 1 行の

299
00:19:19,260 --> 00:19:23,940
Python コードで実行する方法を説明したいと思います。

300
00:19:23,940 --> 00:19:28,400
ご存知のとおり、私がまだお伝えしていないのは、このアルゴリズムが実際にどれほど洗練されているか、マシンにエラーの位置を指示させるのがどれほど簡単であるか、体系的にスケールを調整する方法、そしてすべてをどのようにフレーム化できるかということです。これは、複数の個別のパリティ

301
00:19:28,400 --> 00:19:32,380
チェックではなく、1

302
00:19:32,380 --> 00:19:37,680
つの操作として実行されます。

303
00:19:37,680 --> 00:19:39,580


304
00:19:39,580 --> 00:19:41,680
私の言いたいことを理解するには、パート 2 に参加してください。

