1
00:00:00,000 --> 00:00:03,942
Haben Sie sich jemals gefragt, wie es möglich ist,

2
00:00:03,942 --> 00:00:10,900
eine CD oder DVD zu zerkratzen und trotzdem den darauf gespeicherten Inhalt wiederzugeben?

3
00:00:10,900 --> 00:00:15,186
Der Kratzer wirkt sich tatsächlich auf die Einsen und Nullen auf der Festplatte aus,

4
00:00:15,186 --> 00:00:18,565
sodass andere Daten als die gespeicherten Daten ausgelesen werden.

5
00:00:18,565 --> 00:00:21,490
Wenn die Festplatte jedoch nicht wirklich zerkratzt wird,

6
00:00:21,490 --> 00:00:26,029
werden die ausgelesenen Bits in genau dieselbe Datei dekodiert, die darauf kodiert wurde,

7
00:00:26,029 --> 00:00:28,400
a Bit für Bit kopiert, trotz all dieser Fehler.

8
00:00:28,400 --> 00:00:32,675
Es gibt eine ganze Reihe mathematischer Raffinessen, die es uns ermöglichen,

9
00:00:32,675 --> 00:00:36,840
Daten fehlersicher zu speichern und, was noch wichtiger ist, zu übertragen.

10
00:00:36,840 --> 00:00:39,973
Na gut, eigentlich braucht es gar nicht so viel Cleverness,

11
00:00:39,973 --> 00:00:42,480
um einen Weg zu finden, dies zu bewerkstelligen.

12
00:00:42,480 --> 00:00:46,215
Jede Datei, sei es ein Video, ein Ton oder ein Text, ein Code,

13
00:00:46,215 --> 00:00:50,960
ein Bild oder was auch immer, ist letztendlich eine Folge von Einsen und Nullen.

14
00:00:50,960 --> 00:00:55,485
Und eine einfache Strategie zur Korrektur jedes umgedrehten Bits wäre,

15
00:00:55,485 --> 00:00:57,780
drei Kopien jedes Bits zu speichern.

16
00:00:57,780 --> 00:01:01,044
Dann könnte die Maschine, die diese Datei liest,

17
00:01:01,044 --> 00:01:05,508
diese drei Kopien vergleichen und immer die besten 2 von 3 nehmen,

18
00:01:05,508 --> 00:01:07,440
wenn es eine Diskrepanz gibt.

19
00:01:07,440 --> 00:01:11,560
Das bedeutet jedoch, dass zwei Drittel Ihres Platzes für Redundanz genutzt werden.

20
00:01:11,560 --> 00:01:15,730
Und selbst dann gibt es trotz all des verschenkten Platzes keine sichere Garantie dafür,

21
00:01:15,730 --> 00:01:18,120
was passiert, wenn mehr als ein Bit umgedreht wird.

22
00:01:18,120 --> 00:01:21,027
Die viel interessantere Frage ist, wie man es so gestalten kann,

23
00:01:21,027 --> 00:01:24,740
dass Fehler korrigiert werden können und dabei möglichst wenig Platz verloren geht.

24
00:01:24,740 --> 00:01:27,553
Mit der Methode, die Sie in diesem Video kennenlernen,

25
00:01:27,553 --> 00:01:31,031
könnten Sie beispielsweise Ihre Daten in 256-Bit-Blöcken speichern,

26
00:01:31,031 --> 00:01:32,975
wobei jeder Block 9 Bits verwendet, 9!

27
00:01:32,975 --> 00:01:37,152
um als eine Art Redundanz zu fungieren, und die anderen 247 Bits sind frei,

28
00:01:37,152 --> 00:01:41,000
um jede gewünschte aussagekräftige Nachricht oder Daten zu übertragen.

29
00:01:41,000 --> 00:01:43,139
Und es wird immer noch so sein, dass eine Maschine,

30
00:01:43,139 --> 00:01:46,267
wenn hier irgendein Bit umgedreht wird, allein durch einen Blick auf diesen

31
00:01:46,267 --> 00:01:48,736
Block und nichts weiter in der Lage sein wird, zu erkennen,

32
00:01:48,736 --> 00:01:51,946
dass ein Fehler aufgetreten ist und wo er sich genau befand, sodass sie weiß,

33
00:01:51,946 --> 00:01:53,140
wie sie ihn korrigieren kann.

34
00:01:53,140 --> 00:01:55,540
Und ehrlich gesagt, das fühlt sich wie Magie an.

35
00:01:55,540 --> 00:01:58,265
Und wenn bei diesem speziellen Schema zwei Bits umgedreht werden,

36
00:01:58,265 --> 00:02:01,280
kann die Maschine zumindest erkennen, dass zwei Fehler aufgetreten sind,

37
00:02:01,280 --> 00:02:03,180
weiß jedoch nicht, wie sie diese beheben kann.

38
00:02:03,180 --> 00:02:05,709
Wir werden etwas später darüber sprechen, wie dies

39
00:02:05,709 --> 00:02:08,140
für Blöcke unterschiedlicher Größe skaliert wird.

40
00:02:08,140 --> 00:02:10,937
Methoden, mit denen Sie solche Fehler korrigieren können,

41
00:02:10,937 --> 00:02:13,880
werden vernünftigerweise als Fehlerkorrekturcodes bezeichnet.

42
00:02:13,880 --> 00:02:16,829
Über den größten Teil des letzten Jahrhunderts hinweg war dieses

43
00:02:16,829 --> 00:02:20,504
Gebiet eine wirklich reichhaltige Quelle überraschend tiefgreifender Mathematik,

44
00:02:20,504 --> 00:02:23,000
die in die Geräte einfließt, die wir täglich verwenden.

45
00:02:23,000 --> 00:02:26,176
Ziel ist es, Ihnen ein sehr umfassendes Verständnis eines der

46
00:02:26,176 --> 00:02:29,660
frühesten Beispiele zu vermitteln, das als Hamming-Code bekannt ist.

47
00:02:29,660 --> 00:02:32,822
Übrigens geht es mir beim Aufbau dieses Videos weniger darum,

48
00:02:32,822 --> 00:02:36,802
es so direkt wie möglich zu erklären, als vielmehr darum, Sie dazu anzuregen,

49
00:02:36,802 --> 00:02:40,220
es selbst zu erfinden, mit ein wenig sanfter Anleitung hier und da.

50
00:02:40,220 --> 00:02:42,645
Wenn Sie also das Gefühl haben, irgendwann zu sehen, wohin es führt,

51
00:02:42,645 --> 00:02:45,352
nehmen Sie sich diesen Moment Zeit, um innezuhalten und aktiv vorherzusagen,

52
00:02:45,352 --> 00:02:47,180
wie der Plan aussehen wird, bevor ich es Ihnen sage.

53
00:02:47,180 --> 00:02:51,016
Wenn Sie außerdem möchten, dass Ihr Verständnis bis auf die Hardware-Ebene reicht,

54
00:02:51,016 --> 00:02:54,805
hat Ben Eater in Verbindung mit diesem Video ein Video erstellt, das Ihnen zeigt,

55
00:02:54,805 --> 00:02:57,948
wie Sie Hamming-Codes tatsächlich auf Steckbrettern implementieren,

56
00:02:57,948 --> 00:02:59,520
was äußerst zufriedenstellend ist.

57
00:02:59,520 --> 00:03:02,962
Sie sollten wissen, dass Hamming-Codes nicht so häufig verwendet werden wie

58
00:03:02,962 --> 00:03:05,226
modernere Codes wie der Reed-Solomon-Algorithmus,

59
00:03:05,226 --> 00:03:09,212
aber der Kontrast zwischen der Unmöglichkeit, die sich diese Aufgabe am Anfang anfühlt,

60
00:03:09,212 --> 00:03:11,884
und der völligen Vernünftigkeit, die sie einmal erscheint,

61
00:03:11,884 --> 00:03:14,240
hat etwas Magisches Sie erfahren etwas über Hamming.

62
00:03:14,240 --> 00:03:16,973
Das Grundprinzip der Fehlerkorrektur besteht darin,

63
00:03:16,973 --> 00:03:21,230
dass in einem riesigen Bereich aller möglichen Nachrichten nur einige Teilmengen

64
00:03:21,230 --> 00:03:22,860
als gültige Nachrichten gelten.

65
00:03:22,860 --> 00:03:29,100
Denken Sie als Analogie an richtig geschriebene Wörter und falsch geschriebene Wörter.

66
00:03:29,100 --> 00:03:31,373
Immer wenn eine gültige Nachricht geändert wird,

67
00:03:31,373 --> 00:03:34,111
ist der Empfänger dafür verantwortlich, das, was er sieht,

68
00:03:34,111 --> 00:03:36,431
an den nächsten gültigen Nachbarn zu korrigieren,

69
00:03:36,431 --> 00:03:38,380
wie es bei einem Tippfehler der Fall wäre.

70
00:03:38,380 --> 00:03:42,225
Die Entwicklung eines konkreten Algorithmus zur effizienten

71
00:03:42,225 --> 00:03:47,160
Kategorisierung solcher Nachrichten erfordert jedoch eine gewisse Cleverness.

72
00:03:47,160 --> 00:03:50,595
Die Geschichte beginnt in den 1940er Jahren, als der junge Richard Hamming

73
00:03:50,595 --> 00:03:54,030
für Bell Labs arbeitete und bei einigen seiner Arbeiten einen sehr großen,

74
00:03:54,030 --> 00:03:57,420
teuren Lochkartencomputer benutzte, zu dem er nur begrenzten Zugang hatte.

75
00:03:57,420 --> 00:04:00,733
Und die Programme, die er ständig durchführte, scheiterten immer wieder,

76
00:04:00,733 --> 00:04:03,140
weil hin und wieder ein Teil falsch verstanden wurde.

77
00:04:03,140 --> 00:04:05,730
Da Frustration der Schmelztiegel der Erfindungen war,

78
00:04:05,730 --> 00:04:09,280
hatte er die Nase voll und erfand den weltweit ersten Fehlerkorrekturcode.

79
00:04:09,280 --> 00:04:12,826
Es gibt viele verschiedene Möglichkeiten, Hamming-Codes zu formulieren,

80
00:04:12,826 --> 00:04:16,620
aber zunächst werden wir es so durchgehen, wie Hamming selbst darüber dachte.

81
00:04:16,620 --> 00:04:21,400
Nehmen wir ein einfaches, aber nicht zu einfaches Beispiel: einen Block mit 16 Bit.

82
00:04:21,400 --> 00:04:25,700
Wir nummerieren die Positionen dieser Bits von 0 bis 15.

83
00:04:25,700 --> 00:04:30,458
Die eigentlichen Daten, die wir speichern möchten, werden nur 12 dieser Bits ausmachen,

84
00:04:30,458 --> 00:04:33,920
während 4 der Positionen als eine Art Redundanz reserviert sind.

85
00:04:33,920 --> 00:04:36,543
Das Wort „redundant“ bedeutet hier nicht einfach „kopieren“,

86
00:04:36,543 --> 00:04:40,200
schließlich geben uns diese 4 Bits nicht genug Platz, um die Daten blind zu kopieren.

87
00:04:40,200 --> 00:04:44,470
Stattdessen müssen sie eine viel differenziertere und intelligentere Art der Redundanz

88
00:04:44,470 --> 00:04:48,740
sein, die keine neuen Informationen hinzufügt, sondern die Widerstandsfähigkeit erhöht.

89
00:04:48,740 --> 00:04:52,350
Man könnte erwarten, dass diese 4 besonderen Teile schön verpackt zusammenkommen,

90
00:04:52,350 --> 00:04:55,784
vielleicht am Ende oder so ähnlich, aber wie Sie sehen werden, ermöglicht es,

91
00:04:55,784 --> 00:04:58,338
sie in Positionen zu platzieren, die Zweierpotenzen sind,

92
00:04:58,338 --> 00:05:00,320
am Ende etwas wirklich Elegantes zu schaffen.

93
00:05:00,320 --> 00:05:03,062
Es könnte Ihnen auch einen kleinen Hinweis darauf geben,

94
00:05:03,062 --> 00:05:05,420
wie sich dies auf größere Blöcke skalieren lässt.

95
00:05:05,420 --> 00:05:07,907
Auch technisch gesehen sind es am Ende nur 11 Datenbits.

96
00:05:07,907 --> 00:05:10,788
Sie werden feststellen, dass es eine leichte Nuance für das gibt,

97
00:05:10,788 --> 00:05:14,280
was an Position 0 passiert, aber machen Sie sich darüber im Moment keine Sorgen.

98
00:05:14,280 --> 00:05:17,926
Wie bei jedem Fehlerkorrekturalgorithmus sind auch hier zwei Spieler beteiligt:

99
00:05:17,926 --> 00:05:21,345
ein Sender, der für das Setzen dieser vier Spezialbits verantwortlich ist,

100
00:05:21,345 --> 00:05:23,579
und ein Empfänger, der dafür verantwortlich ist,

101
00:05:23,579 --> 00:05:26,360
eine Art Prüfung durchzuführen und die Fehler zu korrigieren.

102
00:05:26,360 --> 00:05:29,440
Natürlich beziehen sich die Wörter „Sender“ und „Empfänger“ in Wirklichkeit

103
00:05:29,440 --> 00:05:31,913
auf Maschinen oder Software, die alle Prüfungen durchführen,

104
00:05:31,913 --> 00:05:35,480
und der Begriff „Nachricht“ ist sehr weit gefasst und umfasst Dinge wie die Speicherung.

105
00:05:35,480 --> 00:05:39,194
Schließlich ist das Speichern von Daten dasselbe wie das Versenden einer Nachricht

106
00:05:39,194 --> 00:05:42,640
nur von der Vergangenheit in die Zukunft und nicht von einem Ort zum anderen.

107
00:05:42,640 --> 00:05:45,830
Das ist also der Aufbau, aber bevor wir uns darauf einlassen können,

108
00:05:45,830 --> 00:05:49,484
müssen wir über eine verwandte Idee sprechen, die Hamming zum Zeitpunkt seiner

109
00:05:49,484 --> 00:05:51,889
Entdeckung noch frisch im Kopf hatte: eine Methode,

110
00:05:51,889 --> 00:05:55,126
mit der man einzelne Bitfehler erkennen, aber nicht korrigieren kann,

111
00:05:55,126 --> 00:05:57,300
wie man weiß im Geschäft als Paritätskontrolle.

112
00:05:57,300 --> 00:06:00,410
Bei einer Paritätsprüfung trennen wir nur ein einzelnes Bit heraus,

113
00:06:00,410 --> 00:06:02,927
für dessen Abstimmung der Absender verantwortlich ist,

114
00:06:02,927 --> 00:06:04,940
und der Rest kann eine Nachricht übertragen.

115
00:06:04,940 --> 00:06:08,669
Die einzige Aufgabe dieses speziellen Bits besteht darin, sicherzustellen,

116
00:06:08,669 --> 00:06:12,100
dass die Gesamtzahl der Einsen in der Nachricht eine gerade Zahl ist.

117
00:06:12,100 --> 00:06:16,082
Im Moment beträgt die Gesamtzahl der Einsen beispielsweise 7, das ist ungerade,

118
00:06:16,082 --> 00:06:19,367
daher muss der Absender dieses spezielle Bit auf eine 1 umdrehen,

119
00:06:19,367 --> 00:06:20,960
um die Zählung gerade zu machen.

120
00:06:20,960 --> 00:06:25,109
Hätte der Block jedoch bereits mit einer geraden Anzahl von Einsen begonnen,

121
00:06:25,109 --> 00:06:27,480
wäre dieses Sonderbit auf 0 gehalten worden.

122
00:06:27,480 --> 00:06:30,953
Das ist ziemlich einfach, täuschend einfach, aber es ist eine unglaublich

123
00:06:30,953 --> 00:06:34,474
elegante Möglichkeit, die Idee der Veränderung irgendwo in einer Nachricht

124
00:06:34,474 --> 00:06:37,760
zu destillieren, um sie in einer einzigen Information widerzuspiegeln.

125
00:06:37,760 --> 00:06:42,887
Beachten Sie, dass sich die Gesamtzahl der Einsen von gerade auf ungerade ändert,

126
00:06:42,887 --> 00:06:48,140
wenn ein Bit dieser Nachricht umgedreht wird, entweder von 0 auf 1 oder von 1 auf 0.

127
00:06:48,140 --> 00:06:51,784
Wenn Sie also der Empfänger sind, sich diese Nachricht ansehen und eine ungerade Anzahl

128
00:06:51,784 --> 00:06:55,304
von Einsen sehen, können Sie mit Sicherheit wissen, dass ein Fehler aufgetreten ist,

129
00:06:55,304 --> 00:06:58,700
auch wenn Sie möglicherweise keine Ahnung haben, wo dieser Fehler aufgetreten ist.

130
00:06:58,700 --> 00:07:02,661
Ob eine Gruppe von Bits eine gerade oder ungerade Anzahl von Einsen hat,

131
00:07:02,661 --> 00:07:04,940
wird im Fachjargon als Parität bezeichnet.

132
00:07:04,940 --> 00:07:08,088
Sie könnten auch Zahlen verwenden und sagen, dass die Parität 0 oder 1 ist,

133
00:07:08,088 --> 00:07:11,320
was normalerweise hilfreicher ist, wenn Sie anfangen, mit der Idee zu rechnen.

134
00:07:11,320 --> 00:07:16,424
Und dieses spezielle Bit, das der Absender zur Steuerung der Parität verwendet,

135
00:07:16,424 --> 00:07:18,020
wird Paritätsbit genannt.

136
00:07:18,020 --> 00:07:20,100
Und eigentlich sollten wir uns darüber im Klaren sein:

137
00:07:20,100 --> 00:07:23,052
Wenn der Empfänger eine ungerade Parität sieht, bedeutet das nicht unbedingt,

138
00:07:23,052 --> 00:07:25,852
dass nur ein Fehler aufgetreten ist, es könnten auch 3 Fehler oder 5 oder

139
00:07:25,852 --> 00:07:28,803
eine andere ungerade Zahl gewesen sein, aber er kann es mit Sicherheit wissen

140
00:07:28,803 --> 00:07:29,560
dass es nicht 0 war.

141
00:07:29,560 --> 00:07:33,641
Wenn es andererseits zwei Fehler oder eine gerade Anzahl von Fehlern gegeben hätte,

142
00:07:33,641 --> 00:07:36,411
wäre die endgültige Anzahl von Einsen immer noch gerade,

143
00:07:36,411 --> 00:07:39,424
sodass der Empfänger nicht vollständig darauf vertrauen kann,

144
00:07:39,424 --> 00:07:43,360
dass eine gerade Anzahl zwangsläufig bedeutet, dass die Nachricht fehlerfrei ist.

145
00:07:43,360 --> 00:07:45,651
Sie könnten sich darüber beschweren, dass eine Nachricht,

146
00:07:45,651 --> 00:07:48,693
die durch nur 2-Bit-Flips durcheinander gebracht wird, ziemlich schwach ist,

147
00:07:48,693 --> 00:07:49,760
und Sie haben völlig Recht.

148
00:07:49,760 --> 00:07:53,625
Bedenken Sie jedoch, dass es keine Methode zur Fehlererkennung oder -korrektur gibt,

149
00:07:53,625 --> 00:07:56,945
die Ihnen hundertprozentige Sicherheit geben könnte, dass die Nachricht,

150
00:07:56,945 --> 00:07:59,720
die Sie erhalten, die ist, die der Absender beabsichtigt hat.

151
00:07:59,720 --> 00:08:02,666
Schließlich könnte genügend zufälliges Rauschen immer eine gültige

152
00:08:02,666 --> 00:08:05,920
Nachricht durch reinen Zufall in eine andere gültige Nachricht verwandeln.

153
00:08:05,920 --> 00:08:09,145
Stattdessen besteht das Ziel darin, ein Schema zu entwickeln,

154
00:08:09,145 --> 00:08:12,422
das bis zu einer bestimmten maximalen Fehleranzahl robust ist,

155
00:08:12,422 --> 00:08:16,480
oder vielleicht die Wahrscheinlichkeit eines solchen Fehlalarms zu verringern.

156
00:08:16,480 --> 00:08:19,028
Paritätsprüfungen allein sind ziemlich schwach,

157
00:08:19,028 --> 00:08:22,744
aber indem sie die Idee der Änderung einer gesamten Nachricht auf ein

158
00:08:22,744 --> 00:08:26,566
einzelnes Bit reduzieren, geben sie uns einen leistungsstarken Baustein

159
00:08:26,566 --> 00:08:28,000
für ausgefeiltere Schemata.

160
00:08:28,000 --> 00:08:31,359
Als Hamming beispielsweise nach einer Möglichkeit suchte, herauszufinden,

161
00:08:31,359 --> 00:08:34,537
wo ein Fehler aufgetreten ist und nicht nur, dass er aufgetreten ist,

162
00:08:34,537 --> 00:08:37,034
war seine wichtigste Erkenntnis, dass man fragen kann,

163
00:08:37,034 --> 00:08:40,075
wenn man einige Paritätsprüfungen nicht auf die gesamte Nachricht,

164
00:08:40,075 --> 00:08:43,798
sondern auf bestimmte sorgfältig ausgewählte Teilmengen anwendet eine verfeinerte

165
00:08:43,798 --> 00:08:46,840
Reihe von Fragen, die den Ort eines einzelnen Bitfehlers bestimmen.

166
00:08:46,840 --> 00:08:50,526
Das Gesamtgefühl ist ein bisschen so, als würde man ein Spiel mit 20 Fragen spielen,

167
00:08:50,526 --> 00:08:54,300
bei dem Ja- oder Nein-Fragen gestellt werden, die den Raum der Möglichkeiten halbieren.

168
00:08:54,300 --> 00:08:58,594
Nehmen wir zum Beispiel an, wir führen eine Paritätsprüfung nur für diese 8 Bits durch,

169
00:08:58,594 --> 00:09:00,400
also alle ungeradzahligen Positionen.

170
00:09:00,400 --> 00:09:04,708
Wenn dann ein Fehler erkannt wird, erhält der Empfänger etwas mehr Informationen darüber,

171
00:09:04,708 --> 00:09:07,532
wo genau sich der Fehler befindet, nämlich dass er sich an

172
00:09:07,532 --> 00:09:09,160
einer ungeraden Position befindet.

173
00:09:09,160 --> 00:09:12,616
Wenn unter diesen 8 Bits kein Fehler erkannt wird, bedeutet das entweder,

174
00:09:12,616 --> 00:09:16,819
dass überhaupt kein Fehler vorliegt, oder dass er sich irgendwo in den geraden Positionen

175
00:09:16,819 --> 00:09:17,240
befindet.

176
00:09:17,240 --> 00:09:21,291
Man könnte denken, dass die Beschränkung einer Paritätsprüfung auf die Hälfte der Bits

177
00:09:21,291 --> 00:09:24,970
sie weniger effektiv macht, aber wenn sie in Verbindung mit anderen sorgfältig

178
00:09:24,970 --> 00:09:28,835
ausgewählten Prüfungen durchgeführt wird, ergibt sie uns kontraintuitiv etwas viel

179
00:09:28,835 --> 00:09:29,720
Leistungsfähigeres.

180
00:09:29,720 --> 00:09:33,179
Um diese Paritätsprüfung tatsächlich einzurichten, müssen Sie bedenken,

181
00:09:33,179 --> 00:09:35,485
dass ein spezielles Bit reserviert werden muss,

182
00:09:35,485 --> 00:09:37,600
das die Parität der gesamten Gruppe steuert.

183
00:09:37,600 --> 00:09:39,920
Hier wählen wir einfach Position 1.

184
00:09:39,920 --> 00:09:43,278
Im gezeigten Beispiel ist die Parität dieser 8 Bits derzeit ungerade,

185
00:09:43,278 --> 00:09:47,068
sodass der Absender dafür verantwortlich ist, dieses Paritätsbit umzuschalten,

186
00:09:47,068 --> 00:09:48,220
und jetzt ist es gerade.

187
00:09:48,220 --> 00:09:51,040
Dies ist nur eine von vier Paritätsprüfungen, die wir durchführen werden.

188
00:09:51,040 --> 00:09:54,630
Das zweite Häkchen gehört zu den 8 Bits in der rechten Hälfte des Rasters,

189
00:09:54,630 --> 00:09:56,880
zumindest so, wie wir es hier gezeichnet haben.

190
00:09:56,880 --> 00:10:00,289
Dieses Mal verwenden wir möglicherweise Position 2 als Paritätsbit,

191
00:10:00,289 --> 00:10:03,850
sodass diese 8 Bits bereits eine gerade Parität haben und der Absender

192
00:10:03,850 --> 00:10:07,160
beruhigt sein kann, wenn er dieses Bit Nummer 2 unverändert lässt.

193
00:10:07,160 --> 00:10:11,010
Wenn der Empfänger andererseits die Parität dieser Gruppe überprüft und feststellt,

194
00:10:11,010 --> 00:10:14,035
dass sie ungerade ist, weiß er, dass der Fehler irgendwo zwischen

195
00:10:14,035 --> 00:10:15,960
diesen 8 Bits auf der rechten Seite liegt.

196
00:10:15,960 --> 00:10:18,637
Andernfalls liegt entweder kein Fehler vor oder

197
00:10:18,637 --> 00:10:21,260
der Fehler liegt irgendwo in der linken Hälfte.

198
00:10:21,260 --> 00:10:23,417
Oder ich denke, es könnte zwei Fehler gegeben haben,

199
00:10:23,417 --> 00:10:27,080
aber im Moment gehen wir davon aus, dass es höchstens einen Fehler im gesamten Block gibt.

200
00:10:27,080 --> 00:10:29,160
Darüber hinaus brechen die Dinge völlig zusammen.

201
00:10:29,160 --> 00:10:31,138
Bevor wir uns die nächsten beiden Prüfungen ansehen,

202
00:10:31,138 --> 00:10:33,117
nehmen Sie sich einen Moment Zeit und überlegen Sie,

203
00:10:33,117 --> 00:10:35,880
was uns diese ersten beiden ermöglichen, wenn Sie sie zusammen betrachten.

204
00:10:35,880 --> 00:10:38,177
Nehmen wir an, Sie entdecken einen Fehler in den

205
00:10:38,177 --> 00:10:40,240
ungeraden Spalten und in der rechten Hälfte.

206
00:10:40,240 --> 00:10:43,940
Das bedeutet zwangsläufig, dass der Fehler irgendwo in der letzten Spalte liegt.

207
00:10:43,940 --> 00:10:46,418
Wenn in der ungeraden Spalte kein Fehler aufgetreten ist,

208
00:10:46,418 --> 00:10:48,597
in der rechten Hälfte jedoch einer, bedeutet dies,

209
00:10:48,597 --> 00:10:50,520
dass es sich um die vorletzte Spalte handelt.

210
00:10:50,520 --> 00:10:53,728
Wenn in den ungeraden Spalten, aber nicht in der rechten Hälfte ein Fehler auftritt,

211
00:10:53,728 --> 00:10:56,560
wissen Sie ebenfalls, dass er sich irgendwo in der zweiten Spalte befindet.

212
00:10:56,560 --> 00:11:00,003
Und wenn keine dieser beiden Paritätsprüfungen etwas erkennt, bedeutet dies,

213
00:11:00,003 --> 00:11:03,760
dass der einzige Ort, an dem ein Fehler auftreten könnte, die Spalte ganz links ist.

214
00:11:03,760 --> 00:11:06,480
Es könnte aber auch einfach bedeuten, dass überhaupt kein Fehler vorliegt.

215
00:11:06,480 --> 00:11:08,820
Das ist alles eine ziemlich umständliche Art zu sagen,

216
00:11:08,820 --> 00:11:11,800
dass wir mit zwei Paritätsprüfungen die Spalte genau bestimmen können.

217
00:11:11,800 --> 00:11:14,000
Von hier aus können Sie wahrscheinlich erraten, was folgt.

218
00:11:14,000 --> 00:11:16,240
Wir machen im Grunde das Gleiche, außer für die Zeilen.

219
00:11:16,240 --> 00:11:18,982
In den ungeraden Zeilen wird eine Paritätsprüfung durchgeführt,

220
00:11:18,982 --> 00:11:21,040
wobei Position 4 als Paritätsbit verwendet wird.

221
00:11:21,040 --> 00:11:24,773
In diesem Beispiel hat diese Gruppe also bereits eine gerade Parität,

222
00:11:24,773 --> 00:11:26,480
sodass Bit 4 auf 0 gesetzt wäre.

223
00:11:26,480 --> 00:11:30,016
Und schließlich gibt es eine Paritätsprüfung in den unteren beiden Zeilen,

224
00:11:30,016 --> 00:11:32,280
wobei Position 8 als Paritätsbit verwendet wird.

225
00:11:32,280 --> 00:11:35,657
In diesem Fall sieht es so aus, als ob der Absender dieses Bit 8 aktivieren muss,

226
00:11:35,657 --> 00:11:37,840
um der Gruppe eine gleichmäßige Parität zu verleihen.

227
00:11:37,840 --> 00:11:40,551
So wie wir mit den ersten beiden Prüfungen die Spalte festlegen können,

228
00:11:40,551 --> 00:11:43,000
können Sie mit den nächsten beiden Prüfungen die Zeile festlegen.

229
00:11:43,000 --> 00:11:45,484
Stellen Sie sich als Beispiel vor, dass während der

230
00:11:45,484 --> 00:11:48,400
Übertragung ein Fehler beispielsweise an Position 3 auftritt.

231
00:11:48,400 --> 00:11:52,271
Nun, das betrifft die erste Paritätsgruppe und auch die zweite Paritätsgruppe,

232
00:11:52,271 --> 00:11:56,340
sodass der Empfänger weiß, dass irgendwo in der rechten Spalte ein Fehler vorliegt.

233
00:11:56,340 --> 00:12:01,380
Aber es hat keine Auswirkungen auf die dritte Gruppe und auch nicht auf die vierte Gruppe.

234
00:12:01,380 --> 00:12:04,609
Und so kann der Empfänger den Fehler bis zur ersten Zeile,

235
00:12:04,609 --> 00:12:08,660
was zwangsläufig Position 3 bedeutet, lokalisieren und den Fehler beheben.

236
00:12:08,660 --> 00:12:11,639
Nehmen Sie sich vielleicht einen Moment Zeit, um sich davon zu überzeugen,

237
00:12:11,639 --> 00:12:14,420
dass Sie mit den Antworten auf diese vier Fragen wirklich immer einen

238
00:12:14,420 --> 00:12:17,320
bestimmten Ort bestimmen können, ganz gleich, wo er sich gerade befindet.

239
00:12:17,320 --> 00:12:20,340
Tatsächlich bemerken die klugen Köpfe unter Ihnen möglicherweise

240
00:12:20,340 --> 00:12:23,640
sogar einen Zusammenhang zwischen diesen Fragen und dem binären Zählen.

241
00:12:23,640 --> 00:12:26,153
Und wenn ja, lassen Sie mich noch einmal betonen:

242
00:12:26,153 --> 00:12:29,723
Halten Sie inne und versuchen Sie selbst, die Verbindung herzustellen,

243
00:12:29,723 --> 00:12:30,880
bevor ich sie verderbe.

244
00:12:30,880 --> 00:12:34,922
Wenn Sie sich fragen, was passiert, wenn ein Paritätsbit selbst betroffen ist,

245
00:12:34,922 --> 00:12:36,560
können Sie es einfach versuchen.

246
00:12:36,560 --> 00:12:40,050
Nehmen Sie sich einen Moment Zeit, um darüber nachzudenken,

247
00:12:40,050 --> 00:12:43,541
wie jeder Fehler in diesen vier Spezialbits genau wie jeder

248
00:12:43,541 --> 00:12:47,440
andere mit derselben Gruppe von vier Fragen aufgespürt werden kann.

249
00:12:47,440 --> 00:12:50,064
Das spielt keine Rolle, denn letzten Endes geht es darum,

250
00:12:50,064 --> 00:12:53,640
die Nachrichtenbits zu schützen, während die Fehlerkorrekturbits nur mitlaufen.

251
00:12:53,640 --> 00:12:59,260
Aber auch der Schutz dieser Teile fällt natürlich als Nebenprodukt aus dem Plan.

252
00:12:59,260 --> 00:13:02,380
Es könnte Ihnen auch Spaß machen, vorherzusehen, wie sich dies skalieren wird.

253
00:13:02,380 --> 00:13:07,630
Wenn wir beispielsweise einen Block mit einer Größe von 256 Bit verwenden,

254
00:13:07,630 --> 00:13:12,670
um einen Ort zu bestimmen, benötigen Sie nur acht Ja- oder Nein-Fragen,

255
00:13:12,670 --> 00:13:15,680
um binär zu einem bestimmten Ort zu suchen.

256
00:13:15,680 --> 00:13:20,600
Und denken Sie daran, dass bei jeder Frage nur ein einziges Bit aufgegeben werden muss,

257
00:13:20,600 --> 00:13:23,340
um die entsprechende Paritätsprüfung festzulegen.

258
00:13:23,340 --> 00:13:25,295
Einige von Ihnen haben es vielleicht schon gesehen,

259
00:13:25,295 --> 00:13:27,703
aber wir werden später über die systematische Methode sprechen,

260
00:13:27,703 --> 00:13:29,960
um diese Fragen in nur ein oder zwei Minuten herauszufinden.

261
00:13:29,960 --> 00:13:32,765
Hoffentlich reicht diese Skizze aus, um die Effizienz dessen,

262
00:13:32,765 --> 00:13:34,440
was wir hier entwickeln, zu würdigen.

263
00:13:34,440 --> 00:13:37,961
Das erste Ding kann, abgesehen von den acht hervorgehobenen Paritätsbits,

264
00:13:37,961 --> 00:13:41,720
alles sein, was Sie wollen, und jede gewünschte Nachricht oder Daten enthalten.

265
00:13:41,720 --> 00:13:45,750
Die 8 Bits sind in dem Sinne redundant, dass sie vollständig vom Rest

266
00:13:45,750 --> 00:13:50,818
der Nachricht bestimmt werden, aber es geht auf eine viel intelligentere Art und Weise,

267
00:13:50,818 --> 00:13:53,640
als einfach die Nachricht als Ganzes zu kopieren.

268
00:13:53,640 --> 00:13:56,225
Und dennoch wäre man mit so wenig Aufwand in der Lage,

269
00:13:56,225 --> 00:13:59,000
jeden einzelnen Bitfehler zu identifizieren und zu beheben.

270
00:13:59,000 --> 00:14:00,400
Naja fast.

271
00:14:00,400 --> 00:14:02,873
Okay, das einzige Problem besteht hier darin, dass,

272
00:14:02,873 --> 00:14:06,392
wenn keine der vier Paritätsprüfungen einen Fehler erkennt, was bedeutet,

273
00:14:06,392 --> 00:14:10,292
dass die speziell ausgewählten Teilmengen von 8 Bits alle gerade Paritäten haben,

274
00:14:10,292 --> 00:14:13,717
genau wie der Absender es beabsichtigt hat, dann bedeutet das entweder,

275
00:14:13,717 --> 00:14:17,760
dass überhaupt kein Fehler aufgetreten ist , oder es schränkt uns auf Position 0 ein.

276
00:14:17,760 --> 00:14:22,575
Sie sehen, mit vier Ja- oder Nein-Fragen haben wir 16 mögliche Ergebnisse für unsere

277
00:14:22,575 --> 00:14:25,918
Paritätsprüfungen, und das fühlt sich zunächst perfekt an,

278
00:14:25,918 --> 00:14:30,337
um eine von 16 Positionen im Block zu bestimmen, aber Sie müssen auch ein 17.

279
00:14:30,337 --> 00:14:33,000
Ergebnis mitteilen, das „Kein Fehler“. Zustand.

280
00:14:33,000 --> 00:14:37,860
Die Lösung hier ist eigentlich ziemlich einfach: Vergessen Sie einfach das 0. Bit ganz.

281
00:14:37,860 --> 00:14:41,003
Wenn wir also unsere vier Paritätsprüfungen durchführen und feststellen,

282
00:14:41,003 --> 00:14:44,320
dass sie alle gerade sind, bedeutet das eindeutig, dass kein Fehler vorliegt.

283
00:14:44,320 --> 00:14:47,488
Das bedeutet, dass wir nicht mit einem 16-Bit-Block arbeiten,

284
00:14:47,488 --> 00:14:50,707
sondern mit einem 15-Bit-Block, bei dem 11 der Bits frei sind,

285
00:14:50,707 --> 00:14:54,080
um eine Nachricht zu übertragen, und 4 davon der Redundanz dienen.

286
00:14:54,080 --> 00:14:56,608
Und damit haben wir jetzt das, was die Leute in

287
00:14:56,608 --> 00:14:59,400
der Branche als 15-11-Hamming-Code bezeichnen würden.

288
00:14:59,400 --> 00:15:01,351
Trotzdem ist es schön, eine Blockgröße zu haben,

289
00:15:01,351 --> 00:15:04,617
die einer sauberen Potenz von 2 entspricht, und es gibt eine clevere Möglichkeit,

290
00:15:04,617 --> 00:15:06,888
dieses 0-te Bit beizubehalten und es so dazu zu bringen,

291
00:15:06,888 --> 00:15:08,880
ein wenig zusätzliche Arbeit für uns zu erledigen.

292
00:15:08,880 --> 00:15:11,784
Wenn wir es als Paritätsbit im gesamten Block verwenden,

293
00:15:11,784 --> 00:15:16,320
können wir 2-Bit-Fehler tatsächlich erkennen, auch wenn wir sie nicht korrigieren können.

294
00:15:16,320 --> 00:15:17,440
So funktioniert das.

295
00:15:17,440 --> 00:15:20,412
Nachdem wir diese vier speziellen Fehlerkorrekturbits gesetzt haben,

296
00:15:20,412 --> 00:15:23,601
setzen wir das nullte, sodass die Parität des gesamten Blocks gerade ist,

297
00:15:23,601 --> 00:15:25,540
genau wie bei einer normalen Paritätsprüfung.

298
00:15:25,540 --> 00:15:28,354
Wenn es nun einen einzelnen Bitfehler gibt, wechselt die Parität

299
00:15:28,354 --> 00:15:31,168
des gesamten Blocks in den ungeraden Zustand, aber dank der vier

300
00:15:31,168 --> 00:15:33,940
fehlerkorrigierenden Prüfungen würden wir das trotzdem erkennen.

301
00:15:33,940 --> 00:15:38,884
Wenn es jedoch zwei Fehler gibt, wird die Gesamtparität wieder ausgeglichen,

302
00:15:38,884 --> 00:15:43,572
aber der Empfänger sieht aufgrund der vier Paritätsprüfungen immer noch,

303
00:15:43,572 --> 00:15:45,820
dass zumindest ein Fehler vorliegt.

304
00:15:45,820 --> 00:15:48,481
Wenn sie also feststellen, dass die Parität insgesamt gleichmäßig ist,

305
00:15:48,481 --> 00:15:50,768
aber bei den anderen Prüfungen etwas ungleich Null passiert,

306
00:15:50,768 --> 00:15:52,980
bedeutet das, dass mindestens zwei Fehler aufgetreten sind.

307
00:15:52,980 --> 00:15:54,420
Ist das nicht klug?

308
00:15:54,420 --> 00:15:57,252
Auch wenn wir diese 2-Bit-Fehler nicht korrigieren können,

309
00:15:57,252 --> 00:16:00,948
können wir sie einfach dadurch erkennen, dass wir das eine kleine lästige 0.

310
00:16:00,948 --> 00:16:02,340
Bit wieder in Betrieb nehmen.

311
00:16:02,340 --> 00:16:06,540
Das ist ziemlich normal und wird als erweiterter Hamming-Code bezeichnet.

312
00:16:06,540 --> 00:16:09,966
Technisch gesehen haben Sie jetzt eine vollständige Beschreibung dessen,

313
00:16:09,966 --> 00:16:13,580
was ein Hamming-Code bewirkt, zumindest für das Beispiel eines 16-Bit-Blocks.

314
00:16:13,580 --> 00:16:15,968
Ich denke jedoch, dass es für Sie befriedigender sein wird,

315
00:16:15,968 --> 00:16:18,874
Ihr Verständnis zu überprüfen und alles bis zu diesem Punkt zu festigen,

316
00:16:18,874 --> 00:16:21,980
indem Sie selbst ein vollständiges Beispiel von Anfang bis Ende durcharbeiten.

317
00:16:21,980 --> 00:16:25,100
Ich werde es jedoch mit Ihnen durchgehen, damit Sie es selbst überprüfen können.

318
00:16:25,100 --> 00:16:27,006
Um eine Nachricht einzurichten, unabhängig davon,

319
00:16:27,006 --> 00:16:28,836
ob es sich um eine wörtliche Nachricht handelt,

320
00:16:28,836 --> 00:16:31,048
die Sie über den Speicherplatz übersetzen, oder um Daten,

321
00:16:31,048 --> 00:16:33,183
die Sie über einen längeren Zeitraum speichern möchten,

322
00:16:33,183 --> 00:16:35,700
besteht der erste Schritt darin, sie in 11-Bit-Blöcke aufzuteilen.

323
00:16:35,700 --> 00:16:40,340
Jeder Block wird in einen fehlerresistenten 16-Bit-Block verpackt.

324
00:16:40,340 --> 00:16:43,740
Nehmen wir also dieses als Beispiel und arbeiten wir es tatsächlich aus.

325
00:16:43,740 --> 00:16:45,380
Machen Sie es tatsächlich!

326
00:16:45,380 --> 00:16:52,980
Lassen Sie uns innehalten und versuchen, diesen Block zusammenzusetzen.

327
00:16:52,980 --> 00:16:53,980
Okay, bist du bereit?

328
00:16:53,980 --> 00:16:57,798
Denken Sie daran, dass Position 0 zusammen mit den anderen Potenzen von

329
00:16:57,798 --> 00:17:01,457
2 für Fehlerkorrekturzwecke reserviert ist. Sie beginnen also damit,

330
00:17:01,457 --> 00:17:05,700
die Nachrichtenbits der Reihe nach an allen verbleibenden Stellen zu platzieren.

331
00:17:05,700 --> 00:17:09,698
Diese Gruppe muss über eine gerade Parität verfügen, was bereits der Fall ist.

332
00:17:09,698 --> 00:17:13,140
Daher sollten Sie das Paritätsbit in Position 1 auf 0 gesetzt haben.

333
00:17:13,140 --> 00:17:16,255
Die nächste Gruppe beginnt mit einer ungeraden Parität,

334
00:17:16,255 --> 00:17:19,260
daher sollten Sie ihr Paritätsbit auf 1 gesetzt haben.

335
00:17:19,260 --> 00:17:21,836
Die Gruppe danach beginnt mit einer ungeraden Parität,

336
00:17:21,836 --> 00:17:24,740
daher hätten Sie ihr Paritätsbit wiederum auf 1 setzen sollen.

337
00:17:24,740 --> 00:17:27,782
Und die letzte Gruppe hat auch eine ungerade Parität,

338
00:17:27,782 --> 00:17:31,500
was bedeutet, dass wir dieses Bit in Position 8 auf eine 1 setzen.

339
00:17:31,500 --> 00:17:36,714
Und als letzten Schritt hat der gesamte Block nun eine gerade Parität, was bedeutet,

340
00:17:36,714 --> 00:17:41,500
dass Sie das Bit Nummer 0, das übergeordnete Paritätsbit, auf 0 setzen können.

341
00:17:41,500 --> 00:17:45,115
Wenn dieser Block gesendet wird, ist die Parität der vier

342
00:17:45,115 --> 00:17:48,980
speziellen Teilmengen und des Blocks als Ganzes gerade oder 0.

343
00:17:48,980 --> 00:17:53,620
Lassen Sie uns im zweiten Teil der Übung die Rolle des Empfängers übernehmen.

344
00:17:53,620 --> 00:17:56,378
Das würde natürlich bedeuten, dass Sie diese Nachricht noch nicht kennen.

345
00:17:56,378 --> 00:17:59,248
Vielleicht haben einige von Ihnen sie auswendig gelernt, aber nehmen wir an,

346
00:17:59,248 --> 00:18:00,180
dass Sie es nicht wissen.

347
00:18:00,180 --> 00:18:05,940
Ich werde entweder 0, 1 oder 2 der Bits in diesem Block ändern und Sie dann bitten,

348
00:18:05,940 --> 00:18:08,340
herauszufinden, was ich getan habe.

349
00:18:08,340 --> 00:18:13,460
Halten Sie also noch einmal inne und versuchen Sie, es herauszufinden.

350
00:18:13,460 --> 00:18:21,357
Okay, Sie als Empfänger überprüfen jetzt die erste Paritätsgruppe und können sehen,

351
00:18:21,357 --> 00:18:29,820
dass sie gerade ist, sodass jeder vorhandene Fehler in einer geraden Spalte stehen müsste.

352
00:18:29,820 --> 00:18:33,999
Bei der nächsten Prüfung erhalten wir eine ungerade Zahl, die uns sagt,

353
00:18:33,999 --> 00:18:38,760
dass mindestens ein Fehler vorliegt, und uns auf diese bestimmte Spalte eingrenzt.

354
00:18:38,760 --> 00:18:42,900
Die dritte Prüfung ist ausgeglichen und schränkt die Möglichkeiten noch weiter ein.

355
00:18:42,900 --> 00:18:45,766
Und die letzte Paritätsprüfung ist seltsam und sagt uns,

356
00:18:45,766 --> 00:18:49,889
dass irgendwo unten ein Fehler vorliegt, der sich, wie wir jetzt erkennen können,

357
00:18:49,889 --> 00:18:51,700
an Position Nummer 10 befinden muss.

358
00:18:51,700 --> 00:18:54,807
Darüber hinaus ist die Parität des gesamten Blocks ungerade,

359
00:18:54,807 --> 00:18:58,220
was uns die Gewissheit gibt, dass es einen Flip und nicht zwei gab.

360
00:18:58,220 --> 00:19:01,600
Bei drei oder mehr sind alle Wetten ungültig.

361
00:19:01,600 --> 00:19:05,774
Nach der Korrektur von Bit Nummer 10 erhalten wir durch Herausziehen der 11 Bits,

362
00:19:05,774 --> 00:19:09,389
die nicht zur Korrektur verwendet wurden, den relevanten Abschnitt der

363
00:19:09,389 --> 00:19:12,850
ursprünglichen Nachricht, der, wenn man zurückspult und vergleicht,

364
00:19:12,850 --> 00:19:16,160
tatsächlich genau das ist, womit wir das Beispiel begonnen haben.

365
00:19:16,160 --> 00:19:19,724
Und da Sie nun wissen, wie man das alles von Hand macht, möchte ich Ihnen zeigen,

366
00:19:19,724 --> 00:19:23,635
wie Sie den Kernteil dieser gesamten Logik mit einer einzigen Zeile Python-Code ausführen

367
00:19:23,635 --> 00:19:23,940
können.

368
00:19:23,940 --> 00:19:26,453
Sehen Sie, was ich Ihnen noch nicht gesagt habe, ist,

369
00:19:26,453 --> 00:19:29,479
wie elegant dieser Algorithmus wirklich ist, wie einfach es ist,

370
00:19:29,479 --> 00:19:32,877
eine Maschine dazu zu bringen, auf die Position eines Fehlers zu zeigen,

371
00:19:32,877 --> 00:19:36,694
wie man ihn systematisch skaliert und wie wir alles einordnen können Dies ist ein

372
00:19:36,694 --> 00:19:39,580
einziger Vorgang und nicht mehrere separate Paritätsprüfungen.

373
00:19:39,580 --> 00:19:39,580
Um zu sehen, was ich meine, kommen Sie zu Teil 2.

