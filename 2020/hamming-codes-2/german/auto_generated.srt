1
00:00:00,000 --> 00:00:05,488
Haben Sie sich jemals gefragt, wie es möglich ist, eine CD oder DVD zu

2
00:00:05,488 --> 00:00:10,900
zerkratzen und trotzdem den darauf gespeicherten Inhalt wiederzugeben?

3
00:00:10,900 --> 00:00:15,186
Der Kratzer wirkt sich tatsächlich auf die Einsen und Nullen auf der Festplatte aus,

4
00:00:15,186 --> 00:00:19,574
sodass andere Daten als die gespeicherten Daten ausgelesen werden. Wenn die Festplatte

5
00:00:19,574 --> 00:00:23,861
jedoch nicht wirklich zerkratzt wird, werden die ausgelesenen Bits in genau dieselbe

6
00:00:23,861 --> 00:00:28,400
Datei dekodiert, die darauf kodiert wurde, a Bit für Bit kopiert, trotz all dieser Fehler.

7
00:00:28,400 --> 00:00:32,675
Es gibt eine ganze Reihe mathematischer Raffinessen, die es uns ermöglichen,

8
00:00:32,675 --> 00:00:36,840
Daten fehlersicher zu speichern und, was noch wichtiger ist, zu übertragen.

9
00:00:36,840 --> 00:00:39,346
Na gut, eigentlich braucht es gar nicht so viel

10
00:00:39,346 --> 00:00:42,480
Cleverness, um einen Weg zu finden, dies zu bewerkstelligen.

11
00:00:42,480 --> 00:00:46,749
Jede Datei, sei es ein Video, ein Ton oder ein Text, ein Code, ein Bild

12
00:00:46,749 --> 00:00:50,960
oder was auch immer, ist letztendlich eine Folge von Einsen und Nullen.

13
00:00:50,960 --> 00:00:54,019
Und eine einfache Strategie zur Korrektur jedes

14
00:00:54,019 --> 00:00:57,780
umgedrehten Bits wäre, drei Kopien jedes Bits zu speichern.

15
00:00:57,780 --> 00:01:02,243
Dann könnte die Maschine, die diese Datei liest, diese drei Kopien

16
00:01:02,243 --> 00:01:07,440
vergleichen und immer die besten 2 von 3 nehmen, wenn es eine Diskrepanz gibt.

17
00:01:07,440 --> 00:01:11,560
Das bedeutet jedoch, dass zwei Drittel Ihres Platzes für Redundanz genutzt werden.

18
00:01:11,560 --> 00:01:14,980
Und selbst dann gibt es trotz all des verschenkten Platzes keine sichere

19
00:01:14,980 --> 00:01:18,120
Garantie dafür, was passiert, wenn mehr als ein Bit umgedreht wird.

20
00:01:18,120 --> 00:01:21,564
Die viel interessantere Frage ist, wie man es so gestalten kann, dass Fehler

21
00:01:21,564 --> 00:01:24,740
korrigiert werden können und dabei möglichst wenig Platz verloren geht.

22
00:01:24,740 --> 00:01:28,934
Mit der Methode, die Sie in diesem Video kennenlernen, könnten Sie beispielsweise

23
00:01:28,934 --> 00:01:32,975
Ihre Daten in 256-Bit-Blöcken speichern, wobei jeder Block 9 Bits verwendet, 9!

24
00:01:32,975 --> 00:01:36,822
um als eine Art Redundanz zu fungieren, und die anderen 247 Bits sind

25
00:01:36,822 --> 00:01:41,000
frei, um jede gewünschte aussagekräftige Nachricht oder Daten zu übertragen.

26
00:01:41,000 --> 00:01:43,962
Und es wird immer noch so sein, dass eine Maschine, wenn hier irgendein

27
00:01:43,962 --> 00:01:46,967
Bit umgedreht wird, allein durch einen Blick auf diesen Block und nichts

28
00:01:46,967 --> 00:01:49,888
weiter in der Lage sein wird, zu erkennen, dass ein Fehler aufgetreten

29
00:01:49,888 --> 00:01:53,140
ist und wo er sich genau befand, sodass sie weiß, wie sie ihn korrigieren kann.

30
00:01:53,140 --> 00:01:55,540
Und ehrlich gesagt, das fühlt sich wie Magie an.

31
00:01:55,540 --> 00:01:57,935
Und wenn bei diesem speziellen Schema zwei Bits umgedreht

32
00:01:57,935 --> 00:02:00,536
werden, kann die Maschine zumindest erkennen, dass zwei Fehler

33
00:02:00,536 --> 00:02:03,180
aufgetreten sind, weiß jedoch nicht, wie sie diese beheben kann.

34
00:02:03,180 --> 00:02:05,709
Wir werden etwas später darüber sprechen, wie dies

35
00:02:05,709 --> 00:02:08,140
für Blöcke unterschiedlicher Größe skaliert wird.

36
00:02:08,140 --> 00:02:10,937
Methoden, mit denen Sie solche Fehler korrigieren können,

37
00:02:10,937 --> 00:02:13,880
werden vernünftigerweise als Fehlerkorrekturcodes bezeichnet.

38
00:02:13,880 --> 00:02:16,829
Über den größten Teil des letzten Jahrhunderts hinweg war dieses

39
00:02:16,829 --> 00:02:19,960
Gebiet eine wirklich reichhaltige Quelle überraschend tiefgreifender

40
00:02:19,960 --> 00:02:23,000
Mathematik, die in die Geräte einfließt, die wir täglich verwenden.

41
00:02:23,000 --> 00:02:26,176
Ziel ist es, Ihnen ein sehr umfassendes Verständnis eines der

42
00:02:26,176 --> 00:02:29,660
frühesten Beispiele zu vermitteln, das als Hamming-Code bekannt ist.

43
00:02:29,660 --> 00:02:33,128
Übrigens geht es mir beim Aufbau dieses Videos weniger darum, es so

44
00:02:33,128 --> 00:02:36,802
direkt wie möglich zu erklären, als vielmehr darum, Sie dazu anzuregen,

45
00:02:36,802 --> 00:02:40,220
es selbst zu erfinden, mit ein wenig sanfter Anleitung hier und da.

46
00:02:40,220 --> 00:02:42,645
Wenn Sie also das Gefühl haben, irgendwann zu sehen, wohin es führt,

47
00:02:42,645 --> 00:02:44,824
nehmen Sie sich diesen Moment Zeit, um innezuhalten und aktiv

48
00:02:44,824 --> 00:02:47,180
vorherzusagen, wie der Plan aussehen wird, bevor ich es Ihnen sage.

49
00:02:47,180 --> 00:02:51,200
Wenn Sie außerdem möchten, dass Ihr Verständnis bis auf die Hardware-Ebene reicht, hat

50
00:02:51,200 --> 00:02:55,175
Ben Eater in Verbindung mit diesem Video ein Video erstellt, das Ihnen zeigt, wie Sie

51
00:02:55,175 --> 00:02:59,335
Hamming-Codes tatsächlich auf Steckbrettern implementieren, was äußerst zufriedenstellend

52
00:02:59,335 --> 00:02:59,520
ist.

53
00:02:59,520 --> 00:03:02,962
Sie sollten wissen, dass Hamming-Codes nicht so häufig verwendet werden wie

54
00:03:02,962 --> 00:03:06,630
modernere Codes wie der Reed-Solomon-Algorithmus, aber der Kontrast zwischen der

55
00:03:06,630 --> 00:03:09,982
Unmöglichkeit, die sich diese Aufgabe am Anfang anfühlt, und der völligen

56
00:03:09,982 --> 00:03:13,651
Vernünftigkeit, die sie einmal erscheint, hat etwas Magisches Sie erfahren etwas

57
00:03:13,651 --> 00:03:14,240
über Hamming.

58
00:03:14,240 --> 00:03:18,602
Das Grundprinzip der Fehlerkorrektur besteht darin, dass in einem riesigen Bereich

59
00:03:18,602 --> 00:03:22,860
aller möglichen Nachrichten nur einige Teilmengen als gültige Nachrichten gelten.

60
00:03:22,860 --> 00:03:29,100
Denken Sie als Analogie an richtig geschriebene Wörter und falsch geschriebene Wörter.

61
00:03:29,100 --> 00:03:32,208
Immer wenn eine gültige Nachricht geändert wird, ist der Empfänger

62
00:03:32,208 --> 00:03:35,271
dafür verantwortlich, das, was er sieht, an den nächsten gültigen

63
00:03:35,271 --> 00:03:38,380
Nachbarn zu korrigieren, wie es bei einem Tippfehler der Fall wäre.

64
00:03:38,380 --> 00:03:42,225
Die Entwicklung eines konkreten Algorithmus zur effizienten

65
00:03:42,225 --> 00:03:47,160
Kategorisierung solcher Nachrichten erfordert jedoch eine gewisse Cleverness.

66
00:03:47,160 --> 00:03:50,595
Die Geschichte beginnt in den 1940er Jahren, als der junge Richard Hamming

67
00:03:50,595 --> 00:03:54,030
für Bell Labs arbeitete und bei einigen seiner Arbeiten einen sehr großen,

68
00:03:54,030 --> 00:03:57,420
teuren Lochkartencomputer benutzte, zu dem er nur begrenzten Zugang hatte.

69
00:03:57,420 --> 00:04:00,370
Und die Programme, die er ständig durchführte, scheiterten immer

70
00:04:00,370 --> 00:04:03,140
wieder, weil hin und wieder ein Teil falsch verstanden wurde.

71
00:04:03,140 --> 00:04:06,162
Da Frustration der Schmelztiegel der Erfindungen war, hatte er

72
00:04:06,162 --> 00:04:09,280
die Nase voll und erfand den weltweit ersten Fehlerkorrekturcode.

73
00:04:09,280 --> 00:04:12,826
Es gibt viele verschiedene Möglichkeiten, Hamming-Codes zu formulieren,

74
00:04:12,826 --> 00:04:16,620
aber zunächst werden wir es so durchgehen, wie Hamming selbst darüber dachte.

75
00:04:16,620 --> 00:04:21,400
Nehmen wir ein einfaches, aber nicht zu einfaches Beispiel: einen Block mit 16 Bit.

76
00:04:21,400 --> 00:04:25,700
Wir nummerieren die Positionen dieser Bits von 0 bis 15.

77
00:04:25,700 --> 00:04:29,864
Die eigentlichen Daten, die wir speichern möchten, werden nur 12 dieser Bits

78
00:04:29,864 --> 00:04:33,920
ausmachen, während 4 der Positionen als eine Art Redundanz reserviert sind.

79
00:04:33,920 --> 00:04:37,060
Das Wort „redundant“ bedeutet hier nicht einfach „kopieren“, schließlich

80
00:04:37,060 --> 00:04:40,200
geben uns diese 4 Bits nicht genug Platz, um die Daten blind zu kopieren.

81
00:04:40,200 --> 00:04:44,470
Stattdessen müssen sie eine viel differenziertere und intelligentere Art der Redundanz

82
00:04:44,470 --> 00:04:48,740
sein, die keine neuen Informationen hinzufügt, sondern die Widerstandsfähigkeit erhöht.

83
00:04:48,740 --> 00:04:52,350
Man könnte erwarten, dass diese 4 besonderen Teile schön verpackt zusammenkommen,

84
00:04:52,350 --> 00:04:56,093
vielleicht am Ende oder so ähnlich, aber wie Sie sehen werden, ermöglicht es, sie in

85
00:04:56,093 --> 00:04:59,923
Positionen zu platzieren, die Zweierpotenzen sind, am Ende etwas wirklich Elegantes zu

86
00:04:59,923 --> 00:05:00,320
schaffen.

87
00:05:00,320 --> 00:05:02,725
Es könnte Ihnen auch einen kleinen Hinweis darauf

88
00:05:02,725 --> 00:05:05,420
geben, wie sich dies auf größere Blöcke skalieren lässt.

89
00:05:05,420 --> 00:05:08,387
Auch technisch gesehen sind es am Ende nur 11 Datenbits. Sie werden

90
00:05:08,387 --> 00:05:11,486
feststellen, dass es eine leichte Nuance für das gibt, was an Position

91
00:05:11,486 --> 00:05:14,280
0 passiert, aber machen Sie sich darüber im Moment keine Sorgen.

92
00:05:14,280 --> 00:05:18,109
Wie bei jedem Fehlerkorrekturalgorithmus sind auch hier zwei Spieler beteiligt: ein

93
00:05:18,109 --> 00:05:22,211
Sender, der für das Setzen dieser vier Spezialbits verantwortlich ist, und ein Empfänger,

94
00:05:22,211 --> 00:05:25,812
der dafür verantwortlich ist, eine Art Prüfung durchzuführen und die Fehler zu

95
00:05:25,812 --> 00:05:26,360
korrigieren.

96
00:05:26,360 --> 00:05:29,440
Natürlich beziehen sich die Wörter „Sender“ und „Empfänger“ in Wirklichkeit

97
00:05:29,440 --> 00:05:32,561
auf Maschinen oder Software, die alle Prüfungen durchführen, und der Begriff

98
00:05:32,561 --> 00:05:35,480
„Nachricht“ ist sehr weit gefasst und umfasst Dinge wie die Speicherung.

99
00:05:35,480 --> 00:05:39,194
Schließlich ist das Speichern von Daten dasselbe wie das Versenden einer Nachricht

100
00:05:39,194 --> 00:05:42,640
nur von der Vergangenheit in die Zukunft und nicht von einem Ort zum anderen.

101
00:05:42,640 --> 00:05:46,339
Das ist also der Aufbau, aber bevor wir uns darauf einlassen können, müssen wir

102
00:05:46,339 --> 00:05:49,993
über eine verwandte Idee sprechen, die Hamming zum Zeitpunkt seiner Entdeckung

103
00:05:49,993 --> 00:05:53,785
noch frisch im Kopf hatte: eine Methode, mit der man einzelne Bitfehler erkennen,

104
00:05:53,785 --> 00:05:57,300
aber nicht korrigieren kann, wie man weiß im Geschäft als Paritätskontrolle.

105
00:05:57,300 --> 00:06:00,914
Bei einer Paritätsprüfung trennen wir nur ein einzelnes Bit heraus, für dessen

106
00:06:00,914 --> 00:06:04,940
Abstimmung der Absender verantwortlich ist, und der Rest kann eine Nachricht übertragen.

107
00:06:04,940 --> 00:06:08,669
Die einzige Aufgabe dieses speziellen Bits besteht darin, sicherzustellen,

108
00:06:08,669 --> 00:06:12,100
dass die Gesamtzahl der Einsen in der Nachricht eine gerade Zahl ist.

109
00:06:12,100 --> 00:06:16,380
Im Moment beträgt die Gesamtzahl der Einsen beispielsweise 7, das ist ungerade, daher

110
00:06:16,380 --> 00:06:20,611
muss der Absender dieses spezielle Bit auf eine 1 umdrehen, um die Zählung gerade zu

111
00:06:20,611 --> 00:06:20,960
machen.

112
00:06:20,960 --> 00:06:24,193
Hätte der Block jedoch bereits mit einer geraden Anzahl von

113
00:06:24,193 --> 00:06:27,480
Einsen begonnen, wäre dieses Sonderbit auf 0 gehalten worden.

114
00:06:27,480 --> 00:06:30,953
Das ist ziemlich einfach, täuschend einfach, aber es ist eine unglaublich

115
00:06:30,953 --> 00:06:34,474
elegante Möglichkeit, die Idee der Veränderung irgendwo in einer Nachricht

116
00:06:34,474 --> 00:06:37,760
zu destillieren, um sie in einer einzigen Information widerzuspiegeln.

117
00:06:37,760 --> 00:06:42,887
Beachten Sie, dass sich die Gesamtzahl der Einsen von gerade auf ungerade ändert,

118
00:06:42,887 --> 00:06:48,140
wenn ein Bit dieser Nachricht umgedreht wird, entweder von 0 auf 1 oder von 1 auf 0.

119
00:06:48,140 --> 00:06:51,784
Wenn Sie also der Empfänger sind, sich diese Nachricht ansehen und eine ungerade Anzahl

120
00:06:51,784 --> 00:06:55,304
von Einsen sehen, können Sie mit Sicherheit wissen, dass ein Fehler aufgetreten ist,

121
00:06:55,304 --> 00:06:58,700
auch wenn Sie möglicherweise keine Ahnung haben, wo dieser Fehler aufgetreten ist.

122
00:06:58,700 --> 00:07:01,792
Ob eine Gruppe von Bits eine gerade oder ungerade Anzahl

123
00:07:01,792 --> 00:07:04,940
von Einsen hat, wird im Fachjargon als Parität bezeichnet.

124
00:07:04,940 --> 00:07:08,088
Sie könnten auch Zahlen verwenden und sagen, dass die Parität 0 oder 1 ist,

125
00:07:08,088 --> 00:07:11,320
was normalerweise hilfreicher ist, wenn Sie anfangen, mit der Idee zu rechnen.

126
00:07:11,320 --> 00:07:14,319
Und dieses spezielle Bit, das der Absender zur

127
00:07:14,319 --> 00:07:18,020
Steuerung der Parität verwendet, wird Paritätsbit genannt.

128
00:07:18,020 --> 00:07:20,819
Und eigentlich sollten wir uns darüber im Klaren sein: Wenn der Empfänger

129
00:07:20,819 --> 00:07:23,808
eine ungerade Parität sieht, bedeutet das nicht unbedingt, dass nur ein Fehler

130
00:07:23,808 --> 00:07:26,646
aufgetreten ist, es könnten auch 3 Fehler oder 5 oder eine andere ungerade

131
00:07:26,646 --> 00:07:29,560
Zahl gewesen sein, aber er kann es mit Sicherheit wissen dass es nicht 0 war.

132
00:07:29,560 --> 00:07:32,912
Wenn es andererseits zwei Fehler oder eine gerade Anzahl von Fehlern

133
00:07:32,912 --> 00:07:36,411
gegeben hätte, wäre die endgültige Anzahl von Einsen immer noch gerade,

134
00:07:36,411 --> 00:07:39,910
sodass der Empfänger nicht vollständig darauf vertrauen kann, dass eine

135
00:07:39,910 --> 00:07:43,360
gerade Anzahl zwangsläufig bedeutet, dass die Nachricht fehlerfrei ist.

136
00:07:43,360 --> 00:07:46,678
Sie könnten sich darüber beschweren, dass eine Nachricht, die durch nur 2-Bit-Flips

137
00:07:46,678 --> 00:07:49,760
durcheinander gebracht wird, ziemlich schwach ist, und Sie haben völlig Recht.

138
00:07:49,760 --> 00:07:52,852
Bedenken Sie jedoch, dass es keine Methode zur Fehlererkennung oder

139
00:07:52,852 --> 00:07:56,263
-korrektur gibt, die Ihnen hundertprozentige Sicherheit geben könnte, dass

140
00:07:56,263 --> 00:07:59,720
die Nachricht, die Sie erhalten, die ist, die der Absender beabsichtigt hat.

141
00:07:59,720 --> 00:08:02,666
Schließlich könnte genügend zufälliges Rauschen immer eine gültige

142
00:08:02,666 --> 00:08:05,920
Nachricht durch reinen Zufall in eine andere gültige Nachricht verwandeln.

143
00:08:05,920 --> 00:08:09,353
Stattdessen besteht das Ziel darin, ein Schema zu entwickeln, das

144
00:08:09,353 --> 00:08:12,682
bis zu einer bestimmten maximalen Fehleranzahl robust ist, oder

145
00:08:12,682 --> 00:08:16,480
vielleicht die Wahrscheinlichkeit eines solchen Fehlalarms zu verringern.

146
00:08:16,480 --> 00:08:20,302
Paritätsprüfungen allein sind ziemlich schwach, aber indem sie die Idee

147
00:08:20,302 --> 00:08:24,124
der Änderung einer gesamten Nachricht auf ein einzelnes Bit reduzieren,

148
00:08:24,124 --> 00:08:28,000
geben sie uns einen leistungsstarken Baustein für ausgefeiltere Schemata.

149
00:08:28,000 --> 00:08:31,677
Als Hamming beispielsweise nach einer Möglichkeit suchte, herauszufinden, wo ein

150
00:08:31,677 --> 00:08:35,490
Fehler aufgetreten ist und nicht nur, dass er aufgetreten ist, war seine wichtigste

151
00:08:35,490 --> 00:08:39,213
Erkenntnis, dass man fragen kann, wenn man einige Paritätsprüfungen nicht auf die

152
00:08:39,213 --> 00:08:43,026
gesamte Nachricht, sondern auf bestimmte sorgfältig ausgewählte Teilmengen anwendet

153
00:08:43,026 --> 00:08:46,840
eine verfeinerte Reihe von Fragen, die den Ort eines einzelnen Bitfehlers bestimmen.

154
00:08:46,840 --> 00:08:50,526
Das Gesamtgefühl ist ein bisschen so, als würde man ein Spiel mit 20 Fragen spielen,

155
00:08:50,526 --> 00:08:54,300
bei dem Ja- oder Nein-Fragen gestellt werden, die den Raum der Möglichkeiten halbieren.

156
00:08:54,300 --> 00:08:57,228
Nehmen wir zum Beispiel an, wir führen eine Paritätsprüfung

157
00:08:57,228 --> 00:09:00,400
nur für diese 8 Bits durch, also alle ungeradzahligen Positionen.

158
00:09:00,400 --> 00:09:03,367
Wenn dann ein Fehler erkannt wird, erhält der Empfänger etwas

159
00:09:03,367 --> 00:09:06,383
mehr Informationen darüber, wo genau sich der Fehler befindet,

160
00:09:06,383 --> 00:09:09,160
nämlich dass er sich an einer ungeraden Position befindet.

161
00:09:09,160 --> 00:09:13,316
Wenn unter diesen 8 Bits kein Fehler erkannt wird, bedeutet das entweder, dass überhaupt

162
00:09:13,316 --> 00:09:17,240
kein Fehler vorliegt, oder dass er sich irgendwo in den geraden Positionen befindet.

163
00:09:17,240 --> 00:09:21,291
Man könnte denken, dass die Beschränkung einer Paritätsprüfung auf die Hälfte der Bits

164
00:09:21,291 --> 00:09:24,970
sie weniger effektiv macht, aber wenn sie in Verbindung mit anderen sorgfältig

165
00:09:24,970 --> 00:09:28,835
ausgewählten Prüfungen durchgeführt wird, ergibt sie uns kontraintuitiv etwas viel

166
00:09:28,835 --> 00:09:29,720
Leistungsfähigeres.

167
00:09:29,720 --> 00:09:33,611
Um diese Paritätsprüfung tatsächlich einzurichten, müssen Sie bedenken, dass ein

168
00:09:33,611 --> 00:09:37,600
spezielles Bit reserviert werden muss, das die Parität der gesamten Gruppe steuert.

169
00:09:37,600 --> 00:09:39,920
Hier wählen wir einfach Position 1.

170
00:09:39,920 --> 00:09:44,237
Im gezeigten Beispiel ist die Parität dieser 8 Bits derzeit ungerade, sodass der Absender

171
00:09:44,237 --> 00:09:48,220
dafür verantwortlich ist, dieses Paritätsbit umzuschalten, und jetzt ist es gerade.

172
00:09:48,220 --> 00:09:51,040
Dies ist nur eine von vier Paritätsprüfungen, die wir durchführen werden.

173
00:09:51,040 --> 00:09:54,007
Das zweite Häkchen gehört zu den 8 Bits in der rechten Hälfte

174
00:09:54,007 --> 00:09:56,880
des Rasters, zumindest so, wie wir es hier gezeichnet haben.

175
00:09:56,880 --> 00:10:00,289
Dieses Mal verwenden wir möglicherweise Position 2 als Paritätsbit,

176
00:10:00,289 --> 00:10:03,850
sodass diese 8 Bits bereits eine gerade Parität haben und der Absender

177
00:10:03,850 --> 00:10:07,160
beruhigt sein kann, wenn er dieses Bit Nummer 2 unverändert lässt.

178
00:10:07,160 --> 00:10:10,276
Wenn der Empfänger andererseits die Parität dieser Gruppe überprüft

179
00:10:10,276 --> 00:10:13,210
und feststellt, dass sie ungerade ist, weiß er, dass der Fehler

180
00:10:13,210 --> 00:10:15,960
irgendwo zwischen diesen 8 Bits auf der rechten Seite liegt.

181
00:10:15,960 --> 00:10:18,637
Andernfalls liegt entweder kein Fehler vor oder

182
00:10:18,637 --> 00:10:21,260
der Fehler liegt irgendwo in der linken Hälfte.

183
00:10:21,260 --> 00:10:24,027
Oder ich denke, es könnte zwei Fehler gegeben haben, aber im Moment

184
00:10:24,027 --> 00:10:27,080
gehen wir davon aus, dass es höchstens einen Fehler im gesamten Block gibt.

185
00:10:27,080 --> 00:10:29,160
Darüber hinaus brechen die Dinge völlig zusammen.

186
00:10:29,160 --> 00:10:32,408
Bevor wir uns die nächsten beiden Prüfungen ansehen, nehmen Sie sich einen Moment Zeit

187
00:10:32,408 --> 00:10:35,469
und überlegen Sie, was uns diese ersten beiden ermöglichen, wenn Sie sie zusammen

188
00:10:35,469 --> 00:10:35,880
betrachten.

189
00:10:35,880 --> 00:10:38,177
Nehmen wir an, Sie entdecken einen Fehler in den

190
00:10:38,177 --> 00:10:40,240
ungeraden Spalten und in der rechten Hälfte.

191
00:10:40,240 --> 00:10:43,940
Das bedeutet zwangsläufig, dass der Fehler irgendwo in der letzten Spalte liegt.

192
00:10:43,940 --> 00:10:47,358
Wenn in der ungeraden Spalte kein Fehler aufgetreten ist, in der rechten Hälfte

193
00:10:47,358 --> 00:10:50,520
jedoch einer, bedeutet dies, dass es sich um die vorletzte Spalte handelt.

194
00:10:50,520 --> 00:10:53,351
Wenn in den ungeraden Spalten, aber nicht in der rechten Hälfte ein Fehler

195
00:10:53,351 --> 00:10:56,560
auftritt, wissen Sie ebenfalls, dass er sich irgendwo in der zweiten Spalte befindet.

196
00:10:56,560 --> 00:11:00,227
Und wenn keine dieser beiden Paritätsprüfungen etwas erkennt, bedeutet dies, dass

197
00:11:00,227 --> 00:11:03,760
der einzige Ort, an dem ein Fehler auftreten könnte, die Spalte ganz links ist.

198
00:11:03,760 --> 00:11:06,480
Es könnte aber auch einfach bedeuten, dass überhaupt kein Fehler vorliegt.

199
00:11:06,480 --> 00:11:09,033
Das ist alles eine ziemlich umständliche Art zu sagen, dass

200
00:11:09,033 --> 00:11:11,800
wir mit zwei Paritätsprüfungen die Spalte genau bestimmen können.

201
00:11:11,800 --> 00:11:14,000
Von hier aus können Sie wahrscheinlich erraten, was folgt.

202
00:11:14,000 --> 00:11:16,240
Wir machen im Grunde das Gleiche, außer für die Zeilen.

203
00:11:16,240 --> 00:11:18,382
In den ungeraden Zeilen wird eine Paritätsprüfung

204
00:11:18,382 --> 00:11:21,040
durchgeführt, wobei Position 4 als Paritätsbit verwendet wird.

205
00:11:21,040 --> 00:11:23,653
In diesem Beispiel hat diese Gruppe also bereits

206
00:11:23,653 --> 00:11:26,480
eine gerade Parität, sodass Bit 4 auf 0 gesetzt wäre.

207
00:11:26,480 --> 00:11:29,309
Und schließlich gibt es eine Paritätsprüfung in den unteren

208
00:11:29,309 --> 00:11:32,280
beiden Zeilen, wobei Position 8 als Paritätsbit verwendet wird.

209
00:11:32,280 --> 00:11:34,957
In diesem Fall sieht es so aus, als ob der Absender dieses Bit 8

210
00:11:34,957 --> 00:11:37,840
aktivieren muss, um der Gruppe eine gleichmäßige Parität zu verleihen.

211
00:11:37,840 --> 00:11:40,250
So wie wir mit den ersten beiden Prüfungen die Spalte festlegen

212
00:11:40,250 --> 00:11:43,000
können, können Sie mit den nächsten beiden Prüfungen die Zeile festlegen.

213
00:11:43,000 --> 00:11:45,484
Stellen Sie sich als Beispiel vor, dass während der

214
00:11:45,484 --> 00:11:48,400
Übertragung ein Fehler beispielsweise an Position 3 auftritt.

215
00:11:48,400 --> 00:11:52,271
Nun, das betrifft die erste Paritätsgruppe und auch die zweite Paritätsgruppe,

216
00:11:52,271 --> 00:11:56,340
sodass der Empfänger weiß, dass irgendwo in der rechten Spalte ein Fehler vorliegt.

217
00:11:56,340 --> 00:12:01,380
Aber es hat keine Auswirkungen auf die dritte Gruppe und auch nicht auf die vierte Gruppe.

218
00:12:01,380 --> 00:12:04,828
Und so kann der Empfänger den Fehler bis zur ersten Zeile, was

219
00:12:04,828 --> 00:12:08,660
zwangsläufig Position 3 bedeutet, lokalisieren und den Fehler beheben.

220
00:12:08,660 --> 00:12:11,639
Nehmen Sie sich vielleicht einen Moment Zeit, um sich davon zu überzeugen,

221
00:12:11,639 --> 00:12:14,420
dass Sie mit den Antworten auf diese vier Fragen wirklich immer einen

222
00:12:14,420 --> 00:12:17,320
bestimmten Ort bestimmen können, ganz gleich, wo er sich gerade befindet.

223
00:12:17,320 --> 00:12:20,340
Tatsächlich bemerken die klugen Köpfe unter Ihnen möglicherweise

224
00:12:20,340 --> 00:12:23,640
sogar einen Zusammenhang zwischen diesen Fragen und dem binären Zählen.

225
00:12:23,640 --> 00:12:27,159
Und wenn ja, lassen Sie mich noch einmal betonen: Halten Sie inne und

226
00:12:27,159 --> 00:12:30,880
versuchen Sie selbst, die Verbindung herzustellen, bevor ich sie verderbe.

227
00:12:30,880 --> 00:12:33,796
Wenn Sie sich fragen, was passiert, wenn ein Paritätsbit

228
00:12:33,796 --> 00:12:36,560
selbst betroffen ist, können Sie es einfach versuchen.

229
00:12:36,560 --> 00:12:40,050
Nehmen Sie sich einen Moment Zeit, um darüber nachzudenken,

230
00:12:40,050 --> 00:12:43,541
wie jeder Fehler in diesen vier Spezialbits genau wie jeder

231
00:12:43,541 --> 00:12:47,440
andere mit derselben Gruppe von vier Fragen aufgespürt werden kann.

232
00:12:47,440 --> 00:12:50,245
Das spielt keine Rolle, denn letzten Endes geht es darum, die

233
00:12:50,245 --> 00:12:53,640
Nachrichtenbits zu schützen, während die Fehlerkorrekturbits nur mitlaufen.

234
00:12:53,640 --> 00:12:59,260
Aber auch der Schutz dieser Teile fällt natürlich als Nebenprodukt aus dem Plan.

235
00:12:59,260 --> 00:13:02,380
Es könnte Ihnen auch Spaß machen, vorherzusehen, wie sich dies skalieren wird.

236
00:13:02,380 --> 00:13:06,860
Wenn wir beispielsweise einen Block mit einer Größe von 256 Bit

237
00:13:06,860 --> 00:13:11,130
verwenden, um einen Ort zu bestimmen, benötigen Sie nur acht

238
00:13:11,130 --> 00:13:15,680
Ja- oder Nein-Fragen, um binär zu einem bestimmten Ort zu suchen.

239
00:13:15,680 --> 00:13:19,258
Und denken Sie daran, dass bei jeder Frage nur ein einziges Bit

240
00:13:19,258 --> 00:13:23,340
aufgegeben werden muss, um die entsprechende Paritätsprüfung festzulegen.

241
00:13:23,340 --> 00:13:26,499
Einige von Ihnen haben es vielleicht schon gesehen, aber wir werden später über die

242
00:13:26,499 --> 00:13:29,395
systematische Methode sprechen, um diese Fragen in nur ein oder zwei Minuten

243
00:13:29,395 --> 00:13:29,960
herauszufinden.

244
00:13:29,960 --> 00:13:32,403
Hoffentlich reicht diese Skizze aus, um die Effizienz

245
00:13:32,403 --> 00:13:34,440
dessen, was wir hier entwickeln, zu würdigen.

246
00:13:34,440 --> 00:13:37,961
Das erste Ding kann, abgesehen von den acht hervorgehobenen Paritätsbits,

247
00:13:37,961 --> 00:13:41,720
alles sein, was Sie wollen, und jede gewünschte Nachricht oder Daten enthalten.

248
00:13:41,720 --> 00:13:45,750
Die 8 Bits sind in dem Sinne redundant, dass sie vollständig vom Rest

249
00:13:45,750 --> 00:13:49,954
der Nachricht bestimmt werden, aber es geht auf eine viel intelligentere

250
00:13:49,954 --> 00:13:53,640
Art und Weise, als einfach die Nachricht als Ganzes zu kopieren.

251
00:13:53,640 --> 00:13:56,225
Und dennoch wäre man mit so wenig Aufwand in der Lage,

252
00:13:56,225 --> 00:13:59,000
jeden einzelnen Bitfehler zu identifizieren und zu beheben.

253
00:13:59,000 --> 00:14:00,400
Naja fast.

254
00:14:00,400 --> 00:14:03,824
Okay, das einzige Problem besteht hier darin, dass, wenn keine der vier

255
00:14:03,824 --> 00:14:07,248
Paritätsprüfungen einen Fehler erkennt, was bedeutet, dass die speziell

256
00:14:07,248 --> 00:14:10,768
ausgewählten Teilmengen von 8 Bits alle gerade Paritäten haben, genau wie

257
00:14:10,768 --> 00:14:14,430
der Absender es beabsichtigt hat, dann bedeutet das entweder, dass überhaupt

258
00:14:14,430 --> 00:14:17,760
kein Fehler aufgetreten ist , oder es schränkt uns auf Position 0 ein.

259
00:14:17,760 --> 00:14:22,575
Sie sehen, mit vier Ja- oder Nein-Fragen haben wir 16 mögliche Ergebnisse für unsere

260
00:14:22,575 --> 00:14:27,561
Paritätsprüfungen, und das fühlt sich zunächst perfekt an, um eine von 16 Positionen im

261
00:14:27,561 --> 00:14:32,546
Block zu bestimmen, aber Sie müssen auch ein 17. Ergebnis mitteilen, das „Kein Fehler“.

262
00:14:32,546 --> 00:14:33,000
Zustand.

263
00:14:33,000 --> 00:14:37,860
Die Lösung hier ist eigentlich ziemlich einfach: Vergessen Sie einfach das 0. Bit ganz.

264
00:14:37,860 --> 00:14:41,003
Wenn wir also unsere vier Paritätsprüfungen durchführen und feststellen,

265
00:14:41,003 --> 00:14:44,320
dass sie alle gerade sind, bedeutet das eindeutig, dass kein Fehler vorliegt.

266
00:14:44,320 --> 00:14:47,488
Das bedeutet, dass wir nicht mit einem 16-Bit-Block arbeiten,

267
00:14:47,488 --> 00:14:50,707
sondern mit einem 15-Bit-Block, bei dem 11 der Bits frei sind,

268
00:14:50,707 --> 00:14:54,080
um eine Nachricht zu übertragen, und 4 davon der Redundanz dienen.

269
00:14:54,080 --> 00:14:56,608
Und damit haben wir jetzt das, was die Leute in

270
00:14:56,608 --> 00:14:59,400
der Branche als 15-11-Hamming-Code bezeichnen würden.

271
00:14:59,400 --> 00:15:02,546
Trotzdem ist es schön, eine Blockgröße zu haben, die einer sauberen Potenz von

272
00:15:02,546 --> 00:15:05,812
2 entspricht, und es gibt eine clevere Möglichkeit, dieses 0-te Bit beizubehalten

273
00:15:05,812 --> 00:15:08,880
und es so dazu zu bringen, ein wenig zusätzliche Arbeit für uns zu erledigen.

274
00:15:08,880 --> 00:15:12,345
Wenn wir es als Paritätsbit im gesamten Block verwenden, können wir

275
00:15:12,345 --> 00:15:16,320
2-Bit-Fehler tatsächlich erkennen, auch wenn wir sie nicht korrigieren können.

276
00:15:16,320 --> 00:15:17,440
So funktioniert das.

277
00:15:17,440 --> 00:15:20,111
Nachdem wir diese vier speziellen Fehlerkorrekturbits gesetzt

278
00:15:20,111 --> 00:15:22,782
haben, setzen wir das nullte, sodass die Parität des gesamten

279
00:15:22,782 --> 00:15:25,540
Blocks gerade ist, genau wie bei einer normalen Paritätsprüfung.

280
00:15:25,540 --> 00:15:28,354
Wenn es nun einen einzelnen Bitfehler gibt, wechselt die Parität

281
00:15:28,354 --> 00:15:31,168
des gesamten Blocks in den ungeraden Zustand, aber dank der vier

282
00:15:31,168 --> 00:15:33,940
fehlerkorrigierenden Prüfungen würden wir das trotzdem erkennen.

283
00:15:33,940 --> 00:15:37,985
Wenn es jedoch zwei Fehler gibt, wird die Gesamtparität wieder

284
00:15:37,985 --> 00:15:41,645
ausgeglichen, aber der Empfänger sieht aufgrund der vier

285
00:15:41,645 --> 00:15:45,820
Paritätsprüfungen immer noch, dass zumindest ein Fehler vorliegt.

286
00:15:45,820 --> 00:15:48,294
Wenn sie also feststellen, dass die Parität insgesamt gleichmäßig

287
00:15:48,294 --> 00:15:50,768
ist, aber bei den anderen Prüfungen etwas ungleich Null passiert,

288
00:15:50,768 --> 00:15:52,980
bedeutet das, dass mindestens zwei Fehler aufgetreten sind.

289
00:15:52,980 --> 00:15:54,420
Ist das nicht klug?

290
00:15:54,420 --> 00:15:58,356
Auch wenn wir diese 2-Bit-Fehler nicht korrigieren können, können wir sie einfach

291
00:15:58,356 --> 00:16:02,340
dadurch erkennen, dass wir das eine kleine lästige 0. Bit wieder in Betrieb nehmen.

292
00:16:02,340 --> 00:16:06,540
Das ist ziemlich normal und wird als erweiterter Hamming-Code bezeichnet.

293
00:16:06,540 --> 00:16:09,966
Technisch gesehen haben Sie jetzt eine vollständige Beschreibung dessen,

294
00:16:09,966 --> 00:16:13,580
was ein Hamming-Code bewirkt, zumindest für das Beispiel eines 16-Bit-Blocks.

295
00:16:13,580 --> 00:16:16,127
Ich denke jedoch, dass es für Sie befriedigender sein wird, Ihr

296
00:16:16,127 --> 00:16:18,874
Verständnis zu überprüfen und alles bis zu diesem Punkt zu festigen,

297
00:16:18,874 --> 00:16:21,980
indem Sie selbst ein vollständiges Beispiel von Anfang bis Ende durcharbeiten.

298
00:16:21,980 --> 00:16:25,100
Ich werde es jedoch mit Ihnen durchgehen, damit Sie es selbst überprüfen können.

299
00:16:25,100 --> 00:16:27,730
Um eine Nachricht einzurichten, unabhängig davon, ob es sich um eine

300
00:16:27,730 --> 00:16:30,476
wörtliche Nachricht handelt, die Sie über den Speicherplatz übersetzen,

301
00:16:30,476 --> 00:16:33,183
oder um Daten, die Sie über einen längeren Zeitraum speichern möchten,

302
00:16:33,183 --> 00:16:35,700
besteht der erste Schritt darin, sie in 11-Bit-Blöcke aufzuteilen.

303
00:16:35,700 --> 00:16:40,340
Jeder Block wird in einen fehlerresistenten 16-Bit-Block verpackt.

304
00:16:40,340 --> 00:16:43,740
Nehmen wir also dieses als Beispiel und arbeiten wir es tatsächlich aus.

305
00:16:43,740 --> 00:16:45,380
Machen Sie es tatsächlich!

306
00:16:45,380 --> 00:16:52,980
Lassen Sie uns innehalten und versuchen, diesen Block zusammenzusetzen.

307
00:16:52,980 --> 00:16:53,980
Okay, bist du bereit?

308
00:16:53,980 --> 00:16:57,798
Denken Sie daran, dass Position 0 zusammen mit den anderen Potenzen von

309
00:16:57,798 --> 00:17:01,669
2 für Fehlerkorrekturzwecke reserviert ist. Sie beginnen also damit, die

310
00:17:01,669 --> 00:17:05,700
Nachrichtenbits der Reihe nach an allen verbleibenden Stellen zu platzieren.

311
00:17:05,700 --> 00:17:09,445
Diese Gruppe muss über eine gerade Parität verfügen, was bereits der Fall

312
00:17:09,445 --> 00:17:13,140
ist. Daher sollten Sie das Paritätsbit in Position 1 auf 0 gesetzt haben.

313
00:17:13,140 --> 00:17:16,255
Die nächste Gruppe beginnt mit einer ungeraden Parität,

314
00:17:16,255 --> 00:17:19,260
daher sollten Sie ihr Paritätsbit auf 1 gesetzt haben.

315
00:17:19,260 --> 00:17:21,836
Die Gruppe danach beginnt mit einer ungeraden Parität,

316
00:17:21,836 --> 00:17:24,740
daher hätten Sie ihr Paritätsbit wiederum auf 1 setzen sollen.

317
00:17:24,740 --> 00:17:28,007
Und die letzte Gruppe hat auch eine ungerade Parität, was

318
00:17:28,007 --> 00:17:31,500
bedeutet, dass wir dieses Bit in Position 8 auf eine 1 setzen.

319
00:17:31,500 --> 00:17:36,714
Und als letzten Schritt hat der gesamte Block nun eine gerade Parität, was bedeutet,

320
00:17:36,714 --> 00:17:41,500
dass Sie das Bit Nummer 0, das übergeordnete Paritätsbit, auf 0 setzen können.

321
00:17:41,500 --> 00:17:45,115
Wenn dieser Block gesendet wird, ist die Parität der vier

322
00:17:45,115 --> 00:17:48,980
speziellen Teilmengen und des Blocks als Ganzes gerade oder 0.

323
00:17:48,980 --> 00:17:53,620
Lassen Sie uns im zweiten Teil der Übung die Rolle des Empfängers übernehmen.

324
00:17:53,620 --> 00:17:56,788
Das würde natürlich bedeuten, dass Sie diese Nachricht noch nicht kennen. Vielleicht

325
00:17:56,788 --> 00:17:59,919
haben einige von Ihnen sie auswendig gelernt, aber nehmen wir an, dass Sie es nicht

326
00:17:59,919 --> 00:18:00,180
wissen.

327
00:18:00,180 --> 00:18:04,020
Ich werde entweder 0, 1 oder 2 der Bits in diesem Block

328
00:18:04,020 --> 00:18:08,340
ändern und Sie dann bitten, herauszufinden, was ich getan habe.

329
00:18:08,340 --> 00:18:13,460
Halten Sie also noch einmal inne und versuchen Sie, es herauszufinden.

330
00:18:13,460 --> 00:18:21,828
Okay, Sie als Empfänger überprüfen jetzt die erste Paritätsgruppe und können sehen, dass

331
00:18:21,828 --> 00:18:29,820
sie gerade ist, sodass jeder vorhandene Fehler in einer geraden Spalte stehen müsste.

332
00:18:29,820 --> 00:18:34,290
Bei der nächsten Prüfung erhalten wir eine ungerade Zahl, die uns sagt, dass

333
00:18:34,290 --> 00:18:38,760
mindestens ein Fehler vorliegt, und uns auf diese bestimmte Spalte eingrenzt.

334
00:18:38,760 --> 00:18:42,900
Die dritte Prüfung ist ausgeglichen und schränkt die Möglichkeiten noch weiter ein.

335
00:18:42,900 --> 00:18:47,325
Und die letzte Paritätsprüfung ist seltsam und sagt uns, dass irgendwo unten ein Fehler

336
00:18:47,325 --> 00:18:51,700
vorliegt, der sich, wie wir jetzt erkennen können, an Position Nummer 10 befinden muss.

337
00:18:51,700 --> 00:18:55,010
Darüber hinaus ist die Parität des gesamten Blocks ungerade, was

338
00:18:55,010 --> 00:18:58,220
uns die Gewissheit gibt, dass es einen Flip und nicht zwei gab.

339
00:18:58,220 --> 00:19:01,600
Bei drei oder mehr sind alle Wetten ungültig.

340
00:19:01,600 --> 00:19:05,112
Nach der Korrektur von Bit Nummer 10 erhalten wir durch Herausziehen

341
00:19:05,112 --> 00:19:08,676
der 11 Bits, die nicht zur Korrektur verwendet wurden, den relevanten

342
00:19:08,676 --> 00:19:12,240
Abschnitt der ursprünglichen Nachricht, der, wenn man zurückspult und

343
00:19:12,240 --> 00:19:16,160
vergleicht, tatsächlich genau das ist, womit wir das Beispiel begonnen haben.

344
00:19:16,160 --> 00:19:20,071
Und da Sie nun wissen, wie man das alles von Hand macht, möchte ich Ihnen zeigen, wie Sie

345
00:19:20,071 --> 00:19:23,940
den Kernteil dieser gesamten Logik mit einer einzigen Zeile Python-Code ausführen können.

346
00:19:23,940 --> 00:19:27,896
Sehen Sie, was ich Ihnen noch nicht gesagt habe, ist, wie elegant dieser Algorithmus

347
00:19:27,896 --> 00:19:31,713
wirklich ist, wie einfach es ist, eine Maschine dazu zu bringen, auf die Position

348
00:19:31,713 --> 00:19:35,763
eines Fehlers zu zeigen, wie man ihn systematisch skaliert und wie wir alles einordnen

349
00:19:35,763 --> 00:19:39,580
können Dies ist ein einziger Vorgang und nicht mehrere separate Paritätsprüfungen.

350
00:19:39,580 --> 00:19:39,580
Um zu sehen, was ich meine, kommen Sie zu Teil 2.

