1
00:00:00,000 --> 00:00:08,620
คุณเคยสงสัยบ้างไหมว่าเป็นไปได้อย่างไรที่จะเกาซีดีหรือดีวีดีแต่ยังคงเล่นไฟล์ที่เก็บไว้อยู่ได้?

2
00:00:08,620 --> 00:00:10,900


3
00:00:10,900 --> 00:00:15,280
รอยขีดข่วนส่งผลต่อเลข 1 และ 0

4
00:00:15,280 --> 00:00:20,500
บนดิสก์จริงๆ ดังนั้นจึงอ่านข้อมูลที่แตกต่างจากข้อมูลที่เก็บไว้ แต่เว้นแต่ว่าจะมีรอยขีดข่วนจริงๆ

5
00:00:20,500 --> 00:00:26,540
บิตที่อ่านออกจะถูกถอดรหัสเป็นไฟล์เดียวกับที่เข้ารหัสลงบนดิสก์ bit for

6
00:00:26,540 --> 00:00:28,400
bit copy แม้ว่าจะมีข้อผิดพลาดทั้งหมดก็ตาม

7
00:00:28,400 --> 00:00:32,800
มีความฉลาดทางคณิตศาสตร์มากมายที่ช่วยให้เราสามารถจัดเก็บข้อมูลได้ และที่สำคัญไม่แพ้กันในการส่งข้อมูล

8
00:00:32,800 --> 00:00:36,840
ในลักษณะที่ทนทานต่อข้อผิดพลาด

9
00:00:36,840 --> 00:00:41,480
โอเค จริงๆ

10
00:00:41,480 --> 00:00:42,480
แล้ว มันไม่ต้องใช้ความฉลาดขนาดนั้นในการคิดวิธีการทำเช่นนี้

11
00:00:42,480 --> 00:00:47,660
ไฟล์ใดๆ ไม่ว่าจะเป็นวิดีโอ เสียง หรือข้อความ โค้ดบางส่วน รูปภาพ

12
00:00:47,660 --> 00:00:50,960
หรืออะไรก็ตาม สุดท้ายแล้วก็คือลำดับของ 1 และ 0

13
00:00:50,960 --> 00:00:55,340
และกลยุทธ์ง่ายๆ ในการแก้ไขบิตใดๆ

14
00:00:55,340 --> 00:00:57,780
ที่ถูกพลิกคือเก็บสำเนาสามชุดของแต่ละบิต

15
00:00:57,780 --> 00:01:02,240
จากนั้นเครื่องที่อ่านไฟล์นี้สามารถเปรียบเทียบสำเนาทั้งสามชุดนี้ และนำ 2

16
00:01:02,240 --> 00:01:07,440
ใน 3 ที่ดีที่สุดเสมอทุกครั้งที่มีความคลาดเคลื่อน

17
00:01:07,440 --> 00:01:11,560
แต่นั่นหมายความว่าคือการใช้พื้นที่สองในสามของคุณเพื่อความซ้ำซ้อน

18
00:01:11,560 --> 00:01:15,360
และถึงอย่างนั้น สำหรับพื้นที่ทั้งหมดที่สละไปนั้น

19
00:01:15,360 --> 00:01:18,120
ก็ไม่มีการรับประกันที่ชัดเจนเกี่ยวกับสิ่งที่จะเกิดขึ้นหากมีการพลิกบิตมากกว่าหนึ่งบิต

20
00:01:18,120 --> 00:01:21,960
คำถามที่น่าสนใจกว่านั้นคือต้องทำอย่างไรจึงจะสามารถแก้ไขข้อผิดพลาดได้โดยยอมสละพื้นที่ให้น้อยที่สุด

21
00:01:21,960 --> 00:01:24,740


22
00:01:24,740 --> 00:01:28,500
ตัวอย่างเช่น เมื่อใช้วิธีการที่คุณจะได้เรียนรู้เกี่ยวกับวิดีโอนี้ คุณสามารถจัดเก็บข้อมูลของคุณในรูปแบบบล็อก 256 บิต โดยแต่ละบล็อกใช้

23
00:01:28,500 --> 00:01:35,840
9 บิต 9! เพื่อทำหน้าที่เป็นความซ้ำซ้อน และอีก

24
00:01:35,840 --> 00:01:41,000
247 บิตมีอิสระในการส่งข้อความหรือข้อมูลที่มีความหมายตามที่คุณต้องการ

25
00:01:41,000 --> 00:01:44,740
และยังคงเป็นกรณีที่หากมีการพลิกตรงนี้เพียงดูที่บล็อกนี้แล้วไม่มีอะไรเพิ่มเติมเครื่องก็จะสามารถระบุได้ว่ามีข้อผิดพลาดและอยู่ที่ไหนอย่างแม่นยำเพื่อให้รู้วิธีแก้ไข

26
00:01:44,740 --> 00:01:49,640
.

27
00:01:49,640 --> 00:01:53,120


28
00:01:53,140 --> 00:01:55,540
และจริงๆ แล้วนั่นให้ความรู้สึกเหมือนเป็นเวทย์มนตร์

29
00:01:55,540 --> 00:01:59,400
และสำหรับรูปแบบเฉพาะนี้ ถ้ามีการพลิกสองบิต

30
00:01:59,400 --> 00:02:03,180
อย่างน้อยเครื่องจะสามารถตรวจพบว่ามีข้อผิดพลาดสองรายการ แม้ว่าจะไม่ทราบวิธีแก้ไขก็ตาม

31
00:02:03,180 --> 00:02:08,140
เราจะพูดคุยกันในภายหลังเกี่ยวกับวิธีการปรับขนาดบล็อกที่มีขนาดต่างกัน

32
00:02:08,140 --> 00:02:12,620
วิธีที่ช่วยให้คุณแก้ไขข้อผิดพลาดเช่นนี้เป็นที่ทราบกันดีอยู่แล้วว่าเป็นรหัสแก้ไขข้อผิดพลาด

33
00:02:12,620 --> 00:02:13,880


34
00:02:13,880 --> 00:02:18,220
ในช่วงที่ดีขึ้นของศตวรรษที่ผ่านมา สาขานี้เป็นแหล่งคณิตศาสตร์เชิงลึกที่น่าประหลาดใจมากมาย

35
00:02:18,220 --> 00:02:23,000
ซึ่งรวมอยู่ในอุปกรณ์ที่เราใช้ทุกวัน

36
00:02:23,000 --> 00:02:27,740
เป้าหมายคือการทำให้คุณมีความเข้าใจอย่างถ่องแท้เกี่ยวกับหนึ่งในตัวอย่างแรกสุดที่เรียกว่ารหัส

37
00:02:27,740 --> 00:02:29,660
Hamming

38
00:02:29,660 --> 00:02:32,620
อย่างไรก็ตาม วิธีที่ฉันคิดเกี่ยวกับโครงสร้างของวิดีโอนี้

39
00:02:32,620 --> 00:02:37,060
ไม่ได้เน้นไปที่การอธิบายโดยตรงที่สุดเท่าที่จะเป็นไปได้ แต่เป็นการกระตุ้นให้คุณประดิษฐ์มันขึ้นมาเองมากกว่า

40
00:02:37,060 --> 00:02:40,220
โดยมีคำแนะนำที่อ่อนโยนเล็กน้อยตรงนี้และตรงนั้น

41
00:02:40,220 --> 00:02:44,100
ดังนั้น เมื่อคุณรู้สึกว่าคุณเห็นว่ามันจะเป็นอย่างไร ณ

42
00:02:44,100 --> 00:02:47,180
จุดใดจุดหนึ่ง ให้ใช้เวลาสักครู่เพื่อหยุดชั่วคราว คาดการณ์อย่างแข็งขันว่าแผนการจะเป็นอย่างไรก่อนที่ฉันจะบอกคุณ

43
00:02:47,180 --> 00:02:51,500
นอกจากนี้ หากคุณต้องการให้ความเข้าใจของคุณลงไปจนถึงระดับฮาร์ดแวร์ Ben

44
00:02:51,500 --> 00:02:55,160
Eater ได้สร้างวิดีโอร่วมกับวิดีโอนี้เพื่อแสดงให้คุณเห็นวิธีการใช้โค้ด Hamming

45
00:02:55,160 --> 00:02:59,520
บน breadboards ซึ่งน่าพึงพอใจอย่างยิ่ง

46
00:02:59,520 --> 00:03:03,120
คุณควรรู้ไว้ว่า รหัส Hamming

47
00:03:03,120 --> 00:03:08,040
ไม่ได้ใช้กันอย่างแพร่หลายเท่ากับรหัสสมัยใหม่ เช่น อัลกอริธึม

48
00:03:08,040 --> 00:03:14,240
Reed-Solomon แต่มีเวทย์มนตร์บางอย่างที่ทำให้เกิดความแตกต่างระหว่างความรู้สึกที่เป็นไปไม่ได้ในตอนแรกกับความรู้สึกที่สมเหตุสมผลอย่างยิ่งในครั้งเดียว คุณเรียนรู้เกี่ยวกับแฮมมิง

49
00:03:14,240 --> 00:03:19,080
หลักการพื้นฐานของการแก้ไขข้อผิดพลาดคือในพื้นที่อันกว้างใหญ่ของข้อความที่เป็นไปได้ทั้งหมด

50
00:03:19,300 --> 00:03:22,860
มีเพียงบางส่วนเท่านั้นที่จะถือว่าข้อความที่ถูกต้อง

51
00:03:22,860 --> 00:03:29,100
ในการเปรียบเทียบ ลองนึกถึงคำที่สะกดถูกและคำที่สะกดผิด

52
00:03:29,100 --> 00:03:33,340
เมื่อใดก็ตามที่ข้อความที่ถูกต้องถูกแก้ไข ผู้รับจะต้องรับผิดชอบในการแก้ไขสิ่งที่พวกเขาเห็นกลับไปยังเพื่อนบ้านที่ถูกต้องที่ใกล้ที่สุด

53
00:03:33,340 --> 00:03:38,380
เช่นเดียวกับที่คุณทำกับการพิมพ์ผิด

54
00:03:38,380 --> 00:03:43,100
การสร้างอัลกอริธึมที่เป็นรูปธรรมเพื่อจัดหมวดหมู่ข้อความเช่นนี้ได้อย่างมีประสิทธิภาพนั้นต้องใช้ความฉลาดพอสมควร

55
00:03:43,100 --> 00:03:47,160


56
00:03:47,160 --> 00:03:52,060
เรื่องราวเริ่มต้นในปี 1940 เมื่อ Richard

57
00:03:52,060 --> 00:03:55,900
Hamming วัยเยาว์ทำงานให้กับ Bell Labs

58
00:03:55,900 --> 00:03:57,420
และงานบางส่วนของเขาเกี่ยวข้องกับการใช้คอมพิวเตอร์ Punch Card ขนาดใหญ่ราคาแพงซึ่งเขาเข้าถึงได้เพียงอย่างจำกัดเท่านั้น

59
00:03:57,420 --> 00:04:01,200
และโปรแกรมที่เขาทำอย่างต่อเนื่องก็ล้มเหลว

60
00:04:01,200 --> 00:04:03,140
เพราะบางครั้งอาจอ่านผิดบ้าง

61
00:04:03,140 --> 00:04:07,140
ความหงุดหงิดเป็นบ่อเกิดของการประดิษฐ์

62
00:04:07,140 --> 00:04:09,280
เขาเบื่อหน่ายจนคิดค้นรหัสแก้ไขข้อผิดพลาดตัวแรกของโลก

63
00:04:09,280 --> 00:04:13,020
มีหลายวิธีในการวางกรอบโค้ดของ Hamming แต่เมื่อผ่านครั้งแรก

64
00:04:13,020 --> 00:04:16,620
เราจะพูดถึงวิธีที่ Hamming คิดเกี่ยวกับมัน

65
00:04:16,620 --> 00:04:21,400
ลองใช้ตัวอย่างที่เรียบง่ายแต่ไม่ง่ายเกินไป บล็อกขนาด 16 บิต

66
00:04:21,400 --> 00:04:25,700
เราจะกำหนดหมายเลขตำแหน่งของบิตเหล่านี้ตั้งแต่ 0 ถึง 15

67
00:04:25,700 --> 00:04:30,520
ข้อมูลจริงที่เราต้องการจัดเก็บจะประกอบขึ้นเป็น 12 บิตของบิตเหล่านี้เท่านั้น

68
00:04:30,520 --> 00:04:33,920
ในขณะที่ 4 ตำแหน่งจะถูกสงวนไว้เป็นการสำรองประเภทหนึ่ง

69
00:04:33,920 --> 00:04:38,120
คำว่าซ้ำซ้อนในที่นี้ไม่ได้หมายถึงการคัดลอกเท่านั้น อย่างไรก็ตาม

70
00:04:38,120 --> 00:04:40,200
4 บิตเหล่านั้นไม่ได้ให้พื้นที่เพียงพอที่จะคัดลอกข้อมูลแบบสุ่มสี่สุ่มห้า

71
00:04:40,200 --> 00:04:44,880
แต่จะต้องมีความซ้ำซ้อนที่เหมาะสมและชาญฉลาดมากขึ้น โดยไม่ต้องเพิ่มข้อมูลใหม่ใดๆ

72
00:04:44,880 --> 00:04:48,740
แต่เพิ่มความยืดหยุ่น

73
00:04:48,740 --> 00:04:52,620
คุณอาจคาดหวังว่าชิ้นส่วนพิเศษทั้ง 4 ชิ้นนี้จะบรรจุรวมกันอย่างสวยงาม

74
00:04:52,620 --> 00:04:56,400
อาจจะเป็นตอนท้ายหรืออะไรทำนองนั้น แต่อย่างที่คุณเห็น การวางพวกมันในตำแหน่งที่เป็นกำลัง

75
00:04:56,400 --> 00:05:00,320
2 จะทำให้ได้บางสิ่งที่ดูหรูหราจริงๆ ในตอนท้าย

76
00:05:00,320 --> 00:05:05,420
นอกจากนี้ยังอาจให้คำแนะนำเล็กน้อยเกี่ยวกับวิธีการปรับขนาดสำหรับบล็อกขนาดใหญ่

77
00:05:05,420 --> 00:05:09,220
ในทางเทคนิคแล้ว ข้อมูลจะมีเพียง 11 บิต

78
00:05:09,220 --> 00:05:14,260
คุณจะพบว่าสิ่งที่เกิดขึ้นที่ตำแหน่ง 0 มีความแตกต่างเล็กน้อย แต่อย่าเพิ่งกังวลไปในตอนนี้

79
00:05:14,280 --> 00:05:18,640
เช่นเดียวกับอัลกอริธึมการแก้ไขข้อผิดพลาดใดๆ สิ่งนี้จะเกี่ยวข้องกับผู้เล่นสองคน

80
00:05:18,640 --> 00:05:23,200
ผู้ส่งที่รับผิดชอบในการตั้งค่าบิตพิเศษ 4

81
00:05:23,200 --> 00:05:26,360
บิตนี้ และผู้รับที่รับผิดชอบในการดำเนินการตรวจสอบและแก้ไขข้อผิดพลาดบางประเภท

82
00:05:26,360 --> 00:05:30,040
แน่นอนว่าคำว่าผู้ส่งและผู้รับหมายถึงเครื่องจักรหรือซอฟต์แวร์ที่ทำการตรวจสอบทั้งหมด และแนวคิดของข้อความก็มีความหมายกว้างมาก

83
00:05:30,040 --> 00:05:34,040
โดยรวมถึงสิ่งต่างๆ เช่น

84
00:05:34,040 --> 00:05:35,480
พื้นที่เก็บข้อมูล

85
00:05:35,480 --> 00:05:39,320
ท้ายที่สุดแล้ว การจัดเก็บข้อมูลก็เหมือนกับการส่งข้อความจากอดีตสู่อนาคต

86
00:05:39,320 --> 00:05:42,640
แทนที่จะส่งจากที่หนึ่งไปอีกที่หนึ่ง

87
00:05:42,640 --> 00:05:46,700
นั่นคือการตั้งค่า แต่ก่อนที่เราจะดำดิ่งลงไปได้ เราต้องพูดถึงแนวคิดที่เกี่ยวข้องซึ่งยังอยู่ในใจของแฮมมิงในช่วงเวลาที่เขาค้นพบ

88
00:05:46,700 --> 00:05:51,080
ซึ่งเป็นวิธีการที่ช่วยให้คุณตรวจพบข้อผิดพลาดเล็กๆ น้อยๆ

89
00:05:51,080 --> 00:05:55,520
ใดๆ ได้ แต่ไม่สามารถแก้ไขได้

90
00:05:55,520 --> 00:05:57,300
ตามที่ทราบกันดี ในการประกอบธุรกิจเป็นการตรวจสอบความเท่าเทียมกัน

91
00:05:57,300 --> 00:06:01,300
สำหรับการตรวจสอบพาริตี เราจะแยกออกเพียงบิตเดียวที่ผู้ส่งรับผิดชอบในการปรับแต่ง

92
00:06:01,300 --> 00:06:04,940
และส่วนที่เหลือสามารถส่งข้อความได้อย่างอิสระ

93
00:06:04,940 --> 00:06:10,380
งานเดียวของบิตพิเศษนี้คือต้องแน่ใจว่าจำนวน 1

94
00:06:10,380 --> 00:06:12,100
ทั้งหมดในข้อความเป็นเลขคู่

95
00:06:12,100 --> 00:06:16,920
ตัวอย่างเช่น ตอนนี้ จำนวนรวมของ 1 คือ

96
00:06:16,920 --> 00:06:20,960
7 ซึ่งเป็นเลขคี่ ดังนั้นผู้ส่งจึงต้องพลิกบิตพิเศษนั้นให้เป็น 1 เพื่อให้การนับเลขคู่

97
00:06:20,960 --> 00:06:25,320
แต่ถ้าบล็อกเริ่มต้นด้วยเลขคู่เป็น 1 แล้ว

98
00:06:25,320 --> 00:06:27,480
บิตพิเศษนี้ก็จะคงไว้ที่ 0

99
00:06:27,480 --> 00:06:31,640
นี่เป็นวิธีที่ค่อนข้างเรียบง่าย เรียบง่ายหลอกลวง

100
00:06:31,640 --> 00:06:37,760
แต่เป็นวิธีที่สวยงามอย่างเหลือเชื่อในการกลั่นกรองแนวคิดเรื่องการเปลี่ยนแปลงที่ใดก็ได้ในข้อความเพื่อให้สะท้อนให้เห็นเป็นข้อมูลเพียงส่วนเดียว

101
00:06:37,760 --> 00:06:43,680
สังเกตว่าหากมีการพลิกข้อความส่วนใดส่วนหนึ่งของข้อความนี้ จาก 0 เป็น 1 หรือ

102
00:06:43,680 --> 00:06:48,140
1 เป็น 0 มันจะเปลี่ยนจำนวนรวมของ 1 จากเป็นคู่เป็นคี่

103
00:06:48,140 --> 00:06:52,000
ดังนั้น หากคุณเป็นผู้รับ คุณดูข้อความนี้

104
00:06:52,000 --> 00:06:56,580
และคุณเห็นเลขคี่เป็น 1

105
00:06:56,580 --> 00:06:58,700
คุณสามารถรู้ได้อย่างแน่นอนว่ามีข้อผิดพลาดเกิดขึ้น แม้ว่าคุณอาจไม่รู้ว่ามันอยู่ที่ไหนก็ตาม

106
00:06:58,700 --> 00:07:02,820
ในศัพท์แสง ไม่ว่ากลุ่มของบิตจะมีเลข 1

107
00:07:02,820 --> 00:07:04,940
เป็นคู่หรือคี่ก็ตาม เรียกว่าความเท่าเทียมกัน

108
00:07:04,940 --> 00:07:09,140
คุณยังสามารถใช้ตัวเลขและบอกว่าความเท่าเทียมกันคือ 0 หรือ

109
00:07:09,140 --> 00:07:11,320
1 ซึ่งโดยทั่วไปจะมีประโยชน์มากกว่าเมื่อคุณเริ่มคำนวณแนวคิดนี้

110
00:07:11,320 --> 00:07:15,200
และบิตพิเศษนี้ที่ผู้ส่งใช้ในการควบคุมพาริตี

111
00:07:15,200 --> 00:07:18,020
เรียกว่าพาริตีบิต

112
00:07:18,020 --> 00:07:22,460
และจริงๆ แล้วเราควรชัดเจนว่าถ้าผู้รับเห็นความเท่าเทียมกันของเลขคี่ก็ไม่ได้หมายความว่ามีข้อผิดพลาดเพียงจุดเดียว อาจมีข้อผิดพลาด 3

113
00:07:22,460 --> 00:07:26,920
จุด หรือ 5 หรือเลขคี่อื่นๆ

114
00:07:26,920 --> 00:07:29,560
แต่พวกเขาสามารถรู้ได้อย่างแน่นอน ว่ามันไม่ใช่ 0

115
00:07:29,560 --> 00:07:34,880
ในทางกลับกัน หากมีข้อผิดพลาด 2 ข้อ

116
00:07:34,880 --> 00:07:39,560
หรือข้อผิดพลาดเป็นจำนวนคู่ การนับ 1

117
00:07:39,560 --> 00:07:43,360
สุดท้ายนั้นจะยังคงเป็นเลขคู่ ดังนั้นผู้รับจึงไม่มั่นใจเต็มที่ว่าการนับเลขคู่หมายความว่าข้อความนั้นปราศจากข้อผิดพลาด .

118
00:07:43,360 --> 00:07:47,860
คุณอาจบ่นว่าข้อความที่เลอะเทอะด้วยการพลิกเพียง 2

119
00:07:47,860 --> 00:07:49,760
บิตนั้นค่อนข้างอ่อนแอ และคุณพูดถูกอย่างแน่นอน

120
00:07:49,760 --> 00:07:54,480
อย่างไรก็ตาม โปรดทราบว่าไม่มีวิธีการใดในการตรวจจับหรือแก้ไขข้อผิดพลาดที่จะทำให้คุณมั่นใจได้

121
00:07:54,480 --> 00:07:59,720
100% ว่าข้อความที่คุณได้รับคือข้อความที่ผู้ส่งตั้งใจไว้

122
00:07:59,720 --> 00:08:03,760
ท้ายที่สุดแล้ว

123
00:08:03,760 --> 00:08:05,920
สัญญาณรบกวนแบบสุ่มที่เพียงพอสามารถเปลี่ยนข้อความที่ถูกต้องหนึ่งข้อความให้เป็นข้อความที่ถูกต้องอีกข้อความหนึ่งได้เพียงโดยบังเอิญ

124
00:08:05,920 --> 00:08:10,520
เป้าหมายคือการสร้างรูปแบบที่แข็งแกร่งจนถึงจำนวนข้อผิดพลาดสูงสุดที่กำหนด

125
00:08:10,520 --> 00:08:16,480
หรืออาจลดความน่าจะเป็นของผลบวกลวงเช่นนี้

126
00:08:16,480 --> 00:08:20,940
การตรวจสอบความเท่าเทียมกันด้วยตัวเองนั้นค่อนข้างอ่อนแอ

127
00:08:20,940 --> 00:08:25,640
แต่ด้วยการกลั่นกรองแนวคิดเรื่องการเปลี่ยนแปลงในข้อความทั้งหมดให้เหลือเพียงนิดเดียว

128
00:08:25,640 --> 00:08:28,000
สิ่งที่พวกเขามอบให้เราคือแบบเอกสารสำเร็จรูปที่มีประสิทธิภาพสำหรับแผนงานที่มีความซับซ้อนมากขึ้น

129
00:08:28,000 --> 00:08:32,880
ตัวอย่างเช่น ขณะที่ Hamming

130
00:08:32,880 --> 00:08:37,160
กำลังค้นหาวิธีในการระบุว่าข้อผิดพลาดเกิดขึ้นที่ใด ไม่ใช่แค่ว่ามันเกิดขึ้นเท่านั้น

131
00:08:37,160 --> 00:08:42,040
ข้อมูลเชิงลึกที่สำคัญของเขาก็คือ ถ้าคุณใช้การตรวจสอบความเท่าเทียมกันบางอย่างกับข้อความทั้งหมด แต่กับชุดย่อยที่เลือกอย่างระมัดระวังบางชุด

132
00:08:42,040 --> 00:08:46,840
คุณสามารถถามได้ ชุดคำถามที่ได้รับการปรับปรุงมากขึ้นซึ่งจะปักหมุดตำแหน่งของข้อผิดพลาดบิตเดียว

133
00:08:46,840 --> 00:08:51,280
ความรู้สึกโดยรวมก็เหมือนกับการเล่นเกมคำถาม 20

134
00:08:51,280 --> 00:08:54,300
ข้อ การถามคำถามใช่หรือไม่ใช่ที่จะตัดพื้นที่ของความเป็นไปได้ลงครึ่งหนึ่ง

135
00:08:54,300 --> 00:08:58,840
ตัวอย่างเช่น สมมติว่าเราทำการตรวจสอบความเท่าเทียมกันบน 8

136
00:08:58,840 --> 00:08:59,840
บิตเหล่านี้ ซึ่งเป็นตำแหน่งที่เป็นเลขคี่ทั้งหมด

137
00:09:00,400 --> 00:09:04,560
จากนั้นหากตรวจพบข้อผิดพลาด จะทำให้ผู้รับได้รับข้อมูลเพิ่มเติมอีกเล็กน้อยว่าข้อผิดพลาดนั้นอยู่ที่ตำแหน่งใดโดยเฉพาะ

138
00:09:04,560 --> 00:09:09,160
กล่าวคือ ข้อผิดพลาดนั้นอยู่ในตำแหน่งคี่

139
00:09:09,160 --> 00:09:14,360
หากตรวจไม่พบข้อผิดพลาดใน 8 บิตเหล่านั้น

140
00:09:14,360 --> 00:09:17,240
อาจหมายความว่าไม่มีข้อผิดพลาดเลย หรืออยู่ที่ตำแหน่งคู่

141
00:09:17,240 --> 00:09:21,560
คุณอาจคิดว่าการจำกัดการตรวจสอบพาริตีให้เหลือเพียงครึ่งบิตจะทำให้มีประสิทธิภาพน้อยลง แต่เมื่อทำร่วมกับการตรวจสอบอื่นๆ

142
00:09:21,560 --> 00:09:25,460
ที่ได้รับการคัดเลือกมาอย่างดี

143
00:09:25,460 --> 00:09:29,720
มันจะทำให้เรามีบางสิ่งที่ทรงพลังมากขึ้นโดยไม่ได้ตั้งใจ

144
00:09:29,720 --> 00:09:34,440
หากต้องการตั้งค่าการตรวจสอบพาริตีจริงๆ โปรดจำไว้ว่า

145
00:09:34,440 --> 00:09:37,600
จำเป็นต้องมีการจัดสรรบิตพิเศษบางส่วนที่สามารถควบคุมความเท่าเทียมกันของกลุ่มทั้งหมดนั้นได้

146
00:09:37,600 --> 00:09:39,920
เรามาเลือกตำแหน่งที่ 1 กันดีกว่า

147
00:09:39,920 --> 00:09:43,960
สำหรับตัวอย่างที่แสดง แพริตีของ 8

148
00:09:43,960 --> 00:09:48,220
บิตเหล่านี้ในปัจจุบันเป็นเลขคี่ ดังนั้นผู้ส่งจึงมีหน้าที่ในการสลับบิตพาริตีนั้น และตอนนี้ก็เป็นเลขคู่

149
00:09:48,220 --> 00:09:51,040
นี่เป็นเพียง 1 ใน 4 ของการตรวจสอบความเท่าเทียมกันที่เราจะทำ

150
00:09:51,040 --> 00:09:55,560
การตรวจสอบครั้งที่สองเป็นหนึ่งใน 8

151
00:09:55,560 --> 00:09:56,880
บิตบนครึ่งขวาของตาราง อย่างน้อยก็ตามที่เราได้วาดไว้ที่นี่

152
00:09:56,880 --> 00:10:02,520
คราวนี้เราอาจใช้ตำแหน่ง 2 เป็นพาริตีบิต ดังนั้น 8

153
00:10:02,520 --> 00:10:07,160
บิตเหล่านี้จึงมีความเท่าเทียมกันอยู่แล้ว และผู้ส่งก็รู้สึกดีที่จะปล่อยบิตหมายเลข 2 ไว้ไม่เปลี่ยนแปลง

154
00:10:07,160 --> 00:10:11,040
อีกด้านหนึ่ง หากผู้รับตรวจสอบความเท่าเทียมกันของกลุ่มนี้ และพวกเขาพบว่ามันแปลก

155
00:10:11,040 --> 00:10:15,960
พวกเขาจะรู้ว่าข้อผิดพลาดอยู่ที่ไหนสักแห่งใน 8 บิตเหล่านี้ทางด้านขวา

156
00:10:15,960 --> 00:10:21,260
มิฉะนั้นอาจหมายความว่าไม่มีข้อผิดพลาด หรือข้อผิดพลาดอยู่ที่ครึ่งซ้าย

157
00:10:21,260 --> 00:10:24,040
หรือฉันเดาว่าอาจมีข้อผิดพลาดสองประการ

158
00:10:24,040 --> 00:10:27,080
แต่ตอนนี้เราจะถือว่ามีข้อผิดพลาดมากที่สุดหนึ่งข้อในบล็อกทั้งหมด

159
00:10:27,080 --> 00:10:29,160
สิ่งต่าง ๆ พังทลายลงอย่างสมบูรณ์มากกว่านั้น

160
00:10:29,160 --> 00:10:32,920
ก่อนที่เราจะดูการตรวจสอบสองรายการถัดไป

161
00:10:32,920 --> 00:10:35,880
โปรดใช้เวลาสักครู่เพื่อพิจารณาว่าสองรายการแรกนี้ช่วยให้เราทำอะไรได้บ้างเมื่อคุณพิจารณาทั้งสองรายการร่วมกัน

162
00:10:35,880 --> 00:10:40,240
สมมติว่าคุณตรวจพบข้อผิดพลาดในคอลัมน์คี่ และในคอลัมน์ครึ่งขวา

163
00:10:40,240 --> 00:10:43,940
จำเป็นต้องหมายความว่ามีข้อผิดพลาดอยู่ที่ไหนสักแห่งในคอลัมน์สุดท้าย

164
00:10:43,940 --> 00:10:48,280
หากไม่มีข้อผิดพลาดในคอลัมน์คี่แต่มีข้อผิดพลาดในครึ่งขวา

165
00:10:48,280 --> 00:10:50,520
นั่นจะบอกคุณว่าอยู่ในคอลัมน์ที่สองจากคอลัมน์สุดท้าย

166
00:10:50,520 --> 00:10:54,640
ในทำนองเดียวกัน หากมีข้อผิดพลาดในคอลัมน์คี่แต่ไม่ใช่ครึ่งขวา

167
00:10:54,640 --> 00:10:56,560
คุณจะรู้ว่ามันอยู่ที่ไหนสักแห่งในคอลัมน์ที่สอง

168
00:10:56,560 --> 00:11:00,560
และถ้าการตรวจสอบพาริตีทั้งสองตรวจไม่พบสิ่งใดเลย

169
00:11:00,560 --> 00:11:03,760
นั่นหมายความว่าที่เดียวที่อาจเกิดข้อผิดพลาดได้คือในคอลัมน์ซ้ายสุดนั้น

170
00:11:03,760 --> 00:11:06,480
แต่ก็อาจหมายความว่าไม่มีข้อผิดพลาดเลยด้วย

171
00:11:06,480 --> 00:11:10,800
ซึ่งเป็นวิธีที่ค่อนข้างซับซ้อนในการบอกว่าการตรวจสอบความเท่าเทียมกันสองครั้งช่วยให้เราปักหมุดคอลัมน์ได้

172
00:11:10,800 --> 00:11:11,800


173
00:11:11,800 --> 00:11:14,000
จากตรงนี้คุณคงเดาได้ว่าอะไรจะเกิดขึ้นตามมา

174
00:11:14,000 --> 00:11:16,240
โดยพื้นฐานแล้วเราทำสิ่งเดียวกันแต่สำหรับแถว

175
00:11:16,240 --> 00:11:21,040
จะมีการตรวจสอบความเท่าเทียมกันในแถวคี่ โดยใช้ตำแหน่ง 4 เป็นบิตความเท่าเทียมกัน

176
00:11:21,040 --> 00:11:25,480
ดังนั้นในตัวอย่างนี้ กลุ่มนั้นมีความเท่าเทียมกันอยู่แล้ว ดังนั้นบิต

177
00:11:25,480 --> 00:11:26,480
4 จะถูกตั้งค่าเป็น 0

178
00:11:26,480 --> 00:11:31,280
และสุดท้ายจะมีการตรวจสอบความเท่าเทียมกันในสองแถวล่าง โดยใช้ตำแหน่ง

179
00:11:31,280 --> 00:11:32,280
8 เป็นบิตความเท่าเทียมกัน

180
00:11:32,280 --> 00:11:35,840
ในกรณีนี้ ดูเหมือนว่าผู้ส่งจะต้องเปิดบิต

181
00:11:35,840 --> 00:11:37,840
8 นั้นเพื่อให้กลุ่มมีความเท่าเทียมกัน

182
00:11:37,840 --> 00:11:41,360
เหมือนกับที่เช็คสองอันแรกให้เราปักหมุดคอลัมน์ไว้

183
00:11:41,360 --> 00:11:43,000
ส่วนสองอันถัดไปนี้ให้คุณปักหมุดแถวนั้นได้

184
00:11:43,000 --> 00:11:48,400
ตามตัวอย่าง ลองนึกภาพว่าในระหว่างการส่งสัญญาณมีข้อผิดพลาดที่ตำแหน่ง 3

185
00:11:48,400 --> 00:11:52,620
สิ่งนี้ส่งผลต่อกลุ่มพาริตีกลุ่มแรก และส่งผลต่อกลุ่มพาริตีกลุ่มที่สองด้วย

186
00:11:52,620 --> 00:11:56,340
ดังนั้นผู้รับจึงรู้ว่ามีข้อผิดพลาดอยู่ที่ไหนสักแห่งในคอลัมน์ด้านขวานั้น

187
00:11:56,340 --> 00:12:01,380
แต่ไม่กระทบกลุ่มที่สาม และไม่กระทบกลุ่มที่สี่

188
00:12:01,380 --> 00:12:05,460
และนั่นทำให้ผู้รับระบุข้อผิดพลาดได้จนถึงแถวแรก ซึ่งหมายถึงตำแหน่งที่

189
00:12:05,460 --> 00:12:08,660
3 จึงสามารถแก้ไขข้อผิดพลาดได้

190
00:12:08,660 --> 00:12:12,640
คุณอาจสนุกกับการใช้เวลาสักครู่เพื่อโน้มน้าวตัวเองว่าคำตอบสำหรับคำถามทั้งสี่ข้อนี้จะช่วยให้คุณระบุสถานที่ที่เฉพาะเจาะจงได้เสมอ

191
00:12:12,680 --> 00:12:17,320
ไม่ว่าพวกเขาจะอยู่ที่ไหนก็ตาม

192
00:12:17,320 --> 00:12:22,640
อันที่จริง

193
00:12:22,640 --> 00:12:23,640
ความฉลาดในหมู่พวกคุณอาจสังเกตเห็นความเชื่อมโยงระหว่างคำถามเหล่านี้กับการนับเลขฐานสองด้วยซ้ำ

194
00:12:23,640 --> 00:12:27,840
และถ้าคุณทำเช่นนั้น ฉันขอย้ำอีกครั้ง

195
00:12:27,840 --> 00:12:30,880
หยุดชั่วคราว พยายามดึงการเชื่อมต่อด้วยตัวเองก่อนที่ฉันจะสปอยล์

196
00:12:30,880 --> 00:12:35,560
หากคุณสงสัยว่าจะเกิดอะไรขึ้นหาก parity bit

197
00:12:35,560 --> 00:12:36,560
ได้รับผลกระทบ คุณก็สามารถลองดูได้

198
00:12:36,560 --> 00:12:40,720
ใช้เวลาสักครู่เพื่อพิจารณาว่าข้อผิดพลาดใด ๆ ในบิตพิเศษทั้งสี่นี้จะถูกติดตามอย่างไรเหมือนกับที่อื่น

199
00:12:40,720 --> 00:12:47,440
ๆ โดยมีคำถามสี่กลุ่มกลุ่มเดียวกัน

200
00:12:47,440 --> 00:12:50,500
มันไม่สำคัญเลย เพราะท้ายที่สุดแล้ว

201
00:12:50,500 --> 00:12:53,640
สิ่งที่เราต้องการคือการปกป้องบิตของข้อความ บิตการแก้ไขข้อผิดพลาดก็ยังคงดำเนินต่อไป

202
00:12:53,640 --> 00:12:57,120
แต่การปกป้องบิตเหล่านั้นก็เป็นสิ่งที่หลุดออกจากโครงการโดยเป็นผลพลอยได้

203
00:12:57,120 --> 00:12:59,260


204
00:12:59,260 --> 00:13:02,380
คุณอาจสนุกกับการคาดเดาว่าสิ่งนี้จะขยายขนาดได้อย่างไร

205
00:13:02,380 --> 00:13:08,040
ตัวอย่างเช่น หากเราใช้บล็อกขนาด 256

206
00:13:08,040 --> 00:13:15,680
บิต เพื่อปักหมุดตำแหน่ง คุณมีคำถามใช่หรือไม่ใช่เพียงแปดคำถามในการค้นหาแบบไบนารี่ไปยังจุดใดจุดหนึ่งโดยเฉพาะ

207
00:13:15,680 --> 00:13:19,680
และอย่าลืมว่าแต่ละคำถามจำเป็นต้องสละเวลาเพียงเล็กน้อยเพื่อตั้งค่าการตรวจสอบความเท่าเทียมกันที่เหมาะสม

208
00:13:19,680 --> 00:13:23,340


209
00:13:23,340 --> 00:13:26,960
บางท่านอาจเห็นแล้ว

210
00:13:26,960 --> 00:13:29,960
แต่เราจะพูดถึงวิธีที่เป็นระบบเพื่อค้นหาว่าคำถามเหล่านี้คืออะไรในเวลาเพียงไม่กี่นาที

211
00:13:29,960 --> 00:13:33,440
หวังว่าภาพร่างนี้จะเพียงพอที่จะชื่นชมประสิทธิภาพของสิ่งที่เรากำลังพัฒนาที่นี่

212
00:13:33,440 --> 00:13:34,440


213
00:13:34,440 --> 00:13:38,440
สิ่งแรก ยกเว้นพาริตี้บิตที่เน้นไว้แปดบิตนั้น

214
00:13:38,440 --> 00:13:41,720
สามารถเป็นอะไรก็ได้ที่คุณต้องการให้เป็น โดยพกพาข้อความหรือข้อมูลอะไรก็ได้ที่คุณต้องการ

215
00:13:41,720 --> 00:13:45,480
8 บิตนั้นซ้ำซ้อนในแง่ที่ว่าถูกกำหนดโดยส่วนที่เหลือของข้อความ

216
00:13:45,480 --> 00:13:53,640
แต่มันเป็นวิธีที่ฉลาดกว่าการคัดลอกข้อความโดยรวม

217
00:13:53,640 --> 00:13:58,000
ถึงกระนั้น หากยอมแพ้เพียงเล็กน้อย คุณจะสามารถระบุและแก้ไขข้อผิดพลาดเล็กๆ

218
00:13:58,000 --> 00:13:59,000
น้อยๆ ได้

219
00:13:59,000 --> 00:14:00,400
เกือบแล้ว

220
00:14:00,400 --> 00:14:05,920
โอเค ปัญหาหนึ่งที่นี่คือ หากไม่มีการตรวจสอบพาริตี้ทั้งสี่รายการตรวจพบข้อผิดพลาด

221
00:14:05,920 --> 00:14:10,240
หมายความว่าชุดย่อยที่เลือกเป็นพิเศษของ 8

222
00:14:10,240 --> 00:14:15,520
บิตทั้งหมดมีความเท่าเทียมกัน เช่นเดียวกับที่ผู้ส่งตั้งใจไว้ นั่นหมายความว่าไม่มีข้อผิดพลาดเลย

223
00:14:15,520 --> 00:14:17,760
หรือมันจำกัดเราให้แคบลงเหลือตำแหน่ง 0

224
00:14:17,760 --> 00:14:23,040
คุณคงเห็นว่าด้วยคำถามใช่หรือไม่ใช่สี่ข้อ เรามีผลลัพธ์ที่เป็นไปได้ 16 รายการสำหรับการตรวจสอบความเท่าเทียมกันของเรา และในตอนแรกนั้นให้ความรู้สึกที่สมบูรณ์แบบในการระบุ

225
00:14:23,040 --> 00:14:28,000
1 จาก 16 ตำแหน่งในบล็อก แต่คุณยังต้องสื่อสารผลลัพธ์ที่

226
00:14:28,000 --> 00:14:33,000
17 ด้วย ไม่มีข้อผิดพลาด เงื่อนไข.

227
00:14:33,000 --> 00:14:37,860
วิธีแก้ปัญหาตรงนี้ค่อนข้างง่าย เพียงลืมเรื่องบิตที่ 0 ไปโดยสิ้นเชิง

228
00:14:37,860 --> 00:14:41,920
ดังนั้นเมื่อเราตรวจสอบความเท่าเทียมกันทั้งสี่ครั้ง และเราเห็นว่าทุกรายการเท่ากัน

229
00:14:41,920 --> 00:14:44,320
หมายความว่าไม่มีข้อผิดพลาดอย่างชัดเจน

230
00:14:44,320 --> 00:14:49,240
ความหมายคือแทนที่จะทำงานกับบล็อก 16 บิต แต่เราทำงานกับบล็อก 15 บิต

231
00:14:49,240 --> 00:14:54,040
โดยที่ 11 บิตในนั้นว่างในการส่งข้อความ และ 4 บิตในนั้นมีไว้สำหรับการซ้ำซ้อน

232
00:14:54,080 --> 00:14:58,400
และด้วยเหตุนี้ ตอนนี้เราจึงมีสิ่งที่ผู้คนในธุรกิจเรียกว่ารหัส

233
00:14:58,400 --> 00:14:59,400
15-11 Hamming

234
00:14:59,400 --> 00:15:03,920
ที่กล่าวว่า เป็นเรื่องดีที่มีขนาดบล็อกที่มีพลังสะอาดเท่ากับ 2 และมีวิธีที่ชาญฉลาดที่เราสามารถเก็บบิตที่ 0

235
00:15:03,920 --> 00:15:08,880
ไว้รอบๆ และทำให้มันทำงานพิเศษเล็กๆ น้อยๆ ให้เราได้

236
00:15:08,880 --> 00:15:13,600
หากเราใช้มันเป็นพาริตีบิตทั่วทั้งบล็อก มันช่วยให้เราตรวจจับได้จริง แม้ว่าเราจะแก้ไขข้อผิดพลาด

237
00:15:13,600 --> 00:15:16,320
2 บิตไม่ได้ก็ตาม

238
00:15:16,320 --> 00:15:17,440
นี่คือวิธีการทำงาน

239
00:15:17,440 --> 00:15:21,740
หลังจากตั้งค่าบิตแก้ไขข้อผิดพลาดพิเศษทั้งสี่บิตแล้ว เราก็ตั้งค่าบิตนั้นเป็น 0

240
00:15:21,740 --> 00:15:25,540
เพื่อให้พาริตีของบล็อกทั้งหมดเท่ากัน เช่นเดียวกับการตรวจสอบพาริตีปกติ

241
00:15:25,540 --> 00:15:29,780
ทีนี้ หากมีข้อผิดพลาดบิตเดียว

242
00:15:29,780 --> 00:15:33,940
ความเท่าเทียมกันของบล็อกทั้งหมดจะสลับเป็นคี่ แต่เราจะจับได้อยู่ดีด้วยการตรวจสอบแก้ไขข้อผิดพลาดทั้งสี่ครั้ง

243
00:15:33,940 --> 00:15:38,100
อย่างไรก็ตาม หากมีข้อผิดพลาดสองประการ

244
00:15:38,100 --> 00:15:42,660
ความเท่าเทียมกันโดยรวมจะสลับกลับไปเป็นค่าคู่

245
00:15:42,660 --> 00:15:45,820
แต่ผู้รับจะยังคงเห็นว่ามีข้อผิดพลาดบางอย่างเป็นอย่างน้อยเนื่องจากสิ่งที่เกิดขึ้นกับการตรวจสอบความเท่าเทียมกันทั้งสี่ครั้งนั้น

246
00:15:45,820 --> 00:15:49,780
ดังนั้นหากพวกเขาสังเกตเห็นความเท่าเทียมกันโดยรวม แต่มีบางสิ่งที่ไม่เป็นศูนย์เกิดขึ้นกับเช็คอื่นๆ

247
00:15:49,820 --> 00:15:52,980
มันจะบอกว่ามีข้อผิดพลาดอย่างน้อยสองครั้ง

248
00:15:52,980 --> 00:15:54,420
นั่นไม่ฉลาดเหรอ?

249
00:15:54,420 --> 00:15:58,500
แม้ว่าเราจะไม่สามารถแก้ไขข้อผิดพลาด 2 บิตเหล่านั้นได้ เพียงแค่นำบิต

250
00:15:58,500 --> 00:16:02,340
0 ที่น่ารำคาญเล็กน้อยกลับมาทำงาน ก็ช่วยให้เราตรวจพบข้อผิดพลาดเหล่านั้นได้

251
00:16:02,340 --> 00:16:06,540
นี่เป็นมาตรฐานที่ค่อนข้างดี เรียกว่ารหัส Hamming แบบขยาย

252
00:16:06,540 --> 00:16:10,860
ในทางเทคนิคแล้ว ตอนนี้คุณมีคำอธิบายโดยละเอียดแล้วว่าโค้ด Hamming ทำอะไรได้บ้าง

253
00:16:10,860 --> 00:16:13,580
อย่างน้อยก็ตัวอย่างบล็อก 16 บิต

254
00:16:13,580 --> 00:16:17,300
แต่ฉันคิดว่าคุณจะพบว่าการตรวจสอบความเข้าใจของคุณและทำให้ทุกอย่างมั่นคงขึ้นจนถึงจุดนี้จะน่าพึงพอใจมากขึ้นโดยการทำตัวอย่างเต็มๆ

255
00:16:17,300 --> 00:16:21,980
หนึ่งตัวอย่างตั้งแต่ต้นจนจบด้วยตนเอง

256
00:16:21,980 --> 00:16:25,100
ฉันจะก้าวผ่านมันไปกับคุณเพื่อให้คุณสามารถตรวจสอบตัวเองได้

257
00:16:25,100 --> 00:16:29,180
ในการตั้งค่าข้อความ ไม่ว่าจะเป็นข้อความตามตัวอักษรที่คุณกำลังแปลในพื้นที่หรือข้อมูลบางอย่างที่คุณต้องการจัดเก็บเมื่อเวลาผ่านไป

258
00:16:29,180 --> 00:16:34,100
ขั้นตอนแรกคือการแบ่งข้อความออกเป็นชิ้นขนาด 11

259
00:16:34,100 --> 00:16:35,700
บิต

260
00:16:35,700 --> 00:16:40,340
แต่ละชิ้นจะถูกบรรจุลงในบล็อก 16 บิตที่ป้องกันข้อผิดพลาด

261
00:16:40,340 --> 00:16:43,740
ลองเอาอันนี้เป็นตัวอย่างแล้วลองทำจริงดู

262
00:16:43,740 --> 00:16:45,340
เอาเลย ทำได้จริง!

263
00:16:45,380 --> 00:16:47,380
ลองหยุดและลองประกอบบล็อกนี้ดู

264
00:16:52,980 --> 00:16:53,980
โอเค คุณพร้อมหรือยัง?

265
00:16:53,980 --> 00:16:58,500
โปรดจำไว้ว่า ตำแหน่ง 0 พร้อมด้วยกำลังอื่นๆ

266
00:16:58,500 --> 00:17:05,700
ของ 2 สงวนไว้สำหรับการแก้ไขข้อผิดพลาด ดังนั้นคุณจึงเริ่มต้นด้วยการวางบิตข้อความในจุดที่เหลือทั้งหมดตามลำดับ

267
00:17:05,700 --> 00:17:09,700
คุณต้องการให้กลุ่มนี้มีความเท่าเทียมกันซึ่งก็มีอยู่แล้ว ดังนั้นคุณควรตั้งค่าบิตพาริตีนั้นในตำแหน่ง 1

268
00:17:09,700 --> 00:17:13,140
ให้เป็น 0

269
00:17:13,140 --> 00:17:17,700
กลุ่มถัดไปเริ่มต้นด้วยแพริตีคี่ ดังนั้นคุณควรตั้งค่าพาริตีบิตให้เป็น

270
00:17:17,700 --> 00:17:19,260
1

271
00:17:19,260 --> 00:17:23,740
กลุ่มหลังจากนั้นเริ่มต้นด้วยพาริตีคี่ ดังนั้นคุณควรตั้งค่าพาริตีบิตเป็น

272
00:17:23,740 --> 00:17:24,740
1 อีกครั้ง

273
00:17:24,740 --> 00:17:29,500
และกลุ่มสุดท้ายยังมีความเท่าเทียมกันแบบคี่ ซึ่งหมายความว่าเราตั้งค่าบิตนั้นในตำแหน่ง 8

274
00:17:29,500 --> 00:17:31,500
ให้เป็น 1

275
00:17:31,500 --> 00:17:36,460
และในขั้นตอนสุดท้าย ตอนนี้บล็อกทั้งหมดมีความเท่าเทียมกัน ซึ่งหมายความว่าคุณสามารถตั้งค่าบิตนั้นให้เป็น 0

276
00:17:36,460 --> 00:17:41,500
ซึ่งเป็นบิตพาริตีที่ครอบคลุมให้เป็น 0 ได้

277
00:17:41,500 --> 00:17:45,660
ดังนั้นเมื่อบล็อกนี้ถูกส่งออกไป ความเท่าเทียมกันของชุดย่อยพิเศษสี่ชุดและบล็อกโดยรวมทั้งหมดจะเป็นเลขคู่หรือ

278
00:17:45,660 --> 00:17:48,980
0

279
00:17:48,980 --> 00:17:53,620
ในส่วนที่สองของแบบฝึกหัด ให้คุณสวมบทบาทเป็นผู้รับกัน

280
00:17:53,620 --> 00:17:57,580
แน่นอนว่านั่นหมายความว่าคุณไม่รู้ว่าข้อความนี้คืออะไร บางทีพวกคุณบางคนอาจจำมันได้

281
00:17:57,580 --> 00:18:00,180
แต่สมมติว่าคุณไม่ได้รู้

282
00:18:00,180 --> 00:18:05,820
สิ่งที่ฉันจะทำคือเปลี่ยน 0, 1 หรือ

283
00:18:05,820 --> 00:18:08,340
2 บิตในบล็อกนั้น แล้วขอให้คุณหาว่าฉันทำอะไร

284
00:18:08,340 --> 00:18:13,460
ดังนั้นอีกครั้ง ให้หยุดและลองออกกำลังกายดู

285
00:18:13,460 --> 00:18:23,960
โอเค ดังนั้นคุณในฐานะผู้รับจึงตรวจสอบกลุ่มพาริตีกลุ่มแรก และคุณจะเห็นว่ามันเป็นคู่

286
00:18:23,960 --> 00:18:29,820
ดังนั้นข้อผิดพลาดใดๆ ที่มีอยู่จะต้องอยู่ในคอลัมน์คู่

287
00:18:29,820 --> 00:18:34,620
การตรวจสอบครั้งถัดไปจะให้เลขคี่แก่เรา โดยบอกเราทั้งคู่ว่ามีข้อผิดพลาดอย่างน้อยหนึ่งรายการ

288
00:18:34,620 --> 00:18:38,760
และจำกัดเราให้แคบลงในคอลัมน์เฉพาะนี้

289
00:18:38,760 --> 00:18:42,900
การตรวจสอบครั้งที่สามคือการตรวจสอบแบบเท่าๆ กัน โดยลดความเป็นไปได้ลงไปอีก

290
00:18:42,900 --> 00:18:46,780
และการตรวจสอบพาริตีครั้งล่าสุดเป็นเลขคี่ โดยบอกเราว่า มีข้อผิดพลาดอยู่ที่ไหนสักแห่งที่ด้านล่าง

291
00:18:46,780 --> 00:18:51,700
ซึ่งตอนนี้เรามองเห็นแล้วว่าจะต้องอยู่ในตำแหน่งที่ 10

292
00:18:51,700 --> 00:18:56,140
ยิ่งไปกว่านั้น ความเท่าเทียมกันของทั้งบล็อกนั้นแปลก

293
00:18:56,140 --> 00:18:58,220
ทำให้เรามั่นใจว่ามีการพลิกหนึ่งครั้งไม่ใช่สองครั้ง

294
00:18:58,220 --> 00:19:01,600
หากเป็นสามหรือมากกว่า การเดิมพันทั้งหมดจะเป็นโมฆะ

295
00:19:01,600 --> 00:19:06,520
หลังจากแก้ไขบิตหมายเลข 10 แล้ว

296
00:19:06,520 --> 00:19:11,620
การดึง 11

297
00:19:11,620 --> 00:19:16,160
บิตที่ไม่ได้ใช้สำหรับการแก้ไขออกมาจะทำให้เราทราบถึงส่วนที่เกี่ยวข้องของข้อความต้นฉบับ ซึ่งหากคุณกรอกลับและเปรียบเทียบจะเป็นสิ่งที่เราเริ่มตัวอย่างด้วย

298
00:19:16,160 --> 00:19:19,260
และตอนนี้คุณก็ได้ทราบวิธีการทำทั้งหมดนี้ด้วยมือแล้ว ฉันอยากจะแสดงให้คุณเห็นว่าคุณสามารถดำเนินการส่วนหลักของตรรกะทั้งหมดนี้ด้วยโค้ด

299
00:19:19,260 --> 00:19:23,940
Python เพียงบรรทัดเดียวได้อย่างไร

300
00:19:23,940 --> 00:19:28,400
คุณเห็นไหมว่าสิ่งที่ฉันยังไม่ได้บอกคุณคือความสง่างามของอัลกอริธึมนี้จริงๆ ความง่ายแค่ไหนในการให้เครื่องจักรชี้ไปที่ตำแหน่งของข้อผิดพลาด

301
00:19:28,400 --> 00:19:32,380
วิธีปรับขนาดอย่างเป็นระบบ

302
00:19:32,380 --> 00:19:37,680
และวิธีที่เราสามารถจัดเฟรมทั้งหมด

303
00:19:37,680 --> 00:19:39,580
นี่เป็นการดำเนินการเดียวแทนที่จะเป็นการตรวจสอบพาริตีแยกกันหลายครั้ง

304
00:19:39,580 --> 00:19:41,680
หากต้องการดูว่าฉันหมายถึงอะไร มาร่วมกับฉันในส่วนที่ 2

