[
 {
  "input": "I'm assuming that everybody here is coming from part 1. ",
  "translatedText": "من فرض می کنم که همه اینجا از قسمت 1 آمده اند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 0.0,
  "end": 2.56
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it. ",
  "translatedText": "ما در مورد کدهای همینگ صحبت می‌کردیم، راهی برای ایجاد یک بلوک از داده‌ها که در آن بیشتر بیت‌ها پیامی معنادار دارند، در حالی که چند بیت دیگر به‌عنوان نوعی افزونگی عمل می‌کنند، به گونه‌ای که اگر بیتی برگردانده شد، یا یک پیام. بیت یا بیت افزونگی، هر چیزی در این بلوک، گیرنده می‌تواند تشخیص دهد که یک خطا وجود داشته است، و چگونه آن را برطرف کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.06,
  "end": 21.24
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error. ",
  "translatedText": "ایده اصلی ارائه شده در آنجا این بود که چگونه از چندین بررسی برابری برای جستجوی باینری برای رسیدن به خطا استفاده کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 21.88,
  "end": 27.16
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible. ",
  "translatedText": "در آن ویدئو، هدف این بود که کدهای همینگ را تا حد امکان به صورت دستی و قابل کشف مجدد ایجاد کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 28.98,
  "end": 34.6
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are. ",
  "translatedText": "اما وقتی شروع به فکر کردن در مورد اجرای واقعی این کدها، چه در نرم‌افزار یا سخت‌افزار، می‌کنید، این قاب‌بندی ممکن است واقعاً از ظریف بودن این کدها کم‌فروش کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 35.18,
  "end": 43.46
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that. ",
  "translatedText": "ممکن است فکر کنید که باید الگوریتمی بنویسید که تمام مکان‌های خطای احتمالی را ردیابی کند و با هر بررسی آن گروه را به نصف کاهش دهد، اما در واقع بسیار ساده‌تر از این است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 43.92,
  "end": 53.48
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary. ",
  "translatedText": "اگر پاسخ‌های چهار بررسی برابری را که در ویدیوی گذشته انجام دادیم، به‌جای بله و خیر به صورت 1 و 0 بخوانید، به معنای واقعی کلمه موقعیت خطا را در باینری مشخص می‌کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 53.94,
  "end": 64.08
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1. ",
  "translatedText": "به عنوان مثال، عدد 7 در باینری شبیه 0111 است، که در اصل می گوید که 4 به علاوه 2 به علاوه 1 است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 64.78,
  "end": 71.26
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last. ",
  "translatedText": "و توجه کنید که موقعیت 7 در کجا قرار می گیرد، اولین گروه از گروه های برابری ما را تحت تاثیر قرار می دهد، و دوم، و سوم، اما نه آخرین. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 72.54,
  "end": 81.74
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error. ",
  "translatedText": "بنابراین خواندن نتایج آن چهار بررسی از پایین به بالا واقعاً موقعیت خطا را مشخص می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 82.22,
  "end": 87.54
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple. ",
  "translatedText": "هیچ چیز خاصی در مورد مثال 7 وجود ندارد، این به طور کلی کار می کند، و این منطق اجرای کل طرح در سخت افزار را به طرز تکان دهنده ای ساده می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 88.32,
  "end": 95.82
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111. ",
  "translatedText": "حالا اگر می‌خواهید ببینید چرا این جادو اتفاق می‌افتد، این 16 برچسب شاخص را برای موقعیت‌های ما انتخاب کنید، اما به جای نوشتن آنها در پایه 10، بیایید همه آنها را به صورت باینری بنویسیم، از 0000 تا 1111 اجرا شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 97.24,
  "end": 109.88
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent. ",
  "translatedText": "همانطور که این برچسب‌های باینری را دوباره در جعبه‌هایشان قرار می‌دهیم، اجازه دهید تأکید کنم که آنها از داده‌هایی که واقعاً ارسال می‌شوند متمایز هستند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 110.56,
  "end": 117.8
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from. ",
  "translatedText": "آنها چیزی بیش از یک برچسب مفهومی برای کمک به من و شما نیستند که بفهمیم چهار گروه برابری از کجا آمده اند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 118.32,
  "end": 123.5
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary. ",
  "translatedText": "ظرافت داشتن هر چیزی که ما به آن نگاه می کنیم به صورت باینری توصیف می شود، شاید به دلیل سردرگمی توصیف شدن هر چیزی که ما به آن نگاه می کنیم به صورت دودویی تضعیف شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 124.14,
  "end": 132.36
 },
 {
  "input": "It's worth it, though. ",
  "translatedText": "هرچند ارزشش را دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.02,
  "end": 134.12
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1. ",
  "translatedText": "توجه خود را فقط روی آخرین بیت تمام این برچسب ها متمرکز کنید و سپس موقعیت هایی را که بیت نهایی 1 است، برجسته کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 134.8,
  "end": 143.22
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1? ",
  "translatedText": "چیزی که دریافت می کنیم اولین گروه از چهار گروه برابری ما است، به این معنی که می توانید اولین بررسی را به این صورت تفسیر کنید که اگر خطایی وجود دارد، آیا بیت نهایی در موقعیت آن خطا 1 است؟ به طور مشابه، اگر روی بیت دوم تا آخر تمرکز کنید و تمام موقعیت‌هایی را که در آن 1 است برجسته کنید، گروه برابری دوم را از طرح ما دریافت می‌کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 144.24,
  "end": 155.74
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 158.2,
  "end": 166.16
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1? ",
  "translatedText": "به عبارت دیگر، آن چک دوم از شما می پرسد، دوباره سلام، اگر خطایی وجود دارد، آیا بیت دوم تا آخر آن موقعیت 1 است؟ و غیره. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 166.74,
  "end": 174.5
 },
 {
  "input": "And so on. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 175.76,
  "end": 176.9
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1. ",
  "translatedText": "بررسی برابری سوم هر موقعیتی را که بیت سوم تا آخرین بیت آن روشن است و آخرین مورد هشت موقعیت آخر را پوشش می دهد، آنهایی که بالاترین بیت مرتبه آنها 1 است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 177.22,
  "end": 188.74
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary. ",
  "translatedText": "هر کاری که قبلا انجام دادیم مانند پاسخ دادن به این چهار سوال است، که به نوبه خود مانند املای یک موقعیت در باینری است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 189.74,
  "end": 197.74
 },
 {
  "input": "I hope this makes two things clearer. ",
  "translatedText": "امیدوارم این دو چیز را واضح تر کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 199.62,
  "end": 201.48
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two. ",
  "translatedText": "اولین مورد این است که چگونه به طور سیستماتیک به اندازه های بلوکی که قدرت های دو بزرگتر هستند تعمیم دهیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.04,
  "end": 206.46
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check. ",
  "translatedText": "اگر برای توصیف هر موقعیت، بیت‌های بیشتری طول می‌کشد، مانند شش بیت برای توصیف 64 نقطه، هر کدام از آن بیت‌ها یکی از گروه‌های برابری را به شما می‌دهند که باید بررسی کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 206.96,
  "end": 216.68
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar. ",
  "translatedText": "کسانی از شما که پازل صفحه شطرنج را که من با مت پارکر انجام دادم تماشا کردند، ممکن است همه اینها را بسیار آشنا بیابند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.4,
  "end": 223.18
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard. ",
  "translatedText": "این همان منطق اصلی است، اما حل یک مشکل متفاوت، و در یک صفحه شطرنج 64 مربع اعمال می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 223.66,
  "end": 228.78
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8. ",
  "translatedText": "دومین چیزی که امیدوارم روشن شود این است که چرا بیت های برابری ما در موقعیت هایی قرار دارند که قدرت های دو هستند، برای مثال 1، 2، 4 و 8. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 229.88,
  "end": 237.32
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on. ",
  "translatedText": "اینها موقعیت هایی هستند که نمایش باینری آنها فقط یک بیت روشن است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 238.0,
  "end": 243.0
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups. ",
  "translatedText": "این بدان معناست که هر یک از آن بیت های برابری در یک و تنها یکی از چهار گروه برابری قرار می گیرند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.6,
  "end": 249.46
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups. ",
  "translatedText": "همچنین می‌توانید این را در نمونه‌های بزرگ‌تر ببینید، جایی که مهم نیست چقدر بزرگ می‌شوید، هر بیت برابری به راحتی تنها یکی از گروه‌ها را لمس می‌کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 252.04,
  "end": 259.34
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code. ",
  "translatedText": "هنگامی که متوجه شدید که این بررسی‌های برابری که ما بیشتر وقت خود را بر روی آنها متمرکز کرده‌ایم، چیزی جز روشی هوشمندانه برای مشخص کردن موقعیت یک خطا در باینری نیست، آنگاه می‌توانیم با روشی متفاوت برای تفکر در مورد همینگ ارتباط برقرار کنیم. کدهایی که مسلماً بسیار ساده‌تر و ظریف‌تر هستند و اساساً می‌توان آن‌ها را با یک خط کد نوشت. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.6,
  "end": 283.24
 },
 {
  "input": "It's based on the XOR function. ",
  "translatedText": "این بر اساس تابع XOR است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 283.66,
  "end": 285.5
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or. ",
  "translatedText": "XOR، برای کسانی از شما که نمی دانند، مخفف منحصر به فرد یا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 286.94,
  "end": 290.22
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off. ",
  "translatedText": "هنگامی که XOR دو بیت را می گیرید، اگر یکی از آن بیت ها روشن باشد، 1 برمی گردد، اما اگر هر دو روشن یا خاموش باشند، نه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 290.78,
  "end": 299.36
 },
 {
  "input": "Phrased differently, it's the parity of these two bits. ",
  "translatedText": "با بیان متفاوت، برابری این دو بیت است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.1,
  "end": 302.98
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2. ",
  "translatedText": "به عنوان یک فرد ریاضی، ترجیح می دهم در مورد آن به عنوان مد 2 فکر کنم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 303.54,
  "end": 306.76
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component. ",
  "translatedText": "ما همچنین معمولاً در مورد XOR دو رشته بیت مختلف صحبت می کنیم که اساساً این جزء به جزء انجام می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 307.36,
  "end": 313.44
 },
 {
  "input": "It's like addition, but where you never carry. ",
  "translatedText": "این مانند اضافه است، اما جایی که هرگز حمل نمی کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 313.68,
  "end": 315.72
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2. ",
  "translatedText": "باز هم، کسانی که تمایل بیشتری به ریاضی دارند ممکن است ترجیح دهند این را به عنوان افزودن دو بردار و کاهش mod 2 در نظر بگیرند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 316.5,
  "end": 322.48
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood. ",
  "translatedText": "اگر همین الان پایتون را باز کنید و عملیات caret را بین دو عدد صحیح اعمال کنید، این همان کاری است که انجام می‌دهد به جز نمایش بیت‌های آن اعداد زیر سرپوش. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 323.5,
  "end": 332.94
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop. ",
  "translatedText": "نکته کلیدی برای من و شما این است که گرفتن XOR از بسیاری از رشته‌های بیتی مختلف، به طور موثر راهی برای محاسبه تقلید هجو دسته‌ای از گروه‌های جداگانه است، مانند ستون‌ها، همه در یک لحظه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 334.96,
  "end": 347.14
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation. ",
  "translatedText": "این به ما یک روش نسبتاً جالب می دهد تا در مورد بررسی های برابری چندگانه از الگوریتم کد Hamming خود فکر کنیم زیرا همه با هم در یک عملیات واحد بسته بندی می شوند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 351.26,
  "end": 358.78
 },
 {
  "input": "Though at first glance it does look very different. ",
  "translatedText": "اگرچه در نگاه اول بسیار متفاوت به نظر می رسد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 359.48,
  "end": 362.18
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR. ",
  "translatedText": "به طور خاص 16 موقعیت را به صورت باینری بنویسید، همانطور که قبلاً داشتیم، و اکنون موقعیت هایی را که بیت پیام در آنها روشن است به 1 برجسته کنید، و سپس این موقعیت ها را در یک ستون بزرگ جمع کنید و XOR را بگیرید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 362.82,
  "end": 377.1
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly. ",
  "translatedText": "احتمالاً می‌توانید حدس بزنید که 4 بیتی که در نتیجه پایین قرار می‌گیرند، همان 4 بررسی برابری هستند که ما می‌شناسیم و دوستش داریم، اما لحظه‌ای وقت بگذارید و واقعاً به این فکر کنید که چرا دقیقاً چرا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 379.26,
  "end": 389.2
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group. ",
  "translatedText": "برای مثال، این آخرین ستون، تمام موقعیت‌هایی را که آخرین بیت آنها 1 است، می‌شمرد، اما ما در حال حاضر فقط به موقعیت‌های برجسته‌شده محدود شده‌ایم، بنابراین به طور موثر شمارش می‌کند که چند موقعیت برجسته از گروه برابری اول آمده است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 392.22,
  "end": 405.76
 },
 {
  "input": "Does that make sense? ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 406.24,
  "end": 406.8
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on. ",
  "translatedText": "فرقی میکنه؟ به همین ترتیب، ستون بعدی تعداد موقعیت‌های گروه برابری دوم، موقعیت‌هایی که بیت دوم تا آخر آنها 1 است و همچنین برجسته شده‌اند و غیره می‌شمارند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 409.08,
  "end": 420.0
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing. ",
  "translatedText": "این واقعاً فقط یک تغییر کوچک در دیدگاه نسبت به همان کاری است که ما انجام می‌دادیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 420.26,
  "end": 423.96
 },
 {
  "input": "And so you know where it goes from here. ",
  "translatedText": "و بنابراین می دانید که از اینجا به کجا می رود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 427.76,
  "end": 429.6
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000. ",
  "translatedText": "فرستنده مسئول تغییر برخی از بیت های برابری ویژه است تا مطمئن شود که مجموع آنها 0000 است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 430.0,
  "end": 436.56
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error. ",
  "translatedText": "حالا وقتی آن را به این شکل داشته باشیم، این روش واقعاً خوبی به ما می دهد تا فکر کنیم چرا این چهار بیت حاصل در پایین به طور مستقیم موقعیت یک خطا را مشخص می کنند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 439.04,
  "end": 447.58
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1. ",
  "translatedText": "فرض کنید مقداری از بیت در این بلوک از 0 به 1 تغییر می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 448.46,
  "end": 451.86
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error. ",
  "translatedText": "معنی آن این است که موقعیت آن بیت اکنون در XOR کل گنجانده می شود، که مجموع را از 0 به جای این مقدار جدید اضافه شده، یعنی موقعیت خطا، تغییر می دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 452.6,
  "end": 463.82
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0. ",
  "translatedText": "واضح است که کمی کمتر، اگر خطایی وجود داشته باشد که 1 را به 0 تغییر دهد، همین امر صادق است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 464.46,
  "end": 469.36
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0. ",
  "translatedText": "ببینید، اگر یک رشته بیت را دو بار با هم اضافه کنید، مثل این است که اصلاً آن را نداشته باشید، اساساً به این دلیل که در این دنیا 1 به اضافه 1 برابر با 0 است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 470.18,
  "end": 477.94
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it. ",
  "translatedText": "بنابراین افزودن یک کپی از این موقعیت به مجموع کل همان اثری را دارد که ما آن را جابجا می کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 478.92,
  "end": 484.3
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error. ",
  "translatedText": "و آن اثر، دوباره، این است که نتیجه کل در پایین اینجا موقعیت خطا را مشخص می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 485.16,
  "end": 490.7
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end. ",
  "translatedText": "برای نشان دادن زیبایی این موضوع، اجازه دهید یک خط از کد پایتون را که قبلاً به آن ارجاع دادم نشان دهم، که تقریباً تمام منطق انتهای گیرنده را نشان می‌دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 493.04,
  "end": 501.44
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits. ",
  "translatedText": "ما با ایجاد یک آرایه تصادفی از 16 1 و 0 برای شبیه سازی بلوک داده شروع می کنیم، و من بیت های نام را به آن می دهم، اما البته در عمل این چیزی است که ما از فرستنده دریافت می کنیم، و به جای تصادفی بودن، 11 بیت داده همراه با 5 بیت برابری را حمل می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 502.08,
  "end": 517.4
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15. ",
  "translatedText": "اگر تابع enumerateBits را صدا بزنم، کاری که انجام می دهد این است که هر یک از آن بیت ها را با یک شاخص مربوطه جفت می کند، در این مورد از 0 تا 15 اجرا می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 518.12,
  "end": 527.0
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15. ",
  "translatedText": "بنابراین، اگر لیستی ایجاد کنیم که روی همه این جفت‌ها حلقه بزند، جفت‌هایی که شبیه i هستند، و سپس فقط مقدار i، فقط شاخص را بیرون بیاوریم، خوب آنقدرها هم هیجان‌انگیز نیست، فقط آن شاخص‌ها را از 0 تا 15 برمی‌گردانیم. . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 528.18,
  "end": 541.34
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on. ",
  "translatedText": "اما اگر شرط را اضافه کنیم که فقط اگر بیت این کار را انجام دهد، به این معنی که اگر آن بیت 1 باشد و 0 نباشد، خوب آنگاه فقط موقعیت هایی را که بیت مربوطه روشن است بیرون می کشد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 541.68,
  "end": 552.66
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc. ",
  "translatedText": "در این حالت به نظر می رسد که آن موقعیت ها 0، 4، 6، 9 و غیره هستند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 553.38,
  "end": 557.96
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together. ",
  "translatedText": "چیزی که می‌خواهیم این است که همه آن موقعیت‌ها، موقعیت‌های بیت‌هایی که روشن شده‌اند را جمع‌آوری کنیم و سپس آنها را با هم XOR کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 559.98,
  "end": 567.24
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions. ",
  "translatedText": "برای انجام این کار در پایتون، اجازه دهید ابتدا چند تابع مفید را وارد کنم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.18,
  "end": 573.22
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it. ",
  "translatedText": "به این ترتیب می‌توانیم ()reduce را در این لیست فراخوانی کنیم و از تابع XOR برای کاهش آن استفاده کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 573.9,
  "end": 578.7
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way. ",
  "translatedText": "این اساساً راه خود را از طریق لیست می خورد و XOR ها را در طول راه می برد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.1,
  "end": 582.68
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere. ",
  "translatedText": "اگر ترجیح می دهید، می توانید به صراحت آن تابع XOR را بدون نیاز به وارد کردن آن از جایی بنویسید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 584.8,
  "end": 589.44
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001. ",
  "translatedText": "بنابراین در حال حاضر به نظر می رسد که اگر این کار را روی بلوک تصادفی 16 بیتی خود انجام دهیم، 9 را برمی گرداند که نمایش باینری 1001 دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 591.94,
  "end": 601.28
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0. ",
  "translatedText": "ما این کار را در اینجا انجام نمی دهیم، اما می توانید تابعی بنویسید که در آن فرستنده از آن نمایش باینری برای تنظیم چهار بیت برابری در صورت نیاز استفاده کند، در نهایت این بلوک به حالتی می رسد که اجرای این خط کد در لیست کامل بیت ها برمی گردد. یک 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 601.98,
  "end": 615.46
 },
 {
  "input": "This would be considered a well-prepared block. ",
  "translatedText": "این یک بلوک به خوبی آماده شده در نظر گرفته می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 616.08,
  "end": 618.2
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error. ",
  "translatedText": "نکته جالب این است که اگر هر یک از بیت‌های این لیست را تغییر دهیم، یک خطای تصادفی از نویز را شبیه‌سازی کنیم، سپس اگر همین خط کد را اجرا کنید، آن خطا را چاپ می‌کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 619.88,
  "end": 630.22
 },
 {
  "input": "Isn't that neat? ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 630.96,
  "end": 631.52
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any. ",
  "translatedText": "این تمیز نیست؟ می‌توانید این بلوک را از حالت آبی دریافت کنید، این خط را روی آن اجرا کنید و به طور خودکار موقعیت یک خطا یا 0 را در صورت نبودن نشان می‌دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 631.82,
  "end": 641.06
 },
 {
  "input": "And there's nothing special about the size 16 here. ",
  "translatedText": "و هیچ چیز خاصی در مورد سایز 16 در اینجا وجود ندارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 642.5,
  "end": 645.2
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits. ",
  "translatedText": "اگر لیستی از مثلاً 256 بیت داشته باشید، همان خط کد کار می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 645.4,
  "end": 649.86
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction. ",
  "translatedText": "نیازی به گفتن نیست، کدهای بیشتری برای نوشتن در اینجا وجود دارد، مانند انجام بررسی متا برابری برای تشخیص خطاهای 2 بیتی، اما ایده این است که تقریباً تمام منطق اصلی طرح ما به یک کاهش XOR منتهی می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 651.88,
  "end": 663.76
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go. ",
  "translatedText": "اکنون، بسته به راحتی شما با باینری و XOR و به طور کلی نرم افزار، ممکن است این دیدگاه را کمی گیج کننده بیابید، یا آنقدر زیباتر و ساده تر که تعجب کنید که چرا ما از ابتدا با آن شروع نکردیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.12,
  "end": 678.42
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level. ",
  "translatedText": "-برو به زبان ساده، در هنگام پیاده‌سازی کدهای همینگ در سخت‌افزار به‌طور مستقیم می‌توان به دیدگاه بررسی برابری چندگانه فکر کرد، و در هنگام انجام آن در نرم‌افزار، از سطح بالاتر، راحت‌تر به دیدگاه XOR فکر می‌شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 679.14,
  "end": 690.5
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles. ",
  "translatedText": "اولین مورد ساده‌ترین کار است که واقعاً با دست انجام می‌شود، و من فکر می‌کنم با القای شهود اصلی زیربنای همه این‌ها کار بهتری انجام می‌دهد، یعنی اطلاعات مورد نیاز برای یافتن یک خطا مربوط به گزارش اندازه بلوک است. ، یا به عبارت دیگر، با دو برابر شدن اندازه بلوک، هر بار یک بیت رشد می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 691.36,
  "end": 710.0
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need. ",
  "translatedText": "واقعیت مرتبط در اینجا این است که آن اطلاعات به طور مستقیم با میزان افزونگی مورد نیاز ما مطابقت دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 711.02,
  "end": 716.06
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind. ",
  "translatedText": "این واقعاً چیزی است که در برابر واکنش تند و تیز اکثر افراد زمانی که برای اولین بار در مورد ایجاد یک پیام مقاوم در برابر خطاها فکر می کنند، مخالف است، جایی که معمولاً کپی کردن کل پیام اولین غریزی است که به ذهن می رسد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.66,
  "end": 726.54
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix. ",
  "translatedText": "و بعد، اتفاقاً، این راه کاملاً وجود دارد که گاهی اوقات کدهای همینگ را مشاهده می کنید که در آن پیام را در یک ماتریس بزرگ ضرب می کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 727.5,
  "end": 734.0
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales. ",
  "translatedText": "به نوعی خوب است زیرا آن را به خانواده گسترده‌تر کدهای خطی مرتبط می‌کند، اما من فکر می‌کنم که تقریباً هیچ شهودی برای اینکه از کجا آمده یا چگونه مقیاس می‌شود، نمی‌دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 734.67,
  "end": 743.06
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size. ",
  "translatedText": "و در مورد مقیاس بندی، ممکن است متوجه شوید که با افزایش اندازه بلوک، کارایی این طرح بهتر می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 745.2,
  "end": 751.16
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there. ",
  "translatedText": "به عنوان مثال، ما دیدیم که با 256 بیت، شما فقط از 3٪ از آن فضا برای افزونگی استفاده می کنید، و از آنجا به بعد بهتر می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 755.0,
  "end": 762.66
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling. ",
  "translatedText": "همانطور که تعداد بیت های برابری یکی یکی افزایش می یابد، اندازه بلوک دو برابر می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 763.3,
  "end": 767.34
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits. ",
  "translatedText": "و اگر آن را به حد افراط برسانید، می‌توانید بلوکی با مثلاً یک میلیون بیت داشته باشید، که در آن به معنای واقعی کلمه 20 سؤال را با بررسی‌های برابری خود بازی می‌کنید و فقط از 21 بیت برابری استفاده می‌کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 769.0,
  "end": 780.02
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy. ",
  "translatedText": "و اگر به عقب برگردید و به یک میلیون بیت نگاه کنید و یک خطا را پیدا کنید، واقعاً دیوانه کننده است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 780.74,
  "end": 787.06
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that. ",
  "translatedText": "البته مشکل این است که با یک بلوک بزرگتر، احتمال مشاهده خطاهای بیش از یک یا دو بیت بالا می رود و کدهای همینگ چیزی فراتر از آن را کنترل نمی کنند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 788.2,
  "end": 797.66
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high. ",
  "translatedText": "بنابراین در عمل، چیزی که می خواهید این است که اندازه مناسب را پیدا کنید تا احتمال تلنگرهای بیش از حد بیت خیلی زیاد نباشد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 798.32,
  "end": 804.3
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored. ",
  "translatedText": "همچنین، در عمل، خطاها معمولاً به صورت پشت سر هم ظاهر می‌شوند، که یک بلوک را کاملاً خراب می‌کند، بنابراین یک تاکتیک رایج برای کمک به گسترش خطاها در بسیاری از بلوک‌های مختلف این است که آن بلوک‌ها، مانند این، قبل از اینکه به هم بریزند ارسال یا ذخیره می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 806.6,
  "end": 820.98
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block. ",
  "translatedText": "سپس، بسیاری از این موارد به‌طور کامل توسط کدهای مدرن‌تر ارائه می‌شوند، مانند الگوریتم بسیار رایج‌تر Reed-Solomon، که به‌خوبی خطاهای انفجاری را مدیریت می‌کند، و می‌توان آن را به گونه‌ای تنظیم کرد که در برابر تعداد بیشتری از خطاها در هر بلوک انعطاف‌پذیر باشد. . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 825.58,
  "end": 838.82
 },
 {
  "input": "But that's a topic for another time. ",
  "translatedText": "اما این موضوع برای زمان دیگری است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.36,
  "end": 841.34
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was. ",
  "translatedText": "هامینگ در کتاب خود به نام هنر انجام علم و مهندسی به طرز شگفت انگیزی در مورد اینکه کشف این رمز چقدر پر پیچ و خم بود، صریح است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 842.5,
  "end": 849.94
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this. ",
  "translatedText": "او ابتدا انواع طرح‌های مختلف را امتحان کرد که شامل سازماندهی بیت‌ها در بخش‌هایی از شبکه‌ای با ابعاد بالاتر و چیزهای عجیبی مانند این بود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 850.62,
  "end": 857.78
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this? ",
  "translatedText": "این ایده که ممکن است بررسی‌های برابری به گونه‌ای توطئه شود که موقعیت خطا را مشخص کند، تنها زمانی به ذهن همینگ رسید که او پس از یک سری تحلیل دیگر عقب‌نشینی کرد و پرسید، بسیار خوب، کارآمدترین کاری که می‌توانم داشتم چیست؟ ممکن است در مورد این باشد؟ او همچنین در مورد اینکه چقدر مهم است که چک‌های برابری در ذهنش بود، که در دهه ۱۹۴۰ بسیار کمتر از امروز رایج بود، صادق بود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 858.3,
  "end": 871.52
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 872.62,
  "end": 881.22
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind. ",
  "translatedText": "در سراسر این کتاب تقریباً دوازده بار است که او به نقل قول لویی پاستور اشاره می کند، شانس به نفع ذهن آماده است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 881.92,
  "end": 888.22
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate. ",
  "translatedText": "ایده‌های هوشمندانه اغلب در آینده به طرز فریبنده‌ای ساده به نظر می‌رسند، که باعث می‌شود به راحتی از آنها قدردانی نشوند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 889.32,
  "end": 894.3
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you. ",
  "translatedText": "در حال حاضر امید صادقانه من این است که کدهای Hamming یا حداقل امکان چنین کدهایی برای شما تقریباً واضح است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 894.96,
  "end": 901.3
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't. ",
  "translatedText": "اما نباید خودتان را گول بزنید که فکر کنید آنها در واقع واضح هستند، زیرا قطعاً اینطور نیستند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 901.66,
  "end": 906.82
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that. ",
  "translatedText": "بخشی از دلیل اینکه ایده‌های هوشمندانه به طرز فریبنده‌ای آسان به نظر می‌رسند این است که ما فقط نتیجه نهایی را می‌بینیم، تمیز کردن چیزهایی که به هم ریخته بود، هرگز به همه چرخش‌های اشتباه اشاره نمی‌کنیم، و کم‌فروش بودن فضای احتمالات قابل کشف در ابتدای یک مشکل را کم می‌کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 907.88,
  "end": 922.86
 },
 {
  "input": "But this is true in general. ",
  "translatedText": "فرآیند حل، همه اینها اما این به طور کلی درست است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 923.82,
  "end": 924.9
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them. ",
  "translatedText": "من فکر می کنم برای برخی اختراعات خاص، دلیل دوم و عمیق تری وجود دارد که ما از آنها قدردانی نمی کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 924.9,
  "end": 930.04
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory. ",
  "translatedText": "اندیشیدن به اطلاعات بر حسب بیت، تنها در سال 1948 با مقاله اصلی کلود شانون در مورد نظریه اطلاعات، در یک نظریه کامل ادغام شد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 930.84,
  "end": 938.64
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm. ",
  "translatedText": "این اساساً با زمانی که هامینگ الگوریتم خود را توسعه داد همزمان بود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 939.28,
  "end": 942.54
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory. ",
  "translatedText": "این همان مقاله بنیادی بود که نشان داد، به معنای خاصی، تصحیح خطای کارآمد همیشه امکان پذیر است، مهم نیست که احتمال تلنگر بیت چقدر بالا باشد، حداقل در تئوری. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 943.3,
  "end": 952.9
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here. ",
  "translatedText": "به هر حال، شانون و همینگ، علیرغم کار بر روی چیزهای بسیار متفاوت، دفتری در آزمایشگاه بل مشترک داشتند، که در اینجا به سختی تصادفی به نظر می رسد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.7,
  "end": 961.16
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was. ",
  "translatedText": "چندین دهه به سرعت به جلو، و این روزها، بسیاری از ما چنان غرق در فکر کردن در مورد بیت ها و اطلاعات هستیم که به راحتی می توان از تفاوت این طرز تفکر چشم پوشی کرد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.38,
  "end": 972.34
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are. ",
  "translatedText": "از قضا، ایده‌هایی که عمیق‌ترین روش‌هایی را که یک نسل آینده فکر می‌کند شکل می‌دهند، در نهایت به آن نسل آینده ساده‌تر از آنچه واقعا هستند نگاه می‌کنند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 973.1,
  "end": 982.26
 }
]