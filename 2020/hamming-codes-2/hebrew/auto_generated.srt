1
00:00:00,000 --> 00:00:02,560
אני מניח שכולם כאן מגיעים מחלק 1.

2
00:00:03,060 --> 00:00:08,972
דיברנו על קודי Hamming, דרך ליצור גוש נתונים שבו רוב הביטים נושאים מסר משמעותי, 

3
00:00:08,972 --> 00:00:14,145
בעוד שכמה אחרים פועלים כסוג של יתירות, באופן כזה שאם ביט כלשהו יתהפך, 

4
00:00:14,145 --> 00:00:17,988
או הודעה סיביות או סיביות יתירות, כל דבר בבלוק הזה, 

5
00:00:17,988 --> 00:00:21,240
מקלט יוכל לזהות שהייתה שגיאה ואיך לתקן אותה.

6
00:00:21,880 --> 00:00:24,438
הרעיון הבסיסי שהוצג שם היה כיצד להשתמש בבדיקות 

7
00:00:24,438 --> 00:00:27,160
זוגיות מרובות כדי לחפש בינארי בדרך למטה אל השגיאה.

8
00:00:28,980 --> 00:00:34,600
בסרטון ההוא המטרה הייתה לגרום לקודי האמינג להרגיש מעשיים וניתנים לגילוי מחדש ככל האפשר.

9
00:00:35,180 --> 00:00:39,217
אבל כשאתה מתחיל לחשוב על יישום זה בפועל, בתוכנה או בחומרה, 

10
00:00:39,217 --> 00:00:43,460
המסגור הזה עשוי למעשה להמחיש עד כמה הקודים האלה אלגנטיים באמת.

11
00:00:43,920 --> 00:00:48,829
אולי אתה חושב שאתה צריך לכתוב אלגוריתם שעוקב אחר כל מיקומי השגיאות האפשריים 

12
00:00:48,829 --> 00:00:53,480
וחותך את הקבוצה הזו לשניים עם כל בדיקה, אבל זה למעשה הרבה יותר פשוט מזה.

13
00:00:53,940 --> 00:00:59,048
אם אתה קורא את התשובות לארבעת בדיקות השוויון שעשינו בסרטון האחרון, 

14
00:00:59,048 --> 00:01:04,080
כולן בתור 1 ו-0 במקום כן ולא, זה ממש מפרט את מיקום השגיאה בבינארי.

15
00:01:04,780 --> 00:01:11,260
לדוגמה, המספר 7 בבינארי נראה כמו 0111, בעצם אומר שהוא 4 ועוד 2 ועוד 1.

16
00:01:12,540 --> 00:01:19,029
ושימו לב היכן יושבת עמדה 7, היא אכן משפיעה על הראשונה בקבוצות השוויוניות שלנו, 

17
00:01:19,029 --> 00:01:21,740
והשנייה, והשלישית, אך לא האחרונה.

18
00:01:22,220 --> 00:01:27,540
אז קריאת התוצאות של ארבעת הבדיקות הללו מלמטה למעלה אכן מפרטת את מיקומו של השגיאה.

19
00:01:28,320 --> 00:01:31,716
אין שום דבר מיוחד בדוגמה 7, זה עובד באופן כללי, 

20
00:01:31,716 --> 00:01:35,820
וזה הופך את ההיגיון ליישום כל הסכימה בחומרה לפשוטה להחריד.

21
00:01:37,240 --> 00:01:44,051
עכשיו אם אתה רוצה לראות למה הקסם הזה קורה, קח את 16 תוויות האינדקס האלה עבור העמדות שלנו, 

22
00:01:44,051 --> 00:01:49,880
אבל במקום לכתוב אותן בבסיס 10, בוא נכתוב את כולם בבינארי, החל מ-0000 עד 1111.

23
00:01:50,559 --> 00:01:54,490
כשאנחנו מחזירים את התוויות הבינאריות האלה לקופסאות שלהן, 

24
00:01:54,490 --> 00:01:57,800
הרשו לי להדגיש שהן שונות מהנתונים שנשלחים בפועל.

25
00:01:58,320 --> 00:02:03,500
הם לא יותר מאשר תווית מושגית כדי לעזור לך ולי להבין מאיפה הגיעו ארבע קבוצות השוויון.

26
00:02:04,140 --> 00:02:08,183
האלגנטיות של זה שכל מה שאנחנו מסתכלים עליו יתואר בבינארי הוא 

27
00:02:08,183 --> 00:02:12,360
אולי תחת הבלבול של זה שכל מה שאנחנו מסתכלים עליו מתואר בבינארי.

28
00:02:13,020 --> 00:02:14,120
אבל זה שווה את זה.

29
00:02:14,800 --> 00:02:19,092
מקד את תשומת לבך רק לחלק האחרון של כל התוויות הללו, 

30
00:02:19,092 --> 00:02:23,220
ולאחר מכן הדגש את המיקומים שבהם הקטע האחרון הוא 1.

31
00:02:24,240 --> 00:02:28,396
מה שאנחנו מקבלים היא הראשונה מבין ארבע קבוצות השוויון שלנו, 

32
00:02:28,396 --> 00:02:33,246
מה שאומר שאתה יכול לפרש את הסימון הראשון הזה כשואל, היי, אם יש שגיאה, 

33
00:02:33,246 --> 00:02:35,740
האם הביט האחרון במיקום השגיאה הוא 1?

34
00:02:38,200 --> 00:02:43,190
באופן דומה, אם אתה מתמקד בחלק השני עד האחרון, ומדגיש את כל המיקומים שבהם זה 1, 

35
00:02:43,190 --> 00:02:46,160
אתה מקבל את קבוצת השוויון השנייה מהתוכנית שלנו.

36
00:02:46,740 --> 00:02:50,580
במילים אחרות, הבדיקה השנייה שואלת, היי, שוב אני, 

37
00:02:50,580 --> 00:02:54,500
אם יש שגיאה, האם החלק השני אחרון במיקום הזה הוא 1?

38
00:02:55,760 --> 00:02:56,900
וכולי.

39
00:02:57,220 --> 00:03:02,664
בדיקת השוויון השלישית מכסה כל עמדה שהביט השלישי עד האחרון שלה מופעל, 

40
00:03:02,664 --> 00:03:08,740
והאחרון מכסה את שמונת העמדות האחרונות, אלה שהביט הסדר הגבוה ביותר שלהן הוא 1.

41
00:03:09,740 --> 00:03:17,740
כל מה שעשינו קודם לכן זהה למענה על ארבע השאלות הללו, וזה בתורו זהה לאיית מיקום בבינארי.

42
00:03:19,620 --> 00:03:21,480
אני מקווה שזה מבהיר שני דברים יותר.

43
00:03:22,040 --> 00:03:26,460
הראשון הוא איך להכליל באופן שיטתי לגדלי בלוקים שהם עצמות גדולות יותר של שניים.

44
00:03:26,960 --> 00:03:32,101
אם צריך יותר ביטים כדי לתאר כל מיקום, כמו שישה ביטים כדי לתאר 64 נקודות, 

45
00:03:32,101 --> 00:03:36,680
אז כל אחד מהסיביות האלה נותן לך אחת מקבוצות הזוגיות שעלינו לבדוק.

46
00:03:38,400 --> 00:03:43,180
אלו מכם שצפו בפאזל לוח השחמט שעשיתי עם מאט פארקר עשויים למצוא את כל זה מוכר מאוד.

47
00:03:43,660 --> 00:03:48,780
זה אותו היגיון הליבה, אבל פתרון בעיה אחרת, מיושם על לוח שחמט של 64 ריבוע.

48
00:03:49,880 --> 00:03:53,566
הדבר השני שאני מקווה שזה מבהיר הוא מדוע סיביות השוויון 

49
00:03:53,566 --> 00:03:57,320
שלנו יושבות בעמדות שהן חזקות של שתיים, למשל 1, 2, 4 ו-8.

50
00:03:58,000 --> 00:04:03,000
אלו הן העמדות שהייצוג הבינארי שלהן הופעל רק ביט בודד.

51
00:04:03,600 --> 00:04:09,460
המשמעות היא שכל אחד מאותם סיביות זוגיות יושב בתוך אחת ויחידה מארבע קבוצות הזוגיות.

52
00:04:12,040 --> 00:04:16,550
אתה יכול לראות זאת גם בדוגמאות גדולות יותר, שבהן לא משנה כמה גדול אתה מקבל, 

53
00:04:16,550 --> 00:04:19,339
כל סיביות זוגיות נוגעת בנוחות רק באחת מהקבוצות.

54
00:04:25,600 --> 00:04:31,365
ברגע שתבינו שבדיקות השוויון האלה שהתמקדנו בהן כל כך הרבה מזמננו הן לא יותר מאשר דרך 

55
00:04:31,365 --> 00:04:37,268
חכמה לאיית את מיקומה של שגיאה בבינארי, אז נוכל ליצור קשר עם דרך אחרת לחשוב על האמינג. 

56
00:04:37,268 --> 00:04:43,240
קודים, אחד שהוא ללא ספק הרבה יותר פשוט ואלגנטי, ושאפשר לכתוב אותו בעצם עם שורת קוד אחת.

57
00:04:43,660 --> 00:04:45,500
זה מבוסס על פונקציית XOR.

58
00:04:46,940 --> 00:04:50,220
XOR, למי מכם שלא יודע, מייצג בלעדי או.

59
00:04:50,780 --> 00:04:56,731
כאשר אתה לוקח את ה-XOR של שני סיביות, זה יחזיר 1 אם אחד מהסיביות האלה מופעל, 

60
00:04:56,731 --> 00:04:59,360
אבל לא אם שניהם מופעלים או כבויים.

61
00:05:00,100 --> 00:05:02,980
בניסוח שונה, זה השוויון של שני הביטים האלה.

62
00:05:03,540 --> 00:05:06,760
כאדם מתמטיקה, אני מעדיף לחשוב על זה כעל מוד 2 של תוספת.

63
00:05:07,360 --> 00:05:11,391
אנחנו גם מדברים בדרך כלל על XOR של שתי מחרוזות סיביות שונות, 

64
00:05:11,391 --> 00:05:13,440
שבעצם עושה את זה רכיב אחר רכיב.

65
00:05:13,680 --> 00:05:15,720
זה כמו תוספת, אבל איפה שאתה אף פעם לא נושא.

66
00:05:16,500 --> 00:05:22,480
שוב, בעלי נטייה מתמטית יותר עשויים להעדיף לחשוב על זה כעל הוספת שני וקטורים והקטנת מוד 2.

67
00:05:23,500 --> 00:05:28,447
אם אתה פותח איזה Python עכשיו ומיישם את פעולת ה-caret בין שני מספרים שלמים, 

68
00:05:28,447 --> 00:05:32,940
זה מה שהוא עושה מלבד ייצוגי הסיביות של המספרים האלה מתחת למכסה המנוע.

69
00:05:34,960 --> 00:05:41,089
נקודת המפתח עבורך ולי היא שלקיחת ה-XOR של מחרוזות סיביות שונות היא למעשה דרך 

70
00:05:41,089 --> 00:05:47,140
לחשב את הפרודיות של חבורה של קבוצות נפרדות, כמו כך עם העמודות, הכל במכה אחת.

71
00:05:51,260 --> 00:05:56,983
זה נותן לנו דרך די מטופשת לחשוב על בדיקות השוויון המרובות מאלגוריתם קוד Hamming שלנו, 

72
00:05:56,983 --> 00:05:58,780
כשהם ארוזים יחד לפעולה אחת.

73
00:05:59,479 --> 00:06:02,180
למרות שבמבט ראשון זה נראה שונה מאוד.

74
00:06:02,820 --> 00:06:07,696
רשום ספציפית את 16 המיקומים בבינארי, כמו שהיה לנו בעבר, 

75
00:06:07,696 --> 00:06:12,049
ועכשיו סמן את המיקומים שבהם ביט ההודעה מופעל ל-1, 

76
00:06:12,049 --> 00:06:17,100
ואז אסוף את המיקומים האלה לעמודה אחת גדולה ולקחת את ה-XOR.

77
00:06:19,260 --> 00:06:24,194
אתם בוודאי יכולים לנחש ש-4 הביטים שיושבים בתחתית כתוצאה מכך זהים ל-4 

78
00:06:24,194 --> 00:06:29,200
בדיקות השוויון שלמדנו להכיר ואוהבים, אבל קחו רגע לחשוב באמת למה בדיוק.

79
00:06:32,220 --> 00:06:37,547
העמודה האחרונה הזו, למשל, סופרת את כל המיקומים שהחלק האחרון שלהם הוא 1, 

80
00:06:37,547 --> 00:06:41,838
אבל אנחנו כבר מוגבלים רק למיקומים המודגשים, כך שהיא למעשה 

81
00:06:41,838 --> 00:06:45,760
סופרת כמה עמדות מודגשות הגיעו מקבוצת השוויון הראשונה.

82
00:06:46,240 --> 00:06:46,800
האם זה הגיוני?

83
00:06:49,080 --> 00:06:54,328
כמו כן, העמודה הבאה סופרת כמה עמדות יש בקבוצת השוויון השנייה, 

84
00:06:54,328 --> 00:07:00,000
המיקומים שהביט השני אחרון שלהם הוא 1, ואשר גם הם מודגשים, וכן הלאה.

85
00:07:00,260 --> 00:07:03,960
זה באמת רק שינוי קטן בפרספקטיבה על אותו הדבר שעשינו.

86
00:07:07,760 --> 00:07:09,600
וכך אתה יודע לאן זה הולך מכאן.

87
00:07:10,000 --> 00:07:15,720
השולח אחראי על החלפת חלק מהסיביות השוויוניות המיוחדות כדי לוודא שהסכום יגיע ל-0000.

88
00:07:15,720 --> 00:07:21,606
עכשיו ברגע שיש לנו את זה ככה, זה נותן לנו דרך ממש נחמדה לחשוב מדוע 

89
00:07:21,606 --> 00:07:27,580
ארבעת הביטים המתקבלים האלה בתחתית מאייתים ישירות את המיקום של שגיאה.

90
00:07:28,460 --> 00:07:31,860
נניח שחלק מהגוש הזה עובר מ-0 ל-1.

91
00:07:32,600 --> 00:07:38,406
מה שזה אומר הוא שהמיקום של הביט הזה ייכלל כעת ב-XOR הכולל, 

92
00:07:38,406 --> 00:07:43,820
מה שמשנה את הסכום מ-0 לערך זה החדש שנכלל, מיקום השגיאה.

93
00:07:44,460 --> 00:07:49,360
מעט פחות ברור, הדבר נכון אם יש שגיאה שמשנה 1 ל-0.

94
00:07:50,180 --> 00:07:55,239
אתה מבין, אם אתה מוסיף קצת מחרוזת יחד פעמיים, זה אותו דבר כמו לא להיות שם בכלל, 

95
00:07:55,239 --> 00:07:57,580
בעיקרון כי בעולם הזה 1 ועוד 1 שווה 0.

96
00:07:57,580 --> 00:08:04,300
אז להוספת עותק של המיקום הזה לסכום הכולל יש את אותה השפעה כמו שאנחנו מעבירים אותו.

97
00:08:05,160 --> 00:08:10,700
והאפקט הזה, שוב, הוא שהתוצאה הכוללת בתחתית כאן מפרטת את מיקום השגיאה.

98
00:08:13,039 --> 00:08:17,240
כדי להמחיש עד כמה זה אלגנטי, הרשו לי להראות את השורה האחת של קוד 

99
00:08:17,240 --> 00:08:21,440
Python שהתייחסתי אליה קודם, שתלכוד כמעט את כל ההיגיון בקצה המקלט.

100
00:08:22,080 --> 00:08:26,513
נתחיל ביצירת מערך אקראי של 16 1 ו-0 כדי לדמות את בלוק הנתונים, 

101
00:08:26,513 --> 00:08:32,073
ואני אתן לו את סיביות השם, אבל כמובן שבפועל זה יהיה משהו שאנחנו מקבלים מהשולח, 

102
00:08:32,073 --> 00:08:37,000
ובמקום בהיותו אקראי הוא יוביל 11 סיביות נתונים יחד עם 5 סיביות זוגיות.

103
00:08:37,000 --> 00:08:41,956
אם אני קורא לפונקציה enumerateBits, מה שהיא עושה זה לצמד 

104
00:08:41,956 --> 00:08:47,000
כל אחד מהסיביות האלה עם אינדקס מתאים, במקרה הזה מ-0 עד 15.

105
00:08:48,180 --> 00:08:52,425
אז אם אנחנו יוצרים רשימה שמסתובבת בלולאה על כל הזוגות האלה, 

106
00:08:52,425 --> 00:08:56,741
זוגות שנראים כמו i, ואז נוציא רק את ערך i, רק את המדד, ובכן, 

107
00:08:56,741 --> 00:09:01,340
זה לא כל כך מרגש, אנחנו פשוט מקבלים בחזרה את המדדים האלה 0 עד 15.

108
00:09:01,680 --> 00:09:08,001
אבל אם נוסיף את התנאי לעשות את זה רק אם ביט, כלומר אם הביט הזה הוא 1 ולא 0, 

109
00:09:08,001 --> 00:09:12,660
ובכן, אז הוא שולף רק את המיקומים שבהם הביט המקביל מופעל.

110
00:09:13,380 --> 00:09:20,360
במקרה זה נראה שהמיקומים האלה הם 0, 4, 6, 9 וכו'.

111
00:09:20,720 --> 00:09:26,073
מה שאנחנו רוצים זה לאסוף את כל המיקומים האלה, את המיקומים של הביטים המופעלים, 

112
00:09:26,073 --> 00:09:27,240
ואז XOR אותם יחד.

113
00:09:29,180 --> 00:09:33,220
כדי לעשות זאת ב- Python, תחילה תן לי לייבא כמה פונקציות מועילות.

114
00:09:33,900 --> 00:09:38,700
כך נוכל לקרוא ל-reduce() ברשימה זו, ולהשתמש בפונקציה XOR כדי להקטין אותה.

115
00:09:39,100 --> 00:09:42,680
זה בעצם אוכל את הדרך ברשימה, ולוקח XORs לאורך הדרך.

116
00:09:44,800 --> 00:09:49,440
אם אתה מעדיף, אתה יכול לכתוב במפורש את פונקציית XOR מבלי לייבא אותה מכל מקום.

117
00:09:51,940 --> 00:09:57,471
אז כרגע נראה שאם נעשה זאת על הבלוק האקראי שלנו של 16 סיביות, 

118
00:09:57,471 --> 00:10:01,280
זה מחזיר 9, שיש לו את הייצוג הבינארי 1001.

119
00:10:01,980 --> 00:10:06,246
לא נעשה את זה כאן, אבל אתה יכול לכתוב פונקציה שבה השולח משתמש בייצוג 

120
00:10:06,246 --> 00:10:09,833
הבינארי הזה כדי להגדיר את ארבעת סיביות הזוגיות לפי הצורך, 

121
00:10:09,833 --> 00:10:14,408
ובסופו של דבר להביא את הבלוק הזה למצב שבו הפעלת שורת קוד זו ברשימת הביטים 

122
00:10:14,408 --> 00:10:15,460
המלאה מחזירה א 0.

123
00:10:16,080 --> 00:10:20,100
זה ייחשב לבלוק מוכן היטב.

124
00:10:20,100 --> 00:10:25,872
מה שמגניב הוא שאם נחליף כל אחד מהסיביות ברשימה הזו, המדמה שגיאה אקראית מרעש, 

125
00:10:25,872 --> 00:10:30,220
אז אם אתה מפעיל את אותה שורת קוד, הוא מדפיס את השגיאה הזו.

126
00:10:30,960 --> 00:10:31,520
זה לא מסודר?

127
00:10:31,820 --> 00:10:36,589
אתה יכול לקבל את הבלוק הזה ישר, להריץ עליו את השורה הבודדת הזו, 

128
00:10:36,589 --> 00:10:41,060
והוא ינוק אוטומטית את המיקום של שגיאה, או 0 אם לא הייתה כזו.

129
00:10:42,500 --> 00:10:44,840
ואין כאן שום דבר מיוחד במידה 16.

130
00:10:44,840 --> 00:10:49,860
אותה שורת קוד תעבוד אם הייתה לך רשימה של, נניח, 256 סיביות.

131
00:10:51,880 --> 00:10:57,819
מיותר לציין שיש עוד קוד לכתוב כאן, כמו ביצוע בדיקת מטא זוגיות כדי לזהות שגיאות של 

132
00:10:57,819 --> 00:11:03,760
2 סיביות, אבל הרעיון הוא שכמעט כל הלוגיקה הליבה מהסכמה שלנו מסתכמת בהפחתת XOR אחת.

133
00:11:06,120 --> 00:11:10,573
כעת, בהתאם לנוחות שלך עם רכיבי בינארי ו-XOR ותוכנה באופן כללי, 

134
00:11:10,573 --> 00:11:16,582
ייתכן שתמצא את הפרספקטיבה הזו קצת מבלבלת, או הרבה יותר אלגנטי ופשוט שאתה תוהה למה לא 

135
00:11:16,582 --> 00:11:18,420
התחלנו איתה מההתחלה -ללכת.

136
00:11:19,140 --> 00:11:22,845
באופן רופף, קל יותר לחשוב על פרספקטיבה של בדיקת זוגיות מרובה 

137
00:11:22,845 --> 00:11:25,700
בעת יישום קודי Hamming בחומרה באופן ישיר מאוד, 

138
00:11:25,700 --> 00:11:30,500
ואת פרספקטיבה של XOR קל יותר לחשוב עליה כאשר עושים זאת בתוכנה, מרמה גבוהה יותר.

139
00:11:31,360 --> 00:11:37,599
את הראשון הכי קל לעשות ביד, ולדעתי הוא עושה עבודה טובה יותר בהחדרת האינטואיציה 

140
00:11:37,599 --> 00:11:44,629
הליבה העומדת בבסיס כל זה, והיא שהמידע הנדרש לאיתור שגיאה בודדת קשור ללוג של גודל הבלוק , 

141
00:11:44,629 --> 00:11:50,000
או במילים אחרות, הוא גדל טיפה בכל פעם ככל שגודל הבלוק מכפיל את עצמו.

142
00:11:51,020 --> 00:11:56,060
העובדה הרלוונטית כאן היא שהמידע הזה מתאים ישירות לכמות היתירות שאנחנו צריכים.

143
00:11:56,660 --> 00:12:01,541
זה באמת מה שנוגד את התגובה המופרכת של רוב האנשים כשהם חושבים לראשונה על הפיכת הודעה 

144
00:12:01,541 --> 00:12:06,540
לעמידה בפני שגיאות, כאשר בדרך כלל העתקה של כל ההודעה היא האינסטינקט הראשון שעולה בראש.

145
00:12:07,500 --> 00:12:11,657
ואז, אגב, יש את כל הדרך האחרת הזו שלפעמים רואים את קודי האמינג מוצגים, 

146
00:12:11,657 --> 00:12:14,000
שבה אתה מכפיל את המסר במטריצה אחת גדולה.

147
00:12:14,670 --> 00:12:18,711
זה די נחמד כי זה מקשר את זה למשפחה הרחבה יותר של קודים ליניאריים, 

148
00:12:18,711 --> 00:12:23,060
אבל אני חושב שזה כמעט לא נותן אינטואיציה מאיפה זה מגיע או איך זה מתרחב.

149
00:12:25,200 --> 00:12:28,093
ואם כבר מדברים על קנה מידה, אולי תשים לב שהיעילות 

150
00:12:28,093 --> 00:12:31,160
של תכנית זו רק משתפרת ככל שאנו מגדילים את גודל הבלוק.

151
00:12:35,000 --> 00:12:40,785
לדוגמה, ראינו שעם 256 סיביות, אתה משתמש רק ב-3% מהשטח הזה עבור יתירות, 

152
00:12:40,785 --> 00:12:42,660
ומשם זה רק הולך ומשתפר.

153
00:12:43,300 --> 00:12:47,340
ככל שמספר סיביות הזוגיות גדל בזה אחר זה, גודל הבלוק ממשיך להכפיל את עצמו.

154
00:12:49,000 --> 00:12:54,223
ואם אתה לוקח את זה לקיצוניות, אתה יכול לקבל בלוק עם, נגיד, מיליון ביטים, 

155
00:12:54,223 --> 00:13:00,020
שבו אתה ממש משחק 20 שאלות עם בדיקות השוויון שלך, והוא משתמש רק ב-21 ביטים זוגיות.

156
00:13:00,740 --> 00:13:05,715
ואם אתה חוזר אחורה כדי לחשוב על להסתכל על מיליון ביטים ולאתר שגיאה בודדת, 

157
00:13:05,715 --> 00:13:07,060
זה באמת מרגיש מטורף.

158
00:13:08,199 --> 00:13:12,823
הבעיה, כמובן, היא שעם בלוק גדול יותר, ההסתברות לראות יותר משגיאת 

159
00:13:12,823 --> 00:13:17,660
סיביות אחת או שתיים עולה, וקודי Hamming לא מטפלים בשום דבר מעבר לזה.

160
00:13:18,320 --> 00:13:24,300
אז בפועל, מה שתרצו זה למצוא את הגודל הנכון כך שההסתברות של יותר מדי ביט לא תהיה גבוהה מדי.

161
00:13:26,600 --> 00:13:32,146
כמו כן, בפועל, שגיאות נוטות להגיע בהתפרצויות קטנות, מה שיהרוס לחלוטין בלוק בודד, 

162
00:13:32,146 --> 00:13:36,871
אז טקטיקה נפוצה אחת כדי לעזור להפיץ פרץ של שגיאות על פני בלוקים רבים 

163
00:13:36,871 --> 00:13:40,980
ושונים היא לשלב את הבלוקים האלה, ככה, לפני שהם נשלח או נשמר.

164
00:13:45,580 --> 00:13:49,362
אז שוב, הרבה מזה הופך ללא ספק על ידי קודים מודרניים יותר, 

165
00:13:49,362 --> 00:13:54,515
כמו אלגוריתם ריד-סולומון הנפוץ הרבה יותר, המטפל בשגיאות פרץ בצורה טובה במיוחד, 

166
00:13:54,515 --> 00:13:58,820
וניתן לכוון אותו כך שיהיה עמיד למספר גדול יותר של שגיאות בכל בלוק.

167
00:13:59,360 --> 00:14:01,340
אבל זה נושא לפעם אחרת.

168
00:14:02,500 --> 00:14:05,901
בספרו The Art of Doing Science and Engineering, 

169
00:14:05,901 --> 00:14:09,940
האמינג הוא כנה להפליא לגבי מידת הפיתול של גילוי הקוד הזה.

170
00:14:10,620 --> 00:14:14,398
תחילה הוא ניסה כל מיני תוכניות שונות שכללו ארגון הסיביות 

171
00:14:14,398 --> 00:14:17,780
לחלקים של סריג ממדי גבוה יותר ודברים מוזרים כמו זה.

172
00:14:18,300 --> 00:14:24,295
הרעיון שאולי אפשר לקבל בדיקות זוגיות כדי ליצור קשר בצורה שתפרט את המיקום של שגיאה, 

173
00:14:24,295 --> 00:14:28,774
הגיע להאמינג רק כשהוא נסוג לאחר שלל ניתוחים אחרים ושאל, בסדר, 

174
00:14:28,774 --> 00:14:31,520
מה הכי יעיל שיכולתי. אפשר לחשוב על זה?

175
00:14:32,620 --> 00:14:37,511
הוא גם היה כנה לגבי כמה חשוב שבדיקות זוגיות כבר היו בראש שלו, 

176
00:14:37,511 --> 00:14:41,220
מה שהיה הרבה פחות נפוץ בשנות הארבעים מאשר היום.

177
00:14:41,920 --> 00:14:46,835
יש כמו חצי תריסר פעמים במהלך הספר הזה שהוא מתייחס לציטוט של לואי פסטר, 

178
00:14:46,835 --> 00:14:48,220
המזל מעדיף מוח מוכן.

179
00:14:49,320 --> 00:14:52,767
רעיונות חכמים נראים לעתים קרובות פשוטים בצורה מטעה במבט לאחור, 

180
00:14:52,767 --> 00:14:54,300
מה שמקל על הערכה נמוכה יותר.

181
00:14:54,960 --> 00:15:01,300
כרגע תקוותי הכנה היא שקודי האמינג, או לפחות האפשרות של קודים כאלה, מרגישים לך כמעט ברורים.

182
00:15:01,660 --> 00:15:06,820
אבל אתה לא צריך להטעות את עצמך לחשוב שהם בעצם ברורים, כי הם בהחלט לא.

183
00:15:07,880 --> 00:15:13,247
חלק מהסיבה שרעיונות חכמים נראים קלים בצורה מטעה היא שאנחנו רואים רק את התוצאה הסופית, 

184
00:15:13,247 --> 00:15:17,492
מנקים את מה שהיה מבולגן, אף פעם לא מזכירים את כל הפניות הלא נכונות, 

185
00:15:17,492 --> 00:15:22,860
ומדגישים עד כמה עצום המרחב של האפשרויות הניתנות לחקירה בתחילת בעיה תהליך פתרון, כל זה.

186
00:15:23,820 --> 00:15:24,900
אבל זה נכון באופן כללי.

187
00:15:24,900 --> 00:15:30,040
אני חושב שלכמה המצאות מיוחדות, יש סיבה שנייה, עמוקה יותר לכך שאנחנו פחות מעריכים אותן.

188
00:15:30,840 --> 00:15:35,432
חשיבה על מידע במונחים של ביטים התלכדה לתיאוריה מלאה רק ב-1948, 

189
00:15:35,432 --> 00:15:38,640
עם המאמר המכונן של קלוד שאנון על תורת המידע.

190
00:15:39,280 --> 00:15:42,540
זה היה בעצם במקביל לזמן שבו האמינג פיתח את האלגוריתם שלו.

191
00:15:43,300 --> 00:15:48,690
זה היה אותו מאמר יסוד שהראה, במובן מסוים, שתיקון שגיאות יעיל תמיד אפשרי, 

192
00:15:48,690 --> 00:15:52,900
לא משנה כמה גבוהה ההסתברות להיפוך סיביות, לפחות בתיאוריה.

193
00:15:53,700 --> 00:15:59,204
שאנון והאמינג, אגב, חלקו משרד ב-Bell Labs, למרות שעבדו על דברים שונים מאוד, 

194
00:15:59,204 --> 00:16:01,160
מה שכמעט ולא נראה מקרי כאן.

195
00:16:02,380 --> 00:16:07,515
הרץ קדימה כמה עשורים, ובימים אלה, רבים מאיתנו שקועים כל כך בחשיבה 

196
00:16:07,515 --> 00:16:12,340
על פיסות ומידע שקל להתעלם עד כמה הייתה צורת החשיבה הזו מובחנת.

197
00:16:13,100 --> 00:16:17,452
למרבה האירוניה, הרעיונות שמעצבים בצורה העמוקה ביותר את הדרכים שדור 

198
00:16:17,452 --> 00:16:22,260
העתיד חושב יסתכלו בסופו של דבר על אותו דור העתיד פשוטות יותר ממה שהם באמת.

