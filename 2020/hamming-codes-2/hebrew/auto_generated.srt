1
00:00:00,000 --> 00:00:10,900
האם אי פעם תהיתם איך אפשר לגרד תקליטור או DVD ועדיין להשמיע את כל מה שהוא מאחסן?

2
00:00:10,900 --> 00:00:16,525
השריטה באמת משפיעה על ה-1 וה-0 בדיסק, אז הוא קורא נתונים שונים

3
00:00:16,525 --> 00:00:22,328
ממה שנשמר, אבל אלא אם כן הוא ממש שרוט, הביטים שהוא קורא מפוענחים

4
00:00:22,328 --> 00:00:28,400
בדיוק לאותו קובץ שקודד בו, עותק ביט אחר סיבי, למרות כל השגיאות הללו.

5
00:00:28,400 --> 00:00:32,773
יש ערימה שלמה של פיקחות מתמטית שמאפשרת לנו לאחסן נתונים,

6
00:00:32,773 --> 00:00:36,840
ולא פחות חשוב להעביר נתונים, בצורה עמידה בפני שגיאות.

7
00:00:36,840 --> 00:00:42,480
ובכן, בסדר, למעשה לא צריך כל כך הרבה פיקחות כדי למצוא דרך לעשות את זה.

8
00:00:42,480 --> 00:00:46,641
כל קובץ, בין אם זה וידאו או צליל או טקסט, קוד כלשהו,

9
00:00:46,641 --> 00:00:50,960
תמונה, מה שלא יהיה, הוא בסופו של דבר איזה רצף של 1 ו-0.

10
00:00:50,960 --> 00:00:57,780
ואסטרטגיה פשוטה לתיקון כל סיביות שמתהפכת תהיה לאחסן שלושה עותקים של כל סיביות.

11
00:00:57,780 --> 00:01:02,684
לאחר מכן, המכונה שקוראת את הקובץ הזה תוכל להשוות את שלושת העותקים

12
00:01:02,684 --> 00:01:07,440
האלה ותמיד לקחת את ה-2 הטובים ביותר מתוך 3 בכל פעם שיש אי התאמה.

13
00:01:07,440 --> 00:01:11,560
אבל המשמעות היא שימוש בשני שלישים מהשטח שלך לעודפות.

14
00:01:11,560 --> 00:01:18,120
וגם אז, למרות כל השטח שמוותר עליו, אין ערובה חזקה לגבי מה יקרה אם יותר מסיבית אחת תתהפך.

15
00:01:18,120 --> 00:01:21,235
השאלה המעניינת הרבה יותר היא איך לעשות את זה כך

16
00:01:21,235 --> 00:01:24,740
שניתן יהיה לתקן שגיאות תוך ויתור על שטח קטן ככל האפשר.

17
00:01:24,740 --> 00:01:29,022
לדוגמה, באמצעות השיטה שתלמד על הסרטון הזה, תוכל לאחסן את הנתונים

18
00:01:29,022 --> 00:01:32,975
שלך בבלוקים של 256 סיביות, כאשר כל בלוק משתמש ב-9 סיביות, 9!

19
00:01:32,975 --> 00:01:41,000
לפעול כסוג של יתירות, ושאר 247 הסיביות חופשיות לשאת כל מסר או נתונים משמעותיים שתרצו.

20
00:01:41,000 --> 00:01:47,031
וזה עדיין יהיה כך שאם ביט כלשהו יתהפך כאן, רק על ידי הסתכלות על הבלוק הזה ותו

21
00:01:47,031 --> 00:01:53,140
לא, מכונה תוכל לזהות שהייתה שגיאה ובדיוק היכן היא הייתה כדי שהיא תדע לתקן אותה.

22
00:01:53,140 --> 00:01:55,540
ובכנות, זה מרגיש כמו קסם.

23
00:01:55,540 --> 00:01:59,193
ולסכמה הספציפית הזו, אם שני ביטים יתהפכו, המכונה לפחות

24
00:01:59,193 --> 00:02:03,180
תוכל לזהות שהיו שתי שגיאות, אם כי היא לא תדע כיצד לתקן אותן.

25
00:02:03,180 --> 00:02:08,140
נדבר קצת מאוחר יותר על איך זה קנה מידה עבור בלוקים בגדלים שונים.

26
00:02:08,140 --> 00:02:13,880
שיטות המאפשרות לך לתקן שגיאות כמו זו ידועות, באופן סביר, בתור קודי תיקון שגיאות.

27
00:02:13,880 --> 00:02:18,254
בחלקה הטוב יותר של המאה הקודמת, תחום זה היה מקור עשיר באמת

28
00:02:18,254 --> 00:02:23,000
למתמטיקה עמוקה להפתיע שמשולבת במכשירים שאנו משתמשים בהם מדי יום.

29
00:02:23,000 --> 00:02:29,660
המטרה כאן היא לתת לך הבנה מעמיקה מאוד של אחת הדוגמאות המוקדמות ביותר, המכונה קוד Hamming.

30
00:02:29,660 --> 00:02:34,940
ודרך אגב, איך שאני חושב על המבנה של הסרטון הזה הוא פחות עניין של הסבר ישיר ככל

31
00:02:34,940 --> 00:02:40,220
האפשר, ויותר עניין של לדרבן אותך להמציא את זה לעצמך, עם קצת הדרכה עדינה פה ושם.

32
00:02:40,220 --> 00:02:43,727
אז כשאתה מרגיש שאתה רואה לאן זה הולך בשלב מסוים, קח את הרגע הזה

33
00:02:43,727 --> 00:02:47,180
לעצור, חזה באופן פעיל מה התוכנית עומדת להיות לפני שאני אומר לך.

34
00:02:47,180 --> 00:02:53,187
כמו כן, אם אתה רוצה שההבנה שלך תרד לרמת החומרה, בן איטר הכין סרטון יחד עם

35
00:02:53,187 --> 00:02:59,520
הסרטון הזה שמראה לך איך ליישם בפועל קודי Hamming על לוחות לחם, וזה מספק ביותר.

36
00:02:59,520 --> 00:03:04,278
אתה צריך לדעת, קודי Hamming לא נמצאים בשימוש נרחב כמו קודים מודרניים יותר,

37
00:03:04,278 --> 00:03:09,164
כמו אלגוריתם ריד-סולומון, אבל יש קסם מסוים בניגוד בין כמה בלתי אפשרית המשימה

38
00:03:09,164 --> 00:03:14,240
הזו מרגישה בהתחלה, לבין כמה סבירה לחלוטין היא נראית פעם אחת. אתה לומד על האמינג.

39
00:03:14,240 --> 00:03:18,355
העיקרון הבסיסי של תיקון שגיאות הוא שבמרחב עצום של כל

40
00:03:18,355 --> 00:03:22,860
ההודעות האפשריות, רק תת-קבוצה מסוימת תיחשב להודעות חוקיות.

41
00:03:22,860 --> 00:03:29,100
כאנלוגיה, חשבו על מילים מאויתות נכון לעומת מילים מאויתות לא נכון.

42
00:03:29,100 --> 00:03:33,628
בכל פעם שהודעה חוקית משתנה, המקלט אחראי לתקן את מה שהם רואים

43
00:03:33,628 --> 00:03:38,380
בחזרה לשכן התקף הקרוב ביותר, כפי שאתה עשוי לעשות עם שגיאת הקלדה.

44
00:03:38,380 --> 00:03:47,160
עם זאת, להמציא אלגוריתם קונקרטי לסיווג יעיל של הודעות כמו זה, נדרשת פיקחות מסוימת.

45
00:03:47,160 --> 00:03:52,221
הסיפור מתחיל בשנות ה-40, כאשר ריצ&#39;רד האמינג צעיר עבד במעבדות בל, וחלק

46
00:03:52,221 --> 00:03:57,420
מעבודתו כללו שימוש במחשב כרטיס ניקוב יקר מאוד שהייתה לו רק גישה מוגבלת אליו.

47
00:03:57,420 --> 00:04:03,140
והתוכניות שהוא המשיך להעביר את זה לא הפסיקו להיכשל, כי מדי פעם קצת יקראו לא נכון.

48
00:04:03,140 --> 00:04:09,280
התסכול בהיותו כור ההמצאה, כל כך נמאס לו שהוא המציא את קוד תיקון השגיאות הראשון בעולם.

49
00:04:09,280 --> 00:04:12,652
ישנן דרכים רבות ושונות למסגר קודי האמינג, אבל כדרך

50
00:04:12,652 --> 00:04:16,620
ראשונה, אנחנו הולכים לעבור את זה כמו שהאמינג עצמו חשב עליהם.

51
00:04:16,620 --> 00:04:21,400
בואו נשתמש בדוגמה פשוטה, אבל לא פשוטה מדי, בלוק של 16 סיביות.

52
00:04:21,400 --> 00:04:25,700
נמספר את המיקומים של סיביות אלה מ-0 עד 15.

53
00:04:25,700 --> 00:04:30,094
הנתונים האמיתיים שאנו רוצים לאחסן יהוו רק 12 מהסיביות

54
00:04:30,094 --> 00:04:33,920
הללו, בעוד ש-4 מהמיקומים שמורים כסוג של יתירות.

55
00:04:33,920 --> 00:04:36,925
המילה מיותר כאן לא אומרת פשוט העתקה, אחרי הכל, 4 הביטים

56
00:04:36,925 --> 00:04:40,200
האלה לא נותנים לנו מספיק מקום להעתיק את הנתונים בצורה עיוורת.

57
00:04:40,200 --> 00:04:44,552
במקום זאת, הם יצטרכו להיות סוג הרבה יותר ניואנס וחכם

58
00:04:44,552 --> 00:04:48,740
של יתירות, לא להוסיף שום מידע חדש, אלא להוסיף חוסן.

59
00:04:48,740 --> 00:04:54,630
אולי אתה מצפה שארבעת החלקים המיוחדים האלה יבואו ארוזים יפה ביחד, אולי בסוף או משהו כזה,

60
00:04:54,630 --> 00:05:00,320
אבל כפי שתראה, כשהם יושבים בעמדות שהן עוצמה של 2 מאפשר משהו שהוא באמת אלגנטי עד הסוף.

61
00:05:00,320 --> 00:05:05,420
זה גם עשוי לתת לך רמז קטן לגבי איך זה מתאים לבלוקים גדולים יותר.

62
00:05:05,420 --> 00:05:09,709
גם מבחינה טכנית זה בסופו של דבר רק 11 סיביות של נתונים, תגלה

63
00:05:09,709 --> 00:05:14,280
שיש ניואנס מתון למה שמתרחש בעמדה 0, אבל אל תדאג בקשר לזה לעת עתה.

64
00:05:14,280 --> 00:05:20,238
כמו כל אלגוריתם לתיקון שגיאות, זה יכלול שני שחקנים, שולח שאחראי על הגדרת

65
00:05:20,238 --> 00:05:26,360
4 הביטים המיוחדים הללו, ומקלט שאחראי על ביצוע איזושהי בדיקה ותיקון השגיאות.

66
00:05:26,360 --> 00:05:30,920
כמובן, המילים שולח ומקבל באמת מתייחסות למכונות או תוכנות שעושות את כל

67
00:05:30,920 --> 00:05:35,480
הבדיקות, והרעיון של הודעה נועד בצורה רחבה מאוד, לכלול דברים כמו אחסון.

68
00:05:35,480 --> 00:05:42,640
אחרי הכל, אחסון נתונים הוא אותו דבר כמו שליחת מסר רק מהעבר לעתיד במקום ממקום אחד לאחר.

69
00:05:42,640 --> 00:05:47,301
אז זה ההגדרה, אבל לפני שנוכל לצלול פנימה אנחנו צריכים לדבר על

70
00:05:47,301 --> 00:05:52,187
רעיון קשור שהיה טרי בראשו של האמינג בזמן גילויו, שיטה המאפשרת לך

71
00:05:52,187 --> 00:05:57,300
לזהות שגיאות סיביות בודדות, אך לא לתקן אותן, ידועה בעסק כמחאה זוגית.

72
00:05:57,300 --> 00:06:04,940
לבדיקת זוגיות, אנו מפרידים רק ביט בודד אחד שהשולח אחראי לכוונון, והשאר חופשיים לשאת הודעה.

73
00:06:04,940 --> 00:06:12,100
התפקיד היחיד של הביט המיוחד הזה הוא לוודא שהמספר הכולל של 1s בהודעה הוא מספר זוגי.

74
00:06:12,100 --> 00:06:16,428
אז לדוגמא כרגע, המספר הכולל של 1s הוא 7, זה מוזר, אז השולח צריך

75
00:06:16,428 --> 00:06:20,960
להפוך את הסיביות המיוחדת הזו כדי להיות 1, מה שהופך את הספירה לשקול.

76
00:06:20,960 --> 00:06:27,480
אבל אם הבלוק כבר התחיל עם מספר זוגי של 1, אז הביט המיוחד הזה היה נשמר ב-0.

77
00:06:27,480 --> 00:06:32,572
זה די פשוט, פשוט מטעה, אבל זו דרך אלגנטית להפליא לזקק

78
00:06:32,572 --> 00:06:37,760
את הרעיון של שינוי בכל מקום במסר שישתקף בפיסת מידע אחת.

79
00:06:37,760 --> 00:06:42,858
שימו לב שאם חלק כלשהו מההודעה הזו מתהפך, מ-0 ל-1 או מ-1

80
00:06:42,858 --> 00:06:48,140
ל-0, זה משנה את הספירה הכוללת של 1 שניות מזוגיות לא-זוגית.

81
00:06:48,140 --> 00:06:53,526
אז אם אתה המקלט, אתה מסתכל על ההודעה הזו, ותראה מספר אי זוגי של 1, אתה יכול

82
00:06:53,526 --> 00:06:58,700
לדעת בוודאות שהתרחשה שגיאה כלשהי, למרות שאולי אין לך מושג היכן היא הייתה.

83
00:06:58,700 --> 00:07:04,940
בז&#39;רגון, האם לקבוצת ביטים יש מספר זוגי או אי-זוגי של 1, ידוע בתור הזוגיות שלה.

84
00:07:04,940 --> 00:07:08,075
אתה יכול גם להשתמש במספרים ולומר שהשוויון הוא 0 או 1, וזה

85
00:07:08,075 --> 00:07:11,320
בדרך כלל מועיל יותר ברגע שאתה מתחיל לעשות מתמטיקה עם הרעיון.

86
00:07:11,320 --> 00:07:18,020
והביט המיוחד הזה שהשולח משתמש בו כדי לשלוט בזוגיות נקרא סיבית הזוגיות.

87
00:07:18,020 --> 00:07:21,866
ולמעשה, עלינו להיות ברורים, אם המקלט רואה זוגיות אי זוגית, זה

88
00:07:21,866 --> 00:07:25,775
לא בהכרח אומר שהייתה רק שגיאה אחת, אולי היו 3 שגיאות, או 5, או

89
00:07:25,775 --> 00:07:29,560
כל מספר אי זוגי אחר, אבל הם יכולים לדעת בוודאות שזה לא היה 0.

90
00:07:29,560 --> 00:07:36,543
מצד שני, אם היו 2 שגיאות, או כל מספר זוגי של שגיאות, הספירה הסופית של 1s עדיין תהיה

91
00:07:36,543 --> 00:07:43,360
זוגית, כך שהמקבל לא יכול להיות בטוח שספירה זוגית אומרת בהכרח שההודעה נטולת שגיאות.

92
00:07:43,360 --> 00:07:46,832
אתה עלול להתלונן שהודעה שמתבלבלת רק על ידי סיבובים

93
00:07:46,832 --> 00:07:49,760
של 2 סיביות היא די חלשה, ואתה צודק לחלוטין.

94
00:07:49,760 --> 00:07:54,654
זכור, עם זאת, אין שיטה לזיהוי או תיקון שגיאות שיכולה לתת

95
00:07:54,654 --> 00:07:59,720
לך 100% ביטחון שההודעה שאתה מקבל היא זו שהשולח התכוון אליה.

96
00:07:59,720 --> 00:08:05,920
אחרי הכל, מספיק רעש אקראי תמיד יכול לשנות הודעה חוקית אחת להודעה חוקית אחרת רק במקרה.

97
00:08:05,920 --> 00:08:11,024
במקום זאת, המטרה היא להמציא סכמה שתהיה חזקה עד למספר מרבי

98
00:08:11,024 --> 00:08:16,480
מסוים של שגיאות, או אולי להפחית את ההסתברות לחיוב שגוי כמו זה.

99
00:08:16,480 --> 00:08:22,312
בדיקות זוגיות כשלעצמן הן די חלשות, אבל על ידי זיקוק רעיון השינוי על פני מסר מלא

100
00:08:22,312 --> 00:08:28,000
עד לחלק אחד, מה שהם נותנים לנו הוא אבן בניין רבת עוצמה לתוכניות מתוחכמות יותר.

101
00:08:28,000 --> 00:08:34,304
לדוגמה, מכיוון שהאמינג חיפש דרך לזהות היכן קרתה שגיאה, לא רק שהיא קרתה, התובנה העיקרית

102
00:08:34,304 --> 00:08:40,463
שלו הייתה שאם תחיל בדיקות זוגיות לא על ההודעה המלאה, אלא על תת-קבוצות מסוימות שנבחרו

103
00:08:40,463 --> 00:08:46,840
בקפידה, תוכל לשאול סדרה מעודנת יותר של שאלות המציינת את המיקום של כל שגיאת סיביות בודדת.

104
00:08:46,840 --> 00:08:50,358
התחושה הכללית היא קצת כמו לשחק במשחק של 20 שאלות,

105
00:08:50,358 --> 00:08:54,300
לשאול שאילתות כן או לא שחותכות את מרחב האפשרויות לשניים.

106
00:08:54,300 --> 00:09:00,400
לדוגמה, נניח שאנו עושים בדיקת זוגיות רק על 8 הסיביות הללו, כל המיקומים האי-זוגיים.

107
00:09:00,400 --> 00:09:04,700
לאחר מכן, אם מזוהה שגיאה, זה נותן למקלט קצת יותר מידע

108
00:09:04,700 --> 00:09:09,160
על היכן בדיוק נמצאת השגיאה, כלומר שהוא נמצא במיקום מוזר.

109
00:09:09,160 --> 00:09:13,240
אם לא מזוהה שגיאה בין 8 הסיביות האלה, זה אומר שאין

110
00:09:13,240 --> 00:09:17,240
שגיאה בכלל, או שהיא יושבת איפשהו במיקומים הזוגיים.

111
00:09:17,240 --> 00:09:23,646
אולי תחשוב שהגבלת בדיקת זוגיות לחצי מהביטים הופכת אותו לפחות יעיל, אבל כשהיא

112
00:09:23,646 --> 00:09:29,720
נעשית בשילוב עם בדיקות אחרות שנבחרו היטב, זה נותן לנו משהו הרבה יותר חזק.

113
00:09:29,720 --> 00:09:33,795
כדי להגדיר בפועל את בדיקת הזוגיות הזו, זכור, זה מצריך ייעוד

114
00:09:33,795 --> 00:09:37,600
של חלק מיוחד שיש לו שליטה על הזוגיות של אותה קבוצה מלאה.

115
00:09:37,600 --> 00:09:39,920
כאן בואו פשוט נבחר בעמדה 1.

116
00:09:39,920 --> 00:09:43,931
עבור הדוגמה המוצגת, השוויון של 8 הסיביות הללו הוא אי-זוגי

117
00:09:43,931 --> 00:09:48,220
כרגע, כך שהשולח אחראי על החלפת סיביות השוויון, ועכשיו זה זוגי.

118
00:09:48,220 --> 00:09:51,040
זה רק 1 מתוך 4 בדיקות זוגיות שנבצע.

119
00:09:51,040 --> 00:09:56,880
הסימון השני הוא בין 8 הביטים בחצי הימני של הרשת, לפחות כפי שציירנו אותו כאן.

120
00:09:56,880 --> 00:10:01,916
הפעם אנו עשויים להשתמש במיקום 2 כסיביות זוגיות, כך של-8 הסיביות הללו כבר

121
00:10:01,916 --> 00:10:07,160
יש זוגיות זוגית, והשולח יכול להרגיש טוב ולהשאיר את הסיביות מספר 2 ללא שינוי.

122
00:10:07,160 --> 00:10:11,424
ואז בצד השני, אם המקלט יבדוק את השוויון של הקבוצה הזו והם יגלו

123
00:10:11,424 --> 00:10:15,960
שזה מוזר, הם יידעו שהשגיאה נמצאת איפשהו בין 8 הביטים האלה בצד ימין.

124
00:10:15,960 --> 00:10:21,260
אחרת זה אומר שאין שגיאה, או שהשגיאה נמצאת איפשהו בחצי השמאלי.

125
00:10:21,260 --> 00:10:24,025
או שאני מניח שיכולות להיות שתי שגיאות, אבל כרגע

126
00:10:24,025 --> 00:10:27,080
אנחנו הולכים להניח שיש לכל היותר שגיאה אחת בכל הבלוק.

127
00:10:27,080 --> 00:10:29,160
דברים מתקלקלים לגמרי ליותר מזה.

128
00:10:29,160 --> 00:10:32,658
כאן, לפני שנסתכל על שני הבדיקות הבאות, קחו רגע לחשוב מה השניים

129
00:10:32,658 --> 00:10:35,880
הראשונים הללו מאפשרים לנו לעשות כאשר אתם מחשיבים אותם יחד.

130
00:10:35,880 --> 00:10:40,240
נניח שאתה מזהה שגיאה בין העמודות האי זוגיות, ובמחצית הימנית.

131
00:10:40,240 --> 00:10:43,940
זה בהכרח אומר שהשגיאה נמצאת איפשהו בעמודה האחרונה.

132
00:10:43,940 --> 00:10:47,100
אם לא הייתה שגיאה בעמודה האי זוגית אבל הייתה אחת

133
00:10:47,100 --> 00:10:50,520
בחצי הימני, זה אומר לך שהיא בעמודה השנייה עד האחרונה.

134
00:10:50,520 --> 00:10:53,507
כמו כן, אם יש שגיאה בעמודות האי זוגיות אבל לא

135
00:10:53,507 --> 00:10:56,560
בחצי הימני, אתה יודע שהיא איפשהו בעמודה השנייה.

136
00:10:56,560 --> 00:11:00,223
ואם אף אחת משתי בדיקות הזוגיות האלה לא מזהה משהו, זה אומר

137
00:11:00,223 --> 00:11:03,760
שהמקום היחיד שיכול להיות שגיאה הוא בעמודה השמאלית ביותר.

138
00:11:03,760 --> 00:11:06,480
אבל זה יכול גם פשוט אומר שאין שגיאה בכלל.

139
00:11:06,480 --> 00:11:11,800
וזו דרך די מטופשת לומר ששתי בדיקות זוגיות מאפשרות לנו להצמיד את העמודה.

140
00:11:11,800 --> 00:11:14,000
מכאן, אתם בוודאי יכולים לנחש מה בהמשך.

141
00:11:14,000 --> 00:11:16,240
אנחנו עושים את אותו הדבר חוץ מהשורות.

142
00:11:16,240 --> 00:11:21,040
תהיה בדיקת זוגיות בשורות האי זוגיות, תוך שימוש במיקום 4 בתור סיביות זוגיות.

143
00:11:21,040 --> 00:11:26,480
אז בדוגמה הזו לקבוצה כבר יש זוגיות זוגית, אז ביט 4 יוגדר ל-0.

144
00:11:26,480 --> 00:11:32,280
ולבסוף יש בדיקת זוגיות בשתי השורות התחתונות, תוך שימוש במיקום 8 בתור סיביות זוגיות.

145
00:11:32,280 --> 00:11:37,840
במקרה זה, נראה שהשולח צריך להפעיל את ה-bit 8 הזה כדי לתת לקבוצה זוגיות שווה.

146
00:11:37,840 --> 00:11:40,444
בדיוק כפי ששני הסימון הראשונים מאפשרים לנו להצמיד את

147
00:11:40,444 --> 00:11:43,000
העמודה, שני הסימון הבאים מאפשרים לך להצמיד את השורה.

148
00:11:43,000 --> 00:11:48,400
כדוגמה, דמיינו שבמהלך השידור יש שגיאה, למשל, בעמדה 3.

149
00:11:48,400 --> 00:11:52,370
ובכן זה משפיע על קבוצת השוויון הראשונה, וזה משפיע גם על קבוצת

150
00:11:52,370 --> 00:11:56,340
השוויון השנייה, כך שהמקלט יודע שיש שגיאה איפשהו בעמודה הימנית.

151
00:11:56,340 --> 00:12:01,380
אבל זה לא משפיע על הקבוצה השלישית, וזה לא משפיע על הקבוצה הרביעית.

152
00:12:01,380 --> 00:12:04,983
וזה מאפשר למקלט לאתר את השגיאה עד לשורה הראשונה,

153
00:12:04,983 --> 00:12:08,660
שמשמעותה בהכרח מיקום 3, כדי שיוכלו לתקן את השגיאה.

154
00:12:08,660 --> 00:12:13,093
אולי תיהנו להקדיש רגע לשכנע את עצמכם שהתשובות לארבע השאלות הללו

155
00:12:13,093 --> 00:12:17,320
באמת תמיד יאפשרו לכם לקבוע מיקום ספציפי, לא משנה היכן יתבררו.

156
00:12:17,320 --> 00:12:23,640
למעשה, הנבון שביניכם עשוי אפילו להבחין בקשר בין השאלות הללו לבין ספירה בינארית.

157
00:12:23,640 --> 00:12:30,880
ואם כן, שוב הרשו לי להדגיש, לעצור, לנסות בעצמכם לצייר את הקשר לפני שאקלקל אותו.

158
00:12:30,880 --> 00:12:36,560
אם אתה תוהה מה קורה אם סיבית זוגיות עצמה מושפעת, ובכן, אתה יכול פשוט לנסות את זה.

159
00:12:36,560 --> 00:12:41,902
קחו רגע לחשוב כיצד כל שגיאה בין ארבעת הסיביות המיוחדות

160
00:12:41,902 --> 00:12:47,440
הללו תתחקה בדיוק כמו כל אחר, עם אותה קבוצה של ארבע שאלות.

161
00:12:47,440 --> 00:12:50,567
זה לא באמת משנה, מכיוון שבסופו של יום מה שאנחנו רוצים זה

162
00:12:50,567 --> 00:12:53,640
להגן על סיביות ההודעה, סיביות תיקון השגיאות פשוט רוכבות.

163
00:12:53,640 --> 00:12:59,260
אבל הגנה גם על החלקים האלה היא משהו שנופל באופן טבעי מהתוכנית כתוצר לוואי.

164
00:12:59,260 --> 00:13:02,380
אולי תיהנו גם לצפות כיצד זה מתרחב.

165
00:13:02,380 --> 00:13:08,825
אם השתמשנו בבלוק בגודל 256 סיביות, למשל, כדי להצמיד מיקום, אתה

166
00:13:08,825 --> 00:13:15,680
צריך רק שמונה שאלות כן או לא כדי לחפש בינארי בדרך למטה למקום מסוים.

167
00:13:15,680 --> 00:13:23,340
וזכור, כל שאלה דורשת לוותר על ביט בודד בלבד כדי לקבוע את בדיקת השוויון המתאימה.

168
00:13:23,340 --> 00:13:26,529
חלק מכם אולי כבר רואים את זה, אבל נדבר מאוחר יותר על

169
00:13:26,529 --> 00:13:29,960
הדרך השיטתית למצוא מהן השאלות הללו תוך דקה או שתיים בלבד.

170
00:13:29,960 --> 00:13:34,440
אני מקווה שהסקיצה הזו מספיקה כדי להעריך את היעילות של מה שאנחנו מפתחים כאן.

171
00:13:34,440 --> 00:13:38,145
הדבר הראשון, למעט שמונה סיביות זוגיות מודגשת, יכול להיות

172
00:13:38,145 --> 00:13:41,720
מה שאתה רוצה שזה יהיה, לשאת כל מסר או נתונים שאתה רוצה.

173
00:13:41,720 --> 00:13:47,329
8 הביטים מיותרים במובן זה שהם נקבעים לחלוטין על ידי שאר

174
00:13:47,329 --> 00:13:53,640
ההודעה, אבל זה בצורה הרבה יותר חכמה מאשר להעתיק את ההודעה כולה.

175
00:13:53,640 --> 00:13:59,000
ועדיין, עבור כל כך מעט ויתור, תוכל לזהות ולתקן כל שגיאת סיביות בודדת.

176
00:13:59,000 --> 00:14:00,400
ובכן, כמעט.

177
00:14:00,400 --> 00:14:06,161
אוקיי, אז הבעיה האחת כאן היא שאם אף אחת מארבעת בדיקות השוויון לא מזהה שגיאה,

178
00:14:06,161 --> 00:14:11,773
כלומר שלתת-הקבוצות שנבחרו במיוחד של 8 סיביות יש לכולם זוגיות זוגיות, בדיוק

179
00:14:11,773 --> 00:14:17,760
כמו שהשולח התכוון, אז זה אומר שלא הייתה שגיאה בכלל , או שהוא מצמצם אותנו למצב 0.

180
00:14:17,760 --> 00:14:22,948
אתה מבין, עם ארבע שאלות כן או לא, יש לנו 16 תוצאות אפשריות עבור

181
00:14:22,948 --> 00:14:27,892
בדיקות השוויון שלנו, ובהתחלה זה מרגיש מושלם לאיתור 1 מתוך 16

182
00:14:27,892 --> 00:14:33,000
מיקומים בבלוק, אבל אתה צריך גם לתקשר תוצאה 17, ללא שגיאה מַצָב.

183
00:14:33,000 --> 00:14:37,860
הפתרון כאן הוא למעשה די פשוט, פשוט תשכחו לגמרי מהביט ה-0 הזה.

184
00:14:37,860 --> 00:14:41,187
אז כשאנחנו עושים את ארבעת בדיקות השוויון שלנו ואנו

185
00:14:41,187 --> 00:14:44,320
רואים שכולם שווים, זה אומר חד משמעית שאין שגיאה.

186
00:14:44,320 --> 00:14:49,266
מה שזה אומר הוא במקום לעבוד עם בלוק של 16 סיביות, אנחנו עובדים עם בלוק של

187
00:14:49,266 --> 00:14:54,080
15 סיביות, שבו 11 מהסיביות חופשיות לשאת הודעה ו-4 מהן נמצאות לשם יתירות.

188
00:14:54,080 --> 00:14:59,400
ועם זה, יש לנו עכשיו את מה שאנשים בעסק יתייחסו אליו כקוד 15-11 Hamming.

189
00:14:59,400 --> 00:15:04,283
עם זאת, זה נחמד שיש גודל בלוק שהוא כוח נקי של 2, ויש דרך חכמה שנוכל

190
00:15:04,283 --> 00:15:08,880
לשמור על הסיביות ה-0 הזו ולגרום לה לעשות קצת עבודה נוספת עבורנו.

191
00:15:08,880 --> 00:15:12,728
אם אנו משתמשים בו כסיביות זוגיות על פני כל הבלוק, הוא מאפשר

192
00:15:12,728 --> 00:15:16,320
לנו לזהות, למרות שאיננו יכולים לתקן, שגיאות של 2 סיביות.

193
00:15:16,320 --> 00:15:17,440
ככה זה עובד.

194
00:15:17,440 --> 00:15:21,520
לאחר הגדרת ארבעת הביטים המיוחדים לתיקון שגיאות, אנו מגדירים את ה-0

195
00:15:21,520 --> 00:15:25,540
כך שהשוויון של הבלוק המלא יהיה זוגי, בדיוק כמו בדיקת זוגיות רגילה.

196
00:15:25,540 --> 00:15:29,540
עכשיו, אם יש שגיאת סיביות בודדת, אז השוויון של הבלוק המלא משתנה להיות

197
00:15:29,540 --> 00:15:33,940
אי-זוגי, אבל היינו תופסים את זה בכל מקרה הודות לארבעת הבדיקות לתיקון השגיאות.

198
00:15:33,940 --> 00:15:40,038
עם זאת, אם יש שתי שגיאות, אז השוויון הכולל יחזור להיות זוגי, אבל המקלט עדיין

199
00:15:40,038 --> 00:15:45,820
יראה שהייתה לפחות שגיאה כלשהי בגלל מה שקורה עם ארבעת בדיקות השוויון האלה.

200
00:15:45,820 --> 00:15:49,304
אז אם הם מבחינים בשוויון שווה בסך הכל, אבל משהו לא אפס

201
00:15:49,304 --> 00:15:52,980
קורה עם הבדיקות האחרות, זה אומר להם שהיו לפחות שתי שגיאות.

202
00:15:52,980 --> 00:15:54,420
זה לא חכם?

203
00:15:54,420 --> 00:15:58,171
למרות שאיננו יכולים לתקן את השגיאות של 2 סיביות אלה, רק על ידי

204
00:15:58,171 --> 00:16:02,340
החזרת הסיבית ה-0 הקטנה והמטרידה הזו לעבודה, היא מאפשרת לנו לזהות אותן.

205
00:16:02,340 --> 00:16:06,540
זה די סטנדרטי, זה ידוע בתור קוד Hamming מורחב.

206
00:16:06,540 --> 00:16:10,552
מבחינה טכנית, יש לך כעת תיאור מלא של מה שקוד Hamming

207
00:16:10,552 --> 00:16:13,580
עושה, לפחות לדוגמא של בלוק של 16 סיביות.

208
00:16:13,580 --> 00:16:17,780
אבל אני חושב שתמצא את זה יותר מספק לבדוק את ההבנה שלך ולגבש הכל

209
00:16:17,780 --> 00:16:21,980
עד לנקודה זו על ידי ביצוע דוגמה אחת מלאה מההתחלה ועד הסוף בעצמך.

210
00:16:21,980 --> 00:16:25,100
אבל אני אעבור איתך על זה כדי שתוכל לבדוק את עצמך.

211
00:16:25,100 --> 00:16:30,212
כדי להגדיר הודעה, בין אם זו הודעה מילולית שאתה מתרגם בחלל או נתונים

212
00:16:30,212 --> 00:16:35,700
שאתה רוצה לאחסן לאורך זמן, הצעד הראשון הוא לחלק אותו לנתחים של 11 סיביות.

213
00:16:35,700 --> 00:16:40,340
כל נתח הולך להיות ארוז לתוך בלוק 16 סיביות עמיד בפני שגיאות.

214
00:16:40,340 --> 00:16:43,740
אז בואו ניקח את זה כדוגמה ולמעשה נסתדר.

215
00:16:43,740 --> 00:16:45,380
קדימה, באמת תעשה את זה!

216
00:16:45,380 --> 00:16:52,980
בואו נעצור וננסה להרכיב את הבלוק הזה.

217
00:16:52,980 --> 00:16:53,980
בסדר, אתה מוכן?

218
00:16:53,980 --> 00:16:59,931
זכור, מיקום 0 יחד עם שאר החזקות של 2 שמורות לחובה לתיקון שגיאות,

219
00:16:59,931 --> 00:17:05,700
אז אתה מתחיל בהצבת סיביות ההודעה בכל הנקודות הנותרות, לפי הסדר.

220
00:17:05,700 --> 00:17:09,388
אתה צריך שתהיה לקבוצה הזו זוגיות זוגית, מה שהיא כבר עושה,

221
00:17:09,388 --> 00:17:13,140
אז היית צריך להגדיר את סיביות הזוגיות הזו במיקום 1 להיות 0.

222
00:17:13,140 --> 00:17:19,260
הקבוצה הבאה מתחילה עם זוגיות אי זוגית, אז היית צריך להגדיר את סיביות הזוגיות שלה להיות 1.

223
00:17:19,260 --> 00:17:22,150
הקבוצה שאחריה מתחילה עם זוגיות אי זוגית, אז שוב

224
00:17:22,150 --> 00:17:24,740
היית צריך להגדיר את סיביות הזוגיות שלה ל-1.

225
00:17:24,740 --> 00:17:31,500
ולקבוצה הסופית יש גם זוגיות אי זוגית, כלומר הגדרנו את הביט הזה במיקום 8 להיות 1.

226
00:17:31,500 --> 00:17:36,373
ואז כשלב הסופי, לבלוק המלא כעת יש זוגיות זוגית, כלומר אתה

227
00:17:36,373 --> 00:17:41,500
יכול להגדיר את מספר הסיביות 0, סיבית הזוגיות הכוללת, להיות 0.

228
00:17:41,500 --> 00:17:45,601
אז כאשר הבלוק הזה נשלח, השוויון של ארבע תת-הקבוצות

229
00:17:45,601 --> 00:17:48,980
המיוחדות ושל הבלוק בכללותו יהיה זוגי או 0.

230
00:17:48,980 --> 00:17:53,620
כחלק השני של התרגיל, בואו נגיד לכם לשחק את תפקיד המקלט.

231
00:17:53,620 --> 00:17:56,966
כמובן, זה אומר שאתם כבר לא יודעים מהי ההודעה הזו,

232
00:17:56,966 --> 00:18:00,180
אולי חלקכם שיננו אותה בעל פה, אבל בואו נניח שלא.

233
00:18:00,180 --> 00:18:04,567
מה שאני הולך לעשות זה לשנות או 0, 1 או 2 מהסיביות

234
00:18:04,567 --> 00:18:08,340
בבלוק הזה, ואז לבקש ממך להבין מה זה שעשיתי.

235
00:18:08,340 --> 00:18:13,460
אז שוב, עצור ונסה לפתור את זה.

236
00:18:13,460 --> 00:18:21,895
אוקיי, אז אתה כמקלט עכשיו בודק את קבוצת הזוגיות הראשונה ואתה יכול

237
00:18:21,895 --> 00:18:29,820
לראות שהיא זוגית, אז כל שגיאה שקיימת תצטרך להיות בעמודה זוגית.

238
00:18:29,820 --> 00:18:34,290
הסימון הבא נותן לנו מספר אי-זוגי, אומר לשנינו שיש

239
00:18:34,290 --> 00:18:38,760
לפחות שגיאה אחת, ומצמצם אותנו לעמודה הספציפית הזו.

240
00:18:38,760 --> 00:18:42,900
הבדיקה השלישית שווה, ומצמצמת את האפשרויות עוד יותר.

241
00:18:42,900 --> 00:18:47,061
ובדיקת השוויון האחרונה היא מוזרה, ואומרת לנו שיש שגיאה אי שם

242
00:18:47,061 --> 00:18:51,700
בתחתית, שעד עכשיו אנחנו יכולים לראות שהיא חייבת להיות בעמדה מספר 10.

243
00:18:51,700 --> 00:18:58,220
מה גם שהשוויון של כל הבלוק מוזר, נותן לנו ביטחון שהיה הפוך אחד ולא שניים.

244
00:18:58,220 --> 00:19:01,600
אם זה שלושה או יותר, כל ההימורים מושבתים.

245
00:19:01,600 --> 00:19:08,588
לאחר תיקון אותו סיביות מספר 10, שליפת 11 הסיביות שלא שימשו לתיקון נותנת לנו את הקטע

246
00:19:08,588 --> 00:19:15,577
הרלוונטי של ההודעה המקורית, שאם תגלגל אחורה ותשווה הוא אכן בדיוק מה שהתחלנו איתו את

247
00:19:15,577 --> 00:19:16,160
הדוגמה.

248
00:19:16,160 --> 00:19:19,933
ועכשיו כשאתה יודע לעשות את כל זה ביד, אני רוצה להראות לך איך אתה

249
00:19:19,933 --> 00:19:23,940
יכול לבצע את החלק המרכזי של כל ההיגיון הזה עם שורה אחת של קוד Python.

250
00:19:23,940 --> 00:19:29,016
אתה מבין, מה שעדיין לא סיפרתי לך זה עד כמה האלגוריתם הזה באמת אלגנטי, כמה

251
00:19:29,016 --> 00:19:34,298
פשוט לגרום למכונה להצביע על המיקום של שגיאה, איך לשנות אותה באופן שיטתי ואיך

252
00:19:34,298 --> 00:19:39,580
אנחנו יכולים למסגר את כל זאת כפעולה אחת בודדת ולא כמספר בדיקות זוגיות נפרדות.

253
00:19:39,580 --> 00:19:39,580
כדי להבין למה אני מתכוון, בוא הצטרף אליי בחלק 2.

