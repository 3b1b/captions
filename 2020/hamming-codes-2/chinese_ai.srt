1
00:00:00,000 --> 00:00:08,620
您是否想过如何在刮擦 CD 或

2
00:00:08,620 --> 00:00:10,900
DVD 后仍然可以播放其中存储的内容？

3
00:00:10,900 --> 00:00:15,280
划痕确实会影响磁盘上的

4
00:00:15,280 --> 00:00:20,500
1

5
00:00:20,500 --> 00:00:26,540
和

6
00:00:26,540 --> 00:00:28,400
0，因此它会读取与存储的数据不同的数据，但除非它确实被划伤，否则它读取的位会被解码为与编码到其上的文件完全相同的文件，尽管存在所有这些错误，但还是逐位复制。

7
00:00:28,400 --> 00:00:32,800
大量的数学智慧使我们能够以一种能够抵御错误的方式存储数据，并且同样重要的是能够传输数据。

8
00:00:32,800 --> 00:00:36,840


9
00:00:36,840 --> 00:00:41,480
好吧，实际上并不需要那么聪明就能想出一种方法来做到这一点。

10
00:00:41,480 --> 00:00:42,480


11
00:00:42,480 --> 00:00:47,660
任何文件，无论是视频、声音还是文本、代码、图像等等，最终都是由 1 和

12
00:00:47,660 --> 00:00:50,960
0 组成的序列。

13
00:00:50,960 --> 00:00:55,340
纠正任何被翻转的位的一个简单策略是存储每个位的三个副本。

14
00:00:55,340 --> 00:00:57,780


15
00:00:57,780 --> 00:01:02,240
然后，读取该文件的机器可以比较这三个副本，并在出现差异时始终从 3 个副本中取出最好的

16
00:01:02,240 --> 00:01:07,440
2 个。

17
00:01:07,440 --> 00:01:11,560
但这意味着将三分之二的空间用于冗余。

18
00:01:11,560 --> 00:01:15,360
即便如此，对于所有放弃的空间，也不能强有力地保证如果超过一位被翻转会发生什么。

19
00:01:15,360 --> 00:01:18,120


20
00:01:18,120 --> 00:01:21,960
更有趣的问题是如何做到这一点，以便在放弃尽可能少的空间的同时纠正错误。

21
00:01:21,960 --> 00:01:24,740


22
00:01:24,740 --> 00:01:28,500
例如，使用您将在本视频中了解的方法，您可以将数据存储在 256 位块中，其中每个块使用 9

23
00:01:28,500 --> 00:01:35,840
位，9！ 作为一种冗余，其他

24
00:01:35,840 --> 00:01:41,000
247 位可以自由地携带任何您想要的有意义的消息或数据。

25
00:01:41,000 --> 00:01:44,740
情况仍然是这样，如果这里有任何位被翻转，只需查看这个块，机器就能够识别出存在错误并准确定位错误所在，以便知道如何纠正它。

26
00:01:44,740 --> 00:01:49,640


27
00:01:49,640 --> 00:01:53,120


28
00:01:53,140 --> 00:01:55,540
老实说，这感觉就像魔法一样。

29
00:01:55,540 --> 00:01:59,400
对于这个特定的方案，如果两个位被翻转，机器至少能够检测到存在两个错误，尽管它不知道如何修复它们。

30
00:01:59,400 --> 00:02:03,180


31
00:02:03,180 --> 00:02:08,140
稍后我们将讨论如何针对不同大小的块进行缩放。

32
00:02:08,140 --> 00:02:12,620
可以合理地纠正此类错误的方法称为纠错码。

33
00:02:12,620 --> 00:02:13,880


34
00:02:13,880 --> 00:02:18,220
在上个世纪的大部分时间里，这个领域一直是令人惊讶的深度数学的丰富来源，这些数学被纳入我们每天使用的设备中。

35
00:02:18,220 --> 00:02:23,000


36
00:02:23,000 --> 00:02:27,740
这里的目标是让您非常彻底地了解最早的示例之一，即汉明码。

37
00:02:27,740 --> 00:02:29,660


38
00:02:29,660 --> 00:02:32,620
顺便说一句，我对这个视频结构的思考方式并不是尽可能直接地解释它，而是提示你自己发明它，并时不时地给予一些温和的指导。

39
00:02:32,620 --> 00:02:37,060


40
00:02:37,060 --> 00:02:40,220


41
00:02:40,220 --> 00:02:44,100
因此，当你觉得你在某个时刻看到了它的发展方向时，请花点时间停下来，在我告诉你之前积极预测该计划将会是什么。

42
00:02:44,100 --> 00:02:47,180


43
00:02:47,180 --> 00:02:51,500
另外，如果你想让你的理解深入到硬件层面，Ben

44
00:02:51,500 --> 00:02:55,160
Eater

45
00:02:55,160 --> 00:02:59,520
制作了一个与此相关的视频，向你展示如何在面包板上实际实现汉明码，这非常令人满意。

46
00:02:59,520 --> 00:03:03,120
您应该知道，汉明码并不像里德-所罗门算法等更现代的代码那样广泛使用，但是这项任务一开始感觉不可能，而一旦完成却显得多么合理，两者之间的对比有一定的魔力。你了解了汉明。

47
00:03:03,120 --> 00:03:08,040


48
00:03:08,040 --> 00:03:14,240


49
00:03:14,240 --> 00:03:19,080
纠错的基本原理是，在所有可能消息的巨大空间中，只有某些子集将被视为有效消息。

50
00:03:19,300 --> 00:03:22,860


51
00:03:22,860 --> 00:03:29,100
打个比方，想想拼写正确的单词和拼写错误的单词。

52
00:03:29,100 --> 00:03:33,340
每当有效消息被更改时，接收者就有责任将他们看到的内容纠正回最近的有效邻居，就像您可能会处理拼写错误一样。

53
00:03:33,340 --> 00:03:38,380


54
00:03:38,380 --> 00:03:43,100
不过，想出一个具体的算法来有效地对这样的消息进行分类需要一定的聪明才智。

55
00:03:43,100 --> 00:03:47,160


56
00:03:47,160 --> 00:03:52,060
故事开始于 20 世纪

57
00:03:52,060 --> 00:03:55,900
40 年代，当时年轻的理查德·汉明 (Richard

58
00:03:55,900 --> 00:03:57,420
Hamming) 在贝尔实验室工作，他的一些工作涉及使用一台非常昂贵的打孔卡计算机，而他只能有限地使用该计算机。

59
00:03:57,420 --> 00:04:01,200
他不断执行的程序总是失败，因为时不时会有一点被误读。

60
00:04:01,200 --> 00:04:03,140


61
00:04:03,140 --> 00:04:07,140
挫折是发明的严峻考验，他受够了，因此发明了世界上第一个纠错码。

62
00:04:07,140 --> 00:04:09,280


63
00:04:09,280 --> 00:04:13,020
构建汉明码的方法有很多种，但作为第一步，我们将按照汉明本人对它们的看法来了解它。

64
00:04:13,020 --> 00:04:16,620


65
00:04:16,620 --> 00:04:21,400
让我们使用一个简单但又不太简单的例子，一个 16 位的块。

66
00:04:21,400 --> 00:04:25,700
我们将这些位的位置从 0 到 15 进行编号。

67
00:04:25,700 --> 00:04:30,520
我们想要存储的实际数据仅由其中的 12 位组成，而其中

68
00:04:30,520 --> 00:04:33,920
4 个位置被保留作为一种冗余。

69
00:04:33,920 --> 00:04:38,120
这里的冗余一词并不简单地意味着复制，毕竟这4位并没有给我们足够的空间来盲目地复制数据。

70
00:04:38,120 --> 00:04:40,200


71
00:04:40,200 --> 00:04:44,880
相反，它们需要更加细致和巧妙的冗余，不是添加任何新信息，而是增加弹性。

72
00:04:44,880 --> 00:04:48,740


73
00:04:48,740 --> 00:04:52,620
您可能期望这 4

74
00:04:52,620 --> 00:04:56,400
个特殊位能够很好地打包在一起，也许是在最后或类似的地方，但正如您所看到的，让它们位于 2

75
00:04:56,400 --> 00:05:00,320
的幂的位置可以让最终变得非常优雅。

76
00:05:00,320 --> 00:05:05,420
它还可能会给您一些关于如何扩展到更大块的提示。

77
00:05:05,420 --> 00:05:09,220
另外，从技术上讲，它最终只有 11 位数据，您会发现位置

78
00:05:09,220 --> 00:05:14,260
0 处发生的情况有轻微的细微差别，但现在不用担心。

79
00:05:14,280 --> 00:05:18,640
与任何纠错算法一样，这将涉及两个参与者：一个负责设置这

80
00:05:18,640 --> 00:05:23,200
4

81
00:05:23,200 --> 00:05:26,360
个特殊位的发送方，以及一个负责执行某种检查和纠正错误的接收方。

82
00:05:26,360 --> 00:05:30,040
当然，“发送者”和“接收者”这两个词实际上是指执行所有检查的机器或软件，并且消息的概念含义非常广泛，包括存储等内容。

83
00:05:30,040 --> 00:05:34,040


84
00:05:34,040 --> 00:05:35,480


85
00:05:35,480 --> 00:05:39,320
毕竟，存储数据与将消息从过去发送到未来是一样的，而不是从一个地方发送到另一个地方。

86
00:05:39,320 --> 00:05:42,640


87
00:05:42,640 --> 00:05:46,700
这就是设置，但在我们深入讨论之前，我们需要讨论一个相关的想法，这是汉明在发现时的新鲜想法，这种方法可以让您检测到任何单个位错误，但不能纠正它们，已知在业务中作为奇偶校验。

88
00:05:46,700 --> 00:05:51,080


89
00:05:51,080 --> 00:05:55,520


90
00:05:55,520 --> 00:05:57,300


91
00:05:57,300 --> 00:06:01,300
对于奇偶校验，我们只分离出发送者负责调整的一位，其余的可以自由地携带消息。

92
00:06:01,300 --> 00:06:04,940


93
00:06:04,940 --> 00:06:10,380
该特殊位的唯一作用是确保消息中 1

94
00:06:10,380 --> 00:06:12,100
的总数为偶数。

95
00:06:12,100 --> 00:06:16,920
例如，现在 1 的总数是

96
00:06:16,920 --> 00:06:20,960
7，这是奇数，因此发送方需要将该特殊位翻转为 1，使计数为偶数。

97
00:06:20,960 --> 00:06:25,320
但如果该块已经以偶数个 1

98
00:06:25,320 --> 00:06:27,480
开始，那么这个特殊位将保持为 0。

99
00:06:27,480 --> 00:06:31,640
这非常简单，看似简单，但它是一种极其优雅的方式，可以将消息中任何位置的变化的想法提炼出来，并反映在单个信息中。

100
00:06:31,640 --> 00:06:37,760


101
00:06:37,760 --> 00:06:43,680
请注意，如果此消息的任何位被翻转（从 0 到 1 或

102
00:06:43,680 --> 00:06:48,140
1 到 0），它会将 1 的总数从偶数更改为奇数。

103
00:06:48,140 --> 00:06:52,000
因此，如果您是接收者，您查看此消息，并且看到奇数个

104
00:06:52,000 --> 00:06:56,580
1，您可以确定发生了某些错误，即使您可能不知道错误发生在哪里。

105
00:06:56,580 --> 00:06:58,700


106
00:06:58,700 --> 00:07:02,820
用行话来说，一组位的 1

107
00:07:02,820 --> 00:07:04,940
数量是偶数还是奇数，称为奇偶校验。

108
00:07:04,940 --> 00:07:09,140
您还可以使用数字并表示奇偶校验为 0

109
00:07:09,140 --> 00:07:11,320
或 1，一旦您开始用这个想法进行数学计算，这通常会更有帮助。

110
00:07:11,320 --> 00:07:15,200
发送方用来控制奇偶校验的特殊位称为奇偶校验位。

111
00:07:15,200 --> 00:07:18,020


112
00:07:18,020 --> 00:07:22,460
实际上，我们应该清楚，如果接收器看到奇数奇偶校验，并不一定意味着只有一个错误，可能有 3

113
00:07:22,460 --> 00:07:26,920
个错误，或 5

114
00:07:26,920 --> 00:07:29,560
个错误，或任何其他奇数，但他们可以肯定知道它不是 0。

115
00:07:29,560 --> 00:07:34,880
另一方面，如果出现 2

116
00:07:34,880 --> 00:07:39,560
个错误，或者任何偶数个错误，则最终的 1

117
00:07:39,560 --> 00:07:43,360
计数仍然是偶数，因此接收方无法完全确信偶数计数一定意味着消息没有错误。

118
00:07:43,360 --> 00:07:47,860
您可能会抱怨仅通过 2

119
00:07:47,860 --> 00:07:49,760
位翻转就搞乱的消息非常弱，您是绝对正确的。

120
00:07:49,760 --> 00:07:54,480
但请记住，没有任何错误检测或纠正方法可以让您 100%

121
00:07:54,480 --> 00:07:59,720
确信您收到的消息正是发件人想要的消息。

122
00:07:59,720 --> 00:08:03,760
毕竟，足够多的随机噪声总能偶然将一条有效消息变成另一条有效消息。

123
00:08:03,760 --> 00:08:05,920


124
00:08:05,920 --> 00:08:10,520
相反，我们的目标是提出一种在一定的最大错误数范围内稳健的方案，或者减少像这样的误报的可能性。

125
00:08:10,520 --> 00:08:16,480


126
00:08:16,480 --> 00:08:20,940
奇偶校验本身相当弱，但通过将整个消息的变化思想提炼为单个位，它们为我们提供了更复杂方案的强大构建块。

127
00:08:20,940 --> 00:08:25,640


128
00:08:25,640 --> 00:08:28,000


129
00:08:28,000 --> 00:08:32,880
例如，由于汉明正在寻找一种方法来识别错误发生的位置，而不仅仅是错误发生的地方，他的主要见解是，如果您不对完整消息而是对某些精心选择的子集应用一些奇偶校验检查，您可以询问一系列更精确的问题，可以确定任何一位错误的位置。

130
00:08:32,880 --> 00:08:37,160


131
00:08:37,160 --> 00:08:42,040


132
00:08:42,040 --> 00:08:46,840


133
00:08:46,840 --> 00:08:51,280
总体感觉有点像玩 20

134
00:08:51,280 --> 00:08:54,300
个问题的游戏，提出是或否的问题，从而将可能性的空间减半。

135
00:08:54,300 --> 00:08:58,840
例如，假设我们仅对这 8

136
00:08:58,840 --> 00:08:59,840
位（所有奇数位置）进行奇偶校验。

137
00:09:00,400 --> 00:09:04,560
然后，如果检测到错误，它会向接收器提供更多有关错误具体位置的信息，即错误位于奇怪的位置。

138
00:09:04,560 --> 00:09:09,160


139
00:09:09,160 --> 00:09:14,360
如果在这 8

140
00:09:14,360 --> 00:09:17,240
位中没有检测到错误，则意味着根本没有错误，或者它位于偶数位置。

141
00:09:17,240 --> 00:09:21,560
您可能认为将奇偶校验检查限制为一半会降低其效率，但是当它与其他精心选择的检查结合使用时，它会给我们带来更强大的东西，这与直觉相反。

142
00:09:21,560 --> 00:09:25,460


143
00:09:25,460 --> 00:09:29,720


144
00:09:29,720 --> 00:09:34,440
请记住，要实际设置奇偶校验检查，它需要指定一些特殊位来控制整个组的奇偶校验。

145
00:09:34,440 --> 00:09:37,600


146
00:09:37,600 --> 00:09:39,920
这里我们只选择位置1。

147
00:09:39,920 --> 00:09:43,960
对于所示的示例，这 8

148
00:09:43,960 --> 00:09:48,220
位的奇偶校验当前是奇数，因此发送方负责切换该奇偶校验位，现在它是偶数。

149
00:09:48,220 --> 00:09:51,040
这只是我们要做的 4 次奇偶校验中的 1 次。

150
00:09:51,040 --> 00:09:55,560
第二个检查位于网格右半部分的 8

151
00:09:55,560 --> 00:09:56,880
位中，至少我们在这里绘制的是这样的。

152
00:09:56,880 --> 00:10:02,520
这次我们可能使用位置 2 作为奇偶校验位，因此这 8

153
00:10:02,520 --> 00:10:07,160
位已经具有偶校验，并且发送方可以感觉良好，保持该位号 2 不变。

154
00:10:07,160 --> 00:10:11,040
然后在另一端，如果接收器检查该组的奇偶校验并且发现奇偶校验，他们就会知道错误位于右侧的这 8

155
00:10:11,040 --> 00:10:15,960
位中的某个位置。

156
00:10:15,960 --> 00:10:21,260
否则，这意味着要么没有错误，要么错误位于左半部分。

157
00:10:21,260 --> 00:10:24,040
或者我猜可能有两个错误，但现在我们假设整个块中最多有一个错误。

158
00:10:24,040 --> 00:10:27,080


159
00:10:27,080 --> 00:10:29,160
事情远不止于此。

160
00:10:29,160 --> 00:10:32,920
在这里，在我们查看接下来的两项检查之前，请花点时间思考一下，当您将前两项检查放在一起考虑时，我们可以做什么。

161
00:10:32,920 --> 00:10:35,880


162
00:10:35,880 --> 00:10:40,240
假设您在奇数列和右半列中检测到错误。

163
00:10:40,240 --> 00:10:43,940
这必然意味着错误位于最后一列的某个位置。

164
00:10:43,940 --> 00:10:48,280
如果奇数列中没有错误，但右半部分有错误，则说明它位于倒数第二列。

165
00:10:48,280 --> 00:10:50,520


166
00:10:50,520 --> 00:10:54,640
同样，如果奇数列中有错误但右半部分没有错误，您就知道它在第二列中的某个位置。

167
00:10:54,640 --> 00:10:56,560


168
00:10:56,560 --> 00:11:00,560
如果这两个奇偶校验都没有检测到任何内容，则意味着唯一可能出现错误的位置是最左边的列。

169
00:11:00,560 --> 00:11:03,760


170
00:11:03,760 --> 00:11:06,480
但这也可能仅仅意味着根本没有错误。

171
00:11:06,480 --> 00:11:10,800
这是一种相当繁琐的说法，两次奇偶校验让我们确定了该列。

172
00:11:10,800 --> 00:11:11,800


173
00:11:11,800 --> 00:11:14,000
从这里，你大概可以猜到接下来会发生什么。

174
00:11:14,000 --> 00:11:16,240
除了行之外，我们基本上做相同的事情。

175
00:11:16,240 --> 00:11:21,040
将使用位置 4 作为奇偶校验位对奇数行进行奇偶校验。

176
00:11:21,040 --> 00:11:25,480
因此，在此示例中，该组已经具有偶校验，因此位 4

177
00:11:25,480 --> 00:11:26,480
将设置为 0。

178
00:11:26,480 --> 00:11:31,280
最后，对底部两行进行奇偶校验，使用位置 8

179
00:11:31,280 --> 00:11:32,280
作为奇偶校验位。

180
00:11:32,280 --> 00:11:35,840
在这种情况下，发送方似乎需要打开第 8

181
00:11:35,840 --> 00:11:37,840
位才能为组提供偶校验。

182
00:11:37,840 --> 00:11:41,360
正如前两项检查让我们确定列一样，接下来的两项检查让您确定行。

183
00:11:41,360 --> 00:11:43,000


184
00:11:43,000 --> 00:11:48,400
举个例子，假设在传输过程中，位置 3 处出现错误。

185
00:11:48,400 --> 00:11:52,620
这会影响第一个奇偶校验组，也会影响第二个奇偶校验组，因此接收器知道右列中的某处存在错误。

186
00:11:52,620 --> 00:11:56,340


187
00:11:56,340 --> 00:12:01,380
但不影响第三组，也不影响第四组。

188
00:12:01,380 --> 00:12:05,460
这可以让接收者精确定位到第一行（这必然意味着位置

189
00:12:05,460 --> 00:12:08,660
3）的错误，这样他们就可以修复错误。

190
00:12:08,660 --> 00:12:12,640
您可能会喜欢花点时间说服自己，这四个问题的答案确实总是能让您确定一个特定的位置，无论它们最终在哪里。

191
00:12:12,680 --> 00:12:17,320


192
00:12:17,320 --> 00:12:22,640
事实上，精明的你们甚至可能会注意到这些问题和二进制计数之间的联系。

193
00:12:22,640 --> 00:12:23,640


194
00:12:23,640 --> 00:12:27,840
如果你这样做了，请再次让我强调一下，暂停一下，在我破坏之前尝试自己找出其中的联系。

195
00:12:27,840 --> 00:12:30,880


196
00:12:30,880 --> 00:12:35,560
如果您想知道如果奇偶校验位本身受到影响会发生什么，那么您可以尝试一下。

197
00:12:35,560 --> 00:12:36,560


198
00:12:36,560 --> 00:12:40,720
花点时间思考一下，如何使用同一组四个问题来追踪这四个特殊位中的任何错误，就像任何其他错误一样。

199
00:12:40,720 --> 00:12:47,440


200
00:12:47,440 --> 00:12:50,500
这并不重要，因为最终我们想要的是保护消息位，纠错位只是随之而来。

201
00:12:50,500 --> 00:12:53,640


202
00:12:53,640 --> 00:12:57,120
但保护这些位也是该计划的副产品。

203
00:12:57,120 --> 00:12:59,260


204
00:12:59,260 --> 00:13:02,380
您可能还喜欢预测其规模如何。

205
00:13:02,380 --> 00:13:08,040
例如，如果我们使用大小为 256

206
00:13:08,040 --> 00:13:15,680
位的块，为了确定位置，您只需要八个是或否问题即可二进制搜索到某个特定位置。

207
00:13:15,680 --> 00:13:19,680
请记住，每个问题只需要放弃一位即可设置适当的奇偶校验。

208
00:13:19,680 --> 00:13:23,340


209
00:13:23,340 --> 00:13:26,960
你们中的一些人可能已经看到了，但我们稍后会讨论在一两分钟内找到这些问题的系统方法。

210
00:13:26,960 --> 00:13:29,960


211
00:13:29,960 --> 00:13:33,440
希望这个草图足以让我们了解我们正在开发的产品的效率。

212
00:13:33,440 --> 00:13:34,440


213
00:13:34,440 --> 00:13:38,440
第一件事，除了那八个突出显示的奇偶校验位之外，可以是您想要的任何内容，携带您想要的任何消息或数据。

214
00:13:38,440 --> 00:13:41,720


215
00:13:41,720 --> 00:13:45,480
8

216
00:13:45,480 --> 00:13:53,640
位是冗余的，因为它们完全由消息的其余部分决定，但它比简单地复制整个消息要聪明得多。

217
00:13:53,640 --> 00:13:58,000
尽管如此，只要放弃一点点，您就能够识别并修复任何一位错误。

218
00:13:58,000 --> 00:13:59,000


219
00:13:59,000 --> 00:14:00,400
嗯，差不多了。

220
00:14:00,400 --> 00:14:05,920
好的，所以这里的一个问题是，如果四个奇偶校验检查都没有检测到错误，这意味着专门选择的

221
00:14:05,920 --> 00:14:10,240
8

222
00:14:10,240 --> 00:14:15,520
位子集都具有偶数奇偶校验，就像发送者预期的那样，那么它要么意味着根本没有错误，或者它会将我们的范围缩小到位置

223
00:14:15,520 --> 00:14:17,760
0。

224
00:14:17,760 --> 00:14:23,040
你看，有四个是或否问题，我们的奇偶校验有 16 种可能的结果，一开始感觉非常适合精确定位块中

225
00:14:23,040 --> 00:14:28,000
16 个位置中的 1

226
00:14:28,000 --> 00:14:33,000
个，但你还需要传达第 17 个结果，即没有错误健康）状况。

227
00:14:33,000 --> 00:14:37,860
这里的解决方案实际上非常简单，只需完全忘记第 0 位即可。

228
00:14:37,860 --> 00:14:41,920
因此，当我们进行四次奇偶校验并且发现它们都是偶数时，就明确意味着没有错误。

229
00:14:41,920 --> 00:14:44,320


230
00:14:44,320 --> 00:14:49,240
这意味着我们不是使用 16 位块，而是使用 15 位块，其中

231
00:14:49,240 --> 00:14:54,040
11 位可自由携带消息，其中 4 位用于冗余。

232
00:14:54,080 --> 00:14:58,400
这样，我们现在就有了业内人士所说的 15-11

233
00:14:58,400 --> 00:14:59,400
汉明码。

234
00:14:59,400 --> 00:15:03,920
也就是说，块大小是 2 的幂次方是件好事，并且有一种聪明的方法可以保留第

235
00:15:03,920 --> 00:15:08,880
0 位并让它为我们做一些额外的工作。

236
00:15:08,880 --> 00:15:13,600
如果我们将它用作整个块的奇偶校验位，即使我们无法纠正，它也可以让我们实际检测到 2

237
00:15:13,600 --> 00:15:16,320
位错误。

238
00:15:16,320 --> 00:15:17,440
这是它的工作原理。

239
00:15:17,440 --> 00:15:21,740
设置完这四个特殊的纠错位后，我们设置第 0

240
00:15:21,740 --> 00:15:25,540
个位，以便整个块的奇偶校验是偶数，就像正常的奇偶校验一样。

241
00:15:25,540 --> 00:15:29,780
现在，如果存在单个位错误，则整个块的奇偶校验会切换为奇数，但由于四次纠错检查，我们无论如何都会捕获到这一点。

242
00:15:29,780 --> 00:15:33,940


243
00:15:33,940 --> 00:15:38,100
然而，如果有两个错误，那么整体奇偶校验将切换回偶数，但接收器仍然会看到由于这四个奇偶校验检查的情况而至少存在一些错误。

244
00:15:38,100 --> 00:15:42,660


245
00:15:42,660 --> 00:15:45,820


246
00:15:45,820 --> 00:15:49,780
因此，如果他们注意到整体奇偶校验，但其他检查发生非零的情况，则表明至少存在两个错误。

247
00:15:49,820 --> 00:15:52,980


248
00:15:52,980 --> 00:15:54,420
这不是很聪明吗？

249
00:15:54,420 --> 00:15:58,500
尽管我们无法纠正这些 2 位错误，但只需将那个有点麻烦的第

250
00:15:58,500 --> 00:16:02,340
0 位重新投入工作，我们就可以检测到它们。

251
00:16:02,340 --> 00:16:06,540
这是非常标准的，被称为扩展汉明码。

252
00:16:06,540 --> 00:16:10,860
从技术上讲，您现在已经完整地描述了汉明码的作用，至少对于 16

253
00:16:10,860 --> 00:16:13,580
位块的示例是这样。

254
00:16:13,580 --> 00:16:17,300
但我认为您会发现通过自己从头到尾做一个完整的示例来检查您的理解并巩固到目前为止的所有内容会更令人满意。

255
00:16:17,300 --> 00:16:21,980


256
00:16:21,980 --> 00:16:25,100
不过我会和你一起逐步完成，这样你就可以自己检查一下。

257
00:16:25,100 --> 00:16:29,180
要设置消息，无论是在空间上转换的文字消息还是要随时间存储的某些数据，第一步都是将其划分为

258
00:16:29,180 --> 00:16:34,100
11

259
00:16:34,100 --> 00:16:35,700
位块。

260
00:16:35,700 --> 00:16:40,340
每个块将被打包成一个防错的 16 位块。

261
00:16:40,340 --> 00:16:43,740
那我们就以这个为例，实际操作一下吧。

262
00:16:43,740 --> 00:16:45,340
话不多说，实际行动起来吧！

263
00:16:45,380 --> 00:16:47,380
让我们暂停一下并尝试将这个块放在一起。

264
00:16:52,980 --> 00:16:53,980
好吧，你准备好了吗？

265
00:16:53,980 --> 00:16:58,500
请记住，位置 0 以及

266
00:16:58,500 --> 00:17:05,700
2 的其他幂保留用于纠错职责，因此您首先将消息位按顺序放置在所有剩余位置中。

267
00:17:05,700 --> 00:17:09,700
您需要该组具有偶校验，它已经这样做了，因此您应该将位置 1

268
00:17:09,700 --> 00:17:13,140
中的奇偶校验位设置为 0。

269
00:17:13,140 --> 00:17:17,700
下一组以奇数奇偶校验开始，因此您应该将其奇偶校验位设置为

270
00:17:17,700 --> 00:17:19,260
1。

271
00:17:19,260 --> 00:17:23,740
之后的组以奇数奇偶校验开始，因此您应该再次将其奇偶校验位设置为

272
00:17:23,740 --> 00:17:24,740
1。

273
00:17:24,740 --> 00:17:29,500
最后一组也有奇数奇偶校验，这意味着我们将位置 8

274
00:17:29,500 --> 00:17:31,500
中的该位设置为 1。

275
00:17:31,500 --> 00:17:36,460
最后一步，整个块现在具有偶校验，这意味着您可以将位号 0（总体奇偶校验位）设置为

276
00:17:36,460 --> 00:17:41,500
0。

277
00:17:41,500 --> 00:17:45,660
因此，当该块被发送出去时，四个特殊子集和整个块的奇偶校验都将为偶数，即

278
00:17:45,660 --> 00:17:48,980
0。

279
00:17:48,980 --> 00:17:53,620
作为练习的第二部分，让您扮演接收者的角色。

280
00:17:53,620 --> 00:17:57,580
当然，这意味着您还不知道该消息是什么，也许你们中的一些人记住了它，但我们假设您还没有记住。

281
00:17:57,580 --> 00:18:00,180


282
00:18:00,180 --> 00:18:05,820
我要做的是更改该块中的 0、1 或

283
00:18:05,820 --> 00:18:08,340
2 个位，然后要求您弄清楚我做了什么。

284
00:18:08,340 --> 00:18:13,460
所以，再次，暂停并尝试解决它。

285
00:18:13,460 --> 00:18:23,960
好的，作为接收者，您现在检查第一个奇偶校验组，您可以看到它是偶数，因此存在的任何错误都必须位于偶数列中。

286
00:18:23,960 --> 00:18:29,820


287
00:18:29,820 --> 00:18:34,620
下一次检查给我们一个奇数，告诉我们至少有一个错误，并将我们的范围缩小到这一特定列。

288
00:18:34,620 --> 00:18:38,760


289
00:18:38,760 --> 00:18:42,900
第三次检查是均匀的，进一步减少了可能性。

290
00:18:42,900 --> 00:18:46,780
最后的奇偶校验很奇怪，告诉我们底部的某个地方有错误，现在我们可以看到它一定在位置 10

291
00:18:46,780 --> 00:18:51,700
处。

292
00:18:51,700 --> 00:18:56,140
更重要的是，整个区块的奇偶性是奇怪的，这让我们确信只有一次翻转而不是两次。

293
00:18:56,140 --> 00:18:58,220


294
00:18:58,220 --> 00:19:01,600
如果是三个或更多，则所有赌注都失败了。

295
00:19:01,600 --> 00:19:06,520
纠正第 10

296
00:19:06,520 --> 00:19:11,620
位后，取出未用于纠正的 11

297
00:19:11,620 --> 00:19:16,160
位，即可得到原始消息的相关片段，如果您倒回并比较，该片段确实正是我们开始示例时所用的片段。

298
00:19:16,160 --> 00:19:19,260
现在您已经知道如何手动完成所有这些操作，我想向您展示如何使用一行 Python

299
00:19:19,260 --> 00:19:23,940
代码来执行所有这些逻辑的核心部分。

300
00:19:23,940 --> 00:19:28,400
你看，我还没有告诉你的是这个算法到底有多么优雅，让机器指出错误的位置是多么简单，如何系统地缩放它，以及我们如何构建所有错误这是一个单一操作，而不是多个单独的奇偶校验检查。

301
00:19:28,400 --> 00:19:32,380


302
00:19:32,380 --> 00:19:37,680


303
00:19:37,680 --> 00:19:39,580


304
00:19:39,580 --> 00:19:41,680
要明白我的意思，请跟我一起看第二部分。

