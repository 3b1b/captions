1
00:00:00,000 --> 00:00:05,400
¿Alguna vez te has preguntado cómo es posible rayar un

2
00:00:05,400 --> 00:00:10,900
CD o un DVD y aún así reproducir lo que esté almacenado?

3
00:00:10,900 --> 00:00:13,826
El rayado realmente afecta los 1 y 0 en el disco,

4
00:00:13,826 --> 00:00:17,572
por lo que lee datos diferentes de los que estaban almacenados,

5
00:00:17,572 --> 00:00:21,786
pero a menos que esté realmente rayado, los bits que lee se decodifican

6
00:00:21,786 --> 00:00:26,644
exactamente en el mismo archivo que estaba codificado en él, un copia bit por bit,

7
00:00:26,644 --> 00:00:28,400
a pesar de todos esos errores.

8
00:00:28,400 --> 00:00:32,644
Existe una gran cantidad de inteligencia matemática que nos permite almacenar datos y,

9
00:00:32,644 --> 00:00:36,840
lo que es igualmente importante, transmitirlos de una manera resistente a los errores.

10
00:00:36,840 --> 00:00:39,605
Bueno, está bien, en realidad no se necesita mucha

11
00:00:39,605 --> 00:00:42,480
inteligencia para encontrar una manera de hacer esto.

12
00:00:42,480 --> 00:00:46,577
Cualquier archivo, ya sea un vídeo, un sonido o un texto, algún código,

13
00:00:46,577 --> 00:00:50,960
una imagen, lo que sea, es en última instancia una secuencia de unos y ceros.

14
00:00:50,960 --> 00:00:54,308
Y una estrategia sencilla para corregir cualquier bit

15
00:00:54,308 --> 00:00:57,780
que se invierta sería almacenar tres copias de cada bit.

16
00:00:57,780 --> 00:01:02,400
Luego, la máquina que lea este archivo podría comparar estas tres

17
00:01:02,400 --> 00:01:07,440
copias y siempre tomará las 2 mejores de 3 cuando haya una discrepancia.

18
00:01:07,440 --> 00:01:11,560
Pero lo que eso significa es utilizar dos tercios de su espacio para redundancia.

19
00:01:11,560 --> 00:01:14,364
E incluso entonces, a pesar de todo ese espacio cedido,

20
00:01:14,364 --> 00:01:18,120
no hay una garantía sólida de lo que sucederá si se invierte más de un bit.

21
00:01:18,120 --> 00:01:21,261
La pregunta mucho más interesante es cómo lograr que se

22
00:01:21,261 --> 00:01:24,740
puedan corregir los errores ocupando el menor espacio posible.

23
00:01:24,740 --> 00:01:28,137
Por ejemplo, usando el método que aprenderá en este video,

24
00:01:28,137 --> 00:01:32,975
podría almacenar sus datos en bloques de 256 bits, donde cada bloque usa 9 bits, ¡9!

25
00:01:32,975 --> 00:01:36,903
para actuar como una especie de redundancia, y los otros 247 bits son

26
00:01:36,903 --> 00:01:41,000
libres para transportar cualquier mensaje o dato significativo que desee.

27
00:01:41,000 --> 00:01:44,450
Y seguirá siendo así que si aquí se voltea algún bit,

28
00:01:44,450 --> 00:01:48,092
con solo mirar este bloque y nada más, una máquina podrá

29
00:01:48,092 --> 00:01:53,140
identificar que hubo un error y exactamente dónde estaba para saber corregirlo.

30
00:01:53,140 --> 00:01:55,540
Y, sinceramente, eso parece magia.

31
00:01:55,540 --> 00:01:58,586
Y para este esquema en particular, si se invierten dos bits,

32
00:01:58,586 --> 00:02:01,432
la máquina al menos podrá detectar que hubo dos errores,

33
00:02:01,432 --> 00:02:03,180
aunque no sabrá cómo solucionarlos.

34
00:02:03,180 --> 00:02:05,712
Hablaremos un poco más adelante sobre cómo esto

35
00:02:05,712 --> 00:02:08,140
se escala para bloques con diferentes tamaños.

36
00:02:08,140 --> 00:02:11,318
Los métodos que le permiten corregir errores como este se conocen,

37
00:02:11,318 --> 00:02:13,880
razonablemente, como códigos de corrección de errores.

38
00:02:13,880 --> 00:02:16,857
Durante la mayor parte del siglo pasado, este campo ha sido una

39
00:02:16,857 --> 00:02:19,882
fuente realmente rica de matemáticas sorprendentemente profundas

40
00:02:19,882 --> 00:02:23,000
que se incorporan a los dispositivos que utilizamos todos los días.

41
00:02:23,000 --> 00:02:28,009
El objetivo aquí es brindarle una comprensión profunda de uno de los primeros ejemplos,

42
00:02:28,009 --> 00:02:29,660
conocido como código Hamming.

43
00:02:29,660 --> 00:02:33,212
Y, por cierto, la forma en que pienso sobre la estructura de este video

44
00:02:33,212 --> 00:02:36,074
se trata menos de explicarlo lo más directamente posible,

45
00:02:36,074 --> 00:02:40,220
y más de incitarlo a inventarlo usted mismo, con un poco de guía amable aquí y allá.

46
00:02:40,220 --> 00:02:43,042
Entonces, cuando sientas que ves hacia dónde se dirige en algún momento,

47
00:02:43,042 --> 00:02:46,484
tómate ese momento para hacer una pausa y predice activamente cuál será el esquema antes

48
00:02:46,484 --> 00:02:47,180
de que te lo diga.

49
00:02:47,180 --> 00:02:51,095
Además, si desea que su comprensión llegue al nivel del hardware,

50
00:02:51,095 --> 00:02:54,833
Ben Eater ha hecho un video junto con este que le muestra cómo

51
00:02:54,833 --> 00:02:59,520
implementar códigos Hamming en placas, lo cual es extremadamente satisfactorio.

52
00:02:59,520 --> 00:03:03,124
Debes saber que los códigos Hamming no se utilizan tan ampliamente como

53
00:03:03,124 --> 00:03:06,028
los códigos más modernos, como el algoritmo Reed-Solomon,

54
00:03:06,028 --> 00:03:09,683
pero hay cierta magia en el contraste entre lo imposible que parece esta

55
00:03:09,683 --> 00:03:13,088
tarea al principio y lo absolutamente razonable que parece una vez.

56
00:03:13,088 --> 00:03:14,240
aprendes sobre Hamming.

57
00:03:14,240 --> 00:03:18,468
El principio básico de la corrección de errores es que en un vasto espacio de

58
00:03:18,468 --> 00:03:22,860
todos los mensajes posibles, sólo un subconjunto se considerará mensajes válidos.

59
00:03:22,860 --> 00:03:26,489
Como analogía, piense en palabras escritas correctamente

60
00:03:26,489 --> 00:03:29,100
versus palabras escritas incorrectamente.

61
00:03:29,100 --> 00:03:33,711
Siempre que se modifica un mensaje válido, el receptor es responsable de corregir

62
00:03:33,711 --> 00:03:38,380
lo que ve al vecino válido más cercano, como podría hacer con un error tipográfico.

63
00:03:38,380 --> 00:03:42,770
Sin embargo, idear un algoritmo concreto para categorizar

64
00:03:42,770 --> 00:03:47,160
eficientemente mensajes como este requiere cierta astucia.

65
00:03:47,160 --> 00:03:50,734
La historia comienza en la década de 1940, cuando un joven Richard Hamming trabajaba

66
00:03:50,734 --> 00:03:54,350
para los Laboratorios Bell, y parte de su trabajo implicaba el uso de una computadora

67
00:03:54,350 --> 00:03:57,420
de tarjeta perforada muy grande y costosa a la que tenía acceso limitado.

68
00:03:57,420 --> 00:04:00,597
Y los programas que seguía poniendo en él seguían fallando,

69
00:04:00,597 --> 00:04:03,140
porque de vez en cuando se malinterpretaba algo.

70
00:04:03,140 --> 00:04:05,490
Siendo la frustración el crisol de la invención,

71
00:04:05,490 --> 00:04:09,280
se hartó tanto que inventó el primer código de corrección de errores del mundo.

72
00:04:09,280 --> 00:04:12,233
Hay muchas maneras diferentes de enmarcar los códigos de Hamming,

73
00:04:12,233 --> 00:04:15,724
pero como primer paso vamos a repasarlos de la forma en que el propio Hamming

74
00:04:15,724 --> 00:04:16,620
pensaba sobre ellos.

75
00:04:16,620 --> 00:04:21,400
Usemos un ejemplo que es simple, pero no demasiado simple, un bloque de 16 bits.

76
00:04:21,400 --> 00:04:25,700
Numeraremos las posiciones de estos bits del 0 al 15.

77
00:04:25,700 --> 00:04:29,626
Los datos reales que queremos almacenar solo conformarán 12 de estos bits,

78
00:04:29,626 --> 00:04:33,920
mientras que 4 de las posiciones están reservadas como una especie de redundancia.

79
00:04:33,920 --> 00:04:37,143
La palabra redundante aquí no significa simplemente copiar; después de todo,

80
00:04:37,143 --> 00:04:40,200
esos 4 bits no nos dan suficiente espacio para copiar los datos a ciegas.

81
00:04:40,200 --> 00:04:45,398
En cambio, tendrán que ser un tipo de redundancia mucho más matizada e inteligente,

82
00:04:45,398 --> 00:04:48,740
que no agregue información nueva, pero sí resiliencia.

83
00:04:48,740 --> 00:04:52,860
Se podría esperar que estos 4 bits especiales vengan bien empaquetados juntos,

84
00:04:52,860 --> 00:04:56,772
tal vez al final o algo así, pero como verás, colocarlos en posiciones que

85
00:04:56,772 --> 00:05:00,320
son potencias de 2 permite obtener algo realmente elegante al final.

86
00:05:00,320 --> 00:05:05,420
También podría darle una pequeña pista sobre cómo se adapta esto a bloques más grandes.

87
00:05:05,420 --> 00:05:08,588
Además, técnicamente termina siendo solo 11 bits de datos,

88
00:05:08,588 --> 00:05:12,239
encontrará que hay un leve matiz en lo que sucede en la posición 0,

89
00:05:12,239 --> 00:05:14,280
pero no se preocupe por eso por ahora.

90
00:05:14,280 --> 00:05:18,387
Como cualquier algoritmo de corrección de errores, esto involucrará a dos jugadores,

91
00:05:18,387 --> 00:05:22,446
un remitente que es responsable de configurar estos 4 bits especiales y un receptor

92
00:05:22,446 --> 00:05:26,360
que es responsable de realizar algún tipo de verificación y corregir los errores.

93
00:05:26,360 --> 00:05:29,307
Por supuesto, las palabras remitente y receptor en realidad se refieren a

94
00:05:29,307 --> 00:05:31,656
máquinas o software que realizan todas las comprobaciones,

95
00:05:31,656 --> 00:05:33,807
y la idea de mensaje tiene un significado muy amplio,

96
00:05:33,807 --> 00:05:35,480
para incluir cosas como el almacenamiento.

97
00:05:35,480 --> 00:05:39,029
Después de todo, almacenar datos es lo mismo que enviar un

98
00:05:39,029 --> 00:05:42,640
mensaje del pasado al futuro en lugar de de un lugar a otro.

99
00:05:42,640 --> 00:05:46,395
Así que esa es la configuración, pero antes de que podamos profundizar necesitamos

100
00:05:46,395 --> 00:05:50,060
hablar sobre una idea relacionada que estaba fresca en la mente de Hamming en el

101
00:05:50,060 --> 00:05:53,906
momento de su descubrimiento, un método que permite detectar errores de un solo bit,

102
00:05:53,906 --> 00:05:57,300
pero no corregirlos, como se conoce. en el negocio como control de paridad.

103
00:05:57,300 --> 00:06:01,120
Para una verificación de paridad, separamos solo un bit que el remitente

104
00:06:01,120 --> 00:06:04,940
es responsable de ajustar, y el resto es libre de transportar un mensaje.

105
00:06:04,940 --> 00:06:08,364
El único trabajo de este bit especial es asegurarse de

106
00:06:08,364 --> 00:06:12,100
que el número total de unos en el mensaje sea un número par.

107
00:06:12,100 --> 00:06:15,161
Entonces, por ejemplo, ahora mismo, el número total de unos es 7,

108
00:06:15,161 --> 00:06:18,130
eso es impar, por lo que el remitente necesita invertir ese bit

109
00:06:18,130 --> 00:06:20,960
especial para que sea un 1, haciendo que el recuento sea par.

110
00:06:20,960 --> 00:06:24,606
Pero si el bloque ya hubiera comenzado con un número par de unos,

111
00:06:24,606 --> 00:06:27,480
entonces este bit especial se habría mantenido en 0.

112
00:06:27,480 --> 00:06:29,802
Esto es bastante simple, engañosamente simple,

113
00:06:29,802 --> 00:06:33,361
pero es una forma increíblemente elegante de destilar la idea de cambio

114
00:06:33,361 --> 00:06:37,760
en cualquier parte de un mensaje para que se refleje en un solo fragmento de información.

115
00:06:37,760 --> 00:06:42,208
Observe que si alguna parte de este mensaje se invierte,

116
00:06:42,208 --> 00:06:48,140
ya sea de 0 a 1 o de 1 a 0, cambia el recuento total de unos de par a impar.

117
00:06:48,140 --> 00:06:53,148
Entonces, si usted es el receptor, mira este mensaje y ve un número impar de unos,

118
00:06:53,148 --> 00:06:56,467
puede estar seguro de que se ha producido algún error,

119
00:06:56,467 --> 00:06:58,700
aunque no tenga idea de dónde estaba.

120
00:06:58,700 --> 00:07:02,023
En la jerga, si un grupo de bits tiene un número

121
00:07:02,023 --> 00:07:04,940
par o impar de unos se conoce como paridad.

122
00:07:04,940 --> 00:07:07,780
También puedes usar números y decir que la paridad es 0 o 1,

123
00:07:07,780 --> 00:07:11,320
lo que suele ser más útil una vez que empiezas a hacer cálculos con la idea.

124
00:07:11,320 --> 00:07:14,846
Y este bit especial que utiliza el remitente para

125
00:07:14,846 --> 00:07:18,020
controlar la paridad se llama bit de paridad.

126
00:07:18,020 --> 00:07:21,562
Y, de hecho, debemos ser claros: si el receptor ve una paridad impar,

127
00:07:21,562 --> 00:07:25,713
no significa necesariamente que hubo solo un error, puede haber habido 3 errores,

128
00:07:25,713 --> 00:07:29,560
o 5, o cualquier otro número impar, pero pueden estar seguros. que no era 0.

129
00:07:29,560 --> 00:07:33,689
Por otro lado, si hubiera habido 2 errores, o cualquier número par de errores,

130
00:07:33,689 --> 00:07:38,341
ese recuento final de 1 seguiría siendo par, por lo que el receptor no puede tener plena

131
00:07:38,341 --> 00:07:42,941
confianza en que un recuento par necesariamente signifique que el mensaje está libre de

132
00:07:42,941 --> 00:07:43,360
errores.

133
00:07:43,360 --> 00:07:46,692
Podrías quejarte de que un mensaje que se estropea con cambios

134
00:07:46,692 --> 00:07:49,760
de sólo 2 bits es bastante débil, y estarías en lo cierto.

135
00:07:49,760 --> 00:07:53,281
Sin embargo, tenga en cuenta que no existe ningún método de detección

136
00:07:53,281 --> 00:07:56,601
o corrección de errores que pueda brindarle un 100 % de confianza

137
00:07:56,601 --> 00:07:59,720
de que el mensaje que recibe es el que pretendía el remitente.

138
00:07:59,720 --> 00:08:02,820
Después de todo, suficiente ruido aleatorio siempre podría cambiar un

139
00:08:02,820 --> 00:08:05,920
mensaje válido en otro mensaje válido simplemente por pura casualidad.

140
00:08:05,920 --> 00:08:11,104
En cambio, el objetivo es idear un esquema que sea sólido hasta un cierto número

141
00:08:11,104 --> 00:08:16,480
máximo de errores, o tal vez reducir la probabilidad de un falso positivo como este.

142
00:08:16,480 --> 00:08:19,636
Los controles de paridad por sí solos son bastante débiles,

143
00:08:19,636 --> 00:08:23,633
pero al resumir la idea de cambio en un mensaje completo hasta un solo bit,

144
00:08:23,633 --> 00:08:28,000
lo que nos brindan es un poderoso componente básico para esquemas más sofisticados.

145
00:08:28,000 --> 00:08:32,493
Por ejemplo, mientras Hamming buscaba una manera de identificar dónde ocurrió un error,

146
00:08:32,493 --> 00:08:36,373
no solo que sucedió, su idea clave fue que si aplica algunas comprobaciones

147
00:08:36,373 --> 00:08:40,355
de paridad no al mensaje completo, sino a ciertos subconjuntos cuidadosamente

148
00:08:40,355 --> 00:08:43,980
seleccionados, puede preguntar una serie más refinada de preguntas que

149
00:08:43,980 --> 00:08:46,840
precisan la ubicación de cualquier error de un solo bit.

150
00:08:46,840 --> 00:08:50,271
La sensación general es un poco como jugar un juego de 20 preguntas,

151
00:08:50,271 --> 00:08:54,300
haciendo preguntas de sí o no que reducen el espacio de posibilidades a la mitad.

152
00:08:54,300 --> 00:08:58,820
Por ejemplo, digamos que hacemos una verificación de paridad solo en estos 8 bits,

153
00:08:58,820 --> 00:09:00,400
todas las posiciones impares.

154
00:09:00,400 --> 00:09:04,834
Luego, si se detecta un error, le da al receptor un poco más de información sobre

155
00:09:04,834 --> 00:09:09,160
dónde está específicamente el error, es decir, que está en una posición extraña.

156
00:09:09,160 --> 00:09:11,967
Si no se detecta ningún error entre esos 8 bits,

157
00:09:11,967 --> 00:09:16,036
significa que no hay ningún error o que se encuentra en algún lugar de

158
00:09:16,036 --> 00:09:17,240
las posiciones pares.

159
00:09:17,240 --> 00:09:21,381
Se podría pensar que limitar una verificación de paridad a la mitad de los

160
00:09:21,381 --> 00:09:25,799
bits la hace menos efectiva, pero cuando se hace junto con otras comprobaciones

161
00:09:25,799 --> 00:09:29,720
bien elegidas, contraintuitivamente nos brinda algo mucho más poderoso.

162
00:09:29,720 --> 00:09:32,881
Para configurar realmente esa verificación de paridad, recuerde,

163
00:09:32,881 --> 00:09:36,870
es necesario asignar algún bit especial que tenga control sobre la paridad de ese

164
00:09:36,870 --> 00:09:37,600
grupo completo.

165
00:09:37,600 --> 00:09:39,920
Aquí elijamos la posición 1.

166
00:09:39,920 --> 00:09:43,786
Para el ejemplo mostrado, la paridad de estos 8 bits es actualmente impar,

167
00:09:43,786 --> 00:09:48,220
por lo que el remitente es responsable de alternar ese bit de paridad, y ahora es par.

168
00:09:48,220 --> 00:09:51,040
Esta es sólo 1 de cada 4 comprobaciones de paridad que haremos.

169
00:09:51,040 --> 00:09:54,027
La segunda comprobación se encuentra entre los 8 bits de la mitad

170
00:09:54,027 --> 00:09:56,880
derecha de la cuadrícula, al menos como la hemos dibujado aquí.

171
00:09:56,880 --> 00:10:00,212
Esta vez podríamos usar la posición 2 como bit de paridad,

172
00:10:00,212 --> 00:10:03,093
por lo que estos 8 bits ya tienen una paridad par,

173
00:10:03,093 --> 00:10:07,160
y el remitente puede sentirse bien dejando ese bit número 2 sin cambios.

174
00:10:07,160 --> 00:10:11,610
Luego, en el otro extremo, si el receptor verifica la paridad de este grupo y encuentra

175
00:10:11,610 --> 00:10:15,960
que es impar, sabrá que el error está en algún lugar entre estos 8 bits de la derecha.

176
00:10:15,960 --> 00:10:18,583
De lo contrario, significa que no hay error o que

177
00:10:18,583 --> 00:10:21,260
el error está en algún lugar de la mitad izquierda.

178
00:10:21,260 --> 00:10:23,494
O supongo que podrían haber habido dos errores,

179
00:10:23,494 --> 00:10:27,080
pero por ahora vamos a asumir que hay como máximo un error en todo el bloque.

180
00:10:27,080 --> 00:10:29,160
Las cosas se estropean por completo por más que eso.

181
00:10:29,160 --> 00:10:31,386
Aquí, antes de ver las dos comprobaciones siguientes,

182
00:10:31,386 --> 00:10:34,601
tómate un momento para pensar en lo que estas dos primeras nos permiten hacer

183
00:10:34,601 --> 00:10:35,880
cuando las consideramos juntas.

184
00:10:35,880 --> 00:10:40,240
Digamos que detecta un error entre las columnas impares y entre la mitad derecha.

185
00:10:40,240 --> 00:10:43,940
Necesariamente significa que el error está en algún lugar de la última columna.

186
00:10:43,940 --> 00:10:48,065
Si no hubo ningún error en la columna impar pero hubo uno en la mitad derecha,

187
00:10:48,065 --> 00:10:50,520
eso le indica que está en la penúltima columna.

188
00:10:50,520 --> 00:10:54,240
Del mismo modo, si hay un error en las columnas impares pero no en la mitad derecha,

189
00:10:54,240 --> 00:10:56,560
sabrás que está en algún lugar de la segunda columna.

190
00:10:56,560 --> 00:10:59,522
Y si ninguna de esas dos comprobaciones de paridad detecta nada,

191
00:10:59,522 --> 00:11:03,076
significa que el único lugar donde podría haber un error es en la columna más

192
00:11:03,076 --> 00:11:03,760
a la izquierda.

193
00:11:03,760 --> 00:11:06,480
Pero también podría significar simplemente que no hay ningún error.

194
00:11:06,480 --> 00:11:09,020
Lo cual es una forma bastante elaborada de decir que

195
00:11:09,020 --> 00:11:11,800
dos controles de paridad nos permiten precisar la columna.

196
00:11:11,800 --> 00:11:14,000
A partir de aquí, probablemente puedas adivinar lo que sigue.

197
00:11:14,000 --> 00:11:16,240
Básicamente hacemos lo mismo pero para las filas.

198
00:11:16,240 --> 00:11:19,011
Habrá una verificación de paridad en las filas impares,

199
00:11:19,011 --> 00:11:21,040
usando la posición 4 como bit de paridad.

200
00:11:21,040 --> 00:11:24,335
Entonces, en este ejemplo, ese grupo ya tiene una paridad par,

201
00:11:24,335 --> 00:11:26,480
por lo que el bit 4 se establecería en 0.

202
00:11:26,480 --> 00:11:30,212
Y finalmente hay una verificación de paridad en las dos filas inferiores,

203
00:11:30,212 --> 00:11:32,280
usando la posición 8 como bit de paridad.

204
00:11:32,280 --> 00:11:35,192
En este caso, parece que el remitente necesita activar

205
00:11:35,192 --> 00:11:37,840
el bit 8 para darle al grupo una paridad uniforme.

206
00:11:37,840 --> 00:11:41,015
Así como las dos primeras comprobaciones nos permiten fijar la columna,

207
00:11:41,015 --> 00:11:43,000
las dos siguientes le permiten fijar la fila.

208
00:11:43,000 --> 00:11:47,050
Como ejemplo, imaginemos que durante la transmisión hay un error en,

209
00:11:47,050 --> 00:11:48,400
digamos, la posición 3.

210
00:11:48,400 --> 00:11:51,163
Bueno, esto afecta al primer grupo de paridad y también afecta

211
00:11:51,163 --> 00:11:53,839
al segundo grupo de paridad, por lo que el receptor sabe que

212
00:11:53,839 --> 00:11:56,340
hay un error en algún lugar de esa columna de la derecha.

213
00:11:56,340 --> 00:12:01,380
Pero no afecta al tercer grupo ni al cuarto grupo.

214
00:12:01,380 --> 00:12:04,870
Y eso permite al receptor identificar el error hasta la primera fila,

215
00:12:04,870 --> 00:12:08,660
lo que necesariamente significa la posición 3, para poder corregir el error.

216
00:12:08,660 --> 00:12:11,448
Quizás disfrutes tomándote un momento para convencerte de que las

217
00:12:11,448 --> 00:12:14,320
respuestas a estas cuatro preguntas realmente siempre te permitirán

218
00:12:14,320 --> 00:12:17,320
identificar una ubicación específica, sin importar dónde se encuentren.

219
00:12:17,320 --> 00:12:20,510
De hecho, los más astutos podrían incluso notar una

220
00:12:20,510 --> 00:12:23,640
conexión entre estas preguntas y el conteo binario.

221
00:12:23,640 --> 00:12:26,977
Y si lo haces, déjame enfatizar nuevamente, haz una pausa,

222
00:12:26,977 --> 00:12:30,880
intenta por ti mismo establecer la conexión antes de que la estropee.

223
00:12:30,880 --> 00:12:36,560
Si se pregunta qué sucede si un bit de paridad se ve afectado, puede intentarlo.

224
00:12:36,560 --> 00:12:41,899
Tómese un momento para pensar en cómo se localizará cualquier error entre estos

225
00:12:41,899 --> 00:12:47,440
cuatro bits especiales como cualquier otro, con el mismo grupo de cuatro preguntas.

226
00:12:47,440 --> 00:12:50,500
Realmente no importa, ya que al final del día lo que queremos es proteger los

227
00:12:50,500 --> 00:12:53,640
bits del mensaje, los bits de corrección de errores simplemente siguen adelante.

228
00:12:53,640 --> 00:12:56,908
Pero proteger también esos bits es algo que naturalmente

229
00:12:56,908 --> 00:12:59,260
queda fuera del esquema como subproducto.

230
00:12:59,260 --> 00:13:02,380
También puede disfrutar anticipando cómo evoluciona esto.

231
00:13:02,380 --> 00:13:06,190
Si usamos un bloque de tamaño 256 bits, por ejemplo,

232
00:13:06,190 --> 00:13:10,503
para determinar una ubicación, solo necesita ocho preguntas

233
00:13:10,503 --> 00:13:15,680
de sí o no para realizar una búsqueda binaria hasta un lugar específico.

234
00:13:15,680 --> 00:13:19,546
Y recuerde, cada pregunta requiere ceder solo un bit

235
00:13:19,546 --> 00:13:23,340
para establecer la verificación de paridad adecuada.

236
00:13:23,340 --> 00:13:25,344
Es posible que algunos de ustedes ya lo hayan visto,

237
00:13:25,344 --> 00:13:28,598
pero hablaremos más adelante sobre la forma sistemática de encontrar cuáles son estas

238
00:13:28,598 --> 00:13:29,960
preguntas en solo uno o dos minutos.

239
00:13:29,960 --> 00:13:32,245
Ojalá este boceto sea suficiente para apreciar la

240
00:13:32,245 --> 00:13:34,440
eficiencia de lo que aquí estamos desarrollando.

241
00:13:34,440 --> 00:13:37,614
Lo primero, excepto esos ocho bits de paridad resaltados,

242
00:13:37,614 --> 00:13:41,720
puede ser lo que quieras, transportando el mensaje o los datos que quieras.

243
00:13:41,720 --> 00:13:45,752
Los 8 bits son redundantes en el sentido de que están completamente

244
00:13:45,752 --> 00:13:49,725
determinados por el resto del mensaje, pero es de una manera mucho

245
00:13:49,725 --> 00:13:53,640
más inteligente que simplemente copiar el mensaje en su totalidad.

246
00:13:53,640 --> 00:13:56,216
Y aún así, por tan poco dinero entregado, podrías

247
00:13:56,216 --> 00:13:59,000
identificar y corregir cualquier error de un solo bit.

248
00:13:59,000 --> 00:14:00,400
Bueno, casi.

249
00:14:00,400 --> 00:14:04,926
Bien, entonces el único problema aquí es que si ninguna de las cuatro comprobaciones

250
00:14:04,926 --> 00:14:09,026
de paridad detecta un error, lo que significa que los subconjuntos de 8 bits

251
00:14:09,026 --> 00:14:13,712
especialmente seleccionados tienen paridades pares, tal como lo pretendía el remitente,

252
00:14:13,712 --> 00:14:17,760
entonces significa que no hubo ningún error. , o nos reduce a la posición 0.

253
00:14:17,760 --> 00:14:21,639
Verá, con cuatro preguntas de sí o no, tenemos 16 resultados posibles

254
00:14:21,639 --> 00:14:24,798
para nuestras comprobaciones de paridad y, al principio,

255
00:14:24,798 --> 00:14:28,677
eso parece perfecto para identificar 1 de 16 posiciones en el bloque,

256
00:14:28,677 --> 00:14:33,000
pero también debe comunicar un resultado número 17, el de no error. condición.

257
00:14:33,000 --> 00:14:37,860
La solución aquí es bastante simple, simplemente olvídate por completo del bit 0.

258
00:14:37,860 --> 00:14:41,090
Entonces, cuando hacemos nuestras cuatro comprobaciones de paridad y vemos

259
00:14:41,090 --> 00:14:44,320
que todas están iguales, significa inequívocamente que no hay ningún error.

260
00:14:44,320 --> 00:14:47,740
Lo que eso significa es que en lugar de trabajar con un bloque de 16 bits,

261
00:14:47,740 --> 00:14:50,978
trabajamos con un bloque de 15 bits, donde 11 de los bits están libres

262
00:14:50,978 --> 00:14:54,080
para transportar un mensaje y 4 de ellos están ahí para redundancia.

263
00:14:54,080 --> 00:14:59,400
Y con eso, ahora tenemos lo que la gente en el negocio llamaría un código Hamming 15-11.

264
00:14:59,400 --> 00:15:03,528
Dicho esto, es bueno tener un tamaño de bloque que sea una potencia limpia de 2,

265
00:15:03,528 --> 00:15:06,688
y hay una forma inteligente de mantener ese bit 0 y hacer que

266
00:15:06,688 --> 00:15:08,880
haga un poco de trabajo extra por nosotros.

267
00:15:08,880 --> 00:15:12,104
Si lo usamos como bit de paridad en todo el bloque,

268
00:15:12,104 --> 00:15:16,320
nos permite detectar, aunque no podamos corregir, errores de 2 bits.

269
00:15:16,320 --> 00:15:17,440
Así es como funciona.

270
00:15:17,440 --> 00:15:20,749
Después de configurar esos cuatro bits especiales de corrección de errores,

271
00:15:20,749 --> 00:15:23,667
configuramos el 0 para que la paridad del bloque completo sea par,

272
00:15:23,667 --> 00:15:25,540
como en una verificación de paridad normal.

273
00:15:25,540 --> 00:15:28,296
Ahora, si hay un error de un solo bit, entonces la paridad del

274
00:15:28,296 --> 00:15:31,008
bloque completo cambia a impar, pero lo detectaremos de todos

275
00:15:31,008 --> 00:15:33,940
modos gracias a las cuatro comprobaciones de corrección de errores.

276
00:15:33,940 --> 00:15:38,530
Sin embargo, si hay dos errores, entonces la paridad general volverá a ser uniforme,

277
00:15:38,530 --> 00:15:42,472
pero el receptor aún verá que ha habido al menos algún error debido a lo

278
00:15:42,472 --> 00:15:45,820
que está sucediendo con esas cuatro comprobaciones de paridad.

279
00:15:45,820 --> 00:15:48,191
Entonces, si notan una paridad uniforme en general,

280
00:15:48,191 --> 00:15:51,110
pero sucede algo distinto de cero con las otras comprobaciones,

281
00:15:51,110 --> 00:15:52,980
les indica que hubo al menos dos errores.

282
00:15:52,980 --> 00:15:54,420
¿No es eso inteligente?

283
00:15:54,420 --> 00:15:57,346
Aunque no podemos corregir esos errores de 2 bits,

284
00:15:57,346 --> 00:16:02,340
simplemente volviendo a funcionar ese pequeño y molesto bit 0, nos permite detectarlos.

285
00:16:02,340 --> 00:16:06,540
Esto es bastante estándar, se conoce como código Hamming extendido.

286
00:16:06,540 --> 00:16:10,011
Técnicamente hablando, ahora tienes una descripción completa de lo que

287
00:16:10,011 --> 00:16:13,580
hace un código Hamming, al menos para el ejemplo de un bloque de 16 bits.

288
00:16:13,580 --> 00:16:17,830
Pero creo que le resultará más satisfactorio comprobar su comprensión y solidificar

289
00:16:17,830 --> 00:16:21,980
todo hasta este punto haciendo usted mismo un ejemplo completo de principio a fin.

290
00:16:21,980 --> 00:16:25,100
Lo revisaré contigo para que puedas comprobarlo tú mismo.

291
00:16:25,100 --> 00:16:28,441
Para configurar un mensaje, ya sea un mensaje literal que estás

292
00:16:28,441 --> 00:16:32,932
traduciendo en el espacio o algunos datos que deseas almacenar a lo largo del tiempo,

293
00:16:32,932 --> 00:16:35,700
el primer paso es dividirlo en fragmentos de 11 bits.

294
00:16:35,700 --> 00:16:40,340
Cada fragmento se empaquetará en un bloque de 16 bits resistente a errores.

295
00:16:40,340 --> 00:16:43,740
Así que tomemos este como ejemplo y resolvámoslo.

296
00:16:43,740 --> 00:16:45,380
¡Adelante, hazlo de verdad!

297
00:16:45,380 --> 00:16:52,980
Hagamos una pausa e intentemos armar este bloque.

298
00:16:52,980 --> 00:16:53,980
Bien, ¿estás listo?

299
00:16:53,980 --> 00:16:57,642
Recuerde, la posición 0 junto con las otras potencias de 2 están

300
00:16:57,642 --> 00:17:00,516
reservadas para la tarea de corrección de errores,

301
00:17:00,516 --> 00:17:05,192
por lo que comienza colocando los bits del mensaje en todos los lugares restantes,

302
00:17:05,192 --> 00:17:05,700
en orden.

303
00:17:05,700 --> 00:17:09,073
Necesita que este grupo tenga una paridad uniforme, lo cual ya la tiene,

304
00:17:09,073 --> 00:17:13,140
por lo que debería haber configurado ese bit de paridad en la posición 1 para que sea 0.

305
00:17:13,140 --> 00:17:15,951
El siguiente grupo comienza con una paridad impar,

306
00:17:15,951 --> 00:17:19,260
por lo que debería haber establecido su bit de paridad en 1.

307
00:17:19,260 --> 00:17:21,550
El grupo posterior comienza con una paridad impar,

308
00:17:21,550 --> 00:17:24,740
por lo que nuevamente debería haber establecido su bit de paridad en 1.

309
00:17:24,740 --> 00:17:27,465
Y el grupo final también tiene una paridad impar,

310
00:17:27,465 --> 00:17:31,500
lo que significa que configuramos ese bit en la posición 8 para que sea 1.

311
00:17:31,500 --> 00:17:36,067
Y luego, como paso final, el bloque completo ahora tiene una paridad par,

312
00:17:36,067 --> 00:17:41,500
lo que significa que puede establecer ese bit número 0, el bit de paridad general, en 0.

313
00:17:41,500 --> 00:17:45,267
Entonces, cuando este bloque sea expulsado, la paridad de los cuatro

314
00:17:45,267 --> 00:17:48,980
subconjuntos especiales y el bloque en su conjunto serán pares, o 0.

315
00:17:48,980 --> 00:17:53,620
Como segunda parte del ejercicio, hagamos que usted desempeñe el papel de receptor.

316
00:17:53,620 --> 00:17:56,786
Por supuesto, eso significaría que aún no saben cuál es este mensaje,

317
00:17:56,786 --> 00:18:00,180
tal vez algunos de ustedes lo memorizaron, pero supongamos que no lo saben.

318
00:18:00,180 --> 00:18:04,331
Lo que voy a hacer es cambiar 0, 1 o 2 de los bits de ese

319
00:18:04,331 --> 00:18:08,340
bloque y luego pedirte que averigües qué es lo que hice.

320
00:18:08,340 --> 00:18:13,460
Así que nuevamente, haz una pausa e intenta resolverlo.

321
00:18:13,460 --> 00:18:21,397
Bien, ahora usted, como receptor, verifica el primer grupo de paridad y puede ver

322
00:18:21,397 --> 00:18:29,820
que es par, por lo que cualquier error que exista tendría que estar en una columna par.

323
00:18:29,820 --> 00:18:33,180
La siguiente verificación nos da un número impar,

324
00:18:33,180 --> 00:18:38,760
lo que nos indica que hay al menos un error y nos limita a esta columna específica.

325
00:18:38,760 --> 00:18:42,900
El tercer control es parejo, lo que reduce aún más las posibilidades.

326
00:18:42,900 --> 00:18:47,350
Y la última verificación de paridad es impar, lo que nos dice que hay un error en algún

327
00:18:47,350 --> 00:18:51,700
lugar en la parte inferior, que ahora podemos ver debe estar en la posición número 10.

328
00:18:51,700 --> 00:18:54,563
Es más, la paridad de todo el bloque es impar,

329
00:18:54,563 --> 00:18:58,220
lo que nos da confianza de que hubo un lanzamiento y no dos.

330
00:18:58,220 --> 00:19:01,600
Si son tres o más, todas las apuestas están canceladas.

331
00:19:01,600 --> 00:19:06,622
Después de corregir el bit número 10, extraer los 11 bits que no se utilizaron

332
00:19:06,622 --> 00:19:11,073
para la corrección nos da el segmento relevante del mensaje original,

333
00:19:11,073 --> 00:19:16,160
que si rebobinamos y comparamos es exactamente con lo que comenzamos el ejemplo.

334
00:19:16,160 --> 00:19:18,336
Y ahora que sabes cómo hacer todo esto a mano,

335
00:19:18,336 --> 00:19:22,272
me gustaría mostrarte cómo puedes llevar a cabo la parte central de toda esta lógica

336
00:19:22,272 --> 00:19:23,940
con una sola línea de código Python.

337
00:19:23,940 --> 00:19:28,033
Verá, lo que aún no le he dicho es cuán elegante es realmente este algoritmo,

338
00:19:28,033 --> 00:19:31,760
cuán simple es hacer que una máquina apunte a la posición de un error,

339
00:19:31,760 --> 00:19:35,013
cómo escalarlo sistemáticamente y cómo podemos enmarcar todo.

340
00:19:35,013 --> 00:19:39,580
esto como una sola operación en lugar de múltiples comprobaciones de paridad separadas.

341
00:19:39,580 --> 00:19:39,580
Para ver a qué me refiero, únete a mí en la parte 2.

