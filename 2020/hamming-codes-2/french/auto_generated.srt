1
00:00:00,000 --> 00:00:05,668
Vous êtes-vous déjà demandé comment il était possible de gratter

2
00:00:05,668 --> 00:00:10,900
un CD ou un DVD tout en continuant à lire ce qu'il contient?

3
00:00:10,900 --> 00:00:14,353
La rayure affecte réellement les 1 et les 0 sur le disque,

4
00:00:14,353 --> 00:00:18,333
donc il lit des données différentes de celles qui ont été stockées,

5
00:00:18,333 --> 00:00:22,664
mais à moins qu'il ne soit vraiment rayé, les bits qu'il lit sont décodés

6
00:00:22,664 --> 00:00:26,878
exactement dans le même fichier qui y a été codé, un copie bit par bit,

7
00:00:26,878 --> 00:00:28,400
malgré toutes ces erreurs.

8
00:00:28,400 --> 00:00:32,842
Il existe tout un tas d’intelligence mathématique qui nous permet de stocker des données,

9
00:00:32,842 --> 00:00:36,840
et tout aussi important de les transmettre, d’une manière résiliente aux erreurs.

10
00:00:36,840 --> 00:00:39,743
Eh bien, d'accord, en fait, il ne faut pas beaucoup

11
00:00:39,743 --> 00:00:42,480
d'intelligence pour trouver un moyen de procéder.

12
00:00:42,480 --> 00:00:46,833
Tout fichier, qu'il s'agisse d'une vidéo, d'un son ou d'un texte, d'un code,

13
00:00:46,833 --> 00:00:50,960
d'une image, peu importe, est en fin de compte une séquence de 1 et de 0.

14
00:00:50,960 --> 00:00:54,133
Et une stratégie simple pour corriger tout bit

15
00:00:54,133 --> 00:00:57,780
retourné serait de stocker trois copies de chaque bit.

16
00:00:57,780 --> 00:01:02,502
Ensuite, la machine lisant ce fichier pourrait comparer ces trois

17
00:01:02,502 --> 00:01:07,440
copies et toujours prendre la meilleure 2 sur 3 en cas de divergence.

18
00:01:07,440 --> 00:01:11,560
Mais cela signifie que vous utilisez les deux tiers de votre espace pour la redondance.

19
00:01:11,560 --> 00:01:14,100
Et même dans ce cas, malgré tout cet espace abandonné,

20
00:01:14,100 --> 00:01:18,120
il n'y a aucune garantie solide quant à ce qui se passera si plus d'un bit est inversé.

21
00:01:18,120 --> 00:01:21,474
La question bien plus intéressante est de savoir comment faire en sorte que

22
00:01:21,474 --> 00:01:24,740
les erreurs puissent être corrigées en perdant le moins de place possible.

23
00:01:24,740 --> 00:01:28,400
Par exemple, en utilisant la méthode que vous découvrirez dans cette vidéo,

24
00:01:28,400 --> 00:01:31,386
vous pourriez stocker vos données dans des blocs de 256 bits,

25
00:01:31,386 --> 00:01:32,975
où chaque bloc utilise 9 bits, 9!

26
00:01:32,975 --> 00:01:37,041
pour agir comme une sorte de redondance, et les 247 autres bits sont libres

27
00:01:37,041 --> 00:01:41,000
de transporter le message ou les données significatifs que vous souhaitez.

28
00:01:41,000 --> 00:01:43,905
Et il sera toujours vrai que si un bit est inversé ici,

29
00:01:43,905 --> 00:01:48,263
rien qu'en regardant ce bloc et rien de plus, une machine sera capable d'identifier

30
00:01:48,263 --> 00:01:52,102
qu'il y a eu une erreur et précisément où elle se trouvait afin de savoir

31
00:01:52,102 --> 00:01:53,140
comment la corriger.

32
00:01:53,140 --> 00:01:55,540
Et honnêtement, cela semble magique.

33
00:01:55,540 --> 00:01:58,072
Et pour ce schéma particulier, si deux bits sont inversés,

34
00:01:58,072 --> 00:02:01,162
la machine sera au moins capable de détecter qu'il y a eu deux erreurs,

35
00:02:01,162 --> 00:02:03,180
même si elle ne saura pas comment les corriger.

36
00:02:03,180 --> 00:02:05,709
Nous parlerons un peu plus tard de la manière dont

37
00:02:05,709 --> 00:02:08,140
cela s'adapte à des blocs de différentes tailles.

38
00:02:08,140 --> 00:02:11,366
Les méthodes qui vous permettent de corriger de telles erreurs sont connues,

39
00:02:11,366 --> 00:02:13,880
à juste titre, sous le nom de codes de correction d'erreurs.

40
00:02:13,880 --> 00:02:16,794
Pendant la majeure partie du siècle dernier, ce domaine a été

41
00:02:16,794 --> 00:02:19,803
une source très riche de mathématiques étonnamment approfondies

42
00:02:19,803 --> 00:02:23,000
qui sont intégrées aux appareils que nous utilisons quotidiennement.

43
00:02:23,000 --> 00:02:26,354
L’objectif ici est de vous donner une compréhension très approfondie

44
00:02:26,354 --> 00:02:29,660
de l’un des premiers exemples, connu sous le nom de code de Hamming.

45
00:02:29,660 --> 00:02:33,024
Et d'ailleurs, la façon dont je réfléchis à la structure de cette vidéo

46
00:02:33,024 --> 00:02:35,874
consiste moins à l'expliquer aussi directement que possible,

47
00:02:35,874 --> 00:02:38,444
mais plutôt à vous inciter à l'inventer par vous-même,

48
00:02:38,444 --> 00:02:40,220
avec quelques conseils doux ici et là.

49
00:02:40,220 --> 00:02:42,972
Alors, quand vous sentez que vous voyez où cela va à un moment donné,

50
00:02:42,972 --> 00:02:46,393
prenez ce moment pour faire une pause, prédisez activement ce que sera le projet avant

51
00:02:46,393 --> 00:02:47,180
que je vous le dise.

52
00:02:47,180 --> 00:02:50,976
De plus, si vous souhaitez que votre compréhension descende au niveau matériel,

53
00:02:50,976 --> 00:02:54,821
Ben Eater a réalisé une vidéo en conjonction avec celle-ci vous montrant comment

54
00:02:54,821 --> 00:02:57,811
implémenter réellement les codes de Hamming sur des maquettes,

55
00:02:57,811 --> 00:02:59,520
ce qui est extrêmement satisfaisant.

56
00:02:59,520 --> 00:03:03,091
Vous devriez le savoir, les codes de Hamming ne sont pas aussi largement utilisés

57
00:03:03,091 --> 00:03:05,921
que les codes plus modernes, comme l'algorithme de Reed-Solomon,

58
00:03:05,921 --> 00:03:09,667
mais il y a une certaine magie dans le contraste entre le fait que cette tâche semble

59
00:03:09,667 --> 00:03:13,238
impossible au début et à quel point elle semble tout à fait raisonnable une fois.

60
00:03:13,238 --> 00:03:14,240
vous découvrez Hamming.

61
00:03:14,240 --> 00:03:18,449
Le principe de base de la correction d’erreurs est que dans un vaste espace de tous

62
00:03:18,449 --> 00:03:22,860
les messages possibles, seul un sous-ensemble sera considéré comme des messages valides.

63
00:03:22,860 --> 00:03:29,100
Par analogie, pensez aux mots correctement orthographiés et aux mots mal orthographiés.

64
00:03:29,100 --> 00:03:32,112
Chaque fois qu'un message valide est modifié, le destinataire

65
00:03:32,112 --> 00:03:35,756
est responsable de corriger ce qu'il voit au voisin valide le plus proche,

66
00:03:35,756 --> 00:03:38,380
comme vous pourriez le faire avec une faute de frappe.

67
00:03:38,380 --> 00:03:43,102
Cependant, trouver un algorithme concret pour catégoriser efficacement

68
00:03:43,102 --> 00:03:47,160
des messages comme celui-ci demande une certaine ingéniosité.

69
00:03:47,160 --> 00:03:50,716
L'histoire commence dans les années 1940, lorsque le jeune Richard Hamming travaillait

70
00:03:50,716 --> 00:03:54,027
pour les Bell Labs et qu'une partie de son travail impliquait l'utilisation d'un

71
00:03:54,027 --> 00:03:57,420
très gros ordinateur à carte perforée coûteux auquel il n'avait qu'un accès limité.

72
00:03:57,420 --> 00:04:00,153
Et les programmes qu’il continuait à mettre en place échouaient,

73
00:04:00,153 --> 00:04:03,140
parce que de temps en temps, certains éléments étaient mal interprétés.

74
00:04:03,140 --> 00:04:05,339
La frustration étant le creuset de l'invention,

75
00:04:05,339 --> 00:04:09,280
il en eut tellement marre qu'il inventa le premier code correcteur d'erreurs au monde.

76
00:04:09,280 --> 00:04:12,368
Il existe de nombreuses façons différentes de formuler les codes de Hamming,

77
00:04:12,368 --> 00:04:14,774
mais dans un premier temps, nous allons les parcourir de la

78
00:04:14,774 --> 00:04:16,620
manière dont Hamming lui-même les considérait.

79
00:04:16,620 --> 00:04:21,400
Prenons un exemple simple, mais pas trop simple, un bloc de 16 bits.

80
00:04:21,400 --> 00:04:25,700
Nous numéroterons les positions de ces bits de 0 à 15.

81
00:04:25,700 --> 00:04:30,150
Les données réelles que nous souhaitons stocker ne constitueront que 12 de ces bits,

82
00:04:30,150 --> 00:04:33,920
tandis que 4 des positions sont réservées comme une sorte de redondance.

83
00:04:33,920 --> 00:04:36,748
Le mot redondant ici ne signifie pas simplement copier, après tout,

84
00:04:36,748 --> 00:04:40,200
ces 4 bits ne nous laissent pas assez de place pour copier aveuglément les données.

85
00:04:40,200 --> 00:04:44,494
Au lieu de cela, ils devront constituer une sorte de redondance beaucoup plus nuancée et

86
00:04:44,494 --> 00:04:48,740
intelligente, sans ajouter de nouvelles informations, mais en ajoutant de la résilience.

87
00:04:48,740 --> 00:04:52,379
Vous pourriez vous attendre à ce que ces 4 bits spéciaux soient bien emballés ensemble,

88
00:04:52,379 --> 00:04:55,398
peut-être à la fin ou quelque chose comme ça, mais comme vous le verrez,

89
00:04:55,398 --> 00:04:58,128
les placer dans des positions qui sont des puissances de 2 permet

90
00:04:58,128 --> 00:05:00,320
d'obtenir quelque chose de vraiment élégant à la fin.

91
00:05:00,320 --> 00:05:02,916
Cela pourrait également vous donner un petit indice sur

92
00:05:02,916 --> 00:05:05,420
la manière dont cela s'adapte à des blocs plus grands.

93
00:05:05,420 --> 00:05:08,420
De plus, techniquement, il ne s'agit que de 11 bits de données,

94
00:05:08,420 --> 00:05:12,311
vous constaterez qu'il y a une légère nuance pour ce qui se passe à la position 0,

95
00:05:12,311 --> 00:05:14,280
mais ne vous inquiétez pas pour l'instant.

96
00:05:14,280 --> 00:05:18,667
Comme tout algorithme de correction d'erreurs, celui-ci impliquera deux joueurs,

97
00:05:18,667 --> 00:05:22,730
un expéditeur chargé de définir ces 4 bits spéciaux et un récepteur chargé

98
00:05:22,730 --> 00:05:26,360
d'effectuer une sorte de vérification et de correction des erreurs.

99
00:05:26,360 --> 00:05:29,439
Bien sûr, les mots expéditeur et destinataire font en réalité référence à des

100
00:05:29,439 --> 00:05:32,163
machines ou à des logiciels qui effectuent toutes les vérifications,

101
00:05:32,163 --> 00:05:35,480
et la notion de message est très large, pour inclure des éléments comme le stockage.

102
00:05:35,480 --> 00:05:38,839
Après tout, stocker des données revient à envoyer un message

103
00:05:38,839 --> 00:05:42,640
uniquement du passé vers le futur plutôt que d’un endroit à un autre.

104
00:05:42,640 --> 00:05:46,216
Voilà donc la configuration, mais avant de pouvoir plonger dans le vif du sujet,

105
00:05:46,216 --> 00:05:49,925
nous devons parler d'une idée connexe qui était fraîche dans l'esprit de Hamming au

106
00:05:49,925 --> 00:05:53,635
moment de sa découverte, une méthode qui vous permet de détecter des erreurs sur un

107
00:05:53,635 --> 00:05:57,300
seul bit, mais pas de les corriger, connu dans l'entreprise comme chèque de parité.

108
00:05:57,300 --> 00:06:01,094
Pour un contrôle de parité, nous séparons un seul bit que l'expéditeur est

109
00:06:01,094 --> 00:06:04,940
responsable du réglage, et les autres sont libres de transporter un message.

110
00:06:04,940 --> 00:06:08,454
La seule tâche de ce bit spécial est de s'assurer que

111
00:06:08,454 --> 00:06:12,100
le nombre total de 1 dans le message est un nombre pair.

112
00:06:12,100 --> 00:06:15,575
Ainsi, par exemple, à l'heure actuelle, ce nombre total de 1 est de 7,

113
00:06:15,575 --> 00:06:19,638
c'est impair, donc l'expéditeur doit inverser ce bit spécial pour qu'il soit un 1,

114
00:06:19,638 --> 00:06:20,960
ce qui rend le compte pair.

115
00:06:20,960 --> 00:06:24,737
Mais si le bloc avait déjà commencé avec un nombre pair de 1,

116
00:06:24,737 --> 00:06:27,480
alors ce bit spécial aurait été maintenu à 0.

117
00:06:27,480 --> 00:06:29,829
C'est assez simple, d'une simplicité trompeuse,

118
00:06:29,829 --> 00:06:33,256
mais c'est une manière incroyablement élégante de distiller l'idée de

119
00:06:33,256 --> 00:06:36,683
changement n'importe où dans un message pour la refléter dans un seul

120
00:06:36,683 --> 00:06:37,760
élément d'information.

121
00:06:37,760 --> 00:06:42,989
Remarquez que si un bit de ce message est inversé, soit de 0 à 1,

122
00:06:42,989 --> 00:06:48,140
soit de 1 à 0, cela change le nombre total de 1 de pair à impair.

123
00:06:48,140 --> 00:06:51,596
Donc, si vous êtes le destinataire, que vous regardez ce message et que

124
00:06:51,596 --> 00:06:55,676
vous voyez un nombre impair de 1, vous pouvez être sûr qu'une erreur s'est produite,

125
00:06:55,676 --> 00:06:58,700
même si vous n'avez aucune idée de l'endroit où elle se trouve.

126
00:06:58,700 --> 00:07:01,757
Dans le jargon, le fait qu'un groupe de bits ait

127
00:07:01,757 --> 00:07:04,940
un nombre pair ou impair de 1 est appelé sa parité.

128
00:07:04,940 --> 00:07:07,759
Vous pouvez également utiliser des nombres et dire que la parité est de 0 ou 1,

129
00:07:07,759 --> 00:07:09,980
ce qui est généralement plus utile une fois que vous commencez

130
00:07:09,980 --> 00:07:11,320
à faire des mathématiques avec l'idée.

131
00:07:11,320 --> 00:07:14,778
Et ce bit spécial que l’expéditeur utilise pour

132
00:07:14,778 --> 00:07:18,020
contrôler la parité est appelé bit de parité.

133
00:07:18,020 --> 00:07:21,197
Et en fait, soyons clairs, si le récepteur voit une parité impaire,

134
00:07:21,197 --> 00:07:24,327
cela ne signifie pas nécessairement qu'il y a eu une seule erreur,

135
00:07:24,327 --> 00:07:28,532
il peut y avoir eu 3 erreurs, ou 5, ou tout autre nombre impair, mais il peut en être sûr.

136
00:07:28,532 --> 00:07:29,560
que ce n'était pas 0.

137
00:07:29,560 --> 00:07:33,655
D'un autre côté, s'il y avait eu 2 erreurs, ou un nombre pair d'erreurs,

138
00:07:33,655 --> 00:07:38,311
ce décompte final de 1 serait toujours pair, donc le destinataire ne peut pas être

139
00:07:38,311 --> 00:07:43,360
pleinement sûr qu'un décompte pair signifie nécessairement que le message est sans erreur.

140
00:07:43,360 --> 00:07:46,336
Vous pourriez vous plaindre qu'un message qui est gâché par

141
00:07:46,336 --> 00:07:49,760
seulement 2 bits est assez faible, et vous auriez tout à fait raison.

142
00:07:49,760 --> 00:07:53,127
Gardez toutefois à l’esprit qu’il n’existe aucune méthode de détection

143
00:07:53,127 --> 00:07:56,352
ou de correction des erreurs qui puisse vous donner une certitude à

144
00:07:56,352 --> 00:07:59,720
100 % que le message que vous recevez est celui prévu par l’expéditeur.

145
00:07:59,720 --> 00:08:02,567
Après tout, suffisamment de bruit aléatoire pourrait toujours

146
00:08:02,567 --> 00:08:05,920
transformer un message valide en un autre message valide, par pur hasard.

147
00:08:05,920 --> 00:08:11,141
Au lieu de cela, l’objectif est de proposer un système robuste jusqu’à un certain nombre

148
00:08:11,141 --> 00:08:15,952
maximum d’erreurs, ou peut-être de réduire la probabilité d’un faux positif comme

149
00:08:15,952 --> 00:08:16,480
celui-ci.

150
00:08:16,480 --> 00:08:19,274
Les contrôles de parité en eux-mêmes sont assez faibles,

151
00:08:19,274 --> 00:08:23,048
mais en distillant l'idée de changement à travers un message complet jusqu'à

152
00:08:23,048 --> 00:08:26,725
un seul élément, ils nous fournissent un élément de base puissant pour des

153
00:08:26,725 --> 00:08:28,000
schémas plus sophistiqués.

154
00:08:28,000 --> 00:08:31,750
Par exemple, alors que Hamming cherchait un moyen d'identifier l'endroit où une erreur

155
00:08:31,750 --> 00:08:34,553
s'est produite, et pas seulement le fait qu'elle s'est produite,

156
00:08:34,553 --> 00:08:38,174
son idée clé était que si vous appliquez des contrôles de parité non pas au message

157
00:08:38,174 --> 00:08:41,106
complet, mais à certains sous-ensembles soigneusement sélectionnés,

158
00:08:41,106 --> 00:08:44,856
vous pouvez demander une série de questions plus raffinées qui permettent de localiser

159
00:08:44,856 --> 00:08:46,840
l'emplacement de toute erreur sur un seul bit.

160
00:08:46,840 --> 00:08:50,187
Le sentiment général est un peu comme jouer à un jeu de 20 questions,

161
00:08:50,187 --> 00:08:54,300
poser des requêtes par oui ou par non qui divisent par deux l’espace des possibilités.

162
00:08:54,300 --> 00:08:58,862
Par exemple, disons que nous effectuons un contrôle de parité uniquement sur ces 8 bits,

163
00:08:58,862 --> 00:09:00,400
toutes les positions impaires.

164
00:09:00,400 --> 00:09:03,288
Ensuite, si une erreur est détectée, cela donne au récepteur

165
00:09:03,288 --> 00:09:06,650
un peu plus d'informations sur l'endroit précis où se trouve l'erreur,

166
00:09:06,650 --> 00:09:09,160
à savoir qu'elle se trouve dans une position étrange.

167
00:09:09,160 --> 00:09:11,733
Si aucune erreur n'est détectée parmi ces 8 bits,

168
00:09:11,733 --> 00:09:15,644
cela signifie soit qu'il n'y a aucune erreur, soit qu'elle se situe quelque

169
00:09:15,644 --> 00:09:17,240
part dans les positions paires.

170
00:09:17,240 --> 00:09:21,303
Vous pourriez penser que limiter un contrôle de parité à la moitié des bits le rend

171
00:09:21,303 --> 00:09:25,560
moins efficace, mais lorsqu'il est effectué en conjonction avec d'autres contrôles bien

172
00:09:25,560 --> 00:09:29,720
choisis, cela nous donne contre-intuitivement quelque chose de beaucoup plus puissant.

173
00:09:29,720 --> 00:09:32,475
Pour configurer réellement ce contrôle de parité,

174
00:09:32,475 --> 00:09:36,442
n'oubliez pas qu'il faut réserver un bit spécial qui contrôle la parité

175
00:09:36,442 --> 00:09:37,600
de ce groupe complet.

176
00:09:37,600 --> 00:09:39,920
Ici, choisissons simplement la position 1.

177
00:09:39,920 --> 00:09:43,560
Pour l'exemple présenté, la parité de ces 8 bits est actuellement impaire,

178
00:09:43,560 --> 00:09:46,958
donc l'expéditeur est responsable du basculement de ce bit de parité,

179
00:09:46,958 --> 00:09:48,220
et maintenant il est pair.

180
00:09:48,220 --> 00:09:51,040
Il ne s'agit que d'un contrôle de parité sur quatre que nous effectuerons.

181
00:09:51,040 --> 00:09:54,873
La deuxième vérification se situe parmi les 8 bits sur la moitié droite de la grille,

182
00:09:54,873 --> 00:09:56,880
du moins telle que nous l'avons dessinée ici.

183
00:09:56,880 --> 00:10:00,783
Cette fois, nous pourrions utiliser la position 2 comme bit de parité,

184
00:10:00,783 --> 00:10:04,301
donc ces 8 bits ont déjà une parité paire, et l'expéditeur peut

185
00:10:04,301 --> 00:10:07,160
se sentir bien en laissant ce bit numéro 2 inchangé.

186
00:10:07,160 --> 00:10:11,480
Puis à l'autre bout, si le récepteur vérifie la parité de ce groupe et trouve que

187
00:10:11,480 --> 00:10:15,960
c'est étrange, il saura que l'erreur se situe quelque part parmi ces 8 bits à droite.

188
00:10:15,960 --> 00:10:18,398
Sinon, cela signifie soit qu'il n'y a pas d'erreur,

189
00:10:18,398 --> 00:10:21,260
soit que l'erreur se situe quelque part sur la moitié gauche.

190
00:10:21,260 --> 00:10:24,273
Ou je suppose qu'il aurait pu y avoir deux erreurs, mais pour l'instant,

191
00:10:24,273 --> 00:10:27,080
nous allons supposer qu'il y a au plus une erreur dans tout le bloc.

192
00:10:27,080 --> 00:10:29,160
Les choses s'effondrent complètement pour plus que ça.

193
00:10:29,160 --> 00:10:31,152
Ici, avant d’examiner les deux contrôles suivants,

194
00:10:31,152 --> 00:10:34,434
prenez un moment pour réfléchir à ce que ces deux premiers nous permettent de faire

195
00:10:34,434 --> 00:10:35,880
lorsque vous les considérez ensemble.

196
00:10:35,880 --> 00:10:40,240
Disons que vous détectez une erreur parmi les colonnes impaires et parmi la moitié droite.

197
00:10:40,240 --> 00:10:43,940
Cela signifie nécessairement que l'erreur se situe quelque part dans la dernière colonne.

198
00:10:43,940 --> 00:10:47,208
S'il n'y a pas d'erreur dans la colonne impaire mais qu'il y en a une dans

199
00:10:47,208 --> 00:10:50,520
la moitié droite, cela vous indique que c'est dans l'avant-dernière colonne.

200
00:10:50,520 --> 00:10:53,949
De même, s'il y a une erreur dans les colonnes impaires mais pas dans la moitié droite,

201
00:10:53,949 --> 00:10:56,560
vous savez qu'elle se trouve quelque part dans la deuxième colonne.

202
00:10:56,560 --> 00:10:59,512
Et si aucun de ces deux contrôles de parité ne détecte quoi que ce soit,

203
00:10:59,512 --> 00:11:03,072
cela signifie que le seul endroit où une erreur pourrait se trouver est dans la colonne

204
00:11:03,072 --> 00:11:03,760
la plus à gauche.

205
00:11:03,760 --> 00:11:06,480
Mais cela peut aussi simplement signifier qu’il n’y a aucune erreur.

206
00:11:06,480 --> 00:11:09,116
Ce qui est une façon un peu compliquée de dire que deux

207
00:11:09,116 --> 00:11:11,800
contrôles de parité nous permettent de cerner la colonne.

208
00:11:11,800 --> 00:11:14,000
À partir de là, vous pouvez probablement deviner ce qui suit.

209
00:11:14,000 --> 00:11:16,240
Nous faisons essentiellement la même chose mais pour les lignes.

210
00:11:16,240 --> 00:11:18,870
Il y aura un contrôle de parité sur les lignes impaires,

211
00:11:18,870 --> 00:11:21,040
en utilisant la position 4 comme bit de parité.

212
00:11:21,040 --> 00:11:24,512
Ainsi, dans cet exemple, ce groupe a déjà une parité paire,

213
00:11:24,512 --> 00:11:26,480
donc le bit 4 serait défini sur 0.

214
00:11:26,480 --> 00:11:29,909
Et enfin, il y a un contrôle de parité sur les deux rangées du bas,

215
00:11:29,909 --> 00:11:32,280
en utilisant la position 8 comme bit de parité.

216
00:11:32,280 --> 00:11:35,139
Dans ce cas, il semble que l'expéditeur doive activer

217
00:11:35,139 --> 00:11:37,840
ce bit 8 afin de donner au groupe une parité égale.

218
00:11:37,840 --> 00:11:40,951
Tout comme les deux premières vérifications nous permettent de cerner la colonne,

219
00:11:40,951 --> 00:11:43,000
les deux suivantes vous permettent de cerner la ligne.

220
00:11:43,000 --> 00:11:46,078
À titre d'exemple, imaginez que lors de la transmission,

221
00:11:46,078 --> 00:11:48,400
il y ait une erreur, disons, en position 3.

222
00:11:48,400 --> 00:11:50,498
Eh bien, cela affecte le premier groupe de parité,

223
00:11:50,498 --> 00:11:52,801
et cela affecte également le deuxième groupe de parité,

224
00:11:52,801 --> 00:11:56,340
donc le récepteur sait qu'il y a une erreur quelque part dans cette colonne de droite.

225
00:11:56,340 --> 00:12:01,380
Mais cela n’affecte pas le troisième groupe, ni le quatrième groupe.

226
00:12:01,380 --> 00:12:04,950
Et cela permet au récepteur de localiser l'erreur jusqu'à la première ligne,

227
00:12:04,950 --> 00:12:08,660
ce qui signifie nécessairement la position 3, afin de pouvoir corriger l'erreur.

228
00:12:08,660 --> 00:12:11,456
Vous aimerez peut-être prendre un moment pour vous convaincre

229
00:12:11,456 --> 00:12:14,433
que les réponses à ces quatre questions vous permettront toujours

230
00:12:14,433 --> 00:12:17,320
de localiser un endroit spécifique, peu importe où il se trouve.

231
00:12:17,320 --> 00:12:20,690
En fait, les plus astucieux d’entre vous remarqueront peut-être

232
00:12:20,690 --> 00:12:23,640
même un lien entre ces questions et le comptage binaire.

233
00:12:23,640 --> 00:12:26,949
Et si c’est le cas, permettez-moi encore une fois de souligner,

234
00:12:26,949 --> 00:12:30,880
faites une pause, essayez par vous-même de faire le lien avant de le gâcher.

235
00:12:30,880 --> 00:12:34,901
Si vous vous demandez ce qui se passe si un bit de parité lui-même est affecté,

236
00:12:34,901 --> 00:12:36,560
vous pouvez simplement l'essayer.

237
00:12:36,560 --> 00:12:40,326
Prenez un moment pour réfléchir à la manière dont toute erreur

238
00:12:40,326 --> 00:12:45,048
parmi ces quatre éléments spéciaux sera détectée comme n'importe quelle autre,

239
00:12:45,048 --> 00:12:47,440
avec le même groupe de quatre questions.

240
00:12:47,440 --> 00:12:50,448
Cela n'a pas vraiment d'importance, puisqu'en fin de compte, ce que nous voulons,

241
00:12:50,448 --> 00:12:53,640
c'est protéger les bits de message, les bits de correction d'erreur ne font que suivre.

242
00:12:53,640 --> 00:12:56,287
Mais la protection de ces éléments est également quelque

243
00:12:56,287 --> 00:12:59,260
chose qui sort naturellement du schéma en tant que sous-produit.

244
00:12:59,260 --> 00:13:02,380
Vous pourriez également aimer anticiper l’évolution de cette situation.

245
00:13:02,380 --> 00:13:07,749
Si nous utilisons un bloc de 256 bits, par exemple, afin de localiser un emplacement,

246
00:13:07,749 --> 00:13:12,433
vous n'avez besoin que de huit questions par oui ou par non pour effectuer

247
00:13:12,433 --> 00:13:15,680
une recherche binaire jusqu'à un endroit spécifique.

248
00:13:15,680 --> 00:13:19,510
Et rappelez-vous que chaque question nécessite de renoncer

249
00:13:19,510 --> 00:13:23,340
à un seul bit pour définir le contrôle de parité approprié.

250
00:13:23,340 --> 00:13:25,135
Certains d'entre vous le voient peut-être déjà,

251
00:13:25,135 --> 00:13:28,389
mais nous parlerons plus tard de la manière systématique de découvrir quelles sont ces

252
00:13:28,389 --> 00:13:29,960
questions en seulement une minute ou deux.

253
00:13:29,960 --> 00:13:32,091
Espérons que cette esquisse soit suffisante pour

254
00:13:32,091 --> 00:13:34,440
apprécier l’efficacité de ce que nous développons ici.

255
00:13:34,440 --> 00:13:37,921
La première chose, à l'exception de ces huit bits de parité en surbrillance,

256
00:13:37,921 --> 00:13:41,720
peut être ce que vous voulez, transportant le message ou les données de votre choix.

257
00:13:41,720 --> 00:13:45,423
Les 8 bits sont redondants dans le sens où ils sont entièrement

258
00:13:45,423 --> 00:13:49,473
déterminés par le reste du message, mais c'est d'une manière beaucoup

259
00:13:49,473 --> 00:13:53,640
plus intelligente que de simplement copier le message dans son ensemble.

260
00:13:53,640 --> 00:13:56,107
Et pourtant, pour si peu d’abandon, vous seriez en mesure

261
00:13:56,107 --> 00:13:59,000
d’identifier et de corriger n’importe quelle erreur sur un seul bit.

262
00:13:59,000 --> 00:14:00,400
Enfin presque.

263
00:14:00,400 --> 00:14:04,611
D'accord, le seul problème ici est que si aucun des quatre contrôles de parité ne

264
00:14:04,611 --> 00:14:08,823
détecte une erreur, ce qui signifie que les sous-ensembles de 8 bits spécialement

265
00:14:08,823 --> 00:14:12,829
sélectionnés ont tous des parités paires, tout comme l'expéditeur le voulait,

266
00:14:12,829 --> 00:14:15,911
alors cela signifie qu'il n'y a eu aucune erreur du tout. ,

267
00:14:15,911 --> 00:14:17,760
ou cela nous réduit à la position 0.

268
00:14:17,760 --> 00:14:20,699
Vous voyez, avec quatre questions par oui ou par non,

269
00:14:20,699 --> 00:14:24,182
nous avons 16 résultats possibles pour nos contrôles de parité,

270
00:14:24,182 --> 00:14:28,536
et au début cela semble parfait pour identifier 1 position sur 16 dans le bloc,

271
00:14:28,536 --> 00:14:33,000
mais vous devez également communiquer un 17ème résultat, le non erreur. condition.

272
00:14:33,000 --> 00:14:37,860
La solution ici est en fait assez simple, oubliez complètement ce 0ème bit.

273
00:14:37,860 --> 00:14:41,228
Ainsi, lorsque nous effectuons nos quatre contrôles de parité et que nous constatons

274
00:14:41,228 --> 00:14:44,320
qu’ils sont tous égaux, cela signifie sans ambiguïté qu’il n’y a pas d’erreur.

275
00:14:44,320 --> 00:14:47,526
Cela signifie que plutôt que de travailler avec un bloc de 16 bits,

276
00:14:47,526 --> 00:14:50,779
nous travaillons avec un bloc de 15 bits, où 11 des bits sont libres

277
00:14:50,779 --> 00:14:54,080
de transporter un message et 4 d'entre eux sont là pour la redondance.

278
00:14:54,080 --> 00:14:56,792
Et avec cela, nous avons maintenant ce que les gens

279
00:14:56,792 --> 00:14:59,400
du secteur appelleraient un code de Hamming 15-11.

280
00:14:59,400 --> 00:15:03,238
Cela dit, c'est bien d'avoir une taille de bloc qui est une puissance propre de 2,

281
00:15:03,238 --> 00:15:06,336
et il existe un moyen astucieux de conserver ce 0ème bit et de lui

282
00:15:06,336 --> 00:15:08,880
faire faire un peu de travail supplémentaire pour nous.

283
00:15:08,880 --> 00:15:12,012
Si nous l'utilisons comme bit de parité sur l'ensemble du bloc,

284
00:15:12,012 --> 00:15:16,320
il nous permet de détecter, même si nous ne pouvons pas corriger, les erreurs de 2 bits.

285
00:15:16,320 --> 00:15:17,440
Voici comment cela fonctionne.

286
00:15:17,440 --> 00:15:20,461
Après avoir défini ces quatre bits spéciaux de correction d'erreurs,

287
00:15:20,461 --> 00:15:23,788
nous définissons ce 0ème de sorte que la parité du bloc complet soit paire,

288
00:15:23,788 --> 00:15:25,540
tout comme un contrôle de parité normal.

289
00:15:25,540 --> 00:15:27,717
Maintenant, s'il y a une erreur sur un seul bit,

290
00:15:27,717 --> 00:15:29,895
alors la parité du bloc complet devient impaire,

291
00:15:29,895 --> 00:15:32,473
mais nous la détecterions de toute façon grâce aux quatre

292
00:15:32,473 --> 00:15:33,940
contrôles de correction d'erreur.

293
00:15:33,940 --> 00:15:38,380
Cependant, s'il y a deux erreurs, alors la parité globale redeviendra paire,

294
00:15:38,380 --> 00:15:42,302
mais le récepteur verra toujours qu'il y a eu au moins une erreur à

295
00:15:42,302 --> 00:15:45,820
cause de ce qui se passe avec ces quatre contrôles de parité.

296
00:15:45,820 --> 00:15:47,865
Ainsi, s’ils remarquent une parité globale égale,

297
00:15:47,865 --> 00:15:50,811
mais que quelque chose de non nul se produit avec les autres contrôles,

298
00:15:50,811 --> 00:15:52,980
cela leur indique qu’il y a eu au moins deux erreurs.

299
00:15:52,980 --> 00:15:54,420
N'est-ce pas intelligent?

300
00:15:54,420 --> 00:15:57,567
Même si nous ne pouvons pas corriger ces erreurs de 2 bits,

301
00:15:57,567 --> 00:16:00,609
simplement en remettant au travail ce petit bit 0 gênant,

302
00:16:00,609 --> 00:16:02,340
cela nous permet de les détecter.

303
00:16:02,340 --> 00:16:06,540
C'est assez standard, c'est ce qu'on appelle un code de Hamming étendu.

304
00:16:06,540 --> 00:16:10,083
Techniquement parlant, vous avez maintenant une description complète de ce

305
00:16:10,083 --> 00:16:13,580
que fait un code de Hamming, du moins pour l'exemple d'un bloc de 16 bits.

306
00:16:13,580 --> 00:16:17,756
Mais je pense que vous trouverez plus satisfaisant de vérifier votre compréhension et de

307
00:16:17,756 --> 00:16:21,980
tout consolider jusqu'à présent en faisant vous-même un exemple complet du début à la fin.

308
00:16:21,980 --> 00:16:25,100
Je vais cependant le parcourir avec vous afin que vous puissiez vérifier par vous-même.

309
00:16:25,100 --> 00:16:28,681
Pour configurer un message, qu'il s'agisse d'un message littéral que vous

310
00:16:28,681 --> 00:16:32,650
traduisez dans l'espace ou de données que vous souhaitez stocker au fil du temps,

311
00:16:32,650 --> 00:16:35,700
la première étape consiste à le diviser en morceaux de 11 bits.

312
00:16:35,700 --> 00:16:40,340
Chaque morceau sera regroupé dans un bloc de 16 bits résistant aux erreurs.

313
00:16:40,340 --> 00:16:43,740
Prenons donc celui-ci comme exemple et résolvons-le réellement.

314
00:16:43,740 --> 00:16:45,380
Allez-y, faites-le!

315
00:16:45,380 --> 00:16:52,980
Faisons une pause et essayons de constituer ce bloc.

316
00:16:52,980 --> 00:16:53,980
OK, tu es prêt?

317
00:16:53,980 --> 00:16:57,849
N'oubliez pas que la position 0 ainsi que les autres puissances de 2

318
00:16:57,849 --> 00:17:01,550
sont réservées à la correction d'erreurs. Vous commencez donc par

319
00:17:01,550 --> 00:17:05,700
placer les bits de message à tous les emplacements restants, dans l'ordre.

320
00:17:05,700 --> 00:17:09,348
Vous avez besoin que ce groupe ait une parité paire, ce qui est déjà le cas,

321
00:17:09,348 --> 00:17:13,140
vous devriez donc avoir défini ce bit de parité en position 1 pour qu'il soit 0.

322
00:17:13,140 --> 00:17:16,200
Le groupe suivant commence avec une parité impaire,

323
00:17:16,200 --> 00:17:19,260
vous auriez donc dû définir son bit de parité sur 1.

324
00:17:19,260 --> 00:17:21,674
Le groupe suivant commence avec une parité impaire,

325
00:17:21,674 --> 00:17:24,740
vous devriez donc encore une fois définir son bit de parité sur 1.

326
00:17:24,740 --> 00:17:27,542
Et le groupe final a également une parité impaire,

327
00:17:27,542 --> 00:17:31,500
ce qui signifie que nous mettons ce bit en position 8 pour qu'il soit 1.

328
00:17:31,500 --> 00:17:36,198
Et puis, comme dernière étape, le bloc complet a maintenant une parité paire,

329
00:17:36,198 --> 00:17:41,500
ce qui signifie que vous pouvez définir ce bit numéro 0, le bit de parité global, sur 0.

330
00:17:41,500 --> 00:17:45,649
Ainsi, lorsque ce bloc est envoyé, la parité des quatre sous-ensembles

331
00:17:45,649 --> 00:17:48,980
spéciaux et du bloc dans son ensemble sera paire, soit 0.

332
00:17:48,980 --> 00:17:53,620
Dans la deuxième partie de l'exercice, nous vous ferons jouer le rôle du récepteur.

333
00:17:53,620 --> 00:17:56,626
Bien sûr, cela voudrait dire que vous ne savez pas déjà quel est ce message,

334
00:17:56,626 --> 00:17:58,657
peut-être que certains d'entre vous l'ont mémorisé,

335
00:17:58,657 --> 00:18:00,180
mais supposons que ce n'est pas le cas.

336
00:18:00,180 --> 00:18:04,852
Ce que je vais faire, c'est changer 0, 1 ou 2 des bits de ce bloc,

337
00:18:04,852 --> 00:18:08,340
puis vous demander de comprendre ce que j'ai fait.

338
00:18:08,340 --> 00:18:13,460
Encore une fois, faites une pause et essayez de trouver une solution.

339
00:18:13,460 --> 00:18:18,884
D'accord, donc en tant que récepteur, vous vérifiez maintenant

340
00:18:18,884 --> 00:18:24,395
le premier groupe de parité et vous pouvez voir qu'il est pair,

341
00:18:24,395 --> 00:18:29,820
donc toute erreur existant devrait être dans une colonne paire.

342
00:18:29,820 --> 00:18:32,975
La vérification suivante nous donne un nombre impair,

343
00:18:32,975 --> 00:18:37,299
nous indiquant à la fois qu'il y a au moins une erreur et nous limitant à

344
00:18:37,299 --> 00:18:38,760
cette colonne spécifique.

345
00:18:38,760 --> 00:18:42,900
Le troisième contrôle est égal, réduisant encore plus les possibilités.

346
00:18:42,900 --> 00:18:47,071
Et le dernier contrôle de parité est étrange, nous indiquant qu'il y a une erreur

347
00:18:47,071 --> 00:18:50,072
quelque part en bas, qui, nous pouvons maintenant le voir,

348
00:18:50,072 --> 00:18:51,700
doit être en position numéro 10.

349
00:18:51,700 --> 00:18:54,516
De plus, la parité de l'ensemble du bloc est étrange,

350
00:18:54,516 --> 00:18:58,220
ce qui nous donne l'assurance qu'il y a eu un retournement et non deux.

351
00:18:58,220 --> 00:19:01,600
S'il y en a trois ou plus, tous les paris sont ouverts.

352
00:19:01,600 --> 00:19:06,323
Après avoir corrigé ce bit numéro 10, retirer les 11 bits qui n'ont pas été utilisés

353
00:19:06,323 --> 00:19:10,658
pour la correction nous donne le segment pertinent du message d'origine, qui,

354
00:19:10,658 --> 00:19:15,604
si vous rembobinez et comparez, est en effet exactement ce avec quoi nous avons commencé

355
00:19:15,604 --> 00:19:16,160
l'exemple.

356
00:19:16,160 --> 00:19:18,989
Et maintenant que vous savez comment faire tout cela à la main,

357
00:19:18,989 --> 00:19:22,746
j'aimerais vous montrer comment réaliser l'essentiel de toute cette logique avec une

358
00:19:22,746 --> 00:19:23,940
seule ligne de code Python.

359
00:19:23,940 --> 00:19:26,016
Vous voyez, ce que je ne vous ai pas encore dit,

360
00:19:26,016 --> 00:19:28,008
c'est à quel point cet algorithme est élégant,

361
00:19:28,008 --> 00:19:31,696
à quel point il est simple de faire pointer une machine vers la position d'une erreur,

362
00:19:31,696 --> 00:19:34,705
comment la mettre à l'échelle systématiquement et comment nous pouvons

363
00:19:34,705 --> 00:19:37,715
encadrer l'ensemble des erreurs. ceci comme une seule opération plutôt

364
00:19:37,715 --> 00:19:39,580
que plusieurs contrôles de parité distincts.

365
00:19:39,580 --> 00:19:39,580
Pour voir ce que je veux dire, venez me rejoindre dans la partie 2.

