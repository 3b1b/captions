1
00:00:00,000 --> 00:00:05,668
Vous êtes-vous déjà demandé comment il était possible de gratter

2
00:00:05,668 --> 00:00:10,900
un CD ou un DVD tout en continuant à lire ce qu'il contient?

3
00:00:10,900 --> 00:00:15,289
La rayure affecte réellement les 1 et les 0 sur le disque, donc il lit des

4
00:00:15,289 --> 00:00:19,620
données différentes de celles qui ont été stockées, mais à moins qu'il ne

5
00:00:19,620 --> 00:00:24,068
soit vraiment rayé, les bits qu'il lit sont décodés exactement dans le même

6
00:00:24,068 --> 00:00:28,400
fichier qui y a été codé, un copie bit par bit, malgré toutes ces erreurs.

7
00:00:28,400 --> 00:00:32,397
Il existe tout un tas d’intelligence mathématique qui nous permet de stocker des

8
00:00:32,397 --> 00:00:36,840
données, et tout aussi important de les transmettre, d’une manière résiliente aux erreurs.

9
00:00:36,840 --> 00:00:39,743
Eh bien, d'accord, en fait, il ne faut pas beaucoup

10
00:00:39,743 --> 00:00:42,480
d'intelligence pour trouver un moyen de procéder.

11
00:00:42,480 --> 00:00:46,833
Tout fichier, qu'il s'agisse d'une vidéo, d'un son ou d'un texte, d'un code,

12
00:00:46,833 --> 00:00:50,960
d'une image, peu importe, est en fin de compte une séquence de 1 et de 0.

13
00:00:50,960 --> 00:00:54,133
Et une stratégie simple pour corriger tout bit

14
00:00:54,133 --> 00:00:57,780
retourné serait de stocker trois copies de chaque bit.

15
00:00:57,780 --> 00:01:02,502
Ensuite, la machine lisant ce fichier pourrait comparer ces trois

16
00:01:02,502 --> 00:01:07,440
copies et toujours prendre la meilleure 2 sur 3 en cas de divergence.

17
00:01:07,440 --> 00:01:11,560
Mais cela signifie que vous utilisez les deux tiers de votre espace pour la redondance.

18
00:01:11,560 --> 00:01:14,840
Et même dans ce cas, malgré tout cet espace abandonné, il n'y a aucune

19
00:01:14,840 --> 00:01:18,120
garantie solide quant à ce qui se passera si plus d'un bit est inversé.

20
00:01:18,120 --> 00:01:21,474
La question bien plus intéressante est de savoir comment faire en sorte que

21
00:01:21,474 --> 00:01:24,740
les erreurs puissent être corrigées en perdant le moins de place possible.

22
00:01:24,740 --> 00:01:28,641
Par exemple, en utilisant la méthode que vous découvrirez dans cette vidéo, vous

23
00:01:28,641 --> 00:01:32,975
pourriez stocker vos données dans des blocs de 256 bits, où chaque bloc utilise 9 bits, 9!

24
00:01:32,975 --> 00:01:37,041
pour agir comme une sorte de redondance, et les 247 autres bits sont libres

25
00:01:37,041 --> 00:01:41,000
de transporter le message ou les données significatifs que vous souhaitez.

26
00:01:41,000 --> 00:01:44,994
Et il sera toujours vrai que si un bit est inversé ici, rien qu'en regardant

27
00:01:44,994 --> 00:01:48,937
ce bloc et rien de plus, une machine sera capable d'identifier qu'il y a eu

28
00:01:48,937 --> 00:01:53,140
une erreur et précisément où elle se trouvait afin de savoir comment la corriger.

29
00:01:53,140 --> 00:01:55,540
Et honnêtement, cela semble magique.

30
00:01:55,540 --> 00:01:59,145
Et pour ce schéma particulier, si deux bits sont inversés, la machine sera au moins

31
00:01:59,145 --> 00:02:02,793
capable de détecter qu'il y a eu deux erreurs, même si elle ne saura pas comment les

32
00:02:02,793 --> 00:02:03,180
corriger.

33
00:02:03,180 --> 00:02:05,709
Nous parlerons un peu plus tard de la manière dont

34
00:02:05,709 --> 00:02:08,140
cela s'adapte à des blocs de différentes tailles.

35
00:02:08,140 --> 00:02:10,989
Les méthodes qui vous permettent de corriger de telles erreurs sont

36
00:02:10,989 --> 00:02:13,880
connues, à juste titre, sous le nom de codes de correction d'erreurs.

37
00:02:13,880 --> 00:02:16,794
Pendant la majeure partie du siècle dernier, ce domaine a été

38
00:02:16,794 --> 00:02:19,803
une source très riche de mathématiques étonnamment approfondies

39
00:02:19,803 --> 00:02:23,000
qui sont intégrées aux appareils que nous utilisons quotidiennement.

40
00:02:23,000 --> 00:02:26,354
L’objectif ici est de vous donner une compréhension très approfondie

41
00:02:26,354 --> 00:02:29,660
de l’un des premiers exemples, connu sous le nom de code de Hamming.

42
00:02:29,660 --> 00:02:33,024
Et d'ailleurs, la façon dont je réfléchis à la structure de cette vidéo

43
00:02:33,024 --> 00:02:36,528
consiste moins à l'expliquer aussi directement que possible, mais plutôt à

44
00:02:36,528 --> 00:02:40,220
vous inciter à l'inventer par vous-même, avec quelques conseils doux ici et là.

45
00:02:40,220 --> 00:02:43,641
Alors, quand vous sentez que vous voyez où cela va à un moment donné, prenez ce moment

46
00:02:43,641 --> 00:02:47,180
pour faire une pause, prédisez activement ce que sera le projet avant que je vous le dise.

47
00:02:47,180 --> 00:02:51,166
De plus, si vous souhaitez que votre compréhension descende au niveau matériel, Ben

48
00:02:51,166 --> 00:02:55,390
Eater a réalisé une vidéo en conjonction avec celle-ci vous montrant comment implémenter

49
00:02:55,390 --> 00:02:59,520
réellement les codes de Hamming sur des maquettes, ce qui est extrêmement satisfaisant.

50
00:02:59,520 --> 00:03:03,091
Vous devriez le savoir, les codes de Hamming ne sont pas aussi largement utilisés

51
00:03:03,091 --> 00:03:06,618
que les codes plus modernes, comme l'algorithme de Reed-Solomon, mais il y a une

52
00:03:06,618 --> 00:03:10,276
certaine magie dans le contraste entre le fait que cette tâche semble impossible au

53
00:03:10,276 --> 00:03:13,891
début et à quel point elle semble tout à fait raisonnable une fois. vous découvrez

54
00:03:13,891 --> 00:03:14,240
Hamming.

55
00:03:14,240 --> 00:03:18,449
Le principe de base de la correction d’erreurs est que dans un vaste espace de tous

56
00:03:18,449 --> 00:03:22,860
les messages possibles, seul un sous-ensemble sera considéré comme des messages valides.

57
00:03:22,860 --> 00:03:29,100
Par analogie, pensez aux mots correctement orthographiés et aux mots mal orthographiés.

58
00:03:29,100 --> 00:03:32,112
Chaque fois qu'un message valide est modifié, le destinataire

59
00:03:32,112 --> 00:03:35,124
est responsable de corriger ce qu'il voit au voisin valide le

60
00:03:35,124 --> 00:03:38,380
plus proche, comme vous pourriez le faire avec une faute de frappe.

61
00:03:38,380 --> 00:03:43,102
Cependant, trouver un algorithme concret pour catégoriser efficacement

62
00:03:43,102 --> 00:03:47,160
des messages comme celui-ci demande une certaine ingéniosité.

63
00:03:47,160 --> 00:03:50,716
L'histoire commence dans les années 1940, lorsque le jeune Richard Hamming travaillait

64
00:03:50,716 --> 00:03:54,027
pour les Bell Labs et qu'une partie de son travail impliquait l'utilisation d'un

65
00:03:54,027 --> 00:03:57,420
très gros ordinateur à carte perforée coûteux auquel il n'avait qu'un accès limité.

66
00:03:57,420 --> 00:04:00,153
Et les programmes qu’il continuait à mettre en place échouaient,

67
00:04:00,153 --> 00:04:03,140
parce que de temps en temps, certains éléments étaient mal interprétés.

68
00:04:03,140 --> 00:04:06,255
La frustration étant le creuset de l'invention, il en eut tellement

69
00:04:06,255 --> 00:04:09,280
marre qu'il inventa le premier code correcteur d'erreurs au monde.

70
00:04:09,280 --> 00:04:11,646
Il existe de nombreuses façons différentes de formuler les

71
00:04:11,646 --> 00:04:14,133
codes de Hamming, mais dans un premier temps, nous allons les

72
00:04:14,133 --> 00:04:16,620
parcourir de la manière dont Hamming lui-même les considérait.

73
00:04:16,620 --> 00:04:21,400
Prenons un exemple simple, mais pas trop simple, un bloc de 16 bits.

74
00:04:21,400 --> 00:04:25,700
Nous numéroterons les positions de ces bits de 0 à 15.

75
00:04:25,700 --> 00:04:29,836
Les données réelles que nous souhaitons stocker ne constitueront que 12 de ces

76
00:04:29,836 --> 00:04:33,920
bits, tandis que 4 des positions sont réservées comme une sorte de redondance.

77
00:04:33,920 --> 00:04:36,997
Le mot redondant ici ne signifie pas simplement copier, après tout, ces 4

78
00:04:36,997 --> 00:04:40,200
bits ne nous laissent pas assez de place pour copier aveuglément les données.

79
00:04:40,200 --> 00:04:44,494
Au lieu de cela, ils devront constituer une sorte de redondance beaucoup plus nuancée et

80
00:04:44,494 --> 00:04:48,740
intelligente, sans ajouter de nouvelles informations, mais en ajoutant de la résilience.

81
00:04:48,740 --> 00:04:51,593
Vous pourriez vous attendre à ce que ces 4 bits spéciaux soient bien

82
00:04:51,593 --> 00:04:54,488
emballés ensemble, peut-être à la fin ou quelque chose comme ça, mais

83
00:04:54,488 --> 00:04:57,176
comme vous le verrez, les placer dans des positions qui sont des

84
00:04:57,176 --> 00:05:00,320
puissances de 2 permet d'obtenir quelque chose de vraiment élégant à la fin.

85
00:05:00,320 --> 00:05:02,916
Cela pourrait également vous donner un petit indice sur

86
00:05:02,916 --> 00:05:05,420
la manière dont cela s'adapte à des blocs plus grands.

87
00:05:05,420 --> 00:05:08,420
De plus, techniquement, il ne s'agit que de 11 bits de données,

88
00:05:08,420 --> 00:05:11,232
vous constaterez qu'il y a une légère nuance pour ce qui se

89
00:05:11,232 --> 00:05:14,280
passe à la position 0, mais ne vous inquiétez pas pour l'instant.

90
00:05:14,280 --> 00:05:18,180
Comme tout algorithme de correction d'erreurs, celui-ci impliquera deux

91
00:05:18,180 --> 00:05:22,351
joueurs, un expéditeur chargé de définir ces 4 bits spéciaux et un récepteur

92
00:05:22,351 --> 00:05:26,360
chargé d'effectuer une sorte de vérification et de correction des erreurs.

93
00:05:26,360 --> 00:05:29,439
Bien sûr, les mots expéditeur et destinataire font en réalité référence à des

94
00:05:29,439 --> 00:05:32,400
machines ou à des logiciels qui effectuent toutes les vérifications, et la

95
00:05:32,400 --> 00:05:35,480
notion de message est très large, pour inclure des éléments comme le stockage.

96
00:05:35,480 --> 00:05:38,839
Après tout, stocker des données revient à envoyer un message

97
00:05:38,839 --> 00:05:42,640
uniquement du passé vers le futur plutôt que d’un endroit à un autre.

98
00:05:42,640 --> 00:05:46,216
Voilà donc la configuration, mais avant de pouvoir plonger dans le vif du sujet,

99
00:05:46,216 --> 00:05:49,925
nous devons parler d'une idée connexe qui était fraîche dans l'esprit de Hamming au

100
00:05:49,925 --> 00:05:53,635
moment de sa découverte, une méthode qui vous permet de détecter des erreurs sur un

101
00:05:53,635 --> 00:05:57,300
seul bit, mais pas de les corriger, connu dans l'entreprise comme chèque de parité.

102
00:05:57,300 --> 00:06:01,094
Pour un contrôle de parité, nous séparons un seul bit que l'expéditeur est

103
00:06:01,094 --> 00:06:04,940
responsable du réglage, et les autres sont libres de transporter un message.

104
00:06:04,940 --> 00:06:08,454
La seule tâche de ce bit spécial est de s'assurer que

105
00:06:08,454 --> 00:06:12,100
le nombre total de 1 dans le message est un nombre pair.

106
00:06:12,100 --> 00:06:14,988
Ainsi, par exemple, à l'heure actuelle, ce nombre total de

107
00:06:14,988 --> 00:06:17,974
1 est de 7, c'est impair, donc l'expéditeur doit inverser ce

108
00:06:17,974 --> 00:06:20,960
bit spécial pour qu'il soit un 1, ce qui rend le compte pair.

109
00:06:20,960 --> 00:06:24,067
Mais si le bloc avait déjà commencé avec un nombre

110
00:06:24,067 --> 00:06:27,480
pair de 1, alors ce bit spécial aurait été maintenu à 0.

111
00:06:27,480 --> 00:06:30,955
C'est assez simple, d'une simplicité trompeuse, mais c'est une manière

112
00:06:30,955 --> 00:06:34,431
incroyablement élégante de distiller l'idée de changement n'importe où

113
00:06:34,431 --> 00:06:37,760
dans un message pour la refléter dans un seul élément d'information.

114
00:06:37,760 --> 00:06:42,989
Remarquez que si un bit de ce message est inversé, soit de 0 à 1,

115
00:06:42,989 --> 00:06:48,140
soit de 1 à 0, cela change le nombre total de 1 de pair à impair.

116
00:06:48,140 --> 00:06:51,596
Donc, si vous êtes le destinataire, que vous regardez ce message et que

117
00:06:51,596 --> 00:06:55,196
vous voyez un nombre impair de 1, vous pouvez être sûr qu'une erreur s'est

118
00:06:55,196 --> 00:06:58,700
produite, même si vous n'avez aucune idée de l'endroit où elle se trouve.

119
00:06:58,700 --> 00:07:01,757
Dans le jargon, le fait qu'un groupe de bits ait

120
00:07:01,757 --> 00:07:04,940
un nombre pair ou impair de 1 est appelé sa parité.

121
00:07:04,940 --> 00:07:06,984
Vous pouvez également utiliser des nombres et dire que la

122
00:07:06,984 --> 00:07:09,134
parité est de 0 ou 1, ce qui est généralement plus utile une

123
00:07:09,134 --> 00:07:11,320
fois que vous commencez à faire des mathématiques avec l'idée.

124
00:07:11,320 --> 00:07:14,778
Et ce bit spécial que l’expéditeur utilise pour

125
00:07:14,778 --> 00:07:18,020
contrôler la parité est appelé bit de parité.

126
00:07:18,020 --> 00:07:21,991
Et en fait, soyons clairs, si le récepteur voit une parité impaire, cela ne signifie

127
00:07:21,991 --> 00:07:25,869
pas nécessairement qu'il y a eu une seule erreur, il peut y avoir eu 3 erreurs, ou

128
00:07:25,869 --> 00:07:29,560
5, ou tout autre nombre impair, mais il peut en être sûr. que ce n'était pas 0.

129
00:07:29,560 --> 00:07:34,328
D'un autre côté, s'il y avait eu 2 erreurs, ou un nombre pair d'erreurs, ce décompte

130
00:07:34,328 --> 00:07:38,928
final de 1 serait toujours pair, donc le destinataire ne peut pas être pleinement

131
00:07:38,928 --> 00:07:43,360
sûr qu'un décompte pair signifie nécessairement que le message est sans erreur.

132
00:07:43,360 --> 00:07:46,336
Vous pourriez vous plaindre qu'un message qui est gâché par

133
00:07:46,336 --> 00:07:49,760
seulement 2 bits est assez faible, et vous auriez tout à fait raison.

134
00:07:49,760 --> 00:07:53,127
Gardez toutefois à l’esprit qu’il n’existe aucune méthode de détection

135
00:07:53,127 --> 00:07:56,352
ou de correction des erreurs qui puisse vous donner une certitude à

136
00:07:56,352 --> 00:07:59,720
100 % que le message que vous recevez est celui prévu par l’expéditeur.

137
00:07:59,720 --> 00:08:02,567
Après tout, suffisamment de bruit aléatoire pourrait toujours

138
00:08:02,567 --> 00:08:05,920
transformer un message valide en un autre message valide, par pur hasard.

139
00:08:05,920 --> 00:08:11,141
Au lieu de cela, l’objectif est de proposer un système robuste jusqu’à un certain nombre

140
00:08:11,141 --> 00:08:15,952
maximum d’erreurs, ou peut-être de réduire la probabilité d’un faux positif comme

141
00:08:15,952 --> 00:08:16,480
celui-ci.

142
00:08:16,480 --> 00:08:20,205
Les contrôles de parité en eux-mêmes sont assez faibles, mais en distillant

143
00:08:20,205 --> 00:08:24,078
l'idée de changement à travers un message complet jusqu'à un seul élément, ils

144
00:08:24,078 --> 00:08:28,000
nous fournissent un élément de base puissant pour des schémas plus sophistiqués.

145
00:08:28,000 --> 00:08:31,750
Par exemple, alors que Hamming cherchait un moyen d'identifier l'endroit où une erreur

146
00:08:31,750 --> 00:08:35,544
s'est produite, et pas seulement le fait qu'elle s'est produite, son idée clé était que

147
00:08:35,544 --> 00:08:39,252
si vous appliquez des contrôles de parité non pas au message complet, mais à certains

148
00:08:39,252 --> 00:08:43,003
sous-ensembles soigneusement sélectionnés, vous pouvez demander une série de questions

149
00:08:43,003 --> 00:08:46,840
plus raffinées qui permettent de localiser l'emplacement de toute erreur sur un seul bit.

150
00:08:46,840 --> 00:08:50,474
Le sentiment général est un peu comme jouer à un jeu de 20 questions, poser

151
00:08:50,474 --> 00:08:54,300
des requêtes par oui ou par non qui divisent par deux l’espace des possibilités.

152
00:08:54,300 --> 00:08:57,478
Par exemple, disons que nous effectuons un contrôle de parité

153
00:08:57,478 --> 00:09:00,400
uniquement sur ces 8 bits, toutes les positions impaires.

154
00:09:00,400 --> 00:09:03,288
Ensuite, si une erreur est détectée, cela donne au récepteur

155
00:09:03,288 --> 00:09:06,176
un peu plus d'informations sur l'endroit précis où se trouve

156
00:09:06,176 --> 00:09:09,160
l'erreur, à savoir qu'elle se trouve dans une position étrange.

157
00:09:09,160 --> 00:09:13,225
Si aucune erreur n'est détectée parmi ces 8 bits, cela signifie soit qu'il n'y

158
00:09:13,225 --> 00:09:17,240
a aucune erreur, soit qu'elle se situe quelque part dans les positions paires.

159
00:09:17,240 --> 00:09:21,303
Vous pourriez penser que limiter un contrôle de parité à la moitié des bits le rend

160
00:09:21,303 --> 00:09:25,560
moins efficace, mais lorsqu'il est effectué en conjonction avec d'autres contrôles bien

161
00:09:25,560 --> 00:09:29,720
choisis, cela nous donne contre-intuitivement quelque chose de beaucoup plus puissant.

162
00:09:29,720 --> 00:09:33,577
Pour configurer réellement ce contrôle de parité, n'oubliez pas qu'il

163
00:09:33,577 --> 00:09:37,600
faut réserver un bit spécial qui contrôle la parité de ce groupe complet.

164
00:09:37,600 --> 00:09:39,920
Ici, choisissons simplement la position 1.

165
00:09:39,920 --> 00:09:43,803
Pour l'exemple présenté, la parité de ces 8 bits est actuellement impaire, donc

166
00:09:43,803 --> 00:09:47,977
l'expéditeur est responsable du basculement de ce bit de parité, et maintenant il est

167
00:09:47,977 --> 00:09:48,220
pair.

168
00:09:48,220 --> 00:09:51,040
Il ne s'agit que d'un contrôle de parité sur quatre que nous effectuerons.

169
00:09:51,040 --> 00:09:53,937
La deuxième vérification se situe parmi les 8 bits sur la moitié

170
00:09:53,937 --> 00:09:56,880
droite de la grille, du moins telle que nous l'avons dessinée ici.

171
00:09:56,880 --> 00:10:00,343
Cette fois, nous pourrions utiliser la position 2 comme bit de

172
00:10:00,343 --> 00:10:04,026
parité, donc ces 8 bits ont déjà une parité paire, et l'expéditeur

173
00:10:04,026 --> 00:10:07,160
peut se sentir bien en laissant ce bit numéro 2 inchangé.

174
00:10:07,160 --> 00:10:11,480
Puis à l'autre bout, si le récepteur vérifie la parité de ce groupe et trouve que

175
00:10:11,480 --> 00:10:15,960
c'est étrange, il saura que l'erreur se situe quelque part parmi ces 8 bits à droite.

176
00:10:15,960 --> 00:10:18,633
Sinon, cela signifie soit qu'il n'y a pas d'erreur, soit

177
00:10:18,633 --> 00:10:21,260
que l'erreur se situe quelque part sur la moitié gauche.

178
00:10:21,260 --> 00:10:24,273
Ou je suppose qu'il aurait pu y avoir deux erreurs, mais pour l'instant,

179
00:10:24,273 --> 00:10:27,080
nous allons supposer qu'il y a au plus une erreur dans tout le bloc.

180
00:10:27,080 --> 00:10:29,160
Les choses s'effondrent complètement pour plus que ça.

181
00:10:29,160 --> 00:10:32,480
Ici, avant d’examiner les deux contrôles suivants, prenez un moment pour réfléchir à

182
00:10:32,480 --> 00:10:35,880
ce que ces deux premiers nous permettent de faire lorsque vous les considérez ensemble.

183
00:10:35,880 --> 00:10:40,240
Disons que vous détectez une erreur parmi les colonnes impaires et parmi la moitié droite.

184
00:10:40,240 --> 00:10:43,940
Cela signifie nécessairement que l'erreur se situe quelque part dans la dernière colonne.

185
00:10:43,940 --> 00:10:47,208
S'il n'y a pas d'erreur dans la colonne impaire mais qu'il y en a une dans

186
00:10:47,208 --> 00:10:50,520
la moitié droite, cela vous indique que c'est dans l'avant-dernière colonne.

187
00:10:50,520 --> 00:10:53,637
De même, s'il y a une erreur dans les colonnes impaires mais pas dans la moitié

188
00:10:53,637 --> 00:10:56,560
droite, vous savez qu'elle se trouve quelque part dans la deuxième colonne.

189
00:10:56,560 --> 00:11:00,079
Et si aucun de ces deux contrôles de parité ne détecte quoi que ce soit, cela signifie

190
00:11:00,079 --> 00:11:03,476
que le seul endroit où une erreur pourrait se trouver est dans la colonne la plus à

191
00:11:03,476 --> 00:11:03,760
gauche.

192
00:11:03,760 --> 00:11:06,480
Mais cela peut aussi simplement signifier qu’il n’y a aucune erreur.

193
00:11:06,480 --> 00:11:09,116
Ce qui est une façon un peu compliquée de dire que deux

194
00:11:09,116 --> 00:11:11,800
contrôles de parité nous permettent de cerner la colonne.

195
00:11:11,800 --> 00:11:14,000
À partir de là, vous pouvez probablement deviner ce qui suit.

196
00:11:14,000 --> 00:11:16,240
Nous faisons essentiellement la même chose mais pour les lignes.

197
00:11:16,240 --> 00:11:18,409
Il y aura un contrôle de parité sur les lignes

198
00:11:18,409 --> 00:11:21,040
impaires, en utilisant la position 4 comme bit de parité.

199
00:11:21,040 --> 00:11:23,702
Ainsi, dans cet exemple, ce groupe a déjà une

200
00:11:23,702 --> 00:11:26,480
parité paire, donc le bit 4 serait défini sur 0.

201
00:11:26,480 --> 00:11:29,506
Et enfin, il y a un contrôle de parité sur les deux rangées

202
00:11:29,506 --> 00:11:32,280
du bas, en utilisant la position 8 comme bit de parité.

203
00:11:32,280 --> 00:11:35,139
Dans ce cas, il semble que l'expéditeur doive activer

204
00:11:35,139 --> 00:11:37,840
ce bit 8 afin de donner au groupe une parité égale.

205
00:11:37,840 --> 00:11:40,495
Tout comme les deux premières vérifications nous permettent de cerner

206
00:11:40,495 --> 00:11:43,000
la colonne, les deux suivantes vous permettent de cerner la ligne.

207
00:11:43,000 --> 00:11:46,078
À titre d'exemple, imaginez que lors de la transmission,

208
00:11:46,078 --> 00:11:48,400
il y ait une erreur, disons, en position 3.

209
00:11:48,400 --> 00:11:51,156
Eh bien, cela affecte le premier groupe de parité, et cela affecte

210
00:11:51,156 --> 00:11:53,748
également le deuxième groupe de parité, donc le récepteur sait

211
00:11:53,748 --> 00:11:56,340
qu'il y a une erreur quelque part dans cette colonne de droite.

212
00:11:56,340 --> 00:12:01,380
Mais cela n’affecte pas le troisième groupe, ni le quatrième groupe.

213
00:12:01,380 --> 00:12:04,950
Et cela permet au récepteur de localiser l'erreur jusqu'à la première ligne,

214
00:12:04,950 --> 00:12:08,660
ce qui signifie nécessairement la position 3, afin de pouvoir corriger l'erreur.

215
00:12:08,660 --> 00:12:11,456
Vous aimerez peut-être prendre un moment pour vous convaincre

216
00:12:11,456 --> 00:12:14,433
que les réponses à ces quatre questions vous permettront toujours

217
00:12:14,433 --> 00:12:17,320
de localiser un endroit spécifique, peu importe où il se trouve.

218
00:12:17,320 --> 00:12:20,690
En fait, les plus astucieux d’entre vous remarqueront peut-être

219
00:12:20,690 --> 00:12:23,640
même un lien entre ces questions et le comptage binaire.

220
00:12:23,640 --> 00:12:27,311
Et si c’est le cas, permettez-moi encore une fois de souligner, faites

221
00:12:27,311 --> 00:12:30,880
une pause, essayez par vous-même de faire le lien avant de le gâcher.

222
00:12:30,880 --> 00:12:33,795
Si vous vous demandez ce qui se passe si un bit de parité

223
00:12:33,795 --> 00:12:36,560
lui-même est affecté, vous pouvez simplement l'essayer.

224
00:12:36,560 --> 00:12:40,326
Prenez un moment pour réfléchir à la manière dont toute erreur

225
00:12:40,326 --> 00:12:43,614
parmi ces quatre éléments spéciaux sera détectée comme

226
00:12:43,614 --> 00:12:47,440
n'importe quelle autre, avec le même groupe de quatre questions.

227
00:12:47,440 --> 00:12:50,448
Cela n'a pas vraiment d'importance, puisqu'en fin de compte, ce que nous voulons,

228
00:12:50,448 --> 00:12:53,640
c'est protéger les bits de message, les bits de correction d'erreur ne font que suivre.

229
00:12:53,640 --> 00:12:56,287
Mais la protection de ces éléments est également quelque

230
00:12:56,287 --> 00:12:59,260
chose qui sort naturellement du schéma en tant que sous-produit.

231
00:12:59,260 --> 00:13:02,380
Vous pourriez également aimer anticiper l’évolution de cette situation.

232
00:13:02,380 --> 00:13:06,750
Si nous utilisons un bloc de 256 bits, par exemple, afin de localiser

233
00:13:06,750 --> 00:13:11,246
un emplacement, vous n'avez besoin que de huit questions par oui ou par

234
00:13:11,246 --> 00:13:15,680
non pour effectuer une recherche binaire jusqu'à un endroit spécifique.

235
00:13:15,680 --> 00:13:19,510
Et rappelez-vous que chaque question nécessite de renoncer

236
00:13:19,510 --> 00:13:23,340
à un seul bit pour définir le contrôle de parité approprié.

237
00:13:23,340 --> 00:13:26,481
Certains d'entre vous le voient peut-être déjà, mais nous parlerons plus tard de la

238
00:13:26,481 --> 00:13:29,772
manière systématique de découvrir quelles sont ces questions en seulement une minute ou

239
00:13:29,772 --> 00:13:29,960
deux.

240
00:13:29,960 --> 00:13:32,091
Espérons que cette esquisse soit suffisante pour

241
00:13:32,091 --> 00:13:34,440
apprécier l’efficacité de ce que nous développons ici.

242
00:13:34,440 --> 00:13:38,147
La première chose, à l'exception de ces huit bits de parité en surbrillance, peut

243
00:13:38,147 --> 00:13:41,720
être ce que vous voulez, transportant le message ou les données de votre choix.

244
00:13:41,720 --> 00:13:45,423
Les 8 bits sont redondants dans le sens où ils sont entièrement

245
00:13:45,423 --> 00:13:49,473
déterminés par le reste du message, mais c'est d'une manière beaucoup

246
00:13:49,473 --> 00:13:53,640
plus intelligente que de simplement copier le message dans son ensemble.

247
00:13:53,640 --> 00:13:56,107
Et pourtant, pour si peu d’abandon, vous seriez en mesure

248
00:13:56,107 --> 00:13:59,000
d’identifier et de corriger n’importe quelle erreur sur un seul bit.

249
00:13:59,000 --> 00:14:00,400
Enfin presque.

250
00:14:00,400 --> 00:14:04,611
D'accord, le seul problème ici est que si aucun des quatre contrôles de parité ne

251
00:14:04,611 --> 00:14:08,823
détecte une erreur, ce qui signifie que les sous-ensembles de 8 bits spécialement

252
00:14:08,823 --> 00:14:13,137
sélectionnés ont tous des parités paires, tout comme l'expéditeur le voulait, alors

253
00:14:13,137 --> 00:14:17,760
cela signifie qu'il n'y a eu aucune erreur du tout. , ou cela nous réduit à la position 0.

254
00:14:17,760 --> 00:14:21,461
Vous voyez, avec quatre questions par oui ou par non, nous avons 16

255
00:14:21,461 --> 00:14:25,107
résultats possibles pour nos contrôles de parité, et au début cela

256
00:14:25,107 --> 00:14:28,809
semble parfait pour identifier 1 position sur 16 dans le bloc, mais

257
00:14:28,809 --> 00:14:33,000
vous devez également communiquer un 17ème résultat, le non erreur. condition.

258
00:14:33,000 --> 00:14:37,860
La solution ici est en fait assez simple, oubliez complètement ce 0ème bit.

259
00:14:37,860 --> 00:14:41,228
Ainsi, lorsque nous effectuons nos quatre contrôles de parité et que nous constatons

260
00:14:41,228 --> 00:14:44,320
qu’ils sont tous égaux, cela signifie sans ambiguïté qu’il n’y a pas d’erreur.

261
00:14:44,320 --> 00:14:47,526
Cela signifie que plutôt que de travailler avec un bloc de 16 bits,

262
00:14:47,526 --> 00:14:50,779
nous travaillons avec un bloc de 15 bits, où 11 des bits sont libres

263
00:14:50,779 --> 00:14:54,080
de transporter un message et 4 d'entre eux sont là pour la redondance.

264
00:14:54,080 --> 00:14:56,792
Et avec cela, nous avons maintenant ce que les gens

265
00:14:56,792 --> 00:14:59,400
du secteur appelleraient un code de Hamming 15-11.

266
00:14:59,400 --> 00:15:02,637
Cela dit, c'est bien d'avoir une taille de bloc qui est une puissance

267
00:15:02,637 --> 00:15:05,689
propre de 2, et il existe un moyen astucieux de conserver ce 0ème

268
00:15:05,689 --> 00:15:08,880
bit et de lui faire faire un peu de travail supplémentaire pour nous.

269
00:15:08,880 --> 00:15:12,746
Si nous l'utilisons comme bit de parité sur l'ensemble du bloc, il nous permet

270
00:15:12,746 --> 00:15:16,320
de détecter, même si nous ne pouvons pas corriger, les erreurs de 2 bits.

271
00:15:16,320 --> 00:15:17,440
Voici comment cela fonctionne.

272
00:15:17,440 --> 00:15:19,979
Après avoir défini ces quatre bits spéciaux de correction

273
00:15:19,979 --> 00:15:22,694
d'erreurs, nous définissons ce 0ème de sorte que la parité du

274
00:15:22,694 --> 00:15:25,540
bloc complet soit paire, tout comme un contrôle de parité normal.

275
00:15:25,540 --> 00:15:28,428
Maintenant, s'il y a une erreur sur un seul bit, alors la parité

276
00:15:28,428 --> 00:15:31,184
du bloc complet devient impaire, mais nous la détecterions de

277
00:15:31,184 --> 00:15:33,940
toute façon grâce aux quatre contrôles de correction d'erreur.

278
00:15:33,940 --> 00:15:37,976
Cependant, s'il y a deux erreurs, alors la parité globale redeviendra

279
00:15:37,976 --> 00:15:41,783
paire, mais le récepteur verra toujours qu'il y a eu au moins une

280
00:15:41,783 --> 00:15:45,820
erreur à cause de ce qui se passe avec ces quatre contrôles de parité.

281
00:15:45,820 --> 00:15:49,379
Ainsi, s’ils remarquent une parité globale égale, mais que quelque chose de non nul se

282
00:15:49,379 --> 00:15:52,980
produit avec les autres contrôles, cela leur indique qu’il y a eu au moins deux erreurs.

283
00:15:52,980 --> 00:15:54,420
N'est-ce pas intelligent?

284
00:15:54,420 --> 00:15:58,301
Même si nous ne pouvons pas corriger ces erreurs de 2 bits, simplement en

285
00:15:58,301 --> 00:16:02,340
remettant au travail ce petit bit 0 gênant, cela nous permet de les détecter.

286
00:16:02,340 --> 00:16:06,540
C'est assez standard, c'est ce qu'on appelle un code de Hamming étendu.

287
00:16:06,540 --> 00:16:10,083
Techniquement parlant, vous avez maintenant une description complète de ce

288
00:16:10,083 --> 00:16:13,580
que fait un code de Hamming, du moins pour l'exemple d'un bloc de 16 bits.

289
00:16:13,580 --> 00:16:17,756
Mais je pense que vous trouverez plus satisfaisant de vérifier votre compréhension et de

290
00:16:17,756 --> 00:16:21,980
tout consolider jusqu'à présent en faisant vous-même un exemple complet du début à la fin.

291
00:16:21,980 --> 00:16:25,100
Je vais cependant le parcourir avec vous afin que vous puissiez vérifier par vous-même.

292
00:16:25,100 --> 00:16:28,681
Pour configurer un message, qu'il s'agisse d'un message littéral que vous

293
00:16:28,681 --> 00:16:32,166
traduisez dans l'espace ou de données que vous souhaitez stocker au fil

294
00:16:32,166 --> 00:16:35,700
du temps, la première étape consiste à le diviser en morceaux de 11 bits.

295
00:16:35,700 --> 00:16:40,340
Chaque morceau sera regroupé dans un bloc de 16 bits résistant aux erreurs.

296
00:16:40,340 --> 00:16:43,740
Prenons donc celui-ci comme exemple et résolvons-le réellement.

297
00:16:43,740 --> 00:16:45,380
Allez-y, faites-le!

298
00:16:45,380 --> 00:16:52,980
Faisons une pause et essayons de constituer ce bloc.

299
00:16:52,980 --> 00:16:53,980
OK, tu es prêt?

300
00:16:53,980 --> 00:16:57,849
N'oubliez pas que la position 0 ainsi que les autres puissances de 2

301
00:16:57,849 --> 00:17:01,550
sont réservées à la correction d'erreurs. Vous commencez donc par

302
00:17:01,550 --> 00:17:05,700
placer les bits de message à tous les emplacements restants, dans l'ordre.

303
00:17:05,700 --> 00:17:09,348
Vous avez besoin que ce groupe ait une parité paire, ce qui est déjà le cas,

304
00:17:09,348 --> 00:17:13,140
vous devriez donc avoir défini ce bit de parité en position 1 pour qu'il soit 0.

305
00:17:13,140 --> 00:17:16,200
Le groupe suivant commence avec une parité impaire,

306
00:17:16,200 --> 00:17:19,260
vous auriez donc dû définir son bit de parité sur 1.

307
00:17:19,260 --> 00:17:21,907
Le groupe suivant commence avec une parité impaire, vous

308
00:17:21,907 --> 00:17:24,740
devriez donc encore une fois définir son bit de parité sur 1.

309
00:17:24,740 --> 00:17:27,927
Et le groupe final a également une parité impaire, ce qui

310
00:17:27,927 --> 00:17:31,500
signifie que nous mettons ce bit en position 8 pour qu'il soit 1.

311
00:17:31,500 --> 00:17:36,379
Et puis, comme dernière étape, le bloc complet a maintenant une parité paire, ce

312
00:17:36,379 --> 00:17:41,500
qui signifie que vous pouvez définir ce bit numéro 0, le bit de parité global, sur 0.

313
00:17:41,500 --> 00:17:45,649
Ainsi, lorsque ce bloc est envoyé, la parité des quatre sous-ensembles

314
00:17:45,649 --> 00:17:48,980
spéciaux et du bloc dans son ensemble sera paire, soit 0.

315
00:17:48,980 --> 00:17:53,620
Dans la deuxième partie de l'exercice, nous vous ferons jouer le rôle du récepteur.

316
00:17:53,620 --> 00:17:57,017
Bien sûr, cela voudrait dire que vous ne savez pas déjà quel est ce message, peut-être

317
00:17:57,017 --> 00:18:00,180
que certains d'entre vous l'ont mémorisé, mais supposons que ce n'est pas le cas.

318
00:18:00,180 --> 00:18:04,225
Ce que je vais faire, c'est changer 0, 1 ou 2 des bits de

319
00:18:04,225 --> 00:18:08,340
ce bloc, puis vous demander de comprendre ce que j'ai fait.

320
00:18:08,340 --> 00:18:13,460
Encore une fois, faites une pause et essayez de trouver une solution.

321
00:18:13,460 --> 00:18:18,884
D'accord, donc en tant que récepteur, vous vérifiez maintenant

322
00:18:18,884 --> 00:18:24,395
le premier groupe de parité et vous pouvez voir qu'il est pair,

323
00:18:24,395 --> 00:18:29,820
donc toute erreur existant devrait être dans une colonne paire.

324
00:18:29,820 --> 00:18:34,143
La vérification suivante nous donne un nombre impair, nous indiquant à la

325
00:18:34,143 --> 00:18:38,760
fois qu'il y a au moins une erreur et nous limitant à cette colonne spécifique.

326
00:18:38,760 --> 00:18:42,900
Le troisième contrôle est égal, réduisant encore plus les possibilités.

327
00:18:42,900 --> 00:18:47,071
Et le dernier contrôle de parité est étrange, nous indiquant qu'il y a une erreur

328
00:18:47,071 --> 00:18:51,547
quelque part en bas, qui, nous pouvons maintenant le voir, doit être en position numéro

329
00:18:51,547 --> 00:18:51,700
10.

330
00:18:51,700 --> 00:18:54,881
De plus, la parité de l'ensemble du bloc est étrange, ce qui

331
00:18:54,881 --> 00:18:58,220
nous donne l'assurance qu'il y a eu un retournement et non deux.

332
00:18:58,220 --> 00:19:01,600
S'il y en a trois ou plus, tous les paris sont ouverts.

333
00:19:01,600 --> 00:19:06,323
Après avoir corrigé ce bit numéro 10, retirer les 11 bits qui n'ont pas été utilisés

334
00:19:06,323 --> 00:19:11,102
pour la correction nous donne le segment pertinent du message d'origine, qui, si vous

335
00:19:11,102 --> 00:19:15,604
rembobinez et comparez, est en effet exactement ce avec quoi nous avons commencé

336
00:19:15,604 --> 00:19:16,160
l'exemple.

337
00:19:16,160 --> 00:19:20,050
Et maintenant que vous savez comment faire tout cela à la main, j'aimerais vous montrer

338
00:19:20,050 --> 00:19:23,940
comment réaliser l'essentiel de toute cette logique avec une seule ligne de code Python.

339
00:19:23,940 --> 00:19:26,991
Vous voyez, ce que je ne vous ai pas encore dit, c'est à quel point cet

340
00:19:26,991 --> 00:19:30,043
algorithme est élégant, à quel point il est simple de faire pointer une

341
00:19:30,043 --> 00:19:32,967
machine vers la position d'une erreur, comment la mettre à l'échelle

342
00:19:32,967 --> 00:19:36,104
systématiquement et comment nous pouvons encadrer l'ensemble des erreurs.

343
00:19:36,104 --> 00:19:39,580
ceci comme une seule opération plutôt que plusieurs contrôles de parité distincts.

344
00:19:39,580 --> 00:19:39,580
Pour voir ce que je veux dire, venez me rejoindre dans la partie 2.

