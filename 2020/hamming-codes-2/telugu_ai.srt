1
00:00:00,000 --> 00:00:08,620
మీరు ఎప్పుడైనా CD లేదా DVDని

2
00:00:08,620 --> 00:00:10,900
స్క్రాచ్ చేయడం ఎలా సాధ్యమని ఆలోచించారా?

3
00:00:10,900 --> 00:00:15,280
స్క్రాచ్ నిజంగా డిస్క్‌లోని 1 సె మరియు 0 సెలను ప్రభావితం చేస్తుంది, కాబట్టి

4
00:00:15,280 --> 00:00:20,500
ఇది నిల్వ చేయబడిన దాని నుండి భిన్నమైన డేటాను రీడ్ చేస్తుంది, కానీ అది

5
00:00:20,500 --> 00:00:26,540
నిజంగా స్క్రాచ్ చేయబడితే తప్ప, అది చదివిన బిట్‌లు దానిలో ఎన్‌కోడ్ చేయబడిన అదే

6
00:00:26,540 --> 00:00:28,400
ఫైల్‌గా డీకోడ్ చేయబడతాయి, a బిట్ కాపీ కోసం బిట్, అన్ని లోపాలు ఉన్నప్పటికీ.

7
00:00:28,400 --> 00:00:32,800
డేటాను నిల్వ చేయడానికి మరియు ముఖ్యంగా డేటాను ప్రసారం చేయడానికి, లోపాలను

8
00:00:32,800 --> 00:00:36,840
ఎదుర్కొనేందుకు వీలు కల్పించే గణిత తెలివి యొక్క మొత్తం కుప్ప ఉంది.

9
00:00:36,840 --> 00:00:41,480
బాగా, సరే, వాస్తవానికి దీన్ని చేయడానికి ఒక మార్గంతో

10
00:00:41,480 --> 00:00:42,480
ముందుకు రావడానికి అంత తెలివి అవసరం లేదు.

11
00:00:42,480 --> 00:00:47,660
ఏదైనా ఫైల్, అది వీడియో లేదా సౌండ్ లేదా టెక్స్ట్ అయినా, కొంత కోడ్ అయినా,

12
00:00:47,660 --> 00:00:50,960
ఒక ఇమేజ్ అయినా, ఏదైనా సరే, చివరికి 1సె మరియు 0ల శ్రేణిలో ఉంటుంది.

13
00:00:50,960 --> 00:00:55,340
మరియు తిప్పబడిన బిట్‌ను సరిచేయడానికి ఒక సాధారణ వ్యూహం

14
00:00:55,340 --> 00:00:57,780
ప్రతి బిట్ యొక్క మూడు కాపీలను నిల్వ చేయడం.

15
00:00:57,780 --> 00:01:02,240
అప్పుడు ఈ ఫైల్‌ని చదివే యంత్రం ఈ మూడు కాపీలను

16
00:01:02,240 --> 00:01:07,440
పోల్చి, వ్యత్యాసం ఉన్నప్పుడల్లా 3లో 2 ఉత్తమమైన వాటిని తీసుకోగలదు.

17
00:01:07,440 --> 00:01:11,560
కానీ దాని అర్థం ఏమిటంటే, రిడెండెన్సీ కోసం మీ స్పేస్‌లో మూడింట రెండు వంతులను ఉపయోగించడం.

18
00:01:11,560 --> 00:01:15,360
ఆపై కూడా, ఆ స్థలం మొత్తం వదులుకోవడానికి, ఒకటి కంటే ఎక్కువ

19
00:01:15,360 --> 00:01:18,120
బిట్‌లు తిప్పబడితే ఏమి జరుగుతుందనే దానిపై బలమైన హామీ లేదు.

20
00:01:18,120 --> 00:01:21,960
చాలా ఆసక్తికరమైన ప్రశ్న ఏమిటంటే, వీలైనంత తక్కువ స్థలాన్ని

21
00:01:21,960 --> 00:01:24,740
వదిలివేసేటప్పుడు లోపాలను సరిదిద్దడానికి దీన్ని ఎలా తయారు చేయాలి.

22
00:01:24,740 --> 00:01:28,500
ఉదాహరణకు, మీరు ఈ వీడియో గురించి నేర్చుకునే పద్ధతిని ఉపయోగించి, మీరు మీ డేటాను 256-బిట్ బ్లాక్‌లలో నిల్వ

23
00:01:28,500 --> 00:01:35,840
చేయవచ్చు, ఇక్కడ ప్రతి బ్లాక్ 9 బిట్‌లను ఉపయోగిస్తుంది, 9! ఒక రకమైన రిడెండెన్సీగా పని చేయడానికి

24
00:01:35,840 --> 00:01:41,000
మరియు ఇతర 247 బిట్‌లు మీకు కావలసిన అర్థవంతమైన సందేశం లేదా డేటాను ఉచితంగా తీసుకెళ్లవచ్చు.

25
00:01:41,000 --> 00:01:44,740
మరియు ఇక్కడ ఏదైనా బిట్ తిప్పబడితే, ఈ బ్లాక్‌ని చూడటం ద్వారా

26
00:01:44,740 --> 00:01:49,640
మరియు మరేమీ లేదు, ఒక యంత్రం లోపం ఉందని మరియు ఖచ్చితంగా

27
00:01:49,640 --> 00:01:53,120
ఎక్కడ ఉందో గుర్తించగలదు, తద్వారా దానిని ఎలా సరిదిద్దాలో తెలుసు. .

28
00:01:53,140 --> 00:01:55,540
మరియు నిజాయితీగా, ఇది మేజిక్ లాగా అనిపిస్తుంది.

29
00:01:55,540 --> 00:01:59,400
మరియు ఈ నిర్దిష్ట స్కీమ్ కోసం, రెండు బిట్‌లు తిప్పబడినట్లయితే, వాటిని

30
00:01:59,400 --> 00:02:03,180
ఎలా పరిష్కరించాలో తెలియకపోయినప్పటికీ, యంత్రం కనీసం రెండు లోపాలు ఉన్నాయని గుర్తించగలదు.

31
00:02:03,180 --> 00:02:08,140
వివిధ పరిమాణాలు కలిగిన బ్లాక్‌ల కోసం ఇది ఎలా స్కేల్ అవుతుందనే దాని గురించి మేము కొంచెం తర్వాత మాట్లాడుతాము.

32
00:02:08,140 --> 00:02:12,620
ఇలాంటి లోపాలను సరిదిద్దడానికి మిమ్మల్ని అనుమతించే పద్ధతులు

33
00:02:12,620 --> 00:02:13,880
దోష దిద్దుబాటు కోడ్‌లుగా సమంజసంగా తగినంతగా తెలుసు.

34
00:02:13,880 --> 00:02:18,220
గత శతాబ్దంలో చాలా కాలం పాటు, ఈ ఫీల్డ్ ఆశ్చర్యకరంగా లోతైన గణితానికి

35
00:02:18,220 --> 00:02:23,000
నిజంగా గొప్ప మూలంగా ఉంది, అది మనం ప్రతిరోజూ ఉపయోగించే పరికరాలలో చేర్చబడుతుంది.

36
00:02:23,000 --> 00:02:27,740
హామింగ్ కోడ్ అని పిలువబడే తొలి ఉదాహరణలలో ఒకదాని

37
00:02:27,740 --> 00:02:29,660
గురించి మీకు పూర్తి అవగాహన కల్పించడం ఇక్కడ లక్ష్యం.

38
00:02:29,660 --> 00:02:32,620
ఇంకా చెప్పాలంటే, ఈ వీడియో నిర్మాణం గురించి నేను ఆలోచించే విధానం వీలైనంత

39
00:02:32,620 --> 00:02:37,060
సూటిగా వివరించడం గురించి తక్కువగా ఉంది మరియు ఇక్కడ మరియు అక్కడక్కడ

40
00:02:37,060 --> 00:02:40,220
కొంచెం సున్నితమైన మార్గదర్శకత్వంతో మీ కోసం దీన్ని కనిపెట్టమని మిమ్మల్ని ప్రేరేపిస్తుంది.

41
00:02:40,220 --> 00:02:44,100
కాబట్టి ఏదో ఒక సమయంలో అది ఎక్కడికి వెళుతుందో మీకు అనిపించినప్పుడు, ఆ క్షణం పాజ్

42
00:02:44,100 --> 00:02:47,180
చేయండి, నేను మీకు చెప్పే ముందు పథకం ఎలా ఉండబోతుందో చురుకుగా అంచనా వేయండి.

43
00:02:47,180 --> 00:02:51,500
అలాగే, మీ అవగాహన హార్డ్‌వేర్ స్థాయికి దిగజారాలని మీరు కోరుకుంటే, బెన్

44
00:02:51,500 --> 00:02:55,160
ఈటర్ దీనితో కలిపి ఒక వీడియోను రూపొందించారు, బ్రెడ్‌బోర్డ్‌లపై హామింగ్ కోడ్‌లను

45
00:02:55,160 --> 00:02:59,520
వాస్తవంగా ఎలా అమలు చేయాలో చూపుతుంది, ఇది చాలా సంతృప్తికరంగా ఉంది.

46
00:02:59,520 --> 00:03:03,120
రీడ్-సోలమన్ అల్గారిథమ్ వంటి ఆధునిక కోడ్‌ల వలె హామింగ్ కోడ్‌లు విస్తృతంగా ఉపయోగించబడవని మీరు తెలుసుకోవాలి,

47
00:03:03,120 --> 00:03:08,040
అయితే ఈ పని ప్రారంభంలో ఎంత అసాధ్యమని అనిపిస్తుంది మరియు ఇది ఎంతవరకు సహేతుకమైనదిగా

48
00:03:08,040 --> 00:03:14,240
అనిపిస్తుంది అనేదానికి విరుద్ధంగా ఒక నిర్దిష్ట మ్యాజిక్ ఉంది. మీరు హామింగ్ గురించి నేర్చుకుంటారు.

49
00:03:14,240 --> 00:03:19,080
ఎర్రర్ దిద్దుబాటు యొక్క ప్రాథమిక సూత్రం ఏమిటంటే, సాధ్యమయ్యే అన్ని సందేశాల యొక్క

50
00:03:19,300 --> 00:03:22,860
విస్తారమైన ప్రదేశంలో, కొన్ని ఉపసమితులు మాత్రమే చెల్లుబాటు అయ్యే సందేశాలుగా పరిగణించబడతాయి.

51
00:03:22,860 --> 00:03:29,100
సారూప్యతగా, సరిగ్గా స్పెల్లింగ్ చేయబడిన పదాలు vs తప్పుగా వ్రాయబడిన పదాల గురించి ఆలోచించండి.

52
00:03:29,100 --> 00:03:33,340
చెల్లుబాటు అయ్యే సందేశం మార్చబడినప్పుడల్లా, మీరు అక్షరదోషంతో చేసే విధంగా, సమీప చెల్లుబాటు

53
00:03:33,340 --> 00:03:38,380
అయ్యే పొరుగువారికి వారు చూసే వాటిని సరిదిద్దడానికి రిసీవర్ బాధ్యత వహిస్తారు.

54
00:03:38,380 --> 00:03:43,100
ఇలాంటి సందేశాలను సమర్ధవంతంగా వర్గీకరించడానికి కాంక్రీట్ అల్గారిథమ్‌తో

55
00:03:43,100 --> 00:03:47,160
ముందుకు రావడం, అయితే, కొంత తెలివితేటలు అవసరం.

56
00:03:47,160 --> 00:03:52,060
1940వ దశకంలో రిచర్డ్ హామింగ్ అనే యువకుడు బెల్ ల్యాబ్స్‌లో పని చేస్తున్నప్పుడు

57
00:03:52,060 --> 00:03:55,900
కథ మొదలవుతుంది మరియు అతని పనిలో కొంత భాగం అతనికి పరిమితమైన యాక్సెస్

58
00:03:55,900 --> 00:03:57,420
మాత్రమే ఉన్న చాలా పెద్ద ఖరీదైన పంచ్ కార్డ్ కంప్యూటర్‌ను ఉపయోగించడం జరిగింది.

59
00:03:57,420 --> 00:04:01,200
మరియు అతను దాని ద్వారా ఉంచిన ప్రోగ్రామ్‌లు విఫలమవుతూనే

60
00:04:01,200 --> 00:04:03,140
ఉన్నాయి, ఎందుకంటే ప్రతిసారీ కొంచెం తప్పుగా చదవబడుతుంది.

61
00:04:03,140 --> 00:04:07,140
ఆవిష్కారానికి మూలమైన నిరాశ, అతను చాలా విసుగు చెందాడు,

62
00:04:07,140 --> 00:04:09,280
అతను ప్రపంచంలోని మొట్టమొదటి దోష సవరణ కోడ్‌ను కనుగొన్నాడు.

63
00:04:09,280 --> 00:04:13,020
హామింగ్ కోడ్‌లను ఫ్రేమ్ చేయడానికి అనేక విభిన్న మార్గాలు ఉన్నాయి, కానీ మొదటి

64
00:04:13,020 --> 00:04:16,620
పాస్‌గా హామింగ్ స్వయంగా వాటి గురించి ఆలోచించిన విధంగానే మేము దానిని అనుసరించబోతున్నాము.

65
00:04:16,620 --> 00:04:21,400
16 బిట్‌ల బ్లాక్‌ని సరళమైన, కానీ చాలా సరళంగా లేని ఉదాహరణను ఉపయోగించుకుందాం.

66
00:04:21,400 --> 00:04:25,700
మేము ఈ బిట్‌ల స్థానాలను 0 నుండి 15 వరకు సంఖ్య చేస్తాము.

67
00:04:25,700 --> 00:04:30,520
మేము నిల్వ చేయాలనుకుంటున్న వాస్తవ డేటా ఈ బిట్‌లలో 12 మాత్రమే

68
00:04:30,520 --> 00:04:33,920
ఉంటుంది, అయితే 4 స్థానాలు ఒక రకమైన రిడెండెన్సీగా రిజర్వ్ చేయబడ్డాయి.

69
00:04:33,920 --> 00:04:38,120
ఇక్కడ రిడెండెంట్ అనే పదానికి కాపీ అని అర్థం కాదు, అన్నింటికంటే, ఆ

70
00:04:38,120 --> 00:04:40,200
4 బిట్‌లు డేటాను గుడ్డిగా కాపీ చేయడానికి మాకు తగినంత స్థలాన్ని ఇవ్వవు.

71
00:04:40,200 --> 00:04:44,880
బదులుగా, వారు కొత్త సమాచారాన్ని జోడించకుండా, స్థితిస్థాపకతను జోడించడం

72
00:04:44,880 --> 00:04:48,740
ద్వారా మరింత సూక్ష్మంగా మరియు తెలివైన రీడెండెన్సీగా ఉండాలి.

73
00:04:48,740 --> 00:04:52,620
మీరు ఈ 4 ప్రత్యేక బిట్‌లు చక్కగా ప్యాక్ చేయబడతాయని ఆశించవచ్చు, బహుశా

74
00:04:52,620 --> 00:04:56,400
చివరలో లేదా అలాంటిదే కావచ్చు, కానీ మీరు చూస్తారు, 2 యొక్క అధికారాలు

75
00:04:56,400 --> 00:05:00,320
ఉన్న స్థానాల్లో వాటిని కూర్చోబెట్టడం చివరి నాటికి నిజంగా సొగసైనదాన్ని అనుమతిస్తుంది.

76
00:05:00,320 --> 00:05:05,420
పెద్ద బ్లాక్‌ల కోసం ఇది ఎలా స్కేల్ అవుతుందనే దాని గురించి ఇది మీకు చిన్న సూచనను కూడా ఇవ్వవచ్చు.

77
00:05:05,420 --> 00:05:09,220
సాంకేతికంగా ఇది కేవలం 11 బిట్‌ల డేటాగా ముగుస్తుంది, 0 స్థానం వద్ద ఏమి జరుగుతుందనే

78
00:05:09,220 --> 00:05:14,260
దాని కోసం మీరు స్వల్ప స్వల్పభేదాన్ని కనుగొంటారు, కానీ ప్రస్తుతానికి దాని గురించి చింతించకండి.

79
00:05:14,280 --> 00:05:18,640
ఏదైనా ఎర్రర్ కరెక్షన్ అల్గారిథమ్ లాగా, ఇది ఇద్దరు ప్లేయర్‌లను కలిగి ఉంటుంది,

80
00:05:18,640 --> 00:05:23,200
ఈ 4 ప్రత్యేక బిట్‌లను సెట్ చేయడానికి బాధ్యత వహించే పంపినవారు మరియు

81
00:05:23,200 --> 00:05:26,360
ఒక రకమైన తనిఖీని నిర్వహించడానికి మరియు లోపాలను సరిదిద్దడానికి బాధ్యత వహించే రిసీవర్.

82
00:05:26,360 --> 00:05:30,040
వాస్తవానికి, పంపినవారు మరియు రిసీవర్ అనే పదాలు నిజంగా అన్ని తనిఖీలను

83
00:05:30,040 --> 00:05:34,040
చేసే యంత్రాలు లేదా సాఫ్ట్‌వేర్‌లను సూచిస్తాయి మరియు స్టోరేజ్ వంటి

84
00:05:34,040 --> 00:05:35,480
వాటిని చేర్చడానికి సందేశం యొక్క ఆలోచన నిజంగా విస్తృతంగా ఉద్దేశించబడింది.

85
00:05:35,480 --> 00:05:39,320
అన్నింటికంటే, డేటాను నిల్వ చేయడం అనేది ఒక ప్రదేశం నుండి మరొక

86
00:05:39,320 --> 00:05:42,640
ప్రదేశానికి బదులుగా గతం నుండి భవిష్యత్తుకు సందేశాన్ని పంపడం లాంటిదే.

87
00:05:42,640 --> 00:05:46,700
కాబట్టి అది సెటప్, కానీ మనం డైవ్ చేయడానికి ముందు హామింగ్

88
00:05:46,700 --> 00:05:51,080
కనుగొన్న సమయంలో అతని మనస్సులో తాజాగా ఉన్న సంబంధిత ఆలోచన

89
00:05:51,080 --> 00:05:55,520
గురించి మాట్లాడాలి, ఇది ఏదైనా ఒక బిట్ లోపాలను గుర్తించడానికి మిమ్మల్ని

90
00:05:55,520 --> 00:05:57,300
అనుమతిస్తుంది, కానీ వాటిని సరిదిద్దడానికి కాదు. పారిటీ చెక్‌గా వ్యాపారంలో.

91
00:05:57,300 --> 00:06:01,300
సమానత్వ తనిఖీ కోసం, పంపినవారు ట్యూనింగ్‌కు బాధ్యత వహించే ఒకే ఒక్క బిట్‌ను

92
00:06:01,300 --> 00:06:04,940
మాత్రమే మేము వేరు చేస్తాము మరియు మిగిలిన వారు సందేశాన్ని తీసుకువెళ్లడానికి ఉచితం.

93
00:06:04,940 --> 00:06:10,380
ఈ ప్రత్యేక బిట్ యొక్క ఏకైక పని సందేశంలోని

94
00:06:10,380 --> 00:06:12,100
మొత్తం 1ల సంఖ్య సరి సంఖ్య అని నిర్ధారించుకోవడం.

95
00:06:12,100 --> 00:06:16,920
కాబట్టి ఉదాహరణకు ప్రస్తుతం, 1ల యొక్క మొత్తం సంఖ్య 7, అది బేసి,

96
00:06:16,920 --> 00:06:20,960
కాబట్టి పంపినవారు ఆ ప్రత్యేక బిట్‌ను 1గా తిప్పి, గణనను సమానంగా చేయాలి.

97
00:06:20,960 --> 00:06:25,320
అయితే బ్లాక్ ఇప్పటికే 1ల సరి సంఖ్యతో ప్రారంభమై

98
00:06:25,320 --> 00:06:27,480
ఉంటే, ఈ ప్రత్యేక బిట్ 0 వద్ద ఉంచబడుతుంది.

99
00:06:27,480 --> 00:06:31,640
ఇది చాలా సరళమైనది, మోసపూరితమైనది, కానీ సందేశంలో ఎక్కడైనా మార్పు చేయాలనే ఆలోచనను

100
00:06:31,640 --> 00:06:37,760
ఒకే బిట్ సమాచారంలో ప్రతిబింబించేలా చేయడానికి ఇది చాలా సొగసైన మార్గం.

101
00:06:37,760 --> 00:06:43,680
ఈ సందేశంలోని ఏదైనా బిట్ 0 నుండి 1కి లేదా 1 నుండి

102
00:06:43,680 --> 00:06:48,140
0కి తిప్పబడితే, అది 1సె మొత్తం గణనను సరి నుండి బేసిగా మారుస్తుంది.

103
00:06:48,140 --> 00:06:52,000
మీరు రిసీవర్ అయితే, మీరు ఈ సందేశాన్ని చూడండి మరియు

104
00:06:52,000 --> 00:06:56,580
మీకు బేసి సంఖ్య 1లు కనిపిస్తే, అది ఎక్కడ ఉందో

105
00:06:56,580 --> 00:06:58,700
మీకు తెలియకపోయినప్పటికీ, కొంత లోపం సంభవించిందని మీరు ఖచ్చితంగా తెలుసుకోవచ్చు.

106
00:06:58,700 --> 00:07:02,820
పరిభాషలో, బిట్‌ల సమూహం 1ల సరి లేదా బేసి సంఖ్యను

107
00:07:02,820 --> 00:07:04,940
కలిగి ఉందా లేదా అనేది దాని సమానత్వం అంటారు.

108
00:07:04,940 --> 00:07:09,140
మీరు సంఖ్యలను కూడా ఉపయోగించవచ్చు మరియు సమానత్వం 0 లేదా 1 అని చెప్పవచ్చు,

109
00:07:09,140 --> 00:07:11,320
మీరు ఆలోచనతో గణితాన్ని ప్రారంభించిన తర్వాత ఇది సాధారణంగా మరింత ఉపయోగకరంగా ఉంటుంది.

110
00:07:11,320 --> 00:07:15,200
మరియు పంపినవారు పారిటీని నియంత్రించడానికి ఉపయోగించే ఈ

111
00:07:15,200 --> 00:07:18,020
ప్రత్యేక బిట్‌ని పారిటీ బిట్ అంటారు.

112
00:07:18,020 --> 00:07:22,460
వాస్తవానికి, మనం స్పష్టంగా ఉండాలి, రిసీవర్ బేసి సమానత్వాన్ని చూసినట్లయితే, అది కేవలం ఒక

113
00:07:22,460 --> 00:07:26,920
లోపం మాత్రమే ఉందని అర్థం కాదు, 3 లోపాలు లేదా 5 లేదా మరేదైనా

114
00:07:26,920 --> 00:07:29,560
బేసి సంఖ్య ఉండవచ్చు, కానీ వారు ఖచ్చితంగా తెలుసుకోగలరు అది 0 కాదని.

115
00:07:29,560 --> 00:07:34,880
మరోవైపు, 2 ఎర్రర్‌లు లేదా ఏవైనా సరి సంఖ్యలో ఎర్రర్‌లు ఉంటే, ఆ చివరి

116
00:07:34,880 --> 00:07:39,560
1 సె గణన ఇప్పటికీ సమానంగా ఉంటుంది, కాబట్టి రిసీవర్‌కి పూర్తి నమ్మకం

117
00:07:39,560 --> 00:07:43,360
ఉండదు కాబట్టి సరి గణన అంటే సందేశం లోపం లేనిదని అర్థం. .

118
00:07:43,360 --> 00:07:47,860
కేవలం 2 బిట్ ఫ్లిప్‌ల ద్వారా గందరగోళానికి గురైన సందేశం చాలా బలహీనంగా

119
00:07:47,860 --> 00:07:49,760
ఉందని మీరు ఫిర్యాదు చేయవచ్చు మరియు మీరు చెప్పేది ఖచ్చితంగా సరైనది.

120
00:07:49,760 --> 00:07:54,480
గుర్తుంచుకోండి, అయితే, మీరు స్వీకరించే సందేశం పంపినవారు ఉద్దేశించినదేనని మీకు 100% విశ్వాసం

121
00:07:54,480 --> 00:07:59,720
కలిగించే లోపాన్ని గుర్తించడం లేదా సరిదిద్దడం కోసం ఎలాంటి పద్ధతి లేదు.

122
00:07:59,720 --> 00:08:03,760
అన్నింటికంటే, తగినంత యాదృచ్ఛిక శబ్దం ఎల్లప్పుడూ ఒక చెల్లుబాటు

123
00:08:03,760 --> 00:08:05,920
అయ్యే సందేశాన్ని మరొక చెల్లుబాటు అయ్యే సందేశంగా మార్చగలదు.

124
00:08:05,920 --> 00:08:10,520
బదులుగా, నిర్దిష్ట గరిష్ట సంఖ్యలో ఎర్రర్‌ల వరకు పటిష్టంగా ఉండే స్కీమ్‌తో

125
00:08:10,520 --> 00:08:16,480
ముందుకు రావడం లేదా ఇలాంటి తప్పుడు పాజిటివ్ సంభావ్యతను తగ్గించడం లక్ష్యం.

126
00:08:16,480 --> 00:08:20,940
వారి స్వంతంగా పారిటీ తనిఖీలు చాలా బలహీనంగా ఉన్నాయి, కానీ పూర్తి

127
00:08:20,940 --> 00:08:25,640
సందేశంలో మార్పు ఆలోచనను ఒకే బిట్‌కు తగ్గించడం ద్వారా, అవి మనకు

128
00:08:25,640 --> 00:08:28,000
అందించేవి మరింత అధునాతన పథకాల కోసం శక్తివంతమైన బిల్డింగ్ బ్లాక్‌గా ఉంటాయి.

129
00:08:28,000 --> 00:08:32,880
ఉదాహరణకు, హ్యామింగ్ లోపం ఎక్కడ జరిగిందో గుర్తించడానికి ఒక మార్గం కోసం వెతుకుతున్నందున, అది

130
00:08:32,880 --> 00:08:37,160
జరిగిందనే కాకుండా, అతని ముఖ్య అంతర్దృష్టి ఏమిటంటే, మీరు కొన్ని సమానత్వ తనిఖీలను పూర్తి

131
00:08:37,160 --> 00:08:42,040
సందేశానికి కాకుండా, జాగ్రత్తగా ఎంచుకున్న కొన్ని ఉపసమితులకు వర్తింపజేస్తే, మీరు అడగవచ్చు ఏదైనా ఒక

132
00:08:42,040 --> 00:08:46,840
బిట్ ఎర్రర్ ఉన్న లొకేషన్‌ను పిన్ చేసే మరింత శుద్ధి చేసిన ప్రశ్నల శ్రేణి.

133
00:08:46,840 --> 00:08:51,280
మొత్తం ఫీలింగ్ 20 ప్రశ్నల గేమ్‌ను ఆడటం లాంటిది, అవునా లేదా

134
00:08:51,280 --> 00:08:54,300
కాదు అనే ప్రశ్నలను అడగడం, అవకాశాల ఖాళీని సగానికి తగ్గించడం.

135
00:08:54,300 --> 00:08:58,840
ఉదాహరణకు, ఈ 8 బిట్‌లలో, అన్ని బేసి సంఖ్యల

136
00:08:58,840 --> 00:08:59,840
స్థానాలపై మాత్రమే మనం సమానత్వ తనిఖీ చేశామని అనుకుందాం.

137
00:09:00,400 --> 00:09:04,560
అప్పుడు ఒక లోపం గుర్తించబడితే, అది రిసీవర్‌కు నిర్దిష్టంగా లోపం ఎక్కడ ఉందో దాని

138
00:09:04,560 --> 00:09:09,160
గురించి కొంచెం ఎక్కువ సమాచారాన్ని అందిస్తుంది, అంటే అది బేసి స్థానంలో ఉంది.

139
00:09:09,160 --> 00:09:14,360
ఆ 8 బిట్‌లలో ఎటువంటి లోపం కనుగొనబడకపోతే, అది ఏ లోపం

140
00:09:14,360 --> 00:09:17,240
లేదని అర్థం, లేదా అది సరి స్థానాల్లో ఎక్కడో కూర్చుని ఉంటుంది.

141
00:09:17,240 --> 00:09:21,560
సమానత్వ తనిఖీని సగం బిట్‌లకు పరిమితం చేయడం వలన అది తక్కువ

142
00:09:21,560 --> 00:09:25,460
ప్రభావవంతంగా ఉంటుందని మీరు అనుకోవచ్చు, అయితే ఇది ఇతర బాగా ఎంచుకున్న

143
00:09:25,460 --> 00:09:29,720
చెక్‌లతో కలిపి చేసినప్పుడు, ఇది ప్రతికూలంగా మనకు చాలా శక్తివంతమైనదాన్ని ఇస్తుంది.

144
00:09:29,720 --> 00:09:34,440
వాస్తవానికి ఆ పారిటీ చెక్‌ను సెటప్ చేయడానికి, గుర్తుంచుకోండి, ఆ పూర్తి సమూహం యొక్క

145
00:09:34,440 --> 00:09:37,600
సమానత్వం కోసం నియంత్రణను కలిగి ఉన్న కొన్ని ప్రత్యేక బిట్‌లను కేటాయించడం అవసరం.

146
00:09:37,600 --> 00:09:39,920
ఇక్కడ కేవలం స్థానం 1ని ఎంచుకుందాం.

147
00:09:39,920 --> 00:09:43,960
చూపిన ఉదాహరణ కోసం, ఈ 8 బిట్‌ల సమానత్వం ప్రస్తుతం బేసిగా ఉంది, కాబట్టి ఆ

148
00:09:43,960 --> 00:09:48,220
పారిటీ బిట్‌ను టోగుల్ చేయడానికి పంపినవారు బాధ్యత వహిస్తారు మరియు ఇప్పుడు అది సమానంగా ఉంది.

149
00:09:48,220 --> 00:09:51,040
ఇది మేము చేసే 4 పారిటీ తనిఖీలలో 1 మాత్రమే.

150
00:09:51,040 --> 00:09:55,560
రెండవ చెక్ గ్రిడ్ యొక్క కుడి భాగంలో ఉన్న 8

151
00:09:55,560 --> 00:09:56,880
బిట్‌లలో ఒకటి, కనీసం మేము దానిని ఇక్కడ గీసాము.

152
00:09:56,880 --> 00:10:02,520
ఈసారి మనం పొజిషన్ 2ని ప్యారిటీ బిట్‌గా ఉపయోగించవచ్చు, కాబట్టి ఈ 8 బిట్‌లు ఇప్పటికే సరి సమానతను

153
00:10:02,520 --> 00:10:07,160
కలిగి ఉన్నాయి మరియు పంపినవారు ఆ బిట్ నంబర్ 2ని మార్చకుండా ఉంచడం మంచి అనుభూతిని కలిగిస్తుంది.

154
00:10:07,160 --> 00:10:11,040
మరొక వైపు, రిసీవర్ ఈ సమూహం యొక్క సమానత్వాన్ని తనిఖీ చేసి, అది బేసి అని

155
00:10:11,040 --> 00:10:15,960
వారు కనుగొంటే, కుడివైపున ఉన్న ఈ 8 బిట్‌లలో ఎక్కడో లోపం ఉందని వారికి తెలుస్తుంది.

156
00:10:15,960 --> 00:10:21,260
లేకుంటే లోపం లేదని అర్థం, లేదా లోపం ఎడమ భాగంలో ఎక్కడో ఉంది.

157
00:10:21,260 --> 00:10:24,040
లేదా రెండు లోపాలు ఉండవచ్చని నేను ఊహిస్తున్నాను, కానీ ప్రస్తుతానికి

158
00:10:24,040 --> 00:10:27,080
మేము మొత్తం బ్లాక్‌లో గరిష్టంగా ఒక లోపం ఉందని భావించబోతున్నాము.

159
00:10:27,080 --> 00:10:29,160
అంతకు మించి విషయాలు పూర్తిగా విచ్ఛిన్నమవుతాయి.

160
00:10:29,160 --> 00:10:32,920
ఇక్కడ, మేము తదుపరి రెండు తనిఖీలను చూసే ముందు, ఈ మొదటి రెండింటిని మీరు

161
00:10:32,920 --> 00:10:35,880
కలిసి పరిగణించినప్పుడు మనం ఏమి చేయడానికి అనుమతిస్తాము అనే దాని గురించి కొంచెం ఆలోచించండి.

162
00:10:35,880 --> 00:10:40,240
మీరు బేసి నిలువు వరుసలలో మరియు కుడి సగం మధ్య లోపాన్ని గుర్తించారని అనుకుందాం.

163
00:10:40,240 --> 00:10:43,940
ఇది తప్పనిసరిగా లోపం చివరి కాలమ్‌లో ఎక్కడో ఉందని అర్థం.

164
00:10:43,940 --> 00:10:48,280
బేసి కాలమ్‌లో లోపం లేకపోయినా కుడి సగంలో ఒకటి ఉంటే, అది

165
00:10:48,280 --> 00:10:50,520
రెండవ నుండి చివరి నిలువు వరుసలో ఉందని మీకు తెలియజేస్తుంది.

166
00:10:50,520 --> 00:10:54,640
అదే విధంగా బేసి నిలువు వరుసలలో లోపం ఉంటే కానీ కుడి సగంలో

167
00:10:54,640 --> 00:10:56,560
లేకపోతే, అది రెండవ నిలువు వరుసలో ఎక్కడో ఉందని మీకు తెలుసు.

168
00:10:56,560 --> 00:11:00,560
మరియు ఆ రెండు సమానత్వ తనిఖీలలో దేనినీ గుర్తించలేకపోతే, ఆ ఎడమవైపున

169
00:11:00,560 --> 00:11:03,760
ఉన్న నిలువు వరుసలో లోపం ఉన్న ఏకైక స్థలం అని అర్థం.

170
00:11:03,760 --> 00:11:06,480
కానీ ఇది కేవలం ఏ లోపం లేదని అర్థం కావచ్చు.

171
00:11:06,480 --> 00:11:10,800
రెండు సమాన తనిఖీలు కాలమ్‌ను పిన్ చేద్దాం

172
00:11:10,800 --> 00:11:11,800
అని చెప్పడానికి ఇది చాలా కష్టమైన మార్గం.

173
00:11:11,800 --> 00:11:14,000
ఇక్కడ నుండి, మీరు బహుశా ఈ క్రింది వాటిని ఊహించవచ్చు.

174
00:11:14,000 --> 00:11:16,240
మేము ప్రాథమికంగా అదే పని చేస్తాము కానీ వరుసల కోసం.

175
00:11:16,240 --> 00:11:21,040
స్థానం 4ని సమాన బిట్‌గా ఉపయోగించి, బేసి అడ్డు వరుసలలో సమాన తనిఖీ జరగబోతోంది.

176
00:11:21,040 --> 00:11:25,480
కాబట్టి ఈ ఉదాహరణలో ఆ సమూహం ఇప్పటికే సమాన సమానత్వాన్ని

177
00:11:25,480 --> 00:11:26,480
కలిగి ఉంది, కాబట్టి బిట్ 4 0కి సెట్ చేయబడుతుంది.

178
00:11:26,480 --> 00:11:31,280
మరియు చివరగా దిగువ రెండు అడ్డు వరుసలలో 8వ

179
00:11:31,280 --> 00:11:32,280
స్థానాన్ని సమాన బిట్‌గా ఉపయోగిస్తూ సమానత్వ తనిఖీ ఉంది.

180
00:11:32,280 --> 00:11:35,840
ఈ సందర్భంలో, పంపినవారు సమూహానికి సమాన సమానత్వాన్ని అందించడానికి

181
00:11:35,840 --> 00:11:37,840
ఆ బిట్ 8ని ఆన్ చేయవలసి ఉన్నట్లు కనిపిస్తోంది.

182
00:11:37,840 --> 00:11:41,360
మొదటి రెండు చెక్‌లు నిలువు వరుసను పిన్ చేయడానికి వీలు కల్పిస్తున్నట్లే,

183
00:11:41,360 --> 00:11:43,000
ఈ తర్వాతి రెండు అడ్డు వరుసను పిన్ చేయడానికి మిమ్మల్ని అనుమతిస్తాయి.

184
00:11:43,000 --> 00:11:48,400
ఉదాహరణగా, ప్రసార సమయంలో 3వ స్థానం వద్ద లోపం ఉందని ఊహించండి.

185
00:11:48,400 --> 00:11:52,620
ఇది మొదటి సమూహాన్ని ప్రభావితం చేస్తుంది మరియు రెండవ సమూహాన్ని కూడా ప్రభావితం

186
00:11:52,620 --> 00:11:56,340
చేస్తుంది, కాబట్టి ఆ కుడి కాలమ్‌లో ఎక్కడో లోపం ఉందని రిసీవర్‌కు తెలుసు.

187
00:11:56,340 --> 00:12:01,380
కానీ ఇది మూడవ సమూహాన్ని ప్రభావితం చేయదు మరియు ఇది నాల్గవ సమూహాన్ని ప్రభావితం చేయదు.

188
00:12:01,380 --> 00:12:05,460
మరియు ఇది మొదటి వరుస వరకు లోపాన్ని గుర్తించడానికి రిసీవర్‌ని అనుమతిస్తుంది, అంటే

189
00:12:05,460 --> 00:12:08,660
తప్పనిసరిగా స్థానం 3 అని అర్థం, కాబట్టి వారు లోపాన్ని పరిష్కరించగలరు.

190
00:12:08,660 --> 00:12:12,640
ఈ నాలుగు ప్రశ్నలకు సమాధానాలు మీరు ఎక్కడికి వెళ్లినా ఒక నిర్దిష్ట లొకేషన్‌ను పిన్

191
00:12:12,680 --> 00:12:17,320
చేయడానికి మిమ్మల్ని అనుమతిస్తుంది అని మిమ్మల్ని మీరు ఒప్పించుకోవడానికి కొంత సమయం కేటాయించి ఆనందించవచ్చు.

192
00:12:17,320 --> 00:12:22,640
వాస్తవానికి, మీలో ఉన్న తెలివిగలవారు ఈ ప్రశ్నలకు మరియు

193
00:12:22,640 --> 00:12:23,640
బైనరీ లెక్కింపుకు మధ్య సంబంధాన్ని కూడా గమనించవచ్చు.

194
00:12:23,640 --> 00:12:27,840
మరియు మీరు అలా చేస్తే, మళ్లీ నేను నొక్కి చెప్పనివ్వండి, పాజ్ చేయండి,

195
00:12:27,840 --> 00:12:30,880
నేను కనెక్షన్‌ను పాడు చేసే ముందు దాన్ని గీయడానికి మీ కోసం ప్రయత్నించండి.

196
00:12:30,880 --> 00:12:35,560
ఒకవేళ పారిటీ బిట్ కూడా ప్రభావితమైతే ఏమి

197
00:12:35,560 --> 00:12:36,560
జరుగుతుందని మీరు ఆలోచిస్తున్నట్లయితే, మీరు దీన్ని ప్రయత్నించవచ్చు.

198
00:12:36,560 --> 00:12:40,720
ఈ నాలుగు ప్రత్యేక బిట్‌లలోని ఏదైనా లోపం, అదే నాలుగు

199
00:12:40,720 --> 00:12:47,440
ప్రశ్నల సమూహంతో ఇతర వాటిలాగే ఎలా ట్రాక్ చేయబడుతుందో ఆలోచించండి.

200
00:12:47,440 --> 00:12:50,500
ఇది నిజంగా పట్టింపు లేదు, ఎందుకంటే రోజు చివరిలో మనకు కావలసినది

201
00:12:50,500 --> 00:12:53,640
మెసేజ్ బిట్‌లను రక్షించడం, ఎర్రర్ కరెక్షన్ బిట్‌లు కేవలం సవారీ చేస్తున్నాయి.

202
00:12:53,640 --> 00:12:57,120
కానీ ఆ బిట్‌లను కూడా రక్షించడం అనేది సహజంగానే

203
00:12:57,120 --> 00:12:59,260
ఉప ఉత్పత్తిగా పథకం నుండి బయటకు వస్తుంది.

204
00:12:59,260 --> 00:13:02,380
ఇది ఎలా స్కేల్ అవుతుందో కూడా మీరు ఊహించి ఆనందించవచ్చు.

205
00:13:02,380 --> 00:13:08,040
మేము 256 బిట్‌ల పరిమాణం గల బ్లాక్‌ని ఉపయోగించినట్లయితే, ఉదాహరణకు, లొకేషన్‌ను పిన్ చేయడానికి, బైనరీ

206
00:13:08,040 --> 00:13:15,680
శోధన కోసం మీకు ఎనిమిది అవును లేదా కాదు అనే ప్రశ్నలు మాత్రమే అవసరం.

207
00:13:15,680 --> 00:13:19,680
మరియు గుర్తుంచుకోండి, ప్రతి ప్రశ్నకు తగిన పారిటీ చెక్‌ని

208
00:13:19,680 --> 00:13:23,340
సెట్ చేయడానికి ఒక్క బిట్‌ను మాత్రమే వదిలివేయాలి.

209
00:13:23,340 --> 00:13:26,960
మీలో కొందరికి ఇది ఇప్పటికే కనిపించవచ్చు, అయితే ఈ ప్రశ్నలు ఏమిటో ఒకటి

210
00:13:26,960 --> 00:13:29,960
లేదా రెండు నిమిషాల్లో కనుగొనే క్రమబద్ధమైన మార్గం గురించి మేము తర్వాత మాట్లాడుతాము.

211
00:13:29,960 --> 00:13:33,440
మేము ఇక్కడ అభివృద్ధి చేస్తున్న వాటి సామర్థ్యాన్ని

212
00:13:33,440 --> 00:13:34,440
అభినందించడానికి ఈ స్కెచ్ సరిపోతుందని ఆశిస్తున్నాము.

213
00:13:34,440 --> 00:13:38,440
మొదటి విషయం, ఆ ఎనిమిది హైలైట్ చేయబడిన పారిటీ బిట్‌లు మినహా, మీరు

214
00:13:38,440 --> 00:13:41,720
కోరుకున్నది ఏదైనా కావచ్చు, మీకు కావలసిన సందేశం లేదా డేటాను కలిగి ఉంటుంది.

215
00:13:41,720 --> 00:13:45,480
8 బిట్‌లు మిగిలిన సందేశం ద్వారా పూర్తిగా నిర్ణయించబడతాయి అనే అర్థంలో అనవసరంగా ఉంటాయి,

216
00:13:45,480 --> 00:13:53,640
అయితే ఇది సందేశాన్ని మొత్తంగా కాపీ చేయడం కంటే చాలా తెలివిగా ఉంటుంది.

217
00:13:53,640 --> 00:13:58,000
మరియు ఇప్పటికీ, చాలా తక్కువగా ఇచ్చినందుకు, మీరు

218
00:13:58,000 --> 00:13:59,000
ఏ ఒక్క బిట్ లోపాన్ని గుర్తించి పరిష్కరించగలరు.

219
00:13:59,000 --> 00:14:00,400
బాగా, దాదాపు.

220
00:14:00,400 --> 00:14:05,920
సరే, ఇక్కడ ఒక సమస్య ఏమిటంటే, నాలుగు పారిటీ తనిఖీలలో ఏదీ లోపాన్ని

221
00:14:05,920 --> 00:14:10,240
గుర్తించకపోతే, అంటే 8 బిట్‌ల యొక్క ప్రత్యేకంగా ఎంపిక చేయబడిన ఉపసమితులు

222
00:14:10,240 --> 00:14:15,520
అన్నింటికీ సమాన సమానతలను కలిగి ఉంటాయి, పంపినవారు ఉద్దేశించినట్లుగా, అప్పుడు ఎటువంటి లోపం

223
00:14:15,520 --> 00:14:17,760
లేదని అర్థం. , లేదా అది మనల్ని స్థానం 0కి తగ్గిస్తుంది.

224
00:14:17,760 --> 00:14:23,040
మీరు చూస్తారు, నాలుగు అవును లేదా కాదు ప్రశ్నలతో, మా సమానత్వ తనిఖీల కోసం మేము

225
00:14:23,040 --> 00:14:28,000
16 సాధ్యమైన ఫలితాలను కలిగి ఉన్నాము మరియు మొదట బ్లాక్‌లోని 16 స్థానాల్లో 1ని గుర్తించడానికి

226
00:14:28,000 --> 00:14:33,000
ఇది సరైనదనిపిస్తుంది, కానీ మీరు 17వ ఫలితాన్ని కూడా తెలియజేయాలి, లోపం లేదు పరిస్థితి.

227
00:14:33,000 --> 00:14:37,860
ఇక్కడ పరిష్కారం నిజానికి చాలా సులభం, ఆ 0వ బిట్ గురించి పూర్తిగా మరచిపోండి.

228
00:14:37,860 --> 00:14:41,920
కాబట్టి మేము మా నాలుగు సమాన తనిఖీలను చేసినప్పుడు మరియు అవన్నీ

229
00:14:41,920 --> 00:14:44,320
సమానంగా ఉన్నాయని మనం చూసినప్పుడు, ఎటువంటి లోపం లేదని నిస్సందేహంగా అర్థం.

230
00:14:44,320 --> 00:14:49,240
దీని అర్థం ఏమిటంటే, 16-బిట్ బ్లాక్‌తో పని చేయడం కంటే, మేము 15-బిట్ బ్లాక్‌తో పని చేస్తాము,

231
00:14:49,240 --> 00:14:54,040
ఇక్కడ 11 బిట్‌లు సందేశాన్ని తీసుకెళ్లడానికి ఉచితం మరియు వాటిలో 4 రిడెండెన్సీ కోసం ఉన్నాయి.

232
00:14:54,080 --> 00:14:58,400
దానితో, వ్యాపారంలో వ్యక్తులు 15-11 హామింగ్ కోడ్‌గా

233
00:14:58,400 --> 00:14:59,400
సూచించే వాటిని ఇప్పుడు మేము కలిగి ఉన్నాము.

234
00:14:59,400 --> 00:15:03,920
2 యొక్క క్లీన్ పవర్ ఉన్న బ్లాక్ సైజును కలిగి ఉండటం చాలా ఆనందంగా ఉంది మరియు మేము ఆ

235
00:15:03,920 --> 00:15:08,880
0వ బిట్‌ను చుట్టూ ఉంచుకుని, మన కోసం కొంచెం అదనపు పనిని చేయడానికి ఒక తెలివైన మార్గం ఉంది.

236
00:15:08,880 --> 00:15:13,600
మేము దానిని మొత్తం బ్లాక్‌లో సమాన బిట్‌గా ఉపయోగిస్తే, అది

237
00:15:13,600 --> 00:15:16,320
మనం 2-బిట్ ఎర్రర్‌లను సరిదిద్దలేనప్పటికీ, వాస్తవానికి గుర్తించడానికి అనుమతిస్తుంది.

238
00:15:16,320 --> 00:15:17,440
ఇది ఎలా పని చేస్తుందో ఇక్కడ ఉంది.

239
00:15:17,440 --> 00:15:21,740
ఆ నాలుగు ప్రత్యేక ఎర్రర్-కరెక్టింగ్ బిట్‌లను సెట్ చేసిన తర్వాత, మేము దానిని 0వదాన్ని సెట్

240
00:15:21,740 --> 00:15:25,540
చేసాము, తద్వారా పూర్తి బ్లాక్ యొక్క సమానత్వం సాధారణ పారిటీ తనిఖీ వలె సమానంగా ఉంటుంది.

241
00:15:25,540 --> 00:15:29,780
ఇప్పుడు, ఒక బిట్ ఎర్రర్ ఉన్నట్లయితే, పూర్తి బ్లాక్ యొక్క సమానత్వం బేసిగా

242
00:15:29,780 --> 00:15:33,940
టోగుల్ అవుతుంది, అయితే నాలుగు ఎర్రర్-కరెక్టింగ్ చెక్‌ల కారణంగా మేము దానిని పట్టుకుంటాము.

243
00:15:33,940 --> 00:15:38,100
అయితే, రెండు ఎర్రర్‌లు ఉన్నట్లయితే, మొత్తం సమానత్వం తిరిగి సమానంగా ఉండేలా

244
00:15:38,100 --> 00:15:42,660
టోగుల్ అవుతుంది, అయితే ఆ నాలుగు ప్యారిటీ చెక్‌లతో ఏమి జరుగుతోందనే

245
00:15:42,660 --> 00:15:45,820
దాని కారణంగా రిసీవర్ ఇప్పటికీ కనీసం కొంత లోపం ఉన్నట్లు చూస్తుంది.

246
00:15:45,820 --> 00:15:49,780
కాబట్టి వారు మొత్తంగా సమాన సమానత్వాన్ని గమనించినట్లయితే, కానీ ఇతర తనిఖీలతో సున్నా

247
00:15:49,820 --> 00:15:52,980
కాని ఏదైనా జరుగుతున్నట్లయితే, కనీసం రెండు ఎర్రర్‌లు ఉన్నాయని వారికి తెలియజేస్తుంది.

248
00:15:52,980 --> 00:15:54,420
అది తెలివైనది కాదా?

249
00:15:54,420 --> 00:15:58,500
మేము ఆ 2-బిట్ లోపాలను సరిదిద్దలేనప్పటికీ, ఒక చిన్న ఇబ్బందికరమైన 0వ

250
00:15:58,500 --> 00:16:02,340
బిట్‌ను తిరిగి పనిలో ఉంచడం ద్వారా, అది వాటిని గుర్తించేలా చేస్తుంది.

251
00:16:02,340 --> 00:16:06,540
ఇది చాలా ప్రామాణికమైనది, దీనిని పొడిగించిన హామింగ్ కోడ్ అని పిలుస్తారు.

252
00:16:06,540 --> 00:16:10,860
సాంకేతికంగా చెప్పాలంటే, కనీసం 16-బిట్ బ్లాక్ యొక్క ఉదాహరణ కోసం, హామింగ్

253
00:16:10,860 --> 00:16:13,580
కోడ్ ఏమి చేస్తుందో మీకు ఇప్పుడు పూర్తి వివరణ ఉంది.

254
00:16:13,580 --> 00:16:17,300
కానీ మీ అవగాహనను తనిఖీ చేయడం మరియు మొదటి నుండి పూర్తి చేయడానికి ఒక పూర్తి ఉదాహరణ చేయడం

255
00:16:17,300 --> 00:16:21,980
ద్వారా ఈ పాయింట్ వరకు ప్రతిదీ పటిష్టం చేయడం మీకు మరింత సంతృప్తికరంగా ఉంటుందని నేను భావిస్తున్నాను.

256
00:16:21,980 --> 00:16:25,100
నేను మీతో కలిసి అడుగు పెడతాను కాబట్టి మీరు మీరే తనిఖీ చేసుకోవచ్చు.

257
00:16:25,100 --> 00:16:29,180
సందేశాన్ని సెటప్ చేయడానికి, అది మీరు స్పేస్‌లో అనువదిస్తున్న అక్షరార్థ

258
00:16:29,180 --> 00:16:34,100
సందేశమైనా లేదా కాలక్రమేణా మీరు నిల్వ చేయాలనుకుంటున్న కొంత డేటా

259
00:16:34,100 --> 00:16:35,700
అయినా, మొదటి దశ దానిని 11-బిట్ భాగాలుగా విభజించడం.

260
00:16:35,700 --> 00:16:40,340
ప్రతి భాగం ఎర్రర్-రెసిస్టెంట్ 16-బిట్ బ్లాక్‌లోకి ప్యాక్ చేయబడుతుంది.

261
00:16:40,340 --> 00:16:43,740
కాబట్టి దీనిని ఒక ఉదాహరణగా తీసుకుందాం మరియు వాస్తవానికి దాన్ని పని చేద్దాం.

262
00:16:43,740 --> 00:16:45,340
ముందుకు సాగండి, వాస్తవానికి దీన్ని చేయండి!

263
00:16:45,380 --> 00:16:47,380
పాజ్ చేసి, ఈ బ్లాక్‌ని కలపడానికి ప్రయత్నిద్దాం.

264
00:16:52,980 --> 00:16:53,980
సరే, మీరు సిద్ధంగా ఉన్నారా?

265
00:16:53,980 --> 00:16:58,500
గుర్తుంచుకోండి, 2 యొక్క ఇతర అధికారాలతో పాటు స్థానం 0 దోష సవరణ విధి కోసం రిజర్వ్

266
00:16:58,500 --> 00:17:05,700
చేయబడింది, కాబట్టి మీరు సందేశ బిట్‌లను మిగిలిన అన్ని స్పాట్‌లలో క్రమంలో ఉంచడం ద్వారా ప్రారంభించండి.

267
00:17:05,700 --> 00:17:09,700
మీకు ఈ సమూహానికి సమాన సమానత్వం అవసరం, ఇది ఇప్పటికే ఉంది, కాబట్టి

268
00:17:09,700 --> 00:17:13,140
మీరు ఆ పారిటీ బిట్‌ను స్థానం 1లో 0గా సెట్ చేసి ఉండాలి.

269
00:17:13,140 --> 00:17:17,700
తదుపరి సమూహం బేసి సమానత్వంతో ప్రారంభమవుతుంది, కాబట్టి మీరు

270
00:17:17,700 --> 00:17:19,260
దాని సమాన బిట్‌ను 1కి సెట్ చేసి ఉండాలి.

271
00:17:19,260 --> 00:17:23,740
ఆ తర్వాత సమూహం బేసి సమానత్వంతో ప్రారంభమవుతుంది, కాబట్టి మీరు

272
00:17:23,740 --> 00:17:24,740
మళ్లీ దాని సమాన బిట్‌ను 1కి సెట్ చేసి ఉండాలి.

273
00:17:24,740 --> 00:17:29,500
మరియు చివరి సమూహానికి కూడా బేసి సమానత్వం ఉంది, అంటే

274
00:17:29,500 --> 00:17:31,500
మనం ఆ బిట్‌ను 8వ స్థానంలో 1గా సెట్ చేసాము.

275
00:17:31,500 --> 00:17:36,460
ఆపై చివరి దశగా, ఫుల్ బ్లాక్ ఇప్పుడు సరి సమానతను కలిగి ఉంది, అంటే మీరు

276
00:17:36,460 --> 00:17:41,500
ఆ బిట్ నంబర్ 0ని, ఓవర్ ఆర్చింగ్ పారిటీ బిట్‌ని 0గా సెట్ చేయవచ్చు.

277
00:17:41,500 --> 00:17:45,660
కాబట్టి ఈ బ్లాక్ పంపబడినందున, నాలుగు ప్రత్యేక ఉపసమితులు మరియు

278
00:17:45,660 --> 00:17:48,980
మొత్తం బ్లాక్ యొక్క సమానత్వం సమం లేదా 0 అవుతుంది.

279
00:17:48,980 --> 00:17:53,620
వ్యాయామం యొక్క రెండవ భాగం, మీరు రిసీవర్ పాత్రను పోషిస్తారు.

280
00:17:53,620 --> 00:17:57,580
అయితే, ఈ సందేశం ఏమిటో మీకు ఇప్పటికే తెలియదని దీని అర్థం, మీలో

281
00:17:57,580 --> 00:18:00,180
కొందరు దీన్ని గుర్తుపెట్టుకుని ఉండవచ్చు, కానీ మీరు అలా చేయలేదని అనుకుందాం.

282
00:18:00,180 --> 00:18:05,820
నేను ఏమి చేయబోతున్నాను ఆ బ్లాక్‌లోని బిట్‌లలో 0, 1 లేదా 2

283
00:18:05,820 --> 00:18:08,340
గాని మార్చండి, ఆపై నేను ఏమి చేశానో గుర్తించమని మిమ్మల్ని అడగండి.

284
00:18:08,340 --> 00:18:13,460
కాబట్టి మళ్ళీ, పాజ్ చేసి, దాన్ని పని చేయడానికి ప్రయత్నించండి.

285
00:18:13,460 --> 00:18:23,960
సరే, కాబట్టి మీరు రిసీవర్‌గా ఇప్పుడు మొదటి పారిటీ సమూహాన్ని తనిఖీ చేయండి మరియు అది

286
00:18:23,960 --> 00:18:29,820
సమంగా ఉన్నట్లు మీరు చూడవచ్చు, కాబట్టి ఉన్న ఏదైనా లోపం సరి నిలువు వరుసలో ఉండాలి.

287
00:18:29,820 --> 00:18:34,620
తదుపరి చెక్ మాకు బేసి సంఖ్యను ఇస్తుంది, కనీసం ఒక లోపం

288
00:18:34,620 --> 00:18:38,760
ఉందని మాకు చెబుతుంది మరియు ఈ నిర్దిష్ట కాలమ్‌లోకి మమ్మల్ని కుదించింది.

289
00:18:38,760 --> 00:18:42,900
మూడవ చెక్ కూడా, అవకాశాలను మరింత తగ్గించడం.

290
00:18:42,900 --> 00:18:46,780
మరియు చివరి పారీటీ చెక్ బేసిగా ఉంది, దిగువన ఎక్కడో లోపం

291
00:18:46,780 --> 00:18:51,700
ఉందని చెబుతుంది, ఇది ఇప్పుడు మనం చూడగలిగేది 10వ స్థానంలో ఉండాలి.

292
00:18:51,700 --> 00:18:56,140
ఇంకా ఏమిటంటే, మొత్తం బ్లాక్ యొక్క సమానత్వం బేసిగా ఉంది, ఇది

293
00:18:56,140 --> 00:18:58,220
ఒకటి కాదు మరియు రెండు కాదు అనే విశ్వాసాన్ని ఇస్తుంది.

294
00:18:58,220 --> 00:19:01,600
ఇది మూడు లేదా అంతకంటే ఎక్కువ ఉంటే, అన్ని పందాలు నిలిపివేయబడతాయి.

295
00:19:01,600 --> 00:19:06,520
ఆ బిట్ నంబర్ 10ని సరిదిద్దిన తర్వాత, దిద్దుబాటు కోసం ఉపయోగించని 11

296
00:19:06,520 --> 00:19:11,620
బిట్‌లను బయటకు తీయడం వలన అసలు సందేశం యొక్క సంబంధిత విభాగాన్ని మాకు

297
00:19:11,620 --> 00:19:16,160
అందజేస్తుంది, మీరు రివైండ్ చేసి సరిపోల్చినట్లయితే మేము ఉదాహరణను సరిగ్గా ప్రారంభించాము.

298
00:19:16,160 --> 00:19:19,260
మరియు ఇప్పుడు ఇవన్నీ చేతితో ఎలా చేయాలో మీకు తెలుసు కాబట్టి, పైథాన్ కోడ్ యొక్క ఒకే

299
00:19:19,260 --> 00:19:23,940
లైన్‌తో మీరు ఈ తర్కం యొక్క ప్రధాన భాగాన్ని ఎలా నిర్వహించవచ్చో నేను మీకు చూపించాలనుకుంటున్నాను.

300
00:19:23,940 --> 00:19:28,400
మీరు చూడండి, ఈ అల్గారిథమ్ నిజంగా ఎంత సొగసైనదో నేను మీకు ఇంకా

301
00:19:28,400 --> 00:19:32,380
చెప్పలేదు, లోపం ఉన్న స్థానానికి మెషిన్‌ని చూపడం ఎంత సులభమో, దాన్ని

302
00:19:32,380 --> 00:19:37,680
క్రమపద్ధతిలో ఎలా స్కేల్ చేయాలో మరియు మనం అన్నింటినీ ఎలా ఫ్రేమ్

303
00:19:37,680 --> 00:19:39,580
చేయవచ్చు ఇది బహుళ ప్రత్యేక పారిటీ తనిఖీల కంటే ఒకే ఆపరేషన్.

304
00:19:39,580 --> 00:19:41,680
నా ఉద్దేశ్యం ఏమిటో చూడటానికి, పార్ట్ 2లో నాతో చేరండి.

