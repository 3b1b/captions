1
00:00:00,000 --> 00:00:05,561
CD や DVD に傷を付けても、保存されている

2
00:00:05,561 --> 00:00:10,900
ものを再生できる方法を考えたことはありますか?

3
00:00:10,900 --> 00:00:13,059
スクラッチはディスク上の 1 と 0

4
00:00:13,059 --> 00:00:15,331
に実際に影響を与えるため、保存されてい

5
00:00:15,331 --> 00:00:18,172
たものとは異なるデータを読み取りますが、実際にスク

6
00:00:18,172 --> 00:00:21,013
ラッチが発生しない限り、読 み取られたビットは、エ

7
00:00:21,013 --> 00:00:24,195
ンコードされたファイルとまったく同じファイルにデコード

8
00:00:24,195 --> 00:00:27,036
されます。それらすべてのエラーにもかかわらず、ビッ

9
00:00:27,036 --> 00:00:28,400
トごとにコピーしました。

10
00:00:28,400 --> 00:00:31,169
エラーに強い方法でデータを保存すること、そ

11
00:00:31,169 --> 00:00:33,938
して同様に重要なことに 、データを送信する

12
00:00:33,938 --> 00:00:36,840
ことを可能にする数学的賢さは山ほどあります。

13
00:00:36,840 --> 00:00:39,801
そうですね、実際、これを行う方法を思いつ

14
00:00:39,801 --> 00:00:42,480
くのに、それほど賢さは必要ありません。

15
00:00:42,480 --> 00:00:46,797
ビデオ、サウンド、テキスト、コード、画像など、あらゆる

16
00:00:46,797 --> 00:00:50,960
ファイルは、最終的には 1 と 0 のシーケンスです。

17
00:00:50,960 --> 00:00:54,445
反転したビットを修正するための簡単な戦略は、

18
00:00:54,445 --> 00:00:57,780
各ビットのコピーを 3 つ保存することです。

19
00:00:57,780 --> 00:01:01,096
次に、このファイルを読み取るマシンは、これら

20
00:01:01,096 --> 00:01:04,556
3 つのコピーを比較 し、矛盾がある場合は常に

21
00:01:04,556 --> 00:01:07,440
3 つのうち最良の 2 つを選択します。

22
00:01:07,440 --> 00:01:09,500
しかし、これが意味するのは、スペースの 3

23
00:01:09,500 --> 00:01:11,560
分の 2 を冗長性のために使用することです。

24
00:01:11,560 --> 00:01:13,715
そして、それでも、そのスペースがすべて放棄され

25
00:01:13,715 --> 00:01:15,870
たにもかかわらず、複数の ビットが反転された場

26
00:01:15,870 --> 00:01:18,120
合に何が起こるかについて強力な保証はありません。

27
00:01:18,120 --> 00:01:20,290
さらに興味深い問題は、スペースをできるだ

28
00:01:20,290 --> 00:01:22,460
け少なくしながらエラ ーを修正できるよう

29
00:01:22,460 --> 00:01:24,740
にするにはどうすればよいかということです。

30
00:01:24,740 --> 00:01:28,230
たとえば、このビデオで説明する方法を使用すると、データを

31
00:01:28,230 --> 00:01:30,757
256 ビット ブロックに保 存できます。

32
00:01:30,757 --> 00:01:33,043
各ブロックは 9 ビットを使用します。

33
00:01:33,043 --> 00:01:36,311
ある種の冗長性として機能し、残り の 247

34
00:01:36,311 --> 00:01:40,289
ビットは、必要な意味のあるメッセージやデータを自由に伝送

35
00:01:40,289 --> 00:01:41,000
できます。

36
00:01:41,000 --> 00:01:44,030
そして、ここでビットが反転した場合でも、このブ

37
00:01:44,030 --> 00:01:47,060
ロックだけを見る だけで、マシンはエラーがあっ

38
00:01:47,060 --> 00:01:49,299
たことと、エラーがどこにあったか

39
00:01:49,299 --> 00:01:53,120
を正確に特定できるため、それを修正する方法がわかります。。

40
00:01:53,120 --> 00:01:55,540
正直に言うと、それは魔法のように感じます。

41
00:01:55,540 --> 00:01:57,217
そして、この特定のスキームでは、2

42
00:01:57,217 --> 00:01:59,639
つのビットが反転された場合、マシンは少なくとも 2

43
00:01:59,639 --> 00:02:02,155
つのエラーがあったことを検出できますが、それらを修正す

44
00:02:02,155 --> 00:02:03,180
る方法はわかりません。

45
00:02:03,180 --> 00:02:05,607
さまざまなサイズのブロックに対してこれがどのよ

46
00:02:05,607 --> 00:02:08,140
うに拡張されるかについては、後で少し説明します。

47
00:02:08,140 --> 00:02:11,080
このようなエラーを修正できる方法は、エラ

48
00:02:11,080 --> 00:02:13,880
ー修正コードとして十分に知られています。

49
00:02:13,880 --> 00:02:16,920
過去 1 世紀の大部分において、この分野は驚く

50
00:02:16,920 --> 00:02:19,960
ほど奥深い数学の実に豊 富な情報源であり、私た

51
00:02:19,960 --> 00:02:23,000
ちが毎日使用するデバイスに組み込まれています。

52
00:02:23,000 --> 00:02:26,397
ここでの目標は、ハミング コードとして知られる最

53
00:02:26,397 --> 00:02:29,660
も初期の例の 1 つを徹底的に理解することです。

54
00:02:29,660 --> 00:02:33,305
ちなみに、このビデオの構成について私が考えているのは、で

55
00:02:33,305 --> 00:02:36,825
きるだけ直接説明するというよりも、ところどころに少し優

56
00:02:36,825 --> 00:02:40,220
しい指導を加えながら、自分で考え出すよう促すことです。

57
00:02:40,220 --> 00:02:42,540
したがって、ある時点でどうなるか分かったと感じ

58
00:02:42,540 --> 00:02:44,860
たら、その瞬間を一時停 止し、私が言う前に計画

59
00:02:44,860 --> 00:02:47,180
がどのようになるかを積極的に予測してください。

60
00:02:47,180 --> 00:02:50,178
また、ハードウェア レベルまで理解してもらいたい場合

61
00:02:50,178 --> 00:02:53,177
は、Ben Eat er がこのビデオと併せて、実際

62
00:02:53,177 --> 00:02:55,483
にブレッドボードにハミング コードを実

63
00:02:55,483 --> 00:02:57,674
装する方法を示すビデオを作成しました。

64
00:02:57,674 --> 00:02:59,520
これは非常に満足のいくものです。

65
00:02:59,520 --> 00:03:01,384
ハミング コードは、リード ソロモン

66
00:03:01,384 --> 00:03:04,328
アルゴリズムのような最新のコードほど広く使用されていないこと

67
00:03:04,328 --> 00:03:07,272
を 知っておく必要があります。しかし、このタスクが最初はいか

68
00:03:07,272 --> 00:03:09,431
に不可能に感じられるか、そして一度は完全に

69
00:03:09,431 --> 00:03:12,375
合理的であるように見えるというコントラストには、ある種の魔法

70
00:03:12,375 --> 00:03:14,240
があります。ハミングについて学びます。

71
00:03:14,240 --> 00:03:17,072
エラー修正の基本原理は、考えられるすべてのメッ

72
00:03:17,072 --> 00:03:19,904
セージの膨大な空間の中で 、一部のサブセットの

73
00:03:19,904 --> 00:03:22,860
みが有効なメッセージとみなされるということです。

74
00:03:22,860 --> 00:03:25,900
例えとして、正しく綴られた単語と間違っ

75
00:03:25,900 --> 00:03:29,100
て綴られた単語について考えてみましょう。

76
00:03:29,100 --> 00:03:32,193
有効なメッセージが変更されるたびに、受信者は、タ

77
00:03:32,193 --> 00:03:35,286
イプミスの場合と同様に、 表示された内容を最も近

78
00:03:35,286 --> 00:03:38,380
い有効な隣接メッセージに修正する責任があります。

79
00:03:38,380 --> 00:03:42,921
ただし、このようなメッセージを効率的に分類するための具体的

80
00:03:42,921 --> 00:03:47,160
なアルゴリズムを考え出すには、ある程度の賢さが必要です。

81
00:03:47,160 --> 00:03:48,870
物語は 1940 年代に始まります。

82
00:03:48,870 --> 00:03:50,675
当時、若いリチャード・ハミングはベル

83
00:03:50,675 --> 00:03:53,240
研究所で働いていました。彼の仕事の一部には、アクセスが

84
00:03:53,240 --> 00:03:55,520
制限されていた非 常に大型で高価なパンチカード

85
00:03:55,520 --> 00:03:57,420
コンピューターの使用が含まれていました。

86
00:03:57,420 --> 00:04:00,508
そして、彼がやり続けたプログラムは失敗し続けました 。

87
00:04:00,508 --> 00:04:03,140
なぜなら、時折、少し読み間違えられるからです。

88
00:04:03,140 --> 00:04:06,281
欲求不満は発明の坩堝であるため、彼はうんざ

89
00:04:06,281 --> 00:04:09,280
りして世界初の誤り訂正符号を発明しました。

90
00:04:09,280 --> 00:04:11,647
ハミング コードを組み立てるにはさまざま

91
00:04:11,647 --> 00:04:14,015
な方法がありますが、最 初のパスとして、

92
00:04:14,015 --> 00:04:16,620
ハミング自身が考えた方法を試してみましょう。

93
00:04:16,620 --> 00:04:19,065
シンプルではありますが、単純すぎない 16

94
00:04:19,065 --> 00:04:21,400
ビットのブロックの例を使用してみましょう。

95
00:04:21,400 --> 00:04:23,758
これらのビットの位置に 0 から

96
00:04:23,758 --> 00:04:25,700
15 までの番号を付けます。

97
00:04:25,700 --> 00:04:28,564
保存したい実際のデータはこれらのビットのうち

98
00:04:28,564 --> 00:04:31,180
12 ビットのみを構 成し、位置のうちの

99
00:04:31,180 --> 00:04:33,920
4 つは一種の冗長性として予約されています。

100
00:04:33,920 --> 00:04:35,961
ここでの冗長という言葉は単にコピーを意味するものでは

101
00:04:35,961 --> 00:04:37,609
ありません。結局のところ、こ れらの 4

102
00:04:37,609 --> 00:04:39,650
ビットではデータをやみくもにコピーするのに十分な余地

103
00:04:39,650 --> 00:04:40,200
がありません。

104
00:04:40,200 --> 00:04:44,550
代わりに、新しい情報を追加するのではなく、回復力を追

105
00:04:44,550 --> 00:04:48,740
加する、より微妙で賢い種類の冗長性が必要になります。

106
00:04:48,740 --> 00:04:51,635
これら 4 つの特別なビットが、おそらく最後などでうま

107
00:04:51,635 --> 00:04:54,530
くパッケージ化され ることを期待するかもしれませんが、

108
00:04:54,530 --> 00:04:56,567
ご覧のとおり、これらを 2 のべき乗

109
00:04:56,567 --> 00:04:59,462
の位置に配置することで、最後までに非常にエレガントなも

110
00:04:59,462 --> 00:05:00,320
のが得られます。

111
00:05:00,320 --> 00:05:02,825
また、より大きなブロックに対してこれがどのように拡張され

112
00:05:02,825 --> 00:05:05,420
るかについてのちょっとしたヒントも得られるかもしれません。

113
00:05:05,420 --> 00:05:07,437
また、技術的には、最終的にはわずか 11

114
00:05:07,437 --> 00:05:09,936
ビットのデータになるため、位置 0 で何が起こって

115
00:05:09,936 --> 00:05:12,146
いるかについて若干のニュアンスがあることがわか

116
00:05:12,146 --> 00:05:14,260
りますが、今のところは心配しないでください。

117
00:05:14,260 --> 00:05:17,196
他のエラー修正アルゴリズムと同様に、これには 2

118
00:05:17,196 --> 00:05:20,133
人のプレイヤーが関 与します。送信者はこれら 4

119
00:05:20,133 --> 00:05:22,483
つの特別なビットを設定する責任を負い、

120
00:05:22,483 --> 00:05:25,420
受信者は何らかのチェックを実行してエラーを修正する

121
00:05:25,420 --> 00:05:26,360
責任を負います。

122
00:05:26,360 --> 00:05:29,436
もちろん、送信者と受信者という言葉は実際にはすべてのチ

123
00:05:29,436 --> 00:05:32,513
ェックを行うマシンまたはソフトウェアを指し、メッセージ

124
00:05:32,513 --> 00:05:35,480
の概念はストレージなどを含む非常に広い意味を指します。

125
00:05:35,480 --> 00:05:37,866
結局のところ、データを保存することは、ある

126
00:05:37,866 --> 00:05:40,253
場所から別の場所へで はなく、過去から未来

127
00:05:40,253 --> 00:05:42,640
へメッセージを送信することと同じことです。

128
00:05:42,640 --> 00:05:45,505
これがセットアップですが、本題に入る前に、ハミングが

129
00:05:45,505 --> 00:05:48,371
発見した当時に 彼の頭の中に新たにあった関連するアイ

130
00:05:48,371 --> 00:05:50,245
デアについて話す必要がありま す。

131
00:05:50,245 --> 00:05:53,111
それは、単一ビットのエラーを検出できるが、修正はでき

132
00:05:53,111 --> 00:05:55,977
ないという 既知の方法です。ビジネスではパリティチェ

133
00:05:55,977 --> 00:05:57,300
ックとして使用されます。

134
00:05:57,300 --> 00:06:01,251
パリティ チェックでは、送信者が調整を担当する 1 つのビ

135
00:06:01,251 --> 00:06:04,940
ットのみを分離し、残りは自由にメッセージを送信できます。

136
00:06:04,940 --> 00:06:08,520
この特別なビットの唯一の役割は、メッセージ内の

137
00:06:08,520 --> 00:06:12,100
1 の合計数が偶数であることを確認することです。

138
00:06:12,100 --> 00:06:14,614
たとえば、現時点では 1 の合計数は 7

139
00:06:14,614 --> 00:06:17,966
で、これは奇数であるため、送信者 はその特別なビットを

140
00:06:17,966 --> 00:06:20,960
1 に反転してカウントを偶数にする必要があります。

141
00:06:20,960 --> 00:06:24,286
ただし、ブロックがすでに偶数個の 1 で始まって

142
00:06:24,286 --> 00:06:27,480
いた場合、この特別なビットは 0 に保たれます。

143
00:06:27,480 --> 00:06:30,906
これは非常にシンプルで、一見シンプルですが、メッセー

144
00:06:30,906 --> 00:06:34,333
ジ内のどこかに変更があると いうアイデアを抽出して、

145
00:06:34,333 --> 00:06:37,760
わずかな情報に反映させる非常にエレガントな方法です。

146
00:06:37,760 --> 00:06:41,370
このメッセージのビットが 0 から 1、または

147
00:06:41,370 --> 00:06:43,927
1 から 0 に反転 すると、1

148
00:06:43,927 --> 00:06:48,140
の合計数が偶数から奇数に変化することに注意してください。

149
00:06:48,140 --> 00:06:50,726
したがって、あなたが受信者である場合、このメッセ

150
00:06:50,726 --> 00:06:53,312
ージを見て、奇数 の 1 が表示されれば、たとえ

151
00:06:53,312 --> 00:06:55,251
どこでエラーが発生したかは分からな

152
00:06:55,251 --> 00:06:57,837
くても、何らかのエラーが発生したことを確実に知る

153
00:06:57,837 --> 00:06:58,700
ことができます。

154
00:06:58,700 --> 00:07:01,935
専門用語では、ビットのグループに偶数個の 1 が含まれ

155
00:07:01,935 --> 00:07:04,940
るか奇数個の 1 が含まれるかをパリティと呼びます。

156
00:07:04,940 --> 00:07:06,889
数値を使用して、パリティが 0 または 1

157
00:07:06,889 --> 00:07:08,395
であると表現することもできま す。

158
00:07:08,395 --> 00:07:10,522
通常は、その考えに基づいて数学を始めると、この方

159
00:07:10,522 --> 00:07:11,320
がより役立ちます。

160
00:07:11,320 --> 00:07:14,815
送信側がパリティを制御するために使用するこの特

161
00:07:14,815 --> 00:07:18,020
別なビットは、パリティ ビットと呼ばれます。

162
00:07:18,020 --> 00:07:20,295
実際、明確にしておきたいのは、受信側が奇数のパリティを認

163
00:07:20,295 --> 00:07:21,920
識した場合、それは必ずしも 1 つのエ

164
00:07:21,920 --> 00:07:24,358
ラーがあったことを意味するわけではなく、3 つのエラー、5

165
00:07:24,358 --> 00:07:25,821
つのエラー、またはその他の奇数のエ

166
00:07:25,821 --> 00:07:28,097
ラーがあった可能性がありますが、受信者は確実に知ることが

167
00:07:28,097 --> 00:07:29,560
できます。0ではなかったということ。

168
00:07:29,560 --> 00:07:32,949
一方、2 つのエラーがあった場合、または偶数のエラーがあ

169
00:07:32,949 --> 00:07:36,338
った場合、最終的な 1 のカウントは依然として偶数である

170
00:07:36,338 --> 00:07:38,881
ため、受信側は、偶数のカウントが必ずしも

171
00:07:38,881 --> 00:07:42,270
メッセージにエラーがないことを意味すると完全に確信するこ

172
00:07:42,270 --> 00:07:43,360
とはできません。。

173
00:07:43,360 --> 00:07:46,560
たった 2 ビットの反転で台無しになるメッセージは非常に弱い

174
00:07:46,560 --> 00:07:49,760
と不満を言うかもしれませんが、それはまったくその通りです。

175
00:07:49,760 --> 00:07:53,080
ただし、受信したメッセージが送信者が意図したも

176
00:07:53,080 --> 00:07:56,400
のであることを 100 % 確信できるエラー検

177
00:07:56,400 --> 00:07:59,720
出または修正方法はないことに留意してください。

178
00:07:59,720 --> 00:08:01,728
結局のところ、十分なランダム ノイズがあれば、

179
00:08:01,728 --> 00:08:03,736
まったくの偶然で、ある有 効なメッセージが別の

180
00:08:03,736 --> 00:08:05,920
有効なメッセージに常に変更される可能性があります。

181
00:08:05,920 --> 00:08:09,440
代わりに、目標は、特定の最大エラー数まで堅

182
00:08:09,440 --> 00:08:12,960
牢なスキームを考え出 すこと、またはおそら

183
00:08:12,960 --> 00:08:16,480
くこのような誤検知の確率を減らすことです。

184
00:08:16,480 --> 00:08:20,407
パリティ チェック自体は非常に弱いですが、メッセージ全体に

185
00:08:20,407 --> 00:08:24,334
わたる変更のアイデアを単一のビットにまで絞り出すことで、よ

186
00:08:24,334 --> 00:08:28,000
り洗練されたスキームのための強力な構成要素を提供します。

187
00:08:28,000 --> 00:08:31,064
たとえば、ハミング氏は、エラーが発生したことだけでなく

188
00:08:31,064 --> 00:08:34,469
、どこでエラーが発生したかを 特定する方法を探していました。

189
00:08:34,469 --> 00:08:37,533
彼の重要な洞察は、メッセージ全体ではなく、慎重に選択

190
00:08:37,533 --> 00:08:39,462
された特定のサブセットにパリティ

191
00:08:39,462 --> 00:08:42,754
チェックを適用すると、次のようにできるということ でした。

192
00:08:42,754 --> 00:08:45,251
より洗練された一連の質問により、単一ビット

193
00:08:45,251 --> 00:08:46,840
エラーの位置が特定されます。

194
00:08:46,840 --> 00:08:49,253
全体的な感覚は、可能性の空間を半分に切り取る

195
00:08:49,253 --> 00:08:51,776
「はい」または「いいえ」 の質問をする 20

196
00:08:51,776 --> 00:08:54,300
の質問のゲームをプレイしているようなものです。

197
00:08:54,300 --> 00:08:57,122
たとえば、これらの 8 ビット、すべての奇数番号の位

198
00:08:57,122 --> 00:08:59,840
置についてのみパリティ チェックを実行するとします。

199
00:08:59,840 --> 00:09:02,905
その後、エラーが検出された場合、エラーが具体的にど

200
00:09:02,905 --> 00:09:05,971
こにあるのか、つまり、エラ ーが奇数の位置にあるこ

201
00:09:05,971 --> 00:09:09,160
とに関するもう少し詳しい情報が受信機に提供されます。

202
00:09:09,160 --> 00:09:13,273
これらの 8 ビットでエラーが検出されない場合は、エラ

203
00:09:13,273 --> 00:09:17,240
ーがまったくないか、偶数の位置にあることを意味します。

204
00:09:17,240 --> 00:09:21,400
パリティ チェックをビットの半分に制限すると効果が薄れると思

205
00:09:21,400 --> 00:09:25,560
うかもしれませんが、他の適切に選択されたチェックと組み合わ

206
00:09:25,560 --> 00:09:29,720
せて実行すると、直感に反してさらに強力なものが得られます。

207
00:09:29,720 --> 00:09:32,346
実際にパリティ チェックを設定するには、グル

208
00:09:32,346 --> 00:09:34,973
ープ全体のパリティを制 御する特別なビットを

209
00:09:34,973 --> 00:09:37,600
割り当てる必要があることに注意してください。

210
00:09:37,600 --> 00:09:39,920
ここでは位置 1 を選択しましょう。

211
00:09:39,920 --> 00:09:41,776
示されている例では、これらの 8

212
00:09:41,776 --> 00:09:44,179
ビットのパリティは現在奇数であるため、送信

213
00:09:44,179 --> 00:09:46,909
側はそのパリティ ビットを切り替える必要があり、現

214
00:09:46,909 --> 00:09:48,220
在は偶数になっています。

215
00:09:48,220 --> 00:09:49,670
これは、実行する 4 つのパリティ

216
00:09:49,670 --> 00:09:51,040
チェックのうちの 1 つだけです。

217
00:09:51,040 --> 00:09:54,017
2 番目のチェックは、少なくともここで描画したよう

218
00:09:54,017 --> 00:09:56,880
に、グリッドの右半分の 8 ビットの中にあります。

219
00:09:56,880 --> 00:10:00,267
今回は位置 2 をパリティ ビットとして使用する可能性があ

220
00:10:00,267 --> 00:10:02,136
るため、これらの 8 ビットに

221
00:10:02,136 --> 00:10:05,174
はすでに偶数パリティがあり、送信者はビット番号 2

222
00:10:05,174 --> 00:10:07,160
を変更しないままで問題ありません。

223
00:10:07,160 --> 00:10:10,093
次に、反対側で、受信側がこのグループのパリティをチェ

224
00:10:10,093 --> 00:10:13,026
ックし、それが奇数であるこ とが判明した場合、エラー

225
00:10:13,026 --> 00:10:15,960
が右側の 8 ビットのどこかにあることがわかります。

226
00:10:15,960 --> 00:10:18,610
それ以外の場合は、エラーがないか、左半分

227
00:10:18,610 --> 00:10:21,260
のどこかにエラーがあることを意味します。

228
00:10:21,260 --> 00:10:23,169
あるいは、エラーが 2 つあった可能性もあ

229
00:10:23,169 --> 00:10:25,534
ると思いますが、今のと ころは、ブロック全体で最大

230
00:10:25,534 --> 00:10:27,080
1 つのエラーがあると仮定します。

231
00:10:27,080 --> 00:10:29,160
それを超えると物事は完全に壊れます。

232
00:10:29,160 --> 00:10:31,828
ここで、次の 2 つのチェックを検討する前に、最初の

233
00:10:31,828 --> 00:10:34,002
2 つのチェッ クを一緒に考えると何ができる

234
00:10:34,002 --> 00:10:35,880
ようになるのかを少し考えてみましょう。

235
00:10:35,880 --> 00:10:40,240
奇数列と右半分でエラーを検出したとします。

236
00:10:40,240 --> 00:10:42,090
これは必然的に、エラーが最後の列

237
00:10:42,090 --> 00:10:43,940
のどこかにあることを意味します。

238
00:10:43,940 --> 00:10:47,292
奇数列にエラーがなく、右半分にエラーがあった場合は、

239
00:10:47,292 --> 00:10:50,520
それが最後から 2 番目の列にあることがわかります。

240
00:10:50,520 --> 00:10:53,594
同様に、奇数列にエラーがあり、右半分にはエラーがない場

241
00:10:53,594 --> 00:10:56,560
合は、2 列目のどこかにエラーがあることがわかります。

242
00:10:56,560 --> 00:10:58,960
これら 2 つのパリティ チェックのどちらでも何も

243
00:10:58,960 --> 00:11:01,360
検出されなかった場合、エ ラーが存在する可能性があ

244
00:11:01,360 --> 00:11:03,760
る唯一の場所はその左端の列であることを意味します。

245
00:11:03,760 --> 00:11:05,076
ただし、単にエラーがまったくな

246
00:11:05,076 --> 00:11:06,480
いことを意味する場合もあります。

247
00:11:06,480 --> 00:11:09,196
これは、2 つのパリティ チェックによって列を

248
00:11:09,196 --> 00:11:11,800
特定できると言うための、かなり面倒な方法です。

249
00:11:11,800 --> 00:11:14,000
ここから、おそらく次のことが推測できるでしょう。

250
00:11:14,000 --> 00:11:16,240
行について以外は基本的に同じことを行います。

251
00:11:16,240 --> 00:11:18,640
位置 4 をパリティ ビットとして使用して

252
00:11:18,640 --> 00:11:21,040
、奇数行のパリティ チェックが行われます。

253
00:11:21,040 --> 00:11:23,857
したがって、この例では、そのグループはすでに偶数パリティ

254
00:11:23,857 --> 00:11:26,480
を持っているため、ビット 4 は 0 に設定されます。

255
00:11:26,480 --> 00:11:29,496
最後に、位置 8 をパリティ ビットとして使用して

256
00:11:29,496 --> 00:11:32,280
、下位 2 行のパリティ チェックが行われます。

257
00:11:32,280 --> 00:11:35,114
この場合、グループに偶数パリティを与えるために、送

258
00:11:35,114 --> 00:11:37,840
信者はビット 8 をオンにする必要があるようです。

259
00:11:37,840 --> 00:11:40,523
最初の 2 つのチェックで列を特定できるのと同じよ

260
00:11:40,523 --> 00:11:43,000
うに、次の 2 つのチェックで行を特定できます。

261
00:11:43,000 --> 00:11:45,700
例として、送信中に、たとえば位置 3

262
00:11:45,700 --> 00:11:48,400
でエラーが発生したと想像してください。

263
00:11:48,400 --> 00:11:50,826
これは最初のパリティ グループに影響し、2

264
00:11:50,826 --> 00:11:53,472
番目のパリティ グループにも 影響するため、受信

265
00:11:53,472 --> 00:11:56,340
側は右側の列のどこかにエラーがあることがわかります。

266
00:11:56,340 --> 00:11:59,318
しかし、それは 3 番目のグループには影響せず、4

267
00:11:59,318 --> 00:12:01,380
番目のグループにも影響を与えません。

268
00:12:01,380 --> 00:12:04,413
これにより、受信側は最初の行 (必然的に位置 3

269
00:12:04,413 --> 00:12:08,053
を意味しま す) までのエラーを特定できるため、エラーを修正

270
00:12:08,053 --> 00:12:08,660
できます。

271
00:12:08,660 --> 00:12:10,778
これら 4 つの質問への答えによって、たとえそ

272
00:12:10,778 --> 00:12:13,082
れがどこであったとしても、常に特定の場所を突き止

273
00:12:13,082 --> 00:12:15,201
めることができるということを、少し時間をかけて

274
00:12:15,201 --> 00:12:17,320
自分に納得させてみるのも楽しいかもしれません。

275
00:12:17,320 --> 00:12:20,611
実際、賢明な方は、これらの質問と二進数の数え方と

276
00:12:20,611 --> 00:12:23,640
の間に関連性があることに気づくかもしれません。

277
00:12:23,640 --> 00:12:27,325
もしそうなら、私が台無しにする前に、もう一度強調して、

278
00:12:27,325 --> 00:12:30,880
立ち止まって、自分でそのつながりを描いてみてください。

279
00:12:30,880 --> 00:12:33,855
パリティ ビット自体が影響を受けるとどうな

280
00:12:33,855 --> 00:12:36,560
るか気になる場合は、試してみてください。

281
00:12:36,560 --> 00:12:40,186
これら 4 つの特別なビットのエラーが、他のもの

282
00:12:40,186 --> 00:12:43,813
と同じように、同じ 4 つの質問グループを使用し

283
00:12:43,813 --> 00:12:47,440
てどのように追跡されるのかを少し考えてください。

284
00:12:47,440 --> 00:12:49,300
結局のところ、私たちが望んでいるのはメッセージ

285
00:12:49,300 --> 00:12:50,617
ビットを保護することであり、エラ

286
00:12:50,617 --> 00:12:52,632
ー訂正ビットはそのまま使われているだけなので、これは

287
00:12:52,632 --> 00:12:53,640
あまり問題ではありません。

288
00:12:53,640 --> 00:12:56,522
しかし、これらのビットも保護することは

289
00:12:56,522 --> 00:12:59,260
、副産物として自然に計画から外れます。

290
00:12:59,260 --> 00:13:00,820
これがどのようにスケールされるかを

291
00:13:00,820 --> 00:13:02,380
予想するのも楽しいかもしれません。

292
00:13:02,380 --> 00:13:05,669
たとえば、場所を特定するためにサイズ 256

293
00:13:05,669 --> 00:13:09,101
ビットのブロックを使用した場合、特定の場所にた

294
00:13:09,101 --> 00:13:12,104
どり着くまでにバイナリ検索を行うには、8

295
00:13:12,104 --> 00:13:15,680
つの「はい」または「いいえ」の質問だけが必要です。

296
00:13:15,680 --> 00:13:19,510
各質問では、適切なパリティ チェックを設定するために 1

297
00:13:19,510 --> 00:13:23,340
ビットだけを放棄する必要があることを覚えておいてください。

298
00:13:23,340 --> 00:13:25,513
すでにご覧になっている方もいるかもしれません

299
00:13:25,513 --> 00:13:27,391
が、これらの質問の内容を 1 ～ 2

300
00:13:27,391 --> 00:13:29,960
分で見つける体系的な方法については後ほど説明します。

301
00:13:29,960 --> 00:13:32,289
このスケッチが、ここで開発しているものの効率性を理

302
00:13:32,289 --> 00:13:34,440
解していただくのに十分であることを願っています。

303
00:13:34,440 --> 00:13:37,068
最初のものは、強調表示されている 8 つのパリティ

304
00:13:37,068 --> 00:13:39,495
ビットを除いて、任意 のものにすることができ、必

305
00:13:39,495 --> 00:13:41,720
要なメッセージやデータを運ぶことができます。

306
00:13:41,720 --> 00:13:45,693
8 ビットはメッセージの残りの部分によって完全に

307
00:13:45,693 --> 00:13:49,666
決定されるという意味で冗 長ですが、メッセージ全

308
00:13:49,666 --> 00:13:53,640
体を単にコピーするよりもはるかに賢明な方法です。

309
00:13:53,640 --> 00:13:56,374
それでも、ほとんど諦めずに、どんなシングルビット

310
00:13:56,374 --> 00:13:59,000
エラーでも特定して修正することができるでしょう。

311
00:13:59,000 --> 00:14:00,400
よくほとんど。

312
00:14:00,400 --> 00:14:03,255
さて、ここでの 1 つの問題は、4 つのパリティ

313
00:14:03,255 --> 00:14:06,110
チェックのいずれもエラーを 検出しなかった場合、つ

314
00:14:06,110 --> 00:14:08,851
まり、送信者の意図どおり、特別に選択された 8

315
00:14:08,851 --> 00:14:11,706
ビッ トのサブセットがすべて偶数パリティを持つこと

316
00:14:11,706 --> 00:14:13,648
を意味し、それはエラーがまったく

317
00:14:13,648 --> 00:14:15,704
なかったことを意味するかどうかです。

318
00:14:15,704 --> 00:14:17,760
、または位置 0 に絞り込まれます。

319
00:14:17,760 --> 00:14:20,379
ご覧のとおり、はいまたはいいえの質問が 4

320
00:14:20,379 --> 00:14:22,879
つあるため、パリティ チェックには 16

321
00:14:22,879 --> 00:14:26,094
の可能な結果があり、ブロック内の 16 の位置のうち

322
00:14:26,094 --> 00:14:29,547
1 つを正確に特定するには最初 は完璧に思えますが、17

323
00:14:29,547 --> 00:14:33,000
番目の結果、つまりエラーなしを伝える必要もあります。状態。

324
00:14:33,000 --> 00:14:35,616
ここでの解決策は実際には非常に簡単で、0

325
00:14:35,616 --> 00:14:37,860
番目のビットを完全に忘れるだけです。

326
00:14:37,860 --> 00:14:39,982
したがって、4 つのパリティ チェックを実行し

327
00:14:39,982 --> 00:14:42,105
、それらがすべて偶数であ ることが確認できれば

328
00:14:42,105 --> 00:14:44,320
、それは間違いなくエラーがないことを意味します。

329
00:14:44,320 --> 00:14:45,720
これが意味するのは、16 ビット

330
00:14:45,720 --> 00:14:47,367
ブロックを扱うのではなく、15 ビット

331
00:14:47,367 --> 00:14:49,674
ブロックを扱うということです。この場合、ビッ トのうち

332
00:14:49,674 --> 00:14:52,063
11 ビットがメッセージを伝送するために自由に使用され、そ

333
00:14:52,063 --> 00:14:54,040
のうちの 4 ビットは冗長性のために存在します。

334
00:14:54,040 --> 00:14:56,523
これにより、業界の人々が 15-11

335
00:14:56,523 --> 00:14:59,400
ハ ミング コードと呼ぶものが完成しました。

336
00:14:59,400 --> 00:15:01,712
そうは言っても、ブロック サイズが 2

337
00:15:01,712 --> 00:15:04,718
のきれいな累乗であるのは良いことであり、そ の 0

338
00:15:04,718 --> 00:15:07,839
番目のビットを保持して、それに少し追加の作業をさせる賢

339
00:15:07,839 --> 00:15:08,880
い方法があります。

340
00:15:08,880 --> 00:15:10,849
これをブロック全体にわたるパリティ

341
00:15:10,849 --> 00:15:12,709
ビットとして使用すると、修正はで

342
00:15:12,709 --> 00:15:14,460
きなくても、実際に 2 ビット

343
00:15:14,460 --> 00:15:16,320
エラーを検出できるようになります。

344
00:15:16,320 --> 00:15:17,440
仕組みは次のとおりです。

345
00:15:17,440 --> 00:15:20,072
これら 4 つの特別なエラー訂正ビットを設定した後、

346
00:15:20,072 --> 00:15:22,705
通常のパリティ チェックと同 様に、ブロック全体のパ

347
00:15:22,705 --> 00:15:25,540
リティが偶数になるように 0 番目のビットを設定します。

348
00:15:25,540 --> 00:15:28,340
ここで、単一ビット エラーがある場合、ブロック全体のパ

349
00:15:28,340 --> 00:15:30,310
リティが奇数に切り替わりま すが、4

350
00:15:30,310 --> 00:15:33,110
つのエラー修正チェックのおかげで、いずれにせよそれをキ

351
00:15:33,110 --> 00:15:33,940
ャッチできます。

352
00:15:33,940 --> 00:15:36,880
ただし、エラーが 2 つある場合、全体のパリティは

353
00:15:36,880 --> 00:15:39,468
偶数に戻りますが 、受信側では、これら 4

354
00:15:39,468 --> 00:15:41,938
つのパリティ チェックで何が起こっている

355
00:15:41,938 --> 00:15:44,879
かにより、少なくとも何らかのエラーが発生しているこ

356
00:15:44,879 --> 00:15:45,820
とがわかります。

357
00:15:45,820 --> 00:15:48,206
そのため、全体としては偶数パリティであるにもかかわらず、他

358
00:15:48,206 --> 00:15:50,593
のチェックでゼロ以外の何かが 発生していることに気付いた場

359
00:15:50,593 --> 00:15:52,980
合は、少なくとも 2 つのエラーがあったことがわかります。

360
00:15:52,980 --> 00:15:54,420
それは賢明ではないでしょうか？

361
00:15:54,420 --> 00:15:56,978
これらの 2 ビット エラーを修正すること

362
00:15:56,978 --> 00:15:59,050
はできませんが、少し面 倒な 0

363
00:15:59,050 --> 00:16:02,340
番目のビットを動作に戻すだけで、エラーを検出できます。

364
00:16:02,340 --> 00:16:04,860
これは非常に標準的なもので、拡張ハミング

365
00:16:04,860 --> 00:16:06,540
コードとして知られています。

366
00:16:06,540 --> 00:16:08,886
技術的に言えば、少なくとも 16 ビット

367
00:16:08,886 --> 00:16:10,898
ブロックの例について は、ハミング

368
00:16:10,898 --> 00:16:13,580
コードが何を行うかについて完全に説明できました。

369
00:16:13,580 --> 00:16:16,380
ただし、最初から最後まで 1 つの完全な例を

370
00:16:16,380 --> 00:16:19,180
自分で実行して、理解度 を確認し、ここまでの

371
00:16:19,180 --> 00:16:21,980
すべてを定着させる方が満足できると思います。

372
00:16:21,980 --> 00:16:23,540
ただし、私はあなたと一緒にそれを段階的に確認し

373
00:16:23,540 --> 00:16:25,100
ていきますので、あなた自身を確認してください。

374
00:16:25,100 --> 00:16:27,722
メッセージを設定するには、それが空間を介して変換

375
00:16:27,722 --> 00:16:30,345
するリテラル メ ッセージであっても、長期間保存

376
00:16:30,345 --> 00:16:33,405
したいデータであっても、最初のステ ップはメッセージを

377
00:16:33,405 --> 00:16:35,700
11 ビットのチャンクに分割することです。

378
00:16:35,700 --> 00:16:37,960
各チャンクは、エラー耐性のある 16

379
00:16:37,960 --> 00:16:40,340
ビット ブロックにパッケージ化されます。

380
00:16:40,340 --> 00:16:43,740
では、これを例として実際にやってみましょう。

381
00:16:43,740 --> 00:16:45,340
さあ、実際にやってみましょう！

382
00:16:45,340 --> 00:16:47,380
立ち止まってこのブロックを組み立ててみましょう。

383
00:16:47,380 --> 00:16:53,980
はい、準備はできましたか？

384
00:16:53,980 --> 00:16:57,886
位置 0 と他の 2 の累乗はエラー訂正義務のため

385
00:16:57,886 --> 00:17:02,574
に予約されているので、残 りのすべてのスポットにメッセージ

386
00:17:02,574 --> 00:17:05,700
ビットを順番に配置することから始めます。

387
00:17:05,700 --> 00:17:08,180
このグループには偶数パリティが必要ですが、す

388
00:17:08,180 --> 00:17:10,885
でにそうされているため 、位置 1 のパリティ

389
00:17:10,885 --> 00:17:13,140
ビットを 0 に設定する必要があります。

390
00:17:13,140 --> 00:17:16,327
次のグループは奇数パリティで始まるため、そのパリ

391
00:17:16,327 --> 00:17:19,260
ティ ビットを 1 に設定する必要があります。

392
00:17:19,260 --> 00:17:22,051
その後のグループは奇数パリティで始まるため、やはりそ

393
00:17:22,051 --> 00:17:24,740
のパリティ ビットを 1 に設定する必要があります。

394
00:17:24,740 --> 00:17:28,280
また、最後のグループにも奇数パリティがあり

395
00:17:28,280 --> 00:17:31,500
、8 番目のビットを 1 に設定します。

396
00:17:31,500 --> 00:17:34,755
そして最後のステップとして、ブロック全体が偶数パリティを

397
00:17:34,755 --> 00:17:37,546
持つようになりました。これは、 ビット番号 0

398
00:17:37,546 --> 00:17:39,755
(包括的なパリティ ビット) を 0

399
00:17:39,755 --> 00:17:41,500
に設定できることを意味します。

400
00:17:41,500 --> 00:17:44,071
したがって、このブロックが送信されると、4

401
00:17:44,071 --> 00:17:46,525
つの特別なサブセット とブロック全体のパリ

402
00:17:46,525 --> 00:17:48,980
ティはすべて偶数、つまり 0 になります。

403
00:17:48,980 --> 00:17:51,300
演習の 2 番目の部分として、あなたに

404
00:17:51,300 --> 00:17:53,620
受信者の役割を果たしてもらいましょう。

405
00:17:53,620 --> 00:17:55,780
もちろん、それはあなたがこのメッセージが何であるかをま

406
00:17:55,780 --> 00:17:57,940
だ知らないことを意味します。もしかしたら覚えている人も

407
00:17:57,940 --> 00:18:00,180
いるかもしれませんが、まだ覚えていないと仮定しましょう。

408
00:18:00,180 --> 00:18:03,495
私がやろうとしているのは、そのブロック内のビットの

409
00:18:03,495 --> 00:18:06,172
0、1、また は 2 を変更して、私が何を

410
00:18:06,172 --> 00:18:08,340
したのかを理解してもらうことです。

411
00:18:08,340 --> 00:18:13,460
もう一度立ち止まって、問題を解決してみてください。

412
00:18:13,460 --> 00:18:17,550
さて、受信者として最初のパリティ

413
00:18:17,550 --> 00:18:21,880
グループをチェックすると、それが偶

414
00:18:21,880 --> 00:18:27,173
数であることがわかり、存在するエラーは偶数列

415
00:18:27,173 --> 00:18:29,820
にある必要があります。

416
00:18:29,820 --> 00:18:34,455
次のチェックでは奇数が得られ、少なくとも 1 つのエラ

417
00:18:34,455 --> 00:18:38,760
ーがあることがわかり、この特定の列に絞り込まれます。

418
00:18:38,760 --> 00:18:42,900
3 番目のチェックは均等であり、可能性をさらに切り詰めます。

419
00:18:42,900 --> 00:18:45,750
そして、最後のパリティ チェックは奇妙で、下部

420
00:18:45,750 --> 00:18:49,221
のどこかにエラーがあるこ とがわかりますが、今では位置

421
00:18:49,221 --> 00:18:51,700
10 にあるはずであることがわかります。

422
00:18:51,700 --> 00:18:55,017
さらに、ブロック全体のパリティは奇数であるため、フリップ

423
00:18:55,017 --> 00:18:58,220
が 2 回ではなく 1 回であるという確信が得られます。

424
00:18:58,220 --> 00:19:01,600
3 つ以上の場合、すべての賭けは無効になります。

425
00:19:01,600 --> 00:19:06,031
ビット番号 10 を修正した後、修正に使用されなかった

426
00:19:06,031 --> 00:19:09,671
11 ビットを取り出すと、元のメッセージの関連

427
00:19:09,671 --> 00:19:13,311
セグメントが得られま す。巻き戻して比較すると

428
00:19:13,311 --> 00:19:16,160
、まさに例の開始点と同じになります。

429
00:19:16,160 --> 00:19:18,719
これらすべてを手動で行う方法がわかったので、次は、

430
00:19:18,719 --> 00:19:20,971
このロジックすべての中核部 分を 1 行の

431
00:19:20,971 --> 00:19:23,940
Python コードで実行する方法を説明したいと思います。

432
00:19:23,940 --> 00:19:26,514
ご存知のとおり、私がまだお伝えしていないのは、このアル

433
00:19:26,514 --> 00:19:29,089
ゴリズムが実際にどれほど洗練 されているか、マシンにエ

434
00:19:29,089 --> 00:19:31,855
ラーの位置を指示させるのがどれほど簡単であるか、体系的に

435
00:19:31,855 --> 00:19:34,430
スケールを調整する方法、そしてすべてをどのようにフレー

436
00:19:34,430 --> 00:19:37,195
ム化できるかということです。これは、複数の個別のパリティ

437
00:19:37,195 --> 00:19:39,580
チェックではなく、1 つの操作として実行されます。

438
00:19:39,580 --> 00:19:40,892
私の言いたいことを理解するには、パート

439
00:19:40,892 --> 00:19:41,680
2 に参加してください。

