1
00:00:03,620 --> 00:00:06,926
CD や DVD に傷を付けても、保存されている 

2
00:00:06,926 --> 00:00:10,100
ものを再生できる方法を考えたことはありますか? 

3
00:00:10,900 --> 00:00:12,940
スクラッチはディスク上の 1 と 0 

4
00:00:12,940 --> 00:00:15,088
に実際に影響を与えるため、保存されてい 

5
00:00:15,088 --> 00:00:17,773
たものとは異なるデータを読み取りますが、実際にスク

6
00:00:17,773 --> 00:00:20,458
ラッチが発生しない限り、読 み取られたビットは、エ

7
00:00:20,458 --> 00:00:23,466
ンコードされたファイルとまったく同じファイルにデコード 

8
00:00:23,466 --> 00:00:26,151
されます。それらすべてのエラーにもかかわらず、ビッ

9
00:00:26,151 --> 00:00:27,440
トごとにコピーしました。

10
00:00:27,440 --> 00:00:30,314
エラーに強い方法でデータを保存すること、そ

11
00:00:30,314 --> 00:00:33,188
して同様に重要なことに 、データを送信する

12
00:00:33,188 --> 00:00:36,200
ことを可能にする数学的賢さは山ほどあります。

13
00:00:36,200 --> 00:00:38,657
そうですね、実際、これを行う方法を思いつ 

14
00:00:38,657 --> 00:00:40,880
くのに、それほど賢さは必要ありません。

15
00:00:40,880 --> 00:00:45,716
ビデオ、サウンド、テキスト、コード、画像など、あらゆる 

16
00:00:45,716 --> 00:00:50,380
ファイルは、最終的には 1 と 0 のシーケンスです。

17
00:00:50,680 --> 00:00:53,399
反転したビットを修正するための簡単な戦略は、 

18
00:00:53,399 --> 00:00:56,000
各ビットのコピーを 3 つ保存することです。

19
00:00:57,580 --> 00:00:59,804
次に、このファイルを読み取るマシンは、これら 

20
00:00:59,804 --> 00:01:02,125
3 つのコピーを比較 し、矛盾がある場合は常に 

21
00:01:02,125 --> 00:01:04,060
3 つのうち最良の 2 つを選択します。

22
00:01:07,160 --> 00:01:09,009
しかし、これが意味するのは、スペースの 3 

23
00:01:09,009 --> 00:01:10,860
分の 2 を冗長性のために使用することです。

24
00:01:11,480 --> 00:01:13,372
そして、それでも、そのスペースがすべて放棄され

25
00:01:13,372 --> 00:01:15,265
たにもかかわらず、複数の ビットが反転された場

26
00:01:15,265 --> 00:01:17,240
合に何が起こるかについて強力な保証はありません。

27
00:01:17,980 --> 00:01:19,960
さらに興味深い問題は、スペースをできるだ

28
00:01:19,960 --> 00:01:21,940
け少なくしながらエラ ーを修正できるよう

29
00:01:21,940 --> 00:01:24,020
にするにはどうすればよいかということです。

30
00:01:24,520 --> 00:01:28,235
たとえば、このビデオで説明する方法を使用すると、データを 

31
00:01:28,235 --> 00:01:30,925
256 ビット ブロックに保 存できます。

32
00:01:30,925 --> 00:01:33,360
各ブロックは 9 ビットを使用します。

33
00:01:33,760 --> 00:01:36,446
ある種の冗長性として機能し、残り の 247 

34
00:01:36,446 --> 00:01:39,716
ビットは、必要な意味のあるメッセージやデータを自由に伝送

35
00:01:39,716 --> 00:01:40,300
できます。

36
00:01:40,900 --> 00:01:43,840
そして、ここでビットが反転した場合でも、このブ

37
00:01:43,840 --> 00:01:46,780
ロックだけを見る だけで、マシンはエラーがあっ

38
00:01:46,780 --> 00:01:48,953
たことと、エラーがどこにあったか 

39
00:01:48,953 --> 00:01:52,660
を正確に特定できるため、それを修正する方法がわかります。。

40
00:01:52,660 --> 00:01:54,620
正直に言うと、それは魔法のように感じます。

41
00:01:55,440 --> 00:01:57,068
そして、この特定のスキームでは、2 

42
00:01:57,068 --> 00:01:59,421
つのビットが反転された場合、マシンは少なくとも 2 

43
00:01:59,421 --> 00:02:01,864
つのエラーがあったことを検出できますが、それらを修正す

44
00:02:01,864 --> 00:02:02,860
る方法はわかりません。

45
00:02:03,520 --> 00:02:05,174
さまざまなサイズのブロックに対してこれがどのよ

46
00:02:05,174 --> 00:02:06,900
うに拡張されるかについては、後で少し説明します。

47
00:02:07,860 --> 00:02:10,441
このようなエラーを修正できる方法は、エラ 

48
00:02:10,441 --> 00:02:12,900
ー修正コードとして十分に知られています。

49
00:02:13,660 --> 00:02:16,420
過去 1 世紀の大部分において、この分野は驚く

50
00:02:16,420 --> 00:02:19,180
ほど奥深い数学の実に豊 富な情報源であり、私た

51
00:02:19,180 --> 00:02:21,940
ちが毎日使用するデバイスに組み込まれています。

52
00:02:22,840 --> 00:02:25,809
ここでの目標は、ハミング コードとして知られる最 

53
00:02:25,809 --> 00:02:28,660
も初期の例の 1 つを徹底的に理解することです。

54
00:02:29,520 --> 00:02:33,075
ちなみに、このビデオの構成について私が考えているのは、で 

55
00:02:33,075 --> 00:02:36,509
きるだけ直接説明するというよりも、ところどころに少し優 

56
00:02:36,509 --> 00:02:39,820
しい指導を加えながら、自分で考え出すよう促すことです。

57
00:02:40,120 --> 00:02:42,320
したがって、ある時点でどうなるか分かったと感じ

58
00:02:42,320 --> 00:02:44,520
たら、その瞬間を一時停 止し、私が言う前に計画

59
00:02:44,520 --> 00:02:46,720
がどのようになるかを積極的に予測してください。

60
00:02:47,240 --> 00:02:49,912
また、ハードウェア レベルまで理解してもらいたい場合

61
00:02:49,912 --> 00:02:52,585
は、Ben Eat er がこのビデオと併せて、実際

62
00:02:52,585 --> 00:02:54,641
にブレッドボードにハミング コードを実 

63
00:02:54,641 --> 00:02:56,595
装する方法を示すビデオを作成しました。

64
00:02:56,595 --> 00:02:58,240
これは非常に満足のいくものです。

65
00:02:59,300 --> 00:03:01,035
ハミング コードは、リード ソロモン 

66
00:03:01,035 --> 00:03:03,775
アルゴリズムのような最新のコードほど広く使用されていないこと

67
00:03:03,775 --> 00:03:06,515
を 知っておく必要があります。しかし、このタスクが最初はいか

68
00:03:06,515 --> 00:03:08,524
に不可能に感じられるか、そして一度は完全に 

69
00:03:08,524 --> 00:03:11,264
合理的であるように見えるというコントラストには、ある種の魔法

70
00:03:11,264 --> 00:03:13,000
があります。ハミングについて学びます。

71
00:03:13,720 --> 00:03:16,499
エラー修正の基本原理は、考えられるすべてのメッ

72
00:03:16,499 --> 00:03:19,279
セージの膨大な空間の中で 、一部のサブセットの

73
00:03:19,279 --> 00:03:22,180
みが有効なメッセージとみなされるということです。

74
00:03:22,800 --> 00:03:24,816
例えとして、正しく綴られた単語と間違っ

75
00:03:24,816 --> 00:03:26,940
て綴られた単語について考えてみましょう。

76
00:03:28,900 --> 00:03:31,713
有効なメッセージが変更されるたびに、受信者は、タ

77
00:03:31,713 --> 00:03:34,526
イプミスの場合と同様に、 表示された内容を最も近

78
00:03:34,526 --> 00:03:37,340
い有効な隣接メッセージに修正する責任があります。

79
00:03:38,220 --> 00:03:41,240
ただし、このようなメッセージを効率的に分類するための具体的 

80
00:03:41,240 --> 00:03:44,060
なアルゴリズムを考え出すには、ある程度の賢さが必要です。

81
00:03:46,780 --> 00:03:48,553
物語は 1940 年代に始まります。

82
00:03:48,553 --> 00:03:50,425
当時、若いリチャード・ハミングはベル 

83
00:03:50,425 --> 00:03:53,085
研究所で働いていました。彼の仕事の一部には、アクセスが

84
00:03:53,085 --> 00:03:55,449
制限されていた非 常に大型で高価なパンチカード 

85
00:03:55,449 --> 00:03:57,420
コンピューターの使用が含まれていました。

86
00:03:57,800 --> 00:04:00,284
そして、彼がやり続けたプログラムは失敗し続けました 。

87
00:04:00,284 --> 00:04:02,400
なぜなら、時折、少し読み間違えられるからです。

88
00:04:03,120 --> 00:04:05,831
欲求不満は発明の坩堝であるため、彼はうんざ 

89
00:04:05,831 --> 00:04:08,420
りして世界初の誤り訂正符号を発明しました。

90
00:04:09,060 --> 00:04:11,098
ハミング コードを組み立てるにはさまざま

91
00:04:11,098 --> 00:04:13,137
な方法がありますが、最 初のパスとして、

92
00:04:13,137 --> 00:04:15,380
ハミング自身が考えた方法を試してみましょう。

93
00:04:16,519 --> 00:04:18,781
シンプルではありますが、単純すぎない 16 

94
00:04:18,781 --> 00:04:20,940
ビットのブロックの例を使用してみましょう。

95
00:04:21,820 --> 00:04:23,421
これらのビットの位置に 0 から 

96
00:04:23,421 --> 00:04:24,740
15 までの番号を付けます。

97
00:04:25,620 --> 00:04:28,191
保存したい実際のデータはこれらのビットのうち 

98
00:04:28,191 --> 00:04:30,540
12 ビットのみを構 成し、位置のうちの 

99
00:04:30,540 --> 00:04:33,000
4 つは一種の冗長性として予約されています。

100
00:04:33,900 --> 00:04:35,895
ここでの冗長という言葉は単にコピーを意味するものでは

101
00:04:35,895 --> 00:04:37,507
ありません。結局のところ、こ れらの 4 

102
00:04:37,507 --> 00:04:39,502
ビットではデータをやみくもにコピーするのに十分な余地

103
00:04:39,502 --> 00:04:40,040
がありません。

104
00:04:40,720 --> 00:04:44,061
代わりに、新しい情報を追加するのではなく、回復力を追 

105
00:04:44,061 --> 00:04:47,280
加する、より微妙で賢い種類の冗長性が必要になります。

106
00:04:48,600 --> 00:04:51,355
これら 4 つの特別なビットが、おそらく最後などでうま

107
00:04:51,355 --> 00:04:54,110
くパッケージ化され ることを期待するかもしれませんが、

108
00:04:54,110 --> 00:04:56,048
ご覧のとおり、これらを 2 のべき乗 

109
00:04:56,048 --> 00:04:58,803
の位置に配置することで、最後までに非常にエレガントなも

110
00:04:58,803 --> 00:04:59,620
のが得られます。

111
00:05:00,200 --> 00:05:01,840
また、より大きなブロックに対してこれがどのように拡張され

112
00:05:01,840 --> 00:05:03,540
るかについてのちょっとしたヒントも得られるかもしれません。

113
00:05:04,900 --> 00:05:06,808
また、技術的には、最終的にはわずか 11 

114
00:05:06,808 --> 00:05:09,170
ビットのデータになるため、位置 0 で何が起こって 

115
00:05:09,170 --> 00:05:11,260
いるかについて若干のニュアンスがあることがわか

116
00:05:11,260 --> 00:05:13,260
りますが、今のところは心配しないでください。

117
00:05:14,140 --> 00:05:16,824
他のエラー修正アルゴリズムと同様に、これには 2 

118
00:05:16,824 --> 00:05:19,508
人のプレイヤーが関 与します。送信者はこれら 4 

119
00:05:19,508 --> 00:05:21,656
つの特別なビットを設定する責任を負い、 

120
00:05:21,656 --> 00:05:24,340
受信者は何らかのチェックを実行してエラーを修正する

121
00:05:24,340 --> 00:05:25,200
責任を負います。

122
00:05:25,200 --> 00:05:28,418
もちろん、送信者と受信者という言葉は実際にはすべてのチ 

123
00:05:28,418 --> 00:05:31,636
ェックを行うマシンまたはソフトウェアを指し、メッセージ 

124
00:05:31,636 --> 00:05:34,740
の概念はストレージなどを含む非常に広い意味を指します。

125
00:05:35,340 --> 00:05:37,453
結局のところ、データを保存することは、ある

126
00:05:37,453 --> 00:05:39,566
場所から別の場所へで はなく、過去から未来

127
00:05:39,566 --> 00:05:41,680
へメッセージを送信することと同じことです。

128
00:05:42,560 --> 00:05:45,246
これがセットアップですが、本題に入る前に、ハミングが

129
00:05:45,246 --> 00:05:47,932
発見した当時に 彼の頭の中に新たにあった関連するアイ

130
00:05:47,932 --> 00:05:49,688
デアについて話す必要がありま す。

131
00:05:49,688 --> 00:05:52,374
それは、単一ビットのエラーを検出できるが、修正はでき

132
00:05:52,374 --> 00:05:55,060
ないという 既知の方法です。ビジネスではパリティチェ

133
00:05:55,060 --> 00:05:56,300
ックとして使用されます。

134
00:05:56,880 --> 00:06:00,469
パリティ チェックでは、送信者が調整を担当する 1 つのビ 

135
00:06:00,469 --> 00:06:03,820
ットのみを分離し、残りは自由にメッセージを送信できます。

136
00:06:04,880 --> 00:06:08,080
この特別なビットの唯一の役割は、メッセージ内の 

137
00:06:08,080 --> 00:06:11,280
1 の合計数が偶数であることを確認することです。

138
00:06:12,080 --> 00:06:14,316
たとえば、現時点では 1 の合計数は 7 

139
00:06:14,316 --> 00:06:17,297
で、これは奇数であるため、送信者 はその特別なビットを 

140
00:06:17,297 --> 00:06:19,960
1 に反転してカウントを偶数にする必要があります。

141
00:06:20,800 --> 00:06:23,667
ただし、ブロックがすでに偶数個の 1 で始まって 

142
00:06:23,667 --> 00:06:26,420
いた場合、この特別なビットは 0 に保たれます。

143
00:06:27,340 --> 00:06:30,486
これは非常にシンプルで、一見シンプルですが、メッセー

144
00:06:30,486 --> 00:06:33,633
ジ内のどこかに変更があると いうアイデアを抽出して、

145
00:06:33,633 --> 00:06:36,780
わずかな情報に反映させる非常にエレガントな方法です。

146
00:06:37,500 --> 00:06:40,644
このメッセージのビットが 0 から 1、または 

147
00:06:40,644 --> 00:06:42,871
1 から 0 に反転 すると、1 

148
00:06:42,871 --> 00:06:46,540
の合計数が偶数から奇数に変化することに注意してください。

149
00:06:47,980 --> 00:06:50,301
したがって、あなたが受信者である場合、このメッセ

150
00:06:50,301 --> 00:06:52,623
ージを見て、奇数 の 1 が表示されれば、たとえ

151
00:06:52,623 --> 00:06:54,364
どこでエラーが発生したかは分からな 

152
00:06:54,364 --> 00:06:56,686
くても、何らかのエラーが発生したことを確実に知る

153
00:06:56,686 --> 00:06:57,460
ことができます。

154
00:06:58,500 --> 00:07:01,009
専門用語では、ビットのグループに偶数個の 1 が含まれ 

155
00:07:01,009 --> 00:07:03,340
るか奇数個の 1 が含まれるかをパリティと呼びます。

156
00:07:04,860 --> 00:07:06,650
数値を使用して、パリティが 0 または 1 

157
00:07:06,650 --> 00:07:08,034
であると表現することもできま す。

158
00:07:08,034 --> 00:07:09,987
通常は、その考えに基づいて数学を始めると、この方

159
00:07:09,987 --> 00:07:10,720
がより役立ちます。

160
00:07:11,220 --> 00:07:13,463
送信側がパリティを制御するために使用するこの特 

161
00:07:13,463 --> 00:07:15,520
別なビットは、パリティ ビットと呼ばれます。

162
00:07:17,560 --> 00:07:19,867
実際、明確にしておきたいのは、受信側が奇数のパリティを認

163
00:07:19,867 --> 00:07:21,514
識した場合、それは必ずしも 1 つのエ 

164
00:07:21,514 --> 00:07:23,986
ラーがあったことを意味するわけではなく、3 つのエラー、5 

165
00:07:23,986 --> 00:07:25,469
つのエラー、またはその他の奇数のエ 

166
00:07:25,469 --> 00:07:27,776
ラーがあった可能性がありますが、受信者は確実に知ることが

167
00:07:27,776 --> 00:07:29,260
できます。0ではなかったということ。

168
00:07:29,980 --> 00:07:33,005
一方、2 つのエラーがあった場合、または偶数のエラーがあ

169
00:07:33,005 --> 00:07:36,031
った場合、最終的な 1 のカウントは依然として偶数である

170
00:07:36,031 --> 00:07:38,301
ため、受信側は、偶数のカウントが必ずしも 

171
00:07:38,301 --> 00:07:41,327
メッセージにエラーがないことを意味すると完全に確信するこ

172
00:07:41,327 --> 00:07:42,300
とはできません。。

173
00:07:42,840 --> 00:07:45,960
たった 2 ビットの反転で台無しになるメッセージは非常に弱い

174
00:07:45,960 --> 00:07:49,080
 と不満を言うかもしれませんが、それはまったくその通りです。

175
00:07:49,700 --> 00:07:52,766
ただし、受信したメッセージが送信者が意図したも

176
00:07:52,766 --> 00:07:55,833
のであることを 100 % 確信できるエラー検

177
00:07:55,833 --> 00:07:58,900
出または修正方法はないことに留意してください。

178
00:07:59,580 --> 00:08:01,478
結局のところ、十分なランダム ノイズがあれば、

179
00:08:01,478 --> 00:08:03,376
まったくの偶然で、ある有 効なメッセージが別の

180
00:08:03,376 --> 00:08:05,440
有効なメッセージに常に変更される可能性があります。

181
00:08:06,240 --> 00:08:09,286
代わりに、目標は、特定の最大エラー数まで堅

182
00:08:09,286 --> 00:08:12,333
牢なスキームを考え出 すこと、またはおそら

183
00:08:12,333 --> 00:08:15,380
くこのような誤検知の確率を減らすことです。

184
00:08:16,260 --> 00:08:19,975
パリティ チェック自体は非常に弱いですが、メッセージ全体に 

185
00:08:19,975 --> 00:08:23,691
わたる変更のアイデアを単一のビットにまで絞り出すことで、よ 

186
00:08:23,691 --> 00:08:27,160
り洗練されたスキームのための強力な構成要素を提供します。

187
00:08:27,940 --> 00:08:30,867
たとえば、ハミング氏は、エラーが発生したことだけでなく

188
00:08:30,867 --> 00:08:34,120
、どこでエラーが発生したかを 特定する方法を探していました。

189
00:08:34,120 --> 00:08:37,048
彼の重要な洞察は、メッセージ全体ではなく、慎重に選択 

190
00:08:37,048 --> 00:08:38,891
された特定のサブセットにパリティ 

191
00:08:38,891 --> 00:08:42,036
チェックを適用すると、次のようにできるということ でした。

192
00:08:42,036 --> 00:08:44,421
より洗練された一連の質問により、単一ビット 

193
00:08:44,421 --> 00:08:45,940
エラーの位置が特定されます。

194
00:08:46,680 --> 00:08:48,847
全体的な感覚は、可能性の空間を半分に切り取る

195
00:08:48,847 --> 00:08:51,113
「はい」または「いいえ」 の質問をする 20 

196
00:08:51,113 --> 00:08:53,380
の質問のゲームをプレイしているようなものです。

197
00:08:54,160 --> 00:08:56,819
たとえば、これらの 8 ビット、すべての奇数番号の位 

198
00:08:56,819 --> 00:08:59,380
置についてのみパリティ チェックを実行するとします。

199
00:09:00,100 --> 00:09:02,777
その後、エラーが検出された場合、エラーが具体的にど

200
00:09:02,777 --> 00:09:05,455
こにあるのか、つまり、エラ ーが奇数の位置にあるこ

201
00:09:05,455 --> 00:09:08,240
とに関するもう少し詳しい情報が受信機に提供されます。

202
00:09:08,940 --> 00:09:12,656
これらの 8 ビットでエラーが検出されない場合は、エラ 

203
00:09:12,656 --> 00:09:16,240
ーがまったくないか、偶数の位置にあることを意味します。

204
00:09:17,180 --> 00:09:20,520
パリティ チェックをビットの半分に制限すると効果が薄れると思

205
00:09:20,520 --> 00:09:23,860
 うかもしれませんが、他の適切に選択されたチェックと組み合わ

206
00:09:23,860 --> 00:09:27,200
 せて実行すると、直感に反してさらに強力なものが得られます。

207
00:09:29,240 --> 00:09:31,700
実際にパリティ チェックを設定するには、グル

208
00:09:31,700 --> 00:09:34,160
ープ全体のパリティを制 御する特別なビットを

209
00:09:34,160 --> 00:09:36,620
割り当てる必要があることに注意してください。

210
00:09:37,480 --> 00:09:39,180
ここでは位置 1 を選択しましょう。

211
00:09:39,720 --> 00:09:41,343
示されている例では、これらの 8 

212
00:09:41,343 --> 00:09:43,445
ビットのパリティは現在奇数であるため、送信 

213
00:09:43,445 --> 00:09:45,833
側はそのパリティ ビットを切り替える必要があり、現

214
00:09:45,833 --> 00:09:46,980
在は偶数になっています。

215
00:09:47,940 --> 00:09:49,349
これは、実行する 4 つのパリティ 

216
00:09:49,349 --> 00:09:50,680
チェックのうちの 1 つだけです。

217
00:09:50,920 --> 00:09:53,662
2 番目のチェックは、少なくともここで描画したよう 

218
00:09:53,662 --> 00:09:56,300
に、グリッドの右半分の 8 ビットの中にあります。

219
00:09:56,680 --> 00:09:59,771
今回は位置 2 をパリティ ビットとして使用する可能性があ

220
00:09:59,771 --> 00:10:01,476
るため、これらの 8 ビットに 

221
00:10:01,476 --> 00:10:04,247
はすでに偶数パリティがあり、送信者はビット番号 2 

222
00:10:04,247 --> 00:10:06,060
を変更しないままで問題ありません。

223
00:10:07,020 --> 00:10:09,806
次に、反対側で、受信側がこのグループのパリティをチェ

224
00:10:09,806 --> 00:10:12,593
ックし、それが奇数であるこ とが判明した場合、エラー

225
00:10:12,593 --> 00:10:15,380
が右側の 8 ビットのどこかにあることがわかります。

226
00:10:15,820 --> 00:10:18,200
それ以外の場合は、エラーがないか、左半分

227
00:10:18,200 --> 00:10:20,580
のどこかにエラーがあることを意味します。

228
00:10:21,120 --> 00:10:22,885
あるいは、エラーが 2 つあった可能性もあ

229
00:10:22,885 --> 00:10:25,070
ると思いますが、今のと ころは、ブロック全体で最大 

230
00:10:25,070 --> 00:10:26,500
1 つのエラーがあると仮定します。

231
00:10:26,940 --> 00:10:28,740
それを超えると物事は完全に壊れます。

232
00:10:29,160 --> 00:10:31,518
ここで、次の 2 つのチェックを検討する前に、最初の 

233
00:10:31,518 --> 00:10:33,440
2 つのチェッ クを一緒に考えると何ができる

234
00:10:33,440 --> 00:10:35,100
ようになるのかを少し考えてみましょう。

235
00:10:35,800 --> 00:10:39,660
奇数列と右半分でエラーを検出したとします。

236
00:10:40,200 --> 00:10:41,620
これは必然的に、エラーが最後の列

237
00:10:41,620 --> 00:10:43,040
のどこかにあることを意味します。

238
00:10:43,820 --> 00:10:46,815
奇数列にエラーがなく、右半分にエラーがあった場合は、 

239
00:10:46,815 --> 00:10:49,700
それが最後から 2 番目の列にあることがわかります。

240
00:10:50,440 --> 00:10:53,555
同様に、奇数列にエラーがあり、右半分にはエラーがない場 

241
00:10:53,555 --> 00:10:56,560
合は、2 列目のどこかにエラーがあることがわかります。

242
00:10:56,560 --> 00:10:58,746
これら 2 つのパリティ チェックのどちらでも何も

243
00:10:58,746 --> 00:11:00,933
検出されなかった場合、エ ラーが存在する可能性があ

244
00:11:00,933 --> 00:11:03,120
る唯一の場所はその左端の列であることを意味します。

245
00:11:03,340 --> 00:11:04,685
ただし、単にエラーがまったくな

246
00:11:04,685 --> 00:11:06,120
いことを意味する場合もあります。

247
00:11:06,300 --> 00:11:08,618
これは、2 つのパリティ チェックによって列を 

248
00:11:08,618 --> 00:11:10,840
特定できると言うための、かなり面倒な方法です。

249
00:11:11,480 --> 00:11:13,640
ここから、おそらく次のことが推測できるでしょう。

250
00:11:13,800 --> 00:11:16,140
行について以外は基本的に同じことを行います。

251
00:11:16,440 --> 00:11:18,670
位置 4 をパリティ ビットとして使用して

252
00:11:18,670 --> 00:11:20,900
、奇数行のパリティ チェックが行われます。

253
00:11:21,380 --> 00:11:23,679
したがって、この例では、そのグループはすでに偶数パリティ 

254
00:11:23,679 --> 00:11:25,820
を持っているため、ビット 4 は 0 に設定されます。

255
00:11:26,560 --> 00:11:29,170
最後に、位置 8 をパリティ ビットとして使用して 

256
00:11:29,170 --> 00:11:31,580
、下位 2 行のパリティ チェックが行われます。

257
00:11:32,120 --> 00:11:34,516
この場合、グループに偶数パリティを与えるために、送 

258
00:11:34,516 --> 00:11:36,820
信者はビット 8 をオンにする必要があるようです。

259
00:11:37,700 --> 00:11:39,852
最初の 2 つのチェックで列を特定できるのと同じよ 

260
00:11:39,852 --> 00:11:41,840
うに、次の 2 つのチェックで行を特定できます。

261
00:11:42,880 --> 00:11:45,210
例として、送信中に、たとえば位置 3 

262
00:11:45,210 --> 00:11:47,540
でエラーが発生したと想像してください。

263
00:11:48,180 --> 00:11:50,435
これは最初のパリティ グループに影響し、2 

264
00:11:50,435 --> 00:11:52,895
番目のパリティ グループにも 影響するため、受信

265
00:11:52,895 --> 00:11:55,560
側は右側の列のどこかにエラーがあることがわかります。

266
00:11:56,100 --> 00:11:58,723
しかし、それは 3 番目のグループには影響せず、4 

267
00:11:58,723 --> 00:12:00,540
番目のグループにも影響を与えません。

268
00:12:01,240 --> 00:12:03,856
これにより、受信側は最初の行 (必然的に位置 3 

269
00:12:03,856 --> 00:12:06,996
を意味しま す) までのエラーを特定できるため、エラーを修正

270
00:12:06,996 --> 00:12:07,520
できます。

271
00:12:08,580 --> 00:12:10,664
これら 4 つの質問への答えによって、たとえそ

272
00:12:10,664 --> 00:12:12,930
れがどこであったとしても、常に特定の場所を突き止 

273
00:12:12,930 --> 00:12:15,015
めることができるということを、少し時間をかけて

274
00:12:15,015 --> 00:12:17,100
自分に納得させてみるのも楽しいかもしれません。

275
00:12:17,720 --> 00:12:20,501
実際、賢明な方は、これらの質問と二進数の数え方と 

276
00:12:20,501 --> 00:12:23,060
の間に関連性があることに気づくかもしれません。

277
00:12:23,500 --> 00:12:26,259
もしそうなら、私が台無しにする前に、もう一度強調して、 

278
00:12:26,259 --> 00:12:28,920
立ち止まって、自分でそのつながりを描いてみてください。

279
00:12:30,500 --> 00:12:33,412
パリティ ビット自体が影響を受けるとどうな 

280
00:12:33,412 --> 00:12:36,060
るか気になる場合は、試してみてください。

281
00:12:36,440 --> 00:12:39,020
これら 4 つの特別なビットのエラーが、他のもの

282
00:12:39,020 --> 00:12:41,599
と同じように、同じ 4 つの質問グループを使用し

283
00:12:41,599 --> 00:12:44,180
てどのように追跡されるのかを少し考えてください。

284
00:12:47,060 --> 00:12:48,872
結局のところ、私たちが望んでいるのはメッセージ 

285
00:12:48,872 --> 00:12:50,155
ビットを保護することであり、エラ 

286
00:12:50,155 --> 00:12:52,118
ー訂正ビットはそのまま使われているだけなので、これは

287
00:12:52,118 --> 00:12:53,100
あまり問題ではありません。

288
00:12:53,600 --> 00:12:55,764
しかし、これらのビットも保護することは 

289
00:12:55,764 --> 00:12:57,820
、副産物として自然に計画から外れます。

290
00:12:59,200 --> 00:13:00,480
これがどのようにスケールされるかを

291
00:13:00,480 --> 00:13:01,760
予想するのも楽しいかもしれません。

292
00:13:02,300 --> 00:13:04,891
たとえば、場所を特定するためにサイズ 256 

293
00:13:04,891 --> 00:13:07,596
ビットのブロックを使用した場合、特定の場所にた 

294
00:13:07,596 --> 00:13:09,962
どり着くまでにバイナリ検索を行うには、8 

295
00:13:09,962 --> 00:13:12,780
つの「はい」または「いいえ」の質問だけが必要です。

296
00:13:15,640 --> 00:13:18,069
各質問では、適切なパリティ チェックを設定するために 1 

297
00:13:18,069 --> 00:13:20,500
ビットだけを放棄する必要があることを覚えておいてください。

298
00:13:23,160 --> 00:13:25,195
すでにご覧になっている方もいるかもしれません

299
00:13:25,195 --> 00:13:26,954
が、これらの質問の内容を 1 ～ 2 

300
00:13:26,954 --> 00:13:29,360
分で見つける体系的な方法については後ほど説明します。

301
00:13:29,880 --> 00:13:31,637
このスケッチが、ここで開発しているものの効率性を理 

302
00:13:31,637 --> 00:13:33,260
解していただくのに十分であることを願っています。

303
00:13:33,260 --> 00:13:36,351
最初のものは、強調表示されている 8 つのパリティ 

304
00:13:36,351 --> 00:13:39,204
ビットを除いて、任意 のものにすることができ、必

305
00:13:39,204 --> 00:13:41,820
要なメッセージやデータを運ぶことができます。

306
00:13:41,820 --> 00:13:44,553
8 ビットはメッセージの残りの部分によって完全に

307
00:13:44,553 --> 00:13:47,286
決定されるという意味で冗 長ですが、メッセージ全

308
00:13:47,286 --> 00:13:50,020
体を単にコピーするよりもはるかに賢明な方法です。

309
00:13:53,600 --> 00:13:56,038
それでも、ほとんど諦めずに、どんなシングルビット 

310
00:13:56,038 --> 00:13:58,380
エラーでも特定して修正することができるでしょう。

311
00:13:59,200 --> 00:14:00,400
よくほとんど。

312
00:14:00,960 --> 00:14:03,575
さて、ここでの 1 つの問題は、4 つのパリティ 

313
00:14:03,575 --> 00:14:06,190
チェックのいずれもエラーを 検出しなかった場合、つ

314
00:14:06,190 --> 00:14:08,700
まり、送信者の意図どおり、特別に選択された 8 

315
00:14:08,700 --> 00:14:11,315
ビッ トのサブセットがすべて偶数パリティを持つこと

316
00:14:11,315 --> 00:14:13,094
を意味し、それはエラーがまったく 

317
00:14:13,094 --> 00:14:14,977
なかったことを意味するかどうかです。

318
00:14:14,977 --> 00:14:16,860
、または位置 0 に絞り込まれます。

319
00:14:17,740 --> 00:14:20,173
ご覧のとおり、はいまたはいいえの質問が 4 

320
00:14:20,173 --> 00:14:22,496
つあるため、パリティ チェックには 16 

321
00:14:22,496 --> 00:14:25,483
の可能な結果があり、ブロック内の 16 の位置のうち 

322
00:14:25,483 --> 00:14:28,691
1 つを正確に特定するには最初 は完璧に思えますが、17 

323
00:14:28,691 --> 00:14:31,900
番目の結果、つまりエラーなしを伝える必要もあります。状態。

324
00:14:33,020 --> 00:14:35,324
ここでの解決策は実際には非常に簡単で、0 

325
00:14:35,324 --> 00:14:37,300
番目のビットを完全に忘れるだけです。

326
00:14:37,840 --> 00:14:39,686
したがって、4 つのパリティ チェックを実行し

327
00:14:39,686 --> 00:14:41,533
、それらがすべて偶数であ ることが確認できれば

328
00:14:41,533 --> 00:14:43,460
、それは間違いなくエラーがないことを意味します。

329
00:14:44,240 --> 00:14:45,533
これが意味するのは、16 ビット 

330
00:14:45,533 --> 00:14:47,055
ブロックを扱うのではなく、15 ビット 

331
00:14:47,055 --> 00:14:49,186
ブロックを扱うということです。この場合、ビッ トのうち 

332
00:14:49,186 --> 00:14:51,393
11 ビットがメッセージを伝送するために自由に使用され、そ

333
00:14:51,393 --> 00:14:53,220
のうちの 4 ビットは冗長性のために存在します。

334
00:14:53,780 --> 00:14:56,755
これにより、業界の人々が 15-11 

335
00:14:56,755 --> 00:15:00,200
ハ ミング コードと呼ぶものが完成しました。

336
00:15:00,460 --> 00:15:02,333
そうは言っても、ブロック サイズが 2 

337
00:15:02,333 --> 00:15:04,768
のきれいな累乗であるのは良いことであり、そ の 0 

338
00:15:04,768 --> 00:15:07,297
番目のビットを保持して、それに少し追加の作業をさせる賢

339
00:15:07,297 --> 00:15:08,140
い方法があります。

340
00:15:08,700 --> 00:15:10,510
これをブロック全体にわたるパリティ 

341
00:15:10,510 --> 00:15:12,220
ビットとして使用すると、修正はで 

342
00:15:12,220 --> 00:15:13,829
きなくても、実際に 2 ビット 

343
00:15:13,829 --> 00:15:15,540
エラーを検出できるようになります。

344
00:15:16,160 --> 00:15:16,820
仕組みは次のとおりです。

345
00:15:17,180 --> 00:15:19,702
これら 4 つの特別なエラー訂正ビットを設定した後、

346
00:15:19,702 --> 00:15:22,223
通常のパリティ チェックと同 様に、ブロック全体のパ

347
00:15:22,223 --> 00:15:24,940
リティが偶数になるように 0 番目のビットを設定します。

348
00:15:25,700 --> 00:15:28,333
ここで、単一ビット エラーがある場合、ブロック全体のパ

349
00:15:28,333 --> 00:15:30,186
リティが奇数に切り替わりま すが、4 

350
00:15:30,186 --> 00:15:32,819
つのエラー修正チェックのおかげで、いずれにせよそれをキ

351
00:15:32,819 --> 00:15:33,600
ャッチできます。

352
00:15:34,160 --> 00:15:36,887
ただし、エラーが 2 つある場合、全体のパリティは

353
00:15:36,887 --> 00:15:39,288
偶数に戻りますが 、受信側では、これら 4 

354
00:15:39,288 --> 00:15:41,579
つのパリティ チェックで何が起こっている 

355
00:15:41,579 --> 00:15:44,307
かにより、少なくとも何らかのエラーが発生しているこ

356
00:15:44,307 --> 00:15:45,180
とがわかります。

357
00:15:45,180 --> 00:15:47,686
そのため、全体としては偶数パリティであるにもかかわらず、他

358
00:15:47,686 --> 00:15:50,193
のチェックでゼロ以外の何かが 発生していることに気付いた場

359
00:15:50,193 --> 00:15:52,700
合は、少なくとも 2 つのエラーがあったことがわかります。

360
00:15:53,520 --> 00:15:54,000
それは賢明ではないでしょうか？

361
00:15:54,300 --> 00:15:56,548
これらの 2 ビット エラーを修正すること

362
00:15:56,548 --> 00:15:58,368
はできませんが、少し面 倒な 0 

363
00:15:58,368 --> 00:16:01,260
番目のビットを動作に戻すだけで、エラーを検出できます。

364
00:16:02,260 --> 00:16:04,036
これは非常に標準的なもので、拡張ハミング 

365
00:16:04,036 --> 00:16:05,220
コードとして知られています。

366
00:16:06,540 --> 00:16:08,653
技術的に言えば、少なくとも 16 ビット 

367
00:16:08,653 --> 00:16:10,464
ブロックの例について は、ハミング 

368
00:16:10,464 --> 00:16:12,880
コードが何を行うかについて完全に説明できました。

369
00:16:12,880 --> 00:16:15,693
ただし、最初から最後まで 1 つの完全な例を

370
00:16:15,693 --> 00:16:18,506
自分で実行して、理解度 を確認し、ここまでの

371
00:16:18,506 --> 00:16:21,320
すべてを定着させる方が満足できると思います。

372
00:16:22,080 --> 00:16:23,190
ただし、私はあなたと一緒にそれを段階的に確認し

373
00:16:23,190 --> 00:16:24,300
ていきますので、あなた自身を確認してください。

374
00:16:25,120 --> 00:16:27,480
メッセージを設定するには、それが空間を介して変換

375
00:16:27,480 --> 00:16:29,840
するリテラル メ ッセージであっても、長期間保存

376
00:16:29,840 --> 00:16:32,594
したいデータであっても、最初のステ ップはメッセージを 

377
00:16:32,594 --> 00:16:34,660
11 ビットのチャンクに分割することです。

378
00:16:35,580 --> 00:16:37,616
各チャンクは、エラー耐性のある 16 

379
00:16:37,616 --> 00:16:39,760
ビット ブロックにパッケージ化されます。

380
00:16:39,760 --> 00:16:43,220
では、これを例として実際にやってみましょう。

381
00:16:43,740 --> 00:16:44,740
さあ、実際にやってみましょう！

382
00:16:44,740 --> 00:16:47,020
立ち止まってこのブロックを組み立ててみましょう。

383
00:16:52,720 --> 00:16:53,680
はい、準備はできましたか？

384
00:16:54,240 --> 00:16:57,266
位置 0 と他の 2 の累乗はエラー訂正義務のため

385
00:16:57,266 --> 00:17:00,898
に予約されているので、残 りのすべてのスポットにメッセージ 

386
00:17:00,898 --> 00:17:03,320
ビットを順番に配置することから始めます。

387
00:17:05,339 --> 00:17:07,673
このグループには偶数パリティが必要ですが、す

388
00:17:07,673 --> 00:17:10,218
でにそうされているため 、位置 1 のパリティ 

389
00:17:10,218 --> 00:17:12,339
ビットを 0 に設定する必要があります。

390
00:17:13,020 --> 00:17:15,551
次のグループは奇数パリティで始まるため、そのパリ 

391
00:17:15,551 --> 00:17:17,880
ティ ビットを 1 に設定する必要があります。

392
00:17:19,160 --> 00:17:21,747
その後のグループは奇数パリティで始まるため、やはりそ 

393
00:17:21,747 --> 00:17:24,240
のパリティ ビットを 1 に設定する必要があります。

394
00:17:24,780 --> 00:17:27,545
また、最後のグループにも奇数パリティがあり 

395
00:17:27,545 --> 00:17:30,060
、8 番目のビットを 1 に設定します。

396
00:17:31,300 --> 00:17:34,236
そして最後のステップとして、ブロック全体が偶数パリティを

397
00:17:34,236 --> 00:17:36,753
持つようになりました。これは、 ビット番号 0 

398
00:17:36,753 --> 00:17:38,746
(包括的なパリティ ビット) を 0 

399
00:17:38,746 --> 00:17:40,320
に設定できることを意味します。

400
00:17:41,340 --> 00:17:43,677
したがって、このブロックが送信されると、4 

401
00:17:43,677 --> 00:17:45,908
つの特別なサブセット とブロック全体のパリ

402
00:17:45,908 --> 00:17:48,140
ティはすべて偶数、つまり 0 になります。

403
00:17:48,820 --> 00:17:50,500
演習の 2 番目の部分として、あなたに

404
00:17:50,500 --> 00:17:52,180
受信者の役割を果たしてもらいましょう。

405
00:17:53,480 --> 00:17:55,554
もちろん、それはあなたがこのメッセージが何であるかをま

406
00:17:55,554 --> 00:17:57,628
だ知らないことを意味します。もしかしたら覚えている人も

407
00:17:57,628 --> 00:17:59,780
いるかもしれませんが、まだ覚えていないと仮定しましょう。

408
00:18:00,020 --> 00:18:03,156
私がやろうとしているのは、そのブロック内のビットの 

409
00:18:03,156 --> 00:18:05,689
0、1、また は 2 を変更して、私が何を

410
00:18:05,689 --> 00:18:07,740
したのかを理解してもらうことです。

411
00:18:08,260 --> 00:18:10,810
もう一度立ち止まって、問題を解決してみてください。

412
00:18:18,790 --> 00:18:21,070
さて、受信者として最初のパリティ 

413
00:18:21,070 --> 00:18:23,484
グループをチェックすると、それが偶 

414
00:18:23,484 --> 00:18:26,434
数であることがわかり、存在するエラーは偶数列

415
00:18:26,434 --> 00:18:27,910
にある必要があります。

416
00:18:29,690 --> 00:18:33,495
次のチェックでは奇数が得られ、少なくとも 1 つのエラ 

417
00:18:33,495 --> 00:18:37,030
ーがあることがわかり、この特定の列に絞り込まれます。

418
00:18:38,550 --> 00:18:41,790
3 番目のチェックは均等であり、可能性をさらに切り詰めます。

419
00:18:42,650 --> 00:18:44,917
そして、最後のパリティ チェックは奇妙で、下部

420
00:18:44,917 --> 00:18:47,678
のどこかにエラーがあるこ とがわかりますが、今では位置 

421
00:18:47,678 --> 00:18:49,650
10 にあるはずであることがわかります。

422
00:18:51,490 --> 00:18:54,562
さらに、ブロック全体のパリティは奇数であるため、フリップ 

423
00:18:54,562 --> 00:18:57,530
が 2 回ではなく 1 回であるという確信が得られます。

424
00:18:58,070 --> 00:18:59,970
3 つ以上の場合、すべての賭けは無効になります。

425
00:19:01,310 --> 00:19:05,290
ビット番号 10 を修正した後、修正に使用されなかった 

426
00:19:05,290 --> 00:19:08,560
11 ビットを取り出すと、元のメッセージの関連

427
00:19:08,560 --> 00:19:11,830
セグメントが得られま す。巻き戻して比較すると

428
00:19:11,830 --> 00:19:14,390
、まさに例の開始点と同じになります。

429
00:19:15,710 --> 00:19:18,163
これらすべてを手動で行う方法がわかったので、次は、

430
00:19:18,163 --> 00:19:20,323
このロジックすべての中核部 分を 1 行の 

431
00:19:20,323 --> 00:19:23,170
Python コードで実行する方法を説明したいと思います。

432
00:19:23,870 --> 00:19:26,319
ご存知のとおり、私がまだお伝えしていないのは、このアル

433
00:19:26,319 --> 00:19:28,769
ゴリズムが実際にどれほど洗練 されているか、マシンにエ

434
00:19:28,769 --> 00:19:31,400
ラーの位置を指示させるのがどれほど簡単であるか、体系的に 

435
00:19:31,400 --> 00:19:33,850
スケールを調整する方法、そしてすべてをどのようにフレー

436
00:19:33,850 --> 00:19:36,481
ム化できるかということです。これは、複数の個別のパリティ 

437
00:19:36,481 --> 00:19:38,750
チェックではなく、1 つの操作として実行されます。

438
00:19:39,430 --> 00:19:40,605
私の言いたいことを理解するには、パート 

439
00:19:40,605 --> 00:19:41,310
2 に参加してください。

