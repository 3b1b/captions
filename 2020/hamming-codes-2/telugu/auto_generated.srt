1
00:00:00,000 --> 00:00:02,560
ఇక్కడ అందరూ పార్ట్ 1 నుండి వస్తున్నారని నేను ఊహిస్తున్నాను.

2
00:00:03,060 --> 00:00:07,661
మేము హామింగ్ కోడ్‌ల గురించి మాట్లాడుతున్నాము, చాలా బిట్‌లు అర్థవంతమైన సందేశాన్ని 

3
00:00:07,661 --> 00:00:12,774
కలిగి ఉండే డేటా బ్లాక్‌ను సృష్టించే మార్గం, మరికొన్ని ఒక రకమైన రిడెండెన్సీగా పనిచేస్తాయి, 

4
00:00:12,774 --> 00:00:17,660
ఆ విధంగా ఏదైనా బిట్ తిప్పబడితే, సందేశం బిట్ లేదా రిడెండెన్సీ బిట్, ఈ బ్లాక్‌లో ఏదైనా, 

5
00:00:17,660 --> 00:00:21,240
రిసీవర్ లోపం ఉందని మరియు దాన్ని ఎలా పరిష్కరించాలో గుర్తించగలదు.

6
00:00:21,880 --> 00:00:24,955
బైనరీ శోధన కోసం బహుళ పారిటీ తనిఖీలను ఎలా ఉపయోగించాలి 

7
00:00:24,955 --> 00:00:27,160
అనేది అక్కడ అందించబడిన ప్రాథమిక ఆలోచన.

8
00:00:28,980 --> 00:00:32,010
ఆ వీడియోలో హామింగ్ కోడ్‌లను సాధ్యమైనంత వరకు అందుబాటులో 

9
00:00:32,010 --> 00:00:34,600
ఉంచడం మరియు తిరిగి కనుగొనగలిగేలా చేయడం లక్ష్యం.

10
00:00:35,180 --> 00:00:38,865
సాఫ్ట్‌వేర్ లేదా హార్డ్‌వేర్‌లో దీన్ని అమలు చేయడం గురించి మీరు ఆలోచించడం 

11
00:00:38,865 --> 00:00:43,056
ప్రారంభించినప్పుడు, ఈ కోడ్‌లు నిజంగా ఎంత సొగసైనవో ఆ ఫ్రేమింగ్ వాస్తవానికి తక్కువగా 

12
00:00:43,056 --> 00:00:43,460
ఉంటుంది.

13
00:00:43,920 --> 00:00:46,938
సాధ్యమయ్యే అన్ని ఎర్రర్ లొకేషన్‌లను ట్రాక్ చేసే మరియు ప్రతి 

14
00:00:46,938 --> 00:00:50,259
చెక్‌తో ఆ సమూహాన్ని సగానికి తగ్గించే అల్గారిథమ్‌ను మీరు వ్రాయవలసి 

15
00:00:50,259 --> 00:00:53,480
ఉంటుందని మీరు అనుకోవచ్చు, అయితే ఇది నిజానికి దాని కంటే సరళమైనది.

16
00:00:53,940 --> 00:00:58,236
మేము చివరి వీడియోలో చేసిన నాలుగు సమానత్వ తనిఖీలకు సమాధానాలను మీరు చదివితే, 

17
00:00:58,236 --> 00:01:03,335
అవును మరియు సంఖ్యలకు బదులుగా 1 సె మరియు 0 సె, ఇది బైనరీలో లోపం యొక్క స్థానాన్ని అక్షరాలా 

18
00:01:03,335 --> 00:01:04,080
వివరిస్తుంది.

19
00:01:04,780 --> 00:01:08,190
ఉదాహరణకు, బైనరీలో 7 సంఖ్య 0111 లాగా కనిపిస్తుంది, 

20
00:01:08,190 --> 00:01:11,260
ముఖ్యంగా ఇది 4 ప్లస్ 2 ప్లస్ 1 అని చెబుతోంది.

21
00:01:12,540 --> 00:01:16,756
మరియు స్థానం 7 ఎక్కడ కూర్చుందో గమనించండి, ఇది మా సమానత్వ సమూహాలలో 

22
00:01:16,756 --> 00:01:21,740
మొదటిదానిని ప్రభావితం చేస్తుంది మరియు రెండవది మరియు మూడవది, కానీ చివరిది కాదు.

23
00:01:22,220 --> 00:01:24,934
కాబట్టి ఆ నాలుగు చెక్‌ల ఫలితాలను దిగువ నుండి పైకి 

24
00:01:24,934 --> 00:01:27,540
చదవడం నిజంగా లోపం యొక్క స్థితిని తెలియజేస్తుంది.

25
00:01:28,320 --> 00:01:31,798
ఉదాహరణ 7 గురించి ప్రత్యేకంగా ఏమీ లేదు, ఇది సాధారణంగా పని చేస్తుంది మరియు ఇది 

26
00:01:31,798 --> 00:01:35,820
హార్డ్‌వేర్‌లో మొత్తం పథకాన్ని అమలు చేయడానికి తర్కాన్ని దిగ్భ్రాంతికరంగా సులభం చేస్తుంది.

27
00:01:37,240 --> 00:01:40,626
ఇప్పుడు మీరు ఈ మాయాజాలం ఎందుకు జరుగుతుందో చూడాలనుకుంటే, 

28
00:01:40,626 --> 00:01:43,590
మా స్థానాల కోసం ఈ 16 సూచిక లేబుల్‌లను తీసుకోండి, 

29
00:01:43,590 --> 00:01:47,460
కానీ వాటిని బేస్ 10లో వ్రాయడానికి బదులుగా, 0000 నుండి 1111 వరకు 

30
00:01:47,460 --> 00:01:49,880
నడుస్తున్న బైనరీలో అన్నింటినీ వ్రాస్దాం.

31
00:01:50,559 --> 00:01:53,655
మేము ఈ బైనరీ లేబుల్‌లను వాటి పెట్టెల్లోకి తిరిగి ఉంచినప్పుడు, 

32
00:01:53,655 --> 00:01:57,800
అవి వాస్తవానికి పంపబడుతున్న డేటా నుండి విభిన్నంగా ఉన్నాయని నేను నొక్కిచెబుతున్నాను.

33
00:01:58,320 --> 00:02:00,990
నాలుగు సమానత్వ సమూహాలు ఎక్కడ నుండి వచ్చాయో అర్థం చేసుకోవడంలో మీకు 

34
00:02:00,990 --> 00:02:03,500
మరియు నాకు సహాయం చేయడానికి అవి సంభావిత లేబుల్ తప్ప మరేమీ కాదు.

35
00:02:04,140 --> 00:02:07,991
మనం చూస్తున్న ప్రతిదీ బైనరీలో వర్ణించబడటం యొక్క సొగసైనది బహుశా మనం 

36
00:02:07,991 --> 00:02:12,360
చూస్తున్న ప్రతిదాన్ని బైనరీలో వివరించడం వల్ల కలిగే గందరగోళం వల్ల తగ్గుతుంది.

37
00:02:13,020 --> 00:02:14,120
అయితే ఇది విలువైనదే.

38
00:02:14,800 --> 00:02:19,823
ఈ లేబుల్‌లన్నింటిలో చివరి బిట్‌పై మాత్రమే మీ దృష్టిని కేంద్రీకరించండి, 

39
00:02:19,823 --> 00:02:23,220
ఆపై ఆ చివరి బిట్ 1 ఉన్న స్థానాలను హైలైట్ చేయండి.

40
00:02:24,240 --> 00:02:27,761
మేము పొందేది మా నాలుగు సమానత్వ సమూహాలలో మొదటిది, 

41
00:02:27,761 --> 00:02:33,655
అంటే మీరు ఆ మొదటి చెక్‌ని అడుగుతున్నట్లు అర్థం చేసుకోవచ్చు, హే, లోపం ఉన్నట్లయితే, 

42
00:02:33,655 --> 00:02:35,740
ఆ లోపం యొక్క స్థానం 1గా ఉందా?

43
00:02:38,200 --> 00:02:41,277
అదేవిధంగా, మీరు రెండవ నుండి చివరి బిట్‌పై దృష్టి సారించి, 

44
00:02:41,277 --> 00:02:45,098
అది 1 ఉన్న అన్ని స్థానాలను హైలైట్ చేస్తే, మీరు మా పథకం నుండి రెండవ సమాన 

45
00:02:45,098 --> 00:02:46,160
సమూహాన్ని పొందుతారు.

46
00:02:46,740 --> 00:02:50,984
మరో మాటలో చెప్పాలంటే, ఆ రెండవ చెక్ అడుగుతోంది, హే, నన్ను మళ్లీ, 

47
00:02:50,984 --> 00:02:54,500
లోపం ఉంటే, ఆ స్థానం యొక్క రెండవ నుండి చివరి బిట్ 1నా?

48
00:02:55,760 --> 00:02:56,900
మరియు అందువలన న.

49
00:02:57,220 --> 00:03:02,877
మూడవ పారిటీ చెక్ మూడవ నుండి చివరి బిట్ ఆన్ చేయబడిన ప్రతి స్థానాన్ని కవర్ చేస్తుంది 

50
00:03:02,877 --> 00:03:08,740
మరియు చివరిది చివరి ఎనిమిది స్థానాలను కవర్ చేస్తుంది, అత్యధిక ఆర్డర్ బిట్ 1గా ఉంటుంది.

51
00:03:09,740 --> 00:03:14,320
మేము ఇంతకు ముందు చేసినవన్నీ ఈ నాలుగు ప్రశ్నలకు సమాధానమివ్వడం వలెనే ఉంటాయి, 

52
00:03:14,320 --> 00:03:17,740
ఇది బైనరీలో ఒక స్థానాన్ని స్పెల్లింగ్ చేయడం వలె ఉంటుంది.

53
00:03:19,620 --> 00:03:21,480
ఇది రెండు విషయాలను స్పష్టం చేస్తుందని నేను ఆశిస్తున్నాను.

54
00:03:22,040 --> 00:03:24,463
మొదటిది రెండు పెద్ద శక్తులు ఉండే పరిమాణాలను బ్లాక్ 

55
00:03:24,463 --> 00:03:26,460
చేయడానికి క్రమపద్ధతిలో సాధారణీకరించడం ఎలా.

56
00:03:26,960 --> 00:03:30,130
64 స్పాట్‌లను వివరించడానికి ఆరు బిట్‌ల వంటి ప్రతి స్థానాన్ని 

57
00:03:30,130 --> 00:03:33,509
వివరించడానికి మరిన్ని బిట్‌లు తీసుకుంటే, ఆ బిట్‌లలో ప్రతి ఒక్కటి 

58
00:03:33,509 --> 00:03:36,680
మేము తనిఖీ చేయాల్సిన సమాన సమూహాలలో ఒకదాన్ని మీకు అందిస్తుంది.

59
00:03:38,400 --> 00:03:43,180
మీలో మాట్ పార్కర్‌తో నేను చేసిన చదరంగం పజిల్‌ని చూసిన వారికి ఇవన్నీ బాగా తెలిసి ఉండవచ్చు.

60
00:03:43,660 --> 00:03:46,362
ఇది అదే ప్రధాన తర్కం, కానీ వేరొక సమస్యను పరిష్కరిస్తుంది 

61
00:03:46,362 --> 00:03:48,780
మరియు 64-స్క్వేర్డ్ చెస్‌బోర్డ్‌కు వర్తించబడుతుంది.

62
00:03:49,880 --> 00:03:52,836
ఇది స్పష్టం చేస్తుందని నేను ఆశిస్తున్న రెండవ విషయం ఏమిటంటే, 

63
00:03:52,836 --> 00:03:56,679
మా సమానత్వ బిట్‌లు రెండు శక్తులైన స్థానాల్లో ఎందుకు కూర్చున్నాయో, ఉదాహరణకు 1, 

64
00:03:56,679 --> 00:03:57,320
2, 4 మరియు 8.

65
00:03:58,000 --> 00:04:03,000
బైనరీ ప్రాతినిధ్యం కేవలం ఒక్క బిట్ మాత్రమే ఆన్ చేసిన స్థానాలు ఇవి.

66
00:04:03,600 --> 00:04:06,813
దాని అర్థం ఏమిటంటే, ఆ పారిటీ బిట్‌లలో ప్రతి ఒక్కటి 

67
00:04:06,813 --> 00:04:09,460
నాలుగు సమాన సమూహాలలో ఒకటి మాత్రమే ఉంటుంది.

68
00:04:12,040 --> 00:04:15,846
మీరు దీన్ని పెద్ద ఉదాహరణలలో కూడా చూడవచ్చు, ఇక్కడ మీరు ఎంత పెద్దదైనా సరే, 

69
00:04:15,846 --> 00:04:19,339
ప్రతి పారిటీ బిట్ సౌకర్యవంతంగా సమూహాలలో ఒకదానిని మాత్రమే తాకుతుంది.

70
00:04:25,600 --> 00:04:30,034
మేము మా సమయాన్ని ఎక్కువగా కేంద్రీకరించిన ఈ సమానత్వ తనిఖీలు బైనరీలో లోపం యొక్క స్థానాన్ని 

71
00:04:30,034 --> 00:04:33,921
వివరించడానికి ఒక తెలివైన మార్గం తప్ప మరేమీ కాదని మీరు అర్థం చేసుకున్న తర్వాత, 

72
00:04:33,921 --> 00:04:38,007
మేము హామింగ్ గురించి ఆలోచించడానికి వేరొక మార్గంతో కనెక్షన్‌ని పొందవచ్చు. కోడ్‌లు, 

73
00:04:38,007 --> 00:04:42,143
ఇది నిస్సందేహంగా చాలా సరళమైనది మరియు మరింత సొగసైనది మరియు ఇది ప్రాథమికంగా ఒకే లైన్ 

74
00:04:42,143 --> 00:04:43,240
కోడ్‌తో వ్రాయబడుతుంది.

75
00:04:43,660 --> 00:04:45,500
ఇది XOR ఫంక్షన్‌పై ఆధారపడి ఉంటుంది.

76
00:04:46,940 --> 00:04:50,220
XOR, మీలో తెలియని వారికి, ప్రత్యేకమైనది లేదా.

77
00:04:50,780 --> 00:04:54,735
మీరు రెండు బిట్‌ల XORను తీసుకున్నప్పుడు, ఆ బిట్‌లలో ఒకదానిని ఆన్ 

78
00:04:54,735 --> 00:04:59,360
చేసినట్లయితే అది 1ని తిరిగి ఇస్తుంది, కానీ రెండూ ఆన్ లేదా ఆఫ్ చేయబడితే కాదు.

79
00:05:00,100 --> 00:05:02,980
విభిన్నంగా పదబంధం, ఇది ఈ రెండు బిట్‌ల సమానత్వం.

80
00:05:03,540 --> 00:05:06,760
గణిత వ్యక్తిగా, నేను దాని గురించి అదనపు మోడ్ 2గా ఆలోచించాలనుకుంటున్నాను.

81
00:05:07,360 --> 00:05:10,800
మేము సాధారణంగా రెండు వేర్వేరు బిట్ స్ట్రింగ్‌ల XOR గురించి మాట్లాడుతాము, 

82
00:05:10,800 --> 00:05:13,440
ఇది ప్రాథమికంగా ఈ కాంపోనెంట్‌ను కాంపోనెంట్‌గా చేస్తుంది.

83
00:05:13,680 --> 00:05:15,720
ఇది అదనంగా వంటిది, కానీ మీరు ఎక్కడికి తీసుకెళ్లలేరు.

84
00:05:16,500 --> 00:05:19,325
మళ్ళీ, గణితశాస్త్రపరంగా ఎక్కువ మొగ్గు ఉన్నవారు దీనిని రెండు 

85
00:05:19,325 --> 00:05:22,480
వెక్టర్‌లను జోడించడం మరియు మోడ్ 2ను తగ్గించడం వంటిదిగా భావించవచ్చు.

86
00:05:23,500 --> 00:05:28,104
మీరు ప్రస్తుతం కొన్ని పైథాన్‌ని తెరిచి, రెండు పూర్ణాంకాల మధ్య కేరెట్ ఆపరేషన్‌ను 

87
00:05:28,104 --> 00:05:32,940
వర్తింపజేస్తే, ఇది హుడ్ కింద ఉన్న ఆ సంఖ్యల బిట్ రిప్రజెంటేషన్‌లకు మాత్రమే చేస్తుంది.

88
00:05:34,960 --> 00:05:41,226
మీకు మరియు నాకు ముఖ్యమైన అంశం ఏమిటంటే, అనేక విభిన్న బిట్ స్ట్రింగ్‌ల యొక్క XOR తీసుకోవడం 

89
00:05:41,226 --> 00:05:47,140
అనేది నిలువు వరుసల మాదిరిగానే, ప్రత్యేక సమూహాల యొక్క పేరడీలను గణించడానికి ఒక మార్గం.

90
00:05:51,260 --> 00:05:55,112
ఇది మా హామింగ్ కోడ్ అల్గారిథమ్ నుండి బహుళ పారిటీ చెక్‌ల గురించి ఆలోచించడానికి చాలా 

91
00:05:55,112 --> 00:05:58,780
చురుకైన మార్గాన్ని అందిస్తుంది, ఎందుకంటే అన్నీ ఒకే ఆపరేషన్‌లో ప్యాక్ చేయబడతాయి.

92
00:05:59,479 --> 00:06:02,180
మొదటి చూపులో ఇది చాలా భిన్నంగా కనిపించినప్పటికీ.

93
00:06:02,820 --> 00:06:08,046
ప్రత్యేకంగా బైనరీలో 16 స్థానాలను వ్రాయండి, మనం ఇంతకు ముందు ఉన్నట్లుగా, 

94
00:06:08,046 --> 00:06:12,536
ఇప్పుడు మెసేజ్ బిట్ 1కి ఆన్ చేయబడిన స్థానాలను హైలైట్ చేయండి, 

95
00:06:12,536 --> 00:06:17,100
ఆపై ఈ స్థానాలను ఒక పెద్ద నిలువు వరుసలో సేకరించి XOR తీసుకోండి.

96
00:06:19,260 --> 00:06:22,664
ఫలితంగా దిగువన కూర్చున్న 4 బిట్‌లు మనకు తెలిసిన మరియు ఇష్టపడే 

97
00:06:22,664 --> 00:06:25,850
4 పారిటీ చెక్‌ల మాదిరిగానే ఉంటాయని మీరు బహుశా ఊహించవచ్చు, 

98
00:06:25,850 --> 00:06:29,200
అయితే సరిగ్గా ఎందుకు అని ఆలోచించడానికి కొంత సమయం కేటాయించండి.

99
00:06:32,220 --> 00:06:36,637
ఈ చివరి నిలువు వరుస, ఉదాహరణకు, చివరి బిట్ 1 ఉన్న అన్ని స్థానాలను గణిస్తోంది, 

100
00:06:36,637 --> 00:06:40,424
కానీ మేము ఇప్పటికే హైలైట్ చేసిన స్థానాలకు మాత్రమే పరిమితం చేసాము, 

101
00:06:40,424 --> 00:06:44,956
కాబట్టి ఇది మొదటి సమూహ సమూహం నుండి ఎన్ని హైలైట్ చేయబడిన స్థానాలను ప్రభావవంతంగా 

102
00:06:44,956 --> 00:06:45,760
లెక్కిస్తుంది.

103
00:06:46,240 --> 00:06:46,800
అది సమంజసమా?

104
00:06:49,080 --> 00:06:53,635
అదేవిధంగా, తదుపరి నిలువు వరుస రెండవ సమాన సమూహంలో ఎన్ని స్థానాలు ఉన్నాయి, 

105
00:06:53,635 --> 00:06:59,064
రెండవ నుండి చివరి బిట్ 1 వరకు ఉన్న స్థానాలు మరియు హైలైట్ చేయబడినవి మరియు మొదలైనవి కూడా 

106
00:06:59,064 --> 00:07:00,000
లెక్కించబడతాయి.

107
00:07:00,260 --> 00:07:03,960
ఇది నిజంగా మనం చేస్తున్న అదే పనిపై దృష్టికోణంలో చిన్న మార్పు.

108
00:07:07,760 --> 00:07:09,600
మరియు అది ఇక్కడ నుండి ఎక్కడికి వెళుతుందో మీకు తెలుసు.

109
00:07:10,000 --> 00:07:12,660
మొత్తం 0000 వరకు పని చేస్తుందని నిర్ధారించుకోవడానికి కొన్ని 

110
00:07:12,660 --> 00:07:15,720
ప్రత్యేక పారిటీ బిట్‌లను టోగుల్ చేయడానికి పంపినవారు బాధ్యత వహిస్తారు.

111
00:07:15,720 --> 00:07:19,547
ఇప్పుడు మనం దీన్ని ఇలా కలిగి ఉంటే, దిగువన ఉన్న ఈ నాలుగు ఫలిత 

112
00:07:19,547 --> 00:07:23,626
బిట్‌లు నేరుగా లోపం యొక్క స్థానాన్ని ఎందుకు వివరిస్తాయి అనే దాని 

113
00:07:23,626 --> 00:07:27,580
గురించి ఆలోచించడానికి ఇది మాకు నిజంగా మంచి మార్గాన్ని ఇస్తుంది.

114
00:07:28,460 --> 00:07:31,860
ఈ బ్లాక్‌లోని కొంత బిట్ 0 నుండి 1కి టోగుల్ చేయబడిందని అనుకుందాం.

115
00:07:32,600 --> 00:07:37,736
దీని అర్థం ఏమిటంటే, ఆ బిట్ యొక్క స్థానం ఇప్పుడు మొత్తం XORలో చేర్చబడుతుంది, 

116
00:07:37,736 --> 00:07:43,820
ఇది మొత్తాన్ని 0 నుండి బదులుగా ఈ కొత్తగా చేర్చబడిన విలువ, లోపం యొక్క స్థానంగా మారుస్తుంది.

117
00:07:44,460 --> 00:07:49,360
కొంచెం తక్కువ స్పష్టంగా, 1 నుండి 0కి మార్చే లోపం ఉన్నట్లయితే అదే నిజం.

118
00:07:50,180 --> 00:07:53,789
మీరు చూడండి, మీరు ఒక బిట్ స్ట్రింగ్‌ని రెండుసార్లు కలిపితే, 

119
00:07:53,789 --> 00:07:57,580
అది అక్కడ లేనట్లే, ప్రాథమికంగా ఈ ప్రపంచంలో 1 ప్లస్ 1 0కి సమానం.

120
00:07:57,580 --> 00:08:00,681
కాబట్టి మొత్తం మొత్తానికి ఈ స్థానం యొక్క కాపీని 

121
00:08:00,681 --> 00:08:04,300
జోడించడం వలన మనం దానిని తరలిస్తున్నట్లే ప్రభావం ఉంటుంది.

122
00:08:05,160 --> 00:08:08,110
మరియు ఆ ప్రభావం, మళ్ళీ, ఇక్కడ దిగువన ఉన్న మొత్తం 

123
00:08:08,110 --> 00:08:10,700
ఫలితం లోపం యొక్క స్థానాన్ని తెలియజేస్తుంది.

124
00:08:13,039 --> 00:08:17,293
ఇది ఎంత సొగసైనదో వివరించడానికి, నేను ఇంతకు ముందు ప్రస్తావించిన పైథాన్ కోడ్‌లోని 

125
00:08:17,293 --> 00:08:21,440
ఒక లైన్‌ను చూపుతాను, ఇది రిసీవర్ చివరన దాదాపు అన్ని లాజిక్‌లను సంగ్రహిస్తుంది.

126
00:08:22,080 --> 00:08:25,836
మేము డేటా బ్లాక్‌ను అనుకరించడానికి 16 1సె మరియు 0 సె యాదృచ్ఛిక శ్రేణిని 

127
00:08:25,836 --> 00:08:29,435
సృష్టించడం ద్వారా ప్రారంభిస్తాము మరియు నేను దానికి బిట్‌లను ఇస్తాను, 

128
00:08:29,435 --> 00:08:33,243
అయితే ఆచరణలో ఇది మనం పంపినవారి నుండి స్వీకరించేదే అవుతుంది మరియు బదులుగా 

129
00:08:33,243 --> 00:08:37,000
యాదృచ్ఛికంగా ఇది 5 పారిటీ బిట్‌లతో కలిపి 11 డేటా బిట్‌లను కలిగి ఉంటుంది.

130
00:08:37,000 --> 00:08:43,953
నేను ఫంక్షన్ enumerateBits అని పిలిస్తే, అది చేసేది ఆ బిట్‌లను సంబంధిత సూచికతో జత చేయడం, 

131
00:08:43,953 --> 00:08:47,000
ఈ సందర్భంలో 0 నుండి 15 వరకు నడుస్తుంది.

132
00:08:48,180 --> 00:08:52,079
కాబట్టి మనం ఈ అన్ని జతలపై లూప్ చేసే జాబితాను సృష్టించినట్లయితే, 

133
00:08:52,079 --> 00:08:56,648
i లాగా కనిపించే జంటలు, ఆపై మేము కేవలం i విలువను, కేవలం సూచికను తీసివేస్తే, 

134
00:08:56,648 --> 00:09:01,340
అది అంత ఉత్తేజకరమైనది కాదు, మేము ఆ సూచికలను 0 నుండి 15 వరకు తిరిగి పొందుతాము.

135
00:09:01,680 --> 00:09:05,957
కానీ మనం దీన్ని బిట్ అయితే మాత్రమే చేయాలనే షరతును జోడిస్తే, 

136
00:09:05,957 --> 00:09:11,519
అంటే ఆ బిట్ 1 మరియు 0 కాకపోతే, అది సంబంధిత బిట్ ఆన్ చేయబడిన స్థానాలను మాత్రమే 

137
00:09:11,519 --> 00:09:12,660
బయటకు తీస్తుంది.

138
00:09:13,380 --> 00:09:20,360
ఈ సందర్భంలో ఆ స్థానాలు 0, 4, 6, 9, మొదలైనవి ఉన్నట్లు కనిపిస్తోంది.

139
00:09:20,720 --> 00:09:25,547
మనకు కావలసినది ఏమిటంటే, ఆ స్థానాలు, ఆన్ చేయబడిన బిట్‌ల స్థానాలు అన్నీ కలిపి, 

140
00:09:25,547 --> 00:09:27,240
ఆపై వాటిని కలిపి XOR చేయడం.

141
00:09:29,180 --> 00:09:33,220
పైథాన్‌లో దీన్ని చేయడానికి, నేను ముందుగా ఒక జంట సహాయక ఫంక్షన్‌లను దిగుమతి చేస్తాను.

142
00:09:33,900 --> 00:09:36,164
ఆ విధంగా మనం ఈ జాబితాలో తగ్గించు() అని పిలుస్తాము 

143
00:09:36,164 --> 00:09:38,700
మరియు దానిని తగ్గించడానికి XOR ఫంక్షన్‌ని ఉపయోగించవచ్చు.

144
00:09:39,100 --> 00:09:42,680
ఇది ప్రాథమికంగా జాబితా ద్వారా దాని మార్గాన్ని తింటుంది, మార్గం వెంట XORలను తీసుకుంటుంది.

145
00:09:44,800 --> 00:09:47,071
మీరు కావాలనుకుంటే, మీరు ఎక్కడి నుండైనా దిగుమతి 

146
00:09:47,071 --> 00:09:49,440
చేయకుండానే ఆ XOR ఫంక్షన్‌ని స్పష్టంగా వ్రాయవచ్చు.

147
00:09:51,940 --> 00:09:56,963
కాబట్టి ప్రస్తుతానికి మనం దీన్ని 16 బిట్‌ల యాదృచ్ఛిక బ్లాక్‌లో చేస్తే, 

148
00:09:56,963 --> 00:10:01,280
అది బైనరీ ప్రాతినిధ్యం 1001ని కలిగి ఉన్న 9ని తిరిగి ఇస్తుంది.

149
00:10:01,980 --> 00:10:06,402
మేము దీన్ని ఇక్కడ చేయము, కానీ పంపినవారు నాలుగు పారిటీ బిట్‌లను అవసరమైన విధంగా సెట్ 

150
00:10:06,402 --> 00:10:10,345
చేయడానికి బైనరీ ప్రాతినిధ్యాన్ని ఉపయోగించే ఒక ఫంక్షన్‌ను మీరు వ్రాయవచ్చు, 

151
00:10:10,345 --> 00:10:15,140
చివరికి ఈ బ్లాక్‌ని బిట్‌ల పూర్తి జాబితాలో ఈ లైన్ కోడ్‌ని అమలు చేసే స్థితికి చేరుకుంటుంది.

152
00:10:15,140 --> 00:10:15,460
 ఒక 0.

153
00:10:16,080 --> 00:10:20,100
ఇది బాగా సిద్ధమైన బ్లాక్‌గా పరిగణించబడుతుంది.

154
00:10:20,100 --> 00:10:23,764
మంచి విషయం ఏమిటంటే, శబ్దం నుండి యాదృచ్ఛిక లోపాన్ని అనుకరిస్తూ, 

155
00:10:23,764 --> 00:10:28,533
ఈ జాబితాలోని ఏదైనా బిట్‌లను మనం టోగుల్ చేస్తే, మీరు ఇదే లైన్ కోడ్‌ను అమలు చేస్తే, 

156
00:10:28,533 --> 00:10:30,220
అది ఆ లోపాన్ని ముద్రిస్తుంది.

157
00:10:30,960 --> 00:10:31,520
అది చక్కగా లేదా?

158
00:10:31,820 --> 00:10:36,526
మీరు ఈ బ్లాక్‌ను నీలిరంగు నుండి పొందవచ్చు, దానిపై ఈ సింగిల్ లైన్‌ను అమలు చేయవచ్చు 

159
00:10:36,526 --> 00:10:41,060
మరియు అది స్వయంచాలకంగా లోపం యొక్క స్థానం లేదా ఏదైనా లేకుంటే 0ని ఉమ్మివేస్తుంది.

160
00:10:42,500 --> 00:10:44,840
మరియు ఇక్కడ పరిమాణం 16 గురించి ప్రత్యేకంగా ఏమీ లేదు.

161
00:10:44,840 --> 00:10:49,860
మీరు 256 బిట్‌ల జాబితాను కలిగి ఉంటే అదే లైన్ కోడ్ పని చేస్తుంది.

162
00:10:51,880 --> 00:10:56,020
2-బిట్ ఎర్రర్‌లను గుర్తించడానికి మెటా పారిటీ చెక్ చేయడం వంటి మరిన్ని 

163
00:10:56,020 --> 00:10:59,200
కోడ్‌లు ఇక్కడ వ్రాయాలని ప్రత్యేకంగా చెప్పనవసరం లేదు, 

164
00:10:59,200 --> 00:11:03,760
అయితే మా స్కీమ్‌లోని దాదాపు అన్ని కోర్ లాజిక్‌లు ఒకే XOR తగ్గింపుకు వస్తాయి.

165
00:11:06,120 --> 00:11:10,416
ఇప్పుడు, బైనరీ మరియు XORలు మరియు సాధారణంగా సాఫ్ట్‌వేర్‌తో మీ సౌకర్యాన్ని బట్టి, 

166
00:11:10,416 --> 00:11:14,713
మీరు ఈ దృక్పథాన్ని కొంచెం గందరగోళంగా లేదా చాలా సొగసైన మరియు సరళంగా కనుగొనవచ్చు, 

167
00:11:14,713 --> 00:11:18,420
మేము దీన్ని ఎందుకు ప్రారంభించలేదని మీరు ఆశ్చర్యపోతున్నారు. -వెళ్ళండి.

168
00:11:19,140 --> 00:11:23,118
వదులుగా చెప్పాలంటే, హార్డ్‌వేర్‌లో హామింగ్ కోడ్‌లను నేరుగా అమలు చేసేటప్పుడు 

169
00:11:23,118 --> 00:11:25,788
బహుళ పారిటీ తనిఖీ దృక్పథం గురించి ఆలోచించడం సులభం, 

170
00:11:25,788 --> 00:11:30,500
మరియు XOR దృక్పథాన్ని సాఫ్ట్‌వేర్‌లో చేసేటప్పుడు, ఉన్నత స్థాయి నుండి ఆలోచించడం చాలా సులభం.

171
00:11:31,360 --> 00:11:35,853
మొదటిది వాస్తవానికి చేతితో చేయడం చాలా సులభం, మరియు వీటన్నింటికీ అంతర్లీనంగా ఉన్న 

172
00:11:35,853 --> 00:11:39,903
ప్రధాన అంతర్ దృష్టిని కలిగించడం మంచి పని చేస్తుందని నేను భావిస్తున్నాను, 

173
00:11:39,903 --> 00:11:44,230
అంటే ఒకే లోపాన్ని గుర్తించడానికి అవసరమైన సమాచారం బ్లాక్ పరిమాణం యొక్క లాగ్‌కు 

174
00:11:44,230 --> 00:11:49,112
సంబంధించినది. , లేదా మరో మాటలో చెప్పాలంటే, బ్లాక్ సైజు రెట్టింపు అయ్యే కొద్దీ ఒక్కోసారి 

175
00:11:49,112 --> 00:11:50,000
అది పెరుగుతుంది.

176
00:11:51,020 --> 00:11:53,515
ఇక్కడ సంబంధిత వాస్తవం ఏమిటంటే, ఆ సమాచారం మనకు ఎంత 

177
00:11:53,515 --> 00:11:56,060
రిడెండెన్సీ అవసరమో దానికి నేరుగా అనుగుణంగా ఉంటుంది.

178
00:11:56,660 --> 00:11:59,967
చాలా మంది వ్యక్తుల యొక్క మోకాలి కుదుపు ప్రతిచర్యకు వ్యతిరేకంగా జరిగేది అదే, 

179
00:11:59,967 --> 00:12:03,232
వారు ఒక సందేశాన్ని లోపాలను తట్టుకునేలా చేయడం గురించి మొదట ఆలోచించినప్పుడు, 

180
00:12:03,232 --> 00:12:06,540
సాధారణంగా మొత్తం సందేశాన్ని కాపీ చేయడం అనేది గుర్తుకు వచ్చే మొదటి ప్రవృత్తి.

181
00:12:07,500 --> 00:12:10,687
ఆపై, మార్గం ద్వారా, మీరు కొన్నిసార్లు హామింగ్ కోడ్‌లను ప్రదర్శించే ఈ మొత్తం 

182
00:12:10,687 --> 00:12:14,000
ఇతర మార్గం ఉంది, ఇక్కడ మీరు సందేశాన్ని ఒక పెద్ద మ్యాట్రిక్స్ ద్వారా గుణిస్తారు.

183
00:12:14,670 --> 00:12:18,001
ఇది చాలా బాగుంది ఎందుకంటే ఇది సరళ కోడ్‌ల యొక్క విస్తృత కుటుంబానికి సంబంధించినది, 

184
00:12:18,001 --> 00:12:20,674
కానీ అది ఎక్కడ నుండి వస్తుంది లేదా ఎలా స్కేల్ చేస్తుంది అనే దాని 

185
00:12:20,674 --> 00:12:23,060
గురించి దాదాపు అంతర్ దృష్టిని ఇవ్వదని నేను భావిస్తున్నాను.

186
00:12:25,200 --> 00:12:28,454
మరియు స్కేలింగ్ గురించి చెప్పాలంటే, మేము బ్లాక్ పరిమాణాన్ని పెంచుతున్నప్పుడు 

187
00:12:28,454 --> 00:12:31,160
మాత్రమే ఈ పథకం యొక్క సామర్థ్యం మెరుగుపడుతుందని మీరు గమనించవచ్చు.

188
00:12:35,000 --> 00:12:38,829
ఉదాహరణకు, 256 బిట్‌లతో, మీరు రిడెండెన్సీ కోసం ఆ స్థలంలో 3% మాత్రమే 

189
00:12:38,829 --> 00:12:42,660
ఉపయోగిస్తున్నారని మేము చూశాము మరియు అది అక్కడ నుండి మెరుగుపడుతోంది.

190
00:12:43,300 --> 00:12:45,627
పారిటీ బిట్‌ల సంఖ్య ఒక్కొక్కటిగా పెరుగుతున్న కొద్దీ, 

191
00:12:45,627 --> 00:12:47,340
బ్లాక్ పరిమాణం రెట్టింపు అవుతూ ఉంటుంది.

192
00:12:49,000 --> 00:12:53,699
మరియు మీరు దానిని విపరీతంగా తీసుకుంటే, మీరు మిలియన్ బిట్‌లతో బ్లాక్‌ను కలిగి ఉండవచ్చు, 

193
00:12:53,699 --> 00:12:57,265
ఇక్కడ మీరు మీ పారిటీ తనిఖీలతో అక్షరాలా 20 ప్రశ్నలను ప్లే చేస్తారు 

194
00:12:57,265 --> 00:13:00,020
మరియు ఇది 21 పారిటీ బిట్‌లను మాత్రమే ఉపయోగిస్తుంది.

195
00:13:00,740 --> 00:13:03,740
మరియు మీరు మిలియన్ బిట్‌లను చూడటం మరియు ఒక్క ఎర్రర్‌ను గుర్తించడం 

196
00:13:03,740 --> 00:13:07,060
గురించి ఆలోచించడానికి వెనుకడుగు వేస్తే, అది నిజంగా పిచ్చిగా అనిపిస్తుంది.

197
00:13:08,199 --> 00:13:12,838
సమస్య ఏమిటంటే, పెద్ద బ్లాక్‌తో, ఒకటి లేదా రెండు కంటే ఎక్కువ బిట్ ఎర్రర్‌లను 

198
00:13:12,838 --> 00:13:17,660
చూసే సంభావ్యత పెరుగుతుంది మరియు హామింగ్ కోడ్‌లు అంతకు మించి దేనినీ నిర్వహించవు.

199
00:13:18,320 --> 00:13:21,186
కాబట్టి ఆచరణలో, మీకు కావలసినది సరైన పరిమాణాన్ని కనుగొనడం, 

200
00:13:21,186 --> 00:13:24,300
తద్వారా చాలా ఎక్కువ బిట్ ఫ్లిప్‌ల సంభావ్యత చాలా ఎక్కువగా ఉండదు.

201
00:13:26,600 --> 00:13:31,465
అలాగే, ఆచరణలో, లోపాలు చిన్న పేలుళ్లలో వస్తాయి, ఇది ఒక బ్లాక్‌ను పూర్తిగా నాశనం చేస్తుంది, 

202
00:13:31,465 --> 00:13:35,898
కాబట్టి అనేక విభిన్న బ్లాక్‌లలో లోపాలను వ్యాప్తి చేయడంలో సహాయపడే ఒక సాధారణ వ్యూహం 

203
00:13:35,898 --> 00:13:38,871
ఏమిటంటే, ఆ బ్లాక్‌లను వాటి ముందు ఇలా ఇంటర్‌లేస్ చేయడం. 

204
00:13:38,871 --> 00:13:40,980
బయటకు పంపబడింది లేదా నిల్వ చేయబడుతుంది.

205
00:13:45,580 --> 00:13:50,046
మరలా, చాలా సాధారణంగా ఉపయోగించే రీడ్-సోలమన్ అల్గోరిథం వంటి ఆధునిక కోడ్‌ల ద్వారా చాలా 

206
00:13:50,046 --> 00:13:54,566
వరకు పూర్తిగా మూట్ చేయబడింది, ఇది బరస్ట్ ఎర్రర్‌లను ప్రత్యేకంగా నిర్వహిస్తుంది మరియు 

207
00:13:54,566 --> 00:13:58,820
ప్రతి బ్లాక్‌కు పెద్ద సంఖ్యలో ఎర్రర్‌లకు స్థితిస్థాపకంగా ఉండేలా ట్యూన్ చేయవచ్చు.

208
00:13:59,360 --> 00:14:01,340
కానీ అది మరొక సారి చర్చనీయాంశం.

209
00:14:02,500 --> 00:14:05,818
అతని పుస్తకం ది ఆర్ట్ ఆఫ్ డూయింగ్ సైన్స్ అండ్ ఇంజినీరింగ్‌లో, 

210
00:14:05,818 --> 00:14:09,940
హామింగ్ ఈ కోడ్‌ని తన కనిపెట్టడం ఎంత మెలికలు తిరిగిపోయిందో అద్భుతంగా చెప్పాడు.

211
00:14:10,620 --> 00:14:14,274
అతను మొదట బిట్‌లను అధిక డైమెన్షనల్ లాటిస్‌లోని భాగాలుగా నిర్వహించడం మరియు 

212
00:14:14,274 --> 00:14:17,780
ఇలాంటి వింత విషయాలతో కూడిన అన్ని రకాల విభిన్న స్కీమ్‌లను ప్రయత్నించాడు.

213
00:14:18,300 --> 00:14:22,240
లోపం యొక్క స్థితిని వివరించే విధంగా కుట్ర చేయడానికి సమానత్వ తనిఖీలను పొందడం 

214
00:14:22,240 --> 00:14:26,646
సాధ్యమవుతుందనే ఆలోచన హామింగ్‌కు వచ్చినప్పుడు అతను ఇతర విశ్లేషణల సమూహం తర్వాత వెనక్కి 

215
00:14:26,646 --> 00:14:30,172
వెళ్లి, సరే, నేను చేయగలిగిన అత్యంత సమర్థవంతమైనది ఏమిటి అని అడిగాడు. 

216
00:14:30,172 --> 00:14:31,520
దీని గురించి ఆలోచించవచ్చా?

217
00:14:32,620 --> 00:14:36,783
1940 లలో ఈనాటి కంటే తక్కువ సాధారణం అయ్యే పారిటీ తనిఖీలు అతని 

218
00:14:36,783 --> 00:14:41,220
మనస్సులో ఇప్పటికే ఉండటం ఎంత ముఖ్యమో కూడా అతను నిజాయితీగా ఉన్నాడు.

219
00:14:41,920 --> 00:14:45,929
అతను లూయిస్ పాశ్చర్ కోట్‌ను ప్రస్తావించిన అరడజను సార్లు ఈ పుస్తకంలో ఉన్నాయి, 

220
00:14:45,929 --> 00:14:48,220
అదృష్టం సిద్ధమైన మనస్సుకు అనుకూలంగా ఉంటుంది.

221
00:14:49,320 --> 00:14:52,224
తెలివైన ఆలోచనలు తరచుగా వెనుకకు చూస్తే మోసపూరితంగా సరళంగా కనిపిస్తాయి, 

222
00:14:52,224 --> 00:14:54,300
ఇది వాటిని తక్కువ అంచనా వేయడానికి సులభం చేస్తుంది.

223
00:14:54,960 --> 00:14:58,042
హామింగ్ కోడ్‌లు లేదా కనీసం అలాంటి కోడ్‌ల అవకాశం మీకు 

224
00:14:58,042 --> 00:15:01,300
దాదాపు స్పష్టంగా కనిపిస్తుందని ప్రస్తుతం నా నిజాయితీ ఆశ.

225
00:15:01,660 --> 00:15:05,456
అయితే అవి స్పష్టంగా కనిపిస్తున్నాయని భావించి మిమ్మల్ని మీరు మోసం చేసుకోకూడదు, 

226
00:15:05,456 --> 00:15:06,820
ఎందుకంటే అవి ఖచ్చితంగా కావు.

227
00:15:07,880 --> 00:15:11,176
తెలివైన ఆలోచనలు మోసపూరితంగా తేలికగా కనిపించడానికి ఒక కారణం ఏమిటంటే, 

228
00:15:11,176 --> 00:15:15,151
మనం ఎప్పుడైనా తుది ఫలితాన్ని మాత్రమే చూస్తాము, గజిబిజిగా ఉన్నవాటిని శుభ్రం చేయడం, 

229
00:15:15,151 --> 00:15:17,527
తప్పు మలుపులన్నింటినీ ఎప్పుడూ ప్రస్తావించకపోవడం, 

230
00:15:17,527 --> 00:15:21,405
సమస్య ప్రారంభంలో అన్వేషించదగిన అవకాశాల స్థలం ఎంత విశాలంగా ఉందో తక్కువగా అమ్మడం. 

231
00:15:21,405 --> 00:15:22,860
పరిష్కార ప్రక్రియ, అన్నింటినీ.

232
00:15:23,820 --> 00:15:24,900
కానీ ఇది సాధారణంగా నిజం.

233
00:15:24,900 --> 00:15:28,311
కొన్ని ప్రత్యేక ఆవిష్కరణల కోసం, మనం వాటిని తక్కువగా అంచనా వేయడానికి రెండవ, 

234
00:15:28,311 --> 00:15:30,040
లోతైన కారణం ఉందని నేను భావిస్తున్నాను.

235
00:15:30,840 --> 00:15:34,820
సమాచార సిద్ధాంతంపై క్లాడ్ షానన్ యొక్క సెమినల్ పేపర్‌తో 1948 నాటికి బిట్‌ల 

236
00:15:34,820 --> 00:15:38,640
పరంగా సమాచారం గురించి ఆలోచించడం నిజంగా పూర్తి సిద్ధాంతంగా కలిసిపోయింది.

237
00:15:39,280 --> 00:15:42,540
హామింగ్ తన అల్గారిథమ్‌ను అభివృద్ధి చేసినప్పుడు ఇది తప్పనిసరిగా సమానంగా ఉంటుంది.

238
00:15:43,300 --> 00:15:48,247
బిట్ ఫ్లిప్‌ల సంభావ్యత ఎంత ఎక్కువగా ఉన్నా, కనీసం థియరీలో అయినా సమర్థవంతమైన లోపాన్ని 

239
00:15:48,247 --> 00:15:52,900
సరిదిద్దడం ఎల్లప్పుడూ సాధ్యమేనని ఒక నిర్దిష్ట కోణంలో చూపించిన అదే పునాది పేపర్.

240
00:15:53,700 --> 00:15:56,973
షానన్ మరియు హామింగ్, చాలా భిన్నమైన విషయాలపై పనిచేసినప్పటికీ, 

241
00:15:56,973 --> 00:16:01,160
బెల్ ల్యాబ్స్‌లో కార్యాలయాన్ని పంచుకున్నారు, ఇది ఇక్కడ యాదృచ్ఛికంగా కనిపించదు.

242
00:16:02,380 --> 00:16:05,444
కొన్ని దశాబ్దాలుగా ఫాస్ట్ ఫార్వార్డ్, మరియు ఈ రోజుల్లో, 

243
00:16:05,444 --> 00:16:09,275
మనలో చాలా మంది బిట్స్ మరియు సమాచారం గురించి ఆలోచించడంలో మునిగిపోయారు, 

244
00:16:09,275 --> 00:16:12,340
ఈ ఆలోచనా విధానం ఎంత విభిన్నంగా ఉందో పట్టించుకోవడం సులభం.

245
00:16:13,100 --> 00:16:17,746
హాస్యాస్పదంగా, భవిష్యత్ తరం ఆలోచించే మార్గాలను చాలా లోతుగా రూపొందించే 

246
00:16:17,746 --> 00:16:22,260
ఆలోచనలు ఆ భవిష్యత్తు తరానికి నిజంగా ఉన్నదానికంటే సరళంగా కనిపిస్తాయి.

