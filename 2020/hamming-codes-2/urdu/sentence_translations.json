[
 {
  "input": "I'm assuming that everybody here is coming from part 1. ",
  "translatedText": "میں فرض کر رہا ہوں کہ یہاں ہر کوئی حصہ 1 سے آ رہا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 0.0,
  "end": 2.56
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it. ",
  "translatedText": "ہم ہیمنگ کوڈز کے بارے میں بات کر رہے تھے، ڈیٹا کا ایک بلاک بنانے کا ایک طریقہ جہاں زیادہ تر بٹس ایک بامعنی پیغام لے جاتے ہیں، جب کہ کچھ دوسرے ایک قسم کی فالتو پن کے طور پر کام کرتے ہیں، اس طرح کہ اگر کوئی بٹ پلٹ جائے، یا تو ایک پیغام۔bit یا redundancy bit، اس بلاک میں کوئی بھی چیز، وصول کنندہ اس قابل ہو جائے گا کہ یہ شناخت کر سکے کہ کوئی خرابی تھی، اور اسے کیسے ٹھیک کیا جائے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.06,
  "end": 21.24
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error. ",
  "translatedText": "وہاں پیش کیا گیا بنیادی خیال یہ تھا کہ غلطی تک پہنچنے کے لیے بائنری تلاش کرنے کے لیے متعدد برابری چیک کا استعمال کیسے کریں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 21.88,
  "end": 27.16
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible. ",
  "translatedText": "اس ویڈیو میں مقصد ہیمنگ کوڈز کو ممکنہ حد تک ہینڈ آن اور دوبارہ دریافت کرنے کا احساس دلانا تھا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 28.98,
  "end": 34.6
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are. ",
  "translatedText": "لیکن جیسے ہی آپ سافٹ ویئر یا ہارڈ ویئر میں اس کو عملی جامہ پہنانے کے بارے میں سوچنا شروع کر دیتے ہیں، وہ فریمنگ حقیقت میں اس بات کو کم کر سکتی ہے کہ یہ کوڈز واقعی کتنے خوبصورت ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 35.18,
  "end": 43.46
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that. ",
  "translatedText": "آپ سوچ سکتے ہیں کہ آپ کو ایک الگورتھم لکھنے کی ضرورت ہے جو غلطی کے تمام ممکنہ مقامات پر نظر رکھے اور ہر چیک کے ساتھ اس گروپ کو نصف میں کاٹ دے، لیکن یہ حقیقت میں اس سے کہیں زیادہ آسان طریقہ ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 43.92,
  "end": 53.48
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary. ",
  "translatedText": "اگر آپ پچھلی ویڈیو میں ہم نے جو چار برابری کی جانچ پڑتال کی تھی، ان کے جوابات پڑھتے ہیں، جیسے کہ yeses اور nos کے بجائے 1s اور 0s، یہ لفظی طور پر بائنری میں غلطی کی پوزیشن کو واضح کرتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 53.94,
  "end": 64.08
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1. ",
  "translatedText": "مثال کے طور پر، بائنری میں نمبر 7 0111 کی طرح لگتا ہے، بنیادی طور پر یہ کہہ رہا ہے کہ یہ 4 جمع 2 جمع 1 ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 64.78,
  "end": 71.26
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last. ",
  "translatedText": "اور دیکھیں کہ پوزیشن 7 کہاں بیٹھتی ہے، یہ ہمارے برابری گروپوں میں سے پہلے کو متاثر کرتی ہے، اور دوسرے، اور تیسرے کو، لیکن آخری نہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 72.54,
  "end": 81.74
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error. ",
  "translatedText": "لہذا نیچے سے اوپر تک ان چار چیکوں کے نتائج کو پڑھنا واقعی غلطی کی پوزیشن کو واضح کرتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 82.22,
  "end": 87.54
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple. ",
  "translatedText": "مثال 7 کے بارے میں کچھ خاص نہیں ہے، یہ عام طور پر کام کرتا ہے، اور یہ ہارڈ ویئر میں پوری اسکیم کو لاگو کرنے کی منطق کو حیران کن حد تک آسان بنا دیتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 88.32,
  "end": 95.82
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111. ",
  "translatedText": "اب اگر آپ یہ دیکھنا چاہتے ہیں کہ یہ جادو کیوں ہوتا ہے، تو ان 16 انڈیکس لیبلز کو ہماری پوزیشنوں کے لیے لیں، لیکن ان کو بیس 10 میں لکھنے کے بجائے، آئیے ان سب کو بائنری میں لکھیں، جو 0000 سے 1111 تک چلتے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 97.24,
  "end": 109.88
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent. ",
  "translatedText": "جیسا کہ ہم ان بائنری لیبلز کو ان کے خانوں میں واپس ڈالتے ہیں، میں اس بات پر زور دیتا ہوں کہ وہ اصل میں بھیجے جانے والے ڈیٹا سے الگ ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 110.56,
  "end": 117.8
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from. ",
  "translatedText": "وہ ایک تصوراتی لیبل سے زیادہ کچھ نہیں ہیں جو آپ اور مجھے یہ سمجھنے میں مدد کرتے ہیں کہ چار برابری والے گروپ کہاں سے آئے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 118.32,
  "end": 123.5
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary. ",
  "translatedText": "ہر وہ چیز جس کو ہم بائنری میں بیان کر رہے ہیں اس کی خوبصورتی شاید بائنری میں بیان کیے جانے والے ہر چیز کے ہونے کی الجھن کی وجہ سے کم ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 124.14,
  "end": 132.36
 },
 {
  "input": "It's worth it, though. ",
  "translatedText": "یہ اس کے قابل ہے، اگرچہ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.02,
  "end": 134.12
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1. ",
  "translatedText": "اپنی توجہ صرف ان تمام لیبلز کے آخری بٹ پر مرکوز کریں، اور پھر ان پوزیشنوں کو نمایاں کریں جہاں وہ آخری بٹ 1 ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 134.8,
  "end": 143.22
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1? ",
  "translatedText": "ہمیں جو ملتا ہے وہ ہمارے چار برابری گروپوں میں سے پہلا ہے، جس کا مطلب ہے کہ آپ اس پہلے چیک کو پوچھنے سے تعبیر کر سکتے ہیں، ارے، اگر کوئی خرابی ہے، تو کیا اس غلطی کی پوزیشن میں آخری حصہ 1 ہے؟ اسی طرح، اگر آپ دوسرے سے آخری بٹ پر توجہ مرکوز کرتے ہیں، اور ان تمام پوزیشنوں کو نمایاں کرتے ہیں جہاں وہ 1 ہے، تو آپ کو ہماری اسکیم سے دوسرا برابری گروپ ملتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 144.24,
  "end": 155.74
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 158.2,
  "end": 166.16
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1? ",
  "translatedText": "دوسرے لفظوں میں، وہ دوسرا چیک پوچھ رہا ہے، ارے، مجھے دوبارہ، اگر کوئی غلطی ہے، تو کیا اس پوزیشن کا دوسرا آخری حصہ 1 ہے؟ اور اسی طرح. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 166.74,
  "end": 174.5
 },
 {
  "input": "And so on. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 175.76,
  "end": 176.9
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1. ",
  "translatedText": "تیسرا برابری چیک ہر اس پوزیشن کا احاطہ کرتا ہے جس کا تیسرا سے آخری بٹ آن ہے، اور آخری ایک آخری آٹھ پوزیشنوں کا احاطہ کرتا ہے، وہ جن کا سب سے زیادہ آرڈر بٹ 1 ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 177.22,
  "end": 188.74
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary. ",
  "translatedText": "ہم نے پہلے جو کچھ کیا وہ ان چار سوالوں کے جوابات کے برابر ہے، جو کہ بائنری میں پوزیشن کو ہجے کرنے کے مترادف ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 189.74,
  "end": 197.74
 },
 {
  "input": "I hope this makes two things clearer. ",
  "translatedText": "مجھے امید ہے کہ اس سے دو چیزیں واضح ہو جائیں گی۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 199.62,
  "end": 201.48
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two. ",
  "translatedText": "پہلا یہ ہے کہ کس طرح منظم طریقے سے ان سائزوں کو بلاک کرنا ہے جو دو کی بڑی طاقتیں ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.04,
  "end": 206.46
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check. ",
  "translatedText": "اگر ہر پوزیشن کو بیان کرنے میں مزید بٹس لگتے ہیں، جیسے 64 مقامات کو بیان کرنے کے لیے چھ بٹس، تو ان بٹس میں سے ہر ایک آپ کو برابری والے گروپوں میں سے ایک دیتا ہے جسے ہمیں چیک کرنے کی ضرورت ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 206.96,
  "end": 216.68
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar. ",
  "translatedText": "آپ میں سے وہ لوگ جنہوں نے میٹ پارکر کے ساتھ میں نے شطرنج کی تختی کی پہیلی دیکھی ہے شاید وہ یہ سب کچھ بہت زیادہ مانوس محسوس کریں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.4,
  "end": 223.18
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard. ",
  "translatedText": "یہ ایک ہی بنیادی منطق ہے، لیکن ایک مختلف مسئلہ کو حل کرنا، اور 64 مربع شطرنج پر لاگو ہوتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 223.66,
  "end": 228.78
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8. ",
  "translatedText": "دوسری چیز جو مجھے امید ہے کہ اس سے واضح ہوتا ہے کہ ہمارے برابری بٹس ان پوزیشنوں پر کیوں بیٹھے ہیں جو دو کی طاقتیں ہیں، مثال کے طور پر 1، 2، 4، اور 8۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 229.88,
  "end": 237.32
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on. ",
  "translatedText": "یہ وہ پوزیشنیں ہیں جن کی بائنری نمائندگی صرف ایک بٹ آن ہوئی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 238.0,
  "end": 243.0
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups. ",
  "translatedText": "اس کا مطلب یہ ہے کہ ان میں سے ہر ایک برابری بٹس ایک کے اندر بیٹھتا ہے اور چار برابری گروپوں میں سے صرف ایک۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.6,
  "end": 249.46
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups. ",
  "translatedText": "آپ اسے بڑی مثالوں میں بھی دیکھ سکتے ہیں، جہاں اس سے کوئی فرق نہیں پڑتا ہے کہ آپ کتنے ہی بڑے کیوں نہ ہوں، ہر برابری بٹ آسانی سے گروپوں میں سے صرف ایک کو چھوتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 252.04,
  "end": 259.34
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code. ",
  "translatedText": "ایک بار جب آپ یہ سمجھ لیں کہ یہ برابری کی جانچ پڑتال جن پر ہم نے اپنا بہت زیادہ وقت صرف کیا ہے وہ بائنری میں خرابی کی پوزیشن کو واضح کرنے کے ایک ہوشیار طریقے سے زیادہ کچھ نہیں ہیں، پھر ہم ہیمنگ کے بارے میں سوچنے کے ایک مختلف طریقے سے تعلق کھینچ سکتے ہیں۔کوڈز، جو کہ بہت آسان اور زیادہ خوبصورت ہے، اور جسے بنیادی طور پر کوڈ کی ایک لائن کے ساتھ لکھا جا سکتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.6,
  "end": 283.24
 },
 {
  "input": "It's based on the XOR function. ",
  "translatedText": "یہ XOR فنکشن پر مبنی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 283.66,
  "end": 285.5
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or. ",
  "translatedText": "XOR، آپ میں سے ان لوگوں کے لیے جو نہیں جانتے، خصوصی یا کے لیے کھڑا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 286.94,
  "end": 290.22
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off. ",
  "translatedText": "جب آپ دو بٹس کا XOR لیتے ہیں، تو یہ 1 واپس کرنے جا رہا ہے اگر ان میں سے کوئی ایک بٹس آن ہو، لیکن نہیں اگر دونوں آن یا آف ہوں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 290.78,
  "end": 299.36
 },
 {
  "input": "Phrased differently, it's the parity of these two bits. ",
  "translatedText": "مختلف طریقے سے جملے، یہ ان دو بٹس کی برابری ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.1,
  "end": 302.98
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2. ",
  "translatedText": "ایک ریاضی کے فرد کے طور پر، میں اس کے بارے میں اضافی موڈ 2 کے طور پر سوچنا پسند کرتا ہوں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 303.54,
  "end": 306.76
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component. ",
  "translatedText": "ہم عام طور پر دو مختلف بٹ سٹرنگز کے XOR کے بارے میں بھی بات کرتے ہیں، جو بنیادی طور پر اس جزو کو جزو کے لحاظ سے کرتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 307.36,
  "end": 313.44
 },
 {
  "input": "It's like addition, but where you never carry. ",
  "translatedText": "یہ اضافے کی طرح ہے، لیکن جہاں آپ کبھی نہیں لے جاتے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 313.68,
  "end": 315.72
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2. ",
  "translatedText": "ایک بار پھر، زیادہ ریاضی کی طرف مائل اس کے بارے میں سوچنا پسند کریں گے کہ دو ویکٹر کو شامل کرنا اور موڈ 2 کو کم کرنا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 316.5,
  "end": 322.48
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood. ",
  "translatedText": "اگر آپ ابھی کچھ Python کھولتے ہیں اور کیریٹ آپریشن کو دو عدد کے درمیان لاگو کرتے ہیں، تو یہ وہی کام کر رہا ہے لیکن ہڈ کے نیچے ان نمبروں کی تھوڑا سا نمائندگی کرنے کے لئے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 323.5,
  "end": 332.94
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop. ",
  "translatedText": "آپ کے اور میرے لیے اہم نکتہ یہ ہے کہ بہت سے مختلف بٹ سٹرنگز کا XOR لینا مؤثر طریقے سے الگ الگ گروپس کی پیروڈیز کی گنتی کرنے کا ایک طریقہ ہے، جیسا کہ کالموں کے ساتھ، سبھی ایک ساتھ جھپٹ پڑے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 334.96,
  "end": 347.14
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation. ",
  "translatedText": "یہ ہمیں ہمارے ہیمنگ کوڈ الگورتھم سے متعدد برابری کی جانچ پڑتال کے بارے میں سوچنے کا ایک آسان طریقہ فراہم کرتا ہے کیونکہ سبھی کو ایک ہی آپریشن میں ایک ساتھ پیک کیا جاتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 351.26,
  "end": 358.78
 },
 {
  "input": "Though at first glance it does look very different. ",
  "translatedText": "اگرچہ پہلی نظر میں یہ بہت مختلف نظر آتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 359.48,
  "end": 362.18
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR. ",
  "translatedText": "خاص طور پر بائنری میں 16 پوزیشنز کو لکھیں، جیسا کہ ہمارے پاس پہلے تھا، اور اب ان پوزیشنز کو ہائی لائٹ کریں جہاں میسج بٹ کو 1 پر آن کیا گیا ہے، اور پھر ان پوزیشنز کو ایک بڑے کالم میں اکٹھا کریں اور XOR لیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 362.82,
  "end": 377.1
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly. ",
  "translatedText": "آپ شاید اندازہ لگا سکتے ہیں کہ نتیجے کے طور پر نیچے بیٹھے 4 بٹس 4 برابری کی جانچ کے برابر ہیں جو ہم جانتے ہیں اور پسند کرتے ہیں، لیکن حقیقت میں اس کے بارے میں سوچنے کے لیے ایک لمحہ نکالیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 379.26,
  "end": 389.2
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group. ",
  "translatedText": "مثال کے طور پر، یہ آخری کالم ان تمام پوزیشنوں کو گن رہا ہے جن کا آخری بٹ ایک 1 ہے، لیکن ہم پہلے سے ہی صرف نمایاں کردہ پوزیشنوں تک محدود ہیں، اس لیے یہ مؤثر طریقے سے شمار کر رہا ہے کہ پہلے برابری گروپ سے کتنی نمایاں پوزیشنیں آئیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 392.22,
  "end": 405.76
 },
 {
  "input": "Does that make sense? ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 406.24,
  "end": 406.8
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on. ",
  "translatedText": "کیا اسکا کوئ مطلب بنتا ہے؟ اسی طرح، اگلا کالم شمار کرتا ہے کہ دوسرے برابری گروپ میں کتنی پوزیشنیں ہیں، وہ پوزیشنیں جن کا دوسرا سے آخری بٹ 1 ہے، اور جن پر روشنی ڈالی گئی ہے، وغیرہ۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 409.08,
  "end": 420.0
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing. ",
  "translatedText": "یہ وہی چیز ہے جو ہم کر رہے ہیں کے نقطہ نظر میں واقعی صرف ایک چھوٹی سی تبدیلی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 420.26,
  "end": 423.96
 },
 {
  "input": "And so you know where it goes from here. ",
  "translatedText": "اور اس طرح آپ جانتے ہیں کہ یہ یہاں سے کہاں جاتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 427.76,
  "end": 429.6
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000. ",
  "translatedText": "بھیجنے والا کچھ خاص برابری بٹس کو ٹوگل کرنے کے لیے ذمہ دار ہے تاکہ یہ یقینی بنایا جا سکے کہ رقم 0000 بنتی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 430.0,
  "end": 436.56
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error. ",
  "translatedText": "اب ایک بار جب ہمارے پاس یہ اس طرح ہو جائے تو، یہ ہمیں یہ سوچنے کا ایک بہت اچھا طریقہ فراہم کرتا ہے کہ نچلے حصے میں یہ چار نتیجے والے بٹس براہ راست غلطی کی پوزیشن کو کیوں ظاہر کرتے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 439.04,
  "end": 447.58
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1. ",
  "translatedText": "آئیے کہتے ہیں کہ اس بلاک میں تھوڑا سا 0 سے 1 تک ٹوگل ہوجاتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 448.46,
  "end": 451.86
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error. ",
  "translatedText": "اس کا مطلب یہ ہے کہ اس بٹ کی پوزیشن اب کل XOR میں شامل ہونے جا رہی ہے، جو رقم کو 0 سے بدل کر اس نئی شامل ویلیو، غلطی کی پوزیشن میں تبدیل کر دیتی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 452.6,
  "end": 463.82
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0. ",
  "translatedText": "قدرے کم واضح طور پر، یہی بات درست ہے اگر کوئی ایسی غلطی ہو جو 1 کو 0 میں بدل دیتی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 464.46,
  "end": 469.36
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0. ",
  "translatedText": "آپ دیکھتے ہیں، اگر آپ دو بار ایک ساتھ تھوڑا سا سٹرنگ جوڑتے ہیں، تو یہ بالکل ایسا ہی ہے جیسا کہ اس کا وہاں بالکل نہ ہونا، بنیادی طور پر کیونکہ اس دنیا میں 1 جمع 1 برابر 0 ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 470.18,
  "end": 477.94
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it. ",
  "translatedText": "لہذا اس پوزیشن کی ایک کاپی کو کل رقم میں شامل کرنے کا وہی اثر ہوتا ہے جیسا کہ ہم اسے منتقل کر رہے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 478.92,
  "end": 484.3
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error. ",
  "translatedText": "اور وہ اثر، ایک بار پھر، یہ ہے کہ یہاں نیچے کا کل نتیجہ غلطی کی پوزیشن کو ظاہر کرتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 485.16,
  "end": 490.7
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end. ",
  "translatedText": "یہ بتانے کے لیے کہ یہ کتنا خوبصورت ہے، میں دکھاتا ہوں کہ ازگر کے کوڈ کی ایک لائن جس کا میں نے پہلے حوالہ دیا تھا، جو وصول کنندہ کے سرے پر موجود تقریباً تمام منطق کو پکڑ لے گی۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 493.04,
  "end": 501.44
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits. ",
  "translatedText": "ہم ڈیٹا بلاک کی نقل کرنے کے لیے 16 1s اور 0s کی بے ترتیب صف بنا کر شروع کریں گے، اور میں اسے نام کے بٹس دوں گا، لیکن یقیناً عملی طور پر یہ وہ چیز ہوگی جو ہم بھیجنے والے سے وصول کر رہے ہیں، اور اس کے بجائے بے ترتیب ہونے کی وجہ سے یہ 5 برابری بٹس کے ساتھ 11 ڈیٹا بٹس لے کر جائے گا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 502.08,
  "end": 517.4
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15. ",
  "translatedText": "اگر میں فنکشن کو enumerateBits کہتا ہوں، تو یہ جو کرتا ہے ان میں سے ہر ایک بٹس کو متعلقہ انڈیکس کے ساتھ جوڑتا ہے، اس صورت میں 0 سے 15 تک چل رہا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 518.12,
  "end": 527.0
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15. ",
  "translatedText": "لہذا اگر ہم پھر ایک فہرست بناتے ہیں جو ان تمام جوڑوں پر نظر آتی ہے، جوڑے جو i کی طرح نظر آتے ہیں، اور پھر ہم صرف i ویلیو کو نکالتے ہیں، صرف انڈیکس، ٹھیک ہے یہ اتنا دلچسپ نہیں ہے، ہم صرف ان انڈیکس کو 0 سے 15 تک واپس کر دیتے ہیں۔. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 528.18,
  "end": 541.34
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on. ",
  "translatedText": "لیکن اگر ہم اس شرط کو شامل کریں کہ یہ صرف اگر بٹ ہے، یعنی اگر وہ بٹ 1 ہے نہ کہ 0، تو یہ صرف ان پوزیشنوں کو نکالتا ہے جہاں متعلقہ بٹ آن ہوتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 541.68,
  "end": 552.66
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc. ",
  "translatedText": "اس معاملے میں ایسا لگتا ہے کہ وہ پوزیشنیں 0، 4، 6، 9، وغیرہ ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 553.38,
  "end": 557.96
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together. ",
  "translatedText": "ہم جو چاہتے ہیں وہ ان تمام پوزیشنوں کو اکٹھا کرنا ہے، بٹس کی پوزیشنز جو آن ہیں، اور پھر ان کو ایک ساتھ XOR کریں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 559.98,
  "end": 567.24
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions. ",
  "translatedText": "Python میں ایسا کرنے کے لیے، مجھے پہلے ایک دو مددگار فنکشنز درآمد کرنے دیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.18,
  "end": 573.22
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it. ",
  "translatedText": "اس طرح ہم اس فہرست میں reduce() کو کال کر سکتے ہیں، اور اسے کم کرنے کے لیے XOR فنکشن کا استعمال کر سکتے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 573.9,
  "end": 578.7
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way. ",
  "translatedText": "یہ بنیادی طور پر فہرست کے ذریعے اپنا راستہ کھاتا ہے، راستے میں XORs کو لے جاتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.1,
  "end": 582.68
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere. ",
  "translatedText": "اگر آپ چاہیں تو، آپ واضح طور پر اس XOR فنکشن کو کہیں سے درآمد کیے بغیر لکھ سکتے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 584.8,
  "end": 589.44
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001. ",
  "translatedText": "تو اس وقت ایسا لگتا ہے کہ اگر ہم یہ اپنے 16 بٹس کے بے ترتیب بلاک پر کرتے ہیں، تو یہ 9 لوٹاتا ہے، جس کی بائنری نمائندگی 1001 ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 591.94,
  "end": 601.28
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0. ",
  "translatedText": "ہم یہ یہاں نہیں کریں گے، لیکن آپ ایک فنکشن لکھ سکتے ہیں جہاں بھیجنے والا اس بائنری نمائندگی کا استعمال کرتے ہوئے ضرورت کے مطابق چار برابری بٹس کو سیٹ کرتا ہے، بالآخر اس بلاک کو ایسی حالت میں لے جاتا ہے جہاں بٹس کی مکمل فہرست پر کوڈ کی اس لائن کو چلانے سے واپسی ہوتی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 601.98,
  "end": 615.46
 },
 {
  "input": "This would be considered a well-prepared block. ",
  "translatedText": "ایک 0 یہ ایک اچھی طرح سے تیار شدہ بلاک سمجھا جائے گا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 616.08,
  "end": 618.2
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error. ",
  "translatedText": "اچھی بات یہ ہے کہ اگر ہم اس فہرست میں سے کسی ایک بٹ کو ٹوگل کرتے ہیں، شور سے بے ترتیب غلطی کی نقل کرتے ہیں، پھر اگر آپ کوڈ کی اسی لائن کو چلاتے ہیں، تو یہ اس غلطی کو پرنٹ کرتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 619.88,
  "end": 630.22
 },
 {
  "input": "Isn't that neat? ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 630.96,
  "end": 631.52
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any. ",
  "translatedText": "کیا یہ صاف نہیں ہے؟ آپ اس بلاک کو نیلے رنگ سے حاصل کر سکتے ہیں، اس پر اس سنگل لائن کو چلائیں، اور یہ خود بخود کسی غلطی کی پوزیشن کو ختم کر دے گا، یا اگر کوئی نہیں ہے تو 0۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 631.82,
  "end": 641.06
 },
 {
  "input": "And there's nothing special about the size 16 here. ",
  "translatedText": "اور یہاں سائز 16 کے بارے میں کچھ خاص نہیں ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 642.5,
  "end": 645.2
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits. ",
  "translatedText": "کوڈ کی ایک ہی لائن کام کرے گی اگر آپ کے پاس 256 بٹس کی فہرست ہو۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 645.4,
  "end": 649.86
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction. ",
  "translatedText": "یہ کہنے کی ضرورت نہیں کہ یہاں لکھنے کے لیے مزید کوڈ موجود ہیں، جیسے کہ 2 بٹ کی غلطیوں کا پتہ لگانے کے لیے میٹا پیریٹی چیک کرنا، لیکن خیال یہ ہے کہ ہماری اسکیم سے تقریباً تمام بنیادی منطق ایک XOR میں کمی پر آتی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 651.88,
  "end": 663.76
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go. ",
  "translatedText": "اب، بائنری اور XORs اور عام طور پر سافٹ ویئر کے ساتھ آپ کے آرام پر منحصر ہے، آپ کو یا تو یہ نقطہ نظر تھوڑا سا الجھا ہوا، یا اتنا زیادہ خوبصورت اور سادہ لگ سکتا ہے کہ آپ سوچ رہے ہوں گے کہ ہم نے اس کے ساتھ شروع ہی کیوں نہیں کیا۔-جاؤ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.12,
  "end": 678.42
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level. ",
  "translatedText": "ڈھیلے الفاظ میں، ہارڈ ویئر میں ہیمنگ کوڈز کو براہ راست لاگو کرتے وقت ایک سے زیادہ برابری کی جانچ کے نقطہ نظر کے بارے میں سوچنا آسان ہے، اور XOR نقطہ نظر کے بارے میں سوچنا آسان ہے کہ اسے سافٹ ویئر میں کرتے وقت، ایک اعلی سطح سے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 679.14,
  "end": 690.5
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles. ",
  "translatedText": "پہلا اصل میں ہاتھ سے کرنا سب سے آسان ہے، اور مجھے لگتا ہے کہ یہ ان سب کے بنیادی وجدان کو پیدا کرنے میں ایک بہتر کام کرتا ہے، جو کہ ایک غلطی کا پتہ لگانے کے لیے درکار معلومات کا تعلق بلاک کے سائز کے لاگ سے ہے۔، یا دوسرے الفاظ میں، یہ ایک وقت میں تھوڑا سا بڑھتا ہے کیونکہ بلاک کا سائز دوگنا ہوتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 691.36,
  "end": 710.0
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need. ",
  "translatedText": "یہاں متعلقہ حقیقت یہ ہے کہ وہ معلومات براہ راست اس بات سے مطابقت رکھتی ہے کہ ہمیں کتنی بے کاری کی ضرورت ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 711.02,
  "end": 716.06
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind. ",
  "translatedText": "یہی وہ چیز ہے جو زیادہ تر لوگوں کے گھٹنے ٹیکنے والے ردعمل کے خلاف چلتی ہے جب وہ پہلی بار کسی پیغام کو غلطیوں کے لیے لچکدار بنانے کے بارے میں سوچتے ہیں، جہاں عام طور پر پورے پیغام کو کاپی کرنا ذہن میں آنے والی پہلی جبلت ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.66,
  "end": 726.54
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix. ",
  "translatedText": "اور پھر، ویسے، یہ پورا دوسرا طریقہ ہے کہ آپ کبھی کبھی ہیمنگ کوڈز کو پیش کرتے ہوئے دیکھتے ہیں، جہاں آپ پیغام کو ایک بڑے میٹرکس سے ضرب دیتے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 727.5,
  "end": 734.0
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales. ",
  "translatedText": "یہ ایک طرح کا اچھا ہے کیونکہ اس کا تعلق لکیری کوڈز کے وسیع تر خاندان سے ہے، لیکن مجھے لگتا ہے کہ یہ کہاں سے آتا ہے یا اس کی پیمائش کیسے ہوتی ہے اس کے بارے میں تقریباً کوئی وجدان نہیں دیتا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 734.67,
  "end": 743.06
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size. ",
  "translatedText": "اور اسکیلنگ کی بات کرتے ہوئے، آپ محسوس کر سکتے ہیں کہ اس اسکیم کی کارکردگی صرف اسی وقت بہتر ہوتی ہے جب ہم بلاک سائز میں اضافہ کرتے ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 745.2,
  "end": 751.16
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there. ",
  "translatedText": "مثال کے طور پر، ہم نے دیکھا کہ 256 بٹس کے ساتھ، آپ اس جگہ کا صرف 3% فالتو پن کے لیے استعمال کر رہے ہیں، اور یہ وہاں سے بہتر ہوتا جا رہا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 755.0,
  "end": 762.66
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling. ",
  "translatedText": "جیسے جیسے برابری بٹس کی تعداد ایک ایک کرکے بڑھتی ہے، بلاک کا سائز دوگنا ہوتا رہتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 763.3,
  "end": 767.34
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits. ",
  "translatedText": "اور اگر آپ اسے انتہائی حد تک لے جاتے ہیں، تو آپ کے پاس ایک ملین بٹس کا بلاک ہو سکتا ہے، جہاں آپ لفظی طور پر اپنے برابری کی جانچ کے ساتھ 20 سوالات کھیل رہے ہوں گے، اور یہ صرف 21 برابری بٹس کا استعمال کرتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 769.0,
  "end": 780.02
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy. ",
  "translatedText": "اور اگر آپ ایک ملین بٹس کو دیکھنے اور ایک غلطی کا پتہ لگانے کے بارے میں سوچنے کے لئے پیچھے ہٹتے ہیں، تو یہ واقعی پاگل محسوس ہوتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 780.74,
  "end": 787.06
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that. ",
  "translatedText": "مسئلہ، یقیناً، یہ ہے کہ بڑے بلاک کے ساتھ، ایک یا دو سے زیادہ خرابیاں دیکھنے کا امکان بڑھ جاتا ہے، اور ہیمنگ کوڈز اس سے آگے کچھ نہیں سنبھالتے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 788.2,
  "end": 797.66
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high. ",
  "translatedText": "لہذا عملی طور پر، آپ صحیح سائز تلاش کرنا چاہتے ہیں تاکہ بہت زیادہ بٹ پلٹنے کا امکان بہت زیادہ نہ ہو۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 798.32,
  "end": 804.3
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored. ",
  "translatedText": "اس کے علاوہ، عملی طور پر، غلطیاں تھوڑی دیر میں آتی ہیں، جو ایک ہی بلاک کو مکمل طور پر برباد کر دیتی ہیں، لہذا بہت سے مختلف بلاکس میں غلطیوں کو پھیلانے میں مدد کرنے کے لیے ایک عام حربہ یہ ہے کہ ان بلاکس کو آپس میں جوڑنا، اس طرح، ان کے ہونے سے پہلے۔بھیج دیا گیا یا ذخیرہ کیا گیا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 806.6,
  "end": 820.98
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block. ",
  "translatedText": "پھر ایک بار پھر، اس میں سے بہت کچھ کو زیادہ جدید کوڈز کے ذریعے مکمل طور پر پیش کیا جاتا ہے، جیسے کہ بہت زیادہ عام طور پر استعمال ہونے والا Reed-Solomon الگورتھم، جو برسٹ کی غلطیوں کو خاص طور پر اچھی طرح سے ہینڈل کرتا ہے، اور اسے فی بلاک میں بڑی تعداد میں غلطیوں کے لیے لچکدار ہونے کے لیے بنایا جا سکتا ہے۔. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 825.58,
  "end": 838.82
 },
 {
  "input": "But that's a topic for another time. ",
  "translatedText": "لیکن یہ کسی اور وقت کا موضوع ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.36,
  "end": 841.34
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was. ",
  "translatedText": "اپنی کتاب دی آرٹ آف ڈوئنگ سائنس اینڈ انجینئرنگ میں، ہیمنگ حیرت انگیز طور پر اس بات کے بارے میں واضح ہے کہ اس کوڈ کے بارے میں ان کی دریافت کتنی گھمبیر تھی۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 842.5,
  "end": 849.94
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this. ",
  "translatedText": "اس نے سب سے پہلے ہر طرح کی مختلف اسکیموں کو آزمایا جس میں بٹس کو اعلی جہتی جالی کے حصوں میں ترتیب دینا اور اس طرح کی عجیب و غریب چیزیں شامل تھیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 850.62,
  "end": 857.78
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this? ",
  "translatedText": "یہ خیال کہ اس طرح سے سازش کرنے کے لیے برابری کی جانچ پڑتال ممکن ہو سکتی ہے جس سے غلطی کی پوزیشن کو واضح کیا جا سکتا ہے، ہیمنگ کو صرف اس وقت آیا جب اس نے دوسرے تجزیوں کے ایک گروپ کے بعد پیچھے ہٹ کر پوچھا، ٹھیک ہے، میں سب سے زیادہ موثر کون سا ہے؟ شاید اس کے بارے میں ہو؟ وہ اس بارے میں بھی واضح تھا کہ یہ کتنا اہم تھا کہ برابری کی جانچ پڑتال پہلے سے ہی اس کے ذہن میں تھی، جو آج کی نسبت 1940 کی دہائی میں بہت کم عام ہوتی۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 858.3,
  "end": 871.52
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 872.62,
  "end": 881.22
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind. ",
  "translatedText": "اس پوری کتاب میں نصف درجن کے قریب بار ہے کہ وہ لوئس پاسچر کے اقتباس کا حوالہ دیتے ہیں، قسمت ایک تیار دماغ کی حمایت کرتی ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 881.92,
  "end": 888.22
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate. ",
  "translatedText": "ہوشیار خیالات اکثر پیچھے کی نظر میں دھوکے سے سادہ نظر آتے ہیں، جس کی وجہ سے ان کی قدر کرنا آسان ہو جاتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 889.32,
  "end": 894.3
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you. ",
  "translatedText": "ابھی میری ایماندارانہ امید یہ ہے کہ ہیمنگ کوڈز، یا کم از کم اس طرح کے کوڈز کا امکان، آپ کے لیے تقریباً واضح محسوس ہوتا ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 894.96,
  "end": 901.3
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't. ",
  "translatedText": "لیکن آپ کو یہ سوچ کر اپنے آپ کو بیوقوف نہیں بنانا چاہئے کہ وہ حقیقت میں واضح ہیں، کیونکہ وہ یقینی طور پر نہیں ہیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 901.66,
  "end": 906.82
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that. ",
  "translatedText": "ہوشیار خیالات دھوکہ دہی سے آسان نظر آنے کی ایک وجہ یہ ہے کہ ہم صرف حتمی نتیجہ دیکھتے ہیں، جو گندا تھا اسے صاف کرتے ہیں، تمام غلط موڑ کا کبھی ذکر نہیں کرتے، اس بات کو کم کرتے ہیں کہ کسی مسئلے کے آغاز میں قابل دریافت امکانات کی جگہ کتنی وسیع ہے۔حل کرنے کا عمل، یہ سب۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 907.88,
  "end": 922.86
 },
 {
  "input": "But this is true in general. ",
  "translatedText": "لیکن یہ عام طور پر سچ ہے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 923.82,
  "end": 924.9
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them. ",
  "translatedText": "میرے خیال میں کچھ خاص ایجادات کے لیے، ایک دوسری، گہری وجہ ہے کہ ہم ان کی قدر نہیں کرتے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 924.9,
  "end": 930.04
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory. ",
  "translatedText": "بٹس کے لحاظ سے معلومات کے بارے میں سوچنا صرف 1948 تک ایک مکمل تھیوری میں یکجا ہو گیا تھا، جس میں انفارمیشن تھیوری پر کلاڈ شینن کا سیمینل پیپر تھا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 930.84,
  "end": 938.64
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm. ",
  "translatedText": "یہ بنیادی طور پر اس کے ساتھ ہم آہنگ تھا جب ہیمنگ نے اپنا الگورتھم تیار کیا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 939.28,
  "end": 942.54
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory. ",
  "translatedText": "یہ وہی بنیادی کاغذ تھا جس نے ظاہر کیا، ایک خاص معنوں میں، غلطی کی مؤثر اصلاح ہمیشہ ممکن ہے، چاہے بٹ پلٹنے کا امکان کتنا ہی زیادہ ہو، کم از کم تھیوری میں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 943.3,
  "end": 952.9
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here. ",
  "translatedText": "شینن اور ہیمنگ، ویسے، بہت مختلف چیزوں پر کام کرنے کے باوجود، بیل لیبز میں ایک دفتر کا اشتراک کرتے ہیں، جو یہاں شاید ہی اتفاقیہ لگیں۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.7,
  "end": 961.16
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was. ",
  "translatedText": "کئی دہائیوں سے تیزی سے آگے بڑھیں، اور ان دنوں، ہم میں سے بہت سے لوگ بٹس اور معلومات کے بارے میں سوچنے میں اتنے ڈوبے ہوئے ہیں کہ یہ نظر انداز کرنا آسان ہے کہ سوچنے کا یہ طریقہ کتنا الگ تھا۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.38,
  "end": 972.34
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are. ",
  "translatedText": "ستم ظریفی یہ ہے کہ وہ خیالات جو سب سے زیادہ گہرائی سے ان طریقوں کو تشکیل دیتے ہیں جن کے بارے میں ایک آنے والی نسل سوچتی ہے کہ وہ اس آنے والی نسل کو حقیقت سے کہیں زیادہ آسان نظر آئیں گے۔",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 973.1,
  "end": 982.26
 }
]