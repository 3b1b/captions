1
00:00:00,000 --> 00:00:07,330
Elgondolkozott már azon, hogyan lehetséges egy CD-t vagy DVD-t megkarcolni,

2
00:00:07,330 --> 00:00:10,900
és még mindig lejátszani, amit tárol?

3
00:00:10,900 --> 00:00:14,802
A karcolás valóban hatással van a lemezen lévő 1-ekre és 0-kra,

4
00:00:14,802 --> 00:00:19,985
tehát a tárolttól eltérő adatokat olvas ki, de hacsak nem teljesen összekarcolódott,

5
00:00:19,985 --> 00:00:23,704
a kiolvasott bitek pontosan ugyanabba a fájlba dekódolódnak,

6
00:00:23,704 --> 00:00:28,400
mint amilyenre rá volt kódolva. bit a bitmásoláshoz, mindezen hibák ellenére.

7
00:00:28,400 --> 00:00:32,245
Számtalan matematikai okosság van, amely lehetővé teszi az adatok tárolását,

8
00:00:32,245 --> 00:00:35,541
és ami ugyanilyen fontos, hogy adatokat továbbítsunk olyan módon,

9
00:00:35,541 --> 00:00:36,840
amely ellenáll a hibáknak.

10
00:00:36,840 --> 00:00:42,480
Nos, oké, valójában nem kell akkora okosság, hogy kitaláljon egy módot erre.

11
00:00:42,480 --> 00:00:47,238
Bármely fájl, legyen szó videóról, hangról vagy szövegről, valamilyen kódról,

12
00:00:47,238 --> 00:00:50,960
képről vagy bármi másról, végső soron 1-esek és 0-k sorozata.

13
00:00:50,960 --> 00:00:55,152
A megfordított bitek kijavítására egy egyszerű stratégia az lenne,

14
00:00:55,152 --> 00:00:57,780
ha minden bitből három másolatot tárolunk.

15
00:00:57,780 --> 00:01:03,300
Ekkor a fájlt olvasó gép össze tudja hasonlítani ezt a három másolatot,

16
00:01:03,300 --> 00:01:07,440
és mindig a legjobb 2-t kapja a 3-ból, ha eltérés van.

17
00:01:07,440 --> 00:01:11,560
De ez azt jelenti, hogy a hely kétharmadát redundanciára használja.

18
00:01:11,560 --> 00:01:15,424
És még akkor sem, ha az összes helyet feladjuk, nincs komoly garancia arra,

19
00:01:15,424 --> 00:01:18,120
hogy mi történik, ha egynél több bitet megfordítanak.

20
00:01:18,120 --> 00:01:20,983
Sokkal érdekesebb kérdés, hogy hogyan lehet úgy megcsinálni,

21
00:01:20,983 --> 00:01:24,740
hogy a hibákat a lehető legkevesebb hely elhagyása mellett ki lehessen javítani.

22
00:01:24,740 --> 00:01:30,393
Például a videóról megismert módszerrel 256 bites blokkokban tárolhatja adatait,

23
00:01:30,393 --> 00:01:32,975
ahol minden blokk 9, 9 bitet használ!

24
00:01:32,975 --> 00:01:36,957
egyfajta redundanciaként működik, a többi 247 bit pedig szabadon

25
00:01:36,957 --> 00:01:41,000
hordozhat bármilyen értelmes üzenetet vagy adatot, amit csak akar.

26
00:01:41,000 --> 00:01:44,460
És továbbra is az lesz, hogy ha itt bármelyik bit megfordul,

27
00:01:44,460 --> 00:01:48,601
csak erre a blokkra nézve, és semmi másra, a gép képes lesz azonosítani,

28
00:01:48,601 --> 00:01:53,140
hogy hiba történt, és hogy pontosan hol volt, így tudja, hogyan kell kijavítani.

29
00:01:53,140 --> 00:01:55,540
És őszintén szólva, ez varázslatnak tűnik.

30
00:01:55,540 --> 00:01:58,697
És ennél a konkrét sémánál, ha két bit megfordul,

31
00:01:58,697 --> 00:02:03,180
a gép legalább két hibát észlel, bár nem tudja, hogyan javítsa ki őket.

32
00:02:03,180 --> 00:02:05,905
Egy kicsit később beszélünk arról, hogy ez hogyan

33
00:02:05,905 --> 00:02:08,140
skálázható a különböző méretű blokkokhoz.

34
00:02:08,140 --> 00:02:10,952
Az ehhez hasonló hibák kijavítását lehetővé tevő

35
00:02:10,952 --> 00:02:13,880
módszereket ésszerűen hibajavító kódokként ismerik.

36
00:02:13,880 --> 00:02:18,472
A múlt század nagy részében ez a terület a meglepően mély matematikai

37
00:02:18,472 --> 00:02:23,000
adatok gazdag forrása volt, amely beépül a mindennapi használatunkba.

38
00:02:23,000 --> 00:02:27,649
Itt az a cél, hogy nagyon alapos megértést nyújtsunk az egyik legkorábbi,

39
00:02:27,649 --> 00:02:29,660
Hamming-kódként ismert példának.

40
00:02:29,660 --> 00:02:33,689
És mellesleg, ahogyan ennek a videónak a felépítésére gondolok, kevésbé arról van szó,

41
00:02:33,689 --> 00:02:37,348
hogy a lehető legközvetlenebbül magyarázzam el, hanem inkább arra ösztönözzek,

42
00:02:37,348 --> 00:02:40,220
hogy találd ki magadnak, itt-ott egy kis gyengéd irányítással.

43
00:02:40,220 --> 00:02:42,869
Tehát amikor úgy érzed, hogy egy ponton látod, merre tart,

44
00:02:42,869 --> 00:02:46,326
szánj arra a pillanatra egy szünetet, és aktívan jósold meg, mi lesz a terv,

45
00:02:46,326 --> 00:02:47,180
mielőtt elmondanám.

46
00:02:47,180 --> 00:02:50,850
Továbbá, ha azt szeretné, hogy megértése a hardver szintjére jusson,

47
00:02:50,850 --> 00:02:54,360
Ben Eater készített egy videót ehhez a videóhoz, amely bemutatja,

48
00:02:54,360 --> 00:02:58,243
hogyan kell ténylegesen implementálni a Hamming-kódokat a kenyérlapokon,

49
00:02:58,243 --> 00:02:59,520
ami rendkívül kielégítő.

50
00:02:59,520 --> 00:03:02,785
Tudnod kell, a Hamming-kódokat nem használják olyan széles körben,

51
00:03:02,785 --> 00:03:06,002
mint a modernebb kódokat, mint például a Reed-Solomon algoritmus,

52
00:03:06,002 --> 00:03:08,634
de van egy bizonyos varázslat a kontrasztban aközött,

53
00:03:08,634 --> 00:03:11,461
hogy mennyire lehetetlennek tűnik ez a feladat az elején,

54
00:03:11,461 --> 00:03:14,240
és mennyire ésszerűnek tűnik egyszer. tanulsz Hammingről.

55
00:03:14,240 --> 00:03:18,755
A hibajavítás alapelve, hogy az összes lehetséges üzenet hatalmas

56
00:03:18,755 --> 00:03:22,860
területén csak egy részhalmaz tekinthető érvényes üzenetnek.

57
00:03:22,860 --> 00:03:29,100
Analógiaként gondoljon a helyesen írt szavakra a helytelenül írt szavakra.

58
00:03:29,100 --> 00:03:32,640
Amikor egy érvényes üzenetet módosítanak, a fogadó felelős azért,

59
00:03:32,640 --> 00:03:36,019
hogy a látottakat a legközelebbi érvényes szomszédhoz javítsa,

60
00:03:36,019 --> 00:03:38,380
ahogyan azt az elírások esetén is megteheti.

61
00:03:38,380 --> 00:03:42,770
Egy konkrét algoritmus kidolgozása az ehhez hasonló üzenetek

62
00:03:42,770 --> 00:03:47,160
hatékony kategorizálására azonban bizonyos okosságot igényel.

63
00:03:47,160 --> 00:03:50,580
A történet az 1940-es években kezdődik, amikor egy fiatal Richard Hamming a

64
00:03:50,580 --> 00:03:53,280
Bell Labs-nál dolgozott, és néhány munkája egy nagyon nagy,

65
00:03:53,280 --> 00:03:55,485
drága lyukkártyás számítógép használatából állt,

66
00:03:55,485 --> 00:03:57,420
amelyhez csak korlátozott hozzáférése volt.

67
00:03:57,420 --> 00:04:01,233
És a programok, amiket folyamatosan csinált, folyamatosan kudarcot vallottak,

68
00:04:01,233 --> 00:04:03,140
mert időnként egy kicsit félreolvastak.

69
00:04:03,140 --> 00:04:06,607
Mivel a frusztráció a találmány tégelye, annyira elege lett,

70
00:04:06,607 --> 00:04:09,280
hogy feltalálta a világ első hibajavító kódját.

71
00:04:09,280 --> 00:04:12,649
A Hamming-kódok keretbe foglalásának sokféle módja van,

72
00:04:12,649 --> 00:04:16,620
de első lépésként úgy megyünk végig, ahogy Hamming gondolta róluk.

73
00:04:16,620 --> 00:04:21,400
Használjunk egy egyszerű, de nem túl egyszerű példát, egy 16 bites blokkot.

74
00:04:21,400 --> 00:04:25,700
Ezeknek a biteknek a pozícióit 0-tól 15-ig számozzuk.

75
00:04:25,700 --> 00:04:30,167
A tárolni kívánt tényleges adatok csak 12 bitet tesznek ki ebből a bitből,

76
00:04:30,167 --> 00:04:33,920
míg a pozíciók közül 4 egyfajta redundanciaként van fenntartva.

77
00:04:33,920 --> 00:04:36,809
A redundáns szó itt nem egyszerűen másolást jelent,

78
00:04:36,809 --> 00:04:40,200
elvégre az a 4 bit nem ad elég teret az adatok vakmásolására.

79
00:04:40,200 --> 00:04:45,443
Ehelyett sokkal árnyaltabb és okosabb redundanciát kell alkalmazniuk,

80
00:04:45,443 --> 00:04:48,740
nem új információkkal, hanem rugalmassággal.

81
00:04:48,740 --> 00:04:53,160
Arra számíthat, hogy ez a 4 speciális bit szépen össze van csomagolva,

82
00:04:53,160 --> 00:04:56,771
talán a végén, vagy valami hasonló, de amint látni fogja,

83
00:04:56,771 --> 00:05:00,320
ha 2-es pozícióban ülnek, valami igazán elegáns a végére.

84
00:05:00,320 --> 00:05:05,420
Ez is adhat egy kis utalást arra vonatkozóan, hogyan méretezhető ez a nagyobb blokkokhoz.

85
00:05:05,420 --> 00:05:08,927
Technikailag is csak 11 bites adat lesz, és látni fogja,

86
00:05:08,927 --> 00:05:14,280
hogy van egy enyhe árnyalat a 0. pozícióban zajló eseményekhez, de ez most ne aggódjon.

87
00:05:14,280 --> 00:05:18,231
Mint minden hibajavító algoritmus, ez is két játékost foglal magában,

88
00:05:18,231 --> 00:05:22,295
egy feladót, aki a 4 speciális bit beállításáért felelős, és egy vevőt,

89
00:05:22,295 --> 00:05:26,360
aki valamilyen ellenőrzés elvégzéséért és a hibák kijavításáért felelős.

90
00:05:26,360 --> 00:05:30,218
Természetesen a küldő és fogadó szavak valóban olyan gépekre vagy szoftverekre utalnak,

91
00:05:30,218 --> 00:05:33,156
amelyek minden ellenőrzést elvégeznek, és az üzenet fogalma nagyon

92
00:05:33,156 --> 00:05:35,480
tág értelemben értendő, beleértve például a tárolást.

93
00:05:35,480 --> 00:05:40,485
Végül is az adatok tárolása ugyanaz, mint üzenetet küldeni a múltból a jövőbe,

94
00:05:40,485 --> 00:05:42,640
nem pedig egyik helyről a másikra.

95
00:05:42,640 --> 00:05:47,202
Tehát ez a beállítás, de mielőtt belemerülnénk, beszélnünk kell egy kapcsolódó ötletről,

96
00:05:47,202 --> 00:05:50,995
amely Hammingnek a felfedezése idején frissen járt, egy olyan módszerről,

97
00:05:50,995 --> 00:05:55,147
amely lehetővé teszi, hogy bármilyen bites hibát észleljen, de kijavítsa azokat,

98
00:05:55,147 --> 00:05:57,300
ismert. az üzletben paritásellenőrzésként.

99
00:05:57,300 --> 00:06:00,487
A paritásellenőrzéshez csak egyetlen bitet választunk ki,

100
00:06:00,487 --> 00:06:04,940
amelynek hangolásáért a küldő felelős, a többi pedig szabadon hordozhat üzenetet.

101
00:06:04,940 --> 00:06:09,062
Ennek a speciális bitnek az egyetlen feladata, hogy megbizonyosodjon arról,

102
00:06:09,062 --> 00:06:12,100
hogy az üzenetben szereplő 1-ek száma páros szám legyen.

103
00:06:12,100 --> 00:06:15,415
Így például jelenleg az 1-ek teljes száma 7, ez páratlan,

104
00:06:15,415 --> 00:06:19,702
tehát a küldőnek meg kell fordítania azt a speciális bitet, hogy 1 legyen,

105
00:06:19,702 --> 00:06:20,960
így a szám páros lesz.

106
00:06:20,960 --> 00:06:24,460
De ha a blokk már páros számú 1-gyel indult volna,

107
00:06:24,460 --> 00:06:27,480
akkor ez a speciális bit 0-ban maradt volna.

108
00:06:27,480 --> 00:06:31,862
Ez nagyon egyszerű, megtévesztően egyszerű, de hihetetlenül elegáns módja annak,

109
00:06:31,862 --> 00:06:35,054
hogy a változás gondolatát az üzenetben bárhol lepároljuk,

110
00:06:35,054 --> 00:06:37,760
hogy az egyetlen információrészletben tükröződjön.

111
00:06:37,760 --> 00:06:43,160
Figyelje meg, ha ennek az üzenetnek bármely része átfordul, akár 0-ról 1-re,

112
00:06:43,160 --> 00:06:48,140
akár 1-ről 0-ra, az 1-ek teljes számát párosról páratlanra változtatja.

113
00:06:48,140 --> 00:06:53,124
Tehát ha Ön a címzett, megnézi ezt az üzenetet, és páratlan számú 1-et lát,

114
00:06:53,124 --> 00:06:58,700
akkor biztosan tudhatja, hogy hiba történt, még akkor is, ha fogalma sincs, hol volt.

115
00:06:58,700 --> 00:07:03,831
A szakzsargonban azt, hogy egy bitcsoport páros vagy páratlan 1-es számmal rendelkezik,

116
00:07:03,831 --> 00:07:04,940
paritásnak nevezik.

117
00:07:04,940 --> 00:07:08,228
Számokat is használhat, és azt mondhatja, hogy a paritás 0 vagy 1,

118
00:07:08,228 --> 00:07:11,320
ami általában hasznosabb, ha elkezdi a matematikát az ötlettel.

119
00:07:11,320 --> 00:07:16,509
Ezt a speciális bitet pedig, amelyet a küldő a paritás szabályozására használ,

120
00:07:16,509 --> 00:07:18,020
paritásbitnek nevezzük.

121
00:07:18,020 --> 00:07:21,604
És tulajdonképpen tisztán kell lennünk, ha a vevő páratlan paritást lát,

122
00:07:21,604 --> 00:07:25,631
az nem feltétlenül azt jelenti, hogy csak egy hiba volt, lehet, hogy 3 hiba volt,

123
00:07:25,631 --> 00:07:29,560
vagy 5, vagy bármilyen más páratlan szám, de biztosan tudhatják hogy nem 0 volt.

124
00:07:29,560 --> 00:07:32,807
Másrészt, ha 2 vagy páros számú hiba történt volna,

125
00:07:32,807 --> 00:07:35,991
akkor az 1-ek végső száma továbbra is páros lenne,

126
00:07:35,991 --> 00:07:40,924
így a fogadó nem lehet teljesen biztos abban, hogy a páros szám szükségszerűen

127
00:07:40,924 --> 00:07:43,360
azt jelenti, hogy az üzenet hibamentes.

128
00:07:43,360 --> 00:07:47,812
Panaszkodhat, hogy egy üzenet, amely csak 2 bites átfordulással összezavarodik,

129
00:07:47,812 --> 00:07:49,760
elég gyenge, és teljesen igaza van.

130
00:07:49,760 --> 00:07:54,342
Ne feledje azonban, hogy nincs olyan hibaészlelési vagy -javítási módszer,

131
00:07:54,342 --> 00:07:59,720
amely 100%-os biztonságot adna afelől, hogy a kapott üzenetet a küldő szándéka szerinti.

132
00:07:59,720 --> 00:08:02,465
Végtére is, elegendő véletlenszerű zaj pusztán véletlenül

133
00:08:02,465 --> 00:08:05,920
megváltoztathatja az egyik érvényes üzenetet egy másik érvényes üzenetté.

134
00:08:05,920 --> 00:08:11,292
Ehelyett az a cél, hogy egy bizonyos maximális számú hibaig robusztus sémát dolgozzunk

135
00:08:11,292 --> 00:08:16,480
ki, vagy esetleg csökkentsük az ehhez hasonló téves pozitív eredmény valószínűségét.

136
00:08:16,480 --> 00:08:19,482
A paritásellenőrzések önmagukban meglehetősen gyengék,

137
00:08:19,482 --> 00:08:24,287
de ha a változás gondolatát egy teljes üzeneten keresztül egyetlen bitig desztilláljuk,

138
00:08:24,287 --> 00:08:28,000
azt adják, hogy hatékony építőelemet adnak a kifinomultabb sémákhoz.

139
00:08:28,000 --> 00:08:31,340
Például, amikor Hamming egy módot keresett annak azonosítására,

140
00:08:31,340 --> 00:08:35,828
hol történt a hiba, nem csak azt, hogy megtörtént, kulcsfontosságú meglátása az volt,

141
00:08:35,828 --> 00:08:38,802
hogy ha néhány paritásellenőrzést nem a teljes üzenetre,

142
00:08:38,802 --> 00:08:42,038
hanem bizonyos gondosan kiválasztott részhalmazokra alkalmaz,

143
00:08:42,038 --> 00:08:44,648
akkor megkérdezheti. egy kifinomultabb kérdéssor,

144
00:08:44,648 --> 00:08:46,840
amely meghatározza bármely bithiba helyét.

145
00:08:46,840 --> 00:08:50,681
Az általános érzés egy kicsit olyan, mintha egy 20 kérdésből álló játékot játszanánk,

146
00:08:50,681 --> 00:08:54,300
és igen vagy nem kérdéseket tennénk fel, amelyek kettévágják a lehetőségek terét.

147
00:08:54,300 --> 00:08:58,564
Tegyük fel például, hogy csak ezen a 8 biten végezzük el a paritásellenőrzést,

148
00:08:58,564 --> 00:09:00,400
az összes páratlan számú pozíciót.

149
00:09:00,400 --> 00:09:04,749
Aztán ha hibát észlel, egy kicsit több információt ad a vevőnek arról,

150
00:09:04,749 --> 00:09:09,160
hogy pontosan hol van a hiba, nevezetesen, hogy páratlan helyzetben van.

151
00:09:09,160 --> 00:09:13,412
Ha a 8 bit között nem észlelünk hibát, az vagy azt jelenti,

152
00:09:13,412 --> 00:09:17,240
hogy nincs hiba, vagy valahol a páros pozíciókban van.

153
00:09:17,240 --> 00:09:21,822
Azt gondolhatnánk, hogy ha a paritásellenőrzést a bitek felére korlátozzuk,

154
00:09:21,822 --> 00:09:27,067
az kevésbé hatékony, de ha más jól megválasztott ellenőrzésekkel együtt hajtjuk végre,

155
00:09:27,067 --> 00:09:29,720
akkor az intuitív módon sokkal erősebbet ad.

156
00:09:29,720 --> 00:09:33,774
Ne feledje, hogy a paritásellenőrzés tényleges beállításához speciális

157
00:09:33,774 --> 00:09:37,600
bitet kell kijelölni, amely szabályozza a teljes csoport paritását.

158
00:09:37,600 --> 00:09:39,920
Itt csak válasszuk ki az 1. pozíciót.

159
00:09:39,920 --> 00:09:44,040
A bemutatott példában ennek a 8 bitnek a paritása jelenleg páratlan,

160
00:09:44,040 --> 00:09:48,220
tehát a feladó felelős a paritásbit átkapcsolásáért, most pedig páros.

161
00:09:48,220 --> 00:09:51,040
Ez csak 1 a 4 paritásellenőrzésből, amit elvégezünk.

162
00:09:51,040 --> 00:09:54,952
A második ellenőrzés a rács jobb felében található 8 bit között van,

163
00:09:54,952 --> 00:09:56,880
legalábbis ahogy itt megrajzoltuk.

164
00:09:56,880 --> 00:10:00,204
Ezúttal a 2-es pozíciót használhatjuk paritásbitként,

165
00:10:00,204 --> 00:10:04,882
így ennek a 8 bitnek már van páros paritása, és a küldő jól érezheti magát,

166
00:10:04,882 --> 00:10:07,160
ha a 2-es bitet változatlanul hagyja.

167
00:10:07,160 --> 00:10:11,635
Aztán a másik végén, ha a vevő ellenőrzi ennek a csoportnak a paritását, és azt találja,

168
00:10:11,635 --> 00:10:15,960
hogy ez furcsa, akkor tudni fogja, hogy a hiba valahol a jobb oldali 8 bit között van.

169
00:10:15,960 --> 00:10:21,260
Ellenkező esetben ez azt jelenti, hogy nincs hiba, vagy a hiba valahol a bal oldalon van.

170
00:10:21,260 --> 00:10:24,742
Vagy azt hiszem, két hiba is lehetett, de jelenleg azt feltételezzük,

171
00:10:24,742 --> 00:10:27,080
hogy legfeljebb egy hiba van az egész blokkban.

172
00:10:27,080 --> 00:10:29,160
Ennél többért teljesen összeomlanak a dolgok.

173
00:10:29,160 --> 00:10:32,960
Mielőtt megvizsgálnánk a következő két ellenőrzést, gondoljunk át egy pillanatra,

174
00:10:32,960 --> 00:10:35,880
hogy az első kettő mit tesz lehetővé, ha együtt tekintjük őket.

175
00:10:35,880 --> 00:10:40,240
Tegyük fel, hogy hibát észlel a páratlan oszlopok között és a jobb felében.

176
00:10:40,240 --> 00:10:43,940
Ez szükségszerűen azt jelenti, hogy a hiba valahol az utolsó oszlopban van.

177
00:10:43,940 --> 00:10:47,010
Ha a páratlan oszlopban nem volt hiba, de a jobb felében volt,

178
00:10:47,010 --> 00:10:50,520
akkor ez azt jelzi, hogy a másodiktól az utolsóig terjedő oszlopban van.

179
00:10:50,520 --> 00:10:53,004
Hasonlóképpen, ha hiba van a páratlan oszlopokban,

180
00:10:53,004 --> 00:10:56,560
de nem a jobb felében, akkor tudja, hogy valahol a második oszlopban van.

181
00:10:56,560 --> 00:10:59,760
És ha a két paritásellenőrzés egyike sem észlel semmit,

182
00:10:59,760 --> 00:11:03,760
akkor az egyetlen hely, ahol hiba lehet, a bal szélső oszlopban lehet.

183
00:11:03,760 --> 00:11:06,480
De ez azt is jelentheti, hogy egyáltalán nincs hiba.

184
00:11:06,480 --> 00:11:09,114
Ez egy meglehetősen elcsépelt módja annak, hogy két

185
00:11:09,114 --> 00:11:11,800
paritásellenőrzés segítségével rögzítsük az oszlopot.

186
00:11:11,800 --> 00:11:14,000
Innentől valószínűleg sejtheti, mi következik.

187
00:11:14,000 --> 00:11:16,240
Alapvetően ugyanazt csináljuk, csak a sorok esetében.

188
00:11:16,240 --> 00:11:21,040
A páratlan sorokon paritásellenőrzés történik, a 4-es pozíciót használva paritásbitként.

189
00:11:21,040 --> 00:11:24,741
Tehát ebben a példában ennek a csoportnak már van páros paritása,

190
00:11:24,741 --> 00:11:26,480
így a 4. bit 0-ra lesz állítva.

191
00:11:26,480 --> 00:11:29,802
És végül van egy paritásellenőrzés az alsó két sorban,

192
00:11:29,802 --> 00:11:32,280
a 8-as pozíciót használva paritásbitként.

193
00:11:32,280 --> 00:11:35,651
Ebben az esetben úgy tűnik, hogy a küldőnek be kell kapcsolnia a 8-as bitet,

194
00:11:35,651 --> 00:11:37,840
hogy egyenletes paritást biztosítson a csoportnak.

195
00:11:37,840 --> 00:11:40,775
Ahogy az első két ellenőrzés lehetővé teszi az oszlop rögzítését,

196
00:11:40,775 --> 00:11:43,000
a következő kettő lehetővé teszi a sor rögzítését.

197
00:11:43,000 --> 00:11:48,400
Példaként képzeljük el, hogy az átvitel során hiba történik, mondjuk a 3. pozícióban.

198
00:11:48,400 --> 00:11:52,451
Nos, ez érinti az első paritáscsoportot, és a második paritáscsoportot is,

199
00:11:52,451 --> 00:11:56,340
tehát a vevő tudja, hogy valahol hiba van abban a jobb oldali oszlopban.

200
00:11:56,340 --> 00:12:01,380
De ez nem érinti a harmadik csoportot, és nem érinti a negyedik csoportot.

201
00:12:01,380 --> 00:12:05,211
Ez pedig lehetővé teszi, hogy a vevő pontosan az első sorig azonosítsa a hibát,

202
00:12:05,211 --> 00:12:08,660
ami szükségszerűen a 3. pozíciót jelenti, így ki tudja javítani a hibát.

203
00:12:08,660 --> 00:12:11,475
Szívesen szánhat egy pillanatot arra, hogy meggyőzze magát arról,

204
00:12:11,475 --> 00:12:14,376
hogy a négy kérdésre adott válaszok valóban mindig lehetővé teszik,

205
00:12:14,376 --> 00:12:17,320
hogy meghatározzon egy adott helyet, függetlenül attól, hogy hol van.

206
00:12:17,320 --> 00:12:20,155
Valójában az okoskodók még azt is észrevehetik,

207
00:12:20,155 --> 00:12:23,640
hogy van kapcsolat e kérdések és a bináris számolás között.

208
00:12:23,640 --> 00:12:26,828
És ha igen, hadd hangsúlyozzam ismét, állj meg,

209
00:12:26,828 --> 00:12:30,880
próbáld meg magad megvonni az összefüggést, mielőtt elrontom.

210
00:12:30,880 --> 00:12:36,560
Ha kíváncsi arra, hogy mi történik, ha magát a paritásbitet érinti, akkor megpróbálhatja.

211
00:12:36,560 --> 00:12:39,484
Szánjon egy pillanatot arra, hogy gondolja végig,

212
00:12:39,484 --> 00:12:43,754
hogyan lehet e négy speciális bit közötti hibát ugyanúgy nyomon követni,

213
00:12:43,754 --> 00:12:47,440
mint bármely mást, ugyanazzal a négy kérdésből álló csoporttal.

214
00:12:47,440 --> 00:12:51,709
Teljesen mindegy, hiszen végső soron az üzenetbiteket akarjuk megvédeni,

215
00:12:51,709 --> 00:12:53,640
a hibajavító bitek csak haladnak.

216
00:12:53,640 --> 00:12:59,260
De ezeknek a biteknek a védelme is melléktermékként természetesen kiesik a rendszerből.

217
00:12:59,260 --> 00:13:02,380
Azt is élvezheti, ha előre látja, hogy ez hogyan skálázódik.

218
00:13:02,380 --> 00:13:08,153
Ha például egy 256 bites méretű blokkot használtunk egy hely meghatározásához,

219
00:13:08,153 --> 00:13:12,464
akkor mindössze nyolc igen vagy nem kérdésre van szüksége,

220
00:13:12,464 --> 00:13:15,680
hogy binárisan keressen egy bizonyos helyre.

221
00:13:15,680 --> 00:13:19,396
És ne feledje, minden kérdés csak egyetlen bitet

222
00:13:19,396 --> 00:13:23,340
igényel a megfelelő paritásellenőrzés beállításához.

223
00:13:23,340 --> 00:13:26,117
Lehet, hogy néhányan már látják, de később beszélünk arról,

224
00:13:26,117 --> 00:13:29,960
hogyan lehet szisztematikusan egy-két percen belül kideríteni, mik ezek a kérdések.

225
00:13:29,960 --> 00:13:32,369
Remélhetőleg ez a vázlat elegendő ahhoz, hogy értékeljük

226
00:13:32,369 --> 00:13:34,440
az itt fejlesztendő tevékenységünk hatékonyságát.

227
00:13:34,440 --> 00:13:38,113
Az első dolog, a nyolc kiemelt paritásbit kivételével,

228
00:13:38,113 --> 00:13:41,720
bármi lehet, bármilyen üzenetet vagy adatot hordozhat.

229
00:13:41,720 --> 00:13:47,342
A 8 bit redundáns abban az értelemben, hogy teljesen az üzenet többi része

230
00:13:47,342 --> 00:13:53,640
határozza meg őket, de ez sokkal okosabb módszer, mint az üzenet egészének másolása.

231
00:13:53,640 --> 00:13:56,378
És mégis, ennyire kevés feladással képes lenne

232
00:13:56,378 --> 00:13:59,000
azonosítani és kijavítani bármelyik bithibát.

233
00:13:59,000 --> 00:14:00,400
Hát majdnem.

234
00:14:00,400 --> 00:14:04,579
Oké, itt az egyetlen probléma az, hogy ha a négy paritásellenőrzés egyike sem

235
00:14:04,579 --> 00:14:09,080
észlel hibát, ami azt jelenti, hogy a speciálisan kiválasztott 8 bites részhalmazok

236
00:14:09,080 --> 00:14:12,616
mindegyikének páros paritása van, ahogy a küldő szándéka szerint,

237
00:14:12,616 --> 00:14:17,224
akkor ez vagy azt jelenti, hogy egyáltalán nem volt hiba. , vagy leszűkít minket a 0.

238
00:14:17,224 --> 00:14:17,760
pozícióba.

239
00:14:17,760 --> 00:14:22,076
Négy igen vagy nem kérdés esetén 16 lehetséges kimenetelünk van a

240
00:14:22,076 --> 00:14:27,374
paritásellenőrzésünkhöz, és ez elsőre tökéletesnek tűnik a blokk 16 pozíciójából

241
00:14:27,374 --> 00:14:33,000
1 pontos meghatározásához, de közölnie kell a 17. eredményt is, a nem hibát. feltétel.

242
00:14:33,000 --> 00:14:37,860
A megoldás itt valójában nagyon egyszerű, csak felejtsd el teljesen a 0. bitet.

243
00:14:37,860 --> 00:14:41,160
Tehát amikor elvégezzük a négy paritásellenőrzésünket, és azt látjuk,

244
00:14:41,160 --> 00:14:44,320
hogy mindegyik páros, az egyértelműen azt jelenti, hogy nincs hiba.

245
00:14:44,320 --> 00:14:47,845
Ez azt jelenti, hogy ahelyett, hogy egy 16 bites blokkal dolgoznánk,

246
00:14:47,845 --> 00:14:52,291
mi egy 15 bites blokkkal dolgozunk, ahol a bitek közül 11 szabadon hordozhat üzenetet,

247
00:14:52,291 --> 00:14:54,080
és közülük 4 redundancia miatt van.

248
00:14:54,080 --> 00:14:59,400
És ezzel most megvan, amit az üzletemberek 15-11 Hamming-kódként emlegetnének.

249
00:14:59,400 --> 00:15:03,089
Ennek ellenére jó, hogy van egy blokkméret, amely 2-es tiszta hatványt jelent,

250
00:15:03,089 --> 00:15:05,891
és van egy okos módszer, amellyel megtarthatjuk a 0. bitet,

251
00:15:05,891 --> 00:15:08,880
és rávehetjük, hogy egy kis plusz munkát végezzen el helyettünk.

252
00:15:08,880 --> 00:15:11,746
Ha paritásbitként használjuk az egész blokkon,

253
00:15:11,746 --> 00:15:16,320
akkor ténylegesen felismerjük a 2 bites hibákat, bár nem tudjuk kijavítani.

254
00:15:16,320 --> 00:15:17,440
Íme, hogyan működik.

255
00:15:17,440 --> 00:15:21,340
Miután beállítottuk a négy speciális hibajavító bitet, beállítjuk azt a 0-at,

256
00:15:21,340 --> 00:15:25,540
hogy a teljes blokk paritása páros legyen, akárcsak egy normál paritásellenőrzésnél.

257
00:15:25,540 --> 00:15:29,873
Most, ha egyetlen bites hiba van, akkor a teljes blokk paritása páratlanra vált,

258
00:15:29,873 --> 00:15:33,940
de a négy hibajavító ellenőrzésnek köszönhetően ezt mindenképpen megfognánk.

259
00:15:33,940 --> 00:15:39,251
Ha azonban két hiba van, akkor a teljes paritás vissza fog váltani párosra,

260
00:15:39,251 --> 00:15:45,400
de a vevő továbbra is látja, hogy legalább valami hiba történt a négy paritásellenőrzés

261
00:15:45,400 --> 00:15:45,820
miatt.

262
00:15:45,820 --> 00:15:48,330
Tehát ha összességében egyenletes paritást észlelnek,

263
00:15:48,330 --> 00:15:51,538
de a többi ellenőrzésnél valami nem nulla történik, akkor azt jelzi,

264
00:15:51,538 --> 00:15:52,980
hogy legalább két hiba történt.

265
00:15:52,980 --> 00:15:54,420
Hát nem okos?

266
00:15:54,420 --> 00:15:57,692
Annak ellenére, hogy ezeket a 2 bites hibákat nem tudjuk kijavítani,

267
00:15:57,692 --> 00:16:01,391
pusztán az egyetlen zavaró 0. bit visszaállításával lehetővé teszi számunkra,

268
00:16:01,391 --> 00:16:02,340
hogy észleljük őket.

269
00:16:02,340 --> 00:16:06,540
Ez meglehetősen szabványos, kiterjesztett Hamming-kódként ismert.

270
00:16:06,540 --> 00:16:09,620
Technikailag szólva, most már teljes leírása van arról,

271
00:16:09,620 --> 00:16:13,580
hogy mit csinál egy Hamming-kód, legalábbis egy 16 bites blokk esetében.

272
00:16:13,580 --> 00:16:17,570
De azt hiszem, sokkal elégedettebb lesz, ha ellenőrizni fogja a megértését,

273
00:16:17,570 --> 00:16:21,980
és mindent megszilárdít idáig úgy, hogy egy teljes példát tesz az elejétől a végéig.

274
00:16:21,980 --> 00:16:25,100
De végigcsinálom veled, hogy ellenőrizd magad.

275
00:16:25,100 --> 00:16:28,121
Üzenet beállításához, legyen szó szó szerinti üzenetről,

276
00:16:28,121 --> 00:16:30,771
amelyet térben fordít le, vagy bizonyos adatokat,

277
00:16:30,771 --> 00:16:33,580
amelyeket idővel tárolni szeretne, az első lépés az,

278
00:16:33,580 --> 00:16:35,700
hogy fel kell osztani 11 bites részekre.

279
00:16:35,700 --> 00:16:40,340
Minden egyes darab egy hibaálló 16 bites blokkba kerül.

280
00:16:40,340 --> 00:16:43,740
Tehát vegyük ezt példaként, és dolgozzuk ki ténylegesen.

281
00:16:43,740 --> 00:16:45,380
Hajrá, tényleg tedd meg!

282
00:16:45,380 --> 00:16:52,980
Álljunk meg, és próbáljuk összerakni ezt a blokkot.

283
00:16:52,980 --> 00:16:53,980
Oké, készen állsz?

284
00:16:53,980 --> 00:16:59,672
Ne feledje, hogy a 0 pozíció a 2 többi hatványával együtt hibajavítási feladatra van

285
00:16:59,672 --> 00:17:05,700
fenntartva, tehát először az üzenetbiteket az összes többi helyre, sorrendben helyezze el.

286
00:17:05,700 --> 00:17:09,367
Ennek a csoportnak páros paritásúnak kell lennie, ami már így is van,

287
00:17:09,367 --> 00:17:13,140
tehát azt a paritásbitet az 1-es pozícióban 0-ra kellett volna állítani.

288
00:17:13,140 --> 00:17:16,200
A következő csoport páratlan paritással kezdődik,

289
00:17:16,200 --> 00:17:19,260
ezért a paritásbitjét 1-re kellett volna állítani.

290
00:17:19,260 --> 00:17:21,898
Az ezt követő csoport páratlan paritással kezdődik,

291
00:17:21,898 --> 00:17:24,740
tehát ismét 1-re kellett volna állítani a paritásbitjét.

292
00:17:24,740 --> 00:17:27,990
És az utolsó csoportnak is van páratlan paritása,

293
00:17:27,990 --> 00:17:31,500
vagyis azt a bitet a 8-as pozícióban 1-re állítjuk be.

294
00:17:31,500 --> 00:17:35,824
Utolsó lépésként a teljes blokk páros paritású,

295
00:17:35,824 --> 00:17:41,500
vagyis beállíthatja a 0 bitszámot, az átfogó paritásbitet 0-ra.

296
00:17:41,500 --> 00:17:45,240
Tehát amikor ez a blokk elküldésre kerül, a négy speciális

297
00:17:45,240 --> 00:17:48,980
részhalmaz és a blokk egészének paritása páros vagy 0 lesz.

298
00:17:48,980 --> 00:17:53,620
A gyakorlat második részeként játsszuk a befogadó szerepét.

299
00:17:53,620 --> 00:17:57,212
Természetesen ez azt jelentené, hogy még nem tudja, mi ez az üzenet,

300
00:17:57,212 --> 00:18:00,180
talán néhányan megjegyezték, de tegyük fel, hogy még nem.

301
00:18:00,180 --> 00:18:05,237
Azt fogom tenni, hogy megváltoztatom a 0, 1 vagy 2 bitet ebben a blokkban,

302
00:18:05,237 --> 00:18:08,340
majd megkérem, hogy találja ki, mit csináltam.

303
00:18:08,340 --> 00:18:13,460
Tehát ismét álljon meg, és próbálja meg megoldani.

304
00:18:13,460 --> 00:18:22,228
Oké, tehát Ön, mint vevő, most ellenőrizze az első paritáscsoportot, és láthatja,

305
00:18:22,228 --> 00:18:29,820
hogy az páros, tehát minden létező hibának páros oszlopban kell lennie.

306
00:18:29,820 --> 00:18:34,039
A következő ellenőrzés páratlan számot ad nekünk, jelezve,

307
00:18:34,039 --> 00:18:38,760
hogy legalább egy hiba van, és leszűkítve erre a konkrét oszlopra.

308
00:18:38,760 --> 00:18:42,900
A harmadik ellenőrzés kiegyenlített, ami még tovább csökkenti a lehetőségeket.

309
00:18:42,900 --> 00:18:48,076
Az utolsó paritásellenőrzés pedig páratlan, és azt jelzi, hogy valahol alul van egy hiba,

310
00:18:48,076 --> 00:18:51,700
amiről mostanra láthatjuk, hogy a 10-es pozícióban kell lennie.

311
00:18:51,700 --> 00:18:55,929
Sőt, az egész blokk paritása furcsa, ami azt a bizonyosságot ad nekünk,

312
00:18:55,929 --> 00:18:58,220
hogy egy átfordulás volt, és nem kettő.

313
00:18:58,220 --> 00:19:01,600
Ha három vagy több, akkor minden fogadás megszűnik.

314
00:19:01,600 --> 00:19:06,320
A 10-es számú bit kijavítása után a korrekcióhoz nem használt 11 bitet

315
00:19:06,320 --> 00:19:10,176
kihúzva megkapjuk az eredeti üzenet megfelelő szegmensét,

316
00:19:10,176 --> 00:19:16,160
amely ha visszatekerjük és összehasonlítjuk, valóban pontosan az, amivel kezdtük a példát.

317
00:19:16,160 --> 00:19:20,099
És most, hogy tudja, hogyan kell mindezt kézzel megtenni, szeretném megmutatni,

318
00:19:20,099 --> 00:19:23,940
hogyan hajthatja végre ennek a logikának a lényegét egyetlen Python-kódsorral.

319
00:19:23,940 --> 00:19:28,518
Látod, amit még nem mondtam el, az az, hogy valójában mennyire elegáns ez az algoritmus,

320
00:19:28,518 --> 00:19:31,862
milyen egyszerű rávenni a gépet, hogy rámutasson a hiba helyére,

321
00:19:31,862 --> 00:19:36,287
hogyan lehet szisztematikusan skálázni, és hogyan tudjuk keretbe foglalni az egészet.

322
00:19:36,287 --> 00:19:39,580
ez egyetlen művelet, nem pedig több különálló paritásellenőrzés.

323
00:19:39,580 --> 00:19:39,580
Ha szeretnéd megérteni, mire gondolok, csatlakozz hozzám a 2. részhez.

