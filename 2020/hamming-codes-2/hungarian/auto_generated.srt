1
00:00:00,000 --> 00:00:08,620
Elgondolkozott már azon, hogyan lehetséges egy CD-t vagy

2
00:00:08,620 --> 00:00:10,900
DVD-t megkarcolni, és még mindig lejátszani, amit tárol?

3
00:00:10,900 --> 00:00:15,280
A karcolás valóban hatással van a lemezen lévő 1-ekre és 0-kra,

4
00:00:15,280 --> 00:00:20,500
tehát a tárolttól eltérő adatokat olvas ki, de hacsak nem

5
00:00:20,500 --> 00:00:26,540
teljesen összekarcolódott, a kiolvasott bitek pontosan ugyanabba a fájlba dekódolódnak, mint

6
00:00:26,540 --> 00:00:28,400
amilyenre rá volt kódolva. bit a bitmásoláshoz, mindezen hibák ellenére.

7
00:00:28,400 --> 00:00:32,800
Számtalan matematikai okosság van, amely lehetővé teszi az adatok tárolását, és ami

8
00:00:32,800 --> 00:00:36,840
ugyanilyen fontos, hogy adatokat továbbítsunk olyan módon, amely ellenáll a hibáknak.

9
00:00:36,840 --> 00:00:41,480
Nos, oké, valójában nem kell akkora

10
00:00:41,480 --> 00:00:42,480
okosság, hogy kitaláljon egy módot erre.

11
00:00:42,480 --> 00:00:47,660
Bármely fájl, legyen szó videóról, hangról vagy szövegről, valamilyen kódról,

12
00:00:47,660 --> 00:00:50,960
képről vagy bármi másról, végső soron 1-esek és 0-k sorozata.

13
00:00:50,960 --> 00:00:55,340
A megfordított bitek kijavítására egy egyszerű stratégia az

14
00:00:55,340 --> 00:00:57,780
lenne, ha minden bitből három másolatot tárolunk.

15
00:00:57,780 --> 00:01:02,240
Ekkor a fájlt olvasó gép össze tudja hasonlítani ezt a három másolatot,

16
00:01:02,240 --> 00:01:07,440
és mindig a legjobb 2-t kapja a 3-ból, ha eltérés van.

17
00:01:07,440 --> 00:01:11,560
De ez azt jelenti, hogy a hely kétharmadát redundanciára használja.

18
00:01:11,560 --> 00:01:15,360
És még akkor sem, ha az összes helyet feladjuk, nincs komoly

19
00:01:15,360 --> 00:01:18,120
garancia arra, hogy mi történik, ha egynél több bitet megfordítanak.

20
00:01:18,120 --> 00:01:21,960
Sokkal érdekesebb kérdés, hogy hogyan lehet úgy megcsinálni, hogy a

21
00:01:21,960 --> 00:01:24,740
hibákat a lehető legkevesebb hely elhagyása mellett ki lehessen javítani.

22
00:01:24,740 --> 00:01:28,500
Például a videóról megismert módszerrel 256 bites blokkokban tárolhatja adatait, ahol

23
00:01:28,500 --> 00:01:35,840
minden blokk 9, 9 bitet használ! egyfajta redundanciaként működik, a többi 247

24
00:01:35,840 --> 00:01:41,000
bit pedig szabadon hordozhat bármilyen értelmes üzenetet vagy adatot, amit csak akar.

25
00:01:41,000 --> 00:01:44,740
És továbbra is az lesz, hogy ha itt bármelyik bit megfordul, csak erre

26
00:01:44,740 --> 00:01:49,640
a blokkra nézve, és semmi másra, a gép képes lesz azonosítani, hogy hiba

27
00:01:49,640 --> 00:01:53,120
történt, és hogy pontosan hol volt, így tudja, hogyan kell kijavítani. .

28
00:01:53,140 --> 00:01:55,540
És őszintén szólva, ez varázslatnak tűnik.

29
00:01:55,540 --> 00:01:59,400
És ennél a konkrét sémánál, ha két bit megfordul, a gép

30
00:01:59,400 --> 00:02:03,180
legalább két hibát észlel, bár nem tudja, hogyan javítsa ki őket.

31
00:02:03,180 --> 00:02:08,140
Egy kicsit később beszélünk arról, hogy ez hogyan skálázható a különböző méretű blokkokhoz.

32
00:02:08,140 --> 00:02:12,620
Az ehhez hasonló hibák kijavítását lehetővé

33
00:02:12,620 --> 00:02:13,880
tevő módszereket ésszerűen hibajavító kódokként ismerik.

34
00:02:13,880 --> 00:02:18,220
A múlt század nagy részében ez a terület a meglepően mély

35
00:02:18,220 --> 00:02:23,000
matematikai adatok gazdag forrása volt, amely beépül a mindennapi használatunkba.

36
00:02:23,000 --> 00:02:27,740
Itt az a cél, hogy nagyon alapos megértést

37
00:02:27,740 --> 00:02:29,660
nyújtsunk az egyik legkorábbi, Hamming-kódként ismert példának.

38
00:02:29,660 --> 00:02:32,620
És mellesleg, ahogyan ennek a videónak a felépítésére gondolok, kevésbé arról

39
00:02:32,620 --> 00:02:37,060
van szó, hogy a lehető legközvetlenebbül magyarázzam el, hanem inkább arra

40
00:02:37,060 --> 00:02:40,220
ösztönözzek, hogy találd ki magadnak, itt-ott egy kis gyengéd irányítással.

41
00:02:40,220 --> 00:02:44,100
Tehát amikor úgy érzed, hogy egy ponton látod, merre tart, szánj arra a

42
00:02:44,100 --> 00:02:47,180
pillanatra egy szünetet, és aktívan jósold meg, mi lesz a terv, mielőtt elmondanám.

43
00:02:47,180 --> 00:02:51,500
Továbbá, ha azt szeretné, hogy megértése a hardver szintjére jusson, Ben

44
00:02:51,500 --> 00:02:55,160
Eater készített egy videót ehhez a videóhoz, amely bemutatja, hogyan

45
00:02:55,160 --> 00:02:59,520
kell ténylegesen implementálni a Hamming-kódokat a kenyérlapokon, ami rendkívül kielégítő.

46
00:02:59,520 --> 00:03:03,120
Tudnod kell, a Hamming-kódokat nem használják olyan széles körben, mint a modernebb kódokat, mint

47
00:03:03,120 --> 00:03:08,040
például a Reed-Solomon algoritmus, de van egy bizonyos varázslat a kontrasztban aközött, hogy mennyire

48
00:03:08,040 --> 00:03:14,240
lehetetlennek tűnik ez a feladat az elején, és mennyire ésszerűnek tűnik egyszer. tanulsz Hammingről.

49
00:03:14,240 --> 00:03:19,080
A hibajavítás alapelve, hogy az összes lehetséges üzenet

50
00:03:19,300 --> 00:03:22,860
hatalmas területén csak egy részhalmaz tekinthető érvényes üzenetnek.

51
00:03:22,860 --> 00:03:29,100
Analógiaként gondoljon a helyesen írt szavakra a helytelenül írt szavakra.

52
00:03:29,100 --> 00:03:33,340
Amikor egy érvényes üzenetet módosítanak, a fogadó felelős azért, hogy a látottakat

53
00:03:33,340 --> 00:03:38,380
a legközelebbi érvényes szomszédhoz javítsa, ahogyan azt az elírások esetén is megteheti.

54
00:03:38,380 --> 00:03:43,100
Egy konkrét algoritmus kidolgozása az ehhez hasonló

55
00:03:43,100 --> 00:03:47,160
üzenetek hatékony kategorizálására azonban bizonyos okosságot igényel.

56
00:03:47,160 --> 00:03:52,060
A történet az 1940-es években kezdődik, amikor egy fiatal Richard Hamming

57
00:03:52,060 --> 00:03:55,900
a Bell Labs-nál dolgozott, és néhány munkája egy nagyon nagy,

58
00:03:55,900 --> 00:03:57,420
drága lyukkártyás számítógép használatából állt, amelyhez csak korlátozott hozzáférése volt.

59
00:03:57,420 --> 00:04:01,200
És a programok, amiket folyamatosan csinált, folyamatosan

60
00:04:01,200 --> 00:04:03,140
kudarcot vallottak, mert időnként egy kicsit félreolvastak.

61
00:04:03,140 --> 00:04:07,140
Mivel a frusztráció a találmány tégelye, annyira elege

62
00:04:07,140 --> 00:04:09,280
lett, hogy feltalálta a világ első hibajavító kódját.

63
00:04:09,280 --> 00:04:13,020
A Hamming-kódok keretbe foglalásának sokféle módja van, de első

64
00:04:13,020 --> 00:04:16,620
lépésként úgy megyünk végig, ahogy Hamming gondolta róluk.

65
00:04:16,620 --> 00:04:21,400
Használjunk egy egyszerű, de nem túl egyszerű példát, egy 16 bites blokkot.

66
00:04:21,400 --> 00:04:25,700
Ezeknek a biteknek a pozícióit 0-tól 15-ig számozzuk.

67
00:04:25,700 --> 00:04:30,520
A tárolni kívánt tényleges adatok csak 12 bitet tesznek ki ebből

68
00:04:30,520 --> 00:04:33,920
a bitből, míg a pozíciók közül 4 egyfajta redundanciaként van fenntartva.

69
00:04:33,920 --> 00:04:38,120
A redundáns szó itt nem egyszerűen másolást jelent, elvégre az

70
00:04:38,120 --> 00:04:40,200
a 4 bit nem ad elég teret az adatok vakmásolására.

71
00:04:40,200 --> 00:04:44,880
Ehelyett sokkal árnyaltabb és okosabb redundanciát kell

72
00:04:44,880 --> 00:04:48,740
alkalmazniuk, nem új információkkal, hanem rugalmassággal.

73
00:04:48,740 --> 00:04:52,620
Arra számíthat, hogy ez a 4 speciális bit szépen össze van

74
00:04:52,620 --> 00:04:56,400
csomagolva, talán a végén, vagy valami hasonló, de amint látni

75
00:04:56,400 --> 00:05:00,320
fogja, ha 2-es pozícióban ülnek, valami igazán elegáns a végére.

76
00:05:00,320 --> 00:05:05,420
Ez is adhat egy kis utalást arra vonatkozóan, hogyan méretezhető ez a nagyobb blokkokhoz.

77
00:05:05,420 --> 00:05:09,220
Technikailag is csak 11 bites adat lesz, és látni fogja, hogy van egy

78
00:05:09,220 --> 00:05:14,260
enyhe árnyalat a 0. pozícióban zajló eseményekhez, de ez most ne aggódjon.

79
00:05:14,280 --> 00:05:18,640
Mint minden hibajavító algoritmus, ez is két játékost foglal magában, egy

80
00:05:18,640 --> 00:05:23,200
feladót, aki a 4 speciális bit beállításáért felelős, és egy

81
00:05:23,200 --> 00:05:26,360
vevőt, aki valamilyen ellenőrzés elvégzéséért és a hibák kijavításáért felelős.

82
00:05:26,360 --> 00:05:30,040
Természetesen a küldő és fogadó szavak valóban olyan gépekre vagy

83
00:05:30,040 --> 00:05:34,040
szoftverekre utalnak, amelyek minden ellenőrzést elvégeznek, és az üzenet

84
00:05:34,040 --> 00:05:35,480
fogalma nagyon tág értelemben értendő, beleértve például a tárolást.

85
00:05:35,480 --> 00:05:39,320
Végül is az adatok tárolása ugyanaz, mint üzenetet küldeni a

86
00:05:39,320 --> 00:05:42,640
múltból a jövőbe, nem pedig egyik helyről a másikra.

87
00:05:42,640 --> 00:05:46,700
Tehát ez a beállítás, de mielőtt belemerülnénk, beszélnünk kell egy

88
00:05:46,700 --> 00:05:51,080
kapcsolódó ötletről, amely Hammingnek a felfedezése idején frissen járt,

89
00:05:51,080 --> 00:05:55,520
egy olyan módszerről, amely lehetővé teszi, hogy bármilyen bites

90
00:05:55,520 --> 00:05:57,300
hibát észleljen, de kijavítsa azokat, ismert. az üzletben paritásellenőrzésként.

91
00:05:57,300 --> 00:06:01,300
A paritásellenőrzéshez csak egyetlen bitet választunk ki, amelynek hangolásáért

92
00:06:01,300 --> 00:06:04,940
a küldő felelős, a többi pedig szabadon hordozhat üzenetet.

93
00:06:04,940 --> 00:06:10,380
Ennek a speciális bitnek az egyetlen feladata, hogy megbizonyosodjon arról,

94
00:06:10,380 --> 00:06:12,100
hogy az üzenetben szereplő 1-ek száma páros szám legyen.

95
00:06:12,100 --> 00:06:16,920
Így például jelenleg az 1-ek teljes száma 7, ez páratlan, tehát a küldőnek meg

96
00:06:16,920 --> 00:06:20,960
kell fordítania azt a speciális bitet, hogy 1 legyen, így a szám páros lesz.

97
00:06:20,960 --> 00:06:25,320
De ha a blokk már páros számú 1-gyel indult

98
00:06:25,320 --> 00:06:27,480
volna, akkor ez a speciális bit 0-ban maradt volna.

99
00:06:27,480 --> 00:06:31,640
Ez nagyon egyszerű, megtévesztően egyszerű, de hihetetlenül elegáns módja annak, hogy a

100
00:06:31,640 --> 00:06:37,760
változás gondolatát az üzenetben bárhol lepároljuk, hogy az egyetlen információrészletben tükröződjön.

101
00:06:37,760 --> 00:06:43,680
Figyelje meg, ha ennek az üzenetnek bármely része átfordul, akár 0-ról

102
00:06:43,680 --> 00:06:48,140
1-re, akár 1-ről 0-ra, az 1-ek teljes számát párosról páratlanra változtatja.

103
00:06:48,140 --> 00:06:52,000
Tehát ha Ön a címzett, megnézi ezt az üzenetet, és

104
00:06:52,000 --> 00:06:56,580
páratlan számú 1-et lát, akkor biztosan tudhatja, hogy hiba

105
00:06:56,580 --> 00:06:58,700
történt, még akkor is, ha fogalma sincs, hol volt.

106
00:06:58,700 --> 00:07:02,820
A szakzsargonban azt, hogy egy bitcsoport páros

107
00:07:02,820 --> 00:07:04,940
vagy páratlan 1-es számmal rendelkezik, paritásnak nevezik.

108
00:07:04,940 --> 00:07:09,140
Számokat is használhat, és azt mondhatja, hogy a paritás 0 vagy

109
00:07:09,140 --> 00:07:11,320
1, ami általában hasznosabb, ha elkezdi a matematikát az ötlettel.

110
00:07:11,320 --> 00:07:15,200
Ezt a speciális bitet pedig, amelyet a

111
00:07:15,200 --> 00:07:18,020
küldő a paritás szabályozására használ, paritásbitnek nevezzük.

112
00:07:18,020 --> 00:07:22,460
És tulajdonképpen tisztán kell lennünk, ha a vevő páratlan paritást lát, az nem feltétlenül

113
00:07:22,460 --> 00:07:26,920
azt jelenti, hogy csak egy hiba volt, lehet, hogy 3 hiba volt, vagy

114
00:07:26,920 --> 00:07:29,560
5, vagy bármilyen más páratlan szám, de biztosan tudhatják hogy nem 0 volt.

115
00:07:29,560 --> 00:07:34,880
Másrészt, ha 2 vagy páros számú hiba történt volna, akkor az 1-ek végső

116
00:07:34,880 --> 00:07:39,560
száma továbbra is páros lenne, így a fogadó nem lehet teljesen biztos abban,

117
00:07:39,560 --> 00:07:43,360
hogy a páros szám szükségszerűen azt jelenti, hogy az üzenet hibamentes. .

118
00:07:43,360 --> 00:07:47,860
Panaszkodhat, hogy egy üzenet, amely csak 2 bites

119
00:07:47,860 --> 00:07:49,760
átfordulással összezavarodik, elég gyenge, és teljesen igaza van.

120
00:07:49,760 --> 00:07:54,480
Ne feledje azonban, hogy nincs olyan hibaészlelési vagy -javítási módszer, amely 100%-os

121
00:07:54,480 --> 00:07:59,720
biztonságot adna afelől, hogy a kapott üzenetet a küldő szándéka szerinti.

122
00:07:59,720 --> 00:08:03,760
Végtére is, elegendő véletlenszerű zaj pusztán véletlenül megváltoztathatja

123
00:08:03,760 --> 00:08:05,920
az egyik érvényes üzenetet egy másik érvényes üzenetté.

124
00:08:05,920 --> 00:08:10,520
Ehelyett az a cél, hogy egy bizonyos maximális számú hibaig robusztus sémát

125
00:08:10,520 --> 00:08:16,480
dolgozzunk ki, vagy esetleg csökkentsük az ehhez hasonló téves pozitív eredmény valószínűségét.

126
00:08:16,480 --> 00:08:20,940
A paritásellenőrzések önmagukban meglehetősen gyengék, de ha a változás

127
00:08:20,940 --> 00:08:25,640
gondolatát egy teljes üzeneten keresztül egyetlen bitig desztilláljuk, azt

128
00:08:25,640 --> 00:08:28,000
adják, hogy hatékony építőelemet adnak a kifinomultabb sémákhoz.

129
00:08:28,000 --> 00:08:32,880
Például, amikor Hamming egy módot keresett annak azonosítására, hol történt a hiba,

130
00:08:32,880 --> 00:08:37,160
nem csak azt, hogy megtörtént, kulcsfontosságú meglátása az volt, hogy ha

131
00:08:37,160 --> 00:08:42,040
néhány paritásellenőrzést nem a teljes üzenetre, hanem bizonyos gondosan kiválasztott részhalmazokra

132
00:08:42,040 --> 00:08:46,840
alkalmaz, akkor megkérdezheti. egy kifinomultabb kérdéssor, amely meghatározza bármely bithiba helyét.

133
00:08:46,840 --> 00:08:51,280
Az általános érzés egy kicsit olyan, mintha egy 20 kérdésből álló játékot játszanánk,

134
00:08:51,280 --> 00:08:54,300
és igen vagy nem kérdéseket tennénk fel, amelyek kettévágják a lehetőségek terét.

135
00:08:54,300 --> 00:08:58,840
Tegyük fel például, hogy csak ezen a 8 biten

136
00:08:58,840 --> 00:08:59,840
végezzük el a paritásellenőrzést, az összes páratlan számú pozíciót.

137
00:09:00,400 --> 00:09:04,560
Aztán ha hibát észlel, egy kicsit több információt ad a vevőnek arról,

138
00:09:04,560 --> 00:09:09,160
hogy pontosan hol van a hiba, nevezetesen, hogy páratlan helyzetben van.

139
00:09:09,160 --> 00:09:14,360
Ha a 8 bit között nem észlelünk hibát, az vagy azt

140
00:09:14,360 --> 00:09:17,240
jelenti, hogy nincs hiba, vagy valahol a páros pozíciókban van.

141
00:09:17,240 --> 00:09:21,560
Azt gondolhatnánk, hogy ha a paritásellenőrzést a bitek felére korlátozzuk,

142
00:09:21,560 --> 00:09:25,460
az kevésbé hatékony, de ha más jól megválasztott ellenőrzésekkel együtt

143
00:09:25,460 --> 00:09:29,720
hajtjuk végre, akkor az intuitív módon sokkal erősebbet ad.

144
00:09:29,720 --> 00:09:34,440
Ne feledje, hogy a paritásellenőrzés tényleges beállításához speciális bitet

145
00:09:34,440 --> 00:09:37,600
kell kijelölni, amely szabályozza a teljes csoport paritását.

146
00:09:37,600 --> 00:09:39,920
Itt csak válasszuk ki az 1. pozíciót.

147
00:09:39,920 --> 00:09:43,960
A bemutatott példában ennek a 8 bitnek a paritása jelenleg páratlan,

148
00:09:43,960 --> 00:09:48,220
tehát a feladó felelős a paritásbit átkapcsolásáért, most pedig páros.

149
00:09:48,220 --> 00:09:51,040
Ez csak 1 a 4 paritásellenőrzésből, amit elvégezünk.

150
00:09:51,040 --> 00:09:55,560
A második ellenőrzés a rács jobb felében található

151
00:09:55,560 --> 00:09:56,880
8 bit között van, legalábbis ahogy itt megrajzoltuk.

152
00:09:56,880 --> 00:10:02,520
Ezúttal a 2-es pozíciót használhatjuk paritásbitként, így ennek a 8 bitnek már van páros

153
00:10:02,520 --> 00:10:07,160
paritása, és a küldő jól érezheti magát, ha a 2-es bitet változatlanul hagyja.

154
00:10:07,160 --> 00:10:11,040
Aztán a másik végén, ha a vevő ellenőrzi ennek a csoportnak a paritását, és azt találja, hogy

155
00:10:11,040 --> 00:10:15,960
ez furcsa, akkor tudni fogja, hogy a hiba valahol a jobb oldali 8 bit között van.

156
00:10:15,960 --> 00:10:21,260
Ellenkező esetben ez azt jelenti, hogy nincs hiba, vagy a hiba valahol a bal oldalon van.

157
00:10:21,260 --> 00:10:24,040
Vagy azt hiszem, két hiba is lehetett, de jelenleg azt

158
00:10:24,040 --> 00:10:27,080
feltételezzük, hogy legfeljebb egy hiba van az egész blokkban.

159
00:10:27,080 --> 00:10:29,160
Ennél többért teljesen összeomlanak a dolgok.

160
00:10:29,160 --> 00:10:32,920
Mielőtt megvizsgálnánk a következő két ellenőrzést, gondoljunk át egy pillanatra, hogy

161
00:10:32,920 --> 00:10:35,880
az első kettő mit tesz lehetővé, ha együtt tekintjük őket.

162
00:10:35,880 --> 00:10:40,240
Tegyük fel, hogy hibát észlel a páratlan oszlopok között és a jobb felében.

163
00:10:40,240 --> 00:10:43,940
Ez szükségszerűen azt jelenti, hogy a hiba valahol az utolsó oszlopban van.

164
00:10:43,940 --> 00:10:48,280
Ha a páratlan oszlopban nem volt hiba, de a jobb felében volt,

165
00:10:48,280 --> 00:10:50,520
akkor ez azt jelzi, hogy a másodiktól az utolsóig terjedő oszlopban van.

166
00:10:50,520 --> 00:10:54,640
Hasonlóképpen, ha hiba van a páratlan oszlopokban, de nem a

167
00:10:54,640 --> 00:10:56,560
jobb felében, akkor tudja, hogy valahol a második oszlopban van.

168
00:10:56,560 --> 00:11:00,560
És ha a két paritásellenőrzés egyike sem észlel semmit, akkor az

169
00:11:00,560 --> 00:11:03,760
egyetlen hely, ahol hiba lehet, a bal szélső oszlopban lehet.

170
00:11:03,760 --> 00:11:06,480
De ez azt is jelentheti, hogy egyáltalán nincs hiba.

171
00:11:06,480 --> 00:11:10,800
Ez egy meglehetősen elcsépelt módja annak, hogy

172
00:11:10,800 --> 00:11:11,800
két paritásellenőrzés segítségével rögzítsük az oszlopot.

173
00:11:11,800 --> 00:11:14,000
Innentől valószínűleg sejtheti, mi következik.

174
00:11:14,000 --> 00:11:16,240
Alapvetően ugyanazt csináljuk, csak a sorok esetében.

175
00:11:16,240 --> 00:11:21,040
A páratlan sorokon paritásellenőrzés történik, a 4-es pozíciót használva paritásbitként.

176
00:11:21,040 --> 00:11:25,480
Tehát ebben a példában ennek a csoportnak már van

177
00:11:25,480 --> 00:11:26,480
páros paritása, így a 4. bit 0-ra lesz állítva.

178
00:11:26,480 --> 00:11:31,280
És végül van egy paritásellenőrzés az alsó

179
00:11:31,280 --> 00:11:32,280
két sorban, a 8-as pozíciót használva paritásbitként.

180
00:11:32,280 --> 00:11:35,840
Ebben az esetben úgy tűnik, hogy a küldőnek be kell

181
00:11:35,840 --> 00:11:37,840
kapcsolnia a 8-as bitet, hogy egyenletes paritást biztosítson a csoportnak.

182
00:11:37,840 --> 00:11:41,360
Ahogy az első két ellenőrzés lehetővé teszi az oszlop

183
00:11:41,360 --> 00:11:43,000
rögzítését, a következő kettő lehetővé teszi a sor rögzítését.

184
00:11:43,000 --> 00:11:48,400
Példaként képzeljük el, hogy az átvitel során hiba történik, mondjuk a 3. pozícióban.

185
00:11:48,400 --> 00:11:52,620
Nos, ez érinti az első paritáscsoportot, és a második paritáscsoportot is, tehát

186
00:11:52,620 --> 00:11:56,340
a vevő tudja, hogy valahol hiba van abban a jobb oldali oszlopban.

187
00:11:56,340 --> 00:12:01,380
De ez nem érinti a harmadik csoportot, és nem érinti a negyedik csoportot.

188
00:12:01,380 --> 00:12:05,460
Ez pedig lehetővé teszi, hogy a vevő pontosan az első sorig azonosítsa a

189
00:12:05,460 --> 00:12:08,660
hibát, ami szükségszerűen a 3. pozíciót jelenti, így ki tudja javítani a hibát.

190
00:12:08,660 --> 00:12:12,640
Szívesen szánhat egy pillanatot arra, hogy meggyőzze magát arról, hogy a négy kérdésre adott válaszok

191
00:12:12,680 --> 00:12:17,320
valóban mindig lehetővé teszik, hogy meghatározzon egy adott helyet, függetlenül attól, hogy hol van.

192
00:12:17,320 --> 00:12:22,640
Valójában az okoskodók még azt is észrevehetik, hogy van

193
00:12:22,640 --> 00:12:23,640
kapcsolat e kérdések és a bináris számolás között.

194
00:12:23,640 --> 00:12:27,840
És ha igen, hadd hangsúlyozzam ismét, állj meg,

195
00:12:27,840 --> 00:12:30,880
próbáld meg magad megvonni az összefüggést, mielőtt elrontom.

196
00:12:30,880 --> 00:12:35,560
Ha kíváncsi arra, hogy mi történik, ha

197
00:12:35,560 --> 00:12:36,560
magát a paritásbitet érinti, akkor megpróbálhatja.

198
00:12:36,560 --> 00:12:40,720
Szánjon egy pillanatot arra, hogy gondolja végig, hogyan lehet e négy speciális bit közötti

199
00:12:40,720 --> 00:12:47,440
hibát ugyanúgy nyomon követni, mint bármely mást, ugyanazzal a négy kérdésből álló csoporttal.

200
00:12:47,440 --> 00:12:50,500
Teljesen mindegy, hiszen végső soron az üzenetbiteket

201
00:12:50,500 --> 00:12:53,640
akarjuk megvédeni, a hibajavító bitek csak haladnak.

202
00:12:53,640 --> 00:12:57,120
De ezeknek a biteknek a védelme

203
00:12:57,120 --> 00:12:59,260
is melléktermékként természetesen kiesik a rendszerből.

204
00:12:59,260 --> 00:13:02,380
Azt is élvezheti, ha előre látja, hogy ez hogyan skálázódik.

205
00:13:02,380 --> 00:13:08,040
Ha például egy 256 bites méretű blokkot használtunk egy hely meghatározásához, akkor mindössze

206
00:13:08,040 --> 00:13:15,680
nyolc igen vagy nem kérdésre van szüksége, hogy binárisan keressen egy bizonyos helyre.

207
00:13:15,680 --> 00:13:19,680
És ne feledje, minden kérdés csak egyetlen

208
00:13:19,680 --> 00:13:23,340
bitet igényel a megfelelő paritásellenőrzés beállításához.

209
00:13:23,340 --> 00:13:26,960
Lehet, hogy néhányan már látják, de később beszélünk arról, hogyan

210
00:13:26,960 --> 00:13:29,960
lehet szisztematikusan egy-két percen belül kideríteni, mik ezek a kérdések.

211
00:13:29,960 --> 00:13:33,440
Remélhetőleg ez a vázlat elegendő ahhoz, hogy

212
00:13:33,440 --> 00:13:34,440
értékeljük az itt fejlesztendő tevékenységünk hatékonyságát.

213
00:13:34,440 --> 00:13:38,440
Az első dolog, a nyolc kiemelt paritásbit kivételével,

214
00:13:38,440 --> 00:13:41,720
bármi lehet, bármilyen üzenetet vagy adatot hordozhat.

215
00:13:41,720 --> 00:13:45,480
A 8 bit redundáns abban az értelemben, hogy teljesen az üzenet többi része

216
00:13:45,480 --> 00:13:53,640
határozza meg őket, de ez sokkal okosabb módszer, mint az üzenet egészének másolása.

217
00:13:53,640 --> 00:13:58,000
És mégis, ennyire kevés feladással képes

218
00:13:58,000 --> 00:13:59,000
lenne azonosítani és kijavítani bármelyik bithibát.

219
00:13:59,000 --> 00:14:00,400
Hát majdnem.

220
00:14:00,400 --> 00:14:05,920
Oké, itt az egyetlen probléma az, hogy ha a négy paritásellenőrzés egyike sem

221
00:14:05,920 --> 00:14:10,240
észlel hibát, ami azt jelenti, hogy a speciálisan kiválasztott 8 bites részhalmazok mindegyikének

222
00:14:10,240 --> 00:14:15,520
páros paritása van, ahogy a küldő szándéka szerint, akkor ez vagy azt jelenti,

223
00:14:15,520 --> 00:14:17,760
hogy egyáltalán nem volt hiba. , vagy leszűkít minket a 0. pozícióba.

224
00:14:17,760 --> 00:14:23,040
Négy igen vagy nem kérdés esetén 16 lehetséges kimenetelünk van a paritásellenőrzésünkhöz,

225
00:14:23,040 --> 00:14:28,000
és ez elsőre tökéletesnek tűnik a blokk 16 pozíciójából 1 pontos meghatározásához,

226
00:14:28,000 --> 00:14:33,000
de közölnie kell a 17. eredményt is, a nem hibát. feltétel.

227
00:14:33,000 --> 00:14:37,860
A megoldás itt valójában nagyon egyszerű, csak felejtsd el teljesen a 0. bitet.

228
00:14:37,860 --> 00:14:41,920
Tehát amikor elvégezzük a négy paritásellenőrzésünket, és azt látjuk, hogy

229
00:14:41,920 --> 00:14:44,320
mindegyik páros, az egyértelműen azt jelenti, hogy nincs hiba.

230
00:14:44,320 --> 00:14:49,240
Ez azt jelenti, hogy ahelyett, hogy egy 16 bites blokkal dolgoznánk, mi egy 15 bites blokkkal

231
00:14:49,240 --> 00:14:54,040
dolgozunk, ahol a bitek közül 11 szabadon hordozhat üzenetet, és közülük 4 redundancia miatt van.

232
00:14:54,080 --> 00:14:58,400
És ezzel most megvan, amit

233
00:14:58,400 --> 00:14:59,400
az üzletemberek 15-11 Hamming-kódként emlegetnének.

234
00:14:59,400 --> 00:15:03,920
Ennek ellenére jó, hogy van egy blokkméret, amely 2-es tiszta hatványt jelent, és van egy okos

235
00:15:03,920 --> 00:15:08,880
módszer, amellyel megtarthatjuk a 0. bitet, és rávehetjük, hogy egy kis plusz munkát végezzen el helyettünk.

236
00:15:08,880 --> 00:15:13,600
Ha paritásbitként használjuk az egész blokkon, akkor ténylegesen felismerjük

237
00:15:13,600 --> 00:15:16,320
a 2 bites hibákat, bár nem tudjuk kijavítani.

238
00:15:16,320 --> 00:15:17,440
Íme, hogyan működik.

239
00:15:17,440 --> 00:15:21,740
Miután beállítottuk a négy speciális hibajavító bitet, beállítjuk azt a 0-at,

240
00:15:21,740 --> 00:15:25,540
hogy a teljes blokk paritása páros legyen, akárcsak egy normál paritásellenőrzésnél.

241
00:15:25,540 --> 00:15:29,780
Most, ha egyetlen bites hiba van, akkor a teljes blokk paritása

242
00:15:29,780 --> 00:15:33,940
páratlanra vált, de a négy hibajavító ellenőrzésnek köszönhetően ezt mindenképpen megfognánk.

243
00:15:33,940 --> 00:15:38,100
Ha azonban két hiba van, akkor a teljes paritás vissza

244
00:15:38,100 --> 00:15:42,660
fog váltani párosra, de a vevő továbbra is látja,

245
00:15:42,660 --> 00:15:45,820
hogy legalább valami hiba történt a négy paritásellenőrzés miatt.

246
00:15:45,820 --> 00:15:49,780
Tehát ha összességében egyenletes paritást észlelnek, de a többi ellenőrzésnél valami

247
00:15:49,820 --> 00:15:52,980
nem nulla történik, akkor azt jelzi, hogy legalább két hiba történt.

248
00:15:52,980 --> 00:15:54,420
Hát nem okos?

249
00:15:54,420 --> 00:15:58,500
Annak ellenére, hogy ezeket a 2 bites hibákat nem tudjuk kijavítani, pusztán

250
00:15:58,500 --> 00:16:02,340
az egyetlen zavaró 0. bit visszaállításával lehetővé teszi számunkra, hogy észleljük őket.

251
00:16:02,340 --> 00:16:06,540
Ez meglehetősen szabványos, kiterjesztett Hamming-kódként ismert.

252
00:16:06,540 --> 00:16:10,860
Technikailag szólva, most már teljes leírása van arról, hogy mit

253
00:16:10,860 --> 00:16:13,580
csinál egy Hamming-kód, legalábbis egy 16 bites blokk esetében.

254
00:16:13,580 --> 00:16:17,300
De azt hiszem, sokkal elégedettebb lesz, ha ellenőrizni fogja a megértését, és mindent

255
00:16:17,300 --> 00:16:21,980
megszilárdít idáig úgy, hogy egy teljes példát tesz az elejétől a végéig.

256
00:16:21,980 --> 00:16:25,100
De végigcsinálom veled, hogy ellenőrizd magad.

257
00:16:25,100 --> 00:16:29,180
Üzenet beállításához, legyen szó szó szerinti üzenetről, amelyet térben fordít

258
00:16:29,180 --> 00:16:34,100
le, vagy bizonyos adatokat, amelyeket idővel tárolni szeretne, az első

259
00:16:34,100 --> 00:16:35,700
lépés az, hogy fel kell osztani 11 bites részekre.

260
00:16:35,700 --> 00:16:40,340
Minden egyes darab egy hibaálló 16 bites blokkba kerül.

261
00:16:40,340 --> 00:16:43,740
Tehát vegyük ezt példaként, és dolgozzuk ki ténylegesen.

262
00:16:43,740 --> 00:16:45,340
Hajrá, tényleg tedd meg!

263
00:16:45,380 --> 00:16:47,380
Álljunk meg, és próbáljuk összerakni ezt a blokkot.

264
00:16:52,980 --> 00:16:53,980
Oké, készen állsz?

265
00:16:53,980 --> 00:16:58,500
Ne feledje, hogy a 0 pozíció a 2 többi hatványával együtt hibajavítási feladatra

266
00:16:58,500 --> 00:17:05,700
van fenntartva, tehát először az üzenetbiteket az összes többi helyre, sorrendben helyezze el.

267
00:17:05,700 --> 00:17:09,700
Ennek a csoportnak páros paritásúnak kell lennie, ami már így is van,

268
00:17:09,700 --> 00:17:13,140
tehát azt a paritásbitet az 1-es pozícióban 0-ra kellett volna állítani.

269
00:17:13,140 --> 00:17:17,700
A következő csoport páratlan paritással kezdődik, ezért

270
00:17:17,700 --> 00:17:19,260
a paritásbitjét 1-re kellett volna állítani.

271
00:17:19,260 --> 00:17:23,740
Az ezt követő csoport páratlan paritással kezdődik, tehát

272
00:17:23,740 --> 00:17:24,740
ismét 1-re kellett volna állítani a paritásbitjét.

273
00:17:24,740 --> 00:17:29,500
És az utolsó csoportnak is van páratlan paritása, vagyis

274
00:17:29,500 --> 00:17:31,500
azt a bitet a 8-as pozícióban 1-re állítjuk be.

275
00:17:31,500 --> 00:17:36,460
Utolsó lépésként a teljes blokk páros paritású, vagyis

276
00:17:36,460 --> 00:17:41,500
beállíthatja a 0 bitszámot, az átfogó paritásbitet 0-ra.

277
00:17:41,500 --> 00:17:45,660
Tehát amikor ez a blokk elküldésre kerül, a négy speciális

278
00:17:45,660 --> 00:17:48,980
részhalmaz és a blokk egészének paritása páros vagy 0 lesz.

279
00:17:48,980 --> 00:17:53,620
A gyakorlat második részeként játsszuk a befogadó szerepét.

280
00:17:53,620 --> 00:17:57,580
Természetesen ez azt jelentené, hogy még nem tudja, mi ez az

281
00:17:57,580 --> 00:18:00,180
üzenet, talán néhányan megjegyezték, de tegyük fel, hogy még nem.

282
00:18:00,180 --> 00:18:05,820
Azt fogom tenni, hogy megváltoztatom a 0, 1 vagy 2 bitet

283
00:18:05,820 --> 00:18:08,340
ebben a blokkban, majd megkérem, hogy találja ki, mit csináltam.

284
00:18:08,340 --> 00:18:13,460
Tehát ismét álljon meg, és próbálja meg megoldani.

285
00:18:13,460 --> 00:18:23,960
Oké, tehát Ön, mint vevő, most ellenőrizze az első paritáscsoportot, és láthatja,

286
00:18:23,960 --> 00:18:29,820
hogy az páros, tehát minden létező hibának páros oszlopban kell lennie.

287
00:18:29,820 --> 00:18:34,620
A következő ellenőrzés páratlan számot ad nekünk, jelezve, hogy legalább

288
00:18:34,620 --> 00:18:38,760
egy hiba van, és leszűkítve erre a konkrét oszlopra.

289
00:18:38,760 --> 00:18:42,900
A harmadik ellenőrzés kiegyenlített, ami még tovább csökkenti a lehetőségeket.

290
00:18:42,900 --> 00:18:46,780
Az utolsó paritásellenőrzés pedig páratlan, és azt jelzi, hogy valahol alul van

291
00:18:46,780 --> 00:18:51,700
egy hiba, amiről mostanra láthatjuk, hogy a 10-es pozícióban kell lennie.

292
00:18:51,700 --> 00:18:56,140
Sőt, az egész blokk paritása furcsa, ami azt a bizonyosságot

293
00:18:56,140 --> 00:18:58,220
ad nekünk, hogy egy átfordulás volt, és nem kettő.

294
00:18:58,220 --> 00:19:01,600
Ha három vagy több, akkor minden fogadás megszűnik.

295
00:19:01,600 --> 00:19:06,520
A 10-es számú bit kijavítása után a korrekcióhoz nem használt 11

296
00:19:06,520 --> 00:19:11,620
bitet kihúzva megkapjuk az eredeti üzenet megfelelő szegmensét, amely ha

297
00:19:11,620 --> 00:19:16,160
visszatekerjük és összehasonlítjuk, valóban pontosan az, amivel kezdtük a példát.

298
00:19:16,160 --> 00:19:19,260
És most, hogy tudja, hogyan kell mindezt kézzel megtenni, szeretném megmutatni,

299
00:19:19,260 --> 00:19:23,940
hogyan hajthatja végre ennek a logikának a lényegét egyetlen Python-kódsorral.

300
00:19:23,940 --> 00:19:28,400
Látod, amit még nem mondtam el, az az, hogy valójában mennyire

301
00:19:28,400 --> 00:19:32,380
elegáns ez az algoritmus, milyen egyszerű rávenni a gépet, hogy rámutasson

302
00:19:32,380 --> 00:19:37,680
a hiba helyére, hogyan lehet szisztematikusan skálázni, és hogyan tudjuk keretbe

303
00:19:37,680 --> 00:19:39,580
foglalni az egészet. ez egyetlen művelet, nem pedig több különálló paritásellenőrzés.

304
00:19:39,580 --> 00:19:41,680
Ha szeretnéd megérteni, mire gondolok, csatlakozz hozzám a 2. részhez.

