1
00:00:00,000 --> 00:00:05,498
Elgondolkozott már azon, hogyan lehetséges egy CD-t vagy

2
00:00:05,498 --> 00:00:10,900
DVD-t megkarcolni, és még mindig lejátszani, amit tárol?

3
00:00:10,900 --> 00:00:15,168
A karcolás valóban hatással van a lemezen lévő 1-ekre és 0-kra, tehát

4
00:00:15,168 --> 00:00:19,985
a tárolttól eltérő adatokat olvas ki, de hacsak nem teljesen összekarcolódott,

5
00:00:19,985 --> 00:00:24,009
a kiolvasott bitek pontosan ugyanabba a fájlba dekódolódnak, mint

6
00:00:24,009 --> 00:00:28,400
amilyenre rá volt kódolva. bit a bitmásoláshoz, mindezen hibák ellenére.

7
00:00:28,400 --> 00:00:32,595
Számtalan matematikai okosság van, amely lehetővé teszi az adatok tárolását, és ami

8
00:00:32,595 --> 00:00:36,840
ugyanilyen fontos, hogy adatokat továbbítsunk olyan módon, amely ellenáll a hibáknak.

9
00:00:36,840 --> 00:00:42,480
Nos, oké, valójában nem kell akkora okosság, hogy kitaláljon egy módot erre.

10
00:00:42,480 --> 00:00:46,750
Bármely fájl, legyen szó videóról, hangról vagy szövegről, valamilyen

11
00:00:46,750 --> 00:00:50,960
kódról, képről vagy bármi másról, végső soron 1-esek és 0-k sorozata.

12
00:00:50,960 --> 00:00:54,526
A megfordított bitek kijavítására egy egyszerű stratégia

13
00:00:54,526 --> 00:00:57,780
az lenne, ha minden bitből három másolatot tárolunk.

14
00:00:57,780 --> 00:01:02,456
Ekkor a fájlt olvasó gép össze tudja hasonlítani ezt a három

15
00:01:02,456 --> 00:01:07,440
másolatot, és mindig a legjobb 2-t kapja a 3-ból, ha eltérés van.

16
00:01:07,440 --> 00:01:11,560
De ez azt jelenti, hogy a hely kétharmadát redundanciára használja.

17
00:01:11,560 --> 00:01:14,662
És még akkor sem, ha az összes helyet feladjuk, nincs komoly

18
00:01:14,662 --> 00:01:18,120
garancia arra, hogy mi történik, ha egynél több bitet megfordítanak.

19
00:01:18,120 --> 00:01:21,312
Sokkal érdekesebb kérdés, hogy hogyan lehet úgy megcsinálni, hogy a

20
00:01:21,312 --> 00:01:24,740
hibákat a lehető legkevesebb hely elhagyása mellett ki lehessen javítani.

21
00:01:24,740 --> 00:01:28,997
Például a videóról megismert módszerrel 256 bites blokkokban

22
00:01:28,997 --> 00:01:32,975
tárolhatja adatait, ahol minden blokk 9, 9 bitet használ!

23
00:01:32,975 --> 00:01:36,957
egyfajta redundanciaként működik, a többi 247 bit pedig szabadon

24
00:01:36,957 --> 00:01:41,000
hordozhat bármilyen értelmes üzenetet vagy adatot, amit csak akar.

25
00:01:41,000 --> 00:01:45,027
És továbbra is az lesz, hogy ha itt bármelyik bit megfordul, csak erre

26
00:01:45,027 --> 00:01:49,168
a blokkra nézve, és semmi másra, a gép képes lesz azonosítani, hogy hiba

27
00:01:49,168 --> 00:01:53,140
történt, és hogy pontosan hol volt, így tudja, hogyan kell kijavítani.

28
00:01:53,140 --> 00:01:55,540
És őszintén szólva, ez varázslatnak tűnik.

29
00:01:55,540 --> 00:01:59,075
És ennél a konkrét sémánál, ha két bit megfordul, a gép

30
00:01:59,075 --> 00:02:03,180
legalább két hibát észlel, bár nem tudja, hogyan javítsa ki őket.

31
00:02:03,180 --> 00:02:05,905
Egy kicsit később beszélünk arról, hogy ez hogyan

32
00:02:05,905 --> 00:02:08,140
skálázható a különböző méretű blokkokhoz.

33
00:02:08,140 --> 00:02:10,952
Az ehhez hasonló hibák kijavítását lehetővé tevő

34
00:02:10,952 --> 00:02:13,880
módszereket ésszerűen hibajavító kódokként ismerik.

35
00:02:13,880 --> 00:02:18,472
A múlt század nagy részében ez a terület a meglepően mély matematikai

36
00:02:18,472 --> 00:02:23,000
adatok gazdag forrása volt, amely beépül a mindennapi használatunkba.

37
00:02:23,000 --> 00:02:26,330
Itt az a cél, hogy nagyon alapos megértést nyújtsunk

38
00:02:26,330 --> 00:02:29,660
az egyik legkorábbi, Hamming-kódként ismert példának.

39
00:02:29,660 --> 00:02:33,272
És mellesleg, ahogyan ennek a videónak a felépítésére gondolok, kevésbé arról

40
00:02:33,272 --> 00:02:36,746
van szó, hogy a lehető legközvetlenebbül magyarázzam el, hanem inkább arra

41
00:02:36,746 --> 00:02:40,220
ösztönözzek, hogy találd ki magadnak, itt-ott egy kis gyengéd irányítással.

42
00:02:40,220 --> 00:02:43,453
Tehát amikor úgy érzed, hogy egy ponton látod, merre tart, szánj arra a

43
00:02:43,453 --> 00:02:47,180
pillanatra egy szünetet, és aktívan jósold meg, mi lesz a terv, mielőtt elmondanám.

44
00:02:47,180 --> 00:02:51,381
Továbbá, ha azt szeretné, hogy megértése a hardver szintjére jusson, Ben Eater

45
00:02:51,381 --> 00:02:55,637
készített egy videót ehhez a videóhoz, amely bemutatja, hogyan kell ténylegesen

46
00:02:55,637 --> 00:02:59,520
implementálni a Hamming-kódokat a kenyérlapokon, ami rendkívül kielégítő.

47
00:02:59,520 --> 00:03:03,126
Tudnod kell, a Hamming-kódokat nem használják olyan széles körben, mint a

48
00:03:03,126 --> 00:03:06,977
modernebb kódokat, mint például a Reed-Solomon algoritmus, de van egy bizonyos

49
00:03:06,977 --> 00:03:10,535
varázslat a kontrasztban aközött, hogy mennyire lehetetlennek tűnik ez a

50
00:03:10,535 --> 00:03:14,240
feladat az elején, és mennyire ésszerűnek tűnik egyszer. tanulsz Hammingről.

51
00:03:14,240 --> 00:03:18,755
A hibajavítás alapelve, hogy az összes lehetséges üzenet hatalmas

52
00:03:18,755 --> 00:03:22,860
területén csak egy részhalmaz tekinthető érvényes üzenetnek.

53
00:03:22,860 --> 00:03:29,100
Analógiaként gondoljon a helyesen írt szavakra a helytelenül írt szavakra.

54
00:03:29,100 --> 00:03:33,713
Amikor egy érvényes üzenetet módosítanak, a fogadó felelős azért, hogy a látottakat a

55
00:03:33,713 --> 00:03:38,380
legközelebbi érvényes szomszédhoz javítsa, ahogyan azt az elírások esetén is megteheti.

56
00:03:38,380 --> 00:03:42,770
Egy konkrét algoritmus kidolgozása az ehhez hasonló üzenetek

57
00:03:42,770 --> 00:03:47,160
hatékony kategorizálására azonban bizonyos okosságot igényel.

58
00:03:47,160 --> 00:03:50,580
A történet az 1940-es években kezdődik, amikor egy fiatal Richard Hamming a

59
00:03:50,580 --> 00:03:54,090
Bell Labs-nál dolgozott, és néhány munkája egy nagyon nagy, drága lyukkártyás

60
00:03:54,090 --> 00:03:57,420
számítógép használatából állt, amelyhez csak korlátozott hozzáférése volt.

61
00:03:57,420 --> 00:04:00,255
És a programok, amiket folyamatosan csinált, folyamatosan

62
00:04:00,255 --> 00:04:03,140
kudarcot vallottak, mert időnként egy kicsit félreolvastak.

63
00:04:03,140 --> 00:04:06,266
Mivel a frusztráció a találmány tégelye, annyira elege

64
00:04:06,266 --> 00:04:09,280
lett, hogy feltalálta a világ első hibajavító kódját.

65
00:04:09,280 --> 00:04:12,829
A Hamming-kódok keretbe foglalásának sokféle módja van, de

66
00:04:12,829 --> 00:04:16,620
első lépésként úgy megyünk végig, ahogy Hamming gondolta róluk.

67
00:04:16,620 --> 00:04:21,400
Használjunk egy egyszerű, de nem túl egyszerű példát, egy 16 bites blokkot.

68
00:04:21,400 --> 00:04:25,700
Ezeknek a biteknek a pozícióit 0-tól 15-ig számozzuk.

69
00:04:25,700 --> 00:04:29,690
A tárolni kívánt tényleges adatok csak 12 bitet tesznek ki ebből a

70
00:04:29,690 --> 00:04:33,920
bitből, míg a pozíciók közül 4 egyfajta redundanciaként van fenntartva.

71
00:04:33,920 --> 00:04:36,809
A redundáns szó itt nem egyszerűen másolást jelent,

72
00:04:36,809 --> 00:04:40,200
elvégre az a 4 bit nem ad elég teret az adatok vakmásolására.

73
00:04:40,200 --> 00:04:44,395
Ehelyett sokkal árnyaltabb és okosabb redundanciát kell

74
00:04:44,395 --> 00:04:48,740
alkalmazniuk, nem új információkkal, hanem rugalmassággal.

75
00:04:48,740 --> 00:04:52,413
Arra számíthat, hogy ez a 4 speciális bit szépen össze van

76
00:04:52,413 --> 00:04:56,335
csomagolva, talán a végén, vagy valami hasonló, de amint látni

77
00:04:56,335 --> 00:05:00,320
fogja, ha 2-es pozícióban ülnek, valami igazán elegáns a végére.

78
00:05:00,320 --> 00:05:05,420
Ez is adhat egy kis utalást arra vonatkozóan, hogyan méretezhető ez a nagyobb blokkokhoz.

79
00:05:05,420 --> 00:05:09,726
Technikailag is csak 11 bites adat lesz, és látni fogja, hogy van egy

80
00:05:09,726 --> 00:05:14,280
enyhe árnyalat a 0. pozícióban zajló eseményekhez, de ez most ne aggódjon.

81
00:05:14,280 --> 00:05:18,231
Mint minden hibajavító algoritmus, ez is két játékost foglal magában,

82
00:05:18,231 --> 00:05:22,295
egy feladót, aki a 4 speciális bit beállításáért felelős, és egy vevőt,

83
00:05:22,295 --> 00:05:26,360
aki valamilyen ellenőrzés elvégzéséért és a hibák kijavításáért felelős.

84
00:05:26,360 --> 00:05:29,253
Természetesen a küldő és fogadó szavak valóban olyan gépekre vagy

85
00:05:29,253 --> 00:05:32,191
szoftverekre utalnak, amelyek minden ellenőrzést elvégeznek, és az

86
00:05:32,191 --> 00:05:35,480
üzenet fogalma nagyon tág értelemben értendő, beleértve például a tárolást.

87
00:05:35,480 --> 00:05:39,218
Végül is az adatok tárolása ugyanaz, mint üzenetet küldeni

88
00:05:39,218 --> 00:05:42,640
a múltból a jövőbe, nem pedig egyik helyről a másikra.

89
00:05:42,640 --> 00:05:46,125
Tehát ez a beállítás, de mielőtt belemerülnénk, beszélnünk kell egy

90
00:05:46,125 --> 00:05:49,867
kapcsolódó ötletről, amely Hammingnek a felfedezése idején frissen járt,

91
00:05:49,867 --> 00:05:53,506
egy olyan módszerről, amely lehetővé teszi, hogy bármilyen bites hibát

92
00:05:53,506 --> 00:05:57,300
észleljen, de kijavítsa azokat, ismert. az üzletben paritásellenőrzésként.

93
00:05:57,300 --> 00:06:00,982
A paritásellenőrzéshez csak egyetlen bitet választunk ki, amelynek

94
00:06:00,982 --> 00:06:04,940
hangolásáért a küldő felelős, a többi pedig szabadon hordozhat üzenetet.

95
00:06:04,940 --> 00:06:08,682
Ennek a speciális bitnek az egyetlen feladata, hogy megbizonyosodjon

96
00:06:08,682 --> 00:06:12,100
arról, hogy az üzenetben szereplő 1-ek száma páros szám legyen.

97
00:06:12,100 --> 00:06:16,387
Így például jelenleg az 1-ek teljes száma 7, ez páratlan, tehát a küldőnek

98
00:06:16,387 --> 00:06:20,960
meg kell fordítania azt a speciális bitet, hogy 1 legyen, így a szám páros lesz.

99
00:06:20,960 --> 00:06:24,460
De ha a blokk már páros számú 1-gyel indult volna,

100
00:06:24,460 --> 00:06:27,480
akkor ez a speciális bit 0-ban maradt volna.

101
00:06:27,480 --> 00:06:30,726
Ez nagyon egyszerű, megtévesztően egyszerű, de hihetetlenül

102
00:06:30,726 --> 00:06:34,026
elegáns módja annak, hogy a változás gondolatát az üzenetben

103
00:06:34,026 --> 00:06:37,760
bárhol lepároljuk, hogy az egyetlen információrészletben tükröződjön.

104
00:06:37,760 --> 00:06:42,739
Figyelje meg, ha ennek az üzenetnek bármely része átfordul, akár 0-ról

105
00:06:42,739 --> 00:06:48,140
1-re, akár 1-ről 0-ra, az 1-ek teljes számát párosról páratlanra változtatja.

106
00:06:48,140 --> 00:06:53,518
Tehát ha Ön a címzett, megnézi ezt az üzenetet, és páratlan számú 1-et lát, akkor

107
00:06:53,518 --> 00:06:58,700
biztosan tudhatja, hogy hiba történt, még akkor is, ha fogalma sincs, hol volt.

108
00:06:58,700 --> 00:07:01,790
A szakzsargonban azt, hogy egy bitcsoport páros vagy

109
00:07:01,790 --> 00:07:04,940
páratlan 1-es számmal rendelkezik, paritásnak nevezik.

110
00:07:04,940 --> 00:07:08,080
Számokat is használhat, és azt mondhatja, hogy a paritás 0 vagy

111
00:07:08,080 --> 00:07:11,320
1, ami általában hasznosabb, ha elkezdi a matematikát az ötlettel.

112
00:07:11,320 --> 00:07:14,407
Ezt a speciális bitet pedig, amelyet a küldő a

113
00:07:14,407 --> 00:07:18,020
paritás szabályozására használ, paritásbitnek nevezzük.

114
00:07:18,020 --> 00:07:21,752
És tulajdonképpen tisztán kell lennünk, ha a vevő páratlan paritást lát, az

115
00:07:21,752 --> 00:07:25,631
nem feltétlenül azt jelenti, hogy csak egy hiba volt, lehet, hogy 3 hiba volt,

116
00:07:25,631 --> 00:07:29,560
vagy 5, vagy bármilyen más páratlan szám, de biztosan tudhatják hogy nem 0 volt.

117
00:07:29,560 --> 00:07:34,055
Másrészt, ha 2 vagy páros számú hiba történt volna, akkor az 1-ek végső

118
00:07:34,055 --> 00:07:38,426
száma továbbra is páros lenne, így a fogadó nem lehet teljesen biztos

119
00:07:38,426 --> 00:07:43,360
abban, hogy a páros szám szükségszerűen azt jelenti, hogy az üzenet hibamentes.

120
00:07:43,360 --> 00:07:46,142
Panaszkodhat, hogy egy üzenet, amely csak 2 bites

121
00:07:46,142 --> 00:07:49,760
átfordulással összezavarodik, elég gyenge, és teljesen igaza van.

122
00:07:49,760 --> 00:07:54,709
Ne feledje azonban, hogy nincs olyan hibaészlelési vagy -javítási módszer, amely

123
00:07:54,709 --> 00:07:59,720
100%-os biztonságot adna afelől, hogy a kapott üzenetet a küldő szándéka szerinti.

124
00:07:59,720 --> 00:08:02,465
Végtére is, elegendő véletlenszerű zaj pusztán véletlenül

125
00:08:02,465 --> 00:08:05,920
megváltoztathatja az egyik érvényes üzenetet egy másik érvényes üzenetté.

126
00:08:05,920 --> 00:08:11,292
Ehelyett az a cél, hogy egy bizonyos maximális számú hibaig robusztus sémát dolgozzunk

127
00:08:11,292 --> 00:08:16,480
ki, vagy esetleg csökkentsük az ehhez hasonló téves pozitív eredmény valószínűségét.

128
00:08:16,480 --> 00:08:20,410
A paritásellenőrzések önmagukban meglehetősen gyengék, de ha a változás

129
00:08:20,410 --> 00:08:24,287
gondolatát egy teljes üzeneten keresztül egyetlen bitig desztilláljuk,

130
00:08:24,287 --> 00:08:28,000
azt adják, hogy hatékony építőelemet adnak a kifinomultabb sémákhoz.

131
00:08:28,000 --> 00:08:31,548
Például, amikor Hamming egy módot keresett annak azonosítására, hol

132
00:08:31,548 --> 00:08:35,358
történt a hiba, nem csak azt, hogy megtörtént, kulcsfontosságú meglátása

133
00:08:35,358 --> 00:08:39,116
az volt, hogy ha néhány paritásellenőrzést nem a teljes üzenetre, hanem

134
00:08:39,116 --> 00:08:43,134
bizonyos gondosan kiválasztott részhalmazokra alkalmaz, akkor megkérdezheti.

135
00:08:43,134 --> 00:08:46,840
egy kifinomultabb kérdéssor, amely meghatározza bármely bithiba helyét.

136
00:08:46,840 --> 00:08:50,681
Az általános érzés egy kicsit olyan, mintha egy 20 kérdésből álló játékot játszanánk,

137
00:08:50,681 --> 00:08:54,300
és igen vagy nem kérdéseket tennénk fel, amelyek kettévágják a lehetőségek terét.

138
00:08:54,300 --> 00:08:57,376
Tegyük fel például, hogy csak ezen a 8 biten végezzük el

139
00:08:57,376 --> 00:09:00,400
a paritásellenőrzést, az összes páratlan számú pozíciót.

140
00:09:00,400 --> 00:09:04,749
Aztán ha hibát észlel, egy kicsit több információt ad a vevőnek arról,

141
00:09:04,749 --> 00:09:09,160
hogy pontosan hol van a hiba, nevezetesen, hogy páratlan helyzetben van.

142
00:09:09,160 --> 00:09:13,412
Ha a 8 bit között nem észlelünk hibát, az vagy azt jelenti,

143
00:09:13,412 --> 00:09:17,240
hogy nincs hiba, vagy valahol a páros pozíciókban van.

144
00:09:17,240 --> 00:09:21,038
Azt gondolhatnánk, hogy ha a paritásellenőrzést a bitek felére

145
00:09:21,038 --> 00:09:24,776
korlátozzuk, az kevésbé hatékony, de ha más jól megválasztott

146
00:09:24,776 --> 00:09:29,720
ellenőrzésekkel együtt hajtjuk végre, akkor az intuitív módon sokkal erősebbet ad.

147
00:09:29,720 --> 00:09:33,774
Ne feledje, hogy a paritásellenőrzés tényleges beállításához speciális

148
00:09:33,774 --> 00:09:37,600
bitet kell kijelölni, amely szabályozza a teljes csoport paritását.

149
00:09:37,600 --> 00:09:39,920
Itt csak válasszuk ki az 1. pozíciót.

150
00:09:39,920 --> 00:09:44,040
A bemutatott példában ennek a 8 bitnek a paritása jelenleg páratlan,

151
00:09:44,040 --> 00:09:48,220
tehát a feladó felelős a paritásbit átkapcsolásáért, most pedig páros.

152
00:09:48,220 --> 00:09:51,040
Ez csak 1 a 4 paritásellenőrzésből, amit elvégezünk.

153
00:09:51,040 --> 00:09:53,931
A második ellenőrzés a rács jobb felében található

154
00:09:53,931 --> 00:09:56,880
8 bit között van, legalábbis ahogy itt megrajzoltuk.

155
00:09:56,880 --> 00:10:01,989
Ezúttal a 2-es pozíciót használhatjuk paritásbitként, így ennek a 8 bitnek már van

156
00:10:01,989 --> 00:10:07,160
páros paritása, és a küldő jól érezheti magát, ha a 2-es bitet változatlanul hagyja.

157
00:10:07,160 --> 00:10:11,635
Aztán a másik végén, ha a vevő ellenőrzi ennek a csoportnak a paritását, és azt találja,

158
00:10:11,635 --> 00:10:15,960
hogy ez furcsa, akkor tudni fogja, hogy a hiba valahol a jobb oldali 8 bit között van.

159
00:10:15,960 --> 00:10:21,260
Ellenkező esetben ez azt jelenti, hogy nincs hiba, vagy a hiba valahol a bal oldalon van.

160
00:10:21,260 --> 00:10:23,995
Vagy azt hiszem, két hiba is lehetett, de jelenleg azt

161
00:10:23,995 --> 00:10:27,080
feltételezzük, hogy legfeljebb egy hiba van az egész blokkban.

162
00:10:27,080 --> 00:10:29,160
Ennél többért teljesen összeomlanak a dolgok.

163
00:10:29,160 --> 00:10:32,404
Mielőtt megvizsgálnánk a következő két ellenőrzést, gondoljunk át egy

164
00:10:32,404 --> 00:10:35,880
pillanatra, hogy az első kettő mit tesz lehetővé, ha együtt tekintjük őket.

165
00:10:35,880 --> 00:10:40,240
Tegyük fel, hogy hibát észlel a páratlan oszlopok között és a jobb felében.

166
00:10:40,240 --> 00:10:43,940
Ez szükségszerűen azt jelenti, hogy a hiba valahol az utolsó oszlopban van.

167
00:10:43,940 --> 00:10:47,303
Ha a páratlan oszlopban nem volt hiba, de a jobb felében volt, akkor

168
00:10:47,303 --> 00:10:50,520
ez azt jelzi, hogy a másodiktól az utolsóig terjedő oszlopban van.

169
00:10:50,520 --> 00:10:53,442
Hasonlóképpen, ha hiba van a páratlan oszlopokban, de nem a

170
00:10:53,442 --> 00:10:56,560
jobb felében, akkor tudja, hogy valahol a második oszlopban van.

171
00:10:56,560 --> 00:11:00,102
És ha a két paritásellenőrzés egyike sem észlel semmit, akkor

172
00:11:00,102 --> 00:11:03,760
az egyetlen hely, ahol hiba lehet, a bal szélső oszlopban lehet.

173
00:11:03,760 --> 00:11:06,480
De ez azt is jelentheti, hogy egyáltalán nincs hiba.

174
00:11:06,480 --> 00:11:09,114
Ez egy meglehetősen elcsépelt módja annak, hogy két

175
00:11:09,114 --> 00:11:11,800
paritásellenőrzés segítségével rögzítsük az oszlopot.

176
00:11:11,800 --> 00:11:14,000
Innentől valószínűleg sejtheti, mi következik.

177
00:11:14,000 --> 00:11:16,240
Alapvetően ugyanazt csináljuk, csak a sorok esetében.

178
00:11:16,240 --> 00:11:21,040
A páratlan sorokon paritásellenőrzés történik, a 4-es pozíciót használva paritásbitként.

179
00:11:21,040 --> 00:11:23,619
Tehát ebben a példában ennek a csoportnak már

180
00:11:23,619 --> 00:11:26,480
van páros paritása, így a 4. bit 0-ra lesz állítva.

181
00:11:26,480 --> 00:11:29,319
És végül van egy paritásellenőrzés az alsó két

182
00:11:29,319 --> 00:11:32,280
sorban, a 8-as pozíciót használva paritásbitként.

183
00:11:32,280 --> 00:11:35,038
Ebben az esetben úgy tűnik, hogy a küldőnek be kell kapcsolnia

184
00:11:35,038 --> 00:11:37,840
a 8-as bitet, hogy egyenletes paritást biztosítson a csoportnak.

185
00:11:37,840 --> 00:11:40,242
Ahogy az első két ellenőrzés lehetővé teszi az oszlop

186
00:11:40,242 --> 00:11:43,000
rögzítését, a következő kettő lehetővé teszi a sor rögzítését.

187
00:11:43,000 --> 00:11:48,400
Példaként képzeljük el, hogy az átvitel során hiba történik, mondjuk a 3. pozícióban.

188
00:11:48,400 --> 00:11:52,234
Nos, ez érinti az első paritáscsoportot, és a második paritáscsoportot

189
00:11:52,234 --> 00:11:56,340
is, tehát a vevő tudja, hogy valahol hiba van abban a jobb oldali oszlopban.

190
00:11:56,340 --> 00:12:01,380
De ez nem érinti a harmadik csoportot, és nem érinti a negyedik csoportot.

191
00:12:01,380 --> 00:12:04,876
Ez pedig lehetővé teszi, hogy a vevő pontosan az első sorig azonosítsa a

192
00:12:04,876 --> 00:12:08,660
hibát, ami szükségszerűen a 3. pozíciót jelenti, így ki tudja javítani a hibát.

193
00:12:08,660 --> 00:12:11,475
Szívesen szánhat egy pillanatot arra, hogy meggyőzze magát arról,

194
00:12:11,475 --> 00:12:14,376
hogy a négy kérdésre adott válaszok valóban mindig lehetővé teszik,

195
00:12:14,376 --> 00:12:17,320
hogy meghatározzon egy adott helyet, függetlenül attól, hogy hol van.

196
00:12:17,320 --> 00:12:20,450
Valójában az okoskodók még azt is észrevehetik, hogy

197
00:12:20,450 --> 00:12:23,640
van kapcsolat e kérdések és a bináris számolás között.

198
00:12:23,640 --> 00:12:27,359
És ha igen, hadd hangsúlyozzam ismét, állj meg, próbáld

199
00:12:27,359 --> 00:12:30,880
meg magad megvonni az összefüggést, mielőtt elrontom.

200
00:12:30,880 --> 00:12:36,560
Ha kíváncsi arra, hogy mi történik, ha magát a paritásbitet érinti, akkor megpróbálhatja.

201
00:12:36,560 --> 00:12:40,245
Szánjon egy pillanatot arra, hogy gondolja végig, hogyan lehet

202
00:12:40,245 --> 00:12:43,754
e négy speciális bit közötti hibát ugyanúgy nyomon követni,

203
00:12:43,754 --> 00:12:47,440
mint bármely mást, ugyanazzal a négy kérdésből álló csoporttal.

204
00:12:47,440 --> 00:12:50,598
Teljesen mindegy, hiszen végső soron az üzenetbiteket

205
00:12:50,598 --> 00:12:53,640
akarjuk megvédeni, a hibajavító bitek csak haladnak.

206
00:12:53,640 --> 00:12:59,260
De ezeknek a biteknek a védelme is melléktermékként természetesen kiesik a rendszerből.

207
00:12:59,260 --> 00:13:02,380
Azt is élvezheti, ha előre látja, hogy ez hogyan skálázódik.

208
00:13:02,380 --> 00:13:06,837
Ha például egy 256 bites méretű blokkot használtunk egy hely

209
00:13:06,837 --> 00:13:11,441
meghatározásához, akkor mindössze nyolc igen vagy nem kérdésre

210
00:13:11,441 --> 00:13:15,680
van szüksége, hogy binárisan keressen egy bizonyos helyre.

211
00:13:15,680 --> 00:13:19,396
És ne feledje, minden kérdés csak egyetlen bitet

212
00:13:19,396 --> 00:13:23,340
igényel a megfelelő paritásellenőrzés beállításához.

213
00:13:23,340 --> 00:13:26,719
Lehet, hogy néhányan már látják, de később beszélünk arról, hogyan lehet

214
00:13:26,719 --> 00:13:29,960
szisztematikusan egy-két percen belül kideríteni, mik ezek a kérdések.

215
00:13:29,960 --> 00:13:32,369
Remélhetőleg ez a vázlat elegendő ahhoz, hogy értékeljük

216
00:13:32,369 --> 00:13:34,440
az itt fejlesztendő tevékenységünk hatékonyságát.

217
00:13:34,440 --> 00:13:38,113
Az első dolog, a nyolc kiemelt paritásbit kivételével,

218
00:13:38,113 --> 00:13:41,720
bármi lehet, bármilyen üzenetet vagy adatot hordozhat.

219
00:13:41,720 --> 00:13:47,342
A 8 bit redundáns abban az értelemben, hogy teljesen az üzenet többi része

220
00:13:47,342 --> 00:13:53,640
határozza meg őket, de ez sokkal okosabb módszer, mint az üzenet egészének másolása.

221
00:13:53,640 --> 00:13:56,378
És mégis, ennyire kevés feladással képes lenne

222
00:13:56,378 --> 00:13:59,000
azonosítani és kijavítani bármelyik bithibát.

223
00:13:59,000 --> 00:14:00,400
Hát majdnem.

224
00:14:00,400 --> 00:14:04,579
Oké, itt az egyetlen probléma az, hogy ha a négy paritásellenőrzés egyike sem

225
00:14:04,579 --> 00:14:09,080
észlel hibát, ami azt jelenti, hogy a speciálisan kiválasztott 8 bites részhalmazok

226
00:14:09,080 --> 00:14:13,366
mindegyikének páros paritása van, ahogy a küldő szándéka szerint, akkor ez vagy

227
00:14:13,366 --> 00:14:17,760
azt jelenti, hogy egyáltalán nem volt hiba. , vagy leszűkít minket a 0. pozícióba.

228
00:14:17,760 --> 00:14:22,076
Négy igen vagy nem kérdés esetén 16 lehetséges kimenetelünk van a

229
00:14:22,076 --> 00:14:27,374
paritásellenőrzésünkhöz, és ez elsőre tökéletesnek tűnik a blokk 16 pozíciójából

230
00:14:27,374 --> 00:14:33,000
1 pontos meghatározásához, de közölnie kell a 17. eredményt is, a nem hibát. feltétel.

231
00:14:33,000 --> 00:14:37,860
A megoldás itt valójában nagyon egyszerű, csak felejtsd el teljesen a 0. bitet.

232
00:14:37,860 --> 00:14:41,160
Tehát amikor elvégezzük a négy paritásellenőrzésünket, és azt látjuk,

233
00:14:41,160 --> 00:14:44,320
hogy mindegyik páros, az egyértelműen azt jelenti, hogy nincs hiba.

234
00:14:44,320 --> 00:14:47,232
Ez azt jelenti, hogy ahelyett, hogy egy 16 bites blokkal

235
00:14:47,232 --> 00:14:50,349
dolgoznánk, mi egy 15 bites blokkkal dolgozunk, ahol a bitek

236
00:14:50,349 --> 00:14:54,080
közül 11 szabadon hordozhat üzenetet, és közülük 4 redundancia miatt van.

237
00:14:54,080 --> 00:14:59,400
És ezzel most megvan, amit az üzletemberek 15-11 Hamming-kódként emlegetnének.

238
00:14:59,400 --> 00:15:02,715
Ennek ellenére jó, hogy van egy blokkméret, amely 2-es tiszta hatványt

239
00:15:02,715 --> 00:15:05,891
jelent, és van egy okos módszer, amellyel megtarthatjuk a 0. bitet,

240
00:15:05,891 --> 00:15:08,880
és rávehetjük, hogy egy kis plusz munkát végezzen el helyettünk.

241
00:15:08,880 --> 00:15:12,843
Ha paritásbitként használjuk az egész blokkon, akkor ténylegesen

242
00:15:12,843 --> 00:15:16,320
felismerjük a 2 bites hibákat, bár nem tudjuk kijavítani.

243
00:15:16,320 --> 00:15:17,440
Íme, hogyan működik.

244
00:15:17,440 --> 00:15:21,590
Miután beállítottuk a négy speciális hibajavító bitet, beállítjuk azt a 0-at, hogy

245
00:15:21,590 --> 00:15:25,540
a teljes blokk paritása páros legyen, akárcsak egy normál paritásellenőrzésnél.

246
00:15:25,540 --> 00:15:29,552
Most, ha egyetlen bites hiba van, akkor a teljes blokk paritása páratlanra

247
00:15:29,552 --> 00:15:33,940
vált, de a négy hibajavító ellenőrzésnek köszönhetően ezt mindenképpen megfognánk.

248
00:15:33,940 --> 00:15:39,949
Ha azonban két hiba van, akkor a teljes paritás vissza fog váltani párosra, de a vevő

249
00:15:39,949 --> 00:15:45,820
továbbra is látja, hogy legalább valami hiba történt a négy paritásellenőrzés miatt.

250
00:15:45,820 --> 00:15:49,492
Tehát ha összességében egyenletes paritást észlelnek, de a többi ellenőrzésnél

251
00:15:49,492 --> 00:15:52,980
valami nem nulla történik, akkor azt jelzi, hogy legalább két hiba történt.

252
00:15:52,980 --> 00:15:54,420
Hát nem okos?

253
00:15:54,420 --> 00:15:58,214
Annak ellenére, hogy ezeket a 2 bites hibákat nem tudjuk kijavítani, pusztán az

254
00:15:58,214 --> 00:16:02,340
egyetlen zavaró 0. bit visszaállításával lehetővé teszi számunkra, hogy észleljük őket.

255
00:16:02,340 --> 00:16:06,540
Ez meglehetősen szabványos, kiterjesztett Hamming-kódként ismert.

256
00:16:06,540 --> 00:16:10,115
Technikailag szólva, most már teljes leírása van arról, hogy mit

257
00:16:10,115 --> 00:16:13,580
csinál egy Hamming-kód, legalábbis egy 16 bites blokk esetében.

258
00:16:13,580 --> 00:16:17,727
De azt hiszem, sokkal elégedettebb lesz, ha ellenőrizni fogja a megértését, és

259
00:16:17,727 --> 00:16:21,980
mindent megszilárdít idáig úgy, hogy egy teljes példát tesz az elejétől a végéig.

260
00:16:21,980 --> 00:16:25,100
De végigcsinálom veled, hogy ellenőrizd magad.

261
00:16:25,100 --> 00:16:28,545
Üzenet beállításához, legyen szó szó szerinti üzenetről, amelyet

262
00:16:28,545 --> 00:16:32,096
térben fordít le, vagy bizonyos adatokat, amelyeket idővel tárolni

263
00:16:32,096 --> 00:16:35,700
szeretne, az első lépés az, hogy fel kell osztani 11 bites részekre.

264
00:16:35,700 --> 00:16:40,340
Minden egyes darab egy hibaálló 16 bites blokkba kerül.

265
00:16:40,340 --> 00:16:43,740
Tehát vegyük ezt példaként, és dolgozzuk ki ténylegesen.

266
00:16:43,740 --> 00:16:45,380
Hajrá, tényleg tedd meg!

267
00:16:45,380 --> 00:16:52,980
Álljunk meg, és próbáljuk összerakni ezt a blokkot.

268
00:16:52,980 --> 00:16:53,980
Oké, készen állsz?

269
00:16:53,980 --> 00:16:59,672
Ne feledje, hogy a 0 pozíció a 2 többi hatványával együtt hibajavítási feladatra van

270
00:16:59,672 --> 00:17:05,700
fenntartva, tehát először az üzenetbiteket az összes többi helyre, sorrendben helyezze el.

271
00:17:05,700 --> 00:17:09,367
Ennek a csoportnak páros paritásúnak kell lennie, ami már így is van,

272
00:17:09,367 --> 00:17:13,140
tehát azt a paritásbitet az 1-es pozícióban 0-ra kellett volna állítani.

273
00:17:13,140 --> 00:17:16,200
A következő csoport páratlan paritással kezdődik,

274
00:17:16,200 --> 00:17:19,260
ezért a paritásbitjét 1-re kellett volna állítani.

275
00:17:19,260 --> 00:17:21,898
Az ezt követő csoport páratlan paritással kezdődik,

276
00:17:21,898 --> 00:17:24,740
tehát ismét 1-re kellett volna állítani a paritásbitjét.

277
00:17:24,740 --> 00:17:27,990
És az utolsó csoportnak is van páratlan paritása,

278
00:17:27,990 --> 00:17:31,500
vagyis azt a bitet a 8-as pozícióban 1-re állítjuk be.

279
00:17:31,500 --> 00:17:36,454
Utolsó lépésként a teljes blokk páros paritású, vagyis

280
00:17:36,454 --> 00:17:41,500
beállíthatja a 0 bitszámot, az átfogó paritásbitet 0-ra.

281
00:17:41,500 --> 00:17:45,240
Tehát amikor ez a blokk elküldésre kerül, a négy speciális

282
00:17:45,240 --> 00:17:48,980
részhalmaz és a blokk egészének paritása páros vagy 0 lesz.

283
00:17:48,980 --> 00:17:53,620
A gyakorlat második részeként játsszuk a befogadó szerepét.

284
00:17:53,620 --> 00:17:56,795
Természetesen ez azt jelentené, hogy még nem tudja, mi ez az

285
00:17:56,795 --> 00:18:00,180
üzenet, talán néhányan megjegyezték, de tegyük fel, hogy még nem.

286
00:18:00,180 --> 00:18:04,023
Azt fogom tenni, hogy megváltoztatom a 0, 1 vagy 2 bitet

287
00:18:04,023 --> 00:18:08,340
ebben a blokkban, majd megkérem, hogy találja ki, mit csináltam.

288
00:18:08,340 --> 00:18:13,460
Tehát ismét álljon meg, és próbálja meg megoldani.

289
00:18:13,460 --> 00:18:21,158
Oké, tehát Ön, mint vevő, most ellenőrizze az első paritáscsoportot, és

290
00:18:21,158 --> 00:18:29,820
láthatja, hogy az páros, tehát minden létező hibának páros oszlopban kell lennie.

291
00:18:29,820 --> 00:18:34,397
A következő ellenőrzés páratlan számot ad nekünk, jelezve, hogy

292
00:18:34,397 --> 00:18:38,760
legalább egy hiba van, és leszűkítve erre a konkrét oszlopra.

293
00:18:38,760 --> 00:18:42,900
A harmadik ellenőrzés kiegyenlített, ami még tovább csökkenti a lehetőségeket.

294
00:18:42,900 --> 00:18:47,271
Az utolsó paritásellenőrzés pedig páratlan, és azt jelzi, hogy valahol alul

295
00:18:47,271 --> 00:18:51,700
van egy hiba, amiről mostanra láthatjuk, hogy a 10-es pozícióban kell lennie.

296
00:18:51,700 --> 00:18:55,283
Sőt, az egész blokk paritása furcsa, ami azt a bizonyosságot

297
00:18:55,283 --> 00:18:58,220
ad nekünk, hogy egy átfordulás volt, és nem kettő.

298
00:18:58,220 --> 00:19:01,600
Ha három vagy több, akkor minden fogadás megszűnik.

299
00:19:01,600 --> 00:19:06,320
A 10-es számú bit kijavítása után a korrekcióhoz nem használt 11 bitet

300
00:19:06,320 --> 00:19:10,774
kihúzva megkapjuk az eredeti üzenet megfelelő szegmensét, amely ha

301
00:19:10,774 --> 00:19:16,160
visszatekerjük és összehasonlítjuk, valóban pontosan az, amivel kezdtük a példát.

302
00:19:16,160 --> 00:19:20,099
És most, hogy tudja, hogyan kell mindezt kézzel megtenni, szeretném megmutatni,

303
00:19:20,099 --> 00:19:23,940
hogyan hajthatja végre ennek a logikának a lényegét egyetlen Python-kódsorral.

304
00:19:23,940 --> 00:19:27,901
Látod, amit még nem mondtam el, az az, hogy valójában mennyire elegáns ez az

305
00:19:27,901 --> 00:19:31,862
algoritmus, milyen egyszerű rávenni a gépet, hogy rámutasson a hiba helyére,

306
00:19:31,862 --> 00:19:35,824
hogyan lehet szisztematikusan skálázni, és hogyan tudjuk keretbe foglalni az

307
00:19:35,824 --> 00:19:39,580
egészet. ez egyetlen művelet, nem pedig több különálló paritásellenőrzés.

308
00:19:39,580 --> 00:19:39,580
Ha szeretnéd megérteni, mire gondolok, csatlakozz hozzám a 2. részhez.

