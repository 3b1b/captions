[
 {
  "input": "I'm assuming that everybody here is coming from part 1.",
  "translatedText": "Feltételezem, hogy itt mindenki látta már az előző részt.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 0.0,
  "end": 2.56
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it.",
  "translatedText": "A Hamming-kódokról beszéltünk, egy olyan adatblokk létrehozásának módjáról, ahol a legtöbb bit egy értelmes üzenetet hordoz, míg néhány másik egyfajta redundanciaként működik, oly módon, hogy ha bármelyik bit átbillen, akár egy üzenetbit, akár egy redundanciabit, bármi ebben a blokkban, a vevő képes lesz azonosítani, hogy hiba történt, és hogyan kell kijavítani azt.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 3.06,
  "end": 21.24
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error.",
  "translatedText": "Az ott bemutatott alapötlet az volt, hogy hogyan lehet a többszörös paritásellenőrzést egyfajta bináris keresésként használva eljutni a hibáig.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 21.88,
  "end": 27.16
 },
 {
  "input": "In that video, the goal was to make Hamming codes feel as hands-on and rediscoverable as possible.",
  "translatedText": "Abban a videóban a cél az volt, hogy a Hamming-kódokat gyakorlat orientáltan újra felfedezzük.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 28.98,
  "end": 34.6
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are.",
  "translatedText": "De ha elkezdünk gondolkodni a tényleges szoftveres vagy hardveres megvalósításon, rájöhetünk, hogy a korábbi megközelítésünk nem érzékelteti eléggé, hogy ezek a kódok valójában mennyire elegánsak.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 35.18,
  "end": 43.46
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that.",
  "translatedText": "Azt gondolhatnád, hogy olyan algoritmust kell írnod, amely számon tartja a hiba összes lehetséges helyét, és minden egyes ellenőrzésnél felezi a tartományt, de ez valójában sokkal, de sokkal egyszerűbb ennél.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 43.92,
  "end": 53.48
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as ones and zeros instead of yeses and nos, it literally spells out the position of the error in binary.",
  "translatedText": "Ha az előző videóban bemutatott négy paritás-ellenőrzés eredményét összeolvasod egyesek és nullák formájában, igenek és nemek helyett, akkor az szó szerint kiírja a hiba helyét binárisan.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 53.94,
  "end": 64.08
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1.",
  "translatedText": "Például a 7-es szám binárisan 0111-nek néz ki, ami lényegében azt jelenti, hogy 4 plusz 2 plusz 1.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 64.78,
  "end": 71.26
 },
 {
  "input": "And notice where the position 7 sits.",
  "translatedText": "És figyeljük meg, hol helyezkedik el a 7-es pozíció.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 72.54,
  "end": 74.46
 },
 {
  "input": "It does affect the first of our parity groups, and the second, and the third, but not the last.",
  "translatedText": "Hatással van az első csoport paritására, a második és a harmadikéra is, de az utolsóéra nem.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 74.84,
  "end": 81.74
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error.",
  "translatedText": "Tehát a négy ellenőrzés eredményeinek alulról felfelé történő összeolvasása valóban megadja a hiba helyét.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 82.22,
  "end": 87.54
 },
 {
  "input": "There's nothing special about the example 7, this works in general.",
  "translatedText": "A 7-es példában nincs semmi különleges, ez általánosságban is működik.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 88.32,
  "end": 91.14
 },
 {
  "input": "This makes the logic for implementing the whole scheme in hardware shockingly simple.",
  "translatedText": "Ez megdöbbentően egyszerűvé teszi az egész rendszer hardveres megvalósításának logikáját.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 91.78,
  "end": 95.82
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111.",
  "translatedText": "Ha meg akarod érteni, hogy miért működik ez a trükk, vedd a pozíciókhoz tartozó 16 indexcímkét, de a 10-es számrendszer helyett inkább binárisan írjuk le őket, 0000-tól 1111-ig.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 97.24,
  "end": 109.88
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent.",
  "translatedText": "Ahogy ezeket a bináris címkéket visszatesszük a dobozukba, hadd hangsúlyozzam, hogy ezek különböznek a ténylegesen küldött adatoktól.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 110.56,
  "end": 117.8
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from.",
  "translatedText": "Ezek csak kitalált címkék, amelyek segítenek neked és nekem beazonosítani a négy paritáscsoportot.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 118.32,
  "end": 123.5
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary.",
  "translatedText": "Annak eleganciáját, hogy ezen értékeket binárisan kezelhetjük, talán aláássa az a zűrzavar, hogy igazából minden más is amit nézünk binárisan van leírva.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 124.14,
  "end": 132.36
 },
 {
  "input": "It's worth it, though.",
  "translatedText": "De hidd el megéri.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 133.02,
  "end": 134.12
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels.",
  "translatedText": "Először csak a címkék utolsó bitjére koncentrálj.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 134.8,
  "end": 138.24
 },
 {
  "input": "And then highlight the positions where that final bit is a 1.",
  "translatedText": "Majd emeld ki azokat a pozíciókat, ahol az utolsó bit 1.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 139.88,
  "end": 143.22
 },
 {
  "input": "What we get is the first of our four parity groups, which means that you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1?",
  "translatedText": "A négy paritáscsoportunk közül így az elsőt kapjuk, ami azt jelenti, hogy az első ellenőrzést egy kérdésként értelmezhetjük: Ha van hiba, akkor a hely címkéjének utolsó bitje 1?",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 144.24,
  "end": 155.74
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme.",
  "translatedText": "Hasonlóképpen, ha az utolsó előtti bitre koncentrálunk, és kiemeljük az összes olyan pozíciót, ahol ez 1-es, akkor megkapjuk a második paritáscsoportot.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 158.2,
  "end": 166.16
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1?",
  "translatedText": "Más szóval, ezzel a második ellenőrzéssel azt kérdezzük, hogy: Hé! Megint én. Ha van hiba, a címke utolsó előtti bitje 1?",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 166.74,
  "end": 174.5
 },
 {
  "input": "And so on.",
  "translatedText": "És így tovább.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 175.76,
  "end": 176.9
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1.",
  "translatedText": "A harmadik paritásellenőrzés minden olyan pozíciót lefed, amelynek a harmadik bitje be van kapcsolva, a negyedik bit pedig az utolsó nyolc pozíciót, vagyis azokat, amelyek legmagasabb rendű bitje 1.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 177.22,
  "end": 188.74
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary.",
  "translatedText": "Minden amit eddig csináltunk, ugyanazt a négy kérdés válaszolja meg. Ezek eredményéből pedig összeáll a hiba pozíciójának bináris leírása.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 189.74,
  "end": 197.74
 },
 {
  "input": "I hope this makes two things clearer.",
  "translatedText": "Remélem, ez két dolgot is tisztáz.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 199.62,
  "end": 201.48
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two.",
  "translatedText": "Az első az, hogy hogyan lehet szisztematikusan általánosítani a nagyobb kettes hatványait jelentő blokkméretekre.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 202.04,
  "end": 206.46
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check.",
  "translatedText": "Ha minden egyes pozíció leírásához több bitre van szükség, például hat bitre 64 hely megkülönböztetéséhez, akkor mindegyik bithez tartozni fog egy-egy paritáscsoport, amelyet ellenőriznünk kell.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 206.96,
  "end": 216.68
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar.",
  "translatedText": "Azok, akik látták a sakktáblás rejtvényt, amit Matt Parkerrel csináltam, mindezt rendkívül ismerősnek találhatják.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 218.4,
  "end": 223.18
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard.",
  "translatedText": "Ugyanaz az alaplogika, csak egy másik probléma megoldására, egy 64 négyzetméteres sakktáblára alkalmazva.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 223.66,
  "end": 228.78
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8.",
  "translatedText": "A második dolog, amit remélem, hogy ez világossá tesz, hogy miért ülnek a paritásbitjeink olyan pozíciókban, amelyek a kettő hatványai, például 1, 2, 4 és 8.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 229.88,
  "end": 237.32
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on.",
  "translatedText": "Ezek azok a pozíciók, amelyek bináris ábrázolása csak egyetlen bekapcsolt bitet tartalmaz.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 238.0,
  "end": 243.0
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups.",
  "translatedText": "Ez azt jelenti, hogy minden egyes paritásbit a négy paritáscsoport közül csak egy és csakis egybe tartozik.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 243.6,
  "end": 249.46
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups.",
  "translatedText": "Ezt nagyobb példáknál is láthatjuk, ahol bármekkora méretet választunk, minden paritásbit praktikus módon csak az egyik csoportot érinti.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 252.04,
  "end": 259.34
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code.",
  "translatedText": "Amint megértettük, hogy ezek a paritásellenőrzések, amelyekre oly sok időt fordítottunk, nem többek, mint egy okos módja annak, hogy a hiba helyét binárisan leírjuk, akkor kapcsolatot tudunk teremteni a Hamming kódok értelmezésének egy másik módjával, amely vitathatatlanul sokkal egyszerűbb és elegánsabb, és amely alapvetően egyetlen kódsorral megvalósítható.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 265.6,
  "end": 283.24
 },
 {
  "input": "It's based on the XOR function.",
  "translatedText": "Ez a XOR függvényen alapul.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 283.66,
  "end": 285.5
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or.",
  "translatedText": "A XOR - azok számára, akik nem tudják - a kizáró vagy rövidítése.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 286.94,
  "end": 290.22
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or if both are turned off.",
  "translatedText": "Ha két bit XOR-ját vesszük, akkor 1-et kapunk, ha valamelyik bit be van kapcsolva, de 0 lesz, ha mindkettő be van kapcsolva, vagy ha mindkettő ki van kapcsolva.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 290.78,
  "end": 299.36
 },
 {
  "input": "Phrased differently, it's the parity of these two bits.",
  "translatedText": "Másképp fogalmazva, ez a két bit paritását adja.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 300.1,
  "end": 302.98
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2.",
  "translatedText": "Matematikusként én legszívesebben a bináris összeadás alapműveleteként gondolok rá.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 303.54,
  "end": 306.76
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component.",
  "translatedText": "Gyakran említjük két különböző bitsorozat XOR-ját, amely alapvetően komponensenként végzi el ezt.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 307.36,
  "end": 313.44
 },
 {
  "input": "It's like addition, but where you never carry.",
  "translatedText": "Olyan, mint az összeadás, csak itt nem viszünk tovább értékeket.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 313.68,
  "end": 315.72
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2.",
  "translatedText": "A matematikához jobban értők úgy is elképzelhetik, mint két vektor összegét, aminek kettes maradékát vesszük.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 316.5,
  "end": 322.48
 },
 {
  "input": "If you open up some Python right now, and you apply the caret operation between two integers, this is what it's doing, but to the bit representations of those numbers under the hood.",
  "translatedText": "Ha most Python-ban két egész szám közé hatványjelet írsz és lefuttatod, akkor pont ezt teszi a beírt számok bináris reprezentációjával, amit a háttérben vált oda-vissza.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 323.5,
  "end": 332.94
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parities of a bunch of separate groups, like so with the columns, all in one fell swoop.",
  "translatedText": "Számunkra ebből az a lényeges, hogy különböző bitsorozatok XOR-ját véve gyakorlatilag egy csomó különálló csoport paritását tudjuk kiszámítani, mint az oszlopok esetében, mindezt egy csapásra.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 334.96,
  "end": 347.14
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation.",
  "translatedText": "Ez egy elég elegáns módot ad arra, hogy a Hamming-kód algoritmusunk többszörös paritás-ellenőrzését egyetlen műveletbe csomagolva képzeljük el.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 351.26,
  "end": 358.78
 },
 {
  "input": "Though at first glance it does look very different.",
  "translatedText": "Bár első pillantásra nagyon másnak tűnik.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 359.48,
  "end": 362.18
 },
 {
  "input": "Specifically, write down the 16 positions in binary, like we had before, and now highlight only the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR.",
  "translatedText": "Konkrétan írjuk le a 16 pozíciót binárisan, ahogyan korábban is tettük, és most csak azokat a pozíciókat emeljük ki, ahol az üzenetbit 1-es, majd gyűjtsük össze ezeket egy nagy oszlopba, és vegyük a XOR-t.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 362.82,
  "end": 377.1
 },
 {
  "input": "You can probably guess that the four bits sitting at the bottom as a result are the same as the four parity checks we've come to know and love, but take a moment to actually think about why exactly.",
  "translatedText": "Valószínűleg kitalálhatod, hogy az eredményként kapott alul ülő négy bit ugyanazt adja, mint az általunk megismert négy paritásellenőrzés, de szánj egy pillanatot arra, hogy elgondolkodj azon, hogy pontosan miért.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 379.26,
  "end": 389.2
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group.",
  "translatedText": "Ez az utolsó oszlop például megszámolja az összes olyan pozíciót, amelynek utolsó bitje 1, de már csak a kiemelt pozíciók számítanak, így gyakorlatilag a kiemelt pozíciók számát kapjuk meg az első paritáscsoportból.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 392.22,
  "end": 405.76
 },
 {
  "input": "Does that make sense?",
  "translatedText": "Ez így érthető?",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 406.24,
  "end": 406.8
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on.",
  "translatedText": "Hasonlóképpen, a következő oszlop azt számolja, hogy hány olyan pozíció van a második paritáscsoportban, amelyek utolsó előtti bitje 1, emellett szintén kiemeltek. És így tovább.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 409.08,
  "end": 420.0
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing.",
  "translatedText": "Ez valójában ugyanaz amit eddig is csináltunk, csak más szemszögből szemlélve.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 420.26,
  "end": 423.96
 },
 {
  "input": "And so you know where it goes from here.",
  "translatedText": "És így már tudod, hogy hová vezet innen az út.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 427.76,
  "end": 429.6
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000.",
  "translatedText": "A küldő feladata, hogy néhány speciális paritásbitet átkapcsoljon, hogy az összeg biztosan 0000 legyen.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 430.0,
  "end": 436.56
 },
 {
  "input": "Once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error.",
  "translatedText": "Ha idáig sikerült eljutnunk, akkor már könnyebben át tudjuk gondolni, hogy ez a négy bit az alján miért írja le közvetlenül a hiba helyét.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 439.04,
  "end": 447.58
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1.",
  "translatedText": "Tegyük fel, hogy ebben a blokkban egy bit 0-ról 1-re változik.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 448.46,
  "end": 451.86
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error.",
  "translatedText": "Ez azt jelenti, hogy a bit helyének információja most már benne lesz a teljes XOR-ban, ami megváltoztatja az összeget 0-ról az újonnan bevezetett hiba pozíciója értékre.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 452.6,
  "end": 463.82
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0.",
  "translatedText": "Valamivel kevésbé nyilvánvaló, hogy ugyanez igaz, ha egy hiba miatt az 1-es érték 0-ra változik.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 464.46,
  "end": 469.36
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0.",
  "translatedText": "Tudod, ha egy bitsorozatot ily módon összeadod önmagával, az eredmény nulla lesz, mert ebben a világban 1 plusz 1 egyenlő 0-val.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 470.18,
  "end": 477.94
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as removing it.",
  "translatedText": "Tehát ezen pozíció másolatának hozzáadása a teljes összeghez ugyanolyan hatású, mintha eltávolítanánk.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 478.92,
  "end": 484.3
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error.",
  "translatedText": "Ennek ismét az a hatása, hogy eredményként itt alul megkapjuk a hiba helyét.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 485.16,
  "end": 490.7
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end.",
  "translatedText": "Annak illusztrálására, hogy ez milyen elegáns, hadd mutassam meg azt az egy sor Python kódot, amely szinte a teljes fogadó oldali logikát magába foglalja.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 493.04,
  "end": 501.44
 },
 {
  "input": "We'll start by creating a random array of 16 ones and zeros to simulate the data block, and I'll go ahead and give it the name bits, but of course in practice this would be something that we're receiving from a sender, and instead of being random, it would be carrying 11 data bits together with 5 parity bits.",
  "translatedText": "Azzal kezdem, hogy létrehozok egy 16 egyesből vagy nullából álló véletlenszerű tömböt az adatblokk szimulálására, és elnevezem biteknek. Ez a gyakorlatban természetesen olyasmi lenne, amit egy feladótól kapunk, és ahelyett, hogy véletlenszerű lenne, 11 adatbitet hordozna 5 paritásbittel együtt.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 502.08,
  "end": 517.4
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15.",
  "translatedText": "Ha meghívom az enumerateBits függvényt, akkor az minden egyes bitet összepárosít egy megfelelő indexszel, ebben az esetben 0-tól 15-ig.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 518.12,
  "end": 527.0
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i,bit, and then we pull out just the i value, just the index, well, it's not that exciting, we just get back those indices 0 through 15.",
  "translatedText": "Tehát ha létrehozunk egy listát, amely végigmegy ezeken a párokon, az \"i vessző bit\" alakú párokon, és csak az i értéket vesszük ki, vagyis az indexet, nos, ez nem olyan izgalmas, csak a 0-tól 15-ig terjedő indexeket kapjuk vissza.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 528.18,
  "end": 541.34
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on.",
  "translatedText": "De ha hozzáadjuk azt a feltételt, hogy csak akkor tegyük ezt, \"ha bit\", vagyis ha az a bit 1 és nem 0, akkor csak azokat a pozíciókat nézi, ahol a megfelelő bit be van kapcsolva.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 541.68,
  "end": 552.66
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc.",
  "translatedText": "Ebben az esetben ezek a pozíciók a 0, 4, 6, 9, stb.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 553.38,
  "end": 557.96
 },
 {
  "input": "Remember, what we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together.",
  "translatedText": "Ne feledjük, hogy az összes pozíciót, a bekapcsolt bitek pozícióit akarjuk összegyűjteni, majd XOR-olni őket egymással.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 559.98,
  "end": 567.24
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions.",
  "translatedText": "Ehhez Pythonban először is hadd importáljak néhány hasznos függvényt.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 569.18,
  "end": 573.22
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it.",
  "translatedText": "Így meghívhatjuk a reduce()-t erre a listára, és a XOR függvényt használhatjuk a redukcióhoz.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 573.9,
  "end": 578.7
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way.",
  "translatedText": "Ez lényegében végigrágja magát a listán, miközben XOR-okat végez.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 579.1,
  "end": 582.68
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere.",
  "translatedText": "Ha szeretnéd, akkor explicit ki is írhatod XOR függvényt anélkül, hogy importálni kéne bárhonnan.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 584.8,
  "end": 589.44
 },
 {
  "input": "So at the moment, it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001.",
  "translatedText": "Jelenleg tehát úgy néz ki, hogy ha ezt a 16 bites véletlenszerű blokkunkkal végezzük el, akkor 9-et kapunk vissza, ami az 1001-es bináris ábrázolást jelenti.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 591.94,
  "end": 601.28
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the 4 parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0.",
  "translatedText": "Ezt itt most nem fogom megtenni, de meg lehet írni egy olyan függvényt, amit a feladó a bináris ábrázolás 4 paritásbitjének szükség szerinti beállítására használja, hogy végül olyan állapotba hozza ezt a blokkot, ahol a kódsor futtatása a bitek teljes listáján 0-t ad vissza.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 601.98,
  "end": 615.46
 },
 {
  "input": "This would be considered a well-prepared block.",
  "translatedText": "Ez egy jól elkészített blokknak minősülne.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 616.08,
  "end": 618.2
 },
 {
  "input": "Now what's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error.",
  "translatedText": "Most az a klassz, hogy ha a listában lévő bitek bármelyikét átkapcsoljuk egy véletlenszerű hibát szimulálva, és lefuttatjuk ugyanazt a kódsort, akkor kiírja a hiba helyét.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 619.88,
  "end": 630.22
 },
 {
  "input": "Isn't that neat?",
  "translatedText": "Hát nem szuper?",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 630.96,
  "end": 631.52
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any.",
  "translatedText": "Bárhonnan kapsz egy ilyen blokkot, lefuttathatod rajta ezt az egyetlen sort, és automatikusan kiköpi a hiba pozícióját, vagy 0-t, ha nem volt hiba.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 631.82,
  "end": 641.06
 },
 {
  "input": "And there's nothing special about the size 16 here.",
  "translatedText": "És továbbra sincs semmi különös a 16-os méretben.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 642.5,
  "end": 645.2
 },
 {
  "input": "The same line of code would work if you had a list of 256 bits.",
  "translatedText": "Ugyanez a kódsor akkor is működne, ha egy 256 bites blokkra eresztenénk rá.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 645.4,
  "end": 649.86
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction.",
  "translatedText": "Mondanom sem kell, hogy a teljes működéshez kell még több kódot írni, mint például a meta paritásellenőrzéshez a 2 bites hibák felismerésére, de az ötlet az, hogy a módszerünk alapvető logikája egyetlen XOR redukcióra egyszerűsíthető.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 651.88,
  "end": 663.76
 },
 {
  "input": "Now depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go.",
  "translatedText": "Attól függően, hogy mennyire mozogsz otthonosan a kettes számrendszer, a XOR-ok és úgy általában a szoftverek terén, most vagy egy kicsit zavarosnak találod ezt a perspektívát, vagy annyira elegánsnak és egyszerűnek, hogy azon tűnődsz miért nem ezzel a szemlélettel kezdtük a kezdetektől fogva.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 666.12,
  "end": 678.42
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level.",
  "translatedText": "Lazán fogalmazva, a többszörös paritásellenőrzés szemléletre könnyebb gondolni, amikor a Hamming-kódokat hardveresen, nagyon közvetlenül implementáljuk, a XOR szemléletre pedig akkor, amikor szoftveresen, egyfajta magasabb szintről csináljuk.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 679.14,
  "end": 690.5
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles.",
  "translatedText": "Az elsőt a legkönnyebb kézzel elvégezni, és úgy gondolom ezért jobban elősegíti a mindezek alapjául szolgáló intuíció elsajátítását, miszerint az egyetlen hiba megtalálásához szükséges információ a blokk méretének logaritmusával függ össze, vagy más szóval, a blokk méretének megduplázódásával csak egy bittel kell több.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 691.36,
  "end": 710.0
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need.",
  "translatedText": "A legfontosabb tény itt az, hogy ezen információ mérete közvetlenül megfeleltethető a szükséges redundancia mennyiségével.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 711.02,
  "end": 716.06
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind.",
  "translatedText": "Ez az, ami a legtöbb ember beidegződésével ellentétesen hat. Úgy vettem észre, hogy az emberek ösztönös gondolata arra a problémára, hogy egy üzenetet ellenállóvá tegyenek a hibákkal szemben általában az üzenet teljes másolása.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 716.66,
  "end": 726.54
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented where you multiply the message by one big matrix.",
  "translatedText": "És egyébként még van egy másik módszer is, amit néha a Hamming-kódok bemutatására használnak, amikor az üzenetet egy nagy mátrixszal szorozzák meg.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 727.5,
  "end": 734.0
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales.",
  "translatedText": "Persze szép, mert a lineáris kódok tágabb családjára alkalmazható, de szerintem egyáltalán nem segíti annak megértését, hogy honnan származik a módszer, vagy hogyan skálázható.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 734.67,
  "end": 743.06
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size.",
  "translatedText": "És ha már a skálázásnál tartunk, vegyük észre, hogy ennek a rendszernek a hatékonysága csak javul, ahogy növeljük a blokkméretet.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 745.2,
  "end": 751.16
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there.",
  "translatedText": "Láttuk például, hogy 256 bitnek csak 3%-át használjuk redundanciaként. Több bitnél pedig csak egyre jobb ez az arány.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 755.0,
  "end": 762.66
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling.",
  "translatedText": "Ahogy a paritásbitek számát egyesével növeljük, a blokk méretét megduplázhatjuk!",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 763.3,
  "end": 767.34
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits.",
  "translatedText": "És ha ezt a végletekig fokozzuk, olyan blokkunk is lehet, mondjuk, egymillió bitből, ahol szó szerint 20 kérdéssel elvégezhető a teljes paritásellenőrzés, és csak 21 paritásbitet használunk.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 769.0,
  "end": 780.02
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy.",
  "translatedText": "És ha jobban belegondolsz, egymillió bitre ránézni és azonnal megtalálni a hibát őrültségnek hangzik és mégis lehetséges.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 780.74,
  "end": 787.06
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that.",
  "translatedText": "A probléma persze az, hogy nagyobb blokkok esetén megnő a valószínűsége annak, hogy egynél több bithiba keletkezik, és a Hamming-kódok ezeket már nem képesek kezelni.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 788.2,
  "end": 797.66
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high.",
  "translatedText": "A gyakorlatban tehát azt a megfelelő méretet kell megtalálni, ahol az egynél több bit átbillenésének valószínűsége még nem túl nagy.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 798.32,
  "end": 804.3
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block.",
  "translatedText": "Emellett a gyakorlatban a hibák általában rövid sorozatban jelentkeznek, ami teljesen tönkretesz egy-egy blokkot.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 806.6,
  "end": 811.62
 },
 {
  "input": "So one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored.",
  "translatedText": "Tehát az egyik általános taktika a hibák több blokkban való eloszlásának elősegítésére az, hogy ezeket a blokkokat átlapolják, például így, mielőtt elküldik vagy tárolják őket.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 812.2,
  "end": 820.98
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block.",
  "translatedText": "Másfelől ezek a módszerek már jelentősségüket vesztették a modernebb kódok miatt, mint például a sokkal gyakrabban használt Reed-Solomon algoritmus, amely különösen jól kezeli a sorozatos hibákat, és úgy hangolható, hogy blokkonként nagyobb számú hibával szemben is ellenálló legyen.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 825.58,
  "end": 838.82
 },
 {
  "input": "But that is a topic for another time.",
  "translatedText": "De ez már egy másik videó témáját képezhetné.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 839.36,
  "end": 841.34
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was.",
  "translatedText": "A \"The Art of Doing Science and Engineering\" című könyvében Hamming csodálatosan őszintén beszél arról, hogy mennyire kanyargós úton jutott el a kód felfedezéséhez.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 842.5,
  "end": 849.94
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this.",
  "translatedText": "Először mindenféle különböző módszert próbált ki, amelyekben a biteket egy magasabb dimenziós rács részeibe szervezte, és hasonló furcsa dolgokat.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 850.62,
  "end": 857.78
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this?",
  "translatedText": "Az ötlet, hogy esetleg lehetséges lenne a paritás-ellenőrzéseket úgy együttműködésre bírni, hogy a hiba helyét kiírják, csak akkor jutott Hamming eszébe, amikor egy csomó más elemzés után hátrább lépett, és megkérdezte: \"Oké, mi lenne az elképzelhető leghatékonyabb megoldás?\".",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 858.3,
  "end": 871.52
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today.",
  "translatedText": "Őszintén beszél arról is, mennyire fontos volt, hogy már akkor is a paritásellenőrzések jártak a fejében, ami az 1940-es években sokkal kevésbé volt jellemző, mint manapság.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 872.62,
  "end": 881.22
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind.",
  "translatedText": "A könyvben mintegy féltucatszor hivatkozik Louis Pasteur idézetére, miszerint \"A szerencse csak a felkészült elmének kedvez\".",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 881.92,
  "end": 888.22
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate.",
  "translatedText": "A brilliáns ötletek utólag gyakran megtévesztően egyszerűnek tűnnek, ami miatt könnyen alábecsüljük őket.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 889.32,
  "end": 894.3
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you.",
  "translatedText": "Őszintén remélem, hogy a Hamming-kódok, de legalább a hozzá hasonló kódok létezése most már magától értetődőnek tűnik számodra.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 894.96,
  "end": 901.3
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't.",
  "translatedText": "De ne áltasd magad azzal, hogy ezek valóban nyilvánvalóak, mert egyáltalán nem azok.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 901.66,
  "end": 906.82
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that.",
  "translatedText": "Ezen ötletek részben azért tűnnek megtévesztően egyszerűnek, mert mindig csak a végeredményt látjuk, miután minden rendbe lett rakva, a problémamegoldási folyamat kezdetén előttünk álló felfedezhető lehetőségek tárházát és a közben elkövetett rossz fordulatokat már nem.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 907.88,
  "end": 922.86
 },
 {
  "input": "But this is true in general.",
  "translatedText": "De ez általánosságban is igaz.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 923.82,
  "end": 924.9
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them.",
  "translatedText": "Azt hiszem, néhány különleges találmány esetében van egy második, mélyebb oka is annak, hogy alulértékeljük őket.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 924.9,
  "end": 930.04
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory.",
  "translatedText": "Az információ bitekben való elgondolása csak 1948-ra, Claude Shannon információelméletről szóló alapvető tanulmányával vált igazán teljes elméletté.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 930.84,
  "end": 938.64
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm.",
  "translatedText": "Ez lényegében egybeesett azzal, amikor Hamming kifejlesztette algoritmusát.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 939.28,
  "end": 942.54
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory.",
  "translatedText": "Ez volt az az írás, amely bizonyos értelemben elsőként megmutatta, hogy a hatékony hibajavítás mindig lehetséges, függetlenül attól, hogy mekkora a bithibák valószínűsége. Legalábbis elméletben.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 943.3,
  "end": 952.9
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here.",
  "translatedText": "Shannon és Hamming egyébként közös irodában ült a Bell Labs-nél, annak ellenére, hogy elég különböző feladatokon dolgoztak, és ez aligha tűnik véletlennek.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 953.7,
  "end": 961.16
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was.",
  "translatedText": "Ugorjunk előre néhány évtizedet. Manapság annyira elterjedtté vált a bitekről és információról alkotott szemlélet, hogy könnyű figyelmen kívül hagyni, korábban ez mennyire nem így volt.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 962.38,
  "end": 972.34
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are.",
  "translatedText": "Ironikus módon pont azok az eszmék, amelyek a legjobban alakítják a jövő generációinak gondolkodásmódját, tűnnek végül egyszerűbbnek számukra, mint amilyenek valójában.",
  "model": "DeepL",
  "n_reviews": 1,
  "start": 973.1,
  "end": 982.26
 }
]