1
00:00:00,000 --> 00:00:08,620
Вы когда-нибудь задумывались, как можно поцарапать компакт-диск или DVD-диск

2
00:00:08,620 --> 00:00:10,900
и при этом воспроизвести все, что на нем хранится?

3
00:00:10,900 --> 00:00:15,280
Царапина действительно влияет на 1 и 0 на диске, поэтому он считывает

4
00:00:15,280 --> 00:00:20,500
данные, отличные от того, что было сохранено, но если он действительно

5
00:00:20,500 --> 00:00:26,540
не поцарапан, считанные биты декодируются точно в тот же файл, который

6
00:00:26,540 --> 00:00:28,400
был закодирован на нем. побитовая копия, несмотря на все эти ошибки.

7
00:00:28,400 --> 00:00:32,800
Существует целый ряд математических хитростей, которые позволяют нам хранить данные и,

8
00:00:32,800 --> 00:00:36,840
что не менее важно, передавать их устойчивым к ошибкам способом.

9
00:00:36,840 --> 00:00:41,480
Ну да ладно, на самом деле не нужно так

10
00:00:41,480 --> 00:00:42,480
уж много ума, чтобы придумать способ сделать это.

11
00:00:42,480 --> 00:00:47,660
Любой файл, будь то видео, звук или текст, какой-то код, изображение, что

12
00:00:47,660 --> 00:00:50,960
угодно, в конечном итоге представляет собой некую последовательность единиц и нулей.

13
00:00:50,960 --> 00:00:55,340
А простой стратегией исправления любого перевернутого бита

14
00:00:55,340 --> 00:00:57,780
было бы сохранение трех копий каждого бита.

15
00:00:57,780 --> 00:01:02,240
Тогда машина, читающая этот файл, сможет сравнить эти три копии

16
00:01:02,240 --> 00:01:07,440
и всегда брать лучшие 2 из 3, если есть несоответствие.

17
00:01:07,440 --> 00:01:11,560
Но это означает использование двух третей вашего пространства для резервирования.

18
00:01:11,560 --> 00:01:15,360
И даже в этом случае, несмотря на все это отведенное пространство, нет

19
00:01:15,360 --> 00:01:18,120
надежной гарантии того, что произойдет, если будет перевернуто более одного бита.

20
00:01:18,120 --> 00:01:21,960
Гораздо более интересный вопрос — как сделать так, чтобы можно

21
00:01:21,960 --> 00:01:24,740
было исправлять ошибки, занимая при этом как можно меньше места.

22
00:01:24,740 --> 00:01:28,500
Например, используя метод, который вы узнаете из этого видео, вы можете хранить свои данные в

23
00:01:28,500 --> 00:01:35,840
256-битных блоках, где каждый блок использует 9 бит, 9! действовать как своего рода избыточность, а

24
00:01:35,840 --> 00:01:41,000
остальные 247 бит могут свободно переносить любое значимое сообщение или данные, которые вы хотите.

25
00:01:41,000 --> 00:01:44,740
И все равно будет так, что если какой-либо бит здесь будет перевернут, просто

26
00:01:44,740 --> 00:01:49,640
взглянув на этот блок и не более того, машина сможет определить, что произошла

27
00:01:49,640 --> 00:01:53,120
ошибка и точно где она была, чтобы она знала, как ее исправить. .

28
00:01:53,140 --> 00:01:55,540
И, честно говоря, это похоже на волшебство.

29
00:01:55,540 --> 00:01:59,400
И для этой конкретной схемы, если два бита будут перевернуты, машина, по крайней

30
00:01:59,400 --> 00:02:03,180
мере, сможет обнаружить две ошибки, хотя и не будет знать, как их исправить.

31
00:02:03,180 --> 00:02:08,140
Чуть позже мы поговорим о том, как это масштабируется для блоков разных размеров.

32
00:02:08,140 --> 00:02:12,620
Методы, позволяющие исправлять подобные ошибки, вполне

33
00:02:12,620 --> 00:02:13,880
обоснованно называются кодами исправления ошибок.

34
00:02:13,880 --> 00:02:18,220
На протяжении большей части прошлого столетия эта область была действительно богатым источником

35
00:02:18,220 --> 00:02:23,000
удивительно глубокой математики, которая внедрялась в устройства, которые мы используем каждый день.

36
00:02:23,000 --> 00:02:27,740
Цель здесь — дать вам очень полное представление об

37
00:02:27,740 --> 00:02:29,660
одном из самых ранних примеров, известном как код Хэмминга.

38
00:02:29,660 --> 00:02:32,620
И, кстати, я думаю о структуре этого видео не столько для того,

39
00:02:32,620 --> 00:02:37,060
чтобы объяснить его как можно более прямо, сколько для того, чтобы побудить

40
00:02:37,060 --> 00:02:40,220
вас изобрести его самостоятельно, с небольшими мягкими указаниями здесь и там.

41
00:02:40,220 --> 00:02:44,100
Поэтому, когда вы почувствуете, что видите, к чему все идет в какой-то момент, воспользуйтесь моментом,

42
00:02:44,100 --> 00:02:47,180
чтобы сделать паузу и активно спрогнозировать, какой будет схема, прежде чем я вам скажу.

43
00:02:47,180 --> 00:02:51,500
Кроме того, если вы хотите, чтобы ваше понимание достигло аппаратного уровня,

44
00:02:51,500 --> 00:02:55,160
Бен Итер вместе с этим снял видео, показывающее, как на

45
00:02:55,160 --> 00:02:59,520
самом деле реализовать коды Хэмминга на макетах, что очень приятно.

46
00:02:59,520 --> 00:03:03,120
Вы должны знать, что коды Хэмминга не так широко используются, как более современные коды, такие

47
00:03:03,120 --> 00:03:08,040
как алгоритм Рида-Соломона, но есть определенная магия в контрасте между тем, насколько невыполнимой кажется эта

48
00:03:08,040 --> 00:03:14,240
задача в начале, и тем, насколько совершенно разумной она кажется однажды. вы узнаете о Хэмминге.

49
00:03:14,240 --> 00:03:19,080
Основной принцип исправления ошибок заключается в том, что в огромном пространстве

50
00:03:19,300 --> 00:03:22,860
всех возможных сообщений только некоторые подмножества будут считаться действительными сообщениями.

51
00:03:22,860 --> 00:03:29,100
В качестве аналогии подумайте о правильно написанных словах и неправильно написанных словах.

52
00:03:29,100 --> 00:03:33,340
Всякий раз, когда допустимое сообщение изменяется, получатель несет ответственность за исправление

53
00:03:33,340 --> 00:03:38,380
увиденного до ближайшего допустимого соседа, как это можно сделать с опечаткой.

54
00:03:38,380 --> 00:03:43,100
Однако создание конкретного алгоритма для эффективной

55
00:03:43,100 --> 00:03:47,160
классификации подобных сообщений требует определенной смекалки.

56
00:03:47,160 --> 00:03:52,060
История начинается в 1940-х годах, когда молодой Ричард Хэмминг работал в Bell

57
00:03:52,060 --> 00:03:55,900
Labs, и часть его работы заключалась в использовании очень большого дорогого

58
00:03:55,900 --> 00:03:57,420
компьютера с перфокартами, к которому у него был лишь ограниченный доступ.

59
00:03:57,420 --> 00:04:01,200
И программы, которые он продолжал реализовывать, продолжали давать сбой,

60
00:04:01,200 --> 00:04:03,140
потому что время от времени что-то считывалось неправильно.

61
00:04:03,140 --> 00:04:07,140
Разочарование было горнилом изобретений, и ему это настолько надоело,

62
00:04:07,140 --> 00:04:09,280
что он изобрел первый в мире код исправления ошибок.

63
00:04:09,280 --> 00:04:13,020
Существует множество различных способов создания кодов Хэмминга, но для начала

64
00:04:13,020 --> 00:04:16,620
мы рассмотрим их так, как о них думал сам Хэмминг.

65
00:04:16,620 --> 00:04:21,400
Давайте возьмем простой, но не слишком простой пример: блок из 16 бит.

66
00:04:21,400 --> 00:04:25,700
Пронумеруем позиции этих битов от 0 до 15.

67
00:04:25,700 --> 00:04:30,520
Фактические данные, которые мы хотим сохранить, будут состоять только из 12

68
00:04:30,520 --> 00:04:33,920
таких битов, а 4 позиции зарезервированы в качестве своего рода избыточности.

69
00:04:33,920 --> 00:04:38,120
Слово «избыточный» здесь не означает просто копирование: в конце концов, эти

70
00:04:38,120 --> 00:04:40,200
4 бита не дают нам достаточно места для слепого копирования данных.

71
00:04:40,200 --> 00:04:44,880
Вместо этого они должны будут представлять собой гораздо более тонкую и

72
00:04:44,880 --> 00:04:48,740
умную избыточность, не добавляя никакой новой информации, но повышая устойчивость.

73
00:04:48,740 --> 00:04:52,620
Вы могли бы ожидать, что эти 4 специальных бита будут красиво упакованы вместе, может

74
00:04:52,620 --> 00:04:56,400
быть, в конце или что-то в этом роде, но, как вы увидите, расположение их

75
00:04:56,400 --> 00:05:00,320
в положениях, которые являются степенями 2, к концу позволяет получить что-то действительно элегантное.

76
00:05:00,320 --> 00:05:05,420
Это также может дать вам небольшую подсказку о том, как это масштабируется для более крупных блоков.

77
00:05:05,420 --> 00:05:09,220
Кроме того, технически это всего лишь 11 бит данных, вы обнаружите небольшой нюанс

78
00:05:09,220 --> 00:05:14,260
в том, что происходит в позиции 0, но пока не беспокойтесь об этом.

79
00:05:14,280 --> 00:05:18,640
Как и в любом алгоритме исправления ошибок, в нем участвуют два

80
00:05:18,640 --> 00:05:23,200
игрока: отправитель, который отвечает за установку этих 4 специальных битов, и

81
00:05:23,200 --> 00:05:26,360
получатель, который отвечает за выполнение некоторой проверки и исправление ошибок.

82
00:05:26,360 --> 00:05:30,040
Конечно, слова «отправитель» и «получатель» на самом деле относятся к

83
00:05:30,040 --> 00:05:34,040
машинам или программному обеспечению, выполняющим все проверки, а идея

84
00:05:34,040 --> 00:05:35,480
сообщения подразумевается очень широко, включая такие вещи, как хранилище.

85
00:05:35,480 --> 00:05:39,320
В конце концов, хранение данных — это то же самое, что отправка сообщения

86
00:05:39,320 --> 00:05:42,640
только из прошлого в будущее, а не из одного места в другое.

87
00:05:42,640 --> 00:05:46,700
Итак, установка такова, но прежде чем мы углубимся в нее, нам

88
00:05:46,700 --> 00:05:51,080
нужно поговорить о связанной идее, которая была свежа в голове Хэмминга

89
00:05:51,080 --> 00:05:55,520
во время его открытия, о методе, который позволяет обнаруживать любые однобитовые

90
00:05:55,520 --> 00:05:57,300
ошибки, но не исправлять их, известный в бизнесе как проверка паритета.

91
00:05:57,300 --> 00:06:01,300
Для проверки четности мы выделяем только один бит, за настройку

92
00:06:01,300 --> 00:06:04,940
которого отвечает отправитель, а остальные могут свободно переносить сообщение.

93
00:06:04,940 --> 00:06:10,380
Единственная задача этого специального бита — убедиться, что

94
00:06:10,380 --> 00:06:12,100
общее количество единиц в сообщении является четным.

95
00:06:12,100 --> 00:06:16,920
Например, сейчас общее количество единиц равно 7, это нечетно, поэтому отправителю

96
00:06:16,920 --> 00:06:20,960
необходимо перевернуть этот специальный бит на 1, чтобы сделать счет четным.

97
00:06:20,960 --> 00:06:25,320
Но если бы блок уже начинался с четного числа

98
00:06:25,320 --> 00:06:27,480
единиц, тогда этот специальный бит остался бы равным 0.

99
00:06:27,480 --> 00:06:31,640
Это довольно просто, обманчиво просто, но это невероятно элегантный способ выразить идею

100
00:06:31,640 --> 00:06:37,760
изменения в любом месте сообщения и отразить ее в одном бите информации.

101
00:06:37,760 --> 00:06:43,680
Обратите внимание: если какой-либо бит этого сообщения переворачивается с 0 на 1 или

102
00:06:43,680 --> 00:06:48,140
с 1 на 0, общее количество единиц меняется с четного на нечетное.

103
00:06:48,140 --> 00:06:52,000
Итак, если вы получатель, посмотрите на это сообщение и увидите

104
00:06:52,000 --> 00:06:56,580
нечетное число единиц, вы можете точно знать, что произошла какая-то

105
00:06:56,580 --> 00:06:58,700
ошибка, даже если вы понятия не имеете, где она была.

106
00:06:58,700 --> 00:07:02,820
На жаргоне четное или нечетное количество единиц

107
00:07:02,820 --> 00:07:04,940
в группе битов называется ее четностью.

108
00:07:04,940 --> 00:07:09,140
Вы также можете использовать числа и сказать, что четность равна 0 или 1,

109
00:07:09,140 --> 00:07:11,320
что обычно более полезно, когда вы начинаете заниматься математикой с этой идеей.

110
00:07:11,320 --> 00:07:15,200
И этот специальный бит, который отправитель использует

111
00:07:15,200 --> 00:07:18,020
для контроля четности, называется битом четности.

112
00:07:18,020 --> 00:07:22,460
И на самом деле, нам должно быть ясно: если получатель видит нечетную четность, это не

113
00:07:22,460 --> 00:07:26,920
обязательно означает, что была только одна ошибка, могло быть 3 ошибки, или 5, или

114
00:07:26,920 --> 00:07:29,560
любое другое нечетное число, но он может знать это наверняка. что это не 0.

115
00:07:29,560 --> 00:07:34,880
С другой стороны, если бы было 2 ошибки или любое четное количество ошибок,

116
00:07:34,880 --> 00:07:39,560
итоговое количество единиц все равно было бы четным, поэтому получатель не может быть

117
00:07:39,560 --> 00:07:43,360
полностью уверен, что четное количество обязательно означает, что сообщение не содержит ошибок. .

118
00:07:43,360 --> 00:07:47,860
Вы можете жаловаться, что сообщение, которое искажается всего лишь

119
00:07:47,860 --> 00:07:49,760
двумя битами, довольно слабое, и вы будете абсолютно правы.

120
00:07:49,760 --> 00:07:54,480
Однако имейте в виду, что не существует метода обнаружения или исправления ошибок, который мог бы дать

121
00:07:54,480 --> 00:07:59,720
вам 100% уверенность в том, что полученное вами сообщение является именно тем, которое намеревался отправитель.

122
00:07:59,720 --> 00:08:03,760
В конце концов, достаточное количество случайного шума всегда может превратить

123
00:08:03,760 --> 00:08:05,920
одно действительное сообщение в другое действительное сообщение по чистой случайности.

124
00:08:05,920 --> 00:08:10,520
Вместо этого цель состоит в том, чтобы придумать схему, устойчивую к

125
00:08:10,520 --> 00:08:16,480
определенному максимальному количеству ошибок, или, возможно, снизить вероятность такого ложного срабатывания.

126
00:08:16,480 --> 00:08:20,940
Сами по себе проверки четности довольно слабы, но, сведя

127
00:08:20,940 --> 00:08:25,640
идею изменения всего сообщения до одного бита, они дают

128
00:08:25,640 --> 00:08:28,000
нам мощный строительный блок для более сложных схем.

129
00:08:28,000 --> 00:08:32,880
Например, когда Хэмминг искал способ определить, где произошла ошибка, а не только то,

130
00:08:32,880 --> 00:08:37,160
что она произошла, его ключевой вывод заключался в том, что если вы примените

131
00:08:37,160 --> 00:08:42,040
некоторые проверки четности не ко всему сообщению, а к определенным тщательно выбранным подмножествам,

132
00:08:42,040 --> 00:08:46,840
вы можете спросить более уточненная серия вопросов, позволяющая определить местонахождение любой единичной ошибки.

133
00:08:46,840 --> 00:08:51,280
Общее ощущение немного похоже на игру из 20 вопросов, когда вы

134
00:08:51,280 --> 00:08:54,300
задаете вопросы «да» или «нет», которые делят пространство возможностей пополам.

135
00:08:54,300 --> 00:08:58,840
Например, предположим, что мы выполняем проверку четности только для

136
00:08:58,840 --> 00:08:59,840
этих 8 бит, всех позиций с нечетными номерами.

137
00:09:00,400 --> 00:09:04,560
Затем, если ошибка обнаружена, он дает приемнику немного больше информации о том,

138
00:09:04,560 --> 00:09:09,160
где именно находится ошибка, а именно, что она находится в нечетном положении.

139
00:09:09,160 --> 00:09:14,360
Если среди этих 8 бит не обнаружено ошибок, это либо означает,

140
00:09:14,360 --> 00:09:17,240
что ошибки вообще нет, либо она находится где-то в четных позициях.

141
00:09:17,240 --> 00:09:21,560
Вы можете подумать, что ограничение проверки четности половиной битов делает ее менее

142
00:09:21,560 --> 00:09:25,460
эффективной, но когда она выполняется в сочетании с другими правильно выбранными

143
00:09:25,460 --> 00:09:29,720
проверками, это, как ни странно, дает нам нечто гораздо более мощное.

144
00:09:29,720 --> 00:09:34,440
Помните, что для фактической настройки проверки четности необходимо выделить

145
00:09:34,440 --> 00:09:37,600
какой-то специальный бит, который контролирует четность всей группы.

146
00:09:37,600 --> 00:09:39,920
Здесь давайте просто выберем позицию 1.

147
00:09:39,920 --> 00:09:43,960
В показанном примере четность этих 8 бит в настоящее время нечетная, поэтому

148
00:09:43,960 --> 00:09:48,220
отправитель несет ответственность за переключение этого бита четности, и теперь он четный.

149
00:09:48,220 --> 00:09:51,040
Это только 1 из 4 проверок четности, которые мы проведем.

150
00:09:51,040 --> 00:09:55,560
Вторая проверка осуществляется среди 8 бит в правой половине сетки,

151
00:09:55,560 --> 00:09:56,880
по крайней мере, так, как мы ее нарисовали здесь.

152
00:09:56,880 --> 00:10:02,520
На этот раз мы могли бы использовать позицию 2 в качестве бита четности, так что эти 8

153
00:10:02,520 --> 00:10:07,160
бит уже имеют четность, и отправитель может чувствовать себя хорошо, оставив этот бит номер 2 без изменений.

154
00:10:07,160 --> 00:10:11,040
Затем, на другом конце, если получатель проверит четность этой группы и обнаружит, что

155
00:10:11,040 --> 00:10:15,960
она нечетная, он узнает, что ошибка находится где-то среди этих 8 бит справа.

156
00:10:15,960 --> 00:10:21,260
В противном случае это означает, что либо ошибки нет, либо ошибка где-то в левой половине.

157
00:10:21,260 --> 00:10:24,040
Или я предполагаю, что ошибок могло быть две, но сейчас мы

158
00:10:24,040 --> 00:10:27,080
будем предполагать, что во всем блоке есть не более одной ошибки.

159
00:10:27,080 --> 00:10:29,160
Более того, все полностью ломается.

160
00:10:29,160 --> 00:10:32,920
Здесь, прежде чем мы рассмотрим следующие две проверки, подумайте, что

161
00:10:32,920 --> 00:10:35,880
позволяют нам делать первые две проверки, если рассматривать их вместе.

162
00:10:35,880 --> 00:10:40,240
Допустим, вы обнаружили ошибку среди нечетных столбцов и среди правой половины.

163
00:10:40,240 --> 00:10:43,940
Это обязательно означает, что ошибка находится где-то в последнем столбце.

164
00:10:43,940 --> 00:10:48,280
Если в нечетном столбце не было ошибки, но она была в

165
00:10:48,280 --> 00:10:50,520
правой половине, это означает, что она находится в предпоследнем столбце.

166
00:10:50,520 --> 00:10:54,640
Аналогично, если ошибка есть в нечетных столбцах, но не в

167
00:10:54,640 --> 00:10:56,560
правой половине, вы знаете, что она где-то во втором столбце.

168
00:10:56,560 --> 00:11:00,560
И если ни одна из этих двух проверок четности ничего не обнаружит, это

169
00:11:00,560 --> 00:11:03,760
означает, что единственное место, где может быть ошибка, — это самый левый столбец.

170
00:11:03,760 --> 00:11:06,480
Но это также может означать, что ошибки вообще нет.

171
00:11:06,480 --> 00:11:10,800
Это довольно расплывчатый способ сказать, что две

172
00:11:10,800 --> 00:11:11,800
проверки четности позволяют нам зафиксировать столбец.

173
00:11:11,800 --> 00:11:14,000
Отсюда вы, вероятно, можете догадаться, что будет дальше.

174
00:11:14,000 --> 00:11:16,240
Мы делаем в основном то же самое, но для строк.

175
00:11:16,240 --> 00:11:21,040
Будет произведена проверка четности нечетных строк с использованием позиции 4 в качестве бита четности.

176
00:11:21,040 --> 00:11:25,480
Итак, в этом примере эта группа уже имеет

177
00:11:25,480 --> 00:11:26,480
четность, поэтому бит 4 будет установлен в 0.

178
00:11:26,480 --> 00:11:31,280
И, наконец, в двух нижних строках выполняется проверка четности

179
00:11:31,280 --> 00:11:32,280
с использованием позиции 8 в качестве бита четности.

180
00:11:32,280 --> 00:11:35,840
В этом случае похоже, что отправителю необходимо

181
00:11:35,840 --> 00:11:37,840
включить бит 8, чтобы обеспечить четность группе.

182
00:11:37,840 --> 00:11:41,360
Так же, как первые две проверки позволяют нам

183
00:11:41,360 --> 00:11:43,000
закрепить столбец, следующие две позволяют закрепить строку.

184
00:11:43,000 --> 00:11:48,400
В качестве примера представьте, что во время передачи возникла ошибка, скажем, в позиции 3.

185
00:11:48,400 --> 00:11:52,620
Ну, это влияет на первую группу четности, а также влияет на вторую группу

186
00:11:52,620 --> 00:11:56,340
четности, поэтому получатель знает, что где-то в этом правом столбце есть ошибка.

187
00:11:56,340 --> 00:12:01,380
Но это не влияет на третью группу и не влияет на четвертую группу.

188
00:12:01,380 --> 00:12:05,460
И это позволяет получателю точно определить ошибку до первой строки,

189
00:12:05,460 --> 00:12:08,660
что обязательно означает позицию 3, чтобы они могли исправить ошибку.

190
00:12:08,660 --> 00:12:12,640
Возможно, вам понравится потратить время на то, чтобы убедить себя в том, что ответы на эти

191
00:12:12,680 --> 00:12:17,320
четыре вопроса действительно всегда позволят вам определить конкретное место, независимо от того, где оно окажется.

192
00:12:17,320 --> 00:12:22,640
На самом деле, самые проницательные из вас могут даже

193
00:12:22,640 --> 00:12:23,640
заметить связь между этими вопросами и двоичным счетом.

194
00:12:23,640 --> 00:12:27,840
А если да, то еще раз позвольте мне подчеркнуть, сделать

195
00:12:27,840 --> 00:12:30,880
паузу, попытаться самому уловить связь, прежде чем я ее испорчу.

196
00:12:30,880 --> 00:12:35,560
Если вам интересно, что произойдет, если будет затронут

197
00:12:35,560 --> 00:12:36,560
сам бит четности, вы можете просто попробовать.

198
00:12:36,560 --> 00:12:40,720
Найдите минутку и подумайте, как можно отследить любую ошибку среди этих четырех специальных битов,

199
00:12:40,720 --> 00:12:47,440
как и любую другую, с помощью одной и той же группы из четырех вопросов.

200
00:12:47,440 --> 00:12:50,500
На самом деле это не имеет значения, поскольку, в конце концов,

201
00:12:50,500 --> 00:12:53,640
мы хотим защитить биты сообщения, а биты исправления ошибок просто продолжаются.

202
00:12:53,640 --> 00:12:57,120
Но защита и этих частей также является чем-то, что

203
00:12:57,120 --> 00:12:59,260
естественным образом выпадает из схемы как побочный продукт.

204
00:12:59,260 --> 00:13:02,380
Вам также может понравиться предвидеть, как это масштабируется.

205
00:13:02,380 --> 00:13:08,040
Если бы мы использовали блок размером 256 бит, например, чтобы определить местоположение, вам нужно

206
00:13:08,040 --> 00:13:15,680
всего восемь вопросов «да» или «нет» для двоичного поиска пути к определенному месту.

207
00:13:15,680 --> 00:13:19,680
И помните, каждый вопрос требует отказа только от

208
00:13:19,680 --> 00:13:23,340
одного бита, чтобы установить соответствующую проверку четности.

209
00:13:23,340 --> 00:13:26,960
Некоторые из вас, возможно, уже видели это, но позже мы поговорим о

210
00:13:26,960 --> 00:13:29,960
систематическом способе узнать, что это за вопросы, всего за минуту или две.

211
00:13:29,960 --> 00:13:33,440
Надеюсь, этого эскиза будет достаточно, чтобы оценить

212
00:13:33,440 --> 00:13:34,440
эффективность того, что мы здесь разрабатываем.

213
00:13:34,440 --> 00:13:38,440
Первое, за исключением этих восьми выделенных битов четности, может быть любым,

214
00:13:38,440 --> 00:13:41,720
каким вы хотите, неся любое сообщение или данные, которые вы хотите.

215
00:13:41,720 --> 00:13:45,480
8 бит избыточны в том смысле, что они полностью определяются остальной частью

216
00:13:45,480 --> 00:13:53,640
сообщения, но это гораздо более разумный способ, чем простое копирование сообщения целиком.

217
00:13:53,640 --> 00:13:58,000
И все же, приложив так мало усилий, вы сможете

218
00:13:58,000 --> 00:13:59,000
выявить и исправить любую ошибку в один бит.

219
00:13:59,000 --> 00:14:00,400
Ну, почти.

220
00:14:00,400 --> 00:14:05,920
Итак, единственная проблема здесь заключается в том, что если ни одна из четырех

221
00:14:05,920 --> 00:14:10,240
проверок четности не обнаруживает ошибку, а это означает, что все специально выбранные подмножества

222
00:14:10,240 --> 00:14:15,520
8 бит имеют четность, как и предполагал отправитель, то это либо означает, что

223
00:14:15,520 --> 00:14:17,760
ошибки вообще не было. , или это сузит нас до позиции 0.

224
00:14:17,760 --> 00:14:23,040
Видите ли, с четырьмя вопросами «да» или «нет» у нас есть 16 возможных результатов для

225
00:14:23,040 --> 00:14:28,000
наших проверок на четность, и поначалу это кажется идеальным для точного определения 1 из

226
00:14:28,000 --> 00:14:33,000
16 позиций в блоке, но вам также необходимо сообщить 17-й результат, отсутствие ошибки. состояние.

227
00:14:33,000 --> 00:14:37,860
Решение здесь на самом деле довольно простое: просто забудьте полностью об этом 0-м бите.

228
00:14:37,860 --> 00:14:41,920
Поэтому, когда мы выполняем четыре проверки четности и видим, что

229
00:14:41,920 --> 00:14:44,320
все они четные, это однозначно означает, что ошибки нет.

230
00:14:44,320 --> 00:14:49,240
Это означает, что вместо работы с 16-битным блоком мы работаем с 15-битным блоком, где

231
00:14:49,240 --> 00:14:54,040
11 бит свободны для передачи сообщения, а 4 из них предназначены для избыточности.

232
00:14:54,080 --> 00:14:58,400
И теперь у нас есть то, что

233
00:14:58,400 --> 00:14:59,400
люди в бизнесе называют кодом Хэмминга 15-11.

234
00:14:59,400 --> 00:15:03,920
Тем не менее, приятно иметь размер блока, равный чистой степени 2, и есть умный

235
00:15:03,920 --> 00:15:08,880
способ сохранить этот 0-й бит и заставить его выполнять за нас небольшую дополнительную работу.

236
00:15:08,880 --> 00:15:13,600
Если мы используем его в качестве бита четности во всем блоке, это

237
00:15:13,600 --> 00:15:16,320
позволяет нам обнаруживать 2-битные ошибки, даже если мы не можем их исправить.

238
00:15:16,320 --> 00:15:17,440
Вот как это работает.

239
00:15:17,440 --> 00:15:21,740
После установки этих четырех специальных битов, исправляющих ошибки, мы устанавливаем этот 0-й

240
00:15:21,740 --> 00:15:25,540
бит, чтобы четность всего блока была четной, как при обычной проверке четности.

241
00:15:25,540 --> 00:15:29,780
Теперь, если есть ошибка в один бит, то четность полного блока переключается на

242
00:15:29,780 --> 00:15:33,940
нечетную, но мы все равно уловим это благодаря четырем проверкам, исправляющим ошибки.

243
00:15:33,940 --> 00:15:38,100
Однако, если есть две ошибки, то общая четность снова станет четной,

244
00:15:38,100 --> 00:15:42,660
но получатель все равно увидит, что произошла хотя бы какая-то

245
00:15:42,660 --> 00:15:45,820
ошибка из-за того, что происходит с этими четырьмя проверками четности.

246
00:15:45,820 --> 00:15:49,780
Поэтому, если они заметят в целом четность, но с другими проверками происходит

247
00:15:49,820 --> 00:15:52,980
что-то ненулевое, это говорит им, что было как минимум две ошибки.

248
00:15:52,980 --> 00:15:54,420
Разве это не умно?

249
00:15:54,420 --> 00:15:58,500
Несмотря на то, что мы не можем исправить эти 2-битные ошибки, просто

250
00:15:58,500 --> 00:16:02,340
вернув в работу этот маленький надоедливый 0-й бит, мы сможем их обнаружить.

251
00:16:02,340 --> 00:16:06,540
Это довольно стандартный код, известный как расширенный код Хэмминга.

252
00:16:06,540 --> 00:16:10,860
Технически говоря, теперь у вас есть полное описание того, что

253
00:16:10,860 --> 00:16:13,580
делает код Хэмминга, по крайней мере, на примере 16-битного блока.

254
00:16:13,580 --> 00:16:17,300
Но я думаю, вам будет приятнее проверить свое понимание и закрепить все

255
00:16:17,300 --> 00:16:21,980
до этого момента, выполнив один полный пример от начала до конца самостоятельно.

256
00:16:21,980 --> 00:16:25,100
Я пройду через это вместе с вами, чтобы вы могли проверить себя.

257
00:16:25,100 --> 00:16:29,180
Чтобы настроить сообщение, будь то буквальное сообщение, которое вы транслируете

258
00:16:29,180 --> 00:16:34,100
в пространстве, или какие-то данные, которые вы хотите сохранить во

259
00:16:34,100 --> 00:16:35,700
времени, первым шагом является разделение его на 11-битные фрагменты.

260
00:16:35,700 --> 00:16:40,340
Каждый фрагмент будет упакован в устойчивый к ошибкам 16-битный блок.

261
00:16:40,340 --> 00:16:43,740
Итак, давайте возьмем это в качестве примера и на самом деле разберемся.

262
00:16:43,740 --> 00:16:45,340
Давай, действительно сделай это!

263
00:16:45,380 --> 00:16:47,380
Давайте остановимся и попробуем собрать этот блок.

264
00:16:52,980 --> 00:16:53,980
Хорошо, ты готов?

265
00:16:53,980 --> 00:16:58,500
Помните, что позиция 0 вместе с другими степенями двойки зарезервирована для исправления ошибок,

266
00:16:58,500 --> 00:17:05,700
поэтому вы начинаете с размещения битов сообщения во всех оставшихся позициях по порядку.

267
00:17:05,700 --> 00:17:09,700
Вам нужно, чтобы эта группа имела четную четность, которая уже есть, поэтому

268
00:17:09,700 --> 00:17:13,140
вам следует установить этот бит четности в позиции 1 равным 0.

269
00:17:13,140 --> 00:17:17,700
Следующая группа начинается с нечетной четности, поэтому вам

270
00:17:17,700 --> 00:17:19,260
следует установить ее бит четности равным 1.

271
00:17:19,260 --> 00:17:23,740
Следующая группа начинается с нечетной четности, поэтому вам

272
00:17:23,740 --> 00:17:24,740
снова следует установить ее бит четности на 1.

273
00:17:24,740 --> 00:17:29,500
И последняя группа также имеет нечетную четность, то есть

274
00:17:29,500 --> 00:17:31,500
мы устанавливаем этот бит в позиции 8 равным 1.

275
00:17:31,500 --> 00:17:36,460
И затем, в качестве последнего шага, полный блок теперь имеет четность, что означает, что

276
00:17:36,460 --> 00:17:41,500
вы можете установить этот бит с номером 0, общий бит четности, равным 0.

277
00:17:41,500 --> 00:17:45,660
Таким образом, при отправке этого блока четность четырех специальных подмножеств

278
00:17:45,660 --> 00:17:48,980
и блока в целом будет четной или равной 0.

279
00:17:48,980 --> 00:17:53,620
Во второй части упражнения давайте попросим вас сыграть роль получателя.

280
00:17:53,620 --> 00:17:57,580
Конечно, это будет означать, что вы еще не знаете, что это за сообщение, возможно,

281
00:17:57,580 --> 00:18:00,180
некоторые из вас его запомнили, но давайте предположим, что вы этого не сделали.

282
00:18:00,180 --> 00:18:05,820
Что я собираюсь сделать, так это изменить 0, 1 или 2 бита

283
00:18:05,820 --> 00:18:08,340
в этом блоке, а затем попросить вас выяснить, что именно я сделал.

284
00:18:08,340 --> 00:18:13,460
Итак, еще раз сделайте паузу и попробуйте разобраться.

285
00:18:13,460 --> 00:18:23,960
Хорошо, теперь вы, как получатель, проверяете первую группу четности и видите, что

286
00:18:23,960 --> 00:18:29,820
она четная, поэтому любая существующая ошибка должна быть в четном столбце.

287
00:18:29,820 --> 00:18:34,620
Следующая проверка дает нам нечетное число, сообщающее нам обоим, что есть по

288
00:18:34,620 --> 00:18:38,760
крайней мере одна ошибка, и сужающее нас до этого конкретного столбца.

289
00:18:38,760 --> 00:18:42,900
Третья проверка четная, еще больше сокращая возможности.

290
00:18:42,900 --> 00:18:46,780
И последняя проверка четности является нечетной и говорит нам, что где-то внизу есть

291
00:18:46,780 --> 00:18:51,700
ошибка, которая, как мы теперь видим, должна быть на позиции номер 10.

292
00:18:51,700 --> 00:18:56,140
Более того, четность всего блока нечетная, что дает нам уверенность

293
00:18:56,140 --> 00:18:58,220
в том, что был один флип, а не два.

294
00:18:58,220 --> 00:19:01,600
Если их три или больше, все ставки аннулируются.

295
00:19:01,600 --> 00:19:06,520
После исправления этого бита номер 10 извлечение 11 бит, которые не использовались

296
00:19:06,520 --> 00:19:11,620
для исправления, дает нам соответствующий сегмент исходного сообщения, который, если перемотать назад

297
00:19:11,620 --> 00:19:16,160
и сравнить, действительно является именно тем, с чего мы начали пример.

298
00:19:16,160 --> 00:19:19,260
И теперь, когда вы знаете, как делать все это вручную, я хотел бы показать вам,

299
00:19:19,260 --> 00:19:23,940
как можно реализовать основную часть всей этой логики с помощью одной строки кода Python.

300
00:19:23,940 --> 00:19:28,400
Видите ли, я еще не рассказал вам, насколько на самом деле

301
00:19:28,400 --> 00:19:32,380
элегантен этот алгоритм, насколько просто заставить машину указывать на положение

302
00:19:32,380 --> 00:19:37,680
ошибки, как ее систематически масштабировать и как мы можем сформулировать все

303
00:19:37,680 --> 00:19:39,580
это как одна операция, а не несколько отдельных проверок четности.

304
00:19:39,580 --> 00:19:41,680
Чтобы понять, что я имею в виду, присоединяйтесь ко мне во второй части.

