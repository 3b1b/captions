1
00:00:00,000 --> 00:00:05,576
Bạn đã bao giờ tự hỏi làm thế nào có thể làm xước một đĩa CD hoặc

2
00:00:05,576 --> 00:00:10,900
DVD mà vẫn có thể phát lại bất cứ thứ gì nó đang lưu trữ không?

3
00:00:10,900 --> 00:00:14,133
Vết xước thực sự ảnh hưởng đến số 1 và 0 trên đĩa,

4
00:00:14,133 --> 00:00:17,494
do đó nó đọc dữ liệu khác với những gì được lưu trữ,

5
00:00:17,494 --> 00:00:21,932
nhưng trừ khi nó thực sự bị trầy xước, các bit mà nó đọc được sẽ được

6
00:00:21,932 --> 00:00:26,561
giải mã thành cùng một tệp được mã hóa trên đó, một bit để sao chép bit,

7
00:00:26,561 --> 00:00:28,400
bất chấp tất cả những lỗi đó.

8
00:00:28,400 --> 00:00:32,647
Có rất nhiều sự thông minh về toán học cho phép chúng ta lưu trữ dữ liệu và

9
00:00:32,647 --> 00:00:36,840
quan trọng không kém là truyền dữ liệu theo cách có khả năng chống lại lỗi.

10
00:00:36,840 --> 00:00:42,480
Được rồi, thực ra không cần quá thông minh để nghĩ ra cách thực hiện việc này.

11
00:00:42,480 --> 00:00:46,374
Bất kỳ tập tin nào, cho dù đó là video, âm thanh hay văn bản,

12
00:00:46,374 --> 00:00:50,960
một số mã, hình ảnh, bất cứ thứ gì, cuối cùng đều là một chuỗi số 1 và 0.

13
00:00:50,960 --> 00:00:54,515
Và một chiến lược đơn giản để sửa bất kỳ bit nào

14
00:00:54,515 --> 00:00:57,780
bị đảo lộn là lưu trữ ba bản sao của mỗi bit.

15
00:00:57,780 --> 00:01:02,407
Sau đó, máy đọc tệp này có thể so sánh ba bản sao này và

16
00:01:02,407 --> 00:01:07,440
luôn lấy 2 trên 3 bản tốt nhất bất cứ khi nào có sự khác biệt.

17
00:01:07,440 --> 00:01:11,560
Nhưng điều đó có nghĩa là sử dụng 2/3 dung lượng của bạn để dự phòng.

18
00:01:11,560 --> 00:01:14,128
Và thậm chí sau đó, đối với tất cả không gian bị bỏ đi,

19
00:01:14,128 --> 00:01:18,120
không có gì đảm bảo chắc chắn về điều gì sẽ xảy ra nếu có nhiều hơn một bit bị đảo lộn.

20
00:01:18,120 --> 00:01:21,430
Câu hỏi thú vị hơn nhiều là làm thế nào để có thể

21
00:01:21,430 --> 00:01:24,740
sửa lỗi trong khi chiếm ít không gian nhất có thể.

22
00:01:24,740 --> 00:01:28,146
Ví dụ: bằng cách sử dụng phương pháp bạn sẽ tìm hiểu về video này,

23
00:01:28,146 --> 00:01:31,196
bạn có thể lưu trữ dữ liệu của mình trong các khối 256 bit,

24
00:01:31,196 --> 00:01:32,975
trong đó mỗi khối sử dụng 9 bit, 9!

25
00:01:32,975 --> 00:01:36,923
hoạt động như một loại dự phòng và 247 bit còn lại có thể tự

26
00:01:36,923 --> 00:01:41,000
do mang bất kỳ thông điệp hoặc dữ liệu có ý nghĩa nào bạn muốn.

27
00:01:41,000 --> 00:01:44,830
Và vẫn sẽ xảy ra trường hợp nếu bất kỳ bit nào bị đảo lộn ở đây,

28
00:01:44,830 --> 00:01:47,659
chỉ cần nhìn vào khối này và không cần gì thêm,

29
00:01:47,659 --> 00:01:51,607
máy sẽ có thể xác định rằng đã có lỗi và xác định chính xác lỗi đó

30
00:01:51,607 --> 00:01:53,140
ở đâu để nó biết cách sửa.

31
00:01:53,140 --> 00:01:55,540
Và thành thật mà nói, điều đó giống như một phép thuật.

32
00:01:55,540 --> 00:01:58,351
Và đối với sơ đồ cụ thể này, nếu hai bit bị đảo lộn,

33
00:01:58,351 --> 00:02:01,110
máy ít nhất sẽ có thể phát hiện ra rằng có hai lỗi,

34
00:02:01,110 --> 00:02:03,180
mặc dù nó sẽ không biết cách sửa chúng.

35
00:02:03,180 --> 00:02:05,710
Chúng ta sẽ nói một lát sau về cách điều chỉnh tỷ

36
00:02:05,710 --> 00:02:08,140
lệ này đối với các khối có kích thước khác nhau.

37
00:02:08,140 --> 00:02:11,065
Các phương pháp cho phép bạn sửa các lỗi như thế này

38
00:02:11,065 --> 00:02:13,880
được biết đến một cách hợp lý dưới dạng mã sửa lỗi.

39
00:02:13,880 --> 00:02:18,410
Trong phần lớn thế kỷ trước, lĩnh vực này thực sự là một nguồn toán học sâu

40
00:02:18,410 --> 00:02:23,000
sắc đáng kinh ngạc được tích hợp vào các thiết bị chúng ta sử dụng hàng ngày.

41
00:02:23,000 --> 00:02:28,080
Mục tiêu ở đây là giúp bạn hiểu rất kỹ về một trong những ví dụ sớm nhất,

42
00:02:28,080 --> 00:02:29,660
được gọi là mã Hamming.

43
00:02:29,660 --> 00:02:33,262
Và nhân tiện, cách tôi nghĩ về cấu trúc của video này không phải là giải

44
00:02:33,262 --> 00:02:36,716
thích nó một cách trực tiếp nhất có thể mà quan trọng hơn là thúc đẩy

45
00:02:36,716 --> 00:02:40,220
bạn tự sáng tạo ra nó với một chút hướng dẫn nhẹ nhàng chỗ này chỗ kia.

46
00:02:40,220 --> 00:02:43,197
Vì vậy, khi bạn cảm thấy mình biết mọi chuyện sẽ đi đến đâu vào một thời điểm nào đó,

47
00:02:43,197 --> 00:02:45,587
hãy dành thời gian đó để tạm dừng, chủ động dự đoán kế hoạch sẽ diễn

48
00:02:45,587 --> 00:02:47,180
ra như thế nào trước khi tôi nói cho bạn biết.

49
00:02:47,180 --> 00:02:50,723
Ngoài ra, nếu bạn muốn hiểu sâu hơn ở cấp độ phần cứng,

50
00:02:50,723 --> 00:02:54,710
Ben Eater đã tạo một video kết hợp với video này hướng dẫn bạn

51
00:02:54,710 --> 00:02:59,520
cách thực sự triển khai mã Hamming trên bảng mạch, điều này cực kỳ thỏa mãn.

52
00:02:59,520 --> 00:03:03,695
Bạn nên biết, mã Hamming không được sử dụng rộng rãi như các mã hiện đại hơn,

53
00:03:03,695 --> 00:03:07,227
như thuật toán Reed-Solomon, nhưng có một điều kỳ diệu nào đó đối

54
00:03:07,227 --> 00:03:10,974
với sự tương phản giữa việc nhiệm vụ này có cảm giác bất khả thi ngay

55
00:03:10,974 --> 00:03:14,240
từ đầu và nó có vẻ hoàn toàn hợp lý. bạn tìm hiểu về Hamming.

56
00:03:14,240 --> 00:03:18,496
Nguyên tắc cơ bản của việc sửa lỗi là trong một không gian rộng lớn gồm tất cả

57
00:03:18,496 --> 00:03:22,860
các thông báo có thể có, chỉ một số tập hợp con được coi là các thông báo hợp lệ.

58
00:03:22,860 --> 00:03:29,100
Tương tự, hãy nghĩ về những từ viết đúng chính tả và những từ viết sai chính tả.

59
00:03:29,100 --> 00:03:31,574
Bất cứ khi nào một tin nhắn hợp lệ bị thay đổi,

60
00:03:31,574 --> 00:03:36,008
người nhận có trách nhiệm sửa lại những gì họ nhìn thấy cho người hàng xóm hợp lệ gần

61
00:03:36,008 --> 00:03:38,380
nhất, như bạn có thể làm với một lỗi đánh máy.

62
00:03:38,380 --> 00:03:42,877
Tuy nhiên, việc đưa ra một thuật toán cụ thể để phân loại hiệu

63
00:03:42,877 --> 00:03:47,160
quả các tin nhắn như thế này cần có sự thông minh nhất định.

64
00:03:47,160 --> 00:03:50,565
Câu chuyện bắt đầu vào những năm 1940, khi chàng trai trẻ Richard Hamming đang

65
00:03:50,565 --> 00:03:53,971
làm việc cho Bell Labs, và một số công việc của anh liên quan đến việc sử dụng

66
00:03:53,971 --> 00:03:57,420
một chiếc máy tính thẻ đục lỗ rất đắt tiền mà anh chỉ có quyền truy cập hạn chế.

67
00:03:57,420 --> 00:04:00,680
Và các chương trình mà anh ấy thực hiện liên tục bị lỗi,

68
00:04:00,680 --> 00:04:03,140
bởi vì thỉnh thoảng có một chút bị đọc sai.

69
00:04:03,140 --> 00:04:06,129
Sự thất vọng là lò thử thách của phát minh, anh ta chán

70
00:04:06,129 --> 00:04:09,280
nản đến mức phát minh ra mã sửa lỗi đầu tiên trên thế giới.

71
00:04:09,280 --> 00:04:11,998
Có nhiều cách khác nhau để đóng khung mã Hamming,

72
00:04:11,998 --> 00:04:16,620
nhưng bước đầu tiên chúng ta sẽ tìm hiểu nó theo cách mà chính Hamming nghĩ về chúng.

73
00:04:16,620 --> 00:04:21,400
Hãy sử dụng một ví dụ đơn giản nhưng không quá đơn giản, một khối 16 bit.

74
00:04:21,400 --> 00:04:25,700
Chúng ta sẽ đánh số vị trí của các bit này từ 0 đến 15.

75
00:04:25,700 --> 00:04:30,397
Dữ liệu thực tế mà chúng tôi muốn lưu trữ sẽ chỉ chiếm 12 bit trong số này,

76
00:04:30,397 --> 00:04:33,920
trong khi 4 vị trí được dành riêng như một loại dự phòng.

77
00:04:33,920 --> 00:04:36,275
Từ dư thừa ở đây không đơn giản có nghĩa là sao chép,

78
00:04:36,275 --> 00:04:40,200
xét cho cùng thì 4 bit đó không cho chúng ta đủ chỗ để sao chép dữ liệu một cách mù quáng.

79
00:04:40,200 --> 00:04:45,162
Thay vào đó, chúng sẽ cần phải là một loại dự phòng thông minh và sắc thái hơn nhiều,

80
00:04:45,162 --> 00:04:48,740
không thêm bất kỳ thông tin mới nào mà thêm khả năng phục hồi.

81
00:04:48,740 --> 00:04:52,346
Bạn có thể mong đợi 4 bit đặc biệt này được kết hợp chặt chẽ với nhau,

82
00:04:52,346 --> 00:04:55,495
có thể ở cuối hoặc thứ gì đó tương tự, nhưng như bạn sẽ thấy,

83
00:04:55,495 --> 00:04:59,304
việc đặt chúng ở các vị trí có lũy thừa bằng 2 sẽ tạo ra thứ gì đó thực sự

84
00:04:59,304 --> 00:05:00,320
thanh lịch vào cuối.

85
00:05:00,320 --> 00:05:05,420
Nó cũng có thể cung cấp cho bạn một gợi ý nhỏ về cách tỷ lệ này đối với các khối lớn hơn.

86
00:05:05,420 --> 00:05:08,410
Ngoài ra, về mặt kỹ thuật, nó chỉ có 11 bit dữ liệu,

87
00:05:08,410 --> 00:05:12,079
bạn sẽ thấy có một sắc thái nhẹ cho những gì diễn ra ở vị trí 0,

88
00:05:12,079 --> 00:05:14,280
nhưng hiện tại đừng lo lắng về điều đó.

89
00:05:14,280 --> 00:05:19,004
Giống như bất kỳ thuật toán sửa lỗi nào, điều này sẽ có sự tham gia của hai người chơi,

90
00:05:19,004 --> 00:05:22,923
một người gửi chịu trách nhiệm thiết lập 4 bit đặc biệt này và một người

91
00:05:22,923 --> 00:05:26,360
nhận chịu trách nhiệm thực hiện một số loại kiểm tra và sửa lỗi.

92
00:05:26,360 --> 00:05:29,334
Tất nhiên, từ người gửi và người nhận thực sự đề cập đến máy

93
00:05:29,334 --> 00:05:32,456
móc hoặc phần mềm thực hiện tất cả các bước kiểm tra và ý tưởng

94
00:05:32,456 --> 00:05:35,480
về tin nhắn được hiểu rất rộng, bao gồm những thứ như lưu trữ.

95
00:05:35,480 --> 00:05:39,060
Xét cho cùng, việc lưu trữ dữ liệu cũng giống như gửi một tin

96
00:05:39,060 --> 00:05:42,640
nhắn từ quá khứ đến tương lai thay vì từ nơi này đến nơi khác.

97
00:05:42,640 --> 00:05:46,279
Đó là thiết lập, nhưng trước khi đi sâu vào chúng ta cần nói về một ý

98
00:05:46,279 --> 00:05:50,073
tưởng liên quan mới mẻ trong đầu Hamming vào thời điểm ông phát hiện ra,

99
00:05:50,073 --> 00:05:54,284
một phương pháp cho phép bạn phát hiện bất kỳ lỗi bit nào nhưng không sửa chúng,

100
00:05:54,284 --> 00:05:57,300
đã biết trong kinh doanh như một sự kiểm tra tính chẵn lẻ.

101
00:05:57,300 --> 00:06:01,145
Để kiểm tra tính chẵn lẻ, chúng tôi chỉ tách ra một bit duy nhất mà người

102
00:06:01,145 --> 00:06:04,940
gửi chịu trách nhiệm điều chỉnh và phần còn lại được tự do mang tin nhắn.

103
00:06:04,940 --> 00:06:08,482
Công việc duy nhất của bit đặc biệt này là đảm

104
00:06:08,482 --> 00:06:12,100
bảo rằng tổng số số 1 trong tin nhắn là số chẵn.

105
00:06:12,100 --> 00:06:15,404
Vì vậy, ví dụ ngay bây giờ, tổng số 1 đó là 7,

106
00:06:15,404 --> 00:06:20,960
là số lẻ nên người gửi cần lật bit đặc biệt đó thành 1, làm cho số đếm là chẵn.

107
00:06:20,960 --> 00:06:27,480
Nhưng nếu khối đã bắt đầu với số chẵn là 1 thì bit đặc biệt này sẽ được giữ ở mức 0.

108
00:06:27,480 --> 00:06:30,796
Điều này khá đơn giản, có vẻ đơn giản, nhưng đó là một cách

109
00:06:30,796 --> 00:06:34,278
cực kỳ tinh tế để chắt lọc ý tưởng về sự thay đổi ở bất kỳ đâu

110
00:06:34,278 --> 00:06:37,760
trong thông điệp để được phản ánh trong một thông tin duy nhất.

111
00:06:37,760 --> 00:06:42,382
Lưu ý nếu bất kỳ bit nào của thông báo này bị đảo ngược,

112
00:06:42,382 --> 00:06:48,140
từ 0 thành 1 hoặc 1 thành 0, nó sẽ thay đổi tổng số 1 từ chẵn thành lẻ.

113
00:06:48,140 --> 00:06:52,867
Vì vậy, nếu bạn là người nhận, bạn nhìn vào tin nhắn này và thấy số lẻ là 1,

114
00:06:52,867 --> 00:06:56,121
bạn có thể biết chắc chắn rằng đã xảy ra lỗi nào đó,

115
00:06:56,121 --> 00:06:58,700
mặc dù bạn có thể không biết lỗi đó ở đâu.

116
00:06:58,700 --> 00:07:04,940
Trong thuật ngữ, việc một nhóm bit có số 1 chẵn hay lẻ được gọi là tính chẵn lẻ của nó.

117
00:07:04,940 --> 00:07:08,059
Bạn cũng có thể sử dụng các con số và nói số chẵn lẻ là 0 hoặc 1,

118
00:07:08,059 --> 00:07:11,320
điều này thường hữu ích hơn khi bạn bắt đầu làm toán với ý tưởng này.

119
00:07:11,320 --> 00:07:14,927
Và bit đặc biệt này mà người gửi sử dụng để kiểm

120
00:07:14,927 --> 00:07:18,020
soát tính chẵn lẻ được gọi là bit chẵn lẻ.

121
00:07:18,020 --> 00:07:21,851
Và trên thực tế, chúng ta nên nói rõ, nếu người nhận nhìn thấy một số chẵn lẻ lẻ,

122
00:07:21,851 --> 00:07:25,121
điều đó không nhất thiết có nghĩa là chỉ có một lỗi, có thể có 3 lỗi,

123
00:07:25,121 --> 00:07:28,438
hoặc 5 lỗi hoặc bất kỳ số lẻ nào khác, nhưng họ có thể biết chắc chắn.

124
00:07:28,438 --> 00:07:29,560
rằng nó không phải là 0.

125
00:07:29,560 --> 00:07:35,773
Mặt khác, nếu có 2 lỗi hoặc bất kỳ số lỗi chẵn nào thì số 1 cuối cùng vẫn là số chẵn,

126
00:07:35,773 --> 00:07:40,469
do đó người nhận không thể hoàn toàn tin tưởng rằng số chẵn nhất

127
00:07:40,469 --> 00:07:43,360
thiết có nghĩa là tin nhắn không có lỗi.

128
00:07:43,360 --> 00:07:46,496
Bạn có thể phàn nàn rằng một tin nhắn bị lộn xộn

129
00:07:46,496 --> 00:07:49,760
chỉ sau 2 lần lật là khá yếu và bạn hoàn toàn đúng.

130
00:07:49,760 --> 00:07:54,674
Tuy nhiên, hãy nhớ rằng không có phương pháp phát hiện hoặc sửa lỗi nào có

131
00:07:54,674 --> 00:07:59,720
thể giúp bạn tin cậy 100% rằng thư bạn nhận được là thư mà người gửi dự định.

132
00:07:59,720 --> 00:08:02,773
Rốt cuộc, tiếng ồn ngẫu nhiên đủ lớn luôn có thể thay đổi một tin

133
00:08:02,773 --> 00:08:05,920
nhắn hợp lệ thành một tin nhắn hợp lệ khác chỉ hoàn toàn là tình cờ.

134
00:08:05,920 --> 00:08:11,200
Thay vào đó, mục tiêu là đưa ra một sơ đồ mạnh mẽ với số lỗi tối đa nhất

135
00:08:11,200 --> 00:08:16,480
định hoặc có thể giảm xác suất xảy ra kết quả dương tính giả như thế này.

136
00:08:16,480 --> 00:08:20,150
Bản thân việc kiểm tra tính chẵn lẻ khá yếu, nhưng bằng cách chắt lọc ý

137
00:08:20,150 --> 00:08:23,106
tưởng thay đổi toàn bộ thông điệp thành một bit duy nhất,

138
00:08:23,106 --> 00:08:26,878
những gì chúng mang lại cho chúng ta là một khối xây dựng mạnh mẽ cho các

139
00:08:26,878 --> 00:08:28,000
kế hoạch phức tạp hơn.

140
00:08:28,000 --> 00:08:32,751
Ví dụ, khi Hamming đang tìm cách xác định lỗi đã xảy ra ở đâu, không chỉ lỗi xảy ra,

141
00:08:32,751 --> 00:08:37,503
hiểu biết sâu sắc quan trọng của ông là nếu bạn áp dụng một số kiểm tra tính chẵn lẻ

142
00:08:37,503 --> 00:08:41,920
không phải cho toàn bộ thông báo mà cho một số tập hợp con được chọn cẩn thận,

143
00:08:41,920 --> 00:08:46,840
bạn có thể hỏi một loạt câu hỏi tinh tế hơn nhằm xác định vị trí của bất kỳ lỗi bit nào.

144
00:08:46,840 --> 00:08:50,600
Cảm giác tổng thể giống như chơi một trò chơi gồm 20 câu hỏi,

145
00:08:50,600 --> 00:08:54,300
đặt các câu hỏi có hoặc không để cắt đôi không gian khả năng.

146
00:08:54,300 --> 00:08:58,514
Ví dụ: giả sử chúng tôi thực hiện kiểm tra tính chẵn lẻ chỉ trên 8 bit này,

147
00:08:58,514 --> 00:09:00,400
tất cả các vị trí được đánh số lẻ.

148
00:09:00,400 --> 00:09:04,715
Sau đó, nếu phát hiện thấy lỗi, nó sẽ cung cấp cho người nhận thêm

149
00:09:04,715 --> 00:09:09,160
một chút thông tin về lỗi cụ thể ở đâu, cụ thể là lỗi ở vị trí kỳ lạ.

150
00:09:09,160 --> 00:09:12,720
Nếu không phát hiện thấy lỗi nào trong số 8 bit đó,

151
00:09:12,720 --> 00:09:17,240
điều đó có nghĩa là không có lỗi nào cả hoặc nó nằm ở vị trí chẵn.

152
00:09:17,240 --> 00:09:20,325
Bạn có thể nghĩ rằng việc giới hạn kiểm tra tính chẵn lẻ ở mức một

153
00:09:20,325 --> 00:09:23,503
nửa số bit sẽ khiến nó kém hiệu quả hơn, nhưng khi nó được thực hiện

154
00:09:23,503 --> 00:09:25,851
cùng với các kiểm tra được lựa chọn kỹ lưỡng khác,

155
00:09:25,851 --> 00:09:29,720
nó sẽ mang lại cho chúng ta thứ gì đó mạnh mẽ hơn rất nhiều một cách phản trực giác.

156
00:09:29,720 --> 00:09:32,910
Để thực sự thiết lập việc kiểm tra tính chẵn lẻ đó, hãy nhớ rằng,

157
00:09:32,910 --> 00:09:36,826
nó đòi hỏi phải đánh dấu một số bit đặc biệt có quyền kiểm soát tính chẵn lẻ của

158
00:09:36,826 --> 00:09:37,600
toàn bộ nhóm đó.

159
00:09:37,600 --> 00:09:39,920
Ở đây chúng ta hãy chọn vị trí 1.

160
00:09:39,920 --> 00:09:43,771
Đối với ví dụ được hiển thị, tính chẵn lẻ của 8 bit này hiện là số lẻ,

161
00:09:43,771 --> 00:09:48,220
do đó người gửi có trách nhiệm chuyển đổi bit chẵn lẻ đó và bây giờ nó là số chẵn.

162
00:09:48,220 --> 00:09:51,040
Đây chỉ là 1 trong 4 lần kiểm tra tính chẵn lẻ mà chúng tôi sẽ thực hiện.

163
00:09:51,040 --> 00:09:54,675
Kiểm tra thứ hai nằm trong số 8 bit ở nửa bên phải của lưới,

164
00:09:54,675 --> 00:09:56,880
ít nhất là như chúng tôi đã vẽ ở đây.

165
00:09:56,880 --> 00:10:00,560
Lần này chúng ta có thể sử dụng vị trí 2 làm bit chẵn lẻ,

166
00:10:00,560 --> 00:10:05,700
vì vậy 8 bit này đã có giá trị chẵn lẻ và người gửi có thể cảm thấy hài lòng khi

167
00:10:05,700 --> 00:10:07,160
giữ nguyên bit số 2 đó.

168
00:10:07,160 --> 00:10:11,419
Sau đó, ở đầu bên kia, nếu người nhận kiểm tra tính chẵn lẻ của nhóm này và

169
00:10:11,419 --> 00:10:15,960
thấy rằng nó kỳ lạ, họ sẽ biết rằng lỗi nằm ở đâu đó trong số 8 bit bên phải này.

170
00:10:15,960 --> 00:10:21,260
Ngược lại, điều đó có nghĩa là không có lỗi hoặc lỗi nằm ở đâu đó ở nửa bên trái.

171
00:10:21,260 --> 00:10:24,221
Hoặc tôi đoán có thể có hai lỗi, nhưng hiện tại chúng ta

172
00:10:24,221 --> 00:10:27,080
giả định rằng có nhiều nhất một lỗi trong toàn bộ khối.

173
00:10:27,080 --> 00:10:29,160
Mọi thứ bị phá vỡ hoàn toàn vì nhiều hơn thế.

174
00:10:29,160 --> 00:10:31,376
Ở đây, trước khi chúng ta xem xét hai bước kiểm tra tiếp theo,

175
00:10:31,376 --> 00:10:33,557
hãy dành chút thời gian để suy nghĩ xem hai bước kiểm tra đầu

176
00:10:33,557 --> 00:10:35,880
tiên này cho phép chúng ta làm gì khi bạn xem xét chúng cùng nhau.

177
00:10:35,880 --> 00:10:40,240
Giả sử bạn phát hiện lỗi giữa các cột lẻ và giữa nửa bên phải.

178
00:10:40,240 --> 00:10:43,940
Nó nhất thiết có nghĩa là lỗi ở đâu đó trong cột cuối cùng.

179
00:10:43,940 --> 00:10:47,096
Nếu không có lỗi ở cột lẻ nhưng có một lỗi ở nửa bên phải,

180
00:10:47,096 --> 00:10:50,520
điều đó cho bạn biết lỗi đó nằm ở cột thứ hai đến cột cuối cùng.

181
00:10:50,520 --> 00:10:54,506
Tương tự như vậy, nếu có lỗi ở cột lẻ nhưng không ở nửa bên phải,

182
00:10:54,506 --> 00:10:56,560
bạn biết lỗi đó nằm ở cột thứ hai.

183
00:10:56,560 --> 00:10:59,920
Và nếu cả hai lần kiểm tra chẵn lẻ đó đều không phát hiện ra điều gì,

184
00:10:59,920 --> 00:11:03,760
điều đó có nghĩa là nơi duy nhất có thể xảy ra lỗi là ở cột ngoài cùng bên trái.

185
00:11:03,760 --> 00:11:06,480
Nhưng nó cũng có thể đơn giản có nghĩa là không có lỗi nào cả.

186
00:11:06,480 --> 00:11:09,068
Đó hoàn toàn là một cách khá phức tạp để nói rằng hai

187
00:11:09,068 --> 00:11:11,800
lần kiểm tra tính chẵn lẻ cho phép chúng ta xác định cột.

188
00:11:11,800 --> 00:11:14,000
Từ đây có lẽ bạn có thể đoán được điều gì sẽ xảy ra tiếp theo.

189
00:11:14,000 --> 00:11:16,240
Về cơ bản chúng tôi làm điều tương tự nhưng đối với các hàng.

190
00:11:16,240 --> 00:11:21,040
Sẽ có kiểm tra tính chẵn lẻ trên các hàng lẻ, sử dụng vị trí 4 làm bit chẵn lẻ.

191
00:11:21,040 --> 00:11:24,507
Vì vậy, trong ví dụ này, nhóm đó đã có tính chẵn lẻ chẵn,

192
00:11:24,507 --> 00:11:26,480
vì vậy bit 4 sẽ được đặt thành 0.

193
00:11:26,480 --> 00:11:30,221
Và cuối cùng là kiểm tra tính chẵn lẻ ở hai hàng dưới cùng,

194
00:11:30,221 --> 00:11:32,280
sử dụng vị trí 8 làm bit chẵn lẻ.

195
00:11:32,280 --> 00:11:35,090
Trong trường hợp này, có vẻ như người gửi cần

196
00:11:35,090 --> 00:11:37,840
bật bit 8 đó để mang lại cho nhóm sự chẵn lẻ.

197
00:11:37,840 --> 00:11:40,731
Giống như hai bước kiểm tra đầu tiên cho phép chúng ta ghim cột,

198
00:11:40,731 --> 00:11:43,000
hai bước kiểm tra tiếp theo cho phép bạn ghim hàng.

199
00:11:43,000 --> 00:11:48,400
Ví dụ, hãy tưởng tượng rằng trong quá trình truyền có một lỗi ở vị trí 3.

200
00:11:48,400 --> 00:11:52,296
Chà, điều này ảnh hưởng đến nhóm chẵn lẻ đầu tiên và nó cũng ảnh hưởng đến nhóm

201
00:11:52,296 --> 00:11:56,340
chẵn lẻ thứ hai, vì vậy người nhận biết rằng có lỗi ở đâu đó trong cột bên phải đó.

202
00:11:56,340 --> 00:12:01,380
Nhưng nó không ảnh hưởng đến nhóm thứ ba, và nó không ảnh hưởng đến nhóm thứ tư.

203
00:12:01,380 --> 00:12:06,012
Và điều đó cho phép người nhận xác định chính xác lỗi cho đến hàng đầu tiên,

204
00:12:06,012 --> 00:12:08,660
nghĩa là vị trí thứ 3, để họ có thể sửa lỗi.

205
00:12:08,660 --> 00:12:12,867
Bạn có thể thích dành chút thời gian để thuyết phục bản thân rằng câu trả lời cho bốn

206
00:12:12,867 --> 00:12:16,390
câu hỏi này thực sự sẽ luôn giúp bạn xác định được một địa điểm cụ thể,

207
00:12:16,390 --> 00:12:17,320
bất kể chúng ở đâu.

208
00:12:17,320 --> 00:12:20,480
Trên thực tế, những người tinh ý trong số các bạn thậm chí có thể

209
00:12:20,480 --> 00:12:23,640
nhận thấy mối liên hệ giữa những câu hỏi này và việc đếm nhị phân.

210
00:12:23,640 --> 00:12:27,346
Và nếu bạn làm vậy, một lần nữa hãy để tôi nhấn mạnh, tạm dừng,

211
00:12:27,346 --> 00:12:30,880
cố gắng tự mình rút ra mối liên hệ trước khi tôi làm hỏng nó.

212
00:12:30,880 --> 00:12:35,458
Nếu bạn đang thắc mắc điều gì sẽ xảy ra nếu bản thân bit chẵn lẻ bị ảnh hưởng,

213
00:12:35,458 --> 00:12:36,560
thì bạn có thể thử.

214
00:12:36,560 --> 00:12:41,939
Hãy dành một chút thời gian để suy nghĩ xem làm thế nào bất kỳ lỗi nào trong số bốn phần

215
00:12:41,939 --> 00:12:45,626
đặc biệt này sẽ được theo dõi giống như bất kỳ lỗi nào khác,

216
00:12:45,626 --> 00:12:47,440
với cùng một nhóm bốn câu hỏi.

217
00:12:47,440 --> 00:12:50,493
Điều đó thực sự không quan trọng, vì cuối cùng điều chúng ta muốn

218
00:12:50,493 --> 00:12:53,640
là bảo vệ các bit thông báo, các bit sửa lỗi vẫn tiếp tục hoạt động.

219
00:12:53,640 --> 00:12:56,567
Nhưng việc bảo vệ những bit đó cũng là điều đương

220
00:12:56,567 --> 00:12:59,260
nhiên nằm ngoài kế hoạch như một sản phẩm phụ.

221
00:12:59,260 --> 00:13:02,380
Bạn cũng có thể thích dự đoán quy mô này như thế nào.

222
00:13:02,380 --> 00:13:08,260
Ví dụ: nếu chúng tôi sử dụng một khối có kích thước 256 bit để xác định một vị trí,

223
00:13:08,260 --> 00:13:12,740
bạn chỉ cần tám câu hỏi có hoặc không để tìm kiếm nhị phân theo

224
00:13:12,740 --> 00:13:15,680
cách của bạn đến một vị trí cụ thể nào đó.

225
00:13:15,680 --> 00:13:19,472
Và hãy nhớ rằng, mỗi câu hỏi chỉ yêu cầu bỏ đi một

226
00:13:19,472 --> 00:13:23,340
bit duy nhất để đặt kiểm tra tính chẵn lẻ thích hợp.

227
00:13:23,340 --> 00:13:26,607
Một số bạn có thể đã nhìn thấy nó, nhưng sau này chúng ta sẽ nói về cách có

228
00:13:26,607 --> 00:13:29,960
hệ thống để tìm ra nội dung của những câu hỏi này chỉ trong một hoặc hai phút.

229
00:13:29,960 --> 00:13:32,113
Hy vọng bản phác thảo này đủ để đánh giá cao tính

230
00:13:32,113 --> 00:13:34,440
hiệu quả của những gì chúng tôi đang phát triển ở đây.

231
00:13:34,440 --> 00:13:37,464
Điều đầu tiên, ngoại trừ tám bit chẵn lẻ được đánh dấu đó,

232
00:13:37,464 --> 00:13:41,720
có thể là bất cứ thứ gì bạn muốn, mang bất kỳ thông điệp hoặc dữ liệu nào bạn muốn.

233
00:13:41,720 --> 00:13:47,997
8 bit dư thừa theo nghĩa là chúng hoàn toàn được xác định bởi phần còn lại của tin nhắn,

234
00:13:47,997 --> 00:13:53,640
nhưng đó là cách thông minh hơn nhiều so với việc chỉ sao chép toàn bộ tin nhắn.

235
00:13:53,640 --> 00:13:59,000
Tuy nhiên, với rất ít sự từ bỏ, bạn sẽ có thể xác định và sửa bất kỳ lỗi bit nào.

236
00:13:59,000 --> 00:14:00,400
Vâng, gần như vậy.

237
00:14:00,400 --> 00:14:04,624
Được rồi, vấn đề ở đây là nếu không có kiểm tra chẵn lẻ nào trong số bốn

238
00:14:04,624 --> 00:14:09,022
kiểm tra chẵn lẻ phát hiện ra lỗi, nghĩa là các tập hợp con 8 bit được chọn

239
00:14:09,022 --> 00:14:12,783
đặc biệt đều có các số chẵn lẻ, giống như dự định của người gửi,

240
00:14:12,783 --> 00:14:17,760
thì điều đó có nghĩa là không có lỗi nào cả , hoặc nó thu hẹp chúng ta xuống vị trí 0.

241
00:14:17,760 --> 00:14:22,688
Bạn thấy đấy, với bốn câu hỏi có hoặc không, chúng tôi có 16 kết quả có thể xảy ra cho

242
00:14:22,688 --> 00:14:25,408
việc kiểm tra tính chẵn lẻ của mình và lúc đầu,

243
00:14:25,408 --> 00:14:29,090
điều đó có vẻ hoàn hảo để xác định 1 trong 16 vị trí trong khối,

244
00:14:29,090 --> 00:14:33,000
nhưng bạn cũng cần thông báo kết quả thứ 17, không có lỗi tình trạng.

245
00:14:33,000 --> 00:14:37,860
Giải pháp ở đây thực sự khá đơn giản, chỉ cần quên hoàn toàn bit 0 đó đi.

246
00:14:37,860 --> 00:14:41,000
Vì vậy, khi chúng tôi thực hiện bốn lần kiểm tra tính chẵn lẻ và thấy

247
00:14:41,000 --> 00:14:44,320
rằng tất cả chúng đều bằng nhau, điều đó rõ ràng có nghĩa là không có lỗi.

248
00:14:44,320 --> 00:14:49,611
Điều đó có nghĩa là thay vì làm việc với khối 16 bit, chúng tôi làm việc với khối 15 bit,

249
00:14:49,611 --> 00:14:54,080
trong đó 11 bit được tự do mang tin nhắn và 4 trong số đó dành cho dự phòng.

250
00:14:54,080 --> 00:14:59,400
Và cùng với đó, giờ đây chúng ta có thứ mà mọi người trong ngành gọi là mã Hamming 15-11.

251
00:14:59,400 --> 00:15:02,469
Điều đó nói lên rằng, thật tuyệt khi có kích thước khối có lũy thừa

252
00:15:02,469 --> 00:15:05,584
sạch là 2 và có một cách thông minh là chúng ta có thể giữ bit thứ 0

253
00:15:05,584 --> 00:15:08,880
đó xung quanh và khiến nó thực hiện thêm một chút công việc cho chúng ta.

254
00:15:08,880 --> 00:15:12,054
Nếu chúng tôi sử dụng nó như một bit chẵn lẻ trên toàn bộ khối,

255
00:15:12,054 --> 00:15:16,320
nó cho phép chúng tôi thực sự phát hiện các lỗi 2 bit, mặc dù chúng tôi không thể sửa.

256
00:15:16,320 --> 00:15:17,440
Đây là cách nó hoạt động.

257
00:15:17,440 --> 00:15:19,733
Sau khi thiết lập bốn bit sửa lỗi đặc biệt đó,

258
00:15:19,733 --> 00:15:23,344
chúng tôi đặt bit thứ 0 đó sao cho tính chẵn lẻ của toàn bộ khối là chẵn,

259
00:15:23,344 --> 00:15:25,540
giống như kiểm tra tính chẵn lẻ thông thường.

260
00:15:25,540 --> 00:15:29,669
Bây giờ, nếu có một lỗi bit nào đó thì tính chẵn lẻ của toàn bộ khối sẽ chuyển thành số

261
00:15:29,669 --> 00:15:33,752
lẻ, nhưng dù sao thì chúng ta cũng sẽ phát hiện được điều đó nhờ bốn bước kiểm tra sửa

262
00:15:33,752 --> 00:15:33,940
lỗi.

263
00:15:33,940 --> 00:15:38,742
Tuy nhiên, nếu có hai lỗi thì tổng số chẵn lẻ sẽ chuyển về trạng thái chẵn,

264
00:15:38,742 --> 00:15:42,470
nhưng người nhận vẫn thấy rằng đã có ít nhất một số lỗi do

265
00:15:42,470 --> 00:15:45,820
những gì đang xảy ra với bốn lần kiểm tra chẵn lẻ đó.

266
00:15:45,820 --> 00:15:48,132
Vì vậy, nếu họ nhận thấy có sự chẵn lẻ về tổng thể,

267
00:15:48,132 --> 00:15:50,845
nhưng có điều gì đó khác 0 xảy ra với các lần kiểm tra khác,

268
00:15:50,845 --> 00:15:52,980
thì điều đó cho họ biết rằng có ít nhất hai lỗi.

269
00:15:52,980 --> 00:15:54,420
Không phải là thông minh sao?

270
00:15:54,420 --> 00:15:57,042
Mặc dù chúng tôi không thể sửa các lỗi 2 bit đó,

271
00:15:57,042 --> 00:15:59,985
nhưng chỉ cần đưa bit 0 khó chịu đó hoạt động trở lại,

272
00:15:59,985 --> 00:16:02,340
nó sẽ cho phép chúng tôi phát hiện ra chúng.

273
00:16:02,340 --> 00:16:06,540
Đây là mã khá chuẩn, nó được gọi là mã Hamming mở rộng.

274
00:16:06,540 --> 00:16:11,173
Về mặt kỹ thuật, bây giờ bạn đã có mô tả đầy đủ về chức năng của mã Hamming,

275
00:16:11,173 --> 00:16:13,580
ít nhất là đối với ví dụ về khối 16 bit.

276
00:16:13,580 --> 00:16:17,804
Nhưng tôi nghĩ bạn sẽ thấy hài lòng hơn khi kiểm tra sự hiểu biết của mình và củng cố

277
00:16:17,804 --> 00:16:21,980
mọi thứ cho đến thời điểm này bằng cách tự mình làm một ví dụ đầy đủ từ đầu đến cuối.

278
00:16:21,980 --> 00:16:25,100
Tuy nhiên, tôi sẽ cùng bạn giải quyết vấn đề này để bạn có thể tự kiểm tra.

279
00:16:25,100 --> 00:16:28,561
Để thiết lập một tin nhắn, cho dù đó là tin nhắn theo nghĩa đen

280
00:16:28,561 --> 00:16:33,158
mà bạn đang dịch theo không gian hay một số dữ liệu bạn muốn lưu trữ theo thời gian,

281
00:16:33,158 --> 00:16:35,700
bước đầu tiên là chia nó thành các phần 11 bit.

282
00:16:35,700 --> 00:16:40,340
Mỗi đoạn sẽ được đóng gói thành một khối 16 bit chống lỗi.

283
00:16:40,340 --> 00:16:43,740
Vì vậy, hãy lấy ví dụ này làm ví dụ và thực sự giải quyết nó.

284
00:16:43,740 --> 00:16:45,380
Hãy tiếp tục, thực sự làm điều đó!

285
00:16:45,380 --> 00:16:52,980
Hãy tạm dừng và thử ghép khối này lại với nhau.

286
00:16:52,980 --> 00:16:53,980
Được rồi, bạn sẵn sàng chưa?

287
00:16:53,980 --> 00:16:59,678
Hãy nhớ rằng, vị trí 0 cùng với các lũy thừa khác của 2 được dành cho nhiệm vụ sửa lỗi,

288
00:16:59,678 --> 00:17:03,498
vì vậy bạn bắt đầu bằng cách đặt các bit thông báo vào tất

289
00:17:03,498 --> 00:17:05,700
cả các vị trí còn lại theo thứ tự.

290
00:17:05,700 --> 00:17:09,563
Bạn cần nhóm này có tính chẵn lẻ, điều này đã có sẵn,

291
00:17:09,563 --> 00:17:13,140
vì vậy bạn nên đặt bit chẵn lẻ đó ở vị trí 1 là 0.

292
00:17:13,140 --> 00:17:19,260
Nhóm tiếp theo bắt đầu với số chẵn lẻ lẻ, vì vậy bạn nên đặt bit chẵn lẻ của nó là 1.

293
00:17:19,260 --> 00:17:22,055
Nhóm sau đó bắt đầu với số chẵn lẻ lẻ, vì vậy một

294
00:17:22,055 --> 00:17:24,740
lần nữa bạn phải đặt bit chẵn lẻ của nó thành 1.

295
00:17:24,740 --> 00:17:31,500
Và nhóm cuối cùng cũng có tính chẵn lẻ lẻ, nghĩa là chúng ta đặt bit đó ở vị trí 8 là 1.

296
00:17:31,500 --> 00:17:36,385
Và ở bước cuối cùng, toàn bộ khối bây giờ có tính chẵn lẻ chẵn,

297
00:17:36,385 --> 00:17:41,500
nghĩa là bạn có thể đặt số bit đó là 0, bit chẵn lẻ tổng thể, là 0.

298
00:17:41,500 --> 00:17:45,240
Vì vậy, khi khối này được gửi đi, tính chẵn lẻ của bốn tập

299
00:17:45,240 --> 00:17:48,980
hợp con đặc biệt và toàn bộ khối sẽ là số chẵn hoặc bằng 0.

300
00:17:48,980 --> 00:17:53,620
Trong phần thứ hai của bài tập, bạn hãy đóng vai người nhận.

301
00:17:53,620 --> 00:17:56,851
Tất nhiên, điều đó có nghĩa là bạn chưa biết thông điệp này là gì,

302
00:17:56,851 --> 00:18:00,180
có thể một số bạn đã ghi nhớ nó, nhưng hãy giả sử rằng bạn chưa biết.

303
00:18:00,180 --> 00:18:04,187
Những gì tôi sắp làm là thay đổi 0, 1 hoặc 2 bit trong

304
00:18:04,187 --> 00:18:08,340
khối đó và sau đó yêu cầu bạn tìm hiểu xem tôi đã làm gì.

305
00:18:08,340 --> 00:18:13,460
Vì vậy, một lần nữa, hãy tạm dừng và thử giải quyết nó.

306
00:18:13,460 --> 00:18:18,913
Được rồi, bây giờ bạn với tư cách là người nhận hãy kiểm tra

307
00:18:18,913 --> 00:18:24,366
nhóm chẵn lẻ đầu tiên và bạn có thể thấy rằng đó là số chẵn,

308
00:18:24,366 --> 00:18:29,820
vì vậy bất kỳ lỗi nào tồn tại sẽ phải nằm trong một cột chẵn.

309
00:18:29,820 --> 00:18:33,303
Kiểm tra tiếp theo cung cấp cho chúng tôi một số lẻ,

310
00:18:33,303 --> 00:18:38,760
cho chúng tôi biết rằng có ít nhất một lỗi và thu hẹp chúng tôi vào cột cụ thể này.

311
00:18:38,760 --> 00:18:42,900
Lần kiểm tra thứ ba là chẵn, cắt giảm các khả năng hơn nữa.

312
00:18:42,900 --> 00:18:45,517
Và lần kiểm tra chẵn lẻ cuối cùng rất kỳ quặc,

313
00:18:45,517 --> 00:18:48,135
cho chúng ta biết có lỗi ở đâu đó ở phía dưới,

314
00:18:48,135 --> 00:18:51,700
mà đến bây giờ chúng ta có thể thấy lỗi này phải ở vị trí số 10.

315
00:18:51,700 --> 00:18:54,407
Hơn nữa, tính chẵn lẻ của toàn bộ khối là số lẻ,

316
00:18:54,407 --> 00:18:58,220
khiến chúng tôi tin tưởng rằng chỉ có một lần lật chứ không phải hai.

317
00:18:58,220 --> 00:19:01,600
Nếu là ba hoặc nhiều hơn, tất cả cược sẽ bị hủy.

318
00:19:01,600 --> 00:19:06,385
Sau khi sửa bit số 10 đó, việc rút ra 11 bit không được sử dụng để sửa

319
00:19:06,385 --> 00:19:10,295
sẽ cho chúng ta phân đoạn có liên quan của thông báo gốc,

320
00:19:10,295 --> 00:19:16,160
nếu bạn tua lại và so sánh thì thực sự chính xác là những gì chúng ta đã bắt đầu ví dụ.

321
00:19:16,160 --> 00:19:19,272
Và bây giờ bạn đã biết cách thực hiện tất cả những điều này bằng tay,

322
00:19:19,272 --> 00:19:23,095
tôi muốn chỉ cho bạn cách bạn có thể thực hiện phần cốt lõi của tất cả logic này bằng

323
00:19:23,095 --> 00:19:23,940
một dòng mã Python.

324
00:19:23,940 --> 00:19:28,152
Bạn thấy đấy, điều tôi chưa nói với bạn là thuật toán này thực sự tinh tế đến mức nào,

325
00:19:28,152 --> 00:19:31,251
thật đơn giản để khiến một chiếc máy chỉ ra vị trí của một lỗi,

326
00:19:31,251 --> 00:19:35,076
cách chia tỷ lệ nó một cách có hệ thống và cách chúng ta có thể đóng khung tất

327
00:19:35,076 --> 00:19:38,902
cả các lỗi đó. đây là một thao tác đơn lẻ thay vì nhiều lần kiểm tra tính chẵn

328
00:19:38,902 --> 00:19:39,580
lẻ riêng biệt.

329
00:19:39,580 --> 00:19:39,580
Để hiểu ý tôi, hãy cùng tôi tham gia phần 2 nhé.

