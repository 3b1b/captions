1
00:00:00,000 --> 00:00:05,576
Bạn đã bao giờ tự hỏi làm thế nào có thể làm xước một đĩa CD hoặc

2
00:00:05,576 --> 00:00:10,900
DVD mà vẫn có thể phát lại bất cứ thứ gì nó đang lưu trữ không?

3
00:00:10,900 --> 00:00:15,148
Vết xước thực sự ảnh hưởng đến số 1 và 0 trên đĩa, do đó nó đọc dữ

4
00:00:15,148 --> 00:00:19,586
liệu khác với những gì được lưu trữ, nhưng trừ khi nó thực sự bị trầy

5
00:00:19,586 --> 00:00:23,961
xước, các bit mà nó đọc được sẽ được giải mã thành cùng một tệp được

6
00:00:23,961 --> 00:00:28,400
mã hóa trên đó, một bit để sao chép bit, bất chấp tất cả những lỗi đó.

7
00:00:28,400 --> 00:00:32,647
Có rất nhiều sự thông minh về toán học cho phép chúng ta lưu trữ dữ liệu và

8
00:00:32,647 --> 00:00:36,840
quan trọng không kém là truyền dữ liệu theo cách có khả năng chống lại lỗi.

9
00:00:36,840 --> 00:00:42,480
Được rồi, thực ra không cần quá thông minh để nghĩ ra cách thực hiện việc này.

10
00:00:42,480 --> 00:00:46,625
Bất kỳ tập tin nào, cho dù đó là video, âm thanh hay văn bản, một

11
00:00:46,625 --> 00:00:50,960
số mã, hình ảnh, bất cứ thứ gì, cuối cùng đều là một chuỗi số 1 và 0.

12
00:00:50,960 --> 00:00:54,515
Và một chiến lược đơn giản để sửa bất kỳ bit nào

13
00:00:54,515 --> 00:00:57,780
bị đảo lộn là lưu trữ ba bản sao của mỗi bit.

14
00:00:57,780 --> 00:01:02,407
Sau đó, máy đọc tệp này có thể so sánh ba bản sao này và

15
00:01:02,407 --> 00:01:07,440
luôn lấy 2 trên 3 bản tốt nhất bất cứ khi nào có sự khác biệt.

16
00:01:07,440 --> 00:01:11,560
Nhưng điều đó có nghĩa là sử dụng 2/3 dung lượng của bạn để dự phòng.

17
00:01:11,560 --> 00:01:14,862
Và thậm chí sau đó, đối với tất cả không gian bị bỏ đi, không có gì đảm

18
00:01:14,862 --> 00:01:18,120
bảo chắc chắn về điều gì sẽ xảy ra nếu có nhiều hơn một bit bị đảo lộn.

19
00:01:18,120 --> 00:01:21,430
Câu hỏi thú vị hơn nhiều là làm thế nào để có thể

20
00:01:21,430 --> 00:01:24,740
sửa lỗi trong khi chiếm ít không gian nhất có thể.

21
00:01:24,740 --> 00:01:28,908
Ví dụ: bằng cách sử dụng phương pháp bạn sẽ tìm hiểu về video này, bạn có thể lưu

22
00:01:28,908 --> 00:01:32,975
trữ dữ liệu của mình trong các khối 256 bit, trong đó mỗi khối sử dụng 9 bit, 9!

23
00:01:32,975 --> 00:01:36,923
hoạt động như một loại dự phòng và 247 bit còn lại có thể tự

24
00:01:36,923 --> 00:01:41,000
do mang bất kỳ thông điệp hoặc dữ liệu có ý nghĩa nào bạn muốn.

25
00:01:41,000 --> 00:01:45,066
Và vẫn sẽ xảy ra trường hợp nếu bất kỳ bit nào bị đảo lộn ở đây, chỉ

26
00:01:45,066 --> 00:01:49,014
cần nhìn vào khối này và không cần gì thêm, máy sẽ có thể xác định

27
00:01:49,014 --> 00:01:53,140
rằng đã có lỗi và xác định chính xác lỗi đó ở đâu để nó biết cách sửa.

28
00:01:53,140 --> 00:01:55,540
Và thành thật mà nói, điều đó giống như một phép thuật.

29
00:01:55,540 --> 00:01:59,306
Và đối với sơ đồ cụ thể này, nếu hai bit bị đảo lộn, máy ít nhất sẽ có

30
00:01:59,306 --> 00:02:03,180
thể phát hiện ra rằng có hai lỗi, mặc dù nó sẽ không biết cách sửa chúng.

31
00:02:03,180 --> 00:02:05,710
Chúng ta sẽ nói một lát sau về cách điều chỉnh tỷ

32
00:02:05,710 --> 00:02:08,140
lệ này đối với các khối có kích thước khác nhau.

33
00:02:08,140 --> 00:02:11,065
Các phương pháp cho phép bạn sửa các lỗi như thế này

34
00:02:11,065 --> 00:02:13,880
được biết đến một cách hợp lý dưới dạng mã sửa lỗi.

35
00:02:13,880 --> 00:02:18,410
Trong phần lớn thế kỷ trước, lĩnh vực này thực sự là một nguồn toán học sâu

36
00:02:18,410 --> 00:02:23,000
sắc đáng kinh ngạc được tích hợp vào các thiết bị chúng ta sử dụng hàng ngày.

37
00:02:23,000 --> 00:02:26,158
Mục tiêu ở đây là giúp bạn hiểu rất kỹ về một

38
00:02:26,158 --> 00:02:29,660
trong những ví dụ sớm nhất, được gọi là mã Hamming.

39
00:02:29,660 --> 00:02:33,262
Và nhân tiện, cách tôi nghĩ về cấu trúc của video này không phải là giải

40
00:02:33,262 --> 00:02:36,716
thích nó một cách trực tiếp nhất có thể mà quan trọng hơn là thúc đẩy

41
00:02:36,716 --> 00:02:40,220
bạn tự sáng tạo ra nó với một chút hướng dẫn nhẹ nhàng chỗ này chỗ kia.

42
00:02:40,220 --> 00:02:42,574
Vì vậy, khi bạn cảm thấy mình biết mọi chuyện sẽ đi đến đâu vào một

43
00:02:42,574 --> 00:02:44,825
thời điểm nào đó, hãy dành thời gian đó để tạm dừng, chủ động dự

44
00:02:44,825 --> 00:02:47,180
đoán kế hoạch sẽ diễn ra như thế nào trước khi tôi nói cho bạn biết.

45
00:02:47,180 --> 00:02:51,356
Ngoài ra, nếu bạn muốn hiểu sâu hơn ở cấp độ phần cứng, Ben Eater

46
00:02:51,356 --> 00:02:55,533
đã tạo một video kết hợp với video này hướng dẫn bạn cách thực sự

47
00:02:55,533 --> 00:02:59,520
triển khai mã Hamming trên bảng mạch, điều này cực kỳ thỏa mãn.

48
00:02:59,520 --> 00:03:03,213
Bạn nên biết, mã Hamming không được sử dụng rộng rãi như các mã hiện

49
00:03:03,213 --> 00:03:06,853
đại hơn, như thuật toán Reed-Solomon, nhưng có một điều kỳ diệu nào

50
00:03:06,853 --> 00:03:10,493
đó đối với sự tương phản giữa việc nhiệm vụ này có cảm giác bất khả

51
00:03:10,493 --> 00:03:14,240
thi ngay từ đầu và nó có vẻ hoàn toàn hợp lý. bạn tìm hiểu về Hamming.

52
00:03:14,240 --> 00:03:18,496
Nguyên tắc cơ bản của việc sửa lỗi là trong một không gian rộng lớn gồm tất cả

53
00:03:18,496 --> 00:03:22,860
các thông báo có thể có, chỉ một số tập hợp con được coi là các thông báo hợp lệ.

54
00:03:22,860 --> 00:03:29,100
Tương tự, hãy nghĩ về những từ viết đúng chính tả và những từ viết sai chính tả.

55
00:03:29,100 --> 00:03:33,636
Bất cứ khi nào một tin nhắn hợp lệ bị thay đổi, người nhận có trách nhiệm sửa lại những

56
00:03:33,636 --> 00:03:38,173
gì họ nhìn thấy cho người hàng xóm hợp lệ gần nhất, như bạn có thể làm với một lỗi đánh

57
00:03:38,173 --> 00:03:38,380
máy.

58
00:03:38,380 --> 00:03:42,877
Tuy nhiên, việc đưa ra một thuật toán cụ thể để phân loại hiệu

59
00:03:42,877 --> 00:03:47,160
quả các tin nhắn như thế này cần có sự thông minh nhất định.

60
00:03:47,160 --> 00:03:50,565
Câu chuyện bắt đầu vào những năm 1940, khi chàng trai trẻ Richard Hamming đang

61
00:03:50,565 --> 00:03:53,971
làm việc cho Bell Labs, và một số công việc của anh liên quan đến việc sử dụng

62
00:03:53,971 --> 00:03:57,420
một chiếc máy tính thẻ đục lỗ rất đắt tiền mà anh chỉ có quyền truy cập hạn chế.

63
00:03:57,420 --> 00:04:00,222
Và các chương trình mà anh ấy thực hiện liên tục

64
00:04:00,222 --> 00:04:03,140
bị lỗi, bởi vì thỉnh thoảng có một chút bị đọc sai.

65
00:04:03,140 --> 00:04:06,129
Sự thất vọng là lò thử thách của phát minh, anh ta chán

66
00:04:06,129 --> 00:04:09,280
nản đến mức phát minh ra mã sửa lỗi đầu tiên trên thế giới.

67
00:04:09,280 --> 00:04:12,814
Có nhiều cách khác nhau để đóng khung mã Hamming, nhưng bước đầu

68
00:04:12,814 --> 00:04:16,620
tiên chúng ta sẽ tìm hiểu nó theo cách mà chính Hamming nghĩ về chúng.

69
00:04:16,620 --> 00:04:21,400
Hãy sử dụng một ví dụ đơn giản nhưng không quá đơn giản, một khối 16 bit.

70
00:04:21,400 --> 00:04:25,700
Chúng ta sẽ đánh số vị trí của các bit này từ 0 đến 15.

71
00:04:25,700 --> 00:04:29,902
Dữ liệu thực tế mà chúng tôi muốn lưu trữ sẽ chỉ chiếm 12 bit trong

72
00:04:29,902 --> 00:04:33,920
số này, trong khi 4 vị trí được dành riêng như một loại dự phòng.

73
00:04:33,920 --> 00:04:37,016
Từ dư thừa ở đây không đơn giản có nghĩa là sao chép, xét cho cùng thì

74
00:04:37,016 --> 00:04:40,200
4 bit đó không cho chúng ta đủ chỗ để sao chép dữ liệu một cách mù quáng.

75
00:04:40,200 --> 00:04:44,527
Thay vào đó, chúng sẽ cần phải là một loại dự phòng thông minh và sắc thái

76
00:04:44,527 --> 00:04:48,740
hơn nhiều, không thêm bất kỳ thông tin mới nào mà thêm khả năng phục hồi.

77
00:04:48,740 --> 00:04:52,498
Bạn có thể mong đợi 4 bit đặc biệt này được kết hợp chặt chẽ với nhau, có

78
00:04:52,498 --> 00:04:56,358
thể ở cuối hoặc thứ gì đó tương tự, nhưng như bạn sẽ thấy, việc đặt chúng ở

79
00:04:56,358 --> 00:05:00,320
các vị trí có lũy thừa bằng 2 sẽ tạo ra thứ gì đó thực sự thanh lịch vào cuối.

80
00:05:00,320 --> 00:05:05,420
Nó cũng có thể cung cấp cho bạn một gợi ý nhỏ về cách tỷ lệ này đối với các khối lớn hơn.

81
00:05:05,420 --> 00:05:09,708
Ngoài ra, về mặt kỹ thuật, nó chỉ có 11 bit dữ liệu, bạn sẽ thấy có một sắc

82
00:05:09,708 --> 00:05:14,280
thái nhẹ cho những gì diễn ra ở vị trí 0, nhưng hiện tại đừng lo lắng về điều đó.

83
00:05:14,280 --> 00:05:18,360
Giống như bất kỳ thuật toán sửa lỗi nào, điều này sẽ có sự tham gia của hai

84
00:05:18,360 --> 00:05:22,387
người chơi, một người gửi chịu trách nhiệm thiết lập 4 bit đặc biệt này và

85
00:05:22,387 --> 00:05:26,360
một người nhận chịu trách nhiệm thực hiện một số loại kiểm tra và sửa lỗi.

86
00:05:26,360 --> 00:05:29,334
Tất nhiên, từ người gửi và người nhận thực sự đề cập đến máy

87
00:05:29,334 --> 00:05:32,456
móc hoặc phần mềm thực hiện tất cả các bước kiểm tra và ý tưởng

88
00:05:32,456 --> 00:05:35,480
về tin nhắn được hiểu rất rộng, bao gồm những thứ như lưu trữ.

89
00:05:35,480 --> 00:05:39,060
Xét cho cùng, việc lưu trữ dữ liệu cũng giống như gửi một tin

90
00:05:39,060 --> 00:05:42,640
nhắn từ quá khứ đến tương lai thay vì từ nơi này đến nơi khác.

91
00:05:42,640 --> 00:05:46,279
Đó là thiết lập, nhưng trước khi đi sâu vào chúng ta cần nói về một ý

92
00:05:46,279 --> 00:05:49,866
tưởng liên quan mới mẻ trong đầu Hamming vào thời điểm ông phát hiện

93
00:05:49,866 --> 00:05:53,401
ra, một phương pháp cho phép bạn phát hiện bất kỳ lỗi bit nào nhưng

94
00:05:53,401 --> 00:05:57,300
không sửa chúng, đã biết trong kinh doanh như một sự kiểm tra tính chẵn lẻ.

95
00:05:57,300 --> 00:06:01,145
Để kiểm tra tính chẵn lẻ, chúng tôi chỉ tách ra một bit duy nhất mà người

96
00:06:01,145 --> 00:06:04,940
gửi chịu trách nhiệm điều chỉnh và phần còn lại được tự do mang tin nhắn.

97
00:06:04,940 --> 00:06:08,482
Công việc duy nhất của bit đặc biệt này là đảm

98
00:06:08,482 --> 00:06:12,100
bảo rằng tổng số số 1 trong tin nhắn là số chẵn.

99
00:06:12,100 --> 00:06:16,319
Vì vậy, ví dụ ngay bây giờ, tổng số 1 đó là 7, là số lẻ nên

100
00:06:16,319 --> 00:06:20,960
người gửi cần lật bit đặc biệt đó thành 1, làm cho số đếm là chẵn.

101
00:06:20,960 --> 00:06:27,480
Nhưng nếu khối đã bắt đầu với số chẵn là 1 thì bit đặc biệt này sẽ được giữ ở mức 0.

102
00:06:27,480 --> 00:06:30,796
Điều này khá đơn giản, có vẻ đơn giản, nhưng đó là một cách

103
00:06:30,796 --> 00:06:34,278
cực kỳ tinh tế để chắt lọc ý tưởng về sự thay đổi ở bất kỳ đâu

104
00:06:34,278 --> 00:06:37,760
trong thông điệp để được phản ánh trong một thông tin duy nhất.

105
00:06:37,760 --> 00:06:42,787
Lưu ý nếu bất kỳ bit nào của thông báo này bị đảo ngược, từ 0

106
00:06:42,787 --> 00:06:48,140
thành 1 hoặc 1 thành 0, nó sẽ thay đổi tổng số 1 từ chẵn thành lẻ.

107
00:06:48,140 --> 00:06:53,297
Vì vậy, nếu bạn là người nhận, bạn nhìn vào tin nhắn này và thấy số lẻ là 1, bạn có

108
00:06:53,297 --> 00:06:58,700
thể biết chắc chắn rằng đã xảy ra lỗi nào đó, mặc dù bạn có thể không biết lỗi đó ở đâu.

109
00:06:58,700 --> 00:07:04,940
Trong thuật ngữ, việc một nhóm bit có số 1 chẵn hay lẻ được gọi là tính chẵn lẻ của nó.

110
00:07:04,940 --> 00:07:08,059
Bạn cũng có thể sử dụng các con số và nói số chẵn lẻ là 0 hoặc 1,

111
00:07:08,059 --> 00:07:11,320
điều này thường hữu ích hơn khi bạn bắt đầu làm toán với ý tưởng này.

112
00:07:11,320 --> 00:07:14,927
Và bit đặc biệt này mà người gửi sử dụng để kiểm

113
00:07:14,927 --> 00:07:18,020
soát tính chẵn lẻ được gọi là bit chẵn lẻ.

114
00:07:18,020 --> 00:07:21,851
Và trên thực tế, chúng ta nên nói rõ, nếu người nhận nhìn thấy một số chẵn lẻ lẻ,

115
00:07:21,851 --> 00:07:25,635
điều đó không nhất thiết có nghĩa là chỉ có một lỗi, có thể có 3 lỗi, hoặc 5 lỗi

116
00:07:25,635 --> 00:07:29,560
hoặc bất kỳ số lẻ nào khác, nhưng họ có thể biết chắc chắn. rằng nó không phải là 0.

117
00:07:29,560 --> 00:07:34,256
Mặt khác, nếu có 2 lỗi hoặc bất kỳ số lỗi chẵn nào thì số 1 cuối

118
00:07:34,256 --> 00:07:38,735
cùng vẫn là số chẵn, do đó người nhận không thể hoàn toàn tin

119
00:07:38,735 --> 00:07:43,360
tưởng rằng số chẵn nhất thiết có nghĩa là tin nhắn không có lỗi.

120
00:07:43,360 --> 00:07:46,496
Bạn có thể phàn nàn rằng một tin nhắn bị lộn xộn

121
00:07:46,496 --> 00:07:49,760
chỉ sau 2 lần lật là khá yếu và bạn hoàn toàn đúng.

122
00:07:49,760 --> 00:07:54,674
Tuy nhiên, hãy nhớ rằng không có phương pháp phát hiện hoặc sửa lỗi nào có

123
00:07:54,674 --> 00:07:59,720
thể giúp bạn tin cậy 100% rằng thư bạn nhận được là thư mà người gửi dự định.

124
00:07:59,720 --> 00:08:02,773
Rốt cuộc, tiếng ồn ngẫu nhiên đủ lớn luôn có thể thay đổi một tin

125
00:08:02,773 --> 00:08:05,920
nhắn hợp lệ thành một tin nhắn hợp lệ khác chỉ hoàn toàn là tình cờ.

126
00:08:05,920 --> 00:08:11,200
Thay vào đó, mục tiêu là đưa ra một sơ đồ mạnh mẽ với số lỗi tối đa nhất

127
00:08:11,200 --> 00:08:16,480
định hoặc có thể giảm xác suất xảy ra kết quả dương tính giả như thế này.

128
00:08:16,480 --> 00:08:20,150
Bản thân việc kiểm tra tính chẵn lẻ khá yếu, nhưng bằng cách chắt lọc ý

129
00:08:20,150 --> 00:08:23,871
tưởng thay đổi toàn bộ thông điệp thành một bit duy nhất, những gì chúng

130
00:08:23,871 --> 00:08:28,000
mang lại cho chúng ta là một khối xây dựng mạnh mẽ cho các kế hoạch phức tạp hơn.

131
00:08:28,000 --> 00:08:32,751
Ví dụ, khi Hamming đang tìm cách xác định lỗi đã xảy ra ở đâu, không chỉ lỗi xảy ra,

132
00:08:32,751 --> 00:08:37,503
hiểu biết sâu sắc quan trọng của ông là nếu bạn áp dụng một số kiểm tra tính chẵn lẻ

133
00:08:37,503 --> 00:08:42,143
không phải cho toàn bộ thông báo mà cho một số tập hợp con được chọn cẩn thận, bạn

134
00:08:42,143 --> 00:08:46,840
có thể hỏi một loạt câu hỏi tinh tế hơn nhằm xác định vị trí của bất kỳ lỗi bit nào.

135
00:08:46,840 --> 00:08:50,600
Cảm giác tổng thể giống như chơi một trò chơi gồm 20 câu hỏi,

136
00:08:50,600 --> 00:08:54,300
đặt các câu hỏi có hoặc không để cắt đôi không gian khả năng.

137
00:08:54,300 --> 00:08:57,405
Ví dụ: giả sử chúng tôi thực hiện kiểm tra tính chẵn lẻ

138
00:08:57,405 --> 00:09:00,400
chỉ trên 8 bit này, tất cả các vị trí được đánh số lẻ.

139
00:09:00,400 --> 00:09:04,715
Sau đó, nếu phát hiện thấy lỗi, nó sẽ cung cấp cho người nhận thêm

140
00:09:04,715 --> 00:09:09,160
một chút thông tin về lỗi cụ thể ở đâu, cụ thể là lỗi ở vị trí kỳ lạ.

141
00:09:09,160 --> 00:09:13,268
Nếu không phát hiện thấy lỗi nào trong số 8 bit đó, điều đó

142
00:09:13,268 --> 00:09:17,240
có nghĩa là không có lỗi nào cả hoặc nó nằm ở vị trí chẵn.

143
00:09:17,240 --> 00:09:20,325
Bạn có thể nghĩ rằng việc giới hạn kiểm tra tính chẵn lẻ ở mức một

144
00:09:20,325 --> 00:09:23,503
nửa số bit sẽ khiến nó kém hiệu quả hơn, nhưng khi nó được thực hiện

145
00:09:23,503 --> 00:09:26,542
cùng với các kiểm tra được lựa chọn kỹ lưỡng khác, nó sẽ mang lại

146
00:09:26,542 --> 00:09:29,720
cho chúng ta thứ gì đó mạnh mẽ hơn rất nhiều một cách phản trực giác.

147
00:09:29,720 --> 00:09:33,684
Để thực sự thiết lập việc kiểm tra tính chẵn lẻ đó, hãy nhớ rằng, nó đòi hỏi phải

148
00:09:33,684 --> 00:09:37,600
đánh dấu một số bit đặc biệt có quyền kiểm soát tính chẵn lẻ của toàn bộ nhóm đó.

149
00:09:37,600 --> 00:09:39,920
Ở đây chúng ta hãy chọn vị trí 1.

150
00:09:39,920 --> 00:09:44,097
Đối với ví dụ được hiển thị, tính chẵn lẻ của 8 bit này hiện là số lẻ, do đó

151
00:09:44,097 --> 00:09:48,220
người gửi có trách nhiệm chuyển đổi bit chẵn lẻ đó và bây giờ nó là số chẵn.

152
00:09:48,220 --> 00:09:51,040
Đây chỉ là 1 trong 4 lần kiểm tra tính chẵn lẻ mà chúng tôi sẽ thực hiện.

153
00:09:51,040 --> 00:09:54,079
Kiểm tra thứ hai nằm trong số 8 bit ở nửa bên phải

154
00:09:54,079 --> 00:09:56,880
của lưới, ít nhất là như chúng tôi đã vẽ ở đây.

155
00:09:56,880 --> 00:10:02,020
Lần này chúng ta có thể sử dụng vị trí 2 làm bit chẵn lẻ, vì vậy 8 bit này đã có

156
00:10:02,020 --> 00:10:07,160
giá trị chẵn lẻ và người gửi có thể cảm thấy hài lòng khi giữ nguyên bit số 2 đó.

157
00:10:07,160 --> 00:10:11,419
Sau đó, ở đầu bên kia, nếu người nhận kiểm tra tính chẵn lẻ của nhóm này và

158
00:10:11,419 --> 00:10:15,960
thấy rằng nó kỳ lạ, họ sẽ biết rằng lỗi nằm ở đâu đó trong số 8 bit bên phải này.

159
00:10:15,960 --> 00:10:21,260
Ngược lại, điều đó có nghĩa là không có lỗi hoặc lỗi nằm ở đâu đó ở nửa bên trái.

160
00:10:21,260 --> 00:10:24,221
Hoặc tôi đoán có thể có hai lỗi, nhưng hiện tại chúng ta

161
00:10:24,221 --> 00:10:27,080
giả định rằng có nhiều nhất một lỗi trong toàn bộ khối.

162
00:10:27,080 --> 00:10:29,160
Mọi thứ bị phá vỡ hoàn toàn vì nhiều hơn thế.

163
00:10:29,160 --> 00:10:31,376
Ở đây, trước khi chúng ta xem xét hai bước kiểm tra tiếp theo,

164
00:10:31,376 --> 00:10:33,557
hãy dành chút thời gian để suy nghĩ xem hai bước kiểm tra đầu

165
00:10:33,557 --> 00:10:35,880
tiên này cho phép chúng ta làm gì khi bạn xem xét chúng cùng nhau.

166
00:10:35,880 --> 00:10:40,240
Giả sử bạn phát hiện lỗi giữa các cột lẻ và giữa nửa bên phải.

167
00:10:40,240 --> 00:10:43,940
Nó nhất thiết có nghĩa là lỗi ở đâu đó trong cột cuối cùng.

168
00:10:43,940 --> 00:10:47,096
Nếu không có lỗi ở cột lẻ nhưng có một lỗi ở nửa bên phải,

169
00:10:47,096 --> 00:10:50,520
điều đó cho bạn biết lỗi đó nằm ở cột thứ hai đến cột cuối cùng.

170
00:10:50,520 --> 00:10:53,540
Tương tự như vậy, nếu có lỗi ở cột lẻ nhưng không

171
00:10:53,540 --> 00:10:56,560
ở nửa bên phải, bạn biết lỗi đó nằm ở cột thứ hai.

172
00:10:56,560 --> 00:11:00,160
Và nếu cả hai lần kiểm tra chẵn lẻ đó đều không phát hiện ra điều gì, điều

173
00:11:00,160 --> 00:11:03,760
đó có nghĩa là nơi duy nhất có thể xảy ra lỗi là ở cột ngoài cùng bên trái.

174
00:11:03,760 --> 00:11:06,480
Nhưng nó cũng có thể đơn giản có nghĩa là không có lỗi nào cả.

175
00:11:06,480 --> 00:11:09,068
Đó hoàn toàn là một cách khá phức tạp để nói rằng hai

176
00:11:09,068 --> 00:11:11,800
lần kiểm tra tính chẵn lẻ cho phép chúng ta xác định cột.

177
00:11:11,800 --> 00:11:14,000
Từ đây có lẽ bạn có thể đoán được điều gì sẽ xảy ra tiếp theo.

178
00:11:14,000 --> 00:11:16,240
Về cơ bản chúng tôi làm điều tương tự nhưng đối với các hàng.

179
00:11:16,240 --> 00:11:21,040
Sẽ có kiểm tra tính chẵn lẻ trên các hàng lẻ, sử dụng vị trí 4 làm bit chẵn lẻ.

180
00:11:21,040 --> 00:11:23,969
Vì vậy, trong ví dụ này, nhóm đó đã có tính chẵn

181
00:11:23,969 --> 00:11:26,480
lẻ chẵn, vì vậy bit 4 sẽ được đặt thành 0.

182
00:11:26,480 --> 00:11:29,535
Và cuối cùng là kiểm tra tính chẵn lẻ ở hai hàng

183
00:11:29,535 --> 00:11:32,280
dưới cùng, sử dụng vị trí 8 làm bit chẵn lẻ.

184
00:11:32,280 --> 00:11:35,090
Trong trường hợp này, có vẻ như người gửi cần

185
00:11:35,090 --> 00:11:37,840
bật bit 8 đó để mang lại cho nhóm sự chẵn lẻ.

186
00:11:37,840 --> 00:11:40,508
Giống như hai bước kiểm tra đầu tiên cho phép chúng ta ghim

187
00:11:40,508 --> 00:11:43,000
cột, hai bước kiểm tra tiếp theo cho phép bạn ghim hàng.

188
00:11:43,000 --> 00:11:48,400
Ví dụ, hãy tưởng tượng rằng trong quá trình truyền có một lỗi ở vị trí 3.

189
00:11:48,400 --> 00:11:52,296
Chà, điều này ảnh hưởng đến nhóm chẵn lẻ đầu tiên và nó cũng ảnh hưởng đến nhóm

190
00:11:52,296 --> 00:11:56,340
chẵn lẻ thứ hai, vì vậy người nhận biết rằng có lỗi ở đâu đó trong cột bên phải đó.

191
00:11:56,340 --> 00:12:01,380
Nhưng nó không ảnh hưởng đến nhóm thứ ba, và nó không ảnh hưởng đến nhóm thứ tư.

192
00:12:01,380 --> 00:12:04,869
Và điều đó cho phép người nhận xác định chính xác lỗi cho

193
00:12:04,869 --> 00:12:08,660
đến hàng đầu tiên, nghĩa là vị trí thứ 3, để họ có thể sửa lỗi.

194
00:12:08,660 --> 00:12:12,867
Bạn có thể thích dành chút thời gian để thuyết phục bản thân rằng câu trả lời cho bốn

195
00:12:12,867 --> 00:12:17,124
câu hỏi này thực sự sẽ luôn giúp bạn xác định được một địa điểm cụ thể, bất kể chúng ở

196
00:12:17,124 --> 00:12:17,320
đâu.

197
00:12:17,320 --> 00:12:20,480
Trên thực tế, những người tinh ý trong số các bạn thậm chí có thể

198
00:12:20,480 --> 00:12:23,640
nhận thấy mối liên hệ giữa những câu hỏi này và việc đếm nhị phân.

199
00:12:23,640 --> 00:12:27,346
Và nếu bạn làm vậy, một lần nữa hãy để tôi nhấn mạnh, tạm dừng,

200
00:12:27,346 --> 00:12:30,880
cố gắng tự mình rút ra mối liên hệ trước khi tôi làm hỏng nó.

201
00:12:30,880 --> 00:12:33,662
Nếu bạn đang thắc mắc điều gì sẽ xảy ra nếu bản

202
00:12:33,662 --> 00:12:36,560
thân bit chẵn lẻ bị ảnh hưởng, thì bạn có thể thử.

203
00:12:36,560 --> 00:12:41,939
Hãy dành một chút thời gian để suy nghĩ xem làm thế nào bất kỳ lỗi nào trong số bốn phần

204
00:12:41,939 --> 00:12:47,198
đặc biệt này sẽ được theo dõi giống như bất kỳ lỗi nào khác, với cùng một nhóm bốn câu

205
00:12:47,198 --> 00:12:47,440
hỏi.

206
00:12:47,440 --> 00:12:50,493
Điều đó thực sự không quan trọng, vì cuối cùng điều chúng ta muốn

207
00:12:50,493 --> 00:12:53,640
là bảo vệ các bit thông báo, các bit sửa lỗi vẫn tiếp tục hoạt động.

208
00:12:53,640 --> 00:12:56,567
Nhưng việc bảo vệ những bit đó cũng là điều đương

209
00:12:56,567 --> 00:12:59,260
nhiên nằm ngoài kế hoạch như một sản phẩm phụ.

210
00:12:59,260 --> 00:13:02,380
Bạn cũng có thể thích dự đoán quy mô này như thế nào.

211
00:13:02,380 --> 00:13:06,790
Ví dụ: nếu chúng tôi sử dụng một khối có kích thước 256 bit để

212
00:13:06,790 --> 00:13:11,130
xác định một vị trí, bạn chỉ cần tám câu hỏi có hoặc không để

213
00:13:11,130 --> 00:13:15,680
tìm kiếm nhị phân theo cách của bạn đến một vị trí cụ thể nào đó.

214
00:13:15,680 --> 00:13:19,472
Và hãy nhớ rằng, mỗi câu hỏi chỉ yêu cầu bỏ đi một

215
00:13:19,472 --> 00:13:23,340
bit duy nhất để đặt kiểm tra tính chẵn lẻ thích hợp.

216
00:13:23,340 --> 00:13:26,607
Một số bạn có thể đã nhìn thấy nó, nhưng sau này chúng ta sẽ nói về cách có

217
00:13:26,607 --> 00:13:29,960
hệ thống để tìm ra nội dung của những câu hỏi này chỉ trong một hoặc hai phút.

218
00:13:29,960 --> 00:13:32,113
Hy vọng bản phác thảo này đủ để đánh giá cao tính

219
00:13:32,113 --> 00:13:34,440
hiệu quả của những gì chúng tôi đang phát triển ở đây.

220
00:13:34,440 --> 00:13:37,977
Điều đầu tiên, ngoại trừ tám bit chẵn lẻ được đánh dấu đó, có thể là

221
00:13:37,977 --> 00:13:41,720
bất cứ thứ gì bạn muốn, mang bất kỳ thông điệp hoặc dữ liệu nào bạn muốn.

222
00:13:41,720 --> 00:13:47,574
8 bit dư thừa theo nghĩa là chúng hoàn toàn được xác định bởi phần còn lại của tin

223
00:13:47,574 --> 00:13:53,640
nhắn, nhưng đó là cách thông minh hơn nhiều so với việc chỉ sao chép toàn bộ tin nhắn.

224
00:13:53,640 --> 00:13:59,000
Tuy nhiên, với rất ít sự từ bỏ, bạn sẽ có thể xác định và sửa bất kỳ lỗi bit nào.

225
00:13:59,000 --> 00:14:00,400
Vâng, gần như vậy.

226
00:14:00,400 --> 00:14:04,624
Được rồi, vấn đề ở đây là nếu không có kiểm tra chẵn lẻ nào trong số bốn

227
00:14:04,624 --> 00:14:09,022
kiểm tra chẵn lẻ phát hiện ra lỗi, nghĩa là các tập hợp con 8 bit được chọn

228
00:14:09,022 --> 00:14:13,304
đặc biệt đều có các số chẵn lẻ, giống như dự định của người gửi, thì điều

229
00:14:13,304 --> 00:14:17,760
đó có nghĩa là không có lỗi nào cả , hoặc nó thu hẹp chúng ta xuống vị trí 0.

230
00:14:17,760 --> 00:14:22,688
Bạn thấy đấy, với bốn câu hỏi có hoặc không, chúng tôi có 16 kết quả có thể xảy ra cho

231
00:14:22,688 --> 00:14:27,504
việc kiểm tra tính chẵn lẻ của mình và lúc đầu, điều đó có vẻ hoàn hảo để xác định 1

232
00:14:27,504 --> 00:14:32,376
trong 16 vị trí trong khối, nhưng bạn cũng cần thông báo kết quả thứ 17, không có lỗi

233
00:14:32,376 --> 00:14:33,000
tình trạng.

234
00:14:33,000 --> 00:14:37,860
Giải pháp ở đây thực sự khá đơn giản, chỉ cần quên hoàn toàn bit 0 đó đi.

235
00:14:37,860 --> 00:14:41,000
Vì vậy, khi chúng tôi thực hiện bốn lần kiểm tra tính chẵn lẻ và thấy

236
00:14:41,000 --> 00:14:44,320
rằng tất cả chúng đều bằng nhau, điều đó rõ ràng có nghĩa là không có lỗi.

237
00:14:44,320 --> 00:14:49,141
Điều đó có nghĩa là thay vì làm việc với khối 16 bit, chúng tôi làm việc với khối

238
00:14:49,141 --> 00:14:54,080
15 bit, trong đó 11 bit được tự do mang tin nhắn và 4 trong số đó dành cho dự phòng.

239
00:14:54,080 --> 00:14:59,400
Và cùng với đó, giờ đây chúng ta có thứ mà mọi người trong ngành gọi là mã Hamming 15-11.

240
00:14:59,400 --> 00:15:02,469
Điều đó nói lên rằng, thật tuyệt khi có kích thước khối có lũy thừa

241
00:15:02,469 --> 00:15:05,584
sạch là 2 và có một cách thông minh là chúng ta có thể giữ bit thứ 0

242
00:15:05,584 --> 00:15:08,880
đó xung quanh và khiến nó thực hiện thêm một chút công việc cho chúng ta.

243
00:15:08,880 --> 00:15:12,649
Nếu chúng tôi sử dụng nó như một bit chẵn lẻ trên toàn bộ khối, nó cho phép

244
00:15:12,649 --> 00:15:16,320
chúng tôi thực sự phát hiện các lỗi 2 bit, mặc dù chúng tôi không thể sửa.

245
00:15:16,320 --> 00:15:17,440
Đây là cách nó hoạt động.

246
00:15:17,440 --> 00:15:21,441
Sau khi thiết lập bốn bit sửa lỗi đặc biệt đó, chúng tôi đặt bit thứ 0 đó sao cho

247
00:15:21,441 --> 00:15:25,540
tính chẵn lẻ của toàn bộ khối là chẵn, giống như kiểm tra tính chẵn lẻ thông thường.

248
00:15:25,540 --> 00:15:29,669
Bây giờ, nếu có một lỗi bit nào đó thì tính chẵn lẻ của toàn bộ khối sẽ chuyển thành số

249
00:15:29,669 --> 00:15:33,752
lẻ, nhưng dù sao thì chúng ta cũng sẽ phát hiện được điều đó nhờ bốn bước kiểm tra sửa

250
00:15:33,752 --> 00:15:33,940
lỗi.

251
00:15:33,940 --> 00:15:37,668
Tuy nhiên, nếu có hai lỗi thì tổng số chẵn lẻ sẽ chuyển về

252
00:15:37,668 --> 00:15:41,586
trạng thái chẵn, nhưng người nhận vẫn thấy rằng đã có ít nhất

253
00:15:41,586 --> 00:15:45,820
một số lỗi do những gì đang xảy ra với bốn lần kiểm tra chẵn lẻ đó.

254
00:15:45,820 --> 00:15:49,333
Vì vậy, nếu họ nhận thấy có sự chẵn lẻ về tổng thể, nhưng có điều gì đó khác 0

255
00:15:49,333 --> 00:15:52,980
xảy ra với các lần kiểm tra khác, thì điều đó cho họ biết rằng có ít nhất hai lỗi.

256
00:15:52,980 --> 00:15:54,420
Không phải là thông minh sao?

257
00:15:54,420 --> 00:15:58,326
Mặc dù chúng tôi không thể sửa các lỗi 2 bit đó, nhưng chỉ cần đưa bit 0

258
00:15:58,326 --> 00:16:02,340
khó chịu đó hoạt động trở lại, nó sẽ cho phép chúng tôi phát hiện ra chúng.

259
00:16:02,340 --> 00:16:06,540
Đây là mã khá chuẩn, nó được gọi là mã Hamming mở rộng.

260
00:16:06,540 --> 00:16:09,909
Về mặt kỹ thuật, bây giờ bạn đã có mô tả đầy đủ về chức

261
00:16:09,909 --> 00:16:13,580
năng của mã Hamming, ít nhất là đối với ví dụ về khối 16 bit.

262
00:16:13,580 --> 00:16:17,804
Nhưng tôi nghĩ bạn sẽ thấy hài lòng hơn khi kiểm tra sự hiểu biết của mình và củng cố

263
00:16:17,804 --> 00:16:21,980
mọi thứ cho đến thời điểm này bằng cách tự mình làm một ví dụ đầy đủ từ đầu đến cuối.

264
00:16:21,980 --> 00:16:25,100
Tuy nhiên, tôi sẽ cùng bạn giải quyết vấn đề này để bạn có thể tự kiểm tra.

265
00:16:25,100 --> 00:16:28,561
Để thiết lập một tin nhắn, cho dù đó là tin nhắn theo nghĩa đen

266
00:16:28,561 --> 00:16:32,076
mà bạn đang dịch theo không gian hay một số dữ liệu bạn muốn lưu

267
00:16:32,076 --> 00:16:35,700
trữ theo thời gian, bước đầu tiên là chia nó thành các phần 11 bit.

268
00:16:35,700 --> 00:16:40,340
Mỗi đoạn sẽ được đóng gói thành một khối 16 bit chống lỗi.

269
00:16:40,340 --> 00:16:43,740
Vì vậy, hãy lấy ví dụ này làm ví dụ và thực sự giải quyết nó.

270
00:16:43,740 --> 00:16:45,380
Hãy tiếp tục, thực sự làm điều đó!

271
00:16:45,380 --> 00:16:52,980
Hãy tạm dừng và thử ghép khối này lại với nhau.

272
00:16:52,980 --> 00:16:53,980
Được rồi, bạn sẵn sàng chưa?

273
00:16:53,980 --> 00:16:57,929
Hãy nhớ rằng, vị trí 0 cùng với các lũy thừa khác của 2 được

274
00:16:57,929 --> 00:17:01,814
dành cho nhiệm vụ sửa lỗi, vì vậy bạn bắt đầu bằng cách đặt

275
00:17:01,814 --> 00:17:05,700
các bit thông báo vào tất cả các vị trí còn lại theo thứ tự.

276
00:17:05,700 --> 00:17:09,563
Bạn cần nhóm này có tính chẵn lẻ, điều này đã có sẵn,

277
00:17:09,563 --> 00:17:13,140
vì vậy bạn nên đặt bit chẵn lẻ đó ở vị trí 1 là 0.

278
00:17:13,140 --> 00:17:19,260
Nhóm tiếp theo bắt đầu với số chẵn lẻ lẻ, vì vậy bạn nên đặt bit chẵn lẻ của nó là 1.

279
00:17:19,260 --> 00:17:22,055
Nhóm sau đó bắt đầu với số chẵn lẻ lẻ, vì vậy một

280
00:17:22,055 --> 00:17:24,740
lần nữa bạn phải đặt bit chẵn lẻ của nó thành 1.

281
00:17:24,740 --> 00:17:31,500
Và nhóm cuối cùng cũng có tính chẵn lẻ lẻ, nghĩa là chúng ta đặt bit đó ở vị trí 8 là 1.

282
00:17:31,500 --> 00:17:36,385
Và ở bước cuối cùng, toàn bộ khối bây giờ có tính chẵn lẻ chẵn,

283
00:17:36,385 --> 00:17:41,500
nghĩa là bạn có thể đặt số bit đó là 0, bit chẵn lẻ tổng thể, là 0.

284
00:17:41,500 --> 00:17:45,240
Vì vậy, khi khối này được gửi đi, tính chẵn lẻ của bốn tập

285
00:17:45,240 --> 00:17:48,980
hợp con đặc biệt và toàn bộ khối sẽ là số chẵn hoặc bằng 0.

286
00:17:48,980 --> 00:17:53,620
Trong phần thứ hai của bài tập, bạn hãy đóng vai người nhận.

287
00:17:53,620 --> 00:17:56,851
Tất nhiên, điều đó có nghĩa là bạn chưa biết thông điệp này là gì,

288
00:17:56,851 --> 00:18:00,180
có thể một số bạn đã ghi nhớ nó, nhưng hãy giả sử rằng bạn chưa biết.

289
00:18:00,180 --> 00:18:04,187
Những gì tôi sắp làm là thay đổi 0, 1 hoặc 2 bit trong

290
00:18:04,187 --> 00:18:08,340
khối đó và sau đó yêu cầu bạn tìm hiểu xem tôi đã làm gì.

291
00:18:08,340 --> 00:18:13,460
Vì vậy, một lần nữa, hãy tạm dừng và thử giải quyết nó.

292
00:18:13,460 --> 00:18:18,913
Được rồi, bây giờ bạn với tư cách là người nhận hãy kiểm tra

293
00:18:18,913 --> 00:18:24,366
nhóm chẵn lẻ đầu tiên và bạn có thể thấy rằng đó là số chẵn,

294
00:18:24,366 --> 00:18:29,820
vì vậy bất kỳ lỗi nào tồn tại sẽ phải nằm trong một cột chẵn.

295
00:18:29,820 --> 00:18:34,224
Kiểm tra tiếp theo cung cấp cho chúng tôi một số lẻ, cho chúng tôi

296
00:18:34,224 --> 00:18:38,760
biết rằng có ít nhất một lỗi và thu hẹp chúng tôi vào cột cụ thể này.

297
00:18:38,760 --> 00:18:42,900
Lần kiểm tra thứ ba là chẵn, cắt giảm các khả năng hơn nữa.

298
00:18:42,900 --> 00:18:47,244
Và lần kiểm tra chẵn lẻ cuối cùng rất kỳ quặc, cho chúng ta biết có lỗi ở đâu

299
00:18:47,244 --> 00:18:51,700
đó ở phía dưới, mà đến bây giờ chúng ta có thể thấy lỗi này phải ở vị trí số 10.

300
00:18:51,700 --> 00:18:55,070
Hơn nữa, tính chẵn lẻ của toàn bộ khối là số lẻ, khiến chúng

301
00:18:55,070 --> 00:18:58,220
tôi tin tưởng rằng chỉ có một lần lật chứ không phải hai.

302
00:18:58,220 --> 00:19:01,600
Nếu là ba hoặc nhiều hơn, tất cả cược sẽ bị hủy.

303
00:19:01,600 --> 00:19:06,385
Sau khi sửa bit số 10 đó, việc rút ra 11 bit không được sử dụng để sửa

304
00:19:06,385 --> 00:19:11,104
sẽ cho chúng ta phân đoạn có liên quan của thông báo gốc, nếu bạn tua

305
00:19:11,104 --> 00:19:16,160
lại và so sánh thì thực sự chính xác là những gì chúng ta đã bắt đầu ví dụ.

306
00:19:16,160 --> 00:19:20,027
Và bây giờ bạn đã biết cách thực hiện tất cả những điều này bằng tay, tôi muốn chỉ cho

307
00:19:20,027 --> 00:19:23,940
bạn cách bạn có thể thực hiện phần cốt lõi của tất cả logic này bằng một dòng mã Python.

308
00:19:23,940 --> 00:19:27,716
Bạn thấy đấy, điều tôi chưa nói với bạn là thuật toán này thực sự tinh tế đến

309
00:19:27,716 --> 00:19:31,493
mức nào, thật đơn giản để khiến một chiếc máy chỉ ra vị trí của một lỗi, cách

310
00:19:31,493 --> 00:19:35,415
chia tỷ lệ nó một cách có hệ thống và cách chúng ta có thể đóng khung tất cả các

311
00:19:35,415 --> 00:19:39,580
lỗi đó. đây là một thao tác đơn lẻ thay vì nhiều lần kiểm tra tính chẵn lẻ riêng biệt.

312
00:19:39,580 --> 00:19:39,580
Để hiểu ý tôi, hãy cùng tôi tham gia phần 2 nhé.

