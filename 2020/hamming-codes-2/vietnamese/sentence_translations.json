[
 {
  "input": "I'm assuming that everybody here is coming from part 1.",
  "translatedText": "Tôi cho rằng mọi người ở đây đều đến từ phần 1.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 0.0,
  "end": 2.56
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it.",
  "translatedText": "Chúng ta đang nói về mã Hamming, một cách để tạo ra một khối dữ liệu trong đó hầu hết các bit mang một thông điệp có ý nghĩa, trong khi một số bit khác hoạt động như một loại dự phòng, theo cách mà nếu bất kỳ bit nào bị đảo lộn, thì đó sẽ là một thông báo. bit hoặc bit dự phòng, bất kỳ thứ gì trong khối này, bộ thu sẽ có thể xác định rằng đã xảy ra lỗi và cách khắc phục.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.06,
  "end": 21.24
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error.",
  "translatedText": "Ý tưởng cơ bản được trình bày ở đó là cách sử dụng nhiều biện pháp kiểm tra chẵn lẻ để tìm kiếm nhị phân theo cách của bạn để tìm ra lỗi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 21.88,
  "end": 27.16
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible.",
  "translatedText": "Trong video đó, mục tiêu là làm cho mã Hamming có cảm giác thực tế và dễ khám phá lại nhất có thể.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 28.98,
  "end": 34.6
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are.",
  "translatedText": "Nhưng khi bạn bắt đầu nghĩ đến việc thực sự triển khai điều này, dù bằng phần mềm hay phần cứng, thì việc đóng khung đó thực sự có thể đánh giá thấp mức độ trang nhã thực sự của những mã này.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 35.18,
  "end": 43.46
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that.",
  "translatedText": "Bạn có thể nghĩ rằng mình cần phải viết một thuật toán theo dõi tất cả các vị trí lỗi có thể xảy ra và cắt nhóm đó làm đôi sau mỗi lần kiểm tra, nhưng thực tế thì cách này đơn giản hơn thế nhiều.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 43.92,
  "end": 53.48
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary.",
  "translatedText": "Nếu bạn đọc to câu trả lời cho bốn phép kiểm tra tính chẵn lẻ mà chúng tôi đã thực hiện trong video trước, tất cả đều là 1 và 0 thay vì có và không, thì nó sẽ chỉ ra vị trí của lỗi ở dạng nhị phân theo đúng nghĩa đen.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 53.94,
  "end": 64.08
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1.",
  "translatedText": "Ví dụ: số 7 trong hệ nhị phân trông giống như 0111, về cơ bản nó có nghĩa là 4 cộng 2 cộng 1.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 64.78,
  "end": 71.26
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last.",
  "translatedText": "Và hãy để ý xem vị trí số 7 nằm ở đâu, nó ảnh hưởng đến nhóm đầu tiên trong số các nhóm ngang bằng của chúng ta, nhóm thứ hai và nhóm thứ ba, nhưng không ảnh hưởng đến nhóm cuối cùng.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 72.54,
  "end": 81.74
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error.",
  "translatedText": "Vì vậy, việc đọc kết quả của bốn lần kiểm tra đó từ dưới lên trên thực sự sẽ chỉ ra vị trí của lỗi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 82.22,
  "end": 87.54
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple.",
  "translatedText": "Không có gì đặc biệt về ví dụ 7, nhìn chung nó hoạt động tốt và điều này làm cho logic triển khai toàn bộ sơ đồ trong phần cứng trở nên đơn giản đến kinh ngạc.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 88.32,
  "end": 95.82
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111.",
  "translatedText": "Bây giờ nếu bạn muốn biết tại sao điều kỳ diệu này lại xảy ra, hãy lấy 16 nhãn chỉ mục này cho các vị trí của chúng ta, nhưng thay vì viết chúng ở cơ số 10, hãy viết tất cả chúng ở dạng nhị phân, chạy từ 0000 đến 1111.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 97.24,
  "end": 109.88
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent.",
  "translatedText": "Khi chúng ta đặt các nhãn nhị phân này trở lại hộp của chúng, hãy để tôi nhấn mạnh rằng chúng khác biệt với dữ liệu thực sự được gửi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 110.56,
  "end": 117.8
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from.",
  "translatedText": "Chúng không gì khác hơn là một nhãn hiệu khái niệm để giúp bạn và tôi hiểu bốn nhóm ngang bằng đến từ đâu.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 118.32,
  "end": 123.5
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary.",
  "translatedText": "Sự sang trọng của việc mọi thứ chúng ta đang xem xét được mô tả ở dạng nhị phân có thể bị giảm bớt do sự nhầm lẫn khi mọi thứ chúng ta đang xem xét được mô tả ở dạng nhị phân.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 124.14,
  "end": 132.36
 },
 {
  "input": "It's worth it, though.",
  "translatedText": "Tuy nhiên, nó đáng giá.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.02,
  "end": 134.12
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1.",
  "translatedText": "Hãy tập trung sự chú ý của bạn vào phần cuối cùng của tất cả các nhãn này, sau đó đánh dấu các vị trí mà bit cuối cùng đó là 1.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 134.8,
  "end": 143.22
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1?",
  "translatedText": "Những gì chúng tôi nhận được là nhóm đầu tiên trong số bốn nhóm chẵn lẻ, có nghĩa là bạn có thể hiểu lần kiểm tra đầu tiên đó là hỏi, này, nếu có lỗi, bit cuối cùng ở vị trí của lỗi đó có phải là 1 không?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 144.24,
  "end": 155.74
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme.",
  "translatedText": "Tương tự, nếu bạn tập trung vào bit thứ hai đến bit cuối cùng và đánh dấu tất cả các vị trí có số 1, bạn sẽ có được nhóm chẵn lẻ thứ hai từ sơ đồ của chúng tôi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 158.2,
  "end": 166.16
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1?",
  "translatedText": "Nói cách khác, lần kiểm tra thứ hai đó đang hỏi, này, tôi lại nói, nếu có lỗi, bit thứ hai đến bit cuối cùng của vị trí đó có phải là 1 không?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 166.74,
  "end": 174.5
 },
 {
  "input": "And so on.",
  "translatedText": "Và như thế.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 175.76,
  "end": 176.9
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1.",
  "translatedText": "Kiểm tra tính chẵn lẻ thứ ba bao gồm mọi vị trí có bit thứ ba đến bit cuối cùng được bật và vị trí cuối cùng bao gồm tám vị trí cuối cùng, những vị trí có bit thứ tự cao nhất là 1.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 177.22,
  "end": 188.74
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary.",
  "translatedText": "Mọi điều chúng ta đã làm trước đó cũng giống như việc trả lời bốn câu hỏi này, những câu hỏi này cũng giống như việc đánh vần một vị trí trong hệ nhị phân.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 189.74,
  "end": 197.74
 },
 {
  "input": "I hope this makes two things clearer.",
  "translatedText": "Tôi hy vọng điều này làm cho hai điều rõ ràng hơn.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 199.62,
  "end": 201.48
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two.",
  "translatedText": "Đầu tiên là làm thế nào để khái quát hóa một cách có hệ thống các kích thước khối có lũy thừa lớn hơn bằng 2.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.04,
  "end": 206.46
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check.",
  "translatedText": "Nếu cần nhiều bit hơn để mô tả từng vị trí, chẳng hạn như sáu bit để mô tả 64 điểm, thì mỗi bit đó sẽ cung cấp cho bạn một trong các nhóm chẵn lẻ mà chúng ta cần kiểm tra.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 206.96,
  "end": 216.68
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar.",
  "translatedText": "Những ai đã xem trò chơi xếp hình trên bàn cờ mà tôi làm với Matt Parker có thể thấy điều này cực kỳ quen thuộc.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.4,
  "end": 223.18
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard.",
  "translatedText": "Đó là logic cốt lõi tương tự, nhưng giải quyết một vấn đề khác và được áp dụng cho bàn cờ 64 ô vuông.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 223.66,
  "end": 228.78
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8.",
  "translatedText": "Điều thứ hai tôi hy vọng điều này làm rõ là tại sao các bit chẵn lẻ của chúng ta lại nằm ở các vị trí lũy thừa của 2, ví dụ 1, 2, 4 và 8.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 229.88,
  "end": 237.32
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on.",
  "translatedText": "Đây là những vị trí mà biểu diễn nhị phân chỉ được bật một bit.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 238.0,
  "end": 243.0
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups.",
  "translatedText": "Điều đó có nghĩa là mỗi bit chẵn lẻ đó nằm bên trong một và chỉ một trong bốn nhóm chẵn lẻ.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.6,
  "end": 249.46
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups.",
  "translatedText": "Bạn cũng có thể thấy điều này trong các ví dụ lớn hơn, trong đó dù bạn có lớn đến đâu, mỗi bit chẵn lẻ chỉ chạm vào một trong các nhóm một cách thuận tiện.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 252.04,
  "end": 259.34
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code.",
  "translatedText": "Một khi bạn hiểu rằng việc kiểm tra tính chẵn lẻ mà chúng ta đã dành rất nhiều thời gian vào đó không gì khác hơn là một cách thông minh để đánh vần vị trí của một lỗi trong hệ nhị phân, khi đó chúng ta có thể rút ra mối liên hệ bằng một cách nghĩ khác về hamming. mã, một mã được cho là đơn giản và thanh lịch hơn rất nhiều và về cơ bản có thể được viết ra chỉ bằng một dòng mã.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.6,
  "end": 283.24
 },
 {
  "input": "It's based on the XOR function.",
  "translatedText": "Nó dựa trên hàm XOR.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 283.66,
  "end": 285.5
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or.",
  "translatedText": "XOR, dành cho những ai chưa biết, là viết tắt của độc quyền hoặc.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 286.94,
  "end": 290.22
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off.",
  "translatedText": "Khi bạn lấy XOR của hai bit, nó sẽ trả về 1 nếu một trong hai bit đó được bật, nhưng không trả về nếu cả hai bit được bật hoặc tắt.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 290.78,
  "end": 299.36
 },
 {
  "input": "Phrased differently, it's the parity of these two bits.",
  "translatedText": "Nói cách khác, đó là tính chẵn lẻ của hai bit này.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.1,
  "end": 302.98
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2.",
  "translatedText": "Là một người làm toán, tôi thích coi nó như phép cộng mod 2 hơn.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 303.54,
  "end": 306.76
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component.",
  "translatedText": "Chúng ta cũng thường nói về XOR của hai chuỗi bit khác nhau, về cơ bản thực hiện việc này theo từng thành phần.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 307.36,
  "end": 313.44
 },
 {
  "input": "It's like addition, but where you never carry.",
  "translatedText": "Nó giống như sự bổ sung, nhưng bạn không bao giờ mang theo.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 313.68,
  "end": 315.72
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2.",
  "translatedText": "Một lần nữa, những người thiên về toán học hơn có thể thích coi điều này như việc cộng hai vectơ và rút gọn mod 2.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 316.5,
  "end": 322.48
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood.",
  "translatedText": "Nếu bạn mở một số Python ngay bây giờ và áp dụng thao tác dấu mũ giữa hai số nguyên, thì đây chính là những gì nó đang làm nhưng đối với các biểu diễn bit của các số đó ở phần bên dưới.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 323.5,
  "end": 332.94
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop.",
  "translatedText": "Điểm mấu chốt đối với bạn và tôi là việc lấy XOR của nhiều chuỗi bit khác nhau thực sự là một cách để tính toán các bản nhại của một loạt các nhóm riêng biệt, giống như với các cột, tất cả trong một cú trượt.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 334.96,
  "end": 347.14
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation.",
  "translatedText": "Điều này mang lại cho chúng ta một cách khá thú vị để suy nghĩ về nhiều lần kiểm tra tính chẵn lẻ từ thuật toán mã Hamming của chúng ta khi tất cả được gói gọn lại thành một thao tác duy nhất.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 351.26,
  "end": 358.78
 },
 {
  "input": "Though at first glance it does look very different.",
  "translatedText": "Mặc dù thoạt nhìn nó trông rất khác.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 359.48,
  "end": 362.18
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR.",
  "translatedText": "Cụ thể là viết ra 16 vị trí trong hệ nhị phân, giống như chúng ta đã làm trước đây và bây giờ đánh dấu các vị trí mà bit thông báo được bật thành 1, sau đó thu thập các vị trí này thành một cột lớn và lấy XOR.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 362.82,
  "end": 377.1
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly.",
  "translatedText": "Bạn có thể đoán rằng kết quả là 4 bit nằm ở dưới cùng giống với 4 kiểm tra tính chẵn lẻ mà chúng ta đã biết và yêu thích, nhưng hãy dành chút thời gian để thực sự suy nghĩ chính xác lý do tại sao.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 379.26,
  "end": 389.2
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group.",
  "translatedText": "Ví dụ: cột cuối cùng này đang đếm tất cả các vị trí có bit cuối cùng là 1, nhưng chúng tôi chỉ giới hạn ở các vị trí được đánh dấu, do đó, nó đếm một cách hiệu quả số lượng vị trí được đánh dấu đến từ nhóm chẵn lẻ đầu tiên.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 392.22,
  "end": 405.76
 },
 {
  "input": "Does that make sense?",
  "translatedText": "Điều đó có ý nghĩa?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 406.24,
  "end": 406.8
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on.",
  "translatedText": "Tương tự, cột tiếp theo đếm số lượng vị trí trong nhóm chẵn lẻ thứ hai, các vị trí có bit thứ hai đến bit cuối cùng là 1 và cũng được đánh dấu, v. v.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 409.08,
  "end": 420.0
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing.",
  "translatedText": "Đó thực sự chỉ là một sự thay đổi nhỏ trong quan điểm về điều tương tự mà chúng tôi đang làm.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 420.26,
  "end": 423.96
 },
 {
  "input": "And so you know where it goes from here.",
  "translatedText": "Và vì vậy bạn biết nó sẽ đi đâu từ đây.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 427.76,
  "end": 429.6
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000.",
  "translatedText": "Người gửi chịu trách nhiệm chuyển đổi một số bit chẵn lẻ đặc biệt để đảm bảo tổng bằng 0000.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 430.0,
  "end": 436.56
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error.",
  "translatedText": "Bây giờ khi chúng ta đã có nó như thế này, điều này mang lại cho chúng ta một cách thực sự hay để suy nghĩ về lý do tại sao bốn bit kết quả ở phía dưới này trực tiếp đánh vần vị trí của một lỗi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 439.04,
  "end": 447.58
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1.",
  "translatedText": "Giả sử một số bit trong khối này được chuyển từ 0 sang 1.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 448.46,
  "end": 451.86
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error.",
  "translatedText": "Điều đó có nghĩa là vị trí của bit đó hiện sẽ được bao gồm trong tổng XOR, làm thay đổi tổng từ 0 thành thay vào đó là giá trị mới được đưa vào, vị trí của lỗi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 452.6,
  "end": 463.82
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0.",
  "translatedText": "Ít rõ ràng hơn một chút, điều tương tự cũng đúng nếu có lỗi thay đổi từ 1 thành 0.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 464.46,
  "end": 469.36
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0.",
  "translatedText": "Bạn thấy đấy, nếu bạn cộng một chuỗi bit lại với nhau hai lần, thì cũng giống như không có nó ở đó, về cơ bản là vì trong thế giới này 1 cộng 1 bằng 0.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 470.18,
  "end": 477.94
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it.",
  "translatedText": "Vì vậy, việc thêm một bản sao của vị trí này vào tổng số tiền có tác dụng tương tự như việc chúng ta di chuyển nó.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 478.92,
  "end": 484.3
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error.",
  "translatedText": "Và một lần nữa, hiệu ứng đó là kết quả tổng thể ở phía dưới ở đây cho biết vị trí của lỗi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 485.16,
  "end": 490.7
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end.",
  "translatedText": "Để minh họa mức độ tinh tế của điều này, hãy để tôi chỉ ra một dòng mã Python mà tôi đã tham chiếu trước đó, nó sẽ nắm bắt gần như toàn bộ logic ở đầu máy thu.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 493.04,
  "end": 501.44
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits.",
  "translatedText": "Chúng ta sẽ bắt đầu bằng cách tạo một mảng ngẫu nhiên gồm 16 số 1 và 0 để mô phỏng khối dữ liệu và tôi sẽ đặt tên cho nó là các bit, nhưng tất nhiên trong thực tế đây sẽ là thứ chúng tôi nhận được từ người gửi và thay vì ngẫu nhiên nó sẽ mang 11 bit dữ liệu cùng với 5 bit chẵn lẻ.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 502.08,
  "end": 517.4
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15.",
  "translatedText": "Nếu tôi gọi hàm enumerateBits, nhiệm vụ của nó là ghép từng bit đó lại với nhau bằng một chỉ mục tương ứng, trong trường hợp này là từ 0 đến 15.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 518.12,
  "end": 527.0
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15.",
  "translatedText": "Vì vậy, nếu sau đó chúng ta tạo một danh sách lặp lại tất cả các cặp này, các cặp trông giống i và sau đó chúng ta chỉ lấy ra giá trị i, chỉ số, thì điều đó không thú vị lắm, chúng ta chỉ lấy lại các chỉ số đó từ 0 đến 15.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 528.18,
  "end": 541.34
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on.",
  "translatedText": "Nhưng nếu chúng ta thêm vào điều kiện chỉ thực hiện điều này nếu bit, nghĩa là nếu bit đó là 1 chứ không phải 0, thì nó chỉ lấy ra các vị trí mà bit tương ứng được bật.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 541.68,
  "end": 552.66
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc.",
  "translatedText": "Trong trường hợp này, có vẻ như các vị trí đó là 0, 4, 6, 9, v. v.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 553.38,
  "end": 557.96
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together.",
  "translatedText": "Điều chúng tôi muốn là tập hợp tất cả các vị trí đó lại với nhau, vị trí của các bit được bật và sau đó XOR chúng lại với nhau.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 559.98,
  "end": 567.24
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions.",
  "translatedText": "Để thực hiện điều này bằng Python, trước tiên tôi hãy nhập một vài hàm hữu ích.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.18,
  "end": 573.22
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it.",
  "translatedText": "Bằng cách đó, chúng ta có thể gọi hàm less() trong danh sách này và sử dụng hàm XOR để giảm nó.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 573.9,
  "end": 578.7
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way.",
  "translatedText": "Về cơ bản, điều này sẽ xuyên suốt danh sách, mang theo XOR trong suốt quá trình.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.1,
  "end": 582.68
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere.",
  "translatedText": "Nếu muốn, bạn có thể viết rõ ràng hàm XOR đó mà không cần phải nhập nó từ bất kỳ đâu.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 584.8,
  "end": 589.44
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001.",
  "translatedText": "Vì vậy, hiện tại, có vẻ như nếu chúng ta thực hiện điều này trên khối 16 bit ngẫu nhiên, nó sẽ trả về 9, có biểu diễn nhị phân 1001.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 591.94,
  "end": 601.28
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0.",
  "translatedText": "Chúng tôi sẽ không làm điều đó ở đây, nhưng bạn có thể viết một hàm trong đó người gửi sử dụng biểu diễn nhị phân đó để đặt bốn bit chẵn lẻ nếu cần, cuối cùng đưa khối này về trạng thái chạy dòng mã này trên danh sách đầy đủ các bit trả về một số 0.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 601.98,
  "end": 615.46
 },
 {
  "input": "This would be considered a well-prepared block.",
  "translatedText": "Đây sẽ được coi là một khối được chuẩn bị tốt.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 616.08,
  "end": 618.2
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error.",
  "translatedText": "Điều thú vị là nếu chúng ta chuyển đổi bất kỳ bit nào trong danh sách này, mô phỏng một lỗi ngẫu nhiên do nhiễu, thì nếu bạn chạy cùng dòng mã này, nó sẽ in ra lỗi đó.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 619.88,
  "end": 630.22
 },
 {
  "input": "Isn't that neat?",
  "translatedText": "Không phải là gọn gàng sao?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 630.96,
  "end": 631.52
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any.",
  "translatedText": "Bạn có thể lấy khối này bất ngờ, chạy dòng đơn này trên đó và nó sẽ tự động đưa ra vị trí của lỗi hoặc số 0 nếu không có.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 631.82,
  "end": 641.06
 },
 {
  "input": "And there's nothing special about the size 16 here.",
  "translatedText": "Và cũng không có gì đặc biệt về size 16 ở đây.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 642.5,
  "end": 645.2
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits.",
  "translatedText": "Dòng mã tương tự sẽ hoạt động nếu bạn có một danh sách 256 bit.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 645.4,
  "end": 649.86
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction.",
  "translatedText": "Không cần phải nói, có nhiều mã hơn để viết ở đây, chẳng hạn như thực hiện kiểm tra tính chẵn lẻ meta để phát hiện lỗi 2 bit, nhưng ý tưởng là hầu như tất cả logic cốt lõi từ sơ đồ của chúng tôi đều giảm xuống một XOR duy nhất.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 651.88,
  "end": 663.76
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go.",
  "translatedText": "Bây giờ, tùy thuộc vào sự thoải mái của bạn với nhị phân, XOR và phần mềm nói chung, bạn có thể thấy quan điểm này hơi khó hiểu hoặc thanh lịch và đơn giản hơn nhiều đến mức bạn đang tự hỏi tại sao chúng ta không bắt đầu với nó ngay từ đầu. -đi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.12,
  "end": 678.42
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level.",
  "translatedText": "Nói một cách lỏng lẻo, phối cảnh kiểm tra tính chẵn lẻ sẽ dễ nghĩ đến hơn khi triển khai mã Hamming trong phần cứng một cách trực tiếp và phối cảnh XOR là dễ nghĩ đến nhất khi thực hiện nó trong phần mềm, từ cấp độ cao hơn.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 679.14,
  "end": 690.5
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles.",
  "translatedText": "Cách đầu tiên thực sự dễ thực hiện nhất bằng tay và tôi nghĩ nó thực hiện công việc tốt hơn khi thấm nhuần trực giác cốt lõi làm nền tảng cho tất cả những điều này, đó là thông tin cần thiết để xác định một lỗi duy nhất có liên quan đến nhật ký kích thước của khối , hay nói cách khác, nó tăng lên từng chút một khi kích thước khối tăng gấp đôi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 691.36,
  "end": 710.0
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need.",
  "translatedText": "Thực tế có liên quan ở đây là thông tin đó tương ứng trực tiếp với mức độ dư thừa mà chúng ta cần.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 711.02,
  "end": 716.06
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind.",
  "translatedText": "Đó thực sự là điều khiến hầu hết mọi người phải phản ứng tức thời khi lần đầu tiên họ nghĩ đến việc tạo ra một thông điệp có khả năng chống lại lỗi, trong đó việc sao chép toàn bộ thông điệp là bản năng đầu tiên hiện lên trong đầu bạn.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.66,
  "end": 726.54
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix.",
  "translatedText": "Và sau đó, nhân tiện, có một cách hoàn toàn khác mà đôi khi bạn thấy mã Hamming được trình bày, trong đó bạn nhân thông điệp với một ma trận lớn.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 727.5,
  "end": 734.0
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales.",
  "translatedText": "Điều này khá hay vì nó liên quan đến họ mã tuyến tính rộng hơn, nhưng tôi nghĩ điều đó hầu như không mang lại trực giác nào về nguồn gốc của nó hoặc quy mô của nó như thế nào.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 734.67,
  "end": 743.06
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size.",
  "translatedText": "Và nói về việc chia tỷ lệ, bạn có thể nhận thấy rằng hiệu quả của sơ đồ này chỉ trở nên tốt hơn khi chúng tôi tăng kích thước khối.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 745.2,
  "end": 751.16
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there.",
  "translatedText": "Ví dụ: chúng tôi thấy rằng với 256 bit, bạn chỉ sử dụng 3% dung lượng đó để dự phòng và nó sẽ ngày càng tốt hơn từ đó.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 755.0,
  "end": 762.66
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling.",
  "translatedText": "Khi số lượng bit chẵn lẻ tăng lên từng cái một, kích thước khối tiếp tục tăng gấp đôi.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 763.3,
  "end": 767.34
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits.",
  "translatedText": "Và nếu bạn coi điều đó đến mức cực đoan, bạn có thể có một khối với một triệu bit, trong đó bạn thực sự sẽ chơi 20 câu hỏi với các kiểm tra chẵn lẻ của mình và nó chỉ sử dụng 21 bit chẵn lẻ.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 769.0,
  "end": 780.02
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy.",
  "translatedText": "Và nếu bạn lùi lại để nghĩ về việc xem xét một triệu bit và tìm ra một lỗi duy nhất, điều đó thực sự khiến bạn cảm thấy điên rồ.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 780.74,
  "end": 787.06
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that.",
  "translatedText": "Tất nhiên, vấn đề là với khối lớn hơn, xác suất nhìn thấy nhiều hơn một hoặc hai bit lỗi sẽ tăng lên và mã Hamming không xử lý được bất kỳ điều gì ngoài điều đó.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 788.2,
  "end": 797.66
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high.",
  "translatedText": "Vì vậy, trong thực tế, điều bạn muốn là tìm kích thước phù hợp để xác suất xảy ra quá nhiều bit bị lật không quá cao.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 798.32,
  "end": 804.3
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored.",
  "translatedText": "Ngoài ra, trong thực tế, lỗi có xu hướng xảy ra theo từng đợt nhỏ, điều này sẽ làm hỏng hoàn toàn một khối đơn lẻ, do đó, một chiến thuật phổ biến để giúp dàn trải một loạt lỗi trên nhiều khối khác nhau là xen kẽ các khối đó, như thế này, trước khi chúng xuất hiện. gửi đi hoặc lưu trữ.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 806.6,
  "end": 820.98
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block.",
  "translatedText": "Sau đó, một lần nữa, phần lớn trong số này được hiển thị hoàn toàn bằng các mã hiện đại hơn, như thuật toán Reed-Solomon được sử dụng phổ biến hơn nhiều, xử lý các lỗi bùng phát một cách đặc biệt tốt và nó có thể được điều chỉnh để có khả năng phục hồi với số lượng lỗi lớn hơn trên mỗi khối.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 825.58,
  "end": 838.82
 },
 {
  "input": "But that's a topic for another time.",
  "translatedText": "Nhưng đó là một chủ đề cho một thời điểm khác.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.36,
  "end": 841.34
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was.",
  "translatedText": "Trong cuốn sách Nghệ thuật thực hiện khoa học và kỹ thuật, Hamming đã thẳng thắn một cách tuyệt vời về việc khám phá ra mật mã này của ông đã quanh co như thế nào.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 842.5,
  "end": 849.94
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this.",
  "translatedText": "Đầu tiên anh ấy thử tất cả các loại kế hoạch khác nhau liên quan đến việc tổ chức các bit thành các phần của mạng nhiều chiều hơn và những thứ kỳ lạ như thế này.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 850.62,
  "end": 857.78
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this?",
  "translatedText": "Ý tưởng rằng có thể sử dụng các biện pháp kiểm tra tính chẵn lẻ để thông đồng theo cách xác định vị trí của lỗi chỉ đến với Hamming khi anh ấy lùi lại sau một loạt các phân tích khác và hỏi, được rồi, cách hiệu quả nhất mà tôi có thể làm là gì có thể hình dung được về điều này?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 858.3,
  "end": 871.52
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today.",
  "translatedText": "Ông cũng thẳng thắn về tầm quan trọng của việc kiểm tra tính chẵn lẻ đã nằm trong tâm trí ông, điều này có lẽ ít phổ biến hơn vào những năm 1940 so với ngày nay.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 872.62,
  "end": 881.22
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind.",
  "translatedText": "Có khoảng nửa tá lần trong suốt cuốn sách này ông đề cập đến câu nói của Louis Pasteur, may mắn sẽ đến với một tâm trí đã chuẩn bị sẵn sàng.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 881.92,
  "end": 888.22
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate.",
  "translatedText": "Những ý tưởng thông minh thường có vẻ đơn giản khi nhìn lại, điều này khiến chúng dễ bị đánh giá thấp.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 889.32,
  "end": 894.3
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you.",
  "translatedText": "Hiện tại, hy vọng thực sự của tôi là các mã Hamming, hoặc ít nhất là khả năng có các mã như vậy, gần như hiển nhiên đối với bạn.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 894.96,
  "end": 901.3
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't.",
  "translatedText": "Nhưng bạn không nên tự lừa dối mình rằng chúng thực sự hiển nhiên, bởi vì chúng chắc chắn không phải vậy.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 901.66,
  "end": 906.82
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that.",
  "translatedText": "Một phần lý do khiến những ý tưởng thông minh có vẻ dễ dàng bị đánh lừa là vì chúng ta chỉ nhìn thấy kết quả cuối cùng, dọn dẹp những thứ lộn xộn, không bao giờ đề cập đến tất cả những bước rẽ sai lầm, đánh giá thấp tầm quan trọng của những khả năng có thể khám phá khi bắt đầu một vấn đề. quá trình giải quyết, tất cả điều đó.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 907.88,
  "end": 922.86
 },
 {
  "input": "But this is true in general.",
  "translatedText": "Nhưng điều này nói chung là đúng.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 923.82,
  "end": 924.9
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them.",
  "translatedText": "Tôi nghĩ đối với một số phát minh đặc biệt, còn có lý do thứ hai sâu xa hơn khiến chúng ta đánh giá thấp chúng.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 924.9,
  "end": 930.04
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory.",
  "translatedText": "Việc suy nghĩ về thông tin dưới dạng bit chỉ thực sự kết hợp thành một lý thuyết đầy đủ vào năm 1948, với bài báo chuyên đề về lý thuyết thông tin của Claude Shannon.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 930.84,
  "end": 938.64
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm.",
  "translatedText": "Điều này về cơ bản xảy ra đồng thời với thời điểm Hamming phát triển thuật toán của mình.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 939.28,
  "end": 942.54
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory.",
  "translatedText": "Theo một nghĩa nào đó, đây cũng chính là bài báo nền tảng đã chỉ ra rằng luôn có thể sửa lỗi hiệu quả, bất kể xác suất lật bit cao đến đâu, ít nhất là trên lý thuyết.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 943.3,
  "end": 952.9
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here.",
  "translatedText": "Nhân tiện, Shannon và Hamming chia sẻ một văn phòng ở Bell Labs, mặc dù làm việc trên những lĩnh vực rất khác nhau, điều này hầu như không có vẻ trùng hợp ở đây.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.7,
  "end": 961.16
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was.",
  "translatedText": "Nhiều thập kỷ trôi qua nhanh chóng, và ngày nay, nhiều người trong chúng ta quá đắm chìm trong việc suy nghĩ về các bit và thông tin đến mức chúng ta dễ dàng bỏ qua cách suy nghĩ này khác biệt như thế nào.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.38,
  "end": 972.34
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are.",
  "translatedText": "Trớ trêu thay, những ý tưởng định hình sâu sắc nhất cách suy nghĩ của thế hệ tương lai cuối cùng lại khiến thế hệ tương lai nhìn nhận nó đơn giản hơn thực tế.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 973.1,
  "end": 982.26
 }
]