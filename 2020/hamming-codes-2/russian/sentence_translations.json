[
 {
  "input": "I'm assuming that everybody here is coming from part 1.",
  "model": "nmt",
  "translatedText": "Я предполагаю, что все здесь пришли из первой части.",
  "time_range": [
   0.0,
   2.56
  ]
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it.",
  "model": "nmt",
  "translatedText": "Мы говорили о кодах Хэмминга, способе создания блока данных, в котором большинство битов несут значимое сообщение, а несколько других действуют как своего рода избыточность, таким образом, что если какой-либо бит переворачивается, либо сообщение бит или бит избыточности, что-либо в этом блоке, получатель сможет определить, что произошла ошибка и как ее исправить.",
  "time_range": [
   3.06,
   21.24
  ]
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error.",
  "model": "nmt",
  "translatedText": "Основная идея, представленная там, заключалась в том, как использовать несколько проверок четности для двоичного поиска пути к ошибке.",
  "time_range": [
   21.88,
   27.16
  ]
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible.",
  "model": "nmt",
  "translatedText": "Целью этого видео было сделать коды Хэмминга максимально удобными и доступными для повторного открытия.",
  "time_range": [
   28.980000000000008,
   34.6
  ]
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are.",
  "model": "nmt",
  "translatedText": "Но когда вы начинаете думать о реальной реализации этого, будь то в программном или аппаратном обеспечении, эта структура может на самом деле недооценивать, насколько элегантны эти коды на самом деле.",
  "time_range": [
   35.18,
   43.46
  ]
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that.",
  "model": "nmt",
  "translatedText": "Вы можете подумать, что вам нужно написать алгоритм, который отслеживает все возможные места ошибок и сокращает эту группу пополам при каждой проверке, но на самом деле это намного проще.",
  "time_range": [
   43.92,
   53.48
  ]
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary.",
  "model": "nmt",
  "translatedText": "Если вы зачитаете ответы на четыре проверки четности, которые мы проводили в последнем видео (все они представляют собой 1 и 0 вместо «да» и «нет»), то вы буквально определите положение ошибки в двоичном формате.",
  "time_range": [
   53.94,
   64.08
  ]
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1.",
  "model": "nmt",
  "translatedText": "Например, число 7 в двоичном формате выглядит как 0111, что, по сути, означает, что это 4 плюс 2 плюс 1.",
  "time_range": [
   64.78,
   71.26
  ]
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last.",
  "model": "nmt",
  "translatedText": "И обратите внимание, где находится позиция 7: она влияет и на первую из наших групп четности, и на вторую, и на третью, но не на последнюю.",
  "time_range": [
   72.54,
   81.74
  ]
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error.",
  "model": "nmt",
  "translatedText": "Таким образом, чтение результатов этих четырех проверок снизу вверх действительно определяет положение ошибки.",
  "time_range": [
   82.22,
   87.54
  ]
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple.",
  "model": "nmt",
  "translatedText": "В примере 7 нет ничего особенного, в целом он работает, и это делает логику аппаратной реализации всей схемы поразительно простой.",
  "time_range": [
   88.32,
   95.82
  ]
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111.",
  "model": "nmt",
  "translatedText": "Теперь, если вы хотите понять, почему происходит это волшебство, возьмите эти 16 индексных меток для наших позиций, но вместо того, чтобы записывать их в десятичной системе счисления, давайте запишем их все в двоичном формате, от 0000 до 1111.",
  "time_range": [
   97.24,
   109.88
  ]
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent.",
  "model": "nmt",
  "translatedText": "Размещая эти двоичные метки обратно в коробки, позвольте мне подчеркнуть, что они отличаются от фактически отправляемых данных.",
  "time_range": [
   110.55999999999999,
   117.8
  ]
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from.",
  "model": "nmt",
  "translatedText": "Это не что иное, как концептуальный ярлык, который поможет вам и мне понять, откуда взялись четыре группы паритета.",
  "time_range": [
   118.32,
   123.5
  ]
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary.",
  "model": "nmt",
  "translatedText": "Элегантность того, что все, на что мы смотрим, описывается в двоичном формате, возможно, подрывается путаницей, связанной с тем, что все, на что мы смотрим, описывается в двоичном формате.",
  "time_range": [
   124.14,
   132.36
  ]
 },
 {
  "input": "It's worth it, though.",
  "model": "nmt",
  "translatedText": "Однако оно того стоит.",
  "time_range": [
   133.02,
   134.12
  ]
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1.",
  "model": "nmt",
  "translatedText": "Сосредоточьте свое внимание только на последнем бите всех этих меток, а затем выделите позиции, где этот последний бит равен 1.",
  "time_range": [
   134.8,
   143.22
  ]
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1?",
  "model": "nmt",
  "translatedText": "То, что мы получаем, — это первая из наших четырех групп четности, что означает, что вы можете интерпретировать эту первую проверку как вопрос: «Эй, если есть ошибка, последний бит в позиции этой ошибки равен 1?",
  "time_range": [
   144.24,
   155.74
  ]
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme.",
  "model": "nmt",
  "translatedText": "» Аналогично, если вы сосредоточитесь на предпоследнем бите и выделите все позиции, где это 1, вы получите вторую группу четности из нашей схемы.",
  "time_range": [
   158.2,
   166.16
  ]
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1?",
  "model": "nmt",
  "translatedText": "Другими словами, вторая проверка спрашивает: «Эй, еще раз, если есть ошибка, является ли предпоследний бит этой позиции равным 1?",
  "time_range": [
   166.74,
   174.5
  ]
 },
 {
  "input": "And so on.",
  "model": "nmt",
  "translatedText": "» И так далее.",
  "time_range": [
   175.76,
   176.9
  ]
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1.",
  "model": "nmt",
  "translatedText": "Третья проверка четности охватывает каждую позицию, у которой включен третий до последнего бит, а последняя проверка охватывает последние восемь позиций, те, у которых старший бит равен 1.",
  "time_range": [
   177.22,
   188.74
  ]
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary.",
  "model": "nmt",
  "translatedText": "Все, что мы делали ранее, аналогично ответу на эти четыре вопроса, что, в свою очередь, равнозначно написанию позиции в двоичном формате.",
  "time_range": [
   189.74,
   197.74
  ]
 },
 {
  "input": "I hope this makes two things clearer.",
  "model": "nmt",
  "translatedText": "Надеюсь, это прояснит две вещи.",
  "time_range": [
   199.62,
   201.48
  ]
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two.",
  "model": "nmt",
  "translatedText": "Во-первых, как систематически обобщать размеры блоков, превышающие степени двойки.",
  "time_range": [
   202.04,
   206.46
  ]
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check.",
  "model": "nmt",
  "translatedText": "Если для описания каждой позиции требуется больше битов, например шесть битов для описания 64 точек, то каждый из этих битов дает вам одну из групп четности, которую нам нужно проверить.",
  "time_range": [
   206.96,
   216.68
  ]
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar.",
  "model": "nmt",
  "translatedText": "Те из вас, кто смотрел шахматную головоломку, которую я решал с Мэттом Паркером, возможно, найдут все это чрезвычайно знакомым.",
  "time_range": [
   218.4,
   223.18
  ]
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard.",
  "model": "nmt",
  "translatedText": "Это та же основная логика, но она решает другую задачу и применяется к шахматной доске с 64 клетками.",
  "time_range": [
   223.66,
   228.78
  ]
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8.",
  "model": "nmt",
  "translatedText": "Второе, что, я надеюсь, теперь проясняет, — почему наши биты четности находятся в позициях, соответствующих степеням двойки, например 1, 2, 4 и 8.",
  "time_range": [
   229.88,
   237.32
  ]
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on.",
  "model": "nmt",
  "translatedText": "Это позиции, в двоичном представлении которых включен только один бит.",
  "time_range": [
   238.0,
   243.0
  ]
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups.",
  "model": "nmt",
  "translatedText": "Это означает, что каждый из этих битов четности находится внутри одной и только одной из четырех групп четности.",
  "time_range": [
   243.6,
   249.46
  ]
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups.",
  "model": "nmt",
  "translatedText": "Вы также можете увидеть это на более крупных примерах, где независимо от того, насколько вы велики, каждый бит четности удобно касается только одной из групп.",
  "time_range": [
   252.04,
   259.34
  ]
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code.",
  "model": "nmt",
  "translatedText": "Как только вы поймете, что эти проверки четности, которым мы уделили так много времени, являются не чем иным, как умным способом определить положение ошибки в двоичном формате, тогда мы сможем установить связь с другим способом мышления о хэмминге. коды, которые, возможно, намного проще и элегантнее и которые можно записать с помощью одной строки кода.",
  "time_range": [
   265.6,
   283.24
  ]
 },
 {
  "input": "It's based on the XOR function.",
  "model": "nmt",
  "translatedText": "Он основан на функции XOR.",
  "time_range": [
   283.66,
   285.5
  ]
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or.",
  "model": "nmt",
  "translatedText": "XOR, для тех из вас, кто не знает, означает «исключающее или».",
  "time_range": [
   286.94,
   290.22
  ]
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off.",
  "model": "nmt",
  "translatedText": "Когда вы выполняете операцию XOR двух битов, она возвращает 1, если один из этих битов включен, но не если оба включены или выключены.",
  "time_range": [
   290.78,
   299.36
  ]
 },
 {
  "input": "Phrased differently, it's the parity of these two bits.",
  "model": "nmt",
  "translatedText": "Другими словами, это четность этих двух битов.",
  "time_range": [
   300.1,
   302.98
  ]
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2.",
  "model": "nmt",
  "translatedText": "Как математик, я предпочитаю думать об этом как о моде сложения 2.",
  "time_range": [
   303.54,
   306.76
  ]
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component.",
  "model": "nmt",
  "translatedText": "Мы также обычно говорим о XOR двух разных битовых строк, который, по сути, выполняет это компонент за компонентом.",
  "time_range": [
   307.36,
   313.44
  ]
 },
 {
  "input": "It's like addition, but where you never carry.",
  "model": "nmt",
  "translatedText": "Это как дополнение, но куда не понесешь.",
  "time_range": [
   313.68,
   315.72
  ]
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2.",
  "model": "nmt",
  "translatedText": "Опять же, более склонные к математике люди могут предпочесть думать об этом как о добавлении двух векторов и уменьшении модуля 2.",
  "time_range": [
   316.5,
   322.48
  ]
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood.",
  "model": "nmt",
  "translatedText": "Если вы прямо сейчас откроете какой-нибудь Python и примените операцию курсора между двумя целыми числами, это то, что он делает, но к битовым представлениям этих чисел под капотом.",
  "time_range": [
   323.5,
   332.94
  ]
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop.",
  "model": "nmt",
  "translatedText": "Ключевым моментом для нас с вами является то, что выполнение XOR множества различных битовых строк фактически является способом вычислить пародии на кучу отдельных групп, как это происходит со столбцами, одним махом.",
  "time_range": [
   334.96000000000004,
   347.14
  ]
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation.",
  "model": "nmt",
  "translatedText": "Это дает нам довольно привлекательный способ представить множественные проверки четности нашего алгоритма кода Хэмминга как объединенные в одну операцию.",
  "time_range": [
   351.26,
   358.78
  ]
 },
 {
  "input": "Though at first glance it does look very different.",
  "model": "nmt",
  "translatedText": "Хотя на первый взгляд все выглядит совсем иначе.",
  "time_range": [
   359.47999999999996,
   362.18
  ]
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR.",
  "model": "nmt",
  "translatedText": "Специально запишите 16 позиций в двоичном формате, как мы делали раньше, а теперь выделите позиции, где бит сообщения установлен на 1, а затем соберите эти позиции в один большой столбец и выполните XOR.",
  "time_range": [
   362.82,
   377.1
  ]
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly.",
  "model": "nmt",
  "translatedText": "Вы, вероятно, можете догадаться, что 4 бита, находящиеся внизу, в результате совпадают с 4 проверками четности, которые мы знаем и любим, но найдите время, чтобы подумать, почему именно.",
  "time_range": [
   379.26,
   389.2
  ]
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group.",
  "model": "nmt",
  "translatedText": "Например, в этом последнем столбце подсчитываются все позиции, последний бит которых равен 1, но мы уже ограничены только выделенными позициями, поэтому он эффективно подсчитывает, сколько выделенных позиций пришло из первой группы четности.",
  "time_range": [
   392.22,
   405.76
  ]
 },
 {
  "input": "Does that make sense?",
  "model": "nmt",
  "translatedText": "Имеет ли это смысл?",
  "time_range": [
   406.24,
   406.8
  ]
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on.",
  "model": "nmt",
  "translatedText": "Аналогично, в следующем столбце подсчитывается количество позиций во второй группе четности, позиций, предпоследний бит которых равен 1, которые также выделены и т. д.",
  "time_range": [
   409.08,
   420.0
  ]
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing.",
  "model": "nmt",
  "translatedText": "На самом деле это всего лишь небольшой сдвиг во взглядах на то же самое, что мы делаем.",
  "time_range": [
   420.26,
   423.96
  ]
 },
 {
  "input": "And so you know where it goes from here.",
  "model": "nmt",
  "translatedText": "Итак, вы знаете, куда это пойдет дальше.",
  "time_range": [
   427.76,
   429.6
  ]
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000.",
  "model": "nmt",
  "translatedText": "Отправитель отвечает за переключение некоторых специальных битов четности, чтобы убедиться, что сумма равна 0000.",
  "time_range": [
   430.0,
   435.72
  ]
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error.",
  "model": "nmt",
  "translatedText": "Теперь, когда у нас это получилось, это дает нам действительно хороший способ задуматься о том, почему эти четыре результирующих бита внизу непосредственно определяют положение ошибки.",
  "time_range": [
   435.72,
   447.58
  ]
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1.",
  "model": "nmt",
  "translatedText": "Допустим, какой-то бит в этом блоке переключается с 0 на 1.",
  "time_range": [
   448.46,
   451.86
  ]
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error.",
  "model": "nmt",
  "translatedText": "Это означает, что позиция этого бита теперь будет включена в общее исключающее ИЛИ, что изменит сумму с 0 на новое включенное значение, позицию ошибки.",
  "time_range": [
   452.6,
   463.82
  ]
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0.",
  "model": "nmt",
  "translatedText": "Чуть менее очевидно то же самое, если произошла ошибка, из-за которой 1 меняется на 0.",
  "time_range": [
   464.46,
   469.36
  ]
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0.",
  "model": "nmt",
  "translatedText": "Видите ли, если вы складываете битовую строку дважды, это то же самое, что ее вообще нет, потому что в этом мире 1 плюс 1 равняется 0.",
  "time_range": [
   470.18,
   477.58
  ]
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it.",
  "model": "nmt",
  "translatedText": "Таким образом, добавление копии этой позиции к общей сумме имеет тот же эффект, что и ее перемещение.",
  "time_range": [
   477.58,
   484.3
  ]
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error.",
  "model": "nmt",
  "translatedText": "И этот эффект, опять же, заключается в том, что общий результат внизу указывает положение ошибки.",
  "time_range": [
   485.16,
   490.7
  ]
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end.",
  "model": "nmt",
  "translatedText": "Чтобы проиллюстрировать, насколько это элегантно, позвольте мне показать одну строку кода Python, на которую я ссылался ранее, которая захватывает почти всю логику на стороне получателя.",
  "time_range": [
   493.03999999999996,
   501.44
  ]
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits.",
  "model": "nmt",
  "translatedText": "Мы начнем с создания случайного массива из 16 единиц и нулей для имитации блока данных, и я дам ему биты имени, но, конечно, на практике это будет то, что мы получаем от отправителя, и вместо будучи случайным, он будет нести 11 бит данных вместе с 5 битами четности.",
  "time_range": [
   502.08,
   517.0
  ]
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15.",
  "model": "nmt",
  "translatedText": "Если я вызываю функцию enumerateBits, она объединяет каждый из этих битов с соответствующим индексом, в данном случае от 0 до 15.",
  "time_range": [
   517.0,
   527.0
  ]
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15.",
  "model": "nmt",
  "translatedText": "Итак, если мы затем создадим список, который будет циклически перебирать все эти пары, пары, которые выглядят как i, а затем мы вытащим только значение i, только индекс, ну, это не так уж и интересно, мы просто вернем эти индексы от 0 до 15.",
  "time_range": [
   528.18,
   541.34
  ]
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on.",
  "model": "nmt",
  "translatedText": "Но если мы добавим условие делать это только в том случае, если бит, то есть, если этот бит равен 1, а не 0, то тогда будут выбраны только те позиции, где включен соответствующий бит.",
  "time_range": [
   541.68,
   552.66
  ]
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc.",
  "model": "nmt",
  "translatedText": "В данном случае это выглядит как позиции 0, 4, 6, 9 и т. д.",
  "time_range": [
   553.38,
   560.36
  ]
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together.",
  "model": "nmt",
  "translatedText": "Мы хотим собрать вместе все эти позиции, позиции включенных битов, а затем выполнить XOR их вместе.",
  "time_range": [
   560.72,
   567.24
  ]
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions.",
  "model": "nmt",
  "translatedText": "Чтобы сделать это в Python, позвольте мне сначала импортировать пару полезных функций.",
  "time_range": [
   569.18,
   573.22
  ]
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it.",
  "model": "nmt",
  "translatedText": "Таким образом, мы можем вызвать функцию уменьшения() для этого списка и использовать функцию XOR, чтобы уменьшить его.",
  "time_range": [
   573.9,
   578.7
  ]
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way.",
  "model": "nmt",
  "translatedText": "По сути, это проедает весь список, принимая по пути XOR.",
  "time_range": [
   579.1,
   582.68
  ]
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere.",
  "model": "nmt",
  "translatedText": "Если хотите, вы можете явно записать эту функцию XOR без необходимости импортировать ее откуда-либо.",
  "time_range": [
   584.8,
   589.44
  ]
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001.",
  "model": "nmt",
  "translatedText": "Итак, на данный момент похоже, что если мы сделаем это с нашим случайным блоком из 16 бит, он вернет 9, что имеет двоичное представление 1001.",
  "time_range": [
   591.94,
   601.28
  ]
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0.",
  "model": "nmt",
  "translatedText": "Мы не будем этого делать здесь, но вы можете написать функцию, в которой отправитель использует это двоичное представление для установки четырех битов четности по мере необходимости, в конечном итоге переводя этот блок в состояние, при котором выполнение этой строки кода для полного списка бит возвращает результат. 0.",
  "time_range": [
   601.98,
   615.46
  ]
 },
 {
  "input": "This would be considered a well-prepared block.",
  "model": "nmt",
  "translatedText": "Это будет считаться хорошо подготовленным блоком.",
  "time_range": [
   616.08,
   620.1
  ]
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error.",
  "model": "nmt",
  "translatedText": "Что круто, так это то, что если мы переключим любой из битов в этом списке, имитируя случайную ошибку из-за шума, то если вы запустите ту же строку кода, она выведет эту ошибку.",
  "time_range": [
   620.1,
   630.22
  ]
 },
 {
  "input": "Isn't that neat?",
  "model": "nmt",
  "translatedText": "Разве это не аккуратно?",
  "time_range": [
   630.96,
   631.52
  ]
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any.",
  "model": "nmt",
  "translatedText": "Вы можете получить этот блок из ниоткуда, запустить к нему эту единственную строку, и он автоматически выдаст позицию ошибки или 0, если ее не было.",
  "time_range": [
   631.82,
   641.06
  ]
 },
 {
  "input": "And there's nothing special about the size 16 here.",
  "model": "nmt",
  "translatedText": "И в 16 размере здесь нет ничего особенного.",
  "time_range": [
   642.5,
   644.84
  ]
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits.",
  "model": "nmt",
  "translatedText": "Та же самая строка кода будет работать, если у вас есть список, скажем, из 256 бит.",
  "time_range": [
   644.84,
   649.86
  ]
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction.",
  "model": "nmt",
  "translatedText": "Излишне говорить, что здесь нужно написать больше кода, например, выполнить мета-проверку четности для обнаружения 2-битных ошибок, но идея состоит в том, что почти вся основная логика нашей схемы сводится к одному сокращению XOR.",
  "time_range": [
   651.88,
   663.76
  ]
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go.",
  "model": "nmt",
  "translatedText": "Теперь, в зависимости от вашего опыта работы с двоичными файлами, операциями XOR и программным обеспечением в целом, вы можете найти эту точку зрения либо немного запутанной, либо настолько более элегантной и простой, что вы задаетесь вопросом, почему мы просто не начали с нее с самого начала. -идти.",
  "time_range": [
   666.12,
   678.42
  ]
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level.",
  "model": "nmt",
  "translatedText": "Грубо говоря, о перспективе множественной проверки четности легче думать при прямой реализации кодов Хэмминга в аппаратном обеспечении, а о перспективе XOR легче всего думать, когда она выполняется в программном обеспечении, на более высоком уровне.",
  "time_range": [
   679.14,
   690.5
  ]
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles.",
  "model": "nmt",
  "translatedText": "Первый проще всего сделать вручную, и я думаю, что он лучше справляется с задачей, прививая основную интуицию, лежащую в основе всего этого, а именно, что информация, необходимая для обнаружения единственной ошибки, связана с журналом размера блока. или, другими словами, он увеличивается по одному биту при увеличении размера блока вдвое.",
  "time_range": [
   691.36,
   710.0
  ]
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need.",
  "model": "nmt",
  "translatedText": "Важным фактом здесь является то, что эта информация напрямую соответствует тому, какая избыточность нам нужна.",
  "time_range": [
   711.02,
   716.06
  ]
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind.",
  "model": "nmt",
  "translatedText": "Именно это на самом деле противоречит коленному рефлексу большинства людей, когда они впервые задумываются о том, чтобы сделать сообщение устойчивым к ошибкам, когда обычно копирование всего сообщения является первым инстинктом, который приходит на ум.",
  "time_range": [
   716.66,
   726.54
  ]
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix.",
  "model": "nmt",
  "translatedText": "И, кстати, есть совершенно другой способ представления кодов Хэмминга: вы умножаете сообщение на одну большую матрицу.",
  "time_range": [
   727.5,
   734.0
  ]
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales.",
  "model": "nmt",
  "translatedText": "Это в некоторой степени приятно, потому что соотносит его с более широким семейством линейных кодов, но я думаю, что это почти не дает понимания того, откуда он взялся и как масштабируется.",
  "time_range": [
   734.67,
   743.06
  ]
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size.",
  "model": "nmt",
  "translatedText": "Говоря о масштабировании, вы можете заметить, что эффективность этой схемы становится только выше по мере увеличения размера блока.",
  "time_range": [
   745.2,
   751.16
  ]
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there.",
  "model": "nmt",
  "translatedText": "Например, мы увидели, что при 256 битах вы используете только 3% этого пространства для избыточности, и с этого момента ситуация становится все лучше.",
  "time_range": [
   755.0,
   762.66
  ]
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling.",
  "model": "nmt",
  "translatedText": "По мере того как количество битов четности увеличивается один за другим, размер блока продолжает удваиваться.",
  "time_range": [
   763.3,
   767.34
  ]
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits.",
  "model": "nmt",
  "translatedText": "А если довести это до крайности, то у вас может получиться блок, скажем, в миллион битов, в котором вы буквально будете разыгрывать 20 вопросов с проверками на четность, и он использует только 21 бит четности.",
  "time_range": [
   769.0,
   780.02
  ]
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy.",
  "model": "nmt",
  "translatedText": "И если вы сделаете шаг назад и подумаете о том, чтобы просмотреть миллион битов и найти единственную ошибку, это действительно покажется безумием.",
  "time_range": [
   780.74,
   787.06
  ]
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that.",
  "model": "nmt",
  "translatedText": "Проблема, конечно, в том, что при увеличении блока вероятность увидеть более одного или двух битовых ошибок возрастает, а коды Хэмминга ничего сверх этого не обрабатывают.",
  "time_range": [
   788.1999999999999,
   797.66
  ]
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high.",
  "model": "nmt",
  "translatedText": "Поэтому на практике вам нужно найти правильный размер, чтобы вероятность слишком большого количества битовых переворотов не была слишком высокой.",
  "time_range": [
   798.32,
   804.3
  ]
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored.",
  "model": "nmt",
  "translatedText": "Кроме того, на практике ошибки, как правило, возникают небольшими порциями, что может полностью разрушить один блок, поэтому одна из распространенных тактик, помогающих распределить пакет ошибок по множеству разных блоков, заключается в чередовании этих блоков, вот так, прежде чем они будут обработаны. отправлено или сохранено.",
  "time_range": [
   806.6,
   820.98
  ]
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block.",
  "model": "nmt",
  "translatedText": "Опять же, многое из этого становится совершенно спорным из-за более современных кодов, таких как гораздо более часто используемый алгоритм Рида-Соломона, который особенно хорошо обрабатывает пакетные ошибки и может быть настроен на устойчивость к большему количеству ошибок на блок.",
  "time_range": [
   825.58,
   838.82
  ]
 },
 {
  "input": "But that's a topic for another time.",
  "model": "nmt",
  "translatedText": "Но это тема для другого раза.",
  "time_range": [
   839.36,
   841.34
  ]
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was.",
  "model": "nmt",
  "translatedText": "В своей книге «Искусство заниматься наукой и инженерией» Хэмминг удивительно откровенно рассказывает о том, насколько запутанным было его открытие этого кода.",
  "time_range": [
   842.5,
   849.94
  ]
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this.",
  "model": "nmt",
  "translatedText": "Сначала он испробовал всевозможные схемы, включающие организацию битов в части многомерной решетки и подобные странные вещи.",
  "time_range": [
   850.62,
   857.78
  ]
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this?",
  "model": "nmt",
  "translatedText": "Идея о том, что можно заставить проверки четности сговориться таким образом, чтобы определить положение ошибки, пришла к Хэммингу только тогда, когда он отступил после множества других анализов и спросил: «Хорошо, что я могу наиболее эффективно? » возможно, речь идет об этом?",
  "time_range": [
   858.3,
   871.52
  ]
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today.",
  "model": "nmt",
  "translatedText": "Он также откровенно говорил о том, насколько важно, чтобы проверки паритета уже были у него на уме, что в 1940-х годах было бы гораздо менее распространенным явлением, чем сегодня.",
  "time_range": [
   872.62,
   881.22
  ]
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind.",
  "model": "nmt",
  "translatedText": "В этой книге он примерно полдюжины раз ссылается на цитату Луи Пастера: удача любит подготовленный ум.",
  "time_range": [
   881.92,
   888.22
  ]
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate.",
  "model": "nmt",
  "translatedText": "Оглядываясь назад, умные идеи часто кажутся обманчиво простыми, из-за чего их легко недооценить.",
  "time_range": [
   889.32,
   894.3
  ]
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you.",
  "model": "nmt",
  "translatedText": "Сейчас я искренне надеюсь, что коды Хэмминга или, по крайней мере, возможность существования таких кодов кажутся вам почти очевидными.",
  "time_range": [
   894.96,
   901.3
  ]
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't.",
  "model": "nmt",
  "translatedText": "Но не стоит обманывать себя, думая, что они на самом деле очевидны, потому что это определенно не так.",
  "time_range": [
   901.66,
   906.82
  ]
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that.",
  "model": "nmt",
  "translatedText": "Одна из причин того, что умные идеи кажутся обманчиво простыми, заключается в том, что мы всегда видим только конечный результат, убирая то, что было беспорядочным, никогда не упоминая обо всех неправильных поворотах, преуменьшая, насколько огромно пространство исследуемых возможностей в начале проблемы. процесс решения и все такое.",
  "time_range": [
   907.88,
   922.86
  ]
 },
 {
  "input": "But this is true in general.",
  "model": "nmt",
  "translatedText": "Но это правда в целом.",
  "time_range": [
   923.82,
   924.9
  ]
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them.",
  "model": "nmt",
  "translatedText": "Я думаю, что для некоторых особых изобретений существует вторая, более глубокая причина, по которой мы их недооцениваем.",
  "time_range": [
   924.9,
   930.04
  ]
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory.",
  "model": "nmt",
  "translatedText": "Представление об информации в терминах битов по-настоящему сформировалось в полноценную теорию только к 1948 году, когда появилась основополагающая статья Клода Шеннона по теории информации.",
  "time_range": [
   930.84,
   938.64
  ]
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm.",
  "model": "nmt",
  "translatedText": "По сути, это совпало с разработкой Хэммингом своего алгоритма.",
  "time_range": [
   939.28,
   942.54
  ]
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory.",
  "model": "nmt",
  "translatedText": "Это была та же основополагающая статья, которая в определенном смысле показала, что эффективное исправление ошибок всегда возможно, независимо от того, насколько высока вероятность переворота битов, по крайней мере теоретически.",
  "time_range": [
   943.3,
   952.9
  ]
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here.",
  "model": "nmt",
  "translatedText": "Шеннон и Хэмминг, кстати, делили офис в Bell Labs, несмотря на то, что работали над совершенно разными вещами, что вряд ли здесь кажется случайным.",
  "time_range": [
   953.7,
   961.16
  ]
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was.",
  "model": "nmt",
  "translatedText": "Перенесемся на несколько десятилетий вперед, и в наши дни многие из нас настолько погружены в размышления о битах и информации, что легко упустить из виду, насколько особенным был этот образ мышления.",
  "time_range": [
   962.38,
   972.34
  ]
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are.",
  "model": "nmt",
  "translatedText": "По иронии судьбы, идеи, которые наиболее глубоко формируют образ мышления будущего поколения, в конечном итоге будут казаться этому будущему поколению проще, чем они есть на самом деле.",
  "time_range": [
   973.1,
   982.26
  ]
 }
]