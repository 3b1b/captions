1
00:00:00,000 --> 00:00:05,492
Вы когда-нибудь задумывались, как можно поцарапать компакт-диск

2
00:00:05,492 --> 00:00:10,900
или DVD-диск и при этом воспроизвести все, что на нем хранится?

3
00:00:10,900 --> 00:00:15,275
Царапина действительно влияет на 1 и 0 на диске, поэтому он считывает

4
00:00:15,275 --> 00:00:19,712
данные, отличные от того, что было сохранено, но если он действительно

5
00:00:19,712 --> 00:00:24,150
не поцарапан, считанные биты декодируются точно в тот же файл, который

6
00:00:24,150 --> 00:00:28,400
был закодирован на нем. побитовая копия, несмотря на все эти ошибки.

7
00:00:28,400 --> 00:00:32,703
Существует целый ряд математических хитростей, которые позволяют нам хранить

8
00:00:32,703 --> 00:00:36,840
данные и, что не менее важно, передавать их устойчивым к ошибкам способом.

9
00:00:36,840 --> 00:00:42,480
Ну да ладно, на самом деле не нужно так уж много ума, чтобы придумать способ сделать это.

10
00:00:42,480 --> 00:00:46,881
Любой файл, будь то видео, звук или текст, какой-то код, изображение, что угодно,

11
00:00:46,881 --> 00:00:50,960
в конечном итоге представляет собой некую последовательность единиц и нулей.

12
00:00:50,960 --> 00:00:54,570
А простой стратегией исправления любого перевернутого

13
00:00:54,570 --> 00:00:57,780
бита было бы сохранение трех копий каждого бита.

14
00:00:57,780 --> 00:01:02,488
Тогда машина, читающая этот файл, сможет сравнить эти три

15
00:01:02,488 --> 00:01:07,440
копии и всегда брать лучшие 2 из 3, если есть несоответствие.

16
00:01:07,440 --> 00:01:11,560
Но это означает использование двух третей вашего пространства для резервирования.

17
00:01:11,560 --> 00:01:15,012
И даже в этом случае, несмотря на все это отведенное пространство, нет надежной

18
00:01:15,012 --> 00:01:18,120
гарантии того, что произойдет, если будет перевернуто более одного бита.

19
00:01:18,120 --> 00:01:21,403
Гораздо более интересный вопрос — как сделать так, чтобы можно

20
00:01:21,403 --> 00:01:24,740
было исправлять ошибки, занимая при этом как можно меньше места.

21
00:01:24,740 --> 00:01:28,719
Например, используя метод, который вы узнаете из этого видео, вы можете

22
00:01:28,719 --> 00:01:32,975
хранить свои данные в 256-битных блоках, где каждый блок использует 9 бит, 9!

23
00:01:32,975 --> 00:01:36,791
действовать как своего рода избыточность, а остальные 247 бит могут

24
00:01:36,791 --> 00:01:41,000
свободно переносить любое значимое сообщение или данные, которые вы хотите.

25
00:01:41,000 --> 00:01:44,917
И все равно будет так, что если какой-либо бит здесь будет перевернут,

26
00:01:44,917 --> 00:01:48,891
просто взглянув на этот блок и не более того, машина сможет определить,

27
00:01:48,891 --> 00:01:53,140
что произошла ошибка и точно где она была, чтобы она знала, как ее исправить.

28
00:01:53,140 --> 00:01:55,540
И, честно говоря, это похоже на волшебство.

29
00:01:55,540 --> 00:01:59,481
И для этой конкретной схемы, если два бита будут перевернуты, машина, по крайней

30
00:01:59,481 --> 00:02:03,180
мере, сможет обнаружить две ошибки, хотя и не будет знать, как их исправить.

31
00:02:03,180 --> 00:02:08,140
Чуть позже мы поговорим о том, как это масштабируется для блоков разных размеров.

32
00:02:08,140 --> 00:02:11,175
Методы, позволяющие исправлять подобные ошибки, вполне

33
00:02:11,175 --> 00:02:13,880
обоснованно называются кодами исправления ошибок.

34
00:02:13,880 --> 00:02:16,811
На протяжении большей части прошлого столетия эта область была

35
00:02:16,811 --> 00:02:19,882
действительно богатым источником удивительно глубокой математики,

36
00:02:19,882 --> 00:02:23,000
которая внедрялась в устройства, которые мы используем каждый день.

37
00:02:23,000 --> 00:02:26,120
Цель здесь — дать вам очень полное представление об

38
00:02:26,120 --> 00:02:29,660
одном из самых ранних примеров, известном как код Хэмминга.

39
00:02:29,660 --> 00:02:33,050
И, кстати, я думаю о структуре этого видео не столько для того, чтобы

40
00:02:33,050 --> 00:02:36,441
объяснить его как можно более прямо, сколько для того, чтобы побудить

41
00:02:36,441 --> 00:02:40,220
вас изобрести его самостоятельно, с небольшими мягкими указаниями здесь и там.

42
00:02:40,220 --> 00:02:42,455
Поэтому, когда вы почувствуете, что видите, к чему все идет в

43
00:02:42,455 --> 00:02:44,763
какой-то момент, воспользуйтесь моментом, чтобы сделать паузу и

44
00:02:44,763 --> 00:02:47,180
активно спрогнозировать, какой будет схема, прежде чем я вам скажу.

45
00:02:47,180 --> 00:02:51,477
Кроме того, если вы хотите, чтобы ваше понимание достигло аппаратного

46
00:02:51,477 --> 00:02:55,406
уровня, Бен Итер вместе с этим снял видео, показывающее, как на

47
00:02:55,406 --> 00:02:59,520
самом деле реализовать коды Хэмминга на макетах, что очень приятно.

48
00:02:59,520 --> 00:03:03,020
Вы должны знать, что коды Хэмминга не так широко используются, как более

49
00:03:03,020 --> 00:03:06,520
современные коды, такие как алгоритм Рида-Соломона, но есть определенная

50
00:03:06,520 --> 00:03:10,020
магия в контрасте между тем, насколько невыполнимой кажется эта задача в

51
00:03:10,020 --> 00:03:14,240
начале, и тем, насколько совершенно разумной она кажется однажды. вы узнаете о Хэмминге.

52
00:03:14,240 --> 00:03:17,034
Основной принцип исправления ошибок заключается в том, что

53
00:03:17,034 --> 00:03:19,686
в огромном пространстве всех возможных сообщений только

54
00:03:19,686 --> 00:03:22,860
некоторые подмножества будут считаться действительными сообщениями.

55
00:03:22,860 --> 00:03:26,454
В качестве аналогии подумайте о правильно написанных

56
00:03:26,454 --> 00:03:29,100
словах и неправильно написанных словах.

57
00:03:29,100 --> 00:03:33,635
Всякий раз, когда допустимое сообщение изменяется, получатель несет ответственность за

58
00:03:33,635 --> 00:03:37,858
исправление увиденного до ближайшего допустимого соседа, как это можно сделать с

59
00:03:37,858 --> 00:03:38,380
опечаткой.

60
00:03:38,380 --> 00:03:42,432
Однако создание конкретного алгоритма для эффективной

61
00:03:42,432 --> 00:03:47,160
классификации подобных сообщений требует определенной смекалки.

62
00:03:47,160 --> 00:03:50,461
История начинается в 1940-х годах, когда молодой Ричард Хэмминг работал в

63
00:03:50,461 --> 00:03:53,717
Bell Labs, и часть его работы заключалась в использовании очень большого

64
00:03:53,717 --> 00:03:57,420
дорогого компьютера с перфокартами, к которому у него был лишь ограниченный доступ.

65
00:03:57,420 --> 00:04:00,323
И программы, которые он продолжал реализовывать, продолжали давать

66
00:04:00,323 --> 00:04:03,140
сбой, потому что время от времени что-то считывалось неправильно.

67
00:04:03,140 --> 00:04:06,210
Разочарование было горнилом изобретений, и ему это настолько

68
00:04:06,210 --> 00:04:09,280
надоело, что он изобрел первый в мире код исправления ошибок.

69
00:04:09,280 --> 00:04:12,978
Существует множество различных способов создания кодов Хэмминга,

70
00:04:12,978 --> 00:04:16,620
но для начала мы рассмотрим их так, как о них думал сам Хэмминг.

71
00:04:16,620 --> 00:04:21,400
Давайте возьмем простой, но не слишком простой пример: блок из 16 бит.

72
00:04:21,400 --> 00:04:25,700
Пронумеруем позиции этих битов от 0 до 15.

73
00:04:25,700 --> 00:04:29,783
Фактические данные, которые мы хотим сохранить, будут состоять только из 12

74
00:04:29,783 --> 00:04:33,920
таких битов, а 4 позиции зарезервированы в качестве своего рода избыточности.

75
00:04:33,920 --> 00:04:37,103
Слово «избыточный» здесь не означает просто копирование: в конце концов,

76
00:04:37,103 --> 00:04:40,200
эти 4 бита не дают нам достаточно места для слепого копирования данных.

77
00:04:40,200 --> 00:04:44,525
Вместо этого они должны будут представлять собой гораздо более тонкую и умную

78
00:04:44,525 --> 00:04:48,740
избыточность, не добавляя никакой новой информации, но повышая устойчивость.

79
00:04:48,740 --> 00:04:52,526
Вы могли бы ожидать, что эти 4 специальных бита будут красиво упакованы вместе, может

80
00:04:52,526 --> 00:04:56,401
быть, в конце или что-то в этом роде, но, как вы увидите, расположение их в положениях,

81
00:04:56,401 --> 00:05:00,320
которые являются степенями 2, к концу позволяет получить что-то действительно элегантное.

82
00:05:00,320 --> 00:05:02,972
Это также может дать вам небольшую подсказку о том,

83
00:05:02,972 --> 00:05:05,420
как это масштабируется для более крупных блоков.

84
00:05:05,420 --> 00:05:09,968
Кроме того, технически это всего лишь 11 бит данных, вы обнаружите небольшой

85
00:05:09,968 --> 00:05:14,280
нюанс в том, что происходит в позиции 0, но пока не беспокойтесь об этом.

86
00:05:14,280 --> 00:05:18,128
Как и в любом алгоритме исправления ошибок, в нем участвуют два игрока:

87
00:05:18,128 --> 00:05:21,923
отправитель, который отвечает за установку этих 4 специальных битов, и

88
00:05:21,923 --> 00:05:26,360
получатель, который отвечает за выполнение некоторой проверки и исправление ошибок.

89
00:05:26,360 --> 00:05:29,329
Конечно, слова «отправитель» и «получатель» на самом деле относятся к

90
00:05:29,329 --> 00:05:32,341
машинам или программному обеспечению, выполняющим все проверки, а идея

91
00:05:32,341 --> 00:05:35,480
сообщения подразумевается очень широко, включая такие вещи, как хранилище.

92
00:05:35,480 --> 00:05:38,899
В конце концов, хранение данных — это то же самое, что отправка

93
00:05:38,899 --> 00:05:42,640
сообщения только из прошлого в будущее, а не из одного места в другое.

94
00:05:42,640 --> 00:05:46,113
Итак, установка такова, но прежде чем мы углубимся в нее, нам нужно

95
00:05:46,113 --> 00:05:49,637
поговорить о связанной идее, которая была свежа в голове Хэмминга во

96
00:05:49,637 --> 00:05:53,060
время его открытия, о методе, который позволяет обнаруживать любые

97
00:05:53,060 --> 00:05:57,300
однобитовые ошибки, но не исправлять их, известный в бизнесе как проверка паритета.

98
00:05:57,300 --> 00:06:01,200
Для проверки четности мы выделяем только один бит, за настройку которого

99
00:06:01,200 --> 00:06:04,940
отвечает отправитель, а остальные могут свободно переносить сообщение.

100
00:06:04,940 --> 00:06:08,551
Единственная задача этого специального бита — убедиться,

101
00:06:08,551 --> 00:06:12,100
что общее количество единиц в сообщении является четным.

102
00:06:12,100 --> 00:06:16,725
Например, сейчас общее количество единиц равно 7, это нечетно, поэтому отправителю

103
00:06:16,725 --> 00:06:20,960
необходимо перевернуть этот специальный бит на 1, чтобы сделать счет четным.

104
00:06:20,960 --> 00:06:23,929
Но если бы блок уже начинался с четного числа

105
00:06:23,929 --> 00:06:27,480
единиц, тогда этот специальный бит остался бы равным 0.

106
00:06:27,480 --> 00:06:32,843
Это довольно просто, обманчиво просто, но это невероятно элегантный способ выразить

107
00:06:32,843 --> 00:06:37,760
идею изменения в любом месте сообщения и отразить ее в одном бите информации.

108
00:06:37,760 --> 00:06:42,880
Обратите внимание: если какой-либо бит этого сообщения переворачивается с

109
00:06:42,880 --> 00:06:48,140
0 на 1 или с 1 на 0, общее количество единиц меняется с четного на нечетное.

110
00:06:48,140 --> 00:06:51,773
Итак, если вы получатель, посмотрите на это сообщение и увидите

111
00:06:51,773 --> 00:06:55,180
нечетное число единиц, вы можете точно знать, что произошла

112
00:06:55,180 --> 00:06:58,700
какая-то ошибка, даже если вы понятия не имеете, где она была.

113
00:06:58,700 --> 00:07:04,940
На жаргоне четное или нечетное количество единиц в группе битов называется ее четностью.

114
00:07:04,940 --> 00:07:08,150
Вы также можете использовать числа и сказать, что четность равна 0 или 1, что

115
00:07:08,150 --> 00:07:11,320
обычно более полезно, когда вы начинаете заниматься математикой с этой идеей.

116
00:07:11,320 --> 00:07:14,863
И этот специальный бит, который отправитель использует

117
00:07:14,863 --> 00:07:18,020
для контроля четности, называется битом четности.

118
00:07:18,020 --> 00:07:21,788
И на самом деле, нам должно быть ясно: если получатель видит нечетную четность,

119
00:07:21,788 --> 00:07:25,509
это не обязательно означает, что была только одна ошибка, могло быть 3 ошибки,

120
00:07:25,509 --> 00:07:29,560
или 5, или любое другое нечетное число, но он может знать это наверняка. что это не 0.

121
00:07:29,560 --> 00:07:34,124
С другой стороны, если бы было 2 ошибки или любое четное количество ошибок, итоговое

122
00:07:34,124 --> 00:07:38,795
количество единиц все равно было бы четным, поэтому получатель не может быть полностью

123
00:07:38,795 --> 00:07:43,360
уверен, что четное количество обязательно означает, что сообщение не содержит ошибок.

124
00:07:43,360 --> 00:07:46,509
Вы можете жаловаться, что сообщение, которое искажается всего

125
00:07:46,509 --> 00:07:49,760
лишь двумя битами, довольно слабое, и вы будете абсолютно правы.

126
00:07:49,760 --> 00:07:53,250
Однако имейте в виду, что не существует метода обнаружения или исправления

127
00:07:53,250 --> 00:07:56,555
ошибок, который мог бы дать вам 100% уверенность в том, что полученное

128
00:07:56,555 --> 00:07:59,720
вами сообщение является именно тем, которое намеревался отправитель.

129
00:07:59,720 --> 00:08:02,876
В конце концов, достаточное количество случайного шума всегда может превратить одно

130
00:08:02,876 --> 00:08:05,920
действительное сообщение в другое действительное сообщение по чистой случайности.

131
00:08:05,920 --> 00:08:10,816
Вместо этого цель состоит в том, чтобы придумать схему, устойчивую к определенному

132
00:08:10,816 --> 00:08:15,713
максимальному количеству ошибок, или, возможно, снизить вероятность такого ложного

133
00:08:15,713 --> 00:08:16,480
срабатывания.

134
00:08:16,480 --> 00:08:21,925
Сами по себе проверки четности довольно слабы, но, сведя идею изменения всего

135
00:08:21,925 --> 00:08:28,000
сообщения до одного бита, они дают нам мощный строительный блок для более сложных схем.

136
00:08:28,000 --> 00:08:31,748
Например, когда Хэмминг искал способ определить, где произошла ошибка, а не

137
00:08:31,748 --> 00:08:35,496
только то, что она произошла, его ключевой вывод заключался в том, что если

138
00:08:35,496 --> 00:08:39,491
вы примените некоторые проверки четности не ко всему сообщению, а к определенным

139
00:08:39,491 --> 00:08:43,289
тщательно выбранным подмножествам, вы можете спросить более уточненная серия

140
00:08:43,289 --> 00:08:46,840
вопросов, позволяющая определить местонахождение любой единичной ошибки.

141
00:08:46,840 --> 00:08:50,543
Общее ощущение немного похоже на игру из 20 вопросов, когда вы задаете

142
00:08:50,543 --> 00:08:54,300
вопросы «да» или «нет», которые делят пространство возможностей пополам.

143
00:08:54,300 --> 00:08:57,376
Например, предположим, что мы выполняем проверку четности

144
00:08:57,376 --> 00:09:00,400
только для этих 8 бит, всех позиций с нечетными номерами.

145
00:09:00,400 --> 00:09:04,889
Затем, если ошибка обнаружена, он дает приемнику немного больше информации о том,

146
00:09:04,889 --> 00:09:09,160
где именно находится ошибка, а именно, что она находится в нечетном положении.

147
00:09:09,160 --> 00:09:13,075
Если среди этих 8 бит не обнаружено ошибок, это либо означает,

148
00:09:13,075 --> 00:09:17,240
что ошибки вообще нет, либо она находится где-то в четных позициях.

149
00:09:17,240 --> 00:09:21,311
Вы можете подумать, что ограничение проверки четности половиной битов делает

150
00:09:21,311 --> 00:09:25,489
ее менее эффективной, но когда она выполняется в сочетании с другими правильно

151
00:09:25,489 --> 00:09:29,720
выбранными проверками, это, как ни странно, дает нам нечто гораздо более мощное.

152
00:09:29,720 --> 00:09:33,415
Помните, что для фактической настройки проверки четности необходимо

153
00:09:33,415 --> 00:09:37,600
выделить какой-то специальный бит, который контролирует четность всей группы.

154
00:09:37,600 --> 00:09:39,920
Здесь давайте просто выберем позицию 1.

155
00:09:39,920 --> 00:09:43,746
В показанном примере четность этих 8 бит в настоящее время нечетная, поэтому

156
00:09:43,746 --> 00:09:48,220
отправитель несет ответственность за переключение этого бита четности, и теперь он четный.

157
00:09:48,220 --> 00:09:51,040
Это только 1 из 4 проверок четности, которые мы проведем.

158
00:09:51,040 --> 00:09:54,084
Вторая проверка осуществляется среди 8 бит в правой половине

159
00:09:54,084 --> 00:09:56,880
сетки, по крайней мере, так, как мы ее нарисовали здесь.

160
00:09:56,880 --> 00:10:00,201
На этот раз мы могли бы использовать позицию 2 в качестве бита

161
00:10:00,201 --> 00:10:03,469
четности, так что эти 8 бит уже имеют четность, и отправитель

162
00:10:03,469 --> 00:10:07,160
может чувствовать себя хорошо, оставив этот бит номер 2 без изменений.

163
00:10:07,160 --> 00:10:11,613
Затем, на другом конце, если получатель проверит четность этой группы и обнаружит,

164
00:10:11,613 --> 00:10:15,960
что она нечетная, он узнает, что ошибка находится где-то среди этих 8 бит справа.

165
00:10:15,960 --> 00:10:21,260
В противном случае это означает, что либо ошибки нет, либо ошибка где-то в левой половине.

166
00:10:21,260 --> 00:10:24,029
Или я предполагаю, что ошибок могло быть две, но сейчас мы

167
00:10:24,029 --> 00:10:27,080
будем предполагать, что во всем блоке есть не более одной ошибки.

168
00:10:27,080 --> 00:10:29,160
Более того, все полностью ломается.

169
00:10:29,160 --> 00:10:32,520
Здесь, прежде чем мы рассмотрим следующие две проверки, подумайте, что

170
00:10:32,520 --> 00:10:35,880
позволяют нам делать первые две проверки, если рассматривать их вместе.

171
00:10:35,880 --> 00:10:40,240
Допустим, вы обнаружили ошибку среди нечетных столбцов и среди правой половины.

172
00:10:40,240 --> 00:10:43,940
Это обязательно означает, что ошибка находится где-то в последнем столбце.

173
00:10:43,940 --> 00:10:47,100
Если в нечетном столбце не было ошибки, но она была в правой

174
00:10:47,100 --> 00:10:50,520
половине, это означает, что она находится в предпоследнем столбце.

175
00:10:50,520 --> 00:10:53,463
Аналогично, если ошибка есть в нечетных столбцах, но не в

176
00:10:53,463 --> 00:10:56,560
правой половине, вы знаете, что она где-то во втором столбце.

177
00:10:56,560 --> 00:11:00,347
И если ни одна из этих двух проверок четности ничего не обнаружит, это означает,

178
00:11:00,347 --> 00:11:03,760
что единственное место, где может быть ошибка, — это самый левый столбец.

179
00:11:03,760 --> 00:11:06,480
Но это также может означать, что ошибки вообще нет.

180
00:11:06,480 --> 00:11:09,037
Это довольно расплывчатый способ сказать, что две

181
00:11:09,037 --> 00:11:11,800
проверки четности позволяют нам зафиксировать столбец.

182
00:11:11,800 --> 00:11:14,000
Отсюда вы, вероятно, можете догадаться, что будет дальше.

183
00:11:14,000 --> 00:11:16,240
Мы делаем в основном то же самое, но для строк.

184
00:11:16,240 --> 00:11:18,616
Будет произведена проверка четности нечетных строк

185
00:11:18,616 --> 00:11:21,040
с использованием позиции 4 в качестве бита четности.

186
00:11:21,040 --> 00:11:26,480
Итак, в этом примере эта группа уже имеет четность, поэтому бит 4 будет установлен в 0.

187
00:11:26,480 --> 00:11:29,230
И, наконец, в двух нижних строках выполняется проверка

188
00:11:29,230 --> 00:11:32,280
четности с использованием позиции 8 в качестве бита четности.

189
00:11:32,280 --> 00:11:35,060
В этом случае похоже, что отправителю необходимо

190
00:11:35,060 --> 00:11:37,840
включить бит 8, чтобы обеспечить четность группе.

191
00:11:37,840 --> 00:11:40,566
Так же, как первые две проверки позволяют нам закрепить

192
00:11:40,566 --> 00:11:43,000
столбец, следующие две позволяют закрепить строку.

193
00:11:43,000 --> 00:11:46,204
В качестве примера представьте, что во время передачи

194
00:11:46,204 --> 00:11:48,400
возникла ошибка, скажем, в позиции 3.

195
00:11:48,400 --> 00:11:52,190
Ну, это влияет на первую группу четности, а также влияет на вторую группу

196
00:11:52,190 --> 00:11:56,340
четности, поэтому получатель знает, что где-то в этом правом столбце есть ошибка.

197
00:11:56,340 --> 00:12:01,380
Но это не влияет на третью группу и не влияет на четвертую группу.

198
00:12:01,380 --> 00:12:05,020
И это позволяет получателю точно определить ошибку до первой строки,

199
00:12:05,020 --> 00:12:08,660
что обязательно означает позицию 3, чтобы они могли исправить ошибку.

200
00:12:08,660 --> 00:12:11,546
Возможно, вам понравится потратить время на то, чтобы убедить себя в

201
00:12:11,546 --> 00:12:14,391
том, что ответы на эти четыре вопроса действительно всегда позволят

202
00:12:14,391 --> 00:12:17,320
вам определить конкретное место, независимо от того, где оно окажется.

203
00:12:17,320 --> 00:12:20,451
На самом деле, самые проницательные из вас могут даже

204
00:12:20,451 --> 00:12:23,640
заметить связь между этими вопросами и двоичным счетом.

205
00:12:23,640 --> 00:12:27,050
А если да, то еще раз позвольте мне подчеркнуть, сделать

206
00:12:27,050 --> 00:12:30,880
паузу, попытаться самому уловить связь, прежде чем я ее испорчу.

207
00:12:30,880 --> 00:12:33,471
Если вам интересно, что произойдет, если будет

208
00:12:33,471 --> 00:12:36,560
затронут сам бит четности, вы можете просто попробовать.

209
00:12:36,560 --> 00:12:41,683
Найдите минутку и подумайте, как можно отследить любую ошибку среди этих четырех

210
00:12:41,683 --> 00:12:46,870
специальных битов, как и любую другую, с помощью одной и той же группы из четырех

211
00:12:46,870 --> 00:12:47,440
вопросов.

212
00:12:47,440 --> 00:12:50,583
На самом деле это не имеет значения, поскольку, в конце концов, мы хотим

213
00:12:50,583 --> 00:12:53,640
защитить биты сообщения, а биты исправления ошибок просто продолжаются.

214
00:12:53,640 --> 00:12:56,222
Но защита и этих частей также является чем-то, что

215
00:12:56,222 --> 00:12:59,260
естественным образом выпадает из схемы как побочный продукт.

216
00:12:59,260 --> 00:13:02,380
Вам также может понравиться предвидеть, как это масштабируется.

217
00:13:02,380 --> 00:13:06,909
Если бы мы использовали блок размером 256 бит, например, чтобы

218
00:13:06,909 --> 00:13:11,150
определить местоположение, вам нужно всего восемь вопросов

219
00:13:11,150 --> 00:13:15,680
«да» или «нет» для двоичного поиска пути к определенному месту.

220
00:13:15,680 --> 00:13:19,510
И помните, каждый вопрос требует отказа только от одного

221
00:13:19,510 --> 00:13:23,340
бита, чтобы установить соответствующую проверку четности.

222
00:13:23,340 --> 00:13:26,466
Некоторые из вас, возможно, уже видели это, но позже мы поговорим о

223
00:13:26,466 --> 00:13:29,960
систематическом способе узнать, что это за вопросы, всего за минуту или две.

224
00:13:29,960 --> 00:13:32,000
Надеюсь, этого эскиза будет достаточно, чтобы

225
00:13:32,000 --> 00:13:34,440
оценить эффективность того, что мы здесь разрабатываем.

226
00:13:34,440 --> 00:13:38,030
Первое, за исключением этих восьми выделенных битов четности, может быть

227
00:13:38,030 --> 00:13:41,720
любым, каким вы хотите, неся любое сообщение или данные, которые вы хотите.

228
00:13:41,720 --> 00:13:47,997
8 бит избыточны в том смысле, что они полностью определяются остальной частью сообщения,

229
00:13:47,997 --> 00:13:53,640
но это гораздо более разумный способ, чем простое копирование сообщения целиком.

230
00:13:53,640 --> 00:13:56,408
И все же, приложив так мало усилий, вы сможете

231
00:13:56,408 --> 00:13:59,000
выявить и исправить любую ошибку в один бит.

232
00:13:59,000 --> 00:14:00,400
Ну, почти.

233
00:14:00,400 --> 00:14:04,849
Итак, единственная проблема здесь заключается в том, что если ни одна из четырех

234
00:14:04,849 --> 00:14:09,080
проверок четности не обнаруживает ошибку, а это означает, что все специально

235
00:14:09,080 --> 00:14:13,420
выбранные подмножества 8 бит имеют четность, как и предполагал отправитель, то

236
00:14:13,420 --> 00:14:17,760
это либо означает, что ошибки вообще не было. , или это сузит нас до позиции 0.

237
00:14:17,760 --> 00:14:21,694
Видите ли, с четырьмя вопросами «да» или «нет» у нас есть 16 возможных

238
00:14:21,694 --> 00:14:25,407
результатов для наших проверок на четность, и поначалу это кажется

239
00:14:25,407 --> 00:14:29,065
идеальным для точного определения 1 из 16 позиций в блоке, но вам

240
00:14:29,065 --> 00:14:33,000
также необходимо сообщить 17-й результат, отсутствие ошибки. состояние.

241
00:14:33,000 --> 00:14:37,860
Решение здесь на самом деле довольно простое: просто забудьте полностью об этом 0-м бите.

242
00:14:37,860 --> 00:14:41,142
Поэтому, когда мы выполняем четыре проверки четности и видим,

243
00:14:41,142 --> 00:14:44,320
что все они четные, это однозначно означает, что ошибки нет.

244
00:14:44,320 --> 00:14:49,113
Это означает, что вместо работы с 16-битным блоком мы работаем с 15-битным блоком,

245
00:14:49,113 --> 00:14:54,080
где 11 бит свободны для передачи сообщения, а 4 из них предназначены для избыточности.

246
00:14:54,080 --> 00:14:59,400
И теперь у нас есть то, что люди в бизнесе называют кодом Хэмминга 15-11.

247
00:14:59,400 --> 00:15:04,112
Тем не менее, приятно иметь размер блока, равный чистой степени 2, и есть умный способ

248
00:15:04,112 --> 00:15:08,880
сохранить этот 0-й бит и заставить его выполнять за нас небольшую дополнительную работу.

249
00:15:08,880 --> 00:15:12,803
Если мы используем его в качестве бита четности во всем блоке, это позволяет

250
00:15:12,803 --> 00:15:16,320
нам обнаруживать 2-битные ошибки, даже если мы не можем их исправить.

251
00:15:16,320 --> 00:15:17,440
Вот как это работает.

252
00:15:17,440 --> 00:15:21,443
После установки этих четырех специальных битов, исправляющих ошибки, мы устанавливаем

253
00:15:21,443 --> 00:15:25,540
этот 0-й бит, чтобы четность всего блока была четной, как при обычной проверке четности.

254
00:15:25,540 --> 00:15:29,588
Теперь, если есть ошибка в один бит, то четность полного блока переключается на

255
00:15:29,588 --> 00:15:33,940
нечетную, но мы все равно уловим это благодаря четырем проверкам, исправляющим ошибки.

256
00:15:33,940 --> 00:15:37,978
Однако, если есть две ошибки, то общая четность снова станет четной,

257
00:15:37,978 --> 00:15:42,074
но получатель все равно увидит, что произошла хотя бы какая-то ошибка

258
00:15:42,074 --> 00:15:45,820
из-за того, что происходит с этими четырьмя проверками четности.

259
00:15:45,820 --> 00:15:49,177
Поэтому, если они заметят в целом четность, но с другими проверками

260
00:15:49,177 --> 00:15:52,980
происходит что-то ненулевое, это говорит им, что было как минимум две ошибки.

261
00:15:52,980 --> 00:15:54,420
Разве это не умно?

262
00:15:54,420 --> 00:15:58,217
Несмотря на то, что мы не можем исправить эти 2-битные ошибки, просто

263
00:15:58,217 --> 00:16:02,340
вернув в работу этот маленький надоедливый 0-й бит, мы сможем их обнаружить.

264
00:16:02,340 --> 00:16:06,540
Это довольно стандартный код, известный как расширенный код Хэмминга.

265
00:16:06,540 --> 00:16:09,978
Технически говоря, теперь у вас есть полное описание того, что

266
00:16:09,978 --> 00:16:13,580
делает код Хэмминга, по крайней мере, на примере 16-битного блока.

267
00:16:13,580 --> 00:16:17,724
Но я думаю, вам будет приятнее проверить свое понимание и закрепить все до

268
00:16:17,724 --> 00:16:21,980
этого момента, выполнив один полный пример от начала до конца самостоятельно.

269
00:16:21,980 --> 00:16:25,100
Я пройду через это вместе с вами, чтобы вы могли проверить себя.

270
00:16:25,100 --> 00:16:28,406
Чтобы настроить сообщение, будь то буквальное сообщение, которое вы

271
00:16:28,406 --> 00:16:31,712
транслируете в пространстве, или какие-то данные, которые вы хотите

272
00:16:31,712 --> 00:16:35,700
сохранить во времени, первым шагом является разделение его на 11-битные фрагменты.

273
00:16:35,700 --> 00:16:40,340
Каждый фрагмент будет упакован в устойчивый к ошибкам 16-битный блок.

274
00:16:40,340 --> 00:16:43,740
Итак, давайте возьмем это в качестве примера и на самом деле разберемся.

275
00:16:43,740 --> 00:16:45,380
Давай, действительно сделай это!

276
00:16:45,380 --> 00:16:52,980
Давайте остановимся и попробуем собрать этот блок.

277
00:16:52,980 --> 00:16:53,980
Хорошо, ты готов?

278
00:16:53,980 --> 00:16:57,571
Помните, что позиция 0 вместе с другими степенями двойки

279
00:16:57,571 --> 00:17:01,415
зарезервирована для исправления ошибок, поэтому вы начинаете

280
00:17:01,415 --> 00:17:05,700
с размещения битов сообщения во всех оставшихся позициях по порядку.

281
00:17:05,700 --> 00:17:09,393
Вам нужно, чтобы эта группа имела четную четность, которая уже есть,

282
00:17:09,393 --> 00:17:13,140
поэтому вам следует установить этот бит четности в позиции 1 равным 0.

283
00:17:13,140 --> 00:17:15,996
Следующая группа начинается с нечетной четности,

284
00:17:15,996 --> 00:17:19,260
поэтому вам следует установить ее бит четности равным 1.

285
00:17:19,260 --> 00:17:21,769
Следующая группа начинается с нечетной четности,

286
00:17:21,769 --> 00:17:24,740
поэтому вам снова следует установить ее бит четности на 1.

287
00:17:24,740 --> 00:17:28,152
И последняя группа также имеет нечетную четность, то

288
00:17:28,152 --> 00:17:31,500
есть мы устанавливаем этот бит в позиции 8 равным 1.

289
00:17:31,500 --> 00:17:36,191
И затем, в качестве последнего шага, полный блок теперь имеет четность, что

290
00:17:36,191 --> 00:17:41,500
означает, что вы можете установить этот бит с номером 0, общий бит четности, равным 0.

291
00:17:41,500 --> 00:17:44,966
Таким образом, при отправке этого блока четность четырех

292
00:17:44,966 --> 00:17:48,980
специальных подмножеств и блока в целом будет четной или равной 0.

293
00:17:48,980 --> 00:17:53,620
Во второй части упражнения давайте попросим вас сыграть роль получателя.

294
00:17:53,620 --> 00:17:56,960
Конечно, это будет означать, что вы еще не знаете, что это за сообщение, возможно,

295
00:17:56,960 --> 00:18:00,180
некоторые из вас его запомнили, но давайте предположим, что вы этого не сделали.

296
00:18:00,180 --> 00:18:04,128
Что я собираюсь сделать, так это изменить 0, 1 или 2 бита в

297
00:18:04,128 --> 00:18:08,340
этом блоке, а затем попросить вас выяснить, что именно я сделал.

298
00:18:08,340 --> 00:18:13,460
Итак, еще раз сделайте паузу и попробуйте разобраться.

299
00:18:13,460 --> 00:18:21,640
Хорошо, теперь вы, как получатель, проверяете первую группу четности и видите,

300
00:18:21,640 --> 00:18:29,820
что она четная, поэтому любая существующая ошибка должна быть в четном столбце.

301
00:18:29,820 --> 00:18:34,350
Следующая проверка дает нам нечетное число, сообщающее нам обоим, что есть

302
00:18:34,350 --> 00:18:38,760
по крайней мере одна ошибка, и сужающее нас до этого конкретного столбца.

303
00:18:38,760 --> 00:18:42,900
Третья проверка четная, еще больше сокращая возможности.

304
00:18:42,900 --> 00:18:47,101
И последняя проверка четности является нечетной и говорит нам, что где-то

305
00:18:47,101 --> 00:18:51,700
внизу есть ошибка, которая, как мы теперь видим, должна быть на позиции номер 10.

306
00:18:51,700 --> 00:18:54,991
Более того, четность всего блока нечетная, что дает

307
00:18:54,991 --> 00:18:58,220
нам уверенность в том, что был один флип, а не два.

308
00:18:58,220 --> 00:19:01,600
Если их три или больше, все ставки аннулируются.

309
00:19:01,600 --> 00:19:06,320
После исправления этого бита номер 10 извлечение 11 бит, которые не использовались

310
00:19:06,320 --> 00:19:11,155
для исправления, дает нам соответствующий сегмент исходного сообщения, который, если

311
00:19:11,155 --> 00:19:16,160
перемотать назад и сравнить, действительно является именно тем, с чего мы начали пример.

312
00:19:16,160 --> 00:19:20,026
И теперь, когда вы знаете, как делать все это вручную, я хотел бы показать вам, как

313
00:19:20,026 --> 00:19:23,940
можно реализовать основную часть всей этой логики с помощью одной строки кода Python.

314
00:19:23,940 --> 00:19:27,713
Видите ли, я еще не рассказал вам, насколько на самом деле элегантен

315
00:19:27,713 --> 00:19:31,650
этот алгоритм, насколько просто заставить машину указывать на положение

316
00:19:31,650 --> 00:19:35,752
ошибки, как ее систематически масштабировать и как мы можем сформулировать

317
00:19:35,752 --> 00:19:39,580
все это как одна операция, а не несколько отдельных проверок четности.

318
00:19:39,580 --> 00:19:39,580
Чтобы понять, что я имею в виду, присоединяйтесь ко мне во второй части.

