1
00:00:03,620 --> 00:00:06,885
Вы когда-нибудь задумывались, как можно поцарапать компакт-диск 

2
00:00:06,885 --> 00:00:10,100
или DVD-диск и при этом воспроизвести все, что на нем хранится?

3
00:00:10,900 --> 00:00:15,507
Царапина действительно влияет на 1 и 0 на диске, поэтому он считывает данные, 

4
00:00:15,507 --> 00:00:20,056
отличные от того, что было сохранено, но если он действительно не поцарапан, 

5
00:00:20,056 --> 00:00:24,840
считанные биты декодируются точно в тот же файл, который был закодирован на нем. 

6
00:00:24,840 --> 00:00:27,440
побитовая копия, несмотря на все эти ошибки.

7
00:00:27,440 --> 00:00:32,487
Существует целый ряд математических хитростей, которые позволяют нам хранить данные и, 

8
00:00:32,487 --> 00:00:36,200
что не менее важно, передавать их устойчивым к ошибкам способом.

9
00:00:36,200 --> 00:00:40,880
Ну да ладно, на самом деле не нужно так уж много ума, чтобы придумать способ сделать это.

10
00:00:40,880 --> 00:00:45,810
Любой файл, будь то видео, звук или текст, какой-то код, изображение, что угодно, 

11
00:00:45,810 --> 00:00:50,380
в конечном итоге представляет собой некую последовательность единиц и нулей.

12
00:00:50,680 --> 00:00:53,496
А простой стратегией исправления любого перевернутого 

13
00:00:53,496 --> 00:00:56,000
бита было бы сохранение трех копий каждого бита.

14
00:00:57,580 --> 00:01:00,738
Тогда машина, читающая этот файл, сможет сравнить эти три 

15
00:01:00,738 --> 00:01:04,060
копии и всегда брать лучшие 2 из 3, если есть несоответствие.

16
00:01:07,160 --> 00:01:10,860
Но это означает использование двух третей вашего пространства для резервирования.

17
00:01:11,480 --> 00:01:14,018
И даже в этом случае, несмотря на все это отведенное пространство, 

18
00:01:14,018 --> 00:01:17,240
нет надежной гарантии того, что произойдет, если будет перевернуто более одного бита.

19
00:01:17,980 --> 00:01:20,405
Гораздо более интересный вопрос — как сделать так, 

20
00:01:20,405 --> 00:01:24,020
чтобы можно было исправлять ошибки, занимая при этом как можно меньше места.

21
00:01:24,520 --> 00:01:28,198
Например, используя метод, который вы узнаете из этого видео, 

22
00:01:28,198 --> 00:01:33,360
вы можете хранить свои данные в 256-битных блоках, где каждый блок использует 9 бит, 9!

23
00:01:33,760 --> 00:01:36,869
действовать как своего рода избыточность, а остальные 247 бит могут 

24
00:01:36,869 --> 00:01:40,300
свободно переносить любое значимое сообщение или данные, которые вы хотите.

25
00:01:40,900 --> 00:01:44,695
И все равно будет так, что если какой-либо бит здесь будет перевернут, 

26
00:01:44,695 --> 00:01:48,544
просто взглянув на этот блок и не более того, машина сможет определить, 

27
00:01:48,544 --> 00:01:52,660
что произошла ошибка и точно где она была, чтобы она знала, как ее исправить.

28
00:01:52,660 --> 00:01:54,620
И, честно говоря, это похоже на волшебство.

29
00:01:55,440 --> 00:01:58,748
И для этой конкретной схемы, если два бита будут перевернуты, машина, 

30
00:01:58,748 --> 00:02:02,860
по крайней мере, сможет обнаружить две ошибки, хотя и не будет знать, как их исправить.

31
00:02:03,520 --> 00:02:06,900
Чуть позже мы поговорим о том, как это масштабируется для блоков разных размеров.

32
00:02:07,860 --> 00:02:10,186
Методы, позволяющие исправлять подобные ошибки, 

33
00:02:10,186 --> 00:02:12,900
вполне обоснованно называются кодами исправления ошибок.

34
00:02:13,660 --> 00:02:16,321
На протяжении большей части прошлого столетия эта область была 

35
00:02:16,321 --> 00:02:19,109
действительно богатым источником удивительно глубокой математики, 

36
00:02:19,109 --> 00:02:21,940
которая внедрялась в устройства, которые мы используем каждый день.

37
00:02:22,840 --> 00:02:27,244
Цель здесь — дать вам очень полное представление об одном из самых ранних примеров, 

38
00:02:27,244 --> 00:02:28,660
известном как код Хэмминга.

39
00:02:29,520 --> 00:02:32,543
И, кстати, я думаю о структуре этого видео не столько для того, 

40
00:02:32,543 --> 00:02:35,425
чтобы объяснить его как можно более прямо, сколько для того, 

41
00:02:35,425 --> 00:02:37,741
чтобы побудить вас изобрести его самостоятельно, 

42
00:02:37,741 --> 00:02:39,820
с небольшими мягкими указаниями здесь и там.

43
00:02:40,120 --> 00:02:42,821
Поэтому, когда вы почувствуете, что видите, к чему все идет в какой-то момент, 

44
00:02:42,821 --> 00:02:45,283
воспользуйтесь моментом, чтобы сделать паузу и активно спрогнозировать, 

45
00:02:45,283 --> 00:02:46,720
какой будет схема, прежде чем я вам скажу.

46
00:02:47,240 --> 00:02:51,508
Кроме того, если вы хотите, чтобы ваше понимание достигло аппаратного уровня, 

47
00:02:51,508 --> 00:02:54,190
Бен Итер вместе с этим снял видео, показывающее, 

48
00:02:54,190 --> 00:02:58,240
как на самом деле реализовать коды Хэмминга на макетах, что очень приятно.

49
00:02:59,300 --> 00:03:02,111
Вы должны знать, что коды Хэмминга не так широко используются, 

50
00:03:02,111 --> 00:03:04,878
как более современные коды, такие как алгоритм Рида-Соломона, 

51
00:03:04,878 --> 00:03:07,109
но есть определенная магия в контрасте между тем, 

52
00:03:07,109 --> 00:03:09,742
насколько невыполнимой кажется эта задача в начале, и тем, 

53
00:03:09,742 --> 00:03:13,000
насколько совершенно разумной она кажется однажды. вы узнаете о Хэмминге.

54
00:03:13,720 --> 00:03:16,276
Основной принцип исправления ошибок заключается в том, 

55
00:03:16,276 --> 00:03:19,065
что в огромном пространстве всех возможных сообщений только 

56
00:03:19,065 --> 00:03:22,180
некоторые подмножества будут считаться действительными сообщениями.

57
00:03:22,800 --> 00:03:25,185
В качестве аналогии подумайте о правильно написанных 

58
00:03:25,185 --> 00:03:26,940
словах и неправильно написанных словах.

59
00:03:28,900 --> 00:03:31,318
Всякий раз, когда допустимое сообщение изменяется, 

60
00:03:31,318 --> 00:03:35,348
получатель несет ответственность за исправление увиденного до ближайшего допустимого 

61
00:03:35,348 --> 00:03:37,340
соседа, как это можно сделать с опечаткой.

62
00:03:38,220 --> 00:03:40,915
Однако создание конкретного алгоритма для эффективной 

63
00:03:40,915 --> 00:03:44,060
классификации подобных сообщений требует определенной смекалки.

64
00:03:46,780 --> 00:03:50,712
История начинается в 1940-х годах, когда молодой Ричард Хэмминг работал в Bell Labs, 

65
00:03:50,712 --> 00:03:53,996
и часть его работы заключалась в использовании очень большого дорогого 

66
00:03:53,996 --> 00:03:57,420
компьютера с перфокартами, к которому у него был лишь ограниченный доступ.

67
00:03:57,800 --> 00:04:00,343
И программы, которые он продолжал реализовывать, продолжали давать сбой, 

68
00:04:00,343 --> 00:04:02,400
потому что время от времени что-то считывалось неправильно.

69
00:04:03,120 --> 00:04:06,160
Разочарование было горнилом изобретений, и ему это настолько надоело, 

70
00:04:06,160 --> 00:04:08,420
что он изобрел первый в мире код исправления ошибок.

71
00:04:09,060 --> 00:04:12,244
Существует множество различных способов создания кодов Хэмминга, 

72
00:04:12,244 --> 00:04:15,380
но для начала мы рассмотрим их так, как о них думал сам Хэмминг.

73
00:04:16,519 --> 00:04:20,940
Давайте возьмем простой, но не слишком простой пример: блок из 16 бит.

74
00:04:21,820 --> 00:04:24,740
Пронумеруем позиции этих битов от 0 до 15.

75
00:04:25,620 --> 00:04:29,912
Фактические данные, которые мы хотим сохранить, будут состоять только из 12 таких битов, 

76
00:04:29,912 --> 00:04:33,000
а 4 позиции зарезервированы в качестве своего рода избыточности.

77
00:04:33,900 --> 00:04:37,012
Слово «избыточный» здесь не означает просто копирование: в конце концов, 

78
00:04:37,012 --> 00:04:40,040
эти 4 бита не дают нам достаточно места для слепого копирования данных.

79
00:04:40,720 --> 00:04:44,042
Вместо этого они должны будут представлять собой гораздо более тонкую и умную 

80
00:04:44,042 --> 00:04:47,280
избыточность, не добавляя никакой новой информации, но повышая устойчивость.

81
00:04:48,600 --> 00:04:51,952
Вы могли бы ожидать, что эти 4 специальных бита будут красиво упакованы вместе, 

82
00:04:51,952 --> 00:04:54,633
может быть, в конце или что-то в этом роде, но, как вы увидите, 

83
00:04:54,633 --> 00:04:57,147
расположение их в положениях, которые являются степенями 2, 

84
00:04:57,147 --> 00:04:59,620
к концу позволяет получить что-то действительно элегантное.

85
00:05:00,200 --> 00:05:01,936
Это также может дать вам небольшую подсказку о том, 

86
00:05:01,936 --> 00:05:03,540
как это масштабируется для более крупных блоков.

87
00:05:04,900 --> 00:05:09,916
Кроме того, технически это всего лишь 11 бит данных, вы обнаружите небольшой нюанс в том, 

88
00:05:09,916 --> 00:05:13,260
что происходит в позиции 0, но пока не беспокойтесь об этом.

89
00:05:14,140 --> 00:05:17,663
Как и в любом алгоритме исправления ошибок, в нем участвуют два игрока: 

90
00:05:17,663 --> 00:05:21,040
отправитель, который отвечает за установку этих 4 специальных битов, 

91
00:05:21,040 --> 00:05:25,200
и получатель, который отвечает за выполнение некоторой проверки и исправление ошибок.

92
00:05:25,200 --> 00:05:28,306
Конечно, слова «отправитель» и «получатель» на самом деле относятся к 

93
00:05:28,306 --> 00:05:31,145
машинам или программному обеспечению, выполняющим все проверки, 

94
00:05:31,145 --> 00:05:34,740
а идея сообщения подразумевается очень широко, включая такие вещи, как хранилище.

95
00:05:35,340 --> 00:05:37,752
В конце концов, хранение данных — это то же самое, 

96
00:05:37,752 --> 00:05:41,680
что отправка сообщения только из прошлого в будущее, а не из одного места в другое.

97
00:05:42,560 --> 00:05:45,336
Итак, установка такова, но прежде чем мы углубимся в нее, 

98
00:05:45,336 --> 00:05:48,544
нам нужно поговорить о связанной идее, которая была свежа в голове 

99
00:05:48,544 --> 00:05:52,039
Хэмминга во время его открытия, о методе, который позволяет обнаруживать 

100
00:05:52,039 --> 00:05:56,300
любые однобитовые ошибки, но не исправлять их, известный в бизнесе как проверка паритета.

101
00:05:56,880 --> 00:05:59,355
Для проверки четности мы выделяем только один бит, 

102
00:05:59,355 --> 00:06:02,800
за настройку которого отвечает отправитель, а остальные могут свободно 

103
00:06:02,800 --> 00:06:03,820
переносить сообщение.

104
00:06:04,880 --> 00:06:08,108
Единственная задача этого специального бита — убедиться, 

105
00:06:08,108 --> 00:06:11,280
что общее количество единиц в сообщении является четным.

106
00:06:12,080 --> 00:06:15,202
Например, сейчас общее количество единиц равно 7, это нечетно, 

107
00:06:15,202 --> 00:06:18,671
поэтому отправителю необходимо перевернуть этот специальный бит на 1, 

108
00:06:18,671 --> 00:06:19,960
чтобы сделать счет четным.

109
00:06:20,800 --> 00:06:23,804
Но если бы блок уже начинался с четного числа единиц, 

110
00:06:23,804 --> 00:06:26,420
тогда этот специальный бит остался бы равным 0.

111
00:06:27,340 --> 00:06:32,265
Это довольно просто, обманчиво просто, но это невероятно элегантный способ выразить 

112
00:06:32,265 --> 00:06:36,780
идею изменения в любом месте сообщения и отразить ее в одном бите информации.

113
00:06:37,500 --> 00:06:41,959
Обратите внимание: если какой-либо бит этого сообщения переворачивается с 

114
00:06:41,959 --> 00:06:46,540
0 на 1 или с 1 на 0, общее количество единиц меняется с четного на нечетное.

115
00:06:47,980 --> 00:06:52,414
Итак, если вы получатель, посмотрите на это сообщение и увидите нечетное число единиц, 

116
00:06:52,414 --> 00:06:55,166
вы можете точно знать, что произошла какая-то ошибка, 

117
00:06:55,166 --> 00:06:57,460
даже если вы понятия не имеете, где она была.

118
00:06:58,500 --> 00:07:03,340
На жаргоне четное или нечетное количество единиц в группе битов называется ее четностью.

119
00:07:04,860 --> 00:07:07,657
Вы также можете использовать числа и сказать, что четность равна 0 или 1, 

120
00:07:07,657 --> 00:07:10,720
что обычно более полезно, когда вы начинаете заниматься математикой с этой идеей.

121
00:07:11,220 --> 00:07:14,445
И этот специальный бит, который отправитель использует для контроля четности, 

122
00:07:14,445 --> 00:07:15,520
называется битом четности.

123
00:07:17,560 --> 00:07:21,380
И на самом деле, нам должно быть ясно: если получатель видит нечетную четность, 

124
00:07:21,380 --> 00:07:25,153
это не обязательно означает, что была только одна ошибка, могло быть 3 ошибки, 

125
00:07:25,153 --> 00:07:29,260
или 5, или любое другое нечетное число, но он может знать это наверняка. что это не 0.

126
00:07:29,980 --> 00:07:33,623
С другой стороны, если бы было 2 ошибки или любое четное количество ошибок, 

127
00:07:33,623 --> 00:07:36,163
итоговое количество единиц все равно было бы четным, 

128
00:07:36,163 --> 00:07:38,608
поэтому получатель не может быть полностью уверен, 

129
00:07:38,608 --> 00:07:42,300
что четное количество обязательно означает, что сообщение не содержит ошибок.

130
00:07:42,840 --> 00:07:46,851
Вы можете жаловаться, что сообщение, которое искажается всего лишь двумя битами, 

131
00:07:46,851 --> 00:07:49,080
довольно слабое, и вы будете абсолютно правы.

132
00:07:49,700 --> 00:07:53,268
Однако имейте в виду, что не существует метода обнаружения или исправления ошибок, 

133
00:07:53,268 --> 00:07:55,331
который мог бы дать вам 100% уверенность в том, 

134
00:07:55,331 --> 00:07:58,900
что полученное вами сообщение является именно тем, которое намеревался отправитель.

135
00:07:59,580 --> 00:08:02,563
В конце концов, достаточное количество случайного шума всегда может превратить одно 

136
00:08:02,563 --> 00:08:05,440
действительное сообщение в другое действительное сообщение по чистой случайности.

137
00:08:06,240 --> 00:08:09,099
Вместо этого цель состоит в том, чтобы придумать схему, 

138
00:08:09,099 --> 00:08:12,929
устойчивую к определенному максимальному количеству ошибок, или, возможно, 

139
00:08:12,929 --> 00:08:15,380
снизить вероятность такого ложного срабатывания.

140
00:08:16,260 --> 00:08:19,629
Сами по себе проверки четности довольно слабы, но, 

141
00:08:19,629 --> 00:08:23,130
сведя идею изменения всего сообщения до одного бита, 

142
00:08:23,130 --> 00:08:27,160
они дают нам мощный строительный блок для более сложных схем.

143
00:08:27,940 --> 00:08:31,285
Например, когда Хэмминг искал способ определить, где произошла ошибка, 

144
00:08:31,285 --> 00:08:34,678
а не только то, что она произошла, его ключевой вывод заключался в том, 

145
00:08:34,678 --> 00:08:38,118
что если вы примените некоторые проверки четности не ко всему сообщению, 

146
00:08:38,118 --> 00:08:40,568
а к определенным тщательно выбранным подмножествам, 

147
00:08:40,568 --> 00:08:43,018
вы можете спросить более уточненная серия вопросов, 

148
00:08:43,018 --> 00:08:45,940
позволяющая определить местонахождение любой единичной ошибки.

149
00:08:46,680 --> 00:08:49,210
Общее ощущение немного похоже на игру из 20 вопросов, 

150
00:08:49,210 --> 00:08:53,380
когда вы задаете вопросы «да» или «нет», которые делят пространство возможностей пополам.

151
00:08:54,160 --> 00:08:57,836
Например, предположим, что мы выполняем проверку четности только для этих 8 бит, 

152
00:08:57,836 --> 00:08:59,380
всех позиций с нечетными номерами.

153
00:09:00,100 --> 00:09:04,271
Затем, если ошибка обнаружена, он дает приемнику немного больше информации о том, 

154
00:09:04,271 --> 00:09:08,240
где именно находится ошибка, а именно, что она находится в нечетном положении.

155
00:09:08,940 --> 00:09:12,477
Если среди этих 8 бит не обнаружено ошибок, это либо означает, 

156
00:09:12,477 --> 00:09:16,240
что ошибки вообще нет, либо она находится где-то в четных позициях.

157
00:09:17,180 --> 00:09:20,449
Вы можете подумать, что ограничение проверки четности половиной битов делает 

158
00:09:20,449 --> 00:09:23,803
ее менее эффективной, но когда она выполняется в сочетании с другими правильно 

159
00:09:23,803 --> 00:09:27,200
выбранными проверками, это, как ни странно, дает нам нечто гораздо более мощное.

160
00:09:29,240 --> 00:09:32,700
Помните, что для фактической настройки проверки четности необходимо 

161
00:09:32,700 --> 00:09:36,620
выделить какой-то специальный бит, который контролирует четность всей группы.

162
00:09:37,480 --> 00:09:39,180
Здесь давайте просто выберем позицию 1.

163
00:09:39,720 --> 00:09:42,719
В показанном примере четность этих 8 бит в настоящее время нечетная, 

164
00:09:42,719 --> 00:09:46,154
поэтому отправитель несет ответственность за переключение этого бита четности, 

165
00:09:46,154 --> 00:09:46,980
и теперь он четный.

166
00:09:47,940 --> 00:09:50,680
Это только 1 из 4 проверок четности, которые мы проведем.

167
00:09:50,920 --> 00:09:54,046
Вторая проверка осуществляется среди 8 бит в правой половине сетки, 

168
00:09:54,046 --> 00:09:56,300
по крайней мере, так, как мы ее нарисовали здесь.

169
00:09:56,680 --> 00:10:00,191
На этот раз мы могли бы использовать позицию 2 в качестве бита четности, 

170
00:10:00,191 --> 00:10:04,184
так что эти 8 бит уже имеют четность, и отправитель может чувствовать себя хорошо, 

171
00:10:04,184 --> 00:10:06,060
оставив этот бит номер 2 без изменений.

172
00:10:07,020 --> 00:10:11,250
Затем, на другом конце, если получатель проверит четность этой группы и обнаружит, 

173
00:10:11,250 --> 00:10:15,380
что она нечетная, он узнает, что ошибка находится где-то среди этих 8 бит справа.

174
00:10:15,820 --> 00:10:20,580
В противном случае это означает, что либо ошибки нет, либо ошибка где-то в левой половине.

175
00:10:21,120 --> 00:10:24,547
Или я предполагаю, что ошибок могло быть две, но сейчас мы будем предполагать, 

176
00:10:24,547 --> 00:10:26,500
что во всем блоке есть не более одной ошибки.

177
00:10:26,940 --> 00:10:28,740
Более того, все полностью ломается.

178
00:10:29,160 --> 00:10:31,962
Здесь, прежде чем мы рассмотрим следующие две проверки, подумайте, 

179
00:10:31,962 --> 00:10:35,100
что позволяют нам делать первые две проверки, если рассматривать их вместе.

180
00:10:35,800 --> 00:10:39,660
Допустим, вы обнаружили ошибку среди нечетных столбцов и среди правой половины.

181
00:10:40,200 --> 00:10:43,040
Это обязательно означает, что ошибка находится где-то в последнем столбце.

182
00:10:43,820 --> 00:10:47,107
Если в нечетном столбце не было ошибки, но она была в правой половине, 

183
00:10:47,107 --> 00:10:49,700
это означает, что она находится в предпоследнем столбце.

184
00:10:50,440 --> 00:10:53,011
Аналогично, если ошибка есть в нечетных столбцах, 

185
00:10:53,011 --> 00:10:56,560
но не в правой половине, вы знаете, что она где-то во втором столбце.

186
00:10:56,560 --> 00:11:00,010
И если ни одна из этих двух проверок четности ничего не обнаружит, это означает, 

187
00:11:00,010 --> 00:11:03,120
что единственное место, где может быть ошибка, — это самый левый столбец.

188
00:11:03,340 --> 00:11:06,120
Но это также может означать, что ошибки вообще нет.

189
00:11:06,300 --> 00:11:08,482
Это довольно расплывчатый способ сказать, что две 

190
00:11:08,482 --> 00:11:10,840
проверки четности позволяют нам зафиксировать столбец.

191
00:11:11,480 --> 00:11:13,640
Отсюда вы, вероятно, можете догадаться, что будет дальше.

192
00:11:13,800 --> 00:11:16,140
Мы делаем в основном то же самое, но для строк.

193
00:11:16,440 --> 00:11:18,648
Будет произведена проверка четности нечетных строк 

194
00:11:18,648 --> 00:11:20,900
с использованием позиции 4 в качестве бита четности.

195
00:11:21,380 --> 00:11:25,820
Итак, в этом примере эта группа уже имеет четность, поэтому бит 4 будет установлен в 0.

196
00:11:26,560 --> 00:11:28,940
И, наконец, в двух нижних строках выполняется проверка 

197
00:11:28,940 --> 00:11:31,580
четности с использованием позиции 8 в качестве бита четности.

198
00:11:32,120 --> 00:11:35,237
В этом случае похоже, что отправителю необходимо включить бит 8, 

199
00:11:35,237 --> 00:11:36,820
чтобы обеспечить четность группе.

200
00:11:37,700 --> 00:11:40,238
Так же, как первые две проверки позволяют нам закрепить столбец, 

201
00:11:40,238 --> 00:11:41,840
следующие две позволяют закрепить строку.

202
00:11:42,880 --> 00:11:46,515
В качестве примера представьте, что во время передачи возникла ошибка, 

203
00:11:46,515 --> 00:11:47,540
скажем, в позиции 3.

204
00:11:48,180 --> 00:11:52,179
Ну, это влияет на первую группу четности, а также влияет на вторую группу четности, 

205
00:11:52,179 --> 00:11:55,560
поэтому получатель знает, что где-то в этом правом столбце есть ошибка.

206
00:11:56,100 --> 00:12:00,540
Но это не влияет на третью группу и не влияет на четвертую группу.

207
00:12:01,240 --> 00:12:04,380
И это позволяет получателю точно определить ошибку до первой строки, 

208
00:12:04,380 --> 00:12:07,520
что обязательно означает позицию 3, чтобы они могли исправить ошибку.

209
00:12:08,580 --> 00:12:11,625
Возможно, вам понравится потратить время на то, чтобы убедить себя в том, 

210
00:12:11,625 --> 00:12:14,383
что ответы на эти четыре вопроса действительно всегда позволят вам 

211
00:12:14,383 --> 00:12:17,100
определить конкретное место, независимо от того, где оно окажется.

212
00:12:17,720 --> 00:12:20,365
На самом деле, самые проницательные из вас могут даже 

213
00:12:20,365 --> 00:12:23,060
заметить связь между этими вопросами и двоичным счетом.

214
00:12:23,500 --> 00:12:26,366
А если да, то еще раз позвольте мне подчеркнуть, сделать паузу, 

215
00:12:26,366 --> 00:12:28,920
попытаться самому уловить связь, прежде чем я ее испорчу.

216
00:12:30,500 --> 00:12:34,494
Если вам интересно, что произойдет, если будет затронут сам бит четности, 

217
00:12:34,494 --> 00:12:36,060
вы можете просто попробовать.

218
00:12:36,440 --> 00:12:40,085
Найдите минутку и подумайте, как можно отследить любую ошибку среди этих четырех 

219
00:12:40,085 --> 00:12:43,775
специальных битов, как и любую другую, с помощью одной и той же группы из четырех 

220
00:12:43,775 --> 00:12:44,180
вопросов.

221
00:12:47,060 --> 00:12:49,744
На самом деле это не имеет значения, поскольку, в конце концов, 

222
00:12:49,744 --> 00:12:53,100
мы хотим защитить биты сообщения, а биты исправления ошибок просто продолжаются.

223
00:12:53,600 --> 00:12:55,386
Но защита и этих частей также является чем-то, 

224
00:12:55,386 --> 00:12:57,820
что естественным образом выпадает из схемы как побочный продукт.

225
00:12:59,200 --> 00:13:01,760
Вам также может понравиться предвидеть, как это масштабируется.

226
00:13:02,300 --> 00:13:05,528
Если бы мы использовали блок размером 256 бит, например, 

227
00:13:05,528 --> 00:13:09,211
чтобы определить местоположение, вам нужно всего восемь вопросов 

228
00:13:09,211 --> 00:13:12,780
«да» или «нет» для двоичного поиска пути к определенному месту.

229
00:13:15,640 --> 00:13:18,325
И помните, каждый вопрос требует отказа только от одного бита, 

230
00:13:18,325 --> 00:13:20,500
чтобы установить соответствующую проверку четности.

231
00:13:23,160 --> 00:13:26,087
Некоторые из вас, возможно, уже видели это, но позже мы поговорим о 

232
00:13:26,087 --> 00:13:29,360
систематическом способе узнать, что это за вопросы, всего за минуту или две.

233
00:13:29,880 --> 00:13:32,356
Надеюсь, этого эскиза будет достаточно, чтобы оценить эффективность того, 

234
00:13:32,356 --> 00:13:33,260
что мы здесь разрабатываем.

235
00:13:33,260 --> 00:13:37,887
Первое, за исключением этих восьми выделенных битов четности, может быть любым, 

236
00:13:37,887 --> 00:13:41,820
каким вы хотите, неся любое сообщение или данные, которые вы хотите.

237
00:13:41,820 --> 00:13:46,138
8 бит избыточны в том смысле, что они полностью определяются остальной частью сообщения, 

238
00:13:46,138 --> 00:13:50,020
но это гораздо более разумный способ, чем простое копирование сообщения целиком.

239
00:13:53,600 --> 00:13:56,068
И все же, приложив так мало усилий, вы сможете 

240
00:13:56,068 --> 00:13:58,380
выявить и исправить любую ошибку в один бит.

241
00:13:59,200 --> 00:14:00,400
Ну, почти.

242
00:14:00,960 --> 00:14:03,626
Итак, единственная проблема здесь заключается в том, 

243
00:14:03,626 --> 00:14:07,953
что если ни одна из четырех проверок четности не обнаруживает ошибку, а это означает, 

244
00:14:07,953 --> 00:14:11,174
что все специально выбранные подмножества 8 бит имеют четность, 

245
00:14:11,174 --> 00:14:15,199
как и предполагал отправитель, то это либо означает, что ошибки вообще не было. 

246
00:14:15,199 --> 00:14:16,860
, или это сузит нас до позиции 0.

247
00:14:17,740 --> 00:14:21,395
Видите ли, с четырьмя вопросами «да» или «нет» у нас есть 16 возможных 

248
00:14:21,395 --> 00:14:24,845
результатов для наших проверок на четность, и поначалу это кажется 

249
00:14:24,845 --> 00:14:27,883
идеальным для точного определения 1 из 16 позиций в блоке, 

250
00:14:27,883 --> 00:14:31,900
но вам также необходимо сообщить 17-й результат, отсутствие ошибки. состояние.

251
00:14:33,020 --> 00:14:37,300
Решение здесь на самом деле довольно простое: просто забудьте полностью об этом 0-м бите.

252
00:14:37,840 --> 00:14:40,696
Поэтому, когда мы выполняем четыре проверки четности и видим, 

253
00:14:40,696 --> 00:14:43,460
что все они четные, это однозначно означает, что ошибки нет.

254
00:14:44,240 --> 00:14:48,650
Это означает, что вместо работы с 16-битным блоком мы работаем с 15-битным блоком, 

255
00:14:48,650 --> 00:14:53,220
где 11 бит свободны для передачи сообщения, а 4 из них предназначены для избыточности.

256
00:14:53,780 --> 00:15:00,200
И теперь у нас есть то, что люди в бизнесе называют кодом Хэмминга 15-11.

257
00:15:00,460 --> 00:15:03,400
Тем не менее, приятно иметь размер блока, равный чистой степени 2, 

258
00:15:03,400 --> 00:15:07,174
и есть умный способ сохранить этот 0-й бит и заставить его выполнять за нас небольшую 

259
00:15:07,174 --> 00:15:08,140
дополнительную работу.

260
00:15:08,700 --> 00:15:11,651
Если мы используем его в качестве бита четности во всем блоке, 

261
00:15:11,651 --> 00:15:15,540
это позволяет нам обнаруживать 2-битные ошибки, даже если мы не можем их исправить.

262
00:15:16,160 --> 00:15:16,820
Вот как это работает.

263
00:15:17,180 --> 00:15:20,257
После установки этих четырех специальных битов, исправляющих ошибки, 

264
00:15:20,257 --> 00:15:23,423
мы устанавливаем этот 0-й бит, чтобы четность всего блока была четной, 

265
00:15:23,423 --> 00:15:24,940
как при обычной проверке четности.

266
00:15:25,700 --> 00:15:29,983
Теперь, если есть ошибка в один бит, то четность полного блока переключается на нечетную, 

267
00:15:29,983 --> 00:15:33,600
но мы все равно уловим это благодаря четырем проверкам, исправляющим ошибки.

268
00:15:34,160 --> 00:15:37,905
Однако, если есть две ошибки, то общая четность снова станет четной, 

269
00:15:37,905 --> 00:15:42,357
но получатель все равно увидит, что произошла хотя бы какая-то ошибка из-за того, 

270
00:15:42,357 --> 00:15:45,180
что происходит с этими четырьмя проверками четности.

271
00:15:45,180 --> 00:15:48,706
Поэтому, если они заметят в целом четность, но с другими проверками 

272
00:15:48,706 --> 00:15:52,700
происходит что-то ненулевое, это говорит им, что было как минимум две ошибки.

273
00:15:53,520 --> 00:15:54,000
Разве это не умно?

274
00:15:54,300 --> 00:15:57,303
Несмотря на то, что мы не можем исправить эти 2-битные ошибки, 

275
00:15:57,303 --> 00:16:01,260
просто вернув в работу этот маленький надоедливый 0-й бит, мы сможем их обнаружить.

276
00:16:02,260 --> 00:16:05,220
Это довольно стандартный код, известный как расширенный код Хэмминга.

277
00:16:06,540 --> 00:16:09,439
Технически говоря, теперь у вас есть полное описание того, 

278
00:16:09,439 --> 00:16:12,880
что делает код Хэмминга, по крайней мере, на примере 16-битного блока.

279
00:16:12,880 --> 00:16:17,877
Но я думаю, вам будет приятнее проверить свое понимание и закрепить все до этого момента, 

280
00:16:17,877 --> 00:16:21,320
выполнив один полный пример от начала до конца самостоятельно.

281
00:16:22,080 --> 00:16:24,300
Я пройду через это вместе с вами, чтобы вы могли проверить себя.

282
00:16:25,120 --> 00:16:27,614
Чтобы настроить сообщение, будь то буквальное сообщение, 

283
00:16:27,614 --> 00:16:30,283
которое вы транслируете в пространстве, или какие-то данные, 

284
00:16:30,283 --> 00:16:33,478
которые вы хотите сохранить во времени, первым шагом является разделение 

285
00:16:33,478 --> 00:16:34,660
его на 11-битные фрагменты.

286
00:16:35,580 --> 00:16:39,760
Каждый фрагмент будет упакован в устойчивый к ошибкам 16-битный блок.

287
00:16:39,760 --> 00:16:43,220
Итак, давайте возьмем это в качестве примера и на самом деле разберемся.

288
00:16:43,740 --> 00:16:44,740
Давай, действительно сделай это!

289
00:16:44,740 --> 00:16:47,020
Давайте остановимся и попробуем собрать этот блок.

290
00:16:52,720 --> 00:16:53,680
Хорошо, ты готов?

291
00:16:54,240 --> 00:16:57,022
Помните, что позиция 0 вместе с другими степенями двойки 

292
00:16:57,022 --> 00:17:00,000
зарезервирована для исправления ошибок, поэтому вы начинаете 

293
00:17:00,000 --> 00:17:03,320
с размещения битов сообщения во всех оставшихся позициях по порядку.

294
00:17:05,339 --> 00:17:08,814
Вам нужно, чтобы эта группа имела четную четность, которая уже есть, 

295
00:17:08,814 --> 00:17:12,339
поэтому вам следует установить этот бит четности в позиции 1 равным 0.

296
00:17:13,020 --> 00:17:15,288
Следующая группа начинается с нечетной четности, 

297
00:17:15,288 --> 00:17:17,880
поэтому вам следует установить ее бит четности равным 1.

298
00:17:19,160 --> 00:17:21,486
Следующая группа начинается с нечетной четности, 

299
00:17:21,486 --> 00:17:24,240
поэтому вам снова следует установить ее бит четности на 1.

300
00:17:24,780 --> 00:17:27,294
И последняя группа также имеет нечетную четность, 

301
00:17:27,294 --> 00:17:30,060
то есть мы устанавливаем этот бит в позиции 8 равным 1.

302
00:17:31,300 --> 00:17:36,088
И затем, в качестве последнего шага, полный блок теперь имеет четность, что означает, 

303
00:17:36,088 --> 00:17:40,320
что вы можете установить этот бит с номером 0, общий бит четности, равным 0.

304
00:17:41,340 --> 00:17:44,491
Таким образом, при отправке этого блока четность четырех 

305
00:17:44,491 --> 00:17:48,140
специальных подмножеств и блока в целом будет четной или равной 0.

306
00:17:48,820 --> 00:17:52,180
Во второй части упражнения давайте попросим вас сыграть роль получателя.

307
00:17:53,480 --> 00:17:56,687
Конечно, это будет означать, что вы еще не знаете, что это за сообщение, возможно, 

308
00:17:56,687 --> 00:17:59,780
некоторые из вас его запомнили, но давайте предположим, что вы этого не сделали.

309
00:18:00,020 --> 00:18:04,502
Что я собираюсь сделать, так это изменить 0, 1 или 2 бита в этом блоке, 

310
00:18:04,502 --> 00:18:07,740
а затем попросить вас выяснить, что именно я сделал.

311
00:18:08,260 --> 00:18:10,810
Итак, еще раз сделайте паузу и попробуйте разобраться.

312
00:18:18,790 --> 00:18:23,350
Хорошо, теперь вы, как получатель, проверяете первую группу четности и видите, 

313
00:18:23,350 --> 00:18:27,910
что она четная, поэтому любая существующая ошибка должна быть в четном столбце.

314
00:18:29,690 --> 00:18:32,963
Следующая проверка дает нам нечетное число, сообщающее нам обоим, 

315
00:18:32,963 --> 00:18:37,030
что есть по крайней мере одна ошибка, и сужающее нас до этого конкретного столбца.

316
00:18:38,550 --> 00:18:41,790
Третья проверка четная, еще больше сокращая возможности.

317
00:18:42,650 --> 00:18:45,495
И последняя проверка четности является нечетной и говорит нам, 

318
00:18:45,495 --> 00:18:48,204
что где-то внизу есть ошибка, которая, как мы теперь видим, 

319
00:18:48,204 --> 00:18:49,650
должна быть на позиции номер 10.

320
00:18:51,490 --> 00:18:55,888
Более того, четность всего блока нечетная, что дает нам уверенность в том, 

321
00:18:55,888 --> 00:18:57,530
что был один флип, а не два.

322
00:18:58,070 --> 00:18:59,970
Если их три или больше, все ставки аннулируются.

323
00:19:01,310 --> 00:19:04,222
После исправления этого бита номер 10 извлечение 11 бит, 

324
00:19:04,222 --> 00:19:08,616
которые не использовались для исправления, дает нам соответствующий сегмент исходного 

325
00:19:08,616 --> 00:19:13,163
сообщения, который, если перемотать назад и сравнить, действительно является именно тем, 

326
00:19:13,163 --> 00:19:14,390
с чего мы начали пример.

327
00:19:15,710 --> 00:19:19,241
И теперь, когда вы знаете, как делать все это вручную, я хотел бы показать вам, 

328
00:19:19,241 --> 00:19:23,170
как можно реализовать основную часть всей этой логики с помощью одной строки кода Python.

329
00:19:23,870 --> 00:19:28,240
Видите ли, я еще не рассказал вам, насколько на самом деле элегантен этот алгоритм, 

330
00:19:28,240 --> 00:19:31,622
насколько просто заставить машину указывать на положение ошибки, 

331
00:19:31,622 --> 00:19:35,316
как ее систематически масштабировать и как мы можем сформулировать все 

332
00:19:35,316 --> 00:19:38,750
это как одна операция, а не несколько отдельных проверок четности.

333
00:19:39,430 --> 00:19:41,310
Чтобы понять, что я имею в виду, присоединяйтесь ко мне во второй части.

