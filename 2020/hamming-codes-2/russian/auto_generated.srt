1
00:00:00,000 --> 00:00:05,492
Вы когда-нибудь задумывались, как можно поцарапать компакт-диск

2
00:00:05,492 --> 00:00:10,900
или DVD-диск и при этом воспроизвести все, что на нем хранится?

3
00:00:10,900 --> 00:00:15,775
Царапина действительно влияет на 1 и 0 на диске, поэтому он считывает данные,

4
00:00:15,775 --> 00:00:20,587
отличные от того, что было сохранено, но если он действительно не поцарапан,

5
00:00:20,587 --> 00:00:25,650
считанные биты декодируются точно в тот же файл, который был закодирован на нем.

6
00:00:25,650 --> 00:00:28,400
побитовая копия, несмотря на все эти ошибки.

7
00:00:28,400 --> 00:00:33,262
Существует целый ряд математических хитростей, которые позволяют нам хранить данные и,

8
00:00:33,262 --> 00:00:36,840
что не менее важно, передавать их устойчивым к ошибкам способом.

9
00:00:36,840 --> 00:00:42,480
Ну да ладно, на самом деле не нужно так уж много ума, чтобы придумать способ сделать это.

10
00:00:42,480 --> 00:00:46,881
Любой файл, будь то видео, звук или текст, какой-то код, изображение, что угодно,

11
00:00:46,881 --> 00:00:50,960
в конечном итоге представляет собой некую последовательность единиц и нулей.

12
00:00:50,960 --> 00:00:54,570
А простой стратегией исправления любого перевернутого

13
00:00:54,570 --> 00:00:57,780
бита было бы сохранение трех копий каждого бита.

14
00:00:57,780 --> 00:01:02,488
Тогда машина, читающая этот файл, сможет сравнить эти три

15
00:01:02,488 --> 00:01:07,440
копии и всегда брать лучшие 2 из 3, если есть несоответствие.

16
00:01:07,440 --> 00:01:11,560
Но это означает использование двух третей вашего пространства для резервирования.

17
00:01:11,560 --> 00:01:14,451
И даже в этом случае, несмотря на все это отведенное пространство,

18
00:01:14,451 --> 00:01:18,120
нет надежной гарантии того, что произойдет, если будет перевернуто более одного бита.

19
00:01:18,120 --> 00:01:20,778
Гораздо более интересный вопрос — как сделать так,

20
00:01:20,778 --> 00:01:24,740
чтобы можно было исправлять ошибки, занимая при этом как можно меньше места.

21
00:01:24,740 --> 00:01:28,166
Например, используя метод, который вы узнаете из этого видео,

22
00:01:28,166 --> 00:01:32,975
вы можете хранить свои данные в 256-битных блоках, где каждый блок использует 9 бит, 9!

23
00:01:32,975 --> 00:01:36,791
действовать как своего рода избыточность, а остальные 247 бит могут

24
00:01:36,791 --> 00:01:41,000
свободно переносить любое значимое сообщение или данные, которые вы хотите.

25
00:01:41,000 --> 00:01:44,917
И все равно будет так, что если какой-либо бит здесь будет перевернут,

26
00:01:44,917 --> 00:01:48,891
просто взглянув на этот блок и не более того, машина сможет определить,

27
00:01:48,891 --> 00:01:53,140
что произошла ошибка и точно где она была, чтобы она знала, как ее исправить.

28
00:01:53,140 --> 00:01:55,540
И, честно говоря, это похоже на волшебство.

29
00:01:55,540 --> 00:01:58,946
И для этой конкретной схемы, если два бита будут перевернуты, машина,

30
00:01:58,946 --> 00:02:03,180
по крайней мере, сможет обнаружить две ошибки, хотя и не будет знать, как их исправить.

31
00:02:03,180 --> 00:02:08,140
Чуть позже мы поговорим о том, как это масштабируется для блоков разных размеров.

32
00:02:08,140 --> 00:02:10,789
Методы, позволяющие исправлять подобные ошибки,

33
00:02:10,789 --> 00:02:13,880
вполне обоснованно называются кодами исправления ошибок.

34
00:02:13,880 --> 00:02:16,811
На протяжении большей части прошлого столетия эта область была

35
00:02:16,811 --> 00:02:19,882
действительно богатым источником удивительно глубокой математики,

36
00:02:19,882 --> 00:02:23,000
которая внедрялась в устройства, которые мы используем каждый день.

37
00:02:23,000 --> 00:02:28,040
Цель здесь — дать вам очень полное представление об одном из самых ранних примеров,

38
00:02:28,040 --> 00:02:29,660
известном как код Хэмминга.

39
00:02:29,660 --> 00:02:32,760
И, кстати, я думаю о структуре этого видео не столько для того,

40
00:02:32,760 --> 00:02:35,715
чтобы объяснить его как можно более прямо, сколько для того,

41
00:02:35,715 --> 00:02:38,088
чтобы побудить вас изобрести его самостоятельно,

42
00:02:38,088 --> 00:02:40,220
с небольшими мягкими указаниями здесь и там.

43
00:02:40,220 --> 00:02:43,068
Поэтому, когда вы почувствуете, что видите, к чему все идет в какой-то момент,

44
00:02:43,068 --> 00:02:45,665
воспользуйтесь моментом, чтобы сделать паузу и активно спрогнозировать,

45
00:02:45,665 --> 00:02:47,180
какой будет схема, прежде чем я вам скажу.

46
00:02:47,180 --> 00:02:51,968
Кроме того, если вы хотите, чтобы ваше понимание достигло аппаратного уровня,

47
00:02:51,968 --> 00:02:54,976
Бен Итер вместе с этим снял видео, показывающее,

48
00:02:54,976 --> 00:02:59,520
как на самом деле реализовать коды Хэмминга на макетах, что очень приятно.

49
00:02:59,520 --> 00:03:02,540
Вы должны знать, что коды Хэмминга не так широко используются,

50
00:03:02,540 --> 00:03:05,513
как более современные коды, такие как алгоритм Рида-Соломона,

51
00:03:05,513 --> 00:03:07,910
но есть определенная магия в контрасте между тем,

52
00:03:07,910 --> 00:03:10,739
насколько невыполнимой кажется эта задача в начале, и тем,

53
00:03:10,739 --> 00:03:14,240
насколько совершенно разумной она кажется однажды. вы узнаете о Хэмминге.

54
00:03:14,240 --> 00:03:16,844
Основной принцип исправления ошибок заключается в том,

55
00:03:16,844 --> 00:03:19,686
что в огромном пространстве всех возможных сообщений только

56
00:03:19,686 --> 00:03:22,860
некоторые подмножества будут считаться действительными сообщениями.

57
00:03:22,860 --> 00:03:26,454
В качестве аналогии подумайте о правильно написанных

58
00:03:26,454 --> 00:03:29,100
словах и неправильно написанных словах.

59
00:03:29,100 --> 00:03:31,758
Всякий раз, когда допустимое сообщение изменяется,

60
00:03:31,758 --> 00:03:36,190
получатель несет ответственность за исправление увиденного до ближайшего допустимого

61
00:03:36,190 --> 00:03:38,380
соседа, как это можно сделать с опечаткой.

62
00:03:38,380 --> 00:03:42,432
Однако создание конкретного алгоритма для эффективной

63
00:03:42,432 --> 00:03:47,160
классификации подобных сообщений требует определенной смекалки.

64
00:03:47,160 --> 00:03:50,951
История начинается в 1940-х годах, когда молодой Ричард Хэмминг работал в Bell Labs,

65
00:03:50,951 --> 00:03:54,118
и часть его работы заключалась в использовании очень большого дорогого

66
00:03:54,118 --> 00:03:57,420
компьютера с перфокартами, к которому у него был лишь ограниченный доступ.

67
00:03:57,420 --> 00:04:00,583
И программы, которые он продолжал реализовывать, продолжали давать сбой,

68
00:04:00,583 --> 00:04:03,140
потому что время от времени что-то считывалось неправильно.

69
00:04:03,140 --> 00:04:06,662
Разочарование было горнилом изобретений, и ему это настолько надоело,

70
00:04:06,662 --> 00:04:09,280
что он изобрел первый в мире код исправления ошибок.

71
00:04:09,280 --> 00:04:12,978
Существует множество различных способов создания кодов Хэмминга,

72
00:04:12,978 --> 00:04:16,620
но для начала мы рассмотрим их так, как о них думал сам Хэмминг.

73
00:04:16,620 --> 00:04:21,400
Давайте возьмем простой, но не слишком простой пример: блок из 16 бит.

74
00:04:21,400 --> 00:04:25,700
Пронумеруем позиции этих битов от 0 до 15.

75
00:04:25,700 --> 00:04:30,481
Фактические данные, которые мы хотим сохранить, будут состоять только из 12 таких битов,

76
00:04:30,481 --> 00:04:33,920
а 4 позиции зарезервированы в качестве своего рода избыточности.

77
00:04:33,920 --> 00:04:37,103
Слово «избыточный» здесь не означает просто копирование: в конце концов,

78
00:04:37,103 --> 00:04:40,200
эти 4 бита не дают нам достаточно места для слепого копирования данных.

79
00:04:40,200 --> 00:04:44,525
Вместо этого они должны будут представлять собой гораздо более тонкую и умную

80
00:04:44,525 --> 00:04:48,740
избыточность, не добавляя никакой новой информации, но повышая устойчивость.

81
00:04:48,740 --> 00:04:52,262
Вы могли бы ожидать, что эти 4 специальных бита будут красиво упакованы вместе,

82
00:04:52,262 --> 00:04:55,080
может быть, в конце или что-то в этом роде, но, как вы увидите,

83
00:04:55,080 --> 00:04:57,722
расположение их в положениях, которые являются степенями 2,

84
00:04:57,722 --> 00:05:00,320
к концу позволяет получить что-то действительно элегантное.

85
00:05:00,320 --> 00:05:02,972
Это также может дать вам небольшую подсказку о том,

86
00:05:02,972 --> 00:05:05,420
как это масштабируется для более крупных блоков.

87
00:05:05,420 --> 00:05:10,736
Кроме того, технически это всего лишь 11 бит данных, вы обнаружите небольшой нюанс в том,

88
00:05:10,736 --> 00:05:14,280
что происходит в позиции 0, но пока не беспокойтесь об этом.

89
00:05:14,280 --> 00:05:18,128
Как и в любом алгоритме исправления ошибок, в нем участвуют два игрока:

90
00:05:18,128 --> 00:05:21,816
отправитель, который отвечает за установку этих 4 специальных битов,

91
00:05:21,816 --> 00:05:26,360
и получатель, который отвечает за выполнение некоторой проверки и исправление ошибок.

92
00:05:26,360 --> 00:05:29,329
Конечно, слова «отправитель» и «получатель» на самом деле относятся к

93
00:05:29,329 --> 00:05:32,044
машинам или программному обеспечению, выполняющим все проверки,

94
00:05:32,044 --> 00:05:35,480
а идея сообщения подразумевается очень широко, включая такие вещи, как хранилище.

95
00:05:35,480 --> 00:05:38,205
В конце концов, хранение данных — это то же самое,

96
00:05:38,205 --> 00:05:42,640
что отправка сообщения только из прошлого в будущее, а не из одного места в другое.

97
00:05:42,640 --> 00:05:45,602
Итак, установка такова, но прежде чем мы углубимся в нее,

98
00:05:45,602 --> 00:05:49,025
нам нужно поговорить о связанной идее, которая была свежа в голове

99
00:05:49,025 --> 00:05:52,753
Хэмминга во время его открытия, о методе, который позволяет обнаруживать

100
00:05:52,753 --> 00:05:57,300
любые однобитовые ошибки, но не исправлять их, известный в бизнесе как проверка паритета.

101
00:05:57,300 --> 00:06:00,024
Для проверки четности мы выделяем только один бит,

102
00:06:00,024 --> 00:06:03,818
за настройку которого отвечает отправитель, а остальные могут свободно

103
00:06:03,818 --> 00:06:04,940
переносить сообщение.

104
00:06:04,940 --> 00:06:08,551
Единственная задача этого специального бита — убедиться,

105
00:06:08,551 --> 00:06:12,100
что общее количество единиц в сообщении является четным.

106
00:06:12,100 --> 00:06:15,610
Например, сейчас общее количество единиц равно 7, это нечетно,

107
00:06:15,610 --> 00:06:19,511
поэтому отправителю необходимо перевернуть этот специальный бит на 1,

108
00:06:19,511 --> 00:06:20,960
чтобы сделать счет четным.

109
00:06:20,960 --> 00:06:24,445
Но если бы блок уже начинался с четного числа единиц,

110
00:06:24,445 --> 00:06:27,480
тогда этот специальный бит остался бы равным 0.

111
00:06:27,480 --> 00:06:32,843
Это довольно просто, обманчиво просто, но это невероятно элегантный способ выразить

112
00:06:32,843 --> 00:06:37,760
идею изменения в любом месте сообщения и отразить ее в одном бите информации.

113
00:06:37,760 --> 00:06:42,880
Обратите внимание: если какой-либо бит этого сообщения переворачивается с

114
00:06:42,880 --> 00:06:48,140
0 на 1 или с 1 на 0, общее количество единиц меняется с четного на нечетное.

115
00:06:48,140 --> 00:06:53,079
Итак, если вы получатель, посмотрите на это сообщение и увидите нечетное число единиц,

116
00:06:53,079 --> 00:06:56,145
вы можете точно знать, что произошла какая-то ошибка,

117
00:06:56,145 --> 00:06:58,700
даже если вы понятия не имеете, где она была.

118
00:06:58,700 --> 00:07:04,940
На жаргоне четное или нечетное количество единиц в группе битов называется ее четностью.

119
00:07:04,940 --> 00:07:07,985
Вы также можете использовать числа и сказать, что четность равна 0 или 1,

120
00:07:07,985 --> 00:07:11,320
что обычно более полезно, когда вы начинаете заниматься математикой с этой идеей.

121
00:07:11,320 --> 00:07:16,345
И этот специальный бит, который отправитель использует для контроля четности,

122
00:07:16,345 --> 00:07:18,020
называется битом четности.

123
00:07:18,020 --> 00:07:21,788
И на самом деле, нам должно быть ясно: если получатель видит нечетную четность,

124
00:07:21,788 --> 00:07:25,509
это не обязательно означает, что была только одна ошибка, могло быть 3 ошибки,

125
00:07:25,509 --> 00:07:29,560
или 5, или любое другое нечетное число, но он может знать это наверняка. что это не 0.

126
00:07:29,560 --> 00:07:33,640
С другой стороны, если бы было 2 ошибки или любое четное количество ошибок,

127
00:07:33,640 --> 00:07:36,486
итоговое количество единиц все равно было бы четным,

128
00:07:36,486 --> 00:07:39,225
поэтому получатель не может быть полностью уверен,

129
00:07:39,225 --> 00:07:43,360
что четное количество обязательно означает, что сообщение не содержит ошибок.

130
00:07:43,360 --> 00:07:47,474
Вы можете жаловаться, что сообщение, которое искажается всего лишь двумя битами,

131
00:07:47,474 --> 00:07:49,760
довольно слабое, и вы будете абсолютно правы.

132
00:07:49,760 --> 00:07:53,622
Однако имейте в виду, что не существует метода обнаружения или исправления ошибок,

133
00:07:53,622 --> 00:07:55,857
который мог бы дать вам 100% уверенность в том,

134
00:07:55,857 --> 00:07:59,720
что полученное вами сообщение является именно тем, которое намеревался отправитель.

135
00:07:59,720 --> 00:08:02,876
В конце концов, достаточное количество случайного шума всегда может превратить одно

136
00:08:02,876 --> 00:08:05,920
действительное сообщение в другое действительное сообщение по чистой случайности.

137
00:08:05,920 --> 00:08:09,223
Вместо этого цель состоит в том, чтобы придумать схему,

138
00:08:09,223 --> 00:08:13,648
устойчивую к определенному максимальному количеству ошибок, или, возможно,

139
00:08:13,648 --> 00:08:16,480
снизить вероятность такого ложного срабатывания.

140
00:08:16,480 --> 00:08:20,040
Сами по себе проверки четности довольно слабы, но,

141
00:08:20,040 --> 00:08:23,741
сведя идею изменения всего сообщения до одного бита,

142
00:08:23,741 --> 00:08:28,000
они дают нам мощный строительный блок для более сложных схем.

143
00:08:28,000 --> 00:08:31,501
Например, когда Хэмминг искал способ определить, где произошла ошибка,

144
00:08:31,501 --> 00:08:35,052
а не только то, что она произошла, его ключевой вывод заключался в том,

145
00:08:35,052 --> 00:08:38,652
что если вы примените некоторые проверки четности не ко всему сообщению,

146
00:08:38,652 --> 00:08:41,217
а к определенным тщательно выбранным подмножествам,

147
00:08:41,217 --> 00:08:43,782
вы можете спросить более уточненная серия вопросов,

148
00:08:43,782 --> 00:08:46,840
позволяющая определить местонахождение любой единичной ошибки.

149
00:08:46,840 --> 00:08:49,657
Общее ощущение немного похоже на игру из 20 вопросов,

150
00:08:49,657 --> 00:08:54,300
когда вы задаете вопросы «да» или «нет», которые делят пространство возможностей пополам.

151
00:08:54,300 --> 00:08:58,596
Например, предположим, что мы выполняем проверку четности только для этих 8 бит,

152
00:08:58,596 --> 00:09:00,400
всех позиций с нечетными номерами.

153
00:09:00,400 --> 00:09:04,889
Затем, если ошибка обнаружена, он дает приемнику немного больше информации о том,

154
00:09:04,889 --> 00:09:09,160
где именно находится ошибка, а именно, что она находится в нечетном положении.

155
00:09:09,160 --> 00:09:13,075
Если среди этих 8 бит не обнаружено ошибок, это либо означает,

156
00:09:13,075 --> 00:09:17,240
что ошибки вообще нет, либо она находится где-то в четных позициях.

157
00:09:17,240 --> 00:09:21,311
Вы можете подумать, что ограничение проверки четности половиной битов делает

158
00:09:21,311 --> 00:09:25,489
ее менее эффективной, но когда она выполняется в сочетании с другими правильно

159
00:09:25,489 --> 00:09:29,720
выбранными проверками, это, как ни странно, дает нам нечто гораздо более мощное.

160
00:09:29,720 --> 00:09:33,415
Помните, что для фактической настройки проверки четности необходимо

161
00:09:33,415 --> 00:09:37,600
выделить какой-то специальный бит, который контролирует четность всей группы.

162
00:09:37,600 --> 00:09:39,920
Здесь давайте просто выберем позицию 1.

163
00:09:39,920 --> 00:09:43,349
В показанном примере четность этих 8 бит в настоящее время нечетная,

164
00:09:43,349 --> 00:09:47,275
поэтому отправитель несет ответственность за переключение этого бита четности,

165
00:09:47,275 --> 00:09:48,220
и теперь он четный.

166
00:09:48,220 --> 00:09:51,040
Это только 1 из 4 проверок четности, которые мы проведем.

167
00:09:51,040 --> 00:09:54,434
Вторая проверка осуществляется среди 8 бит в правой половине сетки,

168
00:09:54,434 --> 00:09:56,880
по крайней мере, так, как мы ее нарисовали здесь.

169
00:09:56,880 --> 00:10:00,728
На этот раз мы могли бы использовать позицию 2 в качестве бита четности,

170
00:10:00,728 --> 00:10:05,104
так что эти 8 бит уже имеют четность, и отправитель может чувствовать себя хорошо,

171
00:10:05,104 --> 00:10:07,160
оставив этот бит номер 2 без изменений.

172
00:10:07,160 --> 00:10:11,613
Затем, на другом конце, если получатель проверит четность этой группы и обнаружит,

173
00:10:11,613 --> 00:10:15,960
что она нечетная, он узнает, что ошибка находится где-то среди этих 8 бит справа.

174
00:10:15,960 --> 00:10:21,260
В противном случае это означает, что либо ошибки нет, либо ошибка где-то в левой половине.

175
00:10:21,260 --> 00:10:24,967
Или я предполагаю, что ошибок могло быть две, но сейчас мы будем предполагать,

176
00:10:24,967 --> 00:10:27,080
что во всем блоке есть не более одной ошибки.

177
00:10:27,080 --> 00:10:29,160
Более того, все полностью ломается.

178
00:10:29,160 --> 00:10:32,330
Здесь, прежде чем мы рассмотрим следующие две проверки, подумайте,

179
00:10:32,330 --> 00:10:35,880
что позволяют нам делать первые две проверки, если рассматривать их вместе.

180
00:10:35,880 --> 00:10:40,240
Допустим, вы обнаружили ошибку среди нечетных столбцов и среди правой половины.

181
00:10:40,240 --> 00:10:43,940
Это обязательно означает, что ошибка находится где-то в последнем столбце.

182
00:10:43,940 --> 00:10:47,618
Если в нечетном столбце не было ошибки, но она была в правой половине,

183
00:10:47,618 --> 00:10:50,520
это означает, что она находится в предпоследнем столбце.

184
00:10:50,520 --> 00:10:53,057
Аналогично, если ошибка есть в нечетных столбцах,

185
00:10:53,057 --> 00:10:56,560
но не в правой половине, вы знаете, что она где-то во втором столбце.

186
00:10:56,560 --> 00:11:00,347
И если ни одна из этих двух проверок четности ничего не обнаружит, это означает,

187
00:11:00,347 --> 00:11:03,760
что единственное место, где может быть ошибка, — это самый левый столбец.

188
00:11:03,760 --> 00:11:06,480
Но это также может означать, что ошибки вообще нет.

189
00:11:06,480 --> 00:11:09,037
Это довольно расплывчатый способ сказать, что две

190
00:11:09,037 --> 00:11:11,800
проверки четности позволяют нам зафиксировать столбец.

191
00:11:11,800 --> 00:11:14,000
Отсюда вы, вероятно, можете догадаться, что будет дальше.

192
00:11:14,000 --> 00:11:16,240
Мы делаем в основном то же самое, но для строк.

193
00:11:16,240 --> 00:11:18,616
Будет произведена проверка четности нечетных строк

194
00:11:18,616 --> 00:11:21,040
с использованием позиции 4 в качестве бита четности.

195
00:11:21,040 --> 00:11:26,480
Итак, в этом примере эта группа уже имеет четность, поэтому бит 4 будет установлен в 0.

196
00:11:26,480 --> 00:11:29,230
И, наконец, в двух нижних строках выполняется проверка

197
00:11:29,230 --> 00:11:32,280
четности с использованием позиции 8 в качестве бита четности.

198
00:11:32,280 --> 00:11:35,967
В этом случае похоже, что отправителю необходимо включить бит 8,

199
00:11:35,967 --> 00:11:37,840
чтобы обеспечить четность группе.

200
00:11:37,840 --> 00:11:41,004
Так же, как первые две проверки позволяют нам закрепить столбец,

201
00:11:41,004 --> 00:11:43,000
следующие две позволяют закрепить строку.

202
00:11:43,000 --> 00:11:47,213
В качестве примера представьте, что во время передачи возникла ошибка,

203
00:11:47,213 --> 00:11:48,400
скажем, в позиции 3.

204
00:11:48,400 --> 00:11:52,702
Ну, это влияет на первую группу четности, а также влияет на вторую группу четности,

205
00:11:52,702 --> 00:11:56,340
поэтому получатель знает, что где-то в этом правом столбце есть ошибка.

206
00:11:56,340 --> 00:12:01,380
Но это не влияет на третью группу и не влияет на четвертую группу.

207
00:12:01,380 --> 00:12:05,020
И это позволяет получателю точно определить ошибку до первой строки,

208
00:12:05,020 --> 00:12:08,660
что обязательно означает позицию 3, чтобы они могли исправить ошибку.

209
00:12:08,660 --> 00:12:11,755
Возможно, вам понравится потратить время на то, чтобы убедить себя в том,

210
00:12:11,755 --> 00:12:14,558
что ответы на эти четыре вопроса действительно всегда позволят вам

211
00:12:14,558 --> 00:12:17,320
определить конкретное место, независимо от того, где оно окажется.

212
00:12:17,320 --> 00:12:20,451
На самом деле, самые проницательные из вас могут даже

213
00:12:20,451 --> 00:12:23,640
заметить связь между этими вопросами и двоичным счетом.

214
00:12:23,640 --> 00:12:27,469
А если да, то еще раз позвольте мне подчеркнуть, сделать паузу,

215
00:12:27,469 --> 00:12:30,880
попытаться самому уловить связь, прежде чем я ее испорчу.

216
00:12:30,880 --> 00:12:34,960
Если вам интересно, что произойдет, если будет затронут сам бит четности,

217
00:12:34,960 --> 00:12:36,560
вы можете просто попробовать.

218
00:12:36,560 --> 00:12:41,683
Найдите минутку и подумайте, как можно отследить любую ошибку среди этих четырех

219
00:12:41,683 --> 00:12:46,870
специальных битов, как и любую другую, с помощью одной и той же группы из четырех

220
00:12:46,870 --> 00:12:47,440
вопросов.

221
00:12:47,440 --> 00:12:50,195
На самом деле это не имеет значения, поскольку, в конце концов,

222
00:12:50,195 --> 00:12:53,640
мы хотим защитить биты сообщения, а биты исправления ошибок просто продолжаются.

223
00:12:53,640 --> 00:12:56,019
Но защита и этих частей также является чем-то,

224
00:12:56,019 --> 00:12:59,260
что естественным образом выпадает из схемы как побочный продукт.

225
00:12:59,260 --> 00:13:02,380
Вам также может понравиться предвидеть, как это масштабируется.

226
00:13:02,380 --> 00:13:06,477
Если бы мы использовали блок размером 256 бит, например,

227
00:13:06,477 --> 00:13:11,150
чтобы определить местоположение, вам нужно всего восемь вопросов

228
00:13:11,150 --> 00:13:15,680
«да» или «нет» для двоичного поиска пути к определенному месту.

229
00:13:15,680 --> 00:13:19,913
И помните, каждый вопрос требует отказа только от одного бита,

230
00:13:19,913 --> 00:13:23,340
чтобы установить соответствующую проверку четности.

231
00:13:23,340 --> 00:13:26,466
Некоторые из вас, возможно, уже видели это, но позже мы поговорим о

232
00:13:26,466 --> 00:13:29,960
систематическом способе узнать, что это за вопросы, всего за минуту или две.

233
00:13:29,960 --> 00:13:33,242
Надеюсь, этого эскиза будет достаточно, чтобы оценить эффективность того,

234
00:13:33,242 --> 00:13:34,440
что мы здесь разрабатываем.

235
00:13:34,440 --> 00:13:38,375
Первое, за исключением этих восьми выделенных битов четности, может быть любым,

236
00:13:38,375 --> 00:13:41,720
каким вы хотите, неся любое сообщение или данные, которые вы хотите.

237
00:13:41,720 --> 00:13:47,997
8 бит избыточны в том смысле, что они полностью определяются остальной частью сообщения,

238
00:13:47,997 --> 00:13:53,640
но это гораздо более разумный способ, чем простое копирование сообщения целиком.

239
00:13:53,640 --> 00:13:56,408
И все же, приложив так мало усилий, вы сможете

240
00:13:56,408 --> 00:13:59,000
выявить и исправить любую ошибку в один бит.

241
00:13:59,000 --> 00:14:00,400
Ну, почти.

242
00:14:00,400 --> 00:14:03,311
Итак, единственная проблема здесь заключается в том,

243
00:14:03,311 --> 00:14:08,036
что если ни одна из четырех проверок четности не обнаруживает ошибку, а это означает,

244
00:14:08,036 --> 00:14:11,552
что все специально выбранные подмножества 8 бит имеют четность,

245
00:14:11,552 --> 00:14:15,947
как и предполагал отправитель, то это либо означает, что ошибки вообще не было.

246
00:14:15,947 --> 00:14:17,760
, или это сузит нас до позиции 0.

247
00:14:17,760 --> 00:14:21,694
Видите ли, с четырьмя вопросами «да» или «нет» у нас есть 16 возможных

248
00:14:21,694 --> 00:14:25,407
результатов для наших проверок на четность, и поначалу это кажется

249
00:14:25,407 --> 00:14:28,677
идеальным для точного определения 1 из 16 позиций в блоке,

250
00:14:28,677 --> 00:14:33,000
но вам также необходимо сообщить 17-й результат, отсутствие ошибки. состояние.

251
00:14:33,000 --> 00:14:37,860
Решение здесь на самом деле довольно простое: просто забудьте полностью об этом 0-м бите.

252
00:14:37,860 --> 00:14:41,142
Поэтому, когда мы выполняем четыре проверки четности и видим,

253
00:14:41,142 --> 00:14:44,320
что все они четные, это однозначно означает, что ошибки нет.

254
00:14:44,320 --> 00:14:49,113
Это означает, что вместо работы с 16-битным блоком мы работаем с 15-битным блоком,

255
00:14:49,113 --> 00:14:54,080
где 11 бит свободны для передачи сообщения, а 4 из них предназначены для избыточности.

256
00:14:54,080 --> 00:14:59,400
И теперь у нас есть то, что люди в бизнесе называют кодом Хэмминга 15-11.

257
00:14:59,400 --> 00:15:03,029
Тем не менее, приятно иметь размер блока, равный чистой степени 2,

258
00:15:03,029 --> 00:15:07,688
и есть умный способ сохранить этот 0-й бит и заставить его выполнять за нас небольшую

259
00:15:07,688 --> 00:15:08,880
дополнительную работу.

260
00:15:08,880 --> 00:15:12,090
Если мы используем его в качестве бита четности во всем блоке,

261
00:15:12,090 --> 00:15:16,320
это позволяет нам обнаруживать 2-битные ошибки, даже если мы не можем их исправить.

262
00:15:16,320 --> 00:15:17,440
Вот как это работает.

263
00:15:17,440 --> 00:15:20,652
После установки этих четырех специальных битов, исправляющих ошибки,

264
00:15:20,652 --> 00:15:23,957
мы устанавливаем этот 0-й бит, чтобы четность всего блока была четной,

265
00:15:23,957 --> 00:15:25,540
как при обычной проверке четности.

266
00:15:25,540 --> 00:15:30,094
Теперь, если есть ошибка в один бит, то четность полного блока переключается на нечетную,

267
00:15:30,094 --> 00:15:33,940
но мы все равно уловим это благодаря четырем проверкам, исправляющим ошибки.

268
00:15:33,940 --> 00:15:37,978
Однако, если есть две ошибки, то общая четность снова станет четной,

269
00:15:37,978 --> 00:15:42,776
но получатель все равно увидит, что произошла хотя бы какая-то ошибка из-за того,

270
00:15:42,776 --> 00:15:45,820
что происходит с этими четырьмя проверками четности.

271
00:15:45,820 --> 00:15:49,177
Поэтому, если они заметят в целом четность, но с другими проверками

272
00:15:49,177 --> 00:15:52,980
происходит что-то ненулевое, это говорит им, что было как минимум две ошибки.

273
00:15:52,980 --> 00:15:54,420
Разве это не умно?

274
00:15:54,420 --> 00:15:57,837
Несмотря на то, что мы не можем исправить эти 2-битные ошибки,

275
00:15:57,837 --> 00:16:02,340
просто вернув в работу этот маленький надоедливый 0-й бит, мы сможем их обнаружить.

276
00:16:02,340 --> 00:16:06,540
Это довольно стандартный код, известный как расширенный код Хэмминга.

277
00:16:06,540 --> 00:16:09,759
Технически говоря, теперь у вас есть полное описание того,

278
00:16:09,759 --> 00:16:13,580
что делает код Хэмминга, по крайней мере, на примере 16-битного блока.

279
00:16:13,580 --> 00:16:18,553
Но я думаю, вам будет приятнее проверить свое понимание и закрепить все до этого момента,

280
00:16:18,553 --> 00:16:21,980
выполнив один полный пример от начала до конца самостоятельно.

281
00:16:21,980 --> 00:16:25,100
Я пройду через это вместе с вами, чтобы вы могли проверить себя.

282
00:16:25,100 --> 00:16:27,871
Чтобы настроить сообщение, будь то буквальное сообщение,

283
00:16:27,871 --> 00:16:30,837
которое вы транслируете в пространстве, или какие-то данные,

284
00:16:30,837 --> 00:16:34,387
которые вы хотите сохранить во времени, первым шагом является разделение

285
00:16:34,387 --> 00:16:35,700
его на 11-битные фрагменты.

286
00:16:35,700 --> 00:16:40,340
Каждый фрагмент будет упакован в устойчивый к ошибкам 16-битный блок.

287
00:16:40,340 --> 00:16:43,740
Итак, давайте возьмем это в качестве примера и на самом деле разберемся.

288
00:16:43,740 --> 00:16:45,380
Давай, действительно сделай это!

289
00:16:45,380 --> 00:16:52,980
Давайте остановимся и попробуем собрать этот блок.

290
00:16:52,980 --> 00:16:53,980
Хорошо, ты готов?

291
00:16:53,980 --> 00:16:57,571
Помните, что позиция 0 вместе с другими степенями двойки

292
00:16:57,571 --> 00:17:01,415
зарезервирована для исправления ошибок, поэтому вы начинаете

293
00:17:01,415 --> 00:17:05,700
с размещения битов сообщения во всех оставшихся позициях по порядку.

294
00:17:05,700 --> 00:17:09,393
Вам нужно, чтобы эта группа имела четную четность, которая уже есть,

295
00:17:09,393 --> 00:17:13,140
поэтому вам следует установить этот бит четности в позиции 1 равным 0.

296
00:17:13,140 --> 00:17:15,996
Следующая группа начинается с нечетной четности,

297
00:17:15,996 --> 00:17:19,260
поэтому вам следует установить ее бит четности равным 1.

298
00:17:19,260 --> 00:17:21,769
Следующая группа начинается с нечетной четности,

299
00:17:21,769 --> 00:17:24,740
поэтому вам снова следует установить ее бит четности на 1.

300
00:17:24,740 --> 00:17:27,959
И последняя группа также имеет нечетную четность,

301
00:17:27,959 --> 00:17:31,500
то есть мы устанавливаем этот бит в позиции 8 равным 1.

302
00:17:31,500 --> 00:17:36,808
И затем, в качестве последнего шага, полный блок теперь имеет четность, что означает,

303
00:17:36,808 --> 00:17:41,500
что вы можете установить этот бит с номером 0, общий бит четности, равным 0.

304
00:17:41,500 --> 00:17:44,966
Таким образом, при отправке этого блока четность четырех

305
00:17:44,966 --> 00:17:48,980
специальных подмножеств и блока в целом будет четной или равной 0.

306
00:17:48,980 --> 00:17:53,620
Во второй части упражнения давайте попросим вас сыграть роль получателя.

307
00:17:53,620 --> 00:17:56,960
Конечно, это будет означать, что вы еще не знаете, что это за сообщение, возможно,

308
00:17:56,960 --> 00:18:00,180
некоторые из вас его запомнили, но давайте предположим, что вы этого не сделали.

309
00:18:00,180 --> 00:18:04,918
Что я собираюсь сделать, так это изменить 0, 1 или 2 бита в этом блоке,

310
00:18:04,918 --> 00:18:08,340
а затем попросить вас выяснить, что именно я сделал.

311
00:18:08,340 --> 00:18:13,460
Итак, еще раз сделайте паузу и попробуйте разобраться.

312
00:18:13,460 --> 00:18:21,640
Хорошо, теперь вы, как получатель, проверяете первую группу четности и видите,

313
00:18:21,640 --> 00:18:29,820
что она четная, поэтому любая существующая ошибка должна быть в четном столбце.

314
00:18:29,820 --> 00:18:33,806
Следующая проверка дает нам нечетное число, сообщающее нам обоим,

315
00:18:33,806 --> 00:18:38,760
что есть по крайней мере одна ошибка, и сужающее нас до этого конкретного столбца.

316
00:18:38,760 --> 00:18:42,900
Третья проверка четная, еще больше сокращая возможности.

317
00:18:42,900 --> 00:18:46,476
И последняя проверка четности является нечетной и говорит нам,

318
00:18:46,476 --> 00:18:49,883
что где-то внизу есть ошибка, которая, как мы теперь видим,

319
00:18:49,883 --> 00:18:51,700
должна быть на позиции номер 10.

320
00:18:51,700 --> 00:18:56,447
Более того, четность всего блока нечетная, что дает нам уверенность в том,

321
00:18:56,447 --> 00:18:58,220
что был один флип, а не два.

322
00:18:58,220 --> 00:19:01,600
Если их три или больше, все ставки аннулируются.

323
00:19:01,600 --> 00:19:04,841
После исправления этого бита номер 10 извлечение 11 бит,

324
00:19:04,841 --> 00:19:09,733
которые не использовались для исправления, дает нам соответствующий сегмент исходного

325
00:19:09,733 --> 00:19:14,795
сообщения, который, если перемотать назад и сравнить, действительно является именно тем,

326
00:19:14,795 --> 00:19:16,160
с чего мы начали пример.

327
00:19:16,160 --> 00:19:19,842
И теперь, когда вы знаете, как делать все это вручную, я хотел бы показать вам,

328
00:19:19,842 --> 00:19:23,940
как можно реализовать основную часть всей этой логики с помощью одной строки кода Python.

329
00:19:23,940 --> 00:19:28,533
Видите ли, я еще не рассказал вам, насколько на самом деле элегантен этот алгоритм,

330
00:19:28,533 --> 00:19:32,088
насколько просто заставить машину указывать на положение ошибки,

331
00:19:32,088 --> 00:19:35,970
как ее систематически масштабировать и как мы можем сформулировать все

332
00:19:35,970 --> 00:19:39,580
это как одна операция, а не несколько отдельных проверок четности.

333
00:19:39,580 --> 00:19:39,580
Чтобы понять, что я имею в виду, присоединяйтесь ко мне во второй части.

