1
00:00:00,000 --> 00:00:05,752
您是否想过如何在刮擦 CD 或 DV

2
00:00:05,752 --> 00:00:10,900
D 后仍然可以播放其中存储的内容？

3
00:00:10,900 --> 00:00:15,410
划痕确实会影响磁盘上的 1 和 0，因此它会读取

4
00:00:15,410 --> 00:00:19,740
与存储的数据不同的数据，但除非它确实被划伤，否

5
00:00:19,740 --> 00:00:24,250
则它读取的位会被解码为与编码到其上的文件完全相同

6
00:00:24,250 --> 00:00:28,400
的文件，尽管存在所有这些错误，但还是逐位复制。

7
00:00:28,400 --> 00:00:32,713
大量的数学智慧使我们能够以一种能够抵御错误的

8
00:00:32,713 --> 00:00:36,840
方式存储数据，并且同样重要的是能够传输数据。

9
00:00:36,840 --> 00:00:39,745
好吧，好吧，实际上并不需要那么聪

10
00:00:39,745 --> 00:00:42,480
明就能想出一种方法来做到这一点。

11
00:00:42,480 --> 00:00:46,814
任何文件，无论是视频、声音还是文本、代码、图

12
00:00:46,814 --> 00:00:50,960
像等等，最终都是由 1 和 0 组成的序列。

13
00:00:50,960 --> 00:00:57,780
纠正任何被翻转的位的一个简单 策略是存储每个位的三个副本。

14
00:00:57,780 --> 00:01:02,708
然后，读取该文件的机器可以比较这三个副本，并在出

15
00:01:02,708 --> 00:01:07,440
现差异时始终从 3 个副本中取出最好的 2 个。

16
00:01:07,440 --> 00:01:11,560
但这意味着将三分之二的空间用于冗余。

17
00:01:11,560 --> 00:01:15,004
即便如此，对于所有放弃的空间，也不能强有

18
00:01:15,004 --> 00:01:18,120
力地保证如果超过一位被翻转会发生什么。

19
00:01:18,120 --> 00:01:21,613
更有趣的问题是如何做到这一点，以便在

20
00:01:21,613 --> 00:01:24,740
放弃尽可能少的空间的同时纠正错误。

21
00:01:24,740 --> 00:01:29,390
例如，使用您将在本视频中了解的方法，您可以将数据存储在

22
00:01:29,390 --> 00:01:33,043
256 位块中，其中每个块使用 9 位，9！

23
00:01:33,043 --> 00:01:36,919
作为一种冗余，其他 2 47 位可以自

24
00:01:36,919 --> 00:01:41,000
由地携带任何您想要的有意义的消息或数据。

25
00:01:41,000 --> 00:01:45,105
情况仍然是这样，如果这里有任何位被翻转，

26
00:01:45,105 --> 00:01:49,210
只需查看这个块，机器就能够识别出存在错误

27
00:01:49,210 --> 00:01:53,120
以及错误的确切位置，以便知道如何纠正它。

28
00:01:53,120 --> 00:01:55,540
老实说，这感觉就像魔法一样。

29
00:01:55,540 --> 00:01:59,437
对于这个特定的方案，如果两个位被翻转，机器至少能

30
00:01:59,437 --> 00:02:03,180
够检测到存在两个错误，尽管它不知道如何修复它们。

31
00:02:03,180 --> 00:02:08,140
稍后我们将讨论如何针对不同大小的块进行缩放。

32
00:02:08,140 --> 00:02:13,880
可以合理地纠正此类错 误的方法称为纠错码。

33
00:02:13,880 --> 00:02:18,608
在上个世纪的大部分时间里，这个领域一直是令人惊讶的深度

34
00:02:18,608 --> 00:02:23,000
数学的丰富来源，这些数学被纳入我们每天使用的设备中。

35
00:02:23,000 --> 00:02:29,660
这里的目标是让您非常彻底地了 解最早的示例之一，即汉明码。

36
00:02:29,660 --> 00:02:33,356
顺便说一句，我对这个视频结构的思考方式并

37
00:02:33,356 --> 00:02:36,876
不是尽可能直接地解释它，而是提示你自己

38
00:02:36,876 --> 00:02:40,220
发明它，并时不时地给予一些温和的指导。

39
00:02:40,220 --> 00:02:43,828
因此，当你觉得你在某个时刻看到了它的发展方向时，请花点

40
00:02:43,828 --> 00:02:47,180
时间停下来，在我告诉你之前积极预测该计划将会是什么。

41
00:02:47,180 --> 00:02:51,236
另外，如果你想让你的理解深入到硬件层面，Ben

42
00:02:51,236 --> 00:02:55,463
Eater 制作了一个与此相关的视频，向你展示如

43
00:02:55,463 --> 00:02:59,520
何在面包板上实际实现汉明码，这是非常令人满意的。

44
00:02:59,520 --> 00:03:04,542
您应该知道，汉明码并不像里德-所罗门算法等更现代的代码那

45
00:03:04,542 --> 00:03:09,564
样广泛使用，但是这项任务一开始感觉不可能，而一旦完成却显

46
00:03:09,564 --> 00:03:14,240
得多么合理，两者之间的对比有一定的魔力。你了解了汉明。

47
00:03:14,240 --> 00:03:18,660
纠错的基本原理是，在所有可能消息的巨大

48
00:03:18,660 --> 00:03:22,860
空间中，只有某些子集将被视为有效消息。

49
00:03:22,860 --> 00:03:29,100
打个比方，想想拼写正确的单词和拼写错误的单词。

50
00:03:29,100 --> 00:03:33,827
每当有效消息被更改时，接收者就有责任将他们看到的内容

51
00:03:33,827 --> 00:03:38,380
纠正回最近的有效邻居，就像您可能会处理拼写错误一样。

52
00:03:38,380 --> 00:03:42,888
不过，想出一个具体的算法来有效地对这

53
00:03:42,888 --> 00:03:47,160
样的消息进行分类需要一定的聪明才智。

54
00:03:47,160 --> 00:03:50,333
故事开始于 20 世纪 40 年代，当时年轻的理查德·汉明

55
00:03:50,333 --> 00:03:52,342
(R ichard Hamming)

56
00:03:52,342 --> 00:03:54,141
在贝尔实验室工作，他的一些工作涉

57
00:03:54,141 --> 00:03:56,679
及使用一台非常昂贵的打孔卡计算机，而他只能有限地

58
00:03:56,679 --> 00:03:57,420
使用该计算机。

59
00:03:57,420 --> 00:04:03,140
他不断执行的程序总是失败， 因为时不时会有一点被误读。

60
00:04:03,140 --> 00:04:06,401
挫折是发明的严峻考验，他受够了，

61
00:04:06,401 --> 00:04:09,280
因此发明了世界上第一个纠错码。

62
00:04:09,280 --> 00:04:13,039
构建汉明码的方法有很多种，但作为第一步，

63
00:04:13,039 --> 00:04:16,620
我们将按照汉明本人对它们的看法来了解它。

64
00:04:16,620 --> 00:04:21,400
让我们使用一个简单但又不太简单的例子，一个 16 位的块。

65
00:04:21,400 --> 00:04:25,700
我们将这些位的位置从 0 到 15 进行编号。

66
00:04:25,700 --> 00:04:29,996
我们想要存储的实际数据仅由其中的 12 位组

67
00:04:29,996 --> 00:04:33,920
成，而其中 4 个位置被保留作为一种冗余。

68
00:04:33,920 --> 00:04:37,202
这里的冗余一词并不简单地意味着复制，毕竟这4

69
00:04:37,202 --> 00:04:40,200
位并没有给我们足够的空间来盲目地复制数据。

70
00:04:40,200 --> 00:04:44,707
相反，它们需要更加细致和巧妙的冗余，

71
00:04:44,707 --> 00:04:48,740
不是添加任何新信息，而是增加弹性。

72
00:04:48,740 --> 00:04:52,705
您可能期望这 4 个特殊位能够很好地打包在一起，

73
00:04:52,705 --> 00:04:56,671
也许是在最后或类似的地方，但正如您所看到的，让它

74
00:04:56,671 --> 00:05:00,320
们位于 2 的幂的位置可以让最终变得非常优雅。

75
00:05:00,320 --> 00:05:05,420
它还可能会给您一些关于如何扩展到更大块的提示。

76
00:05:05,420 --> 00:05:09,920
另外，从技术上讲，它最终只有 11 位数据，您会发现位

77
00:05:09,920 --> 00:05:14,260
置 0 处发生的情况有轻微的细微差别，但现在不用担心。

78
00:05:14,260 --> 00:05:18,485
与任何纠错算法一样，这将涉及两个参与者：一

79
00:05:18,485 --> 00:05:22,518
个负责设置这 4 个特殊位的发送者，以及

80
00:05:22,518 --> 00:05:26,360
一个负责执行某种检查和纠正错误的接收者。

81
00:05:26,360 --> 00:05:29,552
当然，“发送者”和“接收者”这两个词实际

82
00:05:29,552 --> 00:05:32,592
上是指执行所有检查的机器或软件，并且消

83
00:05:32,592 --> 00:05:35,480
息的概念含义非常广泛，包括存储等内容。

84
00:05:35,480 --> 00:05:39,230
毕竟，存储数据与将消息从过去发送到未来是一

85
00:05:39,230 --> 00:05:42,640
样的，而不是从一个地方发送到另一个地方。

86
00:05:42,640 --> 00:05:46,471
这就是设置，但在我们深入讨论之前，我们需要讨

87
00:05:46,471 --> 00:05:50,136
论一个相关的想法，这是汉明在发现时的新鲜想

88
00:05:50,136 --> 00:05:53,801
法，这种方法可以让您检测到任何单个位错误，

89
00:05:53,801 --> 00:05:57,300
但不能纠正它们，已知在业务中作为奇偶校验。

90
00:05:57,300 --> 00:06:01,321
对于奇偶校验，我们只分离出发送者负责调

91
00:06:01,321 --> 00:06:04,940
整的一位，其余的可以自由地携带消息。

92
00:06:04,940 --> 00:06:12,100
该特殊位的唯一作用是确保消 息中 1 的总数为偶数。

93
00:06:12,100 --> 00:06:16,722
例如，现在 1 的总数是 7，这是奇数，因此发

94
00:06:16,722 --> 00:06:20,960
送方需要将该特殊位翻转为 1，使计数为偶数。

95
00:06:20,960 --> 00:06:24,423
但如果该块已经以偶数个 1 开始

96
00:06:24,423 --> 00:06:27,480
，那么这个特殊位将保持为 0。

97
00:06:27,480 --> 00:06:32,803
这非常简单，看似简单，但它是一种极其优雅的方式，可以将消

98
00:06:32,803 --> 00:06:37,760
息中任何位置的变化的想法提炼出来，并反映在单个信息中。

99
00:06:37,760 --> 00:06:42,666
请注意，如果此消息的任何位被翻转（从 0 变为 1

100
00:06:42,666 --> 00:06:48,140
或从 1 变为 0），它会将 1 的总数从偶数更改为奇数。

101
00:06:48,140 --> 00:06:52,972
因此，如果您是接收者，您查看此消息，并 且看到奇数个

102
00:06:52,972 --> 00:06:58,163
1，您可以确定发生了某些 错误，即使您可能不知道错误发生在

103
00:06:58,163 --> 00:06:58,700
哪里。

104
00:06:58,700 --> 00:07:01,920
用行话来说，一组位的 1 数量

105
00:07:01,920 --> 00:07:04,940
是偶数还是奇数，称为奇偶校验。

106
00:07:04,940 --> 00:07:08,257
您还可以使用数字并表示奇偶校验为 0 或 1，一旦

107
00:07:08,257 --> 00:07:11,320
您开始用这个想法进行数学计算，这通常会更有帮助。

108
00:07:11,320 --> 00:07:18,020
发送方用来控制奇偶校验的 特殊位称为奇偶校验位。

109
00:07:18,020 --> 00:07:21,960
实际上，我们应该清楚，如果接收器看到奇数奇偶校验，并不

110
00:07:21,960 --> 00:07:25,619
一定意味着只有一个错误，可能有 3 个错误，或 5

111
00:07:25,619 --> 00:07:29,560
个 错误，或任何其他奇数，但他们可以肯定知道它不是 0。

112
00:07:29,560 --> 00:07:34,291
另一方面，如果出现 2 个错误，或者任何偶数个

113
00:07:34,291 --> 00:07:39,022
错误，则最终的 1 计数仍然是偶数，因此接收方

114
00:07:39,022 --> 00:07:43,360
无法完全确信偶数计数一定意味着消息没有错误。

115
00:07:43,360 --> 00:07:46,748
您可能会抱怨仅通过 2 位翻转就搞

116
00:07:46,748 --> 00:07:49,760
乱的消息非常弱，您是绝对正确的。

117
00:07:49,760 --> 00:07:54,532
但请记住，没有任何错误检测或纠正方法可以让您

118
00:07:54,532 --> 00:07:59,720
1 00% 确信您收到的消息正是发件人想要的消息。

119
00:07:59,720 --> 00:08:02,913
毕竟，足够多的随机噪声总能偶然将

120
00:08:02,913 --> 00:08:05,920
一条有效消息变成另一条有效消息。

121
00:08:05,920 --> 00:08:11,312
相反，我们的目标是提出一种在一定的最大错误数范

122
00:08:11,312 --> 00:08:16,480
围内稳健的方案，或者减少像这样的误报的可能性。

123
00:08:16,480 --> 00:08:20,467
奇偶校验本身相当弱，但通过将整个消

124
00:08:20,467 --> 00:08:24,455
息的变化思想提炼为单个位，它们为我

125
00:08:24,455 --> 00:08:28,000
们提供了更复杂方案的强大构建块。

126
00:08:28,000 --> 00:08:32,752
例如，由于汉明正在寻找一种方法来识别错误发生的位置，而

127
00:08:32,752 --> 00:08:37,504
不仅仅是错误发生的地方，他的主要见解是，如果您不对完整

128
00:08:37,504 --> 00:08:42,257
消息而是对某些精心选择的子集应用一些奇偶校验检查，您可

129
00:08:42,257 --> 00:08:46,840
以询问一系列更精确的问题，可以确定任何一位错误的位置。

130
00:08:46,840 --> 00:08:50,660
总体感觉有点像玩 20 个问题的游戏，提

131
00:08:50,660 --> 00:08:54,300
出是或否的问题，从而将可能性的空间减半。

132
00:08:54,300 --> 00:08:59,840
例如，假设我们仅对这 8 位（ 所有奇数位置）进行奇偶校验。

133
00:08:59,840 --> 00:09:04,603
然后，如果检测到错误，它会向接收器提供更多有

134
00:09:04,603 --> 00:09:09,160
关错误具体位置的信息，即错误位于奇怪的位置。

135
00:09:09,160 --> 00:09:13,303
如果在这 8 位中没有检测到错误，则意

136
00:09:13,303 --> 00:09:17,240
味着根本没有错误，或者它位于偶数位置。

137
00:09:17,240 --> 00:09:21,524
您可能认为将奇偶校验检查限制为一半会降低其效

138
00:09:21,524 --> 00:09:25,808
率，但是当它与其他精心选择的检查结合使用时，

139
00:09:25,808 --> 00:09:29,720
它会给我们带来更强大的东西，这与直觉相反。

140
00:09:29,720 --> 00:09:33,761
请记住，要实际设置奇偶校验检查，它需要

141
00:09:33,761 --> 00:09:37,600
指定一些特殊位来控制整个组的奇偶校验。

142
00:09:37,600 --> 00:09:39,920
这里我们只选择位置1。

143
00:09:39,920 --> 00:09:44,242
对于所示的示例，这 8 位的奇偶校验当前是奇数，

144
00:09:44,242 --> 00:09:48,220
因此发送方负责切换该奇偶校验位，现在它是偶数。

145
00:09:48,220 --> 00:09:51,040
这只是我们要做的 4 次奇偶校验中的 1 次。

146
00:09:51,040 --> 00:09:53,797
第二个检查位于网格右半部分的 8

147
00:09:53,797 --> 00:09:56,880
位 中，至少我们在这里绘制的是这样的。

148
00:09:56,880 --> 00:10:01,506
这次我们可能使用位置 2 作为奇偶校验位，因此这 8

149
00:10:01,506 --> 00:10:06,646
位已经 具有偶校验，并且发送方可以感觉良好，保持该位号 2

150
00:10:06,646 --> 00:10:07,160
不变。

151
00:10:07,160 --> 00:10:11,717
然后在另一端，如果接收器检查该组的奇偶校验并且发现奇偶校

152
00:10:11,717 --> 00:10:15,960
验，他们就会知道错误位于右侧的这 8 位中的某个位置。

153
00:10:15,960 --> 00:10:21,260
否则，这意味着要么没有错误，要么错误位于左半部分。

154
00:10:21,260 --> 00:10:24,351
或者我猜可能有两个错误，但现在我

155
00:10:24,351 --> 00:10:27,080
们假设整个块中最多有一个错误。

156
00:10:27,080 --> 00:10:29,160
事情远不止于此。

157
00:10:29,160 --> 00:10:32,581
在这里，在我们查看接下来的两项检查之前，请花点时间思考

158
00:10:32,581 --> 00:10:35,880
一下，当您将前两项检查放在一起考虑时，我们可以做什么。

159
00:10:35,880 --> 00:10:40,240
假设您在奇数列和右半列中检测到错误。

160
00:10:40,240 --> 00:10:43,940
这必然意味着错误出现在最后一列的某个位置。

161
00:10:43,940 --> 00:10:47,329
如果奇数列中没有错误，但右半部分

162
00:10:47,329 --> 00:10:50,520
有错误，则说明它位于倒数第二列。

163
00:10:50,520 --> 00:10:53,617
同样，如果奇数列中有错误但右半部分没有

164
00:10:53,617 --> 00:10:56,560
错误，您就知道它在第二列中的某个位置。

165
00:10:56,560 --> 00:11:00,243
如果这两个奇偶校验都没有检测到任何内容，则

166
00:11:00,243 --> 00:11:03,760
意味着唯一可能出现错误的位置是最左边的列。

167
00:11:03,760 --> 00:11:06,480
但这也可能仅仅意味着根本没有错误。

168
00:11:06,480 --> 00:11:11,800
这是一种相当繁琐的说法，两次 奇偶校验让我们确定了该列。

169
00:11:11,800 --> 00:11:14,000
从这里，你大概可以猜到接下来会发生什么。

170
00:11:14,000 --> 00:11:16,240
除了行之外，我们基本上做相同的事情。

171
00:11:16,240 --> 00:11:21,040
将使用位置 4 作为奇偶校验位对奇数行进行奇偶校验。

172
00:11:21,040 --> 00:11:23,842
因此，在此示例中，该组已经具有偶

173
00:11:23,842 --> 00:11:26,480
校验，因此位 4 将设置为 0。

174
00:11:26,480 --> 00:11:29,473
最后，对底部两行进行奇偶校验，

175
00:11:29,473 --> 00:11:32,280
使用位置 8 作为奇偶校验位。

176
00:11:32,280 --> 00:11:35,233
在这种情况下，发送方似乎需要打开

177
00:11:35,233 --> 00:11:37,840
第 8 位才能为组提供偶校验。

178
00:11:37,840 --> 00:11:40,503
正如前两项检查让我们确定列一样

179
00:11:40,503 --> 00:11:43,000
，接下来的两项检查让您确定行。

180
00:11:43,000 --> 00:11:48,400
举个例子，假设在传输过程中，位置 3 处出现错误。

181
00:11:48,400 --> 00:11:52,458
这会影响第一个奇偶校验组，也会影响第二个奇偶

182
00:11:52,458 --> 00:11:56,340
校验组，因此接收器知道右列中的某处存在错误。

183
00:11:56,340 --> 00:12:01,380
但不影响第三组，也不影响第四组。

184
00:12:01,380 --> 00:12:05,185
这可以让接收者精确定位到第一行（这必然意味着

185
00:12:05,185 --> 00:12:08,660
位置 3）的错误，这样他们就可以修复错误。

186
00:12:08,660 --> 00:12:13,074
您可能会喜欢花点时间说服自己，这四个问题的答案确实

187
00:12:13,074 --> 00:12:17,320
总是能让您确定一个特定的位置，无论它们最终在哪里。

188
00:12:17,320 --> 00:12:20,665
事实上，精明的你们甚至可能会注意到

189
00:12:20,665 --> 00:12:23,640
这些问题和二进制计数之间的联系。

190
00:12:23,640 --> 00:12:27,432
如果你这样做了，请再次让我强调一下，暂停一

191
00:12:27,432 --> 00:12:30,880
下，在我破坏之前尝试自己找出其中的联系。

192
00:12:30,880 --> 00:12:33,877
如果您想知道如果奇偶校验位本身受到影

193
00:12:33,877 --> 00:12:36,560
响会发生什么，那么您可以尝试一下。

194
00:12:36,560 --> 00:12:42,226
花点时间思考一下，如何使用同一组四个问题来追踪这

195
00:12:42,226 --> 00:12:47,440
四个特殊位中的任何错误，就像任何其他错误一样。

196
00:12:47,440 --> 00:12:50,633
这并不重要，因为最终我们想要的是

197
00:12:50,633 --> 00:12:53,640
保护消息位，纠错位只是随之而来。

198
00:12:53,640 --> 00:12:59,260
但保护这些位也是 该计划的副产品。

199
00:12:59,260 --> 00:13:02,380
您可能还喜欢预测其规模如何。

200
00:13:02,380 --> 00:13:09,150
例如，如果我们使用大小为 256 位的块，为了确定位置

201
00:13:09,150 --> 00:13:15,680
，您只需要八个是或否问题即可二进制搜索到某个特定位置。

202
00:13:15,680 --> 00:13:23,340
请记住，每个问题只需要放弃一 位即可设置适当的奇偶校验。

203
00:13:23,340 --> 00:13:26,807
你们中的一些人可能已经看到了，但我们稍后会

204
00:13:26,807 --> 00:13:29,960
讨论在一两分钟内找到这些问题的系统方法。

205
00:13:29,960 --> 00:13:34,440
希望这个草图足以让我们了解 我们正在开发的产品的效率。

206
00:13:34,440 --> 00:13:38,225
第一件事，除了那八个突出显示的奇偶校验位之外，可以

207
00:13:38,225 --> 00:13:41,720
是您想要的任何内容，携带您想要的任何消息或数据。

208
00:13:41,720 --> 00:13:47,950
8 位是冗余的，因为它们完全由消息的其余部分

209
00:13:47,950 --> 00:13:53,640
决定，但它比简单地复制整个消息要聪明得多。

210
00:13:53,640 --> 00:13:59,000
尽管如此，只要放弃一点点，您就 能够识别并修复任何一位错误。

211
00:13:59,000 --> 00:14:00,400
嗯，差不多了。

212
00:14:00,400 --> 00:14:04,864
好的，所以这里的一个问题是，如果四个奇偶校验检查都没

213
00:14:04,864 --> 00:14:09,162
有检测到错误，这意味着专门选择的 8 位子集都具有

214
00:14:09,162 --> 00:14:13,626
偶数奇偶校验，就像发送者预期的那样，那么这要么意味着

215
00:14:13,626 --> 00:14:17,760
根本没有错误，或者它会将我们的范围缩小到位置 0。

216
00:14:17,760 --> 00:14:22,955
你看，有四个是或否问题，我们的奇偶校验有 16 种可能的结

217
00:14:22,955 --> 00:14:27,977
果，一开始感觉非常适合精确定位块中 16 个位置中的 1

218
00:14:27,977 --> 00:14:33,000
个，但你还需要传达第 17 个结果，即没有错误健康）状况。

219
00:14:33,000 --> 00:14:37,860
这里的解决方案实际上非常简单，只需完全忘记第 0 位即可。

220
00:14:37,860 --> 00:14:41,260
因此，当我们进行四次奇偶校验并且发现它

221
00:14:41,260 --> 00:14:44,320
们都是偶数时，就明确意味着没有错误。

222
00:14:44,320 --> 00:14:49,268
这意味着我们不是使用 16 位块，而是使用 15 位块

223
00:14:49,268 --> 00:14:54,040
，其中 11 位可自由携带消息，其中 4 位用于冗余。

224
00:14:54,040 --> 00:14:59,400
这样，我们现在就有了业内人士 所说的 15-11 汉明码。

225
00:14:59,400 --> 00:15:04,309
也就是说，块大小是 2 的幂次方是件好事，并且有一种聪明

226
00:15:04,309 --> 00:15:08,880
的方法可以保留第 0 位并让它为我们做一些额外的工作。

227
00:15:08,880 --> 00:15:12,679
如果我们将它用作整个块的奇偶校验位，即使我们无

228
00:15:12,679 --> 00:15:16,320
法纠正，它也可以让我们实际检测到 2 位错误。

229
00:15:16,320 --> 00:15:17,440
这是它的工作原理。

230
00:15:17,440 --> 00:15:21,645
设置完这四个特殊的纠错位后，我们设置第 0 个位，以

231
00:15:21,645 --> 00:15:25,540
便整个块的奇偶校验是偶数，就像正常的奇偶校验一样。

232
00:15:25,540 --> 00:15:29,816
现在，如果存在单个位错误，则整个块的奇偶校验会切换为奇

233
00:15:29,816 --> 00:15:33,940
数，但由于四次纠错检查，我们无论如何都会捕获到这一点。

234
00:15:33,940 --> 00:15:38,029
然而，如果有两个错误，那么整体奇偶校验将

235
00:15:38,029 --> 00:15:42,119
切换回偶数，但接收器仍然会看到由于这四个

236
00:15:42,119 --> 00:15:45,820
奇偶校验检查的情况而至少存在一些错误。

237
00:15:45,820 --> 00:15:49,483
因此，如果他们注意到整体奇偶校验，但其他检

238
00:15:49,483 --> 00:15:52,980
查发生非零的情况，则表明至少存在两个错误。

239
00:15:52,980 --> 00:15:54,420
这不是很聪明吗？

240
00:15:54,420 --> 00:15:58,532
尽管我们无法纠正这些 2 位错误，但只需将那个有点麻

241
00:15:58,532 --> 00:16:02,340
烦的第 0 位重新投入工作，我们就可以检测到它们。

242
00:16:02,340 --> 00:16:06,540
这是非常标准的，被称为扩展汉明码。

243
00:16:06,540 --> 00:16:10,227
从技术上讲，您现在已经完整地描述了汉明码的

244
00:16:10,227 --> 00:16:13,580
作用，至少对于 16 位块的示例是这样。

245
00:16:13,580 --> 00:16:17,941
但我认为您会发现通过自己从头到尾做一个完整的示例来检

246
00:16:17,941 --> 00:16:21,980
查您的理解并巩固到目前为止的所有内容会更令人满意。

247
00:16:21,980 --> 00:16:25,100
不过我会和你一起逐步完成，这样你就可以自己检查一下。

248
00:16:25,100 --> 00:16:28,700
要设置消息，无论是在空间上转换的文

249
00:16:28,700 --> 00:16:34,500
字消息还是要随时间存储的某些数据， 第一步都是将其划分为

250
00:16:34,500 --> 00:16:35,700
11 位块。

251
00:16:35,700 --> 00:16:40,340
每个块将被打包成一个防错的 16 位块。

252
00:16:40,340 --> 00:16:43,740
那我们就以这个为例，实际操作一下吧。

253
00:16:43,740 --> 00:16:45,340
话不多说，实际行动起来吧！

254
00:16:45,340 --> 00:16:47,380
让我们暂停一下并尝试将这个块放在一起。

255
00:16:47,380 --> 00:16:53,980
好吧，你准备好了吗？

256
00:16:53,980 --> 00:16:59,954
请记住，位置 0 以及 2 的其他幂保留用于纠错职

257
00:16:59,954 --> 00:17:05,700
责，因此您首先将消息位按顺序放置在所有剩余位置中。

258
00:17:05,700 --> 00:17:09,589
您需要该组具有偶校验，它已经这样做了，因此您

259
00:17:09,589 --> 00:17:13,140
应该将位置 1 中的奇偶校验位设置为 0。

260
00:17:13,140 --> 00:17:16,391
下一组以奇数奇偶校验开始，因此您

261
00:17:16,391 --> 00:17:19,260
应该将其奇偶校验位设置为 1。

262
00:17:19,260 --> 00:17:22,078
之后的组以奇数奇偶校验开始，因此您

263
00:17:22,078 --> 00:17:24,740
应该再次将其奇偶校验位设置为 1。

264
00:17:24,740 --> 00:17:28,307
最后一组也有奇数奇偶校验，这意味着我

265
00:17:28,307 --> 00:17:31,500
们将位置 8 中的该位设置为 1。

266
00:17:31,500 --> 00:17:36,727
最后一步，整个块现在具有偶校验，这意味着您可

267
00:17:36,727 --> 00:17:41,500
以将位号 0（总体奇偶校验位）设置为 0。

268
00:17:41,500 --> 00:17:45,335
因此，当该块被发送出去时，四个特殊子集

269
00:17:45,335 --> 00:17:48,980
和整个块的奇偶校验都将为偶数，即 0。

270
00:17:48,980 --> 00:17:53,620
作为练习的第二部分，让您扮演接收者的角色。

271
00:17:53,620 --> 00:17:57,042
当然，这意味着您还不知道该消息是什么，也许你们

272
00:17:57,042 --> 00:18:00,180
中的一些人记住了它，但我们假设您还没有记住。

273
00:18:00,180 --> 00:18:04,260
我要做的是更改该块中的 0、1 或

274
00:18:04,260 --> 00:18:08,340
2 位，然后要求您弄清楚我做了什么。

275
00:18:08,340 --> 00:18:13,460
所以，再次，暂停并尝试解决它。

276
00:18:13,460 --> 00:18:21,794
好的，作为接收者，您现在检查第一个奇偶校验组，您可以

277
00:18:21,794 --> 00:18:29,820
看到它是偶数，因此存在的任何错误都必须位于偶数列中。

278
00:18:29,820 --> 00:18:34,502
下一次检查给我们一个奇数，告诉我们至少有一

279
00:18:34,502 --> 00:18:38,760
个错误，并将我们的范围缩小到这一特定列。

280
00:18:38,760 --> 00:18:42,900
第三次检查是均匀的，进一步减少了可能性。

281
00:18:42,900 --> 00:18:47,393
最后的奇偶校验很奇怪，告诉我们底部的某个地方有

282
00:18:47,393 --> 00:18:51,700
错误，现在我们可以看到它一定在位置 10 处。

283
00:18:51,700 --> 00:18:55,131
更重要的是，整个区块的奇偶性是奇怪的，

284
00:18:55,131 --> 00:18:58,220
这让我们确信只有一次翻转而不是两次。

285
00:18:58,220 --> 00:19:01,600
如果是三个或更多，则所有赌注都失败了。

286
00:19:01,600 --> 00:19:06,242
纠正第 10 位后，取出未用于纠正的 11

287
00:19:06,242 --> 00:19:11,517
位 ，即可得到原始消息的相关片段，如果您倒回并比

288
00:19:11,517 --> 00:19:16,160
较，该片段确实正是我们开始示例时所用的片段。

289
00:19:16,160 --> 00:19:20,184
现在您已经知道如何手动完成所有这些操作，我想向您展示如何使

290
00:19:20,184 --> 00:19:23,940
用一行 Python 代码来执行所有这些逻辑的核心部分。

291
00:19:23,940 --> 00:19:28,027
你看，我还没有告诉你的是这个算法到底有多么优

292
00:19:28,027 --> 00:19:31,937
雅，让机器指出错误的位置是多么简单，如何系

293
00:19:31,937 --> 00:19:35,847
统地缩放它，以及我们如何构建所有错误这是一

294
00:19:35,847 --> 00:19:39,580
个单一操作，而不是多个单独的奇偶校验检查。

295
00:19:39,580 --> 00:19:41,680
要明白我的意思，请跟我一起看第二部分。

