1
00:00:03,620 --> 00:00:07,040
您是否想过如何在刮擦 CD 或 DV 

2
00:00:07,040 --> 00:00:10,100
D 后仍然可以播放其中存储的内容？

3
00:00:10,900 --> 00:00:15,162
划痕确实会影响磁盘上的 1 和 0，因此它会读取 

4
00:00:15,162 --> 00:00:19,255
与存储的数据不同的数据，但除非它确实被划伤，否 

5
00:00:19,255 --> 00:00:23,518
则它读取的位会被解码为与编码到其上的文件完全相同 

6
00:00:23,518 --> 00:00:27,440
的文件，尽管存在所有这些错误，但还是逐位复制。

7
00:00:27,440 --> 00:00:31,917
大量的数学智慧使我们能够以一种能够抵御错误的 

8
00:00:31,917 --> 00:00:36,200
方式存储数据，并且同样重要的是能够传输数据。

9
00:00:36,200 --> 00:00:38,610
好吧，好吧，实际上并不需要那么聪 

10
00:00:38,610 --> 00:00:40,880
明就能想出一种方法来做到这一点。

11
00:00:40,880 --> 00:00:45,735
任何文件，无论是视频、声音还是文本、代码、图 

12
00:00:45,735 --> 00:00:50,380
像等等，最终都是由 1 和 0 组成的序列。

13
00:00:50,680 --> 00:00:56,000
纠正任何被翻转的位的一个简单 策略是存储每个位的三个副本。

14
00:00:57,580 --> 00:01:00,886
然后，读取该文件的机器可以比较这三个副本，并在出 

15
00:01:00,886 --> 00:01:04,060
现差异时始终从 3 个副本中取出最好的 2 个。

16
00:01:07,160 --> 00:01:10,860
但这意味着将三分之二的空间用于冗余。

17
00:01:11,480 --> 00:01:14,504
即便如此，对于所有放弃的空间，也不能强有 

18
00:01:14,504 --> 00:01:17,240
力地保证如果超过一位被翻转会发生什么。

19
00:01:17,980 --> 00:01:21,167
更有趣的问题是如何做到这一点，以便在 

20
00:01:21,167 --> 00:01:24,020
放弃尽可能少的空间的同时纠正错误。

21
00:01:24,520 --> 00:01:29,470
例如，使用您将在本视频中了解的方法，您可以将数据存储在 

22
00:01:29,470 --> 00:01:33,360
256 位块中，其中每个块使用 9 位，9！

23
00:01:33,760 --> 00:01:36,946
作为一种冗余，其他 2 47 位可以自

24
00:01:36,946 --> 00:01:40,300
由地携带任何您想要的有意义的消息或数据。

25
00:01:40,900 --> 00:01:44,883
情况仍然是这样，如果这里有任何位被翻转， 

26
00:01:44,883 --> 00:01:48,866
只需查看这个块，机器就能够识别出存在错误 

27
00:01:48,866 --> 00:01:52,660
以及错误的确切位置，以便知道如何纠正它。

28
00:01:52,660 --> 00:01:54,620
老实说，这感觉就像魔法一样。

29
00:01:55,440 --> 00:01:59,225
对于这个特定的方案，如果两个位被翻转，机器至少能 

30
00:01:59,225 --> 00:02:02,860
够检测到存在两个错误，尽管它不知道如何修复它们。

31
00:02:03,520 --> 00:02:06,900
稍后我们将讨论如何针对不同大小的块进行缩放。

32
00:02:07,860 --> 00:02:12,900
可以合理地纠正此类错 误的方法称为纠错码。

33
00:02:13,660 --> 00:02:17,953
在上个世纪的大部分时间里，这个领域一直是令人惊讶的深度 

34
00:02:17,953 --> 00:02:21,940
数学的丰富来源，这些数学被纳入我们每天使用的设备中。

35
00:02:22,840 --> 00:02:28,660
这里的目标是让您非常彻底地了 解最早的示例之一，即汉明码。

36
00:02:29,520 --> 00:02:33,125
顺便说一句，我对这个视频结构的思考方式并 

37
00:02:33,125 --> 00:02:36,558
不是尽可能直接地解释它，而是提示你自己 

38
00:02:36,558 --> 00:02:39,820
发明它，并时不时地给予一些温和的指导。

39
00:02:40,120 --> 00:02:43,542
因此，当你觉得你在某个时刻看到了它的发展方向时，请花点 

40
00:02:43,542 --> 00:02:46,720
时间停下来，在我告诉你之前积极预测该计划将会是什么。

41
00:02:47,240 --> 00:02:50,856
另外，如果你想让你的理解深入到硬件层面，Ben 

42
00:02:50,856 --> 00:02:54,623
Eater 制作了一个与此相关的视频，向你展示如 

43
00:02:54,623 --> 00:02:58,240
何在面包板上实际实现汉明码，这是非常令人满意的。

44
00:02:59,300 --> 00:03:03,974
您应该知道，汉明码并不像里德-所罗门算法等更现代的代码那 

45
00:03:03,974 --> 00:03:08,648
样广泛使用，但是这项任务一开始感觉不可能，而一旦完成却显 

46
00:03:08,648 --> 00:03:13,000
得多么合理，两者之间的对比有一定的魔力。你了解了汉明。

47
00:03:13,720 --> 00:03:18,058
纠错的基本原理是，在所有可能消息的巨大 

48
00:03:18,058 --> 00:03:22,180
空间中，只有某些子集将被视为有效消息。

49
00:03:22,800 --> 00:03:26,940
打个比方，想想拼写正确的单词和拼写错误的单词。

50
00:03:28,900 --> 00:03:33,199
每当有效消息被更改时，接收者就有责任将他们看到的内容 

51
00:03:33,199 --> 00:03:37,340
纠正回最近的有效邻居，就像您可能会处理拼写错误一样。

52
00:03:38,220 --> 00:03:41,218
不过，想出一个具体的算法来有效地对这 

53
00:03:41,218 --> 00:03:44,060
样的消息进行分类需要一定的聪明才智。

54
00:03:46,780 --> 00:03:50,070
故事开始于 20 世纪 40 年代，当时年轻的理查德·汉明 

55
00:03:50,070 --> 00:03:52,154
(R ichard Hamming) 

56
00:03:52,154 --> 00:03:54,019
在贝尔实验室工作，他的一些工作涉 

57
00:03:54,019 --> 00:03:56,652
及使用一台非常昂贵的打孔卡计算机，而他只能有限地

58
00:03:56,652 --> 00:03:57,420
使用该计算机。

59
00:03:57,800 --> 00:04:02,400
他不断执行的程序总是失败， 因为时不时会有一点被误读。

60
00:04:03,120 --> 00:04:05,935
挫折是发明的严峻考验，他受够了， 

61
00:04:05,935 --> 00:04:08,420
因此发明了世界上第一个纠错码。

62
00:04:09,060 --> 00:04:12,297
构建汉明码的方法有很多种，但作为第一步， 

63
00:04:12,297 --> 00:04:15,380
我们将按照汉明本人对它们的看法来了解它。

64
00:04:16,519 --> 00:04:20,940
让我们使用一个简单但又不太简单的例子，一个 16 位的块。

65
00:04:21,820 --> 00:04:24,740
我们将这些位的位置从 0 到 15 进行编号。

66
00:04:25,620 --> 00:04:29,477
我们想要存储的实际数据仅由其中的 12 位组 

67
00:04:29,477 --> 00:04:33,000
成，而其中 4 个位置被保留作为一种冗余。

68
00:04:33,900 --> 00:04:37,109
这里的冗余一词并不简单地意味着复制，毕竟这4 

69
00:04:37,109 --> 00:04:40,040
位并没有给我们足够的空间来盲目地复制数据。

70
00:04:40,720 --> 00:04:44,182
相反，它们需要更加细致和巧妙的冗余， 

71
00:04:44,182 --> 00:04:47,280
不是添加任何新信息，而是增加弹性。

72
00:04:48,600 --> 00:04:52,373
您可能期望这 4 个特殊位能够很好地打包在一起， 

73
00:04:52,373 --> 00:04:56,147
也许是在最后或类似的地方，但正如您所看到的，让它 

74
00:04:56,147 --> 00:04:59,620
们位于 2 的幂的位置可以让最终变得非常优雅。

75
00:05:00,200 --> 00:05:03,540
它还可能会给您一些关于如何扩展到更大块的提示。

76
00:05:04,900 --> 00:05:09,156
另外，从技术上讲，它最终只有 11 位数据，您会发现位 

77
00:05:09,156 --> 00:05:13,260
置 0 处发生的情况有轻微的细微差别，但现在不用担心。

78
00:05:14,140 --> 00:05:18,002
与任何纠错算法一样，这将涉及两个参与者：一 

79
00:05:18,002 --> 00:05:21,688
个负责设置这 4 个特殊位的发送者，以及 

80
00:05:21,688 --> 00:05:25,200
一个负责执行某种检查和纠正错误的接收者。

81
00:05:25,200 --> 00:05:28,539
当然，“发送者”和“接收者”这两个词实际 

82
00:05:28,539 --> 00:05:31,719
上是指执行所有检查的机器或软件，并且消 

83
00:05:31,719 --> 00:05:34,740
息的概念含义非常广泛，包括存储等内容。

84
00:05:35,340 --> 00:05:38,660
毕竟，存储数据与将消息从过去发送到未来是一 

85
00:05:38,660 --> 00:05:41,680
样的，而不是从一个地方发送到另一个地方。

86
00:05:42,560 --> 00:05:46,151
这就是设置，但在我们深入讨论之前，我们需要讨 

87
00:05:46,151 --> 00:05:49,586
论一个相关的想法，这是汉明在发现时的新鲜想 

88
00:05:49,586 --> 00:05:53,021
法，这种方法可以让您检测到任何单个位错误， 

89
00:05:53,021 --> 00:05:56,300
但不能纠正它们，已知在业务中作为奇偶校验。

90
00:05:56,880 --> 00:06:00,532
对于奇偶校验，我们只分离出发送者负责调 

91
00:06:00,532 --> 00:06:03,820
整的一位，其余的可以自由地携带消息。

92
00:06:04,880 --> 00:06:11,280
该特殊位的唯一作用是确保消 息中 1 的总数为偶数。

93
00:06:12,080 --> 00:06:16,191
例如，现在 1 的总数是 7，这是奇数，因此发 

94
00:06:16,191 --> 00:06:19,960
送方需要将该特殊位翻转为 1，使计数为偶数。

95
00:06:20,800 --> 00:06:23,785
但如果该块已经以偶数个 1 开始 

96
00:06:23,785 --> 00:06:26,420
，那么这个特殊位将保持为 0。

97
00:06:27,340 --> 00:06:32,228
这非常简单，看似简单，但它是一种极其优雅的方式，可以将消 

98
00:06:32,228 --> 00:06:36,780
息中任何位置的变化的想法提炼出来，并反映在单个信息中。

99
00:06:37,500 --> 00:06:41,773
请注意，如果此消息的任何位被翻转（从 0 变为 1 

100
00:06:41,773 --> 00:06:46,540
或从 1 变为 0），它会将 1 的总数从偶数更改为奇数。

101
00:06:47,980 --> 00:06:52,318
因此，如果您是接收者，您查看此消息，并 且看到奇数个 

102
00:06:52,318 --> 00:06:56,977
1，您可以确定发生了某些 错误，即使您可能不知道错误发生在

103
00:06:56,977 --> 00:06:57,460
哪里。

104
00:06:58,500 --> 00:07:00,998
用行话来说，一组位的 1 数量 

105
00:07:00,998 --> 00:07:03,340
是偶数还是奇数，称为奇偶校验。

106
00:07:04,860 --> 00:07:07,907
您还可以使用数字并表示奇偶校验为 0 或 1，一旦 

107
00:07:07,907 --> 00:07:10,720
您开始用这个想法进行数学计算，这通常会更有帮助。

108
00:07:11,220 --> 00:07:15,520
发送方用来控制奇偶校验的 特殊位称为奇偶校验位。

109
00:07:17,560 --> 00:07:21,555
实际上，我们应该清楚，如果接收器看到奇数奇偶校验，并不 

110
00:07:21,555 --> 00:07:25,264
一定意味着只有一个错误，可能有 3 个错误，或 5 

111
00:07:25,264 --> 00:07:29,260
个 错误，或任何其他奇数，但他们可以肯定知道它不是 0。

112
00:07:29,980 --> 00:07:34,204
另一方面，如果出现 2 个错误，或者任何偶数个 

113
00:07:34,204 --> 00:07:38,428
错误，则最终的 1 计数仍然是偶数，因此接收方 

114
00:07:38,428 --> 00:07:42,300
无法完全确信偶数计数一定意味着消息没有错误。

115
00:07:42,840 --> 00:07:46,143
您可能会抱怨仅通过 2 位翻转就搞 

116
00:07:46,143 --> 00:07:49,080
乱的消息非常弱，您是绝对正确的。

117
00:07:49,700 --> 00:07:54,108
但请记住，没有任何错误检测或纠正方法可以让您 

118
00:07:54,108 --> 00:07:58,900
1 00% 确信您收到的消息正是发件人想要的消息。

119
00:07:59,580 --> 00:08:02,598
毕竟，足够多的随机噪声总能偶然将 

120
00:08:02,598 --> 00:08:05,440
一条有效消息变成另一条有效消息。

121
00:08:06,240 --> 00:08:10,907
相反，我们的目标是提出一种在一定的最大错误数范 

122
00:08:10,907 --> 00:08:15,380
围内稳健的方案，或者减少像这样的误报的可能性。

123
00:08:16,260 --> 00:08:20,033
奇偶校验本身相当弱，但通过将整个消 

124
00:08:20,033 --> 00:08:23,806
息的变化思想提炼为单个位，它们为我 

125
00:08:23,806 --> 00:08:27,160
们提供了更复杂方案的强大构建块。

126
00:08:27,940 --> 00:08:32,480
例如，由于汉明正在寻找一种方法来识别错误发生的位置，而 

127
00:08:32,480 --> 00:08:37,021
不仅仅是错误发生的地方，他的主要见解是，如果您不对完整 

128
00:08:37,021 --> 00:08:41,561
消息而是对某些精心选择的子集应用一些奇偶校验检查，您可 

129
00:08:41,561 --> 00:08:45,940
以询问一系列更精确的问题，可以确定任何一位错误的位置。

130
00:08:46,680 --> 00:08:50,111
总体感觉有点像玩 20 个问题的游戏，提 

131
00:08:50,111 --> 00:08:53,380
出是或否的问题，从而将可能性的空间减半。

132
00:08:54,160 --> 00:08:59,380
例如，假设我们仅对这 8 位（ 所有奇数位置）进行奇偶校验。

133
00:09:00,100 --> 00:09:04,260
然后，如果检测到错误，它会向接收器提供更多有 

134
00:09:04,260 --> 00:09:08,240
关错误具体位置的信息，即错误位于奇怪的位置。

135
00:09:08,940 --> 00:09:12,683
如果在这 8 位中没有检测到错误，则意 

136
00:09:12,683 --> 00:09:16,240
味着根本没有错误，或者它位于偶数位置。

137
00:09:17,180 --> 00:09:20,619
您可能认为将奇偶校验检查限制为一半会降低其效 

138
00:09:20,619 --> 00:09:24,059
率，但是当它与其他精心选择的检查结合使用时， 

139
00:09:24,059 --> 00:09:27,200
它会给我们带来更强大的东西，这与直觉相反。

140
00:09:29,240 --> 00:09:33,024
请记住，要实际设置奇偶校验检查，它需要 

141
00:09:33,024 --> 00:09:36,620
指定一些特殊位来控制整个组的奇偶校验。

142
00:09:37,480 --> 00:09:39,180
这里我们只选择位置1。

143
00:09:39,720 --> 00:09:43,501
对于所示的示例，这 8 位的奇偶校验当前是奇数， 

144
00:09:43,501 --> 00:09:46,980
因此发送方负责切换该奇偶校验位，现在它是偶数。

145
00:09:47,940 --> 00:09:50,680
这只是我们要做的 4 次奇偶校验中的 1 次。

146
00:09:50,920 --> 00:09:53,460
第二个检查位于网格右半部分的 8 

147
00:09:53,460 --> 00:09:56,300
位 中，至少我们在这里绘制的是这样的。

148
00:09:56,680 --> 00:10:00,901
这次我们可能使用位置 2 作为奇偶校验位，因此这 8 

149
00:10:00,901 --> 00:10:05,591
位已经 具有偶校验，并且发送方可以感觉良好，保持该位号 2 

150
00:10:05,591 --> 00:10:06,060
不变。

151
00:10:07,020 --> 00:10:11,349
然后在另一端，如果接收器检查该组的奇偶校验并且发现奇偶校 

152
00:10:11,349 --> 00:10:15,380
验，他们就会知道错误位于右侧的这 8 位中的某个位置。

153
00:10:15,820 --> 00:10:20,580
否则，这意味着要么没有错误，要么错误位于左半部分。

154
00:10:21,120 --> 00:10:23,978
或者我猜可能有两个错误，但现在我 

155
00:10:23,978 --> 00:10:26,500
们假设整个块中最多有一个错误。

156
00:10:26,940 --> 00:10:28,740
事情远不止于此。

157
00:10:29,160 --> 00:10:32,184
在这里，在我们查看接下来的两项检查之前，请花点时间思考 

158
00:10:32,184 --> 00:10:35,100
一下，当您将前两项检查放在一起考虑时，我们可以做什么。

159
00:10:35,800 --> 00:10:39,660
假设您在奇数列和右半列中检测到错误。

160
00:10:40,200 --> 00:10:43,040
这必然意味着错误出现在最后一列的某个位置。

161
00:10:43,820 --> 00:10:46,849
如果奇数列中没有错误，但右半部分 

162
00:10:46,849 --> 00:10:49,700
有错误，则说明它位于倒数第二列。

163
00:10:50,440 --> 00:10:53,578
同样，如果奇数列中有错误但右半部分没有 

164
00:10:53,578 --> 00:10:56,560
错误，您就知道它在第二列中的某个位置。

165
00:10:56,560 --> 00:10:59,916
如果这两个奇偶校验都没有检测到任何内容，则 

166
00:10:59,916 --> 00:11:03,120
意味着唯一可能出现错误的位置是最左边的列。

167
00:11:03,340 --> 00:11:06,120
但这也可能仅仅意味着根本没有错误。

168
00:11:06,300 --> 00:11:10,840
这是一种相当繁琐的说法，两次 奇偶校验让我们确定了该列。

169
00:11:11,480 --> 00:11:13,640
从这里，你大概可以猜到接下来会发生什么。

170
00:11:13,800 --> 00:11:16,140
除了行之外，我们基本上做相同的事情。

171
00:11:16,440 --> 00:11:20,900
将使用位置 4 作为奇偶校验位对奇数行进行奇偶校验。

172
00:11:21,380 --> 00:11:23,667
因此，在此示例中，该组已经具有偶 

173
00:11:23,667 --> 00:11:25,820
校验，因此位 4 将设置为 0。

174
00:11:26,560 --> 00:11:29,150
最后，对底部两行进行奇偶校验， 

175
00:11:29,150 --> 00:11:31,580
使用位置 8 作为奇偶校验位。

176
00:11:32,120 --> 00:11:34,616
在这种情况下，发送方似乎需要打开 

177
00:11:34,616 --> 00:11:36,820
第 8 位才能为组提供偶校验。

178
00:11:37,700 --> 00:11:39,836
正如前两项检查让我们确定列一样 

179
00:11:39,836 --> 00:11:41,840
，接下来的两项检查让您确定行。

180
00:11:42,880 --> 00:11:47,540
举个例子，假设在传输过程中，位置 3 处出现错误。

181
00:11:48,180 --> 00:11:51,952
这会影响第一个奇偶校验组，也会影响第二个奇偶 

182
00:11:51,952 --> 00:11:55,560
校验组，因此接收器知道右列中的某处存在错误。

183
00:11:56,100 --> 00:12:00,540
但不影响第三组，也不影响第四组。

184
00:12:01,240 --> 00:12:04,522
这可以让接收者精确定位到第一行（这必然意味着 

185
00:12:04,522 --> 00:12:07,520
位置 3）的错误，这样他们就可以修复错误。

186
00:12:08,580 --> 00:12:12,923
您可能会喜欢花点时间说服自己，这四个问题的答案确实 

187
00:12:12,923 --> 00:12:17,100
总是能让您确定一个特定的位置，无论它们最终在哪里。

188
00:12:17,720 --> 00:12:20,547
事实上，精明的你们甚至可能会注意到 

189
00:12:20,547 --> 00:12:23,060
这些问题和二进制计数之间的联系。

190
00:12:23,500 --> 00:12:26,339
如果你这样做了，请再次让我强调一下，暂停一 

191
00:12:26,339 --> 00:12:28,920
下，在我破坏之前尝试自己找出其中的联系。

192
00:12:30,500 --> 00:12:33,434
如果您想知道如果奇偶校验位本身受到影 

193
00:12:33,434 --> 00:12:36,060
响会发生什么，那么您可以尝试一下。

194
00:12:36,440 --> 00:12:40,471
花点时间思考一下，如何使用同一组四个问题来追踪这 

195
00:12:40,471 --> 00:12:44,180
四个特殊位中的任何错误，就像任何其他错误一样。

196
00:12:47,060 --> 00:12:50,171
这并不重要，因为最终我们想要的是 

197
00:12:50,171 --> 00:12:53,100
保护消息位，纠错位只是随之而来。

198
00:12:53,600 --> 00:12:57,820
但保护这些位也是 该计划的副产品。

199
00:12:59,200 --> 00:13:01,760
您可能还喜欢预测其规模如何。

200
00:13:02,300 --> 00:13:07,635
例如，如果我们使用大小为 256 位的块，为了确定位置 

201
00:13:07,635 --> 00:13:12,780
，您只需要八个是或否问题即可二进制搜索到某个特定位置。

202
00:13:15,640 --> 00:13:20,500
请记住，每个问题只需要放弃一 位即可设置适当的奇偶校验。

203
00:13:23,160 --> 00:13:26,407
你们中的一些人可能已经看到了，但我们稍后会 

204
00:13:26,407 --> 00:13:29,360
讨论在一两分钟内找到这些问题的系统方法。

205
00:13:29,880 --> 00:13:33,260
希望这个草图足以让我们了解 我们正在开发的产品的效率。

206
00:13:33,260 --> 00:13:37,711
第一件事，除了那八个突出显示的奇偶校验位之外，可以 

207
00:13:37,711 --> 00:13:41,820
是您想要的任何内容，携带您想要的任何消息或数据。

208
00:13:41,820 --> 00:13:46,106
8 位是冗余的，因为它们完全由消息的其余部分 

209
00:13:46,106 --> 00:13:50,020
决定，但它比简单地复制整个消息要聪明得多。

210
00:13:53,600 --> 00:13:58,380
尽管如此，只要放弃一点点，您就 能够识别并修复任何一位错误。

211
00:13:59,200 --> 00:14:00,400
嗯，差不多了。

212
00:14:00,960 --> 00:14:05,048
好的，所以这里的一个问题是，如果四个奇偶校验检查都没 

213
00:14:05,048 --> 00:14:08,985
有检测到错误，这意味着专门选择的 8 位子集都具有 

214
00:14:08,985 --> 00:14:13,074
偶数奇偶校验，就像发送者预期的那样，那么这要么意味着 

215
00:14:13,074 --> 00:14:16,860
根本没有错误，或者它会将我们的范围缩小到位置 0。

216
00:14:17,740 --> 00:14:22,567
你看，有四个是或否问题，我们的奇偶校验有 16 种可能的结 

217
00:14:22,567 --> 00:14:27,233
果，一开始感觉非常适合精确定位块中 16 个位置中的 1 

218
00:14:27,233 --> 00:14:31,900
个，但你还需要传达第 17 个结果，即没有错误健康）状况。

219
00:14:33,020 --> 00:14:37,300
这里的解决方案实际上非常简单，只需完全忘记第 0 位即可。

220
00:14:37,840 --> 00:14:40,797
因此，当我们进行四次奇偶校验并且发现它 

221
00:14:40,797 --> 00:14:43,460
们都是偶数时，就明确意味着没有错误。

222
00:14:44,240 --> 00:14:48,811
这意味着我们不是使用 16 位块，而是使用 15 位块 

223
00:14:48,811 --> 00:14:53,220
，其中 11 位可自由携带消息，其中 4 位用于冗余。

224
00:14:53,780 --> 00:15:00,200
这样，我们现在就有了业内人士 所说的 15-11 汉明码。

225
00:15:00,460 --> 00:15:04,437
也就是说，块大小是 2 的幂次方是件好事，并且有一种聪明 

226
00:15:04,437 --> 00:15:08,140
的方法可以保留第 0 位并让它为我们做一些额外的工作。

227
00:15:08,700 --> 00:15:12,192
如果我们将它用作整个块的奇偶校验位，即使我们无 

228
00:15:12,192 --> 00:15:15,540
法纠正，它也可以让我们实际检测到 2 位错误。

229
00:15:16,160 --> 00:15:16,820
这是它的工作原理。

230
00:15:17,180 --> 00:15:21,209
设置完这四个特殊的纠错位后，我们设置第 0 个位，以 

231
00:15:21,209 --> 00:15:24,940
便整个块的奇偶校验是偶数，就像正常的奇偶校验一样。

232
00:15:25,700 --> 00:15:29,721
现在，如果存在单个位错误，则整个块的奇偶校验会切换为奇 

233
00:15:29,721 --> 00:15:33,600
数，但由于四次纠错检查，我们无论如何都会捕获到这一点。

234
00:15:34,160 --> 00:15:37,953
然而，如果有两个错误，那么整体奇偶校验将 

235
00:15:37,953 --> 00:15:41,747
切换回偶数，但接收器仍然会看到由于这四个 

236
00:15:41,747 --> 00:15:45,180
奇偶校验检查的情况而至少存在一些错误。

237
00:15:45,180 --> 00:15:49,027
因此，如果他们注意到整体奇偶校验，但其他检 

238
00:15:49,027 --> 00:15:52,700
查发生非零的情况，则表明至少存在两个错误。

239
00:15:53,520 --> 00:15:54,000
这不是很聪明吗？

240
00:15:54,300 --> 00:15:57,913
尽管我们无法纠正这些 2 位错误，但只需将那个有点麻 

241
00:15:57,913 --> 00:16:01,260
烦的第 0 位重新投入工作，我们就可以检测到它们。

242
00:16:02,260 --> 00:16:05,220
这是非常标准的，被称为扩展汉明码。

243
00:16:06,540 --> 00:16:09,860
从技术上讲，您现在已经完整地描述了汉明码的 

244
00:16:09,860 --> 00:16:12,880
作用，至少对于 16 位块的示例是这样。

245
00:16:12,880 --> 00:16:17,262
但我认为您会发现通过自己从头到尾做一个完整的示例来检 

246
00:16:17,262 --> 00:16:21,320
查您的理解并巩固到目前为止的所有内容会更令人满意。

247
00:16:22,080 --> 00:16:24,300
不过我会和你一起逐步完成，这样你就可以自己检查一下。

248
00:16:25,120 --> 00:16:28,360
要设置消息，无论是在空间上转换的文 

249
00:16:28,360 --> 00:16:33,580
字消息还是要随时间存储的某些数据， 第一步都是将其划分为 

250
00:16:33,580 --> 00:16:34,660
11 位块。

251
00:16:35,580 --> 00:16:39,760
每个块将被打包成一个防错的 16 位块。

252
00:16:39,760 --> 00:16:43,220
那我们就以这个为例，实际操作一下吧。

253
00:16:43,740 --> 00:16:44,740
话不多说，实际行动起来吧！

254
00:16:44,740 --> 00:16:47,020
让我们暂停一下并尝试将这个块放在一起。

255
00:16:52,720 --> 00:16:53,680
好吧，你准备好了吗？

256
00:16:54,240 --> 00:16:58,869
请记住，位置 0 以及 2 的其他幂保留用于纠错职 

257
00:16:58,869 --> 00:17:03,320
责，因此您首先将消息位按顺序放置在所有剩余位置中。

258
00:17:05,339 --> 00:17:08,999
您需要该组具有偶校验，它已经这样做了，因此您 

259
00:17:08,999 --> 00:17:12,339
应该将位置 1 中的奇偶校验位设置为 0。

260
00:17:13,020 --> 00:17:15,601
下一组以奇数奇偶校验开始，因此您 

261
00:17:15,601 --> 00:17:17,880
应该将其奇偶校验位设置为 1。

262
00:17:19,160 --> 00:17:21,772
之后的组以奇数奇偶校验开始，因此您 

263
00:17:21,772 --> 00:17:24,240
应该再次将其奇偶校验位设置为 1。

264
00:17:24,780 --> 00:17:27,566
最后一组也有奇数奇偶校验，这意味着我 

265
00:17:27,566 --> 00:17:30,060
们将位置 8 中的该位设置为 1。

266
00:17:31,300 --> 00:17:36,014
最后一步，整个块现在具有偶校验，这意味着您可 

267
00:17:36,014 --> 00:17:40,320
以将位号 0（总体奇偶校验位）设置为 0。

268
00:17:41,340 --> 00:17:44,827
因此，当该块被发送出去时，四个特殊子集 

269
00:17:44,827 --> 00:17:48,140
和整个块的奇偶校验都将为偶数，即 0。

270
00:17:48,820 --> 00:17:52,180
作为练习的第二部分，让您扮演接收者的角色。

271
00:17:53,480 --> 00:17:56,766
当然，这意味着您还不知道该消息是什么，也许你们 

272
00:17:56,766 --> 00:17:59,780
中的一些人记住了它，但我们假设您还没有记住。

273
00:18:00,020 --> 00:18:03,880
我要做的是更改该块中的 0、1 或 

274
00:18:03,880 --> 00:18:07,740
2 位，然后要求您弄清楚我做了什么。

275
00:18:08,260 --> 00:18:10,810
所以，再次，暂停并尝试解决它。

276
00:18:18,790 --> 00:18:23,436
好的，作为接收者，您现在检查第一个奇偶校验组，您可以 

277
00:18:23,436 --> 00:18:27,910
看到它是偶数，因此存在的任何错误都必须位于偶数列中。

278
00:18:29,690 --> 00:18:33,534
下一次检查给我们一个奇数，告诉我们至少有一 

279
00:18:33,534 --> 00:18:37,030
个错误，并将我们的范围缩小到这一特定列。

280
00:18:38,550 --> 00:18:41,790
第三次检查是均匀的，进一步减少了可能性。

281
00:18:42,650 --> 00:18:46,224
最后的奇偶校验很奇怪，告诉我们底部的某个地方有 

282
00:18:46,224 --> 00:18:49,650
错误，现在我们可以看到它一定在位置 10 处。

283
00:18:51,490 --> 00:18:54,668
更重要的是，整个区块的奇偶性是奇怪的， 

284
00:18:54,668 --> 00:18:57,530
这让我们确信只有一次翻转而不是两次。

285
00:18:58,070 --> 00:18:59,970
如果是三个或更多，则所有赌注都失败了。

286
00:19:01,310 --> 00:19:05,480
纠正第 10 位后，取出未用于纠正的 11 

287
00:19:05,480 --> 00:19:10,219
位 ，即可得到原始消息的相关片段，如果您倒回并比 

288
00:19:10,219 --> 00:19:14,390
较，该片段确实正是我们开始示例时所用的片段。

289
00:19:15,710 --> 00:19:19,568
现在您已经知道如何手动完成所有这些操作，我想向您展示如何使 

290
00:19:19,568 --> 00:19:23,170
用一行 Python 代码来执行所有这些逻辑的核心部分。

291
00:19:23,870 --> 00:19:27,759
你看，我还没有告诉你的是这个算法到底有多么优 

292
00:19:27,759 --> 00:19:31,479
雅，让机器指出错误的位置是多么简单，如何系 

293
00:19:31,479 --> 00:19:35,199
统地缩放它，以及我们如何构建所有错误这是一 

294
00:19:35,199 --> 00:19:38,750
个单一操作，而不是多个单独的奇偶校验检查。

295
00:19:39,430 --> 00:19:41,310
要明白我的意思，请跟我一起看第二部分。

