1
00:00:00,000 --> 00:00:02,560
我假设这里的每个人都来自第 1 部分。

2
00:00:03,060 --> 00:00:06,990
我们讨论的是汉明码，这是一种创建数据块的方法 ，

3
00:00:06,990 --> 00:00:11,904
其中大多数位携带有意义的消息，而其他一些 位则充当一种冗余，

4
00:00:11,904 --> 00:00:15,998
这样如果任何位被翻转，要么 是一条消息位或冗余位，

5
00:00:15,998 --> 00:00:19,929
该块中的任何内容，接 收器将能够识别出存在错误，

6
00:00:19,929 --> 00:00:21,240
以及如何修复它。

7
00:00:21,880 --> 00:00:24,595
那里提出的基本思想是如何使用多个奇 

8
00:00:24,595 --> 00:00:27,160
偶校验来进行二进制搜索以找出错误。

9
00:00:28,980 --> 00:00:31,946
在该视频中，我们的目标是让汉明码尽可 

10
00:00:31,946 --> 00:00:34,600
能具有动手操作和可重新发现的感觉。

11
00:00:35,180 --> 00:00:39,573
但是，当您开始考虑在软件或硬件中实际实现这一点时 ，

12
00:00:39,573 --> 00:00:43,460
该框架实际上可能低估了这些代码的真正优雅程度。

13
00:00:43,920 --> 00:00:48,786
您可能认为您需要编写一个算法来跟踪所 有可能的错误位置，

14
00:00:48,786 --> 00:00:53,480
并在每次检查时将该 组切成两半，但实际上比这简单得多。

15
00:00:53,940 --> 00:00:58,217
如果你读出我们在上一个视频中所做的四次奇偶校验的答案，

16
00:00:58,217 --> 00:01:01,069
全部都是 1 和 0，而不是是和否，

17
00:01:01,069 --> 00:01:04,080
它实际上以二进制形式说明了错误的位置。

18
00:01:04,780 --> 00:01:08,482
例如，二进制中的数字 7 看起来像 011 1，

19
00:01:08,482 --> 00:01:11,260
本质上是说它是 4 加 2 加 1。

20
00:01:12,540 --> 00:01:18,172
请注意位置 7 所在的位置，它确实影响我们的第一 个奇偶组，

21
00:01:18,172 --> 00:01:21,740
以及第二个和第三个，但不影响最后一个。

22
00:01:22,220 --> 00:01:27,540
因此，从下到上读取这四次检查的 结果确实可以阐明错误的位置。

23
00:01:28,320 --> 00:01:32,468
示例 7 没有什么特别的，这在一般情况下是有效 的，

24
00:01:32,468 --> 00:01:35,820
这使得在硬件中实现整个方案的逻辑非常简单。

25
00:01:37,240 --> 00:01:40,620
现在，如果您想了解为什么会发生这种神奇的情况，

26
00:01:40,620 --> 00:01:43,706
请将这 1 6 个索引标签作为我们的位置，

27
00:01:43,706 --> 00:01:47,822
但不要将它们写入基数 10 ，而是将它们全部写入二进制，

28
00:01:47,822 --> 00:01:49,880
从 0000 到 1111。

29
00:01:50,559 --> 00:01:54,561
当我们将这些二进制标签放回它们的盒子时 ，

30
00:01:54,561 --> 00:01:57,800
让我强调它们与实际发送的数据不同。

31
00:01:58,320 --> 00:02:00,993
它们只不过是一个概念标签，可以 

32
00:02:00,993 --> 00:02:03,500
帮助你我理解四个奇偶组的来源。

33
00:02:04,140 --> 00:02:08,428
用二进制描述我们所看到的一切的优雅可能会因为我 

34
00:02:08,428 --> 00:02:12,360
们所看到的一切都以二进制描述的混乱而被削弱。

35
00:02:13,020 --> 00:02:14,120
不过，这是值得的。

36
00:02:14,800 --> 00:02:19,523
将您的注意力集中在所有这些标签的最后一位 上，

37
00:02:19,523 --> 00:02:23,220
然后突出显示最后一位为 1 的位置。

38
00:02:24,240 --> 00:02:27,654
我们得到的是四个奇偶校验组中的第一个，

39
00:02:27,654 --> 00:02:31,247
这意 味着您可以将第一个检查解释为询问，

40
00:02:31,247 --> 00:02:35,740
嘿，如果 有错误，该错误位置的最后一位是否为 1？

41
00:02:38,200 --> 00:02:42,816
同样，如果您关注倒数第二位，并突出显示所有为 1 的位置，

42
00:02:42,816 --> 00:02:46,160
您就会从我们的方案中获得第二个奇偶校验组。

43
00:02:46,740 --> 00:02:50,529
换句话说，第二次检查会问，嘿，我再说一次，

44
00:02:50,529 --> 00:02:54,500
 如果有错误，该位置的倒数第二位是 1 吗？

45
00:02:55,760 --> 00:02:56,900
等等。

46
00:02:57,220 --> 00:03:02,093
第三个奇偶校验涵盖倒数第三位打开的每个位置，

47
00:03:02,093 --> 00:03:08,740
最后一个 奇偶校验涵盖最后八个位置，即最高位为 1 的位置。

48
00:03:09,740 --> 00:03:14,252
我们之前所做的一切都与回答这四个问题相 同，

49
00:03:14,252 --> 00:03:17,740
而这又与以二进制拼出一个位置相同。

50
00:03:19,620 --> 00:03:21,480
我希望这能让两件事变得更清楚。

51
00:03:22,040 --> 00:03:26,460
第一个是如何系统地推广到大于 2 的幂的块大小。

52
00:03:26,960 --> 00:03:31,496
如果需要更多位来描述每个位置，例如 6 位来描述 64 

53
00:03:31,496 --> 00:03:36,356
个点 ，那么其中每一位都会为您提供我们需要检查的奇偶校验组之

54
00:03:36,356 --> 00:03:36,680
一。

55
00:03:38,400 --> 00:03:40,858
那些看过我和马特·帕克一起做的棋盘 

56
00:03:40,858 --> 00:03:43,180
拼图的人可能会发现这一切非常熟悉。

57
00:03:43,660 --> 00:03:46,671
它是相同的核心逻辑，但解决不同的问 题，

58
00:03:46,671 --> 00:03:48,780
并应用于 64 方格的棋盘。

59
00:03:49,880 --> 00:03:53,675
我希望这能澄清的第二件事是为什么我们的奇偶校验位 

60
00:03:53,675 --> 00:03:57,320
位于 2 的幂的位置，例如 1、2、4 和 8。

61
00:03:58,000 --> 00:04:03,000
这些位置的二进制表示仅打开了一位。

62
00:04:03,600 --> 00:04:06,609
这意味着这些奇偶校验位中的每一个都位 

63
00:04:06,609 --> 00:04:09,460
于四个奇偶校验组中的一个且仅一个内。

64
00:04:12,040 --> 00:04:16,095
您还可以在更大的示例中看到这一点，无论您有多 大，

65
00:04:16,095 --> 00:04:19,339
每个奇偶校验位都只方便地触及其中一个组。

66
00:04:25,600 --> 00:04:29,313
一旦您明白我们花费大量时间关注的这些奇 

67
00:04:29,313 --> 00:04:34,327
偶校验只不过是一种巧妙的方式来阐明二 进制错误的位置，

68
00:04:34,327 --> 00:04:38,412
那么我们就可以用不同 的方式来思考汉明代码，

69
00:04:38,412 --> 00:04:43,240
可以说更简单、 更优雅，基本上可以用一行代码写下来。

70
00:04:43,660 --> 00:04:45,500
它基于 XOR 函数。

71
00:04:46,940 --> 00:04:50,220
XOR，对于那些不知道的人来说，代表异或。

72
00:04:50,780 --> 00:04:54,431
当您对两位进行异或时，如果其中一位打开，

73
00:04:54,431 --> 00:04:59,360
它将返回 1，但如果两者都打开或关闭，则不会返回 1。

74
00:05:00,100 --> 00:05:02,980
换句话说，它是这两个位的奇偶校验。

75
00:05:03,540 --> 00:05:06,760
作为一个数学家，我更喜欢将其视为加法 mod 2。

76
00:05:07,360 --> 00:05:10,400
我们还经常谈论两个不同位串的异或，

77
00:05:10,400 --> 00:05:13,440
 它基本上是逐个组件地执行此操作。

78
00:05:13,680 --> 00:05:15,720
这就像加法，但你永远不会携带。

79
00:05:16,500 --> 00:05:19,570
同样，更倾向于数学的人可能更愿意将其 

80
00:05:19,570 --> 00:05:22,480
视为添加两个向量并减少 mod 2。

81
00:05:23,500 --> 00:05:26,088
如果您现在打开一些 Python 

82
00:05:26,088 --> 00:05:28,829
并在两个整数之间应用插入符号 操作，

83
00:05:28,829 --> 00:05:32,940
这就是它正在做的事情，但只是针对这些数字的位表示形式。

84
00:05:34,960 --> 00:05:39,223
对你和我来说，关键点在于，对许多不同的位 

85
00:05:39,223 --> 00:05:44,907
串进行异或运算实际上是一种计算一堆单独 组的模仿的方法，

86
00:05:44,907 --> 00:05:47,140
就像列一样，一举完成。

87
00:05:51,260 --> 00:05:55,093
这为我们提供了一种相当时髦的方式来思考汉明码算法中 

88
00:05:55,093 --> 00:05:58,780
的多个奇偶校验，因为所有这些都被打包到一个操作中。

89
00:05:59,479 --> 00:06:02,180
虽然乍一看确实很不一样。

90
00:06:02,820 --> 00:06:08,398
像我们之前那样，专门写下二进制的 16 个 位置，

91
00:06:08,398 --> 00:06:12,414
现在突出显示消息位变为 1 的位置，

92
00:06:12,414 --> 00:06:17,100
 然后将这些位置收集到一大列中并进行异或。

93
00:06:19,260 --> 00:06:24,401
您可能会猜到，结果位于底部的 4 位与 我们所了解和喜爱的 

94
00:06:24,401 --> 00:06:29,200
4 个奇偶校验相同 ，但请花点时间思考一下到底是为什么。

95
00:06:32,220 --> 00:06:37,109
例如，最后一列正在计算最后一位为 1 的所有位置 ，

96
00:06:37,109 --> 00:06:40,118
但我们已经仅限于突出显示的位置，

97
00:06:40,118 --> 00:06:45,760
因此它有效地 计算有多少突出显示的位置来自第一个奇偶校验组。

98
00:06:46,240 --> 00:06:46,800
那有意义吗？

99
00:06:49,080 --> 00:06:52,852
同样，下一列计算第二个奇偶校验组中有 

100
00:06:52,852 --> 00:06:56,624
多少个位置、倒数第二个位为 1 的位 

101
00:06:56,624 --> 00:07:00,000
置以及也突出显示的位置，依此类推。

102
00:07:00,260 --> 00:07:03,960
这实际上只是对我们一直在做的同一件事的看法的一个小小的转变。

103
00:07:07,760 --> 00:07:09,600
所以你知道它从这里走向何方。

104
00:07:10,000 --> 00:07:15,720
发送方负责切换一些特殊奇偶校验 位，以确保总和为 0000。

105
00:07:15,720 --> 00:07:21,869
现在，一旦我们有了这样的结果，这给了我们一个非常好的方 

106
00:07:21,869 --> 00:07:27,580
法来思考为什么底部的这四个结果位直接拼出错误的位置。

107
00:07:28,460 --> 00:07:31,860
假设此块中的某些位从 0 切换到 1。

108
00:07:32,600 --> 00:07:37,660
这意味着该位的位置现在将包含在总 XOR 中，

109
00:07:37,660 --> 00:07:43,820
这会将总和从 0 更改 为这个新包含的值，即错误的位置。

110
00:07:44,460 --> 00:07:48,320
不太明显的是，如果出现将 1 更 改为 0 的错误，

111
00:07:48,320 --> 00:07:49,360
情况也是如此。

112
00:07:50,180 --> 00:07:54,291
你看，如果你将一个位串加在一起两次，那就和根本没有它一 样，

113
00:07:54,291 --> 00:07:57,580
基本上是因为在这个世界上 1 加 1 等于 0。

114
00:07:57,580 --> 00:08:01,048
因此，将此位置的副本添加到总和 

115
00:08:01,048 --> 00:08:04,300
中与我们移动它具有相同的效果。

116
00:08:05,160 --> 00:08:10,700
同样，这种效果是底部的总 结果阐明了错误的位置。

117
00:08:13,039 --> 00:08:16,992
为了说明这是多么优雅，让我展示我之前引用的一行 

118
00:08:16,992 --> 00:08:21,440
P ython 代码，它将捕获接收器端的几乎所有逻辑。

119
00:08:22,080 --> 00:08:25,953
我们将首先创建一个由 16 个 1 和 0 组成的随 

120
00:08:25,953 --> 00:08:29,970
机数组来模拟数据块，我将给它命名位，但当然，在实践 中，

121
00:08:29,970 --> 00:08:33,700
这将是我们从发送方接收的内容，而不是如果是随机 的，

122
00:08:33,700 --> 00:08:37,000
它将携带 11 个数据位和 5 个奇偶校验位。

123
00:08:37,000 --> 00:08:40,793
如果我调用函数 enumerateBits，

124
00:08:40,793 --> 00:08:44,586
它的作用是将每 个位与相应的索引配对在一起，

125
00:08:44,586 --> 00:08:47,000
在本例中为从 0 到 15。

126
00:08:48,180 --> 00:08:51,895
因此，如果我们创建一个列表，循环遍历所有这些对，

127
00:08:51,895 --> 00:08:56,230
看起来像 i 的对，然后我们只取出 i 值，只取出索引，

128
00:08:56,230 --> 00:09:00,565
好吧，这并 不是那么令人兴奋，我们只是取回那些索引 0 

129
00:09:00,565 --> 00:09:01,340
到 15。

130
00:09:01,680 --> 00:09:06,153
但是，如果我们添加条件以仅执行此 if 位，

131
00:09:06,153 --> 00:09:09,406
即如果该位 是 1 而不是 0，

132
00:09:09,406 --> 00:09:12,660
那么它只会提取相应位打开的位置。

133
00:09:13,380 --> 00:09:20,360
在本例中，这些位置看起来是 0、4、6、9 等。

134
00:09:20,720 --> 00:09:25,447
我们想要的是将所有这些位置（打开的位的位 置）收集在一起，

135
00:09:25,447 --> 00:09:27,240
然后将它们异或在一起。

136
00:09:29,180 --> 00:09:31,452
为了在 Python 中执行此操作，

137
00:09:31,452 --> 00:09:33,220
让我首先导入几个有用的函数。

138
00:09:33,900 --> 00:09:37,013
这样我们就可以在这个列表上调用reduce()，

139
00:09:37,013 --> 00:09:38,700
并使用XOR函数来减少它。

140
00:09:39,100 --> 00:09:42,680
这基本上会遍历列表，并一路进行异或运算。

141
00:09:44,800 --> 00:09:47,849
如果您愿意，您可以显式写出该 XO R 函数，

142
00:09:47,849 --> 00:09:49,440
而无需从任何地方导入它。

143
00:09:51,940 --> 00:09:57,305
所以目前看来，如果我们对 16 位随机块执行此 操作，

144
00:09:57,305 --> 00:10:01,280
它会返回 9，其二进制表示为 1001。

145
00:10:01,980 --> 00:10:05,641
我们不会在这里这样做，但您可以编写一个函数，

146
00:10:05,641 --> 00:10:10,633
其中发送方 使用该二进制表示形式根据需要设置四个奇偶校验位，

147
00:10:10,633 --> 00:10:15,460
最终 使该块达到在完整位列表上运行这行代码的状态一个 0。

148
00:10:16,080 --> 00:10:20,100
这将被认为是一个准备充分的区块。

149
00:10:20,100 --> 00:10:23,828
很酷的是，如果我们切换此列表中的任何一位，

150
00:10:23,828 --> 00:10:28,444
模拟噪声引起的 随机错误，那么如果您运行同一行代码，

151
00:10:28,444 --> 00:10:30,220
它就会打印出该错误。

152
00:10:30,960 --> 00:10:31,520
这不是很整洁吗？

153
00:10:31,820 --> 00:10:35,926
你可以突然得到这个块，在上面运行这一行，

154
00:10:35,926 --> 00:10:41,060
它会 自动吐出错误的位置，如果没有错误则吐出 0。

155
00:10:42,500 --> 00:10:44,840
16号没有什么特别的。

156
00:10:44,840 --> 00:10:49,860
如果您有一个 256 位的列表，那么同一行代码也可以工作。

157
00:10:51,880 --> 00:10:56,005
不用说，这里需要编写更多代码，例如进行元奇偶校验 

158
00:10:56,005 --> 00:10:58,975
来检测 2 位错误，但我们的想法是，

159
00:10:58,975 --> 00:11:03,760
我们方案中 的几乎所有核心逻辑都归结为单个 XOR 减少。

160
00:11:06,120 --> 00:11:09,634
现在，根据您对二进制、异或和软件的熟悉程度，

161
00:11:09,634 --> 00:11:14,107
您可能 会发现这种观点有点令人困惑，或者更加优雅和简单，

162
00:11:14,107 --> 00:11:18,420
以 至于您想知道为什么我们不从一开始就开始使用它-去。

163
00:11:19,140 --> 00:11:22,710
宽松地说，当非常直接地在硬件中实现汉明码时，

164
00:11:22,710 --> 00:11:25,306
更 容易考虑多重奇偶校验的观点，

165
00:11:25,306 --> 00:11:28,714
而当在软件中从更高 的层次上实现汉明码时，

166
00:11:28,714 --> 00:11:30,500
最容易考虑异或的观点。

167
00:11:31,360 --> 00:11:36,128
第一个实际上最容易手动完成，我认为它可以更 

168
00:11:36,128 --> 00:11:39,813
好地灌输所有这一切背后的核心直觉，

169
00:11:39,813 --> 00:11:44,798
即定位单 个错误所需的信息与块大小的日志相关，

170
00:11:44,798 --> 00:11:50,000
或者换 句话说，随着块大小加倍，它一次增长一位。

171
00:11:51,020 --> 00:11:56,060
这里的相关事实是，该信息直 接对应于我们需要多少冗余。

172
00:11:56,660 --> 00:12:00,079
这确实与大多数人在第一次考虑使消息 

173
00:12:00,079 --> 00:12:03,119
能够抵御错误时的下意识反应相悖，

174
00:12:03,119 --> 00:12:06,540
通 常复制整个消息是首先想到的本能。

175
00:12:07,500 --> 00:12:11,939
然后，顺便说一句，有时您会看到汉明码的另 一种呈现方式，

176
00:12:11,939 --> 00:12:14,000
即您将消息乘以一个大矩阵。

177
00:12:14,670 --> 00:12:18,782
这很好，因为它将它与更广泛的线性代码家族联系起来，

178
00:12:18,782 --> 00:12:23,060
 但我认为这几乎没有给出它来自何处或如何扩展的直觉。

179
00:12:25,200 --> 00:12:29,065
说到扩展，您可能会注意到，当我们增加 块大小时，

180
00:12:29,065 --> 00:12:31,160
该方案的效率只会变得更好。

181
00:12:35,000 --> 00:12:37,657
例如，我们看到，对于 256 位，

182
00:12:37,657 --> 00:12:40,471
您仅使用该空间 的 3% 进行冗余，

183
00:12:40,471 --> 00:12:42,660
并且从那里开始变得越来越好。

184
00:12:43,300 --> 00:12:47,340
随着奇偶校验位的数量逐个增加，块大小不断加倍。

185
00:12:49,000 --> 00:12:52,463
如果你把它发挥到极致，你可能会拥有一个具有 

186
00:12:52,463 --> 00:12:56,241
1 00 万位的块，实际上你会用奇偶校验来回答 

187
00:12:56,241 --> 00:13:00,020
2 0 个问题，而它只使用 21 个奇偶校验位。

188
00:13:00,740 --> 00:13:05,336
如果你退后一步考虑查看一百万位并 找到一个错误，

189
00:13:05,336 --> 00:13:07,060
那真的感觉很疯狂。

190
00:13:08,199 --> 00:13:13,019
当然，问题在于，对于较大的块，看到超过一或两个位错误 

191
00:13:13,019 --> 00:13:17,660
的概率会上升，而汉明码无法处理超出此范围的任何内容。

192
00:13:18,320 --> 00:13:21,737
因此，在实践中，您需要找到正确的大 小，

193
00:13:21,737 --> 00:13:24,300
以便太多位翻转的概率不会太高。

194
00:13:26,600 --> 00:13:31,624
此外，在实践中，错误往往会突然出现，这会完全破坏单个块 ，

195
00:13:31,624 --> 00:13:36,302
因此帮助将错误突发分散到许多不同块的一种常见策略是在 

196
00:13:36,302 --> 00:13:40,980
这些块被破坏之前将这些块交错，就像这样。 发出或存储。

197
00:13:45,580 --> 00:13:50,272
话又说回来，其中很多内容在更现代的代码中完全没有意义 ，

198
00:13:50,272 --> 00:13:55,132
比如更常用的里德-所罗门算法，它可以很好地处理突发 错误，

199
00:13:55,132 --> 00:13:58,820
并且可以对其进行调整以适应每个块的更多错误。

200
00:13:59,360 --> 00:14:01,340
但这是另一个话题了。

201
00:14:02,500 --> 00:14:06,306
汉明在他的《科学与工程的艺术》一书中非常坦 

202
00:14:06,306 --> 00:14:09,940
诚地讲述了他发现这段代码的过程是多么曲折。

203
00:14:10,620 --> 00:14:14,362
他首先尝试了各种不同的方案，包括将这些位组织 

204
00:14:14,362 --> 00:14:17,780
成更高维晶格的部分以及诸如此类的奇怪事物。

205
00:14:18,300 --> 00:14:22,706
汉明在进行了一系列其他分析后退后一步，问 道：“好吧，

206
00:14:22,706 --> 00:14:25,644
我能做到的最有效的方法是什 么”时，

207
00:14:25,644 --> 00:14:29,887
他才想到了通过奇偶校验来共谋以 阐明错误位置的想法。

208
00:14:29,887 --> 00:14:31,520
 可能是关于这个的？

209
00:14:32,620 --> 00:14:36,841
他还坦诚地表示，奇偶校验已经在他的脑海中变得多么重要，

210
00:14:36,841 --> 00:14:41,220
 而在 20 世纪 40 年代，奇偶校验比今天要少得多。

211
00:14:41,920 --> 00:14:45,235
在这本书中，他大约有六次引用了路易斯· 

212
00:14:45,235 --> 00:14:48,220
巴斯德的名言：幸运眷顾有准备的头脑。

213
00:14:49,320 --> 00:14:54,300
事后看来，聪明的想法往往看似简单，这使得它们很容易被低估。

214
00:14:54,960 --> 00:14:59,239
现在我真诚地希望汉明码，或者至少是这种代 码的可能性，

215
00:14:59,239 --> 00:15:01,300
对你来说几乎是显而易见的。

216
00:15:01,660 --> 00:15:05,454
但你不应该自欺欺人地认为它们实际上 是显而易见的，

217
00:15:05,454 --> 00:15:06,820
因为它们绝对不是。

218
00:15:07,880 --> 00:15:13,051
聪明的想法看起来看似简单，部分原因是我们 只看到最终结果，

219
00:15:13,051 --> 00:15:16,796
清理混乱的部分，从不提及 所有错误的转折，

220
00:15:16,796 --> 00:15:21,790
低估了问题开始时可探索的 可能性空间有多大。 解决过程，

221
00:15:21,790 --> 00:15:22,860
所有这一切。

222
00:15:23,820 --> 00:15:24,900
但总的来说确实如此。

223
00:15:24,900 --> 00:15:27,547
我认为对于一些特殊的发明，我们低 

224
00:15:27,547 --> 00:15:30,040
估它们还有第二个更深层次的原因。

225
00:15:30,840 --> 00:15:33,656
直到 1948 年，随着克劳德·香农（Claude 

226
00:15:33,656 --> 00:15:36,256
Shannon）关于 信息论的开创性论文的出现，

227
00:15:36,256 --> 00:15:38,640
用比特来思考信息才真正融合成一个完整的理论。

228
00:15:39,280 --> 00:15:42,540
这基本上与汉明开发他的算法的时间同时发生。

229
00:15:43,300 --> 00:15:48,675
这篇基础论文在某种意义上表明，无 论位翻转的概率有多高，

230
00:15:48,675 --> 00:15:52,900
有效的纠错 总是可能的，至少在理论上是这样。

231
00:15:53,700 --> 00:15:57,356
顺便说一句，香农和汉明在贝尔实验室共用一间办公室，

232
00:15:57,356 --> 00:16:01,160
 尽管他们从事的工作截然不同，这在这里似乎并非巧合。

233
00:16:02,380 --> 00:16:07,567
快进几十年，如今，我们中的许多人都沉浸在对比特和 

234
00:16:07,567 --> 00:16:12,340
信息的思考中，很容易忽视这种思维方式的独特性。

235
00:16:13,100 --> 00:16:17,777
具有讽刺意味的是，那些最深刻地塑造下一代思维方 

236
00:16:17,777 --> 00:16:22,260
式的想法最终会在下一代人看来比实际情况更简单。

