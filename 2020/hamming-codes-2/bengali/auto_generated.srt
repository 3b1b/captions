1
00:00:00,000 --> 00:00:08,620
আপনি কি কখনও ভেবে দেখেছেন যে কীভাবে একটি সিডি বা ডিভিডি স্ক্র্যাচ করা

2
00:00:08,620 --> 00:00:10,900
সম্ভব এবং তারপরও এটি যা কিছু সঞ্চয় করে তা প্লেব্যাক করতে পারে?

3
00:00:10,900 --> 00:00:15,280
স্ক্র্যাচটি আসলেই ডিস্কের 1s এবং 0s কে প্রভাবিত করে, তাই এটি যা সংরক্ষিত ছিল

4
00:00:15,280 --> 00:00:20,500
তার থেকে বিভিন্ন ডেটা পড়ে, কিন্তু যদি এটি সত্যিই স্ক্র্যাচ আপ না করা

5
00:00:20,500 --> 00:00:26,540
হয়, এটি যে বিটগুলি পড়ে তা অবিকল একই ফাইলে ডিকোড করা হয় যা

6
00:00:26,540 --> 00:00:28,400
এটিতে এনকোড করা হয়েছিল, একটি বিট কপির জন্য বিট, সেই সমস্ত ত্রুটি সত্ত্বেও।

7
00:00:28,400 --> 00:00:32,800
গাণিতিক চতুরতার একটি সম্পূর্ণ স্তূপ রয়েছে যা আমাদের ডেটা সঞ্চয় করতে দেয়,

8
00:00:32,800 --> 00:00:36,840
এবং ঠিক একইভাবে গুরুত্বপূর্ণভাবে ডেটা প্রেরণ করতে, এমনভাবে যা ত্রুটির প্রতি স্থিতিস্থাপক।

9
00:00:36,840 --> 00:00:41,480
ওয়েল, ঠিক আছে, আসলে এটি করার জন্য একটি

10
00:00:41,480 --> 00:00:42,480
উপায় নিয়ে আসতে এত চতুরতা লাগে না।

11
00:00:42,480 --> 00:00:47,660
যেকোনো ফাইল, তা ভিডিও বা শব্দ বা পাঠ্য, কিছু কোড, একটি চিত্র,

12
00:00:47,660 --> 00:00:50,960
যাই হোক না কেন, শেষ পর্যন্ত 1 এবং 0 সেকেন্ডের কিছু ক্রম।

13
00:00:50,960 --> 00:00:55,340
এবং ফ্লিপ করা যে কোনও বিট সংশোধন করার একটি

14
00:00:55,340 --> 00:00:57,780
সহজ কৌশল হ'ল প্রতিটি বিটের তিনটি কপি সংরক্ষণ করা।

15
00:00:57,780 --> 00:01:02,240
তারপরে এই ফাইলটি পড়ার মেশিনটি এই তিনটি কপির তুলনা করতে পারে এবং

16
00:01:02,240 --> 00:01:07,440
যখনই কোনো অমিল হয় তখন সর্বদা 3টির মধ্যে সেরা 2টি নিতে পারে।

17
00:01:07,440 --> 00:01:11,560
কিন্তু এর অর্থ হল আপনার জায়গার দুই তৃতীয়াংশ অপ্রয়োজনীয়তার জন্য ব্যবহার করা।

18
00:01:11,560 --> 00:01:15,360
এবং তারপরেও, সেই সমস্ত জায়গা ছেড়ে দেওয়ার জন্য, একের বেশি বিট

19
00:01:15,360 --> 00:01:18,120
ফ্লিপ হলে কী হবে সে সম্পর্কে কোনও শক্তিশালী গ্যারান্টি নেই।

20
00:01:18,120 --> 00:01:21,960
আরও আকর্ষণীয় প্রশ্ন হল এটি কীভাবে তৈরি করা যায় যাতে যতটা

21
00:01:21,960 --> 00:01:24,740
সম্ভব কম জায়গা ছেড়ে দেওয়ার সময় ত্রুটিগুলি সংশোধন করা যায়।

22
00:01:24,740 --> 00:01:28,500
উদাহরণস্বরূপ, এই ভিডিওটি সম্পর্কে আপনি যে পদ্ধতিটি শিখবেন তা ব্যবহার করে আপনি 256-বিট ব্লকে আপনার ডেটা সংরক্ষণ

23
00:01:28,500 --> 00:01:35,840
করতে পারেন, যেখানে প্রতিটি ব্লক 9 বিট ব্যবহার করে, 9! এক ধরনের অপ্রয়োজনীয়তা হিসাবে কাজ করতে,

24
00:01:35,840 --> 00:01:41,000
এবং অন্যান্য 247 বিটগুলি আপনি যা চান তা অর্থপূর্ণ বার্তা বা ডেটা বহন করতে বিনামূল্যে।

25
00:01:41,000 --> 00:01:44,740
এবং এটি এখনও এমন হবে যে যদি এখানে কোনও বিট উল্টে যায়, শুধুমাত্র এই ব্লকটি

26
00:01:44,740 --> 00:01:49,640
দেখে এবং আর কিছুই না, একটি মেশিন সনাক্ত করতে সক্ষম হবে যে একটি ত্রুটি ছিল

27
00:01:49,640 --> 00:01:53,120
এবং সঠিকভাবে এটি কোথায় ছিল যাতে এটি কীভাবে সংশোধন করতে হয় তা জানে। .

28
00:01:53,140 --> 00:01:55,540
এবং সত্যই, যে জাদু মত মনে হয়.

29
00:01:55,540 --> 00:01:59,400
এবং এই নির্দিষ্ট স্কিমের জন্য, যদি দুটি বিট ফ্লিপ করা হয়, মেশিনটি অন্তত সনাক্ত করতে

30
00:01:59,400 --> 00:02:03,180
সক্ষম হবে যে দুটি ত্রুটি ছিল, যদিও সেগুলি কীভাবে ঠিক করা যায় তা জানে না।

31
00:02:03,180 --> 00:02:08,140
বিভিন্ন আকারের ব্লকগুলির জন্য এটি কীভাবে স্কেল করে সে সম্পর্কে আমরা একটু পরে কথা বলব।

32
00:02:08,140 --> 00:02:12,620
যে পদ্ধতিগুলি আপনাকে এই জাতীয় ত্রুটিগুলি সংশোধন করতে দেয়

33
00:02:12,620 --> 00:02:13,880
তা যথেষ্ট পরিমাণে ত্রুটি সংশোধন কোড হিসাবে পরিচিত।

34
00:02:13,880 --> 00:02:18,220
গত শতাব্দীর আরও ভাল অংশে, এই ক্ষেত্রটি আশ্চর্যজনকভাবে গভীর গণিতের একটি সত্যিই

35
00:02:18,220 --> 00:02:23,000
সমৃদ্ধ উৎস যা আমরা প্রতিদিন ব্যবহার করি এমন ডিভাইসগুলিতে অন্তর্ভুক্ত হয়ে যায়।

36
00:02:23,000 --> 00:02:27,740
এখানে লক্ষ্য হল আপনাকে একটি হ্যামিং কোড নামে

37
00:02:27,740 --> 00:02:29,660
পরিচিত প্রাচীনতম উদাহরণগুলির একটি খুব পুঙ্খানুপুঙ্খভাবে বোঝানো।

38
00:02:29,660 --> 00:02:32,620
এবং যাইহোক, এই ভিডিওটির গঠন সম্পর্কে আমি যেভাবে ভাবছি তা হল এটিকে

39
00:02:32,620 --> 00:02:37,060
যতটা সম্ভব সরাসরি ব্যাখ্যা করার বিষয়ে কম, এবং এখানে এবং সেখানে একটু

40
00:02:37,060 --> 00:02:40,220
মৃদু নির্দেশনা সহ আপনাকে নিজের জন্য এটি উদ্ভাবনের জন্য প্ররোচিত করার বিষয়।

41
00:02:40,220 --> 00:02:44,100
তাই যখন আপনি মনে করেন আপনি দেখতে পাচ্ছেন যে এটি কোন সময়ে কোথায় যাচ্ছে, সেই

42
00:02:44,100 --> 00:02:47,180
মুহূর্তটিকে বিরতি দিন, আমি আপনাকে বলার আগে স্কিমটি কী হতে চলেছে তা সক্রিয়ভাবে ভবিষ্যদ্বাণী করুন।

43
00:02:47,180 --> 00:02:51,500
এছাড়াও, আপনি যদি আপনার বোঝাপড়াকে হার্ডওয়্যার স্তরে নামতে চান তবে বেন ইটার

44
00:02:51,500 --> 00:02:55,160
এটির সাথে একত্রে একটি ভিডিও তৈরি করেছে যা আপনাকে দেখায় যে

45
00:02:55,160 --> 00:02:59,520
কীভাবে ব্রেডবোর্ডে হ্যামিং কোডগুলি বাস্তবে প্রয়োগ করতে হয়, যা অত্যন্ত সন্তোষজনক।

46
00:02:59,520 --> 00:03:03,120
আপনার জানা উচিত, হ্যামিং কোডগুলি রিড-সলোমন অ্যালগরিদমের মতো আরও আধুনিক কোডগুলির মতো ব্যাপকভাবে ব্যবহৃত

47
00:03:03,120 --> 00:03:08,040
হয় না, তবে শুরুতে এই কাজটি কতটা অসম্ভব মনে হয় এবং একবার এটি কতটা

48
00:03:08,040 --> 00:03:14,240
যুক্তিসঙ্গত মনে হয় তার মধ্যে বৈসাদৃশ্যের একটি নির্দিষ্ট জাদু রয়েছে। আপনি হ্যামিং সম্পর্কে শিখুন।

49
00:03:14,240 --> 00:03:19,080
ত্রুটি সংশোধনের মূল নীতি হল যে সমস্ত সম্ভাব্য বার্তাগুলির একটি

50
00:03:19,300 --> 00:03:22,860
বিশাল স্থানে, শুধুমাত্র কিছু উপসেট বৈধ বার্তা হিসাবে বিবেচিত হবে।

51
00:03:22,860 --> 00:03:29,100
একটি উপমা হিসাবে, সঠিকভাবে বানান শব্দ বনাম ভুল বানান শব্দ সম্পর্কে চিন্তা করুন।

52
00:03:29,100 --> 00:03:33,340
যখনই একটি বৈধ বার্তা পরিবর্তন করা হয়, রিসিভার নিকটতম বৈধ প্রতিবেশীর কাছে যা

53
00:03:33,340 --> 00:03:38,380
দেখেন তা সংশোধন করার জন্য দায়ী, যেমন আপনি একটি টাইপোতে করতে পারেন।

54
00:03:38,380 --> 00:03:43,100
এই ধরনের বার্তাগুলিকে দক্ষতার সাথে শ্রেণীবদ্ধ করার জন্য একটি

55
00:03:43,100 --> 00:03:47,160
কংক্রিট অ্যালগরিদম নিয়ে আসা, যদিও, একটি নির্দিষ্ট চতুরতা লাগে৷

56
00:03:47,160 --> 00:03:52,060
গল্পটি শুরু হয় 1940 এর দশকে, যখন একজন যুবক রিচার্ড হ্যামিং বেল ল্যাবসের

57
00:03:52,060 --> 00:03:55,900
জন্য কাজ করছিলেন এবং তার কিছু কাজ একটি খুব বড় ব্যয়বহুল পাঞ্চ

58
00:03:55,900 --> 00:03:57,420
কার্ড কম্পিউটার ব্যবহার করে জড়িত ছিল যেটিতে তার কেবল সীমিত অ্যাক্সেস ছিল।

59
00:03:57,420 --> 00:04:01,200
এবং এটির মাধ্যমে তিনি যে প্রোগ্রামগুলি রেখেছিলেন তা ব্যর্থ হতে

60
00:04:01,200 --> 00:04:03,140
থাকে, কারণ প্রতিবার এবং তারপরে কিছুটা ভুল বোঝা যায়।

61
00:04:03,140 --> 00:04:07,140
হতাশা উদ্ভাবনের ক্রুসিবল হওয়ায় তিনি এতটাই বিরক্ত হয়েছিলেন যে

62
00:04:07,140 --> 00:04:09,280
তিনি বিশ্বের প্রথম ত্রুটি সংশোধন কোড আবিষ্কার করেছিলেন।

63
00:04:09,280 --> 00:04:13,020
হ্যামিং কোডগুলি ফ্রেম করার বিভিন্ন উপায় রয়েছে, তবে প্রথম পাস হিসাবে আমরা

64
00:04:13,020 --> 00:04:16,620
এটির মধ্য দিয়ে যেতে যাচ্ছি যেভাবে হ্যামিং নিজেই সেগুলি সম্পর্কে ভেবেছিল।

65
00:04:16,620 --> 00:04:21,400
আসুন একটি উদাহরণ ব্যবহার করি যা সহজ, কিন্তু খুব সহজ নয়, 16 বিটের একটি ব্লক।

66
00:04:21,400 --> 00:04:25,700
আমরা এই বিটগুলির অবস্থানগুলি 0 থেকে 15 পর্যন্ত সংখ্যা করব।

67
00:04:25,700 --> 00:04:30,520
আমরা যে প্রকৃত ডেটা সঞ্চয় করতে চাই তা এই বিটগুলির মধ্যে শুধুমাত্র 12টি

68
00:04:30,520 --> 00:04:33,920
বিট তৈরি করতে যাচ্ছে, যখন 4টি অবস্থান এক ধরনের রিডানডেন্সি হিসাবে সংরক্ষিত।

69
00:04:33,920 --> 00:04:38,120
এখানে অপ্রয়োজনীয় শব্দটি কেবল অনুলিপি বোঝায় না, সর্বোপরি, সেই 4 বিটগুলি

70
00:04:38,120 --> 00:04:40,200
আমাদের অন্ধভাবে ডেটা অনুলিপি করার জন্য যথেষ্ট জায়গা দেয় না।

71
00:04:40,200 --> 00:04:44,880
পরিবর্তে, তাদের প্রয়োজন হবে অনেক বেশি সূক্ষ্ম এবং চতুর ধরণের অপ্রয়োজনীয়তা,

72
00:04:44,880 --> 00:04:48,740
কোন নতুন তথ্য যোগ করা নয়, বরং স্থিতিস্থাপকতা যোগ করা।

73
00:04:48,740 --> 00:04:52,620
আপনি আশা করতে পারেন যে এই 4টি বিশেষ বিট একসাথে সুন্দরভাবে প্যাকেজ করা হবে, হয়তো

74
00:04:52,620 --> 00:04:56,400
শেষে বা এরকম কিছু, কিন্তু আপনি দেখতে পাবেন, তাদের এমন অবস্থানে বসতে হবে যা

75
00:04:56,400 --> 00:05:00,320
2 এর ক্ষমতা সম্পন্ন এমন কিছুর জন্য অনুমতি দেয় যা শেষ পর্যন্ত সত্যিই মার্জিত।

76
00:05:00,320 --> 00:05:05,420
এটি আপনাকে বৃহত্তর ব্লকগুলির জন্য কীভাবে স্কেল করে সে সম্পর্কে একটি সামান্য ইঙ্গিতও দিতে পারে।

77
00:05:05,420 --> 00:05:09,220
এছাড়াও প্রযুক্তিগতভাবে এটি শুধুমাত্র 11 বিট ডেটার মধ্যে শেষ হয়, আপনি 0 পজিশনে যা হয়

78
00:05:09,220 --> 00:05:14,260
তার জন্য একটি হালকা সূক্ষ্মতা দেখতে পাবেন, কিন্তু আপাতত এটি নিয়ে চিন্তা করবেন না।

79
00:05:14,280 --> 00:05:18,640
যেকোনো ত্রুটি সংশোধন অ্যালগরিদমের মতো, এতে দুইজন খেলোয়াড় জড়িত থাকবে, একজন প্রেরক

80
00:05:18,640 --> 00:05:23,200
যিনি এই 4টি বিশেষ বিট সেট করার জন্য দায়ী, এবং একজন

81
00:05:23,200 --> 00:05:26,360
প্রাপক যিনি কিছু ধরণের পরীক্ষা এবং ত্রুটি সংশোধন করার জন্য দায়ী৷

82
00:05:26,360 --> 00:05:30,040
অবশ্যই, প্রেরক এবং প্রাপক শব্দগুলি আসলেই মেশিন বা সফ্টওয়্যারকে বোঝায়

83
00:05:30,040 --> 00:05:34,040
যা সমস্ত পরীক্ষা করছে এবং একটি বার্তার ধারণাটি সত্যিই

84
00:05:34,040 --> 00:05:35,480
বিস্তৃতভাবে বোঝানো হয়েছে, স্টোরেজের মতো জিনিসগুলিকে অন্তর্ভুক্ত করার জন্য।

85
00:05:35,480 --> 00:05:39,320
সর্বোপরি, ডেটা সংরক্ষণ করা এক জায়গা থেকে অন্য জায়গায়

86
00:05:39,320 --> 00:05:42,640
না গিয়ে অতীত থেকে ভবিষ্যতে বার্তা পাঠানোর মতোই।

87
00:05:42,640 --> 00:05:46,700
সুতরাং এটি সেটআপ, তবে আমরা ডুব দেওয়ার আগে আমাদের একটি সম্পর্কিত ধারণা

88
00:05:46,700 --> 00:05:51,080
সম্পর্কে কথা বলতে হবে যা হ্যামিংয়ের আবিষ্কারের সময় তার মনে তাজা ছিল,

89
00:05:51,080 --> 00:05:55,520
একটি পদ্ধতি যা আপনাকে কোনও একক বিট ত্রুটি সনাক্ত করতে দেয়, তবে

90
00:05:55,520 --> 00:05:57,300
সেগুলি সংশোধন করতে পারে না, পরিচিত। একটি সমতা চেক হিসাবে ব্যবসা.

91
00:05:57,300 --> 00:06:01,300
একটি প্যারিটি চেকের জন্য, আমরা শুধুমাত্র একটি একক বিট আলাদা করি যেটি

92
00:06:01,300 --> 00:06:04,940
টিউনিংয়ের জন্য প্রেরক দায়ী, এবং বাকিরা একটি বার্তা বহন করতে স্বাধীন৷

93
00:06:04,940 --> 00:06:10,380
এই বিশেষ বিটের একমাত্র কাজ হল নিশ্চিত করা

94
00:06:10,380 --> 00:06:12,100
যে বার্তাটিতে মোট 1s সংখ্যাটি একটি জোড় সংখ্যা।

95
00:06:12,100 --> 00:06:16,920
উদাহরণস্বরূপ, এই মুহূর্তে, 1s-এর মোট সংখ্যা হল 7, এটি বিজোড়, তাই প্রেরককে

96
00:06:16,920 --> 00:06:20,960
সেই বিশেষ বিটটিকে 1 হতে উল্টাতে হবে, গণনাকে সমান করে তুলতে হবে।

97
00:06:20,960 --> 00:06:25,320
কিন্তু যদি ব্লকটি ইতিমধ্যেই 1s এর একটি জোড় সংখ্যা দিয়ে শুরু

98
00:06:25,320 --> 00:06:27,480
হয়ে থাকে, তাহলে এই বিশেষ বিটটিকে 0 এ রাখা হতো।

99
00:06:27,480 --> 00:06:31,640
এটি বেশ সহজ, প্রতারণামূলকভাবে সহজ, তবে এটি একটি অবিশ্বাস্যভাবে মার্জিত উপায় যে

100
00:06:31,640 --> 00:06:37,760
কোনও বার্তার যে কোনও জায়গায় পরিবর্তনের ধারণাটি একক তথ্যে প্রতিফলিত হতে পারে।

101
00:06:37,760 --> 00:06:43,680
লক্ষ্য করুন যদি এই বার্তার কোনো বিট ফ্লিপ করা হয়, হয় 0 থেকে 1

102
00:06:43,680 --> 00:06:48,140
বা 1 থেকে 0, এটি 1s-এর মোট গণনাকে জোড় থেকে বিজোড় হতে পরিবর্তন করে।

103
00:06:48,140 --> 00:06:52,000
সুতরাং আপনি যদি রিসিভার হন, আপনি এই বার্তাটি দেখেন, এবং আপনি 1

104
00:06:52,000 --> 00:06:56,580
সেকেন্ডের একটি বিজোড় সংখ্যা দেখতে পান, আপনি নিশ্চিতভাবে জানতে পারেন যে

105
00:06:56,580 --> 00:06:58,700
কিছু ত্রুটি ঘটেছে, যদিও আপনার ধারণা নেই যে এটি কোথায় ছিল।

106
00:06:58,700 --> 00:07:02,820
পরিভাষায়, বিটগুলির একটি গোষ্ঠীতে 1s এর একটি জোড় বা

107
00:07:02,820 --> 00:07:04,940
বিজোড় সংখ্যা আছে কিনা তা এর সমতা হিসাবে পরিচিত।

108
00:07:04,940 --> 00:07:09,140
আপনি সংখ্যাগুলিও ব্যবহার করতে পারেন এবং বলতে পারেন সমতা হল 0 বা 1,

109
00:07:09,140 --> 00:07:11,320
যা সাধারণত আরও সহায়ক হয় একবার আপনি ধারণাটি নিয়ে গণিত করা শুরু করেন।

110
00:07:11,320 --> 00:07:15,200
এবং এই বিশেষ বিট যা প্রেরক প্যারিটি নিয়ন্ত্রণ

111
00:07:15,200 --> 00:07:18,020
করতে ব্যবহার করে তাকে প্যারিটি বিট বলে।

112
00:07:18,020 --> 00:07:22,460
এবং প্রকৃতপক্ষে, আমাদের পরিষ্কার হওয়া উচিত, যদি রিসিভার একটি বিজোড় সমতা দেখে, তবে এর অর্থ

113
00:07:22,460 --> 00:07:26,920
এই নয় যে শুধুমাত্র একটি ত্রুটি ছিল, 3টি ত্রুটি বা 5 বা অন্য কোন

114
00:07:26,920 --> 00:07:29,560
বিজোড় সংখ্যা থাকতে পারে, তবে তারা নিশ্চিতভাবে জানতে পারে যে এটি 0 ছিল না।

115
00:07:29,560 --> 00:07:34,880
অন্যদিকে, যদি 2টি ত্রুটি থাকে, বা কোনো জোড় সংখ্যার ত্রুটি থাকে, তাহলে

116
00:07:34,880 --> 00:07:39,560
1s-এর চূড়ান্ত গণনা এখনও সমান হবে, তাই প্রাপকের সম্পূর্ণ আস্থা থাকতে

117
00:07:39,560 --> 00:07:43,360
পারে না যে একটি জোড় গণনা অগত্যা মানে বার্তাটি ত্রুটি-মুক্ত। .

118
00:07:43,360 --> 00:07:47,860
আপনি অভিযোগ করতে পারেন যে একটি বার্তা যা শুধুমাত্র 2 বিট ফ্লিপ

119
00:07:47,860 --> 00:07:49,760
দ্বারা বিভ্রান্ত হয় তা বেশ দুর্বল, এবং আপনি একেবারে সঠিক হবেন।

120
00:07:49,760 --> 00:07:54,480
মনে রাখবেন, যদিও, ত্রুটি সনাক্তকরণ বা সংশোধনের কোনো পদ্ধতি নেই যা আপনাকে

121
00:07:54,480 --> 00:07:59,720
100% আত্মবিশ্বাস দিতে পারে যে আপনি যে বার্তাটি পেয়েছেন সেটিই প্রেরকের উদ্দেশ্যে।

122
00:07:59,720 --> 00:08:03,760
সর্বোপরি, পর্যাপ্ত এলোমেলো শব্দ সর্বদা একটি বৈধ বার্তাকে কেবলমাত্র

123
00:08:03,760 --> 00:08:05,920
বিশুদ্ধ সুযোগে অন্য বৈধ বার্তায় পরিবর্তন করতে পারে।

124
00:08:05,920 --> 00:08:10,520
পরিবর্তে, লক্ষ্য হল এমন একটি স্কিম নিয়ে আসা যা একটি নির্দিষ্ট সর্বাধিক সংখ্যক

125
00:08:10,520 --> 00:08:16,480
ত্রুটির জন্য শক্তিশালী, অথবা এইরকম একটি মিথ্যা ইতিবাচক হওয়ার সম্ভাবনা কমাতে পারে।

126
00:08:16,480 --> 00:08:20,940
প্যারিটি চেকগুলি তাদের নিজস্বভাবে বেশ দুর্বল, কিন্তু একটি সম্পূর্ণ বার্তা জুড়ে

127
00:08:20,940 --> 00:08:25,640
পরিবর্তনের ধারণাটি একক বিট পর্যন্ত ছড়িয়ে দিয়ে, তারা আমাদের যা

128
00:08:25,640 --> 00:08:28,000
দেয় তা আরও পরিশীলিত স্কিমগুলির জন্য একটি শক্তিশালী বিল্ডিং ব্লক।

129
00:08:28,000 --> 00:08:32,880
উদাহরণস্বরূপ, যেহেতু হ্যামিং একটি ত্রুটি কোথায় ঘটেছে তা সনাক্ত করার একটি উপায় অনুসন্ধান করছিলেন,

130
00:08:32,880 --> 00:08:37,160
কেবল এটি ঘটেছিল তা নয়, তার মূল অন্তর্দৃষ্টি ছিল যে আপনি যদি কিছু প্যারিটি

131
00:08:37,160 --> 00:08:42,040
চেক সম্পূর্ণ বার্তায় নয়, তবে কিছু সাবধানে নির্বাচিত উপসেটগুলিতে প্রয়োগ করেন, আপনি জিজ্ঞাসা করতে

132
00:08:42,040 --> 00:08:46,840
পারেন প্রশ্নগুলির একটি আরও পরিমার্জিত সিরিজ যা যেকোনো একক বিট ত্রুটির অবস্থানকে পিন করে।

133
00:08:46,840 --> 00:08:51,280
সামগ্রিক অনুভূতিটি 20টি প্রশ্নের একটি গেম খেলার মতো, হ্যাঁ বা

134
00:08:51,280 --> 00:08:54,300
না প্রশ্ন জিজ্ঞাসা করা যা সম্ভাবনার স্থানকে অর্ধেক করে দেয়।

135
00:08:54,300 --> 00:08:58,840
উদাহরণ স্বরূপ, ধরা যাক আমরা এই 8টি বিটের উপর

136
00:08:58,840 --> 00:08:59,840
একটি সমতা পরীক্ষা করি, সমস্ত বিজোড় সংখ্যাযুক্ত অবস্থানে।

137
00:09:00,400 --> 00:09:04,560
তারপরে যদি একটি ত্রুটি সনাক্ত করা হয়, এটি রিসিভারকে বিশেষভাবে ত্রুটিটি কোথায়

138
00:09:04,560 --> 00:09:09,160
সে সম্পর্কে একটু বেশি তথ্য দেয়, যেমন এটি একটি বিজোড় অবস্থানে রয়েছে।

139
00:09:09,160 --> 00:09:14,360
যদি এই 8 বিটের মধ্যে কোন ত্রুটি সনাক্ত না করা হয়, তবে

140
00:09:14,360 --> 00:09:17,240
এর মানে হয় কোন ত্রুটি নেই, অথবা এটি কোথাও সমান অবস্থানে বসে।

141
00:09:17,240 --> 00:09:21,560
আপনি ভাবতে পারেন যে প্যারিটি চেককে অর্ধেক বিটের মধ্যে সীমাবদ্ধ করা এটিকে

142
00:09:21,560 --> 00:09:25,460
কম কার্যকর করে তোলে, কিন্তু যখন এটি অন্যান্য ভাল-নির্বাচিত চেকের সাথে

143
00:09:25,460 --> 00:09:29,720
একত্রে করা হয়, তখন এটি আমাদেরকে অনেক বেশি শক্তিশালী কিছু দেয়।

144
00:09:29,720 --> 00:09:34,440
প্রকৃতপক্ষে সেই প্যারিটি চেকটি সেট আপ করতে, মনে রাখবেন, এটির জন্য কিছু বিশেষ

145
00:09:34,440 --> 00:09:37,600
বিট চিহ্নিত করা প্রয়োজন যা সেই পূর্ণ গোষ্ঠীর সমতার জন্য নিয়ন্ত্রণ করে।

146
00:09:37,600 --> 00:09:39,920
এখানে আসুন শুধু পজিশন 1 বেছে নেওয়া যাক।

147
00:09:39,920 --> 00:09:43,960
দেখানো উদাহরণের জন্য, এই 8 বিটের সমতা বর্তমানে বিজোড়, তাই সেই

148
00:09:43,960 --> 00:09:48,220
প্যারিটি বিট টগল করার জন্য প্রেরক দায়ী, এবং এখন এটি সমান।

149
00:09:48,220 --> 00:09:51,040
এটি 4টি প্যারিটি চেকের মধ্যে মাত্র 1টি যা আমরা করব৷

150
00:09:51,040 --> 00:09:55,560
দ্বিতীয় চেকটি গ্রিডের ডান অর্ধেকের 8 বিটের

151
00:09:55,560 --> 00:09:56,880
মধ্যে রয়েছে, অন্তত আমরা এটি এখানে আঁকছি।

152
00:09:56,880 --> 00:10:02,520
এইবার আমরা একটি প্যারিটি বিট হিসাবে অবস্থান 2 ব্যবহার করতে পারি, তাই এই 8 বিটের ইতিমধ্যেই

153
00:10:02,520 --> 00:10:07,160
একটি সমান সমতা রয়েছে এবং প্রেরক সেই বিট নম্বর 2 অপরিবর্তিত রেখে ভাল বোধ করতে পারেন।

154
00:10:07,160 --> 00:10:11,040
তারপর অন্য প্রান্তে, যদি রিসিভার এই গ্রুপের সমতা পরীক্ষা করে এবং তারা দেখতে পায়

155
00:10:11,040 --> 00:10:15,960
যে এটি অদ্ভুত, তারা জানবে যে ত্রুটিটি ডানদিকে এই 8 বিটের মধ্যে কোথাও রয়েছে।

156
00:10:15,960 --> 00:10:21,260
অন্যথায় এর মানে হয় কোন ত্রুটি নেই, বা ত্রুটিটি বাম অর্ধেকের কোথাও রয়েছে।

157
00:10:21,260 --> 00:10:24,040
অথবা আমি অনুমান করি যে দুটি ত্রুটি হতে পারে, কিন্তু এই মুহূর্তে

158
00:10:24,040 --> 00:10:27,080
আমরা অনুমান করতে যাচ্ছি যে পুরো ব্লকে সর্বাধিক একটি ত্রুটি রয়েছে।

159
00:10:27,080 --> 00:10:29,160
এর চেয়েও বেশি কিছুর জন্য জিনিসগুলি সম্পূর্ণ ভেঙ্গে যায়।

160
00:10:29,160 --> 00:10:32,920
এখানে, আমরা পরবর্তী দুটি চেক দেখার আগে, আপনি যখন তাদের একসাথে বিবেচনা করেন তখন এই

161
00:10:32,920 --> 00:10:35,880
প্রথম দুটি আমাদের কী করতে দেয় সে সম্পর্কে চিন্তা করার জন্য একটু সময় নিন।

162
00:10:35,880 --> 00:10:40,240
ধরা যাক আপনি বিজোড় কলামের মধ্যে এবং ডান অর্ধেকের মধ্যে একটি ত্রুটি সনাক্ত করেছেন।

163
00:10:40,240 --> 00:10:43,940
এটি অগত্যা মানে শেষ কলামের কোথাও ত্রুটি আছে।

164
00:10:43,940 --> 00:10:48,280
যদি বিজোড় কলামে কোনো ত্রুটি না থাকে তবে ডান অর্ধে একটি ছিল,

165
00:10:48,280 --> 00:10:50,520
তাহলে এটি আপনাকে বলে যে এটি দ্বিতীয় থেকে শেষ কলামে রয়েছে।

166
00:10:50,520 --> 00:10:54,640
একইভাবে যদি বিজোড় কলামে একটি ত্রুটি থাকে কিন্তু ডান অর্ধেক

167
00:10:54,640 --> 00:10:56,560
না থাকে, আপনি জানেন যে এটি দ্বিতীয় কলামের কোথাও আছে।

168
00:10:56,560 --> 00:11:00,560
এবং যদি এই দুটি প্যারিটি চেকগুলির মধ্যে কোনওটিই কিছু সনাক্ত না করে, তবে

169
00:11:00,560 --> 00:11:03,760
এর অর্থ হল একমাত্র জায়গা যা একটি ত্রুটি হতে পারে সেই বামদিকের কলামে।

170
00:11:03,760 --> 00:11:06,480
কিন্তু এটি সহজভাবে বোঝাতে পারে যে কোনও ত্রুটি নেই।

171
00:11:06,480 --> 00:11:10,800
যা বলার অপেক্ষা রাখে না যে দুটি

172
00:11:10,800 --> 00:11:11,800
প্যারিটি চেক আমাদের কলামটি পিন করে দেয়।

173
00:11:11,800 --> 00:11:14,000
এখান থেকে, আপনি সম্ভবত অনুমান করতে পারেন যা অনুসরণ করে।

174
00:11:14,000 --> 00:11:16,240
আমরা মূলত একই জিনিস কিন্তু সারি জন্য.

175
00:11:16,240 --> 00:11:21,040
একটি প্যারিটি বিট হিসাবে অবস্থান 4 ব্যবহার করে, বিজোড় সারি একটি সমতা চেক হতে যাচ্ছে.

176
00:11:21,040 --> 00:11:25,480
সুতরাং এই উদাহরণে সেই গোষ্ঠীর ইতিমধ্যেই একটি সমান সমতা রয়েছে,

177
00:11:25,480 --> 00:11:26,480
তাই বিট 4 একটি 0 এ সেট করা হবে।

178
00:11:26,480 --> 00:11:31,280
এবং অবশেষে একটি প্যারিটি চেক আছে নীচের দুটি সারিতে,

179
00:11:31,280 --> 00:11:32,280
একটি প্যারিটি বিট হিসাবে অবস্থান 8 ব্যবহার করে।

180
00:11:32,280 --> 00:11:35,840
এই ক্ষেত্রে, দেখে মনে হচ্ছে প্রেরককে গ্রুপটিকে সমান সমান

181
00:11:35,840 --> 00:11:37,840
করার জন্য সেই বিট 8 চালু করতে হবে।

182
00:11:37,840 --> 00:11:41,360
ঠিক যেমন প্রথম দুটি চেক আমাদের কলামকে পিন করতে

183
00:11:41,360 --> 00:11:43,000
দেয়, এই পরের দুটি আপনাকে সারিটি পিন করতে দেয়।

184
00:11:43,000 --> 00:11:48,400
একটি উদাহরণ হিসাবে, কল্পনা করুন যে ট্রান্সমিশনের সময় অবস্থান 3 এ একটি ত্রুটি রয়েছে।

185
00:11:48,400 --> 00:11:52,620
ভাল এটি প্রথম প্যারিটি গ্রুপকে প্রভাবিত করে এবং এটি দ্বিতীয় প্যারিটি গ্রুপকেও

186
00:11:52,620 --> 00:11:56,340
প্রভাবিত করে, তাই রিসিভার জানে যে ডান কলামে কোথাও একটি ত্রুটি রয়েছে।

187
00:11:56,340 --> 00:12:01,380
তবে এটি তৃতীয় গ্রুপকে প্রভাবিত করে না এবং এটি চতুর্থ গ্রুপকে প্রভাবিত করে না।

188
00:12:01,380 --> 00:12:05,460
এবং এটি রিসিভারকে প্রথম সারি পর্যন্ত ত্রুটিটি চিহ্নিত করতে দেয়, যার

189
00:12:05,460 --> 00:12:08,660
অর্থ অগত্যা অবস্থান 3, যাতে তারা ত্রুটিটি ঠিক করতে পারে।

190
00:12:08,660 --> 00:12:12,640
আপনি নিজেকে সন্তুষ্ট করতে একটি মুহূর্ত উপভোগ করতে পারেন যে এই চারটি প্রশ্নের উত্তর

191
00:12:12,680 --> 00:12:17,320
সত্যিই সর্বদা আপনাকে একটি নির্দিষ্ট অবস্থানে পিন করতে দেয়, সেগুলি যেখানেই হোক না কেন।

192
00:12:17,320 --> 00:12:22,640
প্রকৃতপক্ষে, আপনার মধ্যে বিচক্ষণ ব্যক্তি এমনকি এই প্রশ্নগুলি এবং

193
00:12:22,640 --> 00:12:23,640
বাইনারি গণনার মধ্যে একটি সংযোগ লক্ষ্য করতে পারে।

194
00:12:23,640 --> 00:12:27,840
এবং যদি আপনি করেন, আবার আমাকে জোর দিন, বিরতি দিন,

195
00:12:27,840 --> 00:12:30,880
আমি এটি নষ্ট করার আগে সংযোগটি আঁকতে চেষ্টা করুন।

196
00:12:30,880 --> 00:12:35,560
আপনি যদি ভাবছেন যে একটি প্যারিটি বিট নিজেই প্রভাবিত

197
00:12:35,560 --> 00:12:36,560
হলে কী হবে, ভাল, আপনি এটি চেষ্টা করতে পারেন।

198
00:12:36,560 --> 00:12:40,720
এই চারটি স্পেশাল বিটের মধ্যে যেকোন ত্রুটি কিভাবে অন্য যেকোন মত, একই গ্রুপের

199
00:12:40,720 --> 00:12:47,440
চারটি প্রশ্নের সাথে ট্র্যাক করা হবে তা নিয়ে ভাবতে একটু সময় নিন।

200
00:12:47,440 --> 00:12:50,500
এটা আসলে কোন ব্যাপার না, যেহেতু দিনের শেষে আমরা যা চাই তা

201
00:12:50,500 --> 00:12:53,640
হল মেসেজ বিটগুলিকে রক্ষা করা, ত্রুটি সংশোধন বিটগুলি ঠিকই এগিয়ে চলেছে।

202
00:12:53,640 --> 00:12:57,120
তবে সেই বিটগুলিকেও রক্ষা করা এমন কিছু যা

203
00:12:57,120 --> 00:12:59,260
স্বাভাবিকভাবেই একটি উপজাত হিসাবে স্কিম থেকে বেরিয়ে আসে।

204
00:12:59,260 --> 00:13:02,380
আপনি এই দাঁড়িপাল্লা কিভাবে আন্দাজ উপভোগ করতে পারে.

205
00:13:02,380 --> 00:13:08,040
যদি আমরা 256 বিটের আকারের একটি ব্লক ব্যবহার করি, উদাহরণস্বরূপ, একটি অবস্থান পিন ডাউন করার জন্য,

206
00:13:08,040 --> 00:13:15,680
কোনো নির্দিষ্ট স্থানে বাইনারি অনুসন্ধান করার জন্য আপনার শুধুমাত্র আটটি হ্যাঁ বা না প্রশ্নের প্রয়োজন।

207
00:13:15,680 --> 00:13:19,680
এবং মনে রাখবেন, উপযুক্ত প্যারিটি চেক সেট করতে প্রতিটি

208
00:13:19,680 --> 00:13:23,340
প্রশ্নের জন্য শুধুমাত্র একটি বিট ছেড়ে দিতে হবে।

209
00:13:23,340 --> 00:13:26,960
আপনাদের মধ্যে কেউ কেউ হয়তো এটি ইতিমধ্যেই দেখতে পাচ্ছেন, কিন্তু এই প্রশ্নগুলো কি মাত্র এক

210
00:13:26,960 --> 00:13:29,960
বা দুই মিনিটের মধ্যে খুঁজে বের করার পদ্ধতিগত উপায় সম্পর্কে আমরা পরে কথা বলব।

211
00:13:29,960 --> 00:13:33,440
আশা করি এই স্কেচটি আমরা এখানে যা উন্নয়ন

212
00:13:33,440 --> 00:13:34,440
করছি তার দক্ষতার প্রশংসা করার জন্য যথেষ্ট।

213
00:13:34,440 --> 00:13:38,440
প্রথম জিনিস, সেই আটটি হাইলাইট করা প্যারিটি বিট ব্যতীত, আপনি যা চান তা

214
00:13:38,440 --> 00:13:41,720
হতে পারে, আপনি যা চান তা বার্তা বা ডেটা বহন করতে পারেন।

215
00:13:41,720 --> 00:13:45,480
8 বিট এই অর্থে অপ্রয়োজনীয় যে তারা সম্পূর্ণরূপে বার্তার বাকি অংশ দ্বারা

216
00:13:45,480 --> 00:13:53,640
নির্ধারিত হয়, তবে এটি সম্পূর্ণরূপে বার্তাটি অনুলিপি করার চেয়ে অনেক স্মার্ট উপায়ে।

217
00:13:53,640 --> 00:13:58,000
এবং এখনও, এত অল্প ছেড়ে দেওয়ার জন্য, আপনি যে কোনও

218
00:13:58,000 --> 00:13:59,000
একক বিট ত্রুটি সনাক্ত করতে এবং ঠিক করতে সক্ষম হবেন।

219
00:13:59,000 --> 00:14:00,400
ভাল প্রায়.

220
00:14:00,400 --> 00:14:05,920
ঠিক আছে, তাই এখানে একটি সমস্যা হল যে যদি চারটি প্যারিটি চেকের মধ্যে

221
00:14:05,920 --> 00:14:10,240
কোনোটিই একটি ত্রুটি সনাক্ত না করে, যার অর্থ হল 8 বিটের বিশেষভাবে

222
00:14:10,240 --> 00:14:15,520
নির্বাচিত উপসেটগুলির সমতুল্য রয়েছে, ঠিক প্রেরকের মতই, তাহলে এর মানে হয় কোনও

223
00:14:15,520 --> 00:14:17,760
ত্রুটি ছিল না , অথবা এটি আমাদের অবস্থান 0 এ সংকুচিত করে।

224
00:14:17,760 --> 00:14:23,040
আপনি দেখুন, চারটি হ্যাঁ বা না প্রশ্নের সাথে, আমাদের সমতা যাচাইয়ের জন্য 16টি সম্ভাব্য ফলাফল

225
00:14:23,040 --> 00:14:28,000
রয়েছে এবং প্রথমে ব্লকের 16টি অবস্থানের মধ্যে 1টি চিহ্নিত করার জন্য নিখুঁত মনে হয়,

226
00:14:28,000 --> 00:14:33,000
তবে আপনাকে একটি 17 তম ফলাফলের সাথে যোগাযোগ করতে হবে, কোন ত্রুটি নেই অবস্থা

227
00:14:33,000 --> 00:14:37,860
এখানে সমাধান আসলে বেশ সহজ, শুধু 0 তম বিট সম্পর্কে সম্পূর্ণরূপে ভুলে যান।

228
00:14:37,860 --> 00:14:41,920
সুতরাং যখন আমরা আমাদের চারটি সমতা পরীক্ষা করি এবং আমরা দেখতে পাই

229
00:14:41,920 --> 00:14:44,320
যে সেগুলি সবই সমান, এটি দ্ব্যর্থহীনভাবে মানে যে কোনও ত্রুটি নেই।

230
00:14:44,320 --> 00:14:49,240
এর মানে হল একটি 16-বিট ব্লকের সাথে কাজ করার পরিবর্তে, আমরা একটি 15-বিট ব্লকের সাথে কাজ করি,

231
00:14:49,240 --> 00:14:54,040
যেখানে 11টি বিট একটি বার্তা বহন করার জন্য বিনামূল্যে এবং তাদের মধ্যে 4টি রিডানডেন্সির জন্য রয়েছে।

232
00:14:54,080 --> 00:14:58,400
এবং এর সাথে, আমাদের কাছে এখন রয়েছে যা ব্যবসার

233
00:14:58,400 --> 00:14:59,400
লোকেরা একটি 15-11 হ্যামিং কোড হিসাবে উল্লেখ করবে।

234
00:14:59,400 --> 00:15:03,920
এটা বলেছে, 2 এর একটি ক্লিন পাওয়ারের একটি ব্লক সাইজ থাকাটা খুবই ভালো, এবং একটি চতুর উপায় আছে

235
00:15:03,920 --> 00:15:08,880
যে আমরা সেই 0 তম বিটকে চারপাশে রাখতে পারি এবং এটি আমাদের জন্য একটু অতিরিক্ত কাজ করতে পারি।

236
00:15:08,880 --> 00:15:13,600
যদি আমরা এটিকে পুরো ব্লক জুড়ে প্যারিটি বিট হিসাবে ব্যবহার করি, তবে এটি

237
00:15:13,600 --> 00:15:16,320
আমাদের প্রকৃতপক্ষে সনাক্ত করতে দেয়, যদিও আমরা 2-বিট ত্রুটিগুলি সংশোধন করতে পারি না।

238
00:15:16,320 --> 00:15:17,440
এখানে কিভাবে এটা কাজ করে.

239
00:15:17,440 --> 00:15:21,740
এই চারটি বিশেষ ত্রুটি-সংশোধনকারী বিট সেট করার পরে, আমরা 0 তম একটি সেট

240
00:15:21,740 --> 00:15:25,540
করি যাতে পুরো ব্লকের প্যারিটি সমান হয়, ঠিক একটি সাধারণ প্যারিটি চেকের মতো।

241
00:15:25,540 --> 00:15:29,780
এখন, যদি একটি একক বিট ত্রুটি থাকে, তাহলে সম্পূর্ণ ব্লকের প্যারিটিটি বিজোড় হতে

242
00:15:29,780 --> 00:15:33,940
টগল হয়, তবে আমরা তা ধরতে পারব যাইহোক চারটি ত্রুটি-সংশোধনকারী চেকের জন্য ধন্যবাদ।

243
00:15:33,940 --> 00:15:38,100
যাইহোক, যদি দুটি ত্রুটি থাকে, তাহলে সামগ্রিক প্যারিটি আবার সমান হয়ে

244
00:15:38,100 --> 00:15:42,660
যাবে, তবে রিসিভার এখনও দেখতে পাবে যে ওই চারটি প্যারিটি

245
00:15:42,660 --> 00:15:45,820
চেকের সাথে যা ঘটছে তার কারণে অন্তত কিছু ত্রুটি রয়েছে।

246
00:15:45,820 --> 00:15:49,780
তাই যদি তারা সামগ্রিকভাবে একটি সমান সমতা লক্ষ্য করে, কিন্তু অন্যান্য চেকের সাথে

247
00:15:49,820 --> 00:15:52,980
শূন্য নয় এমন কিছু ঘটছে, এটি তাদের বলে যে কমপক্ষে দুটি ত্রুটি ছিল।

248
00:15:52,980 --> 00:15:54,420
চতুর তাই না?

249
00:15:54,420 --> 00:15:58,500
যদিও আমরা সেই 2-বিট ত্রুটিগুলি সংশোধন করতে পারি না, কেবলমাত্র সেই একটি সামান্য

250
00:15:58,500 --> 00:16:02,340
বিরক্তিকর 0 তম বিটকে কাজে ফিরিয়ে দিয়ে, এটি আমাদের সেগুলি সনাক্ত করতে দেয়।

251
00:16:02,340 --> 00:16:06,540
এটি বেশ মানক, এটি একটি বর্ধিত হ্যামিং কোড হিসাবে পরিচিত।

252
00:16:06,540 --> 00:16:10,860
প্রযুক্তিগতভাবে বলতে গেলে, আপনার কাছে এখন একটি হ্যামিং কোড কী করে

253
00:16:10,860 --> 00:16:13,580
তার সম্পূর্ণ বিবরণ রয়েছে, অন্তত একটি 16-বিট ব্লকের উদাহরণের জন্য।

254
00:16:13,580 --> 00:16:17,300
কিন্তু আমি মনে করি আপনি শুরু থেকে শেষ পর্যন্ত একটি সম্পূর্ণ উদাহরণ করার মাধ্যমে আপনার

255
00:16:17,300 --> 00:16:21,980
বোঝাপড়ার পরীক্ষা করা এবং এই বিন্দু পর্যন্ত সবকিছুকে দৃঢ় করা আপনার কাছে আরও সন্তোষজনক হবে।

256
00:16:21,980 --> 00:16:25,100
আমি আপনার সাথে এটির মাধ্যমে পদক্ষেপ করব, যাতে আপনি নিজেকে পরীক্ষা করতে পারেন।

257
00:16:25,100 --> 00:16:29,180
একটি বার্তা সেট আপ করতে, এটি একটি আক্ষরিক বার্তা যা আপনি

258
00:16:29,180 --> 00:16:34,100
স্থানের মাধ্যমে অনুবাদ করছেন বা কিছু ডেটা যা আপনি সময়ের সাথে

259
00:16:34,100 --> 00:16:35,700
সঞ্চয় করতে চান, প্রথম পদক্ষেপটি হল এটিকে 11-বিট খণ্ডে ভাগ করা৷

260
00:16:35,700 --> 00:16:40,340
প্রতিটি খণ্ড একটি ত্রুটি-প্রতিরোধী 16-বিট ব্লকে প্যাকেজ হতে চলেছে।

261
00:16:40,340 --> 00:16:43,740
সুতরাং আসুন একটি উদাহরণ হিসাবে এই এক নিতে এবং আসলে এটা কাজ.

262
00:16:43,740 --> 00:16:45,340
এগিয়ে যান, আসলে এটা করতে!

263
00:16:45,380 --> 00:16:47,380
আসুন বিরতি দিন এবং এই ব্লকটি একসাথে রাখার চেষ্টা করি।

264
00:16:52,980 --> 00:16:53,980
ঠিক আছে, আপনি প্রস্তুত?

265
00:16:53,980 --> 00:16:58,500
মনে রাখবেন, পজিশন 0 এর সাথে 2 এর অন্যান্য ক্ষমতাগুলি ত্রুটি সংশোধন শুল্কের জন্য

266
00:16:58,500 --> 00:17:05,700
সংরক্ষিত, তাই আপনি ক্রমানুসারে বাকি সমস্ত জায়গায় বার্তা বিটগুলি স্থাপন করে শুরু করুন।

267
00:17:05,700 --> 00:17:09,700
আপনার এই গোষ্ঠীর একটি সমান সমতা থাকা দরকার, যা এটি ইতিমধ্যেই করে, তাই

268
00:17:09,700 --> 00:17:13,140
আপনার সেই প্যারিটি বিটটিকে 0 হিসাবে 1 অবস্থানে সেট করা উচিত ছিল।

269
00:17:13,140 --> 00:17:17,700
পরের গোষ্ঠীটি একটি বিজোড় সমতা দিয়ে শুরু হয়, তাই

270
00:17:17,700 --> 00:17:19,260
আপনার উচিত এর সমতা বিটটি 1 সেট করা উচিত।

271
00:17:19,260 --> 00:17:23,740
এর পরের গ্রুপটি একটি বিজোড় সমতা দিয়ে শুরু হয়, তাই

272
00:17:23,740 --> 00:17:24,740
আবার আপনার প্যারিটি বিট 1 এ সেট করা উচিত ছিল।

273
00:17:24,740 --> 00:17:29,500
এবং চূড়ান্ত গোষ্ঠীতেও একটি বিজোড় সমতা রয়েছে, যার অর্থ

274
00:17:29,500 --> 00:17:31,500
আমরা সেই বিটটিকে 8 পজিশনে 1 হিসাবে সেট করেছি।

275
00:17:31,500 --> 00:17:36,460
এবং তারপরে চূড়ান্ত পদক্ষেপ হিসাবে, পূর্ণ ব্লকে এখন একটি সমান সমতা রয়েছে, যার

276
00:17:36,460 --> 00:17:41,500
অর্থ আপনি সেই বিট নম্বর 0, ওভারআর্চিং প্যারিটি বিট, 0 সেট করতে পারেন।

277
00:17:41,500 --> 00:17:45,660
সুতরাং এই ব্লকটি পাঠানো হলে, চারটি বিশেষ উপসেটের

278
00:17:45,660 --> 00:17:48,980
সমতা এবং সামগ্রিকভাবে ব্লকটি সমান বা 0 হবে।

279
00:17:48,980 --> 00:17:53,620
অনুশীলনের দ্বিতীয় অংশ হিসাবে, আসুন আপনাকে গ্রহণকারীর ভূমিকা পালন করতে দিন।

280
00:17:53,620 --> 00:17:57,580
অবশ্যই, এর অর্থ এই যে আপনি ইতিমধ্যেই জানেন না এই বার্তাটি কী, হয়ত আপনার

281
00:17:57,580 --> 00:18:00,180
মধ্যে কেউ কেউ এটি মুখস্থ করেছেন, তবে ধরে নেওয়া যাক যে আপনি তা করেননি।

282
00:18:00,180 --> 00:18:05,820
আমি যা করতে যাচ্ছি তা হল 0, 1, বা 2টি সেই ব্লকের বিটগুলিকে

283
00:18:05,820 --> 00:18:08,340
পরিবর্তন করুন এবং তারপরে আপনাকে জিজ্ঞাসা করতে চাই যে আমি কী করেছি।

284
00:18:08,340 --> 00:18:13,460
তাই আবার, বিরতি এবং এটি কাজ করার চেষ্টা করুন.

285
00:18:13,460 --> 00:18:23,960
ঠিক আছে, তাই আপনি রিসিভার হিসাবে এখন প্রথম প্যারিটি গ্রুপটি পরীক্ষা করুন এবং আপনি

286
00:18:23,960 --> 00:18:29,820
দেখতে পাচ্ছেন যে এটি সমান, তাই বিদ্যমান যেকোন ত্রুটি একটি জোড় কলামে থাকতে হবে।

287
00:18:29,820 --> 00:18:34,620
পরবর্তী চেকটি আমাদের একটি বিজোড় সংখ্যা দেয়, আমাদের উভয়কেই বলে যে

288
00:18:34,620 --> 00:18:38,760
অন্তত একটি ত্রুটি রয়েছে এবং আমাদের এই নির্দিষ্ট কলামে সংকুচিত করে।

289
00:18:38,760 --> 00:18:42,900
তৃতীয় চেক হল জোড়, সম্ভাবনাগুলিকে আরও কমিয়ে দেওয়া।

290
00:18:42,900 --> 00:18:46,780
এবং শেষ প্যারিটি চেকটি বিজোড়, আমাদের বলছে নীচে কোথাও একটি ত্রুটি আছে,

291
00:18:46,780 --> 00:18:51,700
যা এখন পর্যন্ত আমরা দেখতে পাচ্ছি পজিশন নম্বর 10 এ থাকতে হবে।

292
00:18:51,700 --> 00:18:56,140
আরও কি, পুরো ব্লকের সমতা অদ্ভুত, আমাদের আত্মবিশ্বাস

293
00:18:56,140 --> 00:18:58,220
দেয় যে একটি ফ্লিপ ছিল দুটি নয়।

294
00:18:58,220 --> 00:19:01,600
যদি এটি তিন বা তার বেশি হয়, তাহলে সমস্ত বাজি বন্ধ হয়ে যাবে।

295
00:19:01,600 --> 00:19:06,520
সেই বিট নম্বর 10 সংশোধন করার পরে, সংশোধনের জন্য ব্যবহার করা হয়নি এমন 11টি

296
00:19:06,520 --> 00:19:11,620
বিটগুলিকে টেনে বের করা আমাদের মূল বার্তাটির প্রাসঙ্গিক অংশ দেয়, যেটি যদি আপনি রিওয়াইন্ড

297
00:19:11,620 --> 00:19:16,160
করেন এবং তুলনা করেন তবে আমরা যে উদাহরণ দিয়ে শুরু করেছি তা ঠিক।

298
00:19:16,160 --> 00:19:19,260
এবং এখন যেহেতু আপনি জানেন কিভাবে এই সব হাত দিয়ে করতে হয়, আমি আপনাকে দেখাতে চাই

299
00:19:19,260 --> 00:19:23,940
কিভাবে আপনি পাইথন কোডের একটি লাইন দিয়ে এই সমস্ত যুক্তির মূল অংশটি সম্পাদন করতে পারেন।

300
00:19:23,940 --> 00:19:28,400
আপনি দেখতে পাচ্ছেন, আমি আপনাকে এখনও যা বলিনি তা হল এই অ্যালগরিদমটি আসলে

301
00:19:28,400 --> 00:19:32,380
কতটা মার্জিত, একটি ত্রুটির অবস্থান নির্দেশ করার জন্য একটি মেশিন পাওয়া কতটা

302
00:19:32,380 --> 00:19:37,680
সহজ, কীভাবে এটিকে পদ্ধতিগতভাবে স্কেল করা যায় এবং কীভাবে আমরা সমস্ত কিছু ফ্রেম

303
00:19:37,680 --> 00:19:39,580
করতে পারি এটি একাধিক পৃথক প্যারিটি চেকের পরিবর্তে একটি একক অপারেশন হিসাবে।

304
00:19:39,580 --> 00:19:41,680
আমি কি বলতে চাইছি তা দেখতে, পার্ট 2 এ আমার সাথে যোগ দিন।

