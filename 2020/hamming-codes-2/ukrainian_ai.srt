1
00:00:00,000 --> 00:00:08,620
Чи замислювалися ви коли-небудь про те, як можна подряпати компакт-диск або

2
00:00:08,620 --> 00:00:10,900
DVD-диск і все одно відтворювати те, що на ньому зберігається?

3
00:00:10,900 --> 00:00:15,280
Подряпина справді впливає на 1 і 0 на диску, тому він зчитує

4
00:00:15,280 --> 00:00:20,500
дані, відмінні від того, що зберігається, але якщо він справді не

5
00:00:20,500 --> 00:00:26,540
подряпаний, біти, які він зчитує, декодуються в той самий файл, який

6
00:00:26,540 --> 00:00:28,400
був закодований на ньому, побітова копія, незважаючи на всі ці помилки.

7
00:00:28,400 --> 00:00:32,800
Існує ціла купа математичної кмітливості, яка дозволяє нам зберігати дані, і, що

8
00:00:32,800 --> 00:00:36,840
не менш важливо, передавати дані, у спосіб, який є стійким до помилок.

9
00:00:36,840 --> 00:00:41,480
Ну, гаразд, насправді не потрібно так багато

10
00:00:41,480 --> 00:00:42,480
кмітливості, щоб придумати спосіб це зробити.

11
00:00:42,480 --> 00:00:47,660
Будь-який файл, чи то відео, чи звук, чи текст, якийсь

12
00:00:47,660 --> 00:00:50,960
код, зображення тощо, зрештою, є певною послідовністю одиниць і нулів.

13
00:00:50,960 --> 00:00:55,340
І простою стратегією виправлення будь-якого біта, який перевертається,

14
00:00:55,340 --> 00:00:57,780
було б зберігати три копії кожного біта.

15
00:00:57,780 --> 00:01:02,240
Тоді машина, яка читає цей файл, може порівняти ці три копії

16
00:01:02,240 --> 00:01:07,440
та завжди брати найкращі 2 із 3, якщо є розбіжності.

17
00:01:07,440 --> 00:01:11,560
Але це означає використання двох третин вашого простору для резервування.

18
00:01:11,560 --> 00:01:15,360
І навіть тоді, незважаючи на весь цей вільний простір, немає надійної гарантії

19
00:01:15,360 --> 00:01:18,120
щодо того, що станеться, якщо буде перевернуто більше ніж один біт.

20
00:01:18,120 --> 00:01:21,960
Набагато цікавіше питання полягає в тому, як зробити так,

21
00:01:21,960 --> 00:01:24,740
щоб можна було виправляти помилки, звільняючи якомога менше місця.

22
00:01:24,740 --> 00:01:28,500
Наприклад, використовуючи метод, який ви дізнаєтеся про це відео, ви можете зберігати свої дані у

23
00:01:28,500 --> 00:01:35,840
256-бітних блоках, де кожен блок використовує 9 біт, 9! щоб діяти як своєрідна надлишковість, а

24
00:01:35,840 --> 00:01:41,000
інші 247 бітів можуть вільно переносити будь-які значущі повідомлення або дані, які ви хочете.

25
00:01:41,000 --> 00:01:44,740
І все одно буде так, що якщо будь-який біт тут буде перевернуто, просто

26
00:01:44,740 --> 00:01:49,640
подивившись на цей блок і нічого більше, машина зможе визначити, що була

27
00:01:49,640 --> 00:01:53,120
помилка, і точно, де вона була, щоб знати, як її виправити .

28
00:01:53,140 --> 00:01:55,540
І, чесно кажучи, це виглядає як магія.

29
00:01:55,540 --> 00:01:59,400
І для цієї конкретної схеми, якщо два біти будуть перевернуті, машина принаймні зможе

30
00:01:59,400 --> 00:02:03,180
виявити, що було дві помилки, хоча вона не знатиме, як їх виправити.

31
00:02:03,180 --> 00:02:08,140
Трохи пізніше ми поговоримо про те, як це масштабується для блоків різних розмірів.

32
00:02:08,140 --> 00:02:12,620
Методи, які дозволяють виправляти такі помилки, відомі,

33
00:02:12,620 --> 00:02:13,880
досить розумно, як коди виправлення помилок.

34
00:02:13,880 --> 00:02:18,220
Протягом більшої частини минулого століття ця сфера була справді багатим джерелом

35
00:02:18,220 --> 00:02:23,000
напрочуд глибокої математики, яка вбудовується в пристрої, якими ми користуємося щодня.

36
00:02:23,000 --> 00:02:27,740
Мета тут — дати вам дуже повне розуміння

37
00:02:27,740 --> 00:02:29,660
одного з найперших прикладів, відомого як код Хеммінга.

38
00:02:29,660 --> 00:02:32,620
І, до речі, те, як я думаю про структуру цього відео, полягає не

39
00:02:32,620 --> 00:02:37,060
в тому, щоб пояснити це якомога пряміше, а більше в тому, щоб

40
00:02:37,060 --> 00:02:40,220
спонукати вас придумати це для себе, з легкими вказівками тут і там.

41
00:02:40,220 --> 00:02:44,100
Тож коли ви відчуєте, що в якийсь момент бачите, куди це йде, візьміть цей

42
00:02:44,100 --> 00:02:47,180
момент, щоб зупинитися, активно передбачте, якою буде схема, перш ніж я скажу вам.

43
00:02:47,180 --> 00:02:51,500
Крім того, якщо ви хочете, щоб ваше розуміння перейшло до апаратного рівня,

44
00:02:51,500 --> 00:02:55,160
Бен Ітер створив відео в поєднанні з цим відео, яке показує вам,

45
00:02:55,160 --> 00:02:59,520
як насправді впроваджувати коди Хеммінга на макетних платах, що надзвичайно задовольняє.

46
00:02:59,520 --> 00:03:03,120
Ви повинні знати, що коди Хеммінга не так широко використовуються, як більш сучасні коди, як-от

47
00:03:03,120 --> 00:03:08,040
алгоритм Ріда-Соломона, але є певна магія в контрасті між тим, наскільки нездійсненним це завдання здається

48
00:03:08,040 --> 00:03:14,240
на початку, і тим, наскільки цілком розумним воно здається одного разу ви дізнаєтесь про Хеммінга.

49
00:03:14,240 --> 00:03:19,080
Основний принцип виправлення помилок полягає в тому, що у величезному просторі

50
00:03:19,300 --> 00:03:22,860
всіх можливих повідомлень лише деякі підмножини будуть вважатися дійсними повідомленнями.

51
00:03:22,860 --> 00:03:29,100
Як аналогію, подумайте про правильно написані слова проти неправильно написаних слів.

52
00:03:29,100 --> 00:03:33,340
Щоразу, коли дійсне повідомлення змінюється, одержувач несе відповідальність за виправлення того, що

53
00:03:33,340 --> 00:03:38,380
він бачить, до найближчого дійсного сусіда, як це можна зробити з помилкою.

54
00:03:38,380 --> 00:03:43,100
Проте розробка конкретного алгоритму для ефективної

55
00:03:43,100 --> 00:03:47,160
класифікації подібних повідомлень вимагає певної кмітливості.

56
00:03:47,160 --> 00:03:52,060
Історія починається в 1940-х роках, коли молодий Річард Хеммінг працював у

57
00:03:52,060 --> 00:03:55,900
Bell Labs, і частина його роботи включала використання дуже великого дорогого

58
00:03:55,900 --> 00:03:57,420
комп’ютера з перфокартами, до якого він мав лише обмежений доступ.

59
00:03:57,420 --> 00:04:01,200
І програми, які він постійно вставляв у нього, постійно виходили

60
00:04:01,200 --> 00:04:03,140
з ладу, тому що час від часу щось неправильно читалося.

61
00:04:03,140 --> 00:04:07,140
Розчарування, будучи горнилом винахідництва, йому так набридло, що

62
00:04:07,140 --> 00:04:09,280
він винайшов перший у світі код виправлення помилок.

63
00:04:09,280 --> 00:04:13,020
Є багато різних способів створення кодів Хеммінга, але для початку

64
00:04:13,020 --> 00:04:16,620
ми розглянемо це так, як сам Хеммінг думав про них.

65
00:04:16,620 --> 00:04:21,400
Давайте використаємо простий, але не дуже простий приклад, блок із 16 біт.

66
00:04:21,400 --> 00:04:25,700
Ми пронумеруємо позиції цих бітів від 0 до 15.

67
00:04:25,700 --> 00:04:30,520
Фактичні дані, які ми хочемо зберігати, складатимуть лише 12 із цих

68
00:04:30,520 --> 00:04:33,920
бітів, тоді як 4 позиції зарезервовано як свого роду надлишковість.

69
00:04:33,920 --> 00:04:38,120
Слово надлишковий тут не просто означає копіювання, зрештою, ці 4

70
00:04:38,120 --> 00:04:40,200
біти не дають нам достатньо місця для сліпого копіювання даних.

71
00:04:40,200 --> 00:04:44,880
Натомість вони повинні бути набагато більш тонкими та розумними як

72
00:04:44,880 --> 00:04:48,740
резервування, не додаючи жодної нової інформації, але додаючи стійкості.

73
00:04:48,740 --> 00:04:52,620
Ви можете очікувати, що ці 4 спеціальні біти будуть гарно зібрані разом, можливо,

74
00:04:52,620 --> 00:04:56,400
в кінці або щось подібне, але, як ви побачите, розміщення їх у

75
00:04:56,400 --> 00:05:00,320
позиціях, які є степенями 2, дозволяє отримати щось справді елегантне в кінці.

76
00:05:00,320 --> 00:05:05,420
Це також може дати вам невелику підказку про те, як це масштабується для більших блоків.

77
00:05:05,420 --> 00:05:09,220
Крім того, технічно це лише 11 біт даних, ви побачите, що є легкий нюанс

78
00:05:09,220 --> 00:05:14,260
у тому, що відбувається в позиції 0, але не хвилюйтеся про це зараз.

79
00:05:14,280 --> 00:05:18,640
Як і в будь-якому іншому алгоритмі виправлення помилок, у цьому будуть задіяні

80
00:05:18,640 --> 00:05:23,200
два гравці: відправник, який відповідає за встановлення цих 4 спеціальних бітів,

81
00:05:23,200 --> 00:05:26,360
і одержувач, який відповідає за виконання певної перевірки та виправлення помилок.

82
00:05:26,360 --> 00:05:30,040
Звичайно, слова «відправник» і «одержувач» справді стосуються машин або програмного

83
00:05:30,040 --> 00:05:34,040
забезпечення, яке виконує всі перевірки, і ідея повідомлення має на

84
00:05:34,040 --> 00:05:35,480
увазі дуже широке значення, включаючи такі речі, як сховище.

85
00:05:35,480 --> 00:05:39,320
Зрештою, зберігання даних — це те саме, що відправляти повідомлення лише

86
00:05:39,320 --> 00:05:42,640
з минулого в майбутнє, а не з одного місця в інше.

87
00:05:42,640 --> 00:05:46,700
Отже, це налаштування, але перш ніж ми зможемо зануритися в це,

88
00:05:46,700 --> 00:05:51,080
нам потрібно поговорити про пов’язану ідею, яка була свіжою в голові

89
00:05:51,080 --> 00:05:55,520
Геммінга під час його відкриття, метод, який дозволяє виявляти будь-які однобітові

90
00:05:55,520 --> 00:05:57,300
помилки, але не виправляти їх, відомий у бізнесі як перевірка паритету.

91
00:05:57,300 --> 00:06:01,300
Для перевірки парності ми відокремлюємо лише один біт, за налаштування

92
00:06:01,300 --> 00:06:04,940
якого відповідає відправник, а решта можуть вільно передавати повідомлення.

93
00:06:04,940 --> 00:06:10,380
Єдина робота цього спеціального біта полягає в тому, щоб

94
00:06:10,380 --> 00:06:12,100
переконатися, що загальна кількість одиниць у повідомленні є парною.

95
00:06:12,100 --> 00:06:16,920
Так, наприклад, зараз загальна кількість одиниць дорівнює 7, це дивно, тому

96
00:06:16,920 --> 00:06:20,960
відправнику потрібно перевернути цей спеціальний біт на 1, роблячи кількість парних.

97
00:06:20,960 --> 00:06:25,320
Але якби блок уже почався з парної кількості 1,

98
00:06:25,320 --> 00:06:27,480
тоді цей спеціальний біт залишився б рівним 0.

99
00:06:27,480 --> 00:06:31,640
Це досить просто, оманливо просто, але це неймовірно елегантний спосіб дистилювати ідею

100
00:06:31,640 --> 00:06:37,760
зміни будь-де в повідомленні, щоб її відобразити в одному біті інформації.

101
00:06:37,760 --> 00:06:43,680
Зверніть увагу, якщо будь-який біт цього повідомлення перевертається з 0 на 1 або

102
00:06:43,680 --> 00:06:48,140
з 1 на 0, це змінює загальну кількість одиниць з парної на непарну.

103
00:06:48,140 --> 00:06:52,000
Отже, якщо ви одержувач, ви дивитеся на це повідомлення та бачите

104
00:06:52,000 --> 00:06:56,580
непарну кількість одиниць, ви можете точно знати, що сталася якась

105
00:06:56,580 --> 00:06:58,700
помилка, навіть якщо ви можете не знати, де вона була.

106
00:06:58,700 --> 00:07:02,820
На жаргоні парність у групі

107
00:07:02,820 --> 00:07:04,940
бітів називається її парністю.

108
00:07:04,940 --> 00:07:09,140
Ви також можете використовувати числа та сказати, що парність дорівнює 0 або

109
00:07:09,140 --> 00:07:11,320
1, що зазвичай стає більш корисним, коли ви починаєте обчислювати цю ідею.

110
00:07:11,320 --> 00:07:15,200
І цей спеціальний біт, який відправник використовує

111
00:07:15,200 --> 00:07:18,020
для контролю парності, називається бітом парності.

112
00:07:18,020 --> 00:07:22,460
І насправді, ми маємо чітко уточнити: якщо отримувач бачить непарну парність, це не обов’язково

113
00:07:22,460 --> 00:07:26,920
означає, що була лише одна помилка, могло бути 3 помилки, або 5, або

114
00:07:26,920 --> 00:07:29,560
будь-яке інше непарне число, але вони можуть знати напевно що це не 0.

115
00:07:29,560 --> 00:07:34,880
З іншого боку, якби було 2 помилки або будь-яка парна кількість помилок, кінцева

116
00:07:34,880 --> 00:07:39,560
кількість 1с все одно була б парною, тому одержувач не може бути

117
00:07:39,560 --> 00:07:43,360
повністю впевненим, що парна кількість обов’язково означає, що повідомлення без помилок. .

118
00:07:43,360 --> 00:07:47,860
Ви можете поскаржитися на те, що повідомлення, яке спотворюється лише

119
00:07:47,860 --> 00:07:49,760
двома бітами, є досить слабким, і ви будете абсолютно праві.

120
00:07:49,760 --> 00:07:54,480
Однак пам’ятайте, що не існує методу виявлення або виправлення помилок, який міг би дати вам

121
00:07:54,480 --> 00:07:59,720
100% впевненість у тому, що отримане вами повідомлення – це те, що мав намір відправник.

122
00:07:59,720 --> 00:08:03,760
Зрештою, достатня кількість випадкового шуму завжди може змінити

123
00:08:03,760 --> 00:08:05,920
одне дійсне повідомлення на інше просто випадково.

124
00:08:05,920 --> 00:08:10,520
Натомість мета полягає в тому, щоб створити схему, яка є надійною до

125
00:08:10,520 --> 00:08:16,480
певної максимальної кількості помилок, або, можливо, зменшити ймовірність хибного спрацьовування, як це.

126
00:08:16,480 --> 00:08:20,940
Перевірки на парність самі по собі є досить слабкими, але,

127
00:08:20,940 --> 00:08:25,640
зводячи ідею зміни в повному повідомленні до одного біта, вони

128
00:08:25,640 --> 00:08:28,000
дають нам потужний будівельний блок для більш складних схем.

129
00:08:28,000 --> 00:08:32,880
Наприклад, коли Хеммінг шукав спосіб визначити, де сталася помилка, а не просто те, що

130
00:08:32,880 --> 00:08:37,160
вона сталася, його ключове розуміння полягало в тому, що якщо ви застосовуєте деякі

131
00:08:37,160 --> 00:08:42,040
перевірки парності не до всього повідомлення, а до певних ретельно відібраних підмножин, ви

132
00:08:42,040 --> 00:08:46,840
можете запитати більш витончену серію запитань, які визначають місце будь-якої окремої бітової помилки.

133
00:08:46,840 --> 00:08:51,280
Загальне відчуття трохи схоже на гру з 20 запитань, задаючи

134
00:08:51,280 --> 00:08:54,300
запити «так» або «ні», які розрізають простір можливостей навпіл.

135
00:08:54,300 --> 00:08:58,840
Наприклад, скажімо, ми виконуємо перевірку парності лише для

136
00:08:58,840 --> 00:08:59,840
цих 8 бітів, усіх позицій з непарними номерами.

137
00:09:00,400 --> 00:09:04,560
Потім, якщо виявлено помилку, це дає одержувачу трохи більше інформації про те,

138
00:09:04,560 --> 00:09:09,160
де саме є помилка, а саме, що він знаходиться в непарній позиції.

139
00:09:09,160 --> 00:09:14,360
Якщо серед цих 8 бітів не виявлено жодної помилки, це означає,

140
00:09:14,360 --> 00:09:17,240
що помилки немає взагалі, або вона знаходиться десь на парних позиціях.

141
00:09:17,240 --> 00:09:21,560
Ви можете подумати, що обмеження перевірки парності половиною бітів робить її

142
00:09:21,560 --> 00:09:25,460
менш ефективною, але коли це робиться в поєднанні з іншими добре

143
00:09:25,460 --> 00:09:29,720
підібраними перевірками, це суперечить інтуїції дає нам щось набагато потужніше.

144
00:09:29,720 --> 00:09:34,440
Пам’ятайте, що для того, щоб фактично налаштувати цю перевірку парності, потрібно

145
00:09:34,440 --> 00:09:37,600
виділити якийсь спеціальний біт, який контролює парність цієї повної групи.

146
00:09:37,600 --> 00:09:39,920
Давайте просто виберемо позицію 1.

147
00:09:39,920 --> 00:09:43,960
У наведеному прикладі парність цих 8 бітів наразі непарна, тому відправник

148
00:09:43,960 --> 00:09:48,220
відповідає за перемикання цього біта парності, і тепер він парний.

149
00:09:48,220 --> 00:09:51,040
Це лише 1 із 4 перевірок парності, які ми зробимо.

150
00:09:51,040 --> 00:09:55,560
Друга перевірка знаходиться серед 8 бітів у правій половині

151
00:09:55,560 --> 00:09:56,880
сітки, принаймні так, як ми її тут намалювали.

152
00:09:56,880 --> 00:10:02,520
Цього разу ми можемо використати позицію 2 як біт парності, тому ці 8 бітів уже

153
00:10:02,520 --> 00:10:07,160
мають рівну парність, і відправник може почуватися добре, залишивши цей біт номер 2 незмінним.

154
00:10:07,160 --> 00:10:11,040
Тоді на іншому кінці, якщо приймач перевірить парність цієї групи і виявить, що

155
00:10:11,040 --> 00:10:15,960
вона непарна, він знатиме, що помилка десь серед цих 8 бітів праворуч.

156
00:10:15,960 --> 00:10:21,260
Інакше це означає, що або помилки немає, або помилка десь на лівій половині.

157
00:10:21,260 --> 00:10:24,040
Або я припускаю, що могло бути дві помилки, але зараз ми

158
00:10:24,040 --> 00:10:27,080
будемо припускати, що у всьому блоці є щонайбільше одна помилка.

159
00:10:27,080 --> 00:10:29,160
Речі повністю ламаються для більшого.

160
00:10:29,160 --> 00:10:32,920
Тут, перш ніж ми подивимося на наступні дві перевірки, знайдіть хвилинку, щоб подумати

161
00:10:32,920 --> 00:10:35,880
про те, що ці перші дві дозволяють нам робити, якщо розглядати їх разом.

162
00:10:35,880 --> 00:10:40,240
Припустімо, ви виявили помилку серед непарних стовпців і серед правої половини.

163
00:10:40,240 --> 00:10:43,940
Це обов’язково означає, що помилка знаходиться десь в останньому стовпці.

164
00:10:43,940 --> 00:10:48,280
Якщо в непарному стовпці не було помилки, але була одна в

165
00:10:48,280 --> 00:10:50,520
правій половині, це означає, що вона знаходиться в передостанньому стовпці.

166
00:10:50,520 --> 00:10:54,640
Так само, якщо є помилка в непарних стовпцях, але не в

167
00:10:54,640 --> 00:10:56,560
правій половині, ви знаєте, що це десь у другому стовпці.

168
00:10:56,560 --> 00:11:00,560
І якщо жодна з цих двох перевірок парності нічого не виявляє, це

169
00:11:00,560 --> 00:11:03,760
означає, що єдине місце, де може бути помилка, це крайній лівий стовпець.

170
00:11:03,760 --> 00:11:06,480
Але це також може означати, що помилки взагалі немає.

171
00:11:06,480 --> 00:11:10,800
Це досить складний спосіб сказати, що дві

172
00:11:10,800 --> 00:11:11,800
перевірки парності дозволяють нам закріпити стовпець.

173
00:11:11,800 --> 00:11:14,000
Звідси ви, напевно, можете здогадатися, що далі.

174
00:11:14,000 --> 00:11:16,240
Ми робимо в основному те саме, але для рядків.

175
00:11:16,240 --> 00:11:21,040
У непарних рядках буде перевірено парність із використанням позиції 4 як біта парності.

176
00:11:21,040 --> 00:11:25,480
Отже, у цьому прикладі ця група вже має парний

177
00:11:25,480 --> 00:11:26,480
паритет, тому біт 4 буде встановлено на 0.

178
00:11:26,480 --> 00:11:31,280
І, нарешті, є перевірка парності в нижніх двох

179
00:11:31,280 --> 00:11:32,280
рядках, використовуючи позицію 8 як біт парності.

180
00:11:32,280 --> 00:11:35,840
У цьому випадку схоже, що відправник повинен увімкнути

181
00:11:35,840 --> 00:11:37,840
цей біт 8, щоб надати групі рівний паритет.

182
00:11:37,840 --> 00:11:41,360
Подібно до того, як перші дві перевірки дозволяють

183
00:11:41,360 --> 00:11:43,000
нам закріпити стовпець, наступні дві дозволяють закріпити рядок.

184
00:11:43,000 --> 00:11:48,400
Як приклад, уявіть, що під час передачі виникла помилка, скажімо, у позиції 3.

185
00:11:48,400 --> 00:11:52,620
Ну, це впливає на першу групу парності, а також на другу групу

186
00:11:52,620 --> 00:11:56,340
парності, тому приймач знає, що десь у цьому правому стовпці є помилка.

187
00:11:56,340 --> 00:12:01,380
Але це не впливає на третю групу, і не впливає на четверту групу.

188
00:12:01,380 --> 00:12:05,460
І це дозволяє приймачу точно визначити помилку до першого рядка,

189
00:12:05,460 --> 00:12:08,660
що обов’язково означає позицію 3, щоб вони могли виправити помилку.

190
00:12:08,660 --> 00:12:12,640
Можливо, вам сподобається знайти час, щоб переконатися, що відповіді на ці чотири запитання

191
00:12:12,680 --> 00:12:17,320
справді завжди дозволять вам визначити конкретне місце, де б воно не було.

192
00:12:17,320 --> 00:12:22,640
Насправді, кмітливі серед вас можуть навіть помітити

193
00:12:22,640 --> 00:12:23,640
зв’язок між цими запитаннями та двійковим підрахунком.

194
00:12:23,640 --> 00:12:27,840
І якщо так, дозвольте мені ще раз підкреслити, зробити паузу,

195
00:12:27,840 --> 00:12:30,880
спробуйте самі намалювати зв’язок, перш ніж я його зіпсую.

196
00:12:30,880 --> 00:12:35,560
Якщо вам цікаво, що станеться, якщо постраждає

197
00:12:35,560 --> 00:12:36,560
сам біт парності, ви можете просто спробувати.

198
00:12:36,560 --> 00:12:40,720
Знайдіть хвилинку, щоб подумати про те, як будь-яка помилка серед цих чотирьох спеціальних бітів буде

199
00:12:40,720 --> 00:12:47,440
відстежуватися так само, як і будь-яка інша, за допомогою тієї самої групи з чотирьох запитань.

200
00:12:47,440 --> 00:12:50,500
Це не має особливого значення, оскільки врешті-решт ми хочемо

201
00:12:50,500 --> 00:12:53,640
захистити біти повідомлень, біти виправлення помилок просто йдуть разом.

202
00:12:53,640 --> 00:12:57,120
Але захист цих бітів також є те, що

203
00:12:57,120 --> 00:12:59,260
природно випадає зі схеми як побічний продукт.

204
00:12:59,260 --> 00:13:02,380
Вам також може бути цікаво передбачити, як це масштабується.

205
00:13:02,380 --> 00:13:08,040
Наприклад, якщо ми використовували блок розміром 256 біт, щоб визначити місце розташування, вам знадобиться

206
00:13:08,040 --> 00:13:15,680
лише вісім запитань «так» або «ні», щоб виконати двійковий пошук до певної точки.

207
00:13:15,680 --> 00:13:19,680
І пам’ятайте, що кожне запитання вимагає відмови лише

208
00:13:19,680 --> 00:13:23,340
від одного біта, щоб встановити відповідну перевірку парності.

209
00:13:23,340 --> 00:13:26,960
Деякі з вас, можливо, вже бачать це, але ми поговоримо пізніше

210
00:13:26,960 --> 00:13:29,960
про систематичний спосіб знайти ці запитання всього за хвилину або дві.

211
00:13:29,960 --> 00:13:33,440
Сподіваюся, цього ескізу достатньо, щоб оцінити

212
00:13:33,440 --> 00:13:34,440
ефективність того, що ми тут розробляємо.

213
00:13:34,440 --> 00:13:38,440
Перше, за винятком тих восьми виділених бітів парності, може бути будь-яким,

214
00:13:38,440 --> 00:13:41,720
що ви забажаєте, з будь-яким повідомленням або даними, які ви хочете.

215
00:13:41,720 --> 00:13:45,480
8 бітів зайві в тому сенсі, що вони повністю визначаються рештою

216
00:13:45,480 --> 00:13:53,640
повідомлення, але це набагато розумніше, ніж просто копіювати повідомлення в цілому.

217
00:13:53,640 --> 00:13:58,000
І все-таки, за так мало відмови, ви зможете

218
00:13:58,000 --> 00:13:59,000
визначити та виправити будь-яку окрему бітову помилку.

219
00:13:59,000 --> 00:14:00,400
Ну, майже.

220
00:14:00,400 --> 00:14:05,920
Гаразд, одна проблема тут полягає в тому, що якщо жодна з чотирьох

221
00:14:05,920 --> 00:14:10,240
перевірок парності не виявляє помилку, тобто всі спеціально вибрані підмножини з 8

222
00:14:10,240 --> 00:14:15,520
біт мають парні паритети, як і хотів відправник, то це означає, що

223
00:14:15,520 --> 00:14:17,760
помилки взагалі не було , або це звужує нас до позиції 0.

224
00:14:17,760 --> 00:14:23,040
Розумієте, з чотирма запитаннями «так» або «ні» ми маємо 16 можливих результатів для

225
00:14:23,040 --> 00:14:28,000
перевірки парності, і спочатку це ідеально підходить для визначення 1 із 16 позицій

226
00:14:28,000 --> 00:14:33,000
у блоці, але вам також потрібно повідомити 17-й результат, відсутність помилки хвороба.

227
00:14:33,000 --> 00:14:37,860
Рішення тут насправді досить просте, просто забудьте про нульовий біт.

228
00:14:37,860 --> 00:14:41,920
Отже, коли ми виконуємо наші чотири перевірки на парність і бачимо,

229
00:14:41,920 --> 00:14:44,320
що всі вони парні, це однозначно означає, що помилки немає.

230
00:14:44,320 --> 00:14:49,240
Це означає, що замість роботи з 16-бітним блоком ми працюємо з 15-бітним блоком,

231
00:14:49,240 --> 00:14:54,040
де 11 бітів вільні для передачі повідомлення, а 4 з них є резервними.

232
00:14:54,080 --> 00:14:58,400
І разом з цим тепер ми маємо те, що

233
00:14:58,400 --> 00:14:59,400
люди в бізнесі називали б кодом Хеммінга 15-11.

234
00:14:59,400 --> 00:15:03,920
Тим не менш, добре мати розмір блоку, який дорівнює чистій степені 2, і є розумний спосіб,

235
00:15:03,920 --> 00:15:08,880
яким ми можемо зберегти цей 0-й біт і змусити його виконувати трохи більше роботи за нас.

236
00:15:08,880 --> 00:15:13,600
Якщо ми використовуємо його як біт парності для всього блоку, це дозволяє

237
00:15:13,600 --> 00:15:16,320
нам фактично виявляти 2-бітові помилки, навіть якщо ми не можемо виправити їх.

238
00:15:16,320 --> 00:15:17,440
Ось як це працює.

239
00:15:17,440 --> 00:15:21,740
Після встановлення цих чотирьох спеціальних бітів виправлення помилок ми встановлюємо 0-й,

240
00:15:21,740 --> 00:15:25,540
щоб парність повного блоку була парною, як і звичайна перевірка парності.

241
00:15:25,540 --> 00:15:29,780
Тепер, якщо є помилка з одним бітом, то парність повного блоку перемикається на

242
00:15:29,780 --> 00:15:33,940
непарність, але ми все одно вловимо це завдяки чотирьом перевіркам виправлення помилок.

243
00:15:33,940 --> 00:15:38,100
Однак, якщо є дві помилки, тоді загальний паритет повернеться до

244
00:15:38,100 --> 00:15:42,660
рівномірного, але приймач все одно побачить, що сталася принаймні якась

245
00:15:42,660 --> 00:15:45,820
помилка через те, що відбувається з цими чотирма перевірками парності.

246
00:15:45,820 --> 00:15:49,780
Отже, якщо вони помічають рівну парність загалом, але щось відмінне від нуля

247
00:15:49,820 --> 00:15:52,980
відбувається з іншими перевірками, це говорить їм про принаймні дві помилки.

248
00:15:52,980 --> 00:15:54,420
Хіба це не розумно?

249
00:15:54,420 --> 00:15:58,500
Навіть незважаючи на те, що ми не можемо виправити ці 2-бітові помилки, просто

250
00:15:58,500 --> 00:16:02,340
повернувши цей маленький набридливий 0-й біт до роботи, це дозволить нам їх виявити.

251
00:16:02,340 --> 00:16:06,540
Це досить стандартний код, він відомий як розширений код Хеммінга.

252
00:16:06,540 --> 00:16:10,860
Технічно кажучи, тепер у вас є повний опис того,

253
00:16:10,860 --> 00:16:13,580
що робить код Хеммінга, принаймні для прикладу 16-бітного блоку.

254
00:16:13,580 --> 00:16:17,300
Але я думаю, що вам буде приємніше перевірити ваше розуміння та закріпити все

255
00:16:17,300 --> 00:16:21,980
до цього моменту, виконавши один повний приклад від початку до кінця самостійно.

256
00:16:21,980 --> 00:16:25,100
Але я пройду це разом з вами, щоб ви могли перевірити самі.

257
00:16:25,100 --> 00:16:29,180
Щоб налаштувати повідомлення, незалежно від того, чи це дослівне повідомлення, яке

258
00:16:29,180 --> 00:16:34,100
ви перекладаєте через простір, чи якісь дані, які ви хочете зберегти

259
00:16:34,100 --> 00:16:35,700
протягом тривалого часу, перший крок — розділити його на 11-бітні фрагменти.

260
00:16:35,700 --> 00:16:40,340
Кожна частина буде упакована в стійкий до помилок 16-бітний блок.

261
00:16:40,340 --> 00:16:43,740
Отже, давайте візьмемо це як приклад і розберемося.

262
00:16:43,740 --> 00:16:45,340
Давай, справді зроби це!

263
00:16:45,380 --> 00:16:47,380
Давайте зупинимося і спробуємо скласти цей блок.

264
00:16:52,980 --> 00:16:53,980
Гаразд, ти готовий?

265
00:16:53,980 --> 00:16:58,500
Пам’ятайте, що позиція 0 разом з іншими степенями числа 2 зарезервована для виправлення помилок,

266
00:16:58,500 --> 00:17:05,700
тому ви починаєте з розміщення бітів повідомлення в усіх місцях, що залишилися, по порядку.

267
00:17:05,700 --> 00:17:09,700
Вам потрібно, щоб ця група мала рівний паритет, який вона вже має, тому

268
00:17:09,700 --> 00:17:13,140
ви повинні були встановити цей біт парності в позиції 1 на 0.

269
00:17:13,140 --> 00:17:17,700
Наступна група починається з непарної парності, тому вам

270
00:17:17,700 --> 00:17:19,260
слід було встановити її біт парності на 1.

271
00:17:19,260 --> 00:17:23,740
Група після цього починається з непарної парності, тому ви

272
00:17:23,740 --> 00:17:24,740
знову повинні встановити її біт парності на 1.

273
00:17:24,740 --> 00:17:29,500
І остання група також має непарну парність, тобто ми

274
00:17:29,500 --> 00:17:31,500
встановили, що біт у позиції 8 дорівнює 1.

275
00:17:31,500 --> 00:17:36,460
І потім, як останній крок, повний блок тепер має парну парність, тобто

276
00:17:36,460 --> 00:17:41,500
ви можете встановити цей біт номер 0, головний біт парності, рівним 0.

277
00:17:41,500 --> 00:17:45,660
Отже, коли цей блок відправляється, парність чотирьох спеціальних підмножин

278
00:17:45,660 --> 00:17:48,980
і блоку в цілому буде парною, або 0.

279
00:17:48,980 --> 00:17:53,620
У другій частині вправи давайте ви зіграєте роль приймача.

280
00:17:53,620 --> 00:17:57,580
Звичайно, це означатиме, що ви ще не знаєте, що це за

281
00:17:57,580 --> 00:18:00,180
повідомлення, можливо, дехто з вас запам’ятав його, але припустімо, що ні.

282
00:18:00,180 --> 00:18:05,820
Я збираюся змінити 0, 1 або 2 біта в цьому

283
00:18:05,820 --> 00:18:08,340
блоці, а потім попрошу вас зрозуміти, що я зробив.

284
00:18:08,340 --> 00:18:13,460
Тож знову зробіть паузу та спробуйте розібратися.

285
00:18:13,460 --> 00:18:23,960
Отже, ви, як отримувач, тепер перевіряєте першу групу парності, і ви бачите, що

286
00:18:23,960 --> 00:18:29,820
вона парна, тому будь-яка помилка, яка існує, повинна бути в парному стовпці.

287
00:18:29,820 --> 00:18:34,620
Наступна перевірка дає нам непарне число, повідомляючи, що є принаймні

288
00:18:34,620 --> 00:18:38,760
одна помилка, і звужуючи нас до цього конкретного стовпця.

289
00:18:38,760 --> 00:18:42,900
Третя перевірка рівномірна, що ще більше скорочує можливості.

290
00:18:42,900 --> 00:18:46,780
І остання перевірка парності є дивною, повідомляє нам, що десь внизу є

291
00:18:46,780 --> 00:18:51,700
помилка, яка наразі, як ми бачимо, має бути в позиції номер 10.

292
00:18:51,700 --> 00:18:56,140
Більше того, парність усього блоку дивна, що дає нам

293
00:18:56,140 --> 00:18:58,220
впевненість, що був один фліп, а не два.

294
00:18:58,220 --> 00:19:01,600
Якщо їх три або більше, усі ставки скасовуються.

295
00:19:01,600 --> 00:19:06,520
Після виправлення цього біта номер 10, вилучення 11 бітів, які не були використані

296
00:19:06,520 --> 00:19:11,620
для виправлення, дає нам відповідний сегмент вихідного повідомлення, який, якщо ви перемотуєте

297
00:19:11,620 --> 00:19:16,160
назад і порівняєте, справді є саме тим, з чого ми почали приклад.

298
00:19:16,160 --> 00:19:19,260
І тепер, коли ви знаєте, як зробити все це вручну, я хотів би показати вам,

299
00:19:19,260 --> 00:19:23,940
як ви можете виконати основну частину всієї цієї логіки за допомогою одного рядка коду Python.

300
00:19:23,940 --> 00:19:28,400
Розумієте, я ще не сказав вам, наскільки елегантним є цей

301
00:19:28,400 --> 00:19:32,380
алгоритм, як просто змусити машину вказувати на місце помилки, як

302
00:19:32,380 --> 00:19:37,680
систематично її масштабувати та як ми можемо створити все це

303
00:19:37,680 --> 00:19:39,580
як одна операція, а не кілька окремих перевірок парності.

304
00:19:39,580 --> 00:19:41,680
Щоб зрозуміти, що я маю на увазі, приєднуйтеся до частини 2.

