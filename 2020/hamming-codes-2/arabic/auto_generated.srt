1
00:00:00,000 --> 00:00:05,396
هل سبق لك أن تساءلت كيف يمكن خدش قرص مضغوط أو قرص

2
00:00:05,396 --> 00:00:10,900
DVD مع الاستمرار في تشغيله مهما كان ما يتم تخزينه؟

3
00:00:10,900 --> 00:00:16,758
تؤثر عملية الخدش بالفعل على 1 و0 على القرص، لذا فهي تقرأ بيانات مختلفة عما تم

4
00:00:16,758 --> 00:00:22,616
تخزينه، ولكن ما لم يتم خدشها بالفعل، فسيتم فك تشفير البتات التي تقرأها في نفس

5
00:00:22,616 --> 00:00:28,400
الملف الذي تم ترميزه عليه بالضبط، بت للنسخة بت، على الرغم من كل تلك الأخطاء.

6
00:00:28,400 --> 00:00:32,722
هناك قدر كبير من الذكاء الرياضي الذي يسمح لنا بتخزين البيانات،

7
00:00:32,722 --> 00:00:36,840
وبنفس القدر من الأهمية نقل البيانات، بطريقة مقاومة للأخطاء.

8
00:00:36,840 --> 00:00:42,480
حسنًا، حسنًا، في الواقع لا يتطلب الأمر الكثير من الذكاء للتوصل إلى طريقة للقيام بذلك.

9
00:00:42,480 --> 00:00:46,788
أي ملف، سواء كان مقطع فيديو أو صوتًا أو نصًا، أو بعض التعليمات

10
00:00:46,788 --> 00:00:50,960
البرمجية، أو صورة، أو أيًا كان، هو في النهاية تسلسل من 1 و0.

11
00:00:50,960 --> 00:00:57,780
والاستراتيجية البسيطة لتصحيح أي جزء يتم قلبه هي تخزين ثلاث نسخ من كل جزء.

12
00:00:57,780 --> 00:01:02,733
ثم يمكن للآلة التي تقرأ هذا الملف أن تقارن هذه النسخ الثلاث

13
00:01:02,733 --> 00:01:07,440
وتأخذ دائمًا أفضل نسختين من أصل 3 عندما يكون هناك تناقض.

14
00:01:07,440 --> 00:01:11,560
ولكن ما يعنيه ذلك هو استخدام ثلثي المساحة الخاصة بك للتكرار.

15
00:01:11,560 --> 00:01:14,840
وحتى في هذه الحالة، ورغم كل تلك المساحة التي تم التخلي عنها،

16
00:01:14,840 --> 00:01:18,120
ليس هناك ضمان قوي بشأن ما يحدث إذا تم قلب أكثر من بتة واحدة.

17
00:01:18,120 --> 00:01:21,497
السؤال الأكثر إثارة للاهتمام هو كيفية القيام بذلك

18
00:01:21,497 --> 00:01:24,740
بحيث يمكن تصحيح الأخطاء مع ترك أقل مساحة ممكنة.

19
00:01:24,740 --> 00:01:28,891
على سبيل المثال، باستخدام الطريقة التي ستتعرف عليها في هذا الفيديو،

20
00:01:28,891 --> 00:01:33,043
يمكنك تخزين بياناتك في كتل بحجم 256 بت، حيث تستخدم كل كتلة 9 بت، 9!

21
00:01:33,043 --> 00:01:37,063
لتكون بمثابة نوع من التكرار، والـ 247 بت الأخرى

22
00:01:37,063 --> 00:01:41,000
حرة في حمل أي رسالة أو بيانات ذات معنى تريدها.

23
00:01:41,000 --> 00:01:47,170
وسيظل الأمر كذلك، إذا تم قلب أي جزء هنا، فقط من خلال النظر إلى هذه الكتلة وليس أكثر

24
00:01:47,170 --> 00:01:53,120
من ذلك، ستتمكن الآلة من تحديد وجود خطأ وتحديد مكانه بدقة حتى تعرف كيفية تصحيحه .

25
00:01:53,120 --> 00:01:55,540
وبصراحة، هذا يبدو وكأنه سحر.

26
00:01:55,540 --> 00:01:59,460
وبالنسبة لهذا المخطط بالذات، إذا تم قلب اثنين من البتات، فسيكون الجهاز قادرًا

27
00:01:59,460 --> 00:02:03,180
على الأقل على اكتشاف وجود خطأين، على الرغم من أنه لن يعرف كيفية إصلاحهما.

28
00:02:03,180 --> 00:02:08,140
سنتحدث بعد قليل عن كيفية قياس ذلك للكتل ذات الأحجام المختلفة.

29
00:02:08,140 --> 00:02:13,880
تُعرف الطرق التي تتيح لك تصحيح أخطاء مثل هذه، بشكل معقول، باسم رموز تصحيح الأخطاء.

30
00:02:13,880 --> 00:02:18,186
خلال الجزء الأكبر من القرن الماضي، كان هذا المجال مصدرًا غنيًا حقًا

31
00:02:18,186 --> 00:02:23,000
للرياضيات العميقة بشكل مدهش والتي تم دمجها في الأجهزة التي نستخدمها كل يوم.

32
00:02:23,000 --> 00:02:29,660
الهدف هنا هو إعطاؤك فهمًا شاملاً لأحد أقدم الأمثلة، والمعروف باسم كود هامينغ.

33
00:02:29,660 --> 00:02:34,940
وبالمناسبة، الطريقة التي أفكر بها في بنية هذا الفيديو لا تتعلق بشرحها بشكل مباشر قدر

34
00:02:34,940 --> 00:02:40,220
الإمكان، بل تتعلق أكثر بدفعك لابتكارها بنفسك، مع القليل من التوجيه اللطيف هنا وهناك.

35
00:02:40,220 --> 00:02:43,673
لذلك عندما تشعر وكأنك ترى إلى أين ستتجه الأمور في مرحلة ما، توقف

36
00:02:43,673 --> 00:02:47,180
في تلك اللحظة، وتوقع بشكل فعال ما سيكون عليه المخطط قبل أن أخبرك.

37
00:02:47,180 --> 00:02:51,250
أيضًا، إذا كنت تريد أن يصل فهمك إلى مستوى الأجهزة، فقد قام Ben

38
00:02:51,250 --> 00:02:55,255
Eater بإنشاء مقطع فيديو بالتزامن مع هذا الفيديو يوضح لك كيفية

39
00:02:55,255 --> 00:02:59,520
تنفيذ رموز Hamming فعليًا على لوحات التجارب، وهو أمر مرضٍ للغاية.

40
00:02:59,520 --> 00:03:04,513
يجب أن تعلم أن رموز هامينج لا تُستخدم على نطاق واسع مثل الرموز الأكثر حداثة،

41
00:03:04,513 --> 00:03:09,441
مثل خوارزمية ريد-سولومون، ولكن هناك سحرًا معينًا في التناقض بين مدى استحالة

42
00:03:09,441 --> 00:03:14,240
هذه المهمة في البداية، وكيف تبدو معقولة تمامًا مرة واحدة تتعلم عن هامينج.

43
00:03:14,240 --> 00:03:18,249
المبدأ الأساسي لتصحيح الأخطاء هو أنه في مساحة واسعة من جميع

44
00:03:18,249 --> 00:03:22,860
الرسائل المحتملة، سيتم اعتبار بعض المجموعات الفرعية فقط رسائل صالحة.

45
00:03:22,860 --> 00:03:29,100
على سبيل القياس، فكر في الكلمات المكتوبة بشكل صحيح مقابل الكلمات المكتوبة بشكل غير صحيح.

46
00:03:29,100 --> 00:03:33,491
عندما يتم تغيير رسالة صالحة، يكون المتلقي مسؤولاً عن

47
00:03:33,491 --> 00:03:38,380
تصحيح ما يراه إلى أقرب جار صالح، كما قد تفعل مع خطأ مطبعي.

48
00:03:38,380 --> 00:03:42,857
ومع ذلك، فإن التوصل إلى خوارزمية ملموسة لتصنيف مثل

49
00:03:42,857 --> 00:03:47,160
هذه الرسائل بكفاءة يتطلب قدرًا معينًا من الذكاء.

50
00:03:47,160 --> 00:03:50,641
تبدأ القصة في الأربعينيات من القرن العشرين، عندما كان الشاب ريتشارد هامينج

51
00:03:50,641 --> 00:03:53,938
يعمل في مختبرات بيل، وكانت بعض أعماله تتضمن استخدام كمبيوتر كبير الحجم

52
00:03:53,938 --> 00:03:57,420
ومكلف للغاية يعمل بنظام البطاقة المثقبة، ولم يكن لديه سوى وصول محدود إليه.

53
00:03:57,420 --> 00:04:03,140
والبرامج التي ظل يطبقها ظلت تفشل، لأنه بين الحين والآخر سيتم إساءة قراءة جزء منها.

54
00:04:03,140 --> 00:04:06,270
نظرًا لأن الإحباط هو بوتقة الاختراع، فقد سئم كثيرًا

55
00:04:06,270 --> 00:04:09,280
لدرجة أنه اخترع أول رمز لتصحيح الأخطاء في العالم.

56
00:04:09,280 --> 00:04:12,760
هناك العديد من الطرق المختلفة لتأطير رموز هامينج، ولكن

57
00:04:12,760 --> 00:04:16,620
كمرحلة أولى سنتناول الأمر بالطريقة التي فكر بها هامينج نفسه.

58
00:04:16,620 --> 00:04:21,400
دعونا نستخدم مثالاً بسيطًا، ولكن ليس بسيطًا للغاية، وهو كتلة مكونة من 16 بت.

59
00:04:21,400 --> 00:04:25,700
سنقوم بترقيم مواضع هذه البتات من 0 إلى 15.

60
00:04:25,700 --> 00:04:29,733
البيانات الفعلية التي نريد تخزينها ستشكل 12 بتًا فقط

61
00:04:29,733 --> 00:04:33,920
من هذه البتات، في حين يتم حجز 4 مواضع كنوع من التكرار.

62
00:04:33,920 --> 00:04:37,036
كلمة زائدة عن الحاجة هنا لا تعني ببساطة النسخ، ففي نهاية المطاف،

63
00:04:37,036 --> 00:04:40,200
هذه البتات الأربعة لا تمنحنا مساحة كافية لنسخ البيانات بشكل أعمى.

64
00:04:40,200 --> 00:04:44,195
وبدلاً من ذلك، سيحتاجون إلى نوع أكثر دقة وذكاءً من

65
00:04:44,195 --> 00:04:48,740
التكرار، وليس إضافة أي معلومات جديدة، ولكن إضافة المرونة.

66
00:04:48,740 --> 00:04:54,530
قد تتوقع أن تأتي هذه القطع الأربعة الخاصة مجمعة بشكل جيد معًا، ربما في النهاية أو شيء من

67
00:04:54,530 --> 00:05:00,320
هذا القبيل، ولكن كما سترى، فإن وضعها في مواضع تمثل قوى 2 يسمح بشيء أنيق حقًا في النهاية.

68
00:05:00,320 --> 00:05:05,420
قد يمنحك أيضًا تلميحًا بسيطًا حول كيفية قياس هذا للكتل الأكبر حجمًا.

69
00:05:05,420 --> 00:05:09,754
ومن الناحية الفنية أيضًا، سينتهي الأمر بـ 11 بتًا فقط من البيانات، وستجد أن

70
00:05:09,754 --> 00:05:14,260
هناك فارقًا بسيطًا لما يحدث في الموضع 0، لكن لا تقلق بشأن ذلك في الوقت الحالي.

71
00:05:14,260 --> 00:05:20,230
مثل أي خوارزمية لتصحيح الأخطاء، سيتضمن ذلك لاعبين، مرسل مسؤول عن تعيين هذه

72
00:05:20,230 --> 00:05:26,360
البتات الأربعة الخاصة، ومتلقي مسؤول عن إجراء نوع ما من الفحص وتصحيح الأخطاء.

73
00:05:26,360 --> 00:05:31,004
بالطبع، تشير كلمتا المرسل والمستقبل إلى الأجهزة أو البرامج التي تقوم بجميع عمليات

74
00:05:31,004 --> 00:05:35,480
التحقق، والمقصود بفكرة الرسالة على نطاق واسع جدًا، هو تضمين أشياء مثل التخزين.

75
00:05:35,480 --> 00:05:39,092
ففي نهاية المطاف، تخزين البيانات هو نفس إرسال رسالة من

76
00:05:39,092 --> 00:05:42,640
الماضي إلى المستقبل بدلاً من إرسالها من مكان إلى آخر.

77
00:05:42,640 --> 00:05:47,583
إذن هذا هو الإعداد، ولكن قبل أن نتمكن من التعمق في الأمر، نحتاج إلى التحدث عن فكرة ذات

78
00:05:47,583 --> 00:05:52,242
صلة كانت جديدة في ذهن هامينج في وقت اكتشافه، وهي طريقة تتيح لك اكتشاف أي أخطاء في

79
00:05:52,242 --> 00:05:57,300
البتات، ولكن ليس تصحيحها، كما هو معروف. في الأعمال التجارية باعتبارها التحقق من التكافؤ.

80
00:05:57,300 --> 00:06:01,349
للتحقق من التكافؤ، نقوم بفصل بت واحد فقط يكون المرسل

81
00:06:01,349 --> 00:06:04,940
مسؤولاً عن ضبطه، والباقي أحرار في حمل الرسالة.

82
00:06:04,940 --> 00:06:08,596
الوظيفة الوحيدة لهذا البت الخاص هي التأكد من أن

83
00:06:08,596 --> 00:06:12,100
العدد الإجمالي للآحاد في الرسالة هو رقم زوجي.

84
00:06:12,100 --> 00:06:16,470
على سبيل المثال، في الوقت الحالي، إجمالي عدد الآحاد هو 7، وهذا أمر غريب،

85
00:06:16,470 --> 00:06:20,960
لذلك يحتاج المرسل إلى قلب هذا البت الخاص ليصبح 1، مما يجعل العدد متساويًا.

86
00:06:20,960 --> 00:06:27,480
ولكن إذا كانت الكتلة قد بدأت بالفعل بعدد زوجي من 1، فسيتم الاحتفاظ بهذا البت الخاص عند 0.

87
00:06:27,480 --> 00:06:32,694
هذا أمر بسيط جدًا، وبسيط بشكل خادع، ولكنه طريقة أنيقة للغاية لاستخلاص

88
00:06:32,694 --> 00:06:37,760
فكرة التغيير في أي مكان في الرسالة لتنعكس في جزء واحد من المعلومات.

89
00:06:37,760 --> 00:06:42,907
لاحظ أنه إذا تم قلب أي جزء من هذه الرسالة، إما من 0 إلى 1 أو

90
00:06:42,907 --> 00:06:48,140
من 1 إلى 0، فإنه يغير العدد الإجمالي للآحاد من زوجي إلى فردي.

91
00:06:48,140 --> 00:06:53,386
لذلك، إذا كنت المتلقي، ونظرت إلى هذه الرسالة، ورأيت عددًا فرديًا من 1، فيمكنك

92
00:06:53,386 --> 00:06:58,700
التأكد من حدوث خطأ ما، على الرغم من أنه قد لا يكون لديك أي فكرة عن مكان حدوثه.

93
00:06:58,700 --> 00:07:01,820
في المصطلحات، يُعرف ما إذا كانت مجموعة البتات

94
00:07:01,820 --> 00:07:04,940
تحتوي على عدد زوجي أو فردي من 1 باسم التكافؤ.

95
00:07:04,940 --> 00:07:08,173
يمكنك أيضًا استخدام الأرقام والقول إن التكافؤ هو 0 أو 1، وهو ما يكون أكثر

96
00:07:08,173 --> 00:07:11,320
فائدة عادةً بمجرد البدء في إجراء العمليات الحسابية باستخدام هذه الفكرة.

97
00:07:11,320 --> 00:07:18,020
وهذه البتة الخاصة التي يستخدمها المرسل للتحكم في التكافؤ تسمى بت التكافؤ.

98
00:07:18,020 --> 00:07:21,775
وفي الواقع، يجب أن نكون واضحين، إذا رأى المتلقي تكافؤًا فرديًا، فهذا

99
00:07:21,775 --> 00:07:25,586
لا يعني بالضرورة أنه كان هناك خطأ واحد فقط، ربما كان هناك 3 أخطاء، أو

100
00:07:25,586 --> 00:07:29,560
5، أو أي رقم فردي آخر، لكن يمكنهم معرفة ذلك على وجه اليقين أنه لم يكن 0.

101
00:07:29,560 --> 00:07:33,917
من ناحية أخرى، إذا كان هناك خطأين، أو أي عدد زوجي من الأخطاء، فإن

102
00:07:33,917 --> 00:07:38,275
العدد النهائي للأرقام 1 سيظل زوجيًا، لذلك لا يمكن للمستلم أن يكون

103
00:07:38,275 --> 00:07:43,360
واثقًا تمامًا من أن العدد الزوجي يعني بالضرورة أن الرسالة خالية من الأخطاء .

104
00:07:43,360 --> 00:07:46,530
قد تشكو من أن الرسالة التي يتم إفسادها من خلال تقلبات

105
00:07:46,530 --> 00:07:49,760
بمقدار 2 بت فقط تكون ضعيفة جدًا، وستكون على حق تمامًا.

106
00:07:49,760 --> 00:07:54,675
ومع ذلك، ضع في اعتبارك أنه لا توجد طريقة لاكتشاف الأخطاء أو تصحيحها يمكن أن

107
00:07:54,675 --> 00:07:59,720
تمنحك ثقة بنسبة 100% في أن الرسالة التي تتلقاها هي الرسالة التي قصدها المرسل.

108
00:07:59,720 --> 00:08:02,713
بعد كل شيء، يمكن للضوضاء العشوائية الكافية دائمًا تغيير

109
00:08:02,713 --> 00:08:05,920
رسالة صالحة إلى رسالة صالحة أخرى فقط عن طريق الصدفة البحتة.

110
00:08:05,920 --> 00:08:11,200
بدلاً من ذلك، الهدف هو التوصل إلى مخطط قوي يصل إلى حد أقصى معين من

111
00:08:11,200 --> 00:08:16,480
الأخطاء، أو ربما لتقليل احتمالية حدوث نتيجة إيجابية كاذبة مثل هذا.

112
00:08:16,480 --> 00:08:20,216
تعتبر عمليات التحقق من التكافؤ في حد ذاتها ضعيفة جدًا، ولكن

113
00:08:20,216 --> 00:08:23,952
من خلال استخلاص فكرة التغيير عبر رسالة كاملة وصولاً إلى جزء

114
00:08:23,952 --> 00:08:28,000
واحد، فإن ما يقدمونه لنا هو لبنة بناء قوية لمخططات أكثر تعقيدًا.

115
00:08:28,000 --> 00:08:32,756
على سبيل المثال، بينما كان هامينج يبحث عن طريقة لتحديد مكان حدوث الخطأ، وليس

116
00:08:32,756 --> 00:08:37,450
فقط مكان حدوثه، كانت رؤيته الرئيسية هي أنه إذا قمت بتطبيق بعض عمليات التحقق

117
00:08:37,450 --> 00:08:41,898
من التكافؤ ليس على الرسالة الكاملة، ولكن على مجموعات فرعية معينة مختارة

118
00:08:41,898 --> 00:08:46,840
بعناية، فيمكنك أن تسأل سلسلة أكثر دقة من الأسئلة التي تحدد موقع أي خطأ بت واحد.

119
00:08:46,840 --> 00:08:50,570
الشعور العام يشبه إلى حد ما ممارسة لعبة مكونة من 20 سؤالًا، حيث يتم

120
00:08:50,570 --> 00:08:54,300
طرح أسئلة بنعم أو لا مما يؤدي إلى تقطيع مساحة الاحتمالات إلى النصف.

121
00:08:54,300 --> 00:08:56,998
على سبيل المثال، لنفترض أننا قمنا بإجراء فحص التكافؤ على

122
00:08:56,998 --> 00:08:59,840
هذه البتات الثمانية فقط، وجميع المواضع ذات الأرقام الفردية.

123
00:08:59,840 --> 00:09:04,832
ثم إذا تم اكتشاف خطأ، فإنه يمنح المتلقي المزيد من المعلومات

124
00:09:04,832 --> 00:09:09,160
حول مكان الخطأ على وجه التحديد، أي أنه في وضع فردي.

125
00:09:09,160 --> 00:09:13,260
إذا لم يتم اكتشاف أي خطأ بين تلك البتات الثمانية، فهذا يعني إما عدم

126
00:09:13,260 --> 00:09:17,240
وجود خطأ على الإطلاق، أو أنه موجود في مكان ما في المواضع الزوجية.

127
00:09:17,240 --> 00:09:23,329
قد تظن أن قصر فحص التكافؤ على نصف البتات يجعله أقل فعالية، ولكن عندما يتم إجراؤه

128
00:09:23,329 --> 00:09:29,720
بالتزامن مع عمليات فحص أخرى مختارة جيدًا، فإنه يمنحنا شيئًا أكثر قوة بشكل غير متوقع.

129
00:09:29,720 --> 00:09:37,600
لإعداد فحص التكافؤ هذا، تذكر أنه يتطلب تخصيص جزء خاص يتحكم في تكافؤ تلك المجموعة الكاملة.

130
00:09:37,600 --> 00:09:39,920
هنا دعونا فقط نختار الموضع 1.

131
00:09:39,920 --> 00:09:44,226
في المثال الموضح، يعد تكافؤ هذه البتات الثمانية أمرًا فرديًا حاليًا،

132
00:09:44,226 --> 00:09:48,220
لذا يكون المرسل مسؤولاً عن تبديل بت التكافؤ هذا، وهو الآن زوجي.

133
00:09:48,220 --> 00:09:51,040
هذه عملية واحدة فقط من أصل 4 عمليات فحص تكافؤ سنجريها.

134
00:09:51,040 --> 00:09:56,880
الفحص الثاني يكون من بين 8 بتات في النصف الأيمن من الشبكة، على الأقل كما رسمناها هنا.

135
00:09:56,880 --> 00:10:02,177
هذه المرة قد نستخدم الموضع 2 كبت تكافؤ، وبالتالي فإن هذه البتات الثمانية لها بالفعل

136
00:10:02,177 --> 00:10:07,160
تكافؤ متساوي، ويمكن أن يشعر المرسل بالارتياح عند ترك هذا البت رقم 2 دون تغيير.

137
00:10:07,160 --> 00:10:11,589
ومن ثم على الطرف الآخر، إذا تحقق المتلقي من تكافؤ هذه المجموعة ووجد أنه أمر

138
00:10:11,589 --> 00:10:15,960
غريب، فسيعرف أن الخطأ موجود في مكان ما بين هذه البتات الثمانية على اليمين.

139
00:10:15,960 --> 00:10:21,260
وإلا فهذا يعني أنه لا يوجد خطأ، أو أن الخطأ موجود في مكان ما في النصف الأيسر.

140
00:10:21,260 --> 00:10:24,024
أو أعتقد أنه من الممكن أن يكون هناك خطأين، ولكن في الوقت

141
00:10:24,024 --> 00:10:27,080
الحالي سنفترض أن هناك خطأ واحدًا على الأكثر في الكتلة بأكملها.

142
00:10:27,080 --> 00:10:29,160
تنهار الأمور تمامًا لأكثر من ذلك.

143
00:10:29,160 --> 00:10:32,378
هنا، قبل أن ننظر إلى الفحصين التاليين، توقف لحظة للتفكير

144
00:10:32,378 --> 00:10:35,880
فيما يسمح لنا بهذين الاختبارين الأولين عندما تفكر فيهما معًا.

145
00:10:35,880 --> 00:10:40,240
لنفترض أنك اكتشفت خطأ بين الأعمدة الفردية وبين النصف الأيمن.

146
00:10:40,240 --> 00:10:43,940
وهذا يعني بالضرورة أن الخطأ موجود في مكان ما في العمود الأخير.

147
00:10:43,940 --> 00:10:47,068
إذا لم يكن هناك خطأ في العمود الفردي ولكن كان هناك خطأ في

148
00:10:47,068 --> 00:10:50,520
النصف الأيمن، فهذا يخبرك أنه موجود في العمود الثاني قبل الأخير.

149
00:10:50,520 --> 00:10:53,487
وبالمثل، إذا كان هناك خطأ في الأعمدة الفردية ولكن ليس في

150
00:10:53,487 --> 00:10:56,560
النصف الأيمن، فاعلم أنه موجود في مكان ما في العمود الثاني.

151
00:10:56,560 --> 00:11:00,210
وإذا لم يكتشف أي من هذين التحققين من التكافؤ أي شيء، فهذا يعني أن المكان

152
00:11:00,210 --> 00:11:03,760
الوحيد الذي يمكن أن يوجد فيه خطأ هو ذلك العمود الموجود في أقصى اليسار.

153
00:11:03,760 --> 00:11:06,480
ولكنه قد يعني أيضًا أنه لا يوجد خطأ على الإطلاق.

154
00:11:06,480 --> 00:11:11,800
وهي طريقة متقنة إلى حد ما للقول إن فحصي التكافؤ يسمحان لنا بتحديد العمود.

155
00:11:11,800 --> 00:11:14,000
من هنا، ربما يمكنك تخمين ما يلي.

156
00:11:14,000 --> 00:11:16,240
نحن نفعل نفس الشيء بشكل أساسي ولكن بالنسبة للصفوف.

157
00:11:16,240 --> 00:11:21,040
سيكون هناك فحص للتكافؤ في الصفوف الفردية، باستخدام الموضع 4 كبت تكافؤ.

158
00:11:21,040 --> 00:11:26,480
لذلك في هذا المثال، هذه المجموعة لديها بالفعل تكافؤ زوجي، لذا سيتم تعيين البت 4 على 0.

159
00:11:26,480 --> 00:11:32,280
وأخيرًا، هناك فحص تكافؤ في الصفين السفليين، باستخدام الموضع 8 كبت تكافؤ.

160
00:11:32,280 --> 00:11:37,840
في هذه الحالة، يبدو أن المرسل بحاجة إلى تشغيل هذا البت 8 من أجل منح المجموعة التكافؤ.

161
00:11:37,840 --> 00:11:40,420
تمامًا كما تتيح لنا عمليتا التحقق الأولين تثبيت

162
00:11:40,420 --> 00:11:43,000
العمود، تتيح لك الوظيفتان التاليتان تثبيت الصف.

163
00:11:43,000 --> 00:11:48,400
على سبيل المثال، تخيل أنه أثناء الإرسال، حدث خطأ في الموضع 3 على سبيل المثال.

164
00:11:48,400 --> 00:11:52,424
حسنًا، يؤثر هذا على مجموعة التكافؤ الأولى، ويؤثر أيضًا على مجموعة التكافؤ

165
00:11:52,424 --> 00:11:56,340
الثانية، لذلك يعرف المتلقي أن هناك خطأ في مكان ما في هذا العمود الأيمن.

166
00:11:56,340 --> 00:12:01,380
لكنه لا يؤثر على المجموعة الثالثة، ولا يؤثر على المجموعة الرابعة.

167
00:12:01,380 --> 00:12:05,054
وهذا يتيح للمتلقي تحديد الخطأ حتى الصف الأول، وهو ما

168
00:12:05,054 --> 00:12:08,660
يعني بالضرورة الموضع 3، حتى يتمكنوا من إصلاح الخطأ.

169
00:12:08,660 --> 00:12:12,958
قد تستمتع بتخصيص بعض الوقت لإقناع نفسك بأن الإجابات على هذه الأسئلة

170
00:12:12,958 --> 00:12:17,320
الأربعة ستسمح لك دائمًا بتحديد موقع معين، بغض النظر عن مكان تواجدهم.

171
00:12:17,320 --> 00:12:23,640
في الواقع، قد يلاحظ الأذكياء بينكم وجود صلة بين هذه الأسئلة والعد الثنائي.

172
00:12:23,640 --> 00:12:30,880
وإذا قمت بذلك، دعني أؤكد مرة أخرى، توقف مؤقتًا، حاول بنفسك أن ترسم الارتباط قبل أن أفسده.

173
00:12:30,880 --> 00:12:36,560
إذا كنت تتساءل عما يحدث إذا تأثرت بتة التكافؤ نفسها، حسنًا، يمكنك تجربتها فقط.

174
00:12:36,560 --> 00:12:42,207
خذ لحظة للتفكير في كيفية تعقب أي خطأ بين هذه الأجزاء الأربعة الخاصة

175
00:12:42,207 --> 00:12:47,440
تمامًا مثل أي خطأ آخر، مع نفس المجموعة المكونة من أربعة أسئلة.

176
00:12:47,440 --> 00:12:50,540
لا يهم حقًا، نظرًا لأن ما نريده في نهاية المطاف هو حماية

177
00:12:50,540 --> 00:12:53,640
أجزاء الرسالة، فإن وحدات بت تصحيح الأخطاء هي التي تستمر.

178
00:12:53,640 --> 00:12:59,260
لكن حماية تلك البتات أيضًا هو أمر يخرج بشكل طبيعي عن المخطط كمنتج ثانوي.

179
00:12:59,260 --> 00:13:02,380
قد تستمتع أيضًا بتوقع كيفية قياس هذا الأمر.

180
00:13:02,380 --> 00:13:08,708
إذا استخدمنا كتلة بحجم 256 بت، على سبيل المثال، لتحديد موقع ما، فأنت

181
00:13:08,708 --> 00:13:15,680
تحتاج فقط إلى ثمانية أسئلة بنعم أو لا للبحث الثنائي في طريقك إلى مكان محدد.

182
00:13:15,680 --> 00:13:23,340
وتذكر أن كل سؤال يتطلب التخلي عن جزء واحد فقط لتعيين التحقق من التكافؤ المناسب.

183
00:13:23,340 --> 00:13:26,762
ربما يراها البعض منكم بالفعل، لكننا سنتحدث لاحقًا عن الطريقة

184
00:13:26,762 --> 00:13:29,960
المنهجية للعثور على هذه الأسئلة في دقيقة أو دقيقتين فقط.

185
00:13:29,960 --> 00:13:34,440
نأمل أن يكون هذا المخطط كافيًا لتقدير كفاءة ما نقوم بتطويره هنا.

186
00:13:34,440 --> 00:13:38,112
أول شيء، باستثناء تلك البتات الثمانية المتماثلة المميزة،

187
00:13:38,112 --> 00:13:41,720
يمكن أن تكون كما تريد، وتحمل أي رسالة أو بيانات تريدها.

188
00:13:41,720 --> 00:13:47,553
تعتبر البتات الثمانية زائدة عن الحاجة، بمعنى أنه يتم تحديدها بالكامل

189
00:13:47,553 --> 00:13:53,640
من خلال بقية الرسالة، ولكنها بطريقة أكثر ذكاءً من مجرد نسخ الرسالة ككل.

190
00:13:53,640 --> 00:13:59,000
ومع ذلك، مقابل القليل جدًا من الاستسلام، ستكون قادرًا على تحديد وإصلاح أي خطأ في البتات.

191
00:13:59,000 --> 00:14:00,400
حسنًا تقريبًا.

192
00:14:00,400 --> 00:14:04,787
حسنًا، المشكلة الوحيدة هنا هي أنه إذا لم تكتشف أي من عمليات التحقق من

193
00:14:04,787 --> 00:14:09,299
التكافؤ وجود خطأ، مما يعني أن المجموعات الفرعية المحددة خصيصًا والمكونة

194
00:14:09,299 --> 00:14:13,623
من 8 بتات جميعها لها تماثلات زوجية، تمامًا كما قصد المرسل، فهذا يعني

195
00:14:13,623 --> 00:14:17,760
إما أنه لم يكن هناك خطأ على الإطلاق أو أنه يضيق بنا إلى الموضع 0.

196
00:14:17,760 --> 00:14:22,752
كما ترى، مع أربعة أسئلة بنعم أو لا، لدينا 16 نتيجة محتملة لعمليات التحقق من

197
00:14:22,752 --> 00:14:27,679
التكافؤ، وفي البداية يبدو ذلك مثاليًا لتحديد موضع واحد من أصل 16 موضعًا في

198
00:14:27,679 --> 00:14:33,000
الكتلة، ولكنك تحتاج أيضًا إلى توصيل النتيجة السابعة عشرة، وهي عدم وجود خطأ حالة.

199
00:14:33,000 --> 00:14:37,860
الحل هنا بسيط جدًا في الواقع، فقط انسَ هذا الجزء 0 تمامًا.

200
00:14:37,860 --> 00:14:41,172
لذلك عندما نقوم بعمليات التحقق من التكافؤ الأربعة ونرى أنها

201
00:14:41,172 --> 00:14:44,320
كلها متساوية، فهذا يعني بشكل لا لبس فيه أنه لا يوجد خطأ.

202
00:14:44,320 --> 00:14:49,307
ما يعنيه ذلك هو أنه بدلًا من العمل مع كتلة مكونة من 16 بت، فإننا نعمل مع كتلة

203
00:14:49,307 --> 00:14:54,040
مكونة من 15 بت، حيث يكون 11 بتًا مجانيًا لحمل رسالة و4 بتات منها للتكرار.

204
00:14:54,040 --> 00:14:59,400
وبهذا، أصبح لدينا الآن ما يشير إليه الأشخاص في هذا المجال برمز هامينغ 15-11.

205
00:14:59,400 --> 00:15:04,228
ومع ذلك، من الجيد أن يكون لدينا حجم كتلة يساوي قوة نظيفة تبلغ 2، وهناك طريقة ذكية

206
00:15:04,228 --> 00:15:08,880
يمكننا من خلالها الاحتفاظ بهذا الجزء الصفري وجعله يقوم ببعض العمل الإضافي لنا.

207
00:15:08,880 --> 00:15:12,540
إذا استخدمناها كبتة تكافؤ عبر الكتلة بأكملها، فإنها تتيح لنا

208
00:15:12,540 --> 00:15:16,320
بالفعل اكتشاف أخطاء 2 بت، على الرغم من أننا لا نستطيع تصحيحها.

209
00:15:16,320 --> 00:15:17,440
وإليك كيف يعمل.

210
00:15:17,440 --> 00:15:21,461
بعد تعيين تلك البتات الأربعة الخاصة لتصحيح الأخطاء، قمنا بتعيين البت 0

211
00:15:21,461 --> 00:15:25,540
بحيث يكون تكافؤ الكتلة الكاملة متساويًا، تمامًا مثل فحص التكافؤ العادي.

212
00:15:25,540 --> 00:15:29,651
الآن، إذا كان هناك خطأ بت واحد، فإن تكافؤ الكتلة الكاملة يصبح غريبًا،

213
00:15:29,651 --> 00:15:33,940
لكننا سنكتشف ذلك على أي حال بفضل عمليات التحقق الأربعة من تصحيح الأخطاء.

214
00:15:33,940 --> 00:15:37,878
ومع ذلك، إذا كان هناك خطأان، فسيتم تبديل التكافؤ الإجمالي مرة

215
00:15:37,878 --> 00:15:41,881
أخرى إلى كونه متساويًا، لكن المتلقي سيظل يرى أن هناك على الأقل

216
00:15:41,881 --> 00:15:45,820
بعض الأخطاء بسبب ما يحدث مع عمليات التحقق من التكافؤ الأربعة.

217
00:15:45,820 --> 00:15:49,256
لذا، إذا لاحظوا تكافؤًا متساويًا بشكل عام، ولكن حدث شيء غير

218
00:15:49,256 --> 00:15:52,980
صفري مع عمليات التحقق الأخرى، فهذا يخبرهم بوجود خطأين على الأقل.

219
00:15:52,980 --> 00:15:54,420
أليس هذا ذكيا؟

220
00:15:54,420 --> 00:15:58,183
على الرغم من أننا لا نستطيع تصحيح تلك الأخطاء ذات البتتين، إلا أنه

221
00:15:58,183 --> 00:16:02,340
بمجرد إعادة البتة الصفرية المزعجة هذه إلى العمل، فإنها تتيح لنا اكتشافها.

222
00:16:02,340 --> 00:16:06,540
يعد هذا أمرًا قياسيًا جدًا، ويُعرف باسم كود هامينج الممتد.

223
00:16:06,540 --> 00:16:10,060
من الناحية الفنية، لديك الآن وصف كامل لما تفعله

224
00:16:10,060 --> 00:16:13,580
كود هامينج، على الأقل بالنسبة لمثال كتلة 16 بت.

225
00:16:13,580 --> 00:16:17,780
لكنني أعتقد أنك ستجد الأمر أكثر إرضاءً للتحقق من فهمك وترسيخ كل شيء حتى

226
00:16:17,780 --> 00:16:21,980
هذه النقطة من خلال القيام بمثال واحد كامل من البداية إلى النهاية بنفسك.

227
00:16:21,980 --> 00:16:25,100
سأقوم بالخطوات معك حتى تتمكن من التحقق بنفسك.

228
00:16:25,100 --> 00:16:30,435
لإعداد رسالة، سواء كانت رسالة حرفية تترجمها عبر مساحة أو بعض البيانات التي

229
00:16:30,435 --> 00:16:35,700
تريد تخزينها مع مرور الوقت، فإن الخطوة الأولى هي تقسيمها إلى أجزاء 11 بت.

230
00:16:35,700 --> 00:16:40,340
سيتم تجميع كل قطعة في كتلة 16 بت مقاومة للأخطاء.

231
00:16:40,340 --> 00:16:43,740
لذلك دعونا نأخذ هذا كمثال ونعمل عليه بالفعل.

232
00:16:43,740 --> 00:16:45,340
المضي قدما، في الواقع القيام بذلك!

233
00:16:45,340 --> 00:16:47,380
دعونا نتوقف مؤقتًا ونحاول تجميع هذه الكتلة معًا.

234
00:16:47,380 --> 00:16:53,980
حسنًا، هل أنت مستعد؟

235
00:16:53,980 --> 00:17:00,042
تذكر أن الموضع 0 إلى جانب القوى الأخرى للرقم 2 محجوزة لمهمة تصحيح الأخطاء،

236
00:17:00,042 --> 00:17:05,700
لذا عليك أن تبدأ بوضع بتات الرسالة في جميع الأماكن المتبقية بالترتيب.

237
00:17:05,700 --> 00:17:09,390
أنت بحاجة إلى أن يكون لهذه المجموعة تكافؤ متساوي، وهو ما يحدث

238
00:17:09,390 --> 00:17:13,140
بالفعل، لذا يجب عليك تعيين بت التكافؤ هذا في الموضع 1 ليكون 0.

239
00:17:13,140 --> 00:17:19,260
تبدأ المجموعة التالية بتعادل فردي، لذا يجب عليك تعيين بت التكافؤ الخاص بها ليكون 1.

240
00:17:19,260 --> 00:17:24,740
تبدأ المجموعة بعد ذلك بتكافؤ فردي، لذلك يجب عليك مرة أخرى ضبط بت التكافؤ الخاص بها على 1.

241
00:17:24,740 --> 00:17:28,083
والمجموعة الأخيرة لديها أيضًا تكافؤ فردي، مما

242
00:17:28,083 --> 00:17:31,500
يعني أننا وضعنا هذا الجزء في الموضع 8 ليكون 1.

243
00:17:31,500 --> 00:17:36,500
وبعد ذلك كخطوة أخيرة، أصبح للكتلة الكاملة الآن تكافؤ متساوي، مما

244
00:17:36,500 --> 00:17:41,500
يعني أنه يمكنك تعيين رقم البت 0، وهو بت التكافؤ الشامل، ليكون 0.

245
00:17:41,500 --> 00:17:45,337
لذلك عندما يتم إرسال هذه الكتلة، فإن التكافؤ بين المجموعات

246
00:17:45,337 --> 00:17:48,980
الفرعية الأربع الخاصة والكتلة ككل سيكون متساويًا، أو 0.

247
00:17:48,980 --> 00:17:53,620
في الجزء الثاني من التمرين، لنجعلك تلعب دور المتلقي.

248
00:17:53,620 --> 00:17:56,960
بالطبع، هذا يعني أنك لا تعرف بالفعل ما هي هذه الرسالة،

249
00:17:56,960 --> 00:18:00,180
ربما البعض منكم يحفظها، ولكن لنفترض أنك لم تفعل ذلك.

250
00:18:00,180 --> 00:18:08,340
ما سأفعله هو تغيير إما 0 أو 1 أو 2 من البتات في تلك الكتلة، ثم أطلب منك معرفة ما فعلته.

251
00:18:08,340 --> 00:18:13,460
لذا مرة أخرى، توقف مؤقتًا وحاول حلها.

252
00:18:13,460 --> 00:18:21,704
حسنًا، أنت الآن كمستلم تتحقق من مجموعة التكافؤ الأولى ويمكنك أن

253
00:18:21,704 --> 00:18:29,820
ترى أنها زوجية، لذا فإن أي خطأ موجود يجب أن يكون في عمود زوجي.

254
00:18:29,820 --> 00:18:34,333
الفحص التالي يعطينا رقمًا فرديًا، ويخبرنا بوجود خطأ

255
00:18:34,333 --> 00:18:38,760
واحد على الأقل، ويضيق نطاقنا في هذا العمود المحدد.

256
00:18:38,760 --> 00:18:42,900
الفحص الثالث متساوي، مما يقلل من الاحتمالات بشكل أكبر.

257
00:18:42,900 --> 00:18:47,129
وآخر فحص للتكافؤ أمر غريب، حيث يخبرنا بوجود خطأ في مكان ما في

258
00:18:47,129 --> 00:18:51,700
الأسفل، والذي يمكننا الآن أن نرى أنه يجب أن يكون في الموضع رقم 10.

259
00:18:51,700 --> 00:18:55,095
علاوة على ذلك، فإن تكافؤ الكتلة بأكملها أمر غريب،

260
00:18:55,095 --> 00:18:58,220
مما يمنحنا الثقة في وجود قلب واحد وليس اثنين.

261
00:18:58,220 --> 00:19:01,600
إذا كان هناك ثلاثة أو أكثر، كل الرهانات ملغاة.

262
00:19:01,600 --> 00:19:06,110
بعد تصحيح البت رقم 10، فإن سحب البتات الـ 11 التي لم يتم

263
00:19:06,110 --> 00:19:10,858
استخدامها للتصحيح يعطينا الجزء ذي الصلة من الرسالة الأصلية،

264
00:19:10,858 --> 00:19:16,160
والذي إذا قمت بالترجيع والمقارنة فهو في الواقع ما بدأنا به المثال.

265
00:19:16,160 --> 00:19:20,104
والآن بعد أن عرفت كيفية القيام بكل هذا يدويًا، أود أن أوضح لك كيف يمكنك

266
00:19:20,104 --> 00:19:23,940
تنفيذ الجزء الأساسي من كل هذا المنطق باستخدام سطر واحد من كود بايثون.

267
00:19:23,940 --> 00:19:29,036
كما ترى، ما لم أخبرك به بعد هو مدى أناقة هذه الخوارزمية حقًا، ومدى بساطة

268
00:19:29,036 --> 00:19:34,203
جعل الآلة تشير إلى موضع الخطأ، وكيفية قياسه بشكل منهجي، وكيف يمكننا تأطير

269
00:19:34,203 --> 00:19:39,580
كل ذلك هذا كعملية واحدة بدلاً من عمليات التحقق من التكافؤ المنفصلة المتعددة.

270
00:19:39,580 --> 00:19:41,680
لتعرف ما أعنيه، تعال وانضم إلي في الجزء الثاني.

