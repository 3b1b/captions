1
00:00:00,000 --> 00:00:08,620
هل سبق لك أن تساءلت كيف يمكن خدش قرص مضغوط أو

2
00:00:08,620 --> 00:00:10,900
قرص DVD مع الاستمرار في تشغيله مهما كان ما يتم تخزينه؟

3
00:00:10,900 --> 00:00:15,280
تؤثر عملية الخدش بالفعل على 1 و0 على القرص، لذا فهي تقرأ

4
00:00:15,280 --> 00:00:20,500
بيانات مختلفة عما تم تخزينه، ولكن ما لم يتم خدشها بالفعل،

5
00:00:20,500 --> 00:00:26,540
فسيتم فك تشفير البتات التي تقرأها في نفس الملف الذي تم ترميزه

6
00:00:26,540 --> 00:00:28,400
عليه بالضبط، بت للنسخة بت، على الرغم من كل تلك الأخطاء.

7
00:00:28,400 --> 00:00:32,800
هناك قدر كبير من الذكاء الرياضي الذي يسمح لنا بتخزين

8
00:00:32,800 --> 00:00:36,840
البيانات، وبنفس القدر من الأهمية نقل البيانات، بطريقة مقاومة للأخطاء.

9
00:00:36,840 --> 00:00:41,480
حسنًا، حسنًا، في الواقع لا يتطلب الأمر الكثير

10
00:00:41,480 --> 00:00:42,480
من الذكاء للتوصل إلى طريقة للقيام بذلك.

11
00:00:42,480 --> 00:00:47,660
أي ملف، سواء كان مقطع فيديو أو صوتًا أو نصًا، أو بعض التعليمات

12
00:00:47,660 --> 00:00:50,960
البرمجية، أو صورة، أو أيًا كان، هو في النهاية تسلسل من 1 و0.

13
00:00:50,960 --> 00:00:55,340
والاستراتيجية البسيطة لتصحيح أي جزء يتم قلبه

14
00:00:55,340 --> 00:00:57,780
هي تخزين ثلاث نسخ من كل جزء.

15
00:00:57,780 --> 00:01:02,240
ثم يمكن للآلة التي تقرأ هذا الملف أن تقارن هذه النسخ الثلاث

16
00:01:02,240 --> 00:01:07,440
وتأخذ دائمًا أفضل نسختين من أصل 3 عندما يكون هناك تناقض.

17
00:01:07,440 --> 00:01:11,560
ولكن ما يعنيه ذلك هو استخدام ثلثي المساحة الخاصة بك للتكرار.

18
00:01:11,560 --> 00:01:15,360
وحتى في هذه الحالة، ورغم كل تلك المساحة التي تم التخلي عنها، ليس

19
00:01:15,360 --> 00:01:18,120
هناك ضمان قوي بشأن ما يحدث إذا تم قلب أكثر من بتة واحدة.

20
00:01:18,120 --> 00:01:21,960
السؤال الأكثر إثارة للاهتمام هو كيفية القيام بذلك بحيث

21
00:01:21,960 --> 00:01:24,740
يمكن تصحيح الأخطاء مع ترك أقل مساحة ممكنة.

22
00:01:24,740 --> 00:01:28,500
على سبيل المثال، باستخدام الطريقة التي ستتعرف عليها في هذا الفيديو، يمكنك تخزين بياناتك في كتل بحجم

23
00:01:28,500 --> 00:01:35,840
256 بت، حيث تستخدم كل كتلة 9 بت، 9! لتكون بمثابة نوع من التكرار، والـ

24
00:01:35,840 --> 00:01:41,000
247 بت الأخرى حرة في حمل أي رسالة أو بيانات ذات معنى تريدها.

25
00:01:41,000 --> 00:01:44,740
وسيظل الأمر كذلك، إذا تم قلب أي جزء هنا، فقط من خلال

26
00:01:44,740 --> 00:01:49,640
النظر إلى هذه الكتلة وليس أكثر من ذلك، ستتمكن الآلة من

27
00:01:49,640 --> 00:01:53,120
تحديد وجود خطأ وتحديد مكانه بدقة حتى تعرف كيفية تصحيحه .

28
00:01:53,140 --> 00:01:55,540
وبصراحة، هذا يبدو وكأنه سحر.

29
00:01:55,540 --> 00:01:59,400
وبالنسبة لهذا المخطط بالذات، إذا تم قلب اثنين من البتات، فسيكون الجهاز قادرًا على

30
00:01:59,400 --> 00:02:03,180
الأقل على اكتشاف وجود خطأين، على الرغم من أنه لن يعرف كيفية إصلاحهما.

31
00:02:03,180 --> 00:02:08,140
سنتحدث بعد قليل عن كيفية قياس ذلك للكتل ذات الأحجام المختلفة.

32
00:02:08,140 --> 00:02:12,620
تُعرف الطرق التي تتيح لك تصحيح أخطاء مثل

33
00:02:12,620 --> 00:02:13,880
هذه، بشكل معقول، باسم رموز تصحيح الأخطاء.

34
00:02:13,880 --> 00:02:18,220
خلال الجزء الأكبر من القرن الماضي، كان هذا المجال مصدرًا غنيًا حقًا للرياضيات

35
00:02:18,220 --> 00:02:23,000
العميقة بشكل مدهش والتي تم دمجها في الأجهزة التي نستخدمها كل يوم.

36
00:02:23,000 --> 00:02:27,740
الهدف هنا هو إعطاؤك فهمًا شاملاً لأحد

37
00:02:27,740 --> 00:02:29,660
أقدم الأمثلة، والمعروف باسم كود هامينغ.

38
00:02:29,660 --> 00:02:32,620
وبالمناسبة، الطريقة التي أفكر بها في بنية هذا الفيديو لا

39
00:02:32,620 --> 00:02:37,060
تتعلق بشرحها بشكل مباشر قدر الإمكان، بل تتعلق أكثر بدفعك

40
00:02:37,060 --> 00:02:40,220
لابتكارها بنفسك، مع القليل من التوجيه اللطيف هنا وهناك.

41
00:02:40,220 --> 00:02:44,100
لذلك عندما تشعر وكأنك ترى إلى أين ستتجه الأمور في مرحلة ما، توقف

42
00:02:44,100 --> 00:02:47,180
في تلك اللحظة، وتوقع بشكل فعال ما سيكون عليه المخطط قبل أن أخبرك.

43
00:02:47,180 --> 00:02:51,500
أيضًا، إذا كنت تريد أن يصل فهمك إلى مستوى الأجهزة، فقد قام

44
00:02:51,500 --> 00:02:55,160
Ben Eater بإنشاء مقطع فيديو بالتزامن مع هذا الفيديو يوضح لك كيفية

45
00:02:55,160 --> 00:02:59,520
تنفيذ رموز Hamming فعليًا على لوحات التجارب، وهو أمر مرضٍ للغاية.

46
00:02:59,520 --> 00:03:03,120
يجب أن تعلم أن رموز هامينج لا تُستخدم على نطاق واسع مثل الرموز الأكثر

47
00:03:03,120 --> 00:03:08,040
حداثة، مثل خوارزمية ريد-سولومون، ولكن هناك سحرًا معينًا في التناقض بين مدى استحالة

48
00:03:08,040 --> 00:03:14,240
هذه المهمة في البداية، وكيف تبدو معقولة تمامًا مرة واحدة تتعلم عن هامينج.

49
00:03:14,240 --> 00:03:19,080
المبدأ الأساسي لتصحيح الأخطاء هو أنه في مساحة واسعة من جميع

50
00:03:19,300 --> 00:03:22,860
الرسائل المحتملة، سيتم اعتبار بعض المجموعات الفرعية فقط رسائل صالحة.

51
00:03:22,860 --> 00:03:29,100
على سبيل القياس، فكر في الكلمات المكتوبة بشكل صحيح مقابل الكلمات المكتوبة بشكل غير صحيح.

52
00:03:29,100 --> 00:03:33,340
عندما يتم تغيير رسالة صالحة، يكون المتلقي مسؤولاً عن تصحيح ما

53
00:03:33,340 --> 00:03:38,380
يراه إلى أقرب جار صالح، كما قد تفعل مع خطأ مطبعي.

54
00:03:38,380 --> 00:03:43,100
ومع ذلك، فإن التوصل إلى خوارزمية ملموسة لتصنيف مثل

55
00:03:43,100 --> 00:03:47,160
هذه الرسائل بكفاءة يتطلب قدرًا معينًا من الذكاء.

56
00:03:47,160 --> 00:03:52,060
تبدأ القصة في الأربعينيات من القرن العشرين، عندما كان الشاب ريتشارد هامينج يعمل

57
00:03:52,060 --> 00:03:55,900
في مختبرات بيل، وكانت بعض أعماله تتضمن استخدام كمبيوتر كبير الحجم ومكلف

58
00:03:55,900 --> 00:03:57,420
للغاية يعمل بنظام البطاقة المثقبة، ولم يكن لديه سوى وصول محدود إليه.

59
00:03:57,420 --> 00:04:01,200
والبرامج التي ظل يطبقها ظلت تفشل، لأنه بين

60
00:04:01,200 --> 00:04:03,140
الحين والآخر سيتم إساءة قراءة جزء منها.

61
00:04:03,140 --> 00:04:07,140
نظرًا لأن الإحباط هو بوتقة الاختراع، فقد سئم كثيرًا

62
00:04:07,140 --> 00:04:09,280
لدرجة أنه اخترع أول رمز لتصحيح الأخطاء في العالم.

63
00:04:09,280 --> 00:04:13,020
هناك العديد من الطرق المختلفة لتأطير رموز هامينج، ولكن كمرحلة

64
00:04:13,020 --> 00:04:16,620
أولى سنتناول الأمر بالطريقة التي فكر بها هامينج نفسه.

65
00:04:16,620 --> 00:04:21,400
دعونا نستخدم مثالاً بسيطًا، ولكن ليس بسيطًا للغاية، وهو كتلة مكونة من 16 بت.

66
00:04:21,400 --> 00:04:25,700
سنقوم بترقيم مواضع هذه البتات من 0 إلى 15.

67
00:04:25,700 --> 00:04:30,520
البيانات الفعلية التي نريد تخزينها ستشكل 12 بتًا فقط من هذه

68
00:04:30,520 --> 00:04:33,920
البتات، في حين يتم حجز 4 مواضع كنوع من التكرار.

69
00:04:33,920 --> 00:04:38,120
كلمة زائدة عن الحاجة هنا لا تعني ببساطة النسخ، ففي نهاية المطاف،

70
00:04:38,120 --> 00:04:40,200
هذه البتات الأربعة لا تمنحنا مساحة كافية لنسخ البيانات بشكل أعمى.

71
00:04:40,200 --> 00:04:44,880
وبدلاً من ذلك، سيحتاجون إلى نوع أكثر دقة وذكاءً من

72
00:04:44,880 --> 00:04:48,740
التكرار، وليس إضافة أي معلومات جديدة، ولكن إضافة المرونة.

73
00:04:48,740 --> 00:04:52,620
قد تتوقع أن تأتي هذه القطع الأربعة الخاصة مجمعة بشكل جيد معًا،

74
00:04:52,620 --> 00:04:56,400
ربما في النهاية أو شيء من هذا القبيل، ولكن كما سترى، فإن

75
00:04:56,400 --> 00:05:00,320
وضعها في مواضع تمثل قوى 2 يسمح بشيء أنيق حقًا في النهاية.

76
00:05:00,320 --> 00:05:05,420
قد يمنحك أيضًا تلميحًا بسيطًا حول كيفية قياس هذا للكتل الأكبر حجمًا.

77
00:05:05,420 --> 00:05:09,220
ومن الناحية الفنية أيضًا، سينتهي الأمر بـ 11 بتًا فقط من البيانات، وستجد أن هناك

78
00:05:09,220 --> 00:05:14,260
فارقًا بسيطًا لما يحدث في الموضع 0، لكن لا تقلق بشأن ذلك في الوقت الحالي.

79
00:05:14,280 --> 00:05:18,640
مثل أي خوارزمية لتصحيح الأخطاء، سيتضمن ذلك لاعبين، مرسل

80
00:05:18,640 --> 00:05:23,200
مسؤول عن تعيين هذه البتات الأربعة الخاصة، ومتلقي مسؤول

81
00:05:23,200 --> 00:05:26,360
عن إجراء نوع ما من الفحص وتصحيح الأخطاء.

82
00:05:26,360 --> 00:05:30,040
بالطبع، تشير كلمتا المرسل والمستقبل إلى الأجهزة أو البرامج

83
00:05:30,040 --> 00:05:34,040
التي تقوم بجميع عمليات التحقق، والمقصود بفكرة الرسالة على

84
00:05:34,040 --> 00:05:35,480
نطاق واسع جدًا، هو تضمين أشياء مثل التخزين.

85
00:05:35,480 --> 00:05:39,320
ففي نهاية المطاف، تخزين البيانات هو نفس إرسال رسالة من

86
00:05:39,320 --> 00:05:42,640
الماضي إلى المستقبل بدلاً من إرسالها من مكان إلى آخر.

87
00:05:42,640 --> 00:05:46,700
إذن هذا هو الإعداد، ولكن قبل أن نتمكن من التعمق في الأمر، نحتاج

88
00:05:46,700 --> 00:05:51,080
إلى التحدث عن فكرة ذات صلة كانت جديدة في ذهن هامينج في

89
00:05:51,080 --> 00:05:55,520
وقت اكتشافه، وهي طريقة تتيح لك اكتشاف أي أخطاء في البتات، ولكن

90
00:05:55,520 --> 00:05:57,300
ليس تصحيحها، كما هو معروف. في الأعمال التجارية باعتبارها التحقق من التكافؤ.

91
00:05:57,300 --> 00:06:01,300
للتحقق من التكافؤ، نقوم بفصل بت واحد فقط يكون

92
00:06:01,300 --> 00:06:04,940
المرسل مسؤولاً عن ضبطه، والباقي أحرار في حمل الرسالة.

93
00:06:04,940 --> 00:06:10,380
الوظيفة الوحيدة لهذا البت الخاص هي التأكد من أن

94
00:06:10,380 --> 00:06:12,100
العدد الإجمالي للآحاد في الرسالة هو رقم زوجي.

95
00:06:12,100 --> 00:06:16,920
على سبيل المثال، في الوقت الحالي، إجمالي عدد الآحاد هو 7، وهذا أمر غريب،

96
00:06:16,920 --> 00:06:20,960
لذلك يحتاج المرسل إلى قلب هذا البت الخاص ليصبح 1، مما يجعل العدد متساويًا.

97
00:06:20,960 --> 00:06:25,320
ولكن إذا كانت الكتلة قد بدأت بالفعل بعدد زوجي

98
00:06:25,320 --> 00:06:27,480
من 1، فسيتم الاحتفاظ بهذا البت الخاص عند 0.

99
00:06:27,480 --> 00:06:31,640
هذا أمر بسيط جدًا، وبسيط بشكل خادع، ولكنه طريقة أنيقة للغاية لاستخلاص فكرة

100
00:06:31,640 --> 00:06:37,760
التغيير في أي مكان في الرسالة لتنعكس في جزء واحد من المعلومات.

101
00:06:37,760 --> 00:06:43,680
لاحظ أنه إذا تم قلب أي جزء من هذه الرسالة، إما من 0 إلى 1

102
00:06:43,680 --> 00:06:48,140
أو من 1 إلى 0، فإنه يغير العدد الإجمالي للآحاد من زوجي إلى فردي.

103
00:06:48,140 --> 00:06:52,000
لذلك، إذا كنت المتلقي، ونظرت إلى هذه الرسالة، ورأيت عددًا فرديًا

104
00:06:52,000 --> 00:06:56,580
من 1، فيمكنك التأكد من حدوث خطأ ما، على الرغم من

105
00:06:56,580 --> 00:06:58,700
أنه قد لا يكون لديك أي فكرة عن مكان حدوثه.

106
00:06:58,700 --> 00:07:02,820
في المصطلحات، يُعرف ما إذا كانت مجموعة البتات تحتوي

107
00:07:02,820 --> 00:07:04,940
على عدد زوجي أو فردي من 1 باسم التكافؤ.

108
00:07:04,940 --> 00:07:09,140
يمكنك أيضًا استخدام الأرقام والقول إن التكافؤ هو 0 أو 1، وهو ما

109
00:07:09,140 --> 00:07:11,320
يكون أكثر فائدة عادةً بمجرد البدء في إجراء العمليات الحسابية باستخدام هذه الفكرة.

110
00:07:11,320 --> 00:07:15,200
وهذه البتة الخاصة التي يستخدمها المرسل

111
00:07:15,200 --> 00:07:18,020
للتحكم في التكافؤ تسمى بت التكافؤ.

112
00:07:18,020 --> 00:07:22,460
وفي الواقع، يجب أن نكون واضحين، إذا رأى المتلقي تكافؤًا فرديًا، فهذا لا يعني بالضرورة

113
00:07:22,460 --> 00:07:26,920
أنه كان هناك خطأ واحد فقط، ربما كان هناك 3 أخطاء، أو 5، أو أي

114
00:07:26,920 --> 00:07:29,560
رقم فردي آخر، لكن يمكنهم معرفة ذلك على وجه اليقين أنه لم يكن 0.

115
00:07:29,560 --> 00:07:34,880
من ناحية أخرى، إذا كان هناك خطأين، أو أي عدد زوجي من الأخطاء، فإن

116
00:07:34,880 --> 00:07:39,560
العدد النهائي للأرقام 1 سيظل زوجيًا، لذلك لا يمكن للمستلم أن يكون واثقًا

117
00:07:39,560 --> 00:07:43,360
تمامًا من أن العدد الزوجي يعني بالضرورة أن الرسالة خالية من الأخطاء .

118
00:07:43,360 --> 00:07:47,860
قد تشكو من أن الرسالة التي يتم إفسادها من خلال تقلبات

119
00:07:47,860 --> 00:07:49,760
بمقدار 2 بت فقط تكون ضعيفة جدًا، وستكون على حق تمامًا.

120
00:07:49,760 --> 00:07:54,480
ومع ذلك، ضع في اعتبارك أنه لا توجد طريقة لاكتشاف الأخطاء أو تصحيحها يمكن أن

121
00:07:54,480 --> 00:07:59,720
تمنحك ثقة بنسبة 100% في أن الرسالة التي تتلقاها هي الرسالة التي قصدها المرسل.

122
00:07:59,720 --> 00:08:03,760
بعد كل شيء، يمكن للضوضاء العشوائية الكافية دائمًا تغيير رسالة

123
00:08:03,760 --> 00:08:05,920
صالحة إلى رسالة صالحة أخرى فقط عن طريق الصدفة البحتة.

124
00:08:05,920 --> 00:08:10,520
بدلاً من ذلك، الهدف هو التوصل إلى مخطط قوي يصل إلى حد أقصى

125
00:08:10,520 --> 00:08:16,480
معين من الأخطاء، أو ربما لتقليل احتمالية حدوث نتيجة إيجابية كاذبة مثل هذا.

126
00:08:16,480 --> 00:08:20,940
تعتبر عمليات التحقق من التكافؤ في حد ذاتها ضعيفة جدًا، ولكن من

127
00:08:20,940 --> 00:08:25,640
خلال استخلاص فكرة التغيير عبر رسالة كاملة وصولاً إلى جزء واحد،

128
00:08:25,640 --> 00:08:28,000
فإن ما يقدمونه لنا هو لبنة بناء قوية لمخططات أكثر تعقيدًا.

129
00:08:28,000 --> 00:08:32,880
على سبيل المثال، بينما كان هامينج يبحث عن طريقة لتحديد مكان حدوث الخطأ، وليس

130
00:08:32,880 --> 00:08:37,160
فقط مكان حدوثه، كانت رؤيته الرئيسية هي أنه إذا قمت بتطبيق بعض عمليات التحقق

131
00:08:37,160 --> 00:08:42,040
من التكافؤ ليس على الرسالة الكاملة، ولكن على مجموعات فرعية معينة مختارة بعناية، فيمكنك

132
00:08:42,040 --> 00:08:46,840
أن تسأل سلسلة أكثر دقة من الأسئلة التي تحدد موقع أي خطأ بت واحد.

133
00:08:46,840 --> 00:08:51,280
الشعور العام يشبه إلى حد ما ممارسة لعبة مكونة من 20 سؤالًا، حيث يتم

134
00:08:51,280 --> 00:08:54,300
طرح أسئلة بنعم أو لا مما يؤدي إلى تقطيع مساحة الاحتمالات إلى النصف.

135
00:08:54,300 --> 00:08:58,840
على سبيل المثال، لنفترض أننا قمنا بإجراء فحص التكافؤ على

136
00:08:58,840 --> 00:08:59,840
هذه البتات الثمانية فقط، وجميع المواضع ذات الأرقام الفردية.

137
00:09:00,400 --> 00:09:04,560
ثم إذا تم اكتشاف خطأ، فإنه يمنح المتلقي المزيد من المعلومات

138
00:09:04,560 --> 00:09:09,160
حول مكان الخطأ على وجه التحديد، أي أنه في وضع فردي.

139
00:09:09,160 --> 00:09:14,360
إذا لم يتم اكتشاف أي خطأ بين تلك البتات الثمانية، فهذا يعني إما عدم

140
00:09:14,360 --> 00:09:17,240
وجود خطأ على الإطلاق، أو أنه موجود في مكان ما في المواضع الزوجية.

141
00:09:17,240 --> 00:09:21,560
قد تظن أن قصر فحص التكافؤ على نصف البتات يجعله أقل

142
00:09:21,560 --> 00:09:25,460
فعالية، ولكن عندما يتم إجراؤه بالتزامن مع عمليات فحص أخرى

143
00:09:25,460 --> 00:09:29,720
مختارة جيدًا، فإنه يمنحنا شيئًا أكثر قوة بشكل غير متوقع.

144
00:09:29,720 --> 00:09:34,440
لإعداد فحص التكافؤ هذا، تذكر أنه يتطلب تخصيص

145
00:09:34,440 --> 00:09:37,600
جزء خاص يتحكم في تكافؤ تلك المجموعة الكاملة.

146
00:09:37,600 --> 00:09:39,920
هنا دعونا فقط نختار الموضع 1.

147
00:09:39,920 --> 00:09:43,960
في المثال الموضح، يعد تكافؤ هذه البتات الثمانية أمرًا فرديًا حاليًا، لذا

148
00:09:43,960 --> 00:09:48,220
يكون المرسل مسؤولاً عن تبديل بت التكافؤ هذا، وهو الآن زوجي.

149
00:09:48,220 --> 00:09:51,040
هذه عملية واحدة فقط من أصل 4 عمليات فحص تكافؤ سنجريها.

150
00:09:51,040 --> 00:09:55,560
الفحص الثاني يكون من بين 8 بتات في النصف

151
00:09:55,560 --> 00:09:56,880
الأيمن من الشبكة، على الأقل كما رسمناها هنا.

152
00:09:56,880 --> 00:10:02,520
هذه المرة قد نستخدم الموضع 2 كبت تكافؤ، وبالتالي فإن هذه البتات الثمانية لها بالفعل

153
00:10:02,520 --> 00:10:07,160
تكافؤ متساوي، ويمكن أن يشعر المرسل بالارتياح عند ترك هذا البت رقم 2 دون تغيير.

154
00:10:07,160 --> 00:10:11,040
ومن ثم على الطرف الآخر، إذا تحقق المتلقي من تكافؤ هذه المجموعة ووجد أنه أمر

155
00:10:11,040 --> 00:10:15,960
غريب، فسيعرف أن الخطأ موجود في مكان ما بين هذه البتات الثمانية على اليمين.

156
00:10:15,960 --> 00:10:21,260
وإلا فهذا يعني أنه لا يوجد خطأ، أو أن الخطأ موجود في مكان ما في النصف الأيسر.

157
00:10:21,260 --> 00:10:24,040
أو أعتقد أنه من الممكن أن يكون هناك خطأين، ولكن في الوقت

158
00:10:24,040 --> 00:10:27,080
الحالي سنفترض أن هناك خطأ واحدًا على الأكثر في الكتلة بأكملها.

159
00:10:27,080 --> 00:10:29,160
تنهار الأمور تمامًا لأكثر من ذلك.

160
00:10:29,160 --> 00:10:32,920
هنا، قبل أن ننظر إلى الفحصين التاليين، توقف لحظة للتفكير

161
00:10:32,920 --> 00:10:35,880
فيما يسمح لنا بهذين الاختبارين الأولين عندما تفكر فيهما معًا.

162
00:10:35,880 --> 00:10:40,240
لنفترض أنك اكتشفت خطأ بين الأعمدة الفردية وبين النصف الأيمن.

163
00:10:40,240 --> 00:10:43,940
وهذا يعني بالضرورة أن الخطأ موجود في مكان ما في العمود الأخير.

164
00:10:43,940 --> 00:10:48,280
إذا لم يكن هناك خطأ في العمود الفردي ولكن كان هناك خطأ

165
00:10:48,280 --> 00:10:50,520
في النصف الأيمن، فهذا يخبرك أنه موجود في العمود الثاني قبل الأخير.

166
00:10:50,520 --> 00:10:54,640
وبالمثل، إذا كان هناك خطأ في الأعمدة الفردية ولكن ليس في

167
00:10:54,640 --> 00:10:56,560
النصف الأيمن، فاعلم أنه موجود في مكان ما في العمود الثاني.

168
00:10:56,560 --> 00:11:00,560
وإذا لم يكتشف أي من هذين التحققين من التكافؤ أي شيء، فهذا يعني أن المكان

169
00:11:00,560 --> 00:11:03,760
الوحيد الذي يمكن أن يوجد فيه خطأ هو ذلك العمود الموجود في أقصى اليسار.

170
00:11:03,760 --> 00:11:06,480
ولكنه قد يعني أيضًا أنه لا يوجد خطأ على الإطلاق.

171
00:11:06,480 --> 00:11:10,800
وهي طريقة متقنة إلى حد ما للقول

172
00:11:10,800 --> 00:11:11,800
إن فحصي التكافؤ يسمحان لنا بتحديد العمود.

173
00:11:11,800 --> 00:11:14,000
من هنا، ربما يمكنك تخمين ما يلي.

174
00:11:14,000 --> 00:11:16,240
نحن نفعل نفس الشيء بشكل أساسي ولكن بالنسبة للصفوف.

175
00:11:16,240 --> 00:11:21,040
سيكون هناك فحص للتكافؤ في الصفوف الفردية، باستخدام الموضع 4 كبت تكافؤ.

176
00:11:21,040 --> 00:11:25,480
لذلك في هذا المثال، هذه المجموعة لديها بالفعل تكافؤ

177
00:11:25,480 --> 00:11:26,480
زوجي، لذا سيتم تعيين البت 4 على 0.

178
00:11:26,480 --> 00:11:31,280
وأخيرًا، هناك فحص تكافؤ في الصفين

179
00:11:31,280 --> 00:11:32,280
السفليين، باستخدام الموضع 8 كبت تكافؤ.

180
00:11:32,280 --> 00:11:35,840
في هذه الحالة، يبدو أن المرسل بحاجة إلى تشغيل

181
00:11:35,840 --> 00:11:37,840
هذا البت 8 من أجل منح المجموعة التكافؤ.

182
00:11:37,840 --> 00:11:41,360
تمامًا كما تتيح لنا عمليتا التحقق الأولين تثبيت

183
00:11:41,360 --> 00:11:43,000
العمود، تتيح لك الوظيفتان التاليتان تثبيت الصف.

184
00:11:43,000 --> 00:11:48,400
على سبيل المثال، تخيل أنه أثناء الإرسال، حدث خطأ في الموضع 3 على سبيل المثال.

185
00:11:48,400 --> 00:11:52,620
حسنًا، يؤثر هذا على مجموعة التكافؤ الأولى، ويؤثر أيضًا على مجموعة التكافؤ الثانية،

186
00:11:52,620 --> 00:11:56,340
لذلك يعرف المتلقي أن هناك خطأ في مكان ما في هذا العمود الأيمن.

187
00:11:56,340 --> 00:12:01,380
لكنه لا يؤثر على المجموعة الثالثة، ولا يؤثر على المجموعة الرابعة.

188
00:12:01,380 --> 00:12:05,460
وهذا يتيح للمتلقي تحديد الخطأ حتى الصف الأول، وهو ما

189
00:12:05,460 --> 00:12:08,660
يعني بالضرورة الموضع 3، حتى يتمكنوا من إصلاح الخطأ.

190
00:12:08,660 --> 00:12:12,640
قد تستمتع بتخصيص بعض الوقت لإقناع نفسك بأن الإجابات على هذه الأسئلة

191
00:12:12,680 --> 00:12:17,320
الأربعة ستسمح لك دائمًا بتحديد موقع معين، بغض النظر عن مكان تواجدهم.

192
00:12:17,320 --> 00:12:22,640
في الواقع، قد يلاحظ الأذكياء بينكم وجود

193
00:12:22,640 --> 00:12:23,640
صلة بين هذه الأسئلة والعد الثنائي.

194
00:12:23,640 --> 00:12:27,840
وإذا قمت بذلك، دعني أؤكد مرة أخرى، توقف مؤقتًا،

195
00:12:27,840 --> 00:12:30,880
حاول بنفسك أن ترسم الارتباط قبل أن أفسده.

196
00:12:30,880 --> 00:12:35,560
إذا كنت تتساءل عما يحدث إذا تأثرت

197
00:12:35,560 --> 00:12:36,560
بتة التكافؤ نفسها، حسنًا، يمكنك تجربتها فقط.

198
00:12:36,560 --> 00:12:40,720
خذ لحظة للتفكير في كيفية تعقب أي خطأ بين هذه الأجزاء الأربعة الخاصة

199
00:12:40,720 --> 00:12:47,440
تمامًا مثل أي خطأ آخر، مع نفس المجموعة المكونة من أربعة أسئلة.

200
00:12:47,440 --> 00:12:50,500
لا يهم حقًا، نظرًا لأن ما نريده في نهاية المطاف هو

201
00:12:50,500 --> 00:12:53,640
حماية أجزاء الرسالة، فإن وحدات بت تصحيح الأخطاء هي التي تستمر.

202
00:12:53,640 --> 00:12:57,120
لكن حماية تلك البتات أيضًا هو أمر

203
00:12:57,120 --> 00:12:59,260
يخرج بشكل طبيعي عن المخطط كمنتج ثانوي.

204
00:12:59,260 --> 00:13:02,380
قد تستمتع أيضًا بتوقع كيفية قياس هذا الأمر.

205
00:13:02,380 --> 00:13:08,040
إذا استخدمنا كتلة بحجم 256 بت، على سبيل المثال، لتحديد موقع ما، فأنت تحتاج

206
00:13:08,040 --> 00:13:15,680
فقط إلى ثمانية أسئلة بنعم أو لا للبحث الثنائي في طريقك إلى مكان محدد.

207
00:13:15,680 --> 00:13:19,680
وتذكر أن كل سؤال يتطلب التخلي عن جزء

208
00:13:19,680 --> 00:13:23,340
واحد فقط لتعيين التحقق من التكافؤ المناسب.

209
00:13:23,340 --> 00:13:26,960
ربما يراها البعض منكم بالفعل، لكننا سنتحدث لاحقًا عن الطريقة

210
00:13:26,960 --> 00:13:29,960
المنهجية للعثور على هذه الأسئلة في دقيقة أو دقيقتين فقط.

211
00:13:29,960 --> 00:13:33,440
نأمل أن يكون هذا المخطط كافيًا

212
00:13:33,440 --> 00:13:34,440
لتقدير كفاءة ما نقوم بتطويره هنا.

213
00:13:34,440 --> 00:13:38,440
أول شيء، باستثناء تلك البتات الثمانية المتماثلة المميزة، يمكن أن

214
00:13:38,440 --> 00:13:41,720
تكون كما تريد، وتحمل أي رسالة أو بيانات تريدها.

215
00:13:41,720 --> 00:13:45,480
تعتبر البتات الثمانية زائدة عن الحاجة، بمعنى أنه يتم تحديدها بالكامل من

216
00:13:45,480 --> 00:13:53,640
خلال بقية الرسالة، ولكنها بطريقة أكثر ذكاءً من مجرد نسخ الرسالة ككل.

217
00:13:53,640 --> 00:13:58,000
ومع ذلك، مقابل القليل جدًا من الاستسلام، ستكون

218
00:13:58,000 --> 00:13:59,000
قادرًا على تحديد وإصلاح أي خطأ في البتات.

219
00:13:59,000 --> 00:14:00,400
حسنًا تقريبًا.

220
00:14:00,400 --> 00:14:05,920
حسنًا، المشكلة الوحيدة هنا هي أنه إذا لم تكتشف أي من عمليات التحقق من

221
00:14:05,920 --> 00:14:10,240
التكافؤ وجود خطأ، مما يعني أن المجموعات الفرعية المحددة خصيصًا والمكونة من 8

222
00:14:10,240 --> 00:14:15,520
بتات جميعها لها تماثلات زوجية، تمامًا كما قصد المرسل، فهذا يعني إما أنه

223
00:14:15,520 --> 00:14:17,760
لم يكن هناك خطأ على الإطلاق أو أنه يضيق بنا إلى الموضع 0.

224
00:14:17,760 --> 00:14:23,040
كما ترى، مع أربعة أسئلة بنعم أو لا، لدينا 16 نتيجة محتملة لعمليات التحقق من

225
00:14:23,040 --> 00:14:28,000
التكافؤ، وفي البداية يبدو ذلك مثاليًا لتحديد موضع واحد من أصل 16 موضعًا في

226
00:14:28,000 --> 00:14:33,000
الكتلة، ولكنك تحتاج أيضًا إلى توصيل النتيجة السابعة عشرة، وهي عدم وجود خطأ حالة.

227
00:14:33,000 --> 00:14:37,860
الحل هنا بسيط جدًا في الواقع، فقط انسَ هذا الجزء 0 تمامًا.

228
00:14:37,860 --> 00:14:41,920
لذلك عندما نقوم بعمليات التحقق من التكافؤ الأربعة ونرى أنها كلها

229
00:14:41,920 --> 00:14:44,320
متساوية، فهذا يعني بشكل لا لبس فيه أنه لا يوجد خطأ.

230
00:14:44,320 --> 00:14:49,240
ما يعنيه ذلك هو أنه بدلًا من العمل مع كتلة مكونة من 16 بت، فإننا نعمل مع

231
00:14:49,240 --> 00:14:54,040
كتلة مكونة من 15 بت، حيث يكون 11 بتًا مجانيًا لحمل رسالة و4 بتات منها للتكرار.

232
00:14:54,080 --> 00:14:58,400
وبهذا، أصبح لدينا الآن ما يشير إليه

233
00:14:58,400 --> 00:14:59,400
الأشخاص في هذا المجال برمز هامينغ 15-11.

234
00:14:59,400 --> 00:15:03,920
ومع ذلك، من الجيد أن يكون لدينا حجم كتلة يساوي قوة نظيفة تبلغ 2، وهناك

235
00:15:03,920 --> 00:15:08,880
طريقة ذكية يمكننا من خلالها الاحتفاظ بهذا الجزء الصفري وجعله يقوم ببعض العمل الإضافي لنا.

236
00:15:08,880 --> 00:15:13,600
إذا استخدمناها كبتة تكافؤ عبر الكتلة بأكملها، فإنها تتيح لنا بالفعل

237
00:15:13,600 --> 00:15:16,320
اكتشاف أخطاء 2 بت، على الرغم من أننا لا نستطيع تصحيحها.

238
00:15:16,320 --> 00:15:17,440
وإليك كيف يعمل.

239
00:15:17,440 --> 00:15:21,740
بعد تعيين تلك البتات الأربعة الخاصة لتصحيح الأخطاء، قمنا بتعيين البت 0

240
00:15:21,740 --> 00:15:25,540
بحيث يكون تكافؤ الكتلة الكاملة متساويًا، تمامًا مثل فحص التكافؤ العادي.

241
00:15:25,540 --> 00:15:29,780
الآن، إذا كان هناك خطأ بت واحد، فإن تكافؤ الكتلة الكاملة يصبح غريبًا،

242
00:15:29,780 --> 00:15:33,940
لكننا سنكتشف ذلك على أي حال بفضل عمليات التحقق الأربعة من تصحيح الأخطاء.

243
00:15:33,940 --> 00:15:38,100
ومع ذلك، إذا كان هناك خطأان، فسيتم تبديل التكافؤ الإجمالي مرة أخرى

244
00:15:38,100 --> 00:15:42,660
إلى كونه متساويًا، لكن المتلقي سيظل يرى أن هناك على الأقل

245
00:15:42,660 --> 00:15:45,820
بعض الأخطاء بسبب ما يحدث مع عمليات التحقق من التكافؤ الأربعة.

246
00:15:45,820 --> 00:15:49,780
لذا، إذا لاحظوا تكافؤًا متساويًا بشكل عام، ولكن حدث شيء غير

247
00:15:49,820 --> 00:15:52,980
صفري مع عمليات التحقق الأخرى، فهذا يخبرهم بوجود خطأين على الأقل.

248
00:15:52,980 --> 00:15:54,420
أليس هذا ذكيا؟

249
00:15:54,420 --> 00:15:58,500
على الرغم من أننا لا نستطيع تصحيح تلك الأخطاء ذات البتتين، إلا أنه

250
00:15:58,500 --> 00:16:02,340
بمجرد إعادة البتة الصفرية المزعجة هذه إلى العمل، فإنها تتيح لنا اكتشافها.

251
00:16:02,340 --> 00:16:06,540
يعد هذا أمرًا قياسيًا جدًا، ويُعرف باسم كود هامينج الممتد.

252
00:16:06,540 --> 00:16:10,860
من الناحية الفنية، لديك الآن وصف كامل لما تفعله

253
00:16:10,860 --> 00:16:13,580
كود هامينج، على الأقل بالنسبة لمثال كتلة 16 بت.

254
00:16:13,580 --> 00:16:17,300
لكنني أعتقد أنك ستجد الأمر أكثر إرضاءً للتحقق من فهمك وترسيخ كل شيء حتى

255
00:16:17,300 --> 00:16:21,980
هذه النقطة من خلال القيام بمثال واحد كامل من البداية إلى النهاية بنفسك.

256
00:16:21,980 --> 00:16:25,100
سأقوم بالخطوات معك حتى تتمكن من التحقق بنفسك.

257
00:16:25,100 --> 00:16:29,180
لإعداد رسالة، سواء كانت رسالة حرفية تترجمها عبر مساحة

258
00:16:29,180 --> 00:16:34,100
أو بعض البيانات التي تريد تخزينها مع مرور الوقت،

259
00:16:34,100 --> 00:16:35,700
فإن الخطوة الأولى هي تقسيمها إلى أجزاء 11 بت.

260
00:16:35,700 --> 00:16:40,340
سيتم تجميع كل قطعة في كتلة 16 بت مقاومة للأخطاء.

261
00:16:40,340 --> 00:16:43,740
لذلك دعونا نأخذ هذا كمثال ونعمل عليه بالفعل.

262
00:16:43,740 --> 00:16:45,340
المضي قدما، في الواقع القيام بذلك!

263
00:16:45,380 --> 00:16:47,380
دعونا نتوقف مؤقتًا ونحاول تجميع هذه الكتلة معًا.

264
00:16:52,980 --> 00:16:53,980
حسنًا، هل أنت مستعد؟

265
00:16:53,980 --> 00:16:58,500
تذكر أن الموضع 0 إلى جانب القوى الأخرى للرقم 2 محجوزة لمهمة تصحيح

266
00:16:58,500 --> 00:17:05,700
الأخطاء، لذا عليك أن تبدأ بوضع بتات الرسالة في جميع الأماكن المتبقية بالترتيب.

267
00:17:05,700 --> 00:17:09,700
أنت بحاجة إلى أن يكون لهذه المجموعة تكافؤ متساوي، وهو ما يحدث بالفعل،

268
00:17:09,700 --> 00:17:13,140
لذا يجب عليك تعيين بت التكافؤ هذا في الموضع 1 ليكون 0.

269
00:17:13,140 --> 00:17:17,700
تبدأ المجموعة التالية بتعادل فردي، لذا يجب عليك

270
00:17:17,700 --> 00:17:19,260
تعيين بت التكافؤ الخاص بها ليكون 1.

271
00:17:19,260 --> 00:17:23,740
تبدأ المجموعة بعد ذلك بتكافؤ فردي، لذلك يجب عليك

272
00:17:23,740 --> 00:17:24,740
مرة أخرى ضبط بت التكافؤ الخاص بها على 1.

273
00:17:24,740 --> 00:17:29,500
والمجموعة الأخيرة لديها أيضًا تكافؤ فردي، مما يعني أننا

274
00:17:29,500 --> 00:17:31,500
وضعنا هذا الجزء في الموضع 8 ليكون 1.

275
00:17:31,500 --> 00:17:36,460
وبعد ذلك كخطوة أخيرة، أصبح للكتلة الكاملة الآن تكافؤ متساوي، مما يعني

276
00:17:36,460 --> 00:17:41,500
أنه يمكنك تعيين رقم البت 0، وهو بت التكافؤ الشامل، ليكون 0.

277
00:17:41,500 --> 00:17:45,660
لذلك عندما يتم إرسال هذه الكتلة، فإن التكافؤ بين المجموعات

278
00:17:45,660 --> 00:17:48,980
الفرعية الأربع الخاصة والكتلة ككل سيكون متساويًا، أو 0.

279
00:17:48,980 --> 00:17:53,620
في الجزء الثاني من التمرين، لنجعلك تلعب دور المتلقي.

280
00:17:53,620 --> 00:17:57,580
بالطبع، هذا يعني أنك لا تعرف بالفعل ما هي هذه الرسالة،

281
00:17:57,580 --> 00:18:00,180
ربما البعض منكم يحفظها، ولكن لنفترض أنك لم تفعل ذلك.

282
00:18:00,180 --> 00:18:05,820
ما سأفعله هو تغيير إما 0 أو 1 أو 2 من

283
00:18:05,820 --> 00:18:08,340
البتات في تلك الكتلة، ثم أطلب منك معرفة ما فعلته.

284
00:18:08,340 --> 00:18:13,460
لذا مرة أخرى، توقف مؤقتًا وحاول حلها.

285
00:18:13,460 --> 00:18:23,960
حسنًا، أنت الآن كمستلم تتحقق من مجموعة التكافؤ الأولى ويمكنك أن ترى أنها

286
00:18:23,960 --> 00:18:29,820
زوجية، لذا فإن أي خطأ موجود يجب أن يكون في عمود زوجي.

287
00:18:29,820 --> 00:18:34,620
الفحص التالي يعطينا رقمًا فرديًا، ويخبرنا بوجود خطأ واحد

288
00:18:34,620 --> 00:18:38,760
على الأقل، ويضيق نطاقنا في هذا العمود المحدد.

289
00:18:38,760 --> 00:18:42,900
الفحص الثالث متساوي، مما يقلل من الاحتمالات بشكل أكبر.

290
00:18:42,900 --> 00:18:46,780
وآخر فحص للتكافؤ أمر غريب، حيث يخبرنا بوجود خطأ في مكان ما في الأسفل،

291
00:18:46,780 --> 00:18:51,700
والذي يمكننا الآن أن نرى أنه يجب أن يكون في الموضع رقم 10.

292
00:18:51,700 --> 00:18:56,140
علاوة على ذلك، فإن تكافؤ الكتلة بأكملها أمر غريب،

293
00:18:56,140 --> 00:18:58,220
مما يمنحنا الثقة في وجود قلب واحد وليس اثنين.

294
00:18:58,220 --> 00:19:01,600
إذا كان هناك ثلاثة أو أكثر، كل الرهانات ملغاة.

295
00:19:01,600 --> 00:19:06,520
بعد تصحيح البت رقم 10، فإن سحب البتات الـ 11 التي لم

296
00:19:06,520 --> 00:19:11,620
يتم استخدامها للتصحيح يعطينا الجزء ذي الصلة من الرسالة الأصلية، والذي

297
00:19:11,620 --> 00:19:16,160
إذا قمت بالترجيع والمقارنة فهو في الواقع ما بدأنا به المثال.

298
00:19:16,160 --> 00:19:19,260
والآن بعد أن عرفت كيفية القيام بكل هذا يدويًا، أود أن أوضح لك كيف

299
00:19:19,260 --> 00:19:23,940
يمكنك تنفيذ الجزء الأساسي من كل هذا المنطق باستخدام سطر واحد من كود بايثون.

300
00:19:23,940 --> 00:19:28,400
كما ترى، ما لم أخبرك به بعد هو مدى أناقة هذه

301
00:19:28,400 --> 00:19:32,380
الخوارزمية حقًا، ومدى بساطة جعل الآلة تشير إلى موضع الخطأ،

302
00:19:32,380 --> 00:19:37,680
وكيفية قياسه بشكل منهجي، وكيف يمكننا تأطير كل ذلك هذا

303
00:19:37,680 --> 00:19:39,580
كعملية واحدة بدلاً من عمليات التحقق من التكافؤ المنفصلة المتعددة.

304
00:19:39,580 --> 00:19:41,680
لتعرف ما أعنيه، تعال وانضم إلي في الجزء الثاني.

