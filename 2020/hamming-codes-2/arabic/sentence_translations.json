[
 {
  "input": "I'm assuming that everybody here is coming from part 1. ",
  "translatedText": "أفترض أن الجميع هنا قادمون من الجزء الأول. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 0.0,
  "end": 2.56
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it. ",
  "translatedText": "كنا نتحدث عن رموز هامينج، وهي طريقة لإنشاء كتلة من البيانات حيث تحمل معظم البتات رسالة ذات معنى، بينما يعمل عدد قليل آخر كنوع من التكرار، بطريقة بحيث إذا تم قلب أي جزء، إما رسالة بت أو بت متكرر، أي شيء في هذه الكتلة، سيكون جهاز الاستقبال قادرًا على تحديد وجود خطأ، وكيفية إصلاحه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.06,
  "end": 21.24
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error. ",
  "translatedText": "كانت الفكرة الأساسية المقدمة هناك هي كيفية استخدام عمليات التحقق من التكافؤ المتعددة للبحث الثنائي في طريقك إلى الخطأ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 21.88,
  "end": 27.16
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible. ",
  "translatedText": "كان الهدف في هذا الفيديو هو جعل رموز هامينج تبدو عملية وقابلة لإعادة الاكتشاف قدر الإمكان. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 28.98,
  "end": 34.6
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are. ",
  "translatedText": "ولكن عندما تبدأ في التفكير في تنفيذ هذا فعليًا، سواء في البرامج أو الأجهزة، فإن هذا الإطار قد يقلل في الواقع من مدى أناقة هذه الرموز حقًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 35.18,
  "end": 43.46
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that. ",
  "translatedText": "قد تظن أنك بحاجة إلى كتابة خوارزمية تتتبع جميع مواقع الأخطاء المحتملة وتقطع تلك المجموعة إلى النصف مع كل عملية تحقق، ولكنها في الواقع أبسط من ذلك بكثير. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 43.92,
  "end": 53.48
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary. ",
  "translatedText": "إذا قرأت الإجابات على عمليات التحقق من التكافؤ الأربعة التي قمنا بها في الفيديو الأخير، كلها كـ 1 و0 بدلاً من نعم ولا، فإنها توضح حرفيًا موضع الخطأ في النظام الثنائي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 53.94,
  "end": 64.08
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1. ",
  "translatedText": "على سبيل المثال، الرقم 7 في النظام الثنائي يبدو مثل 0111، مما يعني أنه 4 زائد 2 زائد 1. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 64.78,
  "end": 71.26
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last. ",
  "translatedText": "ولاحظ أين يقع الموضع 7، فهو يؤثر بالفعل على المجموعة الأولى من مجموعات التكافؤ، والثانية، والثالثة، ولكن ليس الأخيرة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 72.54,
  "end": 81.74
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error. ",
  "translatedText": "لذا فإن قراءة نتائج عمليات التحقق الأربعة هذه من الأسفل إلى الأعلى توضح بالفعل موضع الخطأ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 82.22,
  "end": 87.54
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple. ",
  "translatedText": "لا يوجد شيء خاص في المثال 7، وهذا يعمل بشكل عام، وهذا يجعل منطق تنفيذ المخطط بأكمله في الأجهزة بسيطًا بشكل صادم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 88.32,
  "end": 95.82
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111. ",
  "translatedText": "الآن إذا كنت تريد معرفة سبب حدوث هذا السحر، فخذ تسميات الفهرس الستة عشر هذه لمواقعنا، ولكن بدلاً من كتابتها في الأساس 10، دعنا نكتبها جميعًا بالنظام الثنائي، بدءًا من 0000 حتى 1111. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 97.24,
  "end": 109.88
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent. ",
  "translatedText": "عندما نعيد هذه التصنيفات الثنائية إلى صناديقها، اسمحوا لي أن أؤكد أنها مختلفة عن البيانات التي يتم إرسالها بالفعل. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 110.56,
  "end": 117.8
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from. ",
  "translatedText": "إنها ليست أكثر من مجرد تسمية مفاهيمية لمساعدتي ومساعدتك في فهم من أين أتت مجموعات التكافؤ الأربع. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 118.32,
  "end": 123.5
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary. ",
  "translatedText": "ربما يتم تقويض أناقة الحصول على كل ما نتطلع إليه موصوفًا في النظام الثنائي بسبب الارتباك المتمثل في وجود كل ما نتطلع إليه موصوفًا في النظام الثنائي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 124.14,
  "end": 132.36
 },
 {
  "input": "It's worth it, though. ",
  "translatedText": "إنه يستحق ذلك، على الرغم من ذلك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.02,
  "end": 134.12
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1. ",
  "translatedText": "ركز انتباهك فقط على الجزء الأخير من كل هذه التسميات، ثم قم بتسليط الضوء على المواضع التي يكون فيها الجزء الأخير هو 1. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 134.8,
  "end": 143.22
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1? ",
  "translatedText": "ما حصلنا عليه هو المجموعة الأولى من مجموعات التكافؤ الأربع لدينا، مما يعني أنه يمكنك تفسير هذا التحقق الأول على أنه يسأل، إذا كان هناك خطأ، فهل البت الأخير في موضع هذا الخطأ هو 1؟ ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 144.24,
  "end": 155.74
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme. ",
  "translatedText": "وبالمثل، إذا ركزت على الجزء الثاني قبل الأخير، وقمت بتمييز جميع المواضع التي يكون فيها الرقم 1، فستحصل على مجموعة التكافؤ الثانية من مخططنا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 158.2,
  "end": 166.16
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1? ",
  "translatedText": "بمعنى آخر، هذا الفحص الثاني يسألني مرة أخرى، إذا كان هناك خطأ، فهل الجزء الثاني قبل الأخير من هذا الموضع هو 1؟ ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 166.74,
  "end": 174.5
 },
 {
  "input": "And so on. ",
  "translatedText": "وما إلى ذلك وهلم جرا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 175.76,
  "end": 176.9
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1. ",
  "translatedText": "يغطي فحص التكافؤ الثالث كل موضع تم تشغيل البت من الثالث إلى الأخير، ويغطي الأخير المواضع الثمانية الأخيرة، تلك التي يكون أعلى بت لها هو 1. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 177.22,
  "end": 188.74
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary. ",
  "translatedText": "كل ما فعلناه سابقًا هو نفس الإجابة على هذه الأسئلة الأربعة، والتي بدورها هي نفس توضيح الموضع في النظام الثنائي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 189.74,
  "end": 197.74
 },
 {
  "input": "I hope this makes two things clearer. ",
  "translatedText": "آمل أن يجعل هذا شيئين أكثر وضوحا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 199.62,
  "end": 201.48
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two. ",
  "translatedText": "الأول هو كيفية التعميم بشكل منهجي على أحجام الكتل التي تكون أكبر من قوى اثنين. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.04,
  "end": 206.46
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check. ",
  "translatedText": "إذا كان الأمر يتطلب المزيد من البتات لوصف كل موضع، مثل ستة بتات لوصف 64 نقطة، فإن كل واحدة من هذه البتات تمنحك إحدى مجموعات التكافؤ التي نحتاج إلى التحقق منها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 206.96,
  "end": 216.68
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar. ",
  "translatedText": "أولئك منكم الذين شاهدوا لغز رقعة الشطرنج الذي قمت به مع مات باركر قد يجدون كل هذا مألوفًا للغاية. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.4,
  "end": 223.18
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard. ",
  "translatedText": "إنه نفس المنطق الأساسي، لكنه يحل مشكلة مختلفة، ويتم تطبيقه على رقعة شطرنج مكونة من 64 مربعًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 223.66,
  "end": 228.78
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8. ",
  "translatedText": "الأمر الثاني الذي آمل أن يوضحه هذا هو سبب وجود بتات التكافؤ لدينا في مواضع تمثل قوى العدد اثنين، على سبيل المثال 1 و2 و4 و8. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 229.88,
  "end": 237.32
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on. ",
  "translatedText": "هذه هي المواضع التي تم تشغيل تمثيلها الثنائي بمقدار بت واحد فقط. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 238.0,
  "end": 243.0
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups. ",
  "translatedText": "ما يعنيه ذلك هو أن كل واحدة من بتات التكافؤ هذه تقع داخل مجموعة واحدة فقط من مجموعات التكافؤ الأربع. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.6,
  "end": 249.46
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups. ",
  "translatedText": "يمكنك أيضًا رؤية ذلك في أمثلة أكبر، حيث بغض النظر عن حجمها، فإن كل بتة تكافؤ تلامس بسهولة مجموعة واحدة فقط من المجموعات. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 252.04,
  "end": 259.34
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code. ",
  "translatedText": "بمجرد أن تفهم أن عمليات التحقق من التكافؤ هذه التي ركزنا عليها كثيرًا من وقتنا ليست أكثر من طريقة ذكية لتوضيح موضع الخطأ في النظام الثنائي، فيمكننا بعد ذلك رسم اتصال بطريقة مختلفة للتفكير في الهام الرموز، التي يمكن القول إنها أبسط بكثير وأكثر أناقة، والتي يمكن كتابتها أساسًا باستخدام سطر واحد من التعليمات البرمجية. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.6,
  "end": 283.24
 },
 {
  "input": "It's based on the XOR function. ",
  "translatedText": "يعتمد على وظيفة XOR. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 283.66,
  "end": 285.5
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or. ",
  "translatedText": "XOR، لأولئك منكم الذين لا يعرفون، يرمز إلى حصري أو. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 286.94,
  "end": 290.22
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off. ",
  "translatedText": "عندما تأخذ XOR لبتين، فسوف يُرجع 1 إذا تم تشغيل أي من تلك البتات، ولكن ليس إذا تم تشغيل كليهما أو إيقاف تشغيلهما. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 290.78,
  "end": 299.36
 },
 {
  "input": "Phrased differently, it's the parity of these two bits. ",
  "translatedText": "بصياغة مختلفة، إنه التكافؤ بين هاتين القطعتين. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.1,
  "end": 302.98
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2. ",
  "translatedText": "باعتباري متخصصًا في الرياضيات، أفضّل التفكير في الأمر على أنه تعديل الإضافة 2. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 303.54,
  "end": 306.76
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component. ",
  "translatedText": "نتحدث أيضًا بشكل شائع عن XOR لسلسلتين مختلفتين من البتات، والتي تقوم بشكل أساسي بتنفيذ هذا المكون تلو الآخر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 307.36,
  "end": 313.44
 },
 {
  "input": "It's like addition, but where you never carry. ",
  "translatedText": "إنها مثل الإضافة، ولكن حيث لا تحملها أبدًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 313.68,
  "end": 315.72
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2. ",
  "translatedText": "مرة أخرى، قد يفضل الأشخاص الأكثر ميلاً للرياضيات التفكير في هذا على أنه إضافة متجهين وتقليل التعديل 2. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 316.5,
  "end": 322.48
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood. ",
  "translatedText": "إذا قمت بفتح بعض لغة Python الآن وقمت بتطبيق عملية علامة الإقحام بين عددين صحيحين، فهذا ما تفعله ولكن على تمثيلات البت لتلك الأرقام الموجودة أسفل الغطاء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 323.5,
  "end": 332.94
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop. ",
  "translatedText": "النقطة الأساسية بالنسبة لي ولكم هي أن أخذ XOR للعديد من سلاسل البت المختلفة هو وسيلة فعالة لحساب المحاكاة الساخرة لمجموعة من المجموعات المنفصلة، كما هو الحال مع الأعمدة، كل ذلك في ضربة واحدة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 334.96,
  "end": 347.14
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation. ",
  "translatedText": "وهذا يمنحنا طريقة رائعة إلى حد ما للتفكير في عمليات التحقق من التكافؤ المتعددة من خوارزمية كود هامينج الخاصة بنا حيث يتم تجميعها جميعًا معًا في عملية واحدة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 351.26,
  "end": 358.78
 },
 {
  "input": "Though at first glance it does look very different. ",
  "translatedText": "على الرغم من أنها تبدو للوهلة الأولى مختلفة تمامًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 359.48,
  "end": 362.18
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR. ",
  "translatedText": "اكتب على وجه التحديد المواضع الستة عشر في النظام الثنائي، كما فعلنا من قبل، وقم الآن بتمييز المواضع التي تم فيها تشغيل بت الرسالة إلى 1، ثم قم بتجميع هذه المواضع في عمود واحد كبير وأخذ XOR. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 362.82,
  "end": 377.1
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly. ",
  "translatedText": "ربما يمكنك تخمين أن البتات الأربعة الموجودة في الأسفل نتيجة لذلك هي نفس عمليات التحقق من التكافؤ الأربعة التي عرفناها ونحبها، ولكن خذ لحظة للتفكير في السبب بالضبط. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 379.26,
  "end": 389.2
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group. ",
  "translatedText": "هذا العمود الأخير، على سبيل المثال، يقوم بإحصاء جميع المواضع التي يكون الجزء الأخير منها هو 1، ولكننا يقتصرون بالفعل على المواضع المميزة فقط، لذا فهو يحسب بشكل فعال عدد المواضع المميزة التي جاءت من مجموعة التكافؤ الأولى. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 392.22,
  "end": 405.76
 },
 {
  "input": "Does that make sense? ",
  "translatedText": "هل هذا منطقي؟ ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 406.24,
  "end": 406.8
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on. ",
  "translatedText": "وبالمثل، يقوم العمود التالي بحساب عدد المواضع الموجودة في مجموعة التكافؤ الثانية، والمواضع التي يكون البت الثاني قبل الأخير هو 1، والتي يتم تمييزها أيضًا، وما إلى ذلك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 409.08,
  "end": 420.0
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing. ",
  "translatedText": "إنه في الحقيقة مجرد تحول بسيط في المنظور حول نفس الشيء الذي كنا نفعله. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 420.26,
  "end": 423.96
 },
 {
  "input": "And so you know where it goes from here. ",
  "translatedText": "وهكذا تعرف إلى أين يتجه الأمر من هنا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 427.76,
  "end": 429.6
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000. ",
  "translatedText": "يكون المرسل مسؤولاً عن تبديل بعض بتات التكافؤ الخاصة للتأكد من أن المبلغ يصل إلى 0000. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 430.0,
  "end": 436.56
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error. ",
  "translatedText": "الآن، بمجرد أن يصبح الأمر بهذا الشكل، فهذا يمنحنا طريقة رائعة للتفكير في السبب وراء توضيح هذه البتات الأربعة الناتجة في الأسفل موضع الخطأ بشكل مباشر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 439.04,
  "end": 447.58
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1. ",
  "translatedText": "لنفترض أنه تم تبديل جزء ما في هذه الكتلة من 0 إلى 1. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 448.46,
  "end": 451.86
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error. ",
  "translatedText": "ما يعنيه ذلك هو أن موضع هذا البت سيتم الآن تضمينه في إجمالي XOR، مما يغير المجموع من 0 إلى هذه القيمة المضمنة حديثًا بدلاً من ذلك، وهو موضع الخطأ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 452.6,
  "end": 463.82
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0. ",
  "translatedText": "وبشكل أقل وضوحًا، ينطبق الأمر نفسه إذا كان هناك خطأ يؤدي إلى تغيير 1 إلى 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 464.46,
  "end": 469.36
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0. ",
  "translatedText": "كما ترى، إذا قمت بإضافة سلسلة صغيرة معًا مرتين، فهذا يعني عدم وجودها على الإطلاق، لأنه في هذا العالم 1 زائد 1 يساوي 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 470.18,
  "end": 477.94
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it. ",
  "translatedText": "لذا فإن إضافة نسخة من هذا الموضع إلى المجموع الإجمالي له نفس التأثير الذي نحركه به. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 478.92,
  "end": 484.3
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error. ",
  "translatedText": "وهذا التأثير، مرة أخرى، هو أن النتيجة الإجمالية في الأسفل توضح موضع الخطأ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 485.16,
  "end": 490.7
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end. ",
  "translatedText": "لتوضيح مدى روعة هذا الأمر، اسمحوا لي أن أعرض سطرًا واحدًا من كود بايثون الذي أشرت إليه من قبل، والذي سيلتقط تقريبًا كل المنطق في نهاية المتلقي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 493.04,
  "end": 501.44
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits. ",
  "translatedText": "سنبدأ بإنشاء مصفوفة عشوائية مكونة من 16 1 و0 لمحاكاة كتلة البيانات، وسأعطيها بتات الاسم، ولكن بالطبع من الناحية العملية سيكون هذا شيئًا نتلقاه من المرسل، وبدلاً من ذلك نظرًا لكونها عشوائية، فإنها ستحمل 11 بتة بيانات مع 5 بتات تكافؤ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 502.08,
  "end": 517.4
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15. ",
  "translatedText": "إذا قمت باستدعاء الدالة enumerateBits، فإن ما تفعله هو إقران كل من تلك البتات مع فهرس مناظر، في هذه الحالة يعمل من 0 إلى 15. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 518.12,
  "end": 527.0
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15. ",
  "translatedText": "لذا، إذا قمنا بعد ذلك بإنشاء قائمة تدور حول كل هذه الأزواج، الأزواج التي تبدو مثل i، ثم قمنا بسحب قيمة i فقط، فقط الفهرس، حسنًا، الأمر ليس مثيرًا، سنستعيد تلك المؤشرات من 0 إلى 15 . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 528.18,
  "end": 541.34
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on. ",
  "translatedText": "ولكن إذا أضفنا شرطًا للقيام بذلك فقط إذا كانت البتة، مما يعني أنه إذا كانت تلك البتة هي 1 وليس 0، فحسنًا فإنها تسحب فقط المواضع التي يتم فيها تشغيل البتة المقابلة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 541.68,
  "end": 552.66
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc. ",
  "translatedText": "في هذه الحالة يبدو أن هذه المواضع هي 0، 4، 6، 9، إلخ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 553.38,
  "end": 557.96
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together. ",
  "translatedText": "ما نريده هو جمع كل تلك المواضع معًا، مواضع البتات التي تم تشغيلها، ثم XOR معًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 559.98,
  "end": 567.24
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions. ",
  "translatedText": "للقيام بذلك في بايثون، اسمحوا لي أولاً باستيراد وظيفتين مفيدتين. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.18,
  "end": 573.22
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it. ",
  "translatedText": "بهذه الطريقة يمكننا استدعاء الدالة تقليل() في هذه القائمة، واستخدام الدالة XOR لتقليلها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 573.9,
  "end": 578.7
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way. ",
  "translatedText": "وهذا في الأساس يشق طريقه عبر القائمة، ويأخذ XORs على طول الطريق. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.1,
  "end": 582.68
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere. ",
  "translatedText": "إذا كنت تفضل ذلك، يمكنك كتابة دالة XOR بوضوح دون الحاجة إلى استيرادها من أي مكان. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 584.8,
  "end": 589.44
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001. ",
  "translatedText": "لذا، في الوقت الحالي، يبدو أننا إذا فعلنا ذلك على الكتلة العشوائية المكونة من 16 بت، فإنها ستُرجع 9، والتي لها التمثيل الثنائي 1001. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 591.94,
  "end": 601.28
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0. ",
  "translatedText": "لن نفعل ذلك هنا، ولكن يمكنك كتابة دالة يستخدم فيها المرسل هذا التمثيل الثنائي لتعيين وحدات البت التماثلية الأربعة حسب الحاجة، وفي النهاية توصيل هذه الكتلة إلى حالة حيث يؤدي تشغيل هذا السطر من التعليمات البرمجية على القائمة الكاملة للبتات إلى إرجاعها 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 601.98,
  "end": 615.46
 },
 {
  "input": "This would be considered a well-prepared block. ",
  "translatedText": "سيتم اعتبار هذا كتلة جيدة الإعداد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 616.08,
  "end": 618.2
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error. ",
  "translatedText": "الأمر الرائع هو أنه إذا قمنا بتبديل أي من البتات في هذه القائمة، لمحاكاة خطأ عشوائي من الضوضاء، ثم إذا قمت بتشغيل نفس السطر من التعليمات البرمجية، فإنه يطبع هذا الخطأ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 619.88,
  "end": 630.22
 },
 {
  "input": "Isn't that neat? ",
  "translatedText": "أليس هذا أنيق؟ ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 630.96,
  "end": 631.52
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any. ",
  "translatedText": "يمكنك الحصول على هذه الكتلة فجأة، وتشغيل هذا السطر الفردي عليها، وسيظهر تلقائيًا موضع الخطأ، أو 0 إذا لم يكن هناك أي خطأ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 631.82,
  "end": 641.06
 },
 {
  "input": "And there's nothing special about the size 16 here. ",
  "translatedText": "وليس هناك شيء خاص بخصوص الحجم 16 هنا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 642.5,
  "end": 645.2
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits. ",
  "translatedText": "سيعمل نفس السطر من التعليمات البرمجية إذا كان لديك قائمة، على سبيل المثال، 256 بت. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 645.4,
  "end": 649.86
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction. ",
  "translatedText": "وغني عن القول أن هناك المزيد من التعليمات البرمجية التي يجب كتابتها هنا، مثل إجراء فحص التكافؤ التعريفي لاكتشاف أخطاء 2 بت، ولكن الفكرة هي أن كل المنطق الأساسي تقريبًا من مخططنا يعود إلى تقليل XOR واحد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 651.88,
  "end": 663.76
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go. ",
  "translatedText": "الآن، اعتمادًا على راحتك مع الثنائيات وXORs والبرامج بشكل عام، قد تجد هذا المنظور مربكًا بعض الشيء، أو أكثر أناقة وبساطة لدرجة أنك تتساءل لماذا لم نبدأ به من البداية -يذهب. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.12,
  "end": 678.42
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level. ",
  "translatedText": "بشكل عام، من الأسهل التفكير في منظور التحقق من التكافؤ المتعدد عند تنفيذ رموز Hamming في الأجهزة بشكل مباشر جدًا، ومن الأسهل التفكير في منظور XOR عند القيام بذلك في البرامج، من مستوى أعلى نوعًا ما. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 679.14,
  "end": 690.5
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles. ",
  "translatedText": "الأول هو الأسهل في الواقع للقيام به يدويًا، وأعتقد أنه يقوم بعمل أفضل في غرس الحدس الأساسي الكامن وراء كل هذا، وهو أن المعلومات المطلوبة لتحديد موقع خطأ واحد مرتبطة بسجل حجم الكتلة أو بعبارة أخرى، فإنه ينمو قطعة واحدة في كل مرة مع تضاعف حجم الكتلة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 691.36,
  "end": 710.0
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need. ",
  "translatedText": "الحقيقة ذات الصلة هنا هي أن هذه المعلومات تتوافق بشكل مباشر مع مقدار التكرار الذي نحتاجه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 711.02,
  "end": 716.06
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind. ",
  "translatedText": "وهذا حقًا ما يتعارض مع رد فعل معظم الأشخاص غير المحسوبين عندما يفكرون لأول مرة في جعل رسالة مقاومة للأخطاء، حيث عادةً ما يكون نسخ الرسالة بأكملها هو أول غريزة تتبادر إلى ذهنهم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.66,
  "end": 726.54
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix. ",
  "translatedText": "وبعد ذلك، بالمناسبة، هناك طريقة أخرى تمامًا حيث ترى أحيانًا رموز هامينج معروضة، حيث تقوم بضرب الرسالة في مصفوفة واحدة كبيرة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 727.5,
  "end": 734.0
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales. ",
  "translatedText": "إنه لطيف نوعًا ما لأنه يرتبط بعائلة أوسع من الرموز الخطية، لكنني أعتقد أن هذا لا يعطي أي فكرة تقريبًا عن مصدرها أو كيفية قياسها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 734.67,
  "end": 743.06
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size. ",
  "translatedText": "وبالحديث عن القياس، قد تلاحظ أن كفاءة هذا المخطط تتحسن فقط عندما نزيد حجم الكتلة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 745.2,
  "end": 751.16
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there. ",
  "translatedText": "على سبيل المثال، رأينا أنه مع 256 بت، فإنك تستخدم 3% فقط من تلك المساحة للتكرار، ويستمر الأمر في التحسن من هناك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 755.0,
  "end": 762.66
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling. ",
  "translatedText": "ومع زيادة عدد البتات المتماثلة واحدة تلو الأخرى، يستمر حجم الكتلة في التضاعف. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 763.3,
  "end": 767.34
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits. ",
  "translatedText": "وإذا أخذت ذلك إلى أقصى الحدود، يمكن أن يكون لديك كتلة تحتوي، على سبيل المثال، على مليون بت، حيث يمكنك حرفيًا تشغيل 20 سؤالًا مع اختبارات التكافؤ الخاصة بك، وتستخدم 21 بتة فقط. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 769.0,
  "end": 780.02
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy. ",
  "translatedText": "وإذا عدت إلى الوراء للتفكير في النظر إلى مليون بت وتحديد موقع خطأ واحد، فإن هذا يبدو جنونًا حقًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 780.74,
  "end": 787.06
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that. ",
  "translatedText": "المشكلة بالطبع هي أنه مع وجود كتلة أكبر، فإن احتمال رؤية أكثر من خطأ واحد أو اثنين من الأخطاء، ولا تتعامل رموز هامينج مع أي شيء أبعد من ذلك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 788.2,
  "end": 797.66
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high. ",
  "translatedText": "لذا، من الناحية العملية، ما تريده هو العثور على الحجم المناسب بحيث لا يكون احتمال حدوث عدد كبير جدًا من تقلبات البتات مرتفعًا جدًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 798.32,
  "end": 804.3
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored. ",
  "translatedText": "أيضًا، من الناحية العملية، تميل الأخطاء إلى الظهور على شكل دفعات صغيرة، مما قد يؤدي إلى تدمير كتلة واحدة تمامًا، لذا فإن أحد الأساليب الشائعة للمساعدة في نشر موجة من الأخطاء عبر العديد من الكتل المختلفة هو تشبيك تلك الكتل، مثل هذا، قبل أن يتم دمجها إرسالها أو تخزينها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 806.6,
  "end": 820.98
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block. ",
  "translatedText": "ثم مرة أخرى، أصبح الكثير من هذا موضع نقاش تمامًا من خلال أكواد أكثر حداثة، مثل خوارزمية Reed-Solomon الأكثر استخدامًا، والتي تتعامل مع أخطاء الاندفاع بشكل جيد، ويمكن ضبطها لتكون مرنة في التعامل مع عدد أكبر من الأخطاء لكل كتلة . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 825.58,
  "end": 838.82
 },
 {
  "input": "But that's a topic for another time. ",
  "translatedText": "ولكن هذا موضوع لوقت آخر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.36,
  "end": 841.34
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was. ",
  "translatedText": "في كتابه &quot;فن ممارسة العلوم والهندسة&quot;، كان هامينغ صريحًا بشكل رائع حول مدى تعقيد اكتشافه لهذا الرمز. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 842.5,
  "end": 849.94
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this. ",
  "translatedText": "لقد جرب أولاً جميع أنواع المخططات المختلفة التي تتضمن تنظيم البتات إلى أجزاء من شبكة ذات أبعاد أعلى وأشياء غريبة مثل هذه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 850.62,
  "end": 857.78
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this? ",
  "translatedText": "فكرة أنه قد يكون من الممكن الحصول على فحوصات التكافؤ للتآمر بطريقة توضح موضع الخطأ جاءت إلى هامينج فقط عندما تراجع بعد مجموعة من التحليلات الأخرى وسأل، حسنًا، ما هو الأكثر كفاءة الذي يمكنني فعله من الممكن أن يكون حول هذا؟ ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 858.3,
  "end": 871.52
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today. ",
  "translatedText": "وكان صريحًا أيضًا بشأن مدى أهمية وجود ضوابط التكافؤ في ذهنه بالفعل، وهو الأمر الذي كان أقل شيوعًا في الأربعينيات مما هو عليه اليوم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 872.62,
  "end": 881.22
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind. ",
  "translatedText": "هناك حوالي ست مرات خلال هذا الكتاب يشير فيها إلى مقولة لويس باستور، الحظ يفضل العقل المستعد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 881.92,
  "end": 888.22
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate. ",
  "translatedText": "غالبًا ما تبدو الأفكار الذكية بسيطة بشكل خادع بعد فوات الأوان، مما يجعل من السهل التقليل من قيمتها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 889.32,
  "end": 894.3
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you. ",
  "translatedText": "في الوقت الحالي، أملي الصادق هو أن تكون رموز هامينج، أو على الأقل إمكانية وجود مثل هذه الرموز، واضحة تقريبًا بالنسبة لك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 894.96,
  "end": 901.3
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't. ",
  "translatedText": "لكن لا ينبغي أن تخدع نفسك بالاعتقاد بأنها واضحة بالفعل، لأنها بالتأكيد ليست كذلك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 901.66,
  "end": 906.82
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that. ",
  "translatedText": "جزء من السبب الذي يجعل الأفكار الذكية تبدو سهلة بشكل خادع هو أننا لا نرى سوى النتيجة النهائية، وننظف ما كان فوضويًا، ولا نذكر أبدًا كل المنعطفات الخاطئة، ونقلل من مدى اتساع مساحة الإمكانيات القابلة للاستكشاف في بداية المشكلة. عملية الحل، كل ذلك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 907.88,
  "end": 922.86
 },
 {
  "input": "But this is true in general. ",
  "translatedText": "ولكن هذا صحيح بشكل عام. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 923.82,
  "end": 924.9
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them. ",
  "translatedText": "أعتقد أنه بالنسبة لبعض الاختراعات الخاصة، هناك سبب ثانٍ وأعمق لعدم تقديرنا لها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 924.9,
  "end": 930.04
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory. ",
  "translatedText": "إن التفكير في المعلومات من حيث البتات قد اندمج فعليًا في نظرية كاملة بحلول عام 1948، مع ورقة كلود شانون الأساسية حول نظرية المعلومات. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 930.84,
  "end": 938.64
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm. ",
  "translatedText": "كان هذا متزامنًا بشكل أساسي مع قيام هامينج بتطوير خوارزميته. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 939.28,
  "end": 942.54
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory. ",
  "translatedText": "كانت هذه هي نفس الورقة التأسيسية التي أظهرت، إلى حد ما، أن التصحيح الفعال للأخطاء أمر ممكن دائمًا، بغض النظر عن مدى احتمالية قلب البتات، على الأقل من الناحية النظرية. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 943.3,
  "end": 952.9
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here. ",
  "translatedText": "بالمناسبة، كان شانون وهامينج يشتركان في مكتب واحد في Bell Labs، على الرغم من العمل على أشياء مختلفة تمامًا، وهو الأمر الذي لا يبدو من قبيل الصدفة هنا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.7,
  "end": 961.16
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was. ",
  "translatedText": "بعد مرور عدة عقود، وفي هذه الأيام، الكثير منا منغمسون جدًا في التفكير في أجزاء ومعلومات، مما يجعل من السهل التغاضي عن مدى تميز طريقة التفكير هذه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.38,
  "end": 972.34
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are. ",
  "translatedText": "ومن عجيب المفارقات أن الأفكار التي تشكل بشكل أعمق الطرق التي يفكر بها جيل المستقبل ستنتهي في النهاية إلى النظر إلى جيل المستقبل بشكل أبسط مما هو عليه بالفعل. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 973.1,
  "end": 982.26
 }
]