1
00:00:00,000 --> 00:00:05,686
Чи замислювалися ви коли-небудь про те, як можна подряпати компакт-диск

2
00:00:05,686 --> 00:00:10,900
або DVD-диск і все одно відтворювати те, що на ньому зберігається?

3
00:00:10,900 --> 00:00:16,536
Подряпина справді впливає на 1 і 0 на диску, тому він зчитує дані, відмінні від того,

4
00:00:16,536 --> 00:00:21,452
що зберігається, але якщо він справді не подряпаний, біти, які він зчитує,

5
00:00:21,452 --> 00:00:26,499
декодуються в той самий файл, який був закодований на ньому, побітова копія,

6
00:00:26,499 --> 00:00:28,400
незважаючи на всі ці помилки.

7
00:00:28,400 --> 00:00:32,592
Існує ціла купа математичної кмітливості, яка дозволяє нам зберігати дані,

8
00:00:32,592 --> 00:00:36,840
і, що не менш важливо, передавати дані, у спосіб, який є стійким до помилок.

9
00:00:36,840 --> 00:00:42,480
Ну, гаразд, насправді не потрібно так багато кмітливості, щоб придумати спосіб це зробити.

10
00:00:42,480 --> 00:00:46,550
Будь-який файл, чи то відео, чи звук, чи текст, якийсь код,

11
00:00:46,550 --> 00:00:50,960
зображення тощо, зрештою, є певною послідовністю одиниць і нулів.

12
00:00:50,960 --> 00:00:54,032
І простою стратегією виправлення будь-якого біта,

13
00:00:54,032 --> 00:00:57,780
який перевертається, було б зберігати три копії кожного біта.

14
00:00:57,780 --> 00:01:02,481
Тоді машина, яка читає цей файл, може порівняти ці три

15
00:01:02,481 --> 00:01:07,440
копії та завжди брати найкращі 2 із 3, якщо є розбіжності.

16
00:01:07,440 --> 00:01:11,560
Але це означає використання двох третин вашого простору для резервування.

17
00:01:11,560 --> 00:01:15,603
І навіть тоді, незважаючи на весь цей вільний простір, немає надійної гарантії щодо того,

18
00:01:15,603 --> 00:01:18,120
що станеться, якщо буде перевернуто більше ніж один біт.

19
00:01:18,120 --> 00:01:21,216
Набагато цікавіше питання полягає в тому, як зробити так,

20
00:01:21,216 --> 00:01:24,740
щоб можна було виправляти помилки, звільняючи якомога менше місця.

21
00:01:24,740 --> 00:01:28,292
Наприклад, використовуючи метод, який ви дізнаєтеся про це відео,

22
00:01:28,292 --> 00:01:32,975
ви можете зберігати свої дані у 256-бітних блоках, де кожен блок використовує 9 біт, 9!

23
00:01:32,975 --> 00:01:37,107
щоб діяти як своєрідна надлишковість, а інші 247 бітів можуть вільно

24
00:01:37,107 --> 00:01:41,000
переносити будь-які значущі повідомлення або дані, які ви хочете.

25
00:01:41,000 --> 00:01:44,868
І все одно буде так, що якщо будь-який біт тут буде перевернуто,

26
00:01:44,868 --> 00:01:49,152
просто подивившись на цей блок і нічого більше, машина зможе визначити,

27
00:01:49,152 --> 00:01:53,140
що була помилка, і точно, де вона була, щоб знати, як її виправити.

28
00:01:53,140 --> 00:01:55,540
І, чесно кажучи, це виглядає як магія.

29
00:01:55,540 --> 00:01:58,665
І для цієї конкретної схеми, якщо два біти будуть перевернуті,

30
00:01:58,665 --> 00:02:02,386
машина принаймні зможе виявити, що було дві помилки, хоча вона не знатиме,

31
00:02:02,386 --> 00:02:03,180
як їх виправити.

32
00:02:03,180 --> 00:02:08,140
Трохи пізніше ми поговоримо про те, як це масштабується для блоків різних розмірів.

33
00:02:08,140 --> 00:02:10,895
Методи, які дозволяють виправляти такі помилки,

34
00:02:10,895 --> 00:02:13,880
відомі, досить розумно, як коди виправлення помилок.

35
00:02:13,880 --> 00:02:18,305
Протягом більшої частини минулого століття ця сфера була справді багатим джерелом

36
00:02:18,305 --> 00:02:23,000
напрочуд глибокої математики, яка вбудовується в пристрої, якими ми користуємося щодня.

37
00:02:23,000 --> 00:02:27,925
Мета тут — дати вам дуже повне розуміння одного з найперших прикладів,

38
00:02:27,925 --> 00:02:29,660
відомого як код Хеммінга.

39
00:02:29,660 --> 00:02:33,613
І, до речі, те, як я думаю про структуру цього відео, полягає не в тому,

40
00:02:33,613 --> 00:02:36,320
щоб пояснити це якомога пряміше, а більше в тому,

41
00:02:36,320 --> 00:02:40,220
щоб спонукати вас придумати це для себе, з легкими вказівками тут і там.

42
00:02:40,220 --> 00:02:43,899
Тож коли ви відчуєте, що в якийсь момент бачите, куди це йде, візьміть цей момент,

43
00:02:43,899 --> 00:02:47,180
щоб зупинитися, активно передбачте, якою буде схема, перш ніж я скажу вам.

44
00:02:47,180 --> 00:02:51,275
Крім того, якщо ви хочете, щоб ваше розуміння перейшло до апаратного рівня,

45
00:02:51,275 --> 00:02:54,777
Бен Ітер створив відео в поєднанні з цим відео, яке показує вам,

46
00:02:54,777 --> 00:02:59,520
як насправді впроваджувати коди Хеммінга на макетних платах, що надзвичайно задовольняє.

47
00:02:59,520 --> 00:03:02,785
Ви повинні знати, що коди Хеммінга не так широко використовуються,

48
00:03:02,785 --> 00:03:05,369
як більш сучасні коди, як-от алгоритм Ріда-Соломона,

49
00:03:05,369 --> 00:03:09,024
але є певна магія в контрасті між тим, наскільки нездійсненним це завдання

50
00:03:09,024 --> 00:03:12,680
здається на початку, і тим, наскільки цілком розумним воно здається одного

51
00:03:12,680 --> 00:03:14,240
разу ви дізнаєтесь про Хеммінга.

52
00:03:14,240 --> 00:03:16,959
Основний принцип виправлення помилок полягає в тому,

53
00:03:16,959 --> 00:03:21,115
що у величезному просторі всіх можливих повідомлень лише деякі підмножини будуть

54
00:03:21,115 --> 00:03:22,860
вважатися дійсними повідомленнями.

55
00:03:22,860 --> 00:03:29,100
Як аналогію, подумайте про правильно написані слова проти неправильно написаних слів.

56
00:03:29,100 --> 00:03:33,318
Щоразу, коли дійсне повідомлення змінюється, одержувач несе відповідальність за

57
00:03:33,318 --> 00:03:36,745
виправлення того, що він бачить, до найближчого дійсного сусіда,

58
00:03:36,745 --> 00:03:38,380
як це можна зробити з помилкою.

59
00:03:38,380 --> 00:03:42,420
Проте розробка конкретного алгоритму для ефективної

60
00:03:42,420 --> 00:03:47,160
класифікації подібних повідомлень вимагає певної кмітливості.

61
00:03:47,160 --> 00:03:51,189
Історія починається в 1940-х роках, коли молодий Річард Хеммінг працював у Bell Labs,

62
00:03:51,189 --> 00:03:54,843
і частина його роботи включала використання дуже великого дорогого комп’ютера

63
00:03:54,843 --> 00:03:57,420
з перфокартами, до якого він мав лише обмежений доступ.

64
00:03:57,420 --> 00:03:59,660
І програми, які він постійно вставляв у нього,

65
00:03:59,660 --> 00:04:03,140
постійно виходили з ладу, тому що час від часу щось неправильно читалося.

66
00:04:03,140 --> 00:04:06,442
Розчарування, будучи горнилом винахідництва, йому так набридло,

67
00:04:06,442 --> 00:04:09,280
що він винайшов перший у світі код виправлення помилок.

68
00:04:09,280 --> 00:04:12,452
Є багато різних способів створення кодів Хеммінга,

69
00:04:12,452 --> 00:04:16,620
але для початку ми розглянемо це так, як сам Хеммінг думав про них.

70
00:04:16,620 --> 00:04:21,400
Давайте використаємо простий, але не дуже простий приклад, блок із 16 біт.

71
00:04:21,400 --> 00:04:25,700
Ми пронумеруємо позиції цих бітів від 0 до 15.

72
00:04:25,700 --> 00:04:30,266
Фактичні дані, які ми хочемо зберігати, складатимуть лише 12 із цих бітів,

73
00:04:30,266 --> 00:04:33,920
тоді як 4 позиції зарезервовано як свого роду надлишковість.

74
00:04:33,920 --> 00:04:36,889
Слово надлишковий тут не просто означає копіювання, зрештою,

75
00:04:36,889 --> 00:04:40,200
ці 4 біти не дають нам достатньо місця для сліпого копіювання даних.

76
00:04:40,200 --> 00:04:45,176
Натомість вони повинні бути набагато більш тонкими та розумними як резервування,

77
00:04:45,176 --> 00:04:48,740
не додаючи жодної нової інформації, але додаючи стійкості.

78
00:04:48,740 --> 00:04:52,530
Ви можете очікувати, що ці 4 спеціальні біти будуть гарно зібрані разом,

79
00:04:52,530 --> 00:04:56,788
можливо, в кінці або щось подібне, але, як ви побачите, розміщення їх у позиціях,

80
00:04:56,788 --> 00:05:00,320
які є степенями 2, дозволяє отримати щось справді елегантне в кінці.

81
00:05:00,320 --> 00:05:05,420
Це також може дати вам невелику підказку про те, як це масштабується для більших блоків.

82
00:05:05,420 --> 00:05:10,509
Крім того, технічно це лише 11 біт даних, ви побачите, що є легкий нюанс у тому,

83
00:05:10,509 --> 00:05:14,280
що відбувається в позиції 0, але не хвилюйтеся про це зараз.

84
00:05:14,280 --> 00:05:17,075
Як і в будь-якому іншому алгоритмі виправлення помилок,

85
00:05:17,075 --> 00:05:19,421
у цьому будуть задіяні два гравці: відправник,

86
00:05:19,421 --> 00:05:22,915
який відповідає за встановлення цих 4 спеціальних бітів, і одержувач,

87
00:05:22,915 --> 00:05:26,360
який відповідає за виконання певної перевірки та виправлення помилок.

88
00:05:26,360 --> 00:05:29,285
Звичайно, слова «відправник» і «одержувач» справді стосуються машин

89
00:05:29,285 --> 00:05:31,737
або програмного забезпечення, яке виконує всі перевірки,

90
00:05:31,737 --> 00:05:35,480
і ідея повідомлення має на увазі дуже широке значення, включаючи такі речі, як сховище.

91
00:05:35,480 --> 00:05:38,681
Зрештою, зберігання даних — це те саме, що відправляти

92
00:05:38,681 --> 00:05:42,640
повідомлення лише з минулого в майбутнє, а не з одного місця в інше.

93
00:05:42,640 --> 00:05:45,909
Отже, це налаштування, але перш ніж ми зможемо зануритися в це,

94
00:05:45,909 --> 00:05:49,433
нам потрібно поговорити про пов’язану ідею, яка була свіжою в голові

95
00:05:49,433 --> 00:05:53,111
Геммінга під час його відкриття, метод, який дозволяє виявляти будь-які

96
00:05:53,111 --> 00:05:57,300
однобітові помилки, але не виправляти їх, відомий у бізнесі як перевірка паритету.

97
00:05:57,300 --> 00:06:00,178
Для перевірки парності ми відокремлюємо лише один біт,

98
00:06:00,178 --> 00:06:04,259
за налаштування якого відповідає відправник, а решта можуть вільно передавати

99
00:06:04,259 --> 00:06:04,940
повідомлення.

100
00:06:04,940 --> 00:06:07,975
Єдина робота цього спеціального біта полягає в тому,

101
00:06:07,975 --> 00:06:12,100
щоб переконатися, що загальна кількість одиниць у повідомленні є парною.

102
00:06:12,100 --> 00:06:16,031
Так, наприклад, зараз загальна кількість одиниць дорівнює 7, це дивно,

103
00:06:16,031 --> 00:06:20,960
тому відправнику потрібно перевернути цей спеціальний біт на 1, роблячи кількість парних.

104
00:06:20,960 --> 00:06:24,289
Але якби блок уже почався з парної кількості 1,

105
00:06:24,289 --> 00:06:27,480
тоді цей спеціальний біт залишився б рівним 0.

106
00:06:27,480 --> 00:06:32,746
Це досить просто, оманливо просто, але це неймовірно елегантний спосіб дистилювати

107
00:06:32,746 --> 00:06:37,760
ідею зміни будь-де в повідомленні, щоб її відобразити в одному біті інформації.

108
00:06:37,760 --> 00:06:42,845
Зверніть увагу, якщо будь-який біт цього повідомлення перевертається з 0

109
00:06:42,845 --> 00:06:48,140
на 1 або з 1 на 0, це змінює загальну кількість одиниць з парної на непарну.

110
00:06:48,140 --> 00:06:51,471
Отже, якщо ви одержувач, ви дивитеся на це повідомлення та

111
00:06:51,471 --> 00:06:54,690
бачите непарну кількість одиниць, ви можете точно знати,

112
00:06:54,690 --> 00:06:58,700
що сталася якась помилка, навіть якщо ви можете не знати, де вона була.

113
00:06:58,700 --> 00:07:04,940
На жаргоні парність у групі бітів називається її парністю.

114
00:07:04,940 --> 00:07:08,320
Ви також можете використовувати числа та сказати, що парність дорівнює 0 або 1,

115
00:07:08,320 --> 00:07:11,320
що зазвичай стає більш корисним, коли ви починаєте обчислювати цю ідею.

116
00:07:11,320 --> 00:07:16,246
І цей спеціальний біт, який відправник використовує для контролю парності,

117
00:07:16,246 --> 00:07:18,020
називається бітом парності.

118
00:07:18,020 --> 00:07:21,850
І насправді, ми маємо чітко уточнити: якщо отримувач бачить непарну парність,

119
00:07:21,850 --> 00:07:25,582
це не обов’язково означає, що була лише одна помилка, могло бути 3 помилки,

120
00:07:25,582 --> 00:07:29,560
або 5, або будь-яке інше непарне число, але вони можуть знати напевно що це не 0.

121
00:07:29,560 --> 00:07:33,865
З іншого боку, якби було 2 помилки або будь-яка парна кількість помилок,

122
00:07:33,865 --> 00:07:38,701
кінцева кількість 1с все одно була б парною, тому одержувач не може бути повністю

123
00:07:38,701 --> 00:07:43,360
впевненим, що парна кількість обов’язково означає, що повідомлення без помилок.

124
00:07:43,360 --> 00:07:45,673
Ви можете поскаржитися на те, що повідомлення,

125
00:07:45,673 --> 00:07:49,760
яке спотворюється лише двома бітами, є досить слабким, і ви будете абсолютно праві.

126
00:07:49,760 --> 00:07:53,721
Однак пам’ятайте, що не існує методу виявлення або виправлення помилок,

127
00:07:53,721 --> 00:07:58,399
який міг би дати вам 100% впевненість у тому, що отримане вами повідомлення – це те,

128
00:07:58,399 --> 00:07:59,720
що мав намір відправник.

129
00:07:59,720 --> 00:08:02,793
Зрештою, достатня кількість випадкового шуму завжди може

130
00:08:02,793 --> 00:08:05,920
змінити одне дійсне повідомлення на інше просто випадково.

131
00:08:05,920 --> 00:08:09,033
Натомість мета полягає в тому, щоб створити схему,

132
00:08:09,033 --> 00:08:13,366
яка є надійною до певної максимальної кількості помилок, або, можливо,

133
00:08:13,366 --> 00:08:16,480
зменшити ймовірність хибного спрацьовування, як це.

134
00:08:16,480 --> 00:08:20,214
Перевірки на парність самі по собі є досить слабкими, але,

135
00:08:20,214 --> 00:08:23,885
зводячи ідею зміни в повному повідомленні до одного біта,

136
00:08:23,885 --> 00:08:28,000
вони дають нам потужний будівельний блок для більш складних схем.

137
00:08:28,000 --> 00:08:31,500
Наприклад, коли Хеммінг шукав спосіб визначити, де сталася помилка,

138
00:08:31,500 --> 00:08:35,258
а не просто те, що вона сталася, його ключове розуміння полягало в тому,

139
00:08:35,258 --> 00:08:39,170
що якщо ви застосовуєте деякі перевірки парності не до всього повідомлення,

140
00:08:39,170 --> 00:08:42,670
а до певних ретельно відібраних підмножин, ви можете запитати більш

141
00:08:42,670 --> 00:08:46,840
витончену серію запитань, які визначають місце будь-якої окремої бітової помилки.

142
00:08:46,840 --> 00:08:49,943
Загальне відчуття трохи схоже на гру з 20 запитань,

143
00:08:49,943 --> 00:08:54,300
задаючи запити «так» або «ні», які розрізають простір можливостей навпіл.

144
00:08:54,300 --> 00:08:58,479
Наприклад, скажімо, ми виконуємо перевірку парності лише для цих 8 бітів,

145
00:08:58,479 --> 00:09:00,400
усіх позицій з непарними номерами.

146
00:09:00,400 --> 00:09:05,233
Потім, якщо виявлено помилку, це дає одержувачу трохи більше інформації про те,

147
00:09:05,233 --> 00:09:09,160
де саме є помилка, а саме, що він знаходиться в непарній позиції.

148
00:09:09,160 --> 00:09:12,958
Якщо серед цих 8 бітів не виявлено жодної помилки, це означає,

149
00:09:12,958 --> 00:09:17,240
що помилки немає взагалі, або вона знаходиться десь на парних позиціях.

150
00:09:17,240 --> 00:09:21,437
Ви можете подумати, що обмеження перевірки парності половиною бітів робить

151
00:09:21,437 --> 00:09:25,242
її менш ефективною, але коли це робиться в поєднанні з іншими добре

152
00:09:25,242 --> 00:09:29,720
підібраними перевірками, це суперечить інтуїції дає нам щось набагато потужніше.

153
00:09:29,720 --> 00:09:33,383
Пам’ятайте, що для того, щоб фактично налаштувати цю перевірку парності,

154
00:09:33,383 --> 00:09:37,600
потрібно виділити якийсь спеціальний біт, який контролює парність цієї повної групи.

155
00:09:37,600 --> 00:09:39,920
Давайте просто виберемо позицію 1.

156
00:09:39,920 --> 00:09:43,393
У наведеному прикладі парність цих 8 бітів наразі непарна,

157
00:09:43,393 --> 00:09:48,220
тому відправник відповідає за перемикання цього біта парності, і тепер він парний.

158
00:09:48,220 --> 00:09:51,040
Це лише 1 із 4 перевірок парності, які ми зробимо.

159
00:09:51,040 --> 00:09:54,731
Друга перевірка знаходиться серед 8 бітів у правій половині сітки,

160
00:09:54,731 --> 00:09:56,880
принаймні так, як ми її тут намалювали.

161
00:09:56,880 --> 00:10:00,424
Цього разу ми можемо використати позицію 2 як біт парності,

162
00:10:00,424 --> 00:10:05,033
тому ці 8 бітів уже мають рівну парність, і відправник може почуватися добре,

163
00:10:05,033 --> 00:10:07,160
залишивши цей біт номер 2 незмінним.

164
00:10:07,160 --> 00:10:11,677
Тоді на іншому кінці, якщо приймач перевірить парність цієї групи і виявить,

165
00:10:11,677 --> 00:10:15,960
що вона непарна, він знатиме, що помилка десь серед цих 8 бітів праворуч.

166
00:10:15,960 --> 00:10:21,260
Інакше це означає, що або помилки немає, або помилка десь на лівій половині.

167
00:10:21,260 --> 00:10:24,915
Або я припускаю, що могло бути дві помилки, але зараз ми будемо припускати,

168
00:10:24,915 --> 00:10:27,080
що у всьому блоці є щонайбільше одна помилка.

169
00:10:27,080 --> 00:10:29,160
Речі повністю ламаються для більшого.

170
00:10:29,160 --> 00:10:32,287
Тут, перш ніж ми подивимося на наступні дві перевірки, знайдіть хвилинку,

171
00:10:32,287 --> 00:10:35,880
щоб подумати про те, що ці перші дві дозволяють нам робити, якщо розглядати їх разом.

172
00:10:35,880 --> 00:10:40,240
Припустімо, ви виявили помилку серед непарних стовпців і серед правої половини.

173
00:10:40,240 --> 00:10:43,940
Це обов’язково означає, що помилка знаходиться десь в останньому стовпці.

174
00:10:43,940 --> 00:10:47,650
Якщо в непарному стовпці не було помилки, але була одна в правій половині,

175
00:10:47,650 --> 00:10:50,520
це означає, що вона знаходиться в передостанньому стовпці.

176
00:10:50,520 --> 00:10:54,402
Так само, якщо є помилка в непарних стовпцях, але не в правій половині,

177
00:10:54,402 --> 00:10:56,560
ви знаєте, що це десь у другому стовпці.

178
00:10:56,560 --> 00:11:00,420
І якщо жодна з цих двох перевірок парності нічого не виявляє, це означає,

179
00:11:00,420 --> 00:11:03,760
що єдине місце, де може бути помилка, це крайній лівий стовпець.

180
00:11:03,760 --> 00:11:06,480
Але це також може означати, що помилки взагалі немає.

181
00:11:06,480 --> 00:11:09,392
Це досить складний спосіб сказати, що дві перевірки

182
00:11:09,392 --> 00:11:11,800
парності дозволяють нам закріпити стовпець.

183
00:11:11,800 --> 00:11:14,000
Звідси ви, напевно, можете здогадатися, що далі.

184
00:11:14,000 --> 00:11:16,240
Ми робимо в основному те саме, але для рядків.

185
00:11:16,240 --> 00:11:21,040
У непарних рядках буде перевірено парність із використанням позиції 4 як біта парності.

186
00:11:21,040 --> 00:11:26,480
Отже, у цьому прикладі ця група вже має парний паритет, тому біт 4 буде встановлено на 0.

187
00:11:26,480 --> 00:11:29,802
І, нарешті, є перевірка парності в нижніх двох рядках,

188
00:11:29,802 --> 00:11:32,280
використовуючи позицію 8 як біт парності.

189
00:11:32,280 --> 00:11:36,024
У цьому випадку схоже, що відправник повинен увімкнути цей біт 8,

190
00:11:36,024 --> 00:11:37,840
щоб надати групі рівний паритет.

191
00:11:37,840 --> 00:11:41,205
Подібно до того, як перші дві перевірки дозволяють нам закріпити стовпець,

192
00:11:41,205 --> 00:11:43,000
наступні дві дозволяють закріпити рядок.

193
00:11:43,000 --> 00:11:48,400
Як приклад, уявіть, що під час передачі виникла помилка, скажімо, у позиції 3.

194
00:11:48,400 --> 00:11:52,725
Ну, це впливає на першу групу парності, а також на другу групу парності,

195
00:11:52,725 --> 00:11:56,340
тому приймач знає, що десь у цьому правому стовпці є помилка.

196
00:11:56,340 --> 00:12:01,380
Але це не впливає на третю групу, і не впливає на четверту групу.

197
00:12:01,380 --> 00:12:04,964
І це дозволяє приймачу точно визначити помилку до першого рядка,

198
00:12:04,964 --> 00:12:08,660
що обов’язково означає позицію 3, щоб вони могли виправити помилку.

199
00:12:08,660 --> 00:12:11,581
Можливо, вам сподобається знайти час, щоб переконатися,

200
00:12:11,581 --> 00:12:16,015
що відповіді на ці чотири запитання справді завжди дозволять вам визначити конкретне

201
00:12:16,015 --> 00:12:17,320
місце, де б воно не було.

202
00:12:17,320 --> 00:12:20,450
Насправді, кмітливі серед вас можуть навіть помітити

203
00:12:20,450 --> 00:12:23,640
зв’язок між цими запитаннями та двійковим підрахунком.

204
00:12:23,640 --> 00:12:27,380
І якщо так, дозвольте мені ще раз підкреслити, зробити паузу,

205
00:12:27,380 --> 00:12:30,880
спробуйте самі намалювати зв’язок, перш ніж я його зіпсую.

206
00:12:30,880 --> 00:12:34,849
Якщо вам цікаво, що станеться, якщо постраждає сам біт парності,

207
00:12:34,849 --> 00:12:36,560
ви можете просто спробувати.

208
00:12:36,560 --> 00:12:40,205
Знайдіть хвилинку, щоб подумати про те, як будь-яка помилка серед

209
00:12:40,205 --> 00:12:43,574
цих чотирьох спеціальних бітів буде відстежуватися так само,

210
00:12:43,574 --> 00:12:47,440
як і будь-яка інша, за допомогою тієї самої групи з чотирьох запитань.

211
00:12:47,440 --> 00:12:51,604
Це не має особливого значення, оскільки врешті-решт ми хочемо захистити біти повідомлень,

212
00:12:51,604 --> 00:12:53,640
біти виправлення помилок просто йдуть разом.

213
00:12:53,640 --> 00:12:59,260
Але захист цих бітів також є те, що природно випадає зі схеми як побічний продукт.

214
00:12:59,260 --> 00:13:02,380
Вам також може бути цікаво передбачити, як це масштабується.

215
00:13:02,380 --> 00:13:06,461
Наприклад, якщо ми використовували блок розміром 256 біт,

216
00:13:06,461 --> 00:13:12,513
щоб визначити місце розташування, вам знадобиться лише вісім запитань «так» або «ні»,

217
00:13:12,513 --> 00:13:15,680
щоб виконати двійковий пошук до певної точки.

218
00:13:15,680 --> 00:13:20,368
І пам’ятайте, що кожне запитання вимагає відмови лише від одного біта,

219
00:13:20,368 --> 00:13:23,340
щоб встановити відповідну перевірку парності.

220
00:13:23,340 --> 00:13:26,650
Деякі з вас, можливо, вже бачать це, але ми поговоримо пізніше про

221
00:13:26,650 --> 00:13:29,960
систематичний спосіб знайти ці запитання всього за хвилину або дві.

222
00:13:29,960 --> 00:13:34,440
Сподіваюся, цього ескізу достатньо, щоб оцінити ефективність того, що ми тут розробляємо.

223
00:13:34,440 --> 00:13:38,279
Перше, за винятком тих восьми виділених бітів парності, може бути будь-яким,

224
00:13:38,279 --> 00:13:41,720
що ви забажаєте, з будь-яким повідомленням або даними, які ви хочете.

225
00:13:41,720 --> 00:13:48,040
8 бітів зайві в тому сенсі, що вони повністю визначаються рештою повідомлення,

226
00:13:48,040 --> 00:13:53,640
але це набагато розумніше, ніж просто копіювати повідомлення в цілому.

227
00:13:53,640 --> 00:13:56,593
І все-таки, за так мало відмови, ви зможете визначити

228
00:13:56,593 --> 00:13:59,000
та виправити будь-яку окрему бітову помилку.

229
00:13:59,000 --> 00:14:00,400
Ну, майже.

230
00:14:00,400 --> 00:14:04,644
Гаразд, одна проблема тут полягає в тому, що якщо жодна з чотирьох

231
00:14:04,644 --> 00:14:08,953
перевірок парності не виявляє помилку, тобто всі спеціально вибрані

232
00:14:08,953 --> 00:14:13,008
підмножини з 8 біт мають парні паритети, як і хотів відправник,

233
00:14:13,008 --> 00:14:17,760
то це означає, що помилки взагалі не було , або це звужує нас до позиції 0.

234
00:14:17,760 --> 00:14:22,820
Розумієте, з чотирма запитаннями «так» або «ні» ми маємо 16 можливих результатів для

235
00:14:22,820 --> 00:14:27,820
перевірки парності, і спочатку це ідеально підходить для визначення 1 із 16 позицій

236
00:14:27,820 --> 00:14:33,000
у блоці, але вам також потрібно повідомити 17-й результат, відсутність помилки хвороба.

237
00:14:33,000 --> 00:14:37,860
Рішення тут насправді досить просте, просто забудьте про нульовий біт.

238
00:14:37,860 --> 00:14:41,318
Отже, коли ми виконуємо наші чотири перевірки на парність і бачимо,

239
00:14:41,318 --> 00:14:44,320
що всі вони парні, це однозначно означає, що помилки немає.

240
00:14:44,320 --> 00:14:49,590
Це означає, що замість роботи з 16-бітним блоком ми працюємо з 15-бітним блоком,

241
00:14:49,590 --> 00:14:54,080
де 11 бітів вільні для передачі повідомлення, а 4 з них є резервними.

242
00:14:54,080 --> 00:14:59,400
І разом з цим тепер ми маємо те, що люди в бізнесі називали б кодом Хеммінга 15-11.

243
00:14:59,400 --> 00:15:03,086
Тим не менш, добре мати розмір блоку, який дорівнює чистій степені 2,

244
00:15:03,086 --> 00:15:07,774
і є розумний спосіб, яким ми можемо зберегти цей 0-й біт і змусити його виконувати трохи

245
00:15:07,774 --> 00:15:08,880
більше роботи за нас.

246
00:15:08,880 --> 00:15:11,914
Якщо ми використовуємо його як біт парності для всього блоку,

247
00:15:11,914 --> 00:15:16,320
це дозволяє нам фактично виявляти 2-бітові помилки, навіть якщо ми не можемо виправити їх.

248
00:15:16,320 --> 00:15:17,440
Ось як це працює.

249
00:15:17,440 --> 00:15:21,687
Після встановлення цих чотирьох спеціальних бітів виправлення помилок ми встановлюємо

250
00:15:21,687 --> 00:15:25,540
0-й, щоб парність повного блоку була парною, як і звичайна перевірка парності.

251
00:15:25,540 --> 00:15:29,563
Тепер, якщо є помилка з одним бітом, то парність повного блоку перемикається на

252
00:15:29,563 --> 00:15:33,940
непарність, але ми все одно вловимо це завдяки чотирьом перевіркам виправлення помилок.

253
00:15:33,940 --> 00:15:38,473
Однак, якщо є дві помилки, тоді загальний паритет повернеться до рівномірного,

254
00:15:38,473 --> 00:15:42,835
але приймач все одно побачить, що сталася принаймні якась помилка через те,

255
00:15:42,835 --> 00:15:45,820
що відбувається з цими чотирма перевірками парності.

256
00:15:45,820 --> 00:15:48,159
Отже, якщо вони помічають рівну парність загалом,

257
00:15:48,159 --> 00:15:51,061
але щось відмінне від нуля відбувається з іншими перевірками,

258
00:15:51,061 --> 00:15:52,980
це говорить їм про принаймні дві помилки.

259
00:15:52,980 --> 00:15:54,420
Хіба це не розумно?

260
00:15:54,420 --> 00:15:57,918
Навіть незважаючи на те, що ми не можемо виправити ці 2-бітові помилки,

261
00:15:57,918 --> 00:16:00,979
просто повернувши цей маленький набридливий 0-й біт до роботи,

262
00:16:00,979 --> 00:16:02,340
це дозволить нам їх виявити.

263
00:16:02,340 --> 00:16:06,540
Це досить стандартний код, він відомий як розширений код Хеммінга.

264
00:16:06,540 --> 00:16:09,592
Технічно кажучи, тепер у вас є повний опис того,

265
00:16:09,592 --> 00:16:13,580
що робить код Хеммінга, принаймні для прикладу 16-бітного блоку.

266
00:16:13,580 --> 00:16:17,726
Але я думаю, що вам буде приємніше перевірити ваше розуміння та закріпити все

267
00:16:17,726 --> 00:16:21,980
до цього моменту, виконавши один повний приклад від початку до кінця самостійно.

268
00:16:21,980 --> 00:16:25,100
Але я пройду це разом з вами, щоб ви могли перевірити самі.

269
00:16:25,100 --> 00:16:28,772
Щоб налаштувати повідомлення, незалежно від того, чи це дослівне повідомлення,

270
00:16:28,772 --> 00:16:31,097
яке ви перекладаєте через простір, чи якісь дані,

271
00:16:31,097 --> 00:16:33,328
які ви хочете зберегти протягом тривалого часу,

272
00:16:33,328 --> 00:16:35,700
перший крок — розділити його на 11-бітні фрагменти.

273
00:16:35,700 --> 00:16:40,340
Кожна частина буде упакована в стійкий до помилок 16-бітний блок.

274
00:16:40,340 --> 00:16:43,740
Отже, давайте візьмемо це як приклад і розберемося.

275
00:16:43,740 --> 00:16:45,380
Давай, справді зроби це!

276
00:16:45,380 --> 00:16:52,980
Давайте зупинимося і спробуємо скласти цей блок.

277
00:16:52,980 --> 00:16:53,980
Гаразд, ти готовий?

278
00:16:53,980 --> 00:16:57,595
Пам’ятайте, що позиція 0 разом з іншими степенями числа 2

279
00:16:57,595 --> 00:17:01,273
зарезервована для виправлення помилок, тому ви починаєте з

280
00:17:01,273 --> 00:17:05,700
розміщення бітів повідомлення в усіх місцях, що залишилися, по порядку.

281
00:17:05,700 --> 00:17:09,447
Вам потрібно, щоб ця група мала рівний паритет, який вона вже має,

282
00:17:09,447 --> 00:17:13,140
тому ви повинні були встановити цей біт парності в позиції 1 на 0.

283
00:17:13,140 --> 00:17:16,107
Наступна група починається з непарної парності,

284
00:17:16,107 --> 00:17:19,260
тому вам слід було встановити її біт парності на 1.

285
00:17:19,260 --> 00:17:21,921
Група після цього починається з непарної парності,

286
00:17:21,921 --> 00:17:24,740
тому ви знову повинні встановити її біт парності на 1.

287
00:17:24,740 --> 00:17:29,365
І остання група також має непарну парність, тобто ми встановили,

288
00:17:29,365 --> 00:17:31,500
що біт у позиції 8 дорівнює 1.

289
00:17:31,500 --> 00:17:36,109
І потім, як останній крок, повний блок тепер має парну парність,

290
00:17:36,109 --> 00:17:41,500
тобто ви можете встановити цей біт номер 0, головний біт парності, рівним 0.

291
00:17:41,500 --> 00:17:45,106
Отже, коли цей блок відправляється, парність чотирьох

292
00:17:45,106 --> 00:17:48,980
спеціальних підмножин і блоку в цілому буде парною, або 0.

293
00:17:48,980 --> 00:17:53,620
У другій частині вправи давайте ви зіграєте роль приймача.

294
00:17:53,620 --> 00:17:57,105
Звичайно, це означатиме, що ви ще не знаєте, що це за повідомлення,

295
00:17:57,105 --> 00:18:00,180
можливо, дехто з вас запам’ятав його, але припустімо, що ні.

296
00:18:00,180 --> 00:18:04,567
Я збираюся змінити 0, 1 або 2 біта в цьому блоці,

297
00:18:04,567 --> 00:18:08,340
а потім попрошу вас зрозуміти, що я зробив.

298
00:18:08,340 --> 00:18:13,460
Тож знову зробіть паузу та спробуйте розібратися.

299
00:18:13,460 --> 00:18:21,483
Отже, ви, як отримувач, тепер перевіряєте першу групу парності, і ви бачите,

300
00:18:21,483 --> 00:18:29,820
що вона парна, тому будь-яка помилка, яка існує, повинна бути в парному стовпці.

301
00:18:29,820 --> 00:18:33,700
Наступна перевірка дає нам непарне число, повідомляючи,

302
00:18:33,700 --> 00:18:38,760
що є принаймні одна помилка, і звужуючи нас до цього конкретного стовпця.

303
00:18:38,760 --> 00:18:42,900
Третя перевірка рівномірна, що ще більше скорочує можливості.

304
00:18:42,900 --> 00:18:46,511
І остання перевірка парності є дивною, повідомляє нам,

305
00:18:46,511 --> 00:18:51,700
що десь внизу є помилка, яка наразі, як ми бачимо, має бути в позиції номер 10.

306
00:18:51,700 --> 00:18:56,327
Більше того, парність усього блоку дивна, що дає нам впевненість,

307
00:18:56,327 --> 00:18:58,220
що був один фліп, а не два.

308
00:18:58,220 --> 00:19:01,600
Якщо їх три або більше, усі ставки скасовуються.

309
00:19:01,600 --> 00:19:05,135
Після виправлення цього біта номер 10, вилучення 11 бітів,

310
00:19:05,135 --> 00:19:09,868
які не були використані для виправлення, дає нам відповідний сегмент вихідного

311
00:19:09,868 --> 00:19:14,662
повідомлення, який, якщо ви перемотуєте назад і порівняєте, справді є саме тим,

312
00:19:14,662 --> 00:19:16,160
з чого ми почали приклад.

313
00:19:16,160 --> 00:19:19,638
І тепер, коли ви знаєте, як зробити все це вручну, я хотів би показати вам,

314
00:19:19,638 --> 00:19:23,619
як ви можете виконати основну частину всієї цієї логіки за допомогою одного рядка коду

315
00:19:23,619 --> 00:19:23,940
Python.

316
00:19:23,940 --> 00:19:28,334
Розумієте, я ще не сказав вам, наскільки елегантним є цей алгоритм,

317
00:19:28,334 --> 00:19:31,760
як просто змусити машину вказувати на місце помилки,

318
00:19:31,760 --> 00:19:37,059
як систематично її масштабувати та як ми можемо створити все це як одна операція,

319
00:19:37,059 --> 00:19:39,580
а не кілька окремих перевірок парності.

320
00:19:39,580 --> 00:19:39,580
Щоб зрозуміти, що я маю на увазі, приєднуйтеся до частини 2.

