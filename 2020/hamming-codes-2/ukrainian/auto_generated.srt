1
00:00:00,000 --> 00:00:02,560
Я припускаю, що всі тут походять із частини 1.

2
00:00:03,060 --> 00:00:06,293
Ми говорили про коди Хеммінга, спосіб створення блоку даних, 

3
00:00:06,293 --> 00:00:08,837
де більшість бітів несуть значуще повідомлення, 

4
00:00:08,837 --> 00:00:12,494
тоді як кілька інших діють як свого роду надлишковість, таким чином, 

5
00:00:12,494 --> 00:00:16,840
що якщо будь-який біт перевертається, або повідомлення біт або біт надлишковості, 

6
00:00:16,840 --> 00:00:21,240
будь-що в цьому блоці, приймач зможе визначити, що була помилка, і як її виправити.

7
00:00:21,880 --> 00:00:23,754
Основна ідея, представлена там, полягала в тому, 

8
00:00:23,754 --> 00:00:27,160
як використовувати кілька перевірок на парність для бінарного пошуку на шляху до помилки.

9
00:00:28,980 --> 00:00:31,763
У цьому відео мета полягала в тому, щоб зробити коди 

10
00:00:31,763 --> 00:00:34,600
Хеммінга максимально практичними та відкритими заново.

11
00:00:35,180 --> 00:00:39,446
Але коли ви починаєте думати про те, щоб реалізувати це в програмному чи апаратному 

12
00:00:39,446 --> 00:00:43,460
забезпеченні, таке фреймування може фактично знизити вартість елегантного коду.

13
00:00:43,920 --> 00:00:46,630
Ви можете подумати, що вам потрібно написати алгоритм, 

14
00:00:46,630 --> 00:00:49,636
який відстежує всі можливі місця помилок і скорочує цю групу 

15
00:00:49,636 --> 00:00:53,480
навпіл під час кожної перевірки, але насправді це набагато, набагато простіше.

16
00:00:53,940 --> 00:00:57,171
Якщо ви зачитаєте відповіді на чотири перевірки парності, 

17
00:00:57,171 --> 00:01:01,015
які ми робили в останньому відео, усі як 1 і 0 замість «так» і «ні», 

18
00:01:01,015 --> 00:01:04,080
це буквально вказує місце помилки в двійковому вигляді.

19
00:01:04,780 --> 00:01:08,668
Наприклад, число 7 у двійковій системі виглядає як 0111, 

20
00:01:08,668 --> 00:01:11,260
по суті кажучи, що це 4 плюс 2 плюс 1.

21
00:01:12,540 --> 00:01:18,812
І зауважте, де знаходиться позиція 7, вона дійсно впливає на першу з наших груп парності, 

22
00:01:18,812 --> 00:01:21,740
і на другу, і на третю, але не на останню.

23
00:01:22,220 --> 00:01:25,084
Отже, читання результатів цих чотирьох перевірок 

24
00:01:25,084 --> 00:01:27,540
знизу вгору справді пояснює місце помилки.

25
00:01:28,320 --> 00:01:31,248
У прикладі 7 немає нічого особливого, загалом це працює, 

26
00:01:31,248 --> 00:01:35,820
і це робить логіку реалізації всієї схеми на апаратному забезпеченні надзвичайно простою.

27
00:01:37,240 --> 00:01:40,636
Тепер, якщо ви хочете зрозуміти, чому відбувається ця магія, 

28
00:01:40,636 --> 00:01:44,423
візьміть ці 16 індексних міток для наших позицій, але замість того, 

29
00:01:44,423 --> 00:01:48,376
щоб записувати їх у базі 10, давайте запишемо їх у двійковому вигляді, 

30
00:01:48,376 --> 00:01:49,880
починаючи від 0000 до 1111.

31
00:01:50,559 --> 00:01:53,465
Коли ми повертаємо ці двійкові мітки назад у свої коробки, 

32
00:01:53,465 --> 00:01:57,800
дозвольте мені підкреслити, що вони відрізняються від даних, які насправді надсилаються.

33
00:01:58,320 --> 00:02:01,803
Вони не що інше, як концептуальний ярлик, який допоможе вам і мені зрозуміти, 

34
00:02:01,803 --> 00:02:03,500
звідки взялися чотири паритетні групи.

35
00:02:04,140 --> 00:02:07,557
Елегантність того, що все, на що ми дивимося, описується у двійковому форматі, 

36
00:02:07,557 --> 00:02:10,153
можливо, підривається плутаниною, пов’язаною з тим, що все, 

37
00:02:10,153 --> 00:02:12,360
на що ми дивимося, описується у двійковому форматі.

38
00:02:13,020 --> 00:02:14,120
Проте воно того варте.

39
00:02:14,800 --> 00:02:19,792
Зосередьте свою увагу лише на останньому фрагменті всіх цих міток, 

40
00:02:19,792 --> 00:02:23,220
а потім виділіть позиції, де останній біт є 1.

41
00:02:24,240 --> 00:02:27,750
Що ми отримуємо, це перша з наших чотирьох груп парності, 

42
00:02:27,750 --> 00:02:32,168
що означає, що ви можете інтерпретувати цю першу перевірку як запитання: 

43
00:02:32,168 --> 00:02:35,740
якщо є помилка, чи є останній біт у позиції цієї помилки 1?

44
00:02:38,200 --> 00:02:42,848
Так само, якщо ви зосередитеся на передостанньому біті та виділите всі позиції, 

45
00:02:42,848 --> 00:02:46,160
де це 1, ви отримаєте другу групу парності з нашої схеми.

46
00:02:46,740 --> 00:02:50,342
Іншими словами, ця друга перевірка запитує, привіт, 

47
00:02:50,342 --> 00:02:54,500
я знову, якщо є помилка, передостанній біт цієї позиції є 1?

48
00:02:55,760 --> 00:02:56,900
І так далі.

49
00:02:57,220 --> 00:03:03,394
Третя перевірка парності охоплює кожну позицію, передостанній біт якої ввімкнено, 

50
00:03:03,394 --> 00:03:08,740
а остання охоплює останні вісім позицій, у яких старший біт дорівнює 1.

51
00:03:09,740 --> 00:03:14,006
Усе, що ми робили раніше, те саме, що відповіді на ці чотири запитання, 

52
00:03:14,006 --> 00:03:17,740
що, у свою чергу, те саме, що виклад позиції в двійковому коді.

53
00:03:19,620 --> 00:03:21,480
Сподіваюся, це зрозуміє дві речі.

54
00:03:22,040 --> 00:03:26,460
По-перше, як систематично узагальнювати розміри блоків, які є більшими степенями двійки.

55
00:03:26,960 --> 00:03:30,474
Якщо для опису кожної позиції потрібно більше бітів, наприклад, 

56
00:03:30,474 --> 00:03:35,142
шість бітів для опису 64 плям, тоді кожен із цих бітів дає вам одну з груп парності, 

57
00:03:35,142 --> 00:03:36,680
яку нам потрібно перевірити.

58
00:03:38,400 --> 00:03:40,210
Тим із вас, хто дивився головоломку на шахівниці, 

59
00:03:40,210 --> 00:03:43,180
яку я розгадував із Метом Паркером, можливо, все це здасться надзвичайно знайомим.

60
00:03:43,660 --> 00:03:46,393
Це та сама основна логіка, але розв’язує іншу проблему 

61
00:03:46,393 --> 00:03:48,780
та застосована до шахової дошки з 64 квадратами.

62
00:03:49,880 --> 00:03:54,566
Друге, що, я сподіваюся, це пояснює, чому наші біти парності сидять у позиціях, 

63
00:03:54,566 --> 00:03:57,320
які є степенями двійки, наприклад, 1, 2, 4 і 8.

64
00:03:58,000 --> 00:04:03,000
Це позиції, двійкове представлення яких має лише один біт.

65
00:04:03,600 --> 00:04:06,759
Це означає, що кожен із цих бітів парності знаходиться 

66
00:04:06,759 --> 00:04:09,460
в одній і лише одній із чотирьох груп парності.

67
00:04:12,040 --> 00:04:15,391
Ви також можете побачити це на більших прикладах, де незалежно від того, 

68
00:04:15,391 --> 00:04:19,339
наскільки великим ви станете, кожен біт парності зручно стосується лише однієї з груп.

69
00:04:25,600 --> 00:04:28,141
Як тільки ви зрозумієте, що ці перевірки парності, 

70
00:04:28,141 --> 00:04:30,981
на яких ми зосередили стільки нашого часу, є не що інше, 

71
00:04:30,981 --> 00:04:34,270
як розумний спосіб виразити позицію помилки в двійковому форматі, 

72
00:04:34,270 --> 00:04:38,755
тоді ми зможемо провести зв’язок з іншим способом уявлення про хемінг коди, який, мабуть, 

73
00:04:38,755 --> 00:04:43,240
є набагато простішим і елегантнішим, і який можна записати за допомогою одного рядка коду.

74
00:04:43,660 --> 00:04:45,500
Він заснований на функції XOR.

75
00:04:46,940 --> 00:04:50,220
XOR, для тих із вас, хто не знає, означає ексклюзивне або.

76
00:04:50,780 --> 00:04:54,409
Коли ви використовуєте XOR двох бітів, він повертає 1, 

77
00:04:54,409 --> 00:04:59,360
якщо один із цих бітів увімкнено, але не якщо обидва увімкнено чи вимкнено.

78
00:05:00,100 --> 00:05:02,980
Іншими словами, це парність цих двох бітів.

79
00:05:03,540 --> 00:05:06,760
Як математик я вважаю за краще думати про це як про додавання 2.

80
00:05:07,360 --> 00:05:10,690
Ми також зазвичай говоримо про XOR двох різних бітових рядків, 

81
00:05:10,690 --> 00:05:13,440
що в основному виконує цей компонент за компонентом.

82
00:05:13,680 --> 00:05:15,720
Це як доповнення, але куди ніколи не понесеш.

83
00:05:16,500 --> 00:05:19,559
Знову ж таки, більш схильні до математики можуть вважати за краще 

84
00:05:19,559 --> 00:05:22,480
думати про це як про додавання двох векторів і зменшення mod 2.

85
00:05:23,500 --> 00:05:26,796
Якщо ви прямо зараз відкриєте якийсь Python і застосуєте операцію 

86
00:05:26,796 --> 00:05:30,093
каретки між двома цілими числами, це буде саме те, що він робить, 

87
00:05:30,093 --> 00:05:32,940
але лише до розрядних представлень цих чисел під капотом.

88
00:05:34,960 --> 00:05:38,910
Ключовим моментом для нас із вами є те, що використання XOR 

89
00:05:38,910 --> 00:05:43,123
багатьох різних бітових рядків є ефективним способом обчислення 

90
00:05:43,123 --> 00:05:47,140
пародії на купу окремих груп, як і зі стовпцями, одним махом.

91
00:05:51,260 --> 00:05:54,846
Це дає нам досить хитрий спосіб уявити, що численні перевірки 

92
00:05:54,846 --> 00:05:58,780
парності з нашого алгоритму коду Хеммінга об’єднані в одну операцію.

93
00:05:59,479 --> 00:06:02,180
Хоча на перший погляд виглядає зовсім інакше.

94
00:06:02,820 --> 00:06:08,070
Зокрема, запишіть 16 позицій у двійковому вигляді, як ми це робили раніше, 

95
00:06:08,070 --> 00:06:12,410
а тепер виділіть позиції, де біт повідомлення ввімкнуто на 1, 

96
00:06:12,410 --> 00:06:17,100
а потім зберіть ці позиції в один великий стовпець і виконайте XOR.

97
00:06:19,260 --> 00:06:23,735
Ви, напевно, можете здогадатися, що 4 біти, які лежать у нижній частині в результаті, 

98
00:06:23,735 --> 00:06:26,754
такі ж, як і 4 перевірки парності, які ми знали і любимо, 

99
00:06:26,754 --> 00:06:29,200
але знайдіть хвилинку, щоб подумати, чому саме.

100
00:06:32,220 --> 00:06:37,492
Цей останній стовпець, наприклад, підраховує всі позиції, останній біт яких дорівнює 1, 

101
00:06:37,492 --> 00:06:42,105
але ми вже обмежені лише виділеними позиціями, тому фактично підраховується, 

102
00:06:42,105 --> 00:06:45,760
скільки виділених позицій походить від першої групи парності.

103
00:06:46,240 --> 00:06:46,800
Чи має це сенс?

104
00:06:49,080 --> 00:06:54,337
Подібним чином у наступному стовпці підраховується кількість позицій у другій 

105
00:06:54,337 --> 00:07:00,000
групі парності, позиції, передостанній біт яких дорівнює 1, які також виділені тощо.

106
00:07:00,260 --> 00:07:03,960
Насправді це лише невелика зміна погляду на те саме, що ми робили.

107
00:07:07,760 --> 00:07:09,600
І ви знаєте, куди це йде.

108
00:07:10,000 --> 00:07:13,677
Відправник відповідає за перемикання деяких спеціальних бітів парності, 

109
00:07:13,677 --> 00:07:15,720
щоб переконатися, що сума дорівнює 0000.

110
00:07:15,720 --> 00:07:21,901
Тепер, коли ми маємо це таким чином, це дає нам дійсно гарний спосіб подумати про те, 

111
00:07:21,901 --> 00:07:27,580
чому ці чотири результуючих біта внизу безпосередньо вказують на місце помилки.

112
00:07:28,460 --> 00:07:31,860
Припустимо, якийсь біт у цьому блоці перемикається з 0 на 1.

113
00:07:32,600 --> 00:07:38,375
Це означає, що позиція цього біта тепер буде включена в загальне XOR, 

114
00:07:38,375 --> 00:07:43,820
яке змінює суму з 0 на це нове включене значення, позицію помилки.

115
00:07:44,460 --> 00:07:49,360
Трохи менш очевидно, те ж саме вірно, якщо є помилка, яка змінює 1 на 0.

116
00:07:50,180 --> 00:07:53,762
Розумієте, якщо ви двічі додаєте бітовий рядок, це все одно, 

117
00:07:53,762 --> 00:07:57,580
що його взагалі немає, тому що в цьому світі 1 плюс 1 дорівнює 0.

118
00:07:57,580 --> 00:08:02,839
Тож додавання копії цієї позиції до загальної суми має той самий ефект, 

119
00:08:02,839 --> 00:08:04,300
що й її переміщення.

120
00:08:05,160 --> 00:08:07,708
І цей ефект, знову ж таки, полягає в тому, що 

121
00:08:07,708 --> 00:08:10,700
загальний результат унизу тут вказує на місце помилки.

122
00:08:13,039 --> 00:08:17,141
Щоб проілюструвати, наскільки це елегантно, дозвольте мені показати той рядок коду 

123
00:08:17,141 --> 00:08:21,440
Python, на який я посилався раніше, який захопить майже всю логіку на стороні приймача.

124
00:08:22,080 --> 00:08:26,635
Ми почнемо зі створення випадкового масиву з 16 1 і 0 для імітації блоку даних, 

125
00:08:26,635 --> 00:08:30,394
і я дам йому біти назви, але, звичайно, на практиці це буде щось, 

126
00:08:30,394 --> 00:08:33,924
що ми отримуємо від відправника, а замість будучи випадковим, 

127
00:08:33,924 --> 00:08:37,000
він містив би 11 біт даних разом із 5 бітами парності.

128
00:08:37,000 --> 00:08:41,960
Якщо я викликаю функцію enumerateBits, вона об’єднає кожен із 

129
00:08:41,960 --> 00:08:47,000
цих бітів із відповідним індексом, у цьому випадку від 0 до 15.

130
00:08:48,180 --> 00:08:52,545
Отже, якщо ми створимо список, який циклічно перебирає всі ці пари, 

131
00:08:52,545 --> 00:08:56,525
пари, які виглядають як i, а потім витягуємо лише значення i, 

132
00:08:56,525 --> 00:09:01,340
лише індекс, це не так цікаво, ми просто повертаємо ті індекси від 0 до 15.

133
00:09:01,680 --> 00:09:07,098
Але якщо ми додамо умову робити це тільки якщо біт, тобто якщо цей біт є 1, 

134
00:09:07,098 --> 00:09:12,660
а не 0, добре, тоді він вилучає лише ті позиції, де відповідний біт увімкнено.

135
00:09:13,380 --> 00:09:20,360
У цьому випадку виглядає так, ніби ці позиції 0, 4, 6, 9 тощо.

136
00:09:20,720 --> 00:09:23,980
Те, що ми хочемо, це зібрати разом усі ці позиції, 

137
00:09:23,980 --> 00:09:27,240
позиції бітів, які ввімкнено, а потім XOR їх разом.

138
00:09:29,180 --> 00:09:33,220
Щоб зробити це в Python, дозвольте мені спочатку імпортувати кілька корисних функцій.

139
00:09:33,900 --> 00:09:37,884
Таким чином ми можемо викликати reduce() у цьому списку та використовувати функцію XOR, 

140
00:09:37,884 --> 00:09:38,700
щоб зменшити його.

141
00:09:39,100 --> 00:09:42,680
Це в основному з'їдає собі шлях через список, використовуючи по дорозі XOR.

142
00:09:44,800 --> 00:09:47,054
Якщо ви бажаєте, ви можете явно написати цю функцію 

143
00:09:47,054 --> 00:09:49,440
XOR без необхідності імпортувати її з будь-якого місця.

144
00:09:51,940 --> 00:09:56,231
Отже, на даний момент виглядає так, що якщо ми зробимо це на нашому 

145
00:09:56,231 --> 00:10:01,280
випадковому блоці з 16 біт, він поверне 9, який має двійкове представлення 1001.

146
00:10:01,980 --> 00:10:05,090
Ми не будемо цього робити тут, але ви можете написати функцію, 

147
00:10:05,090 --> 00:10:07,954
у якій відправник використовує це двійкове представлення, 

148
00:10:07,954 --> 00:10:12,102
щоб за потреби встановити чотири біти парності, зрештою переводячи цей блок у стан, 

149
00:10:12,102 --> 00:10:15,460
коли виконання цього рядка коду з повним списком бітів повертає а 0.

150
00:10:16,080 --> 00:10:20,100
Це буде вважатися добре підготовленим блоком.

151
00:10:20,100 --> 00:10:24,090
Цікаво те, що якщо ми перемикаємо будь-який із бітів у цьому списку, 

152
00:10:24,090 --> 00:10:28,947
імітуючи випадкову помилку через шум, тоді, якщо ви запустите цей самий рядок коду, 

153
00:10:28,947 --> 00:10:30,220
він виведе цю помилку.

154
00:10:30,960 --> 00:10:31,520
Хіба це не гарно?

155
00:10:31,820 --> 00:10:36,800
Ви можете отримати цей блок зненацька, запустити на ньому цей єдиний рядок, 

156
00:10:36,800 --> 00:10:41,060
і він автоматично видасть позицію помилки або 0, якщо її не було.

157
00:10:42,500 --> 00:10:44,840
І нічого особливого в 16 розмірі тут немає.

158
00:10:44,840 --> 00:10:49,860
Той самий рядок коду спрацював би, якби у вас був список із, скажімо, 256 біт.

159
00:10:51,880 --> 00:10:54,822
Зайве говорити, що тут потрібно написати більше коду, 

160
00:10:54,822 --> 00:10:58,255
як-от мета-перевірку парності для виявлення 2-бітових помилок, 

161
00:10:58,255 --> 00:11:02,343
але ідея полягає в тому, що майже вся основна логіка нашої схеми зводиться 

162
00:11:02,343 --> 00:11:03,760
до єдиного скорочення XOR.

163
00:11:06,120 --> 00:11:10,377
Тепер, залежно від вашого комфорту з двійковими кодами та XOR та програмним забезпеченням 

164
00:11:10,377 --> 00:11:13,405
загалом, ви можете або вважати цю перспективу трохи заплутаною, 

165
00:11:13,405 --> 00:11:16,243
або настільки більш елегантною та простою, що ви дивуєтеся, 

166
00:11:16,243 --> 00:11:18,420
чому ми не почали з неї з самого початку -іди.

167
00:11:19,140 --> 00:11:22,404
Грубо кажучи, про перспективу множинної перевірки парності легше подумати, 

168
00:11:22,404 --> 00:11:25,842
якщо реалізовувати коди Хеммінга в апаратному забезпеченні дуже безпосередньо, 

169
00:11:25,842 --> 00:11:29,455
а про перспективу XOR найпростіше подумати, роблячи це в програмному забезпеченні, 

170
00:11:29,455 --> 00:11:30,500
на більш високому рівні.

171
00:11:31,360 --> 00:11:34,179
Перший з них найлегше зробити вручну, і я думаю, 

172
00:11:34,179 --> 00:11:37,630
що він краще справляється з прищепленням основної інтуїції, 

173
00:11:37,630 --> 00:11:41,197
яка лежить в основі всього цього, а саме того, що інформація, 

174
00:11:41,197 --> 00:11:45,512
необхідна для пошуку однієї помилки, пов’язана з журналом розміру блоку. , 

175
00:11:45,512 --> 00:11:50,000
або іншими словами, він зростає по одному біту, коли розмір блоку подвоюється.

176
00:11:51,020 --> 00:11:54,516
Релевантним фактом тут є те, що ця інформація безпосередньо відповідає тому, 

177
00:11:54,516 --> 00:11:56,060
скільки резервування нам потрібно.

178
00:11:56,660 --> 00:11:59,451
Це насправді суперечить реагування більшості людей на колінах, 

179
00:11:59,451 --> 00:12:02,906
коли вони вперше думають про те, щоб зробити повідомлення стійким до помилок, 

180
00:12:02,906 --> 00:12:06,540
де зазвичай скопіювати все повідомлення є першим інстинктом, який спадає на думку.

181
00:12:07,500 --> 00:12:11,532
І, до речі, є цілий інший спосіб, у який ви іноді бачите представлені коди Хеммінга, 

182
00:12:11,532 --> 00:12:14,000
коли ви множите повідомлення на одну велику матрицю.

183
00:12:14,670 --> 00:12:18,513
Це начебто добре, тому що це пов’язує його з більш широкою сім’єю лінійних кодів, 

184
00:12:18,513 --> 00:12:20,950
але я думаю, що це майже не дає інтуїції щодо того, 

185
00:12:20,950 --> 00:12:23,060
звідки він походить або як він масштабується.

186
00:12:25,200 --> 00:12:27,488
Говорячи про масштабування, ви можете помітити, 

187
00:12:27,488 --> 00:12:31,160
що ефективність цієї схеми стає лише кращою, коли ми збільшуємо розмір блоку.

188
00:12:35,000 --> 00:12:38,771
Наприклад, ми бачили, що з 256 бітами ви використовуєте лише 3% 

189
00:12:38,771 --> 00:12:42,660
цього простору для резервування, і з цього моменту все стає краще.

190
00:12:43,300 --> 00:12:45,776
Оскільки кількість бітів парності зростає один за одним, 

191
00:12:45,776 --> 00:12:47,340
розмір блоку продовжує подвоюватися.

192
00:12:49,000 --> 00:12:52,865
І якщо ви доведете це до крайності, у вас може бути блок, скажімо, 

193
00:12:52,865 --> 00:12:57,712
з мільйоном біт, де ви б буквально відтворювали 20 запитань із перевіркою парності, 

194
00:12:57,712 --> 00:13:00,020
і він використовує лише 21 біт парності.

195
00:13:00,740 --> 00:13:03,925
І якщо ви відступите назад, щоб подумати про перегляд мільйона 

196
00:13:03,925 --> 00:13:07,060
бітів і пошук однієї помилки, це справді виглядає божевільним.

197
00:13:08,199 --> 00:13:12,765
Проблема, звісно, полягає в тому, що з більшим блоком зростає ймовірність побачити 

198
00:13:12,765 --> 00:13:17,660
більше однієї або двох бітових помилок, а коди Хеммінга не обробляють нічого, крім цього.

199
00:13:18,320 --> 00:13:20,720
Тож на практиці вам потрібно знайти правильний розмір, 

200
00:13:20,720 --> 00:13:24,300
щоб ймовірність занадто великої кількості перевертань бітів не була надто високою.

201
00:13:26,600 --> 00:13:30,171
Крім того, на практиці помилки, як правило, виникають невеликими пакетами, 

202
00:13:30,171 --> 00:13:33,170
які повністю знищують один блок, тому одна з поширених тактик, 

203
00:13:33,170 --> 00:13:36,551
щоб допомогти розподілити сплеск помилок між багатьма різними блоками, 

204
00:13:36,551 --> 00:13:38,837
полягає в тому, щоб переплести ці блоки, як це, 

205
00:13:38,837 --> 00:13:40,980
перш ніж вони будуть розіслано або збережено.

206
00:13:45,580 --> 00:13:49,547
Знову ж таки, багато чого з цього стає абсолютно спірним через більш сучасні коди, 

207
00:13:49,547 --> 00:13:52,606
як-от набагато частіше використовуваний алгоритм Ріда-Соломона, 

208
00:13:52,606 --> 00:13:56,238
який особливо добре обробляє пакетні помилки, і його можна налаштувати так, 

209
00:13:56,238 --> 00:13:58,820
щоб бути стійким до більшої кількості помилок на блок.

210
00:13:59,360 --> 00:14:01,340
Але це тема іншого разу.

211
00:14:02,500 --> 00:14:06,123
У своїй книзі «Мистецтво займатися наукою та технікою» Хеммінг надзвичайно 

212
00:14:06,123 --> 00:14:09,940
відверто розповідає про те, наскільки звивистим було його відкриття цього коду.

213
00:14:10,620 --> 00:14:14,435
Спочатку він випробував усілякі різні схеми, що передбачають організацію 

214
00:14:14,435 --> 00:14:17,780
бітів у частини решітки вищого виміру та такі дивні речі, як ця.

215
00:14:18,300 --> 00:14:22,250
Ідея про те, що можна змусити перевірку парності конспірувати таким чином, 

216
00:14:22,250 --> 00:14:25,410
щоб визначити місце помилки, прийшла до Геммінга лише тоді, 

217
00:14:25,410 --> 00:14:29,939
коли він відступив після купи інших аналізів і запитав: гаразд, що є найефективнішим, 

218
00:14:29,939 --> 00:14:31,520
що я можу можливо бути про це?

219
00:14:32,620 --> 00:14:37,550
Він також був відвертим, наскільки важливо, щоб він уже думав про перевірку парності, 

220
00:14:37,550 --> 00:14:41,220
яка була б набагато менш поширеною в 1940-х роках, ніж сьогодні.

221
00:14:41,920 --> 00:14:46,058
У цій книзі він півдюжини разів посилається на цитату Луї Пастера: 

222
00:14:46,058 --> 00:14:48,220
удача сприяє підготовленому розуму.

223
00:14:49,320 --> 00:14:54,300
Розумні ідеї часто виглядають оманливо простими, тому їх легко недооцінити.

224
00:14:54,960 --> 00:14:58,245
Наразі я щиро сподіваюся, що коди Хеммінга або принаймні 

225
00:14:58,245 --> 00:15:01,300
можливість таких кодів здаються вам майже очевидними.

226
00:15:01,660 --> 00:15:05,530
Але ви не повинні обманювати себе, думаючи, що вони насправді очевидні, 

227
00:15:05,530 --> 00:15:06,820
тому що це точно не так.

228
00:15:07,880 --> 00:15:11,333
Однією з причин того, що розумні ідеї виглядають оманливо легко, є те, 

229
00:15:11,333 --> 00:15:14,980
що ми завжди бачимо лише кінцевий результат, очищаємо те, що було брудним, 

230
00:15:14,980 --> 00:15:17,850
ніколи не згадуємо всі неправильні повороти, недооцінюючи, 

231
00:15:17,850 --> 00:15:21,644
наскільки величезним є простір досліджуваних можливостей на початку проблеми. 

232
00:15:21,644 --> 00:15:22,860
процес вирішення, все це.

233
00:15:23,820 --> 00:15:24,900
Але в цілому це вірно.

234
00:15:24,900 --> 00:15:27,805
Я думаю, що для деяких особливих винаходів є друга, 

235
00:15:27,805 --> 00:15:30,040
глибша причина, чому ми їх недооцінюємо.

236
00:15:30,840 --> 00:15:34,716
Розуміння інформації в термінах бітів справді об’єдналося в повну теорію лише до 

237
00:15:34,716 --> 00:15:38,640
1948 року, коли Клод Шеннон опублікував фундаментальну статтю з теорії інформації.

238
00:15:39,280 --> 00:15:42,540
Це практично збігалося з тим, коли Хеммінг розробив свій алгоритм.

239
00:15:43,300 --> 00:15:46,653
Це був той самий основоположний документ, який показав, у певному сенсі, 

240
00:15:46,653 --> 00:15:49,822
що ефективне виправлення помилок завжди можливе, незалежно від того, 

241
00:15:49,822 --> 00:15:52,900
наскільки висока ймовірність перевертань бітів, принаймні в теорії.

242
00:15:53,700 --> 00:15:57,404
Шеннон і Хеммінг, до речі, ділилися офісом у Bell Labs, незважаючи на те, 

243
00:15:57,404 --> 00:16:01,160
що працювали над дуже різними речами, що навряд чи здається тут випадковим.

244
00:16:02,380 --> 00:16:05,681
Перемотуємо вперед на кілька десятиліть, і сьогодні багато з 

245
00:16:05,681 --> 00:16:08,767
нас настільки занурені в роздуми про біти та інформацію, 

246
00:16:08,767 --> 00:16:12,340
що легко не помітити, наскільки відмінним був цей спосіб мислення.

247
00:16:13,100 --> 00:16:17,739
За іронією долі, ідеї, які найглибше формують уявлення майбутнього покоління, 

248
00:16:17,739 --> 00:16:22,260
зрештою виглядатимуть це майбутнє покоління простішим, ніж воно є насправді.

