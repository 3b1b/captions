1
00:00:00,000 --> 00:00:05,686
Чи замислювалися ви коли-небудь про те, як можна подряпати компакт-диск

2
00:00:05,686 --> 00:00:10,900
або DVD-диск і все одно відтворювати те, що на ньому зберігається?

3
00:00:10,900 --> 00:00:16,733
Подряпина справді впливає на 1 і 0 на диску, тому він зчитує дані, відмінні від того, що

4
00:00:16,733 --> 00:00:22,632
зберігається, але якщо він справді не подряпаний, біти, які він зчитує, декодуються в той

5
00:00:22,632 --> 00:00:28,400
самий файл, який був закодований на ньому, побітова копія, незважаючи на всі ці помилки.

6
00:00:28,400 --> 00:00:32,592
Існує ціла купа математичної кмітливості, яка дозволяє нам зберігати дані,

7
00:00:32,592 --> 00:00:36,840
і, що не менш важливо, передавати дані, у спосіб, який є стійким до помилок.

8
00:00:36,840 --> 00:00:42,480
Ну, гаразд, насправді не потрібно так багато кмітливості, щоб придумати спосіб це зробити.

9
00:00:42,480 --> 00:00:46,550
Будь-який файл, чи то відео, чи звук, чи текст, якийсь код,

10
00:00:46,550 --> 00:00:50,960
зображення тощо, зрештою, є певною послідовністю одиниць і нулів.

11
00:00:50,960 --> 00:00:54,339
І простою стратегією виправлення будь-якого біта, який

12
00:00:54,339 --> 00:00:57,780
перевертається, було б зберігати три копії кожного біта.

13
00:00:57,780 --> 00:01:02,481
Тоді машина, яка читає цей файл, може порівняти ці три

14
00:01:02,481 --> 00:01:07,440
копії та завжди брати найкращі 2 із 3, якщо є розбіжності.

15
00:01:07,440 --> 00:01:11,560
Але це означає використання двох третин вашого простору для резервування.

16
00:01:11,560 --> 00:01:14,705
І навіть тоді, незважаючи на весь цей вільний простір, немає надійної

17
00:01:14,705 --> 00:01:18,120
гарантії щодо того, що станеться, якщо буде перевернуто більше ніж один біт.

18
00:01:18,120 --> 00:01:21,430
Набагато цікавіше питання полягає в тому, як зробити так, щоб

19
00:01:21,430 --> 00:01:24,740
можна було виправляти помилки, звільняючи якомога менше місця.

20
00:01:24,740 --> 00:01:28,830
Наприклад, використовуючи метод, який ви дізнаєтеся про це відео, ви можете

21
00:01:28,830 --> 00:01:32,975
зберігати свої дані у 256-бітних блоках, де кожен блок використовує 9 біт, 9!

22
00:01:32,975 --> 00:01:37,107
щоб діяти як своєрідна надлишковість, а інші 247 бітів можуть вільно

23
00:01:37,107 --> 00:01:41,000
переносити будь-які значущі повідомлення або дані, які ви хочете.

24
00:01:41,000 --> 00:01:44,868
І все одно буде так, що якщо будь-який біт тут буде перевернуто,

25
00:01:44,868 --> 00:01:49,152
просто подивившись на цей блок і нічого більше, машина зможе визначити,

26
00:01:49,152 --> 00:01:53,140
що була помилка, і точно, де вона була, щоб знати, як її виправити.

27
00:01:53,140 --> 00:01:55,540
І, чесно кажучи, це виглядає як магія.

28
00:01:55,540 --> 00:01:59,508
І для цієї конкретної схеми, якщо два біти будуть перевернуті, машина принаймні

29
00:01:59,508 --> 00:02:03,180
зможе виявити, що було дві помилки, хоча вона не знатиме, як їх виправити.

30
00:02:03,180 --> 00:02:08,140
Трохи пізніше ми поговоримо про те, як це масштабується для блоків різних розмірів.

31
00:02:08,140 --> 00:02:10,895
Методи, які дозволяють виправляти такі помилки,

32
00:02:10,895 --> 00:02:13,880
відомі, досить розумно, як коди виправлення помилок.

33
00:02:13,880 --> 00:02:18,305
Протягом більшої частини минулого століття ця сфера була справді багатим джерелом

34
00:02:18,305 --> 00:02:23,000
напрочуд глибокої математики, яка вбудовується в пристрої, якими ми користуємося щодня.

35
00:02:23,000 --> 00:02:26,330
Мета тут — дати вам дуже повне розуміння одного

36
00:02:26,330 --> 00:02:29,660
з найперших прикладів, відомого як код Хеммінга.

37
00:02:29,660 --> 00:02:33,180
І, до речі, те, як я думаю про структуру цього відео, полягає не

38
00:02:33,180 --> 00:02:36,537
в тому, щоб пояснити це якомога пряміше, а більше в тому, щоб

39
00:02:36,537 --> 00:02:40,220
спонукати вас придумати це для себе, з легкими вказівками тут і там.

40
00:02:40,220 --> 00:02:43,544
Тож коли ви відчуєте, що в якийсь момент бачите, куди це йде, візьміть цей

41
00:02:43,544 --> 00:02:47,180
момент, щоб зупинитися, активно передбачте, якою буде схема, перш ніж я скажу вам.

42
00:02:47,180 --> 00:02:51,275
Крім того, якщо ви хочете, щоб ваше розуміння перейшло до апаратного рівня,

43
00:02:51,275 --> 00:02:55,478
Бен Ітер створив відео в поєднанні з цим відео, яке показує вам, як насправді

44
00:02:55,478 --> 00:02:59,520
впроваджувати коди Хеммінга на макетних платах, що надзвичайно задовольняє.

45
00:02:59,520 --> 00:03:03,224
Ви повинні знати, що коди Хеммінга не так широко використовуються, як більш

46
00:03:03,224 --> 00:03:06,831
сучасні коди, як-от алгоритм Ріда-Соломона, але є певна магія в контрасті

47
00:03:06,831 --> 00:03:10,389
між тим, наскільки нездійсненним це завдання здається на початку, і тим,

48
00:03:10,389 --> 00:03:14,240
наскільки цілком розумним воно здається одного разу ви дізнаєтесь про Хеммінга.

49
00:03:14,240 --> 00:03:18,550
Основний принцип виправлення помилок полягає в тому, що у величезному просторі всіх

50
00:03:18,550 --> 00:03:22,860
можливих повідомлень лише деякі підмножини будуть вважатися дійсними повідомленнями.

51
00:03:22,860 --> 00:03:29,100
Як аналогію, подумайте про правильно написані слова проти неправильно написаних слів.

52
00:03:29,100 --> 00:03:33,318
Щоразу, коли дійсне повідомлення змінюється, одержувач несе відповідальність за

53
00:03:33,318 --> 00:03:37,905
виправлення того, що він бачить, до найближчого дійсного сусіда, як це можна зробити з

54
00:03:37,905 --> 00:03:38,380
помилкою.

55
00:03:38,380 --> 00:03:42,420
Проте розробка конкретного алгоритму для ефективної

56
00:03:42,420 --> 00:03:47,160
класифікації подібних повідомлень вимагає певної кмітливості.

57
00:03:47,160 --> 00:03:50,580
Історія починається в 1940-х роках, коли молодий Річард Хеммінг працював

58
00:03:50,580 --> 00:03:53,906
у Bell Labs, і частина його роботи включала використання дуже великого

59
00:03:53,906 --> 00:03:57,420
дорогого комп’ютера з перфокартами, до якого він мав лише обмежений доступ.

60
00:03:57,420 --> 00:04:00,089
І програми, які він постійно вставляв у нього, постійно

61
00:04:00,089 --> 00:04:03,140
виходили з ладу, тому що час від часу щось неправильно читалося.

62
00:04:03,140 --> 00:04:05,926
Розчарування, будучи горнилом винахідництва, йому так

63
00:04:05,926 --> 00:04:09,280
набридло, що він винайшов перший у світі код виправлення помилок.

64
00:04:09,280 --> 00:04:12,950
Є багато різних способів створення кодів Хеммінга, але для

65
00:04:12,950 --> 00:04:16,620
початку ми розглянемо це так, як сам Хеммінг думав про них.

66
00:04:16,620 --> 00:04:21,400
Давайте використаємо простий, але не дуже простий приклад, блок із 16 біт.

67
00:04:21,400 --> 00:04:25,700
Ми пронумеруємо позиції цих бітів від 0 до 15.

68
00:04:25,700 --> 00:04:29,840
Фактичні дані, які ми хочемо зберігати, складатимуть лише 12 із цих

69
00:04:29,840 --> 00:04:33,920
бітів, тоді як 4 позиції зарезервовано як свого роду надлишковість.

70
00:04:33,920 --> 00:04:37,035
Слово надлишковий тут не просто означає копіювання, зрештою, ці

71
00:04:37,035 --> 00:04:40,200
4 біти не дають нам достатньо місця для сліпого копіювання даних.

72
00:04:40,200 --> 00:04:44,316
Натомість вони повинні бути набагато більш тонкими та розумними як

73
00:04:44,316 --> 00:04:48,740
резервування, не додаючи жодної нової інформації, але додаючи стійкості.

74
00:04:48,740 --> 00:04:52,530
Ви можете очікувати, що ці 4 спеціальні біти будуть гарно зібрані разом,

75
00:04:52,530 --> 00:04:56,269
можливо, в кінці або щось подібне, але, як ви побачите, розміщення їх у

76
00:04:56,269 --> 00:05:00,320
позиціях, які є степенями 2, дозволяє отримати щось справді елегантне в кінці.

77
00:05:00,320 --> 00:05:05,420
Це також може дати вам невелику підказку про те, як це масштабується для більших блоків.

78
00:05:05,420 --> 00:05:09,630
Крім того, технічно це лише 11 біт даних, ви побачите, що є легкий

79
00:05:09,630 --> 00:05:14,280
нюанс у тому, що відбувається в позиції 0, але не хвилюйтеся про це зараз.

80
00:05:14,280 --> 00:05:18,223
Як і в будь-якому іншому алгоритмі виправлення помилок, у цьому будуть задіяні

81
00:05:18,223 --> 00:05:22,266
два гравці: відправник, який відповідає за встановлення цих 4 спеціальних бітів,

82
00:05:22,266 --> 00:05:26,360
і одержувач, який відповідає за виконання певної перевірки та виправлення помилок.

83
00:05:26,360 --> 00:05:29,285
Звичайно, слова «відправник» і «одержувач» справді стосуються машин

84
00:05:29,285 --> 00:05:32,038
або програмного забезпечення, яке виконує всі перевірки, і ідея

85
00:05:32,038 --> 00:05:35,480
повідомлення має на увазі дуже широке значення, включаючи такі речі, як сховище.

86
00:05:35,480 --> 00:05:38,681
Зрештою, зберігання даних — це те саме, що відправляти

87
00:05:38,681 --> 00:05:42,640
повідомлення лише з минулого в майбутнє, а не з одного місця в інше.

88
00:05:42,640 --> 00:05:46,113
Отже, це налаштування, але перш ніж ми зможемо зануритися в це, нам

89
00:05:46,113 --> 00:05:49,893
потрібно поговорити про пов’язану ідею, яка була свіжою в голові Геммінга

90
00:05:49,893 --> 00:05:53,673
під час його відкриття, метод, який дозволяє виявляти будь-які однобітові

91
00:05:53,673 --> 00:05:57,300
помилки, але не виправляти їх, відомий у бізнесі як перевірка паритету.

92
00:05:57,300 --> 00:06:01,015
Для перевірки парності ми відокремлюємо лише один біт, за налаштування

93
00:06:01,015 --> 00:06:04,940
якого відповідає відправник, а решта можуть вільно передавати повідомлення.

94
00:06:04,940 --> 00:06:08,204
Єдина робота цього спеціального біта полягає в тому, щоб

95
00:06:08,204 --> 00:06:12,100
переконатися, що загальна кількість одиниць у повідомленні є парною.

96
00:06:12,100 --> 00:06:16,308
Так, наприклад, зараз загальна кількість одиниць дорівнює 7, це дивно, тому

97
00:06:16,308 --> 00:06:20,960
відправнику потрібно перевернути цей спеціальний біт на 1, роблячи кількість парних.

98
00:06:20,960 --> 00:06:24,289
Але якби блок уже почався з парної кількості 1,

99
00:06:24,289 --> 00:06:27,480
тоді цей спеціальний біт залишився б рівним 0.

100
00:06:27,480 --> 00:06:32,746
Це досить просто, оманливо просто, але це неймовірно елегантний спосіб дистилювати

101
00:06:32,746 --> 00:06:37,760
ідею зміни будь-де в повідомленні, щоб її відобразити в одному біті інформації.

102
00:06:37,760 --> 00:06:42,845
Зверніть увагу, якщо будь-який біт цього повідомлення перевертається з 0

103
00:06:42,845 --> 00:06:48,140
на 1 або з 1 на 0, це змінює загальну кількість одиниць з парної на непарну.

104
00:06:48,140 --> 00:06:51,471
Отже, якщо ви одержувач, ви дивитеся на це повідомлення та

105
00:06:51,471 --> 00:06:54,860
бачите непарну кількість одиниць, ви можете точно знати, що

106
00:06:54,860 --> 00:06:58,700
сталася якась помилка, навіть якщо ви можете не знати, де вона була.

107
00:06:58,700 --> 00:07:04,940
На жаргоні парність у групі бітів називається її парністю.

108
00:07:04,940 --> 00:07:08,024
Ви також можете використовувати числа та сказати, що парність дорівнює 0

109
00:07:08,024 --> 00:07:11,320
або 1, що зазвичай стає більш корисним, коли ви починаєте обчислювати цю ідею.

110
00:07:11,320 --> 00:07:14,735
І цей спеціальний біт, який відправник використовує

111
00:07:14,735 --> 00:07:18,020
для контролю парності, називається бітом парності.

112
00:07:18,020 --> 00:07:21,850
І насправді, ми маємо чітко уточнити: якщо отримувач бачить непарну парність,

113
00:07:21,850 --> 00:07:25,582
це не обов’язково означає, що була лише одна помилка, могло бути 3 помилки,

114
00:07:25,582 --> 00:07:29,560
або 5, або будь-яке інше непарне число, але вони можуть знати напевно що це не 0.

115
00:07:29,560 --> 00:07:34,336
З іншого боку, якби було 2 помилки або будь-яка парна кількість помилок, кінцева

116
00:07:34,336 --> 00:07:38,701
кількість 1с все одно була б парною, тому одержувач не може бути повністю

117
00:07:38,701 --> 00:07:43,360
впевненим, що парна кількість обов’язково означає, що повідомлення без помилок.

118
00:07:43,360 --> 00:07:46,560
Ви можете поскаржитися на те, що повідомлення, яке спотворюється

119
00:07:46,560 --> 00:07:49,760
лише двома бітами, є досить слабким, і ви будете абсолютно праві.

120
00:07:49,760 --> 00:07:53,226
Однак пам’ятайте, що не існує методу виявлення або виправлення

121
00:07:53,226 --> 00:07:56,418
помилок, який міг би дати вам 100% впевненість у тому, що

122
00:07:56,418 --> 00:07:59,720
отримане вами повідомлення – це те, що мав намір відправник.

123
00:07:59,720 --> 00:08:02,793
Зрештою, достатня кількість випадкового шуму завжди може

124
00:08:02,793 --> 00:08:05,920
змінити одне дійсне повідомлення на інше просто випадково.

125
00:08:05,920 --> 00:08:11,352
Натомість мета полягає в тому, щоб створити схему, яка є надійною до певної максимальної

126
00:08:11,352 --> 00:08:16,480
кількості помилок, або, можливо, зменшити ймовірність хибного спрацьовування, як це.

127
00:08:16,480 --> 00:08:20,214
Перевірки на парність самі по собі є досить слабкими, але,

128
00:08:20,214 --> 00:08:23,885
зводячи ідею зміни в повному повідомленні до одного біта,

129
00:08:23,885 --> 00:08:28,000
вони дають нам потужний будівельний блок для більш складних схем.

130
00:08:28,000 --> 00:08:31,757
Наприклад, коли Хеммінг шукав спосіб визначити, де сталася помилка, а не

131
00:08:31,757 --> 00:08:35,412
просто те, що вона сталася, його ключове розуміння полягало в тому, що

132
00:08:35,412 --> 00:08:39,170
якщо ви застосовуєте деякі перевірки парності не до всього повідомлення,

133
00:08:39,170 --> 00:08:42,670
а до певних ретельно відібраних підмножин, ви можете запитати більш

134
00:08:42,670 --> 00:08:46,840
витончену серію запитань, які визначають місце будь-якої окремої бітової помилки.

135
00:08:46,840 --> 00:08:50,420
Загальне відчуття трохи схоже на гру з 20 запитань, задаючи

136
00:08:50,420 --> 00:08:54,300
запити «так» або «ні», які розрізають простір можливостей навпіл.

137
00:08:54,300 --> 00:08:57,237
Наприклад, скажімо, ми виконуємо перевірку парності

138
00:08:57,237 --> 00:09:00,400
лише для цих 8 бітів, усіх позицій з непарними номерами.

139
00:09:00,400 --> 00:09:04,749
Потім, якщо виявлено помилку, це дає одержувачу трохи більше інформації

140
00:09:04,749 --> 00:09:09,160
про те, де саме є помилка, а саме, що він знаходиться в непарній позиції.

141
00:09:09,160 --> 00:09:13,139
Якщо серед цих 8 бітів не виявлено жодної помилки, це означає, що

142
00:09:13,139 --> 00:09:17,240
помилки немає взагалі, або вона знаходиться десь на парних позиціях.

143
00:09:17,240 --> 00:09:21,437
Ви можете подумати, що обмеження перевірки парності половиною бітів робить

144
00:09:21,437 --> 00:09:25,242
її менш ефективною, але коли це робиться в поєднанні з іншими добре

145
00:09:25,242 --> 00:09:29,720
підібраними перевірками, це суперечить інтуїції дає нам щось набагато потужніше.

146
00:09:29,720 --> 00:09:33,835
Пам’ятайте, що для того, щоб фактично налаштувати цю перевірку парності, потрібно

147
00:09:33,835 --> 00:09:37,600
виділити якийсь спеціальний біт, який контролює парність цієї повної групи.

148
00:09:37,600 --> 00:09:39,920
Давайте просто виберемо позицію 1.

149
00:09:39,920 --> 00:09:44,334
У наведеному прикладі парність цих 8 бітів наразі непарна, тому відправник

150
00:09:44,334 --> 00:09:48,220
відповідає за перемикання цього біта парності, і тепер він парний.

151
00:09:48,220 --> 00:09:51,040
Це лише 1 із 4 перевірок парності, які ми зробимо.

152
00:09:51,040 --> 00:09:53,849
Друга перевірка знаходиться серед 8 бітів у правій

153
00:09:53,849 --> 00:09:56,880
половині сітки, принаймні так, як ми її тут намалювали.

154
00:09:56,880 --> 00:10:01,960
Цього разу ми можемо використати позицію 2 як біт парності, тому ці 8 бітів уже мають

155
00:10:01,960 --> 00:10:07,160
рівну парність, і відправник може почуватися добре, залишивши цей біт номер 2 незмінним.

156
00:10:07,160 --> 00:10:11,677
Тоді на іншому кінці, якщо приймач перевірить парність цієї групи і виявить,

157
00:10:11,677 --> 00:10:15,960
що вона непарна, він знатиме, що помилка десь серед цих 8 бітів праворуч.

158
00:10:15,960 --> 00:10:21,260
Інакше це означає, що або помилки немає, або помилка десь на лівій половині.

159
00:10:21,260 --> 00:10:24,001
Або я припускаю, що могло бути дві помилки, але зараз ми

160
00:10:24,001 --> 00:10:27,080
будемо припускати, що у всьому блоці є щонайбільше одна помилка.

161
00:10:27,080 --> 00:10:29,160
Речі повністю ламаються для більшого.

162
00:10:29,160 --> 00:10:32,456
Тут, перш ніж ми подивимося на наступні дві перевірки, знайдіть хвилинку, щоб

163
00:10:32,456 --> 00:10:35,880
подумати про те, що ці перші дві дозволяють нам робити, якщо розглядати їх разом.

164
00:10:35,880 --> 00:10:40,240
Припустімо, ви виявили помилку серед непарних стовпців і серед правої половини.

165
00:10:40,240 --> 00:10:43,940
Це обов’язково означає, що помилка знаходиться десь в останньому стовпці.

166
00:10:43,940 --> 00:10:47,155
Якщо в непарному стовпці не було помилки, але була одна в правій

167
00:10:47,155 --> 00:10:50,520
половині, це означає, що вона знаходиться в передостанньому стовпці.

168
00:10:50,520 --> 00:10:53,486
Так само, якщо є помилка в непарних стовпцях, але не в

169
00:10:53,486 --> 00:10:56,560
правій половині, ви знаєте, що це десь у другому стовпці.

170
00:10:56,560 --> 00:10:59,951
І якщо жодна з цих двох перевірок парності нічого не виявляє, це

171
00:10:59,951 --> 00:11:03,760
означає, що єдине місце, де може бути помилка, це крайній лівий стовпець.

172
00:11:03,760 --> 00:11:06,480
Але це також може означати, що помилки взагалі немає.

173
00:11:06,480 --> 00:11:09,392
Це досить складний спосіб сказати, що дві перевірки

174
00:11:09,392 --> 00:11:11,800
парності дозволяють нам закріпити стовпець.

175
00:11:11,800 --> 00:11:14,000
Звідси ви, напевно, можете здогадатися, що далі.

176
00:11:14,000 --> 00:11:16,240
Ми робимо в основному те саме, але для рядків.

177
00:11:16,240 --> 00:11:21,040
У непарних рядках буде перевірено парність із використанням позиції 4 як біта парності.

178
00:11:21,040 --> 00:11:26,480
Отже, у цьому прикладі ця група вже має парний паритет, тому біт 4 буде встановлено на 0.

179
00:11:26,480 --> 00:11:29,319
І, нарешті, є перевірка парності в нижніх двох

180
00:11:29,319 --> 00:11:32,280
рядках, використовуючи позицію 8 як біт парності.

181
00:11:32,280 --> 00:11:35,400
У цьому випадку схоже, що відправник повинен увімкнути

182
00:11:35,400 --> 00:11:37,840
цей біт 8, щоб надати групі рівний паритет.

183
00:11:37,840 --> 00:11:40,307
Подібно до того, як перші дві перевірки дозволяють нам

184
00:11:40,307 --> 00:11:43,000
закріпити стовпець, наступні дві дозволяють закріпити рядок.

185
00:11:43,000 --> 00:11:48,400
Як приклад, уявіть, що під час передачі виникла помилка, скажімо, у позиції 3.

186
00:11:48,400 --> 00:11:52,132
Ну, це впливає на першу групу парності, а також на другу групу

187
00:11:52,132 --> 00:11:56,340
парності, тому приймач знає, що десь у цьому правому стовпці є помилка.

188
00:11:56,340 --> 00:12:01,380
Але це не впливає на третю групу, і не впливає на четверту групу.

189
00:12:01,380 --> 00:12:04,964
І це дозволяє приймачу точно визначити помилку до першого рядка,

190
00:12:04,964 --> 00:12:08,660
що обов’язково означає позицію 3, щоб вони могли виправити помилку.

191
00:12:08,660 --> 00:12:12,937
Можливо, вам сподобається знайти час, щоб переконатися, що відповіді на ці чотири

192
00:12:12,937 --> 00:12:17,320
запитання справді завжди дозволять вам визначити конкретне місце, де б воно не було.

193
00:12:17,320 --> 00:12:20,450
Насправді, кмітливі серед вас можуть навіть помітити

194
00:12:20,450 --> 00:12:23,640
зв’язок між цими запитаннями та двійковим підрахунком.

195
00:12:23,640 --> 00:12:27,380
І якщо так, дозвольте мені ще раз підкреслити, зробити паузу,

196
00:12:27,380 --> 00:12:30,880
спробуйте самі намалювати зв’язок, перш ніж я його зіпсую.

197
00:12:30,880 --> 00:12:33,750
Якщо вам цікаво, що станеться, якщо постраждає

198
00:12:33,750 --> 00:12:36,560
сам біт парності, ви можете просто спробувати.

199
00:12:36,560 --> 00:12:40,205
Знайдіть хвилинку, щоб подумати про те, як будь-яка помилка серед

200
00:12:40,205 --> 00:12:43,739
цих чотирьох спеціальних бітів буде відстежуватися так само, як

201
00:12:43,739 --> 00:12:47,440
і будь-яка інша, за допомогою тієї самої групи з чотирьох запитань.

202
00:12:47,440 --> 00:12:50,308
Це не має особливого значення, оскільки врешті-решт ми хочемо

203
00:12:50,308 --> 00:12:53,640
захистити біти повідомлень, біти виправлення помилок просто йдуть разом.

204
00:12:53,640 --> 00:12:59,260
Але захист цих бітів також є те, що природно випадає зі схеми як побічний продукт.

205
00:12:59,260 --> 00:13:02,380
Вам також може бути цікаво передбачити, як це масштабується.

206
00:13:02,380 --> 00:13:06,742
Наприклад, якщо ми використовували блок розміром 256 біт, щоб

207
00:13:06,742 --> 00:13:11,387
визначити місце розташування, вам знадобиться лише вісім запитань

208
00:13:11,387 --> 00:13:15,680
«так» або «ні», щоб виконати двійковий пошук до певної точки.

209
00:13:15,680 --> 00:13:19,510
І пам’ятайте, що кожне запитання вимагає відмови лише від

210
00:13:19,510 --> 00:13:23,340
одного біта, щоб встановити відповідну перевірку парності.

211
00:13:23,340 --> 00:13:26,650
Деякі з вас, можливо, вже бачать це, але ми поговоримо пізніше про

212
00:13:26,650 --> 00:13:29,960
систематичний спосіб знайти ці запитання всього за хвилину або дві.

213
00:13:29,960 --> 00:13:34,440
Сподіваюся, цього ескізу достатньо, щоб оцінити ефективність того, що ми тут розробляємо.

214
00:13:34,440 --> 00:13:38,279
Перше, за винятком тих восьми виділених бітів парності, може бути будь-яким,

215
00:13:38,279 --> 00:13:41,720
що ви забажаєте, з будь-яким повідомленням або даними, які ви хочете.

216
00:13:41,720 --> 00:13:48,040
8 бітів зайві в тому сенсі, що вони повністю визначаються рештою повідомлення,

217
00:13:48,040 --> 00:13:53,640
але це набагато розумніше, ніж просто копіювати повідомлення в цілому.

218
00:13:53,640 --> 00:13:56,593
І все-таки, за так мало відмови, ви зможете визначити

219
00:13:56,593 --> 00:13:59,000
та виправити будь-яку окрему бітову помилку.

220
00:13:59,000 --> 00:14:00,400
Ну, майже.

221
00:14:00,400 --> 00:14:04,644
Гаразд, одна проблема тут полягає в тому, що якщо жодна з чотирьох

222
00:14:04,644 --> 00:14:08,953
перевірок парності не виявляє помилку, тобто всі спеціально вибрані

223
00:14:08,953 --> 00:14:13,198
підмножини з 8 біт мають парні паритети, як і хотів відправник, то

224
00:14:13,198 --> 00:14:17,760
це означає, що помилки взагалі не було , або це звужує нас до позиції 0.

225
00:14:17,760 --> 00:14:22,820
Розумієте, з чотирма запитаннями «так» або «ні» ми маємо 16 можливих результатів для

226
00:14:22,820 --> 00:14:27,820
перевірки парності, і спочатку це ідеально підходить для визначення 1 із 16 позицій

227
00:14:27,820 --> 00:14:33,000
у блоці, але вам також потрібно повідомити 17-й результат, відсутність помилки хвороба.

228
00:14:33,000 --> 00:14:37,860
Рішення тут насправді досить просте, просто забудьте про нульовий біт.

229
00:14:37,860 --> 00:14:40,911
Отже, коли ми виконуємо наші чотири перевірки на парність і

230
00:14:40,911 --> 00:14:44,320
бачимо, що всі вони парні, це однозначно означає, що помилки немає.

231
00:14:44,320 --> 00:14:49,069
Це означає, що замість роботи з 16-бітним блоком ми працюємо з 15-бітним

232
00:14:49,069 --> 00:14:54,080
блоком, де 11 бітів вільні для передачі повідомлення, а 4 з них є резервними.

233
00:14:54,080 --> 00:14:59,400
І разом з цим тепер ми маємо те, що люди в бізнесі називали б кодом Хеммінга 15-11.

234
00:14:59,400 --> 00:15:03,771
Тим не менш, добре мати розмір блоку, який дорівнює чистій степені 2, і є розумний

235
00:15:03,771 --> 00:15:08,511
спосіб, яким ми можемо зберегти цей 0-й біт і змусити його виконувати трохи більше роботи

236
00:15:08,511 --> 00:15:08,880
за нас.

237
00:15:08,880 --> 00:15:12,502
Якщо ми використовуємо його як біт парності для всього блоку, це дозволяє

238
00:15:12,502 --> 00:15:16,320
нам фактично виявляти 2-бітові помилки, навіть якщо ми не можемо виправити їх.

239
00:15:16,320 --> 00:15:17,440
Ось як це працює.

240
00:15:17,440 --> 00:15:21,687
Після встановлення цих чотирьох спеціальних бітів виправлення помилок ми встановлюємо

241
00:15:21,687 --> 00:15:25,540
0-й, щоб парність повного блоку була парною, як і звичайна перевірка парності.

242
00:15:25,540 --> 00:15:29,563
Тепер, якщо є помилка з одним бітом, то парність повного блоку перемикається на

243
00:15:29,563 --> 00:15:33,940
непарність, але ми все одно вловимо це завдяки чотирьом перевіркам виправлення помилок.

244
00:15:33,940 --> 00:15:37,670
Однак, якщо є дві помилки, тоді загальний паритет повернеться до

245
00:15:37,670 --> 00:15:41,458
рівномірного, але приймач все одно побачить, що сталася принаймні

246
00:15:41,458 --> 00:15:45,820
якась помилка через те, що відбувається з цими чотирма перевірками парності.

247
00:15:45,820 --> 00:15:49,423
Отже, якщо вони помічають рівну парність загалом, але щось відмінне від нуля

248
00:15:49,423 --> 00:15:52,980
відбувається з іншими перевірками, це говорить їм про принаймні дві помилки.

249
00:15:52,980 --> 00:15:54,420
Хіба це не розумно?

250
00:15:54,420 --> 00:15:58,258
Навіть незважаючи на те, що ми не можемо виправити ці 2-бітові помилки, просто

251
00:15:58,258 --> 00:16:02,340
повернувши цей маленький набридливий 0-й біт до роботи, це дозволить нам їх виявити.

252
00:16:02,340 --> 00:16:06,540
Це досить стандартний код, він відомий як розширений код Хеммінга.

253
00:16:06,540 --> 00:16:10,215
Технічно кажучи, тепер у вас є повний опис того, що робить

254
00:16:10,215 --> 00:16:13,580
код Хеммінга, принаймні для прикладу 16-бітного блоку.

255
00:16:13,580 --> 00:16:17,726
Але я думаю, що вам буде приємніше перевірити ваше розуміння та закріпити все

256
00:16:17,726 --> 00:16:21,980
до цього моменту, виконавши один повний приклад від початку до кінця самостійно.

257
00:16:21,980 --> 00:16:25,100
Але я пройду це разом з вами, щоб ви могли перевірити самі.

258
00:16:25,100 --> 00:16:28,772
Щоб налаштувати повідомлення, незалежно від того, чи це дослівне повідомлення,

259
00:16:28,772 --> 00:16:32,166
яке ви перекладаєте через простір, чи якісь дані, які ви хочете зберегти

260
00:16:32,166 --> 00:16:35,700
протягом тривалого часу, перший крок — розділити його на 11-бітні фрагменти.

261
00:16:35,700 --> 00:16:40,340
Кожна частина буде упакована в стійкий до помилок 16-бітний блок.

262
00:16:40,340 --> 00:16:43,740
Отже, давайте візьмемо це як приклад і розберемося.

263
00:16:43,740 --> 00:16:45,380
Давай, справді зроби це!

264
00:16:45,380 --> 00:16:52,980
Давайте зупинимося і спробуємо скласти цей блок.

265
00:16:52,980 --> 00:16:53,980
Гаразд, ти готовий?

266
00:16:53,980 --> 00:16:57,595
Пам’ятайте, що позиція 0 разом з іншими степенями числа 2

267
00:16:57,595 --> 00:17:01,273
зарезервована для виправлення помилок, тому ви починаєте з

268
00:17:01,273 --> 00:17:05,700
розміщення бітів повідомлення в усіх місцях, що залишилися, по порядку.

269
00:17:05,700 --> 00:17:09,447
Вам потрібно, щоб ця група мала рівний паритет, який вона вже має,

270
00:17:09,447 --> 00:17:13,140
тому ви повинні були встановити цей біт парності в позиції 1 на 0.

271
00:17:13,140 --> 00:17:16,107
Наступна група починається з непарної парності,

272
00:17:16,107 --> 00:17:19,260
тому вам слід було встановити її біт парності на 1.

273
00:17:19,260 --> 00:17:21,921
Група після цього починається з непарної парності,

274
00:17:21,921 --> 00:17:24,740
тому ви знову повинні встановити її біт парності на 1.

275
00:17:24,740 --> 00:17:28,297
І остання група також має непарну парність, тобто

276
00:17:28,297 --> 00:17:31,500
ми встановили, що біт у позиції 8 дорівнює 1.

277
00:17:31,500 --> 00:17:36,535
І потім, як останній крок, повний блок тепер має парну парність, тобто

278
00:17:36,535 --> 00:17:41,500
ви можете встановити цей біт номер 0, головний біт парності, рівним 0.

279
00:17:41,500 --> 00:17:45,106
Отже, коли цей блок відправляється, парність чотирьох

280
00:17:45,106 --> 00:17:48,980
спеціальних підмножин і блоку в цілому буде парною, або 0.

281
00:17:48,980 --> 00:17:53,620
У другій частині вправи давайте ви зіграєте роль приймача.

282
00:17:53,620 --> 00:17:57,105
Звичайно, це означатиме, що ви ще не знаєте, що це за повідомлення,

283
00:17:57,105 --> 00:18:00,180
можливо, дехто з вас запам’ятав його, але припустімо, що ні.

284
00:18:00,180 --> 00:18:04,567
Я збираюся змінити 0, 1 або 2 біта в цьому блоці,

285
00:18:04,567 --> 00:18:08,340
а потім попрошу вас зрозуміти, що я зробив.

286
00:18:08,340 --> 00:18:13,460
Тож знову зробіть паузу та спробуйте розібратися.

287
00:18:13,460 --> 00:18:21,483
Отже, ви, як отримувач, тепер перевіряєте першу групу парності, і ви бачите,

288
00:18:21,483 --> 00:18:29,820
що вона парна, тому будь-яка помилка, яка існує, повинна бути в парному стовпці.

289
00:18:29,820 --> 00:18:34,047
Наступна перевірка дає нам непарне число, повідомляючи, що є

290
00:18:34,047 --> 00:18:38,760
принаймні одна помилка, і звужуючи нас до цього конкретного стовпця.

291
00:18:38,760 --> 00:18:42,900
Третя перевірка рівномірна, що ще більше скорочує можливості.

292
00:18:42,900 --> 00:18:47,431
І остання перевірка парності є дивною, повідомляє нам, що десь внизу

293
00:18:47,431 --> 00:18:51,700
є помилка, яка наразі, як ми бачимо, має бути в позиції номер 10.

294
00:18:51,700 --> 00:18:55,135
Більше того, парність усього блоку дивна, що дає

295
00:18:55,135 --> 00:18:58,220
нам впевненість, що був один фліп, а не два.

296
00:18:58,220 --> 00:19:01,600
Якщо їх три або більше, усі ставки скасовуються.

297
00:19:01,600 --> 00:19:06,573
Після виправлення цього біта номер 10, вилучення 11 бітів, які не були використані

298
00:19:06,573 --> 00:19:11,366
для виправлення, дає нам відповідний сегмент вихідного повідомлення, який, якщо

299
00:19:11,366 --> 00:19:16,160
ви перемотуєте назад і порівняєте, справді є саме тим, з чого ми почали приклад.

300
00:19:16,160 --> 00:19:19,912
І тепер, коли ви знаєте, як зробити все це вручну, я хотів би показати вам, як ви

301
00:19:19,912 --> 00:19:23,940
можете виконати основну частину всієї цієї логіки за допомогою одного рядка коду Python.

302
00:19:23,940 --> 00:19:28,980
Розумієте, я ще не сказав вам, наскільки елегантним є цей алгоритм, як просто

303
00:19:28,980 --> 00:19:34,215
змусити машину вказувати на місце помилки, як систематично її масштабувати та як

304
00:19:34,215 --> 00:19:39,580
ми можемо створити все це як одна операція, а не кілька окремих перевірок парності.

305
00:19:39,580 --> 00:19:39,580
Щоб зрозуміти, що я маю на увазі, приєднуйтеся до частини 2.

