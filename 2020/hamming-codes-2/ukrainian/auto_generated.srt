1
00:00:03,620 --> 00:00:07,000
Чи замислювалися ви коли-небудь про те, як можна подряпати компакт-диск 

2
00:00:07,000 --> 00:00:10,100
або DVD-диск і все одно відтворювати те, що на ньому зберігається?

3
00:00:10,900 --> 00:00:16,227
Подряпина справді впливає на 1 і 0 на диску, тому він зчитує дані, відмінні від того, 

4
00:00:16,227 --> 00:00:20,873
що зберігається, але якщо він справді не подряпаний, біти, які він зчитує, 

5
00:00:20,873 --> 00:00:25,643
декодуються в той самий файл, який був закодований на ньому, побітова копія, 

6
00:00:25,643 --> 00:00:27,440
незважаючи на всі ці помилки.

7
00:00:27,440 --> 00:00:31,790
Існує ціла купа математичної кмітливості, яка дозволяє нам зберігати дані, 

8
00:00:31,790 --> 00:00:36,200
і, що не менш важливо, передавати дані, у спосіб, який є стійким до помилок.

9
00:00:36,200 --> 00:00:40,880
Ну, гаразд, насправді не потрібно так багато кмітливості, щоб придумати спосіб це зробити.

10
00:00:40,880 --> 00:00:45,440
Будь-який файл, чи то відео, чи звук, чи текст, якийсь код, 

11
00:00:45,440 --> 00:00:50,380
зображення тощо, зрештою, є певною послідовністю одиниць і нулів.

12
00:00:50,680 --> 00:00:53,076
І простою стратегією виправлення будь-якого біта, 

13
00:00:53,076 --> 00:00:56,000
який перевертається, було б зберігати три копії кожного біта.

14
00:00:57,580 --> 00:01:00,733
Тоді машина, яка читає цей файл, може порівняти ці три 

15
00:01:00,733 --> 00:01:04,060
копії та завжди брати найкращі 2 із 3, якщо є розбіжності.

16
00:01:07,160 --> 00:01:10,860
Але це означає використання двох третин вашого простору для резервування.

17
00:01:11,480 --> 00:01:15,030
І навіть тоді, незважаючи на весь цей вільний простір, немає надійної гарантії щодо того, 

18
00:01:15,030 --> 00:01:17,240
що станеться, якщо буде перевернуто більше ніж один біт.

19
00:01:17,980 --> 00:01:20,805
Набагато цікавіше питання полягає в тому, як зробити так, 

20
00:01:20,805 --> 00:01:24,020
щоб можна було виправляти помилки, звільняючи якомога менше місця.

21
00:01:24,520 --> 00:01:28,333
Наприклад, використовуючи метод, який ви дізнаєтеся про це відео, 

22
00:01:28,333 --> 00:01:33,360
ви можете зберігати свої дані у 256-бітних блоках, де кожен блок використовує 9 біт, 9!

23
00:01:33,760 --> 00:01:37,127
щоб діяти як своєрідна надлишковість, а інші 247 бітів можуть вільно 

24
00:01:37,127 --> 00:01:40,300
переносити будь-які значущі повідомлення або дані, які ви хочете.

25
00:01:40,900 --> 00:01:44,647
І все одно буде так, що якщо будь-який біт тут буде перевернуто, 

26
00:01:44,647 --> 00:01:48,797
просто подивившись на цей блок і нічого більше, машина зможе визначити, 

27
00:01:48,797 --> 00:01:52,660
що була помилка, і точно, де вона була, щоб знати, як її виправити.

28
00:01:52,660 --> 00:01:54,620
І, чесно кажучи, це виглядає як магія.

29
00:01:55,440 --> 00:01:58,475
І для цієї конкретної схеми, якщо два біти будуть перевернуті, 

30
00:01:58,475 --> 00:02:02,089
машина принаймні зможе виявити, що було дві помилки, хоча вона не знатиме, 

31
00:02:02,089 --> 00:02:02,860
як їх виправити.

32
00:02:03,520 --> 00:02:06,900
Трохи пізніше ми поговоримо про те, як це масштабується для блоків різних розмірів.

33
00:02:07,860 --> 00:02:10,279
Методи, які дозволяють виправляти такі помилки, 

34
00:02:10,279 --> 00:02:12,900
відомі, досить розумно, як коди виправлення помилок.

35
00:02:13,660 --> 00:02:17,677
Протягом більшої частини минулого століття ця сфера була справді багатим джерелом 

36
00:02:17,677 --> 00:02:21,940
напрочуд глибокої математики, яка вбудовується в пристрої, якими ми користуємося щодня.

37
00:02:22,840 --> 00:02:27,144
Мета тут — дати вам дуже повне розуміння одного з найперших прикладів, 

38
00:02:27,144 --> 00:02:28,660
відомого як код Хеммінга.

39
00:02:29,520 --> 00:02:33,375
І, до речі, те, як я думаю про структуру цього відео, полягає не в тому, 

40
00:02:33,375 --> 00:02:36,016
щоб пояснити це якомога пряміше, а більше в тому, 

41
00:02:36,016 --> 00:02:39,820
щоб спонукати вас придумати це для себе, з легкими вказівками тут і там.

42
00:02:40,120 --> 00:02:43,609
Тож коли ви відчуєте, що в якийсь момент бачите, куди це йде, візьміть цей момент, 

43
00:02:43,609 --> 00:02:46,720
щоб зупинитися, активно передбачте, якою буде схема, перш ніж я скажу вам.

44
00:02:47,240 --> 00:02:50,890
Крім того, якщо ви хочете, щоб ваше розуміння перейшло до апаратного рівня, 

45
00:02:50,890 --> 00:02:54,012
Бен Ітер створив відео в поєднанні з цим відео, яке показує вам, 

46
00:02:54,012 --> 00:02:58,240
як насправді впроваджувати коди Хеммінга на макетних платах, що надзвичайно задовольняє.

47
00:02:59,300 --> 00:03:02,339
Ви повинні знати, що коди Хеммінга не так широко використовуються, 

48
00:03:02,339 --> 00:03:04,743
як більш сучасні коди, як-от алгоритм Ріда-Соломона, 

49
00:03:04,743 --> 00:03:08,146
але є певна магія в контрасті між тим, наскільки нездійсненним це завдання 

50
00:03:08,146 --> 00:03:11,548
здається на початку, і тим, наскільки цілком розумним воно здається одного 

51
00:03:11,548 --> 00:03:13,000
разу ви дізнаєтесь про Хеммінга.

52
00:03:13,720 --> 00:03:16,388
Основний принцип виправлення помилок полягає в тому, 

53
00:03:16,388 --> 00:03:20,467
що у величезному просторі всіх можливих повідомлень лише деякі підмножини будуть 

54
00:03:20,467 --> 00:03:22,180
вважатися дійсними повідомленнями.

55
00:03:22,800 --> 00:03:26,940
Як аналогію, подумайте про правильно написані слова проти неправильно написаних слів.

56
00:03:28,900 --> 00:03:32,736
Щоразу, коли дійсне повідомлення змінюється, одержувач несе відповідальність за 

57
00:03:32,736 --> 00:03:35,853
виправлення того, що він бачить, до найближчого дійсного сусіда, 

58
00:03:35,853 --> 00:03:37,340
як це можна зробити з помилкою.

59
00:03:38,220 --> 00:03:40,907
Проте розробка конкретного алгоритму для ефективної 

60
00:03:40,907 --> 00:03:44,060
класифікації подібних повідомлень вимагає певної кмітливості.

61
00:03:46,780 --> 00:03:50,958
Історія починається в 1940-х роках, коли молодий Річард Хеммінг працював у Bell Labs, 

62
00:03:50,958 --> 00:03:54,747
і частина його роботи включала використання дуже великого дорогого комп’ютера 

63
00:03:54,747 --> 00:03:57,420
з перфокартами, до якого він мав лише обмежений доступ.

64
00:03:57,800 --> 00:03:59,601
І програми, які він постійно вставляв у нього, 

65
00:03:59,601 --> 00:04:02,400
постійно виходили з ладу, тому що час від часу щось неправильно читалося.

66
00:04:03,120 --> 00:04:05,970
Розчарування, будучи горнилом винахідництва, йому так набридло, 

67
00:04:05,970 --> 00:04:08,420
що він винайшов перший у світі код виправлення помилок.

68
00:04:09,060 --> 00:04:11,791
Є багато різних способів створення кодів Хеммінга, 

69
00:04:11,791 --> 00:04:15,380
але для початку ми розглянемо це так, як сам Хеммінг думав про них.

70
00:04:16,519 --> 00:04:20,940
Давайте використаємо простий, але не дуже простий приклад, блок із 16 біт.

71
00:04:21,820 --> 00:04:24,740
Ми пронумеруємо позиції цих бітів від 0 до 15.

72
00:04:25,620 --> 00:04:29,720
Фактичні дані, які ми хочемо зберігати, складатимуть лише 12 із цих бітів, 

73
00:04:29,720 --> 00:04:33,000
тоді як 4 позиції зарезервовано як свого роду надлишковість.

74
00:04:33,900 --> 00:04:36,803
Слово надлишковий тут не просто означає копіювання, зрештою, 

75
00:04:36,803 --> 00:04:40,040
ці 4 біти не дають нам достатньо місця для сліпого копіювання даних.

76
00:04:40,720 --> 00:04:44,542
Натомість вони повинні бути набагато більш тонкими та розумними як резервування, 

77
00:04:44,542 --> 00:04:47,280
не додаючи жодної нової інформації, але додаючи стійкості.

78
00:04:48,600 --> 00:04:52,207
Ви можете очікувати, що ці 4 спеціальні біти будуть гарно зібрані разом, 

79
00:04:52,207 --> 00:04:56,259
можливо, в кінці або щось подібне, але, як ви побачите, розміщення їх у позиціях, 

80
00:04:56,259 --> 00:04:59,620
які є степенями 2, дозволяє отримати щось справді елегантне в кінці.

81
00:05:00,200 --> 00:05:03,540
Це також може дати вам невелику підказку про те, як це масштабується для більших блоків.

82
00:05:04,900 --> 00:05:09,702
Крім того, технічно це лише 11 біт даних, ви побачите, що є легкий нюанс у тому, 

83
00:05:09,702 --> 00:05:13,260
що відбувається в позиції 0, але не хвилюйтеся про це зараз.

84
00:05:14,140 --> 00:05:16,699
Як і в будь-якому іншому алгоритмі виправлення помилок, 

85
00:05:16,699 --> 00:05:18,847
у цьому будуть задіяні два гравці: відправник, 

86
00:05:18,847 --> 00:05:22,046
який відповідає за встановлення цих 4 спеціальних бітів, і одержувач, 

87
00:05:22,046 --> 00:05:25,200
який відповідає за виконання певної перевірки та виправлення помилок.

88
00:05:25,200 --> 00:05:28,260
Звичайно, слова «відправник» і «одержувач» справді стосуються машин 

89
00:05:28,260 --> 00:05:30,825
або програмного забезпечення, яке виконує всі перевірки, 

90
00:05:30,825 --> 00:05:34,740
і ідея повідомлення має на увазі дуже широке значення, включаючи такі речі, як сховище.

91
00:05:35,340 --> 00:05:38,174
Зрештою, зберігання даних — це те саме, що відправляти 

92
00:05:38,174 --> 00:05:41,680
повідомлення лише з минулого в майбутнє, а не з одного місця в інше.

93
00:05:42,560 --> 00:05:45,623
Отже, це налаштування, але перш ніж ми зможемо зануритися в це, 

94
00:05:45,623 --> 00:05:48,927
нам потрібно поговорити про пов’язану ідею, яка була свіжою в голові 

95
00:05:48,927 --> 00:05:52,374
Геммінга під час його відкриття, метод, який дозволяє виявляти будь-які 

96
00:05:52,374 --> 00:05:56,300
однобітові помилки, але не виправляти їх, відомий у бізнесі як перевірка паритету.

97
00:05:56,880 --> 00:05:59,494
Для перевірки парності ми відокремлюємо лише один біт, 

98
00:05:59,494 --> 00:06:03,202
за налаштування якого відповідає відправник, а решта можуть вільно передавати 

99
00:06:03,202 --> 00:06:03,820
повідомлення.

100
00:06:04,880 --> 00:06:07,593
Єдина робота цього спеціального біта полягає в тому, 

101
00:06:07,593 --> 00:06:11,280
щоб переконатися, що загальна кількість одиниць у повідомленні є парною.

102
00:06:12,080 --> 00:06:15,576
Так, наприклад, зараз загальна кількість одиниць дорівнює 7, це дивно, 

103
00:06:15,576 --> 00:06:19,960
тому відправнику потрібно перевернути цей спеціальний біт на 1, роблячи кількість парних.

104
00:06:20,800 --> 00:06:23,669
Але якби блок уже почався з парної кількості 1, 

105
00:06:23,669 --> 00:06:26,420
тоді цей спеціальний біт залишився б рівним 0.

106
00:06:27,340 --> 00:06:32,176
Це досить просто, оманливо просто, але це неймовірно елегантний спосіб дистилювати 

107
00:06:32,176 --> 00:06:36,780
ідею зміни будь-де в повідомленні, щоб її відобразити в одному біті інформації.

108
00:06:37,500 --> 00:06:41,928
Зверніть увагу, якщо будь-який біт цього повідомлення перевертається з 0 

109
00:06:41,928 --> 00:06:46,540
на 1 або з 1 на 0, це змінює загальну кількість одиниць з парної на непарну.

110
00:06:47,980 --> 00:06:50,971
Отже, якщо ви одержувач, ви дивитеся на це повідомлення та 

111
00:06:50,971 --> 00:06:53,860
бачите непарну кількість одиниць, ви можете точно знати, 

112
00:06:53,860 --> 00:06:57,460
що сталася якась помилка, навіть якщо ви можете не знати, де вона була.

113
00:06:58,500 --> 00:07:03,340
На жаргоні парність у групі бітів називається її парністю.

114
00:07:04,860 --> 00:07:07,964
Ви також можете використовувати числа та сказати, що парність дорівнює 0 або 1, 

115
00:07:07,964 --> 00:07:10,720
що зазвичай стає більш корисним, коли ви починаєте обчислювати цю ідею.

116
00:07:11,220 --> 00:07:14,381
І цей спеціальний біт, який відправник використовує для контролю парності, 

117
00:07:14,381 --> 00:07:15,520
називається бітом парності.

118
00:07:17,560 --> 00:07:21,443
І насправді, ми маємо чітко уточнити: якщо отримувач бачить непарну парність, 

119
00:07:21,443 --> 00:07:25,227
це не обов’язково означає, що була лише одна помилка, могло бути 3 помилки, 

120
00:07:25,227 --> 00:07:29,260
або 5, або будь-яке інше непарне число, але вони можуть знати напевно що це не 0.

121
00:07:29,980 --> 00:07:33,823
З іншого боку, якби було 2 помилки або будь-яка парна кількість помилок, 

122
00:07:33,823 --> 00:07:38,140
кінцева кількість 1с все одно була б парною, тому одержувач не може бути повністю 

123
00:07:38,140 --> 00:07:42,300
впевненим, що парна кількість обов’язково означає, що повідомлення без помилок.

124
00:07:42,840 --> 00:07:45,096
Ви можете поскаржитися на те, що повідомлення, 

125
00:07:45,096 --> 00:07:49,080
яке спотворюється лише двома бітами, є досить слабким, і ви будете абсолютно праві.

126
00:07:49,700 --> 00:07:53,359
Однак пам’ятайте, що не існує методу виявлення або виправлення помилок, 

127
00:07:53,359 --> 00:07:57,680
який міг би дати вам 100% впевненість у тому, що отримане вами повідомлення – це те, 

128
00:07:57,680 --> 00:07:58,900
що мав намір відправник.

129
00:07:59,580 --> 00:08:02,484
Зрештою, достатня кількість випадкового шуму завжди може 

130
00:08:02,484 --> 00:08:05,440
змінити одне дійсне повідомлення на інше просто випадково.

131
00:08:06,240 --> 00:08:08,934
Натомість мета полягає в тому, щоб створити схему, 

132
00:08:08,934 --> 00:08:12,685
яка є надійною до певної максимальної кількості помилок, або, можливо, 

133
00:08:12,685 --> 00:08:15,380
зменшити ймовірність хибного спрацьовування, як це.

134
00:08:16,260 --> 00:08:19,793
Перевірки на парність самі по собі є досить слабкими, але, 

135
00:08:19,793 --> 00:08:23,267
зводячи ідею зміни в повному повідомленні до одного біта, 

136
00:08:23,267 --> 00:08:27,160
вони дають нам потужний будівельний блок для більш складних схем.

137
00:08:27,940 --> 00:08:31,284
Наприклад, коли Хеммінг шукав спосіб визначити, де сталася помилка, 

138
00:08:31,284 --> 00:08:34,874
а не просто те, що вона сталася, його ключове розуміння полягало в тому, 

139
00:08:34,874 --> 00:08:38,612
що якщо ви застосовуєте деякі перевірки парності не до всього повідомлення, 

140
00:08:38,612 --> 00:08:41,956
а до певних ретельно відібраних підмножин, ви можете запитати більш 

141
00:08:41,956 --> 00:08:45,940
витончену серію запитань, які визначають місце будь-якої окремої бітової помилки.

142
00:08:46,680 --> 00:08:49,467
Загальне відчуття трохи схоже на гру з 20 запитань, 

143
00:08:49,467 --> 00:08:53,380
задаючи запити «так» або «ні», які розрізають простір можливостей навпіл.

144
00:08:54,160 --> 00:08:57,736
Наприклад, скажімо, ми виконуємо перевірку парності лише для цих 8 бітів, 

145
00:08:57,736 --> 00:08:59,380
усіх позицій з непарними номерами.

146
00:09:00,100 --> 00:09:04,591
Потім, якщо виявлено помилку, це дає одержувачу трохи більше інформації про те, 

147
00:09:04,591 --> 00:09:08,240
де саме є помилка, а саме, що він знаходиться в непарній позиції.

148
00:09:08,940 --> 00:09:12,372
Якщо серед цих 8 бітів не виявлено жодної помилки, це означає, 

149
00:09:12,372 --> 00:09:16,240
що помилки немає взагалі, або вона знаходиться десь на парних позиціях.

150
00:09:17,180 --> 00:09:20,549
Ви можете подумати, що обмеження перевірки парності половиною бітів робить 

151
00:09:20,549 --> 00:09:23,605
її менш ефективною, але коли це робиться в поєднанні з іншими добре 

152
00:09:23,605 --> 00:09:27,200
підібраними перевірками, це суперечить інтуїції дає нам щось набагато потужніше.

153
00:09:29,240 --> 00:09:32,671
Пам’ятайте, що для того, щоб фактично налаштувати цю перевірку парності, 

154
00:09:32,671 --> 00:09:36,620
потрібно виділити якийсь спеціальний біт, який контролює парність цієї повної групи.

155
00:09:37,480 --> 00:09:39,180
Давайте просто виберемо позицію 1.

156
00:09:39,720 --> 00:09:42,757
У наведеному прикладі парність цих 8 бітів наразі непарна, 

157
00:09:42,757 --> 00:09:46,980
тому відправник відповідає за перемикання цього біта парності, і тепер він парний.

158
00:09:47,940 --> 00:09:50,680
Це лише 1 із 4 перевірок парності, які ми зробимо.

159
00:09:50,920 --> 00:09:54,320
Друга перевірка знаходиться серед 8 бітів у правій половині сітки, 

160
00:09:54,320 --> 00:09:56,300
принаймні так, як ми її тут намалювали.

161
00:09:56,680 --> 00:09:59,914
Цього разу ми можемо використати позицію 2 як біт парності, 

162
00:09:59,914 --> 00:10:04,119
тому ці 8 бітів уже мають рівну парність, і відправник може почуватися добре, 

163
00:10:04,119 --> 00:10:06,060
залишивши цей біт номер 2 незмінним.

164
00:10:07,020 --> 00:10:11,311
Тоді на іншому кінці, якщо приймач перевірить парність цієї групи і виявить, 

165
00:10:11,311 --> 00:10:15,380
що вона непарна, він знатиме, що помилка десь серед цих 8 бітів праворуч.

166
00:10:15,820 --> 00:10:20,580
Інакше це означає, що або помилки немає, або помилка десь на лівій половині.

167
00:10:21,120 --> 00:10:24,499
Або я припускаю, що могло бути дві помилки, але зараз ми будемо припускати, 

168
00:10:24,499 --> 00:10:26,500
що у всьому блоці є щонайбільше одна помилка.

169
00:10:26,940 --> 00:10:28,740
Речі повністю ламаються для більшого.

170
00:10:29,160 --> 00:10:31,924
Тут, перш ніж ми подивимося на наступні дві перевірки, знайдіть хвилинку, 

171
00:10:31,924 --> 00:10:35,100
щоб подумати про те, що ці перші дві дозволяють нам робити, якщо розглядати їх разом.

172
00:10:35,800 --> 00:10:39,660
Припустімо, ви виявили помилку серед непарних стовпців і серед правої половини.

173
00:10:40,200 --> 00:10:43,040
Це обов’язково означає, що помилка знаходиться десь в останньому стовпці.

174
00:10:43,820 --> 00:10:47,135
Якщо в непарному стовпці не було помилки, але була одна в правій половині, 

175
00:10:47,135 --> 00:10:49,700
це означає, що вона знаходиться в передостанньому стовпці.

176
00:10:50,440 --> 00:10:54,374
Так само, якщо є помилка в непарних стовпцях, але не в правій половині, 

177
00:10:54,374 --> 00:10:56,560
ви знаєте, що це десь у другому стовпці.

178
00:10:56,560 --> 00:11:00,077
І якщо жодна з цих двох перевірок парності нічого не виявляє, це означає, 

179
00:11:00,077 --> 00:11:03,120
що єдине місце, де може бути помилка, це крайній лівий стовпець.

180
00:11:03,340 --> 00:11:06,120
Але це також може означати, що помилки взагалі немає.

181
00:11:06,300 --> 00:11:08,785
Це досить складний спосіб сказати, що дві перевірки 

182
00:11:08,785 --> 00:11:10,840
парності дозволяють нам закріпити стовпець.

183
00:11:11,480 --> 00:11:13,640
Звідси ви, напевно, можете здогадатися, що далі.

184
00:11:13,800 --> 00:11:16,140
Ми робимо в основному те саме, але для рядків.

185
00:11:16,440 --> 00:11:20,900
У непарних рядках буде перевірено парність із використанням позиції 4 як біта парності.

186
00:11:21,380 --> 00:11:25,820
Отже, у цьому прикладі ця група вже має парний паритет, тому біт 4 буде встановлено на 0.

187
00:11:26,560 --> 00:11:29,436
І, нарешті, є перевірка парності в нижніх двох рядках, 

188
00:11:29,436 --> 00:11:31,580
використовуючи позицію 8 як біт парності.

189
00:11:32,120 --> 00:11:35,285
У цьому випадку схоже, що відправник повинен увімкнути цей біт 8, 

190
00:11:35,285 --> 00:11:36,820
щоб надати групі рівний паритет.

191
00:11:37,700 --> 00:11:40,400
Подібно до того, як перші дві перевірки дозволяють нам закріпити стовпець, 

192
00:11:40,400 --> 00:11:41,840
наступні дві дозволяють закріпити рядок.

193
00:11:42,880 --> 00:11:47,540
Як приклад, уявіть, що під час передачі виникла помилка, скажімо, у позиції 3.

194
00:11:48,180 --> 00:11:52,200
Ну, це впливає на першу групу парності, а також на другу групу парності, 

195
00:11:52,200 --> 00:11:55,560
тому приймач знає, що десь у цьому правому стовпці є помилка.

196
00:11:56,100 --> 00:12:00,540
Але це не впливає на третю групу, і не впливає на четверту групу.

197
00:12:01,240 --> 00:12:04,332
І це дозволяє приймачу точно визначити помилку до першого рядка, 

198
00:12:04,332 --> 00:12:07,520
що обов’язково означає позицію 3, щоб вони могли виправити помилку.

199
00:12:08,580 --> 00:12:11,454
Можливо, вам сподобається знайти час, щоб переконатися, 

200
00:12:11,454 --> 00:12:15,816
що відповіді на ці чотири запитання справді завжди дозволять вам визначити конкретне 

201
00:12:15,816 --> 00:12:17,100
місце, де б воно не було.

202
00:12:17,720 --> 00:12:20,365
Насправді, кмітливі серед вас можуть навіть помітити 

203
00:12:20,365 --> 00:12:23,060
зв’язок між цими запитаннями та двійковим підрахунком.

204
00:12:23,500 --> 00:12:26,300
І якщо так, дозвольте мені ще раз підкреслити, зробити паузу, 

205
00:12:26,300 --> 00:12:28,920
спробуйте самі намалювати зв’язок, перш ніж я його зіпсую.

206
00:12:30,500 --> 00:12:34,386
Якщо вам цікаво, що станеться, якщо постраждає сам біт парності, 

207
00:12:34,386 --> 00:12:36,060
ви можете просто спробувати.

208
00:12:36,440 --> 00:12:39,033
Знайдіть хвилинку, щоб подумати про те, як будь-яка помилка серед 

209
00:12:39,033 --> 00:12:41,429
цих чотирьох спеціальних бітів буде відстежуватися так само, 

210
00:12:41,429 --> 00:12:44,180
як і будь-яка інша, за допомогою тієї самої групи з чотирьох запитань.

211
00:12:47,060 --> 00:12:51,116
Це не має особливого значення, оскільки врешті-решт ми хочемо захистити біти повідомлень, 

212
00:12:51,116 --> 00:12:53,100
біти виправлення помилок просто йдуть разом.

213
00:12:53,600 --> 00:12:57,820
Але захист цих бітів також є те, що природно випадає зі схеми як побічний продукт.

214
00:12:59,200 --> 00:13:01,760
Вам також може бути цікаво передбачити, як це масштабується.

215
00:13:02,300 --> 00:13:05,516
Наприклад, якщо ми використовували блок розміром 256 біт, 

216
00:13:05,516 --> 00:13:10,284
щоб визначити місце розташування, вам знадобиться лише вісім запитань «так» або «ні», 

217
00:13:10,284 --> 00:13:12,780
щоб виконати двійковий пошук до певної точки.

218
00:13:15,640 --> 00:13:18,614
І пам’ятайте, що кожне запитання вимагає відмови лише від одного біта, 

219
00:13:18,614 --> 00:13:20,500
щоб встановити відповідну перевірку парності.

220
00:13:23,160 --> 00:13:26,260
Деякі з вас, можливо, вже бачать це, але ми поговоримо пізніше про 

221
00:13:26,260 --> 00:13:29,360
систематичний спосіб знайти ці запитання всього за хвилину або дві.

222
00:13:29,880 --> 00:13:33,260
Сподіваюся, цього ескізу достатньо, щоб оцінити ефективність того, що ми тут розробляємо.

223
00:13:33,260 --> 00:13:37,774
Перше, за винятком тих восьми виділених бітів парності, може бути будь-яким, 

224
00:13:37,774 --> 00:13:41,820
що ви забажаєте, з будь-яким повідомленням або даними, які ви хочете.

225
00:13:41,820 --> 00:13:46,167
8 бітів зайві в тому сенсі, що вони повністю визначаються рештою повідомлення, 

226
00:13:46,167 --> 00:13:50,020
але це набагато розумніше, ніж просто копіювати повідомлення в цілому.

227
00:13:53,600 --> 00:13:56,233
І все-таки, за так мало відмови, ви зможете визначити 

228
00:13:56,233 --> 00:13:58,380
та виправити будь-яку окрему бітову помилку.

229
00:13:59,200 --> 00:14:00,400
Ну, майже.

230
00:14:00,960 --> 00:14:04,847
Гаразд, одна проблема тут полягає в тому, що якщо жодна з чотирьох 

231
00:14:04,847 --> 00:14:08,793
перевірок парності не виявляє помилку, тобто всі спеціально вибрані 

232
00:14:08,793 --> 00:14:12,507
підмножини з 8 біт мають парні паритети, як і хотів відправник, 

233
00:14:12,507 --> 00:14:16,860
то це означає, що помилки взагалі не було , або це звужує нас до позиції 0.

234
00:14:17,740 --> 00:14:22,441
Розумієте, з чотирма запитаннями «так» або «ні» ми маємо 16 можливих результатів для 

235
00:14:22,441 --> 00:14:27,087
перевірки парності, і спочатку це ідеально підходить для визначення 1 із 16 позицій 

236
00:14:27,087 --> 00:14:31,900
у блоці, але вам також потрібно повідомити 17-й результат, відсутність помилки хвороба.

237
00:14:33,020 --> 00:14:37,300
Рішення тут насправді досить просте, просто забудьте про нульовий біт.

238
00:14:37,840 --> 00:14:40,849
Отже, коли ми виконуємо наші чотири перевірки на парність і бачимо, 

239
00:14:40,849 --> 00:14:43,460
що всі вони парні, це однозначно означає, що помилки немає.

240
00:14:44,240 --> 00:14:49,089
Це означає, що замість роботи з 16-бітним блоком ми працюємо з 15-бітним блоком, 

241
00:14:49,089 --> 00:14:53,220
де 11 бітів вільні для передачі повідомлення, а 4 з них є резервними.

242
00:14:53,780 --> 00:15:00,200
І разом з цим тепер ми маємо те, що люди в бізнесі називали б кодом Хеммінга 15-11.

243
00:15:00,460 --> 00:15:03,446
Тим не менш, добре мати розмір блоку, який дорівнює чистій степені 2, 

244
00:15:03,446 --> 00:15:07,244
і є розумний спосіб, яким ми можемо зберегти цей 0-й біт і змусити його виконувати трохи 

245
00:15:07,244 --> 00:15:08,140
більше роботи за нас.

246
00:15:08,700 --> 00:15:11,490
Якщо ми використовуємо його як біт парності для всього блоку, 

247
00:15:11,490 --> 00:15:15,540
це дозволяє нам фактично виявляти 2-бітові помилки, навіть якщо ми не можемо виправити їх.

248
00:15:16,160 --> 00:15:16,820
Ось як це працює.

249
00:15:17,180 --> 00:15:21,249
Після встановлення цих чотирьох спеціальних бітів виправлення помилок ми встановлюємо 

250
00:15:21,249 --> 00:15:24,940
0-й, щоб парність повного блоку була парною, як і звичайна перевірка парності.

251
00:15:25,700 --> 00:15:29,484
Тепер, якщо є помилка з одним бітом, то парність повного блоку перемикається на 

252
00:15:29,484 --> 00:15:33,600
непарність, але ми все одно вловимо це завдяки чотирьом перевіркам виправлення помилок.

253
00:15:34,160 --> 00:15:38,365
Однак, якщо є дві помилки, тоді загальний паритет повернеться до рівномірного, 

254
00:15:38,365 --> 00:15:42,411
але приймач все одно побачить, що сталася принаймні якась помилка через те, 

255
00:15:42,411 --> 00:15:45,180
що відбувається з цими чотирма перевірками парності.

256
00:15:45,180 --> 00:15:47,637
Отже, якщо вони помічають рівну парність загалом, 

257
00:15:47,637 --> 00:15:50,684
але щось відмінне від нуля відбувається з іншими перевірками, 

258
00:15:50,684 --> 00:15:52,700
це говорить їм про принаймні дві помилки.

259
00:15:53,520 --> 00:15:54,000
Хіба це не розумно?

260
00:15:54,300 --> 00:15:57,374
Навіть незважаючи на те, що ми не можемо виправити ці 2-бітові помилки, 

261
00:15:57,374 --> 00:16:00,064
просто повернувши цей маленький набридливий 0-й біт до роботи, 

262
00:16:00,064 --> 00:16:01,260
це дозволить нам їх виявити.

263
00:16:02,260 --> 00:16:05,220
Це досить стандартний код, він відомий як розширений код Хеммінга.

264
00:16:06,540 --> 00:16:09,289
Технічно кажучи, тепер у вас є повний опис того, 

265
00:16:09,289 --> 00:16:12,880
що робить код Хеммінга, принаймні для прикладу 16-бітного блоку.

266
00:16:12,880 --> 00:16:17,046
Але я думаю, що вам буде приємніше перевірити ваше розуміння та закріпити все 

267
00:16:17,046 --> 00:16:21,320
до цього моменту, виконавши один повний приклад від початку до кінця самостійно.

268
00:16:22,080 --> 00:16:24,300
Але я пройду це разом з вами, щоб ви могли перевірити самі.

269
00:16:25,120 --> 00:16:28,425
Щоб налаштувати повідомлення, незалежно від того, чи це дослівне повідомлення, 

270
00:16:28,425 --> 00:16:30,517
яке ви перекладаєте через простір, чи якісь дані, 

271
00:16:30,517 --> 00:16:32,526
які ви хочете зберегти протягом тривалого часу, 

272
00:16:32,526 --> 00:16:34,660
перший крок — розділити його на 11-бітні фрагменти.

273
00:16:35,580 --> 00:16:39,760
Кожна частина буде упакована в стійкий до помилок 16-бітний блок.

274
00:16:39,760 --> 00:16:43,220
Отже, давайте візьмемо це як приклад і розберемося.

275
00:16:43,740 --> 00:16:44,740
Давай, справді зроби це!

276
00:16:44,740 --> 00:16:47,020
Давайте зупинимося і спробуємо скласти цей блок.

277
00:16:52,720 --> 00:16:53,680
Гаразд, ти готовий?

278
00:16:54,240 --> 00:16:57,041
Пам’ятайте, що позиція 0 разом з іншими степенями числа 2 

279
00:16:57,041 --> 00:16:59,890
зарезервована для виправлення помилок, тому ви починаєте з 

280
00:16:59,890 --> 00:17:03,320
розміщення бітів повідомлення в усіх місцях, що залишилися, по порядку.

281
00:17:05,339 --> 00:17:08,866
Вам потрібно, щоб ця група мала рівний паритет, який вона вже має, 

282
00:17:08,866 --> 00:17:12,339
тому ви повинні були встановити цей біт парності в позиції 1 на 0.

283
00:17:13,020 --> 00:17:15,376
Наступна група починається з непарної парності, 

284
00:17:15,376 --> 00:17:17,880
тому вам слід було встановити її біт парності на 1.

285
00:17:19,160 --> 00:17:21,627
Група після цього починається з непарної парності, 

286
00:17:21,627 --> 00:17:24,240
тому ви знову повинні встановити її біт парності на 1.

287
00:17:24,780 --> 00:17:28,392
І остання група також має непарну парність, тобто ми встановили, 

288
00:17:28,392 --> 00:17:30,060
що біт у позиції 8 дорівнює 1.

289
00:17:31,300 --> 00:17:35,458
І потім, як останній крок, повний блок тепер має парну парність, 

290
00:17:35,458 --> 00:17:40,320
тобто ви можете встановити цей біт номер 0, головний біт парності, рівним 0.

291
00:17:41,340 --> 00:17:44,618
Отже, коли цей блок відправляється, парність чотирьох 

292
00:17:44,618 --> 00:17:48,140
спеціальних підмножин і блоку в цілому буде парною, або 0.

293
00:17:48,820 --> 00:17:52,180
У другій частині вправи давайте ви зіграєте роль приймача.

294
00:17:53,480 --> 00:17:56,826
Звичайно, це означатиме, що ви ще не знаєте, що це за повідомлення, 

295
00:17:56,826 --> 00:17:59,780
можливо, дехто з вас запам’ятав його, але припустімо, що ні.

296
00:18:00,020 --> 00:18:04,170
Я збираюся змінити 0, 1 або 2 біта в цьому блоці, 

297
00:18:04,170 --> 00:18:07,740
а потім попрошу вас зрозуміти, що я зробив.

298
00:18:08,260 --> 00:18:10,810
Тож знову зробіть паузу та спробуйте розібратися.

299
00:18:18,790 --> 00:18:23,262
Отже, ви, як отримувач, тепер перевіряєте першу групу парності, і ви бачите, 

300
00:18:23,262 --> 00:18:27,910
що вона парна, тому будь-яка помилка, яка існує, повинна бути в парному стовпці.

301
00:18:29,690 --> 00:18:32,876
Наступна перевірка дає нам непарне число, повідомляючи, 

302
00:18:32,876 --> 00:18:37,030
що є принаймні одна помилка, і звужуючи нас до цього конкретного стовпця.

303
00:18:38,550 --> 00:18:41,790
Третя перевірка рівномірна, що ще більше скорочує можливості.

304
00:18:42,650 --> 00:18:45,523
І остання перевірка парності є дивною, повідомляє нам, 

305
00:18:45,523 --> 00:18:49,650
що десь внизу є помилка, яка наразі, як ми бачимо, має бути в позиції номер 10.

306
00:18:51,490 --> 00:18:55,776
Більше того, парність усього блоку дивна, що дає нам впевненість, 

307
00:18:55,776 --> 00:18:57,530
що був один фліп, а не два.

308
00:18:58,070 --> 00:18:59,970
Якщо їх три або більше, усі ставки скасовуються.

309
00:19:01,310 --> 00:19:04,485
Після виправлення цього біта номер 10, вилучення 11 бітів, 

310
00:19:04,485 --> 00:19:08,738
які не були використані для виправлення, дає нам відповідний сегмент вихідного 

311
00:19:08,738 --> 00:19:13,044
повідомлення, який, якщо ви перемотуєте назад і порівняєте, справді є саме тим, 

312
00:19:13,044 --> 00:19:14,390
з чого ми почали приклад.

313
00:19:15,710 --> 00:19:19,045
І тепер, коли ви знаєте, як зробити все це вручну, я хотів би показати вам, 

314
00:19:19,045 --> 00:19:22,862
як ви можете виконати основну частину всієї цієї логіки за допомогою одного рядка коду 

315
00:19:22,862 --> 00:19:23,170
Python.

316
00:19:23,870 --> 00:19:28,051
Розумієте, я ще не сказав вам, наскільки елегантним є цей алгоритм, 

317
00:19:28,051 --> 00:19:31,310
як просто змусити машину вказувати на місце помилки, 

318
00:19:31,310 --> 00:19:36,351
як систематично її масштабувати та як ми можемо створити все це як одна операція, 

319
00:19:36,351 --> 00:19:38,750
а не кілька окремих перевірок парності.

320
00:19:39,430 --> 00:19:41,310
Щоб зрозуміти, що я маю на увазі, приєднуйтеся до частини 2.

