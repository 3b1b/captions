[
 {
  "input": "I'm assuming that everybody here is coming from part 1.",
  "model": "nmt",
  "translatedText": "Я припускаю, що всі тут походять із частини 1.",
  "time_range": [
   0.0,
   2.56
  ]
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it.",
  "model": "nmt",
  "translatedText": "Ми говорили про коди Хеммінга, спосіб створення блоку даних, де більшість бітів несуть значуще повідомлення, тоді як кілька інших діють як свого роду надлишковість, таким чином, що якщо будь-який біт перевертається, або повідомлення біт або біт надлишковості, будь-що в цьому блоці, приймач зможе визначити, що була помилка, і як її виправити.",
  "time_range": [
   3.06,
   21.24
  ]
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error.",
  "model": "nmt",
  "translatedText": "Основна ідея, представлена там, полягала в тому, як використовувати кілька перевірок на парність для бінарного пошуку на шляху до помилки.",
  "time_range": [
   21.88,
   27.16
  ]
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible.",
  "model": "nmt",
  "translatedText": "У цьому відео мета полягала в тому, щоб зробити коди Хеммінга максимально практичними та відкритими заново.",
  "time_range": [
   28.980000000000008,
   34.6
  ]
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are.",
  "model": "nmt",
  "translatedText": "Але коли ви починаєте думати про те, щоб реалізувати це в програмному чи апаратному забезпеченні, таке фреймування може фактично знизити вартість елегантного коду.",
  "time_range": [
   35.18,
   43.46
  ]
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that.",
  "model": "nmt",
  "translatedText": "Ви можете подумати, що вам потрібно написати алгоритм, який відстежує всі можливі місця помилок і скорочує цю групу навпіл під час кожної перевірки, але насправді це набагато, набагато простіше.",
  "time_range": [
   43.92,
   53.48
  ]
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary.",
  "model": "nmt",
  "translatedText": "Якщо ви зачитаєте відповіді на чотири перевірки парності, які ми робили в останньому відео, усі як 1 і 0 замість «так» і «ні», це буквально вказує місце помилки в двійковому вигляді.",
  "time_range": [
   53.94,
   64.08
  ]
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1.",
  "model": "nmt",
  "translatedText": "Наприклад, число 7 у двійковій системі виглядає як 0111, по суті кажучи, що це 4 плюс 2 плюс 1.",
  "time_range": [
   64.78,
   71.26
  ]
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last.",
  "model": "nmt",
  "translatedText": "І зауважте, де знаходиться позиція 7, вона дійсно впливає на першу з наших груп парності, і на другу, і на третю, але не на останню.",
  "time_range": [
   72.54,
   81.74
  ]
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error.",
  "model": "nmt",
  "translatedText": "Отже, читання результатів цих чотирьох перевірок знизу вгору справді пояснює місце помилки.",
  "time_range": [
   82.22,
   87.54
  ]
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple.",
  "model": "nmt",
  "translatedText": "У прикладі 7 немає нічого особливого, загалом це працює, і це робить логіку реалізації всієї схеми на апаратному забезпеченні надзвичайно простою.",
  "time_range": [
   88.32,
   95.82
  ]
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111.",
  "model": "nmt",
  "translatedText": "Тепер, якщо ви хочете зрозуміти, чому відбувається ця магія, візьміть ці 16 індексних міток для наших позицій, але замість того, щоб записувати їх у базі 10, давайте запишемо їх у двійковому вигляді, починаючи від 0000 до 1111.",
  "time_range": [
   97.24,
   109.88
  ]
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent.",
  "model": "nmt",
  "translatedText": "Коли ми повертаємо ці двійкові мітки назад у свої коробки, дозвольте мені підкреслити, що вони відрізняються від даних, які насправді надсилаються.",
  "time_range": [
   110.55999999999999,
   117.8
  ]
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from.",
  "model": "nmt",
  "translatedText": "Вони не що інше, як концептуальний ярлик, який допоможе вам і мені зрозуміти, звідки взялися чотири паритетні групи.",
  "time_range": [
   118.32,
   123.5
  ]
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary.",
  "model": "nmt",
  "translatedText": "Елегантність того, що все, на що ми дивимося, описується у двійковому форматі, можливо, підривається плутаниною, пов’язаною з тим, що все, на що ми дивимося, описується у двійковому форматі.",
  "time_range": [
   124.14,
   132.36
  ]
 },
 {
  "input": "It's worth it, though.",
  "model": "nmt",
  "translatedText": "Проте воно того варте.",
  "time_range": [
   133.02,
   134.12
  ]
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1.",
  "model": "nmt",
  "translatedText": "Зосередьте свою увагу лише на останньому фрагменті всіх цих міток, а потім виділіть позиції, де останній біт є 1.",
  "time_range": [
   134.8,
   143.22
  ]
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1?",
  "model": "nmt",
  "translatedText": "Що ми отримуємо, це перша з наших чотирьох груп парності, що означає, що ви можете інтерпретувати цю першу перевірку як запитання: якщо є помилка, чи є останній біт у позиції цієї помилки 1?",
  "time_range": [
   144.24,
   155.74
  ]
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme.",
  "model": "nmt",
  "translatedText": "Так само, якщо ви зосередитеся на передостанньому біті та виділите всі позиції, де це 1, ви отримаєте другу групу парності з нашої схеми.",
  "time_range": [
   158.2,
   166.16
  ]
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1?",
  "model": "nmt",
  "translatedText": "Іншими словами, ця друга перевірка запитує, привіт, я знову, якщо є помилка, передостанній біт цієї позиції є 1?",
  "time_range": [
   166.74,
   174.5
  ]
 },
 {
  "input": "And so on.",
  "model": "nmt",
  "translatedText": "І так далі.",
  "time_range": [
   175.76,
   176.9
  ]
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1.",
  "model": "nmt",
  "translatedText": "Третя перевірка парності охоплює кожну позицію, передостанній біт якої ввімкнено, а остання охоплює останні вісім позицій, у яких старший біт дорівнює 1.",
  "time_range": [
   177.22,
   188.74
  ]
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary.",
  "model": "nmt",
  "translatedText": "Усе, що ми робили раніше, те саме, що відповіді на ці чотири запитання, що, у свою чергу, те саме, що виклад позиції в двійковому коді.",
  "time_range": [
   189.74,
   197.74
  ]
 },
 {
  "input": "I hope this makes two things clearer.",
  "model": "nmt",
  "translatedText": "Сподіваюся, це зрозуміє дві речі.",
  "time_range": [
   199.62,
   201.48
  ]
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two.",
  "model": "nmt",
  "translatedText": "По-перше, як систематично узагальнювати розміри блоків, які є більшими степенями двійки.",
  "time_range": [
   202.04,
   206.46
  ]
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check.",
  "model": "nmt",
  "translatedText": "Якщо для опису кожної позиції потрібно більше бітів, наприклад, шість бітів для опису 64 плям, тоді кожен із цих бітів дає вам одну з груп парності, яку нам потрібно перевірити.",
  "time_range": [
   206.96,
   216.68
  ]
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar.",
  "model": "nmt",
  "translatedText": "Тим із вас, хто дивився головоломку на шахівниці, яку я розгадував із Метом Паркером, можливо, все це здасться надзвичайно знайомим.",
  "time_range": [
   218.4,
   223.18
  ]
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard.",
  "model": "nmt",
  "translatedText": "Це та сама основна логіка, але розв’язує іншу проблему та застосована до шахової дошки з 64 квадратами.",
  "time_range": [
   223.66,
   228.78
  ]
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8.",
  "model": "nmt",
  "translatedText": "Друге, що, я сподіваюся, це пояснює, чому наші біти парності сидять у позиціях, які є степенями двійки, наприклад, 1, 2, 4 і 8.",
  "time_range": [
   229.88,
   237.32
  ]
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on.",
  "model": "nmt",
  "translatedText": "Це позиції, двійкове представлення яких має лише один біт.",
  "time_range": [
   238.0,
   243.0
  ]
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups.",
  "model": "nmt",
  "translatedText": "Це означає, що кожен із цих бітів парності знаходиться в одній і лише одній із чотирьох груп парності.",
  "time_range": [
   243.6,
   249.46
  ]
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups.",
  "model": "nmt",
  "translatedText": "Ви також можете побачити це на більших прикладах, де незалежно від того, наскільки великим ви станете, кожен біт парності зручно стосується лише однієї з груп.",
  "time_range": [
   252.04,
   259.34
  ]
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code.",
  "model": "nmt",
  "translatedText": "Як тільки ви зрозумієте, що ці перевірки парності, на яких ми зосередили стільки нашого часу, є не що інше, як розумний спосіб виразити позицію помилки в двійковому форматі, тоді ми зможемо провести зв’язок з іншим способом уявлення про хемінг коди, який, мабуть, є набагато простішим і елегантнішим, і який можна записати за допомогою одного рядка коду.",
  "time_range": [
   265.6,
   283.24
  ]
 },
 {
  "input": "It's based on the XOR function.",
  "model": "nmt",
  "translatedText": "Він заснований на функції XOR.",
  "time_range": [
   283.66,
   285.5
  ]
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or.",
  "model": "nmt",
  "translatedText": "XOR, для тих із вас, хто не знає, означає ексклюзивне або.",
  "time_range": [
   286.94,
   290.22
  ]
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off.",
  "model": "nmt",
  "translatedText": "Коли ви використовуєте XOR двох бітів, він повертає 1, якщо один із цих бітів увімкнено, але не якщо обидва увімкнено чи вимкнено.",
  "time_range": [
   290.78,
   299.36
  ]
 },
 {
  "input": "Phrased differently, it's the parity of these two bits.",
  "model": "nmt",
  "translatedText": "Іншими словами, це парність цих двох бітів.",
  "time_range": [
   300.1,
   302.98
  ]
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2.",
  "model": "nmt",
  "translatedText": "Як математик я вважаю за краще думати про це як про додавання 2.",
  "time_range": [
   303.54,
   306.76
  ]
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component.",
  "model": "nmt",
  "translatedText": "Ми також зазвичай говоримо про XOR двох різних бітових рядків, що в основному виконує цей компонент за компонентом.",
  "time_range": [
   307.36,
   313.44
  ]
 },
 {
  "input": "It's like addition, but where you never carry.",
  "model": "nmt",
  "translatedText": "Це як доповнення, але куди ніколи не понесеш.",
  "time_range": [
   313.68,
   315.72
  ]
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2.",
  "model": "nmt",
  "translatedText": "Знову ж таки, більш схильні до математики можуть вважати за краще думати про це як про додавання двох векторів і зменшення mod 2.",
  "time_range": [
   316.5,
   322.48
  ]
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood.",
  "model": "nmt",
  "translatedText": "Якщо ви прямо зараз відкриєте якийсь Python і застосуєте операцію каретки між двома цілими числами, це буде саме те, що він робить, але лише до розрядних представлень цих чисел під капотом.",
  "time_range": [
   323.5,
   332.94
  ]
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop.",
  "model": "nmt",
  "translatedText": "Ключовим моментом для нас із вами є те, що використання XOR багатьох різних бітових рядків є ефективним способом обчислення пародії на купу окремих груп, як і зі стовпцями, одним махом.",
  "time_range": [
   334.96000000000004,
   347.14
  ]
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation.",
  "model": "nmt",
  "translatedText": "Це дає нам досить хитрий спосіб уявити, що численні перевірки парності з нашого алгоритму коду Хеммінга об’єднані в одну операцію.",
  "time_range": [
   351.26,
   358.78
  ]
 },
 {
  "input": "Though at first glance it does look very different.",
  "model": "nmt",
  "translatedText": "Хоча на перший погляд виглядає зовсім інакше.",
  "time_range": [
   359.47999999999996,
   362.18
  ]
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR.",
  "model": "nmt",
  "translatedText": "Зокрема, запишіть 16 позицій у двійковому вигляді, як ми це робили раніше, а тепер виділіть позиції, де біт повідомлення ввімкнуто на 1, а потім зберіть ці позиції в один великий стовпець і виконайте XOR.",
  "time_range": [
   362.82,
   377.1
  ]
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly.",
  "model": "nmt",
  "translatedText": "Ви, напевно, можете здогадатися, що 4 біти, які лежать у нижній частині в результаті, такі ж, як і 4 перевірки парності, які ми знали і любимо, але знайдіть хвилинку, щоб подумати, чому саме.",
  "time_range": [
   379.26,
   389.2
  ]
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group.",
  "model": "nmt",
  "translatedText": "Цей останній стовпець, наприклад, підраховує всі позиції, останній біт яких дорівнює 1, але ми вже обмежені лише виділеними позиціями, тому фактично підраховується, скільки виділених позицій походить від першої групи парності.",
  "time_range": [
   392.22,
   405.76
  ]
 },
 {
  "input": "Does that make sense?",
  "model": "nmt",
  "translatedText": "Чи має це сенс?",
  "time_range": [
   406.24,
   406.8
  ]
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on.",
  "model": "nmt",
  "translatedText": "Подібним чином у наступному стовпці підраховується кількість позицій у другій групі парності, позиції, передостанній біт яких дорівнює 1, які також виділені тощо.",
  "time_range": [
   409.08,
   420.0
  ]
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing.",
  "model": "nmt",
  "translatedText": "Насправді це лише невелика зміна погляду на те саме, що ми робили.",
  "time_range": [
   420.26,
   423.96
  ]
 },
 {
  "input": "And so you know where it goes from here.",
  "model": "nmt",
  "translatedText": "І ви знаєте, куди це йде.",
  "time_range": [
   427.76,
   429.6
  ]
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000.",
  "model": "nmt",
  "translatedText": "Відправник відповідає за перемикання деяких спеціальних бітів парності, щоб переконатися, що сума дорівнює 0000.",
  "time_range": [
   430.0,
   435.72
  ]
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error.",
  "model": "nmt",
  "translatedText": "Тепер, коли ми маємо це таким чином, це дає нам дійсно гарний спосіб подумати про те, чому ці чотири результуючих біта внизу безпосередньо вказують на місце помилки.",
  "time_range": [
   435.72,
   447.58
  ]
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1.",
  "model": "nmt",
  "translatedText": "Припустимо, якийсь біт у цьому блоці перемикається з 0 на 1.",
  "time_range": [
   448.46,
   451.86
  ]
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error.",
  "model": "nmt",
  "translatedText": "Це означає, що позиція цього біта тепер буде включена в загальне XOR, яке змінює суму з 0 на це нове включене значення, позицію помилки.",
  "time_range": [
   452.6,
   463.82
  ]
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0.",
  "model": "nmt",
  "translatedText": "Трохи менш очевидно, те ж саме вірно, якщо є помилка, яка змінює 1 на 0.",
  "time_range": [
   464.46,
   469.36
  ]
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0.",
  "model": "nmt",
  "translatedText": "Розумієте, якщо ви двічі додаєте бітовий рядок, це все одно, що його взагалі немає, тому що в цьому світі 1 плюс 1 дорівнює 0.",
  "time_range": [
   470.18,
   477.58
  ]
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it.",
  "model": "nmt",
  "translatedText": "Тож додавання копії цієї позиції до загальної суми має той самий ефект, що й її переміщення.",
  "time_range": [
   477.58,
   484.3
  ]
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error.",
  "model": "nmt",
  "translatedText": "І цей ефект, знову ж таки, полягає в тому, що загальний результат унизу тут вказує на місце помилки.",
  "time_range": [
   485.16,
   490.7
  ]
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end.",
  "model": "nmt",
  "translatedText": "Щоб проілюструвати, наскільки це елегантно, дозвольте мені показати той рядок коду Python, на який я посилався раніше, який захопить майже всю логіку на стороні приймача.",
  "time_range": [
   493.03999999999996,
   501.44
  ]
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits.",
  "model": "nmt",
  "translatedText": "Ми почнемо зі створення випадкового масиву з 16 1 і 0 для імітації блоку даних, і я дам йому біти назви, але, звичайно, на практиці це буде щось, що ми отримуємо від відправника, а замість будучи випадковим, він містив би 11 біт даних разом із 5 бітами парності.",
  "time_range": [
   502.08,
   517.0
  ]
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15.",
  "model": "nmt",
  "translatedText": "Якщо я викликаю функцію enumerateBits, вона об’єднає кожен із цих бітів із відповідним індексом, у цьому випадку від 0 до 15.",
  "time_range": [
   517.0,
   527.0
  ]
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15.",
  "model": "nmt",
  "translatedText": "Отже, якщо ми створимо список, який циклічно перебирає всі ці пари, пари, які виглядають як i, а потім витягуємо лише значення i, лише індекс, це не так цікаво, ми просто повертаємо ті індекси від 0 до 15.",
  "time_range": [
   528.18,
   541.34
  ]
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on.",
  "model": "nmt",
  "translatedText": "Але якщо ми додамо умову робити це тільки якщо біт, тобто якщо цей біт є 1, а не 0, добре, тоді він вилучає лише ті позиції, де відповідний біт увімкнено.",
  "time_range": [
   541.68,
   552.66
  ]
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc.",
  "model": "nmt",
  "translatedText": "У цьому випадку виглядає так, ніби ці позиції 0, 4, 6, 9 тощо.",
  "time_range": [
   553.38,
   560.36
  ]
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together.",
  "model": "nmt",
  "translatedText": "Те, що ми хочемо, це зібрати разом усі ці позиції, позиції бітів, які ввімкнено, а потім XOR їх разом.",
  "time_range": [
   560.72,
   567.24
  ]
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions.",
  "model": "nmt",
  "translatedText": "Щоб зробити це в Python, дозвольте мені спочатку імпортувати кілька корисних функцій.",
  "time_range": [
   569.18,
   573.22
  ]
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it.",
  "model": "nmt",
  "translatedText": "Таким чином ми можемо викликати reduce() у цьому списку та використовувати функцію XOR, щоб зменшити його.",
  "time_range": [
   573.9,
   578.7
  ]
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way.",
  "model": "nmt",
  "translatedText": "Це в основному з'їдає собі шлях через список, використовуючи по дорозі XOR.",
  "time_range": [
   579.1,
   582.68
  ]
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere.",
  "model": "nmt",
  "translatedText": "Якщо ви бажаєте, ви можете явно написати цю функцію XOR без необхідності імпортувати її з будь-якого місця.",
  "time_range": [
   584.8,
   589.44
  ]
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001.",
  "model": "nmt",
  "translatedText": "Отже, на даний момент виглядає так, що якщо ми зробимо це на нашому випадковому блоці з 16 біт, він поверне 9, який має двійкове представлення 1001.",
  "time_range": [
   591.94,
   601.28
  ]
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0.",
  "model": "nmt",
  "translatedText": "Ми не будемо цього робити тут, але ви можете написати функцію, у якій відправник використовує це двійкове представлення, щоб за потреби встановити чотири біти парності, зрештою переводячи цей блок у стан, коли виконання цього рядка коду з повним списком бітів повертає а 0.",
  "time_range": [
   601.98,
   615.46
  ]
 },
 {
  "input": "This would be considered a well-prepared block.",
  "model": "nmt",
  "translatedText": "Це буде вважатися добре підготовленим блоком.",
  "time_range": [
   616.08,
   620.1
  ]
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error.",
  "model": "nmt",
  "translatedText": "Цікаво те, що якщо ми перемикаємо будь-який із бітів у цьому списку, імітуючи випадкову помилку через шум, тоді, якщо ви запустите цей самий рядок коду, він виведе цю помилку.",
  "time_range": [
   620.1,
   630.22
  ]
 },
 {
  "input": "Isn't that neat?",
  "model": "nmt",
  "translatedText": "Хіба це не гарно?",
  "time_range": [
   630.96,
   631.52
  ]
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any.",
  "model": "nmt",
  "translatedText": "Ви можете отримати цей блок зненацька, запустити на ньому цей єдиний рядок, і він автоматично видасть позицію помилки або 0, якщо її не було.",
  "time_range": [
   631.82,
   641.06
  ]
 },
 {
  "input": "And there's nothing special about the size 16 here.",
  "model": "nmt",
  "translatedText": "І нічого особливого в 16 розмірі тут немає.",
  "time_range": [
   642.5,
   644.84
  ]
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits.",
  "model": "nmt",
  "translatedText": "Той самий рядок коду спрацював би, якби у вас був список із, скажімо, 256 біт.",
  "time_range": [
   644.84,
   649.86
  ]
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction.",
  "model": "nmt",
  "translatedText": "Зайве говорити, що тут потрібно написати більше коду, як-от мета-перевірку парності для виявлення 2-бітових помилок, але ідея полягає в тому, що майже вся основна логіка нашої схеми зводиться до єдиного скорочення XOR.",
  "time_range": [
   651.88,
   663.76
  ]
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go.",
  "model": "nmt",
  "translatedText": "Тепер, залежно від вашого комфорту з двійковими кодами та XOR та програмним забезпеченням загалом, ви можете або вважати цю перспективу трохи заплутаною, або настільки більш елегантною та простою, що ви дивуєтеся, чому ми не почали з неї з самого початку -іди.",
  "time_range": [
   666.12,
   678.42
  ]
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level.",
  "model": "nmt",
  "translatedText": "Грубо кажучи, про перспективу множинної перевірки парності легше подумати, якщо реалізовувати коди Хеммінга в апаратному забезпеченні дуже безпосередньо, а про перспективу XOR найпростіше подумати, роблячи це в програмному забезпеченні, на більш високому рівні.",
  "time_range": [
   679.14,
   690.5
  ]
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles.",
  "model": "nmt",
  "translatedText": "Перший з них найлегше зробити вручну, і я думаю, що він краще справляється з прищепленням основної інтуїції, яка лежить в основі всього цього, а саме того, що інформація, необхідна для пошуку однієї помилки, пов’язана з журналом розміру блоку. , або іншими словами, він зростає по одному біту, коли розмір блоку подвоюється.",
  "time_range": [
   691.36,
   710.0
  ]
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need.",
  "model": "nmt",
  "translatedText": "Релевантним фактом тут є те, що ця інформація безпосередньо відповідає тому, скільки резервування нам потрібно.",
  "time_range": [
   711.02,
   716.06
  ]
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind.",
  "model": "nmt",
  "translatedText": "Це насправді суперечить реагування більшості людей на колінах, коли вони вперше думають про те, щоб зробити повідомлення стійким до помилок, де зазвичай скопіювати все повідомлення є першим інстинктом, який спадає на думку.",
  "time_range": [
   716.66,
   726.54
  ]
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix.",
  "model": "nmt",
  "translatedText": "І, до речі, є цілий інший спосіб, у який ви іноді бачите представлені коди Хеммінга, коли ви множите повідомлення на одну велику матрицю.",
  "time_range": [
   727.5,
   734.0
  ]
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales.",
  "model": "nmt",
  "translatedText": "Це начебто добре, тому що це пов’язує його з більш широкою сім’єю лінійних кодів, але я думаю, що це майже не дає інтуїції щодо того, звідки він походить або як він масштабується.",
  "time_range": [
   734.67,
   743.06
  ]
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size.",
  "model": "nmt",
  "translatedText": "Говорячи про масштабування, ви можете помітити, що ефективність цієї схеми стає лише кращою, коли ми збільшуємо розмір блоку.",
  "time_range": [
   745.2,
   751.16
  ]
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there.",
  "model": "nmt",
  "translatedText": "Наприклад, ми бачили, що з 256 бітами ви використовуєте лише 3% цього простору для резервування, і з цього моменту все стає краще.",
  "time_range": [
   755.0,
   762.66
  ]
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling.",
  "model": "nmt",
  "translatedText": "Оскільки кількість бітів парності зростає один за одним, розмір блоку продовжує подвоюватися.",
  "time_range": [
   763.3,
   767.34
  ]
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits.",
  "model": "nmt",
  "translatedText": "І якщо ви доведете це до крайності, у вас може бути блок, скажімо, з мільйоном біт, де ви б буквально відтворювали 20 запитань із перевіркою парності, і він використовує лише 21 біт парності.",
  "time_range": [
   769.0,
   780.02
  ]
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy.",
  "model": "nmt",
  "translatedText": "І якщо ви відступите назад, щоб подумати про перегляд мільйона бітів і пошук однієї помилки, це справді виглядає божевільним.",
  "time_range": [
   780.74,
   787.06
  ]
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that.",
  "model": "nmt",
  "translatedText": "Проблема, звісно, полягає в тому, що з більшим блоком зростає ймовірність побачити більше однієї або двох бітових помилок, а коди Хеммінга не обробляють нічого, крім цього.",
  "time_range": [
   788.1999999999999,
   797.66
  ]
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high.",
  "model": "nmt",
  "translatedText": "Тож на практиці вам потрібно знайти правильний розмір, щоб ймовірність занадто великої кількості перевертань бітів не була надто високою.",
  "time_range": [
   798.32,
   804.3
  ]
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored.",
  "model": "nmt",
  "translatedText": "Крім того, на практиці помилки, як правило, виникають невеликими пакетами, які повністю знищують один блок, тому одна з поширених тактик, щоб допомогти розподілити сплеск помилок між багатьма різними блоками, полягає в тому, щоб переплести ці блоки, як це, перш ніж вони будуть розіслано або збережено.",
  "time_range": [
   806.6,
   820.98
  ]
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block.",
  "model": "nmt",
  "translatedText": "Знову ж таки, багато чого з цього стає абсолютно спірним через більш сучасні коди, як-от набагато частіше використовуваний алгоритм Ріда-Соломона, який особливо добре обробляє пакетні помилки, і його можна налаштувати так, щоб бути стійким до більшої кількості помилок на блок.",
  "time_range": [
   825.58,
   838.82
  ]
 },
 {
  "input": "But that's a topic for another time.",
  "model": "nmt",
  "translatedText": "Але це тема іншого разу.",
  "time_range": [
   839.36,
   841.34
  ]
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was.",
  "model": "nmt",
  "translatedText": "У своїй книзі «Мистецтво займатися наукою та технікою» Хеммінг надзвичайно відверто розповідає про те, наскільки звивистим було його відкриття цього коду.",
  "time_range": [
   842.5,
   849.94
  ]
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this.",
  "model": "nmt",
  "translatedText": "Спочатку він випробував усілякі різні схеми, що передбачають організацію бітів у частини решітки вищого виміру та такі дивні речі, як ця.",
  "time_range": [
   850.62,
   857.78
  ]
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this?",
  "model": "nmt",
  "translatedText": "Ідея про те, що можна змусити перевірку парності конспірувати таким чином, щоб визначити місце помилки, прийшла до Геммінга лише тоді, коли він відступив після купи інших аналізів і запитав: гаразд, що є найефективнішим, що я можу можливо бути про це?",
  "time_range": [
   858.3,
   871.52
  ]
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today.",
  "model": "nmt",
  "translatedText": "Він також був відвертим, наскільки важливо, щоб він уже думав про перевірку парності, яка була б набагато менш поширеною в 1940-х роках, ніж сьогодні.",
  "time_range": [
   872.62,
   881.22
  ]
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind.",
  "model": "nmt",
  "translatedText": "У цій книзі він півдюжини разів посилається на цитату Луї Пастера: удача сприяє підготовленому розуму.",
  "time_range": [
   881.92,
   888.22
  ]
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate.",
  "model": "nmt",
  "translatedText": "Розумні ідеї часто виглядають оманливо простими, тому їх легко недооцінити.",
  "time_range": [
   889.32,
   894.3
  ]
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you.",
  "model": "nmt",
  "translatedText": "Наразі я щиро сподіваюся, що коди Хеммінга або принаймні можливість таких кодів здаються вам майже очевидними.",
  "time_range": [
   894.96,
   901.3
  ]
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't.",
  "model": "nmt",
  "translatedText": "Але ви не повинні обманювати себе, думаючи, що вони насправді очевидні, тому що це точно не так.",
  "time_range": [
   901.66,
   906.82
  ]
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that.",
  "model": "nmt",
  "translatedText": "Однією з причин того, що розумні ідеї виглядають оманливо легко, є те, що ми завжди бачимо лише кінцевий результат, очищаємо те, що було брудним, ніколи не згадуємо всі неправильні повороти, недооцінюючи, наскільки величезним є простір досліджуваних можливостей на початку проблеми. процес вирішення, все це.",
  "time_range": [
   907.88,
   922.86
  ]
 },
 {
  "input": "But this is true in general.",
  "model": "nmt",
  "translatedText": "Але в цілому це вірно.",
  "time_range": [
   923.82,
   924.9
  ]
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them.",
  "model": "nmt",
  "translatedText": "Я думаю, що для деяких особливих винаходів є друга, глибша причина, чому ми їх недооцінюємо.",
  "time_range": [
   924.9,
   930.04
  ]
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory.",
  "model": "nmt",
  "translatedText": "Розуміння інформації в термінах бітів справді об’єдналося в повну теорію лише до 1948 року, коли Клод Шеннон опублікував фундаментальну статтю з теорії інформації.",
  "time_range": [
   930.84,
   938.64
  ]
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm.",
  "model": "nmt",
  "translatedText": "Це практично збігалося з тим, коли Хеммінг розробив свій алгоритм.",
  "time_range": [
   939.28,
   942.54
  ]
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory.",
  "model": "nmt",
  "translatedText": "Це був той самий основоположний документ, який показав, у певному сенсі, що ефективне виправлення помилок завжди можливе, незалежно від того, наскільки висока ймовірність перевертань бітів, принаймні в теорії.",
  "time_range": [
   943.3,
   952.9
  ]
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here.",
  "model": "nmt",
  "translatedText": "Шеннон і Хеммінг, до речі, ділилися офісом у Bell Labs, незважаючи на те, що працювали над дуже різними речами, що навряд чи здається тут випадковим.",
  "time_range": [
   953.7,
   961.16
  ]
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was.",
  "model": "nmt",
  "translatedText": "Перемотуємо вперед на кілька десятиліть, і сьогодні багато з нас настільки занурені в роздуми про біти та інформацію, що легко не помітити, наскільки відмінним був цей спосіб мислення.",
  "time_range": [
   962.38,
   972.34
  ]
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are.",
  "model": "nmt",
  "translatedText": "За іронією долі, ідеї, які найглибше формують уявлення майбутнього покоління, зрештою виглядатимуть це майбутнє покоління простішим, ніж воно є насправді.",
  "time_range": [
   973.1,
   982.26
  ]
 }
]