1
00:00:00,000 --> 00:00:05,400
Ti sei mai chiesto come sia possibile grattare un CD o

2
00:00:05,400 --> 00:00:10,900
un DVD e continuare a riprodurre tutto ciò che contiene?

3
00:00:10,900 --> 00:00:15,289
Il graffio influisce davvero sugli 1 e sugli 0 sul disco, quindi legge dati

4
00:00:15,289 --> 00:00:19,563
diversi da quelli memorizzati, ma a meno che non sia davvero graffiato, i

5
00:00:19,563 --> 00:00:24,010
bit che legge vengono decodificati esattamente nello stesso file che è stato

6
00:00:24,010 --> 00:00:28,400
codificato su di esso, un copia bit per bit, nonostante tutti quegli errori.

7
00:00:28,400 --> 00:00:32,645
C&#39;è tutta una serie di abilità matematiche che ci consentono di archiviare dati

8
00:00:32,645 --> 00:00:36,840
e, cosa altrettanto importante, di trasmetterli, in un modo resistente agli errori.

9
00:00:36,840 --> 00:00:42,480
Bene, okay, in realtà non ci vuole molta intelligenza per trovare un modo per farlo.

10
00:00:42,480 --> 00:00:46,597
Qualsiasi file, sia esso un video, un suono o un testo, un codice,

11
00:00:46,597 --> 00:00:50,960
un&#39;immagine, qualunque cosa, è in definitiva una sequenza di 1 e 0.

12
00:00:50,960 --> 00:00:54,343
E una strategia semplice per correggere qualsiasi bit che viene

13
00:00:54,343 --> 00:00:57,780
invertito sarebbe quella di memorizzare tre copie di ciascun bit.

14
00:00:57,780 --> 00:01:02,703
Quindi la macchina che legge questo file potrebbe confrontare queste tre copie

15
00:01:02,703 --> 00:01:07,440
e prendere sempre le migliori 2 su 3 ogni volta che c&#39;è una discrepanza.

16
00:01:07,440 --> 00:01:11,560
Ma ciò significa utilizzare due terzi dello spazio per la ridondanza.

17
00:01:11,560 --> 00:01:14,751
E anche in questo caso, nonostante tutto lo spazio concesso, non esiste

18
00:01:14,751 --> 00:01:18,120
alcuna garanzia forte su cosa accadrebbe se più di un bit venisse invertito.

19
00:01:18,120 --> 00:01:21,305
La questione molto più interessante è come fare in modo che gli

20
00:01:21,305 --> 00:01:24,740
errori possano essere corretti rinunciando al minor spazio possibile.

21
00:01:24,740 --> 00:01:28,597
Ad esempio, utilizzando il metodo che imparerai in questo video, potresti

22
00:01:28,597 --> 00:01:32,975
archiviare i tuoi dati in blocchi da 256 bit, dove ciascun blocco utilizza 9 bit, 9!

23
00:01:32,975 --> 00:01:37,164
per agire come una sorta di ridondanza e gli altri 247 bit sono liberi

24
00:01:37,164 --> 00:01:41,000
di trasportare qualunque messaggio o dato significativo desideri.

25
00:01:41,000 --> 00:01:45,079
E avverrà comunque che se qualche bit viene invertito qui, semplicemente guardando

26
00:01:45,079 --> 00:01:48,913
questo blocco e niente di più, una macchina sarà in grado di identificare che

27
00:01:48,913 --> 00:01:53,140
c&#39;era un errore e precisamente dove si trovava in modo da sapere come correggerlo.

28
00:01:53,140 --> 00:01:55,540
E onestamente, sembra una magia.

29
00:01:55,540 --> 00:01:59,402
E per questo particolare schema, se due bit vengono invertiti, la macchina sarà almeno in

30
00:01:59,402 --> 00:02:03,180
grado di rilevare che si sono verificati due errori, anche se non saprà come risolverli.

31
00:02:03,180 --> 00:02:08,140
Parleremo un po&#39; più tardi di come questo si adatta a blocchi di dimensioni diverse.

32
00:02:08,140 --> 00:02:11,031
I metodi che consentono di correggere errori come questo sono noti,

33
00:02:11,031 --> 00:02:13,880
abbastanza ragionevolmente, come codici di correzione degli errori.

34
00:02:13,880 --> 00:02:16,852
Per gran parte del secolo scorso, questo campo è stato una

35
00:02:16,852 --> 00:02:19,926
fonte davvero ricca di matematica sorprendentemente profonda

36
00:02:19,926 --> 00:02:23,000
che viene incorporata nei dispositivi che usiamo ogni giorno.

37
00:02:23,000 --> 00:02:25,979
L&#39;obiettivo qui è darti una comprensione molto

38
00:02:25,979 --> 00:02:29,660
approfondita di uno dei primi esempi, noto come codice Hamming.

39
00:02:29,660 --> 00:02:33,195
E comunque, il modo in cui penso alla struttura di questo video non è tanto

40
00:02:33,195 --> 00:02:36,777
quello di spiegarlo nel modo più diretto possibile, quanto più una questione

41
00:02:36,777 --> 00:02:40,220
di spingerti a inventarlo da solo, con una piccola guida gentile qua e là.

42
00:02:40,220 --> 00:02:42,477
Quindi, quando hai la sensazione di vedere dove sta andando

43
00:02:42,477 --> 00:02:44,772
ad un certo punto, prenditi quel momento per fare una pausa,

44
00:02:44,772 --> 00:02:47,180
prevedere attivamente quale sarà lo schema prima che te lo dica.

45
00:02:47,180 --> 00:02:51,293
Inoltre, se vuoi che la tua comprensione scenda al livello hardware, Ben Eater

46
00:02:51,293 --> 00:02:55,042
ha realizzato un video insieme a questo che ti mostra come implementare

47
00:02:55,042 --> 00:02:59,520
effettivamente i codici Hamming sulle breadboard, il che è estremamente soddisfacente.

48
00:02:59,520 --> 00:03:03,152
Dovresti sapere che i codici di Hamming non sono così diffusi come i codici

49
00:03:03,152 --> 00:03:06,880
più moderni, come l&#39;algoritmo di Reed-Solomon, ma c&#39;è una certa magia

50
00:03:06,880 --> 00:03:10,512
nel contrasto tra quanto questo compito sembra impossibile all&#39;inizio e

51
00:03:10,512 --> 00:03:14,240
quanto sembra assolutamente ragionevole una volta. impari a conoscere Hamming.

52
00:03:14,240 --> 00:03:18,601
Il principio di base della correzione degli errori è che in un vasto spazio di tutti

53
00:03:18,601 --> 00:03:22,860
i messaggi possibili, solo alcuni sottoinsiemi saranno considerati messaggi validi.

54
00:03:22,860 --> 00:03:26,562
Per analogia, pensa alle parole scritte correttamente

55
00:03:26,562 --> 00:03:29,100
e alle parole scritte in modo errato.

56
00:03:29,100 --> 00:03:32,479
Ogni volta che un messaggio valido viene alterato, il destinatario

57
00:03:32,479 --> 00:03:35,454
è responsabile di correggere ciò che vede al vicino valido

58
00:03:35,454 --> 00:03:38,380
più vicino, come potresti fare con un errore di battitura.

59
00:03:38,380 --> 00:03:42,870
Tuttavia, elaborare un algoritmo concreto per classificare in modo

60
00:03:42,870 --> 00:03:47,160
efficiente messaggi come questo richiede una certa intelligenza.

61
00:03:47,160 --> 00:03:50,667
La storia inizia negli anni &#39;40, quando un giovane Richard Hamming lavorava

62
00:03:50,667 --> 00:03:54,131
per i Bell Labs e parte del suo lavoro prevedeva l&#39;utilizzo di un computer

63
00:03:54,131 --> 00:03:57,420
a scheda perforata molto costoso e al quale aveva solo un accesso limitato.

64
00:03:57,420 --> 00:04:00,305
E i programmi che continuava a far passare continuavano

65
00:04:00,305 --> 00:04:03,140
a fallire, perché ogni tanto qualcuno veniva frainteso.

66
00:04:03,140 --> 00:04:06,165
Essendo la frustrazione il crogiolo dell&#39;invenzione, ne fu così

67
00:04:06,165 --> 00:04:09,280
stufo che inventò il primo codice di correzione degli errori al mondo.

68
00:04:09,280 --> 00:04:12,925
Esistono molti modi diversi per strutturare i codici di Hamming, ma come

69
00:04:12,925 --> 00:04:16,620
primo passo li esamineremo nel modo in cui Hamming stesso li ha concepiti.

70
00:04:16,620 --> 00:04:21,400
Usiamo un esempio semplice, ma non troppo semplice, un blocco di 16 bit.

71
00:04:21,400 --> 00:04:25,700
Numereremo le posizioni di questi bit da 0 a 15.

72
00:04:25,700 --> 00:04:29,955
I dati effettivi che vogliamo archiviare costituiranno solo 12 di questi

73
00:04:29,955 --> 00:04:33,920
bit, mentre 4 posizioni sono riservate come una sorta di ridondanza.

74
00:04:33,920 --> 00:04:37,015
La parola ridondante qui non significa semplicemente copia, dopotutto

75
00:04:37,015 --> 00:04:40,200
quei 4 bit non ci danno abbastanza spazio per copiare ciecamente i dati.

76
00:04:40,200 --> 00:04:44,326
Dovranno invece rappresentare un tipo di ridondanza molto più sfumata e

77
00:04:44,326 --> 00:04:48,740
intelligente, senza aggiungere nuove informazioni, ma aggiungendo resilienza.

78
00:04:48,740 --> 00:04:52,600
Potresti aspettarti che questi 4 pezzi speciali siano ben confezionati insieme,

79
00:04:52,600 --> 00:04:56,460
magari alla fine o qualcosa del genere, ma come vedrai, averli in posizioni che

80
00:04:56,460 --> 00:05:00,320
sono potenze di 2 consente di ottenere qualcosa di veramente elegante alla fine.

81
00:05:00,320 --> 00:05:02,980
Potrebbe anche darti un piccolo suggerimento su

82
00:05:02,980 --> 00:05:05,420
come questo si adatta ai blocchi più grandi.

83
00:05:05,420 --> 00:05:08,470
Inoltre tecnicamente finiscono per essere solo 11 bit di dati,

84
00:05:08,470 --> 00:05:11,520
scoprirai che c&#39;è una leggera sfumatura per ciò che accade

85
00:05:11,520 --> 00:05:14,280
nella posizione 0, ma per ora non preoccuparti di questo.

86
00:05:14,280 --> 00:05:18,385
Come ogni algoritmo di correzione degli errori, coinvolgerà due giocatori, un mittente

87
00:05:18,385 --> 00:05:22,065
responsabile dell&#39;impostazione di questi 4 bit speciali e un destinatario

88
00:05:22,065 --> 00:05:26,029
responsabile dell&#39;esecuzione di una sorta di controllo e della correzione degli

89
00:05:26,029 --> 00:05:26,360
errori.

90
00:05:26,360 --> 00:05:29,373
Naturalmente, le parole mittente e destinatario si riferiscono in realtà a

91
00:05:29,373 --> 00:05:32,506
macchine o software che eseguono tutti i controlli, e l&#39;idea di messaggio

92
00:05:32,506 --> 00:05:35,480
è intesa in modo molto ampio, per includere cose come l&#39;archiviazione.

93
00:05:35,480 --> 00:05:39,183
Dopotutto, archiviare dati è come inviare un messaggio solo

94
00:05:39,183 --> 00:05:42,640
dal passato al futuro invece che da un luogo a un altro.

95
00:05:42,640 --> 00:05:46,243
Questa è la configurazione, ma prima di approfondire dobbiamo parlare di

96
00:05:46,243 --> 00:05:49,747
un&#39;idea correlata che era fresca nella mente di Hamming al momento

97
00:05:49,747 --> 00:05:53,449
della sua scoperta, un metodo che consente di rilevare eventuali errori di

98
00:05:53,449 --> 00:05:57,300
singoli bit, ma non di correggerli, noto nel settore come controllo di parità.

99
00:05:57,300 --> 00:06:01,166
Per un controllo di parità, separiamo solo un singolo bit della cui ottimizzazione

100
00:06:01,166 --> 00:06:04,940
il mittente è responsabile, mentre il resto è libero di trasportare un messaggio.

101
00:06:04,940 --> 00:06:08,458
L&#39;unico compito di questo bit speciale è assicurarsi

102
00:06:08,458 --> 00:06:12,100
che il numero totale di 1 nel messaggio sia un numero pari.

103
00:06:12,100 --> 00:06:16,479
Quindi, ad esempio, in questo momento, il numero totale di 1 è 7, è strano, quindi il

104
00:06:16,479 --> 00:06:20,960
mittente deve invertire quel bit speciale in modo che sia 1, rendendo il conteggio pari.

105
00:06:20,960 --> 00:06:24,191
Ma se il blocco fosse già iniziato con un numero pari di

106
00:06:24,191 --> 00:06:27,480
1, allora questo bit speciale sarebbe stato mantenuto a 0.

107
00:06:27,480 --> 00:06:30,509
È piuttosto semplice, ingannevolmente semplice, ma è un modo

108
00:06:30,509 --> 00:06:33,787
incredibilmente elegante per distillare l&#39;idea di cambiamento

109
00:06:33,787 --> 00:06:37,760
ovunque in un messaggio per rifletterlo in un singolo frammento di informazione.

110
00:06:37,760 --> 00:06:42,950
Nota se qualsiasi parte di questo messaggio viene invertita, da 0

111
00:06:42,950 --> 00:06:48,140
a 1 o da 1 a 0, cambia il conteggio totale di 1 da pari a dispari.

112
00:06:48,140 --> 00:06:51,714
Quindi, se sei il destinatario, guardi questo messaggio e vedi un

113
00:06:51,714 --> 00:06:55,288
numero dispari di 1, puoi sapere con certezza che si è verificato

114
00:06:55,288 --> 00:06:58,700
qualche errore, anche se potresti non avere idea di dove fosse.

115
00:06:58,700 --> 00:07:04,940
In gergo, se un gruppo di bit ha un numero pari o dispari di 1 è noto come parità.

116
00:07:04,940 --> 00:07:08,152
Potresti anche usare i numeri e dire che la parità è 0 o 1, il che in

117
00:07:08,152 --> 00:07:11,320
genere è più utile una volta che inizi a fare calcoli con l&#39;idea.

118
00:07:11,320 --> 00:07:14,533
E questo bit speciale che il mittente utilizza

119
00:07:14,533 --> 00:07:18,020
per controllare la parità è chiamato bit di parità.

120
00:07:18,020 --> 00:07:21,661
E in realtà, dovremmo essere chiari, se il ricevitore vede una parità dispari, non

121
00:07:21,661 --> 00:07:25,479
significa necessariamente che c&#39;è stato un solo errore, potrebbero esserci stati 3

122
00:07:25,479 --> 00:07:29,296
errori, o 5, o qualsiasi altro numero dispari, ma possono saperlo con certezza che non

123
00:07:29,296 --> 00:07:29,560
era 0.

124
00:07:29,560 --> 00:07:34,373
D&#39;altra parte, se ci fossero stati 2 errori, o un numero pari di errori, il conteggio

125
00:07:34,373 --> 00:07:38,866
finale di 1 sarebbe ancora pari, quindi il destinatario non può avere piena fiducia

126
00:07:38,866 --> 00:07:43,360
che un conteggio pari significhi necessariamente che il messaggio è privo di errori.

127
00:07:43,360 --> 00:07:46,473
Potresti lamentarti del fatto che un messaggio che viene incasinato con

128
00:07:46,473 --> 00:07:49,760
solo 2 bit di inversione è piuttosto debole e avresti assolutamente ragione.

129
00:07:49,760 --> 00:07:53,317
Tieni presente, tuttavia, che non esiste un metodo per il rilevamento

130
00:07:53,317 --> 00:07:56,620
o la correzione degli errori che possa darti la certezza al 100%

131
00:07:56,620 --> 00:07:59,720
che il messaggio che ricevi sia quello previsto dal mittente.

132
00:07:59,720 --> 00:08:02,842
Dopotutto, un rumore casuale sufficiente potrebbe sempre trasformare

133
00:08:02,842 --> 00:08:05,920
un messaggio valido in un altro messaggio valido solo per puro caso.

134
00:08:05,920 --> 00:08:11,111
L&#39;obiettivo è invece quello di elaborare uno schema che sia robusto fino a un certo

135
00:08:11,111 --> 00:08:16,067
numero massimo di errori, o magari ridurre la probabilità di un falso positivo come

136
00:08:16,067 --> 00:08:16,480
questo.

137
00:08:16,480 --> 00:08:20,140
I controlli di parità da soli sono piuttosto deboli, ma distillando

138
00:08:20,140 --> 00:08:24,016
l’idea di cambiamento in un intero messaggio fino a un singolo bit, ciò

139
00:08:24,016 --> 00:08:28,000
che ci danno è un potente elemento costitutivo per schemi più sofisticati.

140
00:08:28,000 --> 00:08:31,555
Ad esempio, mentre Hamming stava cercando un modo per identificare dove si è

141
00:08:31,555 --> 00:08:35,203
verificato un errore, non solo che si è verificato, la sua intuizione chiave è

142
00:08:35,203 --> 00:08:39,036
stata che se si applicano alcuni controlli di parità non all&#39;intero messaggio,

143
00:08:39,036 --> 00:08:42,822
ma a determinati sottoinsiemi accuratamente selezionati, è possibile chiedere una

144
00:08:42,822 --> 00:08:46,840
serie più raffinata di domande che individuano la posizione di ogni singolo errore bit.

145
00:08:46,840 --> 00:08:50,706
La sensazione generale è un po’ come giocare a un gioco di 20 domande,

146
00:08:50,706 --> 00:08:54,300
ponendo domande sì o no che dimezzano lo spazio delle possibilità.

147
00:08:54,300 --> 00:08:57,207
Ad esempio, supponiamo di eseguire un controllo di

148
00:08:57,207 --> 00:09:00,400
parità solo su questi 8 bit, tutte le posizioni dispari.

149
00:09:00,400 --> 00:09:03,272
Quindi, se viene rilevato un errore, fornisce al ricevitore

150
00:09:03,272 --> 00:09:06,144
qualche informazione in più su dove si trova specificamente

151
00:09:06,144 --> 00:09:09,160
l&#39;errore, vale a dire che si trova in una posizione strana.

152
00:09:09,160 --> 00:09:13,116
Se non viene rilevato alcun errore tra questi 8 bit, significa che non

153
00:09:13,116 --> 00:09:17,240
c&#39;è alcun errore o che si trova da qualche parte nelle posizioni pari.

154
00:09:17,240 --> 00:09:21,342
Potresti pensare che limitare un controllo di parità alla metà dei bit

155
00:09:21,342 --> 00:09:25,733
lo renda meno efficace, ma quando viene eseguito insieme ad altri controlli

156
00:09:25,733 --> 00:09:29,720
ben scelti, controintuitivamente ci dà qualcosa di molto più potente.

157
00:09:29,720 --> 00:09:33,683
Per impostare effettivamente il controllo di parità, ricorda, è necessario destinare

158
00:09:33,683 --> 00:09:37,600
qualche bit speciale che abbia il controllo della parità di quell&#39;intero gruppo.

159
00:09:37,600 --> 00:09:39,920
Qui scegliamo semplicemente la posizione 1.

160
00:09:39,920 --> 00:09:44,120
Nell&#39;esempio mostrato, la parità di questi 8 bit è attualmente dispari, quindi

161
00:09:44,120 --> 00:09:48,220
il mittente è responsabile della commutazione di quel bit di parità e ora è pari.

162
00:09:48,220 --> 00:09:51,040
Questo è solo 1 dei 4 controlli di parità che faremo.

163
00:09:51,040 --> 00:09:53,960
Il secondo controllo è tra gli 8 bit nella metà destra

164
00:09:53,960 --> 00:09:56,880
della griglia, almeno come l&#39;abbiamo disegnato qui.

165
00:09:56,880 --> 00:10:00,343
Questa volta potremmo usare la posizione 2 come bit di parità,

166
00:10:00,343 --> 00:10:03,641
quindi questi 8 bit hanno già una parità pari e il mittente

167
00:10:03,641 --> 00:10:07,160
può sentirsi a proprio agio lasciando invariato il bit numero 2.

168
00:10:07,160 --> 00:10:11,533
D&#39;altra parte, se il ricevitore controlla la parità di questo gruppo e scopre

169
00:10:11,533 --> 00:10:15,960
che è dispari, saprà che l&#39;errore è da qualche parte tra questi 8 bit a destra.

170
00:10:15,960 --> 00:10:18,486
Altrimenti significa che non ci sono errori oppure

171
00:10:18,486 --> 00:10:21,260
che l&#39;errore è da qualche parte nella metà sinistra.

172
00:10:21,260 --> 00:10:24,213
Oppure immagino che potrebbero esserci stati due errori, ma per ora

173
00:10:24,213 --> 00:10:27,080
assumeremo che ci sia al massimo un errore nell&#39;intero blocco.

174
00:10:27,080 --> 00:10:29,160
Le cose si guastano completamente per qualcosa di più.

175
00:10:29,160 --> 00:10:32,375
Ecco, prima di esaminare i prossimi due controlli, prendiamoci un momento per

176
00:10:32,375 --> 00:10:35,880
pensare a cosa ci permettono di fare questi primi due quando li consideriamo insieme.

177
00:10:35,880 --> 00:10:40,240
Supponiamo che rilevi un errore tra le colonne dispari e nella metà destra.

178
00:10:40,240 --> 00:10:43,940
Significa necessariamente che l&#39;errore è da qualche parte nell&#39;ultima colonna.

179
00:10:43,940 --> 00:10:47,255
Se non c&#39;erano errori nella colonna dispari ma ce n&#39;era

180
00:10:47,255 --> 00:10:50,520
uno nella metà destra, significa che è nella penultima colonna.

181
00:10:50,520 --> 00:10:53,540
Allo stesso modo, se c&#39;è un errore nelle colonne dispari ma non

182
00:10:53,540 --> 00:10:56,560
nella metà destra, sai che è da qualche parte nella seconda colonna.

183
00:10:56,560 --> 00:11:00,371
E se nessuno dei due controlli di parità rileva nulla, significa che l&#39;unico

184
00:11:00,371 --> 00:11:03,760
posto in cui potrebbe trovarsi un errore è nella colonna più a sinistra.

185
00:11:03,760 --> 00:11:06,480
Ma potrebbe anche semplicemente significare che non è presente alcun errore.

186
00:11:06,480 --> 00:11:09,068
Il che è un modo piuttosto elaborato per dire che due

187
00:11:09,068 --> 00:11:11,800
controlli di parità ci permettono di definire la colonna.

188
00:11:11,800 --> 00:11:14,000
Da qui probabilmente puoi intuire cosa segue.

189
00:11:14,000 --> 00:11:16,240
Facciamo sostanzialmente la stessa cosa, ma per le righe.

190
00:11:16,240 --> 00:11:18,572
Verrà effettuato un controllo di parità sulle righe

191
00:11:18,572 --> 00:11:21,040
dispari, utilizzando la posizione 4 come bit di parità.

192
00:11:21,040 --> 00:11:23,625
Quindi in questo esempio quel gruppo ha già una

193
00:11:23,625 --> 00:11:26,480
parità pari, quindi il bit 4 verrebbe impostato su 0.

194
00:11:26,480 --> 00:11:29,354
E infine c&#39;è un controllo di parità sulle due righe

195
00:11:29,354 --> 00:11:32,280
inferiori, utilizzando la posizione 8 come bit di parità.

196
00:11:32,280 --> 00:11:35,223
In questo caso, sembra che il mittente debba attivare

197
00:11:35,223 --> 00:11:37,840
il bit 8 per garantire la parità pari al gruppo.

198
00:11:37,840 --> 00:11:40,377
Proprio come i primi due controlli ci permettono di fissare

199
00:11:40,377 --> 00:11:43,000
la colonna, i due successivi ti permettono di fissare la riga.

200
00:11:43,000 --> 00:11:45,726
Ad esempio, immagina che durante la trasmissione si

201
00:11:45,726 --> 00:11:48,400
verifichi un errore, ad esempio, nella posizione 3.

202
00:11:48,400 --> 00:11:51,060
Bene, questo influisce sul primo gruppo di parità e influisce

203
00:11:51,060 --> 00:11:53,636
anche sul secondo gruppo di parità, quindi il ricevitore sa

204
00:11:53,636 --> 00:11:56,340
che c&#39;è un errore da qualche parte nella colonna di destra.

205
00:11:56,340 --> 00:12:01,380
Ma non influisce sul terzo gruppo e non influisce sul quarto gruppo.

206
00:12:01,380 --> 00:12:05,020
E ciò consente al ricevitore di individuare l&#39;errore fino alla prima riga, che

207
00:12:05,020 --> 00:12:08,660
significa necessariamente la posizione 3, in modo da poter correggere l&#39;errore.

208
00:12:08,660 --> 00:12:11,472
Potresti divertirti a prenderti un momento per convincerti che

209
00:12:11,472 --> 00:12:14,329
le risposte a queste quattro domande ti permetteranno sempre di

210
00:12:14,329 --> 00:12:17,320
individuare un luogo specifico, indipendentemente da dove si trovi.

211
00:12:17,320 --> 00:12:20,452
In effetti, i più astuti tra voi potrebbero anche notare

212
00:12:20,452 --> 00:12:23,640
una connessione tra queste domande e il conteggio binario.

213
00:12:23,640 --> 00:12:27,260
E se lo fai, lasciami ancora una volta sottolineare, fare una pausa,

214
00:12:27,260 --> 00:12:30,880
provare tu stesso a stabilire il collegamento prima che io lo rovini.

215
00:12:30,880 --> 00:12:33,594
Se ti stai chiedendo cosa succede se un bit di parità

216
00:12:33,594 --> 00:12:36,560
stesso viene influenzato, beh, puoi semplicemente provarlo.

217
00:12:36,560 --> 00:12:41,969
Prenditi un momento per pensare a come qualsiasi errore tra questi quattro bit speciali

218
00:12:41,969 --> 00:12:47,440
verrà rintracciato proprio come qualsiasi altro, con lo stesso gruppo di quattro domande.

219
00:12:47,440 --> 00:12:50,519
Non ha molta importanza, poiché alla fine ciò che vogliamo è proteggere i

220
00:12:50,519 --> 00:12:53,640
bit del messaggio, i bit di correzione degli errori continuano a viaggiare.

221
00:12:53,640 --> 00:12:56,233
Ma proteggere anche quelle parti è qualcosa che

222
00:12:56,233 --> 00:12:59,260
naturalmente cade fuori dallo schema come sottoprodotto.

223
00:12:59,260 --> 00:13:02,380
Potresti anche divertirti ad anticipare come tutto questo si espanderà.

224
00:13:02,380 --> 00:13:06,747
Se utilizzassimo un blocco di dimensione 256 bit, ad esempio, per

225
00:13:06,747 --> 00:13:11,114
individuare una posizione, sarebbero necessarie solo otto domande

226
00:13:11,114 --> 00:13:15,680
sì o no per effettuare una ricerca binaria fino a un punto specifico.

227
00:13:15,680 --> 00:13:19,615
E ricorda, ogni domanda richiede la rinuncia di un solo

228
00:13:19,615 --> 00:13:23,340
bit per impostare il controllo di parità appropriato.

229
00:13:23,340 --> 00:13:26,492
Alcuni di voi potrebbero già vederlo, ma parleremo più tardi del modo

230
00:13:26,492 --> 00:13:29,960
sistematico per scoprire quali sono queste domande in appena un minuto o due.

231
00:13:29,960 --> 00:13:32,362
Speriamo che questo schizzo sia sufficiente per apprezzare

232
00:13:32,362 --> 00:13:34,440
l&#39;efficienza di ciò che stiamo sviluppando qui.

233
00:13:34,440 --> 00:13:38,202
La prima cosa, ad eccezione degli otto bit di parità evidenziati, può essere

234
00:13:38,202 --> 00:13:41,720
qualunque cosa tu voglia, portando qualunque messaggio o dato tu voglia.

235
00:13:41,720 --> 00:13:45,382
Gli 8 bit sono ridondanti nel senso che sono completamente

236
00:13:45,382 --> 00:13:49,170
determinati dal resto del messaggio, ma in un modo molto più

237
00:13:49,170 --> 00:13:53,640
intelligente rispetto alla semplice copia del messaggio nel suo insieme.

238
00:13:53,640 --> 00:13:56,346
Eppure, con così poco sacrificio, sarai in grado di

239
00:13:56,346 --> 00:13:59,000
identificare e correggere qualsiasi singolo errore.

240
00:13:59,000 --> 00:14:00,400
Be &#39;quasi.

241
00:14:00,400 --> 00:14:04,898
Ok, quindi l&#39;unico problema qui è che se nessuno dei quattro controlli di parità

242
00:14:04,898 --> 00:14:08,974
rileva un errore, il che significa che i sottoinsiemi di 8 bit appositamente

243
00:14:08,974 --> 00:14:13,208
selezionati hanno tutti parità pari, proprio come previsto dal mittente, allora

244
00:14:13,208 --> 00:14:17,760
significa che non si è verificato alcun errore , oppure ci restringe alla posizione 0.

245
00:14:17,760 --> 00:14:22,435
Vedete, con quattro domande sì o no, abbiamo 16 possibili risultati per i nostri

246
00:14:22,435 --> 00:14:27,515
controlli di parità, e all&#39;inizio sembra perfetto per individuare 1 posizione su 16

247
00:14:27,515 --> 00:14:32,365
nel blocco, ma è necessario comunicare anche un 17esimo risultato, il nessun errore

248
00:14:32,365 --> 00:14:33,000
condizione.

249
00:14:33,000 --> 00:14:37,860
La soluzione qui è in realtà piuttosto semplice, dimentica completamente lo 0° bit.

250
00:14:37,860 --> 00:14:41,067
Quindi, quando eseguiamo i nostri quattro controlli di parità e vediamo

251
00:14:41,067 --> 00:14:44,320
che sono tutti pari, significa inequivocabilmente che non ci sono errori.

252
00:14:44,320 --> 00:14:47,555
Ciò significa che invece di lavorare con un blocco a 16 bit,

253
00:14:47,555 --> 00:14:50,738
lavoriamo con un blocco a 15 bit, in cui 11 bit sono liberi

254
00:14:50,738 --> 00:14:54,080
di trasportare un messaggio e 4 di essi sono lì per ridondanza.

255
00:14:54,080 --> 00:14:56,768
E con questo, ora abbiamo quello che le persone

256
00:14:56,768 --> 00:14:59,400
del settore chiamerebbero codice Hamming 15-11.

257
00:14:59,400 --> 00:15:02,560
Detto questo, è bello avere una dimensione del blocco che sia una

258
00:15:02,560 --> 00:15:05,672
potenza netta di 2, e c&#39;è un modo intelligente per mantenere

259
00:15:05,672 --> 00:15:08,880
lo 0° bit in giro e fargli fare un po&#39; di lavoro extra per noi.

260
00:15:08,880 --> 00:15:12,369
Se lo usiamo come bit di parità nell&#39;intero blocco, ci consente

261
00:15:12,369 --> 00:15:16,320
effettivamente di rilevare, anche se non possiamo correggere, errori a 2 bit.

262
00:15:16,320 --> 00:15:17,440
Ecco come funziona.

263
00:15:17,440 --> 00:15:20,015
Dopo aver impostato questi quattro bit speciali di correzione

264
00:15:20,015 --> 00:15:23,006
degli errori, impostiamo quello 0 in modo che la parità dell&#39;intero

265
00:15:23,006 --> 00:15:25,540
blocco sia pari, proprio come un normale controllo di parità.

266
00:15:25,540 --> 00:15:29,546
Ora, se c&#39;è un errore di un solo bit, la parità dell&#39;intero blocco diventa

267
00:15:29,546 --> 00:15:33,602
dispari, ma lo rileveremmo comunque grazie ai quattro controlli di correzione degli

268
00:15:33,602 --> 00:15:33,940
errori.

269
00:15:33,940 --> 00:15:37,985
Tuttavia, se si verificano due errori, la parità complessiva tornerà ad essere

270
00:15:37,985 --> 00:15:41,877
pari, ma il ricevitore vedrebbe comunque che si è verificato almeno qualche

271
00:15:41,877 --> 00:15:45,820
errore a causa di ciò che sta accadendo con quei quattro controlli di parità.

272
00:15:45,820 --> 00:15:49,443
Quindi, se notano una parità nel complesso, ma succede qualcosa di diverso da zero

273
00:15:49,443 --> 00:15:52,980
con gli altri controlli, significa loro che si sono verificati almeno due errori.

274
00:15:52,980 --> 00:15:54,420
Non è intelligente?

275
00:15:54,420 --> 00:15:58,243
Anche se non possiamo correggere quegli errori a 2 bit, semplicemente

276
00:15:58,243 --> 00:16:02,340
rimettendo in funzione quel piccolo e fastidioso bit 0, possiamo rilevarli.

277
00:16:02,340 --> 00:16:06,540
Questo è piuttosto standard, è noto come codice Hamming esteso.

278
00:16:06,540 --> 00:16:10,086
Tecnicamente parlando, ora hai una descrizione completa di cosa fa

279
00:16:10,086 --> 00:16:13,580
un codice Hamming, almeno per l&#39;esempio di un blocco a 16 bit.

280
00:16:13,580 --> 00:16:17,660
Ma penso che troverai più soddisfacente verificare la tua comprensione e consolidare

281
00:16:17,660 --> 00:16:21,980
tutto fino a questo punto facendo tu stesso un esempio completo dall&#39;inizio alla fine.

282
00:16:21,980 --> 00:16:25,100
Lo esaminerò insieme a te, così potrai controllarti tu stesso.

283
00:16:25,100 --> 00:16:28,686
Per impostare un messaggio, che si tratti di un messaggio letterale

284
00:16:28,686 --> 00:16:32,008
che stai traducendo nello spazio o di alcuni dati che desideri

285
00:16:32,008 --> 00:16:35,700
archiviare nel tempo, il primo passo è dividerlo in blocchi da 11 bit.

286
00:16:35,700 --> 00:16:40,340
Ogni pezzo verrà impacchettato in un blocco a 16 bit resistente agli errori.

287
00:16:40,340 --> 00:16:43,740
Quindi prendiamo questo come esempio e risolviamolo davvero.

288
00:16:43,740 --> 00:16:45,380
Vai avanti, fallo davvero!

289
00:16:45,380 --> 00:16:52,980
Facciamo una pausa e proviamo a mettere insieme questo blocco.

290
00:16:52,980 --> 00:16:53,980
Ok, sei pronto?

291
00:16:53,980 --> 00:16:57,665
Ricorda, la posizione 0 insieme alle altre potenze di 2 sono

292
00:16:57,665 --> 00:17:01,410
riservate al compito di correzione degli errori, quindi inizi

293
00:17:01,410 --> 00:17:05,700
posizionando i bit del messaggio in tutti i punti rimanenti, in ordine.

294
00:17:05,700 --> 00:17:09,338
È necessario che questo gruppo abbia una parità pari, cosa che già

295
00:17:09,338 --> 00:17:13,140
ha, quindi dovresti impostare il bit di parità nella posizione 1 su 0.

296
00:17:13,140 --> 00:17:16,322
Il gruppo successivo inizia con una parità dispari,

297
00:17:16,322 --> 00:17:19,260
quindi dovresti impostare il bit di parità su 1.

298
00:17:19,260 --> 00:17:21,932
Il gruppo successivo inizia con una parità dispari, quindi

299
00:17:21,932 --> 00:17:24,740
anche in questo caso dovresti impostare il bit di parità su 1.

300
00:17:24,740 --> 00:17:28,059
E anche il gruppo finale ha una parità dispari, il che

301
00:17:28,059 --> 00:17:31,500
significa che impostiamo quel bit nella posizione 8 su 1.

302
00:17:31,500 --> 00:17:36,342
E poi, come passaggio finale, l&#39;intero blocco ora ha una parità pari, il

303
00:17:36,342 --> 00:17:41,500
che significa che puoi impostare il bit numero 0, il bit di parità generale, su 0.

304
00:17:41,500 --> 00:17:45,103
Quindi, quando questo blocco viene espulso, la parità dei quattro

305
00:17:45,103 --> 00:17:48,980
sottoinsiemi speciali e del blocco nel suo insieme sarà pari, ovvero 0.

306
00:17:48,980 --> 00:17:53,620
Come seconda parte dell&#39;esercizio, ti faremo interpretare il ruolo del ricevente.

307
00:17:53,620 --> 00:17:57,004
Naturalmente, ciò significherebbe che non sapete già quale sia questo messaggio,

308
00:17:57,004 --> 00:18:00,180
forse alcuni di voi lo hanno memorizzato, ma supponiamo che non lo sappiate.

309
00:18:00,180 --> 00:18:04,053
Quello che farò è cambiare 0, 1 o 2 dei bit in

310
00:18:04,053 --> 00:18:08,340
quel blocco e poi chiederti di capire cosa ho fatto.

311
00:18:08,340 --> 00:18:13,460
Quindi, ancora una volta, fai una pausa e prova a risolverlo.

312
00:18:13,460 --> 00:18:21,640
Ok, quindi tu come ricevitore ora controlli il primo gruppo di parità e puoi vedere

313
00:18:21,640 --> 00:18:29,820
che è pari, quindi qualsiasi errore esistente dovrebbe trovarsi in una colonna pari.

314
00:18:29,820 --> 00:18:34,290
Il controllo successivo ci fornisce un numero dispari, dicendoci che

315
00:18:34,290 --> 00:18:38,760
c&#39;è almeno un errore e restringendoci a questa colonna specifica.

316
00:18:38,760 --> 00:18:42,900
Il terzo controllo è pari, riducendo ulteriormente le possibilità.

317
00:18:42,900 --> 00:18:47,325
E l&#39;ultimo controllo di parità è strano, ci dice che c&#39;è un errore da qualche

318
00:18:47,325 --> 00:18:51,700
parte in fondo, che ormai come possiamo vedere deve essere nella posizione numero 10.

319
00:18:51,700 --> 00:18:54,933
Inoltre, la parità dell&#39;intero blocco è strana, il che ci

320
00:18:54,933 --> 00:18:58,220
dà la certezza che si sia verificato un ribaltamento e non due.

321
00:18:58,220 --> 00:19:01,600
Se sono tre o più, tutte le scommesse vengono annullate.

322
00:19:01,600 --> 00:19:06,605
Dopo aver corretto il bit numero 10, estraendo gli 11 bit che non sono stati utilizzati

323
00:19:06,605 --> 00:19:11,496
per la correzione, otteniamo il segmento rilevante del messaggio originale, che se lo

324
00:19:11,496 --> 00:19:16,160
riavvolgi e confronti è esattamente quello con cui abbiamo iniziato l&#39;esempio.

325
00:19:16,160 --> 00:19:20,259
E ora che sai come fare tutto questo manualmente, vorrei mostrarti come puoi realizzare

326
00:19:20,259 --> 00:19:23,940
la parte centrale di tutta questa logica con una singola riga di codice Python.

327
00:19:23,940 --> 00:19:28,028
Vedi, quello che non ti ho ancora detto è quanto sia elegante questo algoritmo,

328
00:19:28,028 --> 00:19:32,066
quanto sia semplice far sì che una macchina indichi la posizione di un errore,

329
00:19:32,066 --> 00:19:36,053
come ridimensionarlo sistematicamente e come possiamo inquadrare tutto questo

330
00:19:36,053 --> 00:19:39,580
come una singola operazione anziché più controlli di parità separati.

331
00:19:39,580 --> 00:19:39,580
Per capire cosa intendo, unisciti a me nella parte 2.

