1
00:00:00,000 --> 00:00:05,400
Ti sei mai chiesto come sia possibile grattare un CD o

2
00:00:05,400 --> 00:00:10,900
un DVD e continuare a riprodurre tutto ciò che contiene?

3
00:00:10,900 --> 00:00:14,249
Il graffio influisce davvero sugli 1 e sugli 0 sul disco,

4
00:00:14,249 --> 00:00:19,447
quindi legge dati diversi da quelli memorizzati, ma a meno che non sia davvero graffiato,

5
00:00:19,447 --> 00:00:23,664
i bit che legge vengono decodificati esattamente nello stesso file che è

6
00:00:23,664 --> 00:00:28,400
stato codificato su di esso, un copia bit per bit, nonostante tutti quegli errori.

7
00:00:28,400 --> 00:00:32,796
C&#39;è tutta una serie di abilità matematiche che ci consentono di archiviare dati e,

8
00:00:32,796 --> 00:00:36,840
cosa altrettanto importante, di trasmetterli, in un modo resistente agli errori.

9
00:00:36,840 --> 00:00:42,480
Bene, okay, in realtà non ci vuole molta intelligenza per trovare un modo per farlo.

10
00:00:42,480 --> 00:00:46,597
Qualsiasi file, sia esso un video, un suono o un testo, un codice,

11
00:00:46,597 --> 00:00:50,960
un&#39;immagine, qualunque cosa, è in definitiva una sequenza di 1 e 0.

12
00:00:50,960 --> 00:00:54,343
E una strategia semplice per correggere qualsiasi bit che viene

13
00:00:54,343 --> 00:00:57,780
invertito sarebbe quella di memorizzare tre copie di ciascun bit.

14
00:00:57,780 --> 00:01:02,703
Quindi la macchina che legge questo file potrebbe confrontare queste tre copie

15
00:01:02,703 --> 00:01:07,440
e prendere sempre le migliori 2 su 3 ogni volta che c&#39;è una discrepanza.

16
00:01:07,440 --> 00:01:11,560
Ma ciò significa utilizzare due terzi dello spazio per la ridondanza.

17
00:01:11,560 --> 00:01:14,263
E anche in questo caso, nonostante tutto lo spazio concesso,

18
00:01:14,263 --> 00:01:18,120
non esiste alcuna garanzia forte su cosa accadrebbe se più di un bit venisse invertito.

19
00:01:18,120 --> 00:01:21,305
La questione molto più interessante è come fare in modo che gli

20
00:01:21,305 --> 00:01:24,740
errori possano essere corretti rinunciando al minor spazio possibile.

21
00:01:24,740 --> 00:01:28,128
Ad esempio, utilizzando il metodo che imparerai in questo video,

22
00:01:28,128 --> 00:01:30,994
potresti archiviare i tuoi dati in blocchi da 256 bit,

23
00:01:30,994 --> 00:01:32,975
dove ciascun blocco utilizza 9 bit, 9!

24
00:01:32,975 --> 00:01:37,164
per agire come una sorta di ridondanza e gli altri 247 bit sono liberi

25
00:01:37,164 --> 00:01:41,000
di trasportare qualunque messaggio o dato significativo desideri.

26
00:01:41,000 --> 00:01:43,899
E avverrà comunque che se qualche bit viene invertito qui,

27
00:01:43,899 --> 00:01:46,603
semplicemente guardando questo blocco e niente di più,

28
00:01:46,603 --> 00:01:50,633
una macchina sarà in grado di identificare che c&#39;era un errore e precisamente

29
00:01:50,633 --> 00:01:53,140
dove si trovava in modo da sapere come correggerlo.

30
00:01:53,140 --> 00:01:55,540
E onestamente, sembra una magia.

31
00:01:55,540 --> 00:01:58,244
E per questo particolare schema, se due bit vengono invertiti,

32
00:01:58,244 --> 00:02:01,677
la macchina sarà almeno in grado di rilevare che si sono verificati due errori,

33
00:02:01,677 --> 00:02:03,180
anche se non saprà come risolverli.

34
00:02:03,180 --> 00:02:08,140
Parleremo un po&#39; più tardi di come questo si adatta a blocchi di dimensioni diverse.

35
00:02:08,140 --> 00:02:11,031
I metodi che consentono di correggere errori come questo sono noti,

36
00:02:11,031 --> 00:02:13,880
abbastanza ragionevolmente, come codici di correzione degli errori.

37
00:02:13,880 --> 00:02:16,852
Per gran parte del secolo scorso, questo campo è stato una

38
00:02:16,852 --> 00:02:19,926
fonte davvero ricca di matematica sorprendentemente profonda

39
00:02:19,926 --> 00:02:23,000
che viene incorporata nei dispositivi che usiamo ogni giorno.

40
00:02:23,000 --> 00:02:28,199
L&#39;obiettivo qui è darti una comprensione molto approfondita di uno dei primi esempi,

41
00:02:28,199 --> 00:02:29,660
noto come codice Hamming.

42
00:02:29,660 --> 00:02:33,195
E comunque, il modo in cui penso alla struttura di questo video non è tanto

43
00:02:33,195 --> 00:02:35,614
quello di spiegarlo nel modo più diretto possibile,

44
00:02:35,614 --> 00:02:38,405
quanto più una questione di spingerti a inventarlo da solo,

45
00:02:38,405 --> 00:02:40,220
con una piccola guida gentile qua e là.

46
00:02:40,220 --> 00:02:43,192
Quindi, quando hai la sensazione di vedere dove sta andando ad un certo punto,

47
00:02:43,192 --> 00:02:45,599
prenditi quel momento per fare una pausa, prevedere attivamente

48
00:02:45,599 --> 00:02:47,180
quale sarà lo schema prima che te lo dica.

49
00:02:47,180 --> 00:02:50,772
Inoltre, se vuoi che la tua comprensione scenda al livello hardware,

50
00:02:50,772 --> 00:02:55,042
Ben Eater ha realizzato un video insieme a questo che ti mostra come implementare

51
00:02:55,042 --> 00:02:59,520
effettivamente i codici Hamming sulle breadboard, il che è estremamente soddisfacente.

52
00:02:59,520 --> 00:03:03,773
Dovresti sapere che i codici di Hamming non sono così diffusi come i codici più moderni,

53
00:03:03,773 --> 00:03:07,549
come l&#39;algoritmo di Reed-Solomon, ma c&#39;è una certa magia nel contrasto

54
00:03:07,549 --> 00:03:11,181
tra quanto questo compito sembra impossibile all&#39;inizio e quanto sembra

55
00:03:11,181 --> 00:03:14,240
assolutamente ragionevole una volta. impari a conoscere Hamming.

56
00:03:14,240 --> 00:03:18,601
Il principio di base della correzione degli errori è che in un vasto spazio di tutti

57
00:03:18,601 --> 00:03:22,860
i messaggi possibili, solo alcuni sottoinsiemi saranno considerati messaggi validi.

58
00:03:22,860 --> 00:03:26,562
Per analogia, pensa alle parole scritte correttamente

59
00:03:26,562 --> 00:03:29,100
e alle parole scritte in modo errato.

60
00:03:29,100 --> 00:03:31,672
Ogni volta che un messaggio valido viene alterato,

61
00:03:31,672 --> 00:03:36,060
il destinatario è responsabile di correggere ciò che vede al vicino valido più vicino,

62
00:03:36,060 --> 00:03:38,380
come potresti fare con un errore di battitura.

63
00:03:38,380 --> 00:03:42,870
Tuttavia, elaborare un algoritmo concreto per classificare in modo

64
00:03:42,870 --> 00:03:47,160
efficiente messaggi come questo richiede una certa intelligenza.

65
00:03:47,160 --> 00:03:50,667
La storia inizia negli anni &#39;40, quando un giovane Richard Hamming lavorava

66
00:03:50,667 --> 00:03:54,131
per i Bell Labs e parte del suo lavoro prevedeva l&#39;utilizzo di un computer

67
00:03:54,131 --> 00:03:57,420
a scheda perforata molto costoso e al quale aveva solo un accesso limitato.

68
00:03:57,420 --> 00:04:00,872
E i programmi che continuava a far passare continuavano a fallire,

69
00:04:00,872 --> 00:04:03,140
perché ogni tanto qualcuno veniva frainteso.

70
00:04:03,140 --> 00:04:05,676
Essendo la frustrazione il crogiolo dell&#39;invenzione,

71
00:04:05,676 --> 00:04:09,280
ne fu così stufo che inventò il primo codice di correzione degli errori al mondo.

72
00:04:09,280 --> 00:04:12,525
Esistono molti modi diversi per strutturare i codici di Hamming,

73
00:04:12,525 --> 00:04:16,620
ma come primo passo li esamineremo nel modo in cui Hamming stesso li ha concepiti.

74
00:04:16,620 --> 00:04:21,400
Usiamo un esempio semplice, ma non troppo semplice, un blocco di 16 bit.

75
00:04:21,400 --> 00:04:25,700
Numereremo le posizioni di questi bit da 0 a 15.

76
00:04:25,700 --> 00:04:30,247
I dati effettivi che vogliamo archiviare costituiranno solo 12 di questi bit,

77
00:04:30,247 --> 00:04:33,920
mentre 4 posizioni sono riservate come una sorta di ridondanza.

78
00:04:33,920 --> 00:04:36,573
La parola ridondante qui non significa semplicemente copia,

79
00:04:36,573 --> 00:04:40,200
dopotutto quei 4 bit non ci danno abbastanza spazio per copiare ciecamente i dati.

80
00:04:40,200 --> 00:04:45,129
Dovranno invece rappresentare un tipo di ridondanza molto più sfumata e intelligente,

81
00:04:45,129 --> 00:04:48,740
senza aggiungere nuove informazioni, ma aggiungendo resilienza.

82
00:04:48,740 --> 00:04:52,600
Potresti aspettarti che questi 4 pezzi speciali siano ben confezionati insieme,

83
00:04:52,600 --> 00:04:55,302
magari alla fine o qualcosa del genere, ma come vedrai,

84
00:04:55,302 --> 00:04:58,920
averli in posizioni che sono potenze di 2 consente di ottenere qualcosa di

85
00:04:58,920 --> 00:05:00,320
veramente elegante alla fine.

86
00:05:00,320 --> 00:05:02,980
Potrebbe anche darti un piccolo suggerimento su

87
00:05:02,980 --> 00:05:05,420
come questo si adatta ai blocchi più grandi.

88
00:05:05,420 --> 00:05:08,470
Inoltre tecnicamente finiscono per essere solo 11 bit di dati,

89
00:05:08,470 --> 00:05:12,440
scoprirai che c&#39;è una leggera sfumatura per ciò che accade nella posizione 0,

90
00:05:12,440 --> 00:05:14,280
ma per ora non preoccuparti di questo.

91
00:05:14,280 --> 00:05:17,819
Come ogni algoritmo di correzione degli errori, coinvolgerà due giocatori,

92
00:05:17,819 --> 00:05:22,065
un mittente responsabile dell&#39;impostazione di questi 4 bit speciali e un destinatario

93
00:05:22,065 --> 00:05:26,029
responsabile dell&#39;esecuzione di una sorta di controllo e della correzione degli

94
00:05:26,029 --> 00:05:26,360
errori.

95
00:05:26,360 --> 00:05:29,373
Naturalmente, le parole mittente e destinatario si riferiscono in realtà a

96
00:05:29,373 --> 00:05:31,462
macchine o software che eseguono tutti i controlli,

97
00:05:31,462 --> 00:05:33,712
e l&#39;idea di messaggio è intesa in modo molto ampio,

98
00:05:33,712 --> 00:05:35,480
per includere cose come l&#39;archiviazione.

99
00:05:35,480 --> 00:05:39,183
Dopotutto, archiviare dati è come inviare un messaggio solo

100
00:05:39,183 --> 00:05:42,640
dal passato al futuro invece che da un luogo a un altro.

101
00:05:42,640 --> 00:05:46,243
Questa è la configurazione, ma prima di approfondire dobbiamo parlare di

102
00:05:46,243 --> 00:05:49,747
un&#39;idea correlata che era fresca nella mente di Hamming al momento

103
00:05:49,747 --> 00:05:54,091
della sua scoperta, un metodo che consente di rilevare eventuali errori di singoli bit,

104
00:05:54,091 --> 00:05:57,300
ma non di correggerli, noto nel settore come controllo di parità.

105
00:05:57,300 --> 00:06:01,166
Per un controllo di parità, separiamo solo un singolo bit della cui ottimizzazione

106
00:06:01,166 --> 00:06:04,940
il mittente è responsabile, mentre il resto è libero di trasportare un messaggio.

107
00:06:04,940 --> 00:06:08,458
L&#39;unico compito di questo bit speciale è assicurarsi

108
00:06:08,458 --> 00:06:12,100
che il numero totale di 1 nel messaggio sia un numero pari.

109
00:06:12,100 --> 00:06:15,969
Quindi, ad esempio, in questo momento, il numero totale di 1 è 7, è strano,

110
00:06:15,969 --> 00:06:19,585
quindi il mittente deve invertire quel bit speciale in modo che sia 1,

111
00:06:19,585 --> 00:06:20,960
rendendo il conteggio pari.

112
00:06:20,960 --> 00:06:24,361
Ma se il blocco fosse già iniziato con un numero pari di 1,

113
00:06:24,361 --> 00:06:27,480
allora questo bit speciale sarebbe stato mantenuto a 0.

114
00:06:27,480 --> 00:06:29,863
È piuttosto semplice, ingannevolmente semplice,

115
00:06:29,863 --> 00:06:33,191
ma è un modo incredibilmente elegante per distillare l&#39;idea di

116
00:06:33,191 --> 00:06:36,468
cambiamento ovunque in un messaggio per rifletterlo in un singolo

117
00:06:36,468 --> 00:06:37,760
frammento di informazione.

118
00:06:37,760 --> 00:06:42,556
Nota se qualsiasi parte di questo messaggio viene invertita,

119
00:06:42,556 --> 00:06:48,140
da 0 a 1 o da 1 a 0, cambia il conteggio totale di 1 da pari a dispari.

120
00:06:48,140 --> 00:06:52,851
Quindi, se sei il destinatario, guardi questo messaggio e vedi un numero dispari di 1,

121
00:06:52,851 --> 00:06:56,154
puoi sapere con certezza che si è verificato qualche errore,

122
00:06:56,154 --> 00:06:58,700
anche se potresti non avere idea di dove fosse.

123
00:06:58,700 --> 00:07:04,940
In gergo, se un gruppo di bit ha un numero pari o dispari di 1 è noto come parità.

124
00:07:04,940 --> 00:07:07,693
Potresti anche usare i numeri e dire che la parità è 0 o 1,

125
00:07:07,693 --> 00:07:11,320
il che in genere è più utile una volta che inizi a fare calcoli con l&#39;idea.

126
00:07:11,320 --> 00:07:14,533
E questo bit speciale che il mittente utilizza

127
00:07:14,533 --> 00:07:18,020
per controllare la parità è chiamato bit di parità.

128
00:07:18,020 --> 00:07:21,486
E in realtà, dovremmo essere chiari, se il ricevitore vede una parità dispari,

129
00:07:21,486 --> 00:07:24,294
non significa necessariamente che c&#39;è stato un solo errore,

130
00:07:24,294 --> 00:07:27,541
potrebbero esserci stati 3 errori, o 5, o qualsiasi altro numero dispari,

131
00:07:27,541 --> 00:07:29,560
ma possono saperlo con certezza che non era 0.

132
00:07:29,560 --> 00:07:33,678
D&#39;altra parte, se ci fossero stati 2 errori, o un numero pari di errori,

133
00:07:33,678 --> 00:07:38,118
il conteggio finale di 1 sarebbe ancora pari, quindi il destinatario non può avere

134
00:07:38,118 --> 00:07:42,825
piena fiducia che un conteggio pari significhi necessariamente che il messaggio è privo

135
00:07:42,825 --> 00:07:43,360
di errori.

136
00:07:43,360 --> 00:07:46,473
Potresti lamentarti del fatto che un messaggio che viene incasinato con

137
00:07:46,473 --> 00:07:49,760
solo 2 bit di inversione è piuttosto debole e avresti assolutamente ragione.

138
00:07:49,760 --> 00:07:53,317
Tieni presente, tuttavia, che non esiste un metodo per il rilevamento

139
00:07:53,317 --> 00:07:56,620
o la correzione degli errori che possa darti la certezza al 100%

140
00:07:56,620 --> 00:07:59,720
che il messaggio che ricevi sia quello previsto dal mittente.

141
00:07:59,720 --> 00:08:02,842
Dopotutto, un rumore casuale sufficiente potrebbe sempre trasformare

142
00:08:02,842 --> 00:08:05,920
un messaggio valido in un altro messaggio valido solo per puro caso.

143
00:08:05,920 --> 00:08:11,111
L&#39;obiettivo è invece quello di elaborare uno schema che sia robusto fino a un certo

144
00:08:11,111 --> 00:08:16,067
numero massimo di errori, o magari ridurre la probabilità di un falso positivo come

145
00:08:16,067 --> 00:08:16,480
questo.

146
00:08:16,480 --> 00:08:19,333
I controlli di parità da soli sono piuttosto deboli,

147
00:08:19,333 --> 00:08:23,801
ma distillando l’idea di cambiamento in un intero messaggio fino a un singolo bit,

148
00:08:23,801 --> 00:08:28,000
ciò che ci danno è un potente elemento costitutivo per schemi più sofisticati.

149
00:08:28,000 --> 00:08:31,555
Ad esempio, mentre Hamming stava cercando un modo per identificare dove si è

150
00:08:31,555 --> 00:08:33,956
verificato un errore, non solo che si è verificato,

151
00:08:33,956 --> 00:08:37,650
la sua intuizione chiave è stata che se si applicano alcuni controlli di parità

152
00:08:37,650 --> 00:08:41,668
non all&#39;intero messaggio, ma a determinati sottoinsiemi accuratamente selezionati,

153
00:08:41,668 --> 00:08:45,593
è possibile chiedere una serie più raffinata di domande che individuano la posizione

154
00:08:45,593 --> 00:08:46,840
di ogni singolo errore bit.

155
00:08:46,840 --> 00:08:50,706
La sensazione generale è un po’ come giocare a un gioco di 20 domande,

156
00:08:50,706 --> 00:08:54,300
ponendo domande sì o no che dimezzano lo spazio delle possibilità.

157
00:08:54,300 --> 00:08:58,860
Ad esempio, supponiamo di eseguire un controllo di parità solo su questi 8 bit,

158
00:08:58,860 --> 00:09:00,400
tutte le posizioni dispari.

159
00:09:00,400 --> 00:09:03,272
Quindi, se viene rilevato un errore, fornisce al ricevitore

160
00:09:03,272 --> 00:09:06,814
qualche informazione in più su dove si trova specificamente l&#39;errore,

161
00:09:06,814 --> 00:09:09,160
vale a dire che si trova in una posizione strana.

162
00:09:09,160 --> 00:09:12,113
Se non viene rilevato alcun errore tra questi 8 bit,

163
00:09:12,113 --> 00:09:16,069
significa che non c&#39;è alcun errore o che si trova da qualche parte

164
00:09:16,069 --> 00:09:17,240
nelle posizioni pari.

165
00:09:17,240 --> 00:09:21,342
Potresti pensare che limitare un controllo di parità alla metà dei bit

166
00:09:21,342 --> 00:09:26,426
lo renda meno efficace, ma quando viene eseguito insieme ad altri controlli ben scelti,

167
00:09:26,426 --> 00:09:29,720
controintuitivamente ci dà qualcosa di molto più potente.

168
00:09:29,720 --> 00:09:32,610
Per impostare effettivamente il controllo di parità, ricorda,

169
00:09:32,610 --> 00:09:36,480
è necessario destinare qualche bit speciale che abbia il controllo della parità di

170
00:09:36,480 --> 00:09:37,600
quell&#39;intero gruppo.

171
00:09:37,600 --> 00:09:39,920
Qui scegliamo semplicemente la posizione 1.

172
00:09:39,920 --> 00:09:43,766
Nell&#39;esempio mostrato, la parità di questi 8 bit è attualmente dispari,

173
00:09:43,766 --> 00:09:48,220
quindi il mittente è responsabile della commutazione di quel bit di parità e ora è pari.

174
00:09:48,220 --> 00:09:51,040
Questo è solo 1 dei 4 controlli di parità che faremo.

175
00:09:51,040 --> 00:09:54,756
Il secondo controllo è tra gli 8 bit nella metà destra della griglia,

176
00:09:54,756 --> 00:09:56,880
almeno come l&#39;abbiamo disegnato qui.

177
00:09:56,880 --> 00:10:00,343
Questa volta potremmo usare la posizione 2 come bit di parità,

178
00:10:00,343 --> 00:10:03,641
quindi questi 8 bit hanno già una parità pari e il mittente

179
00:10:03,641 --> 00:10:07,160
può sentirsi a proprio agio lasciando invariato il bit numero 2.

180
00:10:07,160 --> 00:10:11,533
D&#39;altra parte, se il ricevitore controlla la parità di questo gruppo e scopre

181
00:10:11,533 --> 00:10:15,960
che è dispari, saprà che l&#39;errore è da qualche parte tra questi 8 bit a destra.

182
00:10:15,960 --> 00:10:18,486
Altrimenti significa che non ci sono errori oppure

183
00:10:18,486 --> 00:10:21,260
che l&#39;errore è da qualche parte nella metà sinistra.

184
00:10:21,260 --> 00:10:23,735
Oppure immagino che potrebbero esserci stati due errori,

185
00:10:23,735 --> 00:10:27,080
ma per ora assumeremo che ci sia al massimo un errore nell&#39;intero blocco.

186
00:10:27,080 --> 00:10:29,160
Le cose si guastano completamente per qualcosa di più.

187
00:10:29,160 --> 00:10:31,262
Ecco, prima di esaminare i prossimi due controlli,

188
00:10:31,262 --> 00:10:34,601
prendiamoci un momento per pensare a cosa ci permettono di fare questi primi due

189
00:10:34,601 --> 00:10:35,880
quando li consideriamo insieme.

190
00:10:35,880 --> 00:10:40,240
Supponiamo che rilevi un errore tra le colonne dispari e nella metà destra.

191
00:10:40,240 --> 00:10:43,940
Significa necessariamente che l&#39;errore è da qualche parte nell&#39;ultima colonna.

192
00:10:43,940 --> 00:10:48,447
Se non c&#39;erano errori nella colonna dispari ma ce n&#39;era uno nella metà destra,

193
00:10:48,447 --> 00:10:50,520
significa che è nella penultima colonna.

194
00:10:50,520 --> 00:10:54,383
Allo stesso modo, se c&#39;è un errore nelle colonne dispari ma non nella metà destra,

195
00:10:54,383 --> 00:10:56,560
sai che è da qualche parte nella seconda colonna.

196
00:10:56,560 --> 00:10:59,148
E se nessuno dei due controlli di parità rileva nulla,

197
00:10:59,148 --> 00:11:02,677
significa che l&#39;unico posto in cui potrebbe trovarsi un errore è nella

198
00:11:02,677 --> 00:11:03,760
colonna più a sinistra.

199
00:11:03,760 --> 00:11:06,480
Ma potrebbe anche semplicemente significare che non è presente alcun errore.

200
00:11:06,480 --> 00:11:09,068
Il che è un modo piuttosto elaborato per dire che due

201
00:11:09,068 --> 00:11:11,800
controlli di parità ci permettono di definire la colonna.

202
00:11:11,800 --> 00:11:14,000
Da qui probabilmente puoi intuire cosa segue.

203
00:11:14,000 --> 00:11:16,240
Facciamo sostanzialmente la stessa cosa, ma per le righe.

204
00:11:16,240 --> 00:11:18,976
Verrà effettuato un controllo di parità sulle righe dispari,

205
00:11:18,976 --> 00:11:21,040
utilizzando la posizione 4 come bit di parità.

206
00:11:21,040 --> 00:11:24,325
Quindi in questo esempio quel gruppo ha già una parità pari,

207
00:11:24,325 --> 00:11:26,480
quindi il bit 4 verrebbe impostato su 0.

208
00:11:26,480 --> 00:11:29,918
E infine c&#39;è un controllo di parità sulle due righe inferiori,

209
00:11:29,918 --> 00:11:32,280
utilizzando la posizione 8 come bit di parità.

210
00:11:32,280 --> 00:11:35,223
In questo caso, sembra che il mittente debba attivare

211
00:11:35,223 --> 00:11:37,840
il bit 8 per garantire la parità pari al gruppo.

212
00:11:37,840 --> 00:11:40,885
Proprio come i primi due controlli ci permettono di fissare la colonna,

213
00:11:40,885 --> 00:11:43,000
i due successivi ti permettono di fissare la riga.

214
00:11:43,000 --> 00:11:46,827
Ad esempio, immagina che durante la trasmissione si verifichi un errore,

215
00:11:46,827 --> 00:11:48,400
ad esempio, nella posizione 3.

216
00:11:48,400 --> 00:11:51,060
Bene, questo influisce sul primo gruppo di parità e influisce

217
00:11:51,060 --> 00:11:53,636
anche sul secondo gruppo di parità, quindi il ricevitore sa

218
00:11:53,636 --> 00:11:56,340
che c&#39;è un errore da qualche parte nella colonna di destra.

219
00:11:56,340 --> 00:12:01,380
Ma non influisce sul terzo gruppo e non influisce sul quarto gruppo.

220
00:12:01,380 --> 00:12:04,844
E ciò consente al ricevitore di individuare l&#39;errore fino alla prima riga,

221
00:12:04,844 --> 00:12:08,660
che significa necessariamente la posizione 3, in modo da poter correggere l&#39;errore.

222
00:12:08,660 --> 00:12:11,472
Potresti divertirti a prenderti un momento per convincerti che

223
00:12:11,472 --> 00:12:14,329
le risposte a queste quattro domande ti permetteranno sempre di

224
00:12:14,329 --> 00:12:17,320
individuare un luogo specifico, indipendentemente da dove si trovi.

225
00:12:17,320 --> 00:12:20,452
In effetti, i più astuti tra voi potrebbero anche notare

226
00:12:20,452 --> 00:12:23,640
una connessione tra queste domande e il conteggio binario.

227
00:12:23,640 --> 00:12:27,260
E se lo fai, lasciami ancora una volta sottolineare, fare una pausa,

228
00:12:27,260 --> 00:12:30,880
provare tu stesso a stabilire il collegamento prima che io lo rovini.

229
00:12:30,880 --> 00:12:34,901
Se ti stai chiedendo cosa succede se un bit di parità stesso viene influenzato,

230
00:12:34,901 --> 00:12:36,560
beh, puoi semplicemente provarlo.

231
00:12:36,560 --> 00:12:41,969
Prenditi un momento per pensare a come qualsiasi errore tra questi quattro bit speciali

232
00:12:41,969 --> 00:12:47,440
verrà rintracciato proprio come qualsiasi altro, con lo stesso gruppo di quattro domande.

233
00:12:47,440 --> 00:12:50,519
Non ha molta importanza, poiché alla fine ciò che vogliamo è proteggere i

234
00:12:50,519 --> 00:12:53,640
bit del messaggio, i bit di correzione degli errori continuano a viaggiare.

235
00:12:53,640 --> 00:12:56,233
Ma proteggere anche quelle parti è qualcosa che

236
00:12:56,233 --> 00:12:59,260
naturalmente cade fuori dallo schema come sottoprodotto.

237
00:12:59,260 --> 00:13:02,380
Potresti anche divertirti ad anticipare come tutto questo si espanderà.

238
00:13:02,380 --> 00:13:06,482
Se utilizzassimo un blocco di dimensione 256 bit, ad esempio,

239
00:13:06,482 --> 00:13:11,114
per individuare una posizione, sarebbero necessarie solo otto domande

240
00:13:11,114 --> 00:13:15,680
sì o no per effettuare una ricerca binaria fino a un punto specifico.

241
00:13:15,680 --> 00:13:19,615
E ricorda, ogni domanda richiede la rinuncia di un solo

242
00:13:19,615 --> 00:13:23,340
bit per impostare il controllo di parità appropriato.

243
00:13:23,340 --> 00:13:26,492
Alcuni di voi potrebbero già vederlo, ma parleremo più tardi del modo

244
00:13:26,492 --> 00:13:29,960
sistematico per scoprire quali sono queste domande in appena un minuto o due.

245
00:13:29,960 --> 00:13:32,362
Speriamo che questo schizzo sia sufficiente per apprezzare

246
00:13:32,362 --> 00:13:34,440
l&#39;efficienza di ciò che stiamo sviluppando qui.

247
00:13:34,440 --> 00:13:37,664
La prima cosa, ad eccezione degli otto bit di parità evidenziati,

248
00:13:37,664 --> 00:13:41,720
può essere qualunque cosa tu voglia, portando qualunque messaggio o dato tu voglia.

249
00:13:41,720 --> 00:13:45,382
Gli 8 bit sono ridondanti nel senso che sono completamente

250
00:13:45,382 --> 00:13:49,170
determinati dal resto del messaggio, ma in un modo molto più

251
00:13:49,170 --> 00:13:53,640
intelligente rispetto alla semplice copia del messaggio nel suo insieme.

252
00:13:53,640 --> 00:13:56,346
Eppure, con così poco sacrificio, sarai in grado di

253
00:13:56,346 --> 00:13:59,000
identificare e correggere qualsiasi singolo errore.

254
00:13:59,000 --> 00:14:00,400
Be &#39;quasi.

255
00:14:00,400 --> 00:14:04,898
Ok, quindi l&#39;unico problema qui è che se nessuno dei quattro controlli di parità

256
00:14:04,898 --> 00:14:08,974
rileva un errore, il che significa che i sottoinsiemi di 8 bit appositamente

257
00:14:08,974 --> 00:14:12,837
selezionati hanno tutti parità pari, proprio come previsto dal mittente,

258
00:14:12,837 --> 00:14:15,801
allora significa che non si è verificato alcun errore ,

259
00:14:15,801 --> 00:14:17,760
oppure ci restringe alla posizione 0.

260
00:14:17,760 --> 00:14:22,435
Vedete, con quattro domande sì o no, abbiamo 16 possibili risultati per i nostri

261
00:14:22,435 --> 00:14:27,515
controlli di parità, e all&#39;inizio sembra perfetto per individuare 1 posizione su 16

262
00:14:27,515 --> 00:14:31,383
nel blocco, ma è necessario comunicare anche un 17esimo risultato,

263
00:14:31,383 --> 00:14:33,000
il nessun errore condizione.

264
00:14:33,000 --> 00:14:37,860
La soluzione qui è in realtà piuttosto semplice, dimentica completamente lo 0° bit.

265
00:14:37,860 --> 00:14:41,067
Quindi, quando eseguiamo i nostri quattro controlli di parità e vediamo

266
00:14:41,067 --> 00:14:44,320
che sono tutti pari, significa inequivocabilmente che non ci sono errori.

267
00:14:44,320 --> 00:14:47,555
Ciò significa che invece di lavorare con un blocco a 16 bit,

268
00:14:47,555 --> 00:14:50,738
lavoriamo con un blocco a 15 bit, in cui 11 bit sono liberi

269
00:14:50,738 --> 00:14:54,080
di trasportare un messaggio e 4 di essi sono lì per ridondanza.

270
00:14:54,080 --> 00:14:56,768
E con questo, ora abbiamo quello che le persone

271
00:14:56,768 --> 00:14:59,400
del settore chiamerebbero codice Hamming 15-11.

272
00:14:59,400 --> 00:15:03,517
Detto questo, è bello avere una dimensione del blocco che sia una potenza netta di 2,

273
00:15:03,517 --> 00:15:07,730
e c&#39;è un modo intelligente per mantenere lo 0° bit in giro e fargli fare un po&#39;

274
00:15:07,730 --> 00:15:08,880
di lavoro extra per noi.

275
00:15:08,880 --> 00:15:11,753
Se lo usiamo come bit di parità nell&#39;intero blocco,

276
00:15:11,753 --> 00:15:16,320
ci consente effettivamente di rilevare, anche se non possiamo correggere, errori a 2 bit.

277
00:15:16,320 --> 00:15:17,440
Ecco come funziona.

278
00:15:17,440 --> 00:15:20,596
Dopo aver impostato questi quattro bit speciali di correzione degli errori,

279
00:15:20,596 --> 00:15:23,712
impostiamo quello 0 in modo che la parità dell&#39;intero blocco sia pari,

280
00:15:23,712 --> 00:15:25,540
proprio come un normale controllo di parità.

281
00:15:25,540 --> 00:15:29,546
Ora, se c&#39;è un errore di un solo bit, la parità dell&#39;intero blocco diventa

282
00:15:29,546 --> 00:15:33,602
dispari, ma lo rileveremmo comunque grazie ai quattro controlli di correzione degli

283
00:15:33,602 --> 00:15:33,940
errori.

284
00:15:33,940 --> 00:15:38,292
Tuttavia, se si verificano due errori, la parità complessiva tornerà ad essere pari,

285
00:15:38,292 --> 00:15:42,235
ma il ricevitore vedrebbe comunque che si è verificato almeno qualche errore

286
00:15:42,235 --> 00:15:45,820
a causa di ciò che sta accadendo con quei quattro controlli di parità.

287
00:15:45,820 --> 00:15:49,443
Quindi, se notano una parità nel complesso, ma succede qualcosa di diverso da zero

288
00:15:49,443 --> 00:15:52,980
con gli altri controlli, significa loro che si sono verificati almeno due errori.

289
00:15:52,980 --> 00:15:54,420
Non è intelligente?

290
00:15:54,420 --> 00:15:57,478
Anche se non possiamo correggere quegli errori a 2 bit,

291
00:15:57,478 --> 00:16:02,340
semplicemente rimettendo in funzione quel piccolo e fastidioso bit 0, possiamo rilevarli.

292
00:16:02,340 --> 00:16:06,540
Questo è piuttosto standard, è noto come codice Hamming esteso.

293
00:16:06,540 --> 00:16:11,092
Tecnicamente parlando, ora hai una descrizione completa di cosa fa un codice Hamming,

294
00:16:11,092 --> 00:16:13,580
almeno per l&#39;esempio di un blocco a 16 bit.

295
00:16:13,580 --> 00:16:17,660
Ma penso che troverai più soddisfacente verificare la tua comprensione e consolidare

296
00:16:17,660 --> 00:16:21,980
tutto fino a questo punto facendo tu stesso un esempio completo dall&#39;inizio alla fine.

297
00:16:21,980 --> 00:16:25,100
Lo esaminerò insieme a te, così potrai controllarti tu stesso.

298
00:16:25,100 --> 00:16:28,686
Per impostare un messaggio, che si tratti di un messaggio letterale

299
00:16:28,686 --> 00:16:33,168
che stai traducendo nello spazio o di alcuni dati che desideri archiviare nel tempo,

300
00:16:33,168 --> 00:16:35,700
il primo passo è dividerlo in blocchi da 11 bit.

301
00:16:35,700 --> 00:16:40,340
Ogni pezzo verrà impacchettato in un blocco a 16 bit resistente agli errori.

302
00:16:40,340 --> 00:16:43,740
Quindi prendiamo questo come esempio e risolviamolo davvero.

303
00:16:43,740 --> 00:16:45,380
Vai avanti, fallo davvero!

304
00:16:45,380 --> 00:16:52,980
Facciamo una pausa e proviamo a mettere insieme questo blocco.

305
00:16:52,980 --> 00:16:53,980
Ok, sei pronto?

306
00:16:53,980 --> 00:16:57,665
Ricorda, la posizione 0 insieme alle altre potenze di 2 sono

307
00:16:57,665 --> 00:17:00,625
riservate al compito di correzione degli errori,

308
00:17:00,625 --> 00:17:05,700
quindi inizi posizionando i bit del messaggio in tutti i punti rimanenti, in ordine.

309
00:17:05,700 --> 00:17:09,555
È necessario che questo gruppo abbia una parità pari, cosa che già ha,

310
00:17:09,555 --> 00:17:13,140
quindi dovresti impostare il bit di parità nella posizione 1 su 0.

311
00:17:13,140 --> 00:17:16,322
Il gruppo successivo inizia con una parità dispari,

312
00:17:16,322 --> 00:17:19,260
quindi dovresti impostare il bit di parità su 1.

313
00:17:19,260 --> 00:17:21,615
Il gruppo successivo inizia con una parità dispari,

314
00:17:21,615 --> 00:17:24,740
quindi anche in questo caso dovresti impostare il bit di parità su 1.

315
00:17:24,740 --> 00:17:27,637
E anche il gruppo finale ha una parità dispari,

316
00:17:27,637 --> 00:17:31,500
il che significa che impostiamo quel bit nella posizione 8 su 1.

317
00:17:31,500 --> 00:17:36,154
E poi, come passaggio finale, l&#39;intero blocco ora ha una parità pari,

318
00:17:36,154 --> 00:17:41,500
il che significa che puoi impostare il bit numero 0, il bit di parità generale, su 0.

319
00:17:41,500 --> 00:17:45,103
Quindi, quando questo blocco viene espulso, la parità dei quattro

320
00:17:45,103 --> 00:17:48,980
sottoinsiemi speciali e del blocco nel suo insieme sarà pari, ovvero 0.

321
00:17:48,980 --> 00:17:53,620
Come seconda parte dell&#39;esercizio, ti faremo interpretare il ruolo del ricevente.

322
00:17:53,620 --> 00:17:57,004
Naturalmente, ciò significherebbe che non sapete già quale sia questo messaggio,

323
00:17:57,004 --> 00:18:00,180
forse alcuni di voi lo hanno memorizzato, ma supponiamo che non lo sappiate.

324
00:18:00,180 --> 00:18:04,053
Quello che farò è cambiare 0, 1 o 2 dei bit in

325
00:18:04,053 --> 00:18:08,340
quel blocco e poi chiederti di capire cosa ho fatto.

326
00:18:08,340 --> 00:18:13,460
Quindi, ancora una volta, fai una pausa e prova a risolverlo.

327
00:18:13,460 --> 00:18:21,640
Ok, quindi tu come ricevitore ora controlli il primo gruppo di parità e puoi vedere

328
00:18:21,640 --> 00:18:29,820
che è pari, quindi qualsiasi errore esistente dovrebbe trovarsi in una colonna pari.

329
00:18:29,820 --> 00:18:33,383
Il controllo successivo ci fornisce un numero dispari,

330
00:18:33,383 --> 00:18:38,760
dicendoci che c&#39;è almeno un errore e restringendoci a questa colonna specifica.

331
00:18:38,760 --> 00:18:42,900
Il terzo controllo è pari, riducendo ulteriormente le possibilità.

332
00:18:42,900 --> 00:18:47,325
E l&#39;ultimo controllo di parità è strano, ci dice che c&#39;è un errore da qualche

333
00:18:47,325 --> 00:18:51,700
parte in fondo, che ormai come possiamo vedere deve essere nella posizione numero 10.

334
00:18:51,700 --> 00:18:54,412
Inoltre, la parità dell&#39;intero blocco è strana,

335
00:18:54,412 --> 00:18:58,220
il che ci dà la certezza che si sia verificato un ribaltamento e non due.

336
00:18:58,220 --> 00:19:01,600
Se sono tre o più, tutte le scommesse vengono annullate.

337
00:19:01,600 --> 00:19:06,605
Dopo aver corretto il bit numero 10, estraendo gli 11 bit che non sono stati utilizzati

338
00:19:06,605 --> 00:19:10,927
per la correzione, otteniamo il segmento rilevante del messaggio originale,

339
00:19:10,927 --> 00:19:15,363
che se lo riavvolgi e confronti è esattamente quello con cui abbiamo iniziato

340
00:19:15,363 --> 00:19:16,160
l&#39;esempio.

341
00:19:16,160 --> 00:19:18,489
E ora che sai come fare tutto questo manualmente,

342
00:19:18,489 --> 00:19:22,356
vorrei mostrarti come puoi realizzare la parte centrale di tutta questa logica con

343
00:19:22,356 --> 00:19:23,940
una singola riga di codice Python.

344
00:19:23,940 --> 00:19:28,028
Vedi, quello che non ti ho ancora detto è quanto sia elegante questo algoritmo,

345
00:19:28,028 --> 00:19:32,066
quanto sia semplice far sì che una macchina indichi la posizione di un errore,

346
00:19:32,066 --> 00:19:36,053
come ridimensionarlo sistematicamente e come possiamo inquadrare tutto questo

347
00:19:36,053 --> 00:19:39,580
come una singola operazione anziché più controlli di parità separati.

348
00:19:39,580 --> 00:19:39,580
Per capire cosa intendo, unisciti a me nella parte 2.

