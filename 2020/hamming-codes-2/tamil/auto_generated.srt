1
00:00:00,000 --> 00:00:02,560
இங்குள்ள அனைவரும் பாகம் 1ல் இருந்து வந்தவர்கள் என்று எண்ணுகிறேன்.

2
00:00:03,060 --> 00:00:06,696
நாங்கள் ஹேமிங் குறியீடுகளைப் பற்றி பேசிக் கொண்டிருந்தோம், 

3
00:00:06,696 --> 00:00:11,397
பெரும்பாலான பிட்கள் அர்த்தமுள்ள செய்தியைக் கொண்டு செல்லும் தரவுத் தொகுதியை 

4
00:00:11,397 --> 00:00:16,600
உருவாக்கும் ஒரு வழி பிட் அல்லது ஒரு பணிநீக்கம் பிட், இந்த பிளாக்கில் உள்ள எதையும், 

5
00:00:16,600 --> 00:00:21,240
ஒரு பெறுநரால் பிழை இருப்பதை அடையாளம் காண முடியும், அதை எவ்வாறு சரிசெய்வது.

6
00:00:21,880 --> 00:00:24,481
அங்கு வழங்கப்பட்ட அடிப்படை யோசனையானது, பிழைக்கான உங்கள் வழியை பைனரி 

7
00:00:24,481 --> 00:00:27,160
தேடுவதற்கு பல சமநிலை சரிபார்ப்புகளை எவ்வாறு பயன்படுத்துவது என்பதுதான்.

8
00:00:28,980 --> 00:00:31,790
அந்த வீடியோவில், ஹேமிங் குறியீடுகளை முடிந்தவரை மீண்டும் 

9
00:00:31,790 --> 00:00:34,600
கண்டுபிடிக்கக்கூடியதாக உணர வைப்பதே குறிக்கோளாக இருந்தது.

10
00:00:35,180 --> 00:00:38,009
ஆனால் மென்பொருளில் அல்லது வன்பொருளில் இதை நடைமுறைப்படுத்துவது பற்றி 

11
00:00:38,009 --> 00:00:40,589
நீங்கள் சிந்திக்கத் தொடங்கும்போது, இந்த குறியீடுகள் உண்மையில் 

12
00:00:40,589 --> 00:00:43,460
எவ்வளவு நேர்த்தியானவை என்பதை அந்த ஃப்ரேமிங் உண்மையில் குறைத்துவிடும்.

13
00:00:43,920 --> 00:00:47,204
சாத்தியமான அனைத்து பிழை இருப்பிடங்களையும் கண்காணிக்கும் ஒரு வழிமுறையை நீங்கள் 

14
00:00:47,204 --> 00:00:50,447
எழுத வேண்டும் என்று நீங்கள் நினைக்கலாம் மற்றும் ஒவ்வொரு சரிபார்ப்பிலும் அந்த 

15
00:00:50,447 --> 00:00:53,480
குழுவை பாதியாக குறைக்கலாம், ஆனால் அது உண்மையில் வழி, அதை விட எளிமையானது.

16
00:00:53,940 --> 00:00:57,667
கடந்த வீடியோவில் நாங்கள் செய்த நான்கு சமநிலை சரிபார்ப்புகளுக்கான பதில்களை, 

17
00:00:57,667 --> 00:01:01,197
ஆம் மற்றும் இல்லை என்பதற்குப் பதிலாக 1கள் மற்றும் 0கள் எனப் படித்தால், 

18
00:01:01,197 --> 00:01:04,080
அது பைனரியில் உள்ள பிழையின் நிலையை உண்மையில் விவரிக்கிறது.

19
00:01:04,780 --> 00:01:08,591
எடுத்துக்காட்டாக, பைனரியில் உள்ள எண் 7 0111 போல் தெரிகிறது, 

20
00:01:08,591 --> 00:01:11,260
இது 4 கூட்டல் 2 கூட்டல் 1 என்று கூறுகிறது.

21
00:01:12,540 --> 00:01:16,047
மற்றும் நிலை 7 எங்கு அமர்ந்திருக்கிறது என்பதைக் கவனியுங்கள், 

22
00:01:16,047 --> 00:01:20,589
இது எங்கள் சமத்துவக் குழுக்களில் முதலாவது மற்றும் இரண்டாவது மற்றும் மூன்றாவது, 

23
00:01:20,589 --> 00:01:21,740
ஆனால் கடைசியாக அல்ல.

24
00:01:22,220 --> 00:01:24,802
எனவே அந்த நான்கு காசோலைகளின் முடிவுகளை கீழிருந்து 

25
00:01:24,802 --> 00:01:27,540
மேல் வரை படிப்பது பிழையின் நிலையை வெளிப்படுத்துகிறது.

26
00:01:28,320 --> 00:01:31,247
எடுத்துக்காட்டு 7 இல் சிறப்பு எதுவும் இல்லை, இது பொதுவாக வேலை செய்கிறது, 

27
00:01:31,247 --> 00:01:33,734
மேலும் இது வன்பொருளில் முழு திட்டத்தையும் செயல்படுத்துவதற்கான 

28
00:01:33,734 --> 00:01:35,820
தர்க்கத்தை அதிர்ச்சியூட்டும் வகையில் எளிதாக்குகிறது.

29
00:01:37,240 --> 00:01:40,566
இப்போது இந்த மேஜிக் ஏன் நடக்கிறது என்பதைப் பார்க்க விரும்பினால், 

30
00:01:40,566 --> 00:01:44,148
இந்த 16 இன்டெக்ஸ் லேபிள்களை எங்கள் நிலைகளுக்கு எடுத்துக் கொள்ளுங்கள், 

31
00:01:44,148 --> 00:01:46,758
ஆனால் அவற்றை அடிப்படை 10 இல் எழுதுவதற்குப் பதிலாக, 

32
00:01:46,758 --> 00:01:49,880
0000 முதல் 1111 வரை இயங்கும் பைனரியில் அனைத்தையும் எழுதுவோம்.

33
00:01:50,559 --> 00:01:53,805
இந்த பைனரி லேபிள்களை அவற்றின் பெட்டிகளில் மீண்டும் வைக்கும்போது, 

34
00:01:53,805 --> 00:01:57,800
அவை உண்மையில் அனுப்பப்படும் தரவுகளிலிருந்து வேறுபட்டவை என்பதை வலியுறுத்துகிறேன்.

35
00:01:58,320 --> 00:02:00,818
நான்கு சமத்துவக் குழுக்கள் எங்கிருந்து வந்தன என்பதைப் புரிந்துகொள்ள 

36
00:02:00,818 --> 00:02:03,500
உங்களுக்கும் எனக்கும் உதவும் ஒரு கருத்தியல் லேபிளைத் தவிர வேறொன்றுமில்லை.

37
00:02:04,140 --> 00:02:07,662
நாம் பார்க்கும் அனைத்தும் பைனரியில் விவரிக்கப்படுவதன் நேர்த்தியானது, 

38
00:02:07,662 --> 00:02:11,543
நாம் பார்க்கும் அனைத்தும் பைனரியில் விவரிக்கப்பட வேண்டும் என்ற குழப்பத்தால் 

39
00:02:11,543 --> 00:02:12,360
குறைக்கப்படலாம்.

40
00:02:13,020 --> 00:02:14,120
இருந்தாலும் அது மதிப்புக்குரியது.

41
00:02:14,800 --> 00:02:19,243
இந்த லேபிள்கள் அனைத்தின் கடைசி பிட்டில் மட்டும் உங்கள் கவனத்தை செலுத்தவும், 

42
00:02:19,243 --> 00:02:23,220
பின்னர் அந்த இறுதி பிட் 1 ஆக இருக்கும் நிலைகளை முன்னிலைப்படுத்தவும்.

43
00:02:24,240 --> 00:02:28,270
நாங்கள் பெறுவது எங்களின் நான்கு சமத்துவக் குழுக்களில் முதன்மையானது, 

44
00:02:28,270 --> 00:02:31,946
அதாவது அந்த முதல் காசோலையைக் கேட்பது போல் நீங்கள் விளக்கலாம், 

45
00:02:31,946 --> 00:02:35,740
ஏய், பிழை இருந்தால், அந்த பிழையின் நிலையில் இறுதி பிட் 1 உள்ளதா?

46
00:02:38,200 --> 00:02:40,839
இதேபோல், நீங்கள் இரண்டாவது முதல் கடைசி பிட் வரை கவனம் செலுத்தி, 

47
00:02:40,839 --> 00:02:43,396
அது 1 ஆக இருக்கும் அனைத்து நிலைகளையும் முன்னிலைப்படுத்தினால், 

48
00:02:43,396 --> 00:02:46,160
எங்கள் திட்டத்தில் இருந்து இரண்டாவது பாரிட்டி குழுவைப் பெறுவீர்கள்.

49
00:02:46,740 --> 00:02:50,290
வேறு வார்த்தைகளில் கூறுவதானால், அந்த இரண்டாவது காசோலை கேட்கிறது, ஏய், 

50
00:02:50,290 --> 00:02:54,500
மீண்டும் என்னிடம், பிழை இருந்தால், அந்த நிலையின் இரண்டாவது முதல் கடைசி பிட் 1 தானா?

51
00:02:55,760 --> 00:02:56,900
மற்றும் பல.

52
00:02:57,220 --> 00:03:01,060
மூன்றாவது பாரிட்டி காசோலையானது, மூன்றாவது முதல் கடைசி பிட் வரை 

53
00:03:01,060 --> 00:03:04,900
இயக்கப்பட்ட ஒவ்வொரு நிலையையும் உள்ளடக்கியது, மேலும் கடைசியானது 

54
00:03:04,900 --> 00:03:08,740
கடைசி எட்டு நிலைகளை உள்ளடக்கியது, அதிகபட்ச ஆர்டர் பிட் 1 ஆகும்.

55
00:03:09,740 --> 00:03:14,836
நாம் முன்பு செய்த அனைத்தும் இந்த நான்கு கேள்விகளுக்குப் பதிலளிப்பதைப் போன்றது, 

56
00:03:14,836 --> 00:03:17,740
இது பைனரியில் ஒரு நிலையை உச்சரிப்பது போன்றது.

57
00:03:19,620 --> 00:03:21,480
இது இரண்டு விஷயங்களை தெளிவாக்குகிறது என்று நம்புகிறேன்.

58
00:03:22,040 --> 00:03:24,391
முதலாவதாக, இரண்டின் பெரிய சக்திகளைக் கொண்ட தொகுதி 

59
00:03:24,391 --> 00:03:26,460
அளவுகளை முறையாகப் பொதுமைப்படுத்துவது எப்படி.

60
00:03:26,960 --> 00:03:30,316
64 புள்ளிகளை விவரிக்க ஆறு பிட்கள் போல, ஒவ்வொரு நிலையையும் விவரிக்க 

61
00:03:30,316 --> 00:03:33,774
அதிக பிட்கள் தேவைப்பட்டால், அந்த பிட்கள் ஒவ்வொன்றும் நாம் சரிபார்க்க 

62
00:03:33,774 --> 00:03:36,680
வேண்டிய சமநிலைக் குழுக்களில் ஒன்றை உங்களுக்கு வழங்குகிறது.

63
00:03:38,400 --> 00:03:41,191
மேட் பார்க்கருடன் நான் செய்த சதுரங்கப் புதிரைப் பார்த்த உங்களில், 

64
00:03:41,191 --> 00:03:43,180
இவை அனைத்தும் மிகவும் பரிச்சயமானதாக இருக்கலாம்.

65
00:03:43,660 --> 00:03:46,368
இது அதே முக்கிய தர்க்கம், ஆனால் வேறு ஒரு சிக்கலைத் தீர்க்கிறது, 

66
00:03:46,368 --> 00:03:48,780
மேலும் 64-சதுர சதுரங்கப் பலகைக்கு இது பயன்படுத்தப்பட்டது.

67
00:03:49,880 --> 00:03:52,723
இது தெளிவுபடுத்தும் இரண்டாவது விஷயம் என்னவென்றால், 1, 2, 4, 

68
00:03:52,723 --> 00:03:56,798
மற்றும் 8 ஆகிய இரண்டு சக்திகளின் நிலைகளில் நமது சமநிலை பிட்கள் ஏன் அமர்ந்திருக்கின்றன 

69
00:03:56,798 --> 00:03:57,320
என்பதுதான்.

70
00:03:58,000 --> 00:04:03,000
பைனரி பிரதிநிதித்துவம் ஒரு பிட் மட்டுமே இயக்கப்பட்டிருக்கும் நிலைகள் இவை.

71
00:04:03,600 --> 00:04:06,385
இதன் பொருள் என்னவென்றால், அந்த ஒவ்வொரு பாரிட்டி பிட்களும் 

72
00:04:06,385 --> 00:04:09,460
ஒன்றுக்குள் அமர்ந்து நான்கு சமத்துவக் குழுக்களில் ஒன்று மட்டுமே.

73
00:04:12,040 --> 00:04:14,579
நீங்கள் இதைப் பெரிய எடுத்துக்காட்டுகளிலும் பார்க்கலாம், 

74
00:04:14,579 --> 00:04:18,387
நீங்கள் எவ்வளவு பெரியதாக இருந்தாலும், ஒவ்வொரு பாரிட்டி பிட்டும் வசதியாக குழுக்களில் 

75
00:04:18,387 --> 00:04:19,339
ஒன்றை மட்டுமே தொடும்.

76
00:04:25,600 --> 00:04:29,137
நாம் அதிக நேரத்தைச் செலுத்திய இந்த சமநிலைச் சரிபார்ப்புகள் பைனரியில் உள்ள 

77
00:04:29,137 --> 00:04:32,770
பிழையின் நிலையை உச்சரிப்பதற்கான ஒரு புத்திசாலித்தனமான வழியைத் தவிர வேறில்லை 

78
00:04:32,770 --> 00:04:36,356
என்பதை நீங்கள் புரிந்துகொண்டவுடன், ஹேமிங்கைப் பற்றி சிந்திக்க வேறு வழியில் 

79
00:04:36,356 --> 00:04:40,467
நாம் இணைப்பை உருவாக்கலாம். குறியீடுகள், இது மிகவும் எளிமையானது மற்றும் நேர்த்தியானது, 

80
00:04:40,467 --> 00:04:43,240
மேலும் இது ஒரு ஒற்றை வரி குறியீட்டைக் கொண்டு எழுதப்படலாம்.

81
00:04:43,660 --> 00:04:45,500
இது XOR செயல்பாட்டை அடிப்படையாகக் கொண்டது.

82
00:04:46,940 --> 00:04:50,220
XOR, உங்களில் தெரியாதவர்களுக்கு, பிரத்தியேகமான அல்லது.

83
00:04:50,780 --> 00:04:54,587
நீங்கள் இரண்டு பிட்களின் XOR ஐ எடுக்கும்போது, அந்த பிட்களில் ஏதேனும் ஒன்று 

84
00:04:54,587 --> 00:04:59,106
இயக்கப்பட்டிருந்தால் அது 1ஐத் தரும், ஆனால் இரண்டும் ஆன் அல்லது ஆஃப் செய்யப்பட்டிருந்தால் 

85
00:04:59,106 --> 00:04:59,360
அல்ல.

86
00:05:00,100 --> 00:05:02,980
வித்தியாசமாக சொற்றொடர், இந்த இரண்டு பிட்களின் சமநிலை.

87
00:05:03,540 --> 00:05:06,760
ஒரு கணித நபராக, நான் அதை கூட்டல் மோட் 2 என நினைக்க விரும்புகிறேன்.

88
00:05:07,360 --> 00:05:10,856
நாங்கள் பொதுவாக இரண்டு வெவ்வேறு பிட் சரங்களின் XOR பற்றி பேசுகிறோம், 

89
00:05:10,856 --> 00:05:13,440
இது அடிப்படையில் இந்த கூறுகளை கூறு மூலம் செய்கிறது.

90
00:05:13,680 --> 00:05:15,720
இது கூட்டல் போன்றது, ஆனால் நீங்கள் எடுத்துச் செல்லவே இல்லை.

91
00:05:16,500 --> 00:05:19,209
மீண்டும், கணித ரீதியாக அதிக விருப்பமுள்ளவர்கள் இதை இரண்டு 

92
00:05:19,209 --> 00:05:22,480
திசையன்களைச் சேர்ப்பது மற்றும் மோட் 2 ஐக் குறைப்பது என்று நினைக்கலாம்.

93
00:05:23,500 --> 00:05:27,538
நீங்கள் இப்போது சில பைத்தானைத் திறந்து, இரண்டு முழு எண்களுக்கு இடையில் கேரட் 

94
00:05:27,538 --> 00:05:31,314
செயல்பாட்டைப் பயன்படுத்தினால், இது பேட்டைக்குக் கீழே அந்த எண்களின் பிட் 

95
00:05:31,314 --> 00:05:32,940
பிரதிநிதித்துவங்களைச் செய்யும்.

96
00:05:34,960 --> 00:05:38,806
உங்களுக்கும் எனக்கும் முக்கியமான விஷயம் என்னவென்றால், 

97
00:05:38,806 --> 00:05:42,367
பல வேறுபட்ட பிட் சரங்களின் XORஐ எடுத்துக்கொள்வது, 

98
00:05:42,367 --> 00:05:47,140
தனித்தனி குழுக்களின் கேலிக்கூத்துகளை கணக்கிடுவதற்கான ஒரு வழியாகும்.

99
00:05:51,260 --> 00:05:53,977
எங்கள் ஹேமிங் குறியீடு அல்காரிதத்தில் இருந்து பல சமநிலை சரிபார்ப்புகளைப் 

100
00:05:53,977 --> 00:05:56,471
பற்றி சிந்திக்க இது எங்களுக்கு மிகவும் எளிமையான வழியை வழங்குகிறது, 

101
00:05:56,471 --> 00:05:58,780
ஏனெனில் அனைத்தும் ஒன்றாக ஒரே செயல்பாட்டில் தொகுக்கப்படுகின்றன.

102
00:05:59,479 --> 00:06:02,180
முதல் பார்வையில் இது மிகவும் வித்தியாசமாகத் தெரிந்தாலும்.

103
00:06:02,820 --> 00:06:07,230
குறிப்பாக பைனரியில் 16 நிலைகளை எழுதவும், முன்பு இருந்தது போல், 

104
00:06:07,230 --> 00:06:12,060
இப்போது செய்தி பிட் 1 க்கு இயக்கப்பட்ட நிலைகளை முன்னிலைப்படுத்தவும், 

105
00:06:12,060 --> 00:06:17,100
பின்னர் இந்த நிலைகளை ஒரு பெரிய நெடுவரிசையில் சேகரித்து XOR ஐ எடுக்கவும்.

106
00:06:19,260 --> 00:06:22,616
இதன் விளைவாக கீழே அமர்ந்திருக்கும் 4 பிட்கள், நாங்கள் அறிந்த மற்றும் விரும்பி 

107
00:06:22,616 --> 00:06:26,015
வைத்திருக்கும் 4 சமநிலை சரிபார்ப்புகளைப் போலவே இருக்கும் என்று நீங்கள் ஒருவேளை 

108
00:06:26,015 --> 00:06:29,200
யூகிக்கலாம், ஆனால் ஏன் என்று சரியாகச் சிந்திக்க சிறிது நேரம் ஒதுக்குங்கள்.

109
00:06:32,220 --> 00:06:35,498
இந்த கடைசி நெடுவரிசை, எடுத்துக்காட்டாக, கடைசி பிட் 1 ஆக உள்ள அனைத்து 

110
00:06:35,498 --> 00:06:38,728
நிலைகளையும் கணக்கிடுகிறது, ஆனால் நாங்கள் ஏற்கனவே ஹைலைட் செய்யப்பட்ட 

111
00:06:38,728 --> 00:06:41,769
நிலைகளுக்கு மட்டுமே வரம்பிடப்பட்டுள்ளோம், எனவே இது முதல் சமநிலை 

112
00:06:41,769 --> 00:06:45,760
குழுவிலிருந்து எத்தனை ஹைலைட் செய்யப்பட்ட நிலைகள் வந்தன என்பதை திறம்பட கணக்கிடுகிறது.

113
00:06:46,240 --> 00:06:46,800
அதில் ஏதாவது பொருளிருக்கிறதா? அதில் அர்த்தமிருக்கிறதா?

114
00:06:49,080 --> 00:06:53,459
அதேபோல, அடுத்த நெடுவரிசை, இரண்டாவது சமத்துவக் குழுவில் எத்தனை நிலைகள் உள்ளன, 

115
00:06:53,459 --> 00:06:56,132
இரண்டாவது முதல் கடைசி பிட் வரையிலான நிலைகள் 1, 

116
00:06:56,132 --> 00:07:00,000
மற்றும் அவையும் தனிப்படுத்தப்பட்டவை மற்றும் பலவற்றைக் கணக்கிடுகிறது.

117
00:07:00,260 --> 00:07:02,402
இது உண்மையில் நாம் செய்துகொண்டிருக்கும் அதே விஷயத்தைப் 

118
00:07:02,402 --> 00:07:03,960
பற்றிய கண்ணோட்டத்தில் ஒரு சிறிய மாற்றம்.

119
00:07:07,760 --> 00:07:09,600
அது இங்கிருந்து எங்கு செல்கிறது என்பது உங்களுக்குத் தெரியும்.

120
00:07:10,000 --> 00:07:12,937
தொகை 0000 ஆக இருக்கும் என்பதை உறுதிப்படுத்த, சில சிறப்பு 

121
00:07:12,937 --> 00:07:15,720
சமநிலை பிட்களை மாற்றுவதற்கு அனுப்புநரின் பொறுப்பாகும்.

122
00:07:15,720 --> 00:07:21,686
இப்போது நாம் இதைப் பெற்றவுடன், கீழே உள்ள இந்த நான்கு பிட்கள் ஏன் பிழையின் நிலையை 

123
00:07:21,686 --> 00:07:27,580
நேரடியாக உச்சரிக்கின்றன என்பதைப் பற்றி சிந்திக்க இது ஒரு நல்ல வழியை வழங்குகிறது.

124
00:07:28,460 --> 00:07:31,860
இந்த பிளாக்கில் சில பிட்கள் 0 இலிருந்து 1 ஆக மாறுகிறது என்று வைத்துக்கொள்வோம்.

125
00:07:32,600 --> 00:07:37,716
இதன் பொருள் என்னவென்றால், அந்த பிட்டின் நிலை இப்போது மொத்த XOR இல் சேர்க்கப்படும், 

126
00:07:37,716 --> 00:07:42,956
இது கூட்டுத்தொகையை 0 என்பதிலிருந்து புதிதாக சேர்க்கப்பட்ட இந்த மதிப்பாக மாற்றுகிறது, 

127
00:07:42,956 --> 00:07:43,820
பிழையின் நிலை.

128
00:07:44,460 --> 00:07:49,360
சற்று குறைவாக வெளிப்படையாக, 1 ஐ 0 ஆக மாற்றும் பிழை இருந்தால் அதுவே உண்மை.

129
00:07:50,180 --> 00:07:53,972
நீங்கள் பார்க்கிறீர்கள், நீங்கள் ஒரு பிட் சரத்தை இரண்டு முறை ஒன்றாகச் சேர்த்தால், 

130
00:07:53,972 --> 00:07:57,580
அது இல்லை என்பதற்கு சமம், அடிப்படையில் இந்த உலகில் 1 கூட்டல் 1 என்பது 0 ஆகும்.

131
00:07:57,580 --> 00:08:01,041
எனவே இந்த நிலையின் நகலை மொத்தத் தொகையில் சேர்ப்பது 

132
00:08:01,041 --> 00:08:04,300
நாம் அதை நகர்த்தும்போது அதே விளைவை ஏற்படுத்தும்.

133
00:08:05,160 --> 00:08:10,700
அந்த விளைவு, மீண்டும், இங்கே கீழே உள்ள மொத்த முடிவு பிழையின் நிலையை உச்சரிக்கிறது.

134
00:08:13,039 --> 00:08:15,196
இது எவ்வளவு நேர்த்தியானது என்பதை விளக்குவதற்கு, 

135
00:08:15,196 --> 00:08:18,340
நான் முன்பு குறிப்பிட்ட பைதான் குறியீட்டின் ஒரு வரியைக் காட்டுகிறேன், 

136
00:08:18,340 --> 00:08:21,440
இது பெறுநரின் முடிவில் கிட்டத்தட்ட எல்லா தர்க்கங்களையும் கைப்பற்றும்.

137
00:08:22,080 --> 00:08:26,081
தரவுத் தொகுதியை உருவகப்படுத்த 16 1s மற்றும் 0s என்ற சீரற்ற வரிசையை உருவாக்குவதன் 

138
00:08:26,081 --> 00:08:28,848
மூலம் தொடங்குவோம், நான் அதற்கு பெயர் பிட்களை தருகிறேன், 

139
00:08:28,848 --> 00:08:32,059
ஆனால் நடைமுறையில் இது ஒரு அனுப்புநரிடமிருந்து நாம் பெறும் ஒன்று, 

140
00:08:32,059 --> 00:08:35,616
அதற்கு பதிலாக சீரற்றதாக இருந்தால், அது 11 டேட்டா பிட்களையும் 5 பேரிட்டி 

141
00:08:35,616 --> 00:08:37,000
பிட்களையும் கொண்டு செல்லும்.

142
00:08:37,000 --> 00:08:42,064
நான் செயல்பாடு enumerateBits என்று அழைத்தால், அது 0 முதல் 15 வரை இயங்கும் இந்த 

143
00:08:42,064 --> 00:08:47,000
விஷயத்தில், அந்த பிட்கள் ஒவ்வொன்றையும் தொடர்புடைய குறியீட்டுடன் இணைப்பதாகும்.

144
00:08:48,180 --> 00:08:52,161
எனவே, இந்த ஜோடிகள் அனைத்தின் மீதும் சுழலும் ஒரு பட்டியலை உருவாக்கினால், 

145
00:08:52,161 --> 00:08:56,916
i போல தோற்றமளிக்கும் ஜோடிகள், பின்னர் i மதிப்பை, குறியீட்டை மட்டும் வெளியே இழுத்தால், 

146
00:08:56,916 --> 00:09:01,340
அது அவ்வளவு உற்சாகமாக இல்லை, அந்த குறியீடுகளை 0 முதல் 15 வரை திரும்பப் பெறுவோம்.

147
00:09:01,680 --> 00:09:06,211
ஆனால் பிட் என்றால் மட்டுமே இதைச் செய்ய வேண்டும் என்ற நிபந்தனையைச் சேர்த்தால், 

148
00:09:06,211 --> 00:09:09,871
அதாவது அந்த பிட் 1 மற்றும் 0 அல்ல என்றால், அது தொடர்புடைய பிட் 

149
00:09:09,871 --> 00:09:12,660
இயக்கப்பட்டிருக்கும் நிலைகளை மட்டும் இழுக்கிறது.

150
00:09:13,380 --> 00:09:20,360
இந்த வழக்கில், அந்த நிலைகள் 0, 4, 6, 9, போன்றவை போல் தெரிகிறது.

151
00:09:20,720 --> 00:09:23,957
நாம் விரும்புவது, அந்த நிலைகள் அனைத்தையும் ஒன்றாகச் சேகரிக்க வேண்டும், 

152
00:09:23,957 --> 00:09:27,240
இயக்கப்பட்ட பிட்களின் நிலைகள், பின்னர் அவற்றை ஒன்றாக XOR செய்ய வேண்டும்.

153
00:09:29,180 --> 00:09:33,220
பைத்தானில் இதைச் செய்ய, முதலில் இரண்டு பயனுள்ள செயல்பாடுகளை இறக்குமதி செய்கிறேன்.

154
00:09:33,900 --> 00:09:36,468
அந்த வகையில் நாம் இந்த பட்டியலில் குறைக்க() என்று அழைக்கலாம் 

155
00:09:36,468 --> 00:09:38,700
மற்றும் அதை குறைக்க XOR செயல்பாட்டைப் பயன்படுத்தலாம்.

156
00:09:39,100 --> 00:09:42,680
இது அடிப்படையில் பட்டியலில் அதன் வழியை உண்கிறது, வழியில் XOR களை எடுத்துக்கொள்கிறது.

157
00:09:44,800 --> 00:09:47,366
நீங்கள் விரும்பினால், XOR செயல்பாட்டை எங்கிருந்தும் 

158
00:09:47,366 --> 00:09:49,440
இறக்குமதி செய்யாமல் வெளிப்படையாக எழுதலாம்.

159
00:09:51,940 --> 00:09:56,571
எனவே தற்போது 16 பிட்களின் சீரற்ற தொகுதியில் இதைச் செய்தால், 

160
00:09:56,571 --> 00:10:01,280
அது 9 ஐத் தருகிறது, இதில் பைனரி பிரதிநிதித்துவம் 1001 உள்ளது.

161
00:10:01,980 --> 00:10:05,772
நாங்கள் அதை இங்கே செய்ய மாட்டோம், ஆனால் அனுப்புநர் அந்த பைனரி பிரதிநிதித்துவத்தைப் 

162
00:10:05,772 --> 00:10:09,154
பயன்படுத்தி நான்கு பேரிட்டி பிட்களை தேவைக்கேற்ப அமைக்கும் ஒரு செயல்பாட்டை 

163
00:10:09,154 --> 00:10:12,535
நீங்கள் எழுதலாம், இறுதியில் இந்தத் தொகுதியை பிட்களின் முழுப் பட்டியலிலும் 

164
00:10:12,535 --> 00:10:15,460
இந்த குறியீட்டு வரியை இயக்கும் நிலைக்கு கொண்டு செல்லலாம். ஒரு 0.

165
00:10:16,080 --> 00:10:20,100
இது நன்கு தயாரிக்கப்பட்ட தொகுதியாகக் கருதப்படும்.

166
00:10:20,100 --> 00:10:24,361
நல்ல விஷயம் என்னவென்றால், இந்த பட்டியலில் உள்ள பிட்களில் ஏதேனும் ஒன்றை நாம் மாற்றினால், 

167
00:10:24,361 --> 00:10:27,121
இரைச்சலில் இருந்து ஒரு சீரற்ற பிழையை உருவகப்படுத்தினால், 

168
00:10:27,121 --> 00:10:30,220
நீங்கள் இதே குறியீட்டை இயக்கினால், அது அந்த பிழையை அச்சிடுகிறது.

169
00:10:30,960 --> 00:10:31,520
அது சுத்தமாக இல்லையா?

170
00:10:31,820 --> 00:10:36,686
இந்தத் தொகுதியை நீங்கள் நீல நிறத்தில் இருந்து பெறலாம், இந்த ஒற்றை வரியை அதில் இயக்கலாம், 

171
00:10:36,686 --> 00:10:41,060
மேலும் அது பிழையின் நிலையை தானாகவே துப்பிவிடும், அல்லது எதுவும் இல்லை என்றால் 0.

172
00:10:42,500 --> 00:10:44,840
இங்கே அளவு 16 பற்றி சிறப்பு எதுவும் இல்லை.

173
00:10:44,840 --> 00:10:49,860
உங்களிடம் 256 பிட்களின் பட்டியல் இருந்தால் அதே வரி குறியீடு வேலை செய்யும்.

174
00:10:51,880 --> 00:10:56,085
2-பிட் பிழைகளைக் கண்டறிய மெட்டா பாரிட்டி செக் செய்வது போன்ற கூடுதல் குறியீடுகள் 

175
00:10:56,085 --> 00:11:00,080
இங்கே எழுத வேண்டும் என்று சொல்லத் தேவையில்லை, ஆனால் எங்கள் திட்டத்தில் உள்ள 

176
00:11:00,080 --> 00:11:03,760
அனைத்து முக்கிய தர்க்கங்களும் ஒரே XOR குறைப்புக்கு வரும் என்பது யோசனை.

177
00:11:06,120 --> 00:11:10,810
இப்போது, பைனரி மற்றும் XORகள் மற்றும் பொதுவாக மென்பொருளில் உள்ள உங்கள் வசதியைப் பொறுத்து, 

178
00:11:10,810 --> 00:11:15,084
இந்த முன்னோக்கைக் கொஞ்சம் குழப்பமாகவோ அல்லது மிகவும் நேர்த்தியாகவும் எளிமையாகவும் 

179
00:11:15,084 --> 00:11:18,420
நாம் ஏன் தொடங்கவில்லை என்று நீங்கள் ஆச்சரியப்படுகிறீர்கள். -போ.

180
00:11:19,140 --> 00:11:22,911
தளர்வாகச் சொன்னால், வன்பொருளில் ஹேமிங் குறியீடுகளை நேரடியாகச் செயல்படுத்தும் போது, 

181
00:11:22,911 --> 00:11:26,046
மல்டிபிள் பேரிட்டி காசோலைக் கண்ணோட்டத்தைப் பற்றி சிந்திக்க எளிதானது, 

182
00:11:26,046 --> 00:11:29,636
மேலும் XOR முன்னோக்கு மென்பொருளில், உயர் மட்டத்தில் இருந்து அதைச் செய்யும்போது 

183
00:11:29,636 --> 00:11:30,500
சிந்திக்க எளிதானது.

184
00:11:31,360 --> 00:11:34,819
முதலாவது கையால் செய்வது மிகவும் எளிதானது, மேலும் இவை அனைத்திற்கும் 

185
00:11:34,819 --> 00:11:38,537
அடிப்படையான உள்ளுணர்வை ஏற்படுத்துவதில் இது ஒரு சிறந்த வேலையைச் செய்யும் 

186
00:11:38,537 --> 00:11:42,358
என்று நான் நினைக்கிறேன், அதாவது ஒரு பிழையைக் கண்டறிவதற்குத் தேவையான தகவல் 

187
00:11:42,358 --> 00:11:46,592
தொகுதியின் அளவின் பதிவுடன் தொடர்புடையது. , அல்லது வேறு வார்த்தைகளில் கூறுவதானால், 

188
00:11:46,592 --> 00:11:50,000
தொகுதி அளவு இரட்டிப்பாகும் போது அது ஒரு நேரத்தில் ஒரு பிட் வளரும்.

189
00:11:51,020 --> 00:11:53,635
இங்கே பொருத்தமான உண்மை என்னவென்றால், அந்த தகவல் நமக்கு 

190
00:11:53,635 --> 00:11:56,060
எவ்வளவு பணிநீக்கம் தேவை என்பதை நேரடியாக ஒத்துள்ளது.

191
00:11:56,660 --> 00:12:00,349
ஒரு செய்தியை பிழைகளைத் தடுக்கும் வகையில் உருவாக்குவதைப் பற்றி முதலில் நினைக்கும் போது, 

192
00:12:00,349 --> 00:12:03,274
பெரும்பாலானவர்களின் மொக்கை எதிர்வினைக்கு எதிராக அதுதான் இயங்குகிறது, 

193
00:12:03,274 --> 00:12:06,540
பொதுவாக முழுச் செய்தியையும் நகலெடுப்பதுதான் மனதில் தோன்றும் முதல் உள்ளுணர்வு.

194
00:12:07,500 --> 00:12:10,583
பின்னர், இந்த முழு வேறு வழியும் உள்ளது, சில சமயங்களில் ஹேமிங் குறியீடுகள் 

195
00:12:10,583 --> 00:12:14,000
வழங்கப்படுகின்றன, அங்கு நீங்கள் செய்தியை ஒரு பெரிய மேட்ரிக்ஸால் பெருக்குகிறீர்கள்.

196
00:12:14,670 --> 00:12:17,531
இது ஒருவகையில் நன்றாக இருக்கிறது, ஏனெனில் இது நேரியல் குறியீடுகளின் பரந்த 

197
00:12:17,531 --> 00:12:20,392
குடும்பத்துடன் தொடர்புடையது, ஆனால் அது எங்கிருந்து வருகிறது அல்லது எப்படி 

198
00:12:20,392 --> 00:12:23,060
அளவிடுகிறது என்பதற்கான உள்ளுணர்வைக் கொடுக்கவில்லை என்று நினைக்கிறேன்.

199
00:12:25,200 --> 00:12:28,159
மற்றும் அளவிடுதல் பற்றி பேசுகையில், தொகுதி அளவை அதிகரிக்கும்போது மட்டுமே 

200
00:12:28,159 --> 00:12:31,160
இந்த திட்டத்தின் செயல்திறன் சிறப்பாக இருக்கும் என்பதை நீங்கள் கவனிக்கலாம்.

201
00:12:35,000 --> 00:12:38,786
எடுத்துக்காட்டாக, 256 பிட்கள் மூலம், நீங்கள் பணிநீக்கத்திற்கு அந்த இடத்தில் 3% மட்டுமே 

202
00:12:38,786 --> 00:12:42,660
பயன்படுத்துகிறீர்கள் என்பதை நாங்கள் பார்த்தோம், மேலும் அது அங்கிருந்து சிறப்பாக வருகிறது.

203
00:12:43,300 --> 00:12:47,340
சமநிலை பிட்களின் எண்ணிக்கை ஒவ்வொன்றாக வளரும்போது, தொகுதி அளவு இரட்டிப்பாகிறது.

204
00:12:49,000 --> 00:12:51,152
நீங்கள் அதை ஒரு தீவிரத்திற்கு எடுத்துக் கொண்டால், 

205
00:12:51,152 --> 00:12:53,993
நீங்கள் ஒரு மில்லியன் பிட்கள் கொண்ட ஒரு தொகுதியை வைத்திருக்கலாம், 

206
00:12:53,993 --> 00:12:57,695
அங்கு நீங்கள் உண்மையில் உங்கள் சமநிலை சரிபார்ப்புகளுடன் 20 கேள்விகளை விளையாடுவீர்கள், 

207
00:12:57,695 --> 00:13:00,020
மேலும் அது 21 சமநிலை பிட்களை மட்டுமே பயன்படுத்துகிறது.

208
00:13:00,740 --> 00:13:03,736
ஒரு மில்லியன் பிட்களைப் பார்த்து ஒரு பிழையைக் கண்டறிவதைப் பற்றி 

209
00:13:03,736 --> 00:13:07,060
சிந்திக்க நீங்கள் பின்வாங்கினால், அது உண்மையிலேயே பைத்தியமாக உணர்கிறது.

210
00:13:08,199 --> 00:13:13,125
பிரச்சனை, நிச்சயமாக, ஒரு பெரிய தொகுதியுடன், ஒன்று அல்லது இரண்டு பிட் பிழைகளை பார்க்கும் 

211
00:13:13,125 --> 00:13:17,660
நிகழ்தகவு அதிகரிக்கிறது, மேலும் ஹேமிங் குறியீடுகள் அதைத் தாண்டி எதையும் கையாளாது.

212
00:13:18,320 --> 00:13:21,533
எனவே நடைமுறையில், நீங்கள் விரும்புவது சரியான அளவைக் கண்டுபிடிப்பதாகும், 

213
00:13:21,533 --> 00:13:24,300
இதனால் பல பிட் ஃபிளிப்புகளின் நிகழ்தகவு மிக அதிகமாக இருக்காது.

214
00:13:26,600 --> 00:13:29,476
மேலும், நடைமுறையில், பிழைகள் சிறிய வெடிப்புகளில் வருகின்றன, 

215
00:13:29,476 --> 00:13:32,975
இது ஒரு தொகுதியை முற்றிலுமாக அழித்துவிடும், எனவே பல்வேறு தொகுதிகளில் ஒரு 

216
00:13:32,975 --> 00:13:36,809
வெடிப்பு பிழைகளை பரப்ப உதவும் ஒரு பொதுவான தந்திரம், அந்த தொகுதிகளை, இது போன்று, 

217
00:13:36,809 --> 00:13:40,980
அவை உருவாகும் முன், பின்னிணைக்க வேண்டும். வெளியே அனுப்பப்பட்டது அல்லது சேமிக்கப்பட்டது.

218
00:13:45,580 --> 00:13:48,914
மீண்டும், இது மிகவும் நவீன குறியீடுகளால் முழுமையாக மாற்றப்படுகிறது, 

219
00:13:48,914 --> 00:13:51,856
பொதுவாகப் பயன்படுத்தப்படும் ரீட்-சாலமன் அல்காரிதம் போன்றது, 

220
00:13:51,856 --> 00:13:54,161
இது வெடிப்புப் பிழைகளை சிறப்பாகக் கையாளுகிறது, 

221
00:13:54,161 --> 00:13:57,790
மேலும் இது ஒரு தொகுதிக்கு அதிக எண்ணிக்கையிலான பிழைகளை எதிர்க்கும் வகையில் 

222
00:13:57,790 --> 00:13:58,820
மாற்றியமைக்கப்படலாம்.

223
00:13:59,360 --> 00:14:01,340
ஆனால் அது மற்றொரு நேரத்திற்கு ஒரு தலைப்பு.

224
00:14:02,500 --> 00:14:05,534
அவரது தி ஆர்ட் ஆஃப் டூயிங் சயின்ஸ் அண்ட் இன்ஜினியரிங் என்ற புத்தகத்தில், 

225
00:14:05,534 --> 00:14:09,150
ஹாமிங் இந்த குறியீட்டின் கண்டுபிடிப்பு எவ்வளவு வளைந்திருந்தது என்பதைப் பற்றி அற்புதமாக 

226
00:14:09,150 --> 00:14:09,940
நேர்மையாக கூறினார்.

227
00:14:10,620 --> 00:14:14,158
பிட்களை உயர் பரிமாண லட்டியின் பகுதிகளாக ஒழுங்கமைப்பது மற்றும் இது போன்ற விசித்திரமான 

228
00:14:14,158 --> 00:14:17,780
விஷயங்களை உள்ளடக்கிய அனைத்து வகையான வெவ்வேறு திட்டங்களையும் அவர் முதலில் முயற்சித்தார்.

229
00:14:18,300 --> 00:14:22,409
ஒரு பிழையின் நிலையை வெளிப்படுத்தும் விதத்தில் சதி செய்ய சமநிலை காசோலைகளைப் பெறுவது 

230
00:14:22,409 --> 00:14:26,568
சாத்தியம் என்ற எண்ணம் ஹேமிங்கிற்கு வந்தது, அவர் வேறு சில பகுப்பாய்வுகளுக்குப் பிறகு 

231
00:14:26,568 --> 00:14:29,985
பின்வாங்கி, சரி, என்னால் முடிந்த திறமையானது எது என்று கேட்டபோதுதான். 

232
00:14:29,985 --> 00:14:31,520
இதைப் பற்றி சிந்திக்க முடியுமா?

233
00:14:32,620 --> 00:14:36,712
1940 களில் இன்று இருப்பதை விட சமச்சீர் சோதனைகள் அவரது மனதில் ஏற்கனவே 

234
00:14:36,712 --> 00:14:41,220
இருந்திருப்பது எவ்வளவு முக்கியம் என்பது குறித்தும் அவர் நேர்மையாக இருந்தார்.

235
00:14:41,920 --> 00:14:45,069
லூயிஸ் பாஸ்டர் மேற்கோள்களை அவர் குறிப்பிடும் இந்த புத்தகம் முழுவதும் 

236
00:14:45,069 --> 00:14:48,220
அரை டஜன் முறைகள் உள்ளன, அதிர்ஷ்டம் தயாராக இருக்கும் மனதை ஆதரிக்கிறது.

237
00:14:49,320 --> 00:14:51,732
புத்திசாலித்தனமான யோசனைகள் பெரும்பாலும் பின்னோக்கிப் பார்க்கும்போது ஏமாற்றும் 

238
00:14:51,732 --> 00:14:54,300
வகையில் எளிமையாகத் தோன்றுகின்றன, இது அவற்றைக் குறைத்து மதிப்பிடுவதை எளிதாக்குகிறது.

239
00:14:54,960 --> 00:14:56,834
இப்போது எனது நேர்மையான நம்பிக்கை என்னவென்றால், 

240
00:14:56,834 --> 00:14:59,984
ஹேமிங் குறியீடுகள் அல்லது குறைந்தபட்சம் அத்தகைய குறியீடுகளின் சாத்தியக்கூறுகள் 

241
00:14:59,984 --> 00:15:01,300
உங்களுக்குத் தெளிவாகத் தெரிகிறது.

242
00:15:01,660 --> 00:15:05,530
ஆனால் அவை உண்மையில் வெளிப்படையானவை என்று நினைத்து உங்களை நீங்களே ஏமாற்றிக் கொள்ளக்கூடாது, 

243
00:15:05,530 --> 00:15:06,820
ஏனென்றால் அவை நிச்சயமாக இல்லை.

244
00:15:07,880 --> 00:15:10,785
புத்திசாலித்தனமான யோசனைகள் ஏமாற்றும் வகையில் எளிமையாக இருப்பதற்கான ஒரு 

245
00:15:10,785 --> 00:15:13,691
காரணம் என்னவென்றால், நாம் எப்போதும் இறுதி முடிவை மட்டுமே பார்க்கிறோம், 

246
00:15:13,691 --> 00:15:17,048
குழப்பமாக இருந்ததை சுத்தம் செய்வது, தவறான திருப்பங்கள் அனைத்தையும் குறிப்பிடாமல், 

247
00:15:17,048 --> 00:15:19,954
ஒரு சிக்கலின் தொடக்கத்தில் ஆராயக்கூடிய சாத்தியக்கூறுகளின் இடம் எவ்வளவு 

248
00:15:19,954 --> 00:15:22,860
பெரியது என்பதை குறைத்து விற்பனை செய்வது. தீர்க்கும் செயல்முறை, அனைத்து.

249
00:15:23,820 --> 00:15:24,900
ஆனால் இது பொதுவாக உண்மை.

250
00:15:24,900 --> 00:15:28,380
சில சிறப்புக் கண்டுபிடிப்புகளுக்கு, நாம் அவற்றைக் குறைத்து மதிப்பிடுவதற்கு இரண்டாவது, 

251
00:15:28,380 --> 00:15:30,040
ஆழமான காரணம் இருப்பதாக நான் நினைக்கிறேன்.

252
00:15:30,840 --> 00:15:34,867
பிட்களின் அடிப்படையில் தகவல்களைச் சிந்திப்பது 1948 ஆம் ஆண்டளவில் ஒரு முழுமையான 

253
00:15:34,867 --> 00:15:38,640
கோட்பாடாக ஒன்றிணைந்தது, தகவல் கோட்பாட்டில் கிளாட் ஷானனின் செமினல் பேப்பர்.

254
00:15:39,280 --> 00:15:42,540
ஹாமிங் தனது வழிமுறையை உருவாக்கியபோது இது அடிப்படையில் ஒத்துப்போனது.

255
00:15:43,300 --> 00:15:47,273
ஒரு குறிப்பிட்ட அர்த்தத்தில், பிட் ஃபிளிப்புகளின் நிகழ்தகவு எவ்வளவு அதிகமாக இருந்தாலும், 

256
00:15:47,273 --> 00:15:50,667
குறைந்தபட்சம் கோட்பாட்டில், திறமையான பிழை திருத்தம் எப்போதும் சாத்தியமாகும் 

257
00:15:50,667 --> 00:15:52,900
என்பதைக் காட்டிய அதே அடிப்படைக் கட்டுரை இதுவாகும்.

258
00:15:53,700 --> 00:15:57,031
ஷானனும் ஹாமிங்கும், பெல் லேப்ஸில் ஒரு அலுவலகத்தைப் பகிர்ந்து கொண்டனர், 

259
00:15:57,031 --> 00:16:01,160
மிகவும் வித்தியாசமான விஷயங்களில் பணிபுரிந்த போதிலும், இது இங்கு தற்செயலாகத் தெரியவில்லை.

260
00:16:02,380 --> 00:16:04,935
பல தசாப்தங்களாக வேகமாக முன்னேறி, இந்த நாட்களில், 

261
00:16:04,935 --> 00:16:08,898
நம்மில் பலர் பிட்கள் மற்றும் தகவல்களைப் பற்றி சிந்திப்பதில் மூழ்கிவிட்டோம், 

262
00:16:08,898 --> 00:16:12,340
இந்த சிந்தனை முறை எவ்வளவு வித்தியாசமானது என்பதைக் கவனிப்பது எளிது.

263
00:16:13,100 --> 00:16:18,015
முரண்பாடாக, வருங்கால சந்ததியினர் நினைக்கும் வழிகளை மிக ஆழமாக வடிவமைக்கும் கருத்துக்கள், 

264
00:16:18,015 --> 00:16:22,260
அந்த எதிர்கால சந்ததியினருக்கு அவை உண்மையில் இருப்பதை விட எளிமையாக இருக்கும்.

