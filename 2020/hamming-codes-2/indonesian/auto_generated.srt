1
00:00:00,000 --> 00:00:05,718
Pernahkah Anda bertanya-tanya bagaimana mungkin untuk menggores

2
00:00:05,718 --> 00:00:10,900
CD atau DVD dan tetap memutarnya apa pun yang disimpannya?

3
00:00:10,900 --> 00:00:15,446
Goresan tersebut benar-benar mempengaruhi angka 1 dan 0 pada disk, jadi ia membacakan

4
00:00:15,446 --> 00:00:19,835
data yang berbeda dari apa yang disimpan, namun kecuali jika benar-benar tergores,

5
00:00:19,835 --> 00:00:24,117
bit-bit yang terbaca akan didekodekan ke dalam file yang sama persis dengan yang

6
00:00:24,117 --> 00:00:28,400
dikodekan ke dalamnya, a salinan bit demi bit, terlepas dari semua kesalahan itu.

7
00:00:28,400 --> 00:00:32,726
Ada banyak kepintaran matematika yang memungkinkan kita menyimpan data, dan sama

8
00:00:32,726 --> 00:00:36,840
pentingnya untuk mengirimkan data, dengan cara yang tahan terhadap kesalahan.

9
00:00:36,840 --> 00:00:40,140
Baiklah, sebenarnya tidak diperlukan banyak kepintaran

10
00:00:40,140 --> 00:00:42,480
untuk menemukan cara melakukan hal ini.

11
00:00:42,480 --> 00:00:46,720
File apa pun, apakah itu video atau suara atau teks, beberapa

12
00:00:46,720 --> 00:00:50,960
kode, gambar, apa pun, pada akhirnya merupakan urutan 1 dan 0.

13
00:00:50,960 --> 00:00:54,399
Dan strategi sederhana untuk memperbaiki bit apa pun yang

14
00:00:54,399 --> 00:00:57,780
terbalik adalah dengan menyimpan tiga salinan setiap bit.

15
00:00:57,780 --> 00:01:02,416
Kemudian mesin yang membaca file ini dapat membandingkan ketiga salinan

16
00:01:02,416 --> 00:01:07,440
tersebut dan selalu mengambil 2 dari 3 yang terbaik setiap kali ada perbedaan.

17
00:01:07,440 --> 00:01:11,560
Namun artinya adalah menggunakan dua pertiga ruang Anda untuk redundansi.

18
00:01:11,560 --> 00:01:14,932
Meski begitu, meskipun ada banyak ruang yang terbuang, tidak ada jaminan

19
00:01:14,932 --> 00:01:18,120
kuat mengenai apa yang akan terjadi jika lebih dari satu bit dibalik.

20
00:01:18,120 --> 00:01:21,199
Pertanyaan yang jauh lebih menarik adalah bagaimana membuat

21
00:01:21,199 --> 00:01:24,740
kesalahan dapat diperbaiki sambil memberikan ruang sesedikit mungkin.

22
00:01:24,740 --> 00:01:28,857
Misalnya, dengan menggunakan metode yang akan Anda pelajari dalam video ini, Anda

23
00:01:28,857 --> 00:01:32,975
dapat menyimpan data dalam blok 256-bit, yang setiap bloknya menggunakan 9 bit, 9!

24
00:01:32,975 --> 00:01:36,926
untuk bertindak sebagai semacam redundansi, dan 247 bit lainnya

25
00:01:36,926 --> 00:01:41,000
bebas membawa pesan atau data bermakna apa pun yang Anda inginkan.

26
00:01:41,000 --> 00:01:44,931
Dan akan tetap terjadi jika ada bit yang terbalik di sini, hanya dengan melihat

27
00:01:44,931 --> 00:01:48,863
blok ini dan tidak lebih, mesin akan dapat mengidentifikasi bahwa ada kesalahan

28
00:01:48,863 --> 00:01:53,140
dan secara tepat di mana letak kesalahannya sehingga ia mengetahui cara memperbaikinya.

29
00:01:53,140 --> 00:01:55,540
Dan sejujurnya, itu terasa seperti keajaiban.

30
00:01:55,540 --> 00:01:59,264
Dan untuk skema khusus ini, jika dua bit dibalik, mesin setidaknya akan dapat

31
00:01:59,264 --> 00:02:03,180
mendeteksi bahwa ada dua kesalahan, meskipun mesin tidak tahu cara memperbaikinya.

32
00:02:03,180 --> 00:02:08,140
Kita akan membahasnya nanti tentang cara menskalakan balok dengan ukuran berbeda.

33
00:02:08,140 --> 00:02:11,010
Metode yang memungkinkan Anda memperbaiki kesalahan seperti

34
00:02:11,010 --> 00:02:13,880
ini dikenal cukup masuk akal sebagai kode koreksi kesalahan.

35
00:02:13,880 --> 00:02:18,363
Selama hampir satu abad terakhir, bidang ini telah menjadi sumber yang sangat kaya akan

36
00:02:18,363 --> 00:02:22,745
matematika mendalam yang dapat dimasukkan ke dalam perangkat yang kita gunakan setiap

37
00:02:22,745 --> 00:02:23,000
hari.

38
00:02:23,000 --> 00:02:26,380
Tujuannya di sini adalah memberi Anda pemahaman menyeluruh tentang

39
00:02:26,380 --> 00:02:29,660
salah satu contoh paling awal, yang dikenal sebagai kode Hamming.

40
00:02:29,660 --> 00:02:33,093
Dan omong-omong, cara saya memikirkan struktur video ini bukanlah

41
00:02:33,093 --> 00:02:36,422
menjelaskannya secara langsung, namun lebih pada mendorong Anda

42
00:02:36,422 --> 00:02:40,220
untuk menciptakannya sendiri, dengan sedikit panduan lembut di sana-sini.

43
00:02:40,220 --> 00:02:42,421
Jadi ketika Anda merasa sudah tahu ke mana arahnya pada suatu

44
00:02:42,421 --> 00:02:44,623
saat, luangkan waktu sejenak untuk berhenti sejenak, prediksi

45
00:02:44,623 --> 00:02:47,180
secara aktif skema apa yang akan terjadi sebelum saya memberi tahu Anda.

46
00:02:47,180 --> 00:02:51,115
Selain itu, jika Anda ingin pemahaman Anda turun ke tingkat perangkat keras, Ben

47
00:02:51,115 --> 00:02:55,244
Eater telah membuat video bersama dengan video ini yang menunjukkan kepada Anda cara

48
00:02:55,244 --> 00:02:59,520
mengimplementasikan kode Hamming pada papan tempat memotong roti, yang sangat memuaskan.

49
00:02:59,520 --> 00:03:03,224
Anda harus tahu, kode Hamming tidak digunakan secara luas seperti kode yang

50
00:03:03,224 --> 00:03:06,880
lebih modern, seperti algoritma Reed-Solomon, namun ada keajaiban tertentu

51
00:03:06,880 --> 00:03:10,535
dalam kontras antara betapa mustahilnya tugas ini terasa pada awalnya, dan

52
00:03:10,535 --> 00:03:14,240
betapa masuk akalnya hal itu ketika dilakukan. Anda belajar tentang Hamming.

53
00:03:14,240 --> 00:03:18,495
Prinsip dasar koreksi kesalahan adalah bahwa dalam ruang yang luas dari semua

54
00:03:18,495 --> 00:03:22,860
kemungkinan pesan, hanya beberapa subset yang akan dianggap sebagai pesan valid.

55
00:03:22,860 --> 00:03:25,772
Sebagai analogi, pikirkan tentang kata-kata yang

56
00:03:25,772 --> 00:03:29,100
dieja dengan benar vs kata-kata yang dieja dengan salah.

57
00:03:29,100 --> 00:03:32,145
Setiap kali pesan yang valid diubah, penerima bertanggung jawab

58
00:03:32,145 --> 00:03:35,381
untuk mengoreksi apa yang mereka lihat kembali ke tetangga terdekat

59
00:03:35,381 --> 00:03:38,380
yang valid, seperti yang mungkin Anda lakukan jika salah ketik.

60
00:03:38,380 --> 00:03:42,594
Namun, menghasilkan algoritma konkrit untuk mengkategorikan

61
00:03:42,594 --> 00:03:47,160
pesan seperti ini secara efisien membutuhkan kepintaran tertentu.

62
00:03:47,160 --> 00:03:50,369
Ceritanya dimulai pada tahun 1940-an, ketika Richard Hamming muda

63
00:03:50,369 --> 00:03:53,918
bekerja untuk Bell Labs, dan beberapa pekerjaannya melibatkan penggunaan

64
00:03:53,918 --> 00:03:57,420
komputer kartu punch yang sangat besar dan mahal yang aksesnya terbatas.

65
00:03:57,420 --> 00:04:00,176
Dan program-program yang dijalankannya terus-menerus

66
00:04:00,176 --> 00:04:03,140
gagal, karena kadang-kadang ada bagian yang salah dibaca.

67
00:04:03,140 --> 00:04:06,083
Frustrasi menjadi wadah penemuan, dia menjadi sangat muak

68
00:04:06,083 --> 00:04:09,280
sehingga dia menemukan kode koreksi kesalahan pertama di dunia.

69
00:04:09,280 --> 00:04:12,926
Ada banyak cara berbeda untuk membingkai kode Hamming, tetapi sebagai langkah

70
00:04:12,926 --> 00:04:16,620
pertama kita akan membahasnya sesuai dengan cara Hamming sendiri memikirkannya.

71
00:04:16,620 --> 00:04:21,400
Mari kita gunakan contoh yang sederhana, namun tidak terlalu sederhana, blok 16 bit.

72
00:04:21,400 --> 00:04:25,700
Kami akan memberi nomor pada posisi bit-bit ini dari 0 hingga 15.

73
00:04:25,700 --> 00:04:29,810
Data aktual yang ingin kita simpan hanya akan berjumlah 12 bit

74
00:04:29,810 --> 00:04:33,920
ini, sementara 4 posisi dicadangkan sebagai semacam redundansi.

75
00:04:33,920 --> 00:04:37,207
Kata redundant di sini tidak hanya berarti menyalin, lagipula, 4 bit tersebut

76
00:04:37,207 --> 00:04:40,200
tidak memberi kita cukup ruang untuk menyalin data secara membabi buta.

77
00:04:40,200 --> 00:04:44,532
Sebaliknya, mereka harus menjadi redundansi yang lebih bernuansa dan

78
00:04:44,532 --> 00:04:48,740
cerdas, tidak menambahkan informasi baru, namun menambah ketahanan.

79
00:04:48,740 --> 00:04:52,644
Anda mungkin mengharapkan 4 bagian khusus ini dikemas dengan baik bersama-sama, mungkin

80
00:04:52,644 --> 00:04:56,637
di akhir atau semacamnya, tetapi seperti yang akan Anda lihat, menempatkannya pada posisi

81
00:04:56,637 --> 00:05:00,320
pangkat 2 memungkinkan untuk menghasilkan sesuatu yang sangat elegan pada akhirnya.

82
00:05:00,320 --> 00:05:02,647
Ini juga mungkin memberi Anda sedikit petunjuk

83
00:05:02,647 --> 00:05:05,420
tentang bagaimana skala ini untuk blok yang lebih besar.

84
00:05:05,420 --> 00:05:09,954
Secara teknis juga hanya berisi 11 bit data, Anda akan menemukan ada sedikit perbedaan

85
00:05:09,954 --> 00:05:14,280
pada apa yang terjadi di posisi 0, tapi jangan khawatir tentang itu untuk saat ini.

86
00:05:14,280 --> 00:05:18,155
Seperti algoritma koreksi kesalahan lainnya, ini akan melibatkan dua pemain,

87
00:05:18,155 --> 00:05:22,081
pengirim yang bertanggung jawab untuk mengatur 4 bit khusus ini, dan penerima

88
00:05:22,081 --> 00:05:26,360
yang bertanggung jawab untuk melakukan semacam pemeriksaan dan memperbaiki kesalahan.

89
00:05:26,360 --> 00:05:29,441
Tentu saja, kata pengirim dan penerima sebenarnya mengacu pada mesin atau

90
00:05:29,441 --> 00:05:32,356
perangkat lunak yang melakukan semua pemeriksaan, dan gagasan tentang

91
00:05:32,356 --> 00:05:35,480
pesan memiliki arti yang sangat luas, termasuk hal-hal seperti penyimpanan.

92
00:05:35,480 --> 00:05:39,060
Lagi pula, menyimpan data sama saja dengan mengirim pesan dari

93
00:05:39,060 --> 00:05:42,640
masa lalu ke masa depan, bukan dari satu tempat ke tempat lain.

94
00:05:42,640 --> 00:05:46,396
Jadi begitulah pengaturannya, tapi sebelum kita mendalami lebih dalam, kita perlu

95
00:05:46,396 --> 00:05:49,924
membicarakan tentang ide terkait yang masih segar di benak Hamming pada saat

96
00:05:49,924 --> 00:05:53,543
penemuannya, sebuah metode yang memungkinkan Anda mendeteksi kesalahan bit apa

97
00:05:53,543 --> 00:05:57,300
pun, namun tidak memperbaikinya, dikenal dalam bisnis sebagai pemeriksaan paritas.

98
00:05:57,300 --> 00:06:00,965
Untuk pemeriksaan paritas, kami memisahkan hanya satu bit yang menjadi

99
00:06:00,965 --> 00:06:04,940
tanggung jawab pengirim untuk disetel, dan sisanya bebas untuk membawa pesan.

100
00:06:04,940 --> 00:06:08,419
Satu-satunya tugas bit khusus ini adalah memastikan

101
00:06:08,419 --> 00:06:12,100
bahwa jumlah total 1 dalam pesan adalah bilangan genap.

102
00:06:12,100 --> 00:06:16,319
Jadi misalnya sekarang, jumlah total 1 itu adalah 7, itu ganjil, jadi

103
00:06:16,319 --> 00:06:20,960
pengirim perlu membalik bit khusus itu menjadi 1, sehingga hitungannya genap.

104
00:06:20,960 --> 00:06:24,283
Namun jika blok telah dimulai dengan bilangan genap

105
00:06:24,283 --> 00:06:27,480
1, maka bit khusus ini akan tetap pada bilangan 0.

106
00:06:27,480 --> 00:06:30,850
Ini cukup sederhana, tampak sederhana, namun merupakan cara

107
00:06:30,850 --> 00:06:34,389
yang sangat elegan untuk menyaring gagasan perubahan di bagian

108
00:06:34,389 --> 00:06:37,760
mana pun dalam pesan agar tercermin dalam sedikit informasi.

109
00:06:37,760 --> 00:06:42,842
Perhatikan jika ada bagian dari pesan ini yang dibalik, baik dari 0 ke

110
00:06:42,842 --> 00:06:48,140
1 atau 1 ke 0, ini akan mengubah jumlah total 1 dari genap menjadi ganjil.

111
00:06:48,140 --> 00:06:51,691
Jadi jika Anda adalah penerimanya, Anda melihat pesan ini, dan Anda melihat

112
00:06:51,691 --> 00:06:55,242
angka 1 yang ganjil, Anda dapat mengetahui dengan pasti bahwa telah terjadi

113
00:06:55,242 --> 00:06:58,700
kesalahan, meskipun Anda mungkin tidak tahu di mana kesalahan itu terjadi.

114
00:06:58,700 --> 00:07:01,977
Dalam jargon, apakah sekelompok bit memiliki jumlah

115
00:07:01,977 --> 00:07:04,940
1 genap atau ganjil dikenal sebagai paritasnya.

116
00:07:04,940 --> 00:07:08,130
Anda juga dapat menggunakan angka dan mengatakan paritasnya adalah 0 atau

117
00:07:08,130 --> 00:07:11,320
1, yang biasanya lebih berguna setelah Anda mulai menghitung ide tersebut.

118
00:07:11,320 --> 00:07:18,020
Dan bit khusus yang digunakan pengirim untuk mengontrol paritas disebut bit paritas.

119
00:07:18,020 --> 00:07:21,939
Dan sebenarnya harus jelas, jika penerima melihat paritas ganjil, bukan

120
00:07:21,939 --> 00:07:25,858
berarti hanya ada satu kesalahan, mungkin ada 3 kesalahan, atau 5, atau

121
00:07:25,858 --> 00:07:29,560
angka ganjil lainnya, tapi mereka bisa tahu pasti bahwa itu bukan 0.

122
00:07:29,560 --> 00:07:33,995
Di sisi lain, jika terdapat 2 kesalahan, atau jumlah kesalahan berapapun, jumlah

123
00:07:33,995 --> 00:07:38,486
akhir dari 1 detik tersebut akan tetap genap, sehingga penerima tidak dapat yakin

124
00:07:38,486 --> 00:07:43,360
sepenuhnya bahwa jumlah kesalahan yang genap berarti pesan tersebut bebas dari kesalahan.

125
00:07:43,360 --> 00:07:46,560
Anda mungkin mengeluh bahwa pesan yang menjadi kacau hanya

126
00:07:46,560 --> 00:07:49,760
dengan pembalikan 2 bit cukup lemah, dan Anda memang benar.

127
00:07:49,760 --> 00:07:53,006
Namun perlu diingat, tidak ada metode deteksi atau koreksi

128
00:07:53,006 --> 00:07:56,363
kesalahan yang dapat memberi Anda keyakinan 100% bahwa pesan

129
00:07:56,363 --> 00:07:59,720
yang Anda terima adalah pesan yang dimaksudkan oleh pengirim.

130
00:07:59,720 --> 00:08:02,820
Lagi pula, gangguan acak yang cukup selalu dapat mengubah satu

131
00:08:02,820 --> 00:08:05,920
pesan valid menjadi pesan valid lainnya hanya secara kebetulan.

132
00:08:05,920 --> 00:08:11,111
Sebaliknya, tujuannya adalah untuk menghasilkan skema yang kuat hingga jumlah kesalahan

133
00:08:11,111 --> 00:08:16,244
maksimum tertentu, atau mungkin untuk mengurangi kemungkinan kesalahan positif seperti

134
00:08:16,244 --> 00:08:16,480
ini.

135
00:08:16,480 --> 00:08:20,250
Pemeriksaan paritas sendiri cukup lemah, namun dengan menyaring gagasan

136
00:08:20,250 --> 00:08:23,968
perubahan dari seluruh pesan menjadi satu bagian saja, apa yang mereka

137
00:08:23,968 --> 00:08:28,000
berikan kepada kita adalah landasan yang kuat untuk skema yang lebih canggih.

138
00:08:28,000 --> 00:08:31,502
Misalnya, saat Hamming sedang mencari cara untuk mengidentifikasi di mana

139
00:08:31,502 --> 00:08:35,195
kesalahan terjadi, bukan hanya kesalahan itu terjadi, wawasan utamanya adalah

140
00:08:35,195 --> 00:08:38,982
jika Anda menerapkan beberapa pemeriksaan paritas bukan pada keseluruhan pesan,

141
00:08:38,982 --> 00:08:42,769
namun pada subkumpulan tertentu yang dipilih dengan cermat, Anda dapat bertanya

142
00:08:42,769 --> 00:08:46,840
serangkaian pertanyaan yang lebih halus yang menjelaskan lokasi kesalahan bit tunggal.

143
00:08:46,840 --> 00:08:50,798
Perasaan keseluruhannya seperti memainkan permainan 20 pertanyaan, menanyakan

144
00:08:50,798 --> 00:08:54,300
pertanyaan ya atau tidak yang memotong ruang kemungkinan menjadi dua.

145
00:08:54,300 --> 00:08:57,215
Sebagai contoh, katakanlah kita melakukan pemeriksaan

146
00:08:57,215 --> 00:09:00,400
paritas hanya pada 8 bit ini, semua posisi bernomor ganjil.

147
00:09:00,400 --> 00:09:04,628
Kemudian jika terdeteksi adanya error, maka akan memberikan sedikit informasi lebih

148
00:09:04,628 --> 00:09:09,160
kepada penerima mengenai di mana tepatnya error tersebut berada, yaitu pada posisi ganjil.

149
00:09:09,160 --> 00:09:13,200
Jika tidak ada kesalahan yang terdeteksi di antara 8 bit tersebut, itu

150
00:09:13,200 --> 00:09:17,240
berarti tidak ada kesalahan sama sekali, atau berada pada posisi genap.

151
00:09:17,240 --> 00:09:21,612
Anda mungkin berpikir bahwa membatasi pemeriksaan paritas hingga setengah bit membuatnya

152
00:09:21,612 --> 00:09:25,740
kurang efektif, namun jika dilakukan bersamaan dengan pemeriksaan lain yang dipilih

153
00:09:25,740 --> 00:09:29,720
dengan baik, hal ini secara berlawanan memberi kita sesuatu yang jauh lebih kuat.

154
00:09:29,720 --> 00:09:33,353
Untuk benar-benar menyiapkan pemeriksaan paritas tersebut, ingat, diperlukan

155
00:09:33,353 --> 00:09:37,600
pengalokasian beberapa bit khusus yang memiliki kontrol untuk paritas grup penuh tersebut.

156
00:09:37,600 --> 00:09:39,920
Disini kita pilih saja posisi 1.

157
00:09:39,920 --> 00:09:44,095
Pada contoh yang ditunjukkan, paritas 8 bit ini saat ini ganjil, sehingga pengirim

158
00:09:44,095 --> 00:09:48,220
bertanggung jawab untuk mengubah bit paritas tersebut, dan sekarang menjadi genap.

159
00:09:48,220 --> 00:09:51,040
Ini hanya 1 dari 4 pemeriksaan paritas yang akan kami lakukan.

160
00:09:51,040 --> 00:09:53,909
Pemeriksaan kedua adalah di antara 8 bit di bagian kanan

161
00:09:53,909 --> 00:09:56,880
grid, setidaknya seperti yang telah kita gambarkan di sini.

162
00:09:56,880 --> 00:10:00,494
Kali ini kita mungkin menggunakan posisi 2 sebagai bit paritas,

163
00:10:00,494 --> 00:10:03,770
jadi 8 bit ini sudah memiliki paritas genap, dan pengirim

164
00:10:03,770 --> 00:10:07,160
akan merasa senang membiarkan bit nomor 2 itu tidak berubah.

165
00:10:07,160 --> 00:10:10,078
Kemudian di sisi lain, jika penerima memeriksa paritas grup ini

166
00:10:10,078 --> 00:10:13,224
dan mereka menemukan bahwa paritasnya ganjil, mereka akan mengetahui

167
00:10:13,224 --> 00:10:15,960
bahwa kesalahannya ada di antara 8 bit di sebelah kanan ini.

168
00:10:15,960 --> 00:10:21,260
Kalau tidak, berarti tidak ada kesalahan, atau kesalahannya ada di bagian kiri.

169
00:10:21,260 --> 00:10:24,106
Atau saya kira mungkin ada dua kesalahan, tapi untuk saat ini kita

170
00:10:24,106 --> 00:10:27,080
akan berasumsi bahwa paling banyak ada satu kesalahan di seluruh blok.

171
00:10:27,080 --> 00:10:29,160
Segala sesuatunya rusak total karena lebih dari itu.

172
00:10:29,160 --> 00:10:31,452
Di sini, sebelum kita melihat dua pemeriksaan berikutnya, luangkan waktu

173
00:10:31,452 --> 00:10:33,650
sejenak untuk memikirkan tentang apa yang dapat kita lakukan dari dua

174
00:10:33,650 --> 00:10:35,880
pemeriksaan pertama ketika Anda mempertimbangkan keduanya bersama-sama.

175
00:10:35,880 --> 00:10:40,240
Katakanlah Anda mendeteksi kesalahan di antara kolom ganjil, dan di paruh kanan.

176
00:10:40,240 --> 00:10:43,940
Ini berarti kesalahannya ada di kolom terakhir.

177
00:10:43,940 --> 00:10:47,079
Jika tidak ada kesalahan pada kolom ganjil namun ada satu kesalahan pada

178
00:10:47,079 --> 00:10:50,520
separuh kanan, berarti kesalahan tersebut berada pada kolom kedua dari terakhir.

179
00:10:50,520 --> 00:10:53,540
Begitu pula jika ada kesalahan di kolom ganjil tetapi tidak

180
00:10:53,540 --> 00:10:56,560
di separuh kanan, Anda tahu kesalahannya ada di kolom kedua.

181
00:10:56,560 --> 00:11:00,221
Dan jika tidak satu pun dari kedua pemeriksaan paritas tersebut yang mendeteksi apa pun,

182
00:11:00,221 --> 00:11:03,760
berarti satu-satunya tempat terjadinya kesalahan adalah di kolom paling kiri tersebut.

183
00:11:03,760 --> 00:11:06,480
Tapi itu juga mungkin berarti tidak ada kesalahan sama sekali.

184
00:11:06,480 --> 00:11:08,994
Ini merupakan cara yang agak rumit untuk mengatakan

185
00:11:08,994 --> 00:11:11,800
bahwa dua pemeriksaan paritas mari kita tentukan kolomnya.

186
00:11:11,800 --> 00:11:14,000
Dari sini, Anda mungkin bisa menebak berikut ini.

187
00:11:14,000 --> 00:11:16,240
Pada dasarnya kami melakukan hal yang sama tetapi untuk barisnya.

188
00:11:16,240 --> 00:11:21,040
Akan ada pemeriksaan paritas pada baris ganjil, menggunakan posisi 4 sebagai bit paritas.

189
00:11:21,040 --> 00:11:23,960
Jadi dalam contoh ini grup tersebut sudah memiliki

190
00:11:23,960 --> 00:11:26,480
paritas genap, jadi bit 4 akan disetel ke 0.

191
00:11:26,480 --> 00:11:29,408
Dan terakhir ada pemeriksaan paritas pada dua baris

192
00:11:29,408 --> 00:11:32,280
terbawah, menggunakan posisi 8 sebagai bit paritas.

193
00:11:32,280 --> 00:11:35,037
Dalam hal ini, sepertinya pengirim perlu mengaktifkan bit 8

194
00:11:35,037 --> 00:11:37,840
tersebut untuk memberikan keseimbangan yang merata pada grup.

195
00:11:37,840 --> 00:11:40,456
Sama seperti dua pemeriksaan pertama yang memungkinkan kita menentukan

196
00:11:40,456 --> 00:11:43,000
kolom, dua pemeriksaan berikutnya memungkinkan Anda menentukan baris.

197
00:11:43,000 --> 00:11:48,400
Sebagai contoh, bayangkan selama transmisi terjadi kesalahan pada, katakanlah, posisi 3.

198
00:11:48,400 --> 00:11:52,484
Ini mempengaruhi kelompok paritas pertama, dan juga mempengaruhi kelompok paritas kedua,

199
00:11:52,484 --> 00:11:56,340
sehingga penerima mengetahui bahwa ada kesalahan di suatu tempat di kolom kanan itu.

200
00:11:56,340 --> 00:12:01,380
Tapi itu tidak mempengaruhi kelompok ketiga, dan tidak mempengaruhi kelompok keempat.

201
00:12:01,380 --> 00:12:04,946
Dan itu memungkinkan penerima menentukan kesalahan hingga baris pertama,

202
00:12:04,946 --> 00:12:08,660
yang berarti posisi 3, sehingga mereka dapat memperbaiki kesalahan tersebut.

203
00:12:08,660 --> 00:12:11,605
Anda mungkin senang meluangkan waktu sejenak untuk meyakinkan diri

204
00:12:11,605 --> 00:12:14,330
sendiri bahwa jawaban atas keempat pertanyaan ini akan selalu

205
00:12:14,330 --> 00:12:17,320
memungkinkan Anda menentukan lokasi tertentu, di mana pun lokasinya.

206
00:12:17,320 --> 00:12:20,379
Faktanya, orang yang cerdik di antara Anda mungkin menyadari

207
00:12:20,379 --> 00:12:23,640
hubungan antara pertanyaan-pertanyaan ini dan penghitungan biner.

208
00:12:23,640 --> 00:12:27,235
Dan jika Anda melakukannya, sekali lagi izinkan saya menekankan, berhenti

209
00:12:27,235 --> 00:12:30,880
sejenak, cobalah sendiri untuk menarik hubungannya sebelum saya merusaknya.

210
00:12:30,880 --> 00:12:33,638
Jika Anda bertanya-tanya apa yang terjadi jika bit

211
00:12:33,638 --> 00:12:36,560
paritas itu sendiri terpengaruh, Anda bisa mencobanya.

212
00:12:36,560 --> 00:12:41,969
Luangkan waktu sejenak untuk memikirkan bagaimana kesalahan apa pun di antara empat bit

213
00:12:41,969 --> 00:12:47,440
khusus ini akan dilacak seperti yang lainnya, dengan kelompok empat pertanyaan yang sama.

214
00:12:47,440 --> 00:12:50,540
Hal ini tidak menjadi masalah, karena pada akhirnya yang kita inginkan

215
00:12:50,540 --> 00:12:53,640
adalah melindungi bit pesan, bit koreksi kesalahan akan terus berjalan.

216
00:12:53,640 --> 00:12:56,389
Namun melindungi bagian-bagian tersebut juga merupakan sesuatu yang

217
00:12:56,389 --> 00:12:59,260
secara alami tidak termasuk dalam skema dan merupakan produk sampingan.

218
00:12:59,260 --> 00:13:02,380
Anda mungkin juga senang mengantisipasi bagaimana skalanya.

219
00:13:02,380 --> 00:13:06,652
Jika kita menggunakan blok berukuran 256 bit, misalnya, untuk

220
00:13:06,652 --> 00:13:10,993
menentukan lokasi, Anda hanya memerlukan delapan pertanyaan ya

221
00:13:10,993 --> 00:13:15,680
atau tidak untuk melakukan pencarian biner hingga ke titik tertentu.

222
00:13:15,680 --> 00:13:19,543
Dan ingat, setiap pertanyaan hanya memerlukan penyerahan

223
00:13:19,543 --> 00:13:23,340
satu bit untuk mengatur pemeriksaan paritas yang sesuai.

224
00:13:23,340 --> 00:13:26,725
Beberapa dari Anda mungkin sudah melihatnya, tetapi nanti kita akan membahas tentang cara

225
00:13:26,725 --> 00:13:29,960
sistematis untuk mengetahui pertanyaan-pertanyaan ini hanya dalam satu atau dua menit.

226
00:13:29,960 --> 00:13:32,589
Semoga sketsa ini cukup untuk mengapresiasi efisiensi

227
00:13:32,589 --> 00:13:34,440
dari apa yang kami kembangkan di sini.

228
00:13:34,440 --> 00:13:38,005
Hal pertama, kecuali delapan bit paritas yang disorot, dapat berupa apa

229
00:13:38,005 --> 00:13:41,720
pun yang Anda inginkan, membawa pesan atau data apa pun yang Anda inginkan.

230
00:13:41,720 --> 00:13:45,518
8 bit tersebut mubazir dalam arti bahwa mereka sepenuhnya

231
00:13:45,518 --> 00:13:49,448
ditentukan oleh sisa pesan, namun ini adalah cara yang jauh

232
00:13:49,448 --> 00:13:53,640
lebih cerdas daripada sekadar menyalin pesan secara keseluruhan.

233
00:13:53,640 --> 00:13:56,367
Dan tetap saja, dengan sedikit menyerah, Anda akan dapat

234
00:13:56,367 --> 00:13:59,000
mengidentifikasi dan memperbaiki kesalahan bit apa pun.

235
00:13:59,000 --> 00:14:00,400
Hampir saja.

236
00:14:00,400 --> 00:14:04,500
Oke, jadi satu-satunya masalah di sini adalah jika tidak satu pun dari empat

237
00:14:04,500 --> 00:14:08,813
pemeriksaan paritas yang mendeteksi kesalahan, artinya subset 8 bit yang dipilih

238
00:14:08,813 --> 00:14:13,127
secara khusus semuanya memiliki paritas genap, seperti yang diinginkan pengirim,

239
00:14:13,127 --> 00:14:17,760
maka itu berarti tidak ada kesalahan sama sekali. , atau mempersempit kita ke posisi 0.

240
00:14:17,760 --> 00:14:21,256
Anda tahu, dengan empat pertanyaan ya atau tidak, kami memiliki 16

241
00:14:21,256 --> 00:14:24,962
kemungkinan hasil untuk pemeriksaan paritas kami, dan pada awalnya itu

242
00:14:24,962 --> 00:14:28,772
terasa sempurna untuk menunjukkan dengan tepat 1 dari 16 posisi di blok,

243
00:14:28,772 --> 00:14:33,000
tetapi Anda juga perlu mengomunikasikan hasil ke-17, tidak ada kesalahan kondisi.

244
00:14:33,000 --> 00:14:37,860
Solusinya di sini sebenarnya cukup sederhana, lupakan saja bit ke-0 itu sepenuhnya.

245
00:14:37,860 --> 00:14:40,980
Jadi ketika kita melakukan empat pemeriksaan paritas dan

246
00:14:40,980 --> 00:14:44,320
kita melihat semuanya genap, itu berarti tidak ada kesalahan.

247
00:14:44,320 --> 00:14:49,262
Artinya, daripada bekerja dengan blok 16-bit, kami bekerja dengan blok 15-bit,

248
00:14:49,262 --> 00:14:54,080
di mana 11 bit bebas untuk membawa pesan dan 4 di antaranya untuk redundansi.

249
00:14:54,080 --> 00:14:56,489
Dan dengan itu, kami sekarang memiliki apa yang oleh

250
00:14:56,489 --> 00:14:59,400
orang-orang dalam bisnis ini disebut sebagai kode 15-11 Hamming.

251
00:14:59,400 --> 00:15:02,678
Meskipun demikian, menyenangkan untuk memiliki ukuran blok dengan pangkat

252
00:15:02,678 --> 00:15:05,779
bersih 2, dan ada cara cerdas agar kita dapat mempertahankan bit ke-0

253
00:15:05,779 --> 00:15:08,880
tersebut dan membuatnya melakukan sedikit pekerjaan ekstra untuk kita.

254
00:15:08,880 --> 00:15:12,772
Jika kita menggunakannya sebagai bit paritas di seluruh blok, ini memungkinkan

255
00:15:12,772 --> 00:15:16,320
kita mendeteksi, meskipun kita tidak dapat memperbaiki, kesalahan 2-bit.

256
00:15:16,320 --> 00:15:17,440
Begini cara kerjanya.

257
00:15:17,440 --> 00:15:21,376
Setelah menyetel keempat bit koreksi kesalahan khusus tersebut, kami menyetel bit ke-0

258
00:15:21,376 --> 00:15:25,223
tersebut sehingga paritas dari blok penuh menjadi genap, seperti pemeriksaan paritas

259
00:15:25,223 --> 00:15:25,540
normal.

260
00:15:25,540 --> 00:15:29,764
Sekarang, jika ada kesalahan bit tunggal, maka paritas blok penuh akan berubah menjadi

261
00:15:29,764 --> 00:15:33,940
ganjil, namun kita akan tetap menangkapnya berkat empat pemeriksaan koreksi kesalahan.

262
00:15:33,940 --> 00:15:37,987
Namun, jika ada dua kesalahan, maka keseluruhan paritas akan kembali menjadi

263
00:15:37,987 --> 00:15:41,719
genap, namun penerima masih akan melihat bahwa setidaknya ada beberapa

264
00:15:41,719 --> 00:15:45,820
kesalahan karena apa yang terjadi dengan keempat pemeriksaan paritas tersebut.

265
00:15:45,820 --> 00:15:48,423
Jadi, jika mereka melihat adanya paritas yang genap secara keseluruhan,

266
00:15:48,423 --> 00:15:50,846
namun terjadi sesuatu yang bukan nol pada pemeriksaan lainnya, hal

267
00:15:50,846 --> 00:15:52,980
ini memberi tahu mereka bahwa setidaknya ada dua kesalahan.

268
00:15:52,980 --> 00:15:54,420
Bukankah itu pintar?

269
00:15:54,420 --> 00:15:58,458
Meskipun kami tidak dapat memperbaiki kesalahan 2-bit tersebut, hanya dengan

270
00:15:58,458 --> 00:16:02,340
mengembalikan satu bit ke-0 yang mengganggu itu, kami dapat mendeteksinya.

271
00:16:02,340 --> 00:16:06,540
Ini cukup standar, dikenal sebagai kode Hamming yang diperluas.

272
00:16:06,540 --> 00:16:10,236
Secara teknis, Anda sekarang memiliki gambaran lengkap tentang

273
00:16:10,236 --> 00:16:13,580
fungsi kode Hamming, setidaknya untuk contoh blok 16-bit.

274
00:16:13,580 --> 00:16:16,319
Namun saya pikir Anda akan merasa lebih puas jika memeriksa

275
00:16:16,319 --> 00:16:19,195
pemahaman Anda dan memantapkan semuanya hingga saat ini dengan

276
00:16:19,195 --> 00:16:21,980
melakukan sendiri satu contoh lengkap dari awal hingga akhir.

277
00:16:21,980 --> 00:16:25,100
Saya akan membahasnya bersama Anda sehingga Anda dapat memeriksanya sendiri.

278
00:16:25,100 --> 00:16:28,753
Untuk menyiapkan pesan, apakah itu pesan literal yang Anda terjemahkan

279
00:16:28,753 --> 00:16:32,200
melalui ruang atau beberapa data yang ingin Anda simpan dari waktu

280
00:16:32,200 --> 00:16:35,700
ke waktu, langkah pertama adalah membaginya menjadi potongan 11-bit.

281
00:16:35,700 --> 00:16:40,340
Setiap potongan akan dikemas ke dalam blok 16-bit yang tahan kesalahan.

282
00:16:40,340 --> 00:16:43,740
Jadi mari kita ambil yang ini sebagai contoh dan kerjakan.

283
00:16:43,740 --> 00:16:45,380
Silakan, lakukanlah!

284
00:16:45,380 --> 00:16:52,980
Mari kita berhenti sejenak dan mencoba menyusun blok ini.

285
00:16:52,980 --> 00:16:53,980
Oke, kamu siap?

286
00:16:53,980 --> 00:16:59,806
Ingat, posisi 0 dan pangkat 2 lainnya dicadangkan untuk tugas koreksi kesalahan, jadi

287
00:16:59,806 --> 00:17:05,700
Anda mulai dengan menempatkan bit pesan di semua tempat yang tersisa, secara berurutan.

288
00:17:05,700 --> 00:17:09,698
Anda memerlukan grup ini untuk memiliki paritas genap, yang sudah dimilikinya,

289
00:17:09,698 --> 00:17:13,140
jadi Anda harus menyetel bit paritas tersebut di posisi 1 menjadi 0.

290
00:17:13,140 --> 00:17:16,105
Grup berikutnya dimulai dengan paritas ganjil,

291
00:17:16,105 --> 00:17:19,260
jadi Anda harus menyetel bit paritasnya menjadi 1.

292
00:17:19,260 --> 00:17:22,026
Grup setelah itu dimulai dengan paritas ganjil, jadi

293
00:17:22,026 --> 00:17:24,740
sekali lagi Anda harus menyetel bit paritasnya ke 1.

294
00:17:24,740 --> 00:17:27,890
Dan grup terakhir juga memiliki paritas ganjil,

295
00:17:27,890 --> 00:17:31,500
artinya bit tersebut kita atur pada posisi 8 menjadi 1.

296
00:17:31,500 --> 00:17:36,433
Dan sebagai langkah terakhir, blok penuh sekarang memiliki paritas genap,

297
00:17:36,433 --> 00:17:41,500
artinya Anda dapat mengatur bit nomor 0, bit paritas keseluruhan, menjadi 0.

298
00:17:41,500 --> 00:17:45,159
Jadi ketika blok ini dilepaskan, paritas dari empat himpunan bagian

299
00:17:45,159 --> 00:17:48,980
khusus dan blok secara keseluruhan semuanya akan menjadi genap, atau 0.

300
00:17:48,980 --> 00:17:53,620
Sebagai bagian kedua dari latihan ini, biarkan Anda berperan sebagai penerima.

301
00:17:53,620 --> 00:17:56,924
Tentu saja itu berarti Anda belum mengetahui apa pesan ini, mungkin

302
00:17:56,924 --> 00:18:00,180
sebagian dari Anda sudah menghafalnya, tapi anggap saja Anda belum.

303
00:18:00,180 --> 00:18:04,320
Apa yang akan saya lakukan adalah mengubah 0, 1, atau 2 bit di blok

304
00:18:04,320 --> 00:18:08,340
itu, dan kemudian meminta Anda mencari tahu apa yang saya lakukan.

305
00:18:08,340 --> 00:18:13,460
Jadi sekali lagi, jeda dan coba kerjakan.

306
00:18:13,460 --> 00:18:21,185
Oke, jadi Anda sebagai penerima sekarang periksa grup paritas pertama dan Anda dapat

307
00:18:21,185 --> 00:18:29,274
melihat bahwa grup tersebut genap, jadi kesalahan apa pun yang ada pasti berada di kolom

308
00:18:29,274 --> 00:18:29,820
genap.

309
00:18:29,820 --> 00:18:34,290
Pemeriksaan berikutnya memberi kita angka ganjil, memberi tahu kita berdua bahwa

310
00:18:34,290 --> 00:18:38,760
setidaknya ada satu kesalahan, dan mempersempit kita ke dalam kolom spesifik ini.

311
00:18:38,760 --> 00:18:42,900
Pemeriksaan ketiga bersifat genap, mengurangi kemungkinan lebih jauh lagi.

312
00:18:42,900 --> 00:18:47,378
Dan pemeriksaan paritas terakhir adalah ganjil, memberi tahu kita bahwa ada kesalahan

313
00:18:47,378 --> 00:18:51,700
di suatu tempat di bawah, yang sekarang kita lihat pasti berada di posisi nomor 10.

314
00:18:51,700 --> 00:18:55,056
Terlebih lagi, paritas seluruh blok ganjil, memberi

315
00:18:55,056 --> 00:18:58,220
kita keyakinan bahwa ada satu flip dan bukan dua.

316
00:18:58,220 --> 00:19:01,600
Jika jumlahnya tiga atau lebih, semua taruhan dibatalkan.

317
00:19:01,600 --> 00:19:06,412
Setelah mengoreksi bit nomor 10 itu, mengeluarkan 11 bit yang tidak digunakan

318
00:19:06,412 --> 00:19:11,286
untuk koreksi memberi kita segmen yang relevan dari pesan asli, yang jika Anda

319
00:19:11,286 --> 00:19:16,160
memutar ulang dan membandingkannya memang persis dengan contoh yang kita mulai.

320
00:19:16,160 --> 00:19:18,728
Dan sekarang setelah Anda mengetahui cara melakukan semua ini dengan

321
00:19:18,728 --> 00:19:21,110
tangan, saya ingin menunjukkan kepada Anda bagaimana Anda dapat

322
00:19:21,110 --> 00:19:23,940
menjalankan bagian inti dari semua logika ini dengan satu baris kode Python.

323
00:19:23,940 --> 00:19:27,656
Anda tahu, apa yang belum saya sampaikan kepada Anda adalah betapa elegannya

324
00:19:27,656 --> 00:19:31,470
algoritma ini, betapa sederhananya membuat mesin menunjukkan posisi kesalahan,

325
00:19:31,470 --> 00:19:35,332
bagaimana menskalakannya secara sistematis, dan bagaimana kita dapat membingkai

326
00:19:35,332 --> 00:19:39,580
semuanya. ini sebagai satu operasi tunggal, bukan beberapa pemeriksaan paritas terpisah.

327
00:19:39,580 --> 00:19:39,580
Untuk memahami maksud saya, bergabunglah dengan saya di bagian 2.

