1
00:00:00,000 --> 00:00:05,718
Pernahkah Anda bertanya-tanya bagaimana mungkin untuk menggores

2
00:00:05,718 --> 00:00:10,900
CD atau DVD dan tetap memutarnya apa pun yang disimpannya?

3
00:00:10,900 --> 00:00:14,442
Goresan tersebut benar-benar mempengaruhi angka 1 dan 0 pada disk,

4
00:00:14,442 --> 00:00:17,667
jadi ia membacakan data yang berbeda dari apa yang disimpan,

5
00:00:17,667 --> 00:00:22,002
namun kecuali jika benar-benar tergores, bit-bit yang terbaca akan didekodekan ke

6
00:00:22,002 --> 00:00:26,602
dalam file yang sama persis dengan yang dikodekan ke dalamnya, a salinan bit demi bit,

7
00:00:26,602 --> 00:00:28,400
terlepas dari semua kesalahan itu.

8
00:00:28,400 --> 00:00:32,246
Ada banyak kepintaran matematika yang memungkinkan kita menyimpan data,

9
00:00:32,246 --> 00:00:36,840
dan sama pentingnya untuk mengirimkan data, dengan cara yang tahan terhadap kesalahan.

10
00:00:36,840 --> 00:00:40,140
Baiklah, sebenarnya tidak diperlukan banyak kepintaran

11
00:00:40,140 --> 00:00:42,480
untuk menemukan cara melakukan hal ini.

12
00:00:42,480 --> 00:00:47,130
File apa pun, apakah itu video atau suara atau teks, beberapa kode,

13
00:00:47,130 --> 00:00:50,960
gambar, apa pun, pada akhirnya merupakan urutan 1 dan 0.

14
00:00:50,960 --> 00:00:54,399
Dan strategi sederhana untuk memperbaiki bit apa pun yang

15
00:00:54,399 --> 00:00:57,780
terbalik adalah dengan menyimpan tiga salinan setiap bit.

16
00:00:57,780 --> 00:01:02,416
Kemudian mesin yang membaca file ini dapat membandingkan ketiga salinan

17
00:01:02,416 --> 00:01:07,440
tersebut dan selalu mengambil 2 dari 3 yang terbaik setiap kali ada perbedaan.

18
00:01:07,440 --> 00:01:11,560
Namun artinya adalah menggunakan dua pertiga ruang Anda untuk redundansi.

19
00:01:11,560 --> 00:01:14,100
Meski begitu, meskipun ada banyak ruang yang terbuang,

20
00:01:14,100 --> 00:01:18,120
tidak ada jaminan kuat mengenai apa yang akan terjadi jika lebih dari satu bit dibalik.

21
00:01:18,120 --> 00:01:21,199
Pertanyaan yang jauh lebih menarik adalah bagaimana membuat

22
00:01:21,199 --> 00:01:24,740
kesalahan dapat diperbaiki sambil memberikan ruang sesedikit mungkin.

23
00:01:24,740 --> 00:01:28,606
Misalnya, dengan menggunakan metode yang akan Anda pelajari dalam video ini,

24
00:01:28,606 --> 00:01:32,975
Anda dapat menyimpan data dalam blok 256-bit, yang setiap bloknya menggunakan 9 bit, 9!

25
00:01:32,975 --> 00:01:36,926
untuk bertindak sebagai semacam redundansi, dan 247 bit lainnya

26
00:01:36,926 --> 00:01:41,000
bebas membawa pesan atau data bermakna apa pun yang Anda inginkan.

27
00:01:41,000 --> 00:01:43,899
Dan akan tetap terjadi jika ada bit yang terbalik di sini,

28
00:01:43,899 --> 00:01:46,209
hanya dengan melihat blok ini dan tidak lebih,

29
00:01:46,209 --> 00:01:50,092
mesin akan dapat mengidentifikasi bahwa ada kesalahan dan secara tepat di mana

30
00:01:50,092 --> 00:01:53,140
letak kesalahannya sehingga ia mengetahui cara memperbaikinya.

31
00:01:53,140 --> 00:01:55,540
Dan sejujurnya, itu terasa seperti keajaiban.

32
00:01:55,540 --> 00:01:57,927
Dan untuk skema khusus ini, jika dua bit dibalik,

33
00:01:57,927 --> 00:02:00,983
mesin setidaknya akan dapat mendeteksi bahwa ada dua kesalahan,

34
00:02:00,983 --> 00:02:03,180
meskipun mesin tidak tahu cara memperbaikinya.

35
00:02:03,180 --> 00:02:08,140
Kita akan membahasnya nanti tentang cara menskalakan balok dengan ukuran berbeda.

36
00:02:08,140 --> 00:02:11,010
Metode yang memungkinkan Anda memperbaiki kesalahan seperti

37
00:02:11,010 --> 00:02:13,880
ini dikenal cukup masuk akal sebagai kode koreksi kesalahan.

38
00:02:13,880 --> 00:02:18,363
Selama hampir satu abad terakhir, bidang ini telah menjadi sumber yang sangat kaya akan

39
00:02:18,363 --> 00:02:22,745
matematika mendalam yang dapat dimasukkan ke dalam perangkat yang kita gunakan setiap

40
00:02:22,745 --> 00:02:23,000
hari.

41
00:02:23,000 --> 00:02:26,380
Tujuannya di sini adalah memberi Anda pemahaman menyeluruh tentang

42
00:02:26,380 --> 00:02:29,660
salah satu contoh paling awal, yang dikenal sebagai kode Hamming.

43
00:02:29,660 --> 00:02:33,093
Dan omong-omong, cara saya memikirkan struktur video ini bukanlah

44
00:02:33,093 --> 00:02:36,422
menjelaskannya secara langsung, namun lebih pada mendorong Anda

45
00:02:36,422 --> 00:02:40,220
untuk menciptakannya sendiri, dengan sedikit panduan lembut di sana-sini.

46
00:02:40,220 --> 00:02:42,634
Jadi ketika Anda merasa sudah tahu ke mana arahnya pada suatu saat,

47
00:02:42,634 --> 00:02:44,303
luangkan waktu sejenak untuk berhenti sejenak,

48
00:02:44,303 --> 00:02:47,180
prediksi secara aktif skema apa yang akan terjadi sebelum saya memberi tahu Anda.

49
00:02:47,180 --> 00:02:50,920
Selain itu, jika Anda ingin pemahaman Anda turun ke tingkat perangkat keras,

50
00:02:50,920 --> 00:02:55,001
Ben Eater telah membuat video bersama dengan video ini yang menunjukkan kepada Anda

51
00:02:55,001 --> 00:02:58,451
cara mengimplementasikan kode Hamming pada papan tempat memotong roti,

52
00:02:58,451 --> 00:02:59,520
yang sangat memuaskan.

53
00:02:59,520 --> 00:03:03,906
Anda harus tahu, kode Hamming tidak digunakan secara luas seperti kode yang lebih modern,

54
00:03:03,906 --> 00:03:07,562
seperti algoritma Reed-Solomon, namun ada keajaiban tertentu dalam kontras

55
00:03:07,562 --> 00:03:10,340
antara betapa mustahilnya tugas ini terasa pada awalnya,

56
00:03:10,340 --> 00:03:14,240
dan betapa masuk akalnya hal itu ketika dilakukan. Anda belajar tentang Hamming.

57
00:03:14,240 --> 00:03:18,495
Prinsip dasar koreksi kesalahan adalah bahwa dalam ruang yang luas dari semua

58
00:03:18,495 --> 00:03:22,860
kemungkinan pesan, hanya beberapa subset yang akan dianggap sebagai pesan valid.

59
00:03:22,860 --> 00:03:25,772
Sebagai analogi, pikirkan tentang kata-kata yang

60
00:03:25,772 --> 00:03:29,100
dieja dengan benar vs kata-kata yang dieja dengan salah.

61
00:03:29,100 --> 00:03:32,145
Setiap kali pesan yang valid diubah, penerima bertanggung jawab

62
00:03:32,145 --> 00:03:35,952
untuk mengoreksi apa yang mereka lihat kembali ke tetangga terdekat yang valid,

63
00:03:35,952 --> 00:03:38,380
seperti yang mungkin Anda lakukan jika salah ketik.

64
00:03:38,380 --> 00:03:42,594
Namun, menghasilkan algoritma konkrit untuk mengkategorikan

65
00:03:42,594 --> 00:03:47,160
pesan seperti ini secara efisien membutuhkan kepintaran tertentu.

66
00:03:47,160 --> 00:03:50,369
Ceritanya dimulai pada tahun 1940-an, ketika Richard Hamming muda

67
00:03:50,369 --> 00:03:53,918
bekerja untuk Bell Labs, dan beberapa pekerjaannya melibatkan penggunaan

68
00:03:53,918 --> 00:03:57,420
komputer kartu punch yang sangat besar dan mahal yang aksesnya terbatas.

69
00:03:57,420 --> 00:04:00,540
Dan program-program yang dijalankannya terus-menerus gagal,

70
00:04:00,540 --> 00:04:03,140
karena kadang-kadang ada bagian yang salah dibaca.

71
00:04:03,140 --> 00:04:06,083
Frustrasi menjadi wadah penemuan, dia menjadi sangat muak

72
00:04:06,083 --> 00:04:09,280
sehingga dia menemukan kode koreksi kesalahan pertama di dunia.

73
00:04:09,280 --> 00:04:11,851
Ada banyak cara berbeda untuk membingkai kode Hamming,

74
00:04:11,851 --> 00:04:15,591
tetapi sebagai langkah pertama kita akan membahasnya sesuai dengan cara Hamming

75
00:04:15,591 --> 00:04:16,620
sendiri memikirkannya.

76
00:04:16,620 --> 00:04:21,400
Mari kita gunakan contoh yang sederhana, namun tidak terlalu sederhana, blok 16 bit.

77
00:04:21,400 --> 00:04:25,700
Kami akan memberi nomor pada posisi bit-bit ini dari 0 hingga 15.

78
00:04:25,700 --> 00:04:30,136
Data aktual yang ingin kita simpan hanya akan berjumlah 12 bit ini,

79
00:04:30,136 --> 00:04:33,920
sementara 4 posisi dicadangkan sebagai semacam redundansi.

80
00:04:33,920 --> 00:04:36,575
Kata redundant di sini tidak hanya berarti menyalin, lagipula,

81
00:04:36,575 --> 00:04:40,200
4 bit tersebut tidak memberi kita cukup ruang untuk menyalin data secara membabi buta.

82
00:04:40,200 --> 00:04:45,035
Sebaliknya, mereka harus menjadi redundansi yang lebih bernuansa dan cerdas,

83
00:04:45,035 --> 00:04:48,740
tidak menambahkan informasi baru, namun menambah ketahanan.

84
00:04:48,740 --> 00:04:52,289
Anda mungkin mengharapkan 4 bagian khusus ini dikemas dengan baik bersama-sama,

85
00:04:52,289 --> 00:04:55,439
mungkin di akhir atau semacamnya, tetapi seperti yang akan Anda lihat,

86
00:04:55,439 --> 00:04:59,388
menempatkannya pada posisi pangkat 2 memungkinkan untuk menghasilkan sesuatu yang sangat

87
00:04:59,388 --> 00:05:00,320
elegan pada akhirnya.

88
00:05:00,320 --> 00:05:02,647
Ini juga mungkin memberi Anda sedikit petunjuk

89
00:05:02,647 --> 00:05:05,420
tentang bagaimana skala ini untuk blok yang lebih besar.

90
00:05:05,420 --> 00:05:09,954
Secara teknis juga hanya berisi 11 bit data, Anda akan menemukan ada sedikit perbedaan

91
00:05:09,954 --> 00:05:14,280
pada apa yang terjadi di posisi 0, tapi jangan khawatir tentang itu untuk saat ini.

92
00:05:14,280 --> 00:05:18,155
Seperti algoritma koreksi kesalahan lainnya, ini akan melibatkan dua pemain,

93
00:05:18,155 --> 00:05:21,427
pengirim yang bertanggung jawab untuk mengatur 4 bit khusus ini,

94
00:05:21,427 --> 00:05:25,252
dan penerima yang bertanggung jawab untuk melakukan semacam pemeriksaan dan

95
00:05:25,252 --> 00:05:26,360
memperbaiki kesalahan.

96
00:05:26,360 --> 00:05:29,441
Tentu saja, kata pengirim dan penerima sebenarnya mengacu pada mesin atau

97
00:05:29,441 --> 00:05:31,523
perangkat lunak yang melakukan semua pemeriksaan,

98
00:05:31,523 --> 00:05:33,939
dan gagasan tentang pesan memiliki arti yang sangat luas,

99
00:05:33,939 --> 00:05:35,480
termasuk hal-hal seperti penyimpanan.

100
00:05:35,480 --> 00:05:40,480
Lagi pula, menyimpan data sama saja dengan mengirim pesan dari masa lalu ke masa depan,

101
00:05:40,480 --> 00:05:42,640
bukan dari satu tempat ke tempat lain.

102
00:05:42,640 --> 00:05:45,892
Jadi begitulah pengaturannya, tapi sebelum kita mendalami lebih dalam,

103
00:05:45,892 --> 00:05:49,466
kita perlu membicarakan tentang ide terkait yang masih segar di benak Hamming

104
00:05:49,466 --> 00:05:53,176
pada saat penemuannya, sebuah metode yang memungkinkan Anda mendeteksi kesalahan

105
00:05:53,176 --> 00:05:57,300
bit apa pun, namun tidak memperbaikinya, dikenal dalam bisnis sebagai pemeriksaan paritas.

106
00:05:57,300 --> 00:06:00,965
Untuk pemeriksaan paritas, kami memisahkan hanya satu bit yang menjadi

107
00:06:00,965 --> 00:06:04,940
tanggung jawab pengirim untuk disetel, dan sisanya bebas untuk membawa pesan.

108
00:06:04,940 --> 00:06:08,419
Satu-satunya tugas bit khusus ini adalah memastikan

109
00:06:08,419 --> 00:06:12,100
bahwa jumlah total 1 dalam pesan adalah bilangan genap.

110
00:06:12,100 --> 00:06:16,017
Jadi misalnya sekarang, jumlah total 1 itu adalah 7, itu ganjil,

111
00:06:16,017 --> 00:06:20,960
jadi pengirim perlu membalik bit khusus itu menjadi 1, sehingga hitungannya genap.

112
00:06:20,960 --> 00:06:24,475
Namun jika blok telah dimulai dengan bilangan genap 1,

113
00:06:24,475 --> 00:06:27,480
maka bit khusus ini akan tetap pada bilangan 0.

114
00:06:27,480 --> 00:06:30,850
Ini cukup sederhana, tampak sederhana, namun merupakan cara

115
00:06:30,850 --> 00:06:34,389
yang sangat elegan untuk menyaring gagasan perubahan di bagian

116
00:06:34,389 --> 00:06:37,760
mana pun dalam pesan agar tercermin dalam sedikit informasi.

117
00:06:37,760 --> 00:06:43,916
Perhatikan jika ada bagian dari pesan ini yang dibalik, baik dari 0 ke 1 atau 1 ke 0,

118
00:06:43,916 --> 00:06:48,140
ini akan mengubah jumlah total 1 dari genap menjadi ganjil.

119
00:06:48,140 --> 00:06:50,896
Jadi jika Anda adalah penerimanya, Anda melihat pesan ini,

120
00:06:50,896 --> 00:06:54,307
dan Anda melihat angka 1 yang ganjil, Anda dapat mengetahui dengan pasti

121
00:06:54,307 --> 00:06:57,672
bahwa telah terjadi kesalahan, meskipun Anda mungkin tidak tahu di mana

122
00:06:57,672 --> 00:06:58,700
kesalahan itu terjadi.

123
00:06:58,700 --> 00:07:01,977
Dalam jargon, apakah sekelompok bit memiliki jumlah

124
00:07:01,977 --> 00:07:04,940
1 genap atau ganjil dikenal sebagai paritasnya.

125
00:07:04,940 --> 00:07:08,259
Anda juga dapat menggunakan angka dan mengatakan paritasnya adalah 0 atau 1,

126
00:07:08,259 --> 00:07:11,320
yang biasanya lebih berguna setelah Anda mulai menghitung ide tersebut.

127
00:07:11,320 --> 00:07:18,020
Dan bit khusus yang digunakan pengirim untuk mengontrol paritas disebut bit paritas.

128
00:07:18,020 --> 00:07:21,612
Dan sebenarnya harus jelas, jika penerima melihat paritas ganjil,

129
00:07:21,612 --> 00:07:25,586
bukan berarti hanya ada satu kesalahan, mungkin ada 3 kesalahan, atau 5,

130
00:07:25,586 --> 00:07:29,560
atau angka ganjil lainnya, tapi mereka bisa tahu pasti bahwa itu bukan 0.

131
00:07:29,560 --> 00:07:33,612
Di sisi lain, jika terdapat 2 kesalahan, atau jumlah kesalahan berapapun,

132
00:07:33,612 --> 00:07:36,514
jumlah akhir dari 1 detik tersebut akan tetap genap,

133
00:07:36,514 --> 00:07:40,950
sehingga penerima tidak dapat yakin sepenuhnya bahwa jumlah kesalahan yang genap

134
00:07:40,950 --> 00:07:43,360
berarti pesan tersebut bebas dari kesalahan.

135
00:07:43,360 --> 00:07:46,560
Anda mungkin mengeluh bahwa pesan yang menjadi kacau hanya

136
00:07:46,560 --> 00:07:49,760
dengan pembalikan 2 bit cukup lemah, dan Anda memang benar.

137
00:07:49,760 --> 00:07:53,006
Namun perlu diingat, tidak ada metode deteksi atau koreksi

138
00:07:53,006 --> 00:07:56,363
kesalahan yang dapat memberi Anda keyakinan 100% bahwa pesan

139
00:07:56,363 --> 00:07:59,720
yang Anda terima adalah pesan yang dimaksudkan oleh pengirim.

140
00:07:59,720 --> 00:08:02,820
Lagi pula, gangguan acak yang cukup selalu dapat mengubah satu

141
00:08:02,820 --> 00:08:05,920
pesan valid menjadi pesan valid lainnya hanya secara kebetulan.

142
00:08:05,920 --> 00:08:11,111
Sebaliknya, tujuannya adalah untuk menghasilkan skema yang kuat hingga jumlah kesalahan

143
00:08:11,111 --> 00:08:16,244
maksimum tertentu, atau mungkin untuk mengurangi kemungkinan kesalahan positif seperti

144
00:08:16,244 --> 00:08:16,480
ini.

145
00:08:16,480 --> 00:08:20,250
Pemeriksaan paritas sendiri cukup lemah, namun dengan menyaring gagasan

146
00:08:20,250 --> 00:08:23,130
perubahan dari seluruh pesan menjadi satu bagian saja,

147
00:08:23,130 --> 00:08:27,005
apa yang mereka berikan kepada kita adalah landasan yang kuat untuk skema

148
00:08:27,005 --> 00:08:28,000
yang lebih canggih.

149
00:08:28,000 --> 00:08:31,502
Misalnya, saat Hamming sedang mencari cara untuk mengidentifikasi di mana

150
00:08:31,502 --> 00:08:34,059
kesalahan terjadi, bukan hanya kesalahan itu terjadi,

151
00:08:34,059 --> 00:08:37,846
wawasan utamanya adalah jika Anda menerapkan beberapa pemeriksaan paritas bukan

152
00:08:37,846 --> 00:08:41,822
pada keseluruhan pesan, namun pada subkumpulan tertentu yang dipilih dengan cermat,

153
00:08:41,822 --> 00:08:45,467
Anda dapat bertanya serangkaian pertanyaan yang lebih halus yang menjelaskan

154
00:08:45,467 --> 00:08:46,840
lokasi kesalahan bit tunggal.

155
00:08:46,840 --> 00:08:50,240
Perasaan keseluruhannya seperti memainkan permainan 20 pertanyaan,

156
00:08:50,240 --> 00:08:54,300
menanyakan pertanyaan ya atau tidak yang memotong ruang kemungkinan menjadi dua.

157
00:08:54,300 --> 00:08:58,834
Sebagai contoh, katakanlah kita melakukan pemeriksaan paritas hanya pada 8 bit ini,

158
00:08:58,834 --> 00:09:00,400
semua posisi bernomor ganjil.

159
00:09:00,400 --> 00:09:04,628
Kemudian jika terdeteksi adanya error, maka akan memberikan sedikit informasi lebih

160
00:09:04,628 --> 00:09:09,160
kepada penerima mengenai di mana tepatnya error tersebut berada, yaitu pada posisi ganjil.

161
00:09:09,160 --> 00:09:12,972
Jika tidak ada kesalahan yang terdeteksi di antara 8 bit tersebut,

162
00:09:12,972 --> 00:09:17,240
itu berarti tidak ada kesalahan sama sekali, atau berada pada posisi genap.

163
00:09:17,240 --> 00:09:21,612
Anda mungkin berpikir bahwa membatasi pemeriksaan paritas hingga setengah bit membuatnya

164
00:09:21,612 --> 00:09:25,740
kurang efektif, namun jika dilakukan bersamaan dengan pemeriksaan lain yang dipilih

165
00:09:25,740 --> 00:09:29,720
dengan baik, hal ini secara berlawanan memberi kita sesuatu yang jauh lebih kuat.

166
00:09:29,720 --> 00:09:32,834
Untuk benar-benar menyiapkan pemeriksaan paritas tersebut, ingat,

167
00:09:32,834 --> 00:09:36,656
diperlukan pengalokasian beberapa bit khusus yang memiliki kontrol untuk paritas

168
00:09:36,656 --> 00:09:37,600
grup penuh tersebut.

169
00:09:37,600 --> 00:09:39,920
Disini kita pilih saja posisi 1.

170
00:09:39,920 --> 00:09:43,189
Pada contoh yang ditunjukkan, paritas 8 bit ini saat ini ganjil,

171
00:09:43,189 --> 00:09:46,861
sehingga pengirim bertanggung jawab untuk mengubah bit paritas tersebut,

172
00:09:46,861 --> 00:09:48,220
dan sekarang menjadi genap.

173
00:09:48,220 --> 00:09:51,040
Ini hanya 1 dari 4 pemeriksaan paritas yang akan kami lakukan.

174
00:09:51,040 --> 00:09:54,211
Pemeriksaan kedua adalah di antara 8 bit di bagian kanan grid,

175
00:09:54,211 --> 00:09:56,880
setidaknya seperti yang telah kita gambarkan di sini.

176
00:09:56,880 --> 00:10:00,494
Kali ini kita mungkin menggunakan posisi 2 sebagai bit paritas,

177
00:10:00,494 --> 00:10:03,770
jadi 8 bit ini sudah memiliki paritas genap, dan pengirim

178
00:10:03,770 --> 00:10:07,160
akan merasa senang membiarkan bit nomor 2 itu tidak berubah.

179
00:10:07,160 --> 00:10:10,078
Kemudian di sisi lain, jika penerima memeriksa paritas grup ini

180
00:10:10,078 --> 00:10:13,224
dan mereka menemukan bahwa paritasnya ganjil, mereka akan mengetahui

181
00:10:13,224 --> 00:10:15,960
bahwa kesalahannya ada di antara 8 bit di sebelah kanan ini.

182
00:10:15,960 --> 00:10:21,260
Kalau tidak, berarti tidak ada kesalahan, atau kesalahannya ada di bagian kiri.

183
00:10:21,260 --> 00:10:24,106
Atau saya kira mungkin ada dua kesalahan, tapi untuk saat ini kita

184
00:10:24,106 --> 00:10:27,080
akan berasumsi bahwa paling banyak ada satu kesalahan di seluruh blok.

185
00:10:27,080 --> 00:10:29,160
Segala sesuatunya rusak total karena lebih dari itu.

186
00:10:29,160 --> 00:10:30,981
Di sini, sebelum kita melihat dua pemeriksaan berikutnya,

187
00:10:30,981 --> 00:10:33,116
luangkan waktu sejenak untuk memikirkan tentang apa yang dapat kita

188
00:10:33,116 --> 00:10:35,880
lakukan dari dua pemeriksaan pertama ketika Anda mempertimbangkan keduanya bersama-sama.

189
00:10:35,880 --> 00:10:40,240
Katakanlah Anda mendeteksi kesalahan di antara kolom ganjil, dan di paruh kanan.

190
00:10:40,240 --> 00:10:43,940
Ini berarti kesalahannya ada di kolom terakhir.

191
00:10:43,940 --> 00:10:47,724
Jika tidak ada kesalahan pada kolom ganjil namun ada satu kesalahan pada separuh kanan,

192
00:10:47,724 --> 00:10:50,520
berarti kesalahan tersebut berada pada kolom kedua dari terakhir.

193
00:10:50,520 --> 00:10:54,446
Begitu pula jika ada kesalahan di kolom ganjil tetapi tidak di separuh kanan,

194
00:10:54,446 --> 00:10:56,560
Anda tahu kesalahannya ada di kolom kedua.

195
00:10:56,560 --> 00:11:00,221
Dan jika tidak satu pun dari kedua pemeriksaan paritas tersebut yang mendeteksi apa pun,

196
00:11:00,221 --> 00:11:03,760
berarti satu-satunya tempat terjadinya kesalahan adalah di kolom paling kiri tersebut.

197
00:11:03,760 --> 00:11:06,480
Tapi itu juga mungkin berarti tidak ada kesalahan sama sekali.

198
00:11:06,480 --> 00:11:08,994
Ini merupakan cara yang agak rumit untuk mengatakan

199
00:11:08,994 --> 00:11:11,800
bahwa dua pemeriksaan paritas mari kita tentukan kolomnya.

200
00:11:11,800 --> 00:11:14,000
Dari sini, Anda mungkin bisa menebak berikut ini.

201
00:11:14,000 --> 00:11:16,240
Pada dasarnya kami melakukan hal yang sama tetapi untuk barisnya.

202
00:11:16,240 --> 00:11:21,040
Akan ada pemeriksaan paritas pada baris ganjil, menggunakan posisi 4 sebagai bit paritas.

203
00:11:21,040 --> 00:11:24,819
Jadi dalam contoh ini grup tersebut sudah memiliki paritas genap,

204
00:11:24,819 --> 00:11:26,480
jadi bit 4 akan disetel ke 0.

205
00:11:26,480 --> 00:11:29,971
Dan terakhir ada pemeriksaan paritas pada dua baris terbawah,

206
00:11:29,971 --> 00:11:32,280
menggunakan posisi 8 sebagai bit paritas.

207
00:11:32,280 --> 00:11:35,037
Dalam hal ini, sepertinya pengirim perlu mengaktifkan bit 8

208
00:11:35,037 --> 00:11:37,840
tersebut untuk memberikan keseimbangan yang merata pada grup.

209
00:11:37,840 --> 00:11:40,714
Sama seperti dua pemeriksaan pertama yang memungkinkan kita menentukan kolom,

210
00:11:40,714 --> 00:11:43,000
dua pemeriksaan berikutnya memungkinkan Anda menentukan baris.

211
00:11:43,000 --> 00:11:48,400
Sebagai contoh, bayangkan selama transmisi terjadi kesalahan pada, katakanlah, posisi 3.

212
00:11:48,400 --> 00:11:52,484
Ini mempengaruhi kelompok paritas pertama, dan juga mempengaruhi kelompok paritas kedua,

213
00:11:52,484 --> 00:11:56,340
sehingga penerima mengetahui bahwa ada kesalahan di suatu tempat di kolom kanan itu.

214
00:11:56,340 --> 00:12:01,380
Tapi itu tidak mempengaruhi kelompok ketiga, dan tidak mempengaruhi kelompok keempat.

215
00:12:01,380 --> 00:12:04,946
Dan itu memungkinkan penerima menentukan kesalahan hingga baris pertama,

216
00:12:04,946 --> 00:12:08,660
yang berarti posisi 3, sehingga mereka dapat memperbaiki kesalahan tersebut.

217
00:12:08,660 --> 00:12:11,605
Anda mungkin senang meluangkan waktu sejenak untuk meyakinkan diri

218
00:12:11,605 --> 00:12:14,330
sendiri bahwa jawaban atas keempat pertanyaan ini akan selalu

219
00:12:14,330 --> 00:12:17,320
memungkinkan Anda menentukan lokasi tertentu, di mana pun lokasinya.

220
00:12:17,320 --> 00:12:20,379
Faktanya, orang yang cerdik di antara Anda mungkin menyadari

221
00:12:20,379 --> 00:12:23,640
hubungan antara pertanyaan-pertanyaan ini dan penghitungan biner.

222
00:12:23,640 --> 00:12:26,798
Dan jika Anda melakukannya, sekali lagi izinkan saya menekankan,

223
00:12:26,798 --> 00:12:30,880
berhenti sejenak, cobalah sendiri untuk menarik hubungannya sebelum saya merusaknya.

224
00:12:30,880 --> 00:12:35,424
Jika Anda bertanya-tanya apa yang terjadi jika bit paritas itu sendiri terpengaruh,

225
00:12:35,424 --> 00:12:36,560
Anda bisa mencobanya.

226
00:12:36,560 --> 00:12:41,969
Luangkan waktu sejenak untuk memikirkan bagaimana kesalahan apa pun di antara empat bit

227
00:12:41,969 --> 00:12:47,440
khusus ini akan dilacak seperti yang lainnya, dengan kelompok empat pertanyaan yang sama.

228
00:12:47,440 --> 00:12:50,540
Hal ini tidak menjadi masalah, karena pada akhirnya yang kita inginkan

229
00:12:50,540 --> 00:12:53,640
adalah melindungi bit pesan, bit koreksi kesalahan akan terus berjalan.

230
00:12:53,640 --> 00:12:56,389
Namun melindungi bagian-bagian tersebut juga merupakan sesuatu yang

231
00:12:56,389 --> 00:12:59,260
secara alami tidak termasuk dalam skema dan merupakan produk sampingan.

232
00:12:59,260 --> 00:13:02,380
Anda mungkin juga senang mengantisipasi bagaimana skalanya.

233
00:13:02,380 --> 00:13:06,239
Jika kita menggunakan blok berukuran 256 bit, misalnya,

234
00:13:06,239 --> 00:13:10,787
untuk menentukan lokasi, Anda hanya memerlukan delapan pertanyaan

235
00:13:10,787 --> 00:13:15,680
ya atau tidak untuk melakukan pencarian biner hingga ke titik tertentu.

236
00:13:15,680 --> 00:13:19,543
Dan ingat, setiap pertanyaan hanya memerlukan penyerahan

237
00:13:19,543 --> 00:13:23,340
satu bit untuk mengatur pemeriksaan paritas yang sesuai.

238
00:13:23,340 --> 00:13:26,725
Beberapa dari Anda mungkin sudah melihatnya, tetapi nanti kita akan membahas tentang cara

239
00:13:26,725 --> 00:13:29,960
sistematis untuk mengetahui pertanyaan-pertanyaan ini hanya dalam satu atau dua menit.

240
00:13:29,960 --> 00:13:32,589
Semoga sketsa ini cukup untuk mengapresiasi efisiensi

241
00:13:32,589 --> 00:13:34,440
dari apa yang kami kembangkan di sini.

242
00:13:34,440 --> 00:13:37,163
Hal pertama, kecuali delapan bit paritas yang disorot,

243
00:13:37,163 --> 00:13:40,779
dapat berupa apa pun yang Anda inginkan, membawa pesan atau data apa pun

244
00:13:40,779 --> 00:13:41,720
yang Anda inginkan.

245
00:13:41,720 --> 00:13:47,352
8 bit tersebut mubazir dalam arti bahwa mereka sepenuhnya ditentukan oleh sisa pesan,

246
00:13:47,352 --> 00:13:51,413
namun ini adalah cara yang jauh lebih cerdas daripada sekadar

247
00:13:51,413 --> 00:13:53,640
menyalin pesan secara keseluruhan.

248
00:13:53,640 --> 00:13:56,367
Dan tetap saja, dengan sedikit menyerah, Anda akan dapat

249
00:13:56,367 --> 00:13:59,000
mengidentifikasi dan memperbaiki kesalahan bit apa pun.

250
00:13:59,000 --> 00:14:00,400
Hampir saja.

251
00:14:00,400 --> 00:14:04,500
Oke, jadi satu-satunya masalah di sini adalah jika tidak satu pun dari empat

252
00:14:04,500 --> 00:14:07,003
pemeriksaan paritas yang mendeteksi kesalahan,

253
00:14:07,003 --> 00:14:11,316
artinya subset 8 bit yang dipilih secara khusus semuanya memiliki paritas genap,

254
00:14:11,316 --> 00:14:15,789
seperti yang diinginkan pengirim, maka itu berarti tidak ada kesalahan sama sekali.

255
00:14:15,789 --> 00:14:17,760
, atau mempersempit kita ke posisi 0.

256
00:14:17,760 --> 00:14:20,369
Anda tahu, dengan empat pertanyaan ya atau tidak,

257
00:14:20,369 --> 00:14:23,866
kami memiliki 16 kemungkinan hasil untuk pemeriksaan paritas kami,

258
00:14:23,866 --> 00:14:27,780
dan pada awalnya itu terasa sempurna untuk menunjukkan dengan tepat 1 dari

259
00:14:27,780 --> 00:14:31,538
16 posisi di blok, tetapi Anda juga perlu mengomunikasikan hasil ke-17,

260
00:14:31,538 --> 00:14:33,000
tidak ada kesalahan kondisi.

261
00:14:33,000 --> 00:14:37,860
Solusinya di sini sebenarnya cukup sederhana, lupakan saja bit ke-0 itu sepenuhnya.

262
00:14:37,860 --> 00:14:42,568
Jadi ketika kita melakukan empat pemeriksaan paritas dan kita melihat semuanya genap,

263
00:14:42,568 --> 00:14:44,320
itu berarti tidak ada kesalahan.

264
00:14:44,320 --> 00:14:49,262
Artinya, daripada bekerja dengan blok 16-bit, kami bekerja dengan blok 15-bit,

265
00:14:49,262 --> 00:14:54,080
di mana 11 bit bebas untuk membawa pesan dan 4 di antaranya untuk redundansi.

266
00:14:54,080 --> 00:14:56,489
Dan dengan itu, kami sekarang memiliki apa yang oleh

267
00:14:56,489 --> 00:14:59,400
orang-orang dalam bisnis ini disebut sebagai kode 15-11 Hamming.

268
00:14:59,400 --> 00:15:03,121
Meskipun demikian, menyenangkan untuk memiliki ukuran blok dengan pangkat bersih 2,

269
00:15:03,121 --> 00:15:06,177
dan ada cara cerdas agar kita dapat mempertahankan bit ke-0 tersebut

270
00:15:06,177 --> 00:15:08,880
dan membuatnya melakukan sedikit pekerjaan ekstra untuk kita.

271
00:15:08,880 --> 00:15:11,934
Jika kita menggunakannya sebagai bit paritas di seluruh blok,

272
00:15:11,934 --> 00:15:16,320
ini memungkinkan kita mendeteksi, meskipun kita tidak dapat memperbaiki, kesalahan 2-bit.

273
00:15:16,320 --> 00:15:17,440
Begini cara kerjanya.

274
00:15:17,440 --> 00:15:20,336
Setelah menyetel keempat bit koreksi kesalahan khusus tersebut,

275
00:15:20,336 --> 00:15:23,956
kami menyetel bit ke-0 tersebut sehingga paritas dari blok penuh menjadi genap,

276
00:15:23,956 --> 00:15:25,540
seperti pemeriksaan paritas normal.

277
00:15:25,540 --> 00:15:29,764
Sekarang, jika ada kesalahan bit tunggal, maka paritas blok penuh akan berubah menjadi

278
00:15:29,764 --> 00:15:33,940
ganjil, namun kita akan tetap menangkapnya berkat empat pemeriksaan koreksi kesalahan.

279
00:15:33,940 --> 00:15:38,355
Namun, jika ada dua kesalahan, maka keseluruhan paritas akan kembali menjadi genap,

280
00:15:38,355 --> 00:15:42,245
namun penerima masih akan melihat bahwa setidaknya ada beberapa kesalahan

281
00:15:42,245 --> 00:15:45,820
karena apa yang terjadi dengan keempat pemeriksaan paritas tersebut.

282
00:15:45,820 --> 00:15:48,423
Jadi, jika mereka melihat adanya paritas yang genap secara keseluruhan,

283
00:15:48,423 --> 00:15:50,701
namun terjadi sesuatu yang bukan nol pada pemeriksaan lainnya,

284
00:15:50,701 --> 00:15:52,980
hal ini memberi tahu mereka bahwa setidaknya ada dua kesalahan.

285
00:15:52,980 --> 00:15:54,420
Bukankah itu pintar?

286
00:15:54,420 --> 00:15:57,776
Meskipun kami tidak dapat memperbaiki kesalahan 2-bit tersebut,

287
00:15:57,776 --> 00:16:02,340
hanya dengan mengembalikan satu bit ke-0 yang mengganggu itu, kami dapat mendeteksinya.

288
00:16:02,340 --> 00:16:06,540
Ini cukup standar, dikenal sebagai kode Hamming yang diperluas.

289
00:16:06,540 --> 00:16:11,468
Secara teknis, Anda sekarang memiliki gambaran lengkap tentang fungsi kode Hamming,

290
00:16:11,468 --> 00:16:13,580
setidaknya untuk contoh blok 16-bit.

291
00:16:13,580 --> 00:16:16,319
Namun saya pikir Anda akan merasa lebih puas jika memeriksa

292
00:16:16,319 --> 00:16:19,195
pemahaman Anda dan memantapkan semuanya hingga saat ini dengan

293
00:16:19,195 --> 00:16:21,980
melakukan sendiri satu contoh lengkap dari awal hingga akhir.

294
00:16:21,980 --> 00:16:25,100
Saya akan membahasnya bersama Anda sehingga Anda dapat memeriksanya sendiri.

295
00:16:25,100 --> 00:16:28,753
Untuk menyiapkan pesan, apakah itu pesan literal yang Anda terjemahkan

296
00:16:28,753 --> 00:16:32,715
melalui ruang atau beberapa data yang ingin Anda simpan dari waktu ke waktu,

297
00:16:32,715 --> 00:16:35,700
langkah pertama adalah membaginya menjadi potongan 11-bit.

298
00:16:35,700 --> 00:16:40,340
Setiap potongan akan dikemas ke dalam blok 16-bit yang tahan kesalahan.

299
00:16:40,340 --> 00:16:43,740
Jadi mari kita ambil yang ini sebagai contoh dan kerjakan.

300
00:16:43,740 --> 00:16:45,380
Silakan, lakukanlah!

301
00:16:45,380 --> 00:16:52,980
Mari kita berhenti sejenak dan mencoba menyusun blok ini.

302
00:16:52,980 --> 00:16:53,980
Oke, kamu siap?

303
00:16:53,980 --> 00:16:59,467
Ingat, posisi 0 dan pangkat 2 lainnya dicadangkan untuk tugas koreksi kesalahan,

304
00:16:59,467 --> 00:17:04,548
jadi Anda mulai dengan menempatkan bit pesan di semua tempat yang tersisa,

305
00:17:04,548 --> 00:17:05,700
secara berurutan.

306
00:17:05,700 --> 00:17:09,698
Anda memerlukan grup ini untuk memiliki paritas genap, yang sudah dimilikinya,

307
00:17:09,698 --> 00:17:13,140
jadi Anda harus menyetel bit paritas tersebut di posisi 1 menjadi 0.

308
00:17:13,140 --> 00:17:16,105
Grup berikutnya dimulai dengan paritas ganjil,

309
00:17:16,105 --> 00:17:19,260
jadi Anda harus menyetel bit paritasnya menjadi 1.

310
00:17:19,260 --> 00:17:21,765
Grup setelah itu dimulai dengan paritas ganjil,

311
00:17:21,765 --> 00:17:24,740
jadi sekali lagi Anda harus menyetel bit paritasnya ke 1.

312
00:17:24,740 --> 00:17:27,890
Dan grup terakhir juga memiliki paritas ganjil,

313
00:17:27,890 --> 00:17:31,500
artinya bit tersebut kita atur pada posisi 8 menjadi 1.

314
00:17:31,500 --> 00:17:36,433
Dan sebagai langkah terakhir, blok penuh sekarang memiliki paritas genap,

315
00:17:36,433 --> 00:17:41,500
artinya Anda dapat mengatur bit nomor 0, bit paritas keseluruhan, menjadi 0.

316
00:17:41,500 --> 00:17:45,159
Jadi ketika blok ini dilepaskan, paritas dari empat himpunan bagian

317
00:17:45,159 --> 00:17:48,980
khusus dan blok secara keseluruhan semuanya akan menjadi genap, atau 0.

318
00:17:48,980 --> 00:17:53,620
Sebagai bagian kedua dari latihan ini, biarkan Anda berperan sebagai penerima.

319
00:17:53,620 --> 00:17:56,535
Tentu saja itu berarti Anda belum mengetahui apa pesan ini,

320
00:17:56,535 --> 00:18:00,180
mungkin sebagian dari Anda sudah menghafalnya, tapi anggap saja Anda belum.

321
00:18:00,180 --> 00:18:04,625
Apa yang akan saya lakukan adalah mengubah 0, 1, atau 2 bit di blok itu,

322
00:18:04,625 --> 00:18:08,340
dan kemudian meminta Anda mencari tahu apa yang saya lakukan.

323
00:18:08,340 --> 00:18:13,460
Jadi sekali lagi, jeda dan coba kerjakan.

324
00:18:13,460 --> 00:18:21,185
Oke, jadi Anda sebagai penerima sekarang periksa grup paritas pertama dan Anda dapat

325
00:18:21,185 --> 00:18:29,274
melihat bahwa grup tersebut genap, jadi kesalahan apa pun yang ada pasti berada di kolom

326
00:18:29,274 --> 00:18:29,820
genap.

327
00:18:29,820 --> 00:18:32,579
Pemeriksaan berikutnya memberi kita angka ganjil,

328
00:18:32,579 --> 00:18:36,000
memberi tahu kita berdua bahwa setidaknya ada satu kesalahan,

329
00:18:36,000 --> 00:18:38,760
dan mempersempit kita ke dalam kolom spesifik ini.

330
00:18:38,760 --> 00:18:42,900
Pemeriksaan ketiga bersifat genap, mengurangi kemungkinan lebih jauh lagi.

331
00:18:42,900 --> 00:18:45,399
Dan pemeriksaan paritas terakhir adalah ganjil,

332
00:18:45,399 --> 00:18:48,731
memberi tahu kita bahwa ada kesalahan di suatu tempat di bawah,

333
00:18:48,731 --> 00:18:51,700
yang sekarang kita lihat pasti berada di posisi nomor 10.

334
00:18:51,700 --> 00:18:55,056
Terlebih lagi, paritas seluruh blok ganjil, memberi

335
00:18:55,056 --> 00:18:58,220
kita keyakinan bahwa ada satu flip dan bukan dua.

336
00:18:58,220 --> 00:19:01,600
Jika jumlahnya tiga atau lebih, semua taruhan dibatalkan.

337
00:19:01,600 --> 00:19:06,412
Setelah mengoreksi bit nomor 10 itu, mengeluarkan 11 bit yang tidak digunakan

338
00:19:06,412 --> 00:19:10,360
untuk koreksi memberi kita segmen yang relevan dari pesan asli,

339
00:19:10,360 --> 00:19:15,172
yang jika Anda memutar ulang dan membandingkannya memang persis dengan contoh

340
00:19:15,172 --> 00:19:16,160
yang kita mulai.

341
00:19:16,160 --> 00:19:19,026
Dan sekarang setelah Anda mengetahui cara melakukan semua ini dengan tangan,

342
00:19:19,026 --> 00:19:21,557
saya ingin menunjukkan kepada Anda bagaimana Anda dapat menjalankan

343
00:19:21,557 --> 00:19:23,940
bagian inti dari semua logika ini dengan satu baris kode Python.

344
00:19:23,940 --> 00:19:27,656
Anda tahu, apa yang belum saya sampaikan kepada Anda adalah betapa elegannya

345
00:19:27,656 --> 00:19:31,470
algoritma ini, betapa sederhananya membuat mesin menunjukkan posisi kesalahan,

346
00:19:31,470 --> 00:19:35,814
bagaimana menskalakannya secara sistematis, dan bagaimana kita dapat membingkai semuanya.

347
00:19:35,814 --> 00:19:39,580
ini sebagai satu operasi tunggal, bukan beberapa pemeriksaan paritas terpisah.

348
00:19:39,580 --> 00:19:39,580
Untuk memahami maksud saya, bergabunglah dengan saya di bagian 2.

