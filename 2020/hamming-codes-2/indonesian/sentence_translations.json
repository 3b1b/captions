[
 {
  "input": "I'm assuming that everybody here is coming from part 1.",
  "model": "nmt",
  "translatedText": "Saya berasumsi bahwa semua orang di sini berasal dari bagian 1.",
  "time_range": [
   0.0,
   2.56
  ]
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it.",
  "model": "nmt",
  "translatedText": "Kita berbicara tentang kode Hamming, suatu cara untuk membuat blok data yang sebagian besar bitnya membawa pesan yang bermakna, sementara beberapa bit lainnya bertindak sebagai semacam redundansi, sedemikian rupa sehingga jika ada bit yang dibalik, maka akan muncul pesan. bit atau bit redundansi, apa pun di blok ini, penerima akan dapat mengidentifikasi kesalahan yang terjadi, dan cara memperbaikinya.",
  "time_range": [
   3.06,
   21.24
  ]
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error.",
  "model": "nmt",
  "translatedText": "Ide dasar yang disajikan di sana adalah bagaimana menggunakan beberapa pemeriksaan paritas untuk mencari biner hingga menemukan kesalahan.",
  "time_range": [
   21.88,
   27.16
  ]
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible.",
  "model": "nmt",
  "translatedText": "Dalam video tersebut, tujuannya adalah untuk membuat kode Hamming terasa mudah dan mudah ditemukan kembali.",
  "time_range": [
   28.980000000000008,
   34.6
  ]
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are.",
  "model": "nmt",
  "translatedText": "Namun saat Anda mulai berpikir untuk mengimplementasikannya, baik dalam perangkat lunak maupun perangkat keras, pembingkaian tersebut mungkin meremehkan betapa elegannya kode-kode ini.",
  "time_range": [
   35.18,
   43.46
  ]
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that.",
  "model": "nmt",
  "translatedText": "Anda mungkin berpikir bahwa Anda perlu menulis algoritma yang melacak semua kemungkinan lokasi kesalahan dan memotong kelompok itu menjadi dua dengan setiap pemeriksaan, tetapi sebenarnya jauh lebih sederhana dari itu.",
  "time_range": [
   43.92,
   53.48
  ]
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary.",
  "model": "nmt",
  "translatedText": "Jika Anda membacakan jawaban atas empat pemeriksaan paritas yang kami lakukan di video terakhir, semuanya dalam angka 1 dan 0, bukan ya dan tidak, maka secara harfiah posisi kesalahan akan dijabarkan dalam biner.",
  "time_range": [
   53.94,
   64.08
  ]
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1.",
  "model": "nmt",
  "translatedText": "Misalnya, angka 7 dalam biner terlihat seperti 0111, yang pada dasarnya berarti 4 ditambah 2 ditambah 1.",
  "time_range": [
   64.78,
   71.26
  ]
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last.",
  "model": "nmt",
  "translatedText": "Dan perhatikan di mana posisi 7 berada, itu memang mempengaruhi kelompok paritas pertama kita, dan kelompok paritas kedua, dan ketiga, tapi bukan yang terakhir.",
  "time_range": [
   72.54,
   81.74
  ]
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error.",
  "model": "nmt",
  "translatedText": "Jadi membaca hasil keempat pemeriksaan tersebut dari bawah ke atas memang menunjukkan posisi kesalahannya.",
  "time_range": [
   82.22,
   87.54
  ]
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple.",
  "model": "nmt",
  "translatedText": "Tidak ada yang istimewa dari contoh 7, ini berfungsi secara umum, dan ini membuat logika untuk mengimplementasikan keseluruhan skema pada perangkat keras menjadi sangat sederhana.",
  "time_range": [
   88.32,
   95.82
  ]
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111.",
  "model": "nmt",
  "translatedText": "Sekarang jika Anda ingin melihat mengapa keajaiban ini terjadi, ambil 16 label indeks ini untuk posisi kita, tapi daripada menuliskannya dalam basis 10, mari kita tulis semuanya dalam biner, mulai dari 0000 hingga 1111.",
  "time_range": [
   97.24,
   109.88
  ]
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent.",
  "model": "nmt",
  "translatedText": "Saat kita mengembalikan label biner ini ke dalam kotaknya, izinkan saya menekankan bahwa label tersebut berbeda dari data yang sebenarnya dikirim.",
  "time_range": [
   110.55999999999999,
   117.8
  ]
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from.",
  "model": "nmt",
  "translatedText": "Itu tidak lebih dari sebuah label konseptual untuk membantu Anda dan saya memahami dari mana empat kelompok paritas itu berasal.",
  "time_range": [
   118.32,
   123.5
  ]
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary.",
  "model": "nmt",
  "translatedText": "Keanggunan dalam mendeskripsikan segala sesuatu yang kita lihat dalam biner mungkin dilemahkan oleh kebingungan karena segala sesuatu yang kita lihat dijelaskan dalam biner.",
  "time_range": [
   124.14,
   132.36
  ]
 },
 {
  "input": "It's worth it, though.",
  "model": "nmt",
  "translatedText": "Tapi itu sepadan.",
  "time_range": [
   133.02,
   134.12
  ]
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1.",
  "model": "nmt",
  "translatedText": "Fokuskan perhatian Anda hanya pada bagian terakhir dari semua label ini, lalu sorot posisi di mana bagian terakhir tersebut adalah 1.",
  "time_range": [
   134.8,
   143.22
  ]
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1?",
  "model": "nmt",
  "translatedText": "Apa yang kita dapatkan adalah yang pertama dari empat kelompok paritas, yang berarti Anda dapat menafsirkan pemeriksaan pertama itu sebagai pertanyaan, hei, jika ada kesalahan, apakah bit terakhir pada posisi kesalahan itu adalah 1?",
  "time_range": [
   144.24,
   155.74
  ]
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme.",
  "model": "nmt",
  "translatedText": "Demikian pula, jika Anda fokus pada bit kedua hingga terakhir, dan menyorot semua posisi yang bernilai 1, Anda mendapatkan grup paritas kedua dari skema kami.",
  "time_range": [
   158.2,
   166.16
  ]
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1?",
  "model": "nmt",
  "translatedText": "Dengan kata lain, pengecekan kedua itu menanyakan, hai, sekali lagi, jika ada kesalahan, apakah bit kedua dari posisi terakhir itu adalah 1?",
  "time_range": [
   166.74,
   174.5
  ]
 },
 {
  "input": "And so on.",
  "model": "nmt",
  "translatedText": "Dan seterusnya.",
  "time_range": [
   175.76,
   176.9
  ]
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1.",
  "model": "nmt",
  "translatedText": "Pemeriksaan paritas ketiga mencakup setiap posisi yang bit ketiga hingga terakhirnya diaktifkan, dan yang terakhir mencakup delapan posisi terakhir, yaitu posisi yang bit urutan tertingginya adalah 1.",
  "time_range": [
   177.22,
   188.74
  ]
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary.",
  "model": "nmt",
  "translatedText": "Semua yang kita lakukan sebelumnya sama dengan menjawab keempat pertanyaan tersebut, yang pada gilirannya sama dengan mengeja posisi dalam biner.",
  "time_range": [
   189.74,
   197.74
  ]
 },
 {
  "input": "I hope this makes two things clearer.",
  "model": "nmt",
  "translatedText": "Saya harap ini membuat dua hal menjadi lebih jelas.",
  "time_range": [
   199.62,
   201.48
  ]
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two.",
  "model": "nmt",
  "translatedText": "Yang pertama adalah bagaimana menggeneralisasi secara sistematis ke ukuran blok yang merupakan pangkat dua yang lebih besar.",
  "time_range": [
   202.04,
   206.46
  ]
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check.",
  "model": "nmt",
  "translatedText": "Jika diperlukan lebih banyak bit untuk mendeskripsikan setiap posisi, seperti enam bit untuk mendeskripsikan 64 titik, maka setiap bit tersebut memberi Anda salah satu grup paritas yang perlu kita periksa.",
  "time_range": [
   206.96,
   216.68
  ]
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar.",
  "model": "nmt",
  "translatedText": "Bagi Anda yang menonton teka-teki papan catur yang saya buat bersama Matt Parker mungkin menganggap semua ini sangat familiar.",
  "time_range": [
   218.4,
   223.18
  ]
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard.",
  "model": "nmt",
  "translatedText": "Logika intinya sama, tetapi memecahkan masalah yang berbeda, dan diterapkan pada papan catur berukuran 64 kotak.",
  "time_range": [
   223.66,
   228.78
  ]
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8.",
  "model": "nmt",
  "translatedText": "Hal kedua yang saya harap dapat dijelaskan adalah mengapa bit paritas kita berada pada posisi pangkat dua, misalnya 1, 2, 4, dan 8.",
  "time_range": [
   229.88,
   237.32
  ]
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on.",
  "model": "nmt",
  "translatedText": "Ini adalah posisi yang representasi binernya hanya diaktifkan satu bit.",
  "time_range": [
   238.0,
   243.0
  ]
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups.",
  "model": "nmt",
  "translatedText": "Artinya, masing-masing bit paritas tersebut berada di dalam satu dan hanya satu dari empat grup paritas.",
  "time_range": [
   243.6,
   249.46
  ]
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups.",
  "model": "nmt",
  "translatedText": "Anda juga dapat melihat ini dalam contoh yang lebih besar, di mana tidak peduli seberapa besar yang Anda dapatkan, setiap bit paritas hanya menyentuh salah satu grup.",
  "time_range": [
   252.04,
   259.34
  ]
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code.",
  "model": "nmt",
  "translatedText": "Setelah Anda memahami bahwa pemeriksaan paritas yang telah kita fokuskan sebagian besar waktu kita tidak lebih dari cara cerdas untuk menguraikan posisi kesalahan dalam biner, maka kita dapat menghubungkannya dengan cara berpikir yang berbeda tentang hamming. kode, yang bisa dibilang jauh lebih sederhana dan elegan, dan pada dasarnya dapat ditulis dengan satu baris kode.",
  "time_range": [
   265.6,
   283.24
  ]
 },
 {
  "input": "It's based on the XOR function.",
  "model": "nmt",
  "translatedText": "Ini didasarkan pada fungsi XOR.",
  "time_range": [
   283.66,
   285.5
  ]
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or.",
  "model": "nmt",
  "translatedText": "XOR bagi anda yang belum tahu, singkatan dari Exclusive or.",
  "time_range": [
   286.94,
   290.22
  ]
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off.",
  "model": "nmt",
  "translatedText": "Saat Anda mengambil XOR dari dua bit, itu akan mengembalikan 1 jika salah satu dari bit tersebut diaktifkan, tetapi tidak jika keduanya diaktifkan atau dinonaktifkan.",
  "time_range": [
   290.78,
   299.36
  ]
 },
 {
  "input": "Phrased differently, it's the parity of these two bits.",
  "model": "nmt",
  "translatedText": "Dengan kata lain, ini adalah paritas dari dua bit ini.",
  "time_range": [
   300.1,
   302.98
  ]
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2.",
  "model": "nmt",
  "translatedText": "Sebagai orang matematika, saya lebih suka menganggapnya sebagai mod penjumlahan 2.",
  "time_range": [
   303.54,
   306.76
  ]
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component.",
  "model": "nmt",
  "translatedText": "Kita juga biasa berbicara tentang XOR dari dua string bit yang berbeda, yang pada dasarnya melakukan komponen demi komponen.",
  "time_range": [
   307.36,
   313.44
  ]
 },
 {
  "input": "It's like addition, but where you never carry.",
  "model": "nmt",
  "translatedText": "Ini seperti tambahan, tetapi Anda tidak pernah membawanya.",
  "time_range": [
   313.68,
   315.72
  ]
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2.",
  "model": "nmt",
  "translatedText": "Sekali lagi, mereka yang lebih cenderung matematis mungkin lebih suka menganggap ini sebagai penjumlahan dua vektor dan pengurangan mod 2.",
  "time_range": [
   316.5,
   322.48
  ]
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood.",
  "model": "nmt",
  "translatedText": "Jika Anda membuka beberapa Python sekarang dan menerapkan operasi tanda sisipan antara dua bilangan bulat, inilah yang dilakukannya kecuali representasi bit dari angka-angka tersebut.",
  "time_range": [
   323.5,
   332.94
  ]
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop.",
  "model": "nmt",
  "translatedText": "Poin kuncinya bagi Anda dan saya adalah bahwa mengambil XOR dari banyak string bit yang berbeda secara efektif merupakan cara untuk menghitung parodi dari sekelompok grup terpisah, seperti halnya dengan kolom, semuanya dalam satu gerakan.",
  "time_range": [
   334.96000000000004,
   347.14
  ]
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation.",
  "model": "nmt",
  "translatedText": "Ini memberi kita cara yang agak menarik untuk memikirkan tentang beberapa pemeriksaan paritas dari algoritma kode Hamming karena semuanya dikemas bersama menjadi satu operasi tunggal.",
  "time_range": [
   351.26,
   358.78
  ]
 },
 {
  "input": "Though at first glance it does look very different.",
  "model": "nmt",
  "translatedText": "Meski sekilas memang terlihat sangat berbeda.",
  "time_range": [
   359.47999999999996,
   362.18
  ]
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR.",
  "model": "nmt",
  "translatedText": "Secara khusus tuliskan 16 posisi dalam biner, seperti yang kita lakukan sebelumnya, dan sekarang sorot posisi di mana bit pesan diubah menjadi 1, lalu kumpulkan posisi-posisi ini ke dalam satu kolom besar dan ambil XOR.",
  "time_range": [
   362.82,
   377.1
  ]
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly.",
  "model": "nmt",
  "translatedText": "Anda mungkin dapat menebak bahwa 4 bit yang berada di bagian bawah sebagai hasilnya sama dengan 4 pemeriksaan paritas yang telah kita kenal dan sukai, tetapi luangkan waktu sejenak untuk memikirkan alasan sebenarnya.",
  "time_range": [
   379.26,
   389.2
  ]
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group.",
  "model": "nmt",
  "translatedText": "Kolom terakhir ini, misalnya, menghitung semua posisi yang bit terakhirnya adalah 1, namun kita sudah dibatasi hanya pada posisi yang disorot, sehingga secara efektif menghitung berapa banyak posisi yang disorot yang berasal dari grup paritas pertama.",
  "time_range": [
   392.22,
   405.76
  ]
 },
 {
  "input": "Does that make sense?",
  "model": "nmt",
  "translatedText": "Apakah itu masuk akal?",
  "time_range": [
   406.24,
   406.8
  ]
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on.",
  "model": "nmt",
  "translatedText": "Demikian pula, kolom berikutnya menghitung berapa banyak posisi dalam grup paritas kedua, posisi yang bit kedua hingga terakhirnya adalah 1, dan yang juga disorot, dan seterusnya.",
  "time_range": [
   409.08,
   420.0
  ]
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing.",
  "model": "nmt",
  "translatedText": "Ini hanyalah perubahan kecil dalam perspektif terhadap hal yang sama yang telah kita lakukan.",
  "time_range": [
   420.26,
   423.96
  ]
 },
 {
  "input": "And so you know where it goes from here.",
  "model": "nmt",
  "translatedText": "Jadi Anda tahu ke mana perginya setelah ini.",
  "time_range": [
   427.76,
   429.6
  ]
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000.",
  "model": "nmt",
  "translatedText": "Pengirim bertanggung jawab untuk mengubah beberapa bit paritas khusus untuk memastikan jumlahnya menjadi 0000.",
  "time_range": [
   430.0,
   435.72
  ]
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error.",
  "model": "nmt",
  "translatedText": "Sekarang setelah kita memilikinya seperti ini, ini memberi kita cara yang sangat bagus untuk memikirkan mengapa keempat bit yang dihasilkan di bawah ini secara langsung menguraikan posisi kesalahan.",
  "time_range": [
   435.72,
   447.58
  ]
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1.",
  "model": "nmt",
  "translatedText": "Katakanlah beberapa bit di blok ini diubah dari 0 menjadi 1.",
  "time_range": [
   448.46,
   451.86
  ]
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error.",
  "model": "nmt",
  "translatedText": "Artinya adalah posisi bit tersebut sekarang akan dimasukkan dalam total XOR, yang mengubah jumlah dari 0 menjadi nilai yang baru dimasukkan, posisi kesalahan.",
  "time_range": [
   452.6,
   463.82
  ]
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0.",
  "model": "nmt",
  "translatedText": "Sedikit kurang jelas, hal yang sama juga berlaku jika ada kesalahan yang mengubah 1 menjadi 0.",
  "time_range": [
   464.46,
   469.36
  ]
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0.",
  "model": "nmt",
  "translatedText": "Soalnya, jika Anda menambahkan sedikit string dua kali, itu sama saja dengan tidak memilikinya sama sekali, pada dasarnya karena di dunia ini 1 tambah 1 sama dengan 0.",
  "time_range": [
   470.18,
   477.58
  ]
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it.",
  "model": "nmt",
  "translatedText": "Jadi menambahkan salinan posisi ini ke jumlah total memiliki efek yang sama seperti kita memindahkannya.",
  "time_range": [
   477.58,
   484.3
  ]
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error.",
  "model": "nmt",
  "translatedText": "Dan efeknya, sekali lagi, adalah hasil total di bawah ini menjelaskan posisi kesalahannya.",
  "time_range": [
   485.16,
   490.7
  ]
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end.",
  "model": "nmt",
  "translatedText": "Untuk mengilustrasikan betapa elegannya hal ini, izinkan saya menunjukkan satu baris kode Python yang saya referensikan sebelumnya, yang akan menangkap hampir semua logika di pihak penerima.",
  "time_range": [
   493.03999999999996,
   501.44
  ]
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits.",
  "model": "nmt",
  "translatedText": "Kita akan mulai dengan membuat array acak 16 1 dan 0 untuk mensimulasikan blok data, dan saya akan memberinya nama bit, tapi tentu saja dalam praktiknya ini akan menjadi sesuatu yang kita terima dari pengirim, dan bukannya karena acak, ia akan membawa 11 bit data bersama dengan 5 bit paritas.",
  "time_range": [
   502.08,
   517.0
  ]
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15.",
  "model": "nmt",
  "translatedText": "Jika saya memanggil fungsi enumerateBits, yang dilakukannya adalah memasangkan masing-masing bit tersebut dengan indeks yang sesuai, dalam hal ini berjalan dari 0 hingga 15.",
  "time_range": [
   517.0,
   527.0
  ]
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15.",
  "model": "nmt",
  "translatedText": "Jadi jika kita kemudian membuat daftar yang mengulang semua pasangan ini, pasangan yang terlihat seperti i, dan kemudian kita hanya mengeluarkan nilai i, hanya indeksnya, itu tidak terlalu menarik, kita hanya mendapatkan kembali indeks tersebut 0 sampai 15.",
  "time_range": [
   528.18,
   541.34
  ]
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on.",
  "model": "nmt",
  "translatedText": "Tetapi jika kita menambahkan kondisi untuk hanya melakukan ini jika bit, yang berarti jika bit tersebut adalah 1 dan bukan 0, maka bit tersebut hanya akan menarik keluar posisi di mana bit terkait diaktifkan.",
  "time_range": [
   541.68,
   552.66
  ]
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc.",
  "model": "nmt",
  "translatedText": "Dalam hal ini sepertinya posisi tersebut adalah 0, 4, 6, 9, dst.",
  "time_range": [
   553.38,
   560.36
  ]
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together.",
  "model": "nmt",
  "translatedText": "Apa yang kita inginkan adalah mengumpulkan semua posisi tersebut, posisi bit-bit yang diaktifkan, dan kemudian melakukan XOR bersama-sama.",
  "time_range": [
   560.72,
   567.24
  ]
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions.",
  "model": "nmt",
  "translatedText": "Untuk melakukan ini dengan Python, izinkan saya mengimpor beberapa fungsi bermanfaat terlebih dahulu.",
  "time_range": [
   569.18,
   573.22
  ]
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it.",
  "model": "nmt",
  "translatedText": "Dengan begitu kita bisa memanggil pengurangan() pada daftar ini, dan menggunakan fungsi XOR untuk menguranginya.",
  "time_range": [
   573.9,
   578.7
  ]
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way.",
  "model": "nmt",
  "translatedText": "Ini pada dasarnya memakan seluruh daftar, mengambil XOR di sepanjang jalan.",
  "time_range": [
   579.1,
   582.68
  ]
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere.",
  "model": "nmt",
  "translatedText": "Jika mau, Anda dapat menulis fungsi XOR tersebut secara eksplisit tanpa harus mengimpornya dari mana pun.",
  "time_range": [
   584.8,
   589.44
  ]
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001.",
  "model": "nmt",
  "translatedText": "Jadi saat ini sepertinya jika kita melakukan ini pada blok acak 16 bit, ia akan mengembalikan 9, yang memiliki representasi biner 1001.",
  "time_range": [
   591.94,
   601.28
  ]
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0.",
  "model": "nmt",
  "translatedText": "Kami tidak akan melakukannya di sini, tetapi Anda dapat menulis fungsi di mana pengirim menggunakan representasi biner tersebut untuk mengatur empat bit paritas sesuai kebutuhan, yang pada akhirnya membuat blok ini ke keadaan di mana menjalankan baris kode ini pada daftar bit lengkap akan kembali sebuah 0.",
  "time_range": [
   601.98,
   615.46
  ]
 },
 {
  "input": "This would be considered a well-prepared block.",
  "model": "nmt",
  "translatedText": "Ini akan dianggap sebagai blok yang dipersiapkan dengan baik.",
  "time_range": [
   616.08,
   620.1
  ]
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error.",
  "model": "nmt",
  "translatedText": "Yang keren adalah jika kita mengganti salah satu bit dalam daftar ini, menyimulasikan kesalahan acak dari noise, lalu jika Anda menjalankan baris kode yang sama, kesalahan tersebut akan dicetak.",
  "time_range": [
   620.1,
   630.22
  ]
 },
 {
  "input": "Isn't that neat?",
  "model": "nmt",
  "translatedText": "Bukankah itu rapi?",
  "time_range": [
   630.96,
   631.52
  ]
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any.",
  "model": "nmt",
  "translatedText": "Anda bisa mendapatkan blok ini secara tiba-tiba, menjalankan satu baris ini di atasnya, dan secara otomatis akan memunculkan posisi kesalahan, atau 0 jika tidak ada.",
  "time_range": [
   631.82,
   641.06
  ]
 },
 {
  "input": "And there's nothing special about the size 16 here.",
  "model": "nmt",
  "translatedText": "Dan tidak ada yang istimewa dari ukuran 16 di sini.",
  "time_range": [
   642.5,
   644.84
  ]
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits.",
  "model": "nmt",
  "translatedText": "Baris kode yang sama akan berfungsi jika Anda memiliki daftar, katakanlah, 256 bit.",
  "time_range": [
   644.84,
   649.86
  ]
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction.",
  "model": "nmt",
  "translatedText": "Tak perlu dikatakan, ada lebih banyak kode untuk ditulis di sini, seperti melakukan pemeriksaan meta paritas untuk mendeteksi kesalahan 2-bit, namun idenya adalah bahwa hampir semua logika inti dari skema kita turun ke pengurangan XOR tunggal.",
  "time_range": [
   651.88,
   663.76
  ]
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go.",
  "model": "nmt",
  "translatedText": "Sekarang, tergantung pada kenyamanan Anda dengan biner dan XOR serta perangkat lunak secara umum, Anda mungkin menganggap perspektif ini sedikit membingungkan, atau jauh lebih elegan dan sederhana sehingga Anda bertanya-tanya mengapa kami tidak memulainya dari awal. -pergi.",
  "time_range": [
   666.12,
   678.42
  ]
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level.",
  "model": "nmt",
  "translatedText": "Secara longgar, perspektif pemeriksaan paritas berganda lebih mudah untuk dipikirkan ketika mengimplementasikan kode Hamming pada perangkat keras secara langsung, dan perspektif XOR paling mudah untuk dipikirkan ketika melakukannya dalam perangkat lunak, dari tingkat yang lebih tinggi.",
  "time_range": [
   679.14,
   690.5
  ]
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles.",
  "model": "nmt",
  "translatedText": "Yang pertama paling mudah dilakukan dengan tangan, dan menurut saya ini lebih baik dalam menanamkan intuisi inti yang mendasari semua ini, yaitu bahwa informasi yang diperlukan untuk menemukan satu kesalahan terkait dengan log ukuran blok. , atau dengan kata lain, ia bertambah sedikit demi sedikit seiring dengan bertambahnya ukuran blok.",
  "time_range": [
   691.36,
   710.0
  ]
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need.",
  "model": "nmt",
  "translatedText": "Fakta yang relevan di sini adalah bahwa informasi tersebut secara langsung berhubungan dengan seberapa banyak redundansi yang kita butuhkan.",
  "time_range": [
   711.02,
   716.06
  ]
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind.",
  "model": "nmt",
  "translatedText": "Hal itulah yang bertentangan dengan reaksi spontan kebanyakan orang ketika mereka pertama kali berpikir untuk membuat sebuah pesan tahan terhadap kesalahan, di mana biasanya menyalin seluruh pesan adalah naluri pertama yang terlintas dalam pikiran.",
  "time_range": [
   716.66,
   726.54
  ]
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix.",
  "model": "nmt",
  "translatedText": "Lalu, ada cara lain yang terkadang Anda lihat menampilkan kode Hamming, yaitu mengalikan pesan dengan satu matriks besar.",
  "time_range": [
   727.5,
   734.0
  ]
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales.",
  "model": "nmt",
  "translatedText": "Agak bagus karena menghubungkannya dengan kelompok kode linier yang lebih luas, tapi menurut saya hal itu hampir tidak memberikan intuisi tentang dari mana asalnya atau bagaimana skalanya.",
  "time_range": [
   734.67,
   743.06
  ]
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size.",
  "model": "nmt",
  "translatedText": "Dan berbicara tentang penskalaan, Anda mungkin memperhatikan bahwa efisiensi skema ini semakin baik seiring dengan peningkatan ukuran blok.",
  "time_range": [
   745.2,
   751.16
  ]
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there.",
  "model": "nmt",
  "translatedText": "Misalnya, kita melihat bahwa dengan 256 bit, Anda hanya menggunakan 3% dari ruang tersebut untuk redundansi, dan hal tersebut terus menjadi lebih baik dari sana.",
  "time_range": [
   755.0,
   762.66
  ]
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling.",
  "model": "nmt",
  "translatedText": "Ketika jumlah bit paritas bertambah satu per satu, ukuran blok terus berlipat ganda.",
  "time_range": [
   763.3,
   767.34
  ]
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits.",
  "model": "nmt",
  "translatedText": "Dan jika Anda menganggapnya ekstrem, Anda bisa memiliki blok dengan, katakanlah, satu juta bit, di mana Anda benar-benar akan memainkan 20 pertanyaan dengan pemeriksaan paritas Anda, dan blok tersebut hanya menggunakan 21 bit paritas.",
  "time_range": [
   769.0,
   780.02
  ]
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy.",
  "model": "nmt",
  "translatedText": "Dan jika Anda mundur sejenak untuk berpikir tentang melihat sejuta bit dan menemukan satu kesalahan, itu benar-benar terasa gila.",
  "time_range": [
   780.74,
   787.06
  ]
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that.",
  "model": "nmt",
  "translatedText": "Masalahnya, tentu saja, dengan blok yang lebih besar, kemungkinan melihat lebih dari satu atau dua kesalahan bit akan meningkat, dan kode Hamming tidak dapat menangani apa pun selain itu.",
  "time_range": [
   788.1999999999999,
   797.66
  ]
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high.",
  "model": "nmt",
  "translatedText": "Jadi dalam praktiknya, yang Anda inginkan adalah menemukan ukuran yang tepat sehingga kemungkinan terjadinya terlalu banyak bit flips tidak terlalu tinggi.",
  "time_range": [
   798.32,
   804.3
  ]
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored.",
  "model": "nmt",
  "translatedText": "Selain itu, dalam praktiknya, kesalahan cenderung terjadi dalam beberapa saat, yang akan merusak total satu blok, jadi salah satu taktik umum untuk membantu menyebarkan ledakan kesalahan ke banyak blok yang berbeda adalah dengan menjalin blok-blok tersebut, seperti ini, sebelum mereka terjadi. dikirim atau disimpan.",
  "time_range": [
   806.6,
   820.98
  ]
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block.",
  "model": "nmt",
  "translatedText": "Selain itu, banyak dari hal ini yang dianggap sepenuhnya diperdebatkan oleh kode-kode yang lebih modern, seperti algoritma Reed-Solomon yang jauh lebih umum digunakan, yang menangani error burst dengan sangat baik, dan dapat disesuaikan agar tahan terhadap jumlah error yang lebih besar per blok.",
  "time_range": [
   825.58,
   838.82
  ]
 },
 {
  "input": "But that's a topic for another time.",
  "model": "nmt",
  "translatedText": "Tapi itu topik untuk lain waktu.",
  "time_range": [
   839.36,
   841.34
  ]
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was.",
  "model": "nmt",
  "translatedText": "Dalam bukunya The Art of Doing Science and Engineering, Hamming sangat berterus terang tentang betapa berliku-liku penemuan kode ini.",
  "time_range": [
   842.5,
   849.94
  ]
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this.",
  "model": "nmt",
  "translatedText": "Dia pertama kali mencoba segala macam skema berbeda yang melibatkan pengorganisasian bit-bit menjadi bagian-bagian kisi dimensi yang lebih tinggi dan hal-hal aneh seperti ini.",
  "time_range": [
   850.62,
   857.78
  ]
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this?",
  "model": "nmt",
  "translatedText": "Gagasan bahwa mungkin saja pemeriksaan paritas berkonspirasi sedemikian rupa sehingga menjelaskan posisi kesalahan hanya muncul di benak Hamming ketika dia mundur setelah serangkaian analisis lain dan bertanya, oke, apa cara paling efisien yang bisa saya lakukan? mungkin tentang ini?",
  "time_range": [
   858.3,
   871.52
  ]
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today.",
  "model": "nmt",
  "translatedText": "Dia juga berterus terang tentang betapa pentingnya pemeriksaan paritas yang sudah ada dalam pikirannya, yang mana hal ini jauh lebih jarang dilakukan pada tahun 1940an dibandingkan saat ini.",
  "time_range": [
   872.62,
   881.22
  ]
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind.",
  "model": "nmt",
  "translatedText": "Ada setengah lusin kali dalam buku ini dia merujuk pada kutipan Louis Pasteur, keberuntungan berpihak pada pikiran yang siap.",
  "time_range": [
   881.92,
   888.22
  ]
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate.",
  "model": "nmt",
  "translatedText": "Ide-ide cerdas sering kali terlihat sederhana jika dipikir-pikir, sehingga mudah untuk kurang dihargai.",
  "time_range": [
   889.32,
   894.3
  ]
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you.",
  "model": "nmt",
  "translatedText": "Saat ini harapan jujur saya adalah bahwa kode Hamming, atau setidaknya kemungkinan kode tersebut, terasa hampir jelas bagi Anda.",
  "time_range": [
   894.96,
   901.3
  ]
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't.",
  "model": "nmt",
  "translatedText": "Namun Anda tidak boleh membodohi diri sendiri dengan berpikir bahwa hal tersebut sebenarnya sudah jelas, karena sebenarnya tidak.",
  "time_range": [
   901.66,
   906.82
  ]
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that.",
  "model": "nmt",
  "translatedText": "Salah satu alasan mengapa ide-ide cerdas terlihat mudah adalah karena kita hanya melihat hasil akhirnya, membereskan apa yang berantakan, tidak pernah menyebutkan semua hal yang salah, meremehkan betapa luasnya ruang kemungkinan yang dapat dieksplorasi pada awal sebuah masalah. proses penyelesaian, semua itu.",
  "time_range": [
   907.88,
   922.86
  ]
 },
 {
  "input": "But this is true in general.",
  "model": "nmt",
  "translatedText": "Namun hal ini berlaku secara umum.",
  "time_range": [
   923.82,
   924.9
  ]
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them.",
  "model": "nmt",
  "translatedText": "Saya pikir untuk beberapa penemuan khusus, ada alasan kedua yang lebih dalam sehingga kita kurang menghargainya.",
  "time_range": [
   924.9,
   930.04
  ]
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory.",
  "model": "nmt",
  "translatedText": "Memikirkan informasi dalam bentuk potongan-potongan baru benar-benar menyatu menjadi teori penuh pada tahun 1948, dengan makalah penting Claude Shannon tentang teori informasi.",
  "time_range": [
   930.84,
   938.64
  ]
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm.",
  "model": "nmt",
  "translatedText": "Hal ini pada dasarnya bersamaan dengan ketika Hamming mengembangkan algoritmanya.",
  "time_range": [
   939.28,
   942.54
  ]
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory.",
  "model": "nmt",
  "translatedText": "Ini adalah makalah dasar yang sama yang menunjukkan, dalam arti tertentu, bahwa koreksi kesalahan yang efisien selalu mungkin dilakukan, tidak peduli seberapa tinggi kemungkinan pembalikan bit, setidaknya secara teori.",
  "time_range": [
   943.3,
   952.9
  ]
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here.",
  "model": "nmt",
  "translatedText": "Omong-omong, Shannon dan Hamming berbagi kantor di Bell Labs, meskipun mengerjakan hal-hal yang sangat berbeda, yang sepertinya bukan suatu kebetulan di sini.",
  "time_range": [
   953.7,
   961.16
  ]
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was.",
  "model": "nmt",
  "translatedText": "Beberapa dekade kemudian, dan saat ini, banyak dari kita yang begitu tenggelam dalam pemikiran tentang hal-hal kecil dan informasi sehingga mudah untuk mengabaikan betapa berbedanya cara berpikir ini.",
  "time_range": [
   962.38,
   972.34
  ]
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are.",
  "model": "nmt",
  "translatedText": "Ironisnya, ide-ide yang secara mendalam membentuk cara berpikir generasi masa depan akan membuat generasi masa depan terlihat lebih sederhana daripada yang sebenarnya.",
  "time_range": [
   973.1,
   982.26
  ]
 }
]