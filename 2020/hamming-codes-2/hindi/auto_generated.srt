1
00:00:00,000 --> 00:00:05,450
क्या आपने कभी सोचा है कि किसी सीडी या डीवीडी को स्क्रैच करना

2
00:00:05,450 --> 00:00:10,900
और उसमें जो कुछ भी संग्रहीत है उसे प्लेबैक करना कैसे संभव है?

3
00:00:10,900 --> 00:00:14,112
स्क्रैच वास्तव में डिस्क पर 1s और 0s को प्रभावित करता है,

4
00:00:14,112 --> 00:00:17,268
इसलिए यह संग्रहीत किए गए डेटा से भिन्न डेटा को पढ़ता है,

5
00:00:17,268 --> 00:00:20,259
लेकिन जब तक इसे वास्तव में स्क्रैच नहीं किया जाता है,

6
00:00:20,259 --> 00:00:24,523
तब तक इसके द्वारा पढ़े गए बिट्स ठीक उसी फ़ाइल में डीकोड हो जाते हैं जो उस पर

7
00:00:24,523 --> 00:00:28,400
एन्कोड किया गया था, ए उन सभी त्रुटियों के बावजूद, बिट कॉपी के लिए बिट।

8
00:00:28,400 --> 00:00:32,161
गणितीय चतुराई का एक पूरा ढेर है जो हमें डेटा संग्रहीत करने की अनुमति देता है,

9
00:00:32,161 --> 00:00:35,344
और उतना ही महत्वपूर्ण रूप से डेटा संचारित करने की अनुमति देता है,

10
00:00:35,344 --> 00:00:36,840
जो त्रुटियों के प्रति लचीला है।

11
00:00:36,840 --> 00:00:39,718
ठीक है, ठीक है, वास्तव में ऐसा करने का कोई तरीका

12
00:00:39,718 --> 00:00:42,480
निकालने के लिए उतनी चतुराई की आवश्यकता नहीं है।

13
00:00:42,480 --> 00:00:46,951
कोई भी फ़ाइल, चाहे वह वीडियो हो या ध्वनि या पाठ, कोई कोड,

14
00:00:46,951 --> 00:00:50,960
कोई छवि, जो भी हो, अंततः 1s और 0s का कुछ अनुक्रम है।

15
00:00:50,960 --> 00:00:54,485
और जो भी बिट फ़्लिप हो जाता है उसे ठीक करने की एक सरल रणनीति

16
00:00:54,485 --> 00:00:57,780
यह होगी कि प्रत्येक बिट की तीन प्रतियां संग्रहीत की जाएं।

17
00:00:57,780 --> 00:01:02,540
फिर इस फ़ाइल को पढ़ने वाली मशीन इन तीन प्रतियों की तुलना कर सकती है

18
00:01:02,540 --> 00:01:07,440
और जब भी कोई विसंगति हो तो हमेशा 3 में से सर्वश्रेष्ठ 2 को ले सकती है।

19
00:01:07,440 --> 00:01:11,560
लेकिन इसका मतलब यह है कि आपके स्थान का दो-तिहाई हिस्सा अतिरेक के लिए उपयोग किया जा रहा है।

20
00:01:11,560 --> 00:01:14,917
और फिर भी, छोड़ी गई सारी जगह के लिए, इस बात की कोई पुख्ता गारंटी

21
00:01:14,917 --> 00:01:18,120
नहीं है कि यदि एक से अधिक बिट फ़्लिप हो जाते हैं तो क्या होगा।

22
00:01:18,120 --> 00:01:21,546
इससे भी अधिक दिलचस्प सवाल यह है कि इसे कैसे बनाया जाए ताकि

23
00:01:21,546 --> 00:01:24,740
यथासंभव कम जगह छोड़ते हुए त्रुटियों को ठीक किया जा सके।

24
00:01:24,740 --> 00:01:27,822
उदाहरण के लिए, जिस विधि के बारे में आप इस वीडियो के बारे में जानेंगे,

25
00:01:27,822 --> 00:01:30,861
उसका उपयोग करके आप अपना डेटा 256-बिट ब्लॉक में संग्रहीत कर सकते हैं,

26
00:01:30,861 --> 00:01:32,975
जहां प्रत्येक ब्लॉक 9 बिट्स, 9 का उपयोग करता है!

27
00:01:32,975 --> 00:01:36,015
एक प्रकार की अतिरेक के रूप में कार्य करने के लिए,

28
00:01:36,015 --> 00:01:41,000
और अन्य 247 बिट्स आपके इच्छित सार्थक संदेश या डेटा को ले जाने के लिए स्वतंत्र हैं।

29
00:01:41,000 --> 00:01:44,285
और यह अब भी होगा कि यदि यहां कोई भी बिट फ़्लिप हो जाता है,

30
00:01:44,285 --> 00:01:48,350
तो केवल इस ब्लॉक को देखकर और कुछ नहीं, एक मशीन यह पहचानने में सक्षम होगी

31
00:01:48,350 --> 00:01:53,140
कि कोई त्रुटि थी और सटीक रूप से यह कहां थी ताकि वह जान सके कि इसे कैसे ठीक किया जाए। .

32
00:01:53,140 --> 00:01:55,540
और ईमानदारी से कहूं तो यह जादू जैसा लगता है।

33
00:01:55,540 --> 00:01:57,959
और इस विशेष योजना के लिए, यदि दो बिट फ़्लिप हो जाते हैं,

34
00:01:57,959 --> 00:02:00,760
तो मशीन कम से कम यह पता लगाने में सक्षम होगी कि दो त्रुटियाँ थीं,

35
00:02:00,760 --> 00:02:03,180
हालाँकि उसे यह नहीं पता होगा कि उन्हें कैसे ठीक किया जाए।

36
00:02:03,180 --> 00:02:05,815
हम थोड़ी देर बाद इस बारे में बात करेंगे कि विभिन्न

37
00:02:05,815 --> 00:02:08,140
आकारों वाले ब्लॉकों के लिए यह पैमाना कैसा है।

38
00:02:08,140 --> 00:02:11,132
वे विधियाँ जो आपको इस तरह की त्रुटियों को ठीक करने देती हैं,

39
00:02:11,132 --> 00:02:13,880
यथोचित रूप से त्रुटि सुधार कोड के रूप में जानी जाती हैं।

40
00:02:13,880 --> 00:02:18,386
पिछली शताब्दी के अधिकांश समय में, यह क्षेत्र आश्चर्यजनक रूप से गहन गणित का एक समृद्ध

41
00:02:18,386 --> 00:02:23,000
स्रोत रहा है जो हमारे द्वारा प्रतिदिन उपयोग किए जाने वाले उपकरणों में शामिल हो जाता है।

42
00:02:23,000 --> 00:02:27,757
यहां लक्ष्य आपको शुरुआती उदाहरणों में से एक, जिसे हैमिंग कोड के नाम से जाना जाता है,

43
00:02:27,757 --> 00:02:29,660
की पूरी तरह से समझ प्रदान करना है।

44
00:02:29,660 --> 00:02:33,164
और वैसे, जिस तरह से मैं इस वीडियो की संरचना के बारे में सोच रहा हूं वह इसे

45
00:02:33,164 --> 00:02:36,668
यथासंभव सीधे समझाने के बारे में कम है, और यहां और वहां थोड़े से मार्गदर्शन

46
00:02:36,668 --> 00:02:40,220
के साथ आपको इसे अपने लिए आविष्कार करने के लिए प्रेरित करने का मामला अधिक है।

47
00:02:40,220 --> 00:02:43,294
इसलिए जब आपको लगे कि किसी बिंदु पर आप देख रहे हैं कि यह कहां जा रहा है,

48
00:02:43,294 --> 00:02:46,838
तो उस क्षण रुकें, मेरे बताने से पहले सक्रिय रूप से अनुमान लगाएं कि योजना क्या होने

49
00:02:46,838 --> 00:02:47,180
वाली है।

50
00:02:47,180 --> 00:02:50,779
साथ ही, यदि आप चाहते हैं कि आपकी समझ हार्डवेयर स्तर तक पहुंचे,

51
00:02:50,779 --> 00:02:54,835
तो बेन ईटर ने इसके साथ मिलकर एक वीडियो बनाया है जिसमें आपको दिखाया गया

52
00:02:54,835 --> 00:02:59,520
है कि वास्तव में ब्रेडबोर्ड पर हैमिंग कोड कैसे लागू किया जाए, जो बेहद संतोषजनक है।

53
00:02:59,520 --> 00:03:04,445
आपको पता होना चाहिए, हैमिंग कोड रीड-सोलोमन एल्गोरिथ्म की तरह अधिक आधुनिक कोड के रूप में

54
00:03:04,445 --> 00:03:09,370
व्यापक रूप से उपयोग नहीं किए जाते हैं, लेकिन शुरुआत में यह कार्य कितना असंभव लगता है और

55
00:03:09,370 --> 00:03:14,240
एक बार यह कितना उचित लगता है, इसके बीच एक निश्चित जादू है। आप हैमिंग के बारे में जानें।

56
00:03:14,240 --> 00:03:19,796
त्रुटि सुधार का मूल सिद्धांत यह है कि सभी संभावित संदेशों के विशाल स्थान में,

57
00:03:19,796 --> 00:03:22,860
केवल कुछ उपसमूह को ही वैध संदेश माना जाएगा।

58
00:03:22,860 --> 00:03:29,100
सादृश्य के रूप में, सही वर्तनी वाले शब्दों बनाम गलत वर्तनी वाले शब्दों के बारे में सोचें।

59
00:03:29,100 --> 00:03:33,740
जब भी कोई वैध संदेश बदल जाता है, तो प्राप्तकर्ता निकटतम वैध पड़ोसी को जो दिखाई देता

60
00:03:33,740 --> 00:03:38,380
है उसे ठीक करने के लिए जिम्मेदार होता है, जैसा कि आप टाइपो के मामले में कर सकते हैं।

61
00:03:38,380 --> 00:03:42,673
हालाँकि, इस तरह के संदेशों को कुशलतापूर्वक वर्गीकृत करने के लिए एक

62
00:03:42,673 --> 00:03:47,160
ठोस एल्गोरिदम के साथ आने के लिए एक निश्चित चतुराई की आवश्यकता होती है।

63
00:03:47,160 --> 00:03:50,461
कहानी 1940 के दशक में शुरू होती है, जब एक युवा रिचर्ड हैमिंग बेल

64
00:03:50,461 --> 00:03:53,864
लैब्स के लिए काम कर रहे थे, और उनके कुछ काम में एक बहुत बड़े महंगे

65
00:03:53,864 --> 00:03:57,420
पंच कार्ड कंप्यूटर का उपयोग करना शामिल था, जिस तक उनकी सीमित पहुंच थी।

66
00:03:57,420 --> 00:04:01,002
और जो प्रोग्राम वह इसके माध्यम से डालता रहा वह विफल होता रहा,

67
00:04:01,002 --> 00:04:03,140
क्योंकि कभी-कभी कुछ गलत पढ़ा जाता था।

68
00:04:03,140 --> 00:04:06,060
आविष्कार की भट्ठी निराशा से वह इतना तंग आ गया कि

69
00:04:06,060 --> 00:04:09,280
उसने दुनिया का पहला त्रुटि सुधार कोड का आविष्कार किया।

70
00:04:09,280 --> 00:04:11,828
हैमिंग कोड को फ्रेम करने के कई अलग-अलग तरीके हैं,

71
00:04:11,828 --> 00:04:15,498
लेकिन पहली बार हम इसके माध्यम से जाने वाले हैं जिस तरह से हैमिंग ने खुद

72
00:04:15,498 --> 00:04:16,620
उनके बारे में सोचा था।

73
00:04:16,620 --> 00:04:21,400
आइए एक उदाहरण का उपयोग करें जो सरल है, लेकिन बहुत सरल नहीं है, 16 बिट्स का एक ब्लॉक।

74
00:04:21,400 --> 00:04:25,700
हम इन बिट्स की स्थिति को 0 से 15 तक क्रमांकित करेंगे।

75
00:04:25,700 --> 00:04:30,745
जो वास्तविक डेटा हम संग्रहीत करना चाहते हैं, वह इनमें से केवल 12 बिट्स को बनाने वाला है,

76
00:04:30,745 --> 00:04:33,920
जबकि 4 स्थान एक प्रकार के अतिरेक के रूप में आरक्षित हैं।

77
00:04:33,920 --> 00:04:36,604
यहां निरर्थक शब्द का मतलब केवल कॉपी करना नहीं है, आखिरकार,

78
00:04:36,604 --> 00:04:40,200
वे 4 बिट्स हमें डेटा को आंख मूंदकर कॉपी करने के लिए पर्याप्त जगह नहीं देते हैं।

79
00:04:40,200 --> 00:04:45,088
इसके बजाय, उन्हें बहुत अधिक सूक्ष्म और चतुर प्रकार के अतिरेक की आवश्यकता होगी,

80
00:04:45,088 --> 00:04:48,740
कोई नई जानकारी नहीं जोड़नी होगी, बल्कि लचीलापन जोड़ना होगा।

81
00:04:48,740 --> 00:04:52,367
आप उम्मीद कर सकते हैं कि ये 4 विशेष बिट्स अच्छी तरह से एक साथ पैक किए जाएंगे,

82
00:04:52,367 --> 00:04:54,739
शायद अंत में या ऐसा कुछ, लेकिन जैसा कि आप देखेंगे,

83
00:04:54,739 --> 00:04:57,204
उन्हें उन स्थितियों में बैठाना जो 2 की शक्तियाँ हैं,

84
00:04:57,204 --> 00:05:00,320
अंत तक कुछ ऐसा करने की अनुमति देता है जो वास्तव में सुरुचिपूर्ण है।

85
00:05:00,320 --> 00:05:05,420
यह आपको इस बारे में भी थोड़ा संकेत दे सकता है कि यह बड़े ब्लॉकों के लिए कैसा है।

86
00:05:05,420 --> 00:05:08,810
इसके अलावा तकनीकी रूप से यह केवल 11 बिट डेटा बनकर रह जाता है,

87
00:05:08,810 --> 00:05:12,256
आप पाएंगे कि स्थिति 0 पर जो होता है उसमें थोड़ी बारीकियां हैं,

88
00:05:12,256 --> 00:05:14,280
लेकिन अभी इसके बारे में चिंता न करें।

89
00:05:14,280 --> 00:05:18,103
किसी भी त्रुटि सुधार एल्गोरिदम की तरह, इसमें दो खिलाड़ी शामिल होंगे,

90
00:05:18,103 --> 00:05:21,594
एक प्रेषक जो इन 4 विशेष बिट्स को सेट करने के लिए जिम्मेदार है,

91
00:05:21,594 --> 00:05:26,360
और एक रिसीवर जो किसी प्रकार की जांच करने और त्रुटियों को ठीक करने के लिए जिम्मेदार है।

92
00:05:26,360 --> 00:05:29,368
बेशक, प्रेषक और रिसीवर शब्द वास्तव में उन मशीनों या सॉफ़्टवेयर

93
00:05:29,368 --> 00:05:32,376
को संदर्भित करते हैं जो सभी जांच कर रहे हैं, और संदेश का विचार

94
00:05:32,376 --> 00:05:35,480
वास्तव में मोटे तौर पर भंडारण जैसी चीजों को शामिल करने के लिए है।

95
00:05:35,480 --> 00:05:38,961
आख़िरकार, डेटा संग्रहीत करना एक संदेश को एक स्थान से

96
00:05:38,961 --> 00:05:42,640
दूसरे स्थान के बजाय अतीत से भविष्य में भेजने जैसा ही है।

97
00:05:42,640 --> 00:05:46,228
तो यह सेटअप है, लेकिन इससे पहले कि हम आगे बढ़ें हमें एक संबंधित विचार

98
00:05:46,228 --> 00:05:50,431
के बारे में बात करने की ज़रूरत है जो हैमिंग के दिमाग में उनकी खोज के समय ताजा था,

99
00:05:50,431 --> 00:05:53,558
एक ऐसी विधि जो आपको किसी भी बिट त्रुटि का पता लगाने देती है,

100
00:05:53,558 --> 00:05:57,300
लेकिन उन्हें ठीक करने की नहीं, ज्ञात है व्यवसाय में समता जाँच के रूप में।

101
00:05:57,300 --> 00:06:01,091
समता जांच के लिए, हम केवल एक बिट को अलग करते हैं जिसे ट्यूनिंग के

102
00:06:01,091 --> 00:06:04,940
लिए प्रेषक जिम्मेदार है, और बाकी संदेश ले जाने के लिए स्वतंत्र हैं।

103
00:06:04,940 --> 00:06:08,443
इस विशेष बिट का एकमात्र काम यह सुनिश्चित करना

104
00:06:08,443 --> 00:06:12,100
है कि संदेश में 1 की कुल संख्या एक सम संख्या है।

105
00:06:12,100 --> 00:06:15,430
उदाहरण के लिए अभी, 1 की कुल संख्या 7 है, यह अजीब है,

106
00:06:15,430 --> 00:06:20,960
इसलिए प्रेषक को उस विशेष बिट को 1 करने के लिए फ़्लिप करना होगा, जिससे गिनती सम हो जाएगी।

107
00:06:20,960 --> 00:06:25,261
लेकिन यदि ब्लॉक पहले से ही 1 की सम संख्या के साथ शुरू हुआ होता,

108
00:06:25,261 --> 00:06:27,480
तो इस विशेष बिट को 0 पर रखा जाता।

109
00:06:27,480 --> 00:06:32,739
यह बहुत ही सरल, भ्रामक रूप से सरल है, लेकिन यह किसी संदेश में कहीं भी परिवर्तन के विचार

110
00:06:32,739 --> 00:06:37,760
को जानकारी के एक टुकड़े में प्रतिबिंबित करने का एक अविश्वसनीय रूप से सुंदर तरीका है।

111
00:06:37,760 --> 00:06:44,067
ध्यान दें कि यदि इस संदेश का कोई भी अंश 0 से 1 या 1 से 0 तक फ़्लिप हो जाता है,

112
00:06:44,067 --> 00:06:48,140
तो यह 1 की कुल गिनती को सम से विषम में बदल देता है।

113
00:06:48,140 --> 00:06:51,051
इसलिए यदि आप रिसीवर हैं, आप इस संदेश को देखते हैं,

114
00:06:51,051 --> 00:06:54,533
और आपको 1 की एक विषम संख्या दिखाई देती है, तो आप निश्चित रूप

115
00:06:54,533 --> 00:06:58,700
से जान सकते हैं कि कुछ त्रुटि हुई है, भले ही आपको पता न हो कि यह कहां थी।

116
00:06:58,700 --> 00:07:02,615
शब्दजाल में, चाहे बिट्स के समूह में 1s की सम या विषम संख्या हो,

117
00:07:02,615 --> 00:07:04,940
इसे इसकी समता के रूप में जाना जाता है।

118
00:07:04,940 --> 00:07:07,917
आप संख्याओं का भी उपयोग कर सकते हैं और कह सकते हैं कि समता 0 या 1 है,

119
00:07:07,917 --> 00:07:11,320
जो आमतौर पर तब अधिक सहायक होती है जब आप इस विचार के साथ गणित करना शुरू करते हैं।

120
00:07:11,320 --> 00:07:16,636
और यह विशेष बिट जिसे प्रेषक समता को नियंत्रित करने के लिए उपयोग करता है,

121
00:07:16,636 --> 00:07:18,020
समता बिट कहलाता है।

122
00:07:18,020 --> 00:07:21,731
और वास्तव में, हमें स्पष्ट होना चाहिए, यदि रिसीवर एक विषम समता देखता है,

123
00:07:21,731 --> 00:07:25,035
तो इसका मतलब यह नहीं है कि केवल एक त्रुटि थी, 3 त्रुटियां, या 5,

124
00:07:25,035 --> 00:07:29,560
या कोई अन्य विषम संख्या हो सकती है, लेकिन वे निश्चित रूप से जान सकते हैं कि यह 0 नहीं था.

125
00:07:29,560 --> 00:07:33,941
दूसरी ओर, यदि 2 त्रुटियाँ थीं, या कोई सम संख्या में त्रुटियाँ थीं,

126
00:07:33,941 --> 00:07:38,585
तो 1 की अंतिम गिनती अभी भी सम होगी, इसलिए प्राप्तकर्ता को पूरा विश्वास

127
00:07:38,585 --> 00:07:43,360
नहीं हो सकता है कि एक सम संख्या का मतलब यह है कि संदेश त्रुटि-मुक्त है। .

128
00:07:43,360 --> 00:07:46,639
आप शिकायत कर सकते हैं कि जो संदेश केवल 2 बिट फ़्लिप से गड़बड़

129
00:07:46,639 --> 00:07:49,760
हो जाता है वह बहुत कमज़ोर होता है, और आप बिल्कुल सही होंगे।

130
00:07:49,760 --> 00:07:54,646
ध्यान रखें, हालाँकि, त्रुटि का पता लगाने या सुधार करने की कोई विधि नहीं है जो

131
00:07:54,646 --> 00:07:59,720
आपको 100% विश्वास दिला सके कि आपको प्राप्त संदेश वही है जो भेजने वाले ने चाहा है।

132
00:07:59,720 --> 00:08:02,820
आख़िरकार, पर्याप्त यादृच्छिक शोर हमेशा शुद्ध संयोग

133
00:08:02,820 --> 00:08:05,920
से एक वैध संदेश को दूसरे वैध संदेश में बदल सकता है।

134
00:08:05,920 --> 00:08:11,027
इसके बजाय, लक्ष्य एक ऐसी योजना बनाना है जो त्रुटियों की एक निश्चित अधिकतम

135
00:08:11,027 --> 00:08:16,480
संख्या तक मजबूत हो, या शायद इस तरह की झूठी सकारात्मकता की संभावना को कम कर सके।

136
00:08:16,480 --> 00:08:20,320
समता जांच अपने आप में काफी कमजोर हैं, लेकिन एक पूर्ण संदेश में

137
00:08:20,320 --> 00:08:24,160
परिवर्तन के विचार को एक बिट तक सीमित करके, वे हमें जो देते हैं

138
00:08:24,160 --> 00:08:28,000
वह अधिक परिष्कृत योजनाओं के लिए एक शक्तिशाली बिल्डिंग ब्लॉक है।

139
00:08:28,000 --> 00:08:32,279
उदाहरण के लिए, जब हैमिंग यह पहचानने का एक तरीका खोज रहा था कि त्रुटि कहाँ हुई है,

140
00:08:32,279 --> 00:08:35,984
न कि केवल यह कि यह घटित हुई है, तो उसकी मुख्य अंतर्दृष्टि यह थी कि यदि

141
00:08:35,984 --> 00:08:39,794
आप कुछ समता जाँचों को पूर्ण संदेश पर नहीं, बल्कि कुछ सावधानीपूर्वक चयनित

142
00:08:39,794 --> 00:08:43,708
उपसमूहों पर लागू करते हैं, तो आप पूछ सकते हैं प्रश्नों की एक अधिक परिष्कृत

143
00:08:43,708 --> 00:08:46,840
श्रृंखला जो किसी भी एक बिट त्रुटि के स्थान को इंगित करती है।

144
00:08:46,840 --> 00:08:49,896
कुल मिलाकर भावना कुछ-कुछ 20 प्रश्नों का खेल खेलने जैसा है,

145
00:08:49,896 --> 00:08:54,300
जिसमें हां या ना में ऐसे प्रश्न पूछे जाते हैं जो संभावनाओं की जगह को आधा कर देते हैं।

146
00:08:54,300 --> 00:08:57,380
उदाहरण के लिए, मान लें कि हम केवल इन 8 बिट्स, सभी

147
00:08:57,380 --> 00:09:00,400
विषम संख्या वाली स्थितियों पर समता जांच करते हैं।

148
00:09:00,400 --> 00:09:04,952
फिर यदि कोई त्रुटि पाई जाती है, तो यह रिसीवर को इस बारे में थोड़ी अधिक जानकारी

149
00:09:04,952 --> 00:09:09,160
देता है कि विशेष रूप से त्रुटि कहाँ है, अर्थात् यह एक विषम स्थिति में है।

150
00:09:09,160 --> 00:09:12,483
यदि उन 8 बिट्स के बीच कोई त्रुटि नहीं पाई जाती है,

151
00:09:12,483 --> 00:09:17,240
तो इसका मतलब है कि कोई त्रुटि नहीं है, या यह कहीं सम स्थिति में बैठता है।

152
00:09:17,240 --> 00:09:22,340
आप सोच सकते हैं कि समता जांच को आधे बिट्स तक सीमित करने से यह कम प्रभावी हो जाता है,

153
00:09:22,340 --> 00:09:27,020
लेकिन जब इसे अन्य अच्छी तरह से चुनी गई जांचों के साथ संयोजन में किया जाता है,

154
00:09:27,020 --> 00:09:29,720
तो यह हमें कुछ अधिक शक्तिशाली प्रदान करता है।

155
00:09:29,720 --> 00:09:32,489
वास्तव में उस समता जाँच को स्थापित करने के लिए, याद रखें,

156
00:09:32,489 --> 00:09:36,453
इसमें कुछ विशेष बिट निर्धारित करने की आवश्यकता होती है जिसका उस पूर्ण समूह की समता

157
00:09:36,453 --> 00:09:37,600
के लिए नियंत्रण होता है।

158
00:09:37,600 --> 00:09:39,920
आइए यहां केवल स्थिति 1 चुनें।

159
00:09:39,920 --> 00:09:43,769
दिखाए गए उदाहरण के लिए, इन 8 बिट्स की समता वर्तमान में विषम है,

160
00:09:43,769 --> 00:09:48,220
इसलिए प्रेषक उस समता बिट को टॉगल करने के लिए जिम्मेदार है, और अब यह सम है।

161
00:09:48,220 --> 00:09:51,040
यह 4 समता जांचों में से केवल 1 है जो हम करेंगे।

162
00:09:51,040 --> 00:09:54,589
दूसरा चेक ग्रिड के दाहिने आधे हिस्से पर 8 बिट्स में से एक है,

163
00:09:54,589 --> 00:09:56,880
कम से कम जैसा कि हमने इसे यहां खींचा है।

164
00:09:56,880 --> 00:10:00,402
इस बार हम स्थिति 2 को समता बिट के रूप में उपयोग कर सकते हैं,

165
00:10:00,402 --> 00:10:03,117
इसलिए इन 8 बिट्स में पहले से ही एक सम समता है,

166
00:10:03,117 --> 00:10:07,160
और प्रेषक उस बिट संख्या 2 को अपरिवर्तित छोड़कर अच्छा महसूस कर सकता है।

167
00:10:07,160 --> 00:10:11,586
फिर दूसरे छोर पर, यदि रिसीवर इस समूह की समता की जांच करता है और उन्हें पता चलता है

168
00:10:11,586 --> 00:10:15,960
कि यह अजीब है, तो उन्हें पता चल जाएगा कि त्रुटि दाईं ओर इन 8 बिट्स में से कहीं है।

169
00:10:15,960 --> 00:10:21,260
अन्यथा इसका मतलब है कि या तो कोई त्रुटि नहीं है, या त्रुटि बाएं आधे हिस्से में कहीं है।

170
00:10:21,260 --> 00:10:24,034
या मुझे लगता है कि दो त्रुटियाँ हो सकती थीं, लेकिन

171
00:10:24,034 --> 00:10:27,080
अभी हम यह मानेंगे कि पूरे ब्लॉक में अधिकतम एक त्रुटि है।

172
00:10:27,080 --> 00:10:29,160
इससे अधिक के लिए चीजें पूरी तरह से टूट जाती हैं।

173
00:10:29,160 --> 00:10:31,208
यहां, इससे पहले कि हम अगली दो जांचों पर गौर करें,

174
00:10:31,208 --> 00:10:34,486
एक पल के लिए यह सोचें कि जब आप उन पर एक साथ विचार करते हैं तो ये पहली दो जांचें

175
00:10:34,486 --> 00:10:35,880
हमें क्या करने की अनुमति देती हैं।

176
00:10:35,880 --> 00:10:40,240
मान लीजिए कि आपको विषम स्तंभों और दाएँ आधे भाग के बीच एक त्रुटि का पता चलता है।

177
00:10:40,240 --> 00:10:43,940
इसका आवश्यक अर्थ यह है कि त्रुटि अंतिम कॉलम में कहीं है।

178
00:10:43,940 --> 00:10:47,897
यदि विषम कॉलम में कोई त्रुटि नहीं थी, लेकिन दाहिने आधे हिस्से में एक त्रुटि थी,

179
00:10:47,897 --> 00:10:50,520
तो यह आपको बताता है कि यह दूसरे से अंतिम कॉलम में है।

180
00:10:50,520 --> 00:10:54,295
इसी तरह यदि विषम कॉलम में कोई त्रुटि है, लेकिन दाहिने आधे हिस्से में नहीं,

181
00:10:54,295 --> 00:10:56,560
तो आप जानते हैं कि यह दूसरे कॉलम में कहीं है।

182
00:10:56,560 --> 00:10:59,845
और यदि उन दोनों समता जांचों में से कोई भी कुछ भी पता नहीं लगाता है,

183
00:10:59,845 --> 00:11:03,760
तो इसका मतलब है कि एकमात्र स्थान जहां त्रुटि हो सकती है वह सबसे बाएं कॉलम में है।

184
00:11:03,760 --> 00:11:06,480
लेकिन इसका सीधा मतलब यह भी हो सकता है कि कोई त्रुटि ही नहीं है।

185
00:11:06,480 --> 00:11:11,800
यह कहने का एक विस्तृत तरीका है कि दो समता जांचों से हम कॉलम को पिन कर सकते हैं।

186
00:11:11,800 --> 00:11:14,000
यहां से, आप शायद अनुमान लगा सकते हैं कि आगे क्या होगा।

187
00:11:14,000 --> 00:11:16,240
हम मूल रूप से वही काम करते हैं लेकिन पंक्तियों के लिए।

188
00:11:16,240 --> 00:11:21,040
समता बिट के रूप में स्थिति 4 का उपयोग करते हुए, विषम पंक्तियों पर समता जांच की जाएगी।

189
00:11:21,040 --> 00:11:26,480
तो इस उदाहरण में उस समूह में पहले से ही सम समता है, इसलिए बिट 4 को 0 पर सेट किया जाएगा।

190
00:11:26,480 --> 00:11:29,239
और अंत में समता बिट के रूप में स्थिति 8 का उपयोग

191
00:11:29,239 --> 00:11:32,280
करते हुए नीचे की दो पंक्तियों पर एक समता जांच होती है।

192
00:11:32,280 --> 00:11:35,060
इस मामले में, ऐसा लगता है कि समूह को समता प्रदान करने

193
00:11:35,060 --> 00:11:37,840
के लिए प्रेषक को उस बिट 8 को चालू करने की आवश्यकता है।

194
00:11:37,840 --> 00:11:40,558
जैसे पहले दो चेक हमें कॉलम को पिन करने देते हैं,

195
00:11:40,558 --> 00:11:43,000
ये अगले दो आपको पंक्ति को पिन करने देते हैं।

196
00:11:43,000 --> 00:11:48,400
उदाहरण के तौर पर, कल्पना करें कि ट्रांसमिशन के दौरान स्थिति 3 पर कोई त्रुटि है।

197
00:11:48,400 --> 00:11:52,980
खैर, यह पहले समता समूह को प्रभावित करता है, और यह दूसरे समता समूह को भी प्रभावित करता है,

198
00:11:52,980 --> 00:11:56,340
इसलिए रिसीवर को पता चलता है कि उस सही कॉलम में कहीं कोई त्रुटि है।

199
00:11:56,340 --> 00:11:58,998
लेकिन तीसरे समूह पर इसका कोई प्रभाव नहीं पड़ता,

200
00:11:58,998 --> 00:12:01,380
और चौथे समूह पर इसका कोई प्रभाव नहीं पड़ता।

201
00:12:01,380 --> 00:12:04,822
और यह रिसीवर को पहली पंक्ति तक त्रुटि को इंगित करने देता है,

202
00:12:04,822 --> 00:12:08,660
जिसका अर्थ आवश्यक रूप से स्थिति 3 है, ताकि वे त्रुटि को ठीक कर सकें।

203
00:12:08,660 --> 00:12:12,933
आप स्वयं को यह समझाने में कुछ समय का आनंद ले सकते हैं कि इन चार प्रश्नों के

204
00:12:12,933 --> 00:12:17,320
उत्तर वास्तव में आपको हमेशा एक विशिष्ट स्थान बताने देंगे, चाहे वे कहीं भी हों।

205
00:12:17,320 --> 00:12:20,510
वास्तव में, आपमें से जो चतुर लोग हैं वे इन प्रश्नों

206
00:12:20,510 --> 00:12:23,640
और बाइनरी काउंटिंग के बीच एक संबंध भी देख सकते हैं।

207
00:12:23,640 --> 00:12:27,119
और यदि आप ऐसा करते हैं, तो मुझे फिर से जोर देने दीजिए, रुकिए,

208
00:12:27,119 --> 00:12:30,880
इससे पहले कि मैं इसे खराब कर दूं, संबंध बनाने का स्वयं प्रयास करें।

209
00:12:30,880 --> 00:12:35,080
यदि आप सोच रहे हैं कि यदि समता बिट स्वयं प्रभावित हो जाए तो क्या होगा,

210
00:12:35,080 --> 00:12:36,560
तो आप इसे आज़मा सकते हैं।

211
00:12:36,560 --> 00:12:42,033
इस बारे में सोचने के लिए एक क्षण लें कि इन चार विशेष बिट्स के बीच किसी भी त्रुटि

212
00:12:42,033 --> 00:12:47,440
को किसी भी अन्य की तरह, चार प्रश्नों के एक ही समूह के साथ कैसे ट्रैक किया जाएगा।

213
00:12:47,440 --> 00:12:50,582
यह वास्तव में कोई फर्क नहीं पड़ता, क्योंकि दिन के अंत में हम जो चाहते हैं

214
00:12:50,582 --> 00:12:53,640
वह संदेश बिट्स की सुरक्षा करना है, त्रुटि सुधार बिट्स बस साथ चल रहे हैं।

215
00:12:53,640 --> 00:12:56,475
लेकिन उन बिट्स की सुरक्षा भी एक ऐसी चीज है जो स्वाभाविक

216
00:12:56,475 --> 00:12:59,260
रूप से एक उपोत्पाद के रूप में योजना से बाहर हो जाती है।

217
00:12:59,260 --> 00:13:02,380
आपको यह अनुमान लगाने में भी आनंद आ सकता है कि इसका पैमाना कैसा होगा।

218
00:13:02,380 --> 00:13:06,700
यदि हमने 256 बिट आकार के ब्लॉक का उपयोग किया है, उदाहरण के लिए,

219
00:13:06,700 --> 00:13:11,156
किसी स्थान को पिन करने के लिए, तो आपको किसी विशिष्ट स्थान पर अपना

220
00:13:11,156 --> 00:13:15,680
रास्ता खोजने के लिए केवल आठ हाँ या नहीं के प्रश्नों की आवश्यकता है।

221
00:13:15,680 --> 00:13:19,365
और याद रखें, प्रत्येक प्रश्न के लिए उचित समता जांच

222
00:13:19,365 --> 00:13:23,340
सेट करने के लिए केवल एक बिट छोड़ने की आवश्यकता होती है।

223
00:13:23,340 --> 00:13:25,386
आप में से कुछ लोग इसे पहले से ही देख सकते हैं,

224
00:13:25,386 --> 00:13:28,696
लेकिन हम बाद में एक या दो मिनट में ये प्रश्न क्या हैं यह जानने के व्यवस्थित

225
00:13:28,696 --> 00:13:29,960
तरीके के बारे में बात करेंगे।

226
00:13:29,960 --> 00:13:32,130
उम्मीद है कि हम यहां जो विकसित कर रहे हैं उसकी

227
00:13:32,130 --> 00:13:34,440
दक्षता की सराहना करने के लिए यह स्केच पर्याप्त है।

228
00:13:34,440 --> 00:13:37,771
पहली चीज़, उन आठ हाइलाइट किए गए समता बिट्स को छोड़कर,

229
00:13:37,771 --> 00:13:41,720
वह हो सकती है जो आप चाहते हैं, जो भी संदेश या डेटा आप चाहते हैं।

230
00:13:41,720 --> 00:13:48,001
8 बिट्स इस अर्थ में अनावश्यक हैं कि वे पूरी तरह से शेष संदेश द्वारा निर्धारित होते हैं,

231
00:13:48,001 --> 00:13:53,640
लेकिन यह संपूर्ण संदेश को कॉपी करने की तुलना में कहीं अधिक स्मार्ट तरीके से है।

232
00:13:53,640 --> 00:13:56,372
और फिर भी, इतनी कम छूट के बावजूद, आप किसी भी एक बिट

233
00:13:56,372 --> 00:13:59,000
त्रुटि को पहचानने और उसे ठीक करने में सक्षम होंगे।

234
00:13:59,000 --> 00:14:00,400
हां तकरीबन।

235
00:14:00,400 --> 00:14:04,617
ठीक है, तो यहां एक समस्या यह है कि यदि चार समता जांचों में से कोई भी

236
00:14:04,617 --> 00:14:08,896
त्रुटि का पता नहीं लगाता है, जिसका अर्थ है कि 8 बिट्स के विशेष रूप से

237
00:14:08,896 --> 00:14:12,686
चयनित उपसमुच्चय में सम समताएं हैं, जैसा कि प्रेषक ने चाहा था,

238
00:14:12,686 --> 00:14:17,760
तो इसका मतलब यह है कि कोई त्रुटि नहीं थी , या यह हमें स्थिति 0 तक सीमित कर देता है।

239
00:14:17,760 --> 00:14:20,845
आप देखते हैं, चार हां या ना वाले प्रश्नों के साथ,

240
00:14:20,845 --> 00:14:23,930
हमारे पास समता जांच के लिए 16 संभावित परिणाम हैं,

241
00:14:23,930 --> 00:14:29,174
और सबसे पहले यह ब्लॉक में 16 पदों में से 1 को इंगित करने के लिए बिल्कुल सही लगता है,

242
00:14:29,174 --> 00:14:33,000
लेकिन आपको 17वां परिणाम भी बताना होगा, कोई त्रुटि नहीं स्थिति।

243
00:14:33,000 --> 00:14:37,860
यहां समाधान वास्तव में बहुत सरल है, बस उस 0वें बिट के बारे में पूरी तरह से भूल जाएं।

244
00:14:37,860 --> 00:14:41,813
इसलिए जब हम अपनी चार समता जांच करते हैं और देखते हैं कि वे सभी सम हैं,

245
00:14:41,813 --> 00:14:44,320
तो इसका स्पष्ट अर्थ है कि कोई त्रुटि नहीं है।

246
00:14:44,320 --> 00:14:47,410
इसका मतलब यह है कि 16-बिट ब्लॉक के साथ काम करने के बजाय,

247
00:14:47,410 --> 00:14:52,182
हम 15-बिट ब्लॉक के साथ काम करते हैं, जहां 11 बिट्स संदेश ले जाने के लिए स्वतंत्र हैं और

248
00:14:52,182 --> 00:14:54,080
उनमें से 4 बिट्स अतिरेक के लिए हैं।

249
00:14:54,080 --> 00:14:56,659
और इसके साथ ही, अब हमारे पास वह है जिसे व्यवसाय

250
00:14:56,659 --> 00:14:59,400
के लोग 15-11 हैमिंग कोड के रूप में संदर्भित करेंगे।

251
00:14:59,400 --> 00:15:02,829
जैसा कि कहा गया है, एक ब्लॉक का आकार 2 की साफ शक्ति वाला होना अच्छा है,

252
00:15:02,829 --> 00:15:05,974
और एक चतुर तरीका है कि हम उस 0 बिट को अपने पास रख सकते हैं और इसे

253
00:15:05,974 --> 00:15:08,880
हमारे लिए थोड़ा अतिरिक्त काम करने के लिए प्राप्त कर सकते हैं।

254
00:15:08,880 --> 00:15:11,975
यदि हम इसे पूरे ब्लॉक में समता बिट के रूप में उपयोग करते हैं,

255
00:15:11,975 --> 00:15:16,320
तो यह हमें वास्तव में पता लगाने देता है, भले ही हम 2-बिट त्रुटियों को ठीक नहीं कर सकते।

256
00:15:16,320 --> 00:15:17,440
यह ऐसे काम करता है।

257
00:15:17,440 --> 00:15:20,492
उन चार विशेष त्रुटि-सुधार बिट्स को सेट करने के बाद,

258
00:15:20,492 --> 00:15:25,540
हम उस 0 वें को सेट करते हैं ताकि पूर्ण ब्लॉक की समता सामान्य समता जांच की तरह समान हो।

259
00:15:25,540 --> 00:15:30,112
अब, यदि एक भी बिट त्रुटि है, तो पूर्ण ब्लॉक की समता विषम होने के लिए टॉगल हो जाती है,

260
00:15:30,112 --> 00:15:33,940
लेकिन चार त्रुटि-सुधार जांचों के लिए धन्यवाद, हम इसे वैसे भी पकड़ लेंगे।

261
00:15:33,940 --> 00:15:38,873
हालाँकि, यदि दो त्रुटियाँ हैं, तो समग्र समता वापस सम होने पर टॉगल हो जाएगी,

262
00:15:38,873 --> 00:15:43,418
लेकिन रिसीवर अभी भी देखेगा कि उन चार समता जाँचों के साथ जो हो रहा है,

263
00:15:43,418 --> 00:15:45,820
उसके कारण कम से कम कुछ त्रुटि हुई है।

264
00:15:45,820 --> 00:15:48,253
इसलिए यदि वे समग्र रूप से एक समान समानता देखते हैं,

265
00:15:48,253 --> 00:15:50,593
लेकिन अन्य जांचों के साथ कुछ गैर-शून्य हो रहा है,

266
00:15:50,593 --> 00:15:52,980
तो यह उन्हें बताता है कि कम से कम दो त्रुटियां थीं।

267
00:15:52,980 --> 00:15:54,420
क्या वह चतुराई नहीं है?

268
00:15:54,420 --> 00:15:57,290
भले ही हम उन 2-बिट त्रुटियों को ठीक नहीं कर सकते हैं,

269
00:15:57,290 --> 00:16:00,692
बस उस एक छोटे से परेशान करने वाले 0वें बिट को काम पर वापस रखकर,

270
00:16:00,692 --> 00:16:02,340
यह हमें उनका पता लगाने देता है।

271
00:16:02,340 --> 00:16:06,540
यह काफी मानक है, इसे विस्तारित हैमिंग कोड के रूप में जाना जाता है।

272
00:16:06,540 --> 00:16:11,253
तकनीकी रूप से कहें तो, अब आपके पास हैमिंग कोड क्या करता है इसका पूरा विवरण है,

273
00:16:11,253 --> 00:16:13,580
कम से कम 16-बिट ब्लॉक के उदाहरण के लिए।

274
00:16:13,580 --> 00:16:17,688
लेकिन मुझे लगता है कि आपको शुरू से अंत तक एक पूरा उदाहरण देकर अपनी

275
00:16:17,688 --> 00:16:21,980
समझ की जांच करना और इस बिंदु तक सब कुछ मजबूत करना अधिक संतोषजनक लगेगा।

276
00:16:21,980 --> 00:16:25,100
हालाँकि, मैं आपके साथ इसमें कदम उठाऊंगा ताकि आप स्वयं जांच कर सकें।

277
00:16:25,100 --> 00:16:28,470
एक संदेश सेट करने के लिए, चाहे वह एक शाब्दिक संदेश हो जिसे आप

278
00:16:28,470 --> 00:16:33,199
अंतरिक्ष में अनुवाद कर रहे हों या कुछ डेटा जिसे आप समय के साथ संग्रहीत करना चाहते हों,

279
00:16:33,199 --> 00:16:35,700
पहला कदम इसे 11-बिट खंडों में विभाजित करना है।

280
00:16:35,700 --> 00:16:40,340
प्रत्येक भाग को त्रुटि-प्रतिरोधी 16-बिट ब्लॉक में पैक किया जाएगा।

281
00:16:40,340 --> 00:16:43,740
तो आइए इसे एक उदाहरण के रूप में लें और वास्तव में इस पर काम करें।

282
00:16:43,740 --> 00:16:45,380
आगे बढ़ो, वास्तव में यह करो!

283
00:16:45,380 --> 00:16:52,980
आइए रुकें और इस ब्लॉक को एक साथ रखने का प्रयास करें।

284
00:16:52,980 --> 00:16:53,980
ठीक है, आप तैयार हैं?

285
00:16:53,980 --> 00:17:00,508
याद रखें, 2 की अन्य शक्तियों के साथ स्थिति 0 त्रुटि सुधार कार्य के लिए आरक्षित है,

286
00:17:00,508 --> 00:17:05,700
इसलिए आप संदेश बिट्स को शेष सभी स्थानों पर क्रम से रखकर शुरू करें।

287
00:17:05,700 --> 00:17:09,600
आपको इस समूह में एक सम समता की आवश्यकता है, जो कि पहले से ही है,

288
00:17:09,600 --> 00:17:13,140
इसलिए आपको उस समता बिट को स्थिति 1 में 0 पर सेट करना चाहिए।

289
00:17:13,140 --> 00:17:19,260
अगला समूह एक विषम समता के साथ शुरू होता है, इसलिए आपको इसका समता बिट 1 पर सेट करना चाहिए।

290
00:17:19,260 --> 00:17:21,890
उसके बाद समूह एक विषम समता के साथ शुरू होता है,

291
00:17:21,890 --> 00:17:24,740
इसलिए आपको फिर से इसका समता बिट 1 पर सेट करना चाहिए।

292
00:17:24,740 --> 00:17:28,088
और अंतिम समूह में भी एक अजीब समानता है, जिसका अर्थ है

293
00:17:28,088 --> 00:17:31,500
कि हम उस बिट को स्थिति 8 में 1 के रूप में सेट करते हैं।

294
00:17:31,500 --> 00:17:36,000
और फिर अंतिम चरण के रूप में, पूर्ण ब्लॉक में अब एक सम समता है,

295
00:17:36,000 --> 00:17:41,500
जिसका अर्थ है कि आप उस बिट संख्या 0, व्यापक समता बिट को 0 पर सेट कर सकते हैं।

296
00:17:41,500 --> 00:17:45,015
इसलिए जैसे ही यह ब्लॉक भेजा जाता है, चार विशेष

297
00:17:45,015 --> 00:17:48,980
उपसमुच्चय और संपूर्ण ब्लॉक की समता सम हो जाएगी, या 0.

298
00:17:48,980 --> 00:17:53,620
अभ्यास के दूसरे भाग के रूप में, आइए आपसे प्राप्तकर्ता की भूमिका निभाएँ।

299
00:17:53,620 --> 00:17:56,289
बेशक, इसका मतलब यह होगा कि आप पहले से नहीं जानते कि यह संदेश क्या है,

300
00:17:56,289 --> 00:17:58,463
हो सकता है कि आप में से कुछ लोगों ने इसे याद कर लिया हो,

301
00:17:58,463 --> 00:18:00,180
लेकिन मान लीजिए कि आपने इसे याद नहीं किया है।

302
00:18:00,180 --> 00:18:04,478
मैं जो करने जा रहा हूं वह उस ब्लॉक में 0, 1, या 2 बिट्स को बदलना है,

303
00:18:04,478 --> 00:18:08,340
और फिर आपसे यह पता लगाने के लिए कहना है कि मैंने क्या किया है।

304
00:18:08,340 --> 00:18:13,460
तो फिर, रुकें और इस पर काम करने का प्रयास करें।

305
00:18:13,460 --> 00:18:21,475
ठीक है, तो अब आप रिसीवर के रूप में पहले समता समूह की जांच करें और आप देख

306
00:18:21,475 --> 00:18:29,820
सकते हैं कि यह सम है, इसलिए जो भी त्रुटि मौजूद है वह सम कॉलम में होनी चाहिए।

307
00:18:29,820 --> 00:18:35,735
अगला चेक हमें एक विषम संख्या देता है, जो हम दोनों को बताता है कि कम से कम एक त्रुटि है,

308
00:18:35,735 --> 00:18:38,760
और हमें इस विशिष्ट कॉलम में सीमित कर देता है।

309
00:18:38,760 --> 00:18:42,900
तीसरी जाँच सम है, संभावनाओं को और भी कम कर देती है।

310
00:18:42,900 --> 00:18:47,524
और अंतिम समता जांच अजीब है, जो हमें बताती है कि नीचे कहीं एक त्रुटि है,

311
00:18:47,524 --> 00:18:51,700
जिसे अब तक हम देख सकते हैं कि वह स्थिति संख्या 10 में होनी चाहिए।

312
00:18:51,700 --> 00:18:58,220
इसके अलावा, पूरे ब्लॉक की समता विषम है, जिससे हमें विश्वास हो गया कि एक फ्लिप था, दो नहीं।

313
00:18:58,220 --> 00:19:01,600
यदि यह तीन या अधिक है, तो सभी दांव बंद हो जाएंगे।

314
00:19:01,600 --> 00:19:06,334
उस बिट संख्या 10 को सही करने के बाद, सुधार के लिए उपयोग नहीं किए गए 11 बिट्स को

315
00:19:06,334 --> 00:19:09,767
बाहर निकालने से हमें मूल संदेश का प्रासंगिक खंड मिलता है,

316
00:19:09,767 --> 00:19:14,680
जिसे यदि आप रिवाइंड करते हैं और तुलना करते हैं तो वास्तव में वही होता है जिसके साथ

317
00:19:14,680 --> 00:19:16,160
हमने उदाहरण शुरू किया था।

318
00:19:16,160 --> 00:19:18,611
और अब जब आप जानते हैं कि यह सब हाथ से कैसे करना है,

319
00:19:18,611 --> 00:19:22,572
तो मैं आपको दिखाना चाहूंगा कि आप पायथन कोड की एक पंक्ति के साथ इस सभी तर्क के मुख्य

320
00:19:22,572 --> 00:19:23,940
भाग को कैसे पूरा कर सकते हैं।

321
00:19:23,940 --> 00:19:27,875
आप देखिए, जो मैंने आपको अभी तक नहीं बताया है वह यह है कि यह एल्गोरिदम वास्तव

322
00:19:27,875 --> 00:19:31,760
में कितना सुंदर है, किसी त्रुटि की स्थिति को इंगित करने के लिए मशीन प्राप्त

323
00:19:31,760 --> 00:19:34,571
करना कितना सरल है, इसे व्यवस्थित रूप से कैसे मापना है,

324
00:19:34,571 --> 00:19:38,506
और हम सभी को कैसे फ्रेम कर सकते हैं यह कई अलग-अलग समता जांचों के बजाय एक एकल

325
00:19:38,506 --> 00:19:39,580
ऑपरेशन के रूप में है।

326
00:19:39,580 --> 00:19:39,580
यह देखने के लिए कि मेरा क्या मतलब है, भाग 2 में मेरे साथ आएँ।

