1
00:00:00,000 --> 00:00:02,560
मैं मान रहा हूं कि यहां हर कोई भाग 1 से आ रहा है।

2
00:00:03,060 --> 00:00:06,565
हम हैमिंग कोड के बारे में बात कर रहे थे, डेटा का एक ब्लॉक बनाने का एक 

3
00:00:06,565 --> 00:00:09,270
तरीका जहां अधिकांश बिट्स एक सार्थक संदेश ले जाते हैं, 

4
00:00:09,270 --> 00:00:12,325
जबकि कुछ अन्य एक प्रकार की अतिरेक के रूप में कार्य करते हैं, 

5
00:00:12,325 --> 00:00:16,381
इस तरह से कि यदि कोई बिट फ़्लिप हो जाता है, तो या तो एक संदेश बिट या अतिरेक बिट, 

6
00:00:16,381 --> 00:00:19,987
इस ब्लॉक में कुछ भी, रिसीवर यह पहचानने में सक्षम होगा कि कोई त्रुटि थी, 

7
00:00:19,987 --> 00:00:21,240
और इसे कैसे ठीक किया जाए।

8
00:00:21,880 --> 00:00:24,520
वहां प्रस्तुत मूल विचार यह था कि त्रुटि तक पहुंचने के लिए 

9
00:00:24,520 --> 00:00:27,160
बाइनरी खोज के लिए एकाधिक समता जांच का उपयोग कैसे किया जाए।

10
00:00:28,980 --> 00:00:34,600
उस वीडियो में लक्ष्य हैमिंग कोड को यथासंभव व्यावहारिक और पुनः खोज योग्य बनाना था।

11
00:00:35,180 --> 00:00:37,997
लेकिन जैसे ही आप वास्तव में इसे सॉफ़्टवेयर या हार्डवेयर में लागू 

12
00:00:37,997 --> 00:00:40,685
करने के बारे में सोचना शुरू करते हैं, वह फ़्रेमिंग वास्तव में 

13
00:00:40,685 --> 00:00:43,460
कम बिक्री कर सकती है कि ये कोड वास्तव में कितने सुरुचिपूर्ण हैं।

14
00:00:43,920 --> 00:00:47,024
आप सोच सकते हैं कि आपको एक एल्गोरिदम लिखने की ज़रूरत है जो सभी 

15
00:00:47,024 --> 00:00:51,410
संभावित त्रुटि स्थानों पर नज़र रखता है और प्रत्येक चेक के साथ उस समूह को आधा कर देता है, 

16
00:00:51,410 --> 00:00:53,480
लेकिन वास्तव में यह उससे कहीं अधिक सरल है।

17
00:00:53,940 --> 00:00:58,980
यदि आप पिछले वीडियो में हमारे द्वारा की गई चार समता जांचों के उत्तरों को हां और ना के 

18
00:00:58,980 --> 00:01:04,080
बजाय 1s और 0s के रूप में पढ़ते हैं, तो यह वस्तुतः बाइनरी में त्रुटि की स्थिति बताता है।

19
00:01:04,780 --> 00:01:08,168
उदाहरण के लिए, बाइनरी में संख्या 7 0111 की तरह दिखती है, 

20
00:01:08,168 --> 00:01:11,260
अनिवार्य रूप से यह कहती है कि यह 4 प्लस 2 प्लस 1 है।

21
00:01:12,540 --> 00:01:17,620
और ध्यान दें कि स्थिति 7 कहाँ बैठती है, यह हमारे समता समूहों में से पहले, 

22
00:01:17,620 --> 00:01:21,740
और दूसरे, और तीसरे को प्रभावित करती है, लेकिन अंतिम को नहीं।

23
00:01:22,220 --> 00:01:24,753
इसलिए नीचे से ऊपर तक उन चार जांचों के परिणामों को 

24
00:01:24,753 --> 00:01:27,540
पढ़ने से वास्तव में त्रुटि की स्थिति का पता चल जाता है।

25
00:01:28,320 --> 00:01:31,658
उदाहरण 7 के बारे में कुछ खास नहीं है, यह सामान्य रूप से काम करता है, 

26
00:01:31,658 --> 00:01:35,820
और यह हार्डवेयर में पूरी योजना को लागू करने के तर्क को आश्चर्यजनक रूप से सरल बनाता है।

27
00:01:37,240 --> 00:01:40,647
अब यदि आप यह देखना चाहते हैं कि यह जादू क्यों होता है, 

28
00:01:40,647 --> 00:01:43,869
तो हमारी स्थिति के लिए इन 16 सूचकांक लेबलों को लें, 

29
00:01:43,869 --> 00:01:48,330
लेकिन उन्हें आधार 10 में लिखने के बजाय, आइए उन सभी को बाइनरी में लिखें, 

30
00:01:48,330 --> 00:01:49,880
0000 से 1111 तक चलते हुए।

31
00:01:50,559 --> 00:01:53,794
जैसे ही हम इन बाइनरी लेबलों को उनके बक्सों में वापस डालते हैं, 

32
00:01:53,794 --> 00:01:57,800
मैं इस बात पर जोर देना चाहता हूं कि वे वास्तव में भेजे जा रहे डेटा से अलग हैं।

33
00:01:58,320 --> 00:02:00,910
वे आपको और मुझे यह समझने में मदद करने के लिए एक वैचारिक 

34
00:02:00,910 --> 00:02:03,500
लेबल से ज्यादा कुछ नहीं हैं कि चार समता समूह कहां से आए।

35
00:02:04,140 --> 00:02:08,173
हम जो कुछ भी देख रहे हैं उसे बाइनरी में वर्णित करने की सुंदरता शायद इस भ्रम के 

36
00:02:08,173 --> 00:02:12,360
कारण कम हो गई है कि हम जो कुछ भी देख रहे हैं उसका वर्णन बाइनरी में किया जा रहा है।

37
00:02:13,020 --> 00:02:14,120
हालाँकि, यह इसके लायक है।

38
00:02:14,800 --> 00:02:19,080
अपना ध्यान केवल इन सभी लेबलों के अंतिम बिट पर केंद्रित करें, 

39
00:02:19,080 --> 00:02:23,220
और फिर उन स्थितियों को हाइलाइट करें जहां वह अंतिम बिट 1 है।

40
00:02:24,240 --> 00:02:27,695
हमें जो मिलता है वह हमारे चार समता समूहों में से पहला है, 

41
00:02:27,695 --> 00:02:31,509
जिसका अर्थ है कि आप उस पहले चेक की व्याख्या यह पूछ सकते हैं कि, 

42
00:02:31,509 --> 00:02:35,740
अरे, यदि कोई त्रुटि है, तो क्या उस त्रुटि की स्थिति में अंतिम बिट 1 है?

43
00:02:38,200 --> 00:02:41,239
इसी तरह, यदि आप दूसरे से अंतिम बिट पर ध्यान केंद्रित करते हैं, 

44
00:02:41,239 --> 00:02:43,844
और उन सभी स्थितियों को हाइलाइट करते हैं जहां वह 1 है, 

45
00:02:43,844 --> 00:02:46,160
तो आपको हमारी योजना से दूसरा समता समूह मिलता है।

46
00:02:46,740 --> 00:02:50,558
दूसरे शब्दों में, वह दूसरा चेक पूछ रहा है, अरे, मुझसे फिर से, 

47
00:02:50,558 --> 00:02:54,500
यदि कोई त्रुटि है, तो क्या उस स्थिति का दूसरा से अंतिम बिट 1 है?

48
00:02:55,760 --> 00:02:56,900
और इसी तरह।

49
00:02:57,220 --> 00:03:03,373
तीसरी समता जांच प्रत्येक स्थिति को कवर करती है जिसका तीसरा से अंतिम बिट चालू होता है, 

50
00:03:03,373 --> 00:03:08,740
और अंतिम अंतिम आठ स्थितियों को कवर करता है, वे जिनकी उच्चतम ऑर्डर बिट 1 है।

51
00:03:09,740 --> 00:03:14,220
हमने पहले जो कुछ भी किया वह इन चार प्रश्नों का उत्तर देने के समान है, 

52
00:03:14,220 --> 00:03:17,740
जो बदले में बाइनरी में किसी स्थिति को बताने के समान है।

53
00:03:19,620 --> 00:03:21,480
मुझे आशा है कि इससे दो बातें स्पष्ट हो जाएंगी।

54
00:03:22,040 --> 00:03:24,250
पहला यह है कि उन आकारों को ब्लॉक करने के लिए व्यवस्थित 

55
00:03:24,250 --> 00:03:26,460
रूप से सामान्यीकरण कैसे किया जाए जो दो की बड़ी घात हैं।

56
00:03:26,960 --> 00:03:30,229
यदि प्रत्येक स्थिति का वर्णन करने के लिए अधिक बिट्स की आवश्यकता होती है, 

57
00:03:30,229 --> 00:03:32,335
जैसे 64 स्थानों का वर्णन करने के लिए छह बिट्स, 

58
00:03:32,335 --> 00:03:35,470
तो उनमें से प्रत्येक बिट आपको समता समूहों में से एक देता है जिसे हमें 

59
00:03:35,470 --> 00:03:36,680
जांचने की आवश्यकता होती है।

60
00:03:38,400 --> 00:03:41,807
आपमें से जिन लोगों ने मैट पार्कर के साथ मेरी शतरंज की बिसात पहेली देखी होगी, 

61
00:03:41,807 --> 00:03:43,180
उन्हें यह सब बहुत परिचित लगेगा।

62
00:03:43,660 --> 00:03:46,242
यह वही मूल तर्क है, लेकिन एक अलग समस्या को हल कर रहा है, 

63
00:03:46,242 --> 00:03:48,780
और इसे 64-वर्ग वाली शतरंज की बिसात पर लागू किया जाता है।

64
00:03:49,880 --> 00:03:53,527
दूसरी बात जो मुझे आशा है कि यह स्पष्ट करती है वह यह है कि हमारे समता बिट्स 

65
00:03:53,527 --> 00:03:57,320
उन स्थितियों में क्यों बैठे हैं जो दो की घात हैं, उदाहरण के लिए 1, 2, 4, और 8।

66
00:03:58,000 --> 00:04:03,000
ये वे स्थितियाँ हैं जिनका द्विआधारी प्रतिनिधित्व केवल एक बिट चालू है।

67
00:04:03,600 --> 00:04:06,530
इसका मतलब यह है कि उनमें से प्रत्येक समता बिट चार 

68
00:04:06,530 --> 00:04:09,460
समता समूहों में से एक और केवल एक के अंदर बैठता है।

69
00:04:12,040 --> 00:04:16,453
आप इसे बड़े उदाहरणों में भी देख सकते हैं, जहां चाहे आप कितना भी बड़ा हो जाएं, 

70
00:04:16,453 --> 00:04:19,339
प्रत्येक समता बिट आसानी से केवल एक समूह को छूती है।

71
00:04:25,600 --> 00:04:29,959
एक बार जब आप समझ जाते हैं कि ये समता जाँचें जिन पर हमने अपना अधिकांश समय केंद्रित किया 

72
00:04:29,959 --> 00:04:33,918
है, बाइनरी में त्रुटि की स्थिति बताने के एक चतुर तरीके से ज्यादा कुछ नहीं हैं, 

73
00:04:33,918 --> 00:04:37,827
तो हम हैमिंग के बारे में सोचने के लिए एक अलग तरीके से संबंध बना सकते हैं कोड, 

74
00:04:37,827 --> 00:04:40,283
एक ऐसा जो यकीनन बहुत सरल और अधिक सुरुचिपूर्ण है, 

75
00:04:40,283 --> 00:04:43,240
और जिसे मूल रूप से कोड की एक पंक्ति के साथ लिखा जा सकता है।

76
00:04:43,660 --> 00:04:45,500
यह XOR फ़ंक्शन पर आधारित है.

77
00:04:46,940 --> 00:04:50,220
आपमें से जो लोग नहीं जानते उनके लिए XOR का मतलब एक्सक्लूसिव या है।

78
00:04:50,780 --> 00:04:56,678
जब आप दो बिट्स का एक्सओआर लेते हैं, तो यदि इनमें से कोई एक बिट चालू है तो यह 1 लौटाएगा, 

79
00:04:56,678 --> 00:04:59,360
लेकिन यदि दोनों चालू या बंद हैं तो नहीं।

80
00:05:00,100 --> 00:05:02,980
अलग-अलग शब्दों में, यह इन दो बिट्स की समता है।

81
00:05:03,540 --> 00:05:06,760
एक गणितज्ञ के रूप में, मैं इसके बारे में अतिरिक्त मॉड 2 के रूप में सोचना पसंद करता हूँ।

82
00:05:07,360 --> 00:05:11,297
हम आम तौर पर दो अलग-अलग बिट स्ट्रिंग्स के एक्सओआर के बारे में भी बात करते हैं, 

83
00:05:11,297 --> 00:05:13,440
जो मूल रूप से इस घटक को घटक द्वारा करता है।

84
00:05:13,680 --> 00:05:15,720
यह जोड़ की तरह है, लेकिन जहां आप कभी नहीं ले जाते।

85
00:05:16,500 --> 00:05:19,544
फिर, गणितीय रूप से अधिक इच्छुक लोग इसे दो वैक्टर जोड़ने 

86
00:05:19,544 --> 00:05:22,480
और मॉड 2 को कम करने के रूप में सोचना पसंद कर सकते हैं।

87
00:05:23,500 --> 00:05:28,522
यदि आप अभी कुछ पायथन खोलते हैं और दो पूर्णांकों के बीच कैरेट ऑपरेशन लागू करते हैं, 

88
00:05:28,522 --> 00:05:32,940
तो यह हुड के नीचे उन संख्याओं के बिट प्रतिनिधित्व के अलावा यही कर रहा है।

89
00:05:34,960 --> 00:05:38,916
आपके और मेरे लिए मुख्य बिंदु यह है कि कई अलग-अलग बिट स्ट्रिंग्स 

90
00:05:38,916 --> 00:05:42,873
का एक्सओआर लेना प्रभावी रूप से अलग-अलग समूहों के समूह की पैरोडी 

91
00:05:42,873 --> 00:05:47,140
की गणना करने का एक तरीका है, जैसे कि कॉलम के साथ, सभी एक ही झटके में।

92
00:05:51,260 --> 00:05:55,069
यह हमें हमारे हैमिंग कोड एल्गोरिदम से कई समता जांचों के बारे में सोचने का एक 

93
00:05:55,069 --> 00:05:58,780
आसान तरीका देता है क्योंकि सभी को एक ही ऑपरेशन में एक साथ पैक किया जाता है।

94
00:05:59,479 --> 00:06:02,180
हालाँकि पहली नज़र में यह बहुत अलग दिखता है।

95
00:06:02,820 --> 00:06:07,689
विशेष रूप से 16 स्थितियों को बाइनरी में लिखें, जैसा कि हमने पहले किया था, 

96
00:06:07,689 --> 00:06:12,690
और अब उन स्थितियों को हाइलाइट करें जहां संदेश बिट को 1 पर चालू किया गया है, 

97
00:06:12,690 --> 00:06:17,100
और फिर इन स्थितियों को एक बड़े कॉलम में इकट्ठा करें और एक्सओआर लें।

98
00:06:19,260 --> 00:06:22,506
आप शायद अनुमान लगा सकते हैं कि परिणामस्वरूप नीचे बैठे 4 बिट्स उन 

99
00:06:22,506 --> 00:06:25,753
4 समता जांचों के समान हैं जिन्हें हम जानते हैं और पसंद करते हैं, 

100
00:06:25,753 --> 00:06:29,200
लेकिन वास्तव में ऐसा क्यों है इसके बारे में सोचने के लिए एक क्षण लें।

101
00:06:32,220 --> 00:06:37,005
उदाहरण के लिए, यह अंतिम कॉलम उन सभी स्थितियों की गिनती कर रहा है, जिनका अंतिम बिट 1 है, 

102
00:06:37,005 --> 00:06:40,594
लेकिन हम पहले से ही केवल हाइलाइट की गई स्थितियों तक ही सीमित हैं, 

103
00:06:40,594 --> 00:06:44,998
इसलिए यह प्रभावी रूप से गिनती कर रहा है कि पहले समता समूह से कितनी हाइलाइट की गई 

104
00:06:44,998 --> 00:06:45,760
स्थिति आई हैं।

105
00:06:46,240 --> 00:06:46,800
समझ आया?

106
00:06:49,080 --> 00:06:54,024
इसी तरह, अगला कॉलम गिनता है कि दूसरे समता समूह में कितनी स्थितियाँ हैं, 

107
00:06:54,024 --> 00:07:00,000
वे स्थितियाँ जिनका दूसरा से अंतिम बिट 1 है, और जिन्हें हाइलाइट भी किया गया है, इत्यादि।

108
00:07:00,260 --> 00:07:03,960
यह वास्तव में उसी चीज के परिप्रेक्ष्य में एक छोटा सा बदलाव है जो हम कर रहे हैं।

109
00:07:07,760 --> 00:07:09,600
और इसलिए आप जानते हैं कि यह यहाँ से कहाँ जाता है।

110
00:07:10,000 --> 00:07:12,661
प्रेषक यह सुनिश्चित करने के लिए कुछ विशेष समता 

111
00:07:12,661 --> 00:07:15,720
बिट्स को टॉगल करने के लिए जिम्मेदार है कि योग 0000 हो।

112
00:07:15,720 --> 00:07:21,686
अब एक बार जब हमारे पास यह इस तरह हो जाता है, तो यह हमें यह सोचने का एक बहुत अच्छा 

113
00:07:21,686 --> 00:07:27,580
तरीका देता है कि नीचे ये चार परिणामी बिट्स सीधे त्रुटि की स्थिति क्यों बताते हैं।

114
00:07:28,460 --> 00:07:31,860
मान लीजिए कि इस ब्लॉक में कुछ बिट 0 से 1 पर टॉगल हो जाता है।

115
00:07:32,600 --> 00:07:38,210
इसका मतलब यह है कि उस बिट की स्थिति अब कुल XOR में शामिल होने जा रही है, 

116
00:07:38,210 --> 00:07:43,820
जो योग को 0 से बदलकर इस नए शामिल मूल्य, त्रुटि की स्थिति में बदल देती है।

117
00:07:44,460 --> 00:07:49,360
थोड़ा कम स्पष्ट रूप से, यदि कोई त्रुटि है जो 1 को 0 में बदल देती है तो भी यही सच है।

118
00:07:50,180 --> 00:07:52,894
आप देखिए, यदि आप एक बिट स्ट्रिंग को दो बार एक साथ जोड़ते हैं, 

119
00:07:52,894 --> 00:07:55,259
तो यह वैसा ही है जैसे कि वहां इसका बिल्कुल भी न होना, 

120
00:07:55,259 --> 00:07:57,580
मूल रूप से क्योंकि इस दुनिया में 1 प्लस 1 बराबर 0 है।

121
00:07:57,580 --> 00:08:00,906
इसलिए कुल योग में इस स्थिति की एक प्रति जोड़ने का 

122
00:08:00,906 --> 00:08:04,300
वही प्रभाव होता है जो हम इसे आगे बढ़ा रहे होते हैं।

123
00:08:05,160 --> 00:08:10,700
और वह प्रभाव, फिर से, यह है कि यहां नीचे कुल परिणाम त्रुटि की स्थिति बताता है।

124
00:08:13,039 --> 00:08:17,289
यह समझाने के लिए कि यह कितना सुंदर है, मैं आपको पायथन कोड की वह एक पंक्ति दिखाता हूँ 

125
00:08:17,289 --> 00:08:21,440
जिसका मैंने पहले उल्लेख किया था, जो रिसीवर के अंत में लगभग सभी तर्कों को पकड़ लेगा।

126
00:08:22,080 --> 00:08:26,924
हम डेटा ब्लॉक को अनुकरण करने के लिए 16 1s और 0s की एक यादृच्छिक सरणी बनाकर शुरू करेंगे, 

127
00:08:26,924 --> 00:08:30,668
और मैं इसे बिट्स नाम दूंगा, लेकिन व्यवहार में यह कुछ ऐसा होगा जो हम 

128
00:08:30,668 --> 00:08:34,467
एक प्रेषक से प्राप्त कर रहे हैं, और इसके बजाय यादृच्छिक होने के कारण 

129
00:08:34,467 --> 00:08:37,000
इसमें 5 समता बिट्स के साथ 11 डेटा बिट्स होंगे।

130
00:08:37,000 --> 00:08:40,576
यदि मैं फ़ंक्शन एन्यूमरेट बिट्स को कॉल करता हूं, 

131
00:08:40,576 --> 00:08:47,000
तो यह प्रत्येक बिट को संबंधित इंडेक्स के साथ जोड़ता है, इस मामले में 0 से 15 तक चलता है।

132
00:08:48,180 --> 00:08:52,074
इसलिए यदि हम एक सूची बनाते हैं जो इन सभी जोड़ियों पर लूप करती है, 

133
00:08:52,074 --> 00:08:56,795
जो जोड़े जो i की तरह दिखते हैं, और फिर हम केवल i मान, केवल सूचकांक निकालते हैं, 

134
00:08:56,795 --> 00:09:01,340
खैर यह उतना रोमांचक नहीं है, हम बस उन सूचकांकों को 0 से 15 तक वापस लाते हैं .

135
00:09:01,680 --> 00:09:05,403
लेकिन अगर हम केवल बिट होने पर ऐसा करने की शर्त जोड़ते हैं, 

136
00:09:05,403 --> 00:09:08,368
जिसका अर्थ है कि यदि वह बिट 1 है और 0 नहीं है, 

137
00:09:08,368 --> 00:09:12,660
तो यह केवल उन स्थितियों को बाहर निकालता है जहां संबंधित बिट चालू है।

138
00:09:13,380 --> 00:09:20,360
इस मामले में ऐसा लगता है कि वे स्थितियाँ 0, 4, 6, 9, आदि हैं।

139
00:09:20,720 --> 00:09:23,779
हम जो चाहते हैं वह उन सभी स्थितियों को, चालू किए गए बिट्स की 

140
00:09:23,779 --> 00:09:27,240
स्थितियों को एक साथ इकट्ठा करना है, और फिर उन्हें एक साथ XOR करना है।

141
00:09:29,180 --> 00:09:33,220
पायथन में ऐसा करने के लिए, मुझे पहले कुछ उपयोगी फ़ंक्शन आयात करने दीजिए।

142
00:09:33,900 --> 00:09:36,111
इस तरह हम इस सूची में कम() को कॉल कर सकते हैं, 

143
00:09:36,111 --> 00:09:38,700
और इसे कम करने के लिए XOR फ़ंक्शन का उपयोग कर सकते हैं।

144
00:09:39,100 --> 00:09:42,680
यह मूल रूप से सूची के माध्यम से अपना रास्ता खाता है, रास्ते में एक्सओआर ले जाता है।

145
00:09:44,800 --> 00:09:49,440
यदि आप चाहें, तो आप उस XOR फ़ंक्शन को कहीं से भी आयात किए बिना स्पष्ट रूप से लिख सकते हैं।

146
00:09:51,940 --> 00:09:57,613
तो फिलहाल ऐसा लगता है कि अगर हम 16 बिट्स के अपने यादृच्छिक ब्लॉक पर ऐसा करते हैं, 

147
00:09:57,613 --> 00:10:01,280
तो यह 9 लौटाता है, जिसका बाइनरी प्रतिनिधित्व 1001 है।

148
00:10:01,980 --> 00:10:05,398
हम इसे यहां नहीं करेंगे, लेकिन आप एक फ़ंक्शन लिख सकते हैं जहां प्रेषक 

149
00:10:05,398 --> 00:10:09,599
आवश्यकतानुसार चार समता बिट्स सेट करने के लिए उस बाइनरी प्रतिनिधित्व का उपयोग करता है, 

150
00:10:09,599 --> 00:10:13,017
अंततः इस ब्लॉक को उस स्थिति में ले जाता है जहां बिट्स की पूरी सूची पर 

151
00:10:13,017 --> 00:10:15,460
कोड की इस पंक्ति को चलाने पर रिटर्न मिलता है एक 0.

152
00:10:16,080 --> 00:10:20,100
इसे एक अच्छी तरह से तैयार ब्लॉक माना जाएगा।

153
00:10:20,100 --> 00:10:23,562
अच्छी बात यह है कि यदि हम शोर से यादृच्छिक त्रुटि का अनुकरण करते 

154
00:10:23,562 --> 00:10:26,172
हुए इस सूची में से किसी एक बिट को टॉगल करते हैं, 

155
00:10:26,172 --> 00:10:30,220
तो यदि आप कोड की इसी पंक्ति को चलाते हैं, तो यह उस त्रुटि को प्रिंट करता है।

156
00:10:30,960 --> 00:10:31,520
क्या वह साफ़-सुथरा नहीं है?

157
00:10:31,820 --> 00:10:36,384
आप इस ब्लॉक को अचानक से प्राप्त कर सकते हैं, इस पर इस एकल पंक्ति को चला सकते हैं, 

158
00:10:36,384 --> 00:10:41,060
और यह स्वचालित रूप से किसी त्रुटि की स्थिति या यदि कोई त्रुटि नहीं है तो 0 बता देगा।

159
00:10:42,500 --> 00:10:44,840
और यहां साइज 16 के बारे में कुछ खास नहीं है।

160
00:10:44,840 --> 00:10:49,860
यदि आपके पास, मान लीजिए, 256 बिट्स की सूची है, तो कोड की वही पंक्ति काम करेगी।

161
00:10:51,880 --> 00:10:55,093
कहने की जरूरत नहीं है, यहां लिखने के लिए और भी कोड हैं, 

162
00:10:55,093 --> 00:10:58,766
जैसे 2-बिट त्रुटियों का पता लगाने के लिए मेटा पैरिटी जांच करना, 

163
00:10:58,766 --> 00:11:03,760
लेकिन विचार यह है कि हमारी योजना के लगभग सभी मुख्य तर्क एक ही एक्सओआर कटौती पर आते हैं।

164
00:11:06,120 --> 00:11:10,170
अब, सामान्य रूप से बाइनरी और एक्सओआर और सॉफ़्टवेयर के साथ आपकी सुविधा के आधार पर, 

165
00:11:10,170 --> 00:11:13,233
आपको या तो यह परिप्रेक्ष्य थोड़ा भ्रमित करने वाला लग सकता है, 

166
00:11:13,233 --> 00:11:17,432
या इतना अधिक सुरुचिपूर्ण और सरल कि आप सोच रहे होंगे कि हमने शुरुआत से ही इसकी शुरुआत 

167
00:11:17,432 --> 00:11:18,420
क्यों नहीं की -जाना।

168
00:11:19,140 --> 00:11:23,072
संक्षेप में कहें तो, हार्डवेयर में हैमिंग कोड को बहुत सीधे लागू करते समय मल्टीपल 

169
00:11:23,072 --> 00:11:25,790
पैरिटी चेक परिप्रेक्ष्य के बारे में सोचना आसान होता है, 

170
00:11:25,790 --> 00:11:29,626
और सॉफ़्टवेयर में इसे उच्च स्तर से करते समय XOR परिप्रेक्ष्य के बारे में सोचना 

171
00:11:29,626 --> 00:11:30,500
सबसे आसान होता है।

172
00:11:31,360 --> 00:11:36,091
पहला वास्तव में हाथ से करना सबसे आसान है, और मुझे लगता है कि यह इन सबके अंतर्निहित 

173
00:11:36,091 --> 00:11:39,169
मूल अंतर्ज्ञान को स्थापित करने में बेहतर काम करता है, 

174
00:11:39,169 --> 00:11:43,786
जो यह है कि एक त्रुटि का पता लगाने के लिए आवश्यक जानकारी ब्लॉक के आकार के लॉग से 

175
00:11:43,786 --> 00:11:48,289
संबंधित है , या दूसरे शब्दों में, जैसे-जैसे ब्लॉक का आकार दोगुना होता जाता है, 

176
00:11:48,289 --> 00:11:50,000
यह एक बार में एक बिट बढ़ता है।

177
00:11:51,020 --> 00:11:53,540
यहां प्रासंगिक तथ्य यह है कि वह जानकारी सीधे तौर पर इस 

178
00:11:53,540 --> 00:11:56,060
बात से मेल खाती है कि हमें कितनी अतिरेक की आवश्यकता है।

179
00:11:56,660 --> 00:11:59,910
यह वास्तव में ज्यादातर लोगों की त्वरित प्रतिक्रिया के विपरीत है जब वे पहली 

180
00:11:59,910 --> 00:12:03,030
बार किसी संदेश को त्रुटियों के प्रति लचीला बनाने के बारे में सोचते हैं, 

181
00:12:03,030 --> 00:12:06,540
जहां आम तौर पर पूरे संदेश की नकल करना पहली प्रवृत्ति होती है जो दिमाग में आती है।

182
00:12:07,500 --> 00:12:11,619
और फिर, वैसे, यह एक और तरीका है जिसमें आप कभी-कभी हैमिंग कोड प्रस्तुत करते हुए देखते हैं, 

183
00:12:11,619 --> 00:12:14,000
जहां आप संदेश को एक बड़े मैट्रिक्स से गुणा करते हैं।

184
00:12:14,670 --> 00:12:18,065
यह अच्छा है क्योंकि यह इसे रैखिक कोड के व्यापक परिवार से जोड़ता है, 

185
00:12:18,065 --> 00:12:22,161
लेकिन मुझे लगता है कि यह लगभग कोई अंतर्ज्ञान नहीं देता है कि यह कहां से आता है या 

186
00:12:22,161 --> 00:12:23,060
इसका आकार कैसा है।

187
00:12:25,200 --> 00:12:29,303
और स्केलिंग की बात करते हुए, आप देख सकते हैं कि जैसे-जैसे हम ब्लॉक आकार बढ़ाते हैं, 

188
00:12:29,303 --> 00:12:31,160
इस योजना की दक्षता बेहतर होती जाती है।

189
00:12:35,000 --> 00:12:38,886
उदाहरण के लिए, हमने देखा कि 256 बिट्स के साथ, आप उस स्थान का केवल 3% 

190
00:12:38,886 --> 00:12:42,660
अतिरेक के लिए उपयोग कर रहे हैं, और यह वहां से बेहतर होता जा रहा है।

191
00:12:43,300 --> 00:12:45,830
जैसे-जैसे समता बिट्स की संख्या एक-एक करके बढ़ती जाती है, 

192
00:12:45,830 --> 00:12:47,340
ब्लॉक का आकार दोगुना होता जाता है।

193
00:12:49,000 --> 00:12:52,728
और यदि आप इसे चरम सीमा तक ले जाते हैं, तो आपके पास एक मिलियन बिट्स 

194
00:12:52,728 --> 00:12:57,682
वाला एक ब्लॉक हो सकता है, जहां आप वस्तुतः अपने समता जांच के साथ 20 प्रश्न खेल रहे होंगे, 

195
00:12:57,682 --> 00:13:00,020
और यह केवल 21 समता बिट्स का उपयोग करता है।

196
00:13:00,740 --> 00:13:03,829
और यदि आप एक लाख बिट्स को देखने और एक त्रुटि का पता लगाने के बारे 

197
00:13:03,829 --> 00:13:07,060
में सोचने के लिए पीछे हटते हैं, तो यह वास्तव में पागलपन जैसा लगता है।

198
00:13:08,199 --> 00:13:12,839
निस्संदेह, समस्या यह है कि बड़े ब्लॉक के साथ, एक या दो से अधिक बिट त्रुटियाँ 

199
00:13:12,839 --> 00:13:17,660
देखने की संभावना बढ़ जाती है, और हैमिंग कोड इससे आगे कुछ भी संभाल नहीं पाते हैं।

200
00:13:18,320 --> 00:13:21,282
इसलिए व्यवहार में, आप जो चाहते हैं वह सही आकार ढूंढना 

201
00:13:21,282 --> 00:13:24,300
है ताकि बहुत अधिक बिट फ़्लिप की संभावना बहुत अधिक न हो।

202
00:13:26,600 --> 00:13:29,754
इसके अलावा, व्यवहार में, त्रुटियां छोटे-छोटे विस्फोटों में आती हैं, 

203
00:13:29,754 --> 00:13:31,934
जो एक ब्लॉक को पूरी तरह से बर्बाद कर देती हैं, 

204
00:13:31,934 --> 00:13:35,459
इसलिए कई अलग-अलग ब्लॉकों में त्रुटियों के विस्फोट को फैलाने में मदद करने के 

205
00:13:35,459 --> 00:13:38,104
लिए एक सामान्य रणनीति उन ब्लॉकों को इस तरह से जोड़ना है, 

206
00:13:38,104 --> 00:13:40,980
इससे पहले कि वे समाप्त हो जाएं बाहर भेजा या संग्रहीत किया गया।

207
00:13:45,580 --> 00:13:49,395
फिर, इसमें से बहुत कुछ को अधिक आधुनिक कोड द्वारा पूरी तरह से म्यूट कर दिया गया है, 

208
00:13:49,395 --> 00:13:52,429
जैसे कि अधिक सामान्यतः उपयोग किया जाने वाला रीड-सोलोमन एल्गोरिदम, 

209
00:13:52,429 --> 00:13:55,280
जो विशेष रूप से विस्फोट त्रुटियों को अच्छी तरह से संभालता है, 

210
00:13:55,280 --> 00:13:58,820
और इसे प्रति ब्लॉक बड़ी संख्या में त्रुटियों के लिए लचीला बनाया जा सकता है। .

211
00:13:59,360 --> 00:14:01,340
लेकिन यह अगली बार का विषय है।

212
00:14:02,500 --> 00:14:05,246
अपनी पुस्तक द आर्ट ऑफ डूइंग साइंस एंड इंजीनियरिंग में, 

213
00:14:05,246 --> 00:14:08,891
हैमिंग ने आश्चर्यजनक रूप से स्पष्ट रूप से बताया है कि इस कोड की उनकी खोज 

214
00:14:08,891 --> 00:14:09,940
कितनी टेढ़ी-मेढ़ी थी।

215
00:14:10,620 --> 00:14:14,128
उन्होंने सबसे पहले बिट्स को उच्च आयामी जाली के हिस्सों में व्यवस्थित करने 

216
00:14:14,128 --> 00:14:17,780
और इस तरह की अजीब चीजों से संबंधित सभी प्रकार की विभिन्न योजनाओं की कोशिश की।

217
00:14:18,300 --> 00:14:23,366
यह विचार कि किसी त्रुटि की स्थिति बताने के लिए समता जांच प्राप्त करना संभव हो सकता है, 

218
00:14:23,366 --> 00:14:27,792
हेमिंग को तभी आया जब वह कई अन्य विश्लेषणों के बाद पीछे हटे और पूछा, ठीक है, 

219
00:14:27,792 --> 00:14:31,520
मैं सबसे कुशल क्या कर सकता हूं क्या आप इस बारे में सोच सकते हैं?

220
00:14:32,620 --> 00:14:36,947
वह इस बारे में भी स्पष्ट थे कि यह कितना महत्वपूर्ण है कि समता जांच पहले से ही 

221
00:14:36,947 --> 00:14:41,220
उनके दिमाग में थी, जो कि आज की तुलना में 1940 के दशक में बहुत कम आम रही होगी।

222
00:14:41,920 --> 00:14:45,096
इस पुस्तक में लगभग आधा दर्जन बार उन्होंने लुई पाश्चर के इस 

223
00:14:45,096 --> 00:14:48,220
कथन का संदर्भ दिया है कि भाग्य तैयार दिमाग का साथ देता है।

224
00:14:49,320 --> 00:14:52,211
चतुर विचार अक्सर बाद में भ्रामक रूप से सरल दिखते हैं, 

225
00:14:52,211 --> 00:14:54,300
जिससे उनकी सराहना करना आसान हो जाता है।

226
00:14:54,960 --> 00:14:59,698
अभी मेरी ईमानदार आशा यह है कि हैमिंग कोड, या कम से कम ऐसे कोड की संभावना, 

227
00:14:59,698 --> 00:15:01,300
आपको लगभग स्पष्ट लगती है।

228
00:15:01,660 --> 00:15:05,235
लेकिन आपको यह सोचकर खुद को मूर्ख नहीं बनाना चाहिए कि वे वास्तव में स्पष्ट हैं, 

229
00:15:05,235 --> 00:15:06,820
क्योंकि वे निश्चित रूप से नहीं हैं।

230
00:15:07,880 --> 00:15:11,584
चतुर विचारों के भ्रामक रूप से आसान दिखने का एक कारण यह है कि हम केवल 

231
00:15:11,584 --> 00:15:14,323
अंतिम परिणाम देखते हैं, जो गड़बड़ था उसे साफ करना, 

232
00:15:14,323 --> 00:15:17,866
सभी गलत मोड़ों का कभी उल्लेख नहीं करना, किसी समस्या की शुरुआत में 

233
00:15:17,866 --> 00:15:22,537
अन्वेषण योग्य संभावनाओं का स्थान कितना विशाल है, इसकी कम बिक्री करना समाधान प्रक्रिया, 

234
00:15:22,537 --> 00:15:22,860
वह सब।

235
00:15:23,820 --> 00:15:24,900
लेकिन यह सामान्य तौर पर सच है.

236
00:15:24,900 --> 00:15:27,784
मुझे लगता है कि कुछ विशेष आविष्कारों के लिए, एक दूसरा, 

237
00:15:27,784 --> 00:15:30,040
गहरा कारण है कि हम उनकी कम सराहना करते हैं।

238
00:15:30,840 --> 00:15:33,390
सूचना सिद्धांत पर क्लाउड शैनन के मौलिक पेपर के साथ, 

239
00:15:33,390 --> 00:15:37,462
बिट्स के संदर्भ में जानकारी के बारे में सोचना वास्तव में 1948 तक एक पूर्ण सिद्धांत 

240
00:15:37,462 --> 00:15:38,640
में परिवर्तित हो गया था।

241
00:15:39,280 --> 00:15:42,540
यह अनिवार्य रूप से तब समवर्ती था जब हैमिंग ने अपना एल्गोरिदम विकसित किया था।

242
00:15:43,300 --> 00:15:48,042
यह वही मूलभूत पेपर था जिसने एक निश्चित अर्थ में दिखाया कि कुशल त्रुटि सुधार हमेशा 

243
00:15:48,042 --> 00:15:52,900
संभव है, चाहे बिट फ़्लिप की संभावना कितनी भी अधिक क्यों न हो, कम से कम सिद्धांत में।

244
00:15:53,700 --> 00:15:56,392
वैसे, बहुत अलग-अलग चीजों पर काम करने के बावजूद, 

245
00:15:56,392 --> 00:16:01,160
शैनन और हैमिंग ने बेल लैब्स में एक कार्यालय साझा किया, जो यहां शायद ही संयोग लगता है।

246
00:16:02,380 --> 00:16:05,734
कई दशक तेजी से आगे बढ़े, और इन दिनों, हममें से कई लोग छोटी-छोटी 

247
00:16:05,734 --> 00:16:09,037
बातों और सूचनाओं के बारे में सोचने में इतने डूबे हुए हैं कि इस 

248
00:16:09,037 --> 00:16:12,340
बात को नजरअंदाज करना आसान है कि सोचने का यह तरीका कितना अलग था।

249
00:16:13,100 --> 00:16:17,650
विडंबना यह है कि जो विचार भविष्य की पीढ़ी के सोचने के तरीकों को सबसे गहराई से 

250
00:16:17,650 --> 00:16:22,260
आकार देते हैं, वे भविष्य की पीढ़ी को वास्तव में उनकी तुलना में अधिक सरल लगेंगे।

