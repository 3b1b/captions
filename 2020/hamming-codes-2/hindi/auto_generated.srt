1
00:00:00,000 --> 00:00:08,620
क्या आपने कभी सोचा है कि किसी सीडी या डीवीडी को स्क्रैच करना

2
00:00:08,620 --> 00:00:10,900
और उसमें जो कुछ भी संग्रहीत है उसे प्लेबैक करना कैसे संभव है?

3
00:00:10,900 --> 00:00:15,280
स्क्रैच वास्तव में डिस्क पर 1s और 0s को प्रभावित करता है, इसलिए यह संग्रहीत किए गए

4
00:00:15,280 --> 00:00:20,500
डेटा से भिन्न डेटा को पढ़ता है, लेकिन जब तक इसे वास्तव में स्क्रैच नहीं किया जाता

5
00:00:20,500 --> 00:00:26,540
है, तब तक इसके द्वारा पढ़े गए बिट्स ठीक उसी फ़ाइल में डीकोड हो जाते हैं जो

6
00:00:26,540 --> 00:00:28,400
उस पर एन्कोड किया गया था, ए उन सभी त्रुटियों के बावजूद, बिट कॉपी के लिए बिट।

7
00:00:28,400 --> 00:00:32,800
गणितीय चतुराई का एक पूरा ढेर है जो हमें डेटा संग्रहीत करने की अनुमति देता है, और उतना

8
00:00:32,800 --> 00:00:36,840
ही महत्वपूर्ण रूप से डेटा संचारित करने की अनुमति देता है, जो त्रुटियों के प्रति लचीला है।

9
00:00:36,840 --> 00:00:41,480
ठीक है, ठीक है, वास्तव में ऐसा करने का कोई

10
00:00:41,480 --> 00:00:42,480
तरीका निकालने के लिए उतनी चतुराई की आवश्यकता नहीं है।

11
00:00:42,480 --> 00:00:47,660
कोई भी फ़ाइल, चाहे वह वीडियो हो या ध्वनि या पाठ, कोई कोड,

12
00:00:47,660 --> 00:00:50,960
कोई छवि, जो भी हो, अंततः 1s और 0s का कुछ अनुक्रम है।

13
00:00:50,960 --> 00:00:55,340
और जो भी बिट फ़्लिप हो जाता है उसे ठीक करने की एक

14
00:00:55,340 --> 00:00:57,780
सरल रणनीति यह होगी कि प्रत्येक बिट की तीन प्रतियां संग्रहीत की जाएं।

15
00:00:57,780 --> 00:01:02,240
फिर इस फ़ाइल को पढ़ने वाली मशीन इन तीन प्रतियों की तुलना कर सकती है और

16
00:01:02,240 --> 00:01:07,440
जब भी कोई विसंगति हो तो हमेशा 3 में से सर्वश्रेष्ठ 2 को ले सकती है।

17
00:01:07,440 --> 00:01:11,560
लेकिन इसका मतलब यह है कि आपके स्थान का दो-तिहाई हिस्सा अतिरेक के लिए उपयोग किया जा रहा है।

18
00:01:11,560 --> 00:01:15,360
और फिर भी, छोड़ी गई सारी जगह के लिए, इस बात की कोई पुख्ता गारंटी

19
00:01:15,360 --> 00:01:18,120
नहीं है कि यदि एक से अधिक बिट फ़्लिप हो जाते हैं तो क्या होगा।

20
00:01:18,120 --> 00:01:21,960
इससे भी अधिक दिलचस्प सवाल यह है कि इसे कैसे बनाया जाए

21
00:01:21,960 --> 00:01:24,740
ताकि यथासंभव कम जगह छोड़ते हुए त्रुटियों को ठीक किया जा सके।

22
00:01:24,740 --> 00:01:28,500
उदाहरण के लिए, जिस विधि के बारे में आप इस वीडियो के बारे में जानेंगे, उसका उपयोग करके आप अपना डेटा 256-बिट ब्लॉक में

23
00:01:28,500 --> 00:01:35,840
संग्रहीत कर सकते हैं, जहां प्रत्येक ब्लॉक 9 बिट्स, 9 का उपयोग करता है! एक प्रकार की अतिरेक के रूप में कार्य

24
00:01:35,840 --> 00:01:41,000
करने के लिए, और अन्य 247 बिट्स आपके इच्छित सार्थक संदेश या डेटा को ले जाने के लिए स्वतंत्र हैं।

25
00:01:41,000 --> 00:01:44,740
और यह अब भी होगा कि यदि यहां कोई भी बिट फ़्लिप हो जाता है, तो केवल इस

26
00:01:44,740 --> 00:01:49,640
ब्लॉक को देखकर और कुछ नहीं, एक मशीन यह पहचानने में सक्षम होगी कि कोई त्रुटि थी और

27
00:01:49,640 --> 00:01:53,120
सटीक रूप से यह कहां थी ताकि वह जान सके कि इसे कैसे ठीक किया जाए। .

28
00:01:53,140 --> 00:01:55,540
और ईमानदारी से कहूं तो यह जादू जैसा लगता है।

29
00:01:55,540 --> 00:01:59,400
और इस विशेष योजना के लिए, यदि दो बिट फ़्लिप हो जाते हैं, तो मशीन कम से कम यह पता

30
00:01:59,400 --> 00:02:03,180
लगाने में सक्षम होगी कि दो त्रुटियाँ थीं, हालाँकि उसे यह नहीं पता होगा कि उन्हें कैसे ठीक किया जाए।

31
00:02:03,180 --> 00:02:08,140
हम थोड़ी देर बाद इस बारे में बात करेंगे कि विभिन्न आकारों वाले ब्लॉकों के लिए यह पैमाना कैसा है।

32
00:02:08,140 --> 00:02:12,620
वे विधियाँ जो आपको इस तरह की त्रुटियों को ठीक करने देती हैं,

33
00:02:12,620 --> 00:02:13,880
यथोचित रूप से त्रुटि सुधार कोड के रूप में जानी जाती हैं।

34
00:02:13,880 --> 00:02:18,220
पिछली शताब्दी के अधिकांश समय में, यह क्षेत्र आश्चर्यजनक रूप से गहन गणित का एक समृद्ध स्रोत

35
00:02:18,220 --> 00:02:23,000
रहा है जो हमारे द्वारा प्रतिदिन उपयोग किए जाने वाले उपकरणों में शामिल हो जाता है।

36
00:02:23,000 --> 00:02:27,740
यहां लक्ष्य आपको शुरुआती उदाहरणों में से एक, जिसे हैमिंग कोड के नाम

37
00:02:27,740 --> 00:02:29,660
से जाना जाता है, की पूरी तरह से समझ प्रदान करना है।

38
00:02:29,660 --> 00:02:32,620
और वैसे, जिस तरह से मैं इस वीडियो की संरचना के बारे में सोच रहा हूं वह

39
00:02:32,620 --> 00:02:37,060
इसे यथासंभव सीधे समझाने के बारे में कम है, और यहां और वहां थोड़े से मार्गदर्शन

40
00:02:37,060 --> 00:02:40,220
के साथ आपको इसे अपने लिए आविष्कार करने के लिए प्रेरित करने का मामला अधिक है।

41
00:02:40,220 --> 00:02:44,100
इसलिए जब आपको लगे कि किसी बिंदु पर आप देख रहे हैं कि यह कहां जा रहा है, तो

42
00:02:44,100 --> 00:02:47,180
उस क्षण रुकें, मेरे बताने से पहले सक्रिय रूप से अनुमान लगाएं कि योजना क्या होने वाली है।

43
00:02:47,180 --> 00:02:51,500
साथ ही, यदि आप चाहते हैं कि आपकी समझ हार्डवेयर स्तर तक पहुंचे, तो बेन

44
00:02:51,500 --> 00:02:55,160
ईटर ने इसके साथ मिलकर एक वीडियो बनाया है जिसमें आपको दिखाया गया है कि

45
00:02:55,160 --> 00:02:59,520
वास्तव में ब्रेडबोर्ड पर हैमिंग कोड कैसे लागू किया जाए, जो बेहद संतोषजनक है।

46
00:02:59,520 --> 00:03:03,120
आपको पता होना चाहिए, हैमिंग कोड रीड-सोलोमन एल्गोरिथ्म की तरह अधिक आधुनिक कोड के रूप में व्यापक रूप

47
00:03:03,120 --> 00:03:08,040
से उपयोग नहीं किए जाते हैं, लेकिन शुरुआत में यह कार्य कितना असंभव लगता है और एक बार

48
00:03:08,040 --> 00:03:14,240
यह कितना उचित लगता है, इसके बीच एक निश्चित जादू है। आप हैमिंग के बारे में जानें।

49
00:03:14,240 --> 00:03:19,080
त्रुटि सुधार का मूल सिद्धांत यह है कि सभी संभावित संदेशों के

50
00:03:19,300 --> 00:03:22,860
विशाल स्थान में, केवल कुछ उपसमूह को ही वैध संदेश माना जाएगा।

51
00:03:22,860 --> 00:03:29,100
सादृश्य के रूप में, सही वर्तनी वाले शब्दों बनाम गलत वर्तनी वाले शब्दों के बारे में सोचें।

52
00:03:29,100 --> 00:03:33,340
जब भी कोई वैध संदेश बदल जाता है, तो प्राप्तकर्ता निकटतम वैध पड़ोसी को जो दिखाई देता है

53
00:03:33,340 --> 00:03:38,380
उसे ठीक करने के लिए जिम्मेदार होता है, जैसा कि आप टाइपो के मामले में कर सकते हैं।

54
00:03:38,380 --> 00:03:43,100
हालाँकि, इस तरह के संदेशों को कुशलतापूर्वक वर्गीकृत करने के लिए एक ठोस

55
00:03:43,100 --> 00:03:47,160
एल्गोरिदम के साथ आने के लिए एक निश्चित चतुराई की आवश्यकता होती है।

56
00:03:47,160 --> 00:03:52,060
कहानी 1940 के दशक में शुरू होती है, जब एक युवा रिचर्ड हैमिंग बेल लैब्स

57
00:03:52,060 --> 00:03:55,900
के लिए काम कर रहे थे, और उनके कुछ काम में एक बहुत बड़े महंगे

58
00:03:55,900 --> 00:03:57,420
पंच कार्ड कंप्यूटर का उपयोग करना शामिल था, जिस तक उनकी सीमित पहुंच थी।

59
00:03:57,420 --> 00:04:01,200
और जो प्रोग्राम वह इसके माध्यम से डालता रहा वह

60
00:04:01,200 --> 00:04:03,140
विफल होता रहा, क्योंकि कभी-कभी कुछ गलत पढ़ा जाता था।

61
00:04:03,140 --> 00:04:07,140
आविष्कार की भट्ठी निराशा से वह इतना तंग आ गया कि

62
00:04:07,140 --> 00:04:09,280
उसने दुनिया का पहला त्रुटि सुधार कोड का आविष्कार किया।

63
00:04:09,280 --> 00:04:13,020
हैमिंग कोड को फ्रेम करने के कई अलग-अलग तरीके हैं, लेकिन पहली बार हम इसके माध्यम

64
00:04:13,020 --> 00:04:16,620
से जाने वाले हैं जिस तरह से हैमिंग ने खुद उनके बारे में सोचा था।

65
00:04:16,620 --> 00:04:21,400
आइए एक उदाहरण का उपयोग करें जो सरल है, लेकिन बहुत सरल नहीं है, 16 बिट्स का एक ब्लॉक।

66
00:04:21,400 --> 00:04:25,700
हम इन बिट्स की स्थिति को 0 से 15 तक क्रमांकित करेंगे।

67
00:04:25,700 --> 00:04:30,520
जो वास्तविक डेटा हम संग्रहीत करना चाहते हैं, वह इनमें से केवल 12 बिट्स को

68
00:04:30,520 --> 00:04:33,920
बनाने वाला है, जबकि 4 स्थान एक प्रकार के अतिरेक के रूप में आरक्षित हैं।

69
00:04:33,920 --> 00:04:38,120
यहां निरर्थक शब्द का मतलब केवल कॉपी करना नहीं है, आखिरकार, वे 4 बिट्स

70
00:04:38,120 --> 00:04:40,200
हमें डेटा को आंख मूंदकर कॉपी करने के लिए पर्याप्त जगह नहीं देते हैं।

71
00:04:40,200 --> 00:04:44,880
इसके बजाय, उन्हें बहुत अधिक सूक्ष्म और चतुर प्रकार के अतिरेक की

72
00:04:44,880 --> 00:04:48,740
आवश्यकता होगी, कोई नई जानकारी नहीं जोड़नी होगी, बल्कि लचीलापन जोड़ना होगा।

73
00:04:48,740 --> 00:04:52,620
आप उम्मीद कर सकते हैं कि ये 4 विशेष बिट्स अच्छी तरह से एक साथ पैक किए जाएंगे,

74
00:04:52,620 --> 00:04:56,400
शायद अंत में या ऐसा कुछ, लेकिन जैसा कि आप देखेंगे, उन्हें उन स्थितियों में बैठाना जो 2

75
00:04:56,400 --> 00:05:00,320
की शक्तियाँ हैं, अंत तक कुछ ऐसा करने की अनुमति देता है जो वास्तव में सुरुचिपूर्ण है।

76
00:05:00,320 --> 00:05:05,420
यह आपको इस बारे में भी थोड़ा संकेत दे सकता है कि यह बड़े ब्लॉकों के लिए कैसा है।

77
00:05:05,420 --> 00:05:09,220
इसके अलावा तकनीकी रूप से यह केवल 11 बिट डेटा बनकर रह जाता है, आप पाएंगे कि स्थिति

78
00:05:09,220 --> 00:05:14,260
0 पर जो होता है उसमें थोड़ी बारीकियां हैं, लेकिन अभी इसके बारे में चिंता न करें।

79
00:05:14,280 --> 00:05:18,640
किसी भी त्रुटि सुधार एल्गोरिदम की तरह, इसमें दो खिलाड़ी शामिल होंगे, एक प्रेषक जो

80
00:05:18,640 --> 00:05:23,200
इन 4 विशेष बिट्स को सेट करने के लिए जिम्मेदार है, और एक रिसीवर जो

81
00:05:23,200 --> 00:05:26,360
किसी प्रकार की जांच करने और त्रुटियों को ठीक करने के लिए जिम्मेदार है।

82
00:05:26,360 --> 00:05:30,040
बेशक, प्रेषक और रिसीवर शब्द वास्तव में उन मशीनों या सॉफ़्टवेयर को संदर्भित

83
00:05:30,040 --> 00:05:34,040
करते हैं जो सभी जांच कर रहे हैं, और संदेश का विचार वास्तव

84
00:05:34,040 --> 00:05:35,480
में मोटे तौर पर भंडारण जैसी चीजों को शामिल करने के लिए है।

85
00:05:35,480 --> 00:05:39,320
आख़िरकार, डेटा संग्रहीत करना एक संदेश को एक स्थान से दूसरे

86
00:05:39,320 --> 00:05:42,640
स्थान के बजाय अतीत से भविष्य में भेजने जैसा ही है।

87
00:05:42,640 --> 00:05:46,700
तो यह सेटअप है, लेकिन इससे पहले कि हम आगे बढ़ें हमें एक संबंधित विचार के

88
00:05:46,700 --> 00:05:51,080
बारे में बात करने की ज़रूरत है जो हैमिंग के दिमाग में उनकी खोज के समय

89
00:05:51,080 --> 00:05:55,520
ताजा था, एक ऐसी विधि जो आपको किसी भी बिट त्रुटि का पता लगाने देती है,

90
00:05:55,520 --> 00:05:57,300
लेकिन उन्हें ठीक करने की नहीं, ज्ञात है व्यवसाय में समता जाँच के रूप में।

91
00:05:57,300 --> 00:06:01,300
समता जांच के लिए, हम केवल एक बिट को अलग करते हैं जिसे ट्यूनिंग

92
00:06:01,300 --> 00:06:04,940
के लिए प्रेषक जिम्मेदार है, और बाकी संदेश ले जाने के लिए स्वतंत्र हैं।

93
00:06:04,940 --> 00:06:10,380
इस विशेष बिट का एकमात्र काम यह सुनिश्चित करना है कि

94
00:06:10,380 --> 00:06:12,100
संदेश में 1 की कुल संख्या एक सम संख्या है।

95
00:06:12,100 --> 00:06:16,920
उदाहरण के लिए अभी, 1 की कुल संख्या 7 है, यह अजीब है, इसलिए प्रेषक को

96
00:06:16,920 --> 00:06:20,960
उस विशेष बिट को 1 करने के लिए फ़्लिप करना होगा, जिससे गिनती सम हो जाएगी।

97
00:06:20,960 --> 00:06:25,320
लेकिन यदि ब्लॉक पहले से ही 1 की सम संख्या के साथ

98
00:06:25,320 --> 00:06:27,480
शुरू हुआ होता, तो इस विशेष बिट को 0 पर रखा जाता।

99
00:06:27,480 --> 00:06:31,640
यह बहुत ही सरल, भ्रामक रूप से सरल है, लेकिन यह किसी संदेश में कहीं भी परिवर्तन के

100
00:06:31,640 --> 00:06:37,760
विचार को जानकारी के एक टुकड़े में प्रतिबिंबित करने का एक अविश्वसनीय रूप से सुंदर तरीका है।

101
00:06:37,760 --> 00:06:43,680
ध्यान दें कि यदि इस संदेश का कोई भी अंश 0 से 1 या 1 से 0 तक

102
00:06:43,680 --> 00:06:48,140
फ़्लिप हो जाता है, तो यह 1 की कुल गिनती को सम से विषम में बदल देता है।

103
00:06:48,140 --> 00:06:52,000
इसलिए यदि आप रिसीवर हैं, आप इस संदेश को देखते हैं, और आपको 1 की

104
00:06:52,000 --> 00:06:56,580
एक विषम संख्या दिखाई देती है, तो आप निश्चित रूप से जान सकते हैं कि

105
00:06:56,580 --> 00:06:58,700
कुछ त्रुटि हुई है, भले ही आपको पता न हो कि यह कहां थी।

106
00:06:58,700 --> 00:07:02,820
शब्दजाल में, चाहे बिट्स के समूह में 1s की सम या विषम

107
00:07:02,820 --> 00:07:04,940
संख्या हो, इसे इसकी समता के रूप में जाना जाता है।

108
00:07:04,940 --> 00:07:09,140
आप संख्याओं का भी उपयोग कर सकते हैं और कह सकते हैं कि समता 0 या 1 है, जो

109
00:07:09,140 --> 00:07:11,320
आमतौर पर तब अधिक सहायक होती है जब आप इस विचार के साथ गणित करना शुरू करते हैं।

110
00:07:11,320 --> 00:07:15,200
और यह विशेष बिट जिसे प्रेषक समता को नियंत्रित करने

111
00:07:15,200 --> 00:07:18,020
के लिए उपयोग करता है, समता बिट कहलाता है।

112
00:07:18,020 --> 00:07:22,460
और वास्तव में, हमें स्पष्ट होना चाहिए, यदि रिसीवर एक विषम समता देखता है, तो इसका मतलब

113
00:07:22,460 --> 00:07:26,920
यह नहीं है कि केवल एक त्रुटि थी, 3 त्रुटियां, या 5, या कोई अन्य विषम संख्या

114
00:07:26,920 --> 00:07:29,560
हो सकती है, लेकिन वे निश्चित रूप से जान सकते हैं कि यह 0 नहीं था.

115
00:07:29,560 --> 00:07:34,880
दूसरी ओर, यदि 2 त्रुटियाँ थीं, या कोई सम संख्या में त्रुटियाँ थीं, तो 1

116
00:07:34,880 --> 00:07:39,560
की अंतिम गिनती अभी भी सम होगी, इसलिए प्राप्तकर्ता को पूरा विश्वास नहीं हो सकता

117
00:07:39,560 --> 00:07:43,360
है कि एक सम संख्या का मतलब यह है कि संदेश त्रुटि-मुक्त है। .

118
00:07:43,360 --> 00:07:47,860
आप शिकायत कर सकते हैं कि जो संदेश केवल 2 बिट फ़्लिप से गड़बड़

119
00:07:47,860 --> 00:07:49,760
हो जाता है वह बहुत कमज़ोर होता है, और आप बिल्कुल सही होंगे।

120
00:07:49,760 --> 00:07:54,480
ध्यान रखें, हालाँकि, त्रुटि का पता लगाने या सुधार करने की कोई विधि नहीं है जो आपको

121
00:07:54,480 --> 00:07:59,720
100% विश्वास दिला सके कि आपको प्राप्त संदेश वही है जो भेजने वाले ने चाहा है।

122
00:07:59,720 --> 00:08:03,760
आख़िरकार, पर्याप्त यादृच्छिक शोर हमेशा शुद्ध संयोग से एक वैध

123
00:08:03,760 --> 00:08:05,920
संदेश को दूसरे वैध संदेश में बदल सकता है।

124
00:08:05,920 --> 00:08:10,520
इसके बजाय, लक्ष्य एक ऐसी योजना बनाना है जो त्रुटियों की एक निश्चित अधिकतम संख्या तक

125
00:08:10,520 --> 00:08:16,480
मजबूत हो, या शायद इस तरह की झूठी सकारात्मकता की संभावना को कम कर सके।

126
00:08:16,480 --> 00:08:20,940
समता जांच अपने आप में काफी कमजोर हैं, लेकिन एक पूर्ण संदेश में

127
00:08:20,940 --> 00:08:25,640
परिवर्तन के विचार को एक बिट तक सीमित करके, वे हमें जो देते

128
00:08:25,640 --> 00:08:28,000
हैं वह अधिक परिष्कृत योजनाओं के लिए एक शक्तिशाली बिल्डिंग ब्लॉक है।

129
00:08:28,000 --> 00:08:32,880
उदाहरण के लिए, जब हैमिंग यह पहचानने का एक तरीका खोज रहा था कि त्रुटि कहाँ हुई है, न

130
00:08:32,880 --> 00:08:37,160
कि केवल यह कि यह घटित हुई है, तो उसकी मुख्य अंतर्दृष्टि यह थी कि यदि आप कुछ समता

131
00:08:37,160 --> 00:08:42,040
जाँचों को पूर्ण संदेश पर नहीं, बल्कि कुछ सावधानीपूर्वक चयनित उपसमूहों पर लागू करते हैं, तो आप पूछ सकते

132
00:08:42,040 --> 00:08:46,840
हैं प्रश्नों की एक अधिक परिष्कृत श्रृंखला जो किसी भी एक बिट त्रुटि के स्थान को इंगित करती है।

133
00:08:46,840 --> 00:08:51,280
कुल मिलाकर भावना कुछ-कुछ 20 प्रश्नों का खेल खेलने जैसा है, जिसमें हां या ना

134
00:08:51,280 --> 00:08:54,300
में ऐसे प्रश्न पूछे जाते हैं जो संभावनाओं की जगह को आधा कर देते हैं।

135
00:08:54,300 --> 00:08:58,840
उदाहरण के लिए, मान लें कि हम केवल इन 8 बिट्स,

136
00:08:58,840 --> 00:08:59,840
सभी विषम संख्या वाली स्थितियों पर समता जांच करते हैं।

137
00:09:00,400 --> 00:09:04,560
फिर यदि कोई त्रुटि पाई जाती है, तो यह रिसीवर को इस बारे में थोड़ी अधिक जानकारी

138
00:09:04,560 --> 00:09:09,160
देता है कि विशेष रूप से त्रुटि कहाँ है, अर्थात् यह एक विषम स्थिति में है।

139
00:09:09,160 --> 00:09:14,360
यदि उन 8 बिट्स के बीच कोई त्रुटि नहीं पाई जाती है, तो इसका मतलब

140
00:09:14,360 --> 00:09:17,240
है कि कोई त्रुटि नहीं है, या यह कहीं सम स्थिति में बैठता है।

141
00:09:17,240 --> 00:09:21,560
आप सोच सकते हैं कि समता जांच को आधे बिट्स तक सीमित करने से यह कम

142
00:09:21,560 --> 00:09:25,460
प्रभावी हो जाता है, लेकिन जब इसे अन्य अच्छी तरह से चुनी गई जांचों के

143
00:09:25,460 --> 00:09:29,720
साथ संयोजन में किया जाता है, तो यह हमें कुछ अधिक शक्तिशाली प्रदान करता है।

144
00:09:29,720 --> 00:09:34,440
वास्तव में उस समता जाँच को स्थापित करने के लिए, याद रखें, इसमें कुछ विशेष बिट निर्धारित

145
00:09:34,440 --> 00:09:37,600
करने की आवश्यकता होती है जिसका उस पूर्ण समूह की समता के लिए नियंत्रण होता है।

146
00:09:37,600 --> 00:09:39,920
आइए यहां केवल स्थिति 1 चुनें।

147
00:09:39,920 --> 00:09:43,960
दिखाए गए उदाहरण के लिए, इन 8 बिट्स की समता वर्तमान में विषम है, इसलिए प्रेषक

148
00:09:43,960 --> 00:09:48,220
उस समता बिट को टॉगल करने के लिए जिम्मेदार है, और अब यह सम है।

149
00:09:48,220 --> 00:09:51,040
यह 4 समता जांचों में से केवल 1 है जो हम करेंगे।

150
00:09:51,040 --> 00:09:55,560
दूसरा चेक ग्रिड के दाहिने आधे भाग पर 8 बिट्स में से

151
00:09:55,560 --> 00:09:56,880
है, कम से कम जैसा कि हमने इसे यहां खींचा है।

152
00:09:56,880 --> 00:10:02,520
इस बार हम स्थिति 2 को समता बिट के रूप में उपयोग कर सकते हैं, इसलिए इन 8 बिट्स में पहले

153
00:10:02,520 --> 00:10:07,160
से ही एक सम समता है, और प्रेषक उस बिट संख्या 2 को अपरिवर्तित छोड़कर अच्छा महसूस कर सकता है।

154
00:10:07,160 --> 00:10:11,040
फिर दूसरे छोर पर, यदि रिसीवर इस समूह की समता की जांच करता है और उन्हें पता चलता है कि

155
00:10:11,040 --> 00:10:15,960
यह अजीब है, तो उन्हें पता चल जाएगा कि त्रुटि दाईं ओर इन 8 बिट्स में से कहीं है।

156
00:10:15,960 --> 00:10:21,260
अन्यथा इसका मतलब है कि या तो कोई त्रुटि नहीं है, या त्रुटि बाएं आधे हिस्से में कहीं है।

157
00:10:21,260 --> 00:10:24,040
या मुझे लगता है कि दो त्रुटियाँ हो सकती थीं, लेकिन अभी

158
00:10:24,040 --> 00:10:27,080
हम यह मानेंगे कि पूरे ब्लॉक में अधिकतम एक त्रुटि है।

159
00:10:27,080 --> 00:10:29,160
इससे अधिक के लिए चीजें पूरी तरह से टूट जाती हैं।

160
00:10:29,160 --> 00:10:32,920
यहां, इससे पहले कि हम अगली दो जांचों पर गौर करें, एक पल के लिए यह सोचें कि जब आप

161
00:10:32,920 --> 00:10:35,880
उन पर एक साथ विचार करते हैं तो ये पहली दो जांचें हमें क्या करने की अनुमति देती हैं।

162
00:10:35,880 --> 00:10:40,240
मान लीजिए कि आपको विषम स्तंभों और दाएँ आधे भाग के बीच एक त्रुटि का पता चलता है।

163
00:10:40,240 --> 00:10:43,940
इसका आवश्यक अर्थ यह है कि त्रुटि अंतिम कॉलम में कहीं है।

164
00:10:43,940 --> 00:10:48,280
यदि विषम कॉलम में कोई त्रुटि नहीं थी, लेकिन दाहिने आधे हिस्से में एक त्रुटि

165
00:10:48,280 --> 00:10:50,520
थी, तो यह आपको बताता है कि यह दूसरे से अंतिम कॉलम में है।

166
00:10:50,520 --> 00:10:54,640
इसी तरह यदि विषम कॉलम में कोई त्रुटि है, लेकिन दाहिने आधे हिस्से

167
00:10:54,640 --> 00:10:56,560
में नहीं, तो आप जानते हैं कि यह दूसरे कॉलम में कहीं है।

168
00:10:56,560 --> 00:11:00,560
और यदि उन दोनों समता जांचों में से कोई भी कुछ भी पता नहीं लगाता है, तो

169
00:11:00,560 --> 00:11:03,760
इसका मतलब है कि एकमात्र स्थान जहां त्रुटि हो सकती है वह सबसे बाएं कॉलम में है।

170
00:11:03,760 --> 00:11:06,480
लेकिन इसका सीधा मतलब यह भी हो सकता है कि कोई त्रुटि ही नहीं है।

171
00:11:06,480 --> 00:11:10,800
यह कहने का एक विस्तृत तरीका है कि दो समता

172
00:11:10,800 --> 00:11:11,800
जांचों से हम कॉलम को पिन कर सकते हैं।

173
00:11:11,800 --> 00:11:14,000
यहां से, आप शायद अनुमान लगा सकते हैं कि आगे क्या होगा।

174
00:11:14,000 --> 00:11:16,240
हम मूल रूप से वही काम करते हैं लेकिन पंक्तियों के लिए।

175
00:11:16,240 --> 00:11:21,040
समता बिट के रूप में स्थिति 4 का उपयोग करते हुए, विषम पंक्तियों पर समता जांच की जाएगी।

176
00:11:21,040 --> 00:11:25,480
तो इस उदाहरण में उस समूह में पहले से ही सम

177
00:11:25,480 --> 00:11:26,480
समता है, इसलिए बिट 4 को 0 पर सेट किया जाएगा।

178
00:11:26,480 --> 00:11:31,280
और अंत में समता बिट के रूप में स्थिति 8 का उपयोग

179
00:11:31,280 --> 00:11:32,280
करते हुए नीचे की दो पंक्तियों पर एक समता जांच होती है।

180
00:11:32,280 --> 00:11:35,840
इस मामले में, ऐसा लगता है कि समूह को समता प्रदान करने के

181
00:11:35,840 --> 00:11:37,840
लिए प्रेषक को उस बिट 8 को चालू करने की आवश्यकता है।

182
00:11:37,840 --> 00:11:41,360
जैसे पहले दो चेक हमें कॉलम को पिन करने देते हैं,

183
00:11:41,360 --> 00:11:43,000
ये अगले दो आपको पंक्ति को पिन करने देते हैं।

184
00:11:43,000 --> 00:11:48,400
उदाहरण के तौर पर, कल्पना करें कि ट्रांसमिशन के दौरान स्थिति 3 पर कोई त्रुटि है।

185
00:11:48,400 --> 00:11:52,620
खैर, यह पहले समता समूह को प्रभावित करता है, और यह दूसरे समता समूह को भी प्रभावित

186
00:11:52,620 --> 00:11:56,340
करता है, इसलिए रिसीवर को पता चलता है कि उस सही कॉलम में कहीं कोई त्रुटि है।

187
00:11:56,340 --> 00:12:01,380
लेकिन तीसरे समूह पर इसका कोई प्रभाव नहीं पड़ता, और चौथे समूह पर इसका कोई प्रभाव नहीं पड़ता।

188
00:12:01,380 --> 00:12:05,460
और यह रिसीवर को पहली पंक्ति तक त्रुटि को इंगित करने देता है, जिसका

189
00:12:05,460 --> 00:12:08,660
अर्थ आवश्यक रूप से स्थिति 3 है, ताकि वे त्रुटि को ठीक कर सकें।

190
00:12:08,660 --> 00:12:12,640
आप स्वयं को यह समझाने में कुछ समय का आनंद ले सकते हैं कि इन चार प्रश्नों

191
00:12:12,680 --> 00:12:17,320
के उत्तर वास्तव में आपको हमेशा एक विशिष्ट स्थान बताने देंगे, चाहे वे कहीं भी हों।

192
00:12:17,320 --> 00:12:22,640
वास्तव में, आपमें से जो चतुर लोग हैं वे इन प्रश्नों

193
00:12:22,640 --> 00:12:23,640
और बाइनरी काउंटिंग के बीच एक संबंध भी देख सकते हैं।

194
00:12:23,640 --> 00:12:27,840
और यदि आप ऐसा करते हैं, तो मुझे फिर से जोर देने दीजिए, रुकिए,

195
00:12:27,840 --> 00:12:30,880
इससे पहले कि मैं इसे खराब कर दूं, संबंध बनाने का स्वयं प्रयास करें।

196
00:12:30,880 --> 00:12:35,560
यदि आप सोच रहे हैं कि यदि समता बिट स्वयं प्रभावित

197
00:12:35,560 --> 00:12:36,560
हो जाए तो क्या होगा, तो आप इसे आज़मा सकते हैं।

198
00:12:36,560 --> 00:12:40,720
इस बारे में सोचने के लिए एक क्षण लें कि इन चार विशेष बिट्स के बीच किसी भी त्रुटि

199
00:12:40,720 --> 00:12:47,440
को किसी भी अन्य की तरह, चार प्रश्नों के एक ही समूह के साथ कैसे ट्रैक किया जाएगा।

200
00:12:47,440 --> 00:12:50,500
यह वास्तव में कोई फर्क नहीं पड़ता, क्योंकि दिन के अंत में हम जो चाहते हैं

201
00:12:50,500 --> 00:12:53,640
वह संदेश बिट्स की सुरक्षा करना है, त्रुटि सुधार बिट्स बस साथ चल रहे हैं।

202
00:12:53,640 --> 00:12:57,120
लेकिन उन बिट्स की सुरक्षा भी एक ऐसी चीज है जो स्वाभाविक रूप

203
00:12:57,120 --> 00:12:59,260
से एक उपोत्पाद के रूप में योजना से बाहर हो जाती है।

204
00:12:59,260 --> 00:13:02,380
आपको यह अनुमान लगाने में भी आनंद आ सकता है कि इसका पैमाना कैसा होगा।

205
00:13:02,380 --> 00:13:08,040
यदि हमने 256 बिट आकार के ब्लॉक का उपयोग किया है, उदाहरण के लिए, किसी स्थान को पिन करने के लिए,

206
00:13:08,040 --> 00:13:15,680
तो आपको किसी विशिष्ट स्थान पर अपना रास्ता खोजने के लिए केवल आठ हाँ या नहीं के प्रश्नों की आवश्यकता है।

207
00:13:15,680 --> 00:13:19,680
और याद रखें, प्रत्येक प्रश्न के लिए उचित समता जांच सेट

208
00:13:19,680 --> 00:13:23,340
करने के लिए केवल एक बिट छोड़ने की आवश्यकता होती है।

209
00:13:23,340 --> 00:13:26,960
आप में से कुछ लोग इसे पहले ही देख सकते हैं, लेकिन हम बाद में एक या

210
00:13:26,960 --> 00:13:29,960
दो मिनट में ये प्रश्न क्या हैं यह जानने के व्यवस्थित तरीके के बारे में बात करेंगे।

211
00:13:29,960 --> 00:13:33,440
उम्मीद है कि हम यहां जो विकसित कर रहे हैं उसकी

212
00:13:33,440 --> 00:13:34,440
दक्षता की सराहना करने के लिए यह स्केच पर्याप्त है।

213
00:13:34,440 --> 00:13:38,440
पहली चीज़, उन आठ हाइलाइट किए गए समता बिट्स को छोड़कर, वह हो सकती

214
00:13:38,440 --> 00:13:41,720
है जो आप चाहते हैं, जो भी संदेश या डेटा आप चाहते हैं।

215
00:13:41,720 --> 00:13:45,480
8 बिट्स इस अर्थ में अनावश्यक हैं कि वे पूरी तरह से शेष संदेश द्वारा निर्धारित होते

216
00:13:45,480 --> 00:13:53,640
हैं, लेकिन यह संपूर्ण संदेश को कॉपी करने की तुलना में कहीं अधिक स्मार्ट तरीके से है।

217
00:13:53,640 --> 00:13:58,000
और फिर भी, इतनी कम छूट के बावजूद, आप किसी भी एक

218
00:13:58,000 --> 00:13:59,000
बिट त्रुटि को पहचानने और उसे ठीक करने में सक्षम होंगे।

219
00:13:59,000 --> 00:14:00,400
हां तकरीबन।

220
00:14:00,400 --> 00:14:05,920
ठीक है, तो यहां एक समस्या यह है कि यदि चार समता जांचों में से कोई भी

221
00:14:05,920 --> 00:14:10,240
त्रुटि का पता नहीं लगाता है, जिसका अर्थ है कि 8 बिट्स के विशेष रूप से

222
00:14:10,240 --> 00:14:15,520
चयनित उपसमुच्चय में सम समताएं हैं, जैसा कि प्रेषक ने चाहा था, तो इसका मतलब यह है

223
00:14:15,520 --> 00:14:17,760
कि कोई त्रुटि नहीं थी , या यह हमें स्थिति 0 तक सीमित कर देता है।

224
00:14:17,760 --> 00:14:23,040
आप देखते हैं, चार हां या ना वाले प्रश्नों के साथ, हमारे पास समता जांच के लिए 16

225
00:14:23,040 --> 00:14:28,000
संभावित परिणाम हैं, और सबसे पहले यह ब्लॉक में 16 पदों में से 1 को इंगित करने

226
00:14:28,000 --> 00:14:33,000
के लिए बिल्कुल सही लगता है, लेकिन आपको 17वां परिणाम भी बताना होगा, कोई त्रुटि नहीं स्थिति।

227
00:14:33,000 --> 00:14:37,860
यहां समाधान वास्तव में बहुत सरल है, बस उस 0वें बिट के बारे में पूरी तरह से भूल जाएं।

228
00:14:37,860 --> 00:14:41,920
इसलिए जब हम अपनी चार समता जांच करते हैं और देखते हैं कि वे

229
00:14:41,920 --> 00:14:44,320
सभी सम हैं, तो इसका स्पष्ट अर्थ है कि कोई त्रुटि नहीं है।

230
00:14:44,320 --> 00:14:49,240
इसका मतलब यह है कि 16-बिट ब्लॉक के साथ काम करने के बजाय, हम 15-बिट ब्लॉक के साथ काम करते

231
00:14:49,240 --> 00:14:54,040
हैं, जहां 11 बिट्स संदेश ले जाने के लिए स्वतंत्र हैं और उनमें से 4 बिट्स अतिरेक के लिए हैं।

232
00:14:54,080 --> 00:14:58,400
और इसके साथ ही, अब हमारे पास वह है जिसे व्यवसाय

233
00:14:58,400 --> 00:14:59,400
के लोग 15-11 हैमिंग कोड के रूप में संदर्भित करेंगे।

234
00:14:59,400 --> 00:15:03,920
जैसा कि कहा गया है, एक ब्लॉक का आकार 2 की साफ शक्ति वाला होना अच्छा है, और एक चतुर तरीका है कि हम

235
00:15:03,920 --> 00:15:08,880
उस 0 बिट को अपने पास रख सकते हैं और इसे हमारे लिए थोड़ा अतिरिक्त काम करने के लिए प्राप्त कर सकते हैं।

236
00:15:08,880 --> 00:15:13,600
यदि हम इसे पूरे ब्लॉक में समता बिट के रूप में उपयोग करते हैं, तो यह हमें

237
00:15:13,600 --> 00:15:16,320
वास्तव में पता लगाने देता है, भले ही हम 2-बिट त्रुटियों को ठीक नहीं कर सकते।

238
00:15:16,320 --> 00:15:17,440
यह ऐसे काम करता है।

239
00:15:17,440 --> 00:15:21,740
उन चार विशेष त्रुटि-सुधार बिट्स को सेट करने के बाद, हम उस 0 वें को

240
00:15:21,740 --> 00:15:25,540
सेट करते हैं ताकि पूर्ण ब्लॉक की समता सामान्य समता जांच की तरह समान हो।

241
00:15:25,540 --> 00:15:29,780
अब, यदि एक भी बिट त्रुटि है, तो पूर्ण ब्लॉक की समता विषम होने के लिए टॉगल

242
00:15:29,780 --> 00:15:33,940
हो जाती है, लेकिन चार त्रुटि-सुधार जांचों के लिए धन्यवाद, हम इसे वैसे भी पकड़ लेंगे।

243
00:15:33,940 --> 00:15:38,100
हालाँकि, यदि दो त्रुटियाँ हैं, तो समग्र समता वापस सम होने पर टॉगल हो

244
00:15:38,100 --> 00:15:42,660
जाएगी, लेकिन रिसीवर अभी भी देखेगा कि उन चार समता जाँचों के साथ

245
00:15:42,660 --> 00:15:45,820
जो हो रहा है, उसके कारण कम से कम कुछ त्रुटि हुई है।

246
00:15:45,820 --> 00:15:49,780
इसलिए यदि वे समग्र रूप से एक समान समानता देखते हैं, लेकिन अन्य जांचों के साथ कुछ

247
00:15:49,820 --> 00:15:52,980
गैर-शून्य हो रहा है, तो यह उन्हें बताता है कि कम से कम दो त्रुटियां थीं।

248
00:15:52,980 --> 00:15:54,420
क्या वह चतुराई नहीं है?

249
00:15:54,420 --> 00:15:58,500
भले ही हम उन 2-बिट त्रुटियों को ठीक नहीं कर सकते हैं, बस उस एक छोटे से

250
00:15:58,500 --> 00:16:02,340
परेशान करने वाले 0वें बिट को काम पर वापस रखकर, यह हमें उनका पता लगाने देता है।

251
00:16:02,340 --> 00:16:06,540
यह काफी मानक है, इसे विस्तारित हैमिंग कोड के रूप में जाना जाता है।

252
00:16:06,540 --> 00:16:10,860
तकनीकी रूप से कहें तो, अब आपके पास हैमिंग कोड क्या करता है

253
00:16:10,860 --> 00:16:13,580
इसका पूरा विवरण है, कम से कम 16-बिट ब्लॉक के उदाहरण के लिए।

254
00:16:13,580 --> 00:16:17,300
लेकिन मुझे लगता है कि आपको शुरू से अंत तक एक पूरा उदाहरण देकर अपनी

255
00:16:17,300 --> 00:16:21,980
समझ की जांच करना और इस बिंदु तक सब कुछ मजबूत करना अधिक संतोषजनक लगेगा।

256
00:16:21,980 --> 00:16:25,100
हालाँकि, मैं आपके साथ इसमें कदम उठाऊंगा ताकि आप स्वयं जांच कर सकें।

257
00:16:25,100 --> 00:16:29,180
एक संदेश सेट करने के लिए, चाहे वह शाब्दिक संदेश हो जिसका आप अंतरिक्ष

258
00:16:29,180 --> 00:16:34,100
में अनुवाद कर रहे हों या कुछ डेटा जिसे आप समय के साथ

259
00:16:34,100 --> 00:16:35,700
संग्रहीत करना चाहते हों, पहला कदम इसे 11-बिट खंडों में विभाजित करना है।

260
00:16:35,700 --> 00:16:40,340
प्रत्येक भाग को त्रुटि-प्रतिरोधी 16-बिट ब्लॉक में पैक किया जाएगा।

261
00:16:40,340 --> 00:16:43,740
तो आइए इसे एक उदाहरण के रूप में लें और वास्तव में इस पर काम करें।

262
00:16:43,740 --> 00:16:45,340
आगे बढ़ो, वास्तव में यह करो!

263
00:16:45,380 --> 00:16:47,380
आइए रुकें और इस ब्लॉक को एक साथ रखने का प्रयास करें।

264
00:16:52,980 --> 00:16:53,980
ठीक है, आप तैयार हैं?

265
00:16:53,980 --> 00:16:58,500
याद रखें, 2 की अन्य शक्तियों के साथ स्थिति 0 त्रुटि सुधार कार्य के लिए आरक्षित

266
00:16:58,500 --> 00:17:05,700
है, इसलिए आप संदेश बिट्स को शेष सभी स्थानों पर क्रम से रखकर शुरू करें।

267
00:17:05,700 --> 00:17:09,700
आपको इस समूह में एक सम समता की आवश्यकता है, जो कि पहले से ही

268
00:17:09,700 --> 00:17:13,140
है, इसलिए आपको उस समता बिट को स्थिति 1 में 0 पर सेट करना चाहिए।

269
00:17:13,140 --> 00:17:17,700
अगला समूह एक विषम समता के साथ शुरू होता है,

270
00:17:17,700 --> 00:17:19,260
इसलिए आपको इसका समता बिट 1 पर सेट करना चाहिए।

271
00:17:19,260 --> 00:17:23,740
उसके बाद समूह एक विषम समता के साथ शुरू होता है, इसलिए

272
00:17:23,740 --> 00:17:24,740
आपको फिर से इसका समता बिट 1 पर सेट करना चाहिए।

273
00:17:24,740 --> 00:17:29,500
और अंतिम समूह में भी एक अजीब समानता है, जिसका अर्थ है कि हम

274
00:17:29,500 --> 00:17:31,500
उस बिट को स्थिति 8 में 1 के रूप में सेट करते हैं।

275
00:17:31,500 --> 00:17:36,460
और फिर अंतिम चरण के रूप में, पूर्ण ब्लॉक में अब एक सम समता है, जिसका अर्थ

276
00:17:36,460 --> 00:17:41,500
है कि आप उस बिट संख्या 0, व्यापक समता बिट को 0 पर सेट कर सकते हैं।

277
00:17:41,500 --> 00:17:45,660
इसलिए जैसे ही यह ब्लॉक भेजा जाता है, चार विशेष उपसमुच्चय

278
00:17:45,660 --> 00:17:48,980
और संपूर्ण ब्लॉक की समता सम हो जाएगी, या 0.

279
00:17:48,980 --> 00:17:53,620
अभ्यास के दूसरे भाग के रूप में, आइए आपसे प्राप्तकर्ता की भूमिका निभाएँ।

280
00:17:53,620 --> 00:17:57,580
बेशक, इसका मतलब यह होगा कि आप पहले से नहीं जानते कि यह संदेश क्या है, हो सकता है कि आप

281
00:17:57,580 --> 00:18:00,180
में से कुछ लोगों ने इसे याद कर लिया हो, लेकिन मान लीजिए कि आपने इसे याद नहीं किया है।

282
00:18:00,180 --> 00:18:05,820
मैं जो करने जा रहा हूं वह उस ब्लॉक में 0, 1, या 2 बिट्स को बदलना

283
00:18:05,820 --> 00:18:08,340
है, और फिर आपसे यह पता लगाने के लिए कहना है कि मैंने क्या किया है।

284
00:18:08,340 --> 00:18:13,460
तो फिर, रुकें और इस पर काम करने का प्रयास करें।

285
00:18:13,460 --> 00:18:23,960
ठीक है, तो अब आप रिसीवर के रूप में पहले समता समूह की जांच करें और आप देख

286
00:18:23,960 --> 00:18:29,820
सकते हैं कि यह सम है, इसलिए जो भी त्रुटि मौजूद है वह सम कॉलम में होनी चाहिए।

287
00:18:29,820 --> 00:18:34,620
अगला चेक हमें एक विषम संख्या देता है, जो हम दोनों को बताता है कि कम

288
00:18:34,620 --> 00:18:38,760
से कम एक त्रुटि है, और हमें इस विशिष्ट कॉलम में सीमित कर देता है।

289
00:18:38,760 --> 00:18:42,900
तीसरी जाँच सम है, संभावनाओं को और भी कम कर देती है।

290
00:18:42,900 --> 00:18:46,780
और अंतिम समता जांच अजीब है, जो हमें बताती है कि नीचे कहीं एक त्रुटि है,

291
00:18:46,780 --> 00:18:51,700
जिसे अब तक हम देख सकते हैं कि वह स्थिति संख्या 10 में होनी चाहिए।

292
00:18:51,700 --> 00:18:56,140
इसके अलावा, पूरे ब्लॉक की समता विषम है, जिससे हमें

293
00:18:56,140 --> 00:18:58,220
विश्वास हो गया कि एक फ्लिप था, दो नहीं।

294
00:18:58,220 --> 00:19:01,600
यदि यह तीन या अधिक है, तो सभी दांव बंद हो जाएंगे।

295
00:19:01,600 --> 00:19:06,520
उस बिट संख्या 10 को सही करने के बाद, सुधार के लिए उपयोग नहीं किए गए 11 बिट्स

296
00:19:06,520 --> 00:19:11,620
को बाहर निकालने से हमें मूल संदेश का प्रासंगिक खंड मिलता है, जिसे यदि आप रिवाइंड करते हैं

297
00:19:11,620 --> 00:19:16,160
और तुलना करते हैं तो वास्तव में वही होता है जिसके साथ हमने उदाहरण शुरू किया था।

298
00:19:16,160 --> 00:19:19,260
और अब जब आप जानते हैं कि यह सब हाथ से कैसे करना है, तो मैं आपको दिखाना चाहूंगा कि

299
00:19:19,260 --> 00:19:23,940
आप पायथन कोड की एक पंक्ति के साथ इस सभी तर्क के मुख्य भाग को कैसे पूरा कर सकते हैं।

300
00:19:23,940 --> 00:19:28,400
आप देखिए, जो मैंने आपको अभी तक नहीं बताया है वह यह है कि यह एल्गोरिदम वास्तव

301
00:19:28,400 --> 00:19:32,380
में कितना सुंदर है, किसी त्रुटि की स्थिति को इंगित करने के लिए मशीन प्राप्त करना

302
00:19:32,380 --> 00:19:37,680
कितना सरल है, इसे व्यवस्थित रूप से कैसे मापना है, और हम सभी को कैसे फ्रेम कर

303
00:19:37,680 --> 00:19:39,580
सकते हैं यह कई अलग-अलग समता जांचों के बजाय एक एकल ऑपरेशन के रूप में है।

304
00:19:39,580 --> 00:19:41,680
यह देखने के लिए कि मेरा क्या मतलब है, भाग 2 में मेरे साथ आएँ।

