1
00:00:03,620 --> 00:00:06,859
क्या आपने कभी सोचा है कि किसी सीडी या डीवीडी को स्क्रैच करना 

2
00:00:06,859 --> 00:00:10,100
और उसमें जो कुछ भी संग्रहीत है उसे प्लेबैक करना कैसे संभव है?

3
00:00:10,900 --> 00:00:13,935
स्क्रैच वास्तव में डिस्क पर 1s और 0s को प्रभावित करता है, 

4
00:00:13,935 --> 00:00:16,919
इसलिए यह संग्रहीत किए गए डेटा से भिन्न डेटा को पढ़ता है, 

5
00:00:16,919 --> 00:00:19,745
लेकिन जब तक इसे वास्तव में स्क्रैच नहीं किया जाता है, 

6
00:00:19,745 --> 00:00:23,776
तब तक इसके द्वारा पढ़े गए बिट्स ठीक उसी फ़ाइल में डीकोड हो जाते हैं जो उस पर 

7
00:00:23,776 --> 00:00:27,440
एन्कोड किया गया था, ए उन सभी त्रुटियों के बावजूद, बिट कॉपी के लिए बिट।

8
00:00:27,440 --> 00:00:31,344
गणितीय चतुराई का एक पूरा ढेर है जो हमें डेटा संग्रहीत करने की अनुमति देता है, 

9
00:00:31,344 --> 00:00:34,648
और उतना ही महत्वपूर्ण रूप से डेटा संचारित करने की अनुमति देता है, 

10
00:00:34,648 --> 00:00:36,200
जो त्रुटियों के प्रति लचीला है।

11
00:00:36,200 --> 00:00:38,588
ठीक है, ठीक है, वास्तव में ऐसा करने का कोई तरीका 

12
00:00:38,588 --> 00:00:40,880
निकालने के लिए उतनी चतुराई की आवश्यकता नहीं है।

13
00:00:40,880 --> 00:00:45,889
कोई भी फ़ाइल, चाहे वह वीडियो हो या ध्वनि या पाठ, कोई कोड, 

14
00:00:45,889 --> 00:00:50,380
कोई छवि, जो भी हो, अंततः 1s और 0s का कुछ अनुक्रम है।

15
00:00:50,680 --> 00:00:53,430
और जो भी बिट फ़्लिप हो जाता है उसे ठीक करने की एक सरल रणनीति 

16
00:00:53,430 --> 00:00:56,000
यह होगी कि प्रत्येक बिट की तीन प्रतियां संग्रहीत की जाएं।

17
00:00:57,580 --> 00:01:00,773
फिर इस फ़ाइल को पढ़ने वाली मशीन इन तीन प्रतियों की तुलना कर सकती है 

18
00:01:00,773 --> 00:01:04,060
और जब भी कोई विसंगति हो तो हमेशा 3 में से सर्वश्रेष्ठ 2 को ले सकती है।

19
00:01:07,160 --> 00:01:10,860
लेकिन इसका मतलब यह है कि आपके स्थान का दो-तिहाई हिस्सा अतिरेक के लिए उपयोग किया जा रहा है।

20
00:01:11,480 --> 00:01:14,428
और फिर भी, छोड़ी गई सारी जगह के लिए, इस बात की कोई पुख्ता गारंटी 

21
00:01:14,428 --> 00:01:17,240
नहीं है कि यदि एक से अधिक बिट फ़्लिप हो जाते हैं तो क्या होगा।

22
00:01:17,980 --> 00:01:21,105
इससे भी अधिक दिलचस्प सवाल यह है कि इसे कैसे बनाया जाए ताकि 

23
00:01:21,105 --> 00:01:24,020
यथासंभव कम जगह छोड़ते हुए त्रुटियों को ठीक किया जा सके।

24
00:01:24,520 --> 00:01:27,829
उदाहरण के लिए, जिस विधि के बारे में आप इस वीडियो के बारे में जानेंगे, 

25
00:01:27,829 --> 00:01:31,090
उसका उपयोग करके आप अपना डेटा 256-बिट ब्लॉक में संग्रहीत कर सकते हैं, 

26
00:01:31,090 --> 00:01:33,360
जहां प्रत्येक ब्लॉक 9 बिट्स, 9 का उपयोग करता है!

27
00:01:33,760 --> 00:01:36,237
एक प्रकार की अतिरेक के रूप में कार्य करने के लिए, 

28
00:01:36,237 --> 00:01:40,300
और अन्य 247 बिट्स आपके इच्छित सार्थक संदेश या डेटा को ले जाने के लिए स्वतंत्र हैं।

29
00:01:40,900 --> 00:01:44,082
और यह अब भी होगा कि यदि यहां कोई भी बिट फ़्लिप हो जाता है, 

30
00:01:44,082 --> 00:01:48,020
तो केवल इस ब्लॉक को देखकर और कुछ नहीं, एक मशीन यह पहचानने में सक्षम होगी 

31
00:01:48,020 --> 00:01:52,660
कि कोई त्रुटि थी और सटीक रूप से यह कहां थी ताकि वह जान सके कि इसे कैसे ठीक किया जाए। .

32
00:01:52,660 --> 00:01:54,620
और ईमानदारी से कहूं तो यह जादू जैसा लगता है।

33
00:01:55,440 --> 00:01:57,789
और इस विशेष योजना के लिए, यदि दो बिट फ़्लिप हो जाते हैं, 

34
00:01:57,789 --> 00:02:00,510
तो मशीन कम से कम यह पता लगाने में सक्षम होगी कि दो त्रुटियाँ थीं, 

35
00:02:00,510 --> 00:02:02,860
हालाँकि उसे यह नहीं पता होगा कि उन्हें कैसे ठीक किया जाए।

36
00:02:03,520 --> 00:02:05,315
हम थोड़ी देर बाद इस बारे में बात करेंगे कि विभिन्न 

37
00:02:05,315 --> 00:02:06,900
आकारों वाले ब्लॉकों के लिए यह पैमाना कैसा है।

38
00:02:07,860 --> 00:02:10,487
वे विधियाँ जो आपको इस तरह की त्रुटियों को ठीक करने देती हैं, 

39
00:02:10,487 --> 00:02:12,900
यथोचित रूप से त्रुटि सुधार कोड के रूप में जानी जाती हैं।

40
00:02:13,660 --> 00:02:17,751
पिछली शताब्दी के अधिकांश समय में, यह क्षेत्र आश्चर्यजनक रूप से गहन गणित का एक समृद्ध 

41
00:02:17,751 --> 00:02:21,940
स्रोत रहा है जो हमारे द्वारा प्रतिदिन उपयोग किए जाने वाले उपकरणों में शामिल हो जाता है।

42
00:02:22,840 --> 00:02:26,997
यहां लक्ष्य आपको शुरुआती उदाहरणों में से एक, जिसे हैमिंग कोड के नाम से जाना जाता है, 

43
00:02:26,997 --> 00:02:28,660
की पूरी तरह से समझ प्रदान करना है।

44
00:02:29,520 --> 00:02:32,938
और वैसे, जिस तरह से मैं इस वीडियो की संरचना के बारे में सोच रहा हूं वह इसे 

45
00:02:32,938 --> 00:02:36,356
यथासंभव सीधे समझाने के बारे में कम है, और यहां और वहां थोड़े से मार्गदर्शन 

46
00:02:36,356 --> 00:02:39,820
के साथ आपको इसे अपने लिए आविष्कार करने के लिए प्रेरित करने का मामला अधिक है।

47
00:02:40,120 --> 00:02:43,035
इसलिए जब आपको लगे कि किसी बिंदु पर आप देख रहे हैं कि यह कहां जा रहा है, 

48
00:02:43,035 --> 00:02:46,396
तो उस क्षण रुकें, मेरे बताने से पहले सक्रिय रूप से अनुमान लगाएं कि योजना क्या होने 

49
00:02:46,396 --> 00:02:46,720
वाली है।

50
00:02:47,240 --> 00:02:50,448
साथ ही, यदि आप चाहते हैं कि आपकी समझ हार्डवेयर स्तर तक पहुंचे, 

51
00:02:50,448 --> 00:02:54,064
तो बेन ईटर ने इसके साथ मिलकर एक वीडियो बनाया है जिसमें आपको दिखाया गया 

52
00:02:54,064 --> 00:02:58,240
है कि वास्तव में ब्रेडबोर्ड पर हैमिंग कोड कैसे लागू किया जाए, जो बेहद संतोषजनक है।

53
00:02:59,300 --> 00:03:03,884
आपको पता होना चाहिए, हैमिंग कोड रीड-सोलोमन एल्गोरिथ्म की तरह अधिक आधुनिक कोड के रूप में 

54
00:03:03,884 --> 00:03:08,468
व्यापक रूप से उपयोग नहीं किए जाते हैं, लेकिन शुरुआत में यह कार्य कितना असंभव लगता है और 

55
00:03:08,468 --> 00:03:13,000
एक बार यह कितना उचित लगता है, इसके बीच एक निश्चित जादू है। आप हैमिंग के बारे में जानें।

56
00:03:13,720 --> 00:03:19,173
त्रुटि सुधार का मूल सिद्धांत यह है कि सभी संभावित संदेशों के विशाल स्थान में, 

57
00:03:19,173 --> 00:03:22,180
केवल कुछ उपसमूह को ही वैध संदेश माना जाएगा।

58
00:03:22,800 --> 00:03:26,940
सादृश्य के रूप में, सही वर्तनी वाले शब्दों बनाम गलत वर्तनी वाले शब्दों के बारे में सोचें।

59
00:03:28,900 --> 00:03:33,120
जब भी कोई वैध संदेश बदल जाता है, तो प्राप्तकर्ता निकटतम वैध पड़ोसी को जो दिखाई देता 

60
00:03:33,120 --> 00:03:37,340
है उसे ठीक करने के लिए जिम्मेदार होता है, जैसा कि आप टाइपो के मामले में कर सकते हैं।

61
00:03:38,220 --> 00:03:41,076
हालाँकि, इस तरह के संदेशों को कुशलतापूर्वक वर्गीकृत करने के लिए एक 

62
00:03:41,076 --> 00:03:44,060
ठोस एल्गोरिदम के साथ आने के लिए एक निश्चित चतुराई की आवश्यकता होती है।

63
00:03:46,780 --> 00:03:50,203
कहानी 1940 के दशक में शुरू होती है, जब एक युवा रिचर्ड हैमिंग बेल 

64
00:03:50,203 --> 00:03:53,732
लैब्स के लिए काम कर रहे थे, और उनके कुछ काम में एक बहुत बड़े महंगे 

65
00:03:53,732 --> 00:03:57,420
पंच कार्ड कंप्यूटर का उपयोग करना शामिल था, जिस तक उनकी सीमित पहुंच थी।

66
00:03:57,800 --> 00:04:00,680
और जो प्रोग्राम वह इसके माध्यम से डालता रहा वह विफल होता रहा, 

67
00:04:00,680 --> 00:04:02,400
क्योंकि कभी-कभी कुछ गलत पढ़ा जाता था।

68
00:04:03,120 --> 00:04:05,641
आविष्कार की भट्ठी निराशा से वह इतना तंग आ गया कि 

69
00:04:05,641 --> 00:04:08,420
उसने दुनिया का पहला त्रुटि सुधार कोड का आविष्कार किया।

70
00:04:09,060 --> 00:04:11,254
हैमिंग कोड को फ्रेम करने के कई अलग-अलग तरीके हैं, 

71
00:04:11,254 --> 00:04:14,414
लेकिन पहली बार हम इसके माध्यम से जाने वाले हैं जिस तरह से हैमिंग ने खुद 

72
00:04:14,414 --> 00:04:15,380
उनके बारे में सोचा था।

73
00:04:16,519 --> 00:04:20,940
आइए एक उदाहरण का उपयोग करें जो सरल है, लेकिन बहुत सरल नहीं है, 16 बिट्स का एक ब्लॉक।

74
00:04:21,820 --> 00:04:24,740
हम इन बिट्स की स्थिति को 0 से 15 तक क्रमांकित करेंगे।

75
00:04:25,620 --> 00:04:30,149
जो वास्तविक डेटा हम संग्रहीत करना चाहते हैं, वह इनमें से केवल 12 बिट्स को बनाने वाला है, 

76
00:04:30,149 --> 00:04:33,000
जबकि 4 स्थान एक प्रकार के अतिरेक के रूप में आरक्षित हैं।

77
00:04:33,900 --> 00:04:36,525
यहां निरर्थक शब्द का मतलब केवल कॉपी करना नहीं है, आखिरकार, 

78
00:04:36,525 --> 00:04:40,040
वे 4 बिट्स हमें डेटा को आंख मूंदकर कॉपी करने के लिए पर्याप्त जगह नहीं देते हैं।

79
00:04:40,720 --> 00:04:44,475
इसके बजाय, उन्हें बहुत अधिक सूक्ष्म और चतुर प्रकार के अतिरेक की आवश्यकता होगी, 

80
00:04:44,475 --> 00:04:47,280
कोई नई जानकारी नहीं जोड़नी होगी, बल्कि लचीलापन जोड़ना होगा।

81
00:04:48,600 --> 00:04:52,052
आप उम्मीद कर सकते हैं कि ये 4 विशेष बिट्स अच्छी तरह से एक साथ पैक किए जाएंगे, 

82
00:04:52,052 --> 00:04:54,309
शायद अंत में या ऐसा कुछ, लेकिन जैसा कि आप देखेंगे, 

83
00:04:54,309 --> 00:04:56,654
उन्हें उन स्थितियों में बैठाना जो 2 की शक्तियाँ हैं, 

84
00:04:56,654 --> 00:04:59,620
अंत तक कुछ ऐसा करने की अनुमति देता है जो वास्तव में सुरुचिपूर्ण है।

85
00:05:00,200 --> 00:05:03,540
यह आपको इस बारे में भी थोड़ा संकेत दे सकता है कि यह बड़े ब्लॉकों के लिए कैसा है।

86
00:05:04,900 --> 00:05:08,099
इसके अलावा तकनीकी रूप से यह केवल 11 बिट डेटा बनकर रह जाता है, 

87
00:05:08,099 --> 00:05:11,350
आप पाएंगे कि स्थिति 0 पर जो होता है उसमें थोड़ी बारीकियां हैं, 

88
00:05:11,350 --> 00:05:13,260
लेकिन अभी इसके बारे में चिंता न करें।

89
00:05:14,140 --> 00:05:17,640
किसी भी त्रुटि सुधार एल्गोरिदम की तरह, इसमें दो खिलाड़ी शामिल होंगे, 

90
00:05:17,640 --> 00:05:20,836
एक प्रेषक जो इन 4 विशेष बिट्स को सेट करने के लिए जिम्मेदार है, 

91
00:05:20,836 --> 00:05:25,200
और एक रिसीवर जो किसी प्रकार की जांच करने और त्रुटियों को ठीक करने के लिए जिम्मेदार है।

92
00:05:25,200 --> 00:05:28,346
बेशक, प्रेषक और रिसीवर शब्द वास्तव में उन मशीनों या सॉफ़्टवेयर 

93
00:05:28,346 --> 00:05:31,493
को संदर्भित करते हैं जो सभी जांच कर रहे हैं, और संदेश का विचार 

94
00:05:31,493 --> 00:05:34,740
वास्तव में मोटे तौर पर भंडारण जैसी चीजों को शामिल करने के लिए है।

95
00:05:35,340 --> 00:05:38,422
आख़िरकार, डेटा संग्रहीत करना एक संदेश को एक स्थान से 

96
00:05:38,422 --> 00:05:41,680
दूसरे स्थान के बजाय अतीत से भविष्य में भेजने जैसा ही है।

97
00:05:42,560 --> 00:05:45,922
तो यह सेटअप है, लेकिन इससे पहले कि हम आगे बढ़ें हमें एक संबंधित विचार 

98
00:05:45,922 --> 00:05:49,862
के बारे में बात करने की ज़रूरत है जो हैमिंग के दिमाग में उनकी खोज के समय ताजा था, 

99
00:05:49,862 --> 00:05:52,792
एक ऐसी विधि जो आपको किसी भी बिट त्रुटि का पता लगाने देती है, 

100
00:05:52,792 --> 00:05:56,300
लेकिन उन्हें ठीक करने की नहीं, ज्ञात है व्यवसाय में समता जाँच के रूप में।

101
00:05:56,880 --> 00:06:00,323
समता जांच के लिए, हम केवल एक बिट को अलग करते हैं जिसे ट्यूनिंग के 

102
00:06:00,323 --> 00:06:03,820
लिए प्रेषक जिम्मेदार है, और बाकी संदेश ले जाने के लिए स्वतंत्र हैं।

103
00:06:04,880 --> 00:06:08,011
इस विशेष बिट का एकमात्र काम यह सुनिश्चित करना 

104
00:06:08,011 --> 00:06:11,280
है कि संदेश में 1 की कुल संख्या एक सम संख्या है।

105
00:06:12,080 --> 00:06:15,041
उदाहरण के लिए अभी, 1 की कुल संख्या 7 है, यह अजीब है, 

106
00:06:15,041 --> 00:06:19,960
इसलिए प्रेषक को उस विशेष बिट को 1 करने के लिए फ़्लिप करना होगा, जिससे गिनती सम हो जाएगी।

107
00:06:20,800 --> 00:06:24,508
लेकिन यदि ब्लॉक पहले से ही 1 की सम संख्या के साथ शुरू हुआ होता, 

108
00:06:24,508 --> 00:06:26,420
तो इस विशेष बिट को 0 पर रखा जाता।

109
00:06:27,340 --> 00:06:32,169
यह बहुत ही सरल, भ्रामक रूप से सरल है, लेकिन यह किसी संदेश में कहीं भी परिवर्तन के विचार 

110
00:06:32,169 --> 00:06:36,780
को जानकारी के एक टुकड़े में प्रतिबिंबित करने का एक अविश्वसनीय रूप से सुंदर तरीका है।

111
00:06:37,500 --> 00:06:42,993
ध्यान दें कि यदि इस संदेश का कोई भी अंश 0 से 1 या 1 से 0 तक फ़्लिप हो जाता है, 

112
00:06:42,993 --> 00:06:46,540
तो यह 1 की कुल गिनती को सम से विषम में बदल देता है।

113
00:06:47,980 --> 00:06:50,593
इसलिए यदि आप रिसीवर हैं, आप इस संदेश को देखते हैं, 

114
00:06:50,593 --> 00:06:53,719
और आपको 1 की एक विषम संख्या दिखाई देती है, तो आप निश्चित रूप 

115
00:06:53,719 --> 00:06:57,460
से जान सकते हैं कि कुछ त्रुटि हुई है, भले ही आपको पता न हो कि यह कहां थी।

116
00:06:58,500 --> 00:07:01,536
शब्दजाल में, चाहे बिट्स के समूह में 1s की सम या विषम संख्या हो, 

117
00:07:01,536 --> 00:07:03,340
इसे इसकी समता के रूप में जाना जाता है।

118
00:07:04,860 --> 00:07:07,594
आप संख्याओं का भी उपयोग कर सकते हैं और कह सकते हैं कि समता 0 या 1 है, 

119
00:07:07,594 --> 00:07:10,720
जो आमतौर पर तब अधिक सहायक होती है जब आप इस विचार के साथ गणित करना शुरू करते हैं।

120
00:07:11,220 --> 00:07:14,631
और यह विशेष बिट जिसे प्रेषक समता को नियंत्रित करने के लिए उपयोग करता है, 

121
00:07:14,631 --> 00:07:15,520
समता बिट कहलाता है।

122
00:07:17,560 --> 00:07:21,322
और वास्तव में, हमें स्पष्ट होना चाहिए, यदि रिसीवर एक विषम समता देखता है, 

123
00:07:21,322 --> 00:07:24,672
तो इसका मतलब यह नहीं है कि केवल एक त्रुटि थी, 3 त्रुटियां, या 5, 

124
00:07:24,672 --> 00:07:29,260
या कोई अन्य विषम संख्या हो सकती है, लेकिन वे निश्चित रूप से जान सकते हैं कि यह 0 नहीं था.

125
00:07:29,980 --> 00:07:33,892
दूसरी ओर, यदि 2 त्रुटियाँ थीं, या कोई सम संख्या में त्रुटियाँ थीं, 

126
00:07:33,892 --> 00:07:38,037
तो 1 की अंतिम गिनती अभी भी सम होगी, इसलिए प्राप्तकर्ता को पूरा विश्वास 

127
00:07:38,037 --> 00:07:42,300
नहीं हो सकता है कि एक सम संख्या का मतलब यह है कि संदेश त्रुटि-मुक्त है। .

128
00:07:42,840 --> 00:07:46,037
आप शिकायत कर सकते हैं कि जो संदेश केवल 2 बिट फ़्लिप से गड़बड़ 

129
00:07:46,037 --> 00:07:49,080
हो जाता है वह बहुत कमज़ोर होता है, और आप बिल्कुल सही होंगे।

130
00:07:49,700 --> 00:07:54,213
ध्यान रखें, हालाँकि, त्रुटि का पता लगाने या सुधार करने की कोई विधि नहीं है जो 

131
00:07:54,213 --> 00:07:58,900
आपको 100% विश्वास दिला सके कि आपको प्राप्त संदेश वही है जो भेजने वाले ने चाहा है।

132
00:07:59,580 --> 00:08:02,510
आख़िरकार, पर्याप्त यादृच्छिक शोर हमेशा शुद्ध संयोग 

133
00:08:02,510 --> 00:08:05,440
से एक वैध संदेश को दूसरे वैध संदेश में बदल सकता है।

134
00:08:06,240 --> 00:08:10,660
इसके बजाय, लक्ष्य एक ऐसी योजना बनाना है जो त्रुटियों की एक निश्चित अधिकतम 

135
00:08:10,660 --> 00:08:15,380
संख्या तक मजबूत हो, या शायद इस तरह की झूठी सकारात्मकता की संभावना को कम कर सके।

136
00:08:16,260 --> 00:08:19,893
समता जांच अपने आप में काफी कमजोर हैं, लेकिन एक पूर्ण संदेश में 

137
00:08:19,893 --> 00:08:23,526
परिवर्तन के विचार को एक बिट तक सीमित करके, वे हमें जो देते हैं 

138
00:08:23,526 --> 00:08:27,160
वह अधिक परिष्कृत योजनाओं के लिए एक शक्तिशाली बिल्डिंग ब्लॉक है।

139
00:08:27,940 --> 00:08:32,028
उदाहरण के लिए, जब हैमिंग यह पहचानने का एक तरीका खोज रहा था कि त्रुटि कहाँ हुई है, 

140
00:08:32,028 --> 00:08:35,568
न कि केवल यह कि यह घटित हुई है, तो उसकी मुख्य अंतर्दृष्टि यह थी कि यदि 

141
00:08:35,568 --> 00:08:39,208
आप कुछ समता जाँचों को पूर्ण संदेश पर नहीं, बल्कि कुछ सावधानीपूर्वक चयनित 

142
00:08:39,208 --> 00:08:42,948
उपसमूहों पर लागू करते हैं, तो आप पूछ सकते हैं प्रश्नों की एक अधिक परिष्कृत 

143
00:08:42,948 --> 00:08:45,940
श्रृंखला जो किसी भी एक बिट त्रुटि के स्थान को इंगित करती है।

144
00:08:46,680 --> 00:08:49,425
कुल मिलाकर भावना कुछ-कुछ 20 प्रश्नों का खेल खेलने जैसा है, 

145
00:08:49,425 --> 00:08:53,380
जिसमें हां या ना में ऐसे प्रश्न पूछे जाते हैं जो संभावनाओं की जगह को आधा कर देते हैं।

146
00:08:54,160 --> 00:08:56,796
उदाहरण के लिए, मान लें कि हम केवल इन 8 बिट्स, सभी 

147
00:08:56,796 --> 00:08:59,380
विषम संख्या वाली स्थितियों पर समता जांच करते हैं।

148
00:09:00,100 --> 00:09:04,330
फिर यदि कोई त्रुटि पाई जाती है, तो यह रिसीवर को इस बारे में थोड़ी अधिक जानकारी 

149
00:09:04,330 --> 00:09:08,240
देता है कि विशेष रूप से त्रुटि कहाँ है, अर्थात् यह एक विषम स्थिति में है।

150
00:09:08,940 --> 00:09:11,942
यदि उन 8 बिट्स के बीच कोई त्रुटि नहीं पाई जाती है, 

151
00:09:11,942 --> 00:09:16,240
तो इसका मतलब है कि कोई त्रुटि नहीं है, या यह कहीं सम स्थिति में बैठता है।

152
00:09:17,180 --> 00:09:21,274
आप सोच सकते हैं कि समता जांच को आधे बिट्स तक सीमित करने से यह कम प्रभावी हो जाता है, 

153
00:09:21,274 --> 00:09:25,032
लेकिन जब इसे अन्य अच्छी तरह से चुनी गई जांचों के साथ संयोजन में किया जाता है, 

154
00:09:25,032 --> 00:09:27,200
तो यह हमें कुछ अधिक शक्तिशाली प्रदान करता है।

155
00:09:29,240 --> 00:09:31,834
वास्तव में उस समता जाँच को स्थापित करने के लिए, याद रखें, 

156
00:09:31,834 --> 00:09:35,546
इसमें कुछ विशेष बिट निर्धारित करने की आवश्यकता होती है जिसका उस पूर्ण समूह की समता 

157
00:09:35,546 --> 00:09:36,620
के लिए नियंत्रण होता है।

158
00:09:37,480 --> 00:09:39,180
आइए यहां केवल स्थिति 1 चुनें।

159
00:09:39,720 --> 00:09:43,086
दिखाए गए उदाहरण के लिए, इन 8 बिट्स की समता वर्तमान में विषम है, 

160
00:09:43,086 --> 00:09:46,980
इसलिए प्रेषक उस समता बिट को टॉगल करने के लिए जिम्मेदार है, और अब यह सम है।

161
00:09:47,940 --> 00:09:50,680
यह 4 समता जांचों में से केवल 1 है जो हम करेंगे।

162
00:09:50,920 --> 00:09:54,190
दूसरा चेक ग्रिड के दाहिने आधे हिस्से पर 8 बिट्स में से एक है, 

163
00:09:54,190 --> 00:09:56,300
कम से कम जैसा कि हमने इसे यहां खींचा है।

164
00:09:56,680 --> 00:09:59,894
इस बार हम स्थिति 2 को समता बिट के रूप में उपयोग कर सकते हैं, 

165
00:09:59,894 --> 00:10:02,371
इसलिए इन 8 बिट्स में पहले से ही एक सम समता है, 

166
00:10:02,371 --> 00:10:06,060
और प्रेषक उस बिट संख्या 2 को अपरिवर्तित छोड़कर अच्छा महसूस कर सकता है।

167
00:10:07,020 --> 00:10:11,225
फिर दूसरे छोर पर, यदि रिसीवर इस समूह की समता की जांच करता है और उन्हें पता चलता है 

168
00:10:11,225 --> 00:10:15,380
कि यह अजीब है, तो उन्हें पता चल जाएगा कि त्रुटि दाईं ओर इन 8 बिट्स में से कहीं है।

169
00:10:15,820 --> 00:10:20,580
अन्यथा इसका मतलब है कि या तो कोई त्रुटि नहीं है, या त्रुटि बाएं आधे हिस्से में कहीं है।

170
00:10:21,120 --> 00:10:23,684
या मुझे लगता है कि दो त्रुटियाँ हो सकती थीं, लेकिन 

171
00:10:23,684 --> 00:10:26,500
अभी हम यह मानेंगे कि पूरे ब्लॉक में अधिकतम एक त्रुटि है।

172
00:10:26,940 --> 00:10:28,740
इससे अधिक के लिए चीजें पूरी तरह से टूट जाती हैं।

173
00:10:29,160 --> 00:10:30,970
यहां, इससे पहले कि हम अगली दो जांचों पर गौर करें, 

174
00:10:30,970 --> 00:10:33,868
एक पल के लिए यह सोचें कि जब आप उन पर एक साथ विचार करते हैं तो ये पहली दो जांचें 

175
00:10:33,868 --> 00:10:35,100
हमें क्या करने की अनुमति देती हैं।

176
00:10:35,800 --> 00:10:39,660
मान लीजिए कि आपको विषम स्तंभों और दाएँ आधे भाग के बीच एक त्रुटि का पता चलता है।

177
00:10:40,200 --> 00:10:43,040
इसका आवश्यक अर्थ यह है कि त्रुटि अंतिम कॉलम में कहीं है।

178
00:10:43,820 --> 00:10:47,356
यदि विषम कॉलम में कोई त्रुटि नहीं थी, लेकिन दाहिने आधे हिस्से में एक त्रुटि थी, 

179
00:10:47,356 --> 00:10:49,700
तो यह आपको बताता है कि यह दूसरे से अंतिम कॉलम में है।

180
00:10:50,440 --> 00:10:54,265
इसी तरह यदि विषम कॉलम में कोई त्रुटि है, लेकिन दाहिने आधे हिस्से में नहीं, 

181
00:10:54,265 --> 00:10:56,560
तो आप जानते हैं कि यह दूसरे कॉलम में कहीं है।

182
00:10:56,560 --> 00:10:59,553
और यदि उन दोनों समता जांचों में से कोई भी कुछ भी पता नहीं लगाता है, 

183
00:10:59,553 --> 00:11:03,120
तो इसका मतलब है कि एकमात्र स्थान जहां त्रुटि हो सकती है वह सबसे बाएं कॉलम में है।

184
00:11:03,340 --> 00:11:06,120
लेकिन इसका सीधा मतलब यह भी हो सकता है कि कोई त्रुटि ही नहीं है।

185
00:11:06,300 --> 00:11:10,840
यह कहने का एक विस्तृत तरीका है कि दो समता जांचों से हम कॉलम को पिन कर सकते हैं।

186
00:11:11,480 --> 00:11:13,640
यहां से, आप शायद अनुमान लगा सकते हैं कि आगे क्या होगा।

187
00:11:13,800 --> 00:11:16,140
हम मूल रूप से वही काम करते हैं लेकिन पंक्तियों के लिए।

188
00:11:16,440 --> 00:11:20,900
समता बिट के रूप में स्थिति 4 का उपयोग करते हुए, विषम पंक्तियों पर समता जांच की जाएगी।

189
00:11:21,380 --> 00:11:25,820
तो इस उदाहरण में उस समूह में पहले से ही सम समता है, इसलिए बिट 4 को 0 पर सेट किया जाएगा।

190
00:11:26,560 --> 00:11:28,948
और अंत में समता बिट के रूप में स्थिति 8 का उपयोग 

191
00:11:28,948 --> 00:11:31,580
करते हुए नीचे की दो पंक्तियों पर एक समता जांच होती है।

192
00:11:32,120 --> 00:11:34,470
इस मामले में, ऐसा लगता है कि समूह को समता प्रदान करने 

193
00:11:34,470 --> 00:11:36,820
के लिए प्रेषक को उस बिट 8 को चालू करने की आवश्यकता है।

194
00:11:37,700 --> 00:11:39,881
जैसे पहले दो चेक हमें कॉलम को पिन करने देते हैं, 

195
00:11:39,881 --> 00:11:41,840
ये अगले दो आपको पंक्ति को पिन करने देते हैं।

196
00:11:42,880 --> 00:11:47,540
उदाहरण के तौर पर, कल्पना करें कि ट्रांसमिशन के दौरान स्थिति 3 पर कोई त्रुटि है।

197
00:11:48,180 --> 00:11:52,437
खैर, यह पहले समता समूह को प्रभावित करता है, और यह दूसरे समता समूह को भी प्रभावित करता है, 

198
00:11:52,437 --> 00:11:55,560
इसलिए रिसीवर को पता चलता है कि उस सही कॉलम में कहीं कोई त्रुटि है।

199
00:11:56,100 --> 00:11:58,441
लेकिन तीसरे समूह पर इसका कोई प्रभाव नहीं पड़ता, 

200
00:11:58,441 --> 00:12:00,540
और चौथे समूह पर इसका कोई प्रभाव नहीं पड़ता।

201
00:12:01,240 --> 00:12:04,209
और यह रिसीवर को पहली पंक्ति तक त्रुटि को इंगित करने देता है, 

202
00:12:04,209 --> 00:12:07,520
जिसका अर्थ आवश्यक रूप से स्थिति 3 है, ताकि वे त्रुटि को ठीक कर सकें।

203
00:12:08,580 --> 00:12:12,784
आप स्वयं को यह समझाने में कुछ समय का आनंद ले सकते हैं कि इन चार प्रश्नों के 

204
00:12:12,784 --> 00:12:17,100
उत्तर वास्तव में आपको हमेशा एक विशिष्ट स्थान बताने देंगे, चाहे वे कहीं भी हों।

205
00:12:17,720 --> 00:12:20,415
वास्तव में, आपमें से जो चतुर लोग हैं वे इन प्रश्नों 

206
00:12:20,415 --> 00:12:23,060
और बाइनरी काउंटिंग के बीच एक संबंध भी देख सकते हैं।

207
00:12:23,500 --> 00:12:26,104
और यदि आप ऐसा करते हैं, तो मुझे फिर से जोर देने दीजिए, रुकिए, 

208
00:12:26,104 --> 00:12:28,920
इससे पहले कि मैं इसे खराब कर दूं, संबंध बनाने का स्वयं प्रयास करें।

209
00:12:30,500 --> 00:12:34,612
यदि आप सोच रहे हैं कि यदि समता बिट स्वयं प्रभावित हो जाए तो क्या होगा, 

210
00:12:34,612 --> 00:12:36,060
तो आप इसे आज़मा सकते हैं।

211
00:12:36,440 --> 00:12:40,334
इस बारे में सोचने के लिए एक क्षण लें कि इन चार विशेष बिट्स के बीच किसी भी त्रुटि 

212
00:12:40,334 --> 00:12:44,180
को किसी भी अन्य की तरह, चार प्रश्नों के एक ही समूह के साथ कैसे ट्रैक किया जाएगा।

213
00:12:47,060 --> 00:12:50,121
यह वास्तव में कोई फर्क नहीं पड़ता, क्योंकि दिन के अंत में हम जो चाहते हैं 

214
00:12:50,121 --> 00:12:53,100
वह संदेश बिट्स की सुरक्षा करना है, त्रुटि सुधार बिट्स बस साथ चल रहे हैं।

215
00:12:53,600 --> 00:12:55,729
लेकिन उन बिट्स की सुरक्षा भी एक ऐसी चीज है जो स्वाभाविक 

216
00:12:55,729 --> 00:12:57,820
रूप से एक उपोत्पाद के रूप में योजना से बाहर हो जाती है।

217
00:12:59,200 --> 00:13:01,760
आपको यह अनुमान लगाने में भी आनंद आ सकता है कि इसका पैमाना कैसा होगा।

218
00:13:02,300 --> 00:13:05,704
यदि हमने 256 बिट आकार के ब्लॉक का उपयोग किया है, उदाहरण के लिए, 

219
00:13:05,704 --> 00:13:09,215
किसी स्थान को पिन करने के लिए, तो आपको किसी विशिष्ट स्थान पर अपना 

220
00:13:09,215 --> 00:13:12,780
रास्ता खोजने के लिए केवल आठ हाँ या नहीं के प्रश्नों की आवश्यकता है।

221
00:13:15,640 --> 00:13:17,978
और याद रखें, प्रत्येक प्रश्न के लिए उचित समता जांच 

222
00:13:17,978 --> 00:13:20,500
सेट करने के लिए केवल एक बिट छोड़ने की आवश्यकता होती है।

223
00:13:23,160 --> 00:13:25,077
आप में से कुछ लोग इसे पहले से ही देख सकते हैं, 

224
00:13:25,077 --> 00:13:28,177
लेकिन हम बाद में एक या दो मिनट में ये प्रश्न क्या हैं यह जानने के व्यवस्थित 

225
00:13:28,177 --> 00:13:29,360
तरीके के बारे में बात करेंगे।

226
00:13:29,880 --> 00:13:31,517
उम्मीद है कि हम यहां जो विकसित कर रहे हैं उसकी 

227
00:13:31,517 --> 00:13:33,260
दक्षता की सराहना करने के लिए यह स्केच पर्याप्त है।

228
00:13:33,260 --> 00:13:37,177
पहली चीज़, उन आठ हाइलाइट किए गए समता बिट्स को छोड़कर, 

229
00:13:37,177 --> 00:13:41,820
वह हो सकती है जो आप चाहते हैं, जो भी संदेश या डेटा आप चाहते हैं।

230
00:13:41,820 --> 00:13:46,140
8 बिट्स इस अर्थ में अनावश्यक हैं कि वे पूरी तरह से शेष संदेश द्वारा निर्धारित होते हैं, 

231
00:13:46,140 --> 00:13:50,020
लेकिन यह संपूर्ण संदेश को कॉपी करने की तुलना में कहीं अधिक स्मार्ट तरीके से है।

232
00:13:53,600 --> 00:13:56,036
और फिर भी, इतनी कम छूट के बावजूद, आप किसी भी एक बिट 

233
00:13:56,036 --> 00:13:58,380
त्रुटि को पहचानने और उसे ठीक करने में सक्षम होंगे।

234
00:13:59,200 --> 00:14:00,400
हां तकरीबन।

235
00:14:00,960 --> 00:14:04,823
ठीक है, तो यहां एक समस्या यह है कि यदि चार समता जांचों में से कोई भी 

236
00:14:04,823 --> 00:14:08,742
त्रुटि का पता नहीं लगाता है, जिसका अर्थ है कि 8 बिट्स के विशेष रूप से 

237
00:14:08,742 --> 00:14:12,213
चयनित उपसमुच्चय में सम समताएं हैं, जैसा कि प्रेषक ने चाहा था, 

238
00:14:12,213 --> 00:14:16,860
तो इसका मतलब यह है कि कोई त्रुटि नहीं थी , या यह हमें स्थिति 0 तक सीमित कर देता है।

239
00:14:17,740 --> 00:14:20,606
आप देखते हैं, चार हां या ना वाले प्रश्नों के साथ, 

240
00:14:20,606 --> 00:14:23,472
हमारे पास समता जांच के लिए 16 संभावित परिणाम हैं, 

241
00:14:23,472 --> 00:14:28,345
और सबसे पहले यह ब्लॉक में 16 पदों में से 1 को इंगित करने के लिए बिल्कुल सही लगता है, 

242
00:14:28,345 --> 00:14:31,900
लेकिन आपको 17वां परिणाम भी बताना होगा, कोई त्रुटि नहीं स्थिति।

243
00:14:33,020 --> 00:14:37,300
यहां समाधान वास्तव में बहुत सरल है, बस उस 0वें बिट के बारे में पूरी तरह से भूल जाएं।

244
00:14:37,840 --> 00:14:41,279
इसलिए जब हम अपनी चार समता जांच करते हैं और देखते हैं कि वे सभी सम हैं, 

245
00:14:41,279 --> 00:14:43,460
तो इसका स्पष्ट अर्थ है कि कोई त्रुटि नहीं है।

246
00:14:44,240 --> 00:14:47,083
इसका मतलब यह है कि 16-बिट ब्लॉक के साथ काम करने के बजाय, 

247
00:14:47,083 --> 00:14:51,473
हम 15-बिट ब्लॉक के साथ काम करते हैं, जहां 11 बिट्स संदेश ले जाने के लिए स्वतंत्र हैं और 

248
00:14:51,473 --> 00:14:53,220
उनमें से 4 बिट्स अतिरेक के लिए हैं।

249
00:14:53,780 --> 00:14:56,892
और इसके साथ ही, अब हमारे पास वह है जिसे व्यवसाय 

250
00:14:56,892 --> 00:15:00,200
के लोग 15-11 हैमिंग कोड के रूप में संदर्भित करेंगे।

251
00:15:00,460 --> 00:15:03,238
जैसा कि कहा गया है, एक ब्लॉक का आकार 2 की साफ शक्ति वाला होना अच्छा है, 

252
00:15:03,238 --> 00:15:05,785
और एक चतुर तरीका है कि हम उस 0 बिट को अपने पास रख सकते हैं और इसे 

253
00:15:05,785 --> 00:15:08,140
हमारे लिए थोड़ा अतिरिक्त काम करने के लिए प्राप्त कर सकते हैं।

254
00:15:08,700 --> 00:15:11,546
यदि हम इसे पूरे ब्लॉक में समता बिट के रूप में उपयोग करते हैं, 

255
00:15:11,546 --> 00:15:15,540
तो यह हमें वास्तव में पता लगाने देता है, भले ही हम 2-बिट त्रुटियों को ठीक नहीं कर सकते।

256
00:15:16,160 --> 00:15:16,820
यह ऐसे काम करता है।

257
00:15:17,180 --> 00:15:20,104
उन चार विशेष त्रुटि-सुधार बिट्स को सेट करने के बाद, 

258
00:15:20,104 --> 00:15:24,940
हम उस 0 वें को सेट करते हैं ताकि पूर्ण ब्लॉक की समता सामान्य समता जांच की तरह समान हो।

259
00:15:25,700 --> 00:15:30,000
अब, यदि एक भी बिट त्रुटि है, तो पूर्ण ब्लॉक की समता विषम होने के लिए टॉगल हो जाती है, 

260
00:15:30,000 --> 00:15:33,600
लेकिन चार त्रुटि-सुधार जांचों के लिए धन्यवाद, हम इसे वैसे भी पकड़ लेंगे।

261
00:15:34,160 --> 00:15:38,736
हालाँकि, यदि दो त्रुटियाँ हैं, तो समग्र समता वापस सम होने पर टॉगल हो जाएगी, 

262
00:15:38,736 --> 00:15:42,951
लेकिन रिसीवर अभी भी देखेगा कि उन चार समता जाँचों के साथ जो हो रहा है, 

263
00:15:42,951 --> 00:15:45,180
उसके कारण कम से कम कुछ त्रुटि हुई है।

264
00:15:45,180 --> 00:15:47,735
इसलिए यदि वे समग्र रूप से एक समान समानता देखते हैं, 

265
00:15:47,735 --> 00:15:50,193
लेकिन अन्य जांचों के साथ कुछ गैर-शून्य हो रहा है, 

266
00:15:50,193 --> 00:15:52,700
तो यह उन्हें बताता है कि कम से कम दो त्रुटियां थीं।

267
00:15:53,520 --> 00:15:54,000
क्या वह चतुराई नहीं है?

268
00:15:54,300 --> 00:15:56,822
भले ही हम उन 2-बिट त्रुटियों को ठीक नहीं कर सकते हैं, 

269
00:15:56,822 --> 00:15:59,811
बस उस एक छोटे से परेशान करने वाले 0वें बिट को काम पर वापस रखकर, 

270
00:15:59,811 --> 00:16:01,260
यह हमें उनका पता लगाने देता है।

271
00:16:02,260 --> 00:16:05,220
यह काफी मानक है, इसे विस्तारित हैमिंग कोड के रूप में जाना जाता है।

272
00:16:06,540 --> 00:16:10,784
तकनीकी रूप से कहें तो, अब आपके पास हैमिंग कोड क्या करता है इसका पूरा विवरण है, 

273
00:16:10,784 --> 00:16:12,880
कम से कम 16-बिट ब्लॉक के उदाहरण के लिए।

274
00:16:12,880 --> 00:16:17,007
लेकिन मुझे लगता है कि आपको शुरू से अंत तक एक पूरा उदाहरण देकर अपनी 

275
00:16:17,007 --> 00:16:21,320
समझ की जांच करना और इस बिंदु तक सब कुछ मजबूत करना अधिक संतोषजनक लगेगा।

276
00:16:22,080 --> 00:16:24,300
हालाँकि, मैं आपके साथ इसमें कदम उठाऊंगा ताकि आप स्वयं जांच कर सकें।

277
00:16:25,120 --> 00:16:28,153
एक संदेश सेट करने के लिए, चाहे वह एक शाब्दिक संदेश हो जिसे आप 

278
00:16:28,153 --> 00:16:32,409
अंतरिक्ष में अनुवाद कर रहे हों या कुछ डेटा जिसे आप समय के साथ संग्रहीत करना चाहते हों, 

279
00:16:32,409 --> 00:16:34,660
पहला कदम इसे 11-बिट खंडों में विभाजित करना है।

280
00:16:35,580 --> 00:16:39,760
प्रत्येक भाग को त्रुटि-प्रतिरोधी 16-बिट ब्लॉक में पैक किया जाएगा।

281
00:16:39,760 --> 00:16:43,220
तो आइए इसे एक उदाहरण के रूप में लें और वास्तव में इस पर काम करें।

282
00:16:43,740 --> 00:16:44,740
आगे बढ़ो, वास्तव में यह करो!

283
00:16:44,740 --> 00:16:47,020
आइए रुकें और इस ब्लॉक को एक साथ रखने का प्रयास करें।

284
00:16:52,720 --> 00:16:53,680
ठीक है, आप तैयार हैं?

285
00:16:54,240 --> 00:16:59,297
याद रखें, 2 की अन्य शक्तियों के साथ स्थिति 0 त्रुटि सुधार कार्य के लिए आरक्षित है, 

286
00:16:59,297 --> 00:17:03,320
इसलिए आप संदेश बिट्स को शेष सभी स्थानों पर क्रम से रखकर शुरू करें।

287
00:17:05,339 --> 00:17:09,009
आपको इस समूह में एक सम समता की आवश्यकता है, जो कि पहले से ही है, 

288
00:17:09,009 --> 00:17:12,339
इसलिए आपको उस समता बिट को स्थिति 1 में 0 पर सेट करना चाहिए।

289
00:17:13,020 --> 00:17:17,880
अगला समूह एक विषम समता के साथ शुरू होता है, इसलिए आपको इसका समता बिट 1 पर सेट करना चाहिए।

290
00:17:19,160 --> 00:17:21,598
उसके बाद समूह एक विषम समता के साथ शुरू होता है, 

291
00:17:21,598 --> 00:17:24,240
इसलिए आपको फिर से इसका समता बिट 1 पर सेट करना चाहिए।

292
00:17:24,780 --> 00:17:27,395
और अंतिम समूह में भी एक अजीब समानता है, जिसका अर्थ है 

293
00:17:27,395 --> 00:17:30,060
कि हम उस बिट को स्थिति 8 में 1 के रूप में सेट करते हैं।

294
00:17:31,300 --> 00:17:35,359
और फिर अंतिम चरण के रूप में, पूर्ण ब्लॉक में अब एक सम समता है, 

295
00:17:35,359 --> 00:17:40,320
जिसका अर्थ है कि आप उस बिट संख्या 0, व्यापक समता बिट को 0 पर सेट कर सकते हैं।

296
00:17:41,340 --> 00:17:44,536
इसलिए जैसे ही यह ब्लॉक भेजा जाता है, चार विशेष 

297
00:17:44,536 --> 00:17:48,140
उपसमुच्चय और संपूर्ण ब्लॉक की समता सम हो जाएगी, या 0.

298
00:17:48,820 --> 00:17:52,180
अभ्यास के दूसरे भाग के रूप में, आइए आपसे प्राप्तकर्ता की भूमिका निभाएँ।

299
00:17:53,480 --> 00:17:56,043
बेशक, इसका मतलब यह होगा कि आप पहले से नहीं जानते कि यह संदेश क्या है, 

300
00:17:56,043 --> 00:17:58,131
हो सकता है कि आप में से कुछ लोगों ने इसे याद कर लिया हो, 

301
00:17:58,131 --> 00:17:59,780
लेकिन मान लीजिए कि आपने इसे याद नहीं किया है।

302
00:18:00,020 --> 00:18:04,086
मैं जो करने जा रहा हूं वह उस ब्लॉक में 0, 1, या 2 बिट्स को बदलना है, 

303
00:18:04,086 --> 00:18:07,740
और फिर आपसे यह पता लगाने के लिए कहना है कि मैंने क्या किया है।

304
00:18:08,260 --> 00:18:10,810
तो फिर, रुकें और इस पर काम करने का प्रयास करें।

305
00:18:18,790 --> 00:18:23,258
ठीक है, तो अब आप रिसीवर के रूप में पहले समता समूह की जांच करें और आप देख 

306
00:18:23,258 --> 00:18:27,910
सकते हैं कि यह सम है, इसलिए जो भी त्रुटि मौजूद है वह सम कॉलम में होनी चाहिए।

307
00:18:29,690 --> 00:18:34,546
अगला चेक हमें एक विषम संख्या देता है, जो हम दोनों को बताता है कि कम से कम एक त्रुटि है, 

308
00:18:34,546 --> 00:18:37,030
और हमें इस विशिष्ट कॉलम में सीमित कर देता है।

309
00:18:38,550 --> 00:18:41,790
तीसरी जाँच सम है, संभावनाओं को और भी कम कर देती है।

310
00:18:42,650 --> 00:18:46,328
और अंतिम समता जांच अजीब है, जो हमें बताती है कि नीचे कहीं एक त्रुटि है, 

311
00:18:46,328 --> 00:18:49,650
जिसे अब तक हम देख सकते हैं कि वह स्थिति संख्या 10 में होनी चाहिए।

312
00:18:51,490 --> 00:18:57,530
इसके अलावा, पूरे ब्लॉक की समता विषम है, जिससे हमें विश्वास हो गया कि एक फ्लिप था, दो नहीं।

313
00:18:58,070 --> 00:18:59,970
यदि यह तीन या अधिक है, तो सभी दांव बंद हो जाएंगे।

314
00:19:01,310 --> 00:19:05,563
उस बिट संख्या 10 को सही करने के बाद, सुधार के लिए उपयोग नहीं किए गए 11 बिट्स को 

315
00:19:05,563 --> 00:19:08,647
बाहर निकालने से हमें मूल संदेश का प्रासंगिक खंड मिलता है, 

316
00:19:08,647 --> 00:19:13,060
जिसे यदि आप रिवाइंड करते हैं और तुलना करते हैं तो वास्तव में वही होता है जिसके साथ 

317
00:19:13,060 --> 00:19:14,390
हमने उदाहरण शुरू किया था।

318
00:19:15,710 --> 00:19:18,061
और अब जब आप जानते हैं कि यह सब हाथ से कैसे करना है, 

319
00:19:18,061 --> 00:19:21,858
तो मैं आपको दिखाना चाहूंगा कि आप पायथन कोड की एक पंक्ति के साथ इस सभी तर्क के मुख्य 

320
00:19:21,858 --> 00:19:23,170
भाग को कैसे पूरा कर सकते हैं।

321
00:19:23,870 --> 00:19:27,614
आप देखिए, जो मैंने आपको अभी तक नहीं बताया है वह यह है कि यह एल्गोरिदम वास्तव 

322
00:19:27,614 --> 00:19:31,310
में कितना सुंदर है, किसी त्रुटि की स्थिति को इंगित करने के लिए मशीन प्राप्त 

323
00:19:31,310 --> 00:19:33,984
करना कितना सरल है, इसे व्यवस्थित रूप से कैसे मापना है, 

324
00:19:33,984 --> 00:19:37,728
और हम सभी को कैसे फ्रेम कर सकते हैं यह कई अलग-अलग समता जांचों के बजाय एक एकल 

325
00:19:37,728 --> 00:19:38,750
ऑपरेशन के रूप में है।

326
00:19:39,430 --> 00:19:41,310
यह देखने के लिए कि मेरा क्या मतलब है, भाग 2 में मेरे साथ आएँ।

