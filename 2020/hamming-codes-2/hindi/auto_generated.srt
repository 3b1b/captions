1
00:00:00,000 --> 00:00:05,450
क्या आपने कभी सोचा है कि किसी सीडी या डीवीडी को स्क्रैच करना

2
00:00:05,450 --> 00:00:10,900
और उसमें जो कुछ भी संग्रहीत है उसे प्लेबैक करना कैसे संभव है?

3
00:00:10,900 --> 00:00:15,330
स्क्रैच वास्तव में डिस्क पर 1s और 0s को प्रभावित करता है, इसलिए यह संग्रहीत किए

4
00:00:15,330 --> 00:00:19,760
गए डेटा से भिन्न डेटा को पढ़ता है, लेकिन जब तक इसे वास्तव में स्क्रैच नहीं किया

5
00:00:19,760 --> 00:00:24,191
जाता है, तब तक इसके द्वारा पढ़े गए बिट्स ठीक उसी फ़ाइल में डीकोड हो जाते हैं जो

6
00:00:24,191 --> 00:00:28,400
उस पर एन्कोड किया गया था, ए उन सभी त्रुटियों के बावजूद, बिट कॉपी के लिए बिट।

7
00:00:28,400 --> 00:00:32,547
गणितीय चतुराई का एक पूरा ढेर है जो हमें डेटा संग्रहीत करने की अनुमति देता है, और उतना

8
00:00:32,547 --> 00:00:36,840
ही महत्वपूर्ण रूप से डेटा संचारित करने की अनुमति देता है, जो त्रुटियों के प्रति लचीला है।

9
00:00:36,840 --> 00:00:39,718
ठीक है, ठीक है, वास्तव में ऐसा करने का कोई तरीका

10
00:00:39,718 --> 00:00:42,480
निकालने के लिए उतनी चतुराई की आवश्यकता नहीं है।

11
00:00:42,480 --> 00:00:46,565
कोई भी फ़ाइल, चाहे वह वीडियो हो या ध्वनि या पाठ, कोई

12
00:00:46,565 --> 00:00:50,960
कोड, कोई छवि, जो भी हो, अंततः 1s और 0s का कुछ अनुक्रम है।

13
00:00:50,960 --> 00:00:54,485
और जो भी बिट फ़्लिप हो जाता है उसे ठीक करने की एक सरल रणनीति

14
00:00:54,485 --> 00:00:57,780
यह होगी कि प्रत्येक बिट की तीन प्रतियां संग्रहीत की जाएं।

15
00:00:57,780 --> 00:01:02,540
फिर इस फ़ाइल को पढ़ने वाली मशीन इन तीन प्रतियों की तुलना कर सकती है

16
00:01:02,540 --> 00:01:07,440
और जब भी कोई विसंगति हो तो हमेशा 3 में से सर्वश्रेष्ठ 2 को ले सकती है।

17
00:01:07,440 --> 00:01:11,560
लेकिन इसका मतलब यह है कि आपके स्थान का दो-तिहाई हिस्सा अतिरेक के लिए उपयोग किया जा रहा है।

18
00:01:11,560 --> 00:01:14,917
और फिर भी, छोड़ी गई सारी जगह के लिए, इस बात की कोई पुख्ता गारंटी

19
00:01:14,917 --> 00:01:18,120
नहीं है कि यदि एक से अधिक बिट फ़्लिप हो जाते हैं तो क्या होगा।

20
00:01:18,120 --> 00:01:21,546
इससे भी अधिक दिलचस्प सवाल यह है कि इसे कैसे बनाया जाए ताकि

21
00:01:21,546 --> 00:01:24,740
यथासंभव कम जगह छोड़ते हुए त्रुटियों को ठीक किया जा सके।

22
00:01:24,740 --> 00:01:27,426
उदाहरण के लिए, जिस विधि के बारे में आप इस वीडियो के बारे में

23
00:01:27,426 --> 00:01:30,289
जानेंगे, उसका उपयोग करके आप अपना डेटा 256-बिट ब्लॉक में संग्रहीत

24
00:01:30,289 --> 00:01:32,975
कर सकते हैं, जहां प्रत्येक ब्लॉक 9 बिट्स, 9 का उपयोग करता है!

25
00:01:32,975 --> 00:01:37,109
एक प्रकार की अतिरेक के रूप में कार्य करने के लिए, और अन्य 247 बिट्स

26
00:01:37,109 --> 00:01:41,000
आपके इच्छित सार्थक संदेश या डेटा को ले जाने के लिए स्वतंत्र हैं।

27
00:01:41,000 --> 00:01:44,898
और यह अब भी होगा कि यदि यहां कोई भी बिट फ़्लिप हो जाता है, तो केवल इस

28
00:01:44,898 --> 00:01:48,740
ब्लॉक को देखकर और कुछ नहीं, एक मशीन यह पहचानने में सक्षम होगी कि कोई

29
00:01:48,740 --> 00:01:53,140
त्रुटि थी और सटीक रूप से यह कहां थी ताकि वह जान सके कि इसे कैसे ठीक किया जाए। .

30
00:01:53,140 --> 00:01:55,540
और ईमानदारी से कहूं तो यह जादू जैसा लगता है।

31
00:01:55,540 --> 00:01:59,232
और इस विशेष योजना के लिए, यदि दो बिट फ़्लिप हो जाते हैं, तो मशीन कम से कम यह पता लगाने

32
00:01:59,232 --> 00:02:03,010
में सक्षम होगी कि दो त्रुटियाँ थीं, हालाँकि उसे यह नहीं पता होगा कि उन्हें कैसे ठीक किया

33
00:02:03,010 --> 00:02:03,180
जाए।

34
00:02:03,180 --> 00:02:05,815
हम थोड़ी देर बाद इस बारे में बात करेंगे कि विभिन्न

35
00:02:05,815 --> 00:02:08,140
आकारों वाले ब्लॉकों के लिए यह पैमाना कैसा है।

36
00:02:08,140 --> 00:02:10,887
वे विधियाँ जो आपको इस तरह की त्रुटियों को ठीक करने देती

37
00:02:10,887 --> 00:02:13,880
हैं, यथोचित रूप से त्रुटि सुधार कोड के रूप में जानी जाती हैं।

38
00:02:13,880 --> 00:02:18,386
पिछली शताब्दी के अधिकांश समय में, यह क्षेत्र आश्चर्यजनक रूप से गहन गणित का एक समृद्ध

39
00:02:18,386 --> 00:02:23,000
स्रोत रहा है जो हमारे द्वारा प्रतिदिन उपयोग किए जाने वाले उपकरणों में शामिल हो जाता है।

40
00:02:23,000 --> 00:02:26,190
यहां लक्ष्य आपको शुरुआती उदाहरणों में से एक, जिसे हैमिंग

41
00:02:26,190 --> 00:02:29,660
कोड के नाम से जाना जाता है, की पूरी तरह से समझ प्रदान करना है।

42
00:02:29,660 --> 00:02:33,164
और वैसे, जिस तरह से मैं इस वीडियो की संरचना के बारे में सोच रहा हूं वह इसे

43
00:02:33,164 --> 00:02:36,668
यथासंभव सीधे समझाने के बारे में कम है, और यहां और वहां थोड़े से मार्गदर्शन

44
00:02:36,668 --> 00:02:40,220
के साथ आपको इसे अपने लिए आविष्कार करने के लिए प्रेरित करने का मामला अधिक है।

45
00:02:40,220 --> 00:02:43,764
इसलिए जब आपको लगे कि किसी बिंदु पर आप देख रहे हैं कि यह कहां जा रहा है, तो उस क्षण

46
00:02:43,764 --> 00:02:47,180
रुकें, मेरे बताने से पहले सक्रिय रूप से अनुमान लगाएं कि योजना क्या होने वाली है।

47
00:02:47,180 --> 00:02:51,179
साथ ही, यदि आप चाहते हैं कि आपकी समझ हार्डवेयर स्तर तक पहुंचे, तो बेन

48
00:02:51,179 --> 00:02:55,178
ईटर ने इसके साथ मिलकर एक वीडियो बनाया है जिसमें आपको दिखाया गया है कि

49
00:02:55,178 --> 00:02:59,520
वास्तव में ब्रेडबोर्ड पर हैमिंग कोड कैसे लागू किया जाए, जो बेहद संतोषजनक है।

50
00:02:59,520 --> 00:03:04,445
आपको पता होना चाहिए, हैमिंग कोड रीड-सोलोमन एल्गोरिथ्म की तरह अधिक आधुनिक कोड के रूप में

51
00:03:04,445 --> 00:03:09,370
व्यापक रूप से उपयोग नहीं किए जाते हैं, लेकिन शुरुआत में यह कार्य कितना असंभव लगता है और

52
00:03:09,370 --> 00:03:14,240
एक बार यह कितना उचित लगता है, इसके बीच एक निश्चित जादू है। आप हैमिंग के बारे में जानें।

53
00:03:14,240 --> 00:03:18,585
त्रुटि सुधार का मूल सिद्धांत यह है कि सभी संभावित संदेशों के

54
00:03:18,585 --> 00:03:22,860
विशाल स्थान में, केवल कुछ उपसमूह को ही वैध संदेश माना जाएगा।

55
00:03:22,860 --> 00:03:29,100
सादृश्य के रूप में, सही वर्तनी वाले शब्दों बनाम गलत वर्तनी वाले शब्दों के बारे में सोचें।

56
00:03:29,100 --> 00:03:33,740
जब भी कोई वैध संदेश बदल जाता है, तो प्राप्तकर्ता निकटतम वैध पड़ोसी को जो दिखाई देता

57
00:03:33,740 --> 00:03:38,380
है उसे ठीक करने के लिए जिम्मेदार होता है, जैसा कि आप टाइपो के मामले में कर सकते हैं।

58
00:03:38,380 --> 00:03:42,673
हालाँकि, इस तरह के संदेशों को कुशलतापूर्वक वर्गीकृत करने के लिए एक

59
00:03:42,673 --> 00:03:47,160
ठोस एल्गोरिदम के साथ आने के लिए एक निश्चित चतुराई की आवश्यकता होती है।

60
00:03:47,160 --> 00:03:50,461
कहानी 1940 के दशक में शुरू होती है, जब एक युवा रिचर्ड हैमिंग बेल

61
00:03:50,461 --> 00:03:53,864
लैब्स के लिए काम कर रहे थे, और उनके कुछ काम में एक बहुत बड़े महंगे

62
00:03:53,864 --> 00:03:57,420
पंच कार्ड कंप्यूटर का उपयोग करना शामिल था, जिस तक उनकी सीमित पहुंच थी।

63
00:03:57,420 --> 00:04:00,135
और जो प्रोग्राम वह इसके माध्यम से डालता रहा वह

64
00:04:00,135 --> 00:04:03,140
विफल होता रहा, क्योंकि कभी-कभी कुछ गलत पढ़ा जाता था।

65
00:04:03,140 --> 00:04:06,060
आविष्कार की भट्ठी निराशा से वह इतना तंग आ गया कि

66
00:04:06,060 --> 00:04:09,280
उसने दुनिया का पहला त्रुटि सुधार कोड का आविष्कार किया।

67
00:04:09,280 --> 00:04:13,000
हैमिंग कोड को फ्रेम करने के कई अलग-अलग तरीके हैं, लेकिन पहली बार हम इसके

68
00:04:13,000 --> 00:04:16,620
माध्यम से जाने वाले हैं जिस तरह से हैमिंग ने खुद उनके बारे में सोचा था।

69
00:04:16,620 --> 00:04:21,400
आइए एक उदाहरण का उपयोग करें जो सरल है, लेकिन बहुत सरल नहीं है, 16 बिट्स का एक ब्लॉक।

70
00:04:21,400 --> 00:04:25,700
हम इन बिट्स की स्थिति को 0 से 15 तक क्रमांकित करेंगे।

71
00:04:25,700 --> 00:04:29,724
जो वास्तविक डेटा हम संग्रहीत करना चाहते हैं, वह इनमें से केवल 12 बिट्स

72
00:04:29,724 --> 00:04:33,920
को बनाने वाला है, जबकि 4 स्थान एक प्रकार के अतिरेक के रूप में आरक्षित हैं।

73
00:04:33,920 --> 00:04:37,105
यहां निरर्थक शब्द का मतलब केवल कॉपी करना नहीं है, आखिरकार, वे 4 बिट्स

74
00:04:37,105 --> 00:04:40,200
हमें डेटा को आंख मूंदकर कॉपी करने के लिए पर्याप्त जगह नहीं देते हैं।

75
00:04:40,200 --> 00:04:44,717
इसके बजाय, उन्हें बहुत अधिक सूक्ष्म और चतुर प्रकार के अतिरेक की आवश्यकता

76
00:04:44,717 --> 00:04:48,740
होगी, कोई नई जानकारी नहीं जोड़नी होगी, बल्कि लचीलापन जोड़ना होगा।

77
00:04:48,740 --> 00:04:52,600
आप उम्मीद कर सकते हैं कि ये 4 विशेष बिट्स अच्छी तरह से एक साथ पैक किए जाएंगे, शायद

78
00:04:52,600 --> 00:04:56,413
अंत में या ऐसा कुछ, लेकिन जैसा कि आप देखेंगे, उन्हें उन स्थितियों में बैठाना जो 2

79
00:04:56,413 --> 00:05:00,320
की शक्तियाँ हैं, अंत तक कुछ ऐसा करने की अनुमति देता है जो वास्तव में सुरुचिपूर्ण है।

80
00:05:00,320 --> 00:05:05,420
यह आपको इस बारे में भी थोड़ा संकेत दे सकता है कि यह बड़े ब्लॉकों के लिए कैसा है।

81
00:05:05,420 --> 00:05:09,904
इसके अलावा तकनीकी रूप से यह केवल 11 बिट डेटा बनकर रह जाता है, आप पाएंगे कि स्थिति

82
00:05:09,904 --> 00:05:14,280
0 पर जो होता है उसमें थोड़ी बारीकियां हैं, लेकिन अभी इसके बारे में चिंता न करें।

83
00:05:14,280 --> 00:05:18,269
किसी भी त्रुटि सुधार एल्गोरिदम की तरह, इसमें दो खिलाड़ी शामिल होंगे, एक

84
00:05:18,269 --> 00:05:22,314
प्रेषक जो इन 4 विशेष बिट्स को सेट करने के लिए जिम्मेदार है, और एक रिसीवर

85
00:05:22,314 --> 00:05:26,360
जो किसी प्रकार की जांच करने और त्रुटियों को ठीक करने के लिए जिम्मेदार है।

86
00:05:26,360 --> 00:05:29,368
बेशक, प्रेषक और रिसीवर शब्द वास्तव में उन मशीनों या सॉफ़्टवेयर

87
00:05:29,368 --> 00:05:32,376
को संदर्भित करते हैं जो सभी जांच कर रहे हैं, और संदेश का विचार

88
00:05:32,376 --> 00:05:35,480
वास्तव में मोटे तौर पर भंडारण जैसी चीजों को शामिल करने के लिए है।

89
00:05:35,480 --> 00:05:38,961
आख़िरकार, डेटा संग्रहीत करना एक संदेश को एक स्थान से

90
00:05:38,961 --> 00:05:42,640
दूसरे स्थान के बजाय अतीत से भविष्य में भेजने जैसा ही है।

91
00:05:42,640 --> 00:05:46,228
तो यह सेटअप है, लेकिन इससे पहले कि हम आगे बढ़ें हमें एक संबंधित विचार

92
00:05:46,228 --> 00:05:49,764
के बारे में बात करने की ज़रूरत है जो हैमिंग के दिमाग में उनकी खोज के

93
00:05:49,764 --> 00:05:53,353
समय ताजा था, एक ऐसी विधि जो आपको किसी भी बिट त्रुटि का पता लगाने देती

94
00:05:53,353 --> 00:05:57,300
है, लेकिन उन्हें ठीक करने की नहीं, ज्ञात है व्यवसाय में समता जाँच के रूप में।

95
00:05:57,300 --> 00:06:01,091
समता जांच के लिए, हम केवल एक बिट को अलग करते हैं जिसे ट्यूनिंग के

96
00:06:01,091 --> 00:06:04,940
लिए प्रेषक जिम्मेदार है, और बाकी संदेश ले जाने के लिए स्वतंत्र हैं।

97
00:06:04,940 --> 00:06:08,443
इस विशेष बिट का एकमात्र काम यह सुनिश्चित करना

98
00:06:08,443 --> 00:06:12,100
है कि संदेश में 1 की कुल संख्या एक सम संख्या है।

99
00:06:12,100 --> 00:06:16,435
उदाहरण के लिए अभी, 1 की कुल संख्या 7 है, यह अजीब है, इसलिए प्रेषक को

100
00:06:16,435 --> 00:06:20,960
उस विशेष बिट को 1 करने के लिए फ़्लिप करना होगा, जिससे गिनती सम हो जाएगी।

101
00:06:20,960 --> 00:06:24,253
लेकिन यदि ब्लॉक पहले से ही 1 की सम संख्या के साथ

102
00:06:24,253 --> 00:06:27,480
शुरू हुआ होता, तो इस विशेष बिट को 0 पर रखा जाता।

103
00:06:27,480 --> 00:06:32,739
यह बहुत ही सरल, भ्रामक रूप से सरल है, लेकिन यह किसी संदेश में कहीं भी परिवर्तन के विचार

104
00:06:32,739 --> 00:06:37,760
को जानकारी के एक टुकड़े में प्रतिबिंबित करने का एक अविश्वसनीय रूप से सुंदर तरीका है।

105
00:06:37,760 --> 00:06:43,109
ध्यान दें कि यदि इस संदेश का कोई भी अंश 0 से 1 या 1 से 0 तक फ़्लिप

106
00:06:43,109 --> 00:06:48,140
हो जाता है, तो यह 1 की कुल गिनती को सम से विषम में बदल देता है।

107
00:06:48,140 --> 00:06:51,621
इसलिए यदि आप रिसीवर हैं, आप इस संदेश को देखते हैं, और आपको 1

108
00:06:51,621 --> 00:06:55,218
की एक विषम संख्या दिखाई देती है, तो आप निश्चित रूप से जान सकते

109
00:06:55,218 --> 00:06:58,700
हैं कि कुछ त्रुटि हुई है, भले ही आपको पता न हो कि यह कहां थी।

110
00:06:58,700 --> 00:07:01,942
शब्दजाल में, चाहे बिट्स के समूह में 1s की सम या विषम

111
00:07:01,942 --> 00:07:04,940
संख्या हो, इसे इसकी समता के रूप में जाना जाता है।

112
00:07:04,940 --> 00:07:08,044
आप संख्याओं का भी उपयोग कर सकते हैं और कह सकते हैं कि समता 0 या 1 है, जो

113
00:07:08,044 --> 00:07:11,320
आमतौर पर तब अधिक सहायक होती है जब आप इस विचार के साथ गणित करना शुरू करते हैं।

114
00:07:11,320 --> 00:07:14,670
और यह विशेष बिट जिसे प्रेषक समता को नियंत्रित

115
00:07:14,670 --> 00:07:18,020
करने के लिए उपयोग करता है, समता बिट कहलाता है।

116
00:07:18,020 --> 00:07:21,883
और वास्तव में, हमें स्पष्ट होना चाहिए, यदि रिसीवर एक विषम समता देखता है, तो

117
00:07:21,883 --> 00:07:25,645
इसका मतलब यह नहीं है कि केवल एक त्रुटि थी, 3 त्रुटियां, या 5, या कोई अन्य

118
00:07:25,645 --> 00:07:29,560
विषम संख्या हो सकती है, लेकिन वे निश्चित रूप से जान सकते हैं कि यह 0 नहीं था.

119
00:07:29,560 --> 00:07:34,138
दूसरी ओर, यदि 2 त्रुटियाँ थीं, या कोई सम संख्या में त्रुटियाँ थीं, तो

120
00:07:34,138 --> 00:07:38,585
1 की अंतिम गिनती अभी भी सम होगी, इसलिए प्राप्तकर्ता को पूरा विश्वास

121
00:07:38,585 --> 00:07:43,360
नहीं हो सकता है कि एक सम संख्या का मतलब यह है कि संदेश त्रुटि-मुक्त है। .

122
00:07:43,360 --> 00:07:46,639
आप शिकायत कर सकते हैं कि जो संदेश केवल 2 बिट फ़्लिप से गड़बड़

123
00:07:46,639 --> 00:07:49,760
हो जाता है वह बहुत कमज़ोर होता है, और आप बिल्कुल सही होंगे।

124
00:07:49,760 --> 00:07:54,646
ध्यान रखें, हालाँकि, त्रुटि का पता लगाने या सुधार करने की कोई विधि नहीं है जो

125
00:07:54,646 --> 00:07:59,720
आपको 100% विश्वास दिला सके कि आपको प्राप्त संदेश वही है जो भेजने वाले ने चाहा है।

126
00:07:59,720 --> 00:08:02,820
आख़िरकार, पर्याप्त यादृच्छिक शोर हमेशा शुद्ध संयोग

127
00:08:02,820 --> 00:08:05,920
से एक वैध संदेश को दूसरे वैध संदेश में बदल सकता है।

128
00:08:05,920 --> 00:08:11,027
इसके बजाय, लक्ष्य एक ऐसी योजना बनाना है जो त्रुटियों की एक निश्चित अधिकतम

129
00:08:11,027 --> 00:08:16,480
संख्या तक मजबूत हो, या शायद इस तरह की झूठी सकारात्मकता की संभावना को कम कर सके।

130
00:08:16,480 --> 00:08:20,320
समता जांच अपने आप में काफी कमजोर हैं, लेकिन एक पूर्ण संदेश में

131
00:08:20,320 --> 00:08:24,160
परिवर्तन के विचार को एक बिट तक सीमित करके, वे हमें जो देते हैं

132
00:08:24,160 --> 00:08:28,000
वह अधिक परिष्कृत योजनाओं के लिए एक शक्तिशाली बिल्डिंग ब्लॉक है।

133
00:08:28,000 --> 00:08:31,861
उदाहरण के लिए, जब हैमिंग यह पहचानने का एक तरीका खोज रहा था कि त्रुटि कहाँ

134
00:08:31,861 --> 00:08:35,619
हुई है, न कि केवल यह कि यह घटित हुई है, तो उसकी मुख्य अंतर्दृष्टि यह थी

135
00:08:35,619 --> 00:08:39,481
कि यदि आप कुछ समता जाँचों को पूर्ण संदेश पर नहीं, बल्कि कुछ सावधानीपूर्वक

136
00:08:39,481 --> 00:08:43,239
चयनित उपसमूहों पर लागू करते हैं, तो आप पूछ सकते हैं प्रश्नों की एक अधिक

137
00:08:43,239 --> 00:08:46,840
परिष्कृत श्रृंखला जो किसी भी एक बिट त्रुटि के स्थान को इंगित करती है।

138
00:08:46,840 --> 00:08:50,621
कुल मिलाकर भावना कुछ-कुछ 20 प्रश्नों का खेल खेलने जैसा है, जिसमें हां या

139
00:08:50,621 --> 00:08:54,300
ना में ऐसे प्रश्न पूछे जाते हैं जो संभावनाओं की जगह को आधा कर देते हैं।

140
00:08:54,300 --> 00:08:57,380
उदाहरण के लिए, मान लें कि हम केवल इन 8 बिट्स, सभी

141
00:08:57,380 --> 00:09:00,400
विषम संख्या वाली स्थितियों पर समता जांच करते हैं।

142
00:09:00,400 --> 00:09:04,952
फिर यदि कोई त्रुटि पाई जाती है, तो यह रिसीवर को इस बारे में थोड़ी अधिक जानकारी

143
00:09:04,952 --> 00:09:09,160
देता है कि विशेष रूप से त्रुटि कहाँ है, अर्थात् यह एक विषम स्थिति में है।

144
00:09:09,160 --> 00:09:13,330
यदि उन 8 बिट्स के बीच कोई त्रुटि नहीं पाई जाती है, तो इसका मतलब

145
00:09:13,330 --> 00:09:17,240
है कि कोई त्रुटि नहीं है, या यह कहीं सम स्थिति में बैठता है।

146
00:09:17,240 --> 00:09:21,140
आप सोच सकते हैं कि समता जांच को आधे बिट्स तक सीमित करने से यह कम

147
00:09:21,140 --> 00:09:25,280
प्रभावी हो जाता है, लेकिन जब इसे अन्य अच्छी तरह से चुनी गई जांचों के

148
00:09:25,280 --> 00:09:29,720
साथ संयोजन में किया जाता है, तो यह हमें कुछ अधिक शक्तिशाली प्रदान करता है।

149
00:09:29,720 --> 00:09:33,445
वास्तव में उस समता जाँच को स्थापित करने के लिए, याद रखें, इसमें कुछ विशेष बिट

150
00:09:33,445 --> 00:09:37,600
निर्धारित करने की आवश्यकता होती है जिसका उस पूर्ण समूह की समता के लिए नियंत्रण होता है।

151
00:09:37,600 --> 00:09:39,920
आइए यहां केवल स्थिति 1 चुनें।

152
00:09:39,920 --> 00:09:44,130
दिखाए गए उदाहरण के लिए, इन 8 बिट्स की समता वर्तमान में विषम है, इसलिए

153
00:09:44,130 --> 00:09:48,220
प्रेषक उस समता बिट को टॉगल करने के लिए जिम्मेदार है, और अब यह सम है।

154
00:09:48,220 --> 00:09:51,040
यह 4 समता जांचों में से केवल 1 है जो हम करेंगे।

155
00:09:51,040 --> 00:09:54,017
दूसरा चेक ग्रिड के दाहिने आधे हिस्से पर 8 बिट्स में

156
00:09:54,017 --> 00:09:56,880
से एक है, कम से कम जैसा कि हमने इसे यहां खींचा है।

157
00:09:56,880 --> 00:10:02,077
इस बार हम स्थिति 2 को समता बिट के रूप में उपयोग कर सकते हैं, इसलिए इन 8 बिट्स में पहले से

158
00:10:02,077 --> 00:10:07,160
ही एक सम समता है, और प्रेषक उस बिट संख्या 2 को अपरिवर्तित छोड़कर अच्छा महसूस कर सकता है।

159
00:10:07,160 --> 00:10:11,586
फिर दूसरे छोर पर, यदि रिसीवर इस समूह की समता की जांच करता है और उन्हें पता चलता है

160
00:10:11,586 --> 00:10:15,960
कि यह अजीब है, तो उन्हें पता चल जाएगा कि त्रुटि दाईं ओर इन 8 बिट्स में से कहीं है।

161
00:10:15,960 --> 00:10:21,260
अन्यथा इसका मतलब है कि या तो कोई त्रुटि नहीं है, या त्रुटि बाएं आधे हिस्से में कहीं है।

162
00:10:21,260 --> 00:10:24,034
या मुझे लगता है कि दो त्रुटियाँ हो सकती थीं, लेकिन

163
00:10:24,034 --> 00:10:27,080
अभी हम यह मानेंगे कि पूरे ब्लॉक में अधिकतम एक त्रुटि है।

164
00:10:27,080 --> 00:10:29,160
इससे अधिक के लिए चीजें पूरी तरह से टूट जाती हैं।

165
00:10:29,160 --> 00:10:32,479
यहां, इससे पहले कि हम अगली दो जांचों पर गौर करें, एक पल के लिए यह सोचें कि जब आप

166
00:10:32,479 --> 00:10:35,880
उन पर एक साथ विचार करते हैं तो ये पहली दो जांचें हमें क्या करने की अनुमति देती हैं।

167
00:10:35,880 --> 00:10:40,240
मान लीजिए कि आपको विषम स्तंभों और दाएँ आधे भाग के बीच एक त्रुटि का पता चलता है।

168
00:10:40,240 --> 00:10:43,940
इसका आवश्यक अर्थ यह है कि त्रुटि अंतिम कॉलम में कहीं है।

169
00:10:43,940 --> 00:10:47,205
यदि विषम कॉलम में कोई त्रुटि नहीं थी, लेकिन दाहिने आधे हिस्से में

170
00:10:47,205 --> 00:10:50,520
एक त्रुटि थी, तो यह आपको बताता है कि यह दूसरे से अंतिम कॉलम में है।

171
00:10:50,520 --> 00:10:53,439
इसी तरह यदि विषम कॉलम में कोई त्रुटि है, लेकिन दाहिने आधे

172
00:10:53,439 --> 00:10:56,560
हिस्से में नहीं, तो आप जानते हैं कि यह दूसरे कॉलम में कहीं है।

173
00:10:56,560 --> 00:11:00,232
और यदि उन दोनों समता जांचों में से कोई भी कुछ भी पता नहीं लगाता है, तो इसका

174
00:11:00,232 --> 00:11:03,760
मतलब है कि एकमात्र स्थान जहां त्रुटि हो सकती है वह सबसे बाएं कॉलम में है।

175
00:11:03,760 --> 00:11:06,480
लेकिन इसका सीधा मतलब यह भी हो सकता है कि कोई त्रुटि ही नहीं है।

176
00:11:06,480 --> 00:11:11,800
यह कहने का एक विस्तृत तरीका है कि दो समता जांचों से हम कॉलम को पिन कर सकते हैं।

177
00:11:11,800 --> 00:11:14,000
यहां से, आप शायद अनुमान लगा सकते हैं कि आगे क्या होगा।

178
00:11:14,000 --> 00:11:16,240
हम मूल रूप से वही काम करते हैं लेकिन पंक्तियों के लिए।

179
00:11:16,240 --> 00:11:21,040
समता बिट के रूप में स्थिति 4 का उपयोग करते हुए, विषम पंक्तियों पर समता जांच की जाएगी।

180
00:11:21,040 --> 00:11:26,480
तो इस उदाहरण में उस समूह में पहले से ही सम समता है, इसलिए बिट 4 को 0 पर सेट किया जाएगा।

181
00:11:26,480 --> 00:11:29,239
और अंत में समता बिट के रूप में स्थिति 8 का उपयोग

182
00:11:29,239 --> 00:11:32,280
करते हुए नीचे की दो पंक्तियों पर एक समता जांच होती है।

183
00:11:32,280 --> 00:11:35,060
इस मामले में, ऐसा लगता है कि समूह को समता प्रदान करने

184
00:11:35,060 --> 00:11:37,840
के लिए प्रेषक को उस बिट 8 को चालू करने की आवश्यकता है।

185
00:11:37,840 --> 00:11:40,558
जैसे पहले दो चेक हमें कॉलम को पिन करने देते हैं,

186
00:11:40,558 --> 00:11:43,000
ये अगले दो आपको पंक्ति को पिन करने देते हैं।

187
00:11:43,000 --> 00:11:48,400
उदाहरण के तौर पर, कल्पना करें कि ट्रांसमिशन के दौरान स्थिति 3 पर कोई त्रुटि है।

188
00:11:48,400 --> 00:11:52,522
खैर, यह पहले समता समूह को प्रभावित करता है, और यह दूसरे समता समूह को भी प्रभावित

189
00:11:52,522 --> 00:11:56,340
करता है, इसलिए रिसीवर को पता चलता है कि उस सही कॉलम में कहीं कोई त्रुटि है।

190
00:11:56,340 --> 00:11:58,998
लेकिन तीसरे समूह पर इसका कोई प्रभाव नहीं पड़ता,

191
00:11:58,998 --> 00:12:01,380
और चौथे समूह पर इसका कोई प्रभाव नहीं पड़ता।

192
00:12:01,380 --> 00:12:04,822
और यह रिसीवर को पहली पंक्ति तक त्रुटि को इंगित करने देता है,

193
00:12:04,822 --> 00:12:08,660
जिसका अर्थ आवश्यक रूप से स्थिति 3 है, ताकि वे त्रुटि को ठीक कर सकें।

194
00:12:08,660 --> 00:12:12,933
आप स्वयं को यह समझाने में कुछ समय का आनंद ले सकते हैं कि इन चार प्रश्नों के

195
00:12:12,933 --> 00:12:17,320
उत्तर वास्तव में आपको हमेशा एक विशिष्ट स्थान बताने देंगे, चाहे वे कहीं भी हों।

196
00:12:17,320 --> 00:12:20,510
वास्तव में, आपमें से जो चतुर लोग हैं वे इन प्रश्नों

197
00:12:20,510 --> 00:12:23,640
और बाइनरी काउंटिंग के बीच एक संबंध भी देख सकते हैं।

198
00:12:23,640 --> 00:12:27,119
और यदि आप ऐसा करते हैं, तो मुझे फिर से जोर देने दीजिए, रुकिए,

199
00:12:27,119 --> 00:12:30,880
इससे पहले कि मैं इसे खराब कर दूं, संबंध बनाने का स्वयं प्रयास करें।

200
00:12:30,880 --> 00:12:33,838
यदि आप सोच रहे हैं कि यदि समता बिट स्वयं प्रभावित

201
00:12:33,838 --> 00:12:36,560
हो जाए तो क्या होगा, तो आप इसे आज़मा सकते हैं।

202
00:12:36,560 --> 00:12:42,033
इस बारे में सोचने के लिए एक क्षण लें कि इन चार विशेष बिट्स के बीच किसी भी त्रुटि

203
00:12:42,033 --> 00:12:47,440
को किसी भी अन्य की तरह, चार प्रश्नों के एक ही समूह के साथ कैसे ट्रैक किया जाएगा।

204
00:12:47,440 --> 00:12:50,582
यह वास्तव में कोई फर्क नहीं पड़ता, क्योंकि दिन के अंत में हम जो चाहते हैं

205
00:12:50,582 --> 00:12:53,640
वह संदेश बिट्स की सुरक्षा करना है, त्रुटि सुधार बिट्स बस साथ चल रहे हैं।

206
00:12:53,640 --> 00:12:56,475
लेकिन उन बिट्स की सुरक्षा भी एक ऐसी चीज है जो स्वाभाविक

207
00:12:56,475 --> 00:12:59,260
रूप से एक उपोत्पाद के रूप में योजना से बाहर हो जाती है।

208
00:12:59,260 --> 00:13:02,380
आपको यह अनुमान लगाने में भी आनंद आ सकता है कि इसका पैमाना कैसा होगा।

209
00:13:02,380 --> 00:13:06,700
यदि हमने 256 बिट आकार के ब्लॉक का उपयोग किया है, उदाहरण के लिए,

210
00:13:06,700 --> 00:13:11,156
किसी स्थान को पिन करने के लिए, तो आपको किसी विशिष्ट स्थान पर अपना

211
00:13:11,156 --> 00:13:15,680
रास्ता खोजने के लिए केवल आठ हाँ या नहीं के प्रश्नों की आवश्यकता है।

212
00:13:15,680 --> 00:13:19,365
और याद रखें, प्रत्येक प्रश्न के लिए उचित समता जांच

213
00:13:19,365 --> 00:13:23,340
सेट करने के लिए केवल एक बिट छोड़ने की आवश्यकता होती है।

214
00:13:23,340 --> 00:13:26,737
आप में से कुछ लोग इसे पहले से ही देख सकते हैं, लेकिन हम बाद में एक या दो मिनट

215
00:13:26,737 --> 00:13:29,960
में ये प्रश्न क्या हैं यह जानने के व्यवस्थित तरीके के बारे में बात करेंगे।

216
00:13:29,960 --> 00:13:32,130
उम्मीद है कि हम यहां जो विकसित कर रहे हैं उसकी

217
00:13:32,130 --> 00:13:34,440
दक्षता की सराहना करने के लिए यह स्केच पर्याप्त है।

218
00:13:34,440 --> 00:13:38,141
पहली चीज़, उन आठ हाइलाइट किए गए समता बिट्स को छोड़कर, वह हो

219
00:13:38,141 --> 00:13:41,720
सकती है जो आप चाहते हैं, जो भी संदेश या डेटा आप चाहते हैं।

220
00:13:41,720 --> 00:13:47,644
8 बिट्स इस अर्थ में अनावश्यक हैं कि वे पूरी तरह से शेष संदेश द्वारा निर्धारित होते

221
00:13:47,644 --> 00:13:53,640
हैं, लेकिन यह संपूर्ण संदेश को कॉपी करने की तुलना में कहीं अधिक स्मार्ट तरीके से है।

222
00:13:53,640 --> 00:13:56,372
और फिर भी, इतनी कम छूट के बावजूद, आप किसी भी एक बिट

223
00:13:56,372 --> 00:13:59,000
त्रुटि को पहचानने और उसे ठीक करने में सक्षम होंगे।

224
00:13:59,000 --> 00:14:00,400
हां तकरीबन।

225
00:14:00,400 --> 00:14:04,617
ठीक है, तो यहां एक समस्या यह है कि यदि चार समता जांचों में से कोई भी

226
00:14:04,617 --> 00:14:08,896
त्रुटि का पता नहीं लगाता है, जिसका अर्थ है कि 8 बिट्स के विशेष रूप से

227
00:14:08,896 --> 00:14:13,175
चयनित उपसमुच्चय में सम समताएं हैं, जैसा कि प्रेषक ने चाहा था, तो इसका

228
00:14:13,175 --> 00:14:17,760
मतलब यह है कि कोई त्रुटि नहीं थी , या यह हमें स्थिति 0 तक सीमित कर देता है।

229
00:14:17,760 --> 00:14:22,696
आप देखते हैं, चार हां या ना वाले प्रश्नों के साथ, हमारे पास समता जांच के लिए 16

230
00:14:22,696 --> 00:14:27,632
संभावित परिणाम हैं, और सबसे पहले यह ब्लॉक में 16 पदों में से 1 को इंगित करने के

231
00:14:27,632 --> 00:14:33,000
लिए बिल्कुल सही लगता है, लेकिन आपको 17वां परिणाम भी बताना होगा, कोई त्रुटि नहीं स्थिति।

232
00:14:33,000 --> 00:14:37,860
यहां समाधान वास्तव में बहुत सरल है, बस उस 0वें बिट के बारे में पूरी तरह से भूल जाएं।

233
00:14:37,860 --> 00:14:41,145
इसलिए जब हम अपनी चार समता जांच करते हैं और देखते हैं कि वे

234
00:14:41,145 --> 00:14:44,320
सभी सम हैं, तो इसका स्पष्ट अर्थ है कि कोई त्रुटि नहीं है।

235
00:14:44,320 --> 00:14:49,145
इसका मतलब यह है कि 16-बिट ब्लॉक के साथ काम करने के बजाय, हम 15-बिट ब्लॉक के साथ काम करते

236
00:14:49,145 --> 00:14:53,863
हैं, जहां 11 बिट्स संदेश ले जाने के लिए स्वतंत्र हैं और उनमें से 4 बिट्स अतिरेक के लिए

237
00:14:53,863 --> 00:14:54,080
हैं।

238
00:14:54,080 --> 00:14:56,659
और इसके साथ ही, अब हमारे पास वह है जिसे व्यवसाय

239
00:14:56,659 --> 00:14:59,400
के लोग 15-11 हैमिंग कोड के रूप में संदर्भित करेंगे।

240
00:14:59,400 --> 00:15:02,639
जैसा कि कहा गया है, एक ब्लॉक का आकार 2 की साफ शक्ति वाला होना अच्छा

241
00:15:02,639 --> 00:15:05,783
है, और एक चतुर तरीका है कि हम उस 0 बिट को अपने पास रख सकते हैं और

242
00:15:05,783 --> 00:15:08,880
इसे हमारे लिए थोड़ा अतिरिक्त काम करने के लिए प्राप्त कर सकते हैं।

243
00:15:08,880 --> 00:15:12,525
यदि हम इसे पूरे ब्लॉक में समता बिट के रूप में उपयोग करते हैं, तो यह हमें

244
00:15:12,525 --> 00:15:16,320
वास्तव में पता लगाने देता है, भले ही हम 2-बिट त्रुटियों को ठीक नहीं कर सकते।

245
00:15:16,320 --> 00:15:17,440
यह ऐसे काम करता है।

246
00:15:17,440 --> 00:15:21,372
उन चार विशेष त्रुटि-सुधार बिट्स को सेट करने के बाद, हम उस 0 वें को

247
00:15:21,372 --> 00:15:25,540
सेट करते हैं ताकि पूर्ण ब्लॉक की समता सामान्य समता जांच की तरह समान हो।

248
00:15:25,540 --> 00:15:29,633
अब, यदि एक भी बिट त्रुटि है, तो पूर्ण ब्लॉक की समता विषम होने के लिए टॉगल हो

249
00:15:29,633 --> 00:15:33,940
जाती है, लेकिन चार त्रुटि-सुधार जांचों के लिए धन्यवाद, हम इसे वैसे भी पकड़ लेंगे।

250
00:15:33,940 --> 00:15:37,900
हालाँकि, यदि दो त्रुटियाँ हैं, तो समग्र समता वापस सम होने पर

251
00:15:37,900 --> 00:15:42,054
टॉगल हो जाएगी, लेकिन रिसीवर अभी भी देखेगा कि उन चार समता जाँचों

252
00:15:42,054 --> 00:15:45,820
के साथ जो हो रहा है, उसके कारण कम से कम कुछ त्रुटि हुई है।

253
00:15:45,820 --> 00:15:49,423
इसलिए यदि वे समग्र रूप से एक समान समानता देखते हैं, लेकिन अन्य जांचों के साथ

254
00:15:49,423 --> 00:15:52,980
कुछ गैर-शून्य हो रहा है, तो यह उन्हें बताता है कि कम से कम दो त्रुटियां थीं।

255
00:15:52,980 --> 00:15:54,420
क्या वह चतुराई नहीं है?

256
00:15:54,420 --> 00:15:58,193
भले ही हम उन 2-बिट त्रुटियों को ठीक नहीं कर सकते हैं, बस उस एक छोटे से

257
00:15:58,193 --> 00:16:02,340
परेशान करने वाले 0वें बिट को काम पर वापस रखकर, यह हमें उनका पता लगाने देता है।

258
00:16:02,340 --> 00:16:06,540
यह काफी मानक है, इसे विस्तारित हैमिंग कोड के रूप में जाना जाता है।

259
00:16:06,540 --> 00:16:10,060
तकनीकी रूप से कहें तो, अब आपके पास हैमिंग कोड क्या करता है

260
00:16:10,060 --> 00:16:13,580
इसका पूरा विवरण है, कम से कम 16-बिट ब्लॉक के उदाहरण के लिए।

261
00:16:13,580 --> 00:16:17,688
लेकिन मुझे लगता है कि आपको शुरू से अंत तक एक पूरा उदाहरण देकर अपनी

262
00:16:17,688 --> 00:16:21,980
समझ की जांच करना और इस बिंदु तक सब कुछ मजबूत करना अधिक संतोषजनक लगेगा।

263
00:16:21,980 --> 00:16:25,100
हालाँकि, मैं आपके साथ इसमें कदम उठाऊंगा ताकि आप स्वयं जांच कर सकें।

264
00:16:25,100 --> 00:16:28,470
एक संदेश सेट करने के लिए, चाहे वह एक शाब्दिक संदेश हो जिसे आप

265
00:16:28,470 --> 00:16:31,840
अंतरिक्ष में अनुवाद कर रहे हों या कुछ डेटा जिसे आप समय के साथ

266
00:16:31,840 --> 00:16:35,700
संग्रहीत करना चाहते हों, पहला कदम इसे 11-बिट खंडों में विभाजित करना है।

267
00:16:35,700 --> 00:16:40,340
प्रत्येक भाग को त्रुटि-प्रतिरोधी 16-बिट ब्लॉक में पैक किया जाएगा।

268
00:16:40,340 --> 00:16:43,740
तो आइए इसे एक उदाहरण के रूप में लें और वास्तव में इस पर काम करें।

269
00:16:43,740 --> 00:16:45,380
आगे बढ़ो, वास्तव में यह करो!

270
00:16:45,380 --> 00:16:52,980
आइए रुकें और इस ब्लॉक को एक साथ रखने का प्रयास करें।

271
00:16:52,980 --> 00:16:53,980
ठीक है, आप तैयार हैं?

272
00:16:53,980 --> 00:16:59,564
याद रखें, 2 की अन्य शक्तियों के साथ स्थिति 0 त्रुटि सुधार कार्य के लिए

273
00:16:59,564 --> 00:17:05,700
आरक्षित है, इसलिए आप संदेश बिट्स को शेष सभी स्थानों पर क्रम से रखकर शुरू करें।

274
00:17:05,700 --> 00:17:09,360
आपको इस समूह में एक सम समता की आवश्यकता है, जो कि पहले से ही

275
00:17:09,360 --> 00:17:13,140
है, इसलिए आपको उस समता बिट को स्थिति 1 में 0 पर सेट करना चाहिए।

276
00:17:13,140 --> 00:17:19,260
अगला समूह एक विषम समता के साथ शुरू होता है, इसलिए आपको इसका समता बिट 1 पर सेट करना चाहिए।

277
00:17:19,260 --> 00:17:21,890
उसके बाद समूह एक विषम समता के साथ शुरू होता है,

278
00:17:21,890 --> 00:17:24,740
इसलिए आपको फिर से इसका समता बिट 1 पर सेट करना चाहिए।

279
00:17:24,740 --> 00:17:28,088
और अंतिम समूह में भी एक अजीब समानता है, जिसका अर्थ है

280
00:17:28,088 --> 00:17:31,500
कि हम उस बिट को स्थिति 8 में 1 के रूप में सेट करते हैं।

281
00:17:31,500 --> 00:17:36,428
और फिर अंतिम चरण के रूप में, पूर्ण ब्लॉक में अब एक सम समता है, जिसका

282
00:17:36,428 --> 00:17:41,500
अर्थ है कि आप उस बिट संख्या 0, व्यापक समता बिट को 0 पर सेट कर सकते हैं।

283
00:17:41,500 --> 00:17:45,015
इसलिए जैसे ही यह ब्लॉक भेजा जाता है, चार विशेष

284
00:17:45,015 --> 00:17:48,980
उपसमुच्चय और संपूर्ण ब्लॉक की समता सम हो जाएगी, या 0.

285
00:17:48,980 --> 00:17:53,620
अभ्यास के दूसरे भाग के रूप में, आइए आपसे प्राप्तकर्ता की भूमिका निभाएँ।

286
00:17:53,620 --> 00:17:56,938
बेशक, इसका मतलब यह होगा कि आप पहले से नहीं जानते कि यह संदेश क्या है, हो सकता है कि आप

287
00:17:56,938 --> 00:18:00,180
में से कुछ लोगों ने इसे याद कर लिया हो, लेकिन मान लीजिए कि आपने इसे याद नहीं किया है।

288
00:18:00,180 --> 00:18:04,228
मैं जो करने जा रहा हूं वह उस ब्लॉक में 0, 1, या 2 बिट्स को बदलना

289
00:18:04,228 --> 00:18:08,340
है, और फिर आपसे यह पता लगाने के लिए कहना है कि मैंने क्या किया है।

290
00:18:08,340 --> 00:18:13,460
तो फिर, रुकें और इस पर काम करने का प्रयास करें।

291
00:18:13,460 --> 00:18:21,475
ठीक है, तो अब आप रिसीवर के रूप में पहले समता समूह की जांच करें और आप देख

292
00:18:21,475 --> 00:18:29,820
सकते हैं कि यह सम है, इसलिए जो भी त्रुटि मौजूद है वह सम कॉलम में होनी चाहिए।

293
00:18:29,820 --> 00:18:34,189
अगला चेक हमें एक विषम संख्या देता है, जो हम दोनों को बताता है कि

294
00:18:34,189 --> 00:18:38,760
कम से कम एक त्रुटि है, और हमें इस विशिष्ट कॉलम में सीमित कर देता है।

295
00:18:38,760 --> 00:18:42,900
तीसरी जाँच सम है, संभावनाओं को और भी कम कर देती है।

296
00:18:42,900 --> 00:18:47,267
और अंतिम समता जांच अजीब है, जो हमें बताती है कि नीचे कहीं एक त्रुटि

297
00:18:47,267 --> 00:18:51,700
है, जिसे अब तक हम देख सकते हैं कि वह स्थिति संख्या 10 में होनी चाहिए।

298
00:18:51,700 --> 00:18:58,220
इसके अलावा, पूरे ब्लॉक की समता विषम है, जिससे हमें विश्वास हो गया कि एक फ्लिप था, दो नहीं।

299
00:18:58,220 --> 00:19:01,600
यदि यह तीन या अधिक है, तो सभी दांव बंद हो जाएंगे।

300
00:19:01,600 --> 00:19:06,334
उस बिट संख्या 10 को सही करने के बाद, सुधार के लिए उपयोग नहीं किए गए 11 बिट्स को

301
00:19:06,334 --> 00:19:11,247
बाहर निकालने से हमें मूल संदेश का प्रासंगिक खंड मिलता है, जिसे यदि आप रिवाइंड करते

302
00:19:11,247 --> 00:19:16,160
हैं और तुलना करते हैं तो वास्तव में वही होता है जिसके साथ हमने उदाहरण शुरू किया था।

303
00:19:16,160 --> 00:19:20,026
और अब जब आप जानते हैं कि यह सब हाथ से कैसे करना है, तो मैं आपको दिखाना चाहूंगा कि

304
00:19:20,026 --> 00:19:23,940
आप पायथन कोड की एक पंक्ति के साथ इस सभी तर्क के मुख्य भाग को कैसे पूरा कर सकते हैं।

305
00:19:23,940 --> 00:19:27,875
आप देखिए, जो मैंने आपको अभी तक नहीं बताया है वह यह है कि यह एल्गोरिदम वास्तव

306
00:19:27,875 --> 00:19:31,760
में कितना सुंदर है, किसी त्रुटि की स्थिति को इंगित करने के लिए मशीन प्राप्त

307
00:19:31,760 --> 00:19:35,491
करना कितना सरल है, इसे व्यवस्थित रूप से कैसे मापना है, और हम सभी को कैसे

308
00:19:35,491 --> 00:19:39,580
फ्रेम कर सकते हैं यह कई अलग-अलग समता जांचों के बजाय एक एकल ऑपरेशन के रूप में है।

309
00:19:39,580 --> 00:19:39,580
यह देखने के लिए कि मेरा क्या मतलब है, भाग 2 में मेरे साथ आएँ।

