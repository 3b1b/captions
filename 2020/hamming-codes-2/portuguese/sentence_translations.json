[
 {
  "input": "I'm assuming that everybody here is coming from part 1.",
  "model": "nmt",
  "translatedText": "Presumo que todos aqui venham da parte 1.",
  "time_range": [
   0.0,
   2.56
  ]
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it.",
  "model": "nmt",
  "translatedText": "Estávamos falando sobre códigos de Hamming, uma forma de criar um bloco de dados onde a maioria dos bits carrega uma mensagem significativa, enquanto alguns outros atuam como uma espécie de redundância, de tal forma que se algum bit for invertido, será uma mensagem bit ou bit de redundância, qualquer coisa neste bloco, um receptor será capaz de identificar que houve um erro e como corrigi-lo.",
  "time_range": [
   3.06,
   21.24
  ]
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error.",
  "model": "nmt",
  "translatedText": "A ideia básica apresentada foi como usar múltiplas verificações de paridade para pesquisar binariamente até o erro.",
  "time_range": [
   21.88,
   27.16
  ]
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible.",
  "model": "nmt",
  "translatedText": "Nesse vídeo, o objetivo era fazer com que os códigos de Hamming parecessem tão práticos e redescobríveis quanto possível.",
  "time_range": [
   28.980000000000008,
   34.6
  ]
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are.",
  "model": "nmt",
  "translatedText": "Mas quando você começa a pensar em realmente implementar isso, seja em software ou hardware, esse enquadramento pode, na verdade, subestimar o quão elegantes esses códigos realmente são.",
  "time_range": [
   35.18,
   43.46
  ]
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that.",
  "model": "nmt",
  "translatedText": "Você pode pensar que precisa escrever um algoritmo que monitore todos os possíveis locais de erro e corte esse grupo pela metade a cada verificação, mas na verdade é muito, muito mais simples do que isso.",
  "time_range": [
   43.92,
   53.48
  ]
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary.",
  "model": "nmt",
  "translatedText": "Se você ler as respostas às quatro verificações de paridade que fizemos no último vídeo, todas como 1s e 0s em vez de sim e não, isso literalmente explica a posição do erro em binário.",
  "time_range": [
   53.94,
   64.08
  ]
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1.",
  "model": "nmt",
  "translatedText": "Por exemplo, o número 7 em binário se parece com 0111, significando essencialmente que é 4 mais 2 mais 1.",
  "time_range": [
   64.78,
   71.26
  ]
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last.",
  "model": "nmt",
  "translatedText": "E observe onde fica a posição 7, ela afeta o primeiro de nossos grupos de paridade, e o segundo, e o terceiro, mas não o último.",
  "time_range": [
   72.54,
   81.74
  ]
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error.",
  "model": "nmt",
  "translatedText": "Portanto, ler os resultados dessas quatro verificações de baixo para cima realmente explica a posição do erro.",
  "time_range": [
   82.22,
   87.54
  ]
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple.",
  "model": "nmt",
  "translatedText": "Não há nada de especial no exemplo 7, ele funciona em geral e torna a lógica para implementar todo o esquema em hardware surpreendentemente simples.",
  "time_range": [
   88.32,
   95.82
  ]
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111.",
  "model": "nmt",
  "translatedText": "Agora se você quiser ver por que essa mágica acontece, pegue esses 16 rótulos de índice para nossas posições, mas em vez de escrevê-los na base 10, vamos escrevê-los todos em binário, indo de 0000 até 1111.",
  "time_range": [
   97.24,
   109.88
  ]
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent.",
  "model": "nmt",
  "translatedText": "Ao colocarmos esses rótulos binários de volta em suas caixas, deixe-me enfatizar que eles são distintos dos dados que estão sendo realmente enviados.",
  "time_range": [
   110.55999999999999,
   117.8
  ]
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from.",
  "model": "nmt",
  "translatedText": "Eles nada mais são do que um rótulo conceitual para ajudar você e eu a entender de onde vieram os quatro grupos de paridade.",
  "time_range": [
   118.32,
   123.5
  ]
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary.",
  "model": "nmt",
  "translatedText": "A elegância de ter tudo o que estamos vendo descrito em binário talvez seja prejudicada pela confusão de ter tudo o que estamos vendo descrito em binário.",
  "time_range": [
   124.14,
   132.36
  ]
 },
 {
  "input": "It's worth it, though.",
  "model": "nmt",
  "translatedText": "Vale a pena, no entanto.",
  "time_range": [
   133.02,
   134.12
  ]
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1.",
  "model": "nmt",
  "translatedText": "Concentre sua atenção apenas na última parte de todos esses rótulos e, em seguida, destaque as posições onde a parte final é 1.",
  "time_range": [
   134.8,
   143.22
  ]
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1?",
  "model": "nmt",
  "translatedText": "O que obtemos é o primeiro dos nossos quatro grupos de paridade, o que significa que você pode interpretar essa primeira verificação como uma pergunta: ei, se houver um erro, o bit final na posição desse erro é 1?",
  "time_range": [
   144.24,
   155.74
  ]
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme.",
  "model": "nmt",
  "translatedText": "Da mesma forma, se você focar no penúltimo bit e destacar todas as posições onde é 1, você obterá o segundo grupo de paridade do nosso esquema.",
  "time_range": [
   158.2,
   166.16
  ]
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1?",
  "model": "nmt",
  "translatedText": "Em outras palavras, essa segunda verificação está perguntando, ei, de novo, se houver um erro, o penúltimo bit dessa posição é 1?",
  "time_range": [
   166.74,
   174.5
  ]
 },
 {
  "input": "And so on.",
  "model": "nmt",
  "translatedText": "E assim por diante.",
  "time_range": [
   175.76,
   176.9
  ]
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1.",
  "model": "nmt",
  "translatedText": "A terceira verificação de paridade cobre todas as posições cujo penúltimo bit está ativado, e a última cobre as últimas oito posições, aquelas cujo bit de ordem mais alta é 1.",
  "time_range": [
   177.22,
   188.74
  ]
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary.",
  "model": "nmt",
  "translatedText": "Tudo o que fizemos anteriormente é o mesmo que responder a estas quatro perguntas, que por sua vez é o mesmo que soletrar uma posição em binário.",
  "time_range": [
   189.74,
   197.74
  ]
 },
 {
  "input": "I hope this makes two things clearer.",
  "model": "nmt",
  "translatedText": "Espero que isso deixe duas coisas mais claras.",
  "time_range": [
   199.62,
   201.48
  ]
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two.",
  "model": "nmt",
  "translatedText": "A primeira é como generalizar sistematicamente para tamanhos de bloco maiores que sejam potências de dois.",
  "time_range": [
   202.04,
   206.46
  ]
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check.",
  "model": "nmt",
  "translatedText": "Se forem necessários mais bits para descrever cada posição, como seis bits para descrever 64 pontos, então cada um desses bits fornece um dos grupos de paridade que precisamos verificar.",
  "time_range": [
   206.96,
   216.68
  ]
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar.",
  "model": "nmt",
  "translatedText": "Aqueles de vocês que assistiram ao quebra-cabeça do tabuleiro de xadrez que fiz com Matt Parker podem achar tudo isso extremamente familiar.",
  "time_range": [
   218.4,
   223.18
  ]
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard.",
  "model": "nmt",
  "translatedText": "É a mesma lógica central, mas resolvendo um problema diferente e aplicada a um tabuleiro de xadrez de 64 casas.",
  "time_range": [
   223.66,
   228.78
  ]
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8.",
  "model": "nmt",
  "translatedText": "A segunda coisa que espero que isso deixe claro é por que nossos bits de paridade estão em posições que são potências de dois, por exemplo, 1, 2, 4 e 8.",
  "time_range": [
   229.88,
   237.32
  ]
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on.",
  "model": "nmt",
  "translatedText": "Estas são as posições cuja representação binária tem apenas um bit ativado.",
  "time_range": [
   238.0,
   243.0
  ]
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups.",
  "model": "nmt",
  "translatedText": "O que isso significa é que cada um desses bits de paridade está dentro de um e apenas um dos quatro grupos de paridade.",
  "time_range": [
   243.6,
   249.46
  ]
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups.",
  "model": "nmt",
  "translatedText": "Você também pode ver isso em exemplos maiores, onde não importa quão grande você seja, cada bit de paridade toca convenientemente apenas um dos grupos.",
  "time_range": [
   252.04,
   259.34
  ]
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code.",
  "model": "nmt",
  "translatedText": "Depois de entender que essas verificações de paridade nas quais nos concentramos tanto em nosso tempo nada mais são do que uma maneira inteligente de explicar a posição de um erro em binário, então poderemos estabelecer uma conexão com uma maneira diferente de pensar sobre hamming códigos, que são sem dúvida muito mais simples e elegantes, e que basicamente podem ser escritos com uma única linha de código.",
  "time_range": [
   265.6,
   283.24
  ]
 },
 {
  "input": "It's based on the XOR function.",
  "model": "nmt",
  "translatedText": "É baseado na função XOR.",
  "time_range": [
   283.66,
   285.5
  ]
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or.",
  "model": "nmt",
  "translatedText": "XOR, para quem não sabe, significa exclusivo ou.",
  "time_range": [
   286.94,
   290.22
  ]
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off.",
  "model": "nmt",
  "translatedText": "Quando você pega o XOR de dois bits, ele retornará 1 se um desses bits estiver ativado, mas não se ambos estiverem ativados ou desativados.",
  "time_range": [
   290.78,
   299.36
  ]
 },
 {
  "input": "Phrased differently, it's the parity of these two bits.",
  "model": "nmt",
  "translatedText": "Em outras palavras, é a paridade desses dois bits.",
  "time_range": [
   300.1,
   302.98
  ]
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2.",
  "model": "nmt",
  "translatedText": "Como um especialista em matemática, prefiro pensar nisso como um mod de adição 2.",
  "time_range": [
   303.54,
   306.76
  ]
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component.",
  "model": "nmt",
  "translatedText": "Também costumamos falar sobre o XOR de duas cadeias de bits diferentes, que basicamente faz isso componente por componente.",
  "time_range": [
   307.36,
   313.44
  ]
 },
 {
  "input": "It's like addition, but where you never carry.",
  "model": "nmt",
  "translatedText": "É como uma adição, mas onde você nunca carrega.",
  "time_range": [
   313.68,
   315.72
  ]
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2.",
  "model": "nmt",
  "translatedText": "Novamente, os mais inclinados à matemática podem preferir pensar nisso como a adição de dois vetores e a redução do mod 2.",
  "time_range": [
   316.5,
   322.48
  ]
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood.",
  "model": "nmt",
  "translatedText": "Se você abrir algum Python agora e aplicar a operação de intercalação entre dois inteiros, isso é o que ele está fazendo, exceto nas representações de bits desses números nos bastidores.",
  "time_range": [
   323.5,
   332.94
  ]
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop.",
  "model": "nmt",
  "translatedText": "O ponto principal para você e para mim é que obter o XOR de muitas cadeias de bits diferentes é efetivamente uma maneira de calcular as paródias de vários grupos separados, como acontece com as colunas, tudo de uma só vez.",
  "time_range": [
   334.96000000000004,
   347.14
  ]
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation.",
  "model": "nmt",
  "translatedText": "Isso nos dá uma maneira bastante elegante de pensar sobre as múltiplas verificações de paridade de nosso algoritmo de código de Hamming como sendo todas agrupadas em uma única operação.",
  "time_range": [
   351.26,
   358.78
  ]
 },
 {
  "input": "Though at first glance it does look very different.",
  "model": "nmt",
  "translatedText": "Embora à primeira vista pareça muito diferente.",
  "time_range": [
   359.47999999999996,
   362.18
  ]
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR.",
  "model": "nmt",
  "translatedText": "Anote especificamente as 16 posições em binário, como fizemos antes, e agora destaque as posições onde o bit da mensagem está ativado para 1 e, em seguida, reúna essas posições em uma grande coluna e pegue o XOR.",
  "time_range": [
   362.82,
   377.1
  ]
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly.",
  "model": "nmt",
  "translatedText": "Você provavelmente pode adivinhar que os 4 bits na parte inferior como resultado são iguais às 4 verificações de paridade que conhecemos e amamos, mas reserve um momento para realmente pensar sobre o porquê exatamente.",
  "time_range": [
   379.26,
   389.2
  ]
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group.",
  "model": "nmt",
  "translatedText": "Esta última coluna, por exemplo, está contando todas as posições cujo último bit é 1, mas já estamos limitados apenas às posições destacadas, portanto está contando efetivamente quantas posições destacadas vieram do primeiro grupo de paridade.",
  "time_range": [
   392.22,
   405.76
  ]
 },
 {
  "input": "Does that make sense?",
  "model": "nmt",
  "translatedText": "Isso faz sentido?",
  "time_range": [
   406.24,
   406.8
  ]
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on.",
  "model": "nmt",
  "translatedText": "Da mesma forma, a próxima coluna conta quantas posições estão no segundo grupo de paridade, as posições cujo penúltimo bit é 1, e que também estão destacadas, e assim por diante.",
  "time_range": [
   409.08,
   420.0
  ]
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing.",
  "model": "nmt",
  "translatedText": "Na verdade, é apenas uma pequena mudança de perspectiva sobre a mesma coisa que temos feito.",
  "time_range": [
   420.26,
   423.96
  ]
 },
 {
  "input": "And so you know where it goes from here.",
  "model": "nmt",
  "translatedText": "E então você sabe para onde vai a partir daqui.",
  "time_range": [
   427.76,
   429.6
  ]
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000.",
  "model": "nmt",
  "translatedText": "O remetente é responsável por alternar alguns dos bits de paridade especiais para garantir que a soma seja 0000.",
  "time_range": [
   430.0,
   435.72
  ]
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error.",
  "model": "nmt",
  "translatedText": "Agora, uma vez que temos isto, isto dá-nos uma maneira muito boa de pensar sobre porque é que estes quatro bits resultantes na parte inferior indicam diretamente a posição de um erro.",
  "time_range": [
   435.72,
   447.58
  ]
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1.",
  "model": "nmt",
  "translatedText": "Digamos que algum bit neste bloco seja alternado de 0 para 1.",
  "time_range": [
   448.46,
   451.86
  ]
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error.",
  "model": "nmt",
  "translatedText": "O que isso significa é que a posição desse bit agora será incluída no XOR total, o que muda a soma de 0 para esse valor recém-incluído, a posição do erro.",
  "time_range": [
   452.6,
   463.82
  ]
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0.",
  "model": "nmt",
  "translatedText": "Um pouco menos óbvio, o mesmo acontece se houver um erro que mude 1 para 0.",
  "time_range": [
   464.46,
   469.36
  ]
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0.",
  "model": "nmt",
  "translatedText": "Veja bem, se você somar uma sequência de bits duas vezes, é o mesmo que não tê-la ali, basicamente porque neste mundo 1 mais 1 é igual a 0.",
  "time_range": [
   470.18,
   477.58
  ]
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it.",
  "model": "nmt",
  "translatedText": "Portanto, adicionar uma cópia desta posição à soma total tem o mesmo efeito que a movemos.",
  "time_range": [
   477.58,
   484.3
  ]
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error.",
  "model": "nmt",
  "translatedText": "E esse efeito, mais uma vez, é que o resultado total na parte inferior aqui indica a posição do erro.",
  "time_range": [
   485.16,
   490.7
  ]
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end.",
  "model": "nmt",
  "translatedText": "Para ilustrar o quão elegante isso é, deixe-me mostrar aquela linha de código Python que mencionei antes, que capturará quase toda a lógica no final do receptor.",
  "time_range": [
   493.03999999999996,
   501.44
  ]
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits.",
  "model": "nmt",
  "translatedText": "Começaremos criando um array aleatório de 16 1s e 0s para simular o bloco de dados, e darei a ele o nome de bits, mas é claro que na prática isso seria algo que receberíamos de um remetente e, em vez de sendo aleatório, carregaria 11 bits de dados junto com 5 bits de paridade.",
  "time_range": [
   502.08,
   517.0
  ]
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15.",
  "model": "nmt",
  "translatedText": "Se eu chamar a função enumerateBits, o que ela faz é emparelhar cada um desses bits com um índice correspondente, neste caso variando de 0 a 15.",
  "time_range": [
   517.0,
   527.0
  ]
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15.",
  "model": "nmt",
  "translatedText": "Então, se criarmos uma lista que percorre todos esses pares, pares que se parecem com i, e então extrairmos apenas o valor i, apenas o índice, bem, não é tão emocionante, apenas recuperamos esses índices de 0 a 15.",
  "time_range": [
   528.18,
   541.34
  ]
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on.",
  "model": "nmt",
  "translatedText": "Mas se adicionarmos a condição de fazer isso apenas se for bit, ou seja, se esse bit for 1 e não 0, bem, então ele retira apenas as posições onde o bit correspondente está ativado.",
  "time_range": [
   541.68,
   552.66
  ]
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc.",
  "model": "nmt",
  "translatedText": "Neste caso, parece que essas posições são 0, 4, 6, 9, etc.",
  "time_range": [
   553.38,
   560.36
  ]
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together.",
  "model": "nmt",
  "translatedText": "O que queremos é reunir todas essas posições, as posições dos bits que estão ativados, e então fazer um XOR entre elas.",
  "time_range": [
   560.72,
   567.24
  ]
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions.",
  "model": "nmt",
  "translatedText": "Para fazer isso em Python, primeiro vou importar algumas funções úteis.",
  "time_range": [
   569.18,
   573.22
  ]
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it.",
  "model": "nmt",
  "translatedText": "Dessa forma podemos chamar reduzir() nesta lista e usar a função XOR para reduzi-la.",
  "time_range": [
   573.9,
   578.7
  ]
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way.",
  "model": "nmt",
  "translatedText": "Isso basicamente percorre a lista, levando XORs ao longo do caminho.",
  "time_range": [
   579.1,
   582.68
  ]
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere.",
  "model": "nmt",
  "translatedText": "Se preferir, você pode escrever explicitamente essa função XOR sem precisar importá-la de qualquer lugar.",
  "time_range": [
   584.8,
   589.44
  ]
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001.",
  "model": "nmt",
  "translatedText": "Então, no momento, parece que se fizermos isso em nosso bloco aleatório de 16 bits, ele retornará 9, que tem a representação binária 1001.",
  "time_range": [
   591.94,
   601.28
  ]
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0.",
  "model": "nmt",
  "translatedText": "Não faremos isso aqui, mas você poderia escrever uma função onde o remetente usa essa representação binária para definir os quatro bits de paridade conforme necessário, levando esse bloco a um estado em que a execução dessa linha de código na lista completa de bits retorna um 0.",
  "time_range": [
   601.98,
   615.46
  ]
 },
 {
  "input": "This would be considered a well-prepared block.",
  "model": "nmt",
  "translatedText": "Este seria considerado um bloco bem preparado.",
  "time_range": [
   616.08,
   620.1
  ]
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error.",
  "model": "nmt",
  "translatedText": "O que é legal é que se alternarmos qualquer um dos bits desta lista, simulando um erro aleatório de ruído, se você executar essa mesma linha de código, esse erro será impresso.",
  "time_range": [
   620.1,
   630.22
  ]
 },
 {
  "input": "Isn't that neat?",
  "model": "nmt",
  "translatedText": "Não é legal?",
  "time_range": [
   630.96,
   631.52
  ]
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any.",
  "model": "nmt",
  "translatedText": "Você pode obter esse bloco do nada, executar esta única linha nele e ele exibirá automaticamente a posição de um erro ou um 0, se não houver nenhum.",
  "time_range": [
   631.82,
   641.06
  ]
 },
 {
  "input": "And there's nothing special about the size 16 here.",
  "model": "nmt",
  "translatedText": "E não há nada de especial no tamanho 16 aqui.",
  "time_range": [
   642.5,
   644.84
  ]
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits.",
  "model": "nmt",
  "translatedText": "A mesma linha de código funcionaria se você tivesse uma lista de, digamos, 256 bits.",
  "time_range": [
   644.84,
   649.86
  ]
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction.",
  "model": "nmt",
  "translatedText": "Escusado será dizer que há mais código para escrever aqui, como fazer a verificação de metaparidade para detectar erros de 2 bits, mas a ideia é que quase toda a lógica central do nosso esquema se reduza a uma única redução de XOR.",
  "time_range": [
   651.88,
   663.76
  ]
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go.",
  "model": "nmt",
  "translatedText": "Agora, dependendo do seu conforto com binários, XORs e software em geral, você pode achar essa perspectiva um pouco confusa ou muito mais elegante e simples que você está se perguntando por que não começamos com ela desde o início. -ir.",
  "time_range": [
   666.12,
   678.42
  ]
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level.",
  "model": "nmt",
  "translatedText": "Falando livremente, a perspectiva de verificação de paridade múltipla é mais fácil de pensar ao implementar códigos de Hamming em hardware de maneira muito direta, e a perspectiva XOR é mais fácil de pensar ao fazê-lo em software, de um nível mais alto.",
  "time_range": [
   679.14,
   690.5
  ]
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles.",
  "model": "nmt",
  "translatedText": "O primeiro é mais fácil de fazer manualmente, e acho que faz um trabalho melhor ao incutir a intuição central subjacente a tudo isso, que é que a informação necessária para localizar um único erro está relacionada ao log do tamanho do bloco , ou em outras palavras, cresce um bit de cada vez à medida que o tamanho do bloco dobra.",
  "time_range": [
   691.36,
   710.0
  ]
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need.",
  "model": "nmt",
  "translatedText": "O fato relevante aqui é que essa informação corresponde diretamente à quantidade de redundância necessária.",
  "time_range": [
   711.02,
   716.06
  ]
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind.",
  "model": "nmt",
  "translatedText": "Isso é realmente o que vai contra a reação instintiva da maioria das pessoas quando pensam pela primeira vez em tornar uma mensagem resistente a erros, onde geralmente copiar a mensagem inteira é o primeiro instinto que vem à mente.",
  "time_range": [
   716.66,
   726.54
  ]
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix.",
  "model": "nmt",
  "translatedText": "E então, a propósito, há toda essa outra maneira que às vezes você vê os códigos de Hamming apresentados, onde você multiplica a mensagem por uma grande matriz.",
  "time_range": [
   727.5,
   734.0
  ]
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales.",
  "model": "nmt",
  "translatedText": "É bom porque o relaciona com a família mais ampla de códigos lineares, mas acho que isso quase não dá nenhuma intuição de onde ele vem ou como é dimensionado.",
  "time_range": [
   734.67,
   743.06
  ]
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size.",
  "model": "nmt",
  "translatedText": "E por falar em dimensionamento, você deve notar que a eficiência desse esquema só melhora à medida que aumentamos o tamanho do bloco.",
  "time_range": [
   745.2,
   751.16
  ]
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there.",
  "model": "nmt",
  "translatedText": "Por exemplo, vimos que com 256 bits, você está usando apenas 3% desse espaço para redundância, e isso continua melhorando a partir daí.",
  "time_range": [
   755.0,
   762.66
  ]
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling.",
  "model": "nmt",
  "translatedText": "À medida que o número de bits de paridade aumenta um por um, o tamanho do bloco continua duplicando.",
  "time_range": [
   763.3,
   767.34
  ]
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits.",
  "model": "nmt",
  "translatedText": "E se você levar isso ao extremo, você poderia ter um bloco com, digamos, um milhão de bits, onde você estaria literalmente jogando 20 perguntas com suas verificações de paridade, e ele usaria apenas 21 bits de paridade.",
  "time_range": [
   769.0,
   780.02
  ]
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy.",
  "model": "nmt",
  "translatedText": "E se você pensar em olhar para um milhão de bits e localizar um único erro, isso realmente parece uma loucura.",
  "time_range": [
   780.74,
   787.06
  ]
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that.",
  "model": "nmt",
  "translatedText": "O problema, claro, é que com um bloco maior, a probabilidade de ver mais de um ou dois erros de bit aumenta, e os códigos de Hamming não lidam com nada além disso.",
  "time_range": [
   788.1999999999999,
   797.66
  ]
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high.",
  "model": "nmt",
  "translatedText": "Então, na prática, o que você deseja é encontrar o tamanho certo para que a probabilidade de muitas inversões de bits não seja muito alta.",
  "time_range": [
   798.32,
   804.3
  ]
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored.",
  "model": "nmt",
  "translatedText": "Além disso, na prática, os erros tendem a ocorrer em pequenas rajadas, o que arruinaria totalmente um único bloco, portanto, uma tática comum para ajudar a espalhar uma rajada de erros por muitos blocos diferentes é entrelaçar esses blocos, assim, antes que eles sejam enviado ou armazenado.",
  "time_range": [
   806.6,
   820.98
  ]
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block.",
  "model": "nmt",
  "translatedText": "Por outro lado, muito disso é completamente discutível por códigos mais modernos, como o algoritmo Reed-Solomon, muito mais comumente usado, que lida particularmente bem com erros de explosão e pode ser ajustado para ser resiliente a um número maior de erros por bloco.",
  "time_range": [
   825.58,
   838.82
  ]
 },
 {
  "input": "But that's a topic for another time.",
  "model": "nmt",
  "translatedText": "Mas isso é assunto para outra hora.",
  "time_range": [
   839.36,
   841.34
  ]
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was.",
  "model": "nmt",
  "translatedText": "Em seu livro The Art of Doing Science and Engineering, Hamming é maravilhosamente sincero sobre o quão sinuosa foi sua descoberta desse código.",
  "time_range": [
   842.5,
   849.94
  ]
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this.",
  "model": "nmt",
  "translatedText": "Ele primeiro tentou todos os tipos de esquemas diferentes envolvendo a organização dos bits em partes de uma rede dimensional superior e coisas estranhas como esta.",
  "time_range": [
   850.62,
   857.78
  ]
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this?",
  "model": "nmt",
  "translatedText": "A ideia de que seria possível fazer com que as verificações de paridade conspirassem de uma forma que explicitasse a posição de um erro só surgiu a Hamming quando ele recuou após um monte de outras análises e perguntou: ok, qual é o mais eficiente que eu poderia concebivelmente ser sobre isso?",
  "time_range": [
   858.3,
   871.52
  ]
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today.",
  "model": "nmt",
  "translatedText": "Ele também foi sincero sobre a importância de já ter em mente as verificações de paridade, o que teria sido muito menos comum na década de 1940 do que é hoje.",
  "time_range": [
   872.62,
   881.22
  ]
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind.",
  "model": "nmt",
  "translatedText": "Há cerca de meia dúzia de vezes ao longo deste livro que ele faz referência à citação de Louis Pasteur: a sorte favorece uma mente preparada.",
  "time_range": [
   881.92,
   888.22
  ]
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate.",
  "model": "nmt",
  "translatedText": "Ideias inteligentes muitas vezes parecem enganosamente simples em retrospectiva, o que as torna fáceis de subestimar.",
  "time_range": [
   889.32,
   894.3
  ]
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you.",
  "model": "nmt",
  "translatedText": "No momento, minha sincera esperança é que os códigos de Hamming, ou pelo menos a possibilidade de tais códigos, pareçam quase óbvios para você.",
  "time_range": [
   894.96,
   901.3
  ]
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't.",
  "model": "nmt",
  "translatedText": "Mas você não deve se enganar pensando que eles são realmente óbvios, porque definitivamente não são.",
  "time_range": [
   901.66,
   906.82
  ]
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that.",
  "model": "nmt",
  "translatedText": "Parte da razão pela qual ideias inteligentes parecem enganosamente fáceis é que só vemos o resultado final, limpando o que estava bagunçado, nunca mencionando todos os caminhos errados, subestimando o quão vasto é o espaço de possibilidades exploráveis no início de um problema. processo de resolução, tudo isso.",
  "time_range": [
   907.88,
   922.86
  ]
 },
 {
  "input": "But this is true in general.",
  "model": "nmt",
  "translatedText": "Mas isso é verdade em geral.",
  "time_range": [
   923.82,
   924.9
  ]
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them.",
  "model": "nmt",
  "translatedText": "Acho que, para algumas invenções especiais, há uma segunda razão mais profunda para as subestimarmos.",
  "time_range": [
   924.9,
   930.04
  ]
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory.",
  "model": "nmt",
  "translatedText": "Pensar na informação em termos de bits só se consolidou numa teoria completa em 1948, com o artigo seminal de Claude Shannon sobre a teoria da informação.",
  "time_range": [
   930.84,
   938.64
  ]
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm.",
  "model": "nmt",
  "translatedText": "Isso ocorreu essencialmente ao mesmo tempo em que Hamming desenvolveu seu algoritmo.",
  "time_range": [
   939.28,
   942.54
  ]
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory.",
  "model": "nmt",
  "translatedText": "Este foi o mesmo artigo fundamental que mostrou, em certo sentido, que a correção eficiente de erros é sempre possível, não importa quão alta seja a probabilidade de inversões de bits, pelo menos em teoria.",
  "time_range": [
   943.3,
   952.9
  ]
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here.",
  "model": "nmt",
  "translatedText": "Shannon e Hamming, aliás, dividiam um escritório no Bell Labs, apesar de trabalharem em coisas muito diferentes, o que dificilmente parece coincidência aqui.",
  "time_range": [
   953.7,
   961.16
  ]
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was.",
  "model": "nmt",
  "translatedText": "Avançando várias décadas, hoje em dia muitos de nós estamos tão imersos em pensar sobre bits e informações que é fácil ignorar o quão distinta era essa forma de pensar.",
  "time_range": [
   962.38,
   972.34
  ]
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are.",
  "model": "nmt",
  "translatedText": "Ironicamente, as ideias que moldam mais profundamente a forma como uma geração futura pensa acabarão por parecer para essa geração futura mais simples do que realmente são.",
  "time_range": [
   973.1,
   982.26
  ]
 }
]