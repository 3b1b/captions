1
00:00:00,000 --> 00:00:08,620
सीडी किंवा डीव्हीडी स्क्रॅच करणे कसे शक्य आहे आणि तरीही ते जे काही साठवले आहे

2
00:00:08,620 --> 00:00:10,900
ते पुन्हा प्ले करणे कसे शक्य आहे याचा तुम्ही कधी विचार केला आहे का?

3
00:00:10,900 --> 00:00:15,280
स्क्रॅचचा खरोखरच डिस्कवरील 1s आणि 0s वर परिणाम होतो, त्यामुळे तो संग्रहित

4
00:00:15,280 --> 00:00:20,500
केलेल्या डेटापासून भिन्न डेटा वाचतो, परंतु जोपर्यंत तो खरोखर स्क्रॅच केला जात

5
00:00:20,500 --> 00:00:26,540
नाही तोपर्यंत, ते वाचलेले बिट्स अगदी त्याच फाईलमध्ये डीकोड केले जातात जी

6
00:00:26,540 --> 00:00:28,400
त्यावर एन्कोड केली होती, a त्या सर्व त्रुटी असूनही बिट कॉपीसाठी बिट.

7
00:00:28,400 --> 00:00:32,800
गणितीय हुशारीचा एक संपूर्ण ढिगारा आहे जो आपल्याला डेटा संग्रहित करण्यास परवानगी

8
00:00:32,800 --> 00:00:36,840
देतो आणि त्याचप्रमाणे महत्त्वाचे म्हणजे डेटा प्रसारित करण्यासाठी, त्रुटींना लवचिक असलेल्या मार्गाने.

9
00:00:36,840 --> 00:00:41,480
बरं, ठीक आहे, खरं तर हे करण्याचा

10
00:00:41,480 --> 00:00:42,480
मार्ग शोधण्यासाठी इतकी हुशारी लागत नाही.

11
00:00:42,480 --> 00:00:47,660
कोणतीही फाईल, मग ती व्हिडिओ असो वा ध्वनी किंवा मजकूर, काही कोड,

12
00:00:47,660 --> 00:00:50,960
प्रतिमा, काहीही असो, शेवटी 1 आणि 0 चे काही क्रम असतात.

13
00:00:50,960 --> 00:00:55,340
आणि कोणताही बिट जो पलटला जातो तो दुरुस्त करण्यासाठी

14
00:00:55,340 --> 00:00:57,780
एक साधी रणनीती म्हणजे प्रत्येक बिटच्या तीन प्रती साठवणे.

15
00:00:57,780 --> 00:01:02,240
मग ही फाइल वाचणारे मशीन या तीन प्रतींची तुलना करू शकते आणि

16
00:01:02,240 --> 00:01:07,440
जेव्हाही विसंगती असेल तेव्हा नेहमी 3 पैकी सर्वोत्तम 2 घेऊ शकते.

17
00:01:07,440 --> 00:01:11,560
पण त्याचा अर्थ असा आहे की तुमच्या दोन तृतीयांश जागा रिडंडंसीसाठी वापरणे.

18
00:01:11,560 --> 00:01:15,360
आणि तरीही, त्या सर्व जागेसाठी, एकापेक्षा जास्त बिट फ्लिप

19
00:01:15,360 --> 00:01:18,120
झाल्यास काय होईल याची कोणतीही ठोस हमी नाही.

20
00:01:18,120 --> 00:01:21,960
अधिक मनोरंजक प्रश्न म्हणजे ते कसे बनवायचे जेणेकरुन शक्य

21
00:01:21,960 --> 00:01:24,740
तितक्या कमी जागा सोडताना त्रुटी सुधारल्या जाऊ शकतात.

22
00:01:24,740 --> 00:01:28,500
उदाहरणार्थ, तुम्ही या व्हिडिओबद्दल शिकणार असलेल्या पद्धतीचा वापर करून, तुम्ही तुमचा डेटा २५६-बिट ब्लॉक्समध्ये संचयित

23
00:01:28,500 --> 00:01:35,840
करू शकता, जिथे प्रत्येक ब्लॉक ९ बिट, ९! एक प्रकारचा रिडंडंसी म्हणून काम करण्यासाठी,

24
00:01:35,840 --> 00:01:41,000
आणि इतर 247 बिट तुम्हाला हवा तो अर्थपूर्ण संदेश किंवा डेटा घेऊन जाण्यासाठी मोकळे आहेत.

25
00:01:41,000 --> 00:01:44,740
आणि तरीही असेच असेल की इथे जर काही गडबड झाली तर, फक्त हा

26
00:01:44,740 --> 00:01:49,640
ब्लॉक बघून आणि आणखी काही नाही, तर मशीन ओळखू शकेल की त्रुटी होती

27
00:01:49,640 --> 00:01:53,120
आणि ती नेमकी कुठे होती, जेणेकरून ती कशी दुरुस्त करायची ते कळेल. .

28
00:01:53,140 --> 00:01:55,540
आणि प्रामाणिकपणे, ते जादूसारखे वाटते.

29
00:01:55,540 --> 00:01:59,400
आणि या विशिष्ट योजनेसाठी, जर दोन बिट्स फ्लिप झाले तर, मशीन कमीतकमी दोन त्रुटी

30
00:01:59,400 --> 00:02:03,180
असल्याचे शोधण्यास सक्षम असेल, परंतु त्या कशा दुरुस्त करायच्या हे माहित नसले तरी.

31
00:02:03,180 --> 00:02:08,140
वेगवेगळ्या आकारांच्या ब्लॉक्ससाठी हे कसे मोजले जाते याबद्दल आम्ही थोड्या वेळाने बोलू.

32
00:02:08,140 --> 00:02:12,620
तुम्हाला यासारख्या चुका दुरुस्त करू देणार्‍या पद्धती

33
00:02:12,620 --> 00:02:13,880
एरर सुधारणा कोड म्हणून ओळखल्या जातात.

34
00:02:13,880 --> 00:02:18,220
गेल्या शतकाच्या चांगल्या भागासाठी, हे क्षेत्र आश्चर्यकारकपणे सखोल गणिताचे खरोखर समृद्ध

35
00:02:18,220 --> 00:02:23,000
स्त्रोत आहे जे आम्ही दररोज वापरत असलेल्या उपकरणांमध्ये समाविष्ट केले जाते.

36
00:02:23,000 --> 00:02:27,740
हॅमिंग कोड म्हणून ओळखल्या जाणार्‍या सर्वात जुन्या उदाहरणांपैकी एकाची

37
00:02:27,740 --> 00:02:29,660
अगदी सखोल माहिती देणे हे येथे ध्येय आहे.

38
00:02:29,660 --> 00:02:32,620
आणि तसे, या व्हिडिओच्या संरचनेबद्दल मी ज्या प्रकारे विचार करत आहे

39
00:02:32,620 --> 00:02:37,060
ते शक्य तितके थेट स्पष्ट करणे कमी आहे आणि इकडे-तिकडे थोडे

40
00:02:37,060 --> 00:02:40,220
सौम्य मार्गदर्शनासह, तुम्हाला स्वतःसाठी ते शोधण्यास प्रवृत्त करणे अधिक आहे.

41
00:02:40,220 --> 00:02:44,100
म्हणून जेव्हा तुम्हाला वाटत असेल की ते कुठे जात आहे ते एखाद्या वेळी, तो

42
00:02:44,100 --> 00:02:47,180
क्षण थांबण्यासाठी घ्या, मी तुम्हाला सांगण्यापूर्वी ही योजना काय असेल याचा सक्रियपणे अंदाज लावा.

43
00:02:47,180 --> 00:02:51,500
तसेच, जर तुम्हाला तुमची समज हार्डवेअरच्या पातळीवर उतरवायची असेल, तर बेन

44
00:02:51,500 --> 00:02:55,160
ईटरने ब्रेडबोर्डवर हॅमिंग कोड प्रत्यक्षात कसे अंमलात आणायचे हे दाखवत

45
00:02:55,160 --> 00:02:59,520
याच्या संयोगाने एक व्हिडिओ बनवला आहे, जो अत्यंत समाधानकारक आहे.

46
00:02:59,520 --> 00:03:03,120
तुम्हाला हे माहित असले पाहिजे, हॅमिंग कोड हे रीड-सोलोमन अल्गोरिदम सारख्या आधुनिक कोड्सइतके मोठ्या

47
00:03:03,120 --> 00:03:08,040
प्रमाणावर वापरले जात नाहीत, परंतु हे कार्य सुरुवातीला किती अशक्य वाटते आणि एकदा

48
00:03:08,040 --> 00:03:14,240
ते किती वाजवी वाटते यामधील फरकाची एक विशिष्ट जादू आहे. तुम्ही हॅमिंगबद्दल शिका.

49
00:03:14,240 --> 00:03:19,080
त्रुटी सुधारण्याचे मूलभूत तत्त्व असे आहे की सर्व संभाव्य संदेशांच्या

50
00:03:19,300 --> 00:03:22,860
विशाल जागेत, फक्त काही उपसंच वैध संदेश मानले जातील.

51
00:03:22,860 --> 00:03:29,100
एक साधर्म्य म्हणून, अचूक स्पेलिंग शब्द वि चुकीचे स्पेलिंग शब्द बद्दल विचार करा.

52
00:03:29,100 --> 00:03:33,340
जेव्हा जेव्हा एखादा वैध संदेश बदलला जातो, तेव्हा प्राप्तकर्ता जवळच्या वैध शेजाऱ्याला

53
00:03:33,340 --> 00:03:38,380
जे दिसले ते दुरुस्त करण्यासाठी जबाबदार असतो, जसे तुम्ही टायपिंगमध्ये करू शकता.

54
00:03:38,380 --> 00:03:43,100
अशा संदेशांचे कार्यक्षमतेने वर्गीकरण करण्यासाठी ठोस अल्गोरिदम

55
00:03:43,100 --> 00:03:47,160
आणणे, तथापि, एक विशिष्ट हुशारी आवश्यक आहे.

56
00:03:47,160 --> 00:03:52,060
कथा 1940 च्या दशकात सुरू होते, जेव्हा एक तरुण रिचर्ड हॅमिंग बेल

57
00:03:52,060 --> 00:03:55,900
लॅबसाठी काम करत होता, आणि त्याच्या काही कामांमध्ये एक खूप मोठा महाग

58
00:03:55,900 --> 00:03:57,420
पंच कार्ड संगणक वापरत होता ज्यामध्ये त्याला फक्त मर्यादित प्रवेश होता.

59
00:03:57,420 --> 00:04:01,200
आणि त्याद्वारे तो मांडत राहिलेले कार्यक्रम अयशस्वी होत

60
00:04:01,200 --> 00:04:03,140
गेले, कारण वेळोवेळी थोडेफार चुकीचे वाचले जात होते.

61
00:04:03,140 --> 00:04:07,140
नैराश्य हे शोधाचे टोक असल्याने तो इतका कंटाळला की

62
00:04:07,140 --> 00:04:09,280
त्याने जगातील पहिला त्रुटी सुधारणेचा कोड शोधून काढला.

63
00:04:09,280 --> 00:04:13,020
हॅमिंग कोड्स फ्रेम करण्याचे बरेच वेगवेगळे मार्ग आहेत, परंतु प्रथम पास म्हणून

64
00:04:13,020 --> 00:04:16,620
आम्ही त्यामधून जाणार आहोत ज्या प्रकारे हॅमिंगने स्वतः त्यांच्याबद्दल विचार केला.

65
00:04:16,620 --> 00:04:21,400
16 बिट्सच्या ब्लॉकचे एक उदाहरण वापरुया जे सोपे आहे, परंतु खूप सोपे नाही.

66
00:04:21,400 --> 00:04:25,700
आम्ही या बिट्सच्या स्थानांची संख्या 0 ते 15 पर्यंत करू.

67
00:04:25,700 --> 00:04:30,520
आम्‍हाला जो खरा डेटा संग्रहित करायचा आहे तो यापैकी फक्त 12 बिट्स

68
00:04:30,520 --> 00:04:33,920
बनवणार आहे, तर 4 पोझिशन्स एक प्रकारची रिडंडंसी म्हणून राखीव आहेत.

69
00:04:33,920 --> 00:04:38,120
येथे रिडंडंट शब्दाचा अर्थ फक्त कॉपी असा नाही, शेवटी, ते 4

70
00:04:38,120 --> 00:04:40,200
बिट्स आम्हाला डेटाची आंधळेपणाने कॉपी करण्यासाठी पुरेशी जागा देत नाहीत.

71
00:04:40,200 --> 00:04:44,880
त्याऐवजी, त्यांना अधिक सूक्ष्म आणि हुशार प्रकारची अनावश्यकता असणे आवश्यक

72
00:04:44,880 --> 00:04:48,740
आहे, कोणतीही नवीन माहिती न जोडता, परंतु लवचिकता जोडणे.

73
00:04:48,740 --> 00:04:52,620
तुम्हाला कदाचित हे 4 स्पेशल बिट्स नीटपणे एकत्रितपणे पॅक केले जातील अशी अपेक्षा

74
00:04:52,620 --> 00:04:56,400
असेल, कदाचित शेवटी किंवा असे काहीतरी, परंतु जसे तुम्ही पहाल, त्यांना 2

75
00:04:56,400 --> 00:05:00,320
च्या पॉवर्स असलेल्या पोझिशन्सवर बसवल्याने शेवटपर्यंत खरोखर मोहक असे काहीतरी मिळू शकते.

76
00:05:00,320 --> 00:05:05,420
हे तुम्हाला मोठ्या ब्लॉक्ससाठी कसे मोजते याबद्दल थोडीशी सूचना देखील देऊ शकते.

77
00:05:05,420 --> 00:05:09,220
तसेच तांत्रिकदृष्ट्या ते फक्त 11 बिट डेटाचे आहे, तुम्हाला 0 च्या स्थानावर काय

78
00:05:09,220 --> 00:05:14,260
चालले आहे यासाठी एक सौम्य सूक्ष्मता आढळेल, परंतु आत्ता त्याबद्दल काळजी करू नका.

79
00:05:14,280 --> 00:05:18,640
कोणत्याही त्रुटी सुधारण्याच्या अल्गोरिदमप्रमाणे, यात दोन खेळाडूंचा समावेश असेल, एक प्रेषक

80
00:05:18,640 --> 00:05:23,200
जो या 4 विशेष बिट सेट करण्यासाठी जबाबदार आहे आणि एक

81
00:05:23,200 --> 00:05:26,360
प्राप्तकर्ता जो काही प्रकारची तपासणी करण्यासाठी आणि त्रुटी सुधारण्यासाठी जबाबदार आहे.

82
00:05:26,360 --> 00:05:30,040
अर्थात, प्रेषक आणि प्राप्तकर्ता हे शब्द खरोखरच सर्व तपासण्या करत

83
00:05:30,040 --> 00:05:34,040
असलेल्या मशीन्स किंवा सॉफ्टवेअरचा संदर्भ घेतात आणि मेसेजची कल्पना

84
00:05:34,040 --> 00:05:35,480
म्हणजे स्टोरेजसारख्या गोष्टींचा समावेश करण्यासाठी खरोखरच व्यापक अर्थ आहे.

85
00:05:35,480 --> 00:05:39,320
शेवटी, डेटा संग्रहित करणे हे एका ठिकाणाहून

86
00:05:39,320 --> 00:05:42,640
दुसर्‍या ठिकाणाऐवजी भूतकाळापासून भविष्यात संदेश पाठविण्यासारखेच आहे.

87
00:05:42,640 --> 00:05:46,700
तर हा सेटअप आहे, परंतु आपण आत जाण्यापूर्वी आपल्याला हॅमिंगच्या शोधाच्या

88
00:05:46,700 --> 00:05:51,080
वेळी त्याच्या मनावर ताज्या असलेल्या एका संबंधित कल्पनेबद्दल बोलणे आवश्यक

89
00:05:51,080 --> 00:05:55,520
आहे, एक पद्धत जी आपल्याला कोणत्याही एकल त्रुटी शोधू देते, परंतु

90
00:05:55,520 --> 00:05:57,300
त्या सुधारू शकत नाही, ज्ञात आहे. समता तपासणी म्हणून व्यवसायात.

91
00:05:57,300 --> 00:06:01,300
समता तपासणीसाठी, आम्ही फक्त एकच बिट वेगळे करतो जो पाठवणारा

92
00:06:01,300 --> 00:06:04,940
ट्युनिंगसाठी जबाबदार असतो आणि बाकीचे संदेश पाठवण्यास मोकळे असतात.

93
00:06:04,940 --> 00:06:10,380
या स्पेशल बिटचे एकमेव काम म्हणजे मेसेजमधील एकूण

94
00:06:10,380 --> 00:06:12,100
1s ही सम संख्या असल्याची खात्री करणे.

95
00:06:12,100 --> 00:06:16,920
उदाहरणार्थ, आत्ता, 1s ची एकूण संख्या 7 आहे, ती विषम आहे, म्हणून प्रेषकाला

96
00:06:16,920 --> 00:06:20,960
1 असण्यासाठी तो विशेष बिट फ्लिप करणे आवश्यक आहे, गणना समान करते.

97
00:06:20,960 --> 00:06:25,320
परंतु जर ब्लॉक आधीच 1s च्या सम संख्येने सुरू झाला

98
00:06:25,320 --> 00:06:27,480
असता, तर हा विशेष बिट 0 वर ठेवला गेला असता.

99
00:06:27,480 --> 00:06:31,640
हे खूपच सोपे आहे, भ्रामकपणे सोपे आहे, परंतु संदेशामध्ये कुठेही बदल करण्याची

100
00:06:31,640 --> 00:06:37,760
कल्पना एका छोट्या माहितीमध्ये प्रतिबिंबित करण्याचा हा एक आश्चर्यकारकपणे मोहक मार्ग आहे.

101
00:06:37,760 --> 00:06:43,680
लक्षात घ्या की या संदेशाचा कोणताही भाग 0 ते 1 किंवा 1 ते

102
00:06:43,680 --> 00:06:48,140
0 पर्यंत फ्लिप झाल्यास, तो 1s ची एकूण संख्या सम असण्यापासून विषममध्ये बदलतो.

103
00:06:48,140 --> 00:06:52,000
म्हणून जर तुम्ही प्राप्तकर्ता असाल, तर तुम्ही हा संदेश पाहाल, आणि तुम्हाला

104
00:06:52,000 --> 00:06:56,580
1s ची विषम संख्या दिसली, तुम्ही निश्चितपणे समजू शकता की काही त्रुटी

105
00:06:56,580 --> 00:06:58,700
आली आहे, जरी तुम्हाला कदाचित तो कुठे होता याची कल्पना नसेल.

106
00:06:58,700 --> 00:07:02,820
शब्दशैलीमध्ये, बिट्सच्या गटामध्ये 1s ची सम किंवा विषम संख्या

107
00:07:02,820 --> 00:07:04,940
आहे की नाही हे त्याची समता म्हणून ओळखले जाते.

108
00:07:04,940 --> 00:07:09,140
तुम्ही संख्या देखील वापरू शकता आणि समता 0 किंवा 1 आहे असे म्हणू शकता,

109
00:07:09,140 --> 00:07:11,320
जे एकदा तुम्ही कल्पनेसह गणित करणे सुरू केले की सामान्यत: अधिक उपयुक्त ठरते.

110
00:07:11,320 --> 00:07:15,200
आणि प्रेषक समता नियंत्रित करण्यासाठी वापरतो

111
00:07:15,200 --> 00:07:18,020
या विशेष बिटला पॅरिटी बिट म्हणतात.

112
00:07:18,020 --> 00:07:22,460
आणि प्रत्यक्षात, आपण हे स्पष्ट केले पाहिजे, जर प्राप्तकर्त्याला विषम समता दिसली, तर याचा

113
00:07:22,460 --> 00:07:26,920
अर्थ फक्त एकच त्रुटी होती असे नाही, 3 त्रुटी, किंवा 5, किंवा इतर कोणतीही

114
00:07:26,920 --> 00:07:29,560
विषम संख्या असू शकते, परंतु ते निश्चितपणे जाणून घेऊ शकतात. की ते 0 नव्हते.

115
00:07:29,560 --> 00:07:34,880
दुसरीकडे, जर 2 चुका झाल्या असत्या, किंवा एररच्या संख्येची संख्या असती, तर 1s

116
00:07:34,880 --> 00:07:39,560
ची अंतिम गणना अजूनही सम असेल, त्यामुळे प्राप्तकर्त्याला पूर्ण विश्वास असू शकत

117
00:07:39,560 --> 00:07:43,360
नाही की सम गणनेचा अर्थ असा आहे की संदेश त्रुटी-मुक्त आहे. .

118
00:07:43,360 --> 00:07:47,860
तुम्ही तक्रार करू शकता की फक्त 2 बिट फ्लिप्सने गोंधळलेला

119
00:07:47,860 --> 00:07:49,760
संदेश खूपच कमकुवत आहे आणि तुम्ही अगदी बरोबर असाल.

120
00:07:49,760 --> 00:07:54,480
लक्षात ठेवा, तथापि, त्रुटी शोधण्यासाठी किंवा दुरुस्त करण्याची कोणतीही पद्धत नाही जी तुम्हाला

121
00:07:54,480 --> 00:07:59,720
100% आत्मविश्वास देऊ शकेल की तुम्हाला प्राप्त झालेला संदेश पाठवणाऱ्याचा हेतू आहे.

122
00:07:59,720 --> 00:08:03,760
शेवटी, पुरेसा यादृच्छिक आवाज नेहमीच एक वैध संदेश

123
00:08:03,760 --> 00:08:05,920
दुसर्‍या वैध संदेशात बदलू शकतो केवळ संधीने.

124
00:08:05,920 --> 00:08:10,520
त्याऐवजी, विशिष्ट जास्तीत जास्त त्रुटींपर्यंत मजबुत असलेली योजना आणणे किंवा

125
00:08:10,520 --> 00:08:16,480
यासारख्या चुकीच्या सकारात्मकतेची संभाव्यता कमी करणे हे उद्दिष्ट आहे.

126
00:08:16,480 --> 00:08:20,940
पॅरिटी चेक त्यांच्या स्वतःहून खूपच कमकुवत आहेत, परंतु संपूर्ण

127
00:08:20,940 --> 00:08:25,640
संदेशामध्ये बदलाची कल्पना एका क्षणापर्यंत पसरवून, ते आम्हाला

128
00:08:25,640 --> 00:08:28,000
अधिक अत्याधुनिक योजनांसाठी एक शक्तिशाली बिल्डिंग ब्लॉक देतात.

129
00:08:28,000 --> 00:08:32,880
उदाहरणार्थ, हॅमिंग एरर कुठे घडली हे ओळखण्याचा मार्ग शोधत होता, फक्त ती घडलीच

130
00:08:32,880 --> 00:08:37,160
नाही, तर त्याची मुख्य माहिती अशी होती की जर तुम्ही काही पॅरिटी चेक

131
00:08:37,160 --> 00:08:42,040
पूर्ण मेसेजवर लागू केले नाही तर काही काळजीपूर्वक निवडलेल्या उपसंचांना, तुम्ही विचारू शकता.

132
00:08:42,040 --> 00:08:46,840
प्रश्नांची अधिक परिष्कृत मालिका जी कोणत्याही एका बिट त्रुटीचे स्थान पिन डाउन करते.

133
00:08:46,840 --> 00:08:51,280
एकंदरीत भावना 20 प्रश्नांचा गेम खेळण्यासारखी आहे, होय किंवा

134
00:08:51,280 --> 00:08:54,300
नाही प्रश्न विचारणे ज्यामुळे शक्यतांची जागा अर्धी कापली जाते.

135
00:08:54,300 --> 00:08:58,840
उदाहरणार्थ, समजा की आम्ही फक्त या 8 बिट्सवर

136
00:08:58,840 --> 00:08:59,840
समता तपासणी करतो, सर्व विषम क्रमांकित स्थानांवर.

137
00:09:00,400 --> 00:09:04,560
नंतर एखादी त्रुटी आढळल्यास, ती प्राप्तकर्त्याला विशेषतः त्रुटी कुठे आहे

138
00:09:04,560 --> 00:09:09,160
याबद्दल थोडी अधिक माहिती देते, म्हणजे ती विचित्र स्थितीत आहे.

139
00:09:09,160 --> 00:09:14,360
जर त्या 8 बिट्समध्ये कोणतीही त्रुटी आढळली नाही, तर याचा अर्थ

140
00:09:14,360 --> 00:09:17,240
एकतर कोणतीही त्रुटी नाही किंवा ती कुठेतरी सम स्थितीत बसते.

141
00:09:17,240 --> 00:09:21,560
तुम्हाला असे वाटेल की समता तपासणी अर्ध्या बिट्सपर्यंत मर्यादित ठेवल्याने

142
00:09:21,560 --> 00:09:25,460
ते कमी प्रभावी होते, परंतु जेव्हा ते इतर योग्य-निवडलेल्या तपासण्यांच्या

143
00:09:25,460 --> 00:09:29,720
संयोगाने केले जाते, तेव्हा ते आम्हाला अधिक शक्तिशाली काहीतरी देते.

144
00:09:29,720 --> 00:09:34,440
ती पॅरिटी चेक प्रत्यक्षात सेट करण्यासाठी, लक्षात ठेवा, त्या पूर्ण गटाच्या

145
00:09:34,440 --> 00:09:37,600
समानतेसाठी नियंत्रण असलेले काही विशेष बिट निश्चित करणे आवश्यक आहे.

146
00:09:37,600 --> 00:09:39,920
येथे फक्त स्थान 1 निवडूया.

147
00:09:39,920 --> 00:09:43,960
दाखवलेल्या उदाहरणासाठी, या 8 बिट्सची पॅरिटी सध्या विषम आहे, त्यामुळे प्रेषक त्या

148
00:09:43,960 --> 00:09:48,220
पॅरिटी बिटला टॉगल करण्यासाठी जबाबदार आहे आणि आता ते सम आहे.

149
00:09:48,220 --> 00:09:51,040
हे 4 पैकी फक्त 1 पॅरिटी चेक आहे जे आम्ही करू.

150
00:09:51,040 --> 00:09:55,560
दुसरा चेक ग्रिडच्या उजव्या अर्ध्या भागावर असलेल्या 8

151
00:09:55,560 --> 00:09:56,880
बिट्समध्ये आहे, कमीतकमी आम्ही तो येथे काढला आहे.

152
00:09:56,880 --> 00:10:02,520
यावेळी आपण पॅरिटी बिट म्हणून पोझिशन 2 वापरू शकतो, त्यामुळे या 8 बिट्समध्ये आधीपासून

153
00:10:02,520 --> 00:10:07,160
सम पॅरिटी आहे आणि प्रेषकाला तो बिट क्रमांक 2 अपरिवर्तित ठेवल्यास चांगले वाटू शकते.

154
00:10:07,160 --> 00:10:11,040
मग दुसऱ्या टोकाला, जर प्राप्तकर्त्याने या गटाची समानता तपासली आणि त्यांना ते विचित्र

155
00:10:11,040 --> 00:10:15,960
असल्याचे आढळले, तर त्यांना कळेल की उजवीकडील या 8 बिट्समध्ये कुठेतरी त्रुटी आहे.

156
00:10:15,960 --> 00:10:21,260
अन्यथा याचा अर्थ एकतर कोणतीही त्रुटी नाही किंवा त्रुटी डाव्या अर्ध्या भागात कुठेतरी आहे.

157
00:10:21,260 --> 00:10:24,040
किंवा मला वाटते की दोन त्रुटी असू शकतात, परंतु आत्ता आम्ही असे

158
00:10:24,040 --> 00:10:27,080
गृहीत धरणार आहोत की संपूर्ण ब्लॉकमध्ये जास्तीत जास्त एक त्रुटी आहे.

159
00:10:27,080 --> 00:10:29,160
त्याहून अधिक गोष्टींसाठी गोष्टी पूर्णपणे खंडित होतात.

160
00:10:29,160 --> 00:10:32,920
येथे, आम्ही पुढील दोन तपासण्या पाहण्याआधी, जेव्हा तुम्ही त्यांचा एकत्रितपणे विचार करता तेव्हा

161
00:10:32,920 --> 00:10:35,880
हे पहिले दोन आम्हाला काय करू देतात याचा विचार करण्यासाठी थोडा वेळ द्या.

162
00:10:35,880 --> 00:10:40,240
समजा तुम्हाला विषम स्तंभांमध्ये आणि उजव्या अर्ध्यामध्ये त्रुटी आढळली आहे.

163
00:10:40,240 --> 00:10:43,940
याचा अर्थ शेवटच्या स्तंभात कुठेतरी त्रुटी आहे.

164
00:10:43,940 --> 00:10:48,280
विषम स्तंभामध्ये कोणतीही त्रुटी नसल्यास, परंतु उजव्या अर्ध्या भागात एक त्रुटी

165
00:10:48,280 --> 00:10:50,520
असल्यास, ते तुम्हाला सांगते की ते दुसऱ्या ते शेवटच्या स्तंभात आहे.

166
00:10:50,520 --> 00:10:54,640
त्याचप्रमाणे जर विषम स्तंभांमध्ये त्रुटी असेल परंतु उजव्या अर्ध्या भागात नसेल,

167
00:10:54,640 --> 00:10:56,560
तर तुम्हाला माहिती आहे की ती दुसऱ्या स्तंभात कुठेतरी आहे.

168
00:10:56,560 --> 00:11:00,560
आणि जर या दोन्ही पॅरिटी तपासण्यांपैकी काहीही आढळले नाही, तर याचा अर्थ

169
00:11:00,560 --> 00:11:03,760
एरर असू शकते अशी एकमेव जागा त्या सर्वात डाव्या स्तंभात आहे.

170
00:11:03,760 --> 00:11:06,480
परंतु याचा अर्थ असा असू शकतो की कोणतीही त्रुटी नाही.

171
00:11:06,480 --> 00:11:10,800
दोन पॅरिटी चेक आम्हाला कॉलम पिन डाउन करू द्या

172
00:11:10,800 --> 00:11:11,800
असे म्हणण्याचा हा सर्व काही उलगडलेला मार्ग आहे.

173
00:11:11,800 --> 00:11:14,000
येथून, आपण कदाचित पुढील काय अंदाज लावू शकता.

174
00:11:14,000 --> 00:11:16,240
आम्ही मुळात तेच करतो पण पंक्तींसाठी.

175
00:11:16,240 --> 00:11:21,040
पॅरिटी बिट म्हणून पोझिशन 4 वापरून विषम पंक्तींवर समता तपासणी केली जाईल.

176
00:11:21,040 --> 00:11:25,480
तर या उदाहरणात त्या गटात आधीपासून सम समता आहे,

177
00:11:25,480 --> 00:11:26,480
त्यामुळे बिट 4 0 वर सेट केला जाईल.

178
00:11:26,480 --> 00:11:31,280
आणि शेवटी पॅरिटी बिट म्हणून स्थान 8

179
00:11:31,280 --> 00:11:32,280
वापरून तळाच्या दोन ओळींवर पॅरिटी चेक आहे.

180
00:11:32,280 --> 00:11:35,840
या प्रकरणात, असे दिसते की प्रेषकाने गटाला समानता

181
00:11:35,840 --> 00:11:37,840
देण्यासाठी ते बिट 8 चालू करणे आवश्यक आहे.

182
00:11:37,840 --> 00:11:41,360
ज्याप्रमाणे पहिल्या दोन तपासण्या आपल्याला स्तंभ खाली पिन करू

183
00:11:41,360 --> 00:11:43,000
देतात, त्याचप्रमाणे पुढील दोन आपल्याला पंक्ती पिन करू देतात.

184
00:11:43,000 --> 00:11:48,400
उदाहरण म्हणून, कल्पना करा की ट्रान्समिशन दरम्यान, स्थिती 3 वर एक त्रुटी आहे.

185
00:11:48,400 --> 00:11:52,620
बरं, हे पहिल्या पॅरिटी गटावर परिणाम करते, आणि ते दुसऱ्या पॅरिटी गटावर देखील

186
00:11:52,620 --> 00:11:56,340
परिणाम करते, म्हणून प्राप्तकर्त्याला माहित आहे की त्या उजव्या स्तंभात कुठेतरी त्रुटी आहे.

187
00:11:56,340 --> 00:12:01,380
परंतु त्याचा तिसऱ्या गटावर परिणाम होत नाही आणि चौथ्या गटावर त्याचा परिणाम होत नाही.

188
00:12:01,380 --> 00:12:05,460
आणि ते प्राप्तकर्त्याला पहिल्या पंक्तीपर्यंत त्रुटी दर्शवू देते, ज्याचा अर्थ स्थान

189
00:12:05,460 --> 00:12:08,660
3 असणे आवश्यक आहे, जेणेकरून ते त्रुटी दूर करू शकतात.

190
00:12:08,660 --> 00:12:12,640
या चार प्रश्नांची उत्तरे तुम्हाला नेहमीच विशिष्ट स्थान पिन करू देतात हे

191
00:12:12,680 --> 00:12:17,320
पटवून देण्यासाठी तुम्हाला थोडा वेळ आनंद वाटेल, मग ते कुठेही असले तरीही.

192
00:12:17,320 --> 00:12:22,640
किंबहुना, तुमच्यातील चतुर लोकांना कदाचित या प्रश्नांचा

193
00:12:22,640 --> 00:12:23,640
आणि बायनरी मोजणीमधील संबंध लक्षात येईल.

194
00:12:23,640 --> 00:12:27,840
आणि जर तुम्ही असे केले तर, मी पुन्हा जोर देईन,

195
00:12:27,840 --> 00:12:30,880
विराम द्या, मी ते खराब करण्यापूर्वी कनेक्शन काढण्याचा प्रयत्न करा.

196
00:12:30,880 --> 00:12:35,560
जर तुम्ही विचार करत असाल की पॅरिटी बिट स्वतःच प्रभावित

197
00:12:35,560 --> 00:12:36,560
झाल्यास काय होईल, ठीक आहे, तुम्ही ते वापरून पाहू शकता.

198
00:12:36,560 --> 00:12:40,720
या चार विशेष बिट्समधील कोणतीही त्रुटी इतर कोणत्याही प्रमाणेच, चार प्रश्नांच्या

199
00:12:40,720 --> 00:12:47,440
समान गटासह कशी शोधली जाईल याचा विचार करण्यासाठी थोडा वेळ घ्या.

200
00:12:47,440 --> 00:12:50,500
याने काही फरक पडत नाही, कारण दिवसाच्या शेवटी आपल्याला संदेश

201
00:12:50,500 --> 00:12:53,640
बिट्सचे संरक्षण करायचे आहे, त्रुटी सुधारणे बिट्स सोबतच असतात.

202
00:12:53,640 --> 00:12:57,120
परंतु त्या बिट्सचे संरक्षण करणे ही अशी गोष्ट

203
00:12:57,120 --> 00:12:59,260
आहे जी नैसर्गिकरित्या उपउत्पादन म्हणून योजनेतून बाहेर पडते.

204
00:12:59,260 --> 00:13:02,380
हे प्रमाण कसे वाढेल याचा अंदाज लावण्याचा तुम्हाला आनंदही वाटेल.

205
00:13:02,380 --> 00:13:08,040
जर आम्ही 256 बिट आकाराचा ब्लॉक वापरला असेल, उदाहरणार्थ, एखादे स्थान पिन डाउन करण्यासाठी,

206
00:13:08,040 --> 00:13:15,680
तुम्हाला काही विशिष्ट ठिकाणी बायनरी शोधण्यासाठी फक्त आठ होय किंवा नाही प्रश्न आवश्यक आहेत.

207
00:13:15,680 --> 00:13:19,680
आणि लक्षात ठेवा, प्रत्येक प्रश्नासाठी योग्य समता तपासणी

208
00:13:19,680 --> 00:13:23,340
सेट करण्यासाठी फक्त एक बिट सोडणे आवश्यक आहे.

209
00:13:23,340 --> 00:13:26,960
तुमच्यापैकी काहींनी ते आधीच पाहिले असेल, परंतु हे प्रश्न काय आहेत ते

210
00:13:26,960 --> 00:13:29,960
फक्त एक किंवा दोन मिनिटांत शोधण्याच्या पद्धतशीर मार्गाबद्दल आम्ही नंतर बोलू.

211
00:13:29,960 --> 00:13:33,440
आशा आहे की आम्ही येथे जे विकसित करत आहोत

212
00:13:33,440 --> 00:13:34,440
त्याच्या कार्यक्षमतेचे कौतुक करण्यासाठी हे स्केच पुरेसे आहे.

213
00:13:34,440 --> 00:13:38,440
पहिली गोष्ट, त्या आठ हायलाइट केलेले पॅरिटी बिट्स वगळता,

214
00:13:38,440 --> 00:13:41,720
तुम्हाला हवे ते संदेश किंवा डेटा घेऊन जाऊ शकते.

215
00:13:41,720 --> 00:13:45,480
8 बिट या अर्थाने अनावश्यक आहेत की ते उर्वरित संदेशाद्वारे पूर्णपणे निर्धारित

216
00:13:45,480 --> 00:13:53,640
केले जातात, परंतु संपूर्ण संदेश कॉपी करण्यापेक्षा ते अधिक हुशार मार्गाने आहे.

217
00:13:53,640 --> 00:13:58,000
आणि तरीही, इतक्या कमी सोडल्याबद्दल, तुम्ही कोणतीही एक बिट

218
00:13:58,000 --> 00:13:59,000
त्रुटी ओळखण्यास आणि त्याचे निराकरण करण्यात सक्षम असाल.

219
00:13:59,000 --> 00:14:00,400
बरं, जवळजवळ.

220
00:14:00,400 --> 00:14:05,920
ठीक आहे, तर इथे एक अडचण अशी आहे की जर चार पॅरिटी तपासण्यांपैकी

221
00:14:05,920 --> 00:14:10,240
एकही त्रुटी आढळली नाही, म्हणजे 8 बिट्सच्या विशेष निवडलेल्या उपसमूहांमध्ये समान समानता

222
00:14:10,240 --> 00:14:15,520
आहेत, जसे की प्रेषकाने अभिप्रेत आहे, तर याचा अर्थ असा होतो की

223
00:14:15,520 --> 00:14:17,760
कोणतीही त्रुटी नव्हती. , किंवा ते आम्हाला स्थान 0 मध्ये कमी करते.

224
00:14:17,760 --> 00:14:23,040
तुम्ही पहा, चार होय किंवा नाही प्रश्नांसह, आमच्या समता तपासणीसाठी आमच्याकडे 16 संभाव्य

225
00:14:23,040 --> 00:14:28,000
परिणाम आहेत, आणि सुरुवातीला ब्लॉकमधील 16 पैकी 1 स्थान निश्चित करण्यासाठी योग्य वाटतात,

226
00:14:28,000 --> 00:14:33,000
परंतु तुम्हाला 17 व्या निकालाशी संवाद साधण्याची आवश्यकता आहे, कोणतीही त्रुटी नाही. अट.

227
00:14:33,000 --> 00:14:37,860
येथे उपाय प्रत्यक्षात खूपच सोपे आहे, फक्त त्या 0व्या बिटबद्दल पूर्णपणे विसरून जा.

228
00:14:37,860 --> 00:14:41,920
म्हणून जेव्हा आम्ही आमच्या चार समानता तपासतो आणि आम्ही पाहतो की ते

229
00:14:41,920 --> 00:14:44,320
सर्व समान आहेत, याचा अर्थ असा होतो की कोणतीही त्रुटी नाही.

230
00:14:44,320 --> 00:14:49,240
याचा अर्थ असा आहे की 16-बिट ब्लॉकसह काम करण्याऐवजी, आम्ही 15-बिट ब्लॉकसह कार्य करतो,

231
00:14:49,240 --> 00:14:54,040
जिथे 11 बिट संदेश घेऊन जाण्यासाठी विनामूल्य आहेत आणि त्यापैकी 4 रिडंडंसीसाठी आहेत.

232
00:14:54,080 --> 00:14:58,400
आणि त्यासह, आमच्याकडे आता व्यवसायातील लोक

233
00:14:58,400 --> 00:14:59,400
15-11 हॅमिंग कोड म्हणून संबोधतात.

234
00:14:59,400 --> 00:15:03,920
ते म्हणाले, 2 ची क्लीन पॉवर असणारा ब्लॉक आकार असणे खूप छान आहे आणि एक चतुर मार्ग

235
00:15:03,920 --> 00:15:08,880
आहे ज्याने आपण तो 0 वा थोडा जवळ ठेवू शकतो आणि आपल्यासाठी थोडे अतिरिक्त काम करू शकतो.

236
00:15:08,880 --> 00:15:13,600
आम्ही संपूर्ण ब्लॉकमध्ये पॅरिटी बिट म्हणून याचा वापर केल्यास, ते

237
00:15:13,600 --> 00:15:16,320
आम्हाला 2-बिट त्रुटी सुधारू शकत नसले तरी प्रत्यक्षात शोधू देते.

238
00:15:16,320 --> 00:15:17,440
ते कसे कार्य करते ते येथे आहे.

239
00:15:17,440 --> 00:15:21,740
ते चार विशेष एरर-करेक्टिंग बिट्स सेट केल्यानंतर, आम्ही ते 0 वा

240
00:15:21,740 --> 00:15:25,540
सेट करतो जेणेकरून सामान्य पॅरिटी चेकप्रमाणे पूर्ण ब्लॉकची पॅरिटी सम असेल.

241
00:15:25,540 --> 00:15:29,780
आता, जर एक बिट एरर असेल, तर पूर्ण ब्लॉकची पॅरिटी विषम

242
00:15:29,780 --> 00:15:33,940
म्हणून टॉगल करते, परंतु तरीही आम्ही चार त्रुटी-सुधारित तपासण्यांमुळे ते पकडू.

243
00:15:33,940 --> 00:15:38,100
तथापि, जर दोन त्रुटी असतील, तर एकूण समानता पुन्हा सम वर

244
00:15:38,100 --> 00:15:42,660
टॉगल होणार आहे, परंतु प्राप्तकर्त्यास तरीही त्या चार पॅरिटी चेकमध्ये

245
00:15:42,660 --> 00:15:45,820
काय चालले आहे त्यामुळे किमान काही त्रुटी असल्याचे दिसून येईल.

246
00:15:45,820 --> 00:15:49,780
त्यामुळे जर त्यांना एकंदरीत सम समानता दिसली, परंतु इतर तपासण्यांमध्ये शून्य नसलेले

247
00:15:49,820 --> 00:15:52,980
काहीतरी घडत आहे, तर ते त्यांना सांगते की किमान दोन त्रुटी होत्या.

248
00:15:52,980 --> 00:15:54,420
हुशार नाही का?

249
00:15:54,420 --> 00:15:58,500
जरी आम्ही त्या 2-बिट चुका दुरुस्त करू शकत नसलो तरी, फक्त एक

250
00:15:58,500 --> 00:16:02,340
थोडा त्रासदायक 0 वी बिट कामावर ठेवून, ते आम्हाला त्या शोधू देते.

251
00:16:02,340 --> 00:16:06,540
हे खूपच मानक आहे, हे विस्तारित हॅमिंग कोड म्हणून ओळखले जाते.

252
00:16:06,540 --> 00:16:10,860
तांत्रिकदृष्ट्या बोलायचे झाल्यास, हॅमिंग कोड काय करतो याचे

253
00:16:10,860 --> 00:16:13,580
संपूर्ण वर्णन तुमच्याकडे आहे, किमान 16-बिट ब्लॉकच्या उदाहरणासाठी.

254
00:16:13,580 --> 00:16:17,300
परंतु मला वाटते की तुम्हाला तुमची समज तपासणे अधिक समाधानकारक वाटेल आणि सुरुवातीपासून ते

255
00:16:17,300 --> 00:16:21,980
स्वतःला पूर्ण करण्यापर्यंत एक पूर्ण उदाहरण देऊन या टप्प्यापर्यंत सर्व काही दृढ करा.

256
00:16:21,980 --> 00:16:25,100
तरीही मी तुमच्याबरोबर यातून मार्ग काढेन जेणेकरून तुम्ही स्वतःला तपासू शकता.

257
00:16:25,100 --> 00:16:29,180
संदेश सेट करण्‍यासाठी, मग तो तुम्‍ही जागेवर भाषांतरित करत असलेला

258
00:16:29,180 --> 00:16:34,100
शाब्दिक संदेश असो किंवा तुम्‍हाला कालांतराने संचयित करायचा असलेला

259
00:16:34,100 --> 00:16:35,700
काही डेटा असो, पहिली पायरी म्हणजे 11-बिट भागांमध्ये विभागणे.

260
00:16:35,700 --> 00:16:40,340
प्रत्येक भाग त्रुटी-प्रतिरोधक 16-बिट ब्लॉकमध्ये पॅकेज केला जाईल.

261
00:16:40,340 --> 00:16:43,740
चला तर मग हे एक उदाहरण म्हणून घेऊ आणि ते प्रत्यक्षात आणू.

262
00:16:43,740 --> 00:16:45,340
पुढे जा, प्रत्यक्षात ते करा!

263
00:16:45,380 --> 00:16:47,380
चला थांबा आणि हा ब्लॉक एकत्र ठेवण्याचा प्रयत्न करूया.

264
00:16:52,980 --> 00:16:53,980
ठीक आहे, तुम्ही तयार आहात?

265
00:16:53,980 --> 00:16:58,500
लक्षात ठेवा, स्थान 0 सोबत 2 च्या इतर शक्ती देखील त्रुटी दुरुस्ती कर्तव्यासाठी

266
00:16:58,500 --> 00:17:05,700
राखीव आहेत, म्हणून तुम्ही क्रमाने उर्वरित सर्व स्पॉट्समध्ये संदेश बिट ठेवून सुरुवात करा.

267
00:17:05,700 --> 00:17:09,700
तुम्‍हाला सम समता असण्‍यासाठी या गटाची आवश्‍यकता आहे, जी ते आधीपासून करत

268
00:17:09,700 --> 00:17:13,140
आहे, त्यामुळे तुम्‍ही ते पॅरिटी बिट स्‍थिती 1 मध्‍ये 0 असायला हवे.

269
00:17:13,140 --> 00:17:17,700
पुढचा गट विषम समतेने सुरू होतो, त्यामुळे तुम्ही

270
00:17:17,700 --> 00:17:19,260
त्याचा पॅरिटी बिट 1 वर सेट केला असावा.

271
00:17:19,260 --> 00:17:23,740
त्यानंतरचा गट विषम पॅरिटीने सुरू होतो, त्यामुळे तुम्ही पुन्हा

272
00:17:23,740 --> 00:17:24,740
त्याचे पॅरिटी बिट 1 वर सेट केले पाहिजे.

273
00:17:24,740 --> 00:17:29,500
आणि अंतिम गटामध्ये विषम समानता देखील आहे, म्हणजे आम्ही ती

274
00:17:29,500 --> 00:17:31,500
बिट स्थान 8 मध्ये 1 म्हणून सेट केली आहे.

275
00:17:31,500 --> 00:17:36,460
आणि मग अंतिम पायरी म्हणून, आता पूर्ण ब्लॉकमध्ये सम समानता आहे, म्हणजे तुम्ही

276
00:17:36,460 --> 00:17:41,500
तो बिट क्रमांक 0, ओव्हरचिंग पॅरिटी बिट, 0 वर सेट करू शकता.

277
00:17:41,500 --> 00:17:45,660
म्हणून हा ब्लॉक पाठवला जात असताना, चार विशेष उपसमूहांची

278
00:17:45,660 --> 00:17:48,980
समता आणि संपूर्ण ब्लॉक सर्व सम किंवा 0 असेल.

279
00:17:48,980 --> 00:17:53,620
व्यायामाचा दुसरा भाग म्हणून, आपण प्राप्तकर्त्याची भूमिका बजावूया.

280
00:17:53,620 --> 00:17:57,580
अर्थात, याचा अर्थ असा आहे की हा संदेश काय आहे हे तुम्हाला आधीच माहित

281
00:17:57,580 --> 00:18:00,180
नाही, कदाचित तुमच्यापैकी काहींनी तो लक्षात ठेवला असेल, परंतु समजू की तुम्हाला नाही.

282
00:18:00,180 --> 00:18:05,820
मी काय करणार आहे ते म्हणजे त्या ब्लॉकमधील ०, १, किंवा २

283
00:18:05,820 --> 00:18:08,340
बिट्स बदला, आणि मग मी काय केले ते शोधण्यासाठी तुम्हाला सांगेन.

284
00:18:08,340 --> 00:18:13,460
म्हणून पुन्हा, विराम द्या आणि प्रयत्न करा.

285
00:18:13,460 --> 00:18:23,960
ठीक आहे, म्हणून तुम्ही आता प्राप्तकर्ता म्हणून प्रथम पॅरिटी गट तपासा आणि तुम्ही ते सम

286
00:18:23,960 --> 00:18:29,820
आहे हे पाहू शकता, त्यामुळे अस्तित्वात असलेली कोणतीही त्रुटी सम स्तंभात असणे आवश्यक आहे.

287
00:18:29,820 --> 00:18:34,620
पुढील चेक आम्हाला एक विषम संख्या देतो, कमीतकमी एक त्रुटी

288
00:18:34,620 --> 00:18:38,760
असल्याचे सांगते आणि आम्हाला या विशिष्ट स्तंभात कमी करते.

289
00:18:38,760 --> 00:18:42,900
तिसरा चेक सम आहे, शक्यता कमी करून आणखी पुढे जाणे.

290
00:18:42,900 --> 00:18:46,780
आणि शेवटची पॅरिटी चेक विषम आहे, आम्हाला सांगते की तळाशी कुठेतरी एक त्रुटी आहे,

291
00:18:46,780 --> 00:18:51,700
जी आत्तापर्यंत आपण पाहू शकतो की स्थान क्रमांक 10 मध्ये असणे आवश्यक आहे.

292
00:18:51,700 --> 00:18:56,140
इतकेच काय, संपूर्ण ब्लॉकची समानता विषम आहे, ज्यामुळे आम्हाला

293
00:18:56,140 --> 00:18:58,220
विश्वास मिळतो की एक फ्लिप होता आणि दोन नाही.

294
00:18:58,220 --> 00:19:01,600
ते तीन किंवा अधिक असल्यास, सर्व बेट्स बंद आहेत.

295
00:19:01,600 --> 00:19:06,520
तो बिट क्रमांक 10 दुरुस्त केल्यानंतर, दुरुस्त्यासाठी न वापरलेले 11 बिट्स बाहेर

296
00:19:06,520 --> 00:19:11,620
काढल्याने आम्हाला मूळ संदेशाचा संबंधित विभाग मिळतो, जो तुम्ही रिवाइंड केला आणि

297
00:19:11,620 --> 00:19:16,160
तुलना केल्यास तेच खरे आहे ज्याने आम्ही उदाहरण सुरू केले आहे.

298
00:19:16,160 --> 00:19:19,260
आणि आता तुम्हाला हे सर्व हाताने कसे करायचे हे माहित आहे, मी तुम्हाला दाखवू इच्छितो

299
00:19:19,260 --> 00:19:23,940
की तुम्ही या सर्व तर्काचा मुख्य भाग पायथन कोडच्या एका ओळीने कसा पूर्ण करू शकता.

300
00:19:23,940 --> 00:19:28,400
तुम्ही पहा, हे अल्गोरिदम खरोखर किती मोहक आहे, एखादे मशीन

301
00:19:28,400 --> 00:19:32,380
मिळवणे किती सोपे आहे, ते पद्धतशीरपणे कसे मोजायचे आणि

302
00:19:32,380 --> 00:19:37,680
आम्ही सर्व कसे फ्रेम करू शकतो हे मी तुम्हाला सांगितले

303
00:19:37,680 --> 00:19:39,580
नाही. हे एकाधिक स्वतंत्र समानता तपासण्यांऐवजी एकच ऑपरेशन म्हणून.

304
00:19:39,580 --> 00:19:41,680
मला काय म्हणायचे आहे ते पाहण्यासाठी, माझ्यासोबत भाग २ मध्ये या.

