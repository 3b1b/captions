1
00:00:00,000 --> 00:00:05,562
सीडी किंवा डीव्हीडी स्क्रॅच करणे कसे शक्य आहे आणि तरीही ते जे काही साठवले

2
00:00:05,562 --> 00:00:10,900
आहे ते पुन्हा प्ले करणे कसे शक्य आहे याचा तुम्ही कधी विचार केला आहे का?

3
00:00:10,900 --> 00:00:15,319
स्क्रॅचचा खरोखरच डिस्कवरील 1s आणि 0s वर परिणाम होतो, त्यामुळे तो संग्रहित

4
00:00:15,319 --> 00:00:19,739
केलेल्या डेटापासून भिन्न डेटा वाचतो, परंतु जोपर्यंत तो खरोखर स्क्रॅच केला

5
00:00:19,739 --> 00:00:24,159
जात नाही तोपर्यंत, ते वाचलेले बिट्स अगदी त्याच फाईलमध्ये डीकोड केले जातात

6
00:00:24,159 --> 00:00:28,400
जी त्यावर एन्कोड केली होती, a त्या सर्व त्रुटी असूनही बिट कॉपीसाठी बिट.

7
00:00:28,400 --> 00:00:32,573
गणितीय हुशारीचा एक संपूर्ण ढिगारा आहे जो आपल्याला डेटा संग्रहित करण्यास परवानगी देतो आणि

8
00:00:32,573 --> 00:00:36,418
त्याचप्रमाणे महत्त्वाचे म्हणजे डेटा प्रसारित करण्यासाठी, त्रुटींना लवचिक असलेल्या

9
00:00:36,418 --> 00:00:36,840
मार्गाने.

10
00:00:36,840 --> 00:00:42,480
बरं, ठीक आहे, खरं तर हे करण्याचा मार्ग शोधण्यासाठी इतकी हुशारी लागत नाही.

11
00:00:42,480 --> 00:00:46,720
कोणतीही फाईल, मग ती व्हिडिओ असो वा ध्वनी किंवा मजकूर, काही

12
00:00:46,720 --> 00:00:50,960
कोड, प्रतिमा, काहीही असो, शेवटी 1 आणि 0 चे काही क्रम असतात.

13
00:00:50,960 --> 00:00:54,433
आणि कोणताही बिट जो पलटला जातो तो दुरुस्त करण्यासाठी एक

14
00:00:54,433 --> 00:00:57,780
साधी रणनीती म्हणजे प्रत्येक बिटच्या तीन प्रती साठवणे.

15
00:00:57,780 --> 00:01:02,451
मग ही फाइल वाचणारे मशीन या तीन प्रतींची तुलना करू शकते आणि

16
00:01:02,451 --> 00:01:07,440
जेव्हाही विसंगती असेल तेव्हा नेहमी 3 पैकी सर्वोत्तम 2 घेऊ शकते.

17
00:01:07,440 --> 00:01:11,560
पण त्याचा अर्थ असा आहे की तुमच्या दोन तृतीयांश जागा रिडंडंसीसाठी वापरणे.

18
00:01:11,560 --> 00:01:14,905
आणि तरीही, त्या सर्व जागेसाठी, एकापेक्षा जास्त बिट

19
00:01:14,905 --> 00:01:18,120
फ्लिप झाल्यास काय होईल याची कोणतीही ठोस हमी नाही.

20
00:01:18,120 --> 00:01:21,552
अधिक मनोरंजक प्रश्न म्हणजे ते कसे बनवायचे जेणेकरुन शक्य

21
00:01:21,552 --> 00:01:24,740
तितक्या कमी जागा सोडताना त्रुटी सुधारल्या जाऊ शकतात.

22
00:01:24,740 --> 00:01:28,857
उदाहरणार्थ, तुम्ही या व्हिडिओबद्दल शिकणार असलेल्या पद्धतीचा वापर करून, तुम्ही

23
00:01:28,857 --> 00:01:32,975
तुमचा डेटा २५६-बिट ब्लॉक्समध्ये संचयित करू शकता, जिथे प्रत्येक ब्लॉक ९ बिट, ९!

24
00:01:32,975 --> 00:01:37,234
एक प्रकारचा रिडंडंसी म्हणून काम करण्यासाठी, आणि इतर 247 बिट तुम्हाला

25
00:01:37,234 --> 00:01:41,000
हवा तो अर्थपूर्ण संदेश किंवा डेटा घेऊन जाण्यासाठी मोकळे आहेत.

26
00:01:41,000 --> 00:01:45,156
आणि तरीही असेच असेल की इथे जर काही गडबड झाली तर, फक्त हा ब्लॉक

27
00:01:45,156 --> 00:01:49,247
बघून आणि आणखी काही नाही, तर मशीन ओळखू शकेल की त्रुटी होती आणि

28
00:01:49,247 --> 00:01:53,140
ती नेमकी कुठे होती, जेणेकरून ती कशी दुरुस्त करायची ते कळेल.

29
00:01:53,140 --> 00:01:55,540
आणि प्रामाणिकपणे, ते जादूसारखे वाटते.

30
00:01:55,540 --> 00:01:59,311
आणि या विशिष्ट योजनेसाठी, जर दोन बिट्स फ्लिप झाले तर, मशीन कमीतकमी दोन त्रुटी

31
00:01:59,311 --> 00:02:03,180
असल्याचे शोधण्यास सक्षम असेल, परंतु त्या कशा दुरुस्त करायच्या हे माहित नसले तरी.

32
00:02:03,180 --> 00:02:08,140
वेगवेगळ्या आकारांच्या ब्लॉक्ससाठी हे कसे मोजले जाते याबद्दल आम्ही थोड्या वेळाने बोलू.

33
00:02:08,140 --> 00:02:13,880
तुम्हाला यासारख्या चुका दुरुस्त करू देणार्‍या पद्धती एरर सुधारणा कोड म्हणून ओळखल्या जातात.

34
00:02:13,880 --> 00:02:18,411
गेल्या शतकाच्या चांगल्या भागासाठी, हे क्षेत्र आश्चर्यकारकपणे सखोल गणिताचे खरोखर

35
00:02:18,411 --> 00:02:23,000
समृद्ध स्त्रोत आहे जे आम्ही दररोज वापरत असलेल्या उपकरणांमध्ये समाविष्ट केले जाते.

36
00:02:23,000 --> 00:02:26,055
हॅमिंग कोड म्हणून ओळखल्या जाणार्‍या सर्वात जुन्या

37
00:02:26,055 --> 00:02:29,660
उदाहरणांपैकी एकाची अगदी सखोल माहिती देणे हे येथे ध्येय आहे.

38
00:02:29,660 --> 00:02:33,162
आणि तसे, या व्हिडिओच्या संरचनेबद्दल मी ज्या प्रकारे विचार करत आहे

39
00:02:33,162 --> 00:02:36,558
ते शक्य तितके थेट स्पष्ट करणे कमी आहे आणि इकडे-तिकडे थोडे सौम्य

40
00:02:36,558 --> 00:02:40,220
मार्गदर्शनासह, तुम्हाला स्वतःसाठी ते शोधण्यास प्रवृत्त करणे अधिक आहे.

41
00:02:40,220 --> 00:02:43,429
म्हणून जेव्हा तुम्हाला वाटत असेल की ते कुठे जात आहे ते एखाद्या वेळी, तो क्षण

42
00:02:43,429 --> 00:02:47,180
थांबण्यासाठी घ्या, मी तुम्हाला सांगण्यापूर्वी ही योजना काय असेल याचा सक्रियपणे अंदाज लावा.

43
00:02:47,180 --> 00:02:51,293
तसेच, जर तुम्हाला तुमची समज हार्डवेअरच्या पातळीवर उतरवायची असेल, तर

44
00:02:51,293 --> 00:02:55,346
बेन ईटरने ब्रेडबोर्डवर हॅमिंग कोड प्रत्यक्षात कसे अंमलात आणायचे हे

45
00:02:55,346 --> 00:02:59,520
दाखवत याच्या संयोगाने एक व्हिडिओ बनवला आहे, जो अत्यंत समाधानकारक आहे.

46
00:02:59,520 --> 00:03:04,159
तुम्हाला हे माहित असले पाहिजे, हॅमिंग कोड हे रीड-सोलोमन अल्गोरिदम सारख्या आधुनिक

47
00:03:04,159 --> 00:03:08,856
कोड्सइतके मोठ्या प्रमाणावर वापरले जात नाहीत, परंतु हे कार्य सुरुवातीला किती अशक्य

48
00:03:08,856 --> 00:03:13,953
वाटते आणि एकदा ते किती वाजवी वाटते यामधील फरकाची एक विशिष्ट जादू आहे. तुम्ही हॅमिंगबद्दल

49
00:03:13,953 --> 00:03:14,240
शिका.

50
00:03:14,240 --> 00:03:18,334
त्रुटी सुधारण्याचे मूलभूत तत्त्व असे आहे की सर्व संभाव्य

51
00:03:18,334 --> 00:03:22,860
संदेशांच्या विशाल जागेत, फक्त काही उपसंच वैध संदेश मानले जातील.

52
00:03:22,860 --> 00:03:29,100
एक साधर्म्य म्हणून, अचूक स्पेलिंग शब्द वि चुकीचे स्पेलिंग शब्द बद्दल विचार करा.

53
00:03:29,100 --> 00:03:33,939
जेव्हा जेव्हा एखादा वैध संदेश बदलला जातो, तेव्हा प्राप्तकर्ता जवळच्या वैध शेजाऱ्याला

54
00:03:33,939 --> 00:03:38,380
जे दिसले ते दुरुस्त करण्यासाठी जबाबदार असतो, जसे तुम्ही टायपिंगमध्ये करू शकता.

55
00:03:38,380 --> 00:03:42,770
अशा संदेशांचे कार्यक्षमतेने वर्गीकरण करण्यासाठी ठोस

56
00:03:42,770 --> 00:03:47,160
अल्गोरिदम आणणे, तथापि, एक विशिष्ट हुशारी आवश्यक आहे.

57
00:03:47,160 --> 00:03:50,410
कथा 1940 च्या दशकात सुरू होते, जेव्हा एक तरुण रिचर्ड हॅमिंग बेल

58
00:03:50,410 --> 00:03:53,864
लॅबसाठी काम करत होता, आणि त्याच्या काही कामांमध्ये एक खूप मोठा महाग

59
00:03:53,864 --> 00:03:57,420
पंच कार्ड संगणक वापरत होता ज्यामध्ये त्याला फक्त मर्यादित प्रवेश होता.

60
00:03:57,420 --> 00:04:00,198
आणि त्याद्वारे तो मांडत राहिलेले कार्यक्रम अयशस्वी

61
00:04:00,198 --> 00:04:03,140
होत गेले, कारण वेळोवेळी थोडेफार चुकीचे वाचले जात होते.

62
00:04:03,140 --> 00:04:06,120
नैराश्य हे शोधाचे टोक असल्याने तो इतका कंटाळला की

63
00:04:06,120 --> 00:04:09,280
त्याने जगातील पहिला त्रुटी सुधारणेचा कोड शोधून काढला.

64
00:04:09,280 --> 00:04:12,879
हॅमिंग कोड्स फ्रेम करण्याचे बरेच वेगवेगळे मार्ग आहेत, परंतु प्रथम पास म्हणून

65
00:04:12,879 --> 00:04:16,620
आम्ही त्यामधून जाणार आहोत ज्या प्रकारे हॅमिंगने स्वतः त्यांच्याबद्दल विचार केला.

66
00:04:16,620 --> 00:04:21,400
16 बिट्सच्या ब्लॉकचे एक उदाहरण वापरुया जे सोपे आहे, परंतु खूप सोपे नाही.

67
00:04:21,400 --> 00:04:25,700
आम्ही या बिट्सच्या स्थानांची संख्या 0 ते 15 पर्यंत करू.

68
00:04:25,700 --> 00:04:29,810
आम्‍हाला जो खरा डेटा संग्रहित करायचा आहे तो यापैकी फक्त 12 बिट्स

69
00:04:29,810 --> 00:04:33,920
बनवणार आहे, तर 4 पोझिशन्स एक प्रकारची रिडंडंसी म्हणून राखीव आहेत.

70
00:04:33,920 --> 00:04:37,060
येथे रिडंडंट शब्दाचा अर्थ फक्त कॉपी असा नाही, शेवटी, ते 4 बिट्स

71
00:04:37,060 --> 00:04:40,200
आम्हाला डेटाची आंधळेपणाने कॉपी करण्यासाठी पुरेशी जागा देत नाहीत.

72
00:04:40,200 --> 00:04:44,301
त्याऐवजी, त्यांना अधिक सूक्ष्म आणि हुशार प्रकारची अनावश्यकता

73
00:04:44,301 --> 00:04:48,740
असणे आवश्यक आहे, कोणतीही नवीन माहिती न जोडता, परंतु लवचिकता जोडणे.

74
00:04:48,740 --> 00:04:52,616
तुम्हाला कदाचित हे 4 स्पेशल बिट्स नीटपणे एकत्रितपणे पॅक केले जातील अशी अपेक्षा

75
00:04:52,616 --> 00:04:56,345
असेल, कदाचित शेवटी किंवा असे काहीतरी, परंतु जसे तुम्ही पहाल, त्यांना 2 च्या

76
00:04:56,345 --> 00:05:00,320
पॉवर्स असलेल्या पोझिशन्सवर बसवल्याने शेवटपर्यंत खरोखर मोहक असे काहीतरी मिळू शकते.

77
00:05:00,320 --> 00:05:05,420
हे तुम्हाला मोठ्या ब्लॉक्ससाठी कसे मोजते याबद्दल थोडीशी सूचना देखील देऊ शकते.

78
00:05:05,420 --> 00:05:09,821
तसेच तांत्रिकदृष्ट्या ते फक्त 11 बिट डेटाचे आहे, तुम्हाला 0 च्या स्थानावर काय

79
00:05:09,821 --> 00:05:14,280
चालले आहे यासाठी एक सौम्य सूक्ष्मता आढळेल, परंतु आत्ता त्याबद्दल काळजी करू नका.

80
00:05:14,280 --> 00:05:18,217
कोणत्याही त्रुटी सुधारण्याच्या अल्गोरिदमप्रमाणे, यात दोन खेळाडूंचा समावेश

81
00:05:18,217 --> 00:05:22,528
असेल, एक प्रेषक जो या 4 विशेष बिट सेट करण्यासाठी जबाबदार आहे आणि एक प्राप्तकर्ता

82
00:05:22,528 --> 00:05:26,360
जो काही प्रकारची तपासणी करण्यासाठी आणि त्रुटी सुधारण्यासाठी जबाबदार आहे.

83
00:05:26,360 --> 00:05:29,265
अर्थात, प्रेषक आणि प्राप्तकर्ता हे शब्द खरोखरच सर्व तपासण्या करत

84
00:05:29,265 --> 00:05:32,216
असलेल्या मशीन्स किंवा सॉफ्टवेअरचा संदर्भ घेतात आणि मेसेजची कल्पना

85
00:05:32,216 --> 00:05:35,480
म्हणजे स्टोरेजसारख्या गोष्टींचा समावेश करण्यासाठी खरोखरच व्यापक अर्थ आहे.

86
00:05:35,480 --> 00:05:38,834
शेवटी, डेटा संग्रहित करणे हे एका ठिकाणाहून दुसर्‍या

87
00:05:38,834 --> 00:05:42,640
ठिकाणाऐवजी भूतकाळापासून भविष्यात संदेश पाठविण्यासारखेच आहे.

88
00:05:42,640 --> 00:05:46,048
तर हा सेटअप आहे, परंतु आपण आत जाण्यापूर्वी आपल्याला हॅमिंगच्या

89
00:05:46,048 --> 00:05:49,780
शोधाच्या वेळी त्याच्या मनावर ताज्या असलेल्या एका संबंधित कल्पनेबद्दल

90
00:05:49,780 --> 00:05:53,296
बोलणे आवश्यक आहे, एक पद्धत जी आपल्याला कोणत्याही एकल त्रुटी शोधू

91
00:05:53,296 --> 00:05:57,300
देते, परंतु त्या सुधारू शकत नाही, ज्ञात आहे. समता तपासणी म्हणून व्यवसायात.

92
00:05:57,300 --> 00:06:00,935
समता तपासणीसाठी, आम्ही फक्त एकच बिट वेगळे करतो जो पाठवणारा

93
00:06:00,935 --> 00:06:04,940
ट्युनिंगसाठी जबाबदार असतो आणि बाकीचे संदेश पाठवण्यास मोकळे असतात.

94
00:06:04,940 --> 00:06:12,100
या स्पेशल बिटचे एकमेव काम म्हणजे मेसेजमधील एकूण 1s ही सम संख्या असल्याची खात्री करणे.

95
00:06:12,100 --> 00:06:16,208
उदाहरणार्थ, आत्ता, 1s ची एकूण संख्या 7 आहे, ती विषम आहे, म्हणून

96
00:06:16,208 --> 00:06:20,960
प्रेषकाला 1 असण्यासाठी तो विशेष बिट फ्लिप करणे आवश्यक आहे, गणना समान करते.

97
00:06:20,960 --> 00:06:24,465
परंतु जर ब्लॉक आधीच 1s च्या सम संख्येने सुरू झाला

98
00:06:24,465 --> 00:06:27,480
असता, तर हा विशेष बिट 0 वर ठेवला गेला असता.

99
00:06:27,480 --> 00:06:32,714
हे खूपच सोपे आहे, भ्रामकपणे सोपे आहे, परंतु संदेशामध्ये कुठेही बदल करण्याची कल्पना

100
00:06:32,714 --> 00:06:37,760
एका छोट्या माहितीमध्ये प्रतिबिंबित करण्याचा हा एक आश्चर्यकारकपणे मोहक मार्ग आहे.

101
00:06:37,760 --> 00:06:42,910
लक्षात घ्या की या संदेशाचा कोणताही भाग 0 ते 1 किंवा 1 ते 0 पर्यंत

102
00:06:42,910 --> 00:06:48,140
फ्लिप झाल्यास, तो 1s ची एकूण संख्या सम असण्यापासून विषममध्ये बदलतो.

103
00:06:48,140 --> 00:06:51,590
म्हणून जर तुम्ही प्राप्तकर्ता असाल, तर तुम्ही हा संदेश पाहाल, आणि

104
00:06:51,590 --> 00:06:54,988
तुम्हाला 1s ची विषम संख्या दिसली, तुम्ही निश्चितपणे समजू शकता की

105
00:06:54,988 --> 00:06:58,700
काही त्रुटी आली आहे, जरी तुम्हाला कदाचित तो कुठे होता याची कल्पना नसेल.

106
00:06:58,700 --> 00:07:01,878
शब्दशैलीमध्ये, बिट्सच्या गटामध्ये 1s ची सम किंवा विषम

107
00:07:01,878 --> 00:07:04,940
संख्या आहे की नाही हे त्याची समता म्हणून ओळखले जाते.

108
00:07:04,940 --> 00:07:08,152
तुम्ही संख्या देखील वापरू शकता आणि समता 0 किंवा 1 आहे असे म्हणू शकता, जे

109
00:07:08,152 --> 00:07:11,320
एकदा तुम्ही कल्पनेसह गणित करणे सुरू केले की सामान्यत: अधिक उपयुक्त ठरते.

110
00:07:11,320 --> 00:07:18,020
आणि प्रेषक समता नियंत्रित करण्यासाठी वापरतो या विशेष बिटला पॅरिटी बिट म्हणतात.

111
00:07:18,020 --> 00:07:21,980
आणि प्रत्यक्षात, आपण हे स्पष्ट केले पाहिजे, जर प्राप्तकर्त्याला विषम समता दिसली,

112
00:07:21,980 --> 00:07:25,941
तर याचा अर्थ फक्त एकच त्रुटी होती असे नाही, 3 त्रुटी, किंवा 5, किंवा इतर कोणतीही

113
00:07:25,941 --> 00:07:29,560
विषम संख्या असू शकते, परंतु ते निश्चितपणे जाणून घेऊ शकतात. की ते 0 नव्हते.

114
00:07:29,560 --> 00:07:34,181
दुसरीकडे, जर 2 चुका झाल्या असत्या, किंवा एररच्या संख्येची संख्या असती,

115
00:07:34,181 --> 00:07:38,608
तर 1s ची अंतिम गणना अजूनही सम असेल, त्यामुळे प्राप्तकर्त्याला पूर्ण

116
00:07:38,608 --> 00:07:43,360
विश्वास असू शकत नाही की सम गणनेचा अर्थ असा आहे की संदेश त्रुटी-मुक्त आहे.

117
00:07:43,360 --> 00:07:46,801
तुम्ही तक्रार करू शकता की फक्त 2 बिट फ्लिप्सने गोंधळलेला

118
00:07:46,801 --> 00:07:49,760
संदेश खूपच कमकुवत आहे आणि तुम्ही अगदी बरोबर असाल.

119
00:07:49,760 --> 00:07:54,568
लक्षात ठेवा, तथापि, त्रुटी शोधण्यासाठी किंवा दुरुस्त करण्याची कोणतीही पद्धत नाही जी

120
00:07:54,568 --> 00:07:59,720
तुम्हाला 100% आत्मविश्वास देऊ शकेल की तुम्हाला प्राप्त झालेला संदेश पाठवणाऱ्याचा हेतू आहे.

121
00:07:59,720 --> 00:08:03,022
शेवटी, पुरेसा यादृच्छिक आवाज नेहमीच एक वैध संदेश

122
00:08:03,022 --> 00:08:05,920
दुसर्‍या वैध संदेशात बदलू शकतो केवळ संधीने.

123
00:08:05,920 --> 00:08:11,053
त्याऐवजी, विशिष्ट जास्तीत जास्त त्रुटींपर्यंत मजबुत असलेली योजना आणणे

124
00:08:11,053 --> 00:08:16,480
किंवा यासारख्या चुकीच्या सकारात्मकतेची संभाव्यता कमी करणे हे उद्दिष्ट आहे.

125
00:08:16,480 --> 00:08:20,361
पॅरिटी चेक त्यांच्या स्वतःहून खूपच कमकुवत आहेत, परंतु संपूर्ण

126
00:08:20,361 --> 00:08:24,180
संदेशामध्ये बदलाची कल्पना एका क्षणापर्यंत पसरवून, ते आम्हाला

127
00:08:24,180 --> 00:08:28,000
अधिक अत्याधुनिक योजनांसाठी एक शक्तिशाली बिल्डिंग ब्लॉक देतात.

128
00:08:28,000 --> 00:08:32,576
उदाहरणार्थ, हॅमिंग एरर कुठे घडली हे ओळखण्याचा मार्ग शोधत होता, फक्त ती घडलीच

129
00:08:32,576 --> 00:08:37,390
नाही, तर त्याची मुख्य माहिती अशी होती की जर तुम्ही काही पॅरिटी चेक पूर्ण मेसेजवर

130
00:08:37,390 --> 00:08:41,966
लागू केले नाही तर काही काळजीपूर्वक निवडलेल्या उपसंचांना, तुम्ही विचारू शकता.

131
00:08:41,966 --> 00:08:46,840
प्रश्नांची अधिक परिष्कृत मालिका जी कोणत्याही एका बिट त्रुटीचे स्थान पिन डाउन करते.

132
00:08:46,840 --> 00:08:50,539
एकंदरीत भावना 20 प्रश्नांचा गेम खेळण्यासारखी आहे, होय किंवा

133
00:08:50,539 --> 00:08:54,300
नाही प्रश्न विचारणे ज्यामुळे शक्यतांची जागा अर्धी कापली जाते.

134
00:08:54,300 --> 00:08:57,548
उदाहरणार्थ, समजा की आम्ही फक्त या 8 बिट्सवर समता

135
00:08:57,548 --> 00:09:00,400
तपासणी करतो, सर्व विषम क्रमांकित स्थानांवर.

136
00:09:00,400 --> 00:09:04,878
नंतर एखादी त्रुटी आढळल्यास, ती प्राप्तकर्त्याला विशेषतः त्रुटी कुठे

137
00:09:04,878 --> 00:09:09,160
आहे याबद्दल थोडी अधिक माहिती देते, म्हणजे ती विचित्र स्थितीत आहे.

138
00:09:09,160 --> 00:09:13,301
जर त्या 8 बिट्समध्ये कोणतीही त्रुटी आढळली नाही, तर याचा अर्थ

139
00:09:13,301 --> 00:09:17,240
एकतर कोणतीही त्रुटी नाही किंवा ती कुठेतरी सम स्थितीत बसते.

140
00:09:17,240 --> 00:09:21,557
तुम्हाला असे वाटेल की समता तपासणी अर्ध्या बिट्सपर्यंत मर्यादित ठेवल्याने

141
00:09:21,557 --> 00:09:25,816
ते कमी प्रभावी होते, परंतु जेव्हा ते इतर योग्य-निवडलेल्या तपासण्यांच्या

142
00:09:25,816 --> 00:09:29,720
संयोगाने केले जाते, तेव्हा ते आम्हाला अधिक शक्तिशाली काहीतरी देते.

143
00:09:29,720 --> 00:09:33,434
ती पॅरिटी चेक प्रत्यक्षात सेट करण्यासाठी, लक्षात ठेवा, त्या पूर्ण

144
00:09:33,434 --> 00:09:37,600
गटाच्या समानतेसाठी नियंत्रण असलेले काही विशेष बिट निश्चित करणे आवश्यक आहे.

145
00:09:37,600 --> 00:09:39,920
येथे फक्त स्थान 1 निवडूया.

146
00:09:39,920 --> 00:09:44,010
दाखवलेल्या उदाहरणासाठी, या 8 बिट्सची पॅरिटी सध्या विषम आहे, त्यामुळे

147
00:09:44,010 --> 00:09:48,220
प्रेषक त्या पॅरिटी बिटला टॉगल करण्यासाठी जबाबदार आहे आणि आता ते सम आहे.

148
00:09:48,220 --> 00:09:51,040
हे 4 पैकी फक्त 1 पॅरिटी चेक आहे जे आम्ही करू.

149
00:09:51,040 --> 00:09:53,988
दुसरा चेक ग्रिडच्या उजव्या अर्ध्या भागावर असलेल्या

150
00:09:53,988 --> 00:09:56,880
8 बिट्समध्ये आहे, कमीतकमी आम्ही तो येथे काढला आहे.

151
00:09:56,880 --> 00:10:02,081
यावेळी आपण पॅरिटी बिट म्हणून पोझिशन 2 वापरू शकतो, त्यामुळे या 8 बिट्समध्ये आधीपासून

152
00:10:02,081 --> 00:10:07,160
सम पॅरिटी आहे आणि प्रेषकाला तो बिट क्रमांक 2 अपरिवर्तित ठेवल्यास चांगले वाटू शकते.

153
00:10:07,160 --> 00:10:11,720
मग दुसऱ्या टोकाला, जर प्राप्तकर्त्याने या गटाची समानता तपासली आणि त्यांना ते विचित्र

154
00:10:11,720 --> 00:10:15,960
असल्याचे आढळले, तर त्यांना कळेल की उजवीकडील या 8 बिट्समध्ये कुठेतरी त्रुटी आहे.

155
00:10:15,960 --> 00:10:21,260
अन्यथा याचा अर्थ एकतर कोणतीही त्रुटी नाही किंवा त्रुटी डाव्या अर्ध्या भागात कुठेतरी आहे.

156
00:10:21,260 --> 00:10:24,080
किंवा मला वाटते की दोन त्रुटी असू शकतात, परंतु आत्ता आम्ही असे

157
00:10:24,080 --> 00:10:27,080
गृहीत धरणार आहोत की संपूर्ण ब्लॉकमध्ये जास्तीत जास्त एक त्रुटी आहे.

158
00:10:27,080 --> 00:10:29,160
त्याहून अधिक गोष्टींसाठी गोष्टी पूर्णपणे खंडित होतात.

159
00:10:29,160 --> 00:10:32,499
येथे, आम्ही पुढील दोन तपासण्या पाहण्याआधी, जेव्हा तुम्ही त्यांचा एकत्रितपणे विचार

160
00:10:32,499 --> 00:10:35,880
करता तेव्हा हे पहिले दोन आम्हाला काय करू देतात याचा विचार करण्यासाठी थोडा वेळ द्या.

161
00:10:35,880 --> 00:10:40,240
समजा तुम्हाला विषम स्तंभांमध्ये आणि उजव्या अर्ध्यामध्ये त्रुटी आढळली आहे.

162
00:10:40,240 --> 00:10:43,940
याचा अर्थ शेवटच्या स्तंभात कुठेतरी त्रुटी आहे.

163
00:10:43,940 --> 00:10:47,184
विषम स्तंभामध्ये कोणतीही त्रुटी नसल्यास, परंतु उजव्या अर्ध्या भागात एक

164
00:10:47,184 --> 00:10:50,520
त्रुटी असल्यास, ते तुम्हाला सांगते की ते दुसऱ्या ते शेवटच्या स्तंभात आहे.

165
00:10:50,520 --> 00:10:53,495
त्याचप्रमाणे जर विषम स्तंभांमध्ये त्रुटी असेल परंतु उजव्या अर्ध्या

166
00:10:53,495 --> 00:10:56,560
भागात नसेल, तर तुम्हाला माहिती आहे की ती दुसऱ्या स्तंभात कुठेतरी आहे.

167
00:10:56,560 --> 00:11:00,187
आणि जर या दोन्ही पॅरिटी तपासण्यांपैकी काहीही आढळले नाही, तर याचा

168
00:11:00,187 --> 00:11:03,760
अर्थ एरर असू शकते अशी एकमेव जागा त्या सर्वात डाव्या स्तंभात आहे.

169
00:11:03,760 --> 00:11:06,480
परंतु याचा अर्थ असा असू शकतो की कोणतीही त्रुटी नाही.

170
00:11:06,480 --> 00:11:09,111
दोन पॅरिटी चेक आम्हाला कॉलम पिन डाउन करू द्या

171
00:11:09,111 --> 00:11:11,800
असे म्हणण्याचा हा सर्व काही उलगडलेला मार्ग आहे.

172
00:11:11,800 --> 00:11:14,000
येथून, आपण कदाचित पुढील काय अंदाज लावू शकता.

173
00:11:14,000 --> 00:11:16,240
आम्ही मुळात तेच करतो पण पंक्तींसाठी.

174
00:11:16,240 --> 00:11:21,040
पॅरिटी बिट म्हणून पोझिशन 4 वापरून विषम पंक्तींवर समता तपासणी केली जाईल.

175
00:11:21,040 --> 00:11:26,480
तर या उदाहरणात त्या गटात आधीपासून सम समता आहे, त्यामुळे बिट 4 0 वर सेट केला जाईल.

176
00:11:26,480 --> 00:11:32,280
आणि शेवटी पॅरिटी बिट म्हणून स्थान 8 वापरून तळाच्या दोन ओळींवर पॅरिटी चेक आहे.

177
00:11:32,280 --> 00:11:37,840
या प्रकरणात, असे दिसते की प्रेषकाने गटाला समानता देण्यासाठी ते बिट 8 चालू करणे आवश्यक आहे.

178
00:11:37,840 --> 00:11:40,441
ज्याप्रमाणे पहिल्या दोन तपासण्या आपल्याला स्तंभ खाली पिन करू

179
00:11:40,441 --> 00:11:43,000
देतात, त्याचप्रमाणे पुढील दोन आपल्याला पंक्ती पिन करू देतात.

180
00:11:43,000 --> 00:11:48,400
उदाहरण म्हणून, कल्पना करा की ट्रान्समिशन दरम्यान, स्थिती 3 वर एक त्रुटी आहे.

181
00:11:48,400 --> 00:11:52,394
बरं, हे पहिल्या पॅरिटी गटावर परिणाम करते, आणि ते दुसऱ्या पॅरिटी गटावर देखील परिणाम

182
00:11:52,394 --> 00:11:56,340
करते, म्हणून प्राप्तकर्त्याला माहित आहे की त्या उजव्या स्तंभात कुठेतरी त्रुटी आहे.

183
00:11:56,340 --> 00:12:01,380
परंतु त्याचा तिसऱ्या गटावर परिणाम होत नाही आणि चौथ्या गटावर त्याचा परिणाम होत नाही.

184
00:12:01,380 --> 00:12:04,885
आणि ते प्राप्तकर्त्याला पहिल्या पंक्तीपर्यंत त्रुटी दर्शवू देते,

185
00:12:04,885 --> 00:12:08,660
ज्याचा अर्थ स्थान 3 असणे आवश्यक आहे, जेणेकरून ते त्रुटी दूर करू शकतात.

186
00:12:08,660 --> 00:12:13,020
या चार प्रश्नांची उत्तरे तुम्हाला नेहमीच विशिष्ट स्थान पिन करू देतात हे

187
00:12:13,020 --> 00:12:17,320
पटवून देण्यासाठी तुम्हाला थोडा वेळ आनंद वाटेल, मग ते कुठेही असले तरीही.

188
00:12:17,320 --> 00:12:21,017
किंबहुना, तुमच्यातील चतुर लोकांना कदाचित या प्रश्नांचा

189
00:12:21,017 --> 00:12:23,640
आणि बायनरी मोजणीमधील संबंध लक्षात येईल.

190
00:12:23,640 --> 00:12:27,035
आणि जर तुम्ही असे केले तर, मी पुन्हा जोर देईन, विराम

191
00:12:27,035 --> 00:12:30,880
द्या, मी ते खराब करण्यापूर्वी कनेक्शन काढण्याचा प्रयत्न करा.

192
00:12:30,880 --> 00:12:33,746
जर तुम्ही विचार करत असाल की पॅरिटी बिट स्वतःच प्रभावित

193
00:12:33,746 --> 00:12:36,560
झाल्यास काय होईल, ठीक आहे, तुम्ही ते वापरून पाहू शकता.

194
00:12:36,560 --> 00:12:41,652
या चार विशेष बिट्समधील कोणतीही त्रुटी इतर कोणत्याही प्रमाणेच, चार

195
00:12:41,652 --> 00:12:47,440
प्रश्नांच्या समान गटासह कशी शोधली जाईल याचा विचार करण्यासाठी थोडा वेळ घ्या.

196
00:12:47,440 --> 00:12:50,514
याने काही फरक पडत नाही, कारण दिवसाच्या शेवटी आपल्याला संदेश

197
00:12:50,514 --> 00:12:53,640
बिट्सचे संरक्षण करायचे आहे, त्रुटी सुधारणे बिट्स सोबतच असतात.

198
00:12:53,640 --> 00:12:56,450
परंतु त्या बिट्सचे संरक्षण करणे ही अशी गोष्ट आहे जी

199
00:12:56,450 --> 00:12:59,260
नैसर्गिकरित्या उपउत्पादन म्हणून योजनेतून बाहेर पडते.

200
00:12:59,260 --> 00:13:02,380
हे प्रमाण कसे वाढेल याचा अंदाज लावण्याचा तुम्हाला आनंदही वाटेल.

201
00:13:02,380 --> 00:13:08,992
जर आम्ही 256 बिट आकाराचा ब्लॉक वापरला असेल, उदाहरणार्थ, एखादे स्थान पिन डाउन करण्यासाठी,

202
00:13:08,992 --> 00:13:15,680
तुम्हाला काही विशिष्ट ठिकाणी बायनरी शोधण्यासाठी फक्त आठ होय किंवा नाही प्रश्न आवश्यक आहेत.

203
00:13:15,680 --> 00:13:19,433
आणि लक्षात ठेवा, प्रत्येक प्रश्नासाठी योग्य समता

204
00:13:19,433 --> 00:13:23,340
तपासणी सेट करण्यासाठी फक्त एक बिट सोडणे आवश्यक आहे.

205
00:13:23,340 --> 00:13:26,718
तुमच्यापैकी काहींनी ते आधीच पाहिले असेल, परंतु हे प्रश्न काय आहेत ते फक्त

206
00:13:26,718 --> 00:13:29,960
एक किंवा दोन मिनिटांत शोधण्याच्या पद्धतशीर मार्गाबद्दल आम्ही नंतर बोलू.

207
00:13:29,960 --> 00:13:32,177
आशा आहे की आम्ही येथे जे विकसित करत आहोत त्याच्या

208
00:13:32,177 --> 00:13:34,440
कार्यक्षमतेचे कौतुक करण्यासाठी हे स्केच पुरेसे आहे.

209
00:13:34,440 --> 00:13:37,903
पहिली गोष्ट, त्या आठ हायलाइट केलेले पॅरिटी बिट्स

210
00:13:37,903 --> 00:13:41,720
वगळता, तुम्हाला हवे ते संदेश किंवा डेटा घेऊन जाऊ शकते.

211
00:13:41,720 --> 00:13:47,680
8 बिट या अर्थाने अनावश्यक आहेत की ते उर्वरित संदेशाद्वारे पूर्णपणे निर्धारित

212
00:13:47,680 --> 00:13:53,640
केले जातात, परंतु संपूर्ण संदेश कॉपी करण्यापेक्षा ते अधिक हुशार मार्गाने आहे.

213
00:13:53,640 --> 00:13:56,224
आणि तरीही, इतक्या कमी सोडल्याबद्दल, तुम्ही कोणतीही एक

214
00:13:56,224 --> 00:13:59,000
बिट त्रुटी ओळखण्यास आणि त्याचे निराकरण करण्यात सक्षम असाल.

215
00:13:59,000 --> 00:14:00,400
बरं, जवळजवळ.

216
00:14:00,400 --> 00:14:04,677
ठीक आहे, तर इथे एक अडचण अशी आहे की जर चार पॅरिटी तपासण्यांपैकी एकही

217
00:14:04,677 --> 00:14:09,017
त्रुटी आढळली नाही, म्हणजे 8 बिट्सच्या विशेष निवडलेल्या उपसमूहांमध्ये

218
00:14:09,017 --> 00:14:13,482
समान समानता आहेत, जसे की प्रेषकाने अभिप्रेत आहे, तर याचा अर्थ असा होतो

219
00:14:13,482 --> 00:14:17,760
की कोणतीही त्रुटी नव्हती. , किंवा ते आम्हाला स्थान 0 मध्ये कमी करते.

220
00:14:17,760 --> 00:14:22,859
तुम्ही पहा, चार होय किंवा नाही प्रश्नांसह, आमच्या समता तपासणीसाठी आमच्याकडे 16 संभाव्य

221
00:14:22,859 --> 00:14:27,959
परिणाम आहेत, आणि सुरुवातीला ब्लॉकमधील 16 पैकी 1 स्थान निश्चित करण्यासाठी योग्य वाटतात,

222
00:14:27,959 --> 00:14:33,000
परंतु तुम्हाला 17 व्या निकालाशी संवाद साधण्याची आवश्यकता आहे, कोणतीही त्रुटी नाही. अट.

223
00:14:33,000 --> 00:14:37,860
येथे उपाय प्रत्यक्षात खूपच सोपे आहे, फक्त त्या 0व्या बिटबद्दल पूर्णपणे विसरून जा.

224
00:14:37,860 --> 00:14:41,012
म्हणून जेव्हा आम्ही आमच्या चार समानता तपासतो आणि आम्ही पाहतो

225
00:14:41,012 --> 00:14:44,320
की ते सर्व समान आहेत, याचा अर्थ असा होतो की कोणतीही त्रुटी नाही.

226
00:14:44,320 --> 00:14:49,287
याचा अर्थ असा आहे की 16-बिट ब्लॉकसह काम करण्याऐवजी, आम्ही 15-बिट ब्लॉकसह कार्य करतो,

227
00:14:49,287 --> 00:14:54,080
जिथे 11 बिट संदेश घेऊन जाण्यासाठी विनामूल्य आहेत आणि त्यापैकी 4 रिडंडंसीसाठी आहेत.

228
00:14:54,080 --> 00:14:59,400
आणि त्यासह, आमच्याकडे आता व्यवसायातील लोक 15-11 हॅमिंग कोड म्हणून संबोधतात.

229
00:14:59,400 --> 00:15:04,053
ते म्हणाले, 2 ची क्लीन पॉवर असणारा ब्लॉक आकार असणे खूप छान आहे आणि एक चतुर मार्ग

230
00:15:04,053 --> 00:15:08,880
आहे ज्याने आपण तो 0 वा थोडा जवळ ठेवू शकतो आणि आपल्यासाठी थोडे अतिरिक्त काम करू शकतो.

231
00:15:08,880 --> 00:15:12,658
आम्ही संपूर्ण ब्लॉकमध्ये पॅरिटी बिट म्हणून याचा वापर केल्यास, ते

232
00:15:12,658 --> 00:15:16,320
आम्हाला 2-बिट त्रुटी सुधारू शकत नसले तरी प्रत्यक्षात शोधू देते.

233
00:15:16,320 --> 00:15:17,440
ते कसे कार्य करते ते येथे आहे.

234
00:15:17,440 --> 00:15:21,430
ते चार विशेष एरर-करेक्टिंग बिट्स सेट केल्यानंतर, आम्ही ते 0 वा सेट

235
00:15:21,430 --> 00:15:25,540
करतो जेणेकरून सामान्य पॅरिटी चेकप्रमाणे पूर्ण ब्लॉकची पॅरिटी सम असेल.

236
00:15:25,540 --> 00:15:29,772
आता, जर एक बिट एरर असेल, तर पूर्ण ब्लॉकची पॅरिटी विषम म्हणून टॉगल

237
00:15:29,772 --> 00:15:33,940
करते, परंतु तरीही आम्ही चार त्रुटी-सुधारित तपासण्यांमुळे ते पकडू.

238
00:15:33,940 --> 00:15:37,836
तथापि, जर दोन त्रुटी असतील, तर एकूण समानता पुन्हा सम वर टॉगल

239
00:15:37,836 --> 00:15:41,923
होणार आहे, परंतु प्राप्तकर्त्यास तरीही त्या चार पॅरिटी चेकमध्ये

240
00:15:41,923 --> 00:15:45,820
काय चालले आहे त्यामुळे किमान काही त्रुटी असल्याचे दिसून येईल.

241
00:15:45,820 --> 00:15:49,496
त्यामुळे जर त्यांना एकंदरीत सम समानता दिसली, परंतु इतर तपासण्यांमध्ये शून्य

242
00:15:49,496 --> 00:15:52,980
नसलेले काहीतरी घडत आहे, तर ते त्यांना सांगते की किमान दोन त्रुटी होत्या.

243
00:15:52,980 --> 00:15:54,420
हुशार नाही का?

244
00:15:54,420 --> 00:15:58,252
जरी आम्ही त्या 2-बिट चुका दुरुस्त करू शकत नसलो तरी, फक्त एक

245
00:15:58,252 --> 00:16:02,340
थोडा त्रासदायक 0 वी बिट कामावर ठेवून, ते आम्हाला त्या शोधू देते.

246
00:16:02,340 --> 00:16:06,540
हे खूपच मानक आहे, हे विस्तारित हॅमिंग कोड म्हणून ओळखले जाते.

247
00:16:06,540 --> 00:16:09,889
तांत्रिकदृष्ट्या बोलायचे झाल्यास, हॅमिंग कोड काय करतो याचे

248
00:16:09,889 --> 00:16:13,580
संपूर्ण वर्णन तुमच्याकडे आहे, किमान 16-बिट ब्लॉकच्या उदाहरणासाठी.

249
00:16:13,580 --> 00:16:17,755
परंतु मला वाटते की तुम्हाला तुमची समज तपासणे अधिक समाधानकारक वाटेल आणि सुरुवातीपासून

250
00:16:17,755 --> 00:16:21,980
ते स्वतःला पूर्ण करण्यापर्यंत एक पूर्ण उदाहरण देऊन या टप्प्यापर्यंत सर्व काही दृढ करा.

251
00:16:21,980 --> 00:16:25,100
तरीही मी तुमच्याबरोबर यातून मार्ग काढेन जेणेकरून तुम्ही स्वतःला तपासू शकता.

252
00:16:25,100 --> 00:16:28,707
संदेश सेट करण्‍यासाठी, मग तो तुम्‍ही जागेवर भाषांतरित करत असलेला

253
00:16:28,707 --> 00:16:32,370
शाब्दिक संदेश असो किंवा तुम्‍हाला कालांतराने संचयित करायचा असलेला

254
00:16:32,370 --> 00:16:35,700
काही डेटा असो, पहिली पायरी म्हणजे 11-बिट भागांमध्ये विभागणे.

255
00:16:35,700 --> 00:16:40,340
प्रत्येक भाग त्रुटी-प्रतिरोधक 16-बिट ब्लॉकमध्ये पॅकेज केला जाईल.

256
00:16:40,340 --> 00:16:43,740
चला तर मग हे एक उदाहरण म्हणून घेऊ आणि ते प्रत्यक्षात आणू.

257
00:16:43,740 --> 00:16:45,380
पुढे जा, प्रत्यक्षात ते करा!

258
00:16:45,380 --> 00:16:52,980
चला थांबा आणि हा ब्लॉक एकत्र ठेवण्याचा प्रयत्न करूया.

259
00:16:52,980 --> 00:16:53,980
ठीक आहे, तुम्ही तयार आहात?

260
00:16:53,980 --> 00:16:59,910
लक्षात ठेवा, स्थान 0 सोबत 2 च्या इतर शक्ती देखील त्रुटी दुरुस्ती कर्तव्यासाठी राखीव

261
00:16:59,910 --> 00:17:05,700
आहेत, म्हणून तुम्ही क्रमाने उर्वरित सर्व स्पॉट्समध्ये संदेश बिट ठेवून सुरुवात करा.

262
00:17:05,700 --> 00:17:09,393
तुम्‍हाला सम समता असण्‍यासाठी या गटाची आवश्‍यकता आहे, जी ते आधीपासून

263
00:17:09,393 --> 00:17:13,140
करत आहे, त्यामुळे तुम्‍ही ते पॅरिटी बिट स्‍थिती 1 मध्‍ये 0 असायला हवे.

264
00:17:13,140 --> 00:17:19,260
पुढचा गट विषम समतेने सुरू होतो, त्यामुळे तुम्ही त्याचा पॅरिटी बिट 1 वर सेट केला असावा.

265
00:17:19,260 --> 00:17:21,864
त्यानंतरचा गट विषम पॅरिटीने सुरू होतो, त्यामुळे

266
00:17:21,864 --> 00:17:24,740
तुम्ही पुन्हा त्याचे पॅरिटी बिट 1 वर सेट केले पाहिजे.

267
00:17:24,740 --> 00:17:28,120
आणि अंतिम गटामध्ये विषम समानता देखील आहे, म्हणजे

268
00:17:28,120 --> 00:17:31,500
आम्ही ती बिट स्थान 8 मध्ये 1 म्हणून सेट केली आहे.

269
00:17:31,500 --> 00:17:36,685
आणि मग अंतिम पायरी म्हणून, आता पूर्ण ब्लॉकमध्ये सम समानता आहे, म्हणजे

270
00:17:36,685 --> 00:17:41,500
तुम्ही तो बिट क्रमांक 0, ओव्हरचिंग पॅरिटी बिट, 0 वर सेट करू शकता.

271
00:17:41,500 --> 00:17:45,688
म्हणून हा ब्लॉक पाठवला जात असताना, चार विशेष उपसमूहांची

272
00:17:45,688 --> 00:17:48,980
समता आणि संपूर्ण ब्लॉक सर्व सम किंवा 0 असेल.

273
00:17:48,980 --> 00:17:53,620
व्यायामाचा दुसरा भाग म्हणून, आपण प्राप्तकर्त्याची भूमिका बजावूया.

274
00:17:53,620 --> 00:17:56,856
अर्थात, याचा अर्थ असा आहे की हा संदेश काय आहे हे तुम्हाला आधीच माहित नाही,

275
00:17:56,856 --> 00:18:00,180
कदाचित तुमच्यापैकी काहींनी तो लक्षात ठेवला असेल, परंतु समजू की तुम्हाला नाही.

276
00:18:00,180 --> 00:18:04,052
मी काय करणार आहे ते म्हणजे त्या ब्लॉकमधील ०, १, किंवा २

277
00:18:04,052 --> 00:18:08,340
बिट्स बदला, आणि मग मी काय केले ते शोधण्यासाठी तुम्हाला सांगेन.

278
00:18:08,340 --> 00:18:13,460
म्हणून पुन्हा, विराम द्या आणि प्रयत्न करा.

279
00:18:13,460 --> 00:18:21,592
ठीक आहे, म्हणून तुम्ही आता प्राप्तकर्ता म्हणून प्रथम पॅरिटी गट तपासा आणि तुम्ही ते सम

280
00:18:21,592 --> 00:18:29,820
आहे हे पाहू शकता, त्यामुळे अस्तित्वात असलेली कोणतीही त्रुटी सम स्तंभात असणे आवश्यक आहे.

281
00:18:29,820 --> 00:18:34,329
पुढील चेक आम्हाला एक विषम संख्या देतो, कमीतकमी एक त्रुटी

282
00:18:34,329 --> 00:18:38,760
असल्याचे सांगते आणि आम्हाला या विशिष्ट स्तंभात कमी करते.

283
00:18:38,760 --> 00:18:42,900
तिसरा चेक सम आहे, शक्यता कमी करून आणखी पुढे जाणे.

284
00:18:42,900 --> 00:18:47,241
आणि शेवटची पॅरिटी चेक विषम आहे, आम्हाला सांगते की तळाशी कुठेतरी एक त्रुटी

285
00:18:47,241 --> 00:18:51,700
आहे, जी आत्तापर्यंत आपण पाहू शकतो की स्थान क्रमांक 10 मध्ये असणे आवश्यक आहे.

286
00:18:51,700 --> 00:18:54,991
इतकेच काय, संपूर्ण ब्लॉकची समानता विषम आहे, ज्यामुळे

287
00:18:54,991 --> 00:18:58,220
आम्हाला विश्वास मिळतो की एक फ्लिप होता आणि दोन नाही.

288
00:18:58,220 --> 00:19:01,600
ते तीन किंवा अधिक असल्यास, सर्व बेट्स बंद आहेत.

289
00:19:01,600 --> 00:19:06,475
तो बिट क्रमांक 10 दुरुस्त केल्यानंतर, दुरुस्त्यासाठी न वापरलेले 11 बिट्स

290
00:19:06,475 --> 00:19:11,017
बाहेर काढल्याने आम्हाला मूळ संदेशाचा संबंधित विभाग मिळतो, जो तुम्ही

291
00:19:11,017 --> 00:19:16,160
रिवाइंड केला आणि तुलना केल्यास तेच खरे आहे ज्याने आम्ही उदाहरण सुरू केले आहे.

292
00:19:16,160 --> 00:19:20,146
आणि आता तुम्हाला हे सर्व हाताने कसे करायचे हे माहित आहे, मी तुम्हाला दाखवू इच्छितो

293
00:19:20,146 --> 00:19:23,940
की तुम्ही या सर्व तर्काचा मुख्य भाग पायथन कोडच्या एका ओळीने कसा पूर्ण करू शकता.

294
00:19:23,940 --> 00:19:29,016
तुम्ही पहा, हे अल्गोरिदम खरोखर किती मोहक आहे, एखादे मशीन मिळवणे किती सोपे

295
00:19:29,016 --> 00:19:33,955
आहे, ते पद्धतशीरपणे कसे मोजायचे आणि आम्ही सर्व कसे फ्रेम करू शकतो हे मी

296
00:19:33,955 --> 00:19:39,580
तुम्हाला सांगितले नाही. हे एकाधिक स्वतंत्र समानता तपासण्यांऐवजी एकच ऑपरेशन म्हणून.

297
00:19:39,580 --> 00:19:39,580
मला काय म्हणायचे आहे ते पाहण्यासाठी, माझ्यासोबत भाग २ मध्ये या.

