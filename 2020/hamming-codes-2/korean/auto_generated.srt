1
00:00:03,620 --> 00:00:06,801
CD나 DVD를 긁으면서도 저장되어 있는 내용을 

2
00:00:06,801 --> 00:00:10,100
재생할 수 있는 방법에 대해 궁금한 적이 있습니까?

3
00:00:10,900 --> 00:00:14,080
스크래치는 실제로 디스크의 1과 0에 영향을 

4
00:00:14,080 --> 00:00:17,643
미치므로 저장된 데이터와 다른 데이터를 읽습니다. 

5
00:00:17,643 --> 00:00:21,205
그러나 실제로 긁지 않는 한 읽은 비트는 인코딩된 

6
00:00:21,205 --> 00:00:24,132
것과 정확히 동일한 파일로 디코딩됩니다. 

7
00:00:24,132 --> 00:00:27,440
모든 오류에도 불구하고 비트 복사용 비트입니다.

8
00:00:27,440 --> 00:00:31,674
오류에 탄력적인 방식으로 데이터를 저장하고 데이터를 

9
00:00:31,674 --> 00:00:35,470
전송할 수 있게 해주는 수많은 수학적 영리함이 

10
00:00:35,470 --> 00:00:36,200
있습니다.

11
00:00:36,200 --> 00:00:38,630
글쎄요, 사실 이 일을 할 수 있는 방법을 찾는 

12
00:00:38,630 --> 00:00:40,880
데는 그렇게 많은 영리함이 필요하지 않습니다.

13
00:00:40,880 --> 00:00:44,750
비디오, 사운드, 텍스트, 일부 코드, 

14
00:00:44,750 --> 00:00:49,148
이미지 등 모든 파일은 궁극적으로 1과 0의 

15
00:00:49,148 --> 00:00:50,380
시퀀스입니다.

16
00:00:50,680 --> 00:00:53,394
그리고 뒤집힌 비트를 수정하는 간단한 전략은 

17
00:00:53,394 --> 00:00:56,000
각 비트의 복사본 3개를 저장하는 것입니다.

18
00:00:57,580 --> 00:00:59,768
그런 다음 이 파일을 읽는 기계는 이 세 개의 

19
00:00:59,768 --> 00:01:01,871
복사본을 비교하고 불일치가 있을 때마다 항상 

20
00:01:01,871 --> 00:01:04,060
3개 중 가장 좋은 2개를 선택할 수 있습니다.

21
00:01:07,160 --> 00:01:08,804
하지만 이는 공간의 2/3를 

22
00:01:08,804 --> 00:01:10,860
중복성을 위해 사용한다는 의미입니다.

23
00:01:11,480 --> 00:01:13,165
그리고 그럼에도 불구하고, 그 모든 공간이 

24
00:01:13,165 --> 00:01:15,062
포기되었음에도 불구하고, 한 비트 이상이 뒤집힐 

25
00:01:15,062 --> 00:01:16,888
경우 무슨 일이 일어날지에 대한 강력한 보장은 

26
00:01:16,888 --> 00:01:17,240
없습니다.

27
00:01:17,980 --> 00:01:20,841
훨씬 더 흥미로운 질문은 가능한 한 적은 공간을 

28
00:01:20,841 --> 00:01:24,020
포기하면서 오류를 수정할 수 있도록 만드는 방법입니다.

29
00:01:24,520 --> 00:01:27,390
예를 들어, 이 비디오에서 배우게 될 방법을 

30
00:01:27,390 --> 00:01:29,571
사용하면 각 블록이 9비트, 9! 

31
00:01:29,571 --> 00:01:32,556
를 사용하는 256비트 블록에 데이터를 저장할 

32
00:01:32,556 --> 00:01:33,360
수 있습니다.

33
00:01:33,760 --> 00:01:35,764
일종의 중복성 역할을 하며 나머지 

34
00:01:35,764 --> 00:01:38,084
247비트는 원하는 의미 있는 메시지나 

35
00:01:38,084 --> 00:01:40,300
데이터를 자유롭게 전달할 수 있습니다.

36
00:01:40,900 --> 00:01:43,681
그리고 여기서 비트가 반전되는 경우에도 

37
00:01:43,681 --> 00:01:46,463
이 블록만 보고 기계는 오류가 있었음을 

38
00:01:46,463 --> 00:01:49,245
식별하고 오류가 발생한 위치를 정확하게 

39
00:01:49,245 --> 00:01:52,660
식별하여 오류를 수정하는 방법을 알 수 있습니다.

40
00:01:52,660 --> 00:01:54,620
그리고 솔직히 그것은 마술처럼 느껴집니다.

41
00:01:55,440 --> 00:01:57,944
그리고 이 특정 방식의 경우 두 비트가 뒤집히면 

42
00:01:57,944 --> 00:02:00,355
컴퓨터는 적어도 두 개의 오류가 있음을 감지할 

43
00:02:00,355 --> 00:02:02,860
수 있지만 이를 수정하는 방법은 알 수 없습니다.

44
00:02:03,520 --> 00:02:05,044
다양한 크기의 블록에 대해 이것이 어떻게 

45
00:02:05,044 --> 00:02:06,900
확장되는지에 대해서는 나중에 조금 이야기하겠습니다.

46
00:02:07,860 --> 00:02:10,036
이와 같은 오류를 수정하는 방법은 

47
00:02:10,036 --> 00:02:12,900
합리적으로 오류 수정 코드로 알려져 있습니다.

48
00:02:13,660 --> 00:02:16,502
지난 세기 대부분 동안 이 분야는 우리가 

49
00:02:16,502 --> 00:02:19,097
매일 사용하는 장치에 통합되는 놀라울 

50
00:02:19,097 --> 00:02:21,940
정도로 심오한 수학의 풍부한 소스였습니다.

51
00:02:22,840 --> 00:02:25,653
여기서 목표는 해밍 코드(Hamming code)로 

52
00:02:25,653 --> 00:02:28,174
알려진 초기 예제 중 하나를 철저하게 이해하는 

53
00:02:28,174 --> 00:02:28,660
것입니다.

54
00:02:29,520 --> 00:02:32,260
그건 그렇고, 제가 이 영상의 구조에 대해 생각하는 

55
00:02:32,260 --> 00:02:35,000
방식은 가능한 한 직접적으로 설명하는 것이 아니라, 

56
00:02:35,000 --> 00:02:37,457
여기저기서 약간의 부드러운 안내를 받아 여러분 

57
00:02:37,457 --> 00:02:39,820
스스로 영상을 만들어내도록 유도하는 것입니다.

58
00:02:40,120 --> 00:02:42,268
따라서 어느 시점에서 그것이 어디로 가는지 알 수 

59
00:02:42,268 --> 00:02:44,494
있을 것 같으면 그 순간을 잠시 멈추고 내가 말하기 

60
00:02:44,494 --> 00:02:46,720
전에 그 계획이 어떻게 될지 적극적으로 예측하십시오.

61
00:02:47,240 --> 00:02:49,961
또한 하드웨어 수준까지 이해를 돕고 싶다면 

62
00:02:49,961 --> 00:02:52,683
Ben Eater가 이 영상과 함께 실제로 

63
00:02:52,683 --> 00:02:55,291
브레드보드에 해밍 코드를 구현하는 방법을 

64
00:02:55,291 --> 00:02:58,240
보여주는 영상을 제작했는데 매우 만족스럽습니다.

65
00:02:59,300 --> 00:03:02,104
해밍 코드는 Reed-Solomon 알고리즘과 

66
00:03:02,104 --> 00:03:04,693
같은 최신 코드만큼 널리 사용되지는 않지만 

67
00:03:04,693 --> 00:03:07,066
이 작업이 처음에는 얼마나 불가능하다고 

68
00:03:07,066 --> 00:03:09,763
느껴지는지와 일단 얼마나 합리적으로 보이는지 

69
00:03:09,763 --> 00:03:13,000
사이에는 어떤 마법이 있습니다. 해밍에 대해 배웁니다.

70
00:03:13,720 --> 00:03:16,453
오류 수정의 기본 원칙은 가능한 모든 

71
00:03:16,453 --> 00:03:19,056
메시지의 광대한 공간에서 일부 하위 

72
00:03:19,056 --> 00:03:22,180
집합만 유효한 메시지로 간주된다는 것입니다.

73
00:03:22,800 --> 00:03:24,870
비유하자면, 철자가 올바른 단어와 

74
00:03:24,870 --> 00:03:26,940
철자가 틀린 단어를 생각해 보세요.

75
00:03:28,900 --> 00:03:31,825
유효한 메시지가 변경될 때마다 수신자는 오타로 

76
00:03:31,825 --> 00:03:34,414
인해 발생할 수 있는 가장 가까운 유효한 

77
00:03:34,414 --> 00:03:37,340
이웃으로 보이는 내용을 수정할 책임이 있습니다.

78
00:03:38,220 --> 00:03:40,106
하지만 이와 같은 메시지를 효율적으로 

79
00:03:40,106 --> 00:03:41,813
분류하기 위한 구체적인 알고리즘을 

80
00:03:41,813 --> 00:03:44,060
생각해 내려면 어느 정도 영리함이 필요합니다.

81
00:03:46,780 --> 00:03:48,942
이야기는 젊은 Richard Hamming이 

82
00:03:48,942 --> 00:03:51,278
Bell Labs에서 일하고 있던 1940년대에 

83
00:03:51,278 --> 00:03:53,181
시작됩니다. 그의 작업 중 일부는 그가 

84
00:03:53,181 --> 00:03:55,170
접근할 수 없었던 매우 크고 값비싼 펀치 

85
00:03:55,170 --> 00:03:57,420
카드 컴퓨터를 사용하는 것과 관련이 있었습니다.

86
00:03:57,800 --> 00:03:59,749
그리고 그가 계속해서 적용한 프로그램은 계속 

87
00:03:59,749 --> 00:04:01,932
실패했습니다. 왜냐하면 때때로 약간의 오해가 있기 

88
00:04:01,932 --> 00:04:02,400
때문입니다.

89
00:04:03,120 --> 00:04:05,566
좌절은 발명의 도가니이기 때문에 그는 너무 

90
00:04:05,566 --> 00:04:08,420
지쳐서 세계 최초의 오류 정정 코드를 발명했습니다.

91
00:04:09,060 --> 00:04:11,232
Hamming 코드를 구성하는 방법에는 

92
00:04:11,232 --> 00:04:13,404
여러 가지가 있지만 먼저 Hamming 

93
00:04:13,404 --> 00:04:15,380
자신이 생각한 방식을 살펴보겠습니다.

94
00:04:16,519 --> 00:04:18,509
간단하지만 너무 단순하지는 않은 

95
00:04:18,509 --> 00:04:20,940
16비트 블록의 예를 사용해 보겠습니다.

96
00:04:21,820 --> 00:04:24,740
이 비트의 위치에 0부터 15까지 번호를 매깁니다.

97
00:04:25,620 --> 00:04:27,973
우리가 저장하려는 실제 데이터는 이러한 

98
00:04:27,973 --> 00:04:30,326
비트 중 12개만 구성할 예정이며 위치 

99
00:04:30,326 --> 00:04:33,000
중 4개는 일종의 중복으로 예약되어 있습니다.

100
00:04:33,900 --> 00:04:35,998
여기서 중복이라는 단어는 단순히 복사를 의미하는 

101
00:04:35,998 --> 00:04:37,863
것이 아닙니다. 결국 이 4비트는 데이터를 

102
00:04:37,863 --> 00:04:40,040
맹목적으로 복사할 충분한 공간을 제공하지 않습니다.

103
00:04:40,720 --> 00:04:42,802
대신, 새로운 정보를 추가하는 것이 

104
00:04:42,802 --> 00:04:44,780
아니라 탄력성을 추가하는 훨씬 더 

105
00:04:44,780 --> 00:04:47,280
미묘하고 영리한 종류의 중복성이 필요합니다.

106
00:04:48,600 --> 00:04:51,280
이 4개의 특수 비트가 끝 부분이나 그와 유사한 

107
00:04:51,280 --> 00:04:53,762
방식으로 함께 멋지게 패키지되어 있을 것으로 

108
00:04:53,762 --> 00:04:56,343
기대할 수 있지만, 보시다시피 2의 거듭제곱인 

109
00:04:56,343 --> 00:04:58,925
위치에 배치하면 마지막에는 정말 우아한 작업이 

110
00:04:58,925 --> 00:04:59,620
가능해집니다.

111
00:05:00,200 --> 00:05:01,669
또한 더 큰 블록에 대해 이것이 어떻게 

112
00:05:01,669 --> 00:05:03,540
확장되는지에 대한 약간의 힌트를 줄 수도 있습니다.

113
00:05:04,900 --> 00:05:07,655
또한 기술적으로는 단지 11비트의 데이터로 끝나므로 

114
00:05:07,655 --> 00:05:10,505
위치 0에서 일어나는 일에 약간의 차이가 있다는 것을 

115
00:05:10,505 --> 00:05:13,260
알 수 있지만 지금은 그것에 대해 걱정하지 마십시오.

116
00:05:14,140 --> 00:05:17,104
다른 오류 수정 알고리즘과 마찬가지로 여기에는 

117
00:05:17,104 --> 00:05:19,841
4개의 특수 비트 설정을 담당하는 송신자, 

118
00:05:19,841 --> 00:05:22,577
일종의 검사 수행 및 오류 수정을 담당하는 

119
00:05:22,577 --> 00:05:25,200
수신자라는 두 명의 플레이어가 참여합니다.

120
00:05:25,200 --> 00:05:27,536
물론, 보낸 사람과 받는 사람이라는 단어는 

121
00:05:27,536 --> 00:05:30,164
실제로 모든 확인을 수행하는 기계나 소프트웨어를 

122
00:05:30,164 --> 00:05:32,501
의미하며, 메시지라는 개념은 저장소와 같은 

123
00:05:32,501 --> 00:05:34,740
것을 포함하여 매우 광범위하게 의미됩니다.

124
00:05:35,340 --> 00:05:37,424
결국 데이터를 저장한다는 것은 한 장소에서 

125
00:05:37,424 --> 00:05:39,421
다른 장소로 메시지를 보내는 것이 아니라 

126
00:05:39,421 --> 00:05:41,680
과거에서 미래로 메시지를 보내는 것과 같습니다.

127
00:05:42,560 --> 00:05:45,346
이것이 설정입니다. 그러나 본격적으로 시작하기 전에 

128
00:05:45,346 --> 00:05:47,940
Hamming이 발견 당시 마음에 떠올랐던 관련 

129
00:05:47,940 --> 00:05:49,862
아이디어에 대해 이야기해야 합니다. 

130
00:05:49,862 --> 00:05:52,648
이 방법은 단일 비트 오류를 감지할 수 있지만 이를 

131
00:05:52,648 --> 00:05:55,339
수정하지는 않는 방법입니다. 비즈니스에서는 패리티 

132
00:05:55,339 --> 00:05:56,300
검사로 사용됩니다.

133
00:05:56,880 --> 00:05:58,983
패리티 검사를 위해 송신자가 튜닝을 

134
00:05:58,983 --> 00:06:01,086
담당하는 단일 비트 하나만 분리하고 

135
00:06:01,086 --> 00:06:03,820
나머지는 자유롭게 메시지를 전달할 수 있습니다.

136
00:06:04,880 --> 00:06:08,145
이 특수 비트의 유일한 역할은 메시지에 있는 

137
00:06:08,145 --> 00:06:11,280
1의 총 개수가 짝수인지 확인하는 것입니다.

138
00:06:12,080 --> 00:06:14,955
예를 들어 지금 당장 1의 총 개수는 7입니다. 

139
00:06:14,955 --> 00:06:17,297
홀수입니다. 따라서 송신자는 해당 특수 

140
00:06:17,297 --> 00:06:19,960
비트를 1로 뒤집어서 짝수로 만들어야 합니다.

141
00:06:20,800 --> 00:06:23,610
그러나 블록이 이미 짝수인 1로 시작했다면 

142
00:06:23,610 --> 00:06:26,420
이 특수 비트는 0으로 유지되었을 것입니다.

143
00:06:27,340 --> 00:06:29,776
이것은 매우 간단하고 믿을 수 없을 정도로 

144
00:06:29,776 --> 00:06:32,212
단순하지만 단일 정보에 반영되도록 메시지의 

145
00:06:32,212 --> 00:06:34,546
어느 위치에서나 변경 아이디어를 정제하는 

146
00:06:34,546 --> 00:06:36,780
믿을 수 없을 정도로 우아한 방법입니다.

147
00:06:37,500 --> 00:06:42,020
이 메시지의 비트가 0에서 1로 또는 1에서 0으로 

148
00:06:42,020 --> 00:06:46,540
반전되면 1의 총 개수가 짝수에서 홀수로 변경됩니다.

149
00:06:47,980 --> 00:06:51,100
따라서 수신자인 경우 이 메시지를 보고 홀수의 

150
00:06:51,100 --> 00:06:53,980
1이 표시되면 오류가 어디에 있었는지 전혀 

151
00:06:53,980 --> 00:06:57,460
모르더라도 오류가 발생했음을 확실히 알 수 있습니다.

152
00:06:58,500 --> 00:07:00,868
전문 용어로 비트 그룹에 짝수 또는 홀수 

153
00:07:00,868 --> 00:07:03,340
개의 1이 있는지 여부를 패리티라고 합니다.

154
00:07:04,860 --> 00:07:06,928
숫자를 사용하여 패리티가 0 또는 1이라고 

155
00:07:06,928 --> 00:07:08,737
말할 수도 있습니다. 이는 일반적으로 

156
00:07:08,737 --> 00:07:10,720
아이디어로 수학을 시작하면 더 유용합니다.

157
00:07:11,220 --> 00:07:13,150
그리고 송신자가 패리티를 제어하기 위해 

158
00:07:13,150 --> 00:07:15,520
사용하는 이 특수 비트를 패리티 비트라고 합니다.

159
00:07:17,560 --> 00:07:20,411
그리고 실제로, 수신자가 홀수 패리티를 본다고 해서 

160
00:07:20,411 --> 00:07:22,967
반드시 하나의 오류가 있었다는 의미는 아니며, 

161
00:07:22,967 --> 00:07:25,818
3개 또는 5개 또는 기타 홀수 오류가 있었을 수도 

162
00:07:25,818 --> 00:07:28,080
있지만 수신자는 확실히 알 수 있습니다. 

163
00:07:28,080 --> 00:07:29,260
0이 아니었다는 거죠.

164
00:07:29,980 --> 00:07:33,120
반면에 2개의 오류가 있거나 오류 수가 짝수인 

165
00:07:33,120 --> 00:07:35,898
경우 1의 최종 개수는 여전히 짝수이므로 

166
00:07:35,898 --> 00:07:38,918
수신자는 짝수 개수가 반드시 메시지에 오류가 

167
00:07:38,918 --> 00:07:42,300
없음을 의미한다는 완전한 확신을 가질 수 없습니다.

168
00:07:42,840 --> 00:07:44,795
당신은 단지 2비트 플립만으로 엉망이 

169
00:07:44,795 --> 00:07:47,124
된 메시지가 꽤 약하다고 불평할 수도 있고, 

170
00:07:47,124 --> 00:07:49,080
당신의 말이 절대적으로 옳을 것입니다.

171
00:07:49,700 --> 00:07:52,724
그러나 수신한 메시지가 보낸 사람이 의도한 

172
00:07:52,724 --> 00:07:55,623
메시지인지 100% 확신할 수 있는 오류 

173
00:07:55,623 --> 00:07:58,900
감지 또는 수정 방법은 없다는 점을 명심하세요.

174
00:07:59,580 --> 00:08:01,475
결국 충분한 무작위 노이즈로 인해 항상 

175
00:08:01,475 --> 00:08:03,285
하나의 유효한 메시지가 순전히 우연에 

176
00:08:03,285 --> 00:08:05,440
의해 다른 유효한 메시지로 바뀔 수 있습니다.

177
00:08:06,240 --> 00:08:10,505
대신 목표는 특정 최대 오류 수까지 견고한 체계를 

178
00:08:10,505 --> 00:08:14,618
마련하거나 이와 같은 거짓 긍정 가능성을 줄이는 

179
00:08:14,618 --> 00:08:15,380
것입니다.

180
00:08:16,260 --> 00:08:18,838
패리티 검사 자체는 매우 약하지만 전체 

181
00:08:18,838 --> 00:08:21,651
메시지에 대한 변경 아이디어를 단일 비트로 

182
00:08:21,651 --> 00:08:24,347
압축함으로써 우리에게 제공하는 것은 보다 

183
00:08:24,347 --> 00:08:27,160
정교한 체계를 위한 강력한 구성 요소입니다.

184
00:08:27,940 --> 00:08:30,326
예를 들어, Hamming은 오류가 발생한 

185
00:08:30,326 --> 00:08:32,912
위치뿐만 아니라 오류가 발생한 위치를 식별하는 

186
00:08:32,912 --> 00:08:35,498
방법을 찾고 있을 때 그의 핵심 통찰력은 전체 

187
00:08:35,498 --> 00:08:38,083
메시지가 아닌 일부 신중하게 선택된 특정 하위 

188
00:08:38,083 --> 00:08:40,470
집합에 일부 패리티 검사를 적용하면 다음과 

189
00:08:40,470 --> 00:08:42,359
같이 질문할 수 있다는 것입니다. 

190
00:08:42,359 --> 00:08:44,945
단일 비트 오류의 위치를 찾아내는 보다 세련된 

191
00:08:44,945 --> 00:08:45,940
일련의 질문입니다.

192
00:08:46,680 --> 00:08:48,881
전체적인 느낌은 가능성의 공간을 절반으로 

193
00:08:48,881 --> 00:08:51,274
줄이는 예 또는 아니오 질문을 하는 20개의 

194
00:08:51,274 --> 00:08:53,380
질문 게임을 하는 것과 약간 비슷합니다.

195
00:08:54,160 --> 00:08:56,523
예를 들어, 모든 홀수 위치인 이 8비트에 

196
00:08:56,523 --> 00:08:59,380
대해서만 패리티 검사를 수행한다고 가정해 보겠습니다.

197
00:09:00,100 --> 00:09:02,813
그런 다음 오류가 감지되면 수신자에게 오류가 

198
00:09:02,813 --> 00:09:05,526
구체적으로 어디에 있는지, 즉 오류가 이상한 

199
00:09:05,526 --> 00:09:08,240
위치에 있는지에 대한 추가 정보를 제공합니다.

200
00:09:08,940 --> 00:09:12,664
8비트 중에서 오류가 감지되지 않으면 오류가 

201
00:09:12,664 --> 00:09:16,240
전혀 없거나 짝수 위치에 있다는 의미입니다.

202
00:09:17,180 --> 00:09:19,550
패리티 검사를 비트의 절반으로 제한하면 

203
00:09:19,550 --> 00:09:22,028
효율성이 떨어진다고 생각할 수도 있지만, 

204
00:09:22,028 --> 00:09:24,290
잘 선택된 다른 검사와 함께 수행하면 

205
00:09:24,290 --> 00:09:27,200
직관에 반하여 훨씬 더 강력한 기능을 제공합니다.

206
00:09:29,240 --> 00:09:31,624
실제로 패리티 검사를 설정하려면 전체 

207
00:09:31,624 --> 00:09:34,008
그룹의 패리티를 제어할 수 있는 특수 

208
00:09:34,008 --> 00:09:36,620
비트를 지정해야 한다는 점을 기억하십시오.

209
00:09:37,480 --> 00:09:39,180
여기서는 위치 1을 선택하겠습니다.

210
00:09:39,720 --> 00:09:42,024
표시된 예에서 이 8비트의 패리티는 

211
00:09:42,024 --> 00:09:44,444
현재 홀수이므로 송신자가 해당 패리티 

212
00:09:44,444 --> 00:09:46,980
비트를 전환해야 하며 이제는 짝수입니다.

213
00:09:47,940 --> 00:09:49,229
이것은 우리가 수행할 패리티 

214
00:09:49,229 --> 00:09:50,680
검사 4개 중 1개에 불과합니다.

215
00:09:50,920 --> 00:09:53,609
두 번째 검사는 적어도 우리가 여기에 그린 것처럼 

216
00:09:53,609 --> 00:09:56,300
그리드의 오른쪽 절반에 있는 8비트 중 하나입니다.

217
00:09:56,680 --> 00:09:59,001
이번에는 위치 2를 패리티 비트로 사용할 수 

218
00:09:59,001 --> 00:10:01,137
있으므로 이 8비트는 이미 짝수 패리티를 

219
00:10:01,137 --> 00:10:03,552
가지며 송신자는 해당 비트 번호 2를 변경하지 

220
00:10:03,552 --> 00:10:06,060
않고 그대로 두는 것이 좋다고 느낄 수 있습니다.

221
00:10:07,020 --> 00:10:08,976
그런 다음 다른 쪽 끝에서 수신자가 이 

222
00:10:08,976 --> 00:10:11,111
그룹의 패리티를 확인하고 그것이 이상하다는 

223
00:10:11,111 --> 00:10:13,245
것을 발견하면 오류가 오른쪽에 있는 8비트 

224
00:10:13,245 --> 00:10:15,380
중 어딘가에 있다는 것을 알게 될 것입니다.

225
00:10:15,820 --> 00:10:18,325
그렇지 않으면 오류가 없거나 오류가 

226
00:10:18,325 --> 00:10:20,580
왼쪽 어딘가에 있음을 의미합니다.

227
00:10:21,120 --> 00:10:23,717
아니면 두 개의 오류가 있었을 수도 있지만 지금은 

228
00:10:23,717 --> 00:10:26,500
전체 블록에 최대 하나의 오류가 있다고 가정하겠습니다.

229
00:10:26,940 --> 00:10:28,740
그 이상으로 상황이 완전히 무너집니다.

230
00:10:29,160 --> 00:10:31,113
여기에서 다음 두 가지 확인 사항을 살펴보기 

231
00:10:31,113 --> 00:10:33,067
전에 처음 두 가지 확인 사항을 함께 고려할 

232
00:10:33,067 --> 00:10:35,100
때 무엇을 할 수 있는지 잠시 생각해 보십시오.

233
00:10:35,800 --> 00:10:37,628
홀수 열과 오른쪽 절반 사이에서 

234
00:10:37,628 --> 00:10:39,660
오류를 발견했다고 가정해 보겠습니다.

235
00:10:40,200 --> 00:10:41,708
이는 반드시 오류가 마지막 열 

236
00:10:41,708 --> 00:10:43,040
어딘가에 있음을 의미합니다.

237
00:10:43,820 --> 00:10:45,593
홀수 열에 오류가 없었지만 오른쪽 

238
00:10:45,593 --> 00:10:47,553
절반에 오류가 있는 경우 이는 마지막 

239
00:10:47,553 --> 00:10:49,700
열에서 두 번째에 있다는 것을 의미합니다.

240
00:10:50,440 --> 00:10:52,276
마찬가지로 홀수 열에는 오류가 있지만 

241
00:10:52,276 --> 00:10:54,199
오른쪽 절반에는 오류가 없으면 두 번째 

242
00:10:54,199 --> 00:10:56,560
열 어딘가에 오류가 있다는 것을 알 수 있습니다.

243
00:10:56,560 --> 00:10:58,864
그리고 두 패리티 검사 중 어느 것도 아무것도 

244
00:10:58,864 --> 00:11:01,081
감지하지 못하면 오류가 있을 수 있는 유일한 

245
00:11:01,081 --> 00:11:03,120
위치는 가장 왼쪽 열에 있다는 의미입니다.

246
00:11:03,340 --> 00:11:04,811
하지만 이는 단순히 오류가 전혀 

247
00:11:04,811 --> 00:11:06,120
없다는 의미일 수도 있습니다.

248
00:11:06,300 --> 00:11:08,338
이는 두 개의 패리티 검사를 통해 열을 

249
00:11:08,338 --> 00:11:10,840
고정할 수 있다고 말하는 다소 복잡한 방법입니다.

250
00:11:11,480 --> 00:11:13,640
여기에서 아마도 다음 내용을 추측할 수 있을 것입니다.

251
00:11:13,800 --> 00:11:15,262
기본적으로 동일한 작업을 수행하지만 

252
00:11:15,262 --> 00:11:16,140
행에 대해 수행합니다.

253
00:11:16,440 --> 00:11:18,776
위치 4를 패리티 비트로 사용하여 홀수 

254
00:11:18,776 --> 00:11:20,900
행에 대한 패리티 검사가 수행됩니다.

255
00:11:21,380 --> 00:11:23,511
따라서 이 예에서 해당 그룹에는 이미 짝수 

256
00:11:23,511 --> 00:11:25,820
패리티가 있으므로 비트 4는 0으로 설정됩니다.

257
00:11:26,560 --> 00:11:29,069
마지막으로 위치 8을 패리티 비트로 사용하여 

258
00:11:29,069 --> 00:11:31,580
아래쪽 두 행에 대한 패리티 검사가 있습니다.

259
00:11:32,120 --> 00:11:34,341
이 경우 그룹에 균등한 패리티를 제공하기 위해 

260
00:11:34,341 --> 00:11:36,820
발신자가 해당 비트 8을 켜야 하는 것처럼 보입니다.

261
00:11:37,700 --> 00:11:39,846
처음 두 검사를 통해 열을 고정할 수 있는 것처럼 

262
00:11:39,846 --> 00:11:41,840
다음 두 검사를 통해 행을 고정할 수 있습니다.

263
00:11:42,880 --> 00:11:45,272
예를 들어, 전송 중에 위치 3에 

264
00:11:45,272 --> 00:11:47,540
오류가 있다고 가정해 보겠습니다.

265
00:11:48,180 --> 00:11:50,402
글쎄, 이것은 첫 번째 패리티 그룹에 영향을 

266
00:11:50,402 --> 00:11:52,803
미치고 두 번째 패리티 그룹에도 영향을 미치므로 

267
00:11:52,803 --> 00:11:55,204
수신자는 오른쪽 열 어딘가에 오류가 있음을 알게 

268
00:11:55,204 --> 00:11:55,560
됩니다.

269
00:11:56,100 --> 00:11:58,461
하지만 세 번째 그룹에는 영향을 주지 않고, 

270
00:11:58,461 --> 00:12:00,540
네 번째 그룹에도 영향을 주지 않습니다.

271
00:12:01,240 --> 00:12:03,151
그리고 이를 통해 수신자는 위치 3을 

272
00:12:03,151 --> 00:12:05,153
의미하는 첫 번째 행까지 오류를 정확히 

273
00:12:05,153 --> 00:12:07,520
찾아낼 수 있으므로 오류를 수정할 수 있습니다.

274
00:12:08,580 --> 00:12:11,254
잠시 시간을 내어 이 네 가지 질문에 대한 답을 

275
00:12:11,254 --> 00:12:14,127
통해 그것이 어디에 있든 특정 위치를 정확히 찾아낼 

276
00:12:14,127 --> 00:12:17,100
수 있다는 점을 스스로 확신하는 것이 즐거울 것입니다.

277
00:12:17,720 --> 00:12:20,390
사실, 기민한 여러분은 이러한 질문과 이진수 

278
00:12:20,390 --> 00:12:23,060
계산 사이의 연관성을 알아차릴 수도 있습니다.

279
00:12:23,500 --> 00:12:25,306
만약 그렇다면 다시 한 번 강조하고, 

280
00:12:25,306 --> 00:12:27,113
잠시 멈춰서 제가 그것을 망치기 전에 

281
00:12:27,113 --> 00:12:28,920
스스로 연결점을 그려보도록 하겠습니다.

282
00:12:30,500 --> 00:12:33,280
패리티 비트 자체가 영향을 받으면 어떻게 

283
00:12:33,280 --> 00:12:36,060
되는지 궁금하다면 시도해 볼 수 있습니다.

284
00:12:36,440 --> 00:12:38,924
4개의 질문으로 구성된 동일한 그룹을 사용하여 

285
00:12:38,924 --> 00:12:41,313
이 4개의 특수 비트 중 오류가 다른 오류와 

286
00:12:41,313 --> 00:12:44,180
마찬가지로 어떻게 추적될 것인지 잠시 생각해 보십시오.

287
00:12:47,060 --> 00:12:48,985
결국 우리가 원하는 것은 메시지 비트를 

288
00:12:48,985 --> 00:12:50,999
보호하는 것이고 오류 수정 비트는 그대로 

289
00:12:50,999 --> 00:12:53,100
따라가기 때문에 실제로는 중요하지 않습니다.

290
00:12:53,600 --> 00:12:55,710
그러나 이러한 비트를 보호하는 것 역시 

291
00:12:55,710 --> 00:12:57,820
부산물로 자연스럽게 계획에서 제외됩니다.

292
00:12:59,200 --> 00:13:00,720
이것이 어떻게 확장되는지 기대하는 

293
00:13:00,720 --> 00:13:01,760
것도 재미있을 것입니다.

294
00:13:02,300 --> 00:13:05,835
예를 들어 위치를 파악하기 위해 256비트 크기의 

295
00:13:05,835 --> 00:13:09,118
블록을 사용한 경우 특정 지점까지 이진 검색을 

296
00:13:09,118 --> 00:13:12,780
수행하려면 8개의 예 또는 아니요 질문만 필요합니다.

297
00:13:15,640 --> 00:13:17,907
그리고 각 질문에는 적절한 패리티 검사를 설정하기 

298
00:13:17,907 --> 00:13:19,933
위해 단 하나의 비트만 포기해야 한다는 점을 

299
00:13:19,933 --> 00:13:20,500
기억하십시오.

300
00:13:23,160 --> 00:13:24,546
이미 보신 분들도 계시겠지만, 

301
00:13:24,546 --> 00:13:26,423
이러한 질문이 무엇인지 단 1~2분 만에 

302
00:13:26,423 --> 00:13:28,299
찾아낼 수 있는 체계적인 방법에 대해서는 

303
00:13:28,299 --> 00:13:29,360
나중에 이야기하겠습니다.

304
00:13:29,880 --> 00:13:31,605
이 스케치가 우리가 여기서 개발 중인 것의 

305
00:13:31,605 --> 00:13:33,260
효율성을 평가하는 데 충분하기를 바랍니다.

306
00:13:33,260 --> 00:13:36,074
강조 표시된 8개의 패리티 비트를 제외하고 

307
00:13:36,074 --> 00:13:38,771
첫 번째 항목은 원하는 메시지나 데이터를 

308
00:13:38,771 --> 00:13:41,820
전달하는 무엇이든 원하는 대로 될 수 있습니다.

309
00:13:41,820 --> 00:13:44,482
8비트는 메시지의 나머지 부분에 의해 완전히 

310
00:13:44,482 --> 00:13:47,038
결정된다는 점에서 중복되지만 단순히 메시지 

311
00:13:47,038 --> 00:13:50,020
전체를 복사하는 것보다 훨씬 더 현명한 방법입니다.

312
00:13:53,600 --> 00:13:56,035
그럼에도 불구하고 포기한 것이 거의 없기 때문에 

313
00:13:56,035 --> 00:13:58,380
단일 비트 오류를 식별하고 수정할 수 있습니다.

314
00:13:59,200 --> 00:14:00,400
글쎄, 거의.

315
00:14:00,960 --> 00:14:03,496
좋아요, 여기서 한 가지 문제는 4개의 패리티 

316
00:14:03,496 --> 00:14:06,422
검사 중 어느 것도 오류를 감지하지 못한다는 것입니다.

317
00:14:06,422 --> 00:14:09,056
 즉, 특별히 선택된 8비트의 하위 집합이 모두 

318
00:14:09,056 --> 00:14:11,299
짝수 패리티를 가지고 있다는 의미입니다. 

319
00:14:11,299 --> 00:14:13,738
보낸 사람이 의도한 것처럼 이는 오류가 전혀 

320
00:14:13,738 --> 00:14:16,372
없다는 의미입니다. , 또는 위치 0으로 범위를 

321
00:14:16,372 --> 00:14:16,860
좁힙니다.

322
00:14:17,740 --> 00:14:21,280
4개의 예 또는 아니오 질문으로 패리티 검사를 위한 

323
00:14:21,280 --> 00:14:24,942
16개의 가능한 결과가 있으며 처음에는 블록의 16개 

324
00:14:24,942 --> 00:14:28,482
위치 중 1개 위치를 정확히 찾아내는 데 완벽하다고 

325
00:14:28,482 --> 00:14:31,900
느껴지지만 17번째 결과도 전달해야 합니다. 상태.

326
00:14:33,020 --> 00:14:35,207
여기의 해결책은 실제로 매우 간단합니다. 

327
00:14:35,207 --> 00:14:37,300
0번째 비트를 완전히 잊어버리면 됩니다.

328
00:14:37,840 --> 00:14:40,650
따라서 4개의 패리티 검사를 수행하여 모두 

329
00:14:40,650 --> 00:14:43,460
짝수임을 확인하면 오류가 없음을 의미합니다.

330
00:14:44,240 --> 00:14:46,366
이것이 의미하는 바는 16비트 블록으로 작업하는 

331
00:14:46,366 --> 00:14:48,651
것이 아니라 15비트 블록으로 작업한다는 것입니다. 

332
00:14:48,651 --> 00:14:50,699
여기서 비트 중 11개는 메시지를 전달하는 데 

333
00:14:50,699 --> 00:14:52,747
자유롭게 사용되고 그 중 4개는 중복성을 위해 

334
00:14:52,747 --> 00:14:53,220
존재합니다.

335
00:14:53,780 --> 00:14:56,776
이제 우리는 업계 사람들이 15-11 

336
00:14:56,776 --> 00:15:00,200
해밍 코드라고 부르는 것을 갖게 되었습니다.

337
00:15:00,460 --> 00:15:03,111
즉, 2의 깨끗한 거듭제곱인 블록 크기를 갖는 것이 

338
00:15:03,111 --> 00:15:05,762
좋으며, 0번째 비트를 유지하고 약간의 추가 작업을 

339
00:15:05,762 --> 00:15:08,140
수행하도록 할 수 있는 영리한 방법이 있습니다.

340
00:15:08,700 --> 00:15:12,120
이를 전체 블록에 걸쳐 패리티 비트로 사용하면 수정할 

341
00:15:12,120 --> 00:15:15,540
수는 없지만 2비트 오류를 실제로 감지할 수 있습니다.

342
00:15:16,160 --> 00:15:16,820
작동 방식은 다음과 같습니다.

343
00:15:17,180 --> 00:15:19,528
4개의 특수 오류 수정 비트를 설정한 후 

344
00:15:19,528 --> 00:15:22,183
일반적인 패리티 검사와 마찬가지로 전체 블록의 

345
00:15:22,183 --> 00:15:24,940
패리티가 짝수가 되도록 0번째 비트를 설정합니다.

346
00:15:25,700 --> 00:15:28,228
이제 단일 비트 오류가 있으면 전체 블록의 

347
00:15:28,228 --> 00:15:30,966
패리티가 홀수로 전환되지만 네 가지 오류 수정 

348
00:15:30,966 --> 00:15:33,600
검사 덕분에 어쨌든 이를 포착할 수 있습니다.

349
00:15:34,160 --> 00:15:37,874
그러나 두 개의 오류가 있는 경우 전체 패리티는 다시 

350
00:15:37,874 --> 00:15:41,341
짝수로 전환되지만 수신자는 여전히 네 개의 패리티 

351
00:15:41,341 --> 00:15:44,560
검사로 인해 최소한 일부 오류가 있음을 알 수 

352
00:15:44,560 --> 00:15:45,180
있습니다.

353
00:15:45,180 --> 00:15:47,795
따라서 전체적으로 짝수 패리티를 발견했지만 

354
00:15:47,795 --> 00:15:50,193
다른 검사에서 0이 아닌 일이 발생하면 

355
00:15:50,193 --> 00:15:52,700
적어도 두 개의 오류가 있음을 알려줍니다.

356
00:15:53,520 --> 00:15:54,000
영리하지 않나요?

357
00:15:54,300 --> 00:15:56,366
이러한 2비트 오류를 수정할 수는 

358
00:15:56,366 --> 00:15:58,758
없지만 약간 귀찮은 0번째 비트를 다시 

359
00:15:58,758 --> 00:16:01,260
작동하게 하면 오류를 감지할 수 있습니다.

360
00:16:02,260 --> 00:16:03,413
이것은 매우 표준적인 것으로 확장된 해밍 

361
00:16:03,413 --> 00:16:04,768
코드(extended Hamming code)로 

362
00:16:04,768 --> 00:16:05,220
알려져 있습니다.

363
00:16:06,540 --> 00:16:08,745
기술적으로 말하자면, 이제 적어도 16비트 

364
00:16:08,745 --> 00:16:10,766
블록의 예에 대해 해밍 코드가 수행하는 

365
00:16:10,766 --> 00:16:12,880
작업에 대한 전체 설명을 갖게 되었습니다.

366
00:16:12,880 --> 00:16:15,659
하지만 처음부터 끝까지 하나의 전체 예제를 직접 

367
00:16:15,659 --> 00:16:18,335
수행하여 지금까지의 이해를 확인하고 모든 것을 

368
00:16:18,335 --> 00:16:21,320
확고히 하는 것이 더 만족스러울 것이라고 생각합니다.

369
00:16:22,080 --> 00:16:23,285
그래도 직접 확인해 볼 수 있도록 

370
00:16:23,285 --> 00:16:24,300
단계별로 안내해 드리겠습니다.

371
00:16:25,120 --> 00:16:28,194
공간을 통해 변환하는 문자 메시지이든 시간이 지남에 

372
00:16:28,194 --> 00:16:31,268
따라 저장하려는 일부 데이터이든 메시지를 설정하려면 

373
00:16:31,268 --> 00:16:34,130
첫 번째 단계는 메시지를 11비트 청크로 나누는 

374
00:16:34,130 --> 00:16:34,660
것입니다.

375
00:16:35,580 --> 00:16:39,760
각 청크는 오류 방지 16비트 블록으로 패키징됩니다.

376
00:16:39,760 --> 00:16:43,220
그럼 이것을 예로 들어 실제로 시도해 보겠습니다.

377
00:16:43,740 --> 00:16:44,740
어서, 실제로 해보세요!

378
00:16:44,740 --> 00:16:47,020
잠시 멈추고 이 블록을 조립해 봅시다.

379
00:16:52,720 --> 00:16:53,680
알았어, 준비됐어?

380
00:16:54,240 --> 00:16:57,193
2의 다른 거듭제곱과 함께 위치 0은 오류 수정 

381
00:16:57,193 --> 00:17:00,256
임무를 위해 예약되어 있으므로 나머지 모든 지점에 

382
00:17:00,256 --> 00:17:03,320
메시지 비트를 순서대로 배치하는 것부터 시작합니다.

383
00:17:05,339 --> 00:17:07,784
이 그룹에는 짝수 패리티가 필요합니다. 

384
00:17:07,784 --> 00:17:10,006
이미 그렇습니다. 따라서 위치 1의 

385
00:17:10,006 --> 00:17:12,339
패리티 비트를 0으로 설정해야 합니다.

386
00:17:13,020 --> 00:17:15,509
다음 그룹은 홀수 패리티로 시작하므로 

387
00:17:15,509 --> 00:17:17,880
패리티 비트를 1로 설정해야 합니다.

388
00:17:19,160 --> 00:17:21,754
그 이후의 그룹은 홀수 패리티로 시작하므로 

389
00:17:21,754 --> 00:17:24,240
다시 패리티 비트를 1로 설정해야 합니다.

390
00:17:24,780 --> 00:17:27,469
그리고 마지막 그룹에도 홀수 패리티가 있습니다. 

391
00:17:27,469 --> 00:17:30,060
즉, 위치 8의 해당 비트를 1로 설정했습니다.

392
00:17:31,300 --> 00:17:34,344
그런 다음 마지막 단계로 이제 전체 블록에 짝수 

393
00:17:34,344 --> 00:17:37,163
패리티가 있습니다. 즉, 가장 중요한 패리티 

394
00:17:37,163 --> 00:17:40,320
비트인 비트 번호 0을 0으로 설정할 수 있습니다.

395
00:17:41,340 --> 00:17:44,799
따라서 이 블록이 전송되면 4개의 특수 하위 집합과 

396
00:17:44,799 --> 00:17:48,140
블록 전체의 패리티는 모두 짝수 또는 0이 됩니다.

397
00:17:48,820 --> 00:17:50,420
연습의 두 번째 부분으로 여러분에게 

398
00:17:50,420 --> 00:17:52,180
수신자의 역할을 맡아 보도록 하겠습니다.

399
00:17:53,480 --> 00:17:55,440
물론, 그것은 여러분이 아직 이 메시지가 무엇인지 

400
00:17:55,440 --> 00:17:56,700
모른다는 것을 의미할 것입니다. 

401
00:17:56,700 --> 00:17:58,520
여러분 중 일부는 그것을 외웠을 수도 있지만, 

402
00:17:58,520 --> 00:17:59,780
암기하지 않았다고 가정해 봅시다.

403
00:18:00,020 --> 00:18:02,817
내가 하려는 일은 해당 블록의 비트 중 0, 

404
00:18:02,817 --> 00:18:05,390
1 또는 2를 변경한 다음 내가 한 일이 

405
00:18:05,390 --> 00:18:07,740
무엇인지 알아내도록 요청하는 것입니다.

406
00:18:08,260 --> 00:18:10,810
그러니 다시 잠시 멈춰서 시도해 보세요.

407
00:18:18,790 --> 00:18:21,646
좋아, 이제 수신자로서 첫 번째 패리티 그룹을 

408
00:18:21,646 --> 00:18:24,613
확인하면 그것이 짝수라는 것을 알 수 있습니다. 

409
00:18:24,613 --> 00:18:27,910
따라서 존재하는 모든 오류는 짝수 열에 있어야 합니다.

410
00:18:29,690 --> 00:18:33,097
다음 확인에서는 홀수를 제공하여 적어도 하나의 

411
00:18:33,097 --> 00:18:37,030
오류가 있음을 알려주고 이 특정 열로 범위를 좁힙니다.

412
00:18:38,550 --> 00:18:41,790
세 번째 확인은 균등하여 가능성을 더욱 줄입니다.

413
00:18:42,650 --> 00:18:44,551
그리고 마지막 패리티 검사는 홀수이며, 

414
00:18:44,551 --> 00:18:46,538
아래쪽 어딘가에 오류가 있음을 알려주며, 

415
00:18:46,538 --> 00:18:48,872
이제 우리는 이 오류가 위치 번호 10에 있음을 

416
00:18:48,872 --> 00:18:49,650
알 수 있습니다.

417
00:18:51,490 --> 00:18:54,626
게다가 전체 블록의 패리티가 홀수이므로 두 번이 

418
00:18:54,626 --> 00:18:57,530
아니라 한 번 뒤집혔다는 확신을 갖게 됩니다.

419
00:18:58,070 --> 00:18:59,970
3개 이상이면 모든 베팅이 취소됩니다.

420
00:19:01,310 --> 00:19:04,831
해당 비트 번호 10을 수정한 후 수정에 사용되지 

421
00:19:04,831 --> 00:19:07,850
않은 11비트를 꺼내면 원본 메시지의 관련 

422
00:19:07,850 --> 00:19:11,245
세그먼트가 제공됩니다. 되감아서 비교하면 실제로 

423
00:19:11,245 --> 00:19:14,390
우리가 예제를 시작한 것과 정확히 일치합니다.

424
00:19:15,710 --> 00:19:17,947
이제 이 모든 작업을 직접 수행하는 방법을 

425
00:19:17,947 --> 00:19:20,372
알았으므로 Python 코드 한 줄로 이 모든 

426
00:19:20,372 --> 00:19:23,170
논리의 핵심 부분을 수행하는 방법을 보여 드리겠습니다.

427
00:19:23,870 --> 00:19:26,101
내가 아직 말하지 않은 것은 이 알고리즘이 

428
00:19:26,101 --> 00:19:28,427
실제로 얼마나 우아한지, 기계가 오류 위치를 

429
00:19:28,427 --> 00:19:30,473
가리키도록 하는 것이 얼마나 간단한지, 

430
00:19:30,473 --> 00:19:32,611
체계적으로 오류의 크기를 조정하는 방법, 

431
00:19:32,611 --> 00:19:35,402
모든 것을 프레임으로 구성하는 방법에 대한 것입니다. 

432
00:19:35,402 --> 00:19:37,913
이는 여러 개의 개별 패리티 검사가 아닌 하나의 

433
00:19:37,913 --> 00:19:38,750
단일 작업입니다.

434
00:19:39,430 --> 00:19:41,310
무슨 뜻인지 보려면 2부에 참여하세요.

