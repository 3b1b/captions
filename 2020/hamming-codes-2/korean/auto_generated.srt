1
00:00:00,000 --> 00:00:10,900
CD나 DVD를 긁으면서도 저장되어 있는 내용을 재생할 수 있는 방법에 대해 궁금한 적이 있습니까?

2
00:00:10,900 --> 00:00:19,515
스크래치는 실제로 디스크의 1과 0에 영향을 미치므로 저장된 데이터와 다른 데이터를 읽습니다. 그러나 실제로 긁지

3
00:00:19,515 --> 00:00:28,400
않는 한 읽은 비트는 인코딩된 것과 정확히 동일한 파일로 디코딩됩니다. 모든 오류에도 불구하고 비트 복사용 비트입니다.

4
00:00:28,400 --> 00:00:36,840
오류에 탄력적인 방식으로 데이터를 저장하고 데이터를 전송할 수 있게 해주는 수많은 수학적 영리함이 있습니다.

5
00:00:36,840 --> 00:00:42,480
글쎄요, 사실 이 일을 할 수 있는 방법을 찾는 데는 그렇게 많은 영리함이 필요하지 않습니다.

6
00:00:42,480 --> 00:00:50,960
비디오, 사운드, 텍스트, 일부 코드, 이미지 등 모든 파일은 궁극적으로 1과 0의 시퀀스입니다.

7
00:00:50,960 --> 00:00:57,780
그리고 뒤집힌 비트를 수정하는 간단한 전략은 각 비트의 복사본 3개를 저장하는 것입니다.

8
00:00:57,780 --> 00:01:07,440
그런 다음 이 파일을 읽는 기계는 이 세 개의 복사본을 비교하고 불일치가 있을 때마다 항상 3개 중 가장 좋은 2개를 선택할 수 있습니다.

9
00:01:07,440 --> 00:01:11,560
하지만 이는 공간의 2/3를 중복성을 위해 사용한다는 의미입니다.

10
00:01:11,560 --> 00:01:18,120
그리고 그럼에도 불구하고, 그 모든 공간이 포기되었음에도 불구하고, 한 비트 이상이 뒤집힐 경우 무슨 일이 일어날지에 대한 강력한 보장은 없습니다.

11
00:01:18,120 --> 00:01:24,740
훨씬 더 흥미로운 질문은 가능한 한 적은 공간을 포기하면서 오류를 수정할 수 있도록 만드는 방법입니다.

12
00:01:24,740 --> 00:01:32,975
예를 들어, 이 비디오에서 배우게 될 방법을 사용하면 각 블록이 9비트, 9! 를 사용하는 256비트 블록에 데이터를 저장할 수 있습니다.

13
00:01:32,975 --> 00:01:41,000
일종의 중복성 역할을 하며 나머지 247비트는 원하는 의미 있는 메시지나 데이터를 자유롭게 전달할 수 있습니다.

14
00:01:41,000 --> 00:01:47,396
그리고 여기서 비트가 반전되는 경우에도 이 블록만 보고 기계는 오류가 있었음을 식별하고

15
00:01:47,396 --> 00:01:53,140
오류가 발생한 위치를 정확하게 식별하여 오류를 수정하는 방법을 알 수 있습니다.

16
00:01:53,140 --> 00:01:55,540
그리고 솔직히 그것은 마술처럼 느껴집니다.

17
00:01:55,540 --> 00:02:03,180
그리고 이 특정 방식의 경우 두 비트가 뒤집히면 컴퓨터는 적어도 두 개의 오류가 있음을 감지할 수 있지만 이를 수정하는 방법은 알 수 없습니다.

18
00:02:03,180 --> 00:02:08,140
다양한 크기의 블록에 대해 이것이 어떻게 확장되는지에 대해서는 나중에 조금 이야기하겠습니다.

19
00:02:08,140 --> 00:02:13,880
이와 같은 오류를 수정하는 방법은 합리적으로 오류 수정 코드로 알려져 있습니다.

20
00:02:13,880 --> 00:02:23,000
지난 세기 대부분 동안 이 분야는 우리가 매일 사용하는 장치에 통합되는 놀라울 정도로 심오한 수학의 풍부한 소스였습니다.

21
00:02:23,000 --> 00:02:29,660
여기서 목표는 해밍 코드(Hamming code)로 알려진 초기 예제 중 하나를 철저하게 이해하는 것입니다.

22
00:02:29,660 --> 00:02:34,794
그건 그렇고, 제가 이 영상의 구조에 대해 생각하는 방식은 가능한 한 직접적으로 설명하는 것이

23
00:02:34,794 --> 00:02:40,220
아니라, 여기저기서 약간의 부드러운 안내를 받아 여러분 스스로 영상을 만들어내도록 유도하는 것입니다.

24
00:02:40,220 --> 00:02:47,180
따라서 어느 시점에서 그것이 어디로 가는지 알 수 있을 것 같으면 그 순간을 잠시 멈추고 내가 말하기 전에 그 계획이 어떻게 될지 적극적으로 예측하십시오.

25
00:02:47,180 --> 00:02:53,286
또한 하드웨어 수준까지 이해를 돕고 싶다면 Ben Eater가 이 영상과 함께 실제로

26
00:02:53,286 --> 00:02:59,520
브레드보드에 해밍 코드를 구현하는 방법을 보여주는 영상을 제작했는데 매우 만족스럽습니다.

27
00:02:59,520 --> 00:03:06,590
해밍 코드는 Reed-Solomon 알고리즘과 같은 최신 코드만큼 널리 사용되지는 않지만 이 작업이 처음에는

28
00:03:06,590 --> 00:03:14,240
얼마나 불가능하다고 느껴지는지와 일단 얼마나 합리적으로 보이는지 사이에는 어떤 마법이 있습니다. 해밍에 대해 배웁니다.

29
00:03:14,240 --> 00:03:22,860
오류 수정의 기본 원칙은 가능한 모든 메시지의 광대한 공간에서 일부 하위 집합만 유효한 메시지로 간주된다는 것입니다.

30
00:03:22,860 --> 00:03:29,100
비유하자면, 철자가 올바른 단어와 철자가 틀린 단어를 생각해 보세요.

31
00:03:29,100 --> 00:03:38,380
유효한 메시지가 변경될 때마다 수신자는 오타로 인해 발생할 수 있는 가장 가까운 유효한 이웃으로 보이는 내용을 수정할 책임이 있습니다.

32
00:03:38,380 --> 00:03:47,160
하지만 이와 같은 메시지를 효율적으로 분류하기 위한 구체적인 알고리즘을 생각해 내려면 어느 정도 영리함이 필요합니다.

33
00:03:47,160 --> 00:03:52,331
이야기는 젊은 Richard Hamming이 Bell Labs에서 일하고 있던 1940년대에 시작됩니다. 그의

34
00:03:52,331 --> 00:03:57,420
작업 중 일부는 그가 접근할 수 없었던 매우 크고 값비싼 펀치 카드 컴퓨터를 사용하는 것과 관련이 있었습니다.

35
00:03:57,420 --> 00:04:03,140
그리고 그가 계속해서 적용한 프로그램은 계속 실패했습니다. 왜냐하면 때때로 약간의 오해가 있기 때문입니다.

36
00:04:03,140 --> 00:04:09,280
좌절은 발명의 도가니이기 때문에 그는 너무 지쳐서 세계 최초의 오류 정정 코드를 발명했습니다.

37
00:04:09,280 --> 00:04:16,620
Hamming 코드를 구성하는 방법에는 여러 가지가 있지만 먼저 Hamming 자신이 생각한 방식을 살펴보겠습니다.

38
00:04:16,620 --> 00:04:21,400
간단하지만 너무 단순하지는 않은 16비트 블록의 예를 사용해 보겠습니다.

39
00:04:21,400 --> 00:04:25,700
이 비트의 위치에 0부터 15까지 번호를 매깁니다.

40
00:04:25,700 --> 00:04:33,920
우리가 저장하려는 실제 데이터는 이러한 비트 중 12개만 구성할 예정이며 위치 중 4개는 일종의 중복으로 예약되어 있습니다.

41
00:04:33,920 --> 00:04:40,200
여기서 중복이라는 단어는 단순히 복사를 의미하는 것이 아닙니다. 결국 이 4비트는 데이터를 맹목적으로 복사할 충분한 공간을 제공하지 않습니다.

42
00:04:40,200 --> 00:04:48,740
대신, 새로운 정보를 추가하는 것이 아니라 탄력성을 추가하는 훨씬 더 미묘하고 영리한 종류의 중복성이 필요합니다.

43
00:04:48,740 --> 00:04:54,582
이 4개의 특수 비트가 끝 부분이나 그와 유사한 방식으로 함께 멋지게 패키지되어 있을 것으로 기대할

44
00:04:54,582 --> 00:05:00,320
수 있지만, 보시다시피 2의 거듭제곱인 위치에 배치하면 마지막에는 정말 우아한 작업이 가능해집니다.

45
00:05:00,320 --> 00:05:05,420
또한 더 큰 블록에 대해 이것이 어떻게 확장되는지에 대한 약간의 힌트를 줄 수도 있습니다.

46
00:05:05,420 --> 00:05:14,280
또한 기술적으로는 단지 11비트의 데이터로 끝나므로 위치 0에서 일어나는 일에 약간의 차이가 있다는 것을 알 수 있지만 지금은 그것에 대해 걱정하지 마십시오.

47
00:05:14,280 --> 00:05:20,506
다른 오류 수정 알고리즘과 마찬가지로 여기에는 4개의 특수 비트 설정을 담당하는 송신자,

48
00:05:20,506 --> 00:05:26,360
일종의 검사 수행 및 오류 수정을 담당하는 수신자라는 두 명의 플레이어가 참여합니다.

49
00:05:26,360 --> 00:05:31,106
물론, 보낸 사람과 받는 사람이라는 단어는 실제로 모든 확인을 수행하는 기계나 소프트웨어를

50
00:05:31,106 --> 00:05:35,480
의미하며, 메시지라는 개념은 저장소와 같은 것을 포함하여 매우 광범위하게 의미됩니다.

51
00:05:35,480 --> 00:05:42,640
결국 데이터를 저장한다는 것은 한 장소에서 다른 장소로 메시지를 보내는 것이 아니라 과거에서 미래로 메시지를 보내는 것과 같습니다.

52
00:05:42,640 --> 00:05:49,918
이것이 설정입니다. 그러나 본격적으로 시작하기 전에 Hamming이 발견 당시 마음에 떠올랐던 관련 아이디어에 대해 이야기해야

53
00:05:49,918 --> 00:05:57,300
합니다. 이 방법은 단일 비트 오류를 감지할 수 있지만 이를 수정하지는 않는 방법입니다. 비즈니스에서는 패리티 검사로 사용됩니다.

54
00:05:57,300 --> 00:06:04,940
패리티 검사를 위해 송신자가 튜닝을 담당하는 단일 비트 하나만 분리하고 나머지는 자유롭게 메시지를 전달할 수 있습니다.

55
00:06:04,940 --> 00:06:12,100
이 특수 비트의 유일한 역할은 메시지에 있는 1의 총 개수가 짝수인지 확인하는 것입니다.

56
00:06:12,100 --> 00:06:20,960
예를 들어 지금 당장 1의 총 개수는 7입니다. 홀수입니다. 따라서 송신자는 해당 특수 비트를 1로 뒤집어서 짝수로 만들어야 합니다.

57
00:06:20,960 --> 00:06:27,480
그러나 블록이 이미 짝수인 1로 시작했다면 이 특수 비트는 0으로 유지되었을 것입니다.

58
00:06:27,480 --> 00:06:32,785
이것은 매우 간단하고 믿을 수 없을 정도로 단순하지만 단일 정보에 반영되도록 메시지의

59
00:06:32,785 --> 00:06:37,760
어느 위치에서나 변경 아이디어를 정제하는 믿을 수 없을 정도로 우아한 방법입니다.

60
00:06:37,760 --> 00:06:48,140
이 메시지의 비트가 0에서 1로 또는 1에서 0으로 반전되면 1의 총 개수가 짝수에서 홀수로 변경됩니다.

61
00:06:48,140 --> 00:06:58,700
따라서 수신자인 경우 이 메시지를 보고 홀수의 1이 표시되면 오류가 어디에 있었는지 전혀 모르더라도 오류가 발생했음을 확실히 알 수 있습니다.

62
00:06:58,700 --> 00:07:04,940
전문 용어로 비트 그룹에 짝수 또는 홀수 개의 1이 있는지 여부를 패리티라고 합니다.

63
00:07:04,940 --> 00:07:11,320
숫자를 사용하여 패리티가 0 또는 1이라고 말할 수도 있습니다. 이는 일반적으로 아이디어로 수학을 시작하면 더 유용합니다.

64
00:07:11,320 --> 00:07:18,020
그리고 송신자가 패리티를 제어하기 위해 사용하는 이 특수 비트를 패리티 비트라고 합니다.

65
00:07:18,020 --> 00:07:23,644
그리고 실제로, 수신자가 홀수 패리티를 본다고 해서 반드시 하나의 오류가 있었다는 의미는 아니며, 3개

66
00:07:23,644 --> 00:07:29,560
또는 5개 또는 기타 홀수 오류가 있었을 수도 있지만 수신자는 확실히 알 수 있습니다. 0이 아니었다는 거죠.

67
00:07:29,560 --> 00:07:36,189
반면에 2개의 오류가 있거나 오류 수가 짝수인 경우 1의 최종 개수는 여전히 짝수이므로

68
00:07:36,189 --> 00:07:43,360
수신자는 짝수 개수가 반드시 메시지에 오류가 없음을 의미한다는 완전한 확신을 가질 수 없습니다.

69
00:07:43,360 --> 00:07:49,760
당신은 단지 2비트 플립만으로 엉망이 된 메시지가 꽤 약하다고 불평할 수도 있고, 당신의 말이 절대적으로 옳을 것입니다.

70
00:07:49,760 --> 00:07:59,720
그러나 수신한 메시지가 보낸 사람이 의도한 메시지인지 100% 확신할 수 있는 오류 감지 또는 수정 방법은 없다는 점을 명심하세요.

71
00:07:59,720 --> 00:08:05,920
결국 충분한 무작위 노이즈로 인해 항상 하나의 유효한 메시지가 순전히 우연에 의해 다른 유효한 메시지로 바뀔 수 있습니다.

72
00:08:05,920 --> 00:08:16,480
대신 목표는 특정 최대 오류 수까지 견고한 체계를 마련하거나 이와 같은 거짓 긍정 가능성을 줄이는 것입니다.

73
00:08:16,480 --> 00:08:22,178
패리티 검사 자체는 매우 약하지만 전체 메시지에 대한 변경 아이디어를 단일 비트로

74
00:08:22,178 --> 00:08:28,000
압축함으로써 우리에게 제공하는 것은 보다 정교한 체계를 위한 강력한 구성 요소입니다.

75
00:08:28,000 --> 00:08:34,245
예를 들어, Hamming은 오류가 발생한 위치뿐만 아니라 오류가 발생한 위치를 식별하는 방법을 찾고 있을

76
00:08:34,245 --> 00:08:40,698
때 그의 핵심 통찰력은 전체 메시지가 아닌 일부 신중하게 선택된 특정 하위 집합에 일부 패리티 검사를 적용하면

77
00:08:40,698 --> 00:08:46,840
다음과 같이 질문할 수 있다는 것입니다. 단일 비트 오류의 위치를 찾아내는 보다 세련된 일련의 질문입니다.

78
00:08:46,840 --> 00:08:54,300
전체적인 느낌은 가능성의 공간을 절반으로 줄이는 예 또는 아니오 질문을 하는 20개의 질문 게임을 하는 것과 약간 비슷합니다.

79
00:08:54,300 --> 00:09:00,400
예를 들어, 모든 홀수 위치인 이 8비트에 대해서만 패리티 검사를 수행한다고 가정해 보겠습니다.

80
00:09:00,400 --> 00:09:09,160
그런 다음 오류가 감지되면 수신자에게 오류가 구체적으로 어디에 있는지, 즉 오류가 이상한 위치에 있는지에 대한 추가 정보를 제공합니다.

81
00:09:09,160 --> 00:09:17,240
8비트 중에서 오류가 감지되지 않으면 오류가 전혀 없거나 짝수 위치에 있다는 의미입니다.

82
00:09:17,240 --> 00:09:23,547
패리티 검사를 비트의 절반으로 제한하면 효율성이 떨어진다고 생각할 수도 있지만, 잘

83
00:09:23,547 --> 00:09:29,720
선택된 다른 검사와 함께 수행하면 직관에 반하여 훨씬 더 강력한 기능을 제공합니다.

84
00:09:29,720 --> 00:09:37,600
실제로 패리티 검사를 설정하려면 전체 그룹의 패리티를 제어할 수 있는 특수 비트를 지정해야 한다는 점을 기억하십시오.

85
00:09:37,600 --> 00:09:39,920
여기서는 위치 1을 선택하겠습니다.

86
00:09:39,920 --> 00:09:48,220
표시된 예에서 이 8비트의 패리티는 현재 홀수이므로 송신자가 해당 패리티 비트를 전환해야 하며 이제는 짝수입니다.

87
00:09:48,220 --> 00:09:51,040
이것은 우리가 수행할 패리티 검사 4개 중 1개에 불과합니다.

88
00:09:51,040 --> 00:09:56,880
두 번째 검사는 적어도 우리가 여기에 그린 것처럼 그리드의 오른쪽 절반에 있는 8비트 중 하나입니다.

89
00:09:56,880 --> 00:10:01,765
이번에는 위치 2를 패리티 비트로 사용할 수 있으므로 이 8비트는 이미 짝수 패리티를

90
00:10:01,765 --> 00:10:07,160
가지며 송신자는 해당 비트 번호 2를 변경하지 않고 그대로 두는 것이 좋다고 느낄 수 있습니다.

91
00:10:07,160 --> 00:10:11,466
그런 다음 다른 쪽 끝에서 수신자가 이 그룹의 패리티를 확인하고 그것이 이상하다는

92
00:10:11,466 --> 00:10:15,960
것을 발견하면 오류가 오른쪽에 있는 8비트 중 어딘가에 있다는 것을 알게 될 것입니다.

93
00:10:15,960 --> 00:10:21,260
그렇지 않으면 오류가 없거나 오류가 왼쪽 어딘가에 있음을 의미합니다.

94
00:10:21,260 --> 00:10:27,080
아니면 두 개의 오류가 있었을 수도 있지만 지금은 전체 블록에 최대 하나의 오류가 있다고 가정하겠습니다.

95
00:10:27,080 --> 00:10:29,160
그 이상으로 상황이 완전히 무너집니다.

96
00:10:29,160 --> 00:10:35,880
여기에서 다음 두 가지 확인 사항을 살펴보기 전에 처음 두 가지 확인 사항을 함께 고려할 때 무엇을 할 수 있는지 잠시 생각해 보십시오.

97
00:10:35,880 --> 00:10:40,240
홀수 열과 오른쪽 절반 사이에서 오류를 발견했다고 가정해 보겠습니다.

98
00:10:40,240 --> 00:10:43,940
이는 반드시 오류가 마지막 열 어딘가에 있음을 의미합니다.

99
00:10:43,940 --> 00:10:50,520
홀수 열에 오류가 없었지만 오른쪽 절반에 오류가 있는 경우 이는 마지막 열에서 두 번째에 있다는 것을 의미합니다.

100
00:10:50,520 --> 00:10:56,560
마찬가지로 홀수 열에는 오류가 있지만 오른쪽 절반에는 오류가 없으면 두 번째 열 어딘가에 오류가 있다는 것을 알 수 있습니다.

101
00:10:56,560 --> 00:11:03,760
그리고 두 패리티 검사 중 어느 것도 아무것도 감지하지 못하면 오류가 있을 수 있는 유일한 위치는 가장 왼쪽 열에 있다는 의미입니다.

102
00:11:03,760 --> 00:11:06,480
하지만 이는 단순히 오류가 전혀 없다는 의미일 수도 있습니다.

103
00:11:06,480 --> 00:11:11,800
이는 두 개의 패리티 검사를 통해 열을 고정할 수 있다고 말하는 다소 복잡한 방법입니다.

104
00:11:11,800 --> 00:11:14,000
여기에서 아마도 다음 내용을 추측할 수 있을 것입니다.

105
00:11:14,000 --> 00:11:16,240
기본적으로 동일한 작업을 수행하지만 행에 대해 수행합니다.

106
00:11:16,240 --> 00:11:21,040
위치 4를 패리티 비트로 사용하여 홀수 행에 대한 패리티 검사가 수행됩니다.

107
00:11:21,040 --> 00:11:26,480
따라서 이 예에서 해당 그룹에는 이미 짝수 패리티가 있으므로 비트 4는 0으로 설정됩니다.

108
00:11:26,480 --> 00:11:32,280
마지막으로 위치 8을 패리티 비트로 사용하여 아래쪽 두 행에 대한 패리티 검사가 있습니다.

109
00:11:32,280 --> 00:11:37,840
이 경우 그룹에 균등한 패리티를 제공하기 위해 발신자가 해당 비트 8을 켜야 하는 것처럼 보입니다.

110
00:11:37,840 --> 00:11:43,000
처음 두 검사를 통해 열을 고정할 수 있는 것처럼 다음 두 검사를 통해 행을 고정할 수 있습니다.

111
00:11:43,000 --> 00:11:48,400
예를 들어, 전송 중에 위치 3에 오류가 있다고 가정해 보겠습니다.

112
00:11:48,400 --> 00:11:56,340
글쎄, 이것은 첫 번째 패리티 그룹에 영향을 미치고 두 번째 패리티 그룹에도 영향을 미치므로 수신자는 오른쪽 열 어딘가에 오류가 있음을 알게 됩니다.

113
00:11:56,340 --> 00:12:01,380
하지만 세 번째 그룹에는 영향을 주지 않고, 네 번째 그룹에도 영향을 주지 않습니다.

114
00:12:01,380 --> 00:12:08,660
그리고 이를 통해 수신자는 위치 3을 의미하는 첫 번째 행까지 오류를 정확히 찾아낼 수 있으므로 오류를 수정할 수 있습니다.

115
00:12:08,660 --> 00:12:17,320
잠시 시간을 내어 이 네 가지 질문에 대한 답을 통해 그것이 어디에 있든 특정 위치를 정확히 찾아낼 수 있다는 점을 스스로 확신하는 것이 즐거울 것입니다.

116
00:12:17,320 --> 00:12:23,640
사실, 기민한 여러분은 이러한 질문과 이진수 계산 사이의 연관성을 알아차릴 수도 있습니다.

117
00:12:23,640 --> 00:12:30,880
만약 그렇다면 다시 한 번 강조하고, 잠시 멈춰서 제가 그것을 망치기 전에 스스로 연결점을 그려보도록 하겠습니다.

118
00:12:30,880 --> 00:12:36,560
패리티 비트 자체가 영향을 받으면 어떻게 되는지 궁금하다면 시도해 볼 수 있습니다.

119
00:12:36,560 --> 00:12:47,440
4개의 질문으로 구성된 동일한 그룹을 사용하여 이 4개의 특수 비트 중 오류가 다른 오류와 마찬가지로 어떻게 추적될 것인지 잠시 생각해 보십시오.

120
00:12:47,440 --> 00:12:53,640
결국 우리가 원하는 것은 메시지 비트를 보호하는 것이고 오류 수정 비트는 그대로 따라가기 때문에 실제로는 중요하지 않습니다.

121
00:12:53,640 --> 00:12:59,260
그러나 이러한 비트를 보호하는 것 역시 부산물로 자연스럽게 계획에서 제외됩니다.

122
00:12:59,260 --> 00:13:02,380
이것이 어떻게 확장되는지 기대하는 것도 재미있을 것입니다.

123
00:13:02,380 --> 00:13:15,680
예를 들어 위치를 파악하기 위해 256비트 크기의 블록을 사용한 경우 특정 지점까지 이진 검색을 수행하려면 8개의 예 또는 아니요 질문만 필요합니다.

124
00:13:15,680 --> 00:13:23,340
그리고 각 질문에는 적절한 패리티 검사를 설정하기 위해 단 하나의 비트만 포기해야 한다는 점을 기억하십시오.

125
00:13:23,340 --> 00:13:29,960
이미 보신 분들도 계시겠지만, 이러한 질문이 무엇인지 단 1~2분 만에 찾아낼 수 있는 체계적인 방법에 대해서는 나중에 이야기하겠습니다.

126
00:13:29,960 --> 00:13:34,440
이 스케치가 우리가 여기서 개발 중인 것의 효율성을 평가하는 데 충분하기를 바랍니다.

127
00:13:34,440 --> 00:13:41,720
강조 표시된 8개의 패리티 비트를 제외하고 첫 번째 항목은 원하는 메시지나 데이터를 전달하는 무엇이든 원하는 대로 될 수 있습니다.

128
00:13:41,720 --> 00:13:53,640
8비트는 메시지의 나머지 부분에 의해 완전히 결정된다는 점에서 중복되지만 단순히 메시지 전체를 복사하는 것보다 훨씬 더 현명한 방법입니다.

129
00:13:53,640 --> 00:13:59,000
그럼에도 불구하고 포기한 것이 거의 없기 때문에 단일 비트 오류를 식별하고 수정할 수 있습니다.

130
00:13:59,000 --> 00:14:00,400
글쎄, 거의.

131
00:14:00,400 --> 00:14:08,920
좋아요, 여기서 한 가지 문제는 4개의 패리티 검사 중 어느 것도 오류를 감지하지 못한다는 것입니다. 즉, 특별히 선택된 8비트의 하위 집합이

132
00:14:08,920 --> 00:14:17,760
모두 짝수 패리티를 가지고 있다는 의미입니다. 보낸 사람이 의도한 것처럼 이는 오류가 전혀 없다는 의미입니다. , 또는 위치 0으로 범위를 좁힙니다.

133
00:14:17,760 --> 00:14:25,511
4개의 예 또는 아니오 질문으로 패리티 검사를 위한 16개의 가능한 결과가 있으며 처음에는 블록의 16개

134
00:14:25,511 --> 00:14:33,000
위치 중 1개 위치를 정확히 찾아내는 데 완벽하다고 느껴지지만 17번째 결과도 전달해야 합니다. 상태.

135
00:14:33,000 --> 00:14:37,860
여기의 해결책은 실제로 매우 간단합니다. 0번째 비트를 완전히 잊어버리면 됩니다.

136
00:14:37,860 --> 00:14:44,320
따라서 4개의 패리티 검사를 수행하여 모두 짝수임을 확인하면 오류가 없음을 의미합니다.

137
00:14:44,320 --> 00:14:49,114
이것이 의미하는 바는 16비트 블록으로 작업하는 것이 아니라 15비트 블록으로 작업한다는 것입니다.

138
00:14:49,114 --> 00:14:54,080
여기서 비트 중 11개는 메시지를 전달하는 데 자유롭게 사용되고 그 중 4개는 중복성을 위해 존재합니다.

139
00:14:54,080 --> 00:14:59,400
이제 우리는 업계 사람들이 15-11 해밍 코드라고 부르는 것을 갖게 되었습니다.

140
00:14:59,400 --> 00:15:08,880
즉, 2의 깨끗한 거듭제곱인 블록 크기를 갖는 것이 좋으며, 0번째 비트를 유지하고 약간의 추가 작업을 수행하도록 할 수 있는 영리한 방법이 있습니다.

141
00:15:08,880 --> 00:15:16,320
이를 전체 블록에 걸쳐 패리티 비트로 사용하면 수정할 수는 없지만 2비트 오류를 실제로 감지할 수 있습니다.

142
00:15:16,320 --> 00:15:17,440
작동 방식은 다음과 같습니다.

143
00:15:17,440 --> 00:15:25,540
4개의 특수 오류 수정 비트를 설정한 후 일반적인 패리티 검사와 마찬가지로 전체 블록의 패리티가 짝수가 되도록 0번째 비트를 설정합니다.

144
00:15:25,540 --> 00:15:33,940
이제 단일 비트 오류가 있으면 전체 블록의 패리티가 홀수로 전환되지만 네 가지 오류 수정 검사 덕분에 어쨌든 이를 포착할 수 있습니다.

145
00:15:33,940 --> 00:15:45,820
그러나 두 개의 오류가 있는 경우 전체 패리티는 다시 짝수로 전환되지만 수신자는 여전히 네 개의 패리티 검사로 인해 최소한 일부 오류가 있음을 알 수 있습니다.

146
00:15:45,820 --> 00:15:52,980
따라서 전체적으로 짝수 패리티를 발견했지만 다른 검사에서 0이 아닌 일이 발생하면 적어도 두 개의 오류가 있음을 알려줍니다.

147
00:15:52,980 --> 00:15:54,420
영리하지 않나요?

148
00:15:54,420 --> 00:16:02,340
이러한 2비트 오류를 수정할 수는 없지만 약간 귀찮은 0번째 비트를 다시 작동하게 하면 오류를 감지할 수 있습니다.

149
00:16:02,340 --> 00:16:06,540
이것은 매우 표준적인 것으로 확장된 해밍 코드(extended Hamming code)로 알려져 있습니다.

150
00:16:06,540 --> 00:16:13,580
기술적으로 말하자면, 이제 적어도 16비트 블록의 예에 대해 해밍 코드가 수행하는 작업에 대한 전체 설명을 갖게 되었습니다.

151
00:16:13,580 --> 00:16:21,980
하지만 처음부터 끝까지 하나의 전체 예제를 직접 수행하여 지금까지의 이해를 확인하고 모든 것을 확고히 하는 것이 더 만족스러울 것이라고 생각합니다.

152
00:16:21,980 --> 00:16:25,100
그래도 직접 확인해 볼 수 있도록 단계별로 안내해 드리겠습니다.

153
00:16:25,100 --> 00:16:35,700
공간을 통해 변환하는 문자 메시지이든 시간이 지남에 따라 저장하려는 일부 데이터이든 메시지를 설정하려면 첫 번째 단계는 메시지를 11비트 청크로 나누는 것입니다.

154
00:16:35,700 --> 00:16:40,340
각 청크는 오류 방지 16비트 블록으로 패키징됩니다.

155
00:16:40,340 --> 00:16:43,740
그럼 이것을 예로 들어 실제로 시도해 보겠습니다.

156
00:16:43,740 --> 00:16:45,380
어서, 실제로 해보세요!

157
00:16:45,380 --> 00:16:52,980
잠시 멈추고 이 블록을 조립해 봅시다.

158
00:16:52,980 --> 00:16:53,980
알았어, 준비됐어?

159
00:16:53,980 --> 00:17:05,700
2의 다른 거듭제곱과 함께 위치 0은 오류 수정 임무를 위해 예약되어 있으므로 나머지 모든 지점에 메시지 비트를 순서대로 배치하는 것부터 시작합니다.

160
00:17:05,700 --> 00:17:13,140
이 그룹에는 짝수 패리티가 필요합니다. 이미 그렇습니다. 따라서 위치 1의 패리티 비트를 0으로 설정해야 합니다.

161
00:17:13,140 --> 00:17:19,260
다음 그룹은 홀수 패리티로 시작하므로 패리티 비트를 1로 설정해야 합니다.

162
00:17:19,260 --> 00:17:24,740
그 이후의 그룹은 홀수 패리티로 시작하므로 다시 패리티 비트를 1로 설정해야 합니다.

163
00:17:24,740 --> 00:17:31,500
그리고 마지막 그룹에도 홀수 패리티가 있습니다. 즉, 위치 8의 해당 비트를 1로 설정했습니다.

164
00:17:31,500 --> 00:17:41,500
그런 다음 마지막 단계로 이제 전체 블록에 짝수 패리티가 있습니다. 즉, 가장 중요한 패리티 비트인 비트 번호 0을 0으로 설정할 수 있습니다.

165
00:17:41,500 --> 00:17:48,980
따라서 이 블록이 전송되면 4개의 특수 하위 집합과 블록 전체의 패리티는 모두 짝수 또는 0이 됩니다.

166
00:17:48,980 --> 00:17:53,620
연습의 두 번째 부분으로 여러분에게 수신자의 역할을 맡아 보도록 하겠습니다.

167
00:17:53,620 --> 00:18:00,180
물론, 그것은 여러분이 아직 이 메시지가 무엇인지 모른다는 것을 의미할 것입니다. 여러분 중 일부는 그것을 외웠을 수도 있지만, 암기하지 않았다고 가정해 봅시다.

168
00:18:00,180 --> 00:18:08,340
내가 하려는 일은 해당 블록의 비트 중 0, 1 또는 2를 변경한 다음 내가 한 일이 무엇인지 알아내도록 요청하는 것입니다.

169
00:18:08,340 --> 00:18:13,460
그러니 다시 잠시 멈춰서 시도해 보세요.

170
00:18:13,460 --> 00:18:29,820
좋아, 이제 수신자로서 첫 번째 패리티 그룹을 확인하면 그것이 짝수라는 것을 알 수 있습니다. 따라서 존재하는 모든 오류는 짝수 열에 있어야 합니다.

171
00:18:29,820 --> 00:18:38,760
다음 확인에서는 홀수를 제공하여 적어도 하나의 오류가 있음을 알려주고 이 특정 열로 범위를 좁힙니다.

172
00:18:38,760 --> 00:18:42,900
세 번째 확인은 균등하여 가능성을 더욱 줄입니다.

173
00:18:42,900 --> 00:18:51,700
그리고 마지막 패리티 검사는 홀수이며, 아래쪽 어딘가에 오류가 있음을 알려주며, 이제 우리는 이 오류가 위치 번호 10에 있음을 알 수 있습니다.

174
00:18:51,700 --> 00:18:58,220
게다가 전체 블록의 패리티가 홀수이므로 두 번이 아니라 한 번 뒤집혔다는 확신을 갖게 됩니다.

175
00:18:58,220 --> 00:19:01,600
3개 이상이면 모든 베팅이 취소됩니다.

176
00:19:01,600 --> 00:19:08,880
해당 비트 번호 10을 수정한 후 수정에 사용되지 않은 11비트를 꺼내면 원본 메시지의 관련

177
00:19:08,880 --> 00:19:16,160
세그먼트가 제공됩니다. 되감아서 비교하면 실제로 우리가 예제를 시작한 것과 정확히 일치합니다.

178
00:19:16,160 --> 00:19:23,940
이제 이 모든 작업을 직접 수행하는 방법을 알았으므로 Python 코드 한 줄로 이 모든 논리의 핵심 부분을 수행하는 방법을 보여 드리겠습니다.

179
00:19:23,940 --> 00:19:31,857
내가 아직 말하지 않은 것은 이 알고리즘이 실제로 얼마나 우아한지, 기계가 오류 위치를 가리키도록 하는 것이 얼마나 간단한지, 체계적으로 오류의

180
00:19:31,857 --> 00:19:39,580
크기를 조정하는 방법, 모든 것을 프레임으로 구성하는 방법에 대한 것입니다. 이는 여러 개의 개별 패리티 검사가 아닌 하나의 단일 작업입니다.

181
00:19:39,580 --> 00:19:39,580
무슨 뜻인지 보려면 2부에 참여하세요.

