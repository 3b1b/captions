1
00:00:00,000 --> 00:00:01,486
여기 계신 분들은 모두 1부에서 

2
00:00:01,486 --> 00:00:02,560
오신 분들인 것 같아요.

3
00:00:03,060 --> 00:00:06,217
우리는 대부분의 비트가 의미 있는 메시지를 전달하는 

4
00:00:06,217 --> 00:00:09,265
반면 다른 비트는 일종의 중복 역할을 하는 데이터 

5
00:00:09,265 --> 00:00:12,422
블록을 생성하는 방법인 해밍 코드에 대해 이야기하고 

6
00:00:12,422 --> 00:00:15,361
있었습니다. 비트 또는 중복 비트 등 이 블록에 

7
00:00:15,361 --> 00:00:18,191
있는 모든 항목을 통해 수신자는 오류가 있음을 

8
00:00:18,191 --> 00:00:21,240
식별하고 이를 수정하는 방법을 확인할 수 있습니다.

9
00:00:21,880 --> 00:00:24,617
거기에 제시된 기본 아이디어는 다중 패리티 검사를 

10
00:00:24,617 --> 00:00:27,160
사용하여 오류까지 이진 검색하는 방법이었습니다.

11
00:00:28,980 --> 00:00:31,790
해당 비디오의 목표는 Hamming 코드를 가능한 한 

12
00:00:31,790 --> 00:00:34,600
직접 사용하고 재발견할 수 있도록 만드는 것이었습니다.

13
00:00:35,180 --> 00:00:37,070
그러나 소프트웨어나 하드웨어에서 이를 

14
00:00:37,070 --> 00:00:39,320
실제로 구현하는 것에 대해 생각하기 시작하면 

15
00:00:39,320 --> 00:00:41,480
해당 프레임은 실제로 이러한 코드가 실제로 

16
00:00:41,480 --> 00:00:43,460
얼마나 우아한지 과소평가할 수 있습니다.

17
00:00:43,920 --> 00:00:47,142
가능한 모든 오류 위치를 추적하고 검사할 때마다 해당 

18
00:00:47,142 --> 00:00:50,150
그룹을 절반으로 줄이는 알고리즘을 작성해야 한다고 

19
00:00:50,150 --> 00:00:52,835
생각할 수도 있지만 실제로는 그보다 훨씬 더 

20
00:00:52,835 --> 00:00:53,480
간단합니다.

21
00:00:53,940 --> 00:00:57,440
지난 비디오에서 우리가 했던 네 가지 패리티 검사에 

22
00:00:57,440 --> 00:01:00,579
대한 답을 모두 예와 아니오 대신 1과 0으로 

23
00:01:00,579 --> 00:01:04,080
읽으면 문자 그대로 이진수로 오류 위치를 설명합니다.

24
00:01:04,780 --> 00:01:07,849
예를 들어, 이진수 7은 0111처럼 보입니다. 

25
00:01:07,849 --> 00:01:11,260
이는 본질적으로 4 더하기 2 더하기 1을 의미합니다.

26
00:01:12,540 --> 00:01:15,344
그리고 위치 7이 어디에 있는지 확인하세요. 

27
00:01:15,344 --> 00:01:18,037
이는 패리티 그룹 중 첫 번째, 두 번째, 

28
00:01:18,037 --> 00:01:21,179
세 번째에 영향을 주지만 마지막에는 영향을 미치지 

29
00:01:21,179 --> 00:01:21,740
않습니다.

30
00:01:22,220 --> 00:01:24,932
따라서 이 네 가지 검사 결과를 아래에서 위로 

31
00:01:24,932 --> 00:01:27,540
읽으면 실제로 오류의 위치를 알 수 있습니다.

32
00:01:28,320 --> 00:01:30,293
예제 7에는 특별한 것이 없습니다. 

33
00:01:30,293 --> 00:01:32,662
이는 일반적으로 작동하며 하드웨어에서 전체 

34
00:01:32,662 --> 00:01:35,326
구성표를 구현하는 논리를 놀라울 정도로 단순하게 

35
00:01:35,326 --> 00:01:35,820
만듭니다.

36
00:01:37,240 --> 00:01:40,101
이제 이 마법이 왜 일어나는지 알고 싶다면 

37
00:01:40,101 --> 00:01:43,440
위치에 대한 16개의 인덱스 레이블을 사용하세요. 

38
00:01:43,440 --> 00:01:46,302
단, 10진수로 작성하는 대신 0000부터 

39
00:01:46,302 --> 00:01:49,880
1111까지 실행되는 이진수로 모두 작성해 보겠습니다.

40
00:01:50,559 --> 00:01:53,862
이러한 바이너리 레이블을 상자에 다시 넣을 때 

41
00:01:53,862 --> 00:01:56,783
실제로 전송되는 데이터와 구별된다는 점을 

42
00:01:56,783 --> 00:01:57,800
강조하겠습니다.

43
00:01:58,320 --> 00:01:59,913
이는 여러분과 제가 네 개의 패리티 

44
00:01:59,913 --> 00:02:01,507
그룹이 어디에서 왔는지 이해하는 데 

45
00:02:01,507 --> 00:02:03,500
도움이 되는 개념적 레이블에 지나지 않습니다.

46
00:02:04,140 --> 00:02:06,751
우리가 보고 있는 모든 것을 이진법으로 기술하는 

47
00:02:06,751 --> 00:02:09,652
것의 우아함은 우리가 보고 있는 모든 것을 이진법으로 

48
00:02:09,652 --> 00:02:12,360
기술하는 것의 혼란으로 인해 약화될 수도 있습니다.

49
00:02:13,020 --> 00:02:14,120
그래도 그만한 가치가 있습니다.

50
00:02:14,800 --> 00:02:18,848
모든 레이블의 마지막 비트에만 주의를 집중한 

51
00:02:18,848 --> 00:02:23,220
다음 마지막 비트가 1인 위치를 강조 표시하세요.

52
00:02:24,240 --> 00:02:26,945
우리가 얻는 것은 네 개의 패리티 그룹 중 

53
00:02:26,945 --> 00:02:29,764
첫 번째입니다. 즉, 첫 번째 검사를 다음과 

54
00:02:29,764 --> 00:02:32,244
같이 묻는 것으로 해석할 수 있습니다. 

55
00:02:32,244 --> 00:02:35,176
오류가 있으면 해당 오류 위치의 마지막 비트가 

56
00:02:35,176 --> 00:02:35,740
1인가요?

57
00:02:38,200 --> 00:02:40,948
마찬가지로, 마지막 비트에서 두 번째 비트에 초점을 

58
00:02:40,948 --> 00:02:43,696
맞추고 해당 비트가 1인 모든 위치를 강조 표시하면 

59
00:02:43,696 --> 00:02:46,160
구성표에서 두 번째 패리티 그룹을 얻게 됩니다.

60
00:02:46,740 --> 00:02:48,809
즉, 두 번째 확인은 '안녕하세요, 

61
00:02:48,809 --> 00:02:51,223
다시 한 번 말씀드리지만, 오류가 있는 경우 해당 

62
00:02:51,223 --> 00:02:53,379
위치의 마지막에서 두 번째 비트가 1인가요? 

63
00:02:53,379 --> 00:02:54,500
'라고 묻습니다.

64
00:02:55,760 --> 00:02:56,900
등등.

65
00:02:57,220 --> 00:03:00,804
세 번째 패리티 검사는 마지막에서 세 번째 비트가 

66
00:03:00,804 --> 00:03:03,108
켜져 있는 모든 위치를 다루고, 

67
00:03:03,108 --> 00:03:06,692
마지막 패리티 검사는 가장 높은 순서 비트가 1인 

68
00:03:06,692 --> 00:03:08,740
마지막 8개 위치를 다룹니다.

69
00:03:09,740 --> 00:03:12,444
이전에 우리가 했던 모든 것은 이 네 가지 

70
00:03:12,444 --> 00:03:14,359
질문에 답하는 것과 동일하며, 

71
00:03:14,359 --> 00:03:17,740
이는 다시 이진법으로 위치를 철자하는 것과 동일합니다.

72
00:03:19,620 --> 00:03:21,480
이것이 두 가지를 더 명확하게 해주기를 바랍니다.

73
00:03:22,040 --> 00:03:24,198
첫 번째는 2의 거듭제곱보다 큰 블록 

74
00:03:24,198 --> 00:03:26,460
크기를 체계적으로 일반화하는 방법입니다.

75
00:03:26,960 --> 00:03:30,017
64개 지점을 설명하는 데 6비트가 필요한 것처럼 

76
00:03:30,017 --> 00:03:33,185
각 위치를 설명하는 데 더 많은 비트가 필요한 경우 

77
00:03:33,185 --> 00:03:36,024
각 비트는 확인해야 할 패리티 그룹 중 하나를 

78
00:03:36,024 --> 00:03:36,680
제공합니다.

79
00:03:38,400 --> 00:03:40,872
제가 Matt Parker와 함께 했던 체스판 퍼즐을 

80
00:03:40,872 --> 00:03:43,180
본 분들이라면 이 모든 것이 매우 익숙할 것입니다.

81
00:03:43,660 --> 00:03:46,157
동일한 핵심 논리이지만 다른 문제를 

82
00:03:46,157 --> 00:03:48,780
해결하고 64제곱 체스판에 적용됩니다.

83
00:03:49,880 --> 00:03:52,204
두 번째로 명확해지기를 바라는 것은 

84
00:03:52,204 --> 00:03:54,181
패리티 비트가 1, 2, 4, 

85
00:03:54,181 --> 00:03:57,320
8과 같이 2의 거듭제곱 위치에 있는 이유입니다.

86
00:03:58,000 --> 00:04:03,000
이는 이진 표현이 단일 비트만 켜져 있는 위치입니다.

87
00:04:03,600 --> 00:04:06,657
이는 각 패리티 비트가 4개의 패리티 그룹 

88
00:04:06,657 --> 00:04:09,460
중 하나에만 위치한다는 것을 의미합니다.

89
00:04:12,040 --> 00:04:14,194
얼마나 큰지 상관없이 각 패리티 

90
00:04:14,194 --> 00:04:16,467
비트가 그룹 중 하나에만 편리하게 

91
00:04:16,467 --> 00:04:19,339
닿는 더 큰 예에서도 이를 볼 수 있습니다.

92
00:04:25,600 --> 00:04:29,033
우리가 많은 시간을 투자해 온 이러한 패리티 검사가 

93
00:04:29,033 --> 00:04:32,229
오류의 위치를 바이너리로 설명하는 영리한 방법일 

94
00:04:32,229 --> 00:04:35,544
뿐이라는 점을 이해하면 해밍에 대해 생각하는 다른 

95
00:04:35,544 --> 00:04:37,912
방식으로 연결을 그릴 수 있습니다. 

96
00:04:37,912 --> 00:04:41,464
훨씬 더 간단하고 우아하며 기본적으로 한 줄의 코드로 

97
00:04:41,464 --> 00:04:43,240
작성할 수 있는 코드입니다.

98
00:04:43,660 --> 00:04:45,500
XOR 함수를 기반으로 합니다.

99
00:04:46,940 --> 00:04:48,729
XOR은 모르시는 분들을 위해 설명하자면, 

100
00:04:48,729 --> 00:04:50,220
Exclusive or의 약자입니다.

101
00:04:50,780 --> 00:04:53,640
두 비트의 XOR을 수행하면 해당 비트 중 

102
00:04:53,640 --> 00:04:56,500
하나가 켜져 있으면 1이 반환되지만 둘 다 

103
00:04:56,500 --> 00:04:59,360
켜져 있거나 꺼져 있으면 반환되지 않습니다.

104
00:05:00,100 --> 00:05:02,980
다르게 말하면, 이 두 비트의 패리티입니다.

105
00:05:03,540 --> 00:05:05,189
수학적인 사람으로서 나는 그것을 추가 

106
00:05:05,189 --> 00:05:06,760
모드 2로 생각하는 것을 선호합니다.

107
00:05:07,360 --> 00:05:09,525
또한 기본적으로 이 구성 요소를 구성 요소별로 

108
00:05:09,525 --> 00:05:11,524
수행하는 두 개의 서로 다른 비트 문자열의 

109
00:05:11,524 --> 00:05:13,440
XOR에 대해서도 일반적으로 이야기합니다.

110
00:05:13,680 --> 00:05:15,720
그것은 덧셈과 비슷하지만 결코 가지고 다니지 않습니다.

111
00:05:16,500 --> 00:05:18,519
다시 말하지만, 수학적으로 더 기울어진 사람은 

112
00:05:18,519 --> 00:05:20,383
이를 두 개의 벡터를 추가하고 mod 2를 

113
00:05:20,383 --> 00:05:22,480
줄이는 것으로 생각하는 것을 선호할 수 있습니다.

114
00:05:23,500 --> 00:05:26,606
지금 당장 Python을 열고 두 정수 사이에 

115
00:05:26,606 --> 00:05:29,833
캐럿 연산을 적용하면 이것이 수행되는 작업이지만 

116
00:05:29,833 --> 00:05:32,940
내부적으로 해당 숫자의 비트 표현이 수행됩니다.

117
00:05:34,960 --> 00:05:38,038
여러분과 저에게 중요한 점은 다양한 비트 

118
00:05:38,038 --> 00:05:40,715
문자열의 XOR을 취하는 것이 열의 

119
00:05:40,715 --> 00:05:43,659
경우와 같이 여러 개별 그룹의 패러디를 

120
00:05:43,659 --> 00:05:47,140
한꺼번에 계산하는 효과적인 방법이라는 것입니다.

121
00:05:51,260 --> 00:05:53,866
이는 해밍 코드 알고리즘의 다중 패리티 검사를 

122
00:05:53,866 --> 00:05:56,273
모두 하나의 단일 작업으로 함께 패키지하는 

123
00:05:56,273 --> 00:05:58,780
것으로 생각하는 다소 멋진 방법을 제공합니다.

124
00:05:59,479 --> 00:06:02,180
언뜻 보면 매우 달라 보이지만.

125
00:06:02,820 --> 00:06:06,505
이전처럼 16개 위치를 이진수로 구체적으로 

126
00:06:06,505 --> 00:06:09,883
기록하고 이제 메시지 비트가 1로 켜진 

127
00:06:09,883 --> 00:06:13,261
위치를 강조 표시한 다음 이러한 위치를 

128
00:06:13,261 --> 00:06:17,100
하나의 큰 열로 수집하고 XOR을 수행합니다.

129
00:06:19,260 --> 00:06:22,309
결과적으로 맨 아래에 있는 4비트는 우리가 알고 

130
00:06:22,309 --> 00:06:25,585
사랑하게 된 4개의 패리티 검사와 동일하다고 추측할 

131
00:06:25,585 --> 00:06:28,748
수 있지만 실제로 그 이유가 무엇인지 잠시 생각해 

132
00:06:28,748 --> 00:06:29,200
보세요.

133
00:06:32,220 --> 00:06:35,637
예를 들어 이 마지막 열은 마지막 비트가 1인 

134
00:06:35,637 --> 00:06:38,661
모든 위치를 계산하지만 이미 강조 표시된 

135
00:06:38,661 --> 00:06:41,816
위치로만 제한되어 있으므로 첫 번째 패리티 

136
00:06:41,816 --> 00:06:45,760
그룹에서 강조 표시된 위치 수를 효과적으로 계산합니다.

137
00:06:46,240 --> 00:06:46,800
말이 돼?

138
00:06:49,080 --> 00:06:52,590
마찬가지로 다음 열에서는 두 번째 패리티 그룹에 

139
00:06:52,590 --> 00:06:56,099
위치가 몇 개 있는지, 마지막 비트에서 두 번째 

140
00:06:56,099 --> 00:07:00,000
비트가 1이고 역시 강조 표시된 위치 등을 계산합니다.

141
00:07:00,260 --> 00:07:02,059
이는 우리가 해왔던 동일한 일에 

142
00:07:02,059 --> 00:07:03,960
대한 관점의 작은 변화일 뿐입니다.

143
00:07:07,760 --> 00:07:09,600
그래서 여기서부터 어디로 가는지 알 수 있습니다.

144
00:07:10,000 --> 00:07:12,745
보낸 사람은 합계가 0000이 되도록 특수 

145
00:07:12,745 --> 00:07:15,720
패리티 비트 중 일부를 전환할 책임이 있습니다.

146
00:07:15,720 --> 00:07:19,769
이제 이와 같은 결과가 나오면 하단에 있는 4개의 

147
00:07:19,769 --> 00:07:23,385
결과 비트가 오류 위치를 직접적으로 설명하는 

148
00:07:23,385 --> 00:07:27,580
이유를 생각할 수 있는 정말 좋은 방법을 제공합니다.

149
00:07:28,460 --> 00:07:30,065
이 블록의 일부 비트가 0에서 

150
00:07:30,065 --> 00:07:31,860
1로 전환된다고 가정해 보겠습니다.

151
00:07:32,600 --> 00:07:35,949
이는 해당 비트의 위치가 이제 전체 

152
00:07:35,949 --> 00:07:39,465
XOR에 포함되어 합계가 0에서 새로 

153
00:07:39,465 --> 00:07:43,820
포함된 값인 오류 위치로 변경된다는 의미입니다.

154
00:07:44,460 --> 00:07:46,696
약간 덜 명확하게 말하면 1을 0으로 

155
00:07:46,696 --> 00:07:49,360
변경하는 오류가 있는 경우에도 마찬가지입니다.

156
00:07:50,180 --> 00:07:52,379
알다시피, 비트 문자열을 두 번 더하면 

157
00:07:52,379 --> 00:07:54,280
거기에 전혀 없는 것과 같습니다. 

158
00:07:54,280 --> 00:07:56,580
기본적으로 이 세상에서는 1 더하기 1이 

159
00:07:56,580 --> 00:07:57,580
0이기 때문입니다.

160
00:07:57,580 --> 00:08:00,582
따라서 이 위치의 복사본을 총 합계에 

161
00:08:00,582 --> 00:08:04,300
추가하면 이동하는 것과 동일한 효과가 있습니다.

162
00:08:05,160 --> 00:08:07,736
그리고 그 효과는 여기 하단의 전체 

163
00:08:07,736 --> 00:08:10,700
결과가 오류의 위치를 설명한다는 것입니다.

164
00:08:13,039 --> 00:08:15,940
이것이 얼마나 우아한지 설명하기 위해 이전에 참조한 

165
00:08:15,940 --> 00:08:18,539
Python 코드 한 줄을 보여 드리겠습니다. 

166
00:08:18,539 --> 00:08:21,440
이 코드는 수신자 측의 거의 모든 논리를 캡처합니다.

167
00:08:22,080 --> 00:08:25,465
데이터 블록을 시뮬레이션하기 위해 16개의 1과 

168
00:08:25,465 --> 00:08:29,226
0으로 구성된 임의의 배열을 생성하는 것부터 시작하고 

169
00:08:29,226 --> 00:08:31,859
여기에 이름 비트를 부여할 것입니다. 

170
00:08:31,859 --> 00:08:35,244
무작위이므로 5개의 패리티 비트와 함께 11개의 

171
00:08:35,244 --> 00:08:37,000
데이터 비트를 전달합니다.

172
00:08:37,000 --> 00:08:40,285
enumerateBits 함수를 호출하면 

173
00:08:40,285 --> 00:08:43,857
각 비트를 해당 인덱스와 쌍으로 연결합니다. 

174
00:08:43,857 --> 00:08:47,000
이 경우에는 0에서 15까지 실행됩니다.

175
00:08:48,180 --> 00:08:51,501
그래서 우리가 이 모든 쌍, 즉 i처럼 보이는 

176
00:08:51,501 --> 00:08:54,951
쌍을 반복하는 목록을 생성하고 i 값만 추출하고 

177
00:08:54,951 --> 00:08:58,273
인덱스만 추출하면 그다지 흥미롭지는 않습니다. 

178
00:08:58,273 --> 00:09:01,340
0부터 15까지의 인덱스만 다시 가져옵니다.

179
00:09:01,680 --> 00:09:05,429
하지만 만약 비트인 경우에만 이 작업을 수행한다는 

180
00:09:05,429 --> 00:09:08,910
조건을 추가하면, 즉 해당 비트가 1이고 0이 

181
00:09:08,910 --> 00:09:12,660
아닌 경우 해당 비트가 켜져 있는 위치만 꺼냅니다.

182
00:09:13,380 --> 00:09:16,969
이 경우 해당 위치는 0, 4, 

183
00:09:16,969 --> 00:09:20,360
6, 9 등인 것처럼 보입니다.

184
00:09:20,720 --> 00:09:22,743
우리가 원하는 것은 모든 위치, 

185
00:09:22,743 --> 00:09:26,003
즉 켜져 있는 비트의 위치를 함께 수집한 다음 함께 

186
00:09:26,003 --> 00:09:27,240
XOR하는 것입니다.

187
00:09:29,180 --> 00:09:31,065
Python에서 이 작업을 수행하려면 

188
00:09:31,065 --> 00:09:33,220
먼저 몇 가지 유용한 함수를 가져오겠습니다.

189
00:09:33,900 --> 00:09:36,140
그런 식으로 우리는 이 목록에서 Reduce()를 

190
00:09:36,140 --> 00:09:38,300
호출하고 XOR 함수를 사용하여 목록을 줄일 수 

191
00:09:38,300 --> 00:09:38,700
있습니다.

192
00:09:39,100 --> 00:09:42,680
이것은 기본적으로 목록을 통해 XOR을 수행합니다.

193
00:09:44,800 --> 00:09:47,216
원하는 경우 XOR 함수를 어디에서든 가져올 

194
00:09:47,216 --> 00:09:49,440
필요 없이 명시적으로 작성할 수 있습니다.

195
00:09:51,940 --> 00:09:55,142
따라서 현재로서는 16비트의 무작위 블록에 

196
00:09:55,142 --> 00:09:57,810
대해 이 작업을 수행하면 이진 표현 

197
00:09:57,810 --> 00:10:01,280
1001을 갖는 9가 반환되는 것처럼 보입니다.

198
00:10:01,980 --> 00:10:04,460
여기서는 수행하지 않겠지만 송신자가 이진 

199
00:10:04,460 --> 00:10:07,048
표현을 사용하여 필요에 따라 4개의 패리티 

200
00:10:07,048 --> 00:10:09,744
비트를 설정하는 함수를 작성할 수 있습니다. 

201
00:10:09,744 --> 00:10:12,656
그러면 궁극적으로 이 블록을 전체 비트 목록에서 

202
00:10:12,656 --> 00:10:15,460
이 코드 줄을 실행하는 상태가 반환됩니다. 0.

203
00:10:16,080 --> 00:10:20,100
이는 잘 준비된 블록으로 간주됩니다.

204
00:10:20,100 --> 00:10:23,232
멋진 점은 이 목록의 비트 중 하나를 전환하여 

205
00:10:23,232 --> 00:10:26,726
노이즈로 인한 임의 오류를 시뮬레이션한 다음 동일한 

206
00:10:26,726 --> 00:10:30,220
코드 줄을 실행하면 해당 오류가 인쇄된다는 것입니다.

207
00:10:30,960 --> 00:10:31,520
깔끔하지 않나요?

208
00:10:31,820 --> 00:10:34,651
갑자기 이 블록을 가져와서 이 한 

209
00:10:34,651 --> 00:10:38,526
줄을 실행하면 오류 위치가 자동으로 표시되고, 

210
00:10:38,526 --> 00:10:41,060
오류가 없으면 0이 표시됩니다.

211
00:10:42,500 --> 00:10:44,840
그리고 사이즈 16에는 특별한 것이 없습니다.

212
00:10:44,840 --> 00:10:47,350
예를 들어 256비트 목록이 있는 

213
00:10:47,350 --> 00:10:49,860
경우 동일한 코드 줄이 작동합니다.

214
00:10:51,880 --> 00:10:54,182
말할 필요도 없이 여기에 작성해야 할 코드가 

215
00:10:54,182 --> 00:10:56,668
더 있습니다. 예를 들어 2비트 오류를 감지하기 

216
00:10:56,668 --> 00:10:58,971
위한 메타 패리티 검사를 수행하는 것입니다. 

217
00:10:58,971 --> 00:11:01,365
그러나 아이디어는 우리 체계의 거의 모든 핵심 

218
00:11:01,365 --> 00:11:03,760
논리가 단일 XOR 감소로 귀결된다는 것입니다.

219
00:11:06,120 --> 00:11:09,058
이제 바이너리, XOR 및 일반적인 소프트웨어에 

220
00:11:09,058 --> 00:11:12,215
대한 편안함에 따라 이 관점이 약간 혼란스러울 수도 

221
00:11:12,215 --> 00:11:15,372
있고 훨씬 더 우아하고 단순하여 왜 우리가 처음부터 

222
00:11:15,372 --> 00:11:18,420
시작하지 않았는지 궁금해할 수도 있습니다. -가다.

223
00:11:19,140 --> 00:11:21,761
대략적으로 말하면 다중 패리티 검사 관점은 

224
00:11:21,761 --> 00:11:24,273
하드웨어에서 해밍 코드를 직접 구현할 때 

225
00:11:24,273 --> 00:11:27,332
생각하기가 더 쉽고, XOR 관점은 소프트웨어에서 

226
00:11:27,332 --> 00:11:30,500
수행할 때 더 높은 수준에서 생각하기 가장 쉽습니다.

227
00:11:31,360 --> 00:11:34,466
첫 번째는 실제로 손으로 하는 것이 가장 쉽고, 

228
00:11:34,466 --> 00:11:37,573
이 모든 것의 기초가 되는 핵심 직관을 심어주는 

229
00:11:37,573 --> 00:11:40,219
것이 더 나은 일이라고 생각합니다. 즉, 

230
00:11:40,219 --> 00:11:43,326
단일 오류를 찾는 데 필요한 정보는 블록 크기의 

231
00:11:43,326 --> 00:11:45,742
로그와 관련이 있다는 것입니다. 즉, 

232
00:11:45,742 --> 00:11:48,849
블록 크기가 두 배로 증가함에 따라 한 번에 한 

233
00:11:48,849 --> 00:11:50,000
비트씩 증가합니다.

234
00:11:51,020 --> 00:11:53,430
여기서 관련 사실은 해당 정보가 필요한 

235
00:11:53,430 --> 00:11:56,060
중복 정도와 직접적으로 일치한다는 것입니다.

236
00:11:56,660 --> 00:11:59,063
이는 오류에 대해 탄력적인 메시지를 만드는 것에 

237
00:11:59,063 --> 00:12:01,377
대해 처음 생각할 때 대부분의 사람들이 무작정 

238
00:12:01,377 --> 00:12:03,068
반응하는 것과 반대되는 것입니다. 

239
00:12:03,068 --> 00:12:05,560
일반적으로 전체 메시지를 복사하는 것이 가장 먼저 

240
00:12:05,560 --> 00:12:06,540
떠오르는 본능입니다.

241
00:12:07,500 --> 00:12:10,425
그런데 때로는 해밍 코드가 표시되는 완전히 다른 

242
00:12:10,425 --> 00:12:13,458
방식이 있는데, 여기서 메시지에 하나의 큰 행렬을 

243
00:12:13,458 --> 00:12:14,000
곱합니다.

244
00:12:14,670 --> 00:12:16,949
더 넓은 범위의 선형 코드 제품군과 관련되어 

245
00:12:16,949 --> 00:12:19,047
있기 때문에 다소 좋지만, 그것이 어디서 

246
00:12:19,047 --> 00:12:20,962
왔는지 또는 어떻게 확장되는지에 대한 

247
00:12:20,962 --> 00:12:23,060
직관을 거의 제공하지 않는다고 생각합니다.

248
00:12:25,200 --> 00:12:28,073
확장에 관해 말하자면, 블록 크기를 늘릴수록 이 

249
00:12:28,073 --> 00:12:31,160
체계의 효율성이 더 좋아진다는 것을 알 수 있습니다.

250
00:12:35,000 --> 00:12:37,515
예를 들어, 256비트의 경우 중복성을 

251
00:12:37,515 --> 00:12:39,916
위해 해당 공간의 3%만 사용하고 그 

252
00:12:39,916 --> 00:12:42,660
이후로 점점 더 좋아지는 것을 확인했습니다.

253
00:12:43,300 --> 00:12:45,366
패리티 비트 수가 하나씩 증가함에 따라 

254
00:12:45,366 --> 00:12:47,340
블록 크기는 계속 두 배로 늘어납니다.

255
00:12:49,000 --> 00:12:51,204
그리고 이를 극단적으로 받아들인다면, 

256
00:12:51,204 --> 00:12:54,142
예를 들어 백만 비트의 블록을 가질 수 있습니다. 

257
00:12:54,142 --> 00:12:56,661
여기서 패리티 검사로 문자 그대로 20개의 

258
00:12:56,661 --> 00:12:59,600
질문을 플레이하고 21개의 패리티 비트만 사용하게 

259
00:12:59,600 --> 00:13:00,020
됩니다.

260
00:13:00,740 --> 00:13:02,846
그리고 한 걸음 물러서서 백만 개의 비트를 

261
00:13:02,846 --> 00:13:04,690
살펴보고 단일 오류를 찾는 것에 대해 

262
00:13:04,690 --> 00:13:07,060
생각한다면 그것은 정말로 미친 것처럼 느껴집니다.

263
00:13:08,199 --> 00:13:11,173
물론 문제는 블록이 클수록 비트 오류가 

264
00:13:11,173 --> 00:13:14,011
1~2개 이상 나올 확률이 높아지고, 

265
00:13:14,011 --> 00:13:17,660
해밍 코드는 그 이상은 처리하지 못한다는 점이다.

266
00:13:18,320 --> 00:13:20,056
따라서 실제로 원하는 것은 비트 

267
00:13:20,056 --> 00:13:22,081
플립이 너무 많이 발생할 확률이 너무 

268
00:13:22,081 --> 00:13:24,300
높지 않도록 올바른 크기를 찾는 것입니다.

269
00:13:26,600 --> 00:13:29,476
또한 실제로 오류는 작은 단위로 발생하는 경향이 있어 

270
00:13:29,476 --> 00:13:31,585
단일 블록을 완전히 망칠 수 있습니다. 

271
00:13:31,585 --> 00:13:34,461
따라서 여러 블록에 걸쳐 오류를 분산시키는 데 도움이 

272
00:13:34,461 --> 00:13:37,145
되는 일반적인 전술 중 하나는 해당 블록이 블록에 

273
00:13:37,145 --> 00:13:39,829
포함되기 전에 이와 같이 인터레이스하는 것입니다. 

274
00:13:39,829 --> 00:13:40,980
발송 또는 보관됩니다.

275
00:13:45,580 --> 00:13:48,038
그런 다음 다시 말하지만, 이 중 많은 부분은 

276
00:13:48,038 --> 00:13:50,592
버스트 오류를 특히 잘 처리하고 블록당 더 많은 

277
00:13:50,592 --> 00:13:53,145
수의 오류에 탄력적으로 조정될 수 있는 훨씬 더 

278
00:13:53,145 --> 00:13:55,982
일반적으로 사용되는 Reed-Solomon 알고리즘과 

279
00:13:55,982 --> 00:13:58,820
같은 최신 코드에 의해 완전히 논쟁의 여지가 있습니다.

280
00:13:59,360 --> 00:14:01,340
그러나 그것은 다른 시간에 다룰 주제입니다.

281
00:14:02,500 --> 00:14:04,413
Hamming은 자신의 저서 The Art of 

282
00:14:04,413 --> 00:14:05,688
Doing Science and 

283
00:14:05,688 --> 00:14:07,389
Engineering에서 자신이 발견한 이 

284
00:14:07,389 --> 00:14:09,160
코드가 얼마나 의미심장한 일이었는지 놀랍도록 

285
00:14:09,160 --> 00:14:09,940
솔직하게 밝혔습니다.

286
00:14:10,620 --> 00:14:13,163
그는 먼저 비트를 더 높은 차원의 격자 부분으로 

287
00:14:13,163 --> 00:14:15,707
구성하는 것과 이와 같은 이상한 것들을 포함하는 

288
00:14:15,707 --> 00:14:17,780
모든 종류의 다양한 계획을 시도했습니다.

289
00:14:18,300 --> 00:14:20,286
오류의 위치를 명시하는 방식으로 패리티 검사를 

290
00:14:20,286 --> 00:14:22,350
공모하여 음모를 꾸미는 것이 가능할 수도 있다는 

291
00:14:22,350 --> 00:14:24,489
생각은 Hamming이 여러 가지 다른 분석을 한 

292
00:14:24,489 --> 00:14:26,400
후 한 걸음 물러나서 &quot;알겠습니다. 

293
00:14:26,400 --> 00:14:28,616
제가 할 수 있는 가장 효율적인 방법은 무엇입니까? 

294
00:14:28,616 --> 00:14:30,297
&quot;라고 물었을 때부터였습니다. 

295
00:14:30,297 --> 00:14:31,520
아마도 이것에 관한 것입니까?

296
00:14:32,620 --> 00:14:35,220
그는 또한 패리티 검사가 이미 그의 마음 속에 

297
00:14:35,220 --> 00:14:38,020
있다는 것이 얼마나 중요한지 솔직하게 말했습니다. 

298
00:14:38,020 --> 00:14:40,720
1940년대에는 오늘날보다 훨씬 덜 일반적이었을 

299
00:14:40,720 --> 00:14:41,220
것입니다.

300
00:14:41,920 --> 00:14:45,123
이 책 전체에 걸쳐 그는 루이 파스퇴르의 명언을 여섯 

301
00:14:45,123 --> 00:14:48,220
번이나 언급합니다. 행운은 준비된 마음을 선호합니다.

302
00:14:49,320 --> 00:14:51,810
영리한 아이디어는 돌이켜보면 믿을 수 없을 만큼 

303
00:14:51,810 --> 00:14:54,300
단순해 보이는 경우가 많아 과소평가되기 쉽습니다.

304
00:14:54,960 --> 00:14:57,040
지금 당장은 해밍 코드, 또는 적어도 

305
00:14:57,040 --> 00:14:59,219
그러한 코드의 가능성이 여러분에게 거의 

306
00:14:59,219 --> 00:15:01,300
명백하게 느껴지기를 진심으로 바랍니다.

307
00:15:01,660 --> 00:15:03,101
하지만 그것들이 실제로 명백하다고 

308
00:15:03,101 --> 00:15:04,771
생각하도록 자신을 속여서는 안 됩니다. 

309
00:15:04,771 --> 00:15:06,820
왜냐하면 그것들은 확실히 그렇지 않기 때문입니다.

310
00:15:07,880 --> 00:15:10,835
영리한 아이디어가 믿을 수 없을 정도로 쉬워 보이는 

311
00:15:10,835 --> 00:15:13,688
이유 중 하나는 우리가 최종 결과만 보고 지저분한 

312
00:15:13,688 --> 00:15:16,440
것을 정리하고 모든 잘못된 방향을 언급하지 않고 

313
00:15:16,440 --> 00:15:19,497
문제가 시작될 때 탐색 가능한 가능성의 공간이 얼마나 

314
00:15:19,497 --> 00:15:22,146
광대한지 과소평가하기 때문입니다. 해결 과정, 

315
00:15:22,146 --> 00:15:22,860
그 모든 것.

316
00:15:23,820 --> 00:15:24,900
그러나 이것은 일반적으로 사실입니다.

317
00:15:24,900 --> 00:15:27,204
저는 몇몇 특별한 발명품에 대해 우리가 그것을 

318
00:15:27,204 --> 00:15:29,508
과소평가하는 두 번째로 더 깊은 이유가 있다고 

319
00:15:29,508 --> 00:15:30,040
생각합니다.

320
00:15:30,840 --> 00:15:33,532
정보를 비트 단위로 생각하는 것은 정보 이론에 관한 

321
00:15:33,532 --> 00:15:36,040
Claude Shannon의 중요한 논문을 통해 

322
00:15:36,040 --> 00:15:38,640
1948년에 비로소 완전한 이론으로 통합되었습니다.

323
00:15:39,280 --> 00:15:40,805
이는 Hamming이 자신의 알고리즘을 

324
00:15:40,805 --> 00:15:42,540
개발했을 때와 본질적으로 동시에 발생했습니다.

325
00:15:43,300 --> 00:15:46,500
이것은 적어도 이론적으로는 비트 플립 확률이 아무리 

326
00:15:46,500 --> 00:15:49,700
높더라도 어떤 의미에서는 효율적인 오류 수정이 항상 

327
00:15:49,700 --> 00:15:52,900
가능하다는 것을 보여주는 동일한 기본 논문이었습니다.

328
00:15:53,700 --> 00:15:56,100
그런데 Shannon과 Hamming은 매우 다른 

329
00:15:56,100 --> 00:15:58,501
일을 하고 있음에도 불구하고 Bell Labs에서 

330
00:15:58,501 --> 00:16:00,731
사무실을 공유했는데, 여기서는 우연이 아닌 것 

331
00:16:00,731 --> 00:16:01,160
같습니다.

332
00:16:02,380 --> 00:16:05,657
수십 년이 지난 지금, 우리 중 많은 사람들이 

333
00:16:05,657 --> 00:16:09,062
비트와 정보에 대한 생각에 너무 몰두하여 이러한 

334
00:16:09,062 --> 00:16:12,340
사고 방식이 얼마나 뚜렷한지 간과하기 쉽습니다.

335
00:16:13,100 --> 00:16:15,992
아이러니하게도 미래 세대가 생각하는 방식을 

336
00:16:15,992 --> 00:16:19,126
가장 근본적으로 형성하는 아이디어는 결국 미래 

337
00:16:19,126 --> 00:16:22,260
세대를 실제보다 더 단순하게 보게 될 것입니다.

