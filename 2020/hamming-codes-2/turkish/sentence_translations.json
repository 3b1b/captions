[
 {
  "input": "I'm assuming that everybody here is coming from part 1.",
  "model": "nmt",
  "translatedText": "Buradaki herkesin 1. bölümden geldiğini varsayıyorum.",
  "time_range": [
   0.0,
   2.56
  ]
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it.",
  "model": "nmt",
  "translatedText": "Bitlerin çoğunun anlamlı bir mesaj taşıdığı, diğer birkaç parçanın ise bir tür artıklık işlevi gördüğü bir veri bloğu oluşturmanın bir yolu olan Hamming kodlarından bahsediyorduk; herhangi bir bit ters çevrildiğinde ya bir mesaj Bit veya artıklık biti, bu bloktaki herhangi bir şeyde, alıcı bir hata olduğunu ve bunun nasıl düzeltileceğini tanımlayabilecektir.",
  "time_range": [
   3.06,
   21.24
  ]
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error.",
  "model": "nmt",
  "translatedText": "Orada sunulan temel fikir, hataya giden yolda ikili arama yapmak için çoklu eşlik kontrolünün nasıl kullanılacağıydı.",
  "time_range": [
   21.88,
   27.16
  ]
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible.",
  "model": "nmt",
  "translatedText": "Bu videoda amaç, Hamming kodlarının mümkün olduğunca uygulamalı ve yeniden keşfedilebilir olmasını sağlamaktı.",
  "time_range": [
   28.980000000000008,
   34.6
  ]
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are.",
  "model": "nmt",
  "translatedText": "Ancak bunu yazılım veya donanımda gerçekten uygulamayı düşünmeye başladığınızda, bu çerçeveleme aslında bu kodların gerçekte ne kadar zarif olduğunun altını çizebilir.",
  "time_range": [
   35.18,
   43.46
  ]
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that.",
  "model": "nmt",
  "translatedText": "Tüm olası hata konumlarını takip eden ve her kontrolde bu grubu yarıya indiren bir algoritma yazmanız gerektiğini düşünebilirsiniz, ancak aslında bu bundan çok ama çok daha basittir.",
  "time_range": [
   43.92,
   53.48
  ]
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary.",
  "model": "nmt",
  "translatedText": "Son videoda yaptığımız dört eşlik kontrolünün yanıtlarını evet ve hayır yerine 1'ler ve 0'lar olarak okursanız, bu tam anlamıyla hatanın ikili dosyadaki konumunu belirtir.",
  "time_range": [
   53.94,
   64.08
  ]
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1.",
  "model": "nmt",
  "translatedText": "Örneğin, ikili sistemde 7 sayısı 0111'e benzer, aslında 4 artı 2 artı 1 olduğunu söyler.",
  "time_range": [
   64.78,
   71.26
  ]
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last.",
  "model": "nmt",
  "translatedText": "Ve 7. pozisyonun nerede olduğuna dikkat edin, bu durum eşitlik gruplarımızın birincisini, ikincisini ve üçüncüsünü etkiliyor, ancak sonuncusunu etkilemiyor.",
  "time_range": [
   72.54,
   81.74
  ]
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error.",
  "model": "nmt",
  "translatedText": "Yani bu dört kontrolün sonuçlarını aşağıdan yukarıya doğru okumak gerçekten de hatanın konumunu ortaya koyuyor.",
  "time_range": [
   82.22,
   87.54
  ]
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple.",
  "model": "nmt",
  "translatedText": "Örnek 7'de özel bir şey yok, bu genel olarak işe yarıyor ve bu, tüm şemanın donanıma uygulanmasının mantığını şaşırtıcı derecede basit hale getiriyor.",
  "time_range": [
   88.32,
   95.82
  ]
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111.",
  "model": "nmt",
  "translatedText": "Şimdi bu sihrin neden oluştuğunu görmek istiyorsanız, pozisyonlarımız için bu 16 indeks etiketini alın, ancak bunları 10 tabanında yazmak yerine, hepsini 0000'den 1111'e kadar ikili olarak yazalım.",
  "time_range": [
   97.24,
   109.88
  ]
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent.",
  "model": "nmt",
  "translatedText": "Bu ikili etiketleri kutularına geri koyarken, bunların gerçekte gönderilen verilerden farklı olduklarını vurgulamam gerekiyor.",
  "time_range": [
   110.55999999999999,
   117.8
  ]
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from.",
  "model": "nmt",
  "translatedText": "Bunlar sizin ve benim dört eşitlik grubunun nereden geldiğini anlamamıza yardımcı olacak kavramsal bir etiketten başka bir şey değil.",
  "time_range": [
   118.32,
   123.5
  ]
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary.",
  "model": "nmt",
  "translatedText": "Baktığımız her şeyin ikili olarak tanımlanmasının zarafeti, belki de baktığımız her şeyin ikili olarak tanımlanmasının yarattığı kafa karışıklığı nedeniyle gölgede kalıyor.",
  "time_range": [
   124.14,
   132.36
  ]
 },
 {
  "input": "It's worth it, though.",
  "model": "nmt",
  "translatedText": "Yine de buna değer.",
  "time_range": [
   133.02,
   134.12
  ]
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1.",
  "model": "nmt",
  "translatedText": "Dikkatinizi tüm bu etiketlerin sadece son kısmına odaklayın ve ardından bu son bitin 1 olduğu konumları vurgulayın.",
  "time_range": [
   134.8,
   143.22
  ]
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1?",
  "model": "nmt",
  "translatedText": "Elde ettiğimiz şey, dört eşlik grubumuzun ilkidir; bu, ilk kontrolü şu soruyla yorumlayabileceğiniz anlamına gelir: hey, eğer bir hata varsa, bu hatanın konumundaki son bit 1 mi?",
  "time_range": [
   144.24,
   155.74
  ]
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme.",
  "model": "nmt",
  "translatedText": "Benzer şekilde, ikinciden sonuncuya odaklanırsanız ve bunun 1 olduğu tüm konumları vurgularsanız, şemamızdan ikinci eşlik grubunu elde edersiniz.",
  "time_range": [
   158.2,
   166.16
  ]
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1?",
  "model": "nmt",
  "translatedText": "Başka bir deyişle, bu ikinci kontrol şunu soruyor: Hey, ben yine, eğer bir hata varsa, bu konumun ikinciden sondan biti 1 mi?",
  "time_range": [
   166.74,
   174.5
  ]
 },
 {
  "input": "And so on.",
  "model": "nmt",
  "translatedText": "Ve benzeri.",
  "time_range": [
   175.76,
   176.9
  ]
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1.",
  "model": "nmt",
  "translatedText": "Üçüncü eşlik kontrolü, üçüncü bitten son bitine kadar açık olan her konumu kapsar ve sonuncusu, en yüksek dereceli biti 1 olan son sekiz konumu kapsar.",
  "time_range": [
   177.22,
   188.74
  ]
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary.",
  "model": "nmt",
  "translatedText": "Daha önce yaptığımız her şey bu dört soruyu yanıtlamakla aynıydı, bu da ikili sistemde bir konumun hecelenmesiyle aynı şeydi.",
  "time_range": [
   189.74,
   197.74
  ]
 },
 {
  "input": "I hope this makes two things clearer.",
  "model": "nmt",
  "translatedText": "Umarım bu iki şeyi daha açık hale getirir.",
  "time_range": [
   199.62,
   201.48
  ]
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two.",
  "model": "nmt",
  "translatedText": "Birincisi, ikinin daha büyük kuvvetleri olan blok boyutlarına sistematik olarak nasıl genelleştirme yapılacağıdır.",
  "time_range": [
   202.04,
   206.46
  ]
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check.",
  "model": "nmt",
  "translatedText": "Her bir konumu tanımlamak daha fazla bit gerektiriyorsa, örneğin 64 noktayı tanımlamak için altı bit gerekiyorsa, o zaman bu bitlerin her biri size kontrol etmemiz gereken eşlik gruplarından birini verir.",
  "time_range": [
   206.96,
   216.68
  ]
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar.",
  "model": "nmt",
  "translatedText": "Matt Parker'la yaptığım satranç tahtası bulmacasını izleyenleriniz tüm bunları fazlasıyla tanıdık bulabilir.",
  "time_range": [
   218.4,
   223.18
  ]
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard.",
  "model": "nmt",
  "translatedText": "Bu aynı temel mantıktır ancak farklı bir problemi çözmektedir ve 64 karelik bir satranç tahtasına uygulanmıştır.",
  "time_range": [
   223.66,
   228.78
  ]
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8.",
  "model": "nmt",
  "translatedText": "Bunun açıklığa kavuşturacağını umduğum ikinci şey, eşlik bitlerimizin neden ikinin kuvvetleri olan konumlarda olduğudur, örneğin 1, 2, 4 ve 8.",
  "time_range": [
   229.88,
   237.32
  ]
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on.",
  "model": "nmt",
  "translatedText": "Bunlar, ikili gösterimi yalnızca tek bir bitin açık olduğu konumlardır.",
  "time_range": [
   238.0,
   243.0
  ]
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups.",
  "model": "nmt",
  "translatedText": "Bunun anlamı, bu eşlik bitlerinin her birinin, dört eşlik grubundan yalnızca birinin içinde yer almasıdır.",
  "time_range": [
   243.6,
   249.46
  ]
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups.",
  "model": "nmt",
  "translatedText": "Bunu daha büyük örneklerde de görebilirsiniz; ne kadar büyürseniz büyüsün, her eşlik biti rahatlıkla gruplardan yalnızca birine dokunur.",
  "time_range": [
   252.04,
   259.34
  ]
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code.",
  "model": "nmt",
  "translatedText": "Zamanımızın büyük bir kısmını üzerinde yoğunlaştığımız bu eşlik kontrollerinin, ikili sistemde bir hatanın konumunu açıklamanın akıllıca bir yolundan başka bir şey olmadığını anladığınızda, hamming hakkında düşünmenin farklı bir yolu ile bağlantı kurabiliriz. Muhtemelen çok daha basit ve daha zarif olan ve temelde tek bir kod satırıyla yazılabilen kodlar.",
  "time_range": [
   265.6,
   283.24
  ]
 },
 {
  "input": "It's based on the XOR function.",
  "model": "nmt",
  "translatedText": "XOR fonksiyonuna dayanmaktadır.",
  "time_range": [
   283.66,
   285.5
  ]
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or.",
  "model": "nmt",
  "translatedText": "Bilmeyenler için XOR, özel veya anlamına gelir.",
  "time_range": [
   286.94,
   290.22
  ]
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off.",
  "model": "nmt",
  "translatedText": "İki bitin XOR'unu aldığınızda, bu bitlerden herhangi biri açıksa 1 değerini döndürür, ancak her ikisi de açık veya kapalıysa bu sonuç değişmez.",
  "time_range": [
   290.78,
   299.36
  ]
 },
 {
  "input": "Phrased differently, it's the parity of these two bits.",
  "model": "nmt",
  "translatedText": "Farklı bir ifadeyle bu iki bitin paritesidir.",
  "time_range": [
   300.1,
   302.98
  ]
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2.",
  "model": "nmt",
  "translatedText": "Bir matematikçi olarak bunu toplama modu 2 olarak düşünmeyi tercih ederim.",
  "time_range": [
   303.54,
   306.76
  ]
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component.",
  "model": "nmt",
  "translatedText": "Ayrıca genellikle iki farklı bit dizisinin XOR'undan bahsederiz, bu da temel olarak bu bileşeni bileşen bazında yapar.",
  "time_range": [
   307.36,
   313.44
  ]
 },
 {
  "input": "It's like addition, but where you never carry.",
  "model": "nmt",
  "translatedText": "Toplama gibi ama asla taşımadığınız yer.",
  "time_range": [
   313.68,
   315.72
  ]
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2.",
  "model": "nmt",
  "translatedText": "Yine, matematiğe daha yatkın olanlar bunu iki vektörün eklenmesi ve mod 2'nin azaltılması olarak düşünmeyi tercih edebilir.",
  "time_range": [
   316.5,
   322.48
  ]
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood.",
  "model": "nmt",
  "translatedText": "Şu anda Python'u açarsanız ve iki tamsayı arasında düzeltme işareti işlemini uygularsanız, yaptığı şey budur, ancak bu sayıların başlık altındaki bit temsillerine yöneliktir.",
  "time_range": [
   323.5,
   332.94
  ]
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop.",
  "model": "nmt",
  "translatedText": "Sizin ve benim için kilit nokta, birçok farklı bit dizisinin XOR'unu almanın, sütunlarda olduğu gibi bir grup ayrı grubun parodilerini tek bir hamlede etkili bir şekilde hesaplamanın bir yolu olmasıdır.",
  "time_range": [
   334.96000000000004,
   347.14
  ]
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation.",
  "model": "nmt",
  "translatedText": "Bu bize, Hamming kod algoritmamızın çoklu eşlik kontrollerinin tek bir işlemde paketlenmesi hakkında düşünmemiz için oldukça şık bir yol sağlıyor.",
  "time_range": [
   351.26,
   358.78
  ]
 },
 {
  "input": "Though at first glance it does look very different.",
  "model": "nmt",
  "translatedText": "Her ne kadar ilk bakışta çok farklı görünse de.",
  "time_range": [
   359.47999999999996,
   362.18
  ]
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR.",
  "model": "nmt",
  "translatedText": "Daha önce yaptığımız gibi, ikili olarak 16 konumu özel olarak yazın ve şimdi mesaj bitinin 1'e açık olduğu konumları vurgulayın ve ardından bu konumları büyük bir sütunda toplayın ve XOR'u alın.",
  "time_range": [
   362.82,
   377.1
  ]
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly.",
  "model": "nmt",
  "translatedText": "Sonuç olarak altta bulunan 4 bitin, bildiğimiz ve sevdiğimiz 4 eşlik kontrolüyle aynı olduğunu muhtemelen tahmin edebilirsiniz, ancak bunun nedenini tam olarak düşünmek için bir dakikanızı ayırın.",
  "time_range": [
   379.26,
   389.2
  ]
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group.",
  "model": "nmt",
  "translatedText": "Örneğin bu son sütun, son biti 1 olan tüm pozisyonları sayıyor, ancak biz zaten yalnızca vurgulanan konumlarla sınırlıyız, dolayısıyla kaç tane vurgulanan konumun ilk eşlik grubundan geldiğini etkili bir şekilde sayıyor.",
  "time_range": [
   392.22,
   405.76
  ]
 },
 {
  "input": "Does that make sense?",
  "model": "nmt",
  "translatedText": "bu mantıklı mı?",
  "time_range": [
   406.24,
   406.8
  ]
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on.",
  "model": "nmt",
  "translatedText": "Benzer şekilde, bir sonraki sütun, ikinci eşlik grubunda kaç konumun bulunduğunu, ikinciden sondan biti 1 olan ve hangilerinin vurgulandığını vb. sayar.",
  "time_range": [
   409.08,
   420.0
  ]
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing.",
  "model": "nmt",
  "translatedText": "Aslında bu, yapmakta olduğumuz şeye ilişkin perspektifte küçük bir değişiklik.",
  "time_range": [
   420.26,
   423.96
  ]
 },
 {
  "input": "And so you know where it goes from here.",
  "model": "nmt",
  "translatedText": "Yani buradan nereye gideceğini biliyorsun.",
  "time_range": [
   427.76,
   429.6
  ]
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000.",
  "model": "nmt",
  "translatedText": "Gönderen, toplamın 0000 olmasını sağlamak için bazı özel eşlik bitlerinin değiştirilmesinden sorumludur.",
  "time_range": [
   430.0,
   435.72
  ]
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error.",
  "model": "nmt",
  "translatedText": "Şimdi bu şekilde elde ettiğimizde, bu bize, alttaki sonuçta ortaya çıkan dört bitin neden doğrudan bir hatanın konumunu gösterdiğini düşünmemiz için gerçekten güzel bir yol sağlıyor.",
  "time_range": [
   435.72,
   447.58
  ]
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1.",
  "model": "nmt",
  "translatedText": "Diyelim ki bu bloktaki bir bit 0'dan 1'e değiştirildi.",
  "time_range": [
   448.46,
   451.86
  ]
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error.",
  "model": "nmt",
  "translatedText": "Bunun anlamı, o bitin konumu artık toplam XOR'a dahil edilecek, bu da toplamı 0'dan yeni eklenen değere, yani hatanın konumuna dönüştürecek.",
  "time_range": [
   452.6,
   463.82
  ]
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0.",
  "model": "nmt",
  "translatedText": "Biraz daha az açık bir şekilde, 1'i 0'a değiştiren bir hata varsa aynı durum geçerlidir.",
  "time_range": [
   464.46,
   469.36
  ]
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0.",
  "model": "nmt",
  "translatedText": "Görüyorsunuz, eğer bir bit dizisini iki kez toplarsanız, bu orada hiç olmamasıyla aynı şeydir, çünkü bu dünyada 1 artı 1 eşittir 0.",
  "time_range": [
   470.18,
   477.58
  ]
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it.",
  "model": "nmt",
  "translatedText": "Yani bu pozisyonun bir kopyasını toplam toplama eklemek, onu taşımamızla aynı etkiye sahiptir.",
  "time_range": [
   477.58,
   484.3
  ]
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error.",
  "model": "nmt",
  "translatedText": "Ve bu etki yine, alttaki toplam sonucun hatanın konumunu ortaya koymasıdır.",
  "time_range": [
   485.16,
   490.7
  ]
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end.",
  "model": "nmt",
  "translatedText": "Bunun ne kadar zarif olduğunu göstermek için, daha önce bahsettiğim Python kodunun alıcı tarafındaki mantığın neredeyse tamamını yakalayacak bir satırını göstermeme izin verin.",
  "time_range": [
   493.03999999999996,
   501.44
  ]
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits.",
  "model": "nmt",
  "translatedText": "Veri bloğunu simüle etmek için 16 1 ve 0'lardan oluşan rastgele bir dizi oluşturarak başlayacağız ve ona bitlerin adını vereceğim, ancak elbette pratikte bu, bir göndericiden aldığımız bir şey olacaktır ve bunun yerine rastgele olduğundan 5 eşlik bitiyle birlikte 11 veri biti taşıyor olacaktır.",
  "time_range": [
   502.08,
   517.0
  ]
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15.",
  "model": "nmt",
  "translatedText": "EnumerateBits fonksiyonunu çağırırsam, bu bitlerin her birini karşılık gelen bir indeksle eşleştirir, bu durumda 0'dan 15'e kadar çalışır.",
  "time_range": [
   517.0,
   527.0
  ]
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15.",
  "model": "nmt",
  "translatedText": "Yani eğer daha sonra tüm bu çiftleri, i'ye benzeyen çiftleri kapsayan bir liste oluşturursak ve sonra sadece i değerini, sadece indeksi çıkarırsak, bu o kadar da heyecan verici değil, sadece 0'dan 15'e kadar olan indeksleri geri alırız.",
  "time_range": [
   528.18,
   541.34
  ]
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on.",
  "model": "nmt",
  "translatedText": "Ancak bunu yalnızca if biti yapma koşulunu eklersek, yani bu bit 0 değil de 1 ise, o zaman yalnızca karşılık gelen bitin açık olduğu konumları çeker.",
  "time_range": [
   541.68,
   552.66
  ]
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc.",
  "model": "nmt",
  "translatedText": "Bu durumda bu konumlar 0, 4, 6, 9 vb. gibi görünüyor.",
  "time_range": [
   553.38,
   560.36
  ]
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together.",
  "model": "nmt",
  "translatedText": "İstediğimiz şey, tüm bu konumları, açık olan bitlerin konumlarını bir araya toplamak ve ardından bunları XOR ile bir araya getirmek.",
  "time_range": [
   560.72,
   567.24
  ]
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions.",
  "model": "nmt",
  "translatedText": "Bunu Python'da yapmak için önce birkaç yararlı işlevi içe aktarayım.",
  "time_range": [
   569.18,
   573.22
  ]
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it.",
  "model": "nmt",
  "translatedText": "Bu şekilde bu listede reduc()'u çağırabilir ve azaltmak için XOR fonksiyonunu kullanabiliriz.",
  "time_range": [
   573.9,
   578.7
  ]
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way.",
  "model": "nmt",
  "translatedText": "Bu, temelde XOR'ları da alarak liste boyunca yolunu yiyor.",
  "time_range": [
   579.1,
   582.68
  ]
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere.",
  "model": "nmt",
  "translatedText": "İsterseniz, herhangi bir yerden içe aktarmanıza gerek kalmadan bu XOR işlevini açıkça yazabilirsiniz.",
  "time_range": [
   584.8,
   589.44
  ]
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001.",
  "model": "nmt",
  "translatedText": "Yani şu anda öyle görünüyor ki eğer bunu 16 bitlik rastgele bloğumuz üzerinde yaparsak, ikili temsili 1001 olan 9 değerini döndürür.",
  "time_range": [
   591.94,
   601.28
  ]
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0.",
  "model": "nmt",
  "translatedText": "Bunu burada yapmayacağız, ancak gönderenin, dört eşlik bitini gerektiği gibi ayarlamak için bu ikili gösterimi kullandığı ve sonuçta bu bloğu, bu kod satırını bitlerin tam listesinde çalıştırmanın geri döndüğü bir duruma getirdiği bir fonksiyon yazabilirsiniz. bir 0.",
  "time_range": [
   601.98,
   615.46
  ]
 },
 {
  "input": "This would be considered a well-prepared block.",
  "model": "nmt",
  "translatedText": "Bu iyi hazırlanmış bir blok olarak kabul edilir.",
  "time_range": [
   616.08,
   620.1
  ]
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error.",
  "model": "nmt",
  "translatedText": "İşin güzel yanı, bu listedeki bitlerden herhangi birini değiştirirsek, gürültüden kaynaklanan rastgele bir hatayı simüle edersek, o zaman aynı kod satırını çalıştırırsanız, o hatayı yazdırır.",
  "time_range": [
   620.1,
   630.22
  ]
 },
 {
  "input": "Isn't that neat?",
  "model": "nmt",
  "translatedText": "Çok hoş değil mi?",
  "time_range": [
   630.96,
   631.52
  ]
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any.",
  "model": "nmt",
  "translatedText": "Bu bloğu birdenbire alabilir, üzerinde bu tek satırı çalıştırabilirsiniz ve otomatik olarak bir hatanın konumunu veya eğer yoksa 0'ı söyler.",
  "time_range": [
   631.82,
   641.06
  ]
 },
 {
  "input": "And there's nothing special about the size 16 here.",
  "model": "nmt",
  "translatedText": "Ve burada 16 bedenin özel bir yanı yok.",
  "time_range": [
   642.5,
   644.84
  ]
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits.",
  "model": "nmt",
  "translatedText": "Örneğin 256 bitlik bir listeniz varsa aynı kod satırı işe yarar.",
  "time_range": [
   644.84,
   649.86
  ]
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction.",
  "model": "nmt",
  "translatedText": "Söylemeye gerek yok, 2 bitlik hataları tespit etmek için meta eşlik kontrolü yapmak gibi buraya yazılacak daha fazla kod var, ancak fikir şu ki, şemamızdaki temel mantığın neredeyse tamamı tek bir XOR azaltımına dayanıyor.",
  "time_range": [
   651.88,
   663.76
  ]
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go.",
  "model": "nmt",
  "translatedText": "Şimdi, ikili ve XOR'lar ve genel olarak yazılım konusundaki rahatınıza bağlı olarak, bu bakış açısını ya biraz kafa karıştırıcı bulabilir ya da çok daha şık ve basit bulabilir ve neden en baştan bununla başlamadığımızı merak edebilirsiniz. -Gitmek.",
  "time_range": [
   666.12,
   678.42
  ]
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level.",
  "model": "nmt",
  "translatedText": "Kabaca konuşursak, çoklu eşlik kontrolü perspektifini, Hamming kodlarını donanıma doğrudan uygularken düşünmek daha kolaydır ve XOR perspektifini, bunu yazılımda yaparken, daha yüksek bir seviyeden düşünmek en kolayıdır.",
  "time_range": [
   679.14,
   690.5
  ]
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles.",
  "model": "nmt",
  "translatedText": "İlkini elle yapmak en kolay olanıdır ve bence tüm bunların altında yatan temel sezgiyi aşılamak açısından daha iyi bir iş çıkarıyor; yani tek bir hatayı bulmak için gereken bilgi, bloğun boyutunun günlüğüyle ilgilidir. , başka bir deyişle, blok boyutu iki katına çıktıkça her seferinde bir bit büyür.",
  "time_range": [
   691.36,
   710.0
  ]
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need.",
  "model": "nmt",
  "translatedText": "Buradaki ilgili gerçek şu ki, bu bilgi doğrudan ne kadar fazlalığa ihtiyacımız olduğuna karşılık geliyor.",
  "time_range": [
   711.02,
   716.06
  ]
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind.",
  "model": "nmt",
  "translatedText": "Bu aslında çoğu insanın, bir mesajı hatalara karşı dayanıklı hale getirmeyi ilk düşündüklerinde, düşünmeden verdikleri tepkiyle çelişen şeydir; burada genellikle mesajın tamamını kopyalamak akla gelen ilk içgüdüdür.",
  "time_range": [
   716.66,
   726.54
  ]
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix.",
  "model": "nmt",
  "translatedText": "Ve bu arada, bazen Hamming kodlarının sunulduğunu gördüğünüz, mesajı büyük bir matrisle çarptığınız tamamen farklı bir yol daha var.",
  "time_range": [
   727.5,
   734.0
  ]
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales.",
  "model": "nmt",
  "translatedText": "Bu biraz hoş çünkü onu daha geniş doğrusal kod ailesiyle ilişkilendiriyor, ancak bunun nereden geldiği veya nasıl ölçeklendiği konusunda neredeyse hiçbir sezgi vermediğini düşünüyorum.",
  "time_range": [
   734.67,
   743.06
  ]
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size.",
  "model": "nmt",
  "translatedText": "Ölçeklendirmeden bahsetmişken, blok boyutunu artırdıkça bu planın verimliliğinin de arttığını fark edebilirsiniz.",
  "time_range": [
   745.2,
   751.16
  ]
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there.",
  "model": "nmt",
  "translatedText": "Örneğin, 256 bit ile bu alanın yalnızca %3'ünü yedeklilik için kullandığınızı ve bu noktadan sonra giderek daha iyi hale geldiğini gördük.",
  "time_range": [
   755.0,
   762.66
  ]
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling.",
  "model": "nmt",
  "translatedText": "Eşlik bitlerinin sayısı birer birer arttıkça blok boyutu da iki katına çıkar.",
  "time_range": [
   763.3,
   767.34
  ]
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits.",
  "model": "nmt",
  "translatedText": "Ve eğer bunu aşırıya götürürseniz, diyelim ki bir milyon bitlik bir bloğunuz olabilir, burada kelimenin tam anlamıyla eşlik kontrollerinizle 20 soru oynuyorsunuz ve bu blok yalnızca 21 eşlik biti kullanıyor.",
  "time_range": [
   769.0,
   780.02
  ]
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy.",
  "model": "nmt",
  "translatedText": "Milyonlarca parçaya bakıp tek bir hatayı bulmayı düşünmek için geri adım atarsanız, bu gerçekten çılgınca geliyor.",
  "time_range": [
   780.74,
   787.06
  ]
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that.",
  "model": "nmt",
  "translatedText": "Sorun, elbette, daha büyük bir blokla, bir veya iki bitten daha fazla hata görme olasılığının artması ve Hamming kodlarının bunun ötesinde hiçbir şeyi ele almamasıdır.",
  "time_range": [
   788.1999999999999,
   797.66
  ]
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high.",
  "model": "nmt",
  "translatedText": "Yani pratikte isteyeceğiniz şey, çok fazla bit dönme olasılığının çok yüksek olmaması için doğru boyutu bulmaktır.",
  "time_range": [
   798.32,
   804.3
  ]
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored.",
  "model": "nmt",
  "translatedText": "Ayrıca pratikte hatalar küçük patlamalar halinde ortaya çıkma eğilimindedir, bu da tek bir bloğu tamamen mahveder, bu nedenle bir dizi hatanın birçok farklı bloğa yayılmasına yardımcı olacak yaygın bir taktik, bu blokları bu şekilde birbirine geçirmeden önce bu şekilde birbirine geçirmektir. gönderilir veya saklanır.",
  "time_range": [
   806.6,
   820.98
  ]
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block.",
  "model": "nmt",
  "translatedText": "Öte yandan, bunların birçoğu, çok daha yaygın olarak kullanılan, patlama hatalarını özellikle iyi bir şekilde ele alan Reed-Solomon algoritması gibi daha modern kodlar tarafından tamamen tartışmalı hale getiriliyor ve blok başına daha fazla sayıda hataya karşı dayanıklı olacak şekilde ayarlanabiliyor.",
  "time_range": [
   825.58,
   838.82
  ]
 },
 {
  "input": "But that's a topic for another time.",
  "model": "nmt",
  "translatedText": "Ama bu başka bir zamanın konusu.",
  "time_range": [
   839.36,
   841.34
  ]
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was.",
  "model": "nmt",
  "translatedText": "Hamming, The Art of Doing Science and Engineering adlı kitabında bu kodu keşfetmesinin ne kadar dolambaçlı olduğunu son derece samimi bir şekilde anlatıyor.",
  "time_range": [
   842.5,
   849.94
  ]
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this.",
  "model": "nmt",
  "translatedText": "İlk önce, parçaları daha yüksek boyutlu bir kafesin parçalarına ayırmayı ve bunun gibi tuhaf şeyleri içeren her türlü farklı şemayı denedi.",
  "time_range": [
   850.62,
   857.78
  ]
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this?",
  "model": "nmt",
  "translatedText": "Bir hatanın konumunu ortaya koyacak şekilde eşlik kontrollerinin bir araya getirilmesinin mümkün olabileceği fikri, Hamming'in aklına ancak bir sürü başka analizden sonra geri çekilip, tamam, yapabileceğim en verimli şeyin ne olduğunu sorduğunda geldi. bunun hakkında olabilir mi?",
  "time_range": [
   858.3,
   871.52
  ]
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today.",
  "model": "nmt",
  "translatedText": "Ayrıca, 1940'larda bugün olduğundan çok daha az yaygın olan eşitlik kontrollerinin zaten aklında olmasının ne kadar önemli olduğu konusunda da samimiydi.",
  "time_range": [
   872.62,
   881.22
  ]
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind.",
  "model": "nmt",
  "translatedText": "Bu kitap boyunca neredeyse yarım düzine kez Louis Pasteur'ün bir sözüne gönderme yapıyor; şans hazırlıklı bir zihinden yanadır.",
  "time_range": [
   881.92,
   888.22
  ]
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate.",
  "model": "nmt",
  "translatedText": "Zekice fikirler genellikle geriye dönüp bakıldığında aldatıcı derecede basit görünür, bu da onları küçümsemeyi kolaylaştırır.",
  "time_range": [
   889.32,
   894.3
  ]
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you.",
  "model": "nmt",
  "translatedText": "Şu anda samimi umudum, Hamming kodlarının veya en azından bu tür kodların olasılığının size neredeyse apaçık gelmesidir.",
  "time_range": [
   894.96,
   901.3
  ]
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't.",
  "model": "nmt",
  "translatedText": "Ancak bunların aslında bariz olduğunu düşünerek kendinizi kandırmamalısınız çünkü kesinlikle öyle değiller.",
  "time_range": [
   901.66,
   906.82
  ]
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that.",
  "model": "nmt",
  "translatedText": "Zekice fikirlerin aldatıcı derecede kolay görünmesinin bir nedeni de, yalnızca nihai sonucu görmemiz, dağınık olanı temizlememiz, tüm yanlış dönüşlerden hiç bahsetmememiz, bir sorunun başlangıcında keşfedilebilir olasılıklar alanının ne kadar geniş olduğunun altını çizmemizdir. çözme süreci, bunların hepsi.",
  "time_range": [
   907.88,
   922.86
  ]
 },
 {
  "input": "But this is true in general.",
  "model": "nmt",
  "translatedText": "Ancak bu genel olarak doğrudur.",
  "time_range": [
   923.82,
   924.9
  ]
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them.",
  "model": "nmt",
  "translatedText": "Bazı özel icatlarda onları yeterince takdir etmememizin ikinci ve daha derin bir nedeni olduğunu düşünüyorum.",
  "time_range": [
   924.9,
   930.04
  ]
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory.",
  "model": "nmt",
  "translatedText": "Bilgiyi bitler cinsinden düşünmek, Claude Shannon'ın bilgi teorisi üzerine ufuk açıcı makalesiyle ancak 1948'de tam bir teoriye dönüştü.",
  "time_range": [
   930.84,
   938.64
  ]
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm.",
  "model": "nmt",
  "translatedText": "Bu aslında Hamming'in algoritmasını geliştirmesiyle eşzamanlıydı.",
  "time_range": [
   939.28,
   942.54
  ]
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory.",
  "model": "nmt",
  "translatedText": "Bu, en azından teoride, bit kayması olasılığı ne kadar yüksek olursa olsun, bir anlamda etkili hata düzeltmenin her zaman mümkün olduğunu gösteren aynı temel makaleydi.",
  "time_range": [
   943.3,
   952.9
  ]
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here.",
  "model": "nmt",
  "translatedText": "Bu arada Shannon ve Hamming, çok farklı şeyler üzerinde çalışmalarına rağmen Bell Laboratuvarları'nda bir ofisi paylaşıyorlardı ki bu da burada pek rastlantısal görünmüyor.",
  "time_range": [
   953.7,
   961.16
  ]
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was.",
  "model": "nmt",
  "translatedText": "Birkaç on yıl ileri saralım ve bu günlerde çoğumuz küçük parçalar ve bilgiler üzerine düşünmeye o kadar dalmış durumdayız ki, bu düşünce tarzının ne kadar farklı olduğunu gözden kaçırmak çok kolay.",
  "time_range": [
   962.38,
   972.34
  ]
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are.",
  "model": "nmt",
  "translatedText": "İroniktir ki, gelecek neslin düşünme biçimini en derinden şekillendiren fikirler, gelecek nesile gerçekte olduğundan daha basit görünmeye yol açacaktır.",
  "time_range": [
   973.1,
   982.26
  ]
 }
]