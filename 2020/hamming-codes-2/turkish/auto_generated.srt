1
00:00:00,000 --> 00:00:05,356
Bir CD&#39;yi veya DVD&#39;yi çizerken, içinde sakladığı

2
00:00:05,356 --> 00:00:10,900
şeyi oynatmanın nasıl mümkün olduğunu hiç merak ettiniz mi?

3
00:00:10,900 --> 00:00:14,709
Çizik gerçekten diskteki 1&#39;leri ve 0&#39;ları etkiler,

4
00:00:14,709 --> 00:00:18,197
bu nedenle depolanan verilerden farklı verileri okur,

5
00:00:18,197 --> 00:00:21,942
ancak gerçekten çizilmediği sürece okuduğu bitlerin kodu,

6
00:00:21,942 --> 00:00:26,010
üzerine kodlanmış olanla tam olarak aynı dosyaya dönüştürülür.

7
00:00:26,010 --> 00:00:28,400
tüm bu hatalara rağmen bit bit kopya.

8
00:00:28,400 --> 00:00:31,213
Verileri depolamamıza ve aynı derecede önemlisi,

9
00:00:31,213 --> 00:00:35,289
hatalara karşı dirençli bir şekilde veri iletmemize olanak tanıyan bir

10
00:00:35,289 --> 00:00:36,840
sürü matematiksel zeka var.

11
00:00:36,840 --> 00:00:42,480
Tamam, aslında bunu yapmanın bir yolunu bulmak o kadar da zeki olmayı gerektirmiyor.

12
00:00:42,480 --> 00:00:46,550
Herhangi bir dosya, ister video, ister ses, ister metin, ister bir kod,

13
00:00:46,550 --> 00:00:50,960
ister bir görüntü olsun, sonuçta 1&#39;ler ve 0&#39;lardan oluşan bir dizidir.

14
00:00:50,960 --> 00:00:55,222
Ve ters çevrilen herhangi bir biti düzeltmek için basit bir strateji,

15
00:00:55,222 --> 00:00:57,780
her bitin üç kopyasını saklamak olacaktır.

16
00:00:57,780 --> 00:01:02,542
Daha sonra bu dosyayı okuyan makine bu üç kopyayı karşılaştırabilir ve

17
00:01:02,542 --> 00:01:07,440
bir tutarsızlık olduğunda her zaman 3 üzerinden en iyi 2&#39;yi alabilir.

18
00:01:07,440 --> 00:01:11,560
Ancak bunun anlamı, alanınızın üçte ikisini yedeklilik için kullanmaktır.

19
00:01:11,560 --> 00:01:13,906
Ve o zaman bile, kaybedilen tüm bu alana rağmen,

20
00:01:13,906 --> 00:01:18,120
birden fazla bitin ters çevrilmesi durumunda ne olacağına dair güçlü bir garanti yoktur.

21
00:01:18,120 --> 00:01:21,513
Çok daha ilginç olan soru, mümkün olduğunca az yer kaplarken

22
00:01:21,513 --> 00:01:24,740
hataların düzeltilebilmesi için bunun nasıl yapılacağıdır.

23
00:01:24,740 --> 00:01:28,889
Örneğin, bu videoda öğreneceğiniz yöntemi kullanarak verilerinizi

24
00:01:28,889 --> 00:01:32,975
256 bitlik bloklarda saklayabilirsiniz; burada her blok 9 bit, 9!

25
00:01:32,975 --> 00:01:36,609
bir tür artıklık görevi görür ve diğer 247 bit,

26
00:01:36,609 --> 00:01:41,000
istediğiniz anlamlı mesajı veya veriyi taşımakta özgürdür.

27
00:01:41,000 --> 00:01:43,697
Ve yine de burada herhangi bir bit ters çevrilirse,

28
00:01:43,697 --> 00:01:46,551
sadece bu bloğa bakarak ve başka hiçbir şeye bakmadan,

29
00:01:46,551 --> 00:01:50,545
bir makine bir hata olduğunu ve tam olarak nerede olduğunu tespit edebilecek

30
00:01:50,545 --> 00:01:53,140
ve böylece onu nasıl düzelteceğini bilebilecektir.

31
00:01:53,140 --> 00:01:55,540
Ve dürüst olmak gerekirse, bu sihir gibi geliyor.

32
00:01:55,540 --> 00:01:58,038
Ve bu özel şema için, eğer iki bit ters çevrilirse,

33
00:01:58,038 --> 00:02:00,825
makine en azından iki hata olduğunu tespit edebilecektir,

34
00:02:00,825 --> 00:02:03,180
ancak bunları nasıl düzelteceğini bilemeyecektir.

35
00:02:03,180 --> 00:02:06,452
Bunun farklı boyutlardaki bloklar için nasıl ölçeklendirileceği

36
00:02:06,452 --> 00:02:08,140
hakkında biraz sonra konuşacağız.

37
00:02:08,140 --> 00:02:11,118
Bunun gibi hataları düzeltmenize izin veren yöntemler,

38
00:02:11,118 --> 00:02:13,880
makul olarak, hata düzeltme kodları olarak bilinir.

39
00:02:13,880 --> 00:02:18,652
Geçen yüzyılın büyük bir bölümünde bu alan, her gün kullandığımız cihazlara dahil edilen,

40
00:02:18,652 --> 00:02:23,000
şaşırtıcı derecede derin bir matematik açısından gerçekten zengin bir kaynak oldu.

41
00:02:23,000 --> 00:02:26,130
Buradaki amaç size Hamming kodu olarak bilinen en eski

42
00:02:26,130 --> 00:02:29,660
örneklerden biri hakkında kapsamlı bir anlayış kazandırmaktır.

43
00:02:29,660 --> 00:02:32,782
Bu arada, bu videonun yapısı hakkında düşünme biçimim,

44
00:02:32,782 --> 00:02:35,507
onu mümkün olduğunca doğrudan açıklamaktan çok,

45
00:02:35,507 --> 00:02:40,220
ara sıra hafif bir rehberlikle sizi onu kendiniz icat etmeye teşvik etmekle ilgili.

46
00:02:40,220 --> 00:02:43,313
Yani bir noktada işlerin nereye gideceğini gördüğünüzü hissettiğinizde,

47
00:02:43,313 --> 00:02:47,180
o anı duraklatın ve ben size söylemeden önce planın ne olacağını aktif olarak tahmin edin.

48
00:02:47,180 --> 00:02:50,722
Ayrıca, anlayışınızın donanım düzeyine inmesini istiyorsanız,

49
00:02:50,722 --> 00:02:54,835
Ben Eater bununla bağlantılı olarak Hamming kodlarını devre tahtalarına

50
00:02:54,835 --> 00:02:59,520
nasıl uygulayacağınızı gösteren bir video hazırladı ki bu son derece tatmin edici.

51
00:02:59,520 --> 00:03:03,083
Hamming kodlarının, Reed-Solomon algoritması gibi daha modern kodlar

52
00:03:03,083 --> 00:03:06,854
kadar yaygın kullanılmadığını bilmelisiniz, ancak bu görevin başlangıçta

53
00:03:06,854 --> 00:03:10,572
ne kadar imkansız hissettirdiği ile bir kez ne kadar mantıklı göründüğü

54
00:03:10,572 --> 00:03:14,240
arasındaki karşıtlıkta belli bir sihir var. Hamming&#39;i öğreniyorsun.

55
00:03:14,240 --> 00:03:18,674
Hata düzeltmenin temel ilkesi, olası tüm mesajların geniş bir alanında

56
00:03:18,674 --> 00:03:22,860
yalnızca bazı alt kümelerin geçerli mesaj olarak kabul edilmesidir.

57
00:03:22,860 --> 00:03:29,100
Bir benzetme olarak, doğru yazılan sözcükler ile yanlış yazılan sözcükleri düşünün.

58
00:03:29,100 --> 00:03:34,255
Geçerli bir mesaj değiştirildiğinde, tıpkı bir yazım hatasında yapabileceğiniz gibi,

59
00:03:34,255 --> 00:03:38,380
alıcı gördüklerini en yakın geçerli komşuya düzeltmekten sorumludur.

60
00:03:38,380 --> 00:03:42,516
Ancak bunun gibi mesajları etkili bir şekilde kategorize

61
00:03:42,516 --> 00:03:47,160
etmek için somut bir algoritma bulmak belli bir zeka gerektirir.

62
00:03:47,160 --> 00:03:50,694
Hikaye 1940&#39;larda, genç Richard Hamming&#39;in Bell Laboratuvarları

63
00:03:50,694 --> 00:03:54,278
için çalıştığı ve bazı işlerinin sınırlı erişime sahip olduğu çok büyük,

64
00:03:54,278 --> 00:03:57,420
pahalı bir delikli kart bilgisayarını kullandığı zaman başlıyor.

65
00:03:57,420 --> 00:04:00,146
Ve uygulamaya koyduğu programlar sürekli başarısız

66
00:04:00,146 --> 00:04:03,140
oluyordu çünkü ara sıra bazı kısımlar yanlış okunuyordu.

67
00:04:03,140 --> 00:04:06,120
Hayal kırıklığı buluşun potası olduğundan o kadar

68
00:04:06,120 --> 00:04:09,280
bıktı ki dünyanın ilk hata düzeltme kodunu icat etti.

69
00:04:09,280 --> 00:04:11,993
Hamming kodlarını çerçevelemenin pek çok farklı yolu vardır,

70
00:04:11,993 --> 00:04:15,685
ancak ilk geçiş olarak biz bunu Hamming&#39;in kendisinin onlar hakkında düşündüğü

71
00:04:15,685 --> 00:04:16,620
şekilde ele alacağız.

72
00:04:16,620 --> 00:04:21,400
Basit ama çok da basit olmayan bir örnek, 16 bitlik bir blok kullanalım.

73
00:04:21,400 --> 00:04:25,700
Bu bitlerin konumlarını 0&#39;dan 15&#39;e kadar numaralandıracağız.

74
00:04:25,700 --> 00:04:30,341
Saklamak istediğimiz gerçek veriler bu bitlerden yalnızca 12&#39;sini oluşturacak,

75
00:04:30,341 --> 00:04:33,920
konumların 4&#39;ü ise bir tür artıklık olarak ayrılmış durumda.

76
00:04:33,920 --> 00:04:36,667
Buradaki gereksiz kelimesi sadece kopyalama anlamına gelmiyor,

77
00:04:36,667 --> 00:04:40,200
sonuçta bu 4 bit bize verileri körü körüne kopyalamak için yeterli alan vermiyor.

78
00:04:40,200 --> 00:04:44,703
Bunun yerine, bunların çok daha incelikli ve akıllı bir tür fazlalık olması,

79
00:04:44,703 --> 00:04:48,740
herhangi bir yeni bilgi eklemesi değil, esneklik sağlaması gerekecek.

80
00:04:48,740 --> 00:04:52,493
Bu 4 özel parçanın, belki sonunda ya da buna benzer bir şekilde güzel bir şekilde

81
00:04:52,493 --> 00:04:55,376
bir araya gelmesini bekleyebilirsiniz, ancak göreceğiniz gibi,

82
00:04:55,376 --> 00:04:58,214
bunların 2&#39;nin kuvvetleri olan konumlara yerleştirilmesi,

83
00:04:58,214 --> 00:05:00,320
sonunda gerçekten zarif bir şeye olanak tanır.

84
00:05:00,320 --> 00:05:03,487
Ayrıca, bunun daha büyük bloklar için nasıl ölçeklendiğine

85
00:05:03,487 --> 00:05:05,420
dair size küçük bir ipucu verebilir.

86
00:05:05,420 --> 00:05:08,490
Ayrıca teknik olarak sadece 11 bitlik bir veriden ibarettir,

87
00:05:08,490 --> 00:05:12,216
0 konumunda olup bitenlerle ilgili hafif bir nüans olduğunu göreceksiniz,

88
00:05:12,216 --> 00:05:14,280
ancak şimdilik bunun için endişelenmeyin.

89
00:05:14,280 --> 00:05:18,272
Herhangi bir hata düzeltme algoritması gibi, bu da iki oyuncuyu içerecektir;

90
00:05:18,272 --> 00:05:22,419
bu 4 özel bitin ayarlanmasından sorumlu olan bir gönderici ve bir tür kontrolün

91
00:05:22,419 --> 00:05:26,360
gerçekleştirilmesinden ve hataların düzeltilmesinden sorumlu olan bir alıcı.

92
00:05:26,360 --> 00:05:29,460
Elbette, gönderen ve alıcı kelimeleri aslında tüm kontrolleri yapan

93
00:05:29,460 --> 00:05:32,151
makinelere veya yazılımlara atıfta bulunur ve mesaj fikri,

94
00:05:32,151 --> 00:05:35,480
depolama gibi şeyleri de içerecek şekilde oldukça geniş bir anlama gelir.

95
00:05:35,480 --> 00:05:39,635
Sonuçta veri depolamak, mesajın bir yerden başka bir yere değil,

96
00:05:39,635 --> 00:05:42,640
geçmişten geleceğe gönderilmesiyle aynı şeydir.

97
00:05:42,640 --> 00:05:46,204
Kurulum bu, ancak konuya dalmadan önce, keşfi sırasında Hamming&#39;in

98
00:05:46,204 --> 00:05:49,518
aklında yeni olan ilgili bir fikir hakkında konuşmamız gerekiyor;

99
00:05:49,518 --> 00:05:53,082
herhangi bir tek bit hatasını tespit etmenize izin veren ancak bunları

100
00:05:53,082 --> 00:05:57,300
düzeltmenize izin vermeyen bir yöntem, bilinen iş dünyasında parite kontrolü olarak.

101
00:05:57,300 --> 00:06:01,056
Eşlik kontrolü için, gönderenin ayarlamadan sorumlu olduğu

102
00:06:01,056 --> 00:06:04,940
tek bir biti ayırıyoruz ve geri kalanı mesaj taşımakta özgür.

103
00:06:04,940 --> 00:06:08,482
Bu özel bitin tek görevi mesajdaki 1&#39;lerin

104
00:06:08,482 --> 00:06:12,100
toplam sayısının çift sayı olmasını sağlamaktır.

105
00:06:12,100 --> 00:06:15,858
Örneğin şu anda, 1&#39;lerin toplam sayısı 7&#39;dir, bu tek sayıdır,

106
00:06:15,858 --> 00:06:19,724
dolayısıyla gönderenin bu özel biti 1 olacak şekilde çevirmesi gerekir,

107
00:06:19,724 --> 00:06:20,960
böylece sayı çift olur.

108
00:06:20,960 --> 00:06:27,480
Ancak blok zaten çift sayıda 1&#39;lerle başlamış olsaydı, bu özel bit 0&#39;da tutulurdu.

109
00:06:27,480 --> 00:06:30,906
Bu oldukça basit, yanıltıcı derecede basit, ancak bir mesajın

110
00:06:30,906 --> 00:06:34,056
herhangi bir yerindeki değişimin tek bir bilgi parçasına

111
00:06:34,056 --> 00:06:37,760
yansıtılacağı fikrini damıtmanın inanılmaz derecede zarif bir yolu.

112
00:06:37,760 --> 00:06:43,175
Bu mesajın herhangi bir bitinin 0&#39;dan 1&#39;e veya 1&#39;den 0&#39;a çevrilmesi

113
00:06:43,175 --> 00:06:48,140
durumunda, 1&#39;lerin toplam sayısının çiftten teke değişmesine dikkat edin.

114
00:06:48,140 --> 00:06:52,909
Yani eğer alıcıysanız, bu mesaja baktığınızda ve tek sayıda 1&#39;ler görüyorsanız,

115
00:06:52,909 --> 00:06:56,485
nerede olduğu hakkında hiçbir fikriniz olmasa bile bir hatanın

116
00:06:56,485 --> 00:06:58,700
meydana geldiğinden emin olabilirsiniz.

117
00:06:58,700 --> 00:07:03,602
Jargonda, bir bit grubunun çift veya tek sayıda 1&#39;e sahip olup olmadığı,

118
00:07:03,602 --> 00:07:04,940
eşlik olarak bilinir.

119
00:07:04,940 --> 00:07:08,255
Ayrıca sayıları kullanabilir ve paritenin 0 veya 1 olduğunu söyleyebilirsiniz;

120
00:07:08,255 --> 00:07:11,320
bu fikirle matematik yapmaya başladığınızda genellikle daha yararlı olur.

121
00:07:11,320 --> 00:07:15,922
Ve göndericinin pariteyi kontrol etmek için kullandığı bu özel bit,

122
00:07:15,922 --> 00:07:18,020
eşlik biti olarak adlandırılır.

123
00:07:18,020 --> 00:07:21,699
Ve aslında, açık olmalıyız ki, eğer alıcı tek bir parite görürse,

124
00:07:21,699 --> 00:07:24,542
bu sadece bir hata olduğu anlamına gelmez, 3 hata,

125
00:07:24,542 --> 00:07:29,560
5 hata veya başka herhangi bir tek sayı olabilir, ancak kesin olarak bilebilir. 0 değildi.

126
00:07:29,560 --> 00:07:33,863
Öte yandan, 2 hata veya herhangi bir çift sayıda hata olsaydı,

127
00:07:33,863 --> 00:07:37,621
son 1 sayısı hâlâ çift sayı olurdu, dolayısıyla alıcı,

128
00:07:37,621 --> 00:07:43,360
çift sayının mutlaka mesajın hatasız olduğu anlamına geldiğine tam olarak güvenemez.

129
00:07:43,360 --> 00:07:46,374
Yalnızca 2 bitlik geçişlerle bozulan bir mesajın oldukça

130
00:07:46,374 --> 00:07:49,760
zayıf olduğundan şikayet edebilirsiniz ve kesinlikle haklısınız.

131
00:07:49,760 --> 00:07:54,838
Ancak, aldığınız mesajın gönderenin amaçladığı mesaj olduğuna dair size %100

132
00:07:54,838 --> 00:07:59,720
güven verecek bir hata tespiti veya düzeltme yöntemi olmadığını unutmayın.

133
00:07:59,720 --> 00:08:02,970
Sonuçta, yeterince rastgele gürültü her zaman geçerli bir mesajı

134
00:08:02,970 --> 00:08:05,920
tamamen şans eseri başka bir geçerli mesaja dönüştürebilir.

135
00:08:05,920 --> 00:08:11,162
Bunun yerine amaç, belirli bir maksimum hata sayısına kadar dayanıklı

136
00:08:11,162 --> 00:08:16,480
bir şema bulmak veya bunun gibi yanlış pozitif olasılığını azaltmaktır.

137
00:08:16,480 --> 00:08:19,632
Eşlik kontrolleri kendi başlarına oldukça zayıftır,

138
00:08:19,632 --> 00:08:24,968
ancak tüm mesajdaki değişim fikrini tek bir bit&#39;e indirgeyerek bize verdikleri şey,

139
00:08:24,968 --> 00:08:28,000
daha karmaşık planlar için güçlü bir yapı taşıdır.

140
00:08:28,000 --> 00:08:31,237
Örneğin, Hamming bir hatanın sadece meydana geldiğini değil,

141
00:08:31,237 --> 00:08:35,801
nerede meydana geldiğini de belirlemenin bir yolunu ararken, onun temel görüşü şuydu:

142
00:08:35,801 --> 00:08:40,471
Eğer bazı eşitlik kontrollerini mesajın tamamına değil de dikkatle seçilmiş belirli alt

143
00:08:40,471 --> 00:08:43,072
kümelere uygularsanız, şu soruyu sorabilirsiniz:

144
00:08:43,072 --> 00:08:46,840
herhangi bir bit hatasının yerini belirleyen daha rafine bir dizi soru.

145
00:08:46,840 --> 00:08:50,357
Genel his biraz 20 soruluk bir oyun oynamaya, olasılıklar

146
00:08:50,357 --> 00:08:54,300
alanını yarıya indiren evet veya hayır soruları sormaya benziyor.

147
00:08:54,300 --> 00:08:57,104
Örneğin, diyelim ki sadece bu 8 bit üzerinde, tek sayılı

148
00:08:57,104 --> 00:09:00,400
konumların tümü üzerinde bir eşlik kontrolü yaptığımızı varsayalım.

149
00:09:00,400 --> 00:09:05,308
Daha sonra bir hata tespit edilirse, alıcıya hatanın tam olarak nerede olduğu,

150
00:09:05,308 --> 00:09:09,160
yani tek bir konumda olduğu hakkında biraz daha bilgi verilir.

151
00:09:09,160 --> 00:09:12,440
Bu 8 bit arasında herhangi bir hata tespit edilmezse,

152
00:09:12,440 --> 00:09:17,240
bu ya hiç hata olmadığı anlamına gelir ya da çift konumlarda bir yerde bulunur.

153
00:09:17,240 --> 00:09:21,251
Eşlik kontrolünü bitlerin yarısıyla sınırlandırmanın onu daha az etkili

154
00:09:21,251 --> 00:09:25,318
hale getirdiğini düşünebilirsiniz, ancak diğer iyi seçilmiş kontrollerle

155
00:09:25,318 --> 00:09:29,720
birlikte yapıldığında, mantıksız bir şekilde bize çok daha güçlü bir şey verir.

156
00:09:29,720 --> 00:09:32,943
Eşlik kontrolünü gerçekten ayarlamak için, unutmayın,

157
00:09:32,943 --> 00:09:37,600
o tam grubun eşliğini kontrol eden bazı özel bitlerin tahsis edilmesi gerekir.

158
00:09:37,600 --> 00:09:39,920
Burada sadece konum 1&#39;i seçelim.

159
00:09:39,920 --> 00:09:43,216
Gösterilen örnekte, bu 8 bitin paritesi şu anda tektir,

160
00:09:43,216 --> 00:09:48,220
dolayısıyla gönderen bu eşlik bitinin değiştirilmesinden sorumludur ve artık çifttir.

161
00:09:48,220 --> 00:09:51,040
Bu, yapacağımız 4 eşlik kontrolünden yalnızca 1&#39;idir.

162
00:09:51,040 --> 00:09:54,284
İkinci kontrol, en azından burada çizdiğimiz şekliyle,

163
00:09:54,284 --> 00:09:56,880
ızgaranın sağ yarısındaki 8 bit arasındadır.

164
00:09:56,880 --> 00:09:59,942
Bu kez konum 2&#39;yi eşlik biti olarak kullanabiliriz,

165
00:09:59,942 --> 00:10:03,277
böylece bu 8 bit zaten eşit bir eşliğe sahiptir ve gönderen,

166
00:10:03,277 --> 00:10:07,160
bu 2 numaralı biti değiştirmeden bırakmanın kendisini iyi hissedebilir.

167
00:10:07,160 --> 00:10:11,368
Diğer taraftan eğer alıcı bu grubun paritesini kontrol ederse ve bunun tuhaf

168
00:10:11,368 --> 00:10:15,960
olduğunu görürse, hatanın sağdaki bu 8 bit arasında bir yerde olduğunu anlayacaktır.

169
00:10:15,960 --> 00:10:18,782
Aksi takdirde bu, ya hata olmadığı ya da hatanın

170
00:10:18,782 --> 00:10:21,260
sol yarıda bir yerde olduğu anlamına gelir.

171
00:10:21,260 --> 00:10:24,051
Ya da sanırım iki hata olabilirdi ama şimdilik

172
00:10:24,051 --> 00:10:27,080
tüm blokta en fazla bir hata olduğunu varsayacağız.

173
00:10:27,080 --> 00:10:29,160
Bundan daha fazlası için işler tamamen bozulur.

174
00:10:29,160 --> 00:10:32,564
Burada, sonraki iki kontrole bakmadan önce, bir dakika durup bu ilk ikisinin

175
00:10:32,564 --> 00:10:35,880
birlikte değerlendirildiğinde bize ne yapmamıza olanak sağladığını düşünün.

176
00:10:35,880 --> 00:10:40,240
Diyelim ki tek sütunlar arasında ve sağ yarıda bir hata tespit ettiniz.

177
00:10:40,240 --> 00:10:43,940
Bu mutlaka hatanın son sütunda bir yerde olduğu anlamına gelir.

178
00:10:43,940 --> 00:10:47,230
Tek sütunda hata yoksa ancak sağ yarıda bir hata varsa,

179
00:10:47,230 --> 00:10:50,520
bu size sorunun sondan ikinci sütunda olduğunu gösterir.

180
00:10:50,520 --> 00:10:54,055
Benzer şekilde, tek sütunlarda bir hata varsa ancak sağ yarıda değilse,

181
00:10:54,055 --> 00:10:56,560
bunun ikinci sütunda bir yerde olduğunu bilirsiniz.

182
00:10:56,560 --> 00:11:00,185
Ve eğer bu iki eşlik kontrolünden hiçbiri bir şey tespit etmezse, bu,

183
00:11:00,185 --> 00:11:03,760
hatanın olabileceği tek yerin en soldaki sütun olduğu anlamına gelir.

184
00:11:03,760 --> 00:11:06,480
Ancak bu aynı zamanda hiçbir hatanın olmadığı anlamına da gelebilir.

185
00:11:06,480 --> 00:11:09,246
Bu, iki eşlik kontrolünün sütunu belirlememize izin

186
00:11:09,246 --> 00:11:11,800
verdiğini söylemenin oldukça ayrıntılı bir yolu.

187
00:11:11,800 --> 00:11:14,000
Buradan sonrasını muhtemelen tahmin edebilirsiniz.

188
00:11:14,000 --> 00:11:16,240
Temelde aynı şeyi yapıyoruz ancak satırlar için.

189
00:11:16,240 --> 00:11:21,040
Konum 4&#39;ü eşlik biti olarak kullanarak tek satırlarda bir eşlik kontrolü yapılacak.

190
00:11:21,040 --> 00:11:26,480
Yani bu örnekte bu grup zaten çift eşlikli olduğundan bit 4, 0&#39;a ayarlanacaktır.

191
00:11:26,480 --> 00:11:29,259
Ve son olarak, alt iki satırda, konum 8&#39;i

192
00:11:29,259 --> 00:11:32,280
eşlik biti olarak kullanan bir eşlik kontrolü var.

193
00:11:32,280 --> 00:11:35,697
Bu durumda, gruba eşit eşitlik sağlamak için gönderenin 8.

194
00:11:35,697 --> 00:11:37,840
biti açması gerekiyor gibi görünüyor.

195
00:11:37,840 --> 00:11:40,374
İlk iki kontrol sütunu belirlememize izin verdiği gibi,

196
00:11:40,374 --> 00:11:43,000
sonraki iki kontrol de satırı belirlemenize olanak sağlar.

197
00:11:43,000 --> 00:11:48,400
Örnek olarak, iletim sırasında örneğin 3. pozisyonda bir hata olduğunu hayal edin.

198
00:11:48,400 --> 00:11:52,976
Bu, birinci eşlik grubunu etkiler ve aynı zamanda ikinci eşlik grubunu da etkiler,

199
00:11:52,976 --> 00:11:56,340
böylece alıcı, sağ sütunda bir yerde bir hata olduğunu bilir.

200
00:11:56,340 --> 00:12:01,380
Ama üçüncü grubu etkilemediği gibi dördüncü grubu da etkilemez.

201
00:12:01,380 --> 00:12:04,684
Ve bu, alıcının hatayı ilk satıra kadar tespit etmesini sağlar,

202
00:12:04,684 --> 00:12:08,660
bu da zorunlu olarak 3. konum anlamına gelir, böylece hatayı düzeltebilirler.

203
00:12:08,660 --> 00:12:10,984
Bu dört sorunun yanıtlarının, nerede olursa olsun,

204
00:12:10,984 --> 00:12:13,901
belirli bir konumu belirlemenize gerçekten olanak sağlayacağına

205
00:12:13,901 --> 00:12:17,320
kendinizi ikna etmek için bir dakikanızı ayırmanın tadını çıkarabilirsiniz.

206
00:12:17,320 --> 00:12:20,446
Hatta aranızdaki zeki biri bu sorularla ikili

207
00:12:20,446 --> 00:12:23,640
sayım arasında bir bağlantı bile fark edebilir.

208
00:12:23,640 --> 00:12:27,260
Ve eğer yaparsanız, tekrar vurgulayayım, duraklatın,

209
00:12:27,260 --> 00:12:30,880
ben onu bozmadan bağlantıyı kendiniz kurmaya çalışın.

210
00:12:30,880 --> 00:12:35,201
Bir eşlik bitinin kendisi etkilenirse ne olacağını merak ediyorsanız,

211
00:12:35,201 --> 00:12:36,560
bunu deneyebilirsiniz.

212
00:12:36,560 --> 00:12:41,754
Bir dakikanızı ayırıp bu dört özel parça arasındaki herhangi bir hatanın,

213
00:12:41,754 --> 00:12:47,440
tıpkı diğerleri gibi, dört sorudan oluşan aynı grupla nasıl bulunacağını düşünün.

214
00:12:47,440 --> 00:12:50,470
Aslında bunun bir önemi yok, çünkü günün sonunda istediğimiz şey

215
00:12:50,470 --> 00:12:53,640
mesaj bitlerini korumaktır, hata düzeltme bitleri yoluna devam eder.

216
00:12:53,640 --> 00:12:56,308
Ancak bu parçaların da korunması, doğal olarak

217
00:12:56,308 --> 00:12:59,260
bir yan ürün olarak planın dışında kalan bir şeydir.

218
00:12:59,260 --> 00:13:02,380
Bunun nasıl ölçekleneceğini tahmin etmekten de keyif alabilirsiniz.

219
00:13:02,380 --> 00:13:07,713
Örneğin, bir konumu belirlemek için 256 bit boyutunda bir blok kullansaydık,

220
00:13:07,713 --> 00:13:12,216
belirli bir noktaya giden yolu ikili olarak aramak için yalnızca

221
00:13:12,216 --> 00:13:15,680
sekiz evet veya hayır sorusuna ihtiyacınız olurdu.

222
00:13:15,680 --> 00:13:19,688
Ve unutmayın, her soru uygun eşlik kontrolünü ayarlamak

223
00:13:19,688 --> 00:13:23,340
için yalnızca tek bir bitten vazgeçmeyi gerektirir.

224
00:13:23,340 --> 00:13:26,540
Bazılarınız bunu zaten görmüş olabilir, ancak daha sonra bu soruların ne

225
00:13:26,540 --> 00:13:29,960
olduğunu bir veya iki dakika içinde bulmanın sistematik yolundan bahsedeceğiz.

226
00:13:29,960 --> 00:13:34,440
Umarım bu taslak, burada geliştirdiğimiz şeyin verimliliğini takdir etmek için yeterlidir.

227
00:13:34,440 --> 00:13:39,089
İlk şey, vurgulanan sekiz eşlik biti dışında, istediğiniz her şey olabilir,

228
00:13:39,089 --> 00:13:41,720
istediğiniz mesajı veya veriyi taşıyabilir.

229
00:13:41,720 --> 00:13:47,862
8 bit, tamamen mesajın geri kalanı tarafından belirlenmeleri anlamında gereksizdir,

230
00:13:47,862 --> 00:13:53,640
ancak bu, mesajın bir bütün olarak kopyalanmasından çok daha akıllı bir yoldur.

231
00:13:53,640 --> 00:13:56,347
Ve yine de, bu kadar az vazgeçmekle, herhangi bir

232
00:13:56,347 --> 00:13:59,000
tek bit hatasını tespit edip düzeltebileceksiniz.

233
00:13:59,000 --> 00:14:00,400
Neredeyse.

234
00:14:00,400 --> 00:14:04,724
Tamam, buradaki sorun şu ki, eğer dört eşlik kontrolünden hiçbiri bir

235
00:14:04,724 --> 00:14:09,419
hata tespit etmezse, yani özel olarak seçilmiş 8 bitlik alt kümelerin tümü,

236
00:14:09,419 --> 00:14:12,570
gönderenin amaçladığı gibi eşit eşliklere sahipse,

237
00:14:12,570 --> 00:14:17,760
o zaman bu da hiçbir hata olmadığı anlamına gelir. veya bizi 0 pozisyonuna daraltır.

238
00:14:17,760 --> 00:14:22,936
Görüyorsunuz, dört evet veya hayır sorusuyla, eşitlik kontrollerimiz için 16 olası sonuç

239
00:14:22,936 --> 00:14:27,881
var ve ilk başta bu, bloktaki 16 konumdan 1&#39;inin yerini belirlemek için mükemmel

240
00:14:27,881 --> 00:14:33,000
gibi geliyor, ancak aynı zamanda 17. sonucu da iletmeniz gerekiyor, yani hata yok durum.

241
00:14:33,000 --> 00:14:37,860
Buradaki çözüm aslında oldukça basit, sadece o 0&#39;ıncı biti tamamen unutun.

242
00:14:37,860 --> 00:14:41,998
Yani dört eşlik kontrolümüzü yaptığımızda ve hepsinin eşit olduğunu gördüğümüzde,

243
00:14:41,998 --> 00:14:44,320
bu açıkça hiçbir hata olmadığı anlamına gelir.

244
00:14:44,320 --> 00:14:49,286
Bunun anlamı, 16 bitlik bir blokla çalışmak yerine, 15 bitlik bir blokla çalışıyoruz;

245
00:14:49,286 --> 00:14:54,080
burada bitlerin 11&#39;i mesaj taşımak için serbest ve 4&#39;ü yedeklik için orada.

246
00:14:54,080 --> 00:14:56,635
Ve bununla birlikte, artık sektördeki insanların

247
00:14:56,635 --> 00:14:59,400
15-11 Hamming kodu olarak adlandıracağı şeye sahibiz.

248
00:14:59,400 --> 00:15:02,527
Bununla birlikte, 2&#39;nin temiz kuvveti olan bir blok boyutuna

249
00:15:02,527 --> 00:15:05,703
sahip olmak güzel ve bu 0&#39;ıncı biti etrafta tutmanın ve bizim

250
00:15:05,703 --> 00:15:08,880
için biraz fazladan iş yapmasını sağlamanın akıllıca bir yolu var.

251
00:15:08,880 --> 00:15:12,300
Bunu tüm blok boyunca bir eşlik biti olarak kullanırsak,

252
00:15:12,300 --> 00:15:16,320
2 bitlik hataları düzeltemesek bile aslında tespit etmemizi sağlar.

253
00:15:16,320 --> 00:15:17,440
İşte nasıl çalışıyor?

254
00:15:17,440 --> 00:15:20,336
Bu dört özel hata düzeltme bitini ayarladıktan sonra,

255
00:15:20,336 --> 00:15:24,145
tam bloğun paritesi normal bir eşlik kontrolü gibi çift olacak şekilde

256
00:15:24,145 --> 00:15:25,540
0&#39;ıncı biti ayarladık.

257
00:15:25,540 --> 00:15:29,557
Şimdi, eğer tek bir bit hatası varsa, o zaman tam bloğun paritesi tek olacak

258
00:15:29,557 --> 00:15:33,940
şekilde değişir, ancak dört hata düzeltme kontrolü sayesinde bunu yine de yakalarız.

259
00:15:33,940 --> 00:15:37,766
Bununla birlikte, eğer iki hata varsa, o zaman genel parite tekrar

260
00:15:37,766 --> 00:15:41,764
eşit duruma dönecektir, ancak alıcı yine de bu dört eşlik kontrolünde

261
00:15:41,764 --> 00:15:45,820
olup bitenlerden dolayı en azından bir miktar hata olduğunu görecektir.

262
00:15:45,820 --> 00:15:49,400
Yani genel olarak eşit bir eşitlik fark ederlerse ancak diğer kontrollerde

263
00:15:49,400 --> 00:15:52,980
sıfırdan farklı bir şey oluyorsa, bu onlara en az iki hata olduğunu söyler.

264
00:15:52,980 --> 00:15:54,420
Bu çok akıllıca değil mi?

265
00:15:54,420 --> 00:15:57,264
Her ne kadar bu 2 bitlik hataları düzeltemesek de,

266
00:15:57,264 --> 00:16:00,555
o küçük can sıkıcı 0&#39;ıncı biti tekrar devreye sokarak,

267
00:16:00,555 --> 00:16:02,340
onları tespit etmemizi sağlıyor.

268
00:16:02,340 --> 00:16:06,540
Bu oldukça standarttır, genişletilmiş Hamming kodu olarak bilinir.

269
00:16:06,540 --> 00:16:10,111
Teknik açıdan konuşursak, artık en azından 16 bitlik bir blok örneği

270
00:16:10,111 --> 00:16:13,580
için Hamming kodunun ne yaptığının tam bir açıklamasına sahipsiniz.

271
00:16:13,580 --> 00:16:17,804
Ancak, baştan sona kendi başınıza tam bir örnek yaparak anlayışınızı kontrol etmeyi ve

272
00:16:17,804 --> 00:16:21,980
bu noktaya kadar her şeyi sağlamlaştırmayı daha tatmin edici bulacağınızı düşünüyorum.

273
00:16:21,980 --> 00:16:25,100
Kendinizi kontrol edebilmeniz için ben de sizinle birlikte üzerinden geçeceğim.

274
00:16:25,100 --> 00:16:30,248
İster uzayda çevirdiğiniz gerçek bir mesaj, ister zaman içinde depolamak istediğiniz

275
00:16:30,248 --> 00:16:35,700
bazı veriler olsun, bir mesaj oluşturmak için ilk adım, onu 11 bitlik parçalara bölmektir.

276
00:16:35,700 --> 00:16:40,340
Her parça, hataya dayanıklı 16 bitlik bir blok halinde paketlenecek.

277
00:16:40,340 --> 00:16:43,740
Hadi bunu bir örnek olarak alalım ve gerçekten üzerinde çalışalım.

278
00:16:43,740 --> 00:16:45,380
Devam edin, gerçekten yapın!

279
00:16:45,380 --> 00:16:52,980
Durup bu bloğu bir araya getirmeyi deneyelim.

280
00:16:52,980 --> 00:16:53,980
Tamam, hazır mısın?

281
00:16:53,980 --> 00:17:00,115
Unutmayın, 0 konumu ve 2&#39;nin diğer kuvvetleri hata düzeltme görevi için ayrılmıştır,

282
00:17:00,115 --> 00:17:05,700
bu nedenle mesaj bitlerini kalan tüm noktalara sırayla yerleştirerek başlarsınız.

283
00:17:05,700 --> 00:17:08,856
Bu grubun çift eşlikli olması gerekir ki zaten öyledir,

284
00:17:08,856 --> 00:17:13,140
dolayısıyla 1 konumundaki eşlik bitini 0 olacak şekilde ayarlamanız gerekir.

285
00:17:13,140 --> 00:17:16,554
Bir sonraki grup tek bir eşlikle başlar, dolayısıyla

286
00:17:16,554 --> 00:17:19,260
eşlik bitini 1 olarak ayarlamanız gerekir.

287
00:17:19,260 --> 00:17:22,167
Bundan sonraki grup tek eşlikle başlar, dolayısıyla

288
00:17:22,167 --> 00:17:24,740
eşlik bitini yine 1&#39;e ayarlamanız gerekir.

289
00:17:24,740 --> 00:17:31,500
Ve son grubun da tek bir paritesi var, yani bu biti 8 pozisyonuna 1 olarak ayarladık.

290
00:17:31,500 --> 00:17:35,571
Ve son adım olarak, tam bloğun artık çift bir eşlik durumu var; bu,

291
00:17:35,571 --> 00:17:40,482
0 numaralı bit sayısını, yani kapsayıcı eşlik bitini 0 olarak ayarlayabileceğiniz

292
00:17:40,482 --> 00:17:41,500
anlamına geliyor.

293
00:17:41,500 --> 00:17:45,240
Yani bu blok gönderildiğinde, dört özel alt kümenin ve

294
00:17:45,240 --> 00:17:48,980
bir bütün olarak bloğun paritesi çift veya 0 olacaktır.

295
00:17:48,980 --> 00:17:53,620
Alıştırmanın ikinci bölümünde alıcı rolünü oynamanızı sağlayalım.

296
00:17:53,620 --> 00:17:56,948
Tabii bu, bu mesajın ne olduğunu henüz bilmediğiniz anlamına gelir,

297
00:17:56,948 --> 00:18:00,180
belki bazılarınız ezberlemiştir, ama varsayalım ki ezberlemediniz.

298
00:18:00,180 --> 00:18:04,189
Yapacağım şey, o bloktaki bitlerden 0, 1 veya 2&#39;sini

299
00:18:04,189 --> 00:18:08,340
değiştirmek ve sonra sizden ne yaptığımı bulmanızı istemek.

300
00:18:08,340 --> 00:18:13,460
Tekrar duraklatın ve çözmeye çalışın.

301
00:18:13,460 --> 00:18:21,039
Tamam, şimdi alıcı olarak siz ilk eşlik grubunu kontrol ediyorsunuz ve bunun çift

302
00:18:21,039 --> 00:18:29,080
olduğunu görebiliyorsunuz, dolayısıyla mevcut herhangi bir hatanın çift sütunda olması

303
00:18:29,080 --> 00:18:29,820
gerekir.

304
00:18:29,820 --> 00:18:33,077
Bir sonraki kontrol bize tek bir sayı veriyor,

305
00:18:33,077 --> 00:18:38,760
ikimize de en az bir hata olduğunu söylüyor ve bizi bu spesifik sütuna daraltıyor.

306
00:18:38,760 --> 00:18:42,900
Üçüncü kontrol eşittir, olasılıkları daha da azaltır.

307
00:18:42,900 --> 00:18:47,633
Ve son eşlik kontrolü tuhaf, bize altta bir yerde bir hata olduğunu söylüyor,

308
00:18:47,633 --> 00:18:51,700
şu anda bunun 10 numaralı konumda olması gerektiğini görebiliyoruz.

309
00:18:51,700 --> 00:18:55,425
Dahası, tüm bloğun paritesi tuhaftır ve bize iki değil,

310
00:18:55,425 --> 00:18:58,220
tek bir atış olduğu konusunda güven verir.

311
00:18:58,220 --> 00:19:01,600
Üç veya daha fazla ise tüm bahisler kapalıdır.

312
00:19:01,600 --> 00:19:06,241
10 numaralı biti düzelttikten sonra, düzeltme için kullanılmayan 11 biti

313
00:19:06,241 --> 00:19:09,674
çıkarmak bize orijinal mesajın ilgili bölümünü verir;

314
00:19:09,674 --> 00:19:14,443
geri sararsanız ve karşılaştırırsanız, bu gerçekten de örneğe başladığımız

315
00:19:14,443 --> 00:19:16,160
şeyin tam olarak aynısıdır.

316
00:19:16,160 --> 00:19:18,797
Artık tüm bunları elle nasıl yapacağınızı bildiğinize göre,

317
00:19:18,797 --> 00:19:21,918
size tüm bu mantığın temel kısmını tek bir Python kodu satırıyla nasıl

318
00:19:21,918 --> 00:19:23,940
gerçekleştirebileceğinizi göstermek istiyorum.

319
00:19:23,940 --> 00:19:27,885
Görüyorsunuz, size henüz söylemediğim şey, bu algoritmanın gerçekte ne kadar zarif

320
00:19:27,885 --> 00:19:31,498
olduğu, bir makinenin hatanın konumunu göstermesinin ne kadar basit olduğu,

321
00:19:31,498 --> 00:19:34,826
bunu sistematik olarak nasıl ölçeklendireceğimiz ve tüm bunları nasıl

322
00:19:34,826 --> 00:19:38,581
çerçeveleyebileceğimizdir. bu, birden fazla ayrı eşlik kontrolü yerine tek bir

323
00:19:38,581 --> 00:19:39,580
işlem olarak yapılır.

324
00:19:39,580 --> 00:19:39,580
Ne demek istediğimi anlamak için 2. bölümde bana katılın.

