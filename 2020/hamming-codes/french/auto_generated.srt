1
00:00:00,000 --> 00:00:03,120
Je suppose que tout le monde ici vient de la partie 1.

2
00:00:03,120 --> 00:00:06,823
Nous parlions des codes de Hamming, une façon de créer un bloc de données dont

3
00:00:06,823 --> 00:00:10,574
la plupart des bits portent un message significatif, tandis que quelques autres

4
00:00:10,574 --> 00:00:14,418
agissent comme une sorte de redondance, de telle sorte que si un bit est inversé,

5
00:00:14,418 --> 00:00:18,028
soit un message bit ou un bit de redondance, n'importe quoi dans ce bloc, un

6
00:00:18,028 --> 00:00:21,920
récepteur sera capable d'identifier qu'il y a eu une erreur et comment la corriger.

7
00:00:21,920 --> 00:00:25,806
L'idée de base présentée ici était de savoir comment utiliser plusieurs

8
00:00:25,806 --> 00:00:29,800
contrôles de parité pour effectuer une recherche binaire jusqu'à l'erreur.

9
00:00:29,800 --> 00:00:32,535
Dans cette vidéo, l'objectif était de rendre les codes

10
00:00:32,535 --> 00:00:35,420
de Hamming aussi pratiques et redécouvrables que possible.

11
00:00:35,420 --> 00:00:38,164
Mais lorsque vous commencez à réfléchir à la mise en œuvre

12
00:00:38,164 --> 00:00:41,095
réelle de cela, que ce soit au niveau logiciel ou matériel, ce

13
00:00:41,095 --> 00:00:44,120
cadrage peut en fait sous-estimer l'élégance réelle de ces codes.

14
00:00:44,120 --> 00:00:47,376
Vous pensez peut-être que vous devez écrire un algorithme qui garde une

15
00:00:47,376 --> 00:00:50,632
trace de tous les emplacements d'erreur possibles et coupe ce groupe de

16
00:00:50,632 --> 00:00:54,160
moitié à chaque vérification, mais c'est en réalité bien plus simple que cela.

17
00:00:54,160 --> 00:00:57,596
Si vous lisez les réponses aux quatre contrôles de parité que nous avons

18
00:00:57,596 --> 00:01:01,174
effectués dans la dernière vidéo, toutes sous forme de 1 et de 0 au lieu de

19
00:01:01,174 --> 00:01:04,800
oui et de non, cela indique littéralement la position de l'erreur en binaire.

20
00:01:04,800 --> 00:01:08,790
Par exemple, le nombre 7 en binaire ressemble à 0111, ce

21
00:01:08,790 --> 00:01:12,640
qui signifie essentiellement que c'est 4 plus 2 plus 1.

22
00:01:12,640 --> 00:01:17,202
Et remarquez où se situe la position 7, elle affecte le premier de nos

23
00:01:17,202 --> 00:01:22,280
groupes paritaires, ainsi que le deuxième et le troisième, mais pas le dernier.

24
00:01:22,280 --> 00:01:25,515
Ainsi, la lecture des résultats de ces quatre contrôles

25
00:01:25,515 --> 00:01:28,520
de bas en haut précise bien la position de l’erreur.

26
00:01:28,520 --> 00:01:32,879
Il n'y a rien de spécial dans l'exemple 7, cela fonctionne en général, et cela rend la

27
00:01:32,879 --> 00:01:36,938
logique d'implémentation de l'ensemble du schéma matériellement d'une simplicité

28
00:01:36,938 --> 00:01:37,440
choquante.

29
00:01:37,440 --> 00:01:41,971
Maintenant, si vous voulez voir pourquoi cette magie se produit, prenez

30
00:01:41,971 --> 00:01:46,566
ces 16 étiquettes d'index pour nos positions, mais au lieu de les écrire

31
00:01:46,566 --> 00:01:50,720
en base 10, écrivons-les toutes en binaire, allant de 0000 à 1111.

32
00:01:50,720 --> 00:01:54,884
Alors que nous remettons ces étiquettes binaires dans leurs boîtes, permettez-moi

33
00:01:54,884 --> 00:01:58,440
de souligner qu'elles sont distinctes des données réellement envoyées.

34
00:01:58,440 --> 00:02:01,299
Ce n'est rien de plus qu'une étiquette conceptuelle pour nous aider,

35
00:02:01,299 --> 00:02:04,200
vous et moi, à comprendre d'où viennent les quatre groupes paritaires.

36
00:02:04,200 --> 00:02:08,707
L'élégance d'avoir tout ce que nous regardons soit décrit en binaire est peut-être

37
00:02:08,707 --> 00:02:13,160
sapée par la confusion d'avoir tout ce que nous regardons étant décrit en binaire.

38
00:02:13,160 --> 00:02:15,040
Mais ça vaut le coup.

39
00:02:15,040 --> 00:02:19,356
Concentrez votre attention uniquement sur le dernier bit de toutes ces

40
00:02:19,356 --> 00:02:24,280
étiquettes, puis mettez en surbrillance les positions où ce dernier bit est un 1.

41
00:02:24,280 --> 00:02:28,190
Ce que nous obtenons est le premier de nos quatre groupes de parité, ce qui

42
00:02:28,190 --> 00:02:32,666
signifie que vous pouvez interpréter cette première vérification comme demandant : hé,

43
00:02:32,666 --> 00:02:36,680
s’il y a une erreur, le dernier bit à la position de cette erreur est-il un 1?

44
00:02:36,680 --> 00:02:40,076
De même, si vous vous concentrez sur l'avant-dernier bit et

45
00:02:40,076 --> 00:02:43,586
mettez en surbrillance toutes les positions où il s'agit d'un

46
00:02:43,586 --> 00:02:47,040
1, vous obtenez le deuxième groupe de parité de notre schéma.

47
00:02:47,040 --> 00:02:51,478
En d’autres termes, cette deuxième vérification demande : hé, encore une

48
00:02:51,478 --> 00:02:56,160
fois, s’il y a une erreur, l’avant-dernier bit de cette position est-il un 1?

49
00:02:56,160 --> 00:02:57,160
Et ainsi de suite.

50
00:02:57,160 --> 00:03:01,168
Le troisième contrôle de parité couvre chaque position dont

51
00:03:01,168 --> 00:03:05,310
l'avant-dernier bit est activé, et le dernier couvre les huit

52
00:03:05,310 --> 00:03:10,120
dernières positions, celles dont le bit de poids le plus élevé est un 1.

53
00:03:10,120 --> 00:03:14,808
Tout ce que nous avons fait plus tôt revient à répondre à ces

54
00:03:14,808 --> 00:03:19,800
quatre questions, ce qui revient à épeler une position en binaire.

55
00:03:19,800 --> 00:03:22,080
J'espère que cela rend deux choses plus claires.

56
00:03:22,080 --> 00:03:24,590
La première est de savoir comment généraliser systématiquement à

57
00:03:24,590 --> 00:03:27,140
des tailles de blocs qui sont des puissances de deux plus grandes.

58
00:03:27,140 --> 00:03:32,506
S'il faut plus de bits pour décrire chaque position, comme six bits pour décrire 64

59
00:03:32,506 --> 00:03:38,065
points, alors chacun de ces bits vous donne l'un des groupes de parité que nous devons

60
00:03:38,065 --> 00:03:38,640
vérifier.

61
00:03:38,640 --> 00:03:41,087
Ceux d’entre vous qui ont regardé le puzzle d’échiquier que j’ai réalisé

62
00:03:41,087 --> 00:03:43,400
avec Matt Parker trouveront peut-être tout cela extrêmement familier.

63
00:03:43,400 --> 00:03:46,848
C'est la même logique de base, mais résolvant un problème

64
00:03:46,848 --> 00:03:49,880
différent, et appliquée à un échiquier de 64 cases.

65
00:03:49,880 --> 00:03:52,754
La deuxième chose que j'espère que cela clarifie est la raison

66
00:03:52,754 --> 00:03:55,673
pour laquelle nos bits de parité se trouvent dans des positions

67
00:03:55,673 --> 00:03:58,320
qui sont des puissances de deux, par exemple 1, 2, 4 et 8.

68
00:03:58,320 --> 00:04:03,640
Ce sont les positions dont la représentation binaire n'a qu'un seul bit activé.

69
00:04:03,640 --> 00:04:07,925
Cela signifie que chacun de ces bits de parité se

70
00:04:07,925 --> 00:04:12,640
trouve dans un et un seul des quatre groupes de parité.

71
00:04:12,640 --> 00:04:19,236
Vous pouvez également le constater dans des exemples plus grands, où quelle

72
00:04:19,236 --> 00:04:25,920
que soit votre taille, chaque bit de parité ne touche qu'un seul des groupes.

73
00:04:25,920 --> 00:04:29,520
Une fois que vous comprenez que ces contrôles de parité sur lesquels nous avons consacré

74
00:04:29,520 --> 00:04:32,836
une grande partie de notre temps ne sont rien de plus qu'une manière intelligente

75
00:04:32,836 --> 00:04:36,477
d'épeler la position d'une erreur en binaire, nous pouvons alors établir un lien avec une

76
00:04:36,477 --> 00:04:39,955
manière différente de penser au hamming. des codes, qui sont sans doute beaucoup plus

77
00:04:39,955 --> 00:04:43,596
simples et plus élégants, et qui peuvent essentiellement être écrits avec une seule ligne

78
00:04:43,596 --> 00:04:43,920
de code.

79
00:04:43,920 --> 00:04:46,200
Il est basé sur la fonction XOR.

80
00:04:46,200 --> 00:04:50,960
XOR, pour ceux d'entre vous qui ne le savent pas, signifie exclusif ou.

81
00:04:50,960 --> 00:04:55,646
Lorsque vous effectuez le XOR de deux bits, il renvoie un 1 si l'un de

82
00:04:55,646 --> 00:05:00,200
ces bits est activé, mais pas si les deux sont activés ou désactivés.

83
00:05:00,200 --> 00:05:03,760
Exprimé différemment, c'est la parité de ces deux bits.

84
00:05:03,760 --> 00:05:07,840
En tant que mathématicien, je préfère y penser comme un mod d'addition 2.

85
00:05:07,840 --> 00:05:10,705
Nous parlons aussi couramment du XOR de deux chaînes de bits

86
00:05:10,705 --> 00:05:14,040
différentes, qui effectue essentiellement cela composant par composant.

87
00:05:14,040 --> 00:05:16,280
C'est comme une addition, mais où l'on ne porte jamais.

88
00:05:16,280 --> 00:05:19,949
Encore une fois, les plus enclins aux mathématiques préféreront peut-être

89
00:05:19,949 --> 00:05:23,520
considérer cela comme l'ajout de deux vecteurs et la réduction du mod 2.

90
00:05:23,520 --> 00:05:29,598
Si vous ouvrez Python dès maintenant et appliquez l'opération caret entre deux entiers,

91
00:05:29,598 --> 00:05:35,400
c'est ce qu'il fait, mais aux représentations binaires de ces nombres sous le capot.

92
00:05:35,400 --> 00:05:40,752
Le point clé pour vous et moi est que prendre le XOR de nombreuses chaînes de

93
00:05:40,752 --> 00:05:45,830
bits différentes est effectivement un moyen de calculer les parodies d'un

94
00:05:45,830 --> 00:05:51,320
groupe de groupes séparés, comme c'est le cas avec les colonnes, d'un seul coup.

95
00:05:51,320 --> 00:05:55,523
Cela nous donne une façon plutôt élégante de considérer les multiples contrôles de parité

96
00:05:55,523 --> 00:05:59,680
de notre algorithme de code de Hamming comme étant tous regroupés en une seule opération.

97
00:05:59,680 --> 00:06:02,800
Même si à première vue, cela semble très différent.

98
00:06:02,800 --> 00:06:08,623
Notez spécifiquement les 16 positions en binaire, comme nous l'avions fait auparavant,

99
00:06:08,623 --> 00:06:14,179
et mettez maintenant en surbrillance les positions où le bit de message est activé

100
00:06:14,179 --> 00:06:19,400
sur 1, puis rassemblez ces positions dans une grande colonne et prenez le XOR.

101
00:06:19,400 --> 00:06:23,907
Vous pouvez probablement deviner que les 4 bits situés en bas sont

102
00:06:23,907 --> 00:06:28,212
les mêmes que les 4 contrôles de parité que nous connaissons et

103
00:06:28,212 --> 00:06:32,720
aimons, mais prenez un moment pour réfléchir à pourquoi exactement.

104
00:06:32,720 --> 00:06:36,090
Cette dernière colonne, par exemple, compte toutes les positions dont

105
00:06:36,090 --> 00:06:39,267
le dernier bit est un 1, mais nous sommes déjà limités uniquement

106
00:06:39,267 --> 00:06:42,397
aux positions en surbrillance, elle compte donc effectivement le

107
00:06:42,397 --> 00:06:45,960
nombre de positions en surbrillance provenant du premier groupe de parité.

108
00:06:45,960 --> 00:06:48,520
Cela a-t-il du sens?

109
00:06:48,520 --> 00:06:52,481
De même, la colonne suivante compte le nombre de positions dans le

110
00:06:52,481 --> 00:06:56,383
deuxième groupe de parité, les positions dont l'avant-dernier bit

111
00:06:56,383 --> 00:07:00,640
est un 1 et qui sont également mises en surbrillance, et ainsi de suite.

112
00:07:00,640 --> 00:07:03,766
Il s'agit en réalité d'un petit changement de

113
00:07:03,766 --> 00:07:07,640
perspective par rapport à la même chose que nous faisons.

114
00:07:07,640 --> 00:07:10,000
Et donc vous savez où cela va à partir de maintenant.

115
00:07:10,000 --> 00:07:14,614
L'expéditeur est responsable d'activer certains bits de

116
00:07:14,614 --> 00:07:19,640
parité spéciaux pour s'assurer que la somme est égale à 0000.

117
00:07:19,640 --> 00:07:22,697
Maintenant, une fois que nous avons cela, cela nous donne une très

118
00:07:22,697 --> 00:07:25,754
bonne façon de réfléchir à la raison pour laquelle ces quatre bits

119
00:07:25,754 --> 00:07:28,720
résultants en bas indiquent directement la position d'une erreur.

120
00:07:28,720 --> 00:07:32,720
Disons qu'un élément de ce bloc passe de 0 à 1.

121
00:07:32,720 --> 00:07:38,692
Cela signifie que la position de ce bit va maintenant être incluse dans le XOR total, ce

122
00:07:38,692 --> 00:07:44,196
qui fait passer la somme de 0 à cette valeur nouvellement incluse, la position de

123
00:07:44,196 --> 00:07:44,800
l'erreur.

124
00:07:44,800 --> 00:07:47,221
De manière un peu moins évidente, il en va de

125
00:07:47,221 --> 00:07:49,800
même s'il y a une erreur qui change un 1 en un 0.

126
00:07:49,800 --> 00:07:54,371
Vous voyez, si vous ajoutez deux fois une petite chaîne, cela revient à ne pas

127
00:07:54,371 --> 00:07:59,000
l'avoir du tout, essentiellement parce que dans ce monde, 1 plus 1 est égal à 0.

128
00:07:59,000 --> 00:08:02,200
Ainsi, ajouter une copie de cette position à la

129
00:08:02,200 --> 00:08:05,400
somme totale a le même effet que de la déplacer.

130
00:08:05,400 --> 00:08:09,520
Et cet effet, encore une fois, est que le résultat

131
00:08:09,520 --> 00:08:13,480
total en bas indique ici la position de l’erreur.

132
00:08:13,480 --> 00:08:16,315
Pour illustrer à quel point cela est élégant, permettez-moi de

133
00:08:16,315 --> 00:08:19,420
montrer cette ligne de code Python que j'ai référencée précédemment,

134
00:08:19,420 --> 00:08:22,120
qui capturera presque toute la logique du côté du récepteur.

135
00:08:22,120 --> 00:08:26,227
Nous allons commencer par créer un tableau aléatoire de 16 1 et 0 pour simuler

136
00:08:26,227 --> 00:08:30,074
le bloc de données, et je lui donnerai le nom des bits, mais bien sûr, en

137
00:08:30,074 --> 00:08:34,233
pratique, ce serait quelque chose que nous recevons d'un expéditeur, et au lieu

138
00:08:34,233 --> 00:08:38,600
de étant aléatoire, il transporterait 11 bits de données ainsi que 5 bits de parité.

139
00:08:38,600 --> 00:08:43,382
Si j'appelle la fonction enumerateBits, elle associe chacun de

140
00:08:43,382 --> 00:08:48,240
ces bits à un index correspondant, dans ce cas allant de 0 à 15.

141
00:08:48,240 --> 00:08:52,693
Donc, si nous créons ensuite une liste qui boucle sur toutes ces paires, des paires

142
00:08:52,693 --> 00:08:57,466
qui ressemblent à i, et que nous extrayons ensuite uniquement la valeur i, juste l'index,

143
00:08:57,466 --> 00:09:01,920
eh bien, ce n'est pas si excitant, nous récupérons simplement ces indices de 0 à 15.

144
00:09:01,920 --> 00:09:05,870
Mais si nous ajoutons la condition de ne faire cela que si bit,

145
00:09:05,870 --> 00:09:09,696
c'est-à-dire si ce bit est un 1 et non un 0, alors il extrait

146
00:09:09,696 --> 00:09:13,400
uniquement les positions où le bit correspondant est activé.

147
00:09:13,400 --> 00:09:20,720
Dans ce cas, il semble que ces positions soient 0, 4, 6, 9, etc.

148
00:09:20,720 --> 00:09:25,227
Ce que nous voulons, c'est rassembler toutes ces positions,

149
00:09:25,227 --> 00:09:29,960
les positions des bits qui sont activés, puis les XOR ensemble.

150
00:09:29,960 --> 00:09:33,960
Pour ce faire en Python, permettez-moi d'abord d'importer quelques fonctions utiles.

151
00:09:33,960 --> 00:09:36,428
De cette façon, nous pouvons appeler réduire() sur

152
00:09:36,428 --> 00:09:39,140
cette liste et utiliser la fonction XOR pour la réduire.

153
00:09:39,140 --> 00:09:44,840
Cela se fraye un chemin à travers la liste, prenant des XORs en cours de route.

154
00:09:44,840 --> 00:09:48,653
Si vous préférez, vous pouvez écrire explicitement cette

155
00:09:48,653 --> 00:09:52,200
fonction XOR sans avoir à l'importer de n'importe où.

156
00:09:52,200 --> 00:09:57,004
Donc pour le moment, il semble que si nous faisons cela sur notre bloc

157
00:09:57,004 --> 00:10:02,080
aléatoire de 16 bits, cela renvoie 9, qui a la représentation binaire 1001.

158
00:10:02,080 --> 00:10:05,946
Nous ne le ferons pas ici, mais vous pouvez écrire une fonction dans laquelle

159
00:10:05,946 --> 00:10:09,615
l'expéditeur utilise cette représentation binaire pour définir les quatre

160
00:10:09,615 --> 00:10:13,283
bits de parité selon les besoins, amenant finalement ce bloc à un état où

161
00:10:13,283 --> 00:10:17,200
l'exécution de cette ligne de code sur la liste complète des bits renvoie un 0.

162
00:10:17,200 --> 00:10:20,200
Cela serait considéré comme un bloc bien préparé.

163
00:10:20,200 --> 00:10:23,523
Ce qui est cool, c'est que si nous basculons l'un des bits de

164
00:10:23,523 --> 00:10:26,901
cette liste, simulant une erreur aléatoire due au bruit, alors

165
00:10:26,901 --> 00:10:30,600
si vous exécutez cette même ligne de code, cette erreur est affichée.

166
00:10:30,600 --> 00:10:31,920
N'est-ce pas sympa?

167
00:10:31,920 --> 00:10:37,353
Vous pouvez obtenir ce bloc à l'improviste, exécuter cette seule ligne dessus, et

168
00:10:37,353 --> 00:10:42,920
il crachera automatiquement la position d'une erreur, ou un 0 s'il n'y en avait pas.

169
00:10:42,920 --> 00:10:45,520
Et il n'y a rien de spécial concernant la taille 16 ici.

170
00:10:45,520 --> 00:10:52,280
La même ligne de code fonctionnerait si vous aviez une liste de, disons, 256 bits.

171
00:10:52,280 --> 00:10:56,775
Inutile de dire qu'il y a plus de code à écrire ici, comme effectuer la vérification

172
00:10:56,775 --> 00:11:01,007
de méta-parité pour détecter les erreurs de 2 bits, mais l'idée est que presque

173
00:11:01,007 --> 00:11:05,080
toute la logique de base de notre schéma se résume à une seule réduction XOR.

174
00:11:05,080 --> 00:11:08,548
Maintenant, selon votre aisance avec les binaires, les XOR et les

175
00:11:08,548 --> 00:11:12,121
logiciels en général, vous pouvez soit trouver cette perspective un

176
00:11:12,121 --> 00:11:15,746
peu déroutante, soit tellement plus élégante et simple que vous vous

177
00:11:15,746 --> 00:11:19,320
demandez pourquoi nous ne l'avons pas commencé dès le début. -aller.

178
00:11:19,320 --> 00:11:22,411
En gros, la perspective du contrôle de parité multiple est plus facile

179
00:11:22,411 --> 00:11:25,371
à penser lors de l'implémentation très directe des codes de Hamming

180
00:11:25,371 --> 00:11:28,332
dans le matériel, et la perspective XOR est la plus facile à penser

181
00:11:28,332 --> 00:11:31,380
lorsqu'on l'effectue dans le logiciel, à partir d'un niveau supérieur.

182
00:11:31,380 --> 00:11:35,167
Le premier est le plus simple à réaliser à la main, et je pense qu'il

183
00:11:35,167 --> 00:11:38,846
fait un meilleur travail en inculquant l'intuition fondamentale qui

184
00:11:38,846 --> 00:11:42,904
sous-tend tout cela, à savoir que les informations requises pour localiser

185
00:11:42,904 --> 00:11:46,637
une seule erreur sont liées au journal de la taille du bloc. , ou en

186
00:11:46,637 --> 00:11:51,020
d’autres termes, il augmente petit à petit à mesure que la taille du bloc double.

187
00:11:51,020 --> 00:11:53,775
Le fait pertinent ici est que ces informations correspondent

188
00:11:53,775 --> 00:11:56,440
directement au niveau de redondance dont nous avons besoin.

189
00:11:56,440 --> 00:11:59,160
C'est vraiment ce qui va à l'encontre de la réaction instinctive de

190
00:11:59,160 --> 00:12:01,960
la plupart des gens lorsqu'ils pensent pour la première fois à rendre

191
00:12:01,960 --> 00:12:04,680
un message résistant aux erreurs, alors que copier l'intégralité du

192
00:12:04,680 --> 00:12:07,520
message est généralement le premier instinct qui leur vient à l'esprit.

193
00:12:07,520 --> 00:12:11,231
Et puis, en passant, il y a cette toute autre façon de voir parfois les codes

194
00:12:11,231 --> 00:12:14,800
de Hamming présentés, où vous multipliez le message par une grande matrice.

195
00:12:14,800 --> 00:12:20,040
C'est plutôt sympa car cela le relie à la famille plus large des codes linéaires, mais

196
00:12:20,040 --> 00:12:25,160
je pense que cela ne donne presque aucune intuition sur son origine ou son évolution.

197
00:12:25,160 --> 00:12:28,637
Et en parlant de mise à l'échelle, vous remarquerez peut-être que l'efficacité de

198
00:12:28,637 --> 00:12:32,200
ce système ne fait que s'améliorer à mesure que nous augmentons la taille des blocs.

199
00:12:32,200 --> 00:12:37,625
Par exemple, nous avons vu qu'avec 256 bits, vous n'utilisez que 3 % de cet

200
00:12:37,625 --> 00:12:43,480
espace pour la redondance, et la situation ne cesse de s'améliorer à partir de là.

201
00:12:43,480 --> 00:12:46,288
À mesure que le nombre de bits de parité augmente

202
00:12:46,288 --> 00:12:49,040
un par un, la taille du bloc continue de doubler.

203
00:12:49,040 --> 00:12:52,767
Et si vous poussez cela à l'extrême, vous pourriez avoir un bloc avec,

204
00:12:52,767 --> 00:12:56,495
disons, un million de bits, dans lequel vous joueriez littéralement 20

205
00:12:56,495 --> 00:13:00,800
questions avec vos contrôles de parité, et il n'utiliserait que 21 bits de parité.

206
00:13:00,800 --> 00:13:04,690
Et si vous prenez du recul et réfléchissez à examiner un million

207
00:13:04,690 --> 00:13:08,640
de bits et à localiser une seule erreur, cela semble vraiment fou.

208
00:13:08,640 --> 00:13:13,527
Le problème, bien sûr, est qu’avec un bloc plus grand, la probabilité de voir plus d’un

209
00:13:13,527 --> 00:13:18,360
ou deux bits d’erreur augmente, et les codes de Hamming ne gèrent rien d’autre au-delà.

210
00:13:18,360 --> 00:13:22,415
Donc, en pratique, ce que vous voudriez, c'est trouver la bonne taille pour que la

211
00:13:22,415 --> 00:13:26,520
probabilité d'un trop grand nombre de retournements de bits ne soit pas trop élevée.

212
00:13:26,520 --> 00:13:31,098
De plus, dans la pratique, les erreurs ont tendance à se produire par petites

213
00:13:31,098 --> 00:13:35,677
rafales, ce qui ruinerait totalement un seul bloc. Une tactique courante pour

214
00:13:35,677 --> 00:13:40,373
aider à répartir une rafale d'erreurs sur de nombreux blocs différents consiste

215
00:13:40,373 --> 00:13:45,480
à entrelacer ces blocs, comme ceci, avant qu'ils ne soient générés. envoyés ou stockés.

216
00:13:45,480 --> 00:13:48,947
Là encore, une grande partie de cela est rendue complètement sans objet par

217
00:13:48,947 --> 00:13:52,370
des codes plus modernes, comme l'algorithme de Reed-Solomon, beaucoup plus

218
00:13:52,370 --> 00:13:55,883
couramment utilisé, qui gère particulièrement bien les erreurs en rafale, et

219
00:13:55,883 --> 00:13:59,580
il peut être réglé pour être résilient à un plus grand nombre d'erreurs par bloc.

220
00:13:59,580 --> 00:14:03,000
Mais c'est un sujet pour une autre fois.

221
00:14:03,000 --> 00:14:06,878
Dans son livre The Art of Doing Science and Engineering, Hamming est

222
00:14:06,878 --> 00:14:10,700
merveilleusement franc sur les méandres de sa découverte de ce code.

223
00:14:10,700 --> 00:14:14,472
Il a d'abord essayé toutes sortes de schémas différents impliquant l'organisation des

224
00:14:14,472 --> 00:14:18,420
bits en parties d'un réseau de dimension supérieure et des choses étranges comme celle-ci.

225
00:14:18,420 --> 00:14:21,772
L'idée qu'il pourrait être possible d'obtenir des contrôles de parité pour

226
00:14:21,772 --> 00:14:25,483
conspirer d'une manière qui précise la position d'une erreur n'est venue à Hamming

227
00:14:25,483 --> 00:14:28,836
que lorsqu'il a pris du recul après un tas d'autres analyses et a demandé,

228
00:14:28,836 --> 00:14:32,860
d'accord, quelle est la méthode la plus efficace possible. peut-être qu'il s'agisse de ça?

229
00:14:32,860 --> 00:14:35,812
Il a également souligné à quel point il était important que les

230
00:14:35,812 --> 00:14:38,810
contrôles de parité soient déjà présents dans son esprit, ce qui

231
00:14:38,810 --> 00:14:42,040
aurait été beaucoup moins courant dans les années 1940 qu'aujourd'hui.

232
00:14:42,040 --> 00:14:45,791
Il y a environ une demi-douzaine de fois tout au long de ce livre où il fait

233
00:14:45,791 --> 00:14:49,640
référence à la citation de Louis Pasteur, la chance favorise un esprit préparé.

234
00:14:49,640 --> 00:14:52,402
Avec le recul, les idées intelligentes semblent souvent d’une

235
00:14:52,402 --> 00:14:55,120
simplicité trompeuse, ce qui les rend faciles à sous-estimer.

236
00:14:55,120 --> 00:14:58,470
À l’heure actuelle, j’espère honnêtement que les codes de Hamming, ou

237
00:14:58,470 --> 00:15:01,820
du moins la possibilité de tels codes, vous semblent presque évidents.

238
00:15:01,820 --> 00:15:05,014
Mais vous ne devriez pas vous tromper en pensant qu’ils sont

239
00:15:05,014 --> 00:15:08,000
en réalité évidents, car ils ne le sont certainement pas.

240
00:15:08,000 --> 00:15:11,815
Une partie de la raison pour laquelle les idées intelligentes semblent trompeusement

241
00:15:11,815 --> 00:15:15,855
faciles est que nous ne voyons que le résultat final, nettoyant ce qui était en désordre,

242
00:15:15,855 --> 00:15:19,850
sans jamais mentionner tous les mauvais virages, sous-estimant à quel point l'espace des

243
00:15:19,850 --> 00:15:23,845
possibilités explorables est vaste au début d'un problème. processus de résolution, tout

244
00:15:23,845 --> 00:15:23,980
ça.

245
00:15:23,980 --> 00:15:25,280
Mais cela est vrai en général.

246
00:15:25,280 --> 00:15:27,982
Je pense que pour certaines inventions spéciales, il y a une

247
00:15:27,982 --> 00:15:31,040
deuxième raison, plus profonde, pour laquelle nous les sous-estimons.

248
00:15:31,040 --> 00:15:34,084
La conception de l'information en termes de bits n'a véritablement

249
00:15:34,084 --> 00:15:36,673
abouti à une théorie complète qu'en 1948, avec l'article

250
00:15:36,673 --> 00:15:39,400
fondateur de Claude Shannon sur la théorie de l'information.

251
00:15:39,400 --> 00:15:43,440
Cela correspondait essentiellement au moment où Hamming développait son algorithme.

252
00:15:43,440 --> 00:15:46,900
Il s’agissait du même article fondateur qui montrait, dans un certain

253
00:15:46,900 --> 00:15:50,459
sens, qu’une correction d’erreur efficace est toujours possible, quelle

254
00:15:50,459 --> 00:15:53,920
que soit la probabilité de retournements de bits, du moins en théorie.

255
00:15:53,920 --> 00:15:58,018
Shannon et Hamming, d'ailleurs, partageaient un bureau dans les Bell Labs, bien qu'ils

256
00:15:58,018 --> 00:16:01,834
travaillaient sur des choses très différentes, ce qui ne semble pas ici être une

257
00:16:01,834 --> 00:16:02,400
coïncidence.

258
00:16:02,400 --> 00:16:05,929
Avance rapide de plusieurs décennies, et de nos jours, beaucoup d’entre nous

259
00:16:05,929 --> 00:16:09,504
sont tellement plongés dans la réflexion sur des éléments et des informations

260
00:16:09,504 --> 00:16:13,080
qu’il est facile d’oublier à quel point cette façon de penser était distincte.

261
00:16:13,080 --> 00:16:14,603
Ironiquement, les idées qui façonnent le plus profondément la

262
00:16:14,603 --> 00:16:16,175
façon de penser d’une génération future finiront par considérer

263
00:16:16,175 --> 00:16:17,920
cette génération future plus simplement qu’elles ne le sont réellement.

