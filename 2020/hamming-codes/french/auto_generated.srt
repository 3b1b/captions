1
00:00:00,000 --> 00:00:03,120
Je suppose que tout le monde ici vient de la partie 1.

2
00:00:03,120 --> 00:00:06,823
Nous parlions des codes de Hamming, une façon de créer un bloc de données dont

3
00:00:06,823 --> 00:00:09,308
la plupart des bits portent un message significatif,

4
00:00:09,308 --> 00:00:12,449
tandis que quelques autres agissent comme une sorte de redondance,

5
00:00:12,449 --> 00:00:16,528
de telle sorte que si un bit est inversé, soit un message bit ou un bit de redondance,

6
00:00:16,528 --> 00:00:20,325
n'importe quoi dans ce bloc, un récepteur sera capable d'identifier qu'il y a eu

7
00:00:20,325 --> 00:00:21,920
une erreur et comment la corriger.

8
00:00:21,920 --> 00:00:25,806
L'idée de base présentée ici était de savoir comment utiliser plusieurs

9
00:00:25,806 --> 00:00:29,800
contrôles de parité pour effectuer une recherche binaire jusqu'à l'erreur.

10
00:00:29,800 --> 00:00:32,535
Dans cette vidéo, l'objectif était de rendre les codes

11
00:00:32,535 --> 00:00:35,420
de Hamming aussi pratiques et redécouvrables que possible.

12
00:00:35,420 --> 00:00:38,909
Mais lorsque vous commencez à réfléchir à la mise en œuvre réelle de cela,

13
00:00:38,909 --> 00:00:41,840
que ce soit au niveau logiciel ou matériel, ce cadrage peut en

14
00:00:41,840 --> 00:00:44,120
fait sous-estimer l'élégance réelle de ces codes.

15
00:00:44,120 --> 00:00:47,376
Vous pensez peut-être que vous devez écrire un algorithme qui garde une

16
00:00:47,376 --> 00:00:50,632
trace de tous les emplacements d'erreur possibles et coupe ce groupe de

17
00:00:50,632 --> 00:00:54,160
moitié à chaque vérification, mais c'est en réalité bien plus simple que cela.

18
00:00:54,160 --> 00:00:57,596
Si vous lisez les réponses aux quatre contrôles de parité que nous avons

19
00:00:57,596 --> 00:01:01,174
effectués dans la dernière vidéo, toutes sous forme de 1 et de 0 au lieu de

20
00:01:01,174 --> 00:01:04,800
oui et de non, cela indique littéralement la position de l'erreur en binaire.

21
00:01:04,800 --> 00:01:08,580
Par exemple, le nombre 7 en binaire ressemble à 0111,

22
00:01:08,580 --> 00:01:12,640
ce qui signifie essentiellement que c'est 4 plus 2 plus 1.

23
00:01:12,640 --> 00:01:17,202
Et remarquez où se situe la position 7, elle affecte le premier de nos

24
00:01:17,202 --> 00:01:22,280
groupes paritaires, ainsi que le deuxième et le troisième, mais pas le dernier.

25
00:01:22,280 --> 00:01:25,515
Ainsi, la lecture des résultats de ces quatre contrôles

26
00:01:25,515 --> 00:01:28,520
de bas en haut précise bien la position de l’erreur.

27
00:01:28,520 --> 00:01:32,077
Il n'y a rien de spécial dans l'exemple 7, cela fonctionne en général,

28
00:01:32,077 --> 00:01:36,387
et cela rend la logique d'implémentation de l'ensemble du schéma matériellement d'une

29
00:01:36,387 --> 00:01:37,440
simplicité choquante.

30
00:01:37,440 --> 00:01:41,530
Maintenant, si vous voulez voir pourquoi cette magie se produit,

31
00:01:41,530 --> 00:01:44,866
prenez ces 16 étiquettes d'index pour nos positions,

32
00:01:44,866 --> 00:01:49,335
mais au lieu de les écrire en base 10, écrivons-les toutes en binaire,

33
00:01:49,335 --> 00:01:50,720
allant de 0000 à 1111.

34
00:01:50,720 --> 00:01:54,173
Alors que nous remettons ces étiquettes binaires dans leurs boîtes,

35
00:01:54,173 --> 00:01:58,440
permettez-moi de souligner qu'elles sont distinctes des données réellement envoyées.

36
00:01:58,440 --> 00:02:01,299
Ce n'est rien de plus qu'une étiquette conceptuelle pour nous aider,

37
00:02:01,299 --> 00:02:04,200
vous et moi, à comprendre d'où viennent les quatre groupes paritaires.

38
00:02:04,200 --> 00:02:08,707
L'élégance d'avoir tout ce que nous regardons soit décrit en binaire est peut-être

39
00:02:08,707 --> 00:02:13,160
sapée par la confusion d'avoir tout ce que nous regardons étant décrit en binaire.

40
00:02:13,160 --> 00:02:15,040
Mais ça vaut le coup.

41
00:02:15,040 --> 00:02:20,085
Concentrez votre attention uniquement sur le dernier bit de toutes ces étiquettes,

42
00:02:20,085 --> 00:02:24,280
puis mettez en surbrillance les positions où ce dernier bit est un 1.

43
00:02:24,280 --> 00:02:27,830
Ce que nous obtenons est le premier de nos quatre groupes de parité,

44
00:02:27,830 --> 00:02:32,460
ce qui signifie que vous pouvez interpréter cette première vérification comme demandant :

45
00:02:32,460 --> 00:02:36,680
hé, s’il y a une erreur, le dernier bit à la position de cette erreur est-il un 1?

46
00:02:36,680 --> 00:02:40,076
De même, si vous vous concentrez sur l'avant-dernier bit et

47
00:02:40,076 --> 00:02:43,756
mettez en surbrillance toutes les positions où il s'agit d'un 1,

48
00:02:43,756 --> 00:02:47,040
vous obtenez le deuxième groupe de parité de notre schéma.

49
00:02:47,040 --> 00:02:51,843
En d’autres termes, cette deuxième vérification demande : hé, encore une fois,

50
00:02:51,843 --> 00:02:56,160
s’il y a une erreur, l’avant-dernier bit de cette position est-il un 1?

51
00:02:56,160 --> 00:02:57,160
Et ainsi de suite.

52
00:02:57,160 --> 00:03:01,168
Le troisième contrôle de parité couvre chaque position dont

53
00:03:01,168 --> 00:03:06,712
l'avant-dernier bit est activé, et le dernier couvre les huit dernières positions,

54
00:03:06,712 --> 00:03:10,120
celles dont le bit de poids le plus élevé est un 1.

55
00:03:10,120 --> 00:03:16,170
Tout ce que nous avons fait plus tôt revient à répondre à ces quatre questions,

56
00:03:16,170 --> 00:03:19,800
ce qui revient à épeler une position en binaire.

57
00:03:19,800 --> 00:03:22,080
J'espère que cela rend deux choses plus claires.

58
00:03:22,080 --> 00:03:24,590
La première est de savoir comment généraliser systématiquement à

59
00:03:24,590 --> 00:03:27,140
des tailles de blocs qui sont des puissances de deux plus grandes.

60
00:03:27,140 --> 00:03:30,526
S'il faut plus de bits pour décrire chaque position,

61
00:03:30,526 --> 00:03:35,892
comme six bits pour décrire 64 points, alors chacun de ces bits vous donne l'un des

62
00:03:35,892 --> 00:03:38,640
groupes de parité que nous devons vérifier.

63
00:03:38,640 --> 00:03:41,087
Ceux d’entre vous qui ont regardé le puzzle d’échiquier que j’ai réalisé

64
00:03:41,087 --> 00:03:43,400
avec Matt Parker trouveront peut-être tout cela extrêmement familier.

65
00:03:43,400 --> 00:03:47,502
C'est la même logique de base, mais résolvant un problème différent,

66
00:03:47,502 --> 00:03:49,880
et appliquée à un échiquier de 64 cases.

67
00:03:49,880 --> 00:03:52,754
La deuxième chose que j'espère que cela clarifie est la raison

68
00:03:52,754 --> 00:03:55,673
pour laquelle nos bits de parité se trouvent dans des positions

69
00:03:55,673 --> 00:03:58,320
qui sont des puissances de deux, par exemple 1, 2, 4 et 8.

70
00:03:58,320 --> 00:04:03,640
Ce sont les positions dont la représentation binaire n'a qu'un seul bit activé.

71
00:04:03,640 --> 00:04:07,925
Cela signifie que chacun de ces bits de parité se

72
00:04:07,925 --> 00:04:12,640
trouve dans un et un seul des quatre groupes de parité.

73
00:04:12,640 --> 00:04:18,368
Vous pouvez également le constater dans des exemples plus grands,

74
00:04:18,368 --> 00:04:25,920
où quelle que soit votre taille, chaque bit de parité ne touche qu'un seul des groupes.

75
00:04:25,920 --> 00:04:29,520
Une fois que vous comprenez que ces contrôles de parité sur lesquels nous avons consacré

76
00:04:29,520 --> 00:04:32,836
une grande partie de notre temps ne sont rien de plus qu'une manière intelligente

77
00:04:32,836 --> 00:04:36,477
d'épeler la position d'une erreur en binaire, nous pouvons alors établir un lien avec une

78
00:04:36,477 --> 00:04:38,580
manière différente de penser au hamming. des codes,

79
00:04:38,580 --> 00:04:41,007
qui sont sans doute beaucoup plus simples et plus élégants,

80
00:04:41,007 --> 00:04:43,920
et qui peuvent essentiellement être écrits avec une seule ligne de code.

81
00:04:43,920 --> 00:04:46,200
Il est basé sur la fonction XOR.

82
00:04:46,200 --> 00:04:50,960
XOR, pour ceux d'entre vous qui ne le savent pas, signifie exclusif ou.

83
00:04:50,960 --> 00:04:55,646
Lorsque vous effectuez le XOR de deux bits, il renvoie un 1 si l'un de

84
00:04:55,646 --> 00:05:00,200
ces bits est activé, mais pas si les deux sont activés ou désactivés.

85
00:05:00,200 --> 00:05:03,760
Exprimé différemment, c'est la parité de ces deux bits.

86
00:05:03,760 --> 00:05:07,840
En tant que mathématicien, je préfère y penser comme un mod d'addition 2.

87
00:05:07,840 --> 00:05:11,315
Nous parlons aussi couramment du XOR de deux chaînes de bits différentes,

88
00:05:11,315 --> 00:05:14,040
qui effectue essentiellement cela composant par composant.

89
00:05:14,040 --> 00:05:16,280
C'est comme une addition, mais où l'on ne porte jamais.

90
00:05:16,280 --> 00:05:19,949
Encore une fois, les plus enclins aux mathématiques préféreront peut-être

91
00:05:19,949 --> 00:05:23,520
considérer cela comme l'ajout de deux vecteurs et la réduction du mod 2.

92
00:05:23,520 --> 00:05:29,598
Si vous ouvrez Python dès maintenant et appliquez l'opération caret entre deux entiers,

93
00:05:29,598 --> 00:05:35,400
c'est ce qu'il fait, mais aux représentations binaires de ces nombres sous le capot.

94
00:05:35,400 --> 00:05:40,752
Le point clé pour vous et moi est que prendre le XOR de nombreuses chaînes de

95
00:05:40,752 --> 00:05:45,830
bits différentes est effectivement un moyen de calculer les parodies d'un

96
00:05:45,830 --> 00:05:51,320
groupe de groupes séparés, comme c'est le cas avec les colonnes, d'un seul coup.

97
00:05:51,320 --> 00:05:55,523
Cela nous donne une façon plutôt élégante de considérer les multiples contrôles de parité

98
00:05:55,523 --> 00:05:59,680
de notre algorithme de code de Hamming comme étant tous regroupés en une seule opération.

99
00:05:59,680 --> 00:06:02,800
Même si à première vue, cela semble très différent.

100
00:06:02,800 --> 00:06:08,623
Notez spécifiquement les 16 positions en binaire, comme nous l'avions fait auparavant,

101
00:06:08,623 --> 00:06:14,647
et mettez maintenant en surbrillance les positions où le bit de message est activé sur 1,

102
00:06:14,647 --> 00:06:19,400
puis rassemblez ces positions dans une grande colonne et prenez le XOR.

103
00:06:19,400 --> 00:06:23,907
Vous pouvez probablement deviner que les 4 bits situés en bas sont

104
00:06:23,907 --> 00:06:28,750
les mêmes que les 4 contrôles de parité que nous connaissons et aimons,

105
00:06:28,750 --> 00:06:32,720
mais prenez un moment pour réfléchir à pourquoi exactement.

106
00:06:32,720 --> 00:06:36,090
Cette dernière colonne, par exemple, compte toutes les positions dont

107
00:06:36,090 --> 00:06:39,267
le dernier bit est un 1, mais nous sommes déjà limités uniquement

108
00:06:39,267 --> 00:06:42,397
aux positions en surbrillance, elle compte donc effectivement le

109
00:06:42,397 --> 00:06:45,960
nombre de positions en surbrillance provenant du premier groupe de parité.

110
00:06:45,960 --> 00:06:48,520
Cela a-t-il du sens?

111
00:06:48,520 --> 00:06:52,481
De même, la colonne suivante compte le nombre de positions dans le

112
00:06:52,481 --> 00:06:56,383
deuxième groupe de parité, les positions dont l'avant-dernier bit

113
00:06:56,383 --> 00:07:00,640
est un 1 et qui sont également mises en surbrillance, et ainsi de suite.

114
00:07:00,640 --> 00:07:03,766
Il s'agit en réalité d'un petit changement de

115
00:07:03,766 --> 00:07:07,640
perspective par rapport à la même chose que nous faisons.

116
00:07:07,640 --> 00:07:10,000
Et donc vous savez où cela va à partir de maintenant.

117
00:07:10,000 --> 00:07:14,614
L'expéditeur est responsable d'activer certains bits de

118
00:07:14,614 --> 00:07:19,640
parité spéciaux pour s'assurer que la somme est égale à 0000.

119
00:07:19,640 --> 00:07:22,697
Maintenant, une fois que nous avons cela, cela nous donne une très

120
00:07:22,697 --> 00:07:25,754
bonne façon de réfléchir à la raison pour laquelle ces quatre bits

121
00:07:25,754 --> 00:07:28,720
résultants en bas indiquent directement la position d'une erreur.

122
00:07:28,720 --> 00:07:32,720
Disons qu'un élément de ce bloc passe de 0 à 1.

123
00:07:32,720 --> 00:07:38,491
Cela signifie que la position de ce bit va maintenant être incluse dans le XOR total,

124
00:07:38,491 --> 00:07:43,189
ce qui fait passer la somme de 0 à cette valeur nouvellement incluse,

125
00:07:43,189 --> 00:07:44,800
la position de l'erreur.

126
00:07:44,800 --> 00:07:47,221
De manière un peu moins évidente, il en va de

127
00:07:47,221 --> 00:07:49,800
même s'il y a une erreur qui change un 1 en un 0.

128
00:07:49,800 --> 00:07:53,098
Vous voyez, si vous ajoutez deux fois une petite chaîne,

129
00:07:53,098 --> 00:07:57,727
cela revient à ne pas l'avoir du tout, essentiellement parce que dans ce monde,

130
00:07:57,727 --> 00:07:59,000
1 plus 1 est égal à 0.

131
00:07:59,000 --> 00:08:02,200
Ainsi, ajouter une copie de cette position à la

132
00:08:02,200 --> 00:08:05,400
somme totale a le même effet que de la déplacer.

133
00:08:05,400 --> 00:08:09,520
Et cet effet, encore une fois, est que le résultat

134
00:08:09,520 --> 00:08:13,480
total en bas indique ici la position de l’erreur.

135
00:08:13,480 --> 00:08:16,315
Pour illustrer à quel point cela est élégant, permettez-moi de

136
00:08:16,315 --> 00:08:19,420
montrer cette ligne de code Python que j'ai référencée précédemment,

137
00:08:19,420 --> 00:08:22,120
qui capturera presque toute la logique du côté du récepteur.

138
00:08:22,120 --> 00:08:26,227
Nous allons commencer par créer un tableau aléatoire de 16 1 et 0 pour simuler

139
00:08:26,227 --> 00:08:30,593
le bloc de données, et je lui donnerai le nom des bits, mais bien sûr, en pratique,

140
00:08:30,593 --> 00:08:35,272
ce serait quelque chose que nous recevons d'un expéditeur, et au lieu de étant aléatoire,

141
00:08:35,272 --> 00:08:38,600
il transporterait 11 bits de données ainsi que 5 bits de parité.

142
00:08:38,600 --> 00:08:43,382
Si j'appelle la fonction enumerateBits, elle associe chacun de

143
00:08:43,382 --> 00:08:48,240
ces bits à un index correspondant, dans ce cas allant de 0 à 15.

144
00:08:48,240 --> 00:08:52,110
Donc, si nous créons ensuite une liste qui boucle sur toutes ces paires,

145
00:08:52,110 --> 00:08:56,670
des paires qui ressemblent à i, et que nous extrayons ensuite uniquement la valeur i,

146
00:08:56,670 --> 00:08:59,321
juste l'index, eh bien, ce n'est pas si excitant,

147
00:08:59,321 --> 00:09:01,920
nous récupérons simplement ces indices de 0 à 15.

148
00:09:01,920 --> 00:09:05,870
Mais si nous ajoutons la condition de ne faire cela que si bit,

149
00:09:05,870 --> 00:09:09,696
c'est-à-dire si ce bit est un 1 et non un 0, alors il extrait

150
00:09:09,696 --> 00:09:13,400
uniquement les positions où le bit correspondant est activé.

151
00:09:13,400 --> 00:09:20,720
Dans ce cas, il semble que ces positions soient 0, 4, 6, 9, etc.

152
00:09:20,720 --> 00:09:25,227
Ce que nous voulons, c'est rassembler toutes ces positions,

153
00:09:25,227 --> 00:09:29,960
les positions des bits qui sont activés, puis les XOR ensemble.

154
00:09:29,960 --> 00:09:33,960
Pour ce faire en Python, permettez-moi d'abord d'importer quelques fonctions utiles.

155
00:09:33,960 --> 00:09:36,428
De cette façon, nous pouvons appeler réduire() sur

156
00:09:36,428 --> 00:09:39,140
cette liste et utiliser la fonction XOR pour la réduire.

157
00:09:39,140 --> 00:09:44,840
Cela se fraye un chemin à travers la liste, prenant des XORs en cours de route.

158
00:09:44,840 --> 00:09:48,653
Si vous préférez, vous pouvez écrire explicitement cette

159
00:09:48,653 --> 00:09:52,200
fonction XOR sans avoir à l'importer de n'importe où.

160
00:09:52,200 --> 00:09:57,004
Donc pour le moment, il semble que si nous faisons cela sur notre bloc

161
00:09:57,004 --> 00:10:02,080
aléatoire de 16 bits, cela renvoie 9, qui a la représentation binaire 1001.

162
00:10:02,080 --> 00:10:05,946
Nous ne le ferons pas ici, mais vous pouvez écrire une fonction dans laquelle

163
00:10:05,946 --> 00:10:09,615
l'expéditeur utilise cette représentation binaire pour définir les quatre

164
00:10:09,615 --> 00:10:13,283
bits de parité selon les besoins, amenant finalement ce bloc à un état où

165
00:10:13,283 --> 00:10:17,200
l'exécution de cette ligne de code sur la liste complète des bits renvoie un 0.

166
00:10:17,200 --> 00:10:20,200
Cela serait considéré comme un bloc bien préparé.

167
00:10:20,200 --> 00:10:24,220
Ce qui est cool, c'est que si nous basculons l'un des bits de cette liste,

168
00:10:24,220 --> 00:10:27,812
simulant une erreur aléatoire due au bruit, alors si vous exécutez

169
00:10:27,812 --> 00:10:30,600
cette même ligne de code, cette erreur est affichée.

170
00:10:30,600 --> 00:10:31,920
N'est-ce pas sympa?

171
00:10:31,920 --> 00:10:37,154
Vous pouvez obtenir ce bloc à l'improviste, exécuter cette seule ligne dessus,

172
00:10:37,154 --> 00:10:42,920
et il crachera automatiquement la position d'une erreur, ou un 0 s'il n'y en avait pas.

173
00:10:42,920 --> 00:10:45,520
Et il n'y a rien de spécial concernant la taille 16 ici.

174
00:10:45,520 --> 00:10:52,280
La même ligne de code fonctionnerait si vous aviez une liste de, disons, 256 bits.

175
00:10:52,280 --> 00:10:55,083
Inutile de dire qu'il y a plus de code à écrire ici,

176
00:10:55,083 --> 00:10:59,526
comme effectuer la vérification de méta-parité pour détecter les erreurs de 2 bits,

177
00:10:59,526 --> 00:11:03,704
mais l'idée est que presque toute la logique de base de notre schéma se résume

178
00:11:03,704 --> 00:11:05,080
à une seule réduction XOR.

179
00:11:05,080 --> 00:11:07,759
Maintenant, selon votre aisance avec les binaires,

180
00:11:07,759 --> 00:11:11,332
les XOR et les logiciels en général, vous pouvez soit trouver cette

181
00:11:11,332 --> 00:11:15,011
perspective un peu déroutante, soit tellement plus élégante et simple

182
00:11:15,011 --> 00:11:19,320
que vous vous demandez pourquoi nous ne l'avons pas commencé dès le début. -aller.

183
00:11:19,320 --> 00:11:22,411
En gros, la perspective du contrôle de parité multiple est plus facile

184
00:11:22,411 --> 00:11:26,155
à penser lors de l'implémentation très directe des codes de Hamming dans le matériel,

185
00:11:26,155 --> 00:11:30,030
et la perspective XOR est la plus facile à penser lorsqu'on l'effectue dans le logiciel,

186
00:11:30,030 --> 00:11:31,380
à partir d'un niveau supérieur.

187
00:11:31,380 --> 00:11:34,193
Le premier est le plus simple à réaliser à la main,

188
00:11:34,193 --> 00:11:37,926
et je pense qu'il fait un meilleur travail en inculquant l'intuition

189
00:11:37,926 --> 00:11:41,605
fondamentale qui sous-tend tout cela, à savoir que les informations

190
00:11:41,605 --> 00:11:46,204
requises pour localiser une seule erreur sont liées au journal de la taille du bloc.

191
00:11:46,204 --> 00:11:51,020
, ou en d’autres termes, il augmente petit à petit à mesure que la taille du bloc double.

192
00:11:51,020 --> 00:11:53,775
Le fait pertinent ici est que ces informations correspondent

193
00:11:53,775 --> 00:11:56,440
directement au niveau de redondance dont nous avons besoin.

194
00:11:56,440 --> 00:11:59,160
C'est vraiment ce qui va à l'encontre de la réaction instinctive de

195
00:11:59,160 --> 00:12:01,960
la plupart des gens lorsqu'ils pensent pour la première fois à rendre

196
00:12:01,960 --> 00:12:04,680
un message résistant aux erreurs, alors que copier l'intégralité du

197
00:12:04,680 --> 00:12:07,520
message est généralement le premier instinct qui leur vient à l'esprit.

198
00:12:07,520 --> 00:12:11,231
Et puis, en passant, il y a cette toute autre façon de voir parfois les codes

199
00:12:11,231 --> 00:12:14,800
de Hamming présentés, où vous multipliez le message par une grande matrice.

200
00:12:14,800 --> 00:12:19,739
C'est plutôt sympa car cela le relie à la famille plus large des codes linéaires,

201
00:12:19,739 --> 00:12:25,160
mais je pense que cela ne donne presque aucune intuition sur son origine ou son évolution.

202
00:12:25,160 --> 00:12:28,637
Et en parlant de mise à l'échelle, vous remarquerez peut-être que l'efficacité de

203
00:12:28,637 --> 00:12:32,200
ce système ne fait que s'améliorer à mesure que nous augmentons la taille des blocs.

204
00:12:32,200 --> 00:12:37,625
Par exemple, nous avons vu qu'avec 256 bits, vous n'utilisez que 3 % de cet

205
00:12:37,625 --> 00:12:43,480
espace pour la redondance, et la situation ne cesse de s'améliorer à partir de là.

206
00:12:43,480 --> 00:12:46,905
À mesure que le nombre de bits de parité augmente un par un,

207
00:12:46,905 --> 00:12:49,040
la taille du bloc continue de doubler.

208
00:12:49,040 --> 00:12:52,767
Et si vous poussez cela à l'extrême, vous pourriez avoir un bloc avec,

209
00:12:52,767 --> 00:12:56,495
disons, un million de bits, dans lequel vous joueriez littéralement 20

210
00:12:56,495 --> 00:13:00,800
questions avec vos contrôles de parité, et il n'utiliserait que 21 bits de parité.

211
00:13:00,800 --> 00:13:04,690
Et si vous prenez du recul et réfléchissez à examiner un million

212
00:13:04,690 --> 00:13:08,640
de bits et à localiser une seule erreur, cela semble vraiment fou.

213
00:13:08,640 --> 00:13:11,694
Le problème, bien sûr, est qu’avec un bloc plus grand,

214
00:13:11,694 --> 00:13:15,305
la probabilité de voir plus d’un ou deux bits d’erreur augmente,

215
00:13:15,305 --> 00:13:18,360
et les codes de Hamming ne gèrent rien d’autre au-delà.

216
00:13:18,360 --> 00:13:22,415
Donc, en pratique, ce que vous voudriez, c'est trouver la bonne taille pour que la

217
00:13:22,415 --> 00:13:26,520
probabilité d'un trop grand nombre de retournements de bits ne soit pas trop élevée.

218
00:13:26,520 --> 00:13:31,626
De plus, dans la pratique, les erreurs ont tendance à se produire par petites rafales,

219
00:13:31,626 --> 00:13:36,146
ce qui ruinerait totalement un seul bloc. Une tactique courante pour aider à

220
00:13:36,146 --> 00:13:41,136
répartir une rafale d'erreurs sur de nombreux blocs différents consiste à entrelacer

221
00:13:41,136 --> 00:13:45,480
ces blocs, comme ceci, avant qu'ils ne soient générés. envoyés ou stockés.

222
00:13:45,480 --> 00:13:48,947
Là encore, une grande partie de cela est rendue complètement sans objet par

223
00:13:48,947 --> 00:13:51,731
des codes plus modernes, comme l'algorithme de Reed-Solomon,

224
00:13:51,731 --> 00:13:55,746
beaucoup plus couramment utilisé, qui gère particulièrement bien les erreurs en rafale,

225
00:13:55,746 --> 00:13:59,580
et il peut être réglé pour être résilient à un plus grand nombre d'erreurs par bloc.

226
00:13:59,580 --> 00:14:03,000
Mais c'est un sujet pour une autre fois.

227
00:14:03,000 --> 00:14:06,203
Dans son livre The Art of Doing Science and Engineering,

228
00:14:06,203 --> 00:14:10,700
Hamming est merveilleusement franc sur les méandres de sa découverte de ce code.

229
00:14:10,700 --> 00:14:14,472
Il a d'abord essayé toutes sortes de schémas différents impliquant l'organisation des

230
00:14:14,472 --> 00:14:18,420
bits en parties d'un réseau de dimension supérieure et des choses étranges comme celle-ci.

231
00:14:18,420 --> 00:14:21,772
L'idée qu'il pourrait être possible d'obtenir des contrôles de parité pour

232
00:14:21,772 --> 00:14:25,483
conspirer d'une manière qui précise la position d'une erreur n'est venue à Hamming

233
00:14:25,483 --> 00:14:28,836
que lorsqu'il a pris du recul après un tas d'autres analyses et a demandé,

234
00:14:28,836 --> 00:14:32,860
d'accord, quelle est la méthode la plus efficace possible. peut-être qu'il s'agisse de ça?

235
00:14:32,860 --> 00:14:35,812
Il a également souligné à quel point il était important que les

236
00:14:35,812 --> 00:14:38,487
contrôles de parité soient déjà présents dans son esprit,

237
00:14:38,487 --> 00:14:42,040
ce qui aurait été beaucoup moins courant dans les années 1940 qu'aujourd'hui.

238
00:14:42,040 --> 00:14:45,791
Il y a environ une demi-douzaine de fois tout au long de ce livre où il fait

239
00:14:45,791 --> 00:14:49,640
référence à la citation de Louis Pasteur, la chance favorise un esprit préparé.

240
00:14:49,640 --> 00:14:53,382
Avec le recul, les idées intelligentes semblent souvent d’une simplicité trompeuse,

241
00:14:53,382 --> 00:14:55,120
ce qui les rend faciles à sous-estimer.

242
00:14:55,120 --> 00:14:58,326
À l’heure actuelle, j’espère honnêtement que les codes de Hamming,

243
00:14:58,326 --> 00:15:01,820
ou du moins la possibilité de tels codes, vous semblent presque évidents.

244
00:15:01,820 --> 00:15:06,114
Mais vous ne devriez pas vous tromper en pensant qu’ils sont en réalité évidents,

245
00:15:06,114 --> 00:15:08,000
car ils ne le sont certainement pas.

246
00:15:08,000 --> 00:15:11,815
Une partie de la raison pour laquelle les idées intelligentes semblent trompeusement

247
00:15:11,815 --> 00:15:15,855
faciles est que nous ne voyons que le résultat final, nettoyant ce qui était en désordre,

248
00:15:15,855 --> 00:15:18,054
sans jamais mentionner tous les mauvais virages,

249
00:15:18,054 --> 00:15:22,049
sous-estimant à quel point l'espace des possibilités explorables est vaste au début d'un

250
00:15:22,049 --> 00:15:23,980
problème. processus de résolution, tout ça.

251
00:15:23,980 --> 00:15:25,280
Mais cela est vrai en général.

252
00:15:25,280 --> 00:15:28,736
Je pense que pour certaines inventions spéciales, il y a une deuxième raison,

253
00:15:28,736 --> 00:15:31,040
plus profonde, pour laquelle nous les sous-estimons.

254
00:15:31,040 --> 00:15:34,084
La conception de l'information en termes de bits n'a véritablement

255
00:15:34,084 --> 00:15:36,673
abouti à une théorie complète qu'en 1948, avec l'article

256
00:15:36,673 --> 00:15:39,400
fondateur de Claude Shannon sur la théorie de l'information.

257
00:15:39,400 --> 00:15:43,440
Cela correspondait essentiellement au moment où Hamming développait son algorithme.

258
00:15:43,440 --> 00:15:47,196
Il s’agissait du même article fondateur qui montrait, dans un certain sens,

259
00:15:47,196 --> 00:15:50,113
qu’une correction d’erreur efficace est toujours possible,

260
00:15:50,113 --> 00:15:53,920
quelle que soit la probabilité de retournements de bits, du moins en théorie.

261
00:15:53,920 --> 00:15:57,453
Shannon et Hamming, d'ailleurs, partageaient un bureau dans les Bell Labs,

262
00:15:57,453 --> 00:16:00,232
bien qu'ils travaillaient sur des choses très différentes,

263
00:16:00,232 --> 00:16:02,400
ce qui ne semble pas ici être une coïncidence.

264
00:16:02,400 --> 00:16:04,921
Avance rapide de plusieurs décennies, et de nos jours,

265
00:16:04,921 --> 00:16:08,587
beaucoup d’entre nous sont tellement plongés dans la réflexion sur des éléments

266
00:16:08,587 --> 00:16:12,025
et des informations qu’il est facile d’oublier à quel point cette façon de

267
00:16:12,025 --> 00:16:13,080
penser était distincte.

268
00:16:13,080 --> 00:16:14,603
Ironiquement, les idées qui façonnent le plus profondément la

269
00:16:14,603 --> 00:16:16,175
façon de penser d’une génération future finiront par considérer

270
00:16:16,175 --> 00:16:17,920
cette génération future plus simplement qu’elles ne le sont réellement.

