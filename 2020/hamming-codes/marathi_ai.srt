1
00:00:00,000 --> 00:00:03,120
मी असे गृहीत धरत आहे की येथे प्रत्येकजण भाग 1 पासून येत आहे.

2
00:00:03,120 --> 00:00:06,920
आम्ही हॅमिंग कोडबद्दल बोलत होतो, डेटाचा एक ब्लॉक तयार करण्याचा एक मार्ग

3
00:00:06,920 --> 00:00:11,640
जिथे बहुतेक बिट एक अर्थपूर्ण संदेश देतात, तर काही इतर एक प्रकारचा

4
00:00:11,640 --> 00:00:15,800
रिडंडंसी म्हणून काम करतात, अशा प्रकारे की जर काही बिट फ्लिप झाले

5
00:00:15,800 --> 00:00:20,560
तर एकतर संदेश बिट किंवा रिडंडंसी बिट, या ब्लॉकमधील काहीही, एक प्राप्तकर्ता

6
00:00:20,560 --> 00:00:21,920
त्रुटी आहे हे ओळखण्यास सक्षम असेल आणि त्याचे निराकरण कसे करावे.

7
00:00:21,920 --> 00:00:25,900
तेथे सादर केलेली मूलभूत कल्पना ही होती की त्रुटीकडे

8
00:00:25,900 --> 00:00:29,800
जाण्यासाठी बायनरी शोधण्यासाठी एकाधिक पॅरिटी चेक कसे वापरायचे.

9
00:00:29,800 --> 00:00:33,920
त्या व्हिडिओमध्ये हॅमिंग कोड शक्य तितक्या हँड्स-ऑन

10
00:00:33,920 --> 00:00:35,420
आणि पुन्हा शोधण्यायोग्य वाटणे हे ध्येय होते.

11
00:00:35,420 --> 00:00:40,040
परंतु जसे तुम्ही हे सॉफ्टवेअर किंवा हार्डवेअरमध्ये प्रत्यक्षात अंमलात आणण्याचा विचार करू लागता,

12
00:00:40,040 --> 00:00:44,120
ते फ्रेमिंग हे कोड्स खरोखर किती सुंदर आहेत हे कमी करू शकते.

13
00:00:44,120 --> 00:00:47,620
तुम्हाला असे वाटेल की तुम्हाला एखादे अल्गोरिदम लिहावे लागेल जे

14
00:00:47,620 --> 00:00:52,320
सर्व संभाव्य त्रुटी स्थानांचा मागोवा ठेवेल आणि प्रत्येक चेकसह त्या

15
00:00:52,320 --> 00:00:54,160
गटाला अर्धा कापून टाकेल, परंतु प्रत्यक्षात ते त्यापेक्षा सोपे आहे.

16
00:00:54,160 --> 00:00:58,720
शेवटच्या व्हिडिओमध्ये आम्ही केलेल्या चार पॅरिटी चेकची उत्तरे तुम्ही होय आणि नाही ऐवजी

17
00:00:58,760 --> 00:01:04,800
1s आणि 0s अशी वाचली, तर ते बायनरीमधील त्रुटीचे स्थान अक्षरशः स्पष्ट करते.

18
00:01:04,800 --> 00:01:10,160
उदाहरणार्थ, बायनरी मधील 7 ही संख्या 0111 सारखी दिसते,

19
00:01:10,160 --> 00:01:12,640
मूलत: ते 4 अधिक 2 अधिक 1 असे म्हणते.

20
00:01:12,640 --> 00:01:17,960
आणि लक्षात घ्या की स्थान 7 कुठे बसते, ते आमच्या समता

21
00:01:17,960 --> 00:01:22,280
गटांपैकी पहिल्यावर, आणि दुसऱ्या आणि तिसऱ्याला प्रभावित करते, परंतु शेवटचे नाही.

22
00:01:22,280 --> 00:01:26,560
त्यामुळे तळापासून वरपर्यंत त्या चार तपासण्यांचे

23
00:01:26,560 --> 00:01:28,000
निकाल वाचून त्रुटीची स्थिती स्पष्ट होते.

24
00:01:28,520 --> 00:01:32,240
उदाहरण 7 मध्ये विशेष काही नाही, हे सर्वसाधारणपणे कार्य करते आणि

25
00:01:32,240 --> 00:01:37,440
यामुळे हार्डवेअरमध्ये संपूर्ण योजना लागू करण्याचे तर्क धक्कादायकपणे सोपे होते.

26
00:01:37,440 --> 00:01:43,380
आता ही जादू का घडते हे जर तुम्हाला पहायचे असेल, तर

27
00:01:43,380 --> 00:01:48,480
आमच्या पोझिशन्ससाठी ही 16 इंडेक्स लेबले घ्या, परंतु त्यांना बेस 10

28
00:01:48,480 --> 00:01:50,720
मध्ये लिहिण्याऐवजी, 0000 ते 1111 पर्यंत चालणारे ते सर्व बायनरीमध्ये लिहूया.

29
00:01:50,720 --> 00:01:55,880
जसे आम्ही ही बायनरी लेबले त्यांच्या बॉक्समध्ये परत ठेवतो, मी

30
00:01:56,080 --> 00:01:58,440
यावर जोर देतो की ते प्रत्यक्षात पाठवलेल्या डेटापेक्षा वेगळे आहेत.

31
00:01:58,440 --> 00:02:02,200
ते चार समानता गट कुठून आले हे तुम्हाला आणि मला

32
00:02:02,200 --> 00:02:04,200
समजण्यास मदत करण्यासाठी एक संकल्पनात्मक लेबलपेक्षा अधिक काही नाही.

33
00:02:04,200 --> 00:02:08,840
बायनरीमध्ये वर्णन केल्या जाणाऱ्या प्रत्येक गोष्टीचे वर्णन आपण

34
00:02:08,840 --> 00:02:13,160
पाहत आहोत या संभ्रमामुळे कदाचित कमी होईल.

35
00:02:13,160 --> 00:02:15,040
तो वाचतो आहे, तरी.

36
00:02:15,040 --> 00:02:20,740
तुमचे लक्ष या सर्व लेबल्सच्या शेवटच्या बिट्सवर केंद्रित करा आणि नंतर

37
00:02:20,740 --> 00:02:24,280
ते स्थान हायलाइट करा जिथे तो अंतिम बिट 1 आहे.

38
00:02:24,280 --> 00:02:28,800
आम्हाला जे मिळते ते आमच्या चार पॅरिटी गटांपैकी पहिले आहे, याचा अर्थ

39
00:02:28,800 --> 00:02:34,480
तुम्ही त्या पहिल्या चेकचा विचार म्हणून अर्थ लावू शकता, अरे, जर एखादी

40
00:02:34,480 --> 00:02:36,680
त्रुटी असेल, तर त्या त्रुटीच्या स्थितीतील अंतिम बिट 1 आहे का?

41
00:02:36,680 --> 00:02:42,600
त्याचप्रमाणे, जर तुम्ही सेकंड टू लास्ट बिटवर लक्ष केंद्रित केले आणि 1

42
00:02:42,600 --> 00:02:47,040
असलेल्या सर्व पोझिशन्स हायलाइट केल्यास तुम्हाला आमच्या स्कीममधून दुसरा पॅरिटी ग्रुप मिळेल.

43
00:02:47,040 --> 00:02:51,960
दुसऱ्या शब्दांत, तो दुसरा चेक विचारत आहे, अहो, मला पुन्हा, जर एखादी

44
00:02:51,960 --> 00:02:56,160
त्रुटी असेल, तर त्या स्थितीचा दुसरा टू शेवटचा बिट 1 आहे का?

45
00:02:56,160 --> 00:02:57,160
वगैरे.

46
00:02:57,160 --> 00:03:03,320
तिसरा पॅरिटी चेक प्रत्येक पोझिशनचा कव्हर करतो ज्याचा तिसरा ते शेवटचा बिट चालू

47
00:03:03,320 --> 00:03:10,120
आहे आणि शेवटच्या आठ पोझिशन्सला कव्हर करते, ज्यांची सर्वोच्च ऑर्डर बिट 1 आहे.

48
00:03:10,120 --> 00:03:15,680
आम्ही याआधी जे काही केले ते या चार प्रश्नांची उत्तरे

49
00:03:15,680 --> 00:03:18,800
देण्यासारखेच आहे, जे यामधून बायनरीमधील स्थानाचे स्पेलिंग सारखेच आहे.

50
00:03:19,800 --> 00:03:22,080
मला आशा आहे की हे दोन गोष्टी स्पष्ट करेल.

51
00:03:22,080 --> 00:03:27,140
प्रथम म्हणजे दोन मोठ्या शक्ती असलेल्या आकारांना ब्लॉक करण्यासाठी पद्धतशीरपणे सामान्यीकरण कसे करावे.

52
00:03:27,140 --> 00:03:33,180
प्रत्येक पोझिशनचे वर्णन करण्यासाठी अधिक बिट्स लागत असल्यास, जसे की 64 स्पॉट्सचे वर्णन करण्यासाठी सहा

53
00:03:33,180 --> 00:03:38,640
बिट्स, तर त्या प्रत्येक बिट्समुळे आपल्याला समानता गटांपैकी एक मिळेल जो आपल्याला तपासण्याची आवश्यकता आहे.

54
00:03:38,640 --> 00:03:42,060
तुमच्यापैकी ज्यांनी मी मॅट पार्करसोबत केलेले बुद्धिबळाचे कोडे

55
00:03:42,060 --> 00:03:43,400
पाहिले त्यांना कदाचित हे सर्व अत्यंत परिचित वाटेल.

56
00:03:43,400 --> 00:03:48,200
हे समान मुख्य तर्क आहे, परंतु वेगळ्या समस्येचे

57
00:03:48,200 --> 00:03:49,880
निराकरण करते आणि 64-चौरस बुद्धिबळावर लागू केले जाते.

58
00:03:49,880 --> 00:03:54,000
दुसरी गोष्ट मला आशा आहे की हे स्पष्ट करते की आमचे पॅरिटी बिट्स

59
00:03:54,000 --> 00:03:58,320
दोन पॉवर असलेल्या पोझिशनमध्ये का बसले आहेत, उदाहरणार्थ 1, 2, 4 आणि 8.

60
00:03:58,320 --> 00:04:03,640
ही अशी पोझिशन्स आहेत ज्यांचे बायनरी प्रतिनिधित्व फक्त एक बिट चालू आहे.

61
00:04:03,640 --> 00:04:09,000
याचा अर्थ असा आहे की त्या प्रत्येक पॅरिटी

62
00:04:09,000 --> 00:04:12,640
बिट्स चार पॅरिटी गटांपैकी फक्त एकामध्ये बसतात.

63
00:04:12,640 --> 00:04:16,840
आपण हे मोठ्या उदाहरणांमध्ये देखील पाहू शकता, जिथे आपण कितीही मोठे

64
00:04:16,840 --> 00:04:25,920
असले तरीही, प्रत्येक पॅरिटी बिट सोयीस्करपणे फक्त एका गटाला स्पर्श करते.

65
00:04:25,920 --> 00:04:29,680
एकदा आपण समजून घेतले की या समता तपासण्या ज्यावर आम्ही आमचा

66
00:04:29,680 --> 00:04:34,320
बराच वेळ लक्ष केंद्रित केला आहे ते बायनरीमधील त्रुटीची स्थिती स्पष्ट

67
00:04:34,320 --> 00:04:37,880
करण्याचा एक चतुर मार्ग आहे, त्यानंतर आम्ही हॅमिंगबद्दल विचार करण्याच्या वेगळ्या

68
00:04:37,880 --> 00:04:42,160
मार्गाने कनेक्शन काढू शकतो. कोड्स, जे वादातीतपणे बरेच सोपे आणि अधिक

69
00:04:42,160 --> 00:04:43,880
शोभिवंत आहेत आणि जे मुळात कोडच्या एका ओळीने लिहिता येतात.

70
00:04:43,920 --> 00:04:46,200
हे XOR फंक्शनवर आधारित आहे.

71
00:04:46,200 --> 00:04:50,960
XOR, तुमच्यापैकी ज्यांना माहित नाही त्यांच्यासाठी, अनन्य किंवा.

72
00:04:50,960 --> 00:04:55,440
जेव्हा तुम्ही दोन बिट्सचा XOR घेता, तेव्हा त्यापैकी एक बिट चालू असल्यास

73
00:04:55,440 --> 00:05:00,200
ते 1 परत करेल, परंतु दोन्ही चालू किंवा बंद असल्यास नाही.

74
00:05:00,200 --> 00:05:03,760
वेगळ्या पद्धतीने शब्दबद्ध केले तर ही या दोन बिट्सची समानता आहे.

75
00:05:03,760 --> 00:05:07,840
एक गणिती व्यक्ती म्हणून, मी त्याबद्दल अतिरिक्त मोड 2 म्हणून विचार करण्यास प्राधान्य देतो.

76
00:05:07,840 --> 00:05:12,000
आम्ही सामान्यतः दोन भिन्न बिट स्ट्रिंग्सच्या XOR बद्दल

77
00:05:12,040 --> 00:05:14,040
बोलतो, जे मुळात हा घटक घटकानुसार करते.

78
00:05:14,040 --> 00:05:16,280
हे जोडण्यासारखे आहे, परंतु जिथे आपण कधीही वाहून नेत नाही.

79
00:05:16,280 --> 00:05:21,240
पुन्हा, अधिक गणिती कल हे दोन वेक्टर जोडणे आणि मोड

80
00:05:21,240 --> 00:05:23,520
2 कमी करणे असा विचार करणे पसंत करू शकतात.

81
00:05:23,520 --> 00:05:28,720
जर तुम्ही आत्ताच काही Python उघडले आणि दोन पूर्णांकांमध्ये कॅरेट ऑपरेशन लागू केले,

82
00:05:28,720 --> 00:05:35,400
तर ते हेच करत आहे परंतु हुडच्या खाली असलेल्या त्या संख्यांच्या थोड्या प्रतिनिधित्वासाठी.

83
00:05:35,400 --> 00:05:40,920
तुमच्यासाठी आणि माझ्यासाठी महत्त्वाचा मुद्दा असा आहे की अनेक भिन्न बिट

84
00:05:40,960 --> 00:05:45,960
स्ट्रिंग्सचे XOR घेणे हा वेगवेगळ्या गटांच्या विडंबनांची प्रभावीपणे गणना करण्याचा एक

85
00:05:45,960 --> 00:05:51,320
मार्ग आहे, जसे की स्तंभांप्रमाणेच, सर्व काही एकाच वेळी होते.

86
00:05:51,320 --> 00:05:54,520
हे आम्हाला आमच्या हॅमिंग कोड अल्गोरिदममधील एकाधिक समानता तपासण्यांबद्दल विचार करण्याचा एक

87
00:05:54,520 --> 00:05:59,680
अतिशय आकर्षक मार्ग देते कारण सर्व एकाच ऑपरेशनमध्ये एकत्रित केले जातात.

88
00:05:59,680 --> 00:06:02,800
जरी पहिल्या दृष्टीक्षेपात ते खूप वेगळे दिसते.

89
00:06:02,800 --> 00:06:08,360
विशेषत: बायनरीमध्ये 16 पोझिशन्स लिहा, जसे की आमच्याकडे आधी होती, आणि आता

90
00:06:08,640 --> 00:06:14,800
ज्या पोझिशन्सवर मेसेज बिट ऑन केले आहे ते 1 वर हायलाइट करा

91
00:06:14,800 --> 00:06:19,400
आणि नंतर या पोझिशन्स एका मोठ्या कॉलममध्ये एकत्र करा आणि XOR घ्या.

92
00:06:19,400 --> 00:06:23,480
आपण कदाचित अंदाज लावू शकता की परिणामी तळाशी बसलेले 4

93
00:06:23,480 --> 00:06:27,480
बिट्स 4 पॅरिटी तपासण्यांसारखेच आहेत ज्या आम्हाला माहित आहेत आणि

94
00:06:27,480 --> 00:06:32,720
आवडतात, परंतु नक्की का याचा विचार करण्यासाठी थोडा वेळ घ्या.

95
00:06:32,720 --> 00:06:37,880
हा शेवटचा स्तंभ, उदाहरणार्थ, सर्व पोझिशन्स मोजत आहे ज्याचा शेवटचा बिट 1

96
00:06:38,400 --> 00:06:42,400
आहे, परंतु आम्ही आधीच केवळ हायलाइट केलेल्या पोझिशन्सपुरते मर्यादित आहोत, त्यामुळे पहिल्या

97
00:06:42,400 --> 00:06:45,960
पॅरिटी गटातून किती हायलाइट केलेल्या पोझिशन्स आल्या हे प्रभावीपणे मोजत आहे.

98
00:06:45,960 --> 00:06:48,520
त्याला काही अर्थ आहे का?

99
00:06:48,520 --> 00:06:53,600
त्याचप्रमाणे, पुढील स्तंभ दुसऱ्या पॅरिटी गटात किती पोझिशन्स आहेत याची

100
00:06:53,600 --> 00:06:59,640
मोजणी करतो, ज्या पोझिशन्सचा दुसरा ते शेवटचा बिट 1

101
00:06:59,640 --> 00:07:00,640
आहे आणि ज्या हायलाइट केल्या आहेत, आणि असेच पुढे.

102
00:07:00,640 --> 00:07:06,640
आम्ही करत आहोत त्याच गोष्टीकडे दृष्टीकोनातील हा खरोखरच एक छोटासा बदल आहे.

103
00:07:07,640 --> 00:07:10,000
आणि म्हणून ते इथून कुठे जाते हे तुम्हाला माहिती आहे.

104
00:07:10,000 --> 00:07:14,400
बेरीज 0000 असल्याचे सुनिश्चित करण्यासाठी काही विशेष

105
00:07:14,400 --> 00:07:19,640
पॅरिटी बिट्स टॉगल करण्यासाठी प्रेषक जबाबदार आहे.

106
00:07:19,640 --> 00:07:23,600
आता एकदा आमच्याकडे असे झाले की, हे आम्हाला तळाशी असलेले हे चार परिणामी बिट्स

107
00:07:23,600 --> 00:07:28,720
थेट त्रुटीची स्थिती का स्पष्ट करतात याबद्दल विचार करण्याचा एक चांगला मार्ग देते.

108
00:07:28,720 --> 00:07:32,680
समजा या ब्लॉकमध्ये ० ते १ पर्यंत टॉगल केले आहे.

109
00:07:32,720 --> 00:07:37,320
याचा अर्थ असा आहे की त्या बिटची स्थिती आता एकूण

110
00:07:37,320 --> 00:07:42,960
XOR मध्ये समाविष्ट केली जाणार आहे, जी बेरीज 0 वरून

111
00:07:42,960 --> 00:07:44,800
बदलते त्याऐवजी हे नवीन समाविष्ट केलेले मूल्य, त्रुटीची स्थिती.

112
00:07:44,800 --> 00:07:48,800
थोडेसे कमी स्पष्टपणे, 1 ते 0

113
00:07:48,800 --> 00:07:49,800
बदलणारी त्रुटी असल्यास तेच खरे आहे.

114
00:07:49,800 --> 00:07:54,720
तुम्ही पहा, जर तुम्ही दोनदा थोडीशी स्ट्रिंग जोडली, तर ती तिथे अजिबात

115
00:07:54,720 --> 00:07:59,000
नसल्यासारखीच आहे, मुळात कारण या जगात 1 अधिक 1 बरोबर 0 आहे.

116
00:07:59,000 --> 00:08:03,720
त्यामुळे एकूण बेरीजमध्ये या स्थितीची एक प्रत जोडल्याने

117
00:08:03,720 --> 00:08:05,400
आपण ती हलवत आहोत तसाच परिणाम होतो.

118
00:08:05,400 --> 00:08:10,080
आणि तो परिणाम, पुन्हा, येथे तळाशी

119
00:08:10,080 --> 00:08:13,480
एकूण परिणाम त्रुटीची स्थिती स्पष्ट करतो.

120
00:08:13,480 --> 00:08:17,720
हे किती शोभिवंत आहे हे स्पष्ट करण्यासाठी, मी आधी संदर्भित केलेल्या पायथन

121
00:08:17,720 --> 00:08:22,120
कोडची एक ओळ दाखवते, जी रिसीव्हरच्या शेवटी जवळजवळ सर्व लॉजिक कॅप्चर करेल.

122
00:08:22,120 --> 00:08:27,160
आम्ही डेटा ब्लॉकचे नक्कल करण्यासाठी 16 1s आणि 0s चा यादृच्छिक अॅरे तयार

123
00:08:27,160 --> 00:08:31,160
करून सुरुवात करू आणि मी त्याला नावाचे बिट्स देईन, परंतु अर्थातच सराव

124
00:08:31,160 --> 00:08:36,160
मध्ये हे असे काहीतरी असेल जे आम्हाला प्रेषकाकडून प्राप्त होत असेल आणि

125
00:08:36,160 --> 00:08:38,600
त्याऐवजी यादृच्छिक असल्याने ते 5 पॅरिटी बिट्ससह 11 डेटा बिट्स घेऊन जाईल.

126
00:08:38,600 --> 00:08:43,160
जर मी फंक्शनला enumerateBits म्हणतो, तर ते काय करते ते प्रत्येक

127
00:08:43,160 --> 00:08:48,240
बिट्सला संबंधित इंडेक्ससह जोडते, या प्रकरणात 0 ते 15 पर्यंत चालते.

128
00:08:48,240 --> 00:08:53,200
मग जर आपण या सर्व जोड्या, i सारख्या दिसणार्‍या जोड्या लूप करणारी यादी

129
00:08:53,200 --> 00:08:59,160
तयार केली आणि मग आपण फक्त i मूल्य, फक्त निर्देशांक काढू, तर ते

130
00:08:59,160 --> 00:09:01,920
इतके रोमांचक नाही, तर आपल्याला ते निर्देशांक 0 ते 15 परत मिळतात. .

131
00:09:01,920 --> 00:09:07,520
पण जर आपण हे फक्त बिट जर करण्याची अट जोडली, म्हणजे जर तो बिट 1 असेल

132
00:09:07,520 --> 00:09:13,400
तर 0 नसेल, तर तो फक्त त्या पोझिशन्स बाहेर काढतो जिथे संबंधित बिट चालू आहे.

133
00:09:13,400 --> 00:09:20,320
या प्रकरणात असे दिसते की ती पोझिशन्स 0, 4, 6, 9, इ.

134
00:09:20,720 --> 00:09:24,640
त्या सर्व पोझिशन्स, चालू केलेल्या बिट्सच्या पोझिशन्स

135
00:09:24,640 --> 00:09:29,960
आणि नंतर त्यांना एकत्र XOR करायचे आहे.

136
00:09:29,960 --> 00:09:33,960
पायथनमध्ये हे करण्यासाठी, मी प्रथम काही उपयुक्त कार्ये आयात करू.

137
00:09:33,960 --> 00:09:39,140
अशाप्रकारे आपण या यादीत reduce() कॉल करू शकतो आणि ते कमी करण्यासाठी XOR फंक्शन वापरू शकतो.

138
00:09:39,140 --> 00:09:44,840
हे मुळात XORs घेऊन, यादीतून मार्ग काढते.

139
00:09:44,840 --> 00:09:48,760
तुमची इच्छा असल्यास, तुम्ही ते XOR फंक्शन

140
00:09:48,800 --> 00:09:52,200
कोठूनही आयात न करता स्पष्टपणे लिहू शकता.

141
00:09:52,200 --> 00:09:56,880
तर याक्षणी असे दिसते की जर आपण हे आपल्या 16 बिट्सच्या यादृच्छिक

142
00:09:56,880 --> 00:10:02,080
ब्लॉकवर केले तर ते 9 परत करेल, ज्याचे बायनरी प्रतिनिधित्व 1001 आहे.

143
00:10:02,080 --> 00:10:05,960
आम्ही ते येथे करणार नाही, परंतु तुम्ही एक फंक्शन लिहू शकता जिथे प्रेषक

144
00:10:05,960 --> 00:10:11,560
आवश्यकतेनुसार चार पॅरिटी बिट्स सेट करण्यासाठी बायनरी प्रतिनिधित्व वापरतो, शेवटी हा ब्लॉक अशा

145
00:10:11,560 --> 00:10:16,200
स्थितीत आणतो जिथे कोडची ही ओळ बिट्सच्या संपूर्ण यादीवर चालते. एक 0.

146
00:10:17,200 --> 00:10:20,200
हा एक उत्तम प्रकारे तयार केलेला ब्लॉक मानला जाईल.

147
00:10:20,200 --> 00:10:24,640
काय छान आहे की जर आपण या यादीतील कोणत्याही एका बिट्सला टॉगल केले, नॉइजमधून यादृच्छिक

148
00:10:24,640 --> 00:10:30,600
त्रुटीचे नक्कल करून, जर तुम्ही कोडची हीच ओळ चालवली तर ती त्रुटी प्रिंट करते.

149
00:10:30,600 --> 00:10:31,920
नीट आहे ना?

150
00:10:31,920 --> 00:10:37,200
तुम्ही हा ब्लॉक निळ्या रंगातून मिळवू शकता, त्यावर ही एकल ओळ चालवा

151
00:10:37,200 --> 00:10:42,920
आणि ती आपोआप त्रुटीची स्थिती बाहेर टाकेल, किंवा जर नसेल तर 0.

152
00:10:42,920 --> 00:10:45,520
आणि येथे 16 आकाराबद्दल काही विशेष नाही.

153
00:10:45,520 --> 00:10:52,280
तुमच्याकडे २५६ बिट्सची यादी असेल तर कोडची समान ओळ काम करेल.

154
00:10:52,280 --> 00:10:56,280
2-बिट त्रुटी शोधण्यासाठी मेटा पॅरिटी चेक करण्यासारखे, इथे लिहिण्यासाठी आणखी कोड

155
00:10:56,280 --> 00:11:01,440
आहे हे सांगण्याची गरज नाही, परंतु कल्पना अशी आहे की

156
00:11:01,440 --> 00:11:05,080
आमच्या योजनेतील जवळजवळ सर्व मुख्य तर्क एका XOR कपातीवर येतात.

157
00:11:05,080 --> 00:11:10,600
आता, बायनरी आणि XORs आणि सर्वसाधारणपणे सॉफ्टवेअरसह तुमच्या सोयीनुसार, तुम्हाला एकतर हा दृष्टीकोन

158
00:11:10,600 --> 00:11:15,880
थोडा गोंधळात टाकणारा किंवा इतका अधिक मोहक आणि सोपा वाटू शकतो की, आम्ही

159
00:11:15,880 --> 00:11:19,320
सुरुवातीपासूनच याची सुरुवात का केली नाही याचा तुम्हाला प्रश्न पडतो. - जा

160
00:11:19,320 --> 00:11:22,880
हलक्या शब्दात सांगायचे तर, हार्डवेअरमध्ये हॅमिंग कोडची अंमलबजावणी करताना मल्टीपल

161
00:11:22,880 --> 00:11:27,560
पॅरिटी चेक दृष्टीकोन विचार करणे सोपे आहे, आणि XOR दृष्टीकोन

162
00:11:27,560 --> 00:11:31,380
हे सॉफ्टवेअरमध्ये करत असताना विचार करणे सर्वात सोपा आहे.

163
00:11:31,380 --> 00:11:35,640
पहिली गोष्ट हाताने करणे सर्वात सोपी आहे, आणि मला वाटते की या

164
00:11:35,640 --> 00:11:40,720
सर्व गोष्टींमध्ये अंतर्भूत असलेली मूळ अंतर्ज्ञान स्थापित करणे अधिक चांगले कार्य करते,

165
00:11:40,720 --> 00:11:46,840
म्हणजे एक त्रुटी शोधण्यासाठी आवश्यक असलेली माहिती ब्लॉकच्या आकाराच्या लॉगशी संबंधित आहे.

166
00:11:46,840 --> 00:11:51,020
, किंवा दुसर्‍या शब्दात, ब्लॉकचा आकार दुप्पट होताना तो एकावेळी थोडा वाढतो.

167
00:11:51,020 --> 00:11:55,440
येथे संबंधित वस्तुस्थिती अशी आहे की ती माहिती आपल्याला

168
00:11:55,440 --> 00:11:56,440
किती रिडंडन्सीची आवश्यकता आहे याच्याशी थेट संबंधित आहे.

169
00:11:56,440 --> 00:12:00,320
बहुतेक लोकांच्या गुडघेदुखीच्या प्रतिक्रियेच्या विरोधात हेच चालते जेव्हा ते प्रथम

170
00:12:00,320 --> 00:12:05,280
एखादे संदेश त्रुटींना लवचिक बनवण्याचा विचार करतात, जेथे सामान्यतः संपूर्ण

171
00:12:05,280 --> 00:12:07,520
संदेश कॉपी करणे ही मनात येणारी पहिली प्रवृत्ती असते.

172
00:12:07,520 --> 00:12:11,120
आणि मग, तसे, हा संपूर्ण दुसरा मार्ग आहे ज्यामध्ये आपण कधीकधी हॅमिंग

173
00:12:11,120 --> 00:12:14,800
कोड सादर केलेले दिसतो, जिथे आपण संदेश एका मोठ्या मॅट्रिक्सने गुणाकार करतो.

174
00:12:14,800 --> 00:12:18,580
हे एक प्रकारचे छान आहे कारण ते रेखीय कोडच्या विस्तृत कुटुंबाशी संबंधित आहे, परंतु मला वाटते

175
00:12:18,580 --> 00:12:25,160
की ते कोठून येते किंवा ते कसे मोजले जाते याबद्दल जवळजवळ कोणतीही अंतर्ज्ञान देत नाही.

176
00:12:25,160 --> 00:12:29,340
आणि स्केलिंगबद्दल बोलताना, तुमच्या लक्षात येईल की या योजनेची कार्यक्षमता

177
00:12:29,340 --> 00:12:32,200
केवळ आम्ही ब्लॉक आकार वाढवतो तेव्हाच अधिक चांगली होते.

178
00:12:32,200 --> 00:12:40,560
उदाहरणार्थ, आम्ही पाहिले की 256 बिट्ससह, तुम्ही त्यातील केवळ 3%

179
00:12:40,560 --> 00:12:43,480
जागा रिडंडंसीसाठी वापरत आहात आणि ते तिथून चांगले होत आहे.

180
00:12:43,480 --> 00:12:49,040
पॅरिटी बिट्सची संख्या एक एक करून वाढत असताना, ब्लॉकचा आकार दुप्पट होत जातो.

181
00:12:49,040 --> 00:12:53,840
आणि जर तुम्ही ते टोकापर्यंत नेले, तर तुमच्याकडे एक दशलक्ष बिट्सचा

182
00:12:53,840 --> 00:12:58,800
ब्लॉक असू शकतो, जिथे तुम्ही तुमच्या पॅरिटी चेकसह अक्षरशः 20

183
00:12:58,800 --> 00:13:00,800
प्रश्न खेळत असाल आणि ते फक्त 21 पॅरिटी बिट्स वापरते.

184
00:13:00,800 --> 00:13:05,760
आणि जर तुम्ही दशलक्ष बिट्स पाहण्याचा आणि एक त्रुटी शोधण्याचा

185
00:13:05,760 --> 00:13:08,640
विचार करण्यासाठी मागे पाऊल टाकले तर ते खरोखरच वेडे वाटते.

186
00:13:08,640 --> 00:13:12,680
अर्थातच, समस्या अशी आहे की मोठ्या ब्लॉकसह, एक किंवा दोन बिट त्रुटींपेक्षा

187
00:13:12,680 --> 00:13:18,360
जास्त दिसण्याची शक्यता वाढते आणि हॅमिंग कोड त्यापलीकडे काहीही हाताळत नाहीत.

188
00:13:18,360 --> 00:13:22,020
त्यामुळे व्यवहारात, तुम्हाला योग्य आकार शोधायचा आहे जेणेकरून

189
00:13:22,020 --> 00:13:25,520
खूप जास्त बिट फ्लिप होण्याची शक्यता जास्त नसेल.

190
00:13:26,520 --> 00:13:30,920
तसेच, व्यवहारात, त्रुटी थोड्या वेळाने येतात, ज्यामुळे एकाच ब्लॉकचा पूर्णपणे नाश होतो,

191
00:13:30,920 --> 00:13:35,680
त्यामुळे अनेक वेगवेगळ्या ब्लॉक्समध्ये त्रुटी पसरवण्यास मदत करण्यासाठी एक सामान्य युक्ती म्हणजे

192
00:13:35,680 --> 00:13:41,720
त्या ब्लॉक्सना एकमेकांशी जोडणे, जसे की, ते होण्यापूर्वी. बाहेर पाठवले किंवा साठवले.

193
00:13:45,480 --> 00:13:49,920
नंतर पुन्हा, यापैकी बरेच काही अधिक आधुनिक कोडद्वारे पूर्णपणे विवादित केले जाते, जसे

194
00:13:49,920 --> 00:13:55,060
की सामान्यतः वापरल्या जाणार्‍या रीड-सोलोमन अल्गोरिदम, जे बर्स्ट एरर्स विशेषतः चांगल्या प्रकारे हाताळते

195
00:13:55,100 --> 00:13:59,580
आणि प्रत्येक ब्लॉकमध्ये मोठ्या संख्येने त्रुटींसाठी लवचिक होण्यासाठी ट्यून केले जाऊ शकते. .

196
00:13:59,580 --> 00:14:03,000
पण तो दुसर्‍या वेळी विषय आहे.

197
00:14:03,000 --> 00:14:07,660
त्याच्या द आर्ट ऑफ डुइंग सायन्स अँड इंजिनीअरिंग या पुस्तकात, हॅमिंगने

198
00:14:07,660 --> 00:14:10,700
या कोडचा शोध किती क्षुल्लक होता हे आश्चर्यकारकपणे स्पष्ट केले आहे.

199
00:14:10,700 --> 00:14:15,180
त्याने प्रथम सर्व प्रकारच्या विविध योजना वापरून पाहिल्या ज्यामध्ये बिट्सला उच्च

200
00:14:15,180 --> 00:14:18,420
मितीय जाळीच्या भागांमध्ये व्यवस्थित करणे आणि यासारख्या विचित्र गोष्टींचा समावेश आहे.

201
00:14:18,420 --> 00:14:22,520
एररच्या स्थितीचे स्पेलिंग अशा प्रकारे कट रचण्यासाठी पॅरिटी चेक मिळवणे

202
00:14:22,520 --> 00:14:26,360
शक्य आहे ही कल्पना हॅमिंगला तेव्हाच आली जेव्हा त्याने

203
00:14:26,360 --> 00:14:30,800
इतर विश्लेषणाच्या गुच्छानंतर मागे पाऊल टाकले आणि विचारले, ठीक आहे,

204
00:14:30,800 --> 00:14:32,860
मी सर्वात कार्यक्षम काय आहे? कदाचित या बद्दल असेल?

205
00:14:32,860 --> 00:14:36,760
पॅरिटी चेक त्याच्या मनात आधीपासूनच होते हे किती महत्वाचे आहे याबद्दल ते स्पष्टपणे

206
00:14:36,760 --> 00:14:42,040
सांगत होते, जे आजच्या पेक्षा 1940 च्या दशकात कमी सामान्य झाले असते.

207
00:14:42,040 --> 00:14:46,040
या पुस्तकात अर्धा डझन वेळा त्यांनी लुई पाश्चरच्या कोटाचा

208
00:14:46,040 --> 00:14:49,640
संदर्भ दिला आहे, नशीब तयार मनाला अनुकूल आहे.

209
00:14:49,640 --> 00:14:55,120
हुशार कल्पना अनेकदा भ्रामकपणे सोप्या दिसतात, ज्यामुळे त्यांचे कमी कौतुक करणे सोपे होते.

210
00:14:55,120 --> 00:14:59,680
सध्या माझी प्रामाणिक आशा आहे की हॅमिंग कोड्स किंवा

211
00:14:59,680 --> 00:15:01,820
किमान अशा कोडची शक्यता तुम्हाला जवळजवळ स्पष्ट वाटते.

212
00:15:01,820 --> 00:15:05,440
परंतु ते प्रत्यक्षात स्पष्ट आहेत असा विचार करून

213
00:15:05,440 --> 00:15:08,000
तुम्ही स्वत:ला फसवू नका, कारण ते नक्कीच नाहीत.

214
00:15:08,000 --> 00:15:12,080
हुशार कल्पना भ्रामकपणे सोप्या दिसण्याच्या कारणाचा एक भाग हा आहे की आपण

215
00:15:12,080 --> 00:15:17,360
फक्त अंतिम परिणाम पाहतो, जे गोंधळलेले होते ते साफ करणे, सर्व

216
00:15:17,360 --> 00:15:22,400
चुकीच्या वळणांचा कधीही उल्लेख न करणे, एखाद्या समस्येच्या सुरुवातीला शोधण्यायोग्य शक्यतांची

217
00:15:22,400 --> 00:15:23,980
जागा किती विस्तीर्ण आहे हे कमी करणे. सोडवण्याची प्रक्रिया, ते सर्व.

218
00:15:23,980 --> 00:15:25,280
पण हे सर्वसाधारणपणे खरे आहे.

219
00:15:25,280 --> 00:15:29,880
मला असे वाटते की काही विशेष शोधांसाठी, एक दुसरे,

220
00:15:29,880 --> 00:15:31,040
सखोल कारण आहे की आपण त्यांचे कमी कौतुक करतो.

221
00:15:31,040 --> 00:15:35,040
माहितीच्या सिद्धांतावर क्लॉड शॅननच्या मुख्य पेपरसह 1948 पर्यंत बिट्सच्या संदर्भात

222
00:15:35,040 --> 00:15:39,400
माहितीचा विचार करणे खरोखरच संपूर्ण सिद्धांतामध्ये एकत्रित झाले होते.

223
00:15:39,400 --> 00:15:43,400
जेव्हा हॅमिंगने त्याचे अल्गोरिदम विकसित केले तेव्हा हे मूलत: समांतर होते.

224
00:15:43,440 --> 00:15:47,300
हा तोच पायाभूत कागद होता ज्याने एका विशिष्ट अर्थाने

225
00:15:47,300 --> 00:15:52,080
दाखवून दिले की, किमान सिद्धांतानुसार, बिट फ्लिपची संभाव्यता कितीही

226
00:15:52,080 --> 00:15:53,920
उच्च असली तरीही कार्यक्षम त्रुटी सुधारणे नेहमीच शक्य असते.

227
00:15:53,920 --> 00:15:58,120
शॅनन आणि हॅमिंग यांनी अगदी वेगळ्या गोष्टींवर काम करूनही बेल

228
00:15:58,120 --> 00:16:02,400
लॅबमध्ये एक ऑफिस शेअर केले, जे इथे योगायोगच नाही.

229
00:16:02,400 --> 00:16:06,960
अनेक दशके फास्ट फॉरवर्ड, आणि आजकाल, आपल्यापैकी बरेच जण बिट्स आणि माहितीबद्दल विचार करण्यात इतके

230
00:16:06,960 --> 00:16:13,080
मग्न आहेत की विचार करण्याची ही पद्धत किती वेगळी होती याकडे दुर्लक्ष करणे सोपे आहे.

231
00:16:13,080 --> 00:16:17,920
गंमत म्हणजे, भावी पिढीच्या विचारसरणीला सर्वात गहनपणे आकार

232
00:16:17,920 --> 00:16:22,640
देणार्‍या कल्पना त्या भावी पिढीला त्यांच्यापेक्षा सोप्या वाटतील.

