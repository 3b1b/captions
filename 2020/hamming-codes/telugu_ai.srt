1
00:00:00,000 --> 00:00:03,120
ఇక్కడ అందరూ పార్ట్ 1 నుండి వస్తున్నారని నేను ఊహిస్తున్నాను.

2
00:00:03,120 --> 00:00:06,920
మేము హామింగ్ కోడ్‌ల గురించి మాట్లాడుతున్నాము, చాలా బిట్‌లు అర్థవంతమైన సందేశాన్ని

3
00:00:06,920 --> 00:00:11,640
కలిగి ఉండే డేటా బ్లాక్‌ను సృష్టించే మార్గం, మరికొన్ని ఒక

4
00:00:11,640 --> 00:00:15,800
రకమైన రిడెండెన్సీగా పనిచేస్తాయి, ఆ విధంగా ఏదైనా బిట్ తిప్పబడితే,

5
00:00:15,800 --> 00:00:20,560
సందేశం బిట్ లేదా రిడెండెన్సీ బిట్, ఈ బ్లాక్‌లో ఏదైనా,

6
00:00:20,560 --> 00:00:21,920
రిసీవర్ లోపం ఉందని మరియు దాన్ని ఎలా పరిష్కరించాలో గుర్తించగలదు.

7
00:00:21,920 --> 00:00:25,900
బైనరీ శోధన కోసం బహుళ పారిటీ తనిఖీలను ఎలా

8
00:00:25,900 --> 00:00:29,800
ఉపయోగించాలి అనేది అక్కడ అందించబడిన ప్రాథమిక ఆలోచన.

9
00:00:29,800 --> 00:00:33,920
ఆ వీడియోలో హామింగ్ కోడ్‌లను సాధ్యమైనంత వరకు అందుబాటులో

10
00:00:33,920 --> 00:00:35,420
ఉంచడం మరియు తిరిగి కనుగొనగలిగేలా చేయడం లక్ష్యం.

11
00:00:35,420 --> 00:00:40,040
సాఫ్ట్‌వేర్ లేదా హార్డ్‌వేర్‌లో దీన్ని అమలు చేయడం గురించి మీరు ఆలోచించడం ప్రారంభించినప్పుడు,

12
00:00:40,040 --> 00:00:44,120
ఈ కోడ్‌లు నిజంగా ఎంత సొగసైనవో ఆ ఫ్రేమింగ్ వాస్తవానికి తక్కువగా ఉంటుంది.

13
00:00:44,120 --> 00:00:47,620
సాధ్యమయ్యే అన్ని ఎర్రర్ లొకేషన్‌లను ట్రాక్ చేసే మరియు ప్రతి చెక్‌తో

14
00:00:47,620 --> 00:00:52,320
ఆ సమూహాన్ని సగానికి తగ్గించే అల్గారిథమ్‌ను మీరు వ్రాయవలసి ఉంటుందని

15
00:00:52,320 --> 00:00:54,160
మీరు అనుకోవచ్చు, అయితే ఇది నిజానికి దాని కంటే సరళమైనది.

16
00:00:54,160 --> 00:00:58,720
మేము చివరి వీడియోలో చేసిన నాలుగు సమానత్వ తనిఖీలకు సమాధానాలను మీరు చదివితే, అవును మరియు సంఖ్యలకు

17
00:00:58,760 --> 00:01:04,800
బదులుగా 1 సె మరియు 0 సె, ఇది బైనరీలో లోపం యొక్క స్థానాన్ని అక్షరాలా వివరిస్తుంది.

18
00:01:04,800 --> 00:01:10,160
ఉదాహరణకు, బైనరీలో 7 సంఖ్య 0111 లాగా కనిపిస్తుంది, ముఖ్యంగా

19
00:01:10,160 --> 00:01:12,640
ఇది 4 ప్లస్ 2 ప్లస్ 1 అని చెబుతోంది.

20
00:01:12,640 --> 00:01:17,960
మరియు స్థానం 7 ఎక్కడ కూర్చుందో గమనించండి, ఇది మా సమానత్వ సమూహాలలో

21
00:01:17,960 --> 00:01:22,280
మొదటిదానిని ప్రభావితం చేస్తుంది మరియు రెండవది మరియు మూడవది, కానీ చివరిది కాదు.

22
00:01:22,280 --> 00:01:26,560
కాబట్టి ఆ నాలుగు చెక్‌ల ఫలితాలను దిగువ నుండి

23
00:01:26,560 --> 00:01:28,000
పైకి చదవడం నిజంగా లోపం యొక్క స్థితిని తెలియజేస్తుంది.

24
00:01:28,520 --> 00:01:32,240
ఉదాహరణ 7 గురించి ప్రత్యేకంగా ఏమీ లేదు, ఇది సాధారణంగా పని చేస్తుంది మరియు

25
00:01:32,240 --> 00:01:37,440
ఇది హార్డ్‌వేర్‌లో మొత్తం పథకాన్ని అమలు చేయడానికి తర్కాన్ని దిగ్భ్రాంతికరంగా సులభం చేస్తుంది.

26
00:01:37,440 --> 00:01:43,380
ఇప్పుడు మీరు ఈ మాయాజాలం ఎందుకు జరుగుతుందో చూడాలనుకుంటే, మా స్థానాల కోసం

27
00:01:43,380 --> 00:01:48,480
ఈ 16 సూచిక లేబుల్‌లను తీసుకోండి, కానీ వాటిని బేస్ 10లో వ్రాయడానికి

28
00:01:48,480 --> 00:01:50,720
బదులుగా, 0000 నుండి 1111 వరకు నడుస్తున్న బైనరీలో అన్నింటినీ వ్రాస్దాం.

29
00:01:50,720 --> 00:01:55,880
మేము ఈ బైనరీ లేబుల్‌లను వాటి పెట్టెల్లోకి తిరిగి ఉంచినప్పుడు, అవి

30
00:01:56,080 --> 00:01:58,440
వాస్తవానికి పంపబడుతున్న డేటా నుండి విభిన్నంగా ఉన్నాయని నేను నొక్కిచెబుతున్నాను.

31
00:01:58,440 --> 00:02:02,200
నాలుగు సమానత్వ సమూహాలు ఎక్కడ నుండి వచ్చాయో అర్థం చేసుకోవడంలో మీకు మరియు

32
00:02:02,200 --> 00:02:04,200
నాకు సహాయం చేయడానికి అవి సంభావిత లేబుల్ తప్ప మరేమీ కాదు.

33
00:02:04,200 --> 00:02:08,840
మనం చూస్తున్న ప్రతిదీ బైనరీలో వర్ణించబడటం యొక్క సొగసైనది బహుశా మనం

34
00:02:08,840 --> 00:02:13,160
చూస్తున్న ప్రతిదాన్ని బైనరీలో వివరించడం వల్ల కలిగే గందరగోళం వల్ల తగ్గుతుంది.

35
00:02:13,160 --> 00:02:15,040
అయితే ఇది విలువైనదే.

36
00:02:15,040 --> 00:02:20,740
ఈ లేబుల్‌లన్నింటిలో చివరి బిట్‌పై మాత్రమే మీ దృష్టిని కేంద్రీకరించండి, ఆపై

37
00:02:20,740 --> 00:02:24,280
ఆ చివరి బిట్ 1 ఉన్న స్థానాలను హైలైట్ చేయండి.

38
00:02:24,280 --> 00:02:28,800
మేము పొందేది మా నాలుగు సమానత్వ సమూహాలలో మొదటిది, అంటే

39
00:02:28,800 --> 00:02:34,480
మీరు ఆ మొదటి చెక్‌ని అడుగుతున్నట్లు అర్థం చేసుకోవచ్చు, హే,

40
00:02:34,480 --> 00:02:36,680
లోపం ఉన్నట్లయితే, ఆ లోపం యొక్క స్థానం 1గా ఉందా?

41
00:02:36,680 --> 00:02:42,600
అదేవిధంగా, మీరు రెండవ నుండి చివరి బిట్‌పై దృష్టి సారించి, అది 1 ఉన్న అన్ని

42
00:02:42,600 --> 00:02:47,040
స్థానాలను హైలైట్ చేస్తే, మీరు మా పథకం నుండి రెండవ సమాన సమూహాన్ని పొందుతారు.

43
00:02:47,040 --> 00:02:51,960
మరో మాటలో చెప్పాలంటే, ఆ రెండవ చెక్ అడుగుతోంది, హే, నన్ను మళ్లీ,

44
00:02:51,960 --> 00:02:56,160
లోపం ఉంటే, ఆ స్థానం యొక్క రెండవ నుండి చివరి బిట్ 1నా?

45
00:02:56,160 --> 00:02:57,160
మరియు అందువలన న.

46
00:02:57,160 --> 00:03:03,320
మూడవ పారిటీ చెక్ మూడవ నుండి చివరి బిట్ ఆన్ చేయబడిన ప్రతి స్థానాన్ని కవర్ చేస్తుంది

47
00:03:03,320 --> 00:03:10,120
మరియు చివరిది చివరి ఎనిమిది స్థానాలను కవర్ చేస్తుంది, అత్యధిక ఆర్డర్ బిట్ 1గా ఉంటుంది.

48
00:03:10,120 --> 00:03:15,680
మేము ఇంతకు ముందు చేసినవన్నీ ఈ నాలుగు ప్రశ్నలకు సమాధానమివ్వడం వలెనే

49
00:03:15,680 --> 00:03:18,800
ఉంటాయి, ఇది బైనరీలో ఒక స్థానాన్ని స్పెల్లింగ్ చేయడం వలె ఉంటుంది.

50
00:03:19,800 --> 00:03:22,080
ఇది రెండు విషయాలను స్పష్టం చేస్తుందని నేను ఆశిస్తున్నాను.

51
00:03:22,080 --> 00:03:27,140
మొదటిది రెండు పెద్ద శక్తులు ఉండే పరిమాణాలను బ్లాక్ చేయడానికి క్రమపద్ధతిలో సాధారణీకరించడం ఎలా.

52
00:03:27,140 --> 00:03:33,180
64 స్పాట్‌లను వివరించడానికి ఆరు బిట్‌ల వంటి ప్రతి స్థానాన్ని వివరించడానికి మరిన్ని బిట్‌లు తీసుకుంటే,

53
00:03:33,180 --> 00:03:38,640
ఆ బిట్‌లలో ప్రతి ఒక్కటి మేము తనిఖీ చేయాల్సిన సమాన సమూహాలలో ఒకదాన్ని మీకు అందిస్తుంది.

54
00:03:38,640 --> 00:03:42,060
మీలో మాట్ పార్కర్‌తో నేను చేసిన చదరంగం పజిల్‌ని

55
00:03:42,060 --> 00:03:43,400
చూసిన వారికి ఇవన్నీ బాగా తెలిసి ఉండవచ్చు.

56
00:03:43,400 --> 00:03:48,200
ఇది అదే ప్రధాన తర్కం, కానీ వేరొక

57
00:03:48,200 --> 00:03:49,880
సమస్యను పరిష్కరిస్తుంది మరియు 64-స్క్వేర్డ్ చెస్‌బోర్డ్‌కు వర్తించబడుతుంది.

58
00:03:49,880 --> 00:03:54,000
ఇది స్పష్టం చేస్తుందని నేను ఆశిస్తున్న రెండవ విషయం ఏమిటంటే, మా సమానత్వ బిట్‌లు

59
00:03:54,000 --> 00:03:58,320
రెండు శక్తులైన స్థానాల్లో ఎందుకు కూర్చున్నాయో, ఉదాహరణకు 1, 2, 4 మరియు 8.

60
00:03:58,320 --> 00:04:03,640
బైనరీ ప్రాతినిధ్యం కేవలం ఒక్క బిట్ మాత్రమే ఆన్ చేసిన స్థానాలు ఇవి.

61
00:04:03,640 --> 00:04:09,000
దాని అర్థం ఏమిటంటే, ఆ పారిటీ బిట్‌లలో ప్రతి

62
00:04:09,000 --> 00:04:12,640
ఒక్కటి నాలుగు సమాన సమూహాలలో ఒకటి మాత్రమే ఉంటుంది.

63
00:04:12,640 --> 00:04:16,840
మీరు దీన్ని పెద్ద ఉదాహరణలలో కూడా చూడవచ్చు, ఇక్కడ మీరు ఎంత పెద్దదైనా

64
00:04:16,840 --> 00:04:25,920
సరే, ప్రతి పారిటీ బిట్ సౌకర్యవంతంగా సమూహాలలో ఒకదానిని మాత్రమే తాకుతుంది.

65
00:04:25,920 --> 00:04:29,680
మేము మా సమయాన్ని ఎక్కువగా కేంద్రీకరించిన ఈ సమానత్వ తనిఖీలు బైనరీలో లోపం

66
00:04:29,680 --> 00:04:34,320
యొక్క స్థానాన్ని వివరించడానికి ఒక తెలివైన మార్గం తప్ప మరేమీ కాదని

67
00:04:34,320 --> 00:04:37,880
మీరు అర్థం చేసుకున్న తర్వాత, మేము హామింగ్ గురించి ఆలోచించడానికి వేరొక

68
00:04:37,880 --> 00:04:42,160
మార్గంతో కనెక్షన్‌ని పొందవచ్చు. కోడ్‌లు, ఇది నిస్సందేహంగా చాలా సరళమైనది మరియు

69
00:04:42,160 --> 00:04:43,880
మరింత సొగసైనది మరియు ఇది ప్రాథమికంగా ఒకే లైన్ కోడ్‌తో వ్రాయబడుతుంది.

70
00:04:43,920 --> 00:04:46,200
ఇది XOR ఫంక్షన్‌పై ఆధారపడి ఉంటుంది.

71
00:04:46,200 --> 00:04:50,960
XOR, మీలో తెలియని వారికి, ప్రత్యేకమైనది లేదా.

72
00:04:50,960 --> 00:04:55,440
మీరు రెండు బిట్‌ల XORను తీసుకున్నప్పుడు, ఆ బిట్‌లలో ఒకదానిని ఆన్ చేసినట్లయితే అది

73
00:04:55,440 --> 00:05:00,200
1ని తిరిగి ఇస్తుంది, కానీ రెండూ ఆన్ లేదా ఆఫ్ చేయబడితే కాదు.

74
00:05:00,200 --> 00:05:03,760
విభిన్నంగా పదబంధం, ఇది ఈ రెండు బిట్‌ల సమానత్వం.

75
00:05:03,760 --> 00:05:07,840
గణిత వ్యక్తిగా, నేను దాని గురించి అదనపు మోడ్ 2గా ఆలోచించాలనుకుంటున్నాను.

76
00:05:07,840 --> 00:05:12,000
మేము సాధారణంగా రెండు వేర్వేరు బిట్ స్ట్రింగ్‌ల XOR గురించి

77
00:05:12,040 --> 00:05:14,040
మాట్లాడుతాము, ఇది ప్రాథమికంగా ఈ కాంపోనెంట్‌ను కాంపోనెంట్‌గా చేస్తుంది.

78
00:05:14,040 --> 00:05:16,280
ఇది అదనంగా వంటిది, కానీ మీరు ఎక్కడికి తీసుకెళ్లలేరు.

79
00:05:16,280 --> 00:05:21,240
మళ్ళీ, గణితశాస్త్రపరంగా ఎక్కువ మొగ్గు ఉన్నవారు దీనిని రెండు వెక్టర్‌లను

80
00:05:21,240 --> 00:05:23,520
జోడించడం మరియు మోడ్ 2ను తగ్గించడం వంటిదిగా భావించవచ్చు.

81
00:05:23,520 --> 00:05:28,720
మీరు ప్రస్తుతం కొన్ని పైథాన్‌ని తెరిచి, రెండు పూర్ణాంకాల మధ్య కేరెట్ ఆపరేషన్‌ను వర్తింపజేస్తే,

82
00:05:28,720 --> 00:05:35,400
ఇది హుడ్ కింద ఉన్న ఆ సంఖ్యల బిట్ రిప్రజెంటేషన్‌లకు మాత్రమే చేస్తుంది.

83
00:05:35,400 --> 00:05:40,920
మీకు మరియు నాకు ముఖ్యమైన అంశం ఏమిటంటే, అనేక విభిన్న

84
00:05:40,960 --> 00:05:45,960
బిట్ స్ట్రింగ్‌ల యొక్క XOR తీసుకోవడం అనేది నిలువు వరుసల

85
00:05:45,960 --> 00:05:51,320
మాదిరిగానే, ప్రత్యేక సమూహాల యొక్క పేరడీలను గణించడానికి ఒక మార్గం.

86
00:05:51,320 --> 00:05:54,520
ఇది మా హామింగ్ కోడ్ అల్గారిథమ్ నుండి బహుళ పారిటీ చెక్‌ల గురించి ఆలోచించడానికి

87
00:05:54,520 --> 00:05:59,680
చాలా చురుకైన మార్గాన్ని అందిస్తుంది, ఎందుకంటే అన్నీ ఒకే ఆపరేషన్‌లో ప్యాక్ చేయబడతాయి.

88
00:05:59,680 --> 00:06:02,800
మొదటి చూపులో ఇది చాలా భిన్నంగా కనిపించినప్పటికీ.

89
00:06:02,800 --> 00:06:08,360
ప్రత్యేకంగా బైనరీలో 16 స్థానాలను వ్రాయండి, మనం ఇంతకు ముందు ఉన్నట్లుగా, ఇప్పుడు

90
00:06:08,640 --> 00:06:14,800
మెసేజ్ బిట్ 1కి ఆన్ చేయబడిన స్థానాలను హైలైట్ చేయండి, ఆపై

91
00:06:14,800 --> 00:06:19,400
ఈ స్థానాలను ఒక పెద్ద నిలువు వరుసలో సేకరించి XOR తీసుకోండి.

92
00:06:19,400 --> 00:06:23,480
ఫలితంగా దిగువన కూర్చున్న 4 బిట్‌లు మనకు తెలిసిన మరియు ఇష్టపడే

93
00:06:23,480 --> 00:06:27,480
4 పారిటీ చెక్‌ల మాదిరిగానే ఉంటాయని మీరు బహుశా ఊహించవచ్చు,

94
00:06:27,480 --> 00:06:32,720
అయితే సరిగ్గా ఎందుకు అని ఆలోచించడానికి కొంత సమయం కేటాయించండి.

95
00:06:32,720 --> 00:06:37,880
ఈ చివరి నిలువు వరుస, ఉదాహరణకు, చివరి బిట్ 1 ఉన్న అన్ని స్థానాలను

96
00:06:38,400 --> 00:06:42,400
గణిస్తోంది, కానీ మేము ఇప్పటికే హైలైట్ చేసిన స్థానాలకు మాత్రమే పరిమితం చేసాము, కాబట్టి

97
00:06:42,400 --> 00:06:45,960
ఇది మొదటి సమూహ సమూహం నుండి ఎన్ని హైలైట్ చేయబడిన స్థానాలను ప్రభావవంతంగా లెక్కిస్తుంది.

98
00:06:45,960 --> 00:06:48,520
అది సమంజసమా?

99
00:06:48,520 --> 00:06:53,600
అదేవిధంగా, తదుపరి నిలువు వరుస రెండవ సమాన సమూహంలో ఎన్ని స్థానాలు

100
00:06:53,600 --> 00:06:59,640
ఉన్నాయి, రెండవ నుండి చివరి బిట్ 1 వరకు ఉన్న

101
00:06:59,640 --> 00:07:00,640
స్థానాలు మరియు హైలైట్ చేయబడినవి మరియు మొదలైనవి కూడా లెక్కించబడతాయి.

102
00:07:00,640 --> 00:07:06,640
ఇది నిజంగా మనం చేస్తున్న అదే పనిపై దృష్టికోణంలో చిన్న మార్పు.

103
00:07:07,640 --> 00:07:10,000
మరియు అది ఇక్కడ నుండి ఎక్కడికి వెళుతుందో మీకు తెలుసు.

104
00:07:10,000 --> 00:07:14,400
మొత్తం 0000 వరకు పని చేస్తుందని నిర్ధారించుకోవడానికి కొన్ని ప్రత్యేక

105
00:07:14,400 --> 00:07:19,640
పారిటీ బిట్‌లను టోగుల్ చేయడానికి పంపినవారు బాధ్యత వహిస్తారు.

106
00:07:19,640 --> 00:07:23,600
ఇప్పుడు మనం దీన్ని ఇలా కలిగి ఉంటే, దిగువన ఉన్న ఈ నాలుగు ఫలిత బిట్‌లు నేరుగా లోపం

107
00:07:23,600 --> 00:07:28,720
యొక్క స్థానాన్ని ఎందుకు వివరిస్తాయి అనే దాని గురించి ఆలోచించడానికి ఇది మాకు నిజంగా మంచి మార్గాన్ని ఇస్తుంది.

108
00:07:28,720 --> 00:07:32,680
ఈ బ్లాక్‌లోని కొంత బిట్ 0 నుండి 1కి టోగుల్ చేయబడిందని అనుకుందాం.

109
00:07:32,720 --> 00:07:37,320
దీని అర్థం ఏమిటంటే, ఆ బిట్ యొక్క స్థానం ఇప్పుడు

110
00:07:37,320 --> 00:07:42,960
మొత్తం XORలో చేర్చబడుతుంది, ఇది మొత్తాన్ని 0 నుండి బదులుగా

111
00:07:42,960 --> 00:07:44,800
ఈ కొత్తగా చేర్చబడిన విలువ, లోపం యొక్క స్థానంగా మారుస్తుంది.

112
00:07:44,800 --> 00:07:48,800
కొంచెం తక్కువ స్పష్టంగా, 1 నుండి 0కి

113
00:07:48,800 --> 00:07:49,800
మార్చే లోపం ఉన్నట్లయితే అదే నిజం.

114
00:07:49,800 --> 00:07:54,720
మీరు చూడండి, మీరు ఒక బిట్ స్ట్రింగ్‌ని రెండుసార్లు కలిపితే, అది అక్కడ

115
00:07:54,720 --> 00:07:59,000
లేనట్లే, ప్రాథమికంగా ఈ ప్రపంచంలో 1 ప్లస్ 1 0కి సమానం.

116
00:07:59,000 --> 00:08:03,720
కాబట్టి మొత్తం మొత్తానికి ఈ స్థానం యొక్క కాపీని

117
00:08:03,720 --> 00:08:05,400
జోడించడం వలన మనం దానిని తరలిస్తున్నట్లే ప్రభావం ఉంటుంది.

118
00:08:05,400 --> 00:08:10,080
మరియు ఆ ప్రభావం, మళ్ళీ, ఇక్కడ దిగువన ఉన్న

119
00:08:10,080 --> 00:08:13,480
మొత్తం ఫలితం లోపం యొక్క స్థానాన్ని తెలియజేస్తుంది.

120
00:08:13,480 --> 00:08:17,720
ఇది ఎంత సొగసైనదో వివరించడానికి, నేను ఇంతకు ముందు ప్రస్తావించిన పైథాన్ కోడ్‌లోని

121
00:08:17,720 --> 00:08:22,120
ఒక లైన్‌ను చూపుతాను, ఇది రిసీవర్ చివరన దాదాపు అన్ని లాజిక్‌లను సంగ్రహిస్తుంది.

122
00:08:22,120 --> 00:08:27,160
మేము డేటా బ్లాక్‌ను అనుకరించడానికి 16 1సె మరియు 0 సె యాదృచ్ఛిక

123
00:08:27,160 --> 00:08:31,160
శ్రేణిని సృష్టించడం ద్వారా ప్రారంభిస్తాము మరియు నేను దానికి బిట్‌లను ఇస్తాను, అయితే

124
00:08:31,160 --> 00:08:36,160
ఆచరణలో ఇది మనం పంపినవారి నుండి స్వీకరించేదే అవుతుంది మరియు బదులుగా యాదృచ్ఛికంగా

125
00:08:36,160 --> 00:08:38,600
ఇది 5 పారిటీ బిట్‌లతో కలిపి 11 డేటా బిట్‌లను కలిగి ఉంటుంది.

126
00:08:38,600 --> 00:08:43,160
నేను ఫంక్షన్ enumerateBits అని పిలిస్తే, అది చేసేది ఆ బిట్‌లను సంబంధిత

127
00:08:43,160 --> 00:08:48,240
సూచికతో జత చేయడం, ఈ సందర్భంలో 0 నుండి 15 వరకు నడుస్తుంది.

128
00:08:48,240 --> 00:08:53,200
కాబట్టి మనం ఈ అన్ని జతలపై లూప్ చేసే జాబితాను సృష్టించినట్లయితే, i లాగా కనిపించే

129
00:08:53,200 --> 00:08:59,160
జంటలు, ఆపై మేము కేవలం i విలువను, కేవలం సూచికను తీసివేస్తే, అది అంత ఉత్తేజకరమైనది

130
00:08:59,160 --> 00:09:01,920
కాదు, మేము ఆ సూచికలను 0 నుండి 15 వరకు తిరిగి పొందుతాము. .

131
00:09:01,920 --> 00:09:07,520
కానీ మనం దీన్ని బిట్ అయితే మాత్రమే చేయాలనే షరతును జోడిస్తే, అంటే ఆ బిట్ 1

132
00:09:07,520 --> 00:09:13,400
మరియు 0 కాకపోతే, అది సంబంధిత బిట్ ఆన్ చేయబడిన స్థానాలను మాత్రమే బయటకు తీస్తుంది.

133
00:09:13,400 --> 00:09:20,320
ఈ సందర్భంలో ఆ స్థానాలు 0, 4, 6, 9, మొదలైనవి ఉన్నట్లు కనిపిస్తోంది.

134
00:09:20,720 --> 00:09:24,640
మనకు కావలసినది ఏమిటంటే, ఆ స్థానాలు, ఆన్ చేయబడిన బిట్‌ల

135
00:09:24,640 --> 00:09:29,960
స్థానాలు అన్నీ కలిపి, ఆపై వాటిని కలిపి XOR చేయడం.

136
00:09:29,960 --> 00:09:33,960
పైథాన్‌లో దీన్ని చేయడానికి, నేను ముందుగా ఒక జంట సహాయక ఫంక్షన్‌లను దిగుమతి చేస్తాను.

137
00:09:33,960 --> 00:09:39,140
ఆ విధంగా మనం ఈ జాబితాలో తగ్గించు() అని పిలుస్తాము మరియు దానిని తగ్గించడానికి XOR ఫంక్షన్‌ని ఉపయోగించవచ్చు.

138
00:09:39,140 --> 00:09:44,840
ఇది ప్రాథమికంగా జాబితా ద్వారా దాని మార్గాన్ని తింటుంది, మార్గం వెంట XORలను తీసుకుంటుంది.

139
00:09:44,840 --> 00:09:48,760
మీరు కావాలనుకుంటే, మీరు ఎక్కడి నుండైనా దిగుమతి

140
00:09:48,800 --> 00:09:52,200
చేయకుండానే ఆ XOR ఫంక్షన్‌ని స్పష్టంగా వ్రాయవచ్చు.

141
00:09:52,200 --> 00:09:56,880
కాబట్టి ప్రస్తుతానికి మనం దీన్ని 16 బిట్‌ల యాదృచ్ఛిక బ్లాక్‌లో చేస్తే,

142
00:09:56,880 --> 00:10:02,080
అది బైనరీ ప్రాతినిధ్యం 1001ని కలిగి ఉన్న 9ని తిరిగి ఇస్తుంది.

143
00:10:02,080 --> 00:10:05,960
మేము దీన్ని ఇక్కడ చేయము, కానీ పంపినవారు నాలుగు పారిటీ బిట్‌లను అవసరమైన విధంగా సెట్

144
00:10:05,960 --> 00:10:11,560
చేయడానికి బైనరీ ప్రాతినిధ్యాన్ని ఉపయోగించే ఒక ఫంక్షన్‌ను మీరు వ్రాయవచ్చు, చివరికి ఈ బ్లాక్‌ని బిట్‌ల

145
00:10:11,560 --> 00:10:16,200
పూర్తి జాబితాలో ఈ లైన్ కోడ్‌ని అమలు చేసే స్థితికి చేరుకుంటుంది. ఒక 0.

146
00:10:17,200 --> 00:10:20,200
ఇది బాగా సిద్ధమైన బ్లాక్‌గా పరిగణించబడుతుంది.

147
00:10:20,200 --> 00:10:24,640
మంచి విషయం ఏమిటంటే, శబ్దం నుండి యాదృచ్ఛిక లోపాన్ని అనుకరిస్తూ, ఈ జాబితాలోని ఏదైనా బిట్‌లను మనం

148
00:10:24,640 --> 00:10:30,600
టోగుల్ చేస్తే, మీరు ఇదే లైన్ కోడ్‌ను అమలు చేస్తే, అది ఆ లోపాన్ని ముద్రిస్తుంది.

149
00:10:30,600 --> 00:10:31,920
అది చక్కగా లేదా?

150
00:10:31,920 --> 00:10:37,200
మీరు ఈ బ్లాక్‌ను నీలిరంగు నుండి పొందవచ్చు, దానిపై ఈ సింగిల్ లైన్‌ను అమలు చేయవచ్చు

151
00:10:37,200 --> 00:10:42,920
మరియు అది స్వయంచాలకంగా లోపం యొక్క స్థానం లేదా ఏదైనా లేకుంటే 0ని ఉమ్మివేస్తుంది.

152
00:10:42,920 --> 00:10:45,520
మరియు ఇక్కడ పరిమాణం 16 గురించి ప్రత్యేకంగా ఏమీ లేదు.

153
00:10:45,520 --> 00:10:52,280
మీరు 256 బిట్‌ల జాబితాను కలిగి ఉంటే అదే లైన్ కోడ్ పని చేస్తుంది.

154
00:10:52,280 --> 00:10:56,280
2-బిట్ ఎర్రర్‌లను గుర్తించడానికి మెటా పారిటీ చెక్ చేయడం వంటి మరిన్ని

155
00:10:56,280 --> 00:11:01,440
కోడ్‌లు ఇక్కడ వ్రాయాలని ప్రత్యేకంగా చెప్పనవసరం లేదు, అయితే మా స్కీమ్‌లోని

156
00:11:01,440 --> 00:11:05,080
దాదాపు అన్ని కోర్ లాజిక్‌లు ఒకే XOR తగ్గింపుకు వస్తాయి.

157
00:11:05,080 --> 00:11:10,600
ఇప్పుడు, బైనరీ మరియు XORలు మరియు సాధారణంగా సాఫ్ట్‌వేర్‌తో మీ సౌకర్యాన్ని బట్టి,

158
00:11:10,600 --> 00:11:15,880
మీరు ఈ దృక్పథాన్ని కొంచెం గందరగోళంగా లేదా చాలా సొగసైన మరియు

159
00:11:15,880 --> 00:11:19,320
సరళంగా కనుగొనవచ్చు, మేము దీన్ని ఎందుకు ప్రారంభించలేదని మీరు ఆశ్చర్యపోతున్నారు. -వెళ్ళండి.

160
00:11:19,320 --> 00:11:22,880
వదులుగా చెప్పాలంటే, హార్డ్‌వేర్‌లో హామింగ్ కోడ్‌లను నేరుగా అమలు చేసేటప్పుడు బహుళ

161
00:11:22,880 --> 00:11:27,560
పారిటీ తనిఖీ దృక్పథం గురించి ఆలోచించడం సులభం, మరియు XOR దృక్పథాన్ని

162
00:11:27,560 --> 00:11:31,380
సాఫ్ట్‌వేర్‌లో చేసేటప్పుడు, ఉన్నత స్థాయి నుండి ఆలోచించడం చాలా సులభం.

163
00:11:31,380 --> 00:11:35,640
మొదటిది వాస్తవానికి చేతితో చేయడం చాలా సులభం, మరియు వీటన్నింటికీ అంతర్లీనంగా ఉన్న ప్రధాన

164
00:11:35,640 --> 00:11:40,720
అంతర్ దృష్టిని కలిగించడం మంచి పని చేస్తుందని నేను భావిస్తున్నాను, అంటే ఒకే లోపాన్ని

165
00:11:40,720 --> 00:11:46,840
గుర్తించడానికి అవసరమైన సమాచారం బ్లాక్ పరిమాణం యొక్క లాగ్‌కు సంబంధించినది. , లేదా మరో

166
00:11:46,840 --> 00:11:51,020
మాటలో చెప్పాలంటే, బ్లాక్ సైజు రెట్టింపు అయ్యే కొద్దీ ఒక్కోసారి అది పెరుగుతుంది.

167
00:11:51,020 --> 00:11:55,440
ఇక్కడ సంబంధిత వాస్తవం ఏమిటంటే, ఆ సమాచారం మనకు

168
00:11:55,440 --> 00:11:56,440
ఎంత రిడెండెన్సీ అవసరమో దానికి నేరుగా అనుగుణంగా ఉంటుంది.

169
00:11:56,440 --> 00:12:00,320
చాలా మంది వ్యక్తుల యొక్క మోకాలి కుదుపు ప్రతిచర్యకు వ్యతిరేకంగా జరిగేది అదే,

170
00:12:00,320 --> 00:12:05,280
వారు ఒక సందేశాన్ని లోపాలను తట్టుకునేలా చేయడం గురించి మొదట ఆలోచించినప్పుడు, సాధారణంగా

171
00:12:05,280 --> 00:12:07,520
మొత్తం సందేశాన్ని కాపీ చేయడం అనేది గుర్తుకు వచ్చే మొదటి ప్రవృత్తి.

172
00:12:07,520 --> 00:12:11,120
ఆపై, మార్గం ద్వారా, మీరు కొన్నిసార్లు హామింగ్ కోడ్‌లను ప్రదర్శించే ఈ మొత్తం ఇతర

173
00:12:11,120 --> 00:12:14,800
మార్గం ఉంది, ఇక్కడ మీరు సందేశాన్ని ఒక పెద్ద మ్యాట్రిక్స్ ద్వారా గుణిస్తారు.

174
00:12:14,800 --> 00:12:18,580
ఇది చాలా బాగుంది ఎందుకంటే ఇది సరళ కోడ్‌ల యొక్క విస్తృత కుటుంబానికి సంబంధించినది, కానీ అది ఎక్కడ నుండి

175
00:12:18,580 --> 00:12:25,160
వస్తుంది లేదా ఎలా స్కేల్ చేస్తుంది అనే దాని గురించి దాదాపు అంతర్ దృష్టిని ఇవ్వదని నేను భావిస్తున్నాను.

176
00:12:25,160 --> 00:12:29,340
మరియు స్కేలింగ్ గురించి చెప్పాలంటే, మేము బ్లాక్ పరిమాణాన్ని పెంచుతున్నప్పుడు

177
00:12:29,340 --> 00:12:32,200
మాత్రమే ఈ పథకం యొక్క సామర్థ్యం మెరుగుపడుతుందని మీరు గమనించవచ్చు.

178
00:12:32,200 --> 00:12:40,560
ఉదాహరణకు, 256 బిట్‌లతో, మీరు రిడెండెన్సీ కోసం ఆ స్థలంలో 3%

179
00:12:40,560 --> 00:12:43,480
మాత్రమే ఉపయోగిస్తున్నారని మేము చూశాము మరియు అది అక్కడ నుండి మెరుగుపడుతోంది.

180
00:12:43,480 --> 00:12:49,040
పారిటీ బిట్‌ల సంఖ్య ఒక్కొక్కటిగా పెరుగుతున్న కొద్దీ, బ్లాక్ పరిమాణం రెట్టింపు అవుతూ ఉంటుంది.

181
00:12:49,040 --> 00:12:53,840
మరియు మీరు దానిని విపరీతంగా తీసుకుంటే, మీరు మిలియన్ బిట్‌లతో బ్లాక్‌ను కలిగి

182
00:12:53,840 --> 00:12:58,800
ఉండవచ్చు, ఇక్కడ మీరు మీ పారిటీ తనిఖీలతో అక్షరాలా 20 ప్రశ్నలను

183
00:12:58,800 --> 00:13:00,800
ప్లే చేస్తారు మరియు ఇది 21 పారిటీ బిట్‌లను మాత్రమే ఉపయోగిస్తుంది.

184
00:13:00,800 --> 00:13:05,760
మరియు మీరు మిలియన్ బిట్‌లను చూడటం మరియు ఒక్క ఎర్రర్‌ను గుర్తించడం

185
00:13:05,760 --> 00:13:08,640
గురించి ఆలోచించడానికి వెనుకడుగు వేస్తే, అది నిజంగా పిచ్చిగా అనిపిస్తుంది.

186
00:13:08,640 --> 00:13:12,680
సమస్య ఏమిటంటే, పెద్ద బ్లాక్‌తో, ఒకటి లేదా రెండు కంటే ఎక్కువ బిట్ ఎర్రర్‌లను

187
00:13:12,680 --> 00:13:18,360
చూసే సంభావ్యత పెరుగుతుంది మరియు హామింగ్ కోడ్‌లు అంతకు మించి దేనినీ నిర్వహించవు.

188
00:13:18,360 --> 00:13:22,020
కాబట్టి ఆచరణలో, మీకు కావలసినది సరైన పరిమాణాన్ని కనుగొనడం, తద్వారా

189
00:13:22,020 --> 00:13:25,520
చాలా ఎక్కువ బిట్ ఫ్లిప్‌ల సంభావ్యత చాలా ఎక్కువగా ఉండదు.

190
00:13:26,520 --> 00:13:30,920
అలాగే, ఆచరణలో, లోపాలు చిన్న పేలుళ్లలో వస్తాయి, ఇది ఒక బ్లాక్‌ను పూర్తిగా నాశనం చేస్తుంది,

191
00:13:30,920 --> 00:13:35,680
కాబట్టి అనేక విభిన్న బ్లాక్‌లలో లోపాలను వ్యాప్తి చేయడంలో సహాయపడే ఒక సాధారణ వ్యూహం ఏమిటంటే,

192
00:13:35,680 --> 00:13:41,720
ఆ బ్లాక్‌లను వాటి ముందు ఇలా ఇంటర్‌లేస్ చేయడం. బయటకు పంపబడింది లేదా నిల్వ చేయబడుతుంది.

193
00:13:45,480 --> 00:13:49,920
మరలా, చాలా సాధారణంగా ఉపయోగించే రీడ్-సోలమన్ అల్గోరిథం వంటి ఆధునిక కోడ్‌ల ద్వారా చాలా

194
00:13:49,920 --> 00:13:55,060
వరకు పూర్తిగా మూట్ చేయబడింది, ఇది బరస్ట్ ఎర్రర్‌లను ప్రత్యేకంగా నిర్వహిస్తుంది మరియు

195
00:13:55,100 --> 00:13:59,580
ప్రతి బ్లాక్‌కు పెద్ద సంఖ్యలో ఎర్రర్‌లకు స్థితిస్థాపకంగా ఉండేలా ట్యూన్ చేయవచ్చు. .

196
00:13:59,580 --> 00:14:03,000
కానీ అది మరొక సారి చర్చనీయాంశం.

197
00:14:03,000 --> 00:14:07,660
అతని పుస్తకం ది ఆర్ట్ ఆఫ్ డూయింగ్ సైన్స్ అండ్ ఇంజినీరింగ్‌లో, హామింగ్

198
00:14:07,660 --> 00:14:10,700
ఈ కోడ్‌ని తన కనిపెట్టడం ఎంత మెలికలు తిరిగిపోయిందో అద్భుతంగా చెప్పాడు.

199
00:14:10,700 --> 00:14:15,180
అతను మొదట బిట్‌లను అధిక డైమెన్షనల్ లాటిస్‌లోని భాగాలుగా నిర్వహించడం మరియు

200
00:14:15,180 --> 00:14:18,420
ఇలాంటి వింత విషయాలతో కూడిన అన్ని రకాల విభిన్న స్కీమ్‌లను ప్రయత్నించాడు.

201
00:14:18,420 --> 00:14:22,520
లోపం యొక్క స్థితిని వివరించే విధంగా కుట్ర చేయడానికి సమానత్వ

202
00:14:22,520 --> 00:14:26,360
తనిఖీలను పొందడం సాధ్యమవుతుందనే ఆలోచన హామింగ్‌కు వచ్చినప్పుడు అతను ఇతర

203
00:14:26,360 --> 00:14:30,800
విశ్లేషణల సమూహం తర్వాత వెనక్కి వెళ్లి, సరే, నేను చేయగలిగిన

204
00:14:30,800 --> 00:14:32,860
అత్యంత సమర్థవంతమైనది ఏమిటి అని అడిగాడు. దీని గురించి ఆలోచించవచ్చా?

205
00:14:32,860 --> 00:14:36,760
1940 లలో ఈనాటి కంటే తక్కువ సాధారణం అయ్యే పారిటీ తనిఖీలు అతని

206
00:14:36,760 --> 00:14:42,040
మనస్సులో ఇప్పటికే ఉండటం ఎంత ముఖ్యమో కూడా అతను నిజాయితీగా ఉన్నాడు.

207
00:14:42,040 --> 00:14:46,040
అతను లూయిస్ పాశ్చర్ కోట్‌ను ప్రస్తావించిన అరడజను సార్లు ఈ

208
00:14:46,040 --> 00:14:49,640
పుస్తకంలో ఉన్నాయి, అదృష్టం సిద్ధమైన మనస్సుకు అనుకూలంగా ఉంటుంది.

209
00:14:49,640 --> 00:14:55,120
తెలివైన ఆలోచనలు తరచుగా వెనుకకు చూస్తే మోసపూరితంగా సరళంగా కనిపిస్తాయి, ఇది వాటిని తక్కువ అంచనా వేయడానికి సులభం చేస్తుంది.

210
00:14:55,120 --> 00:14:59,680
హామింగ్ కోడ్‌లు లేదా కనీసం అలాంటి కోడ్‌ల అవకాశం మీకు

211
00:14:59,680 --> 00:15:01,820
దాదాపు స్పష్టంగా కనిపిస్తుందని ప్రస్తుతం నా నిజాయితీ ఆశ.

212
00:15:01,820 --> 00:15:05,440
అయితే అవి స్పష్టంగా కనిపిస్తున్నాయని భావించి మిమ్మల్ని మీరు

213
00:15:05,440 --> 00:15:08,000
మోసం చేసుకోకూడదు, ఎందుకంటే అవి ఖచ్చితంగా కావు.

214
00:15:08,000 --> 00:15:12,080
తెలివైన ఆలోచనలు మోసపూరితంగా తేలికగా కనిపించడానికి ఒక కారణం ఏమిటంటే, మనం

215
00:15:12,080 --> 00:15:17,360
ఎప్పుడైనా తుది ఫలితాన్ని మాత్రమే చూస్తాము, గజిబిజిగా ఉన్నవాటిని శుభ్రం చేయడం,

216
00:15:17,360 --> 00:15:22,400
తప్పు మలుపులన్నింటినీ ఎప్పుడూ ప్రస్తావించకపోవడం, సమస్య ప్రారంభంలో అన్వేషించదగిన అవకాశాల స్థలం

217
00:15:22,400 --> 00:15:23,980
ఎంత విశాలంగా ఉందో తక్కువగా అమ్మడం. పరిష్కార ప్రక్రియ, అన్నింటినీ.

218
00:15:23,980 --> 00:15:25,280
కానీ ఇది సాధారణంగా నిజం.

219
00:15:25,280 --> 00:15:29,880
కొన్ని ప్రత్యేక ఆవిష్కరణల కోసం, మనం వాటిని తక్కువగా అంచనా

220
00:15:29,880 --> 00:15:31,040
వేయడానికి రెండవ, లోతైన కారణం ఉందని నేను భావిస్తున్నాను.

221
00:15:31,040 --> 00:15:35,040
సమాచార సిద్ధాంతంపై క్లాడ్ షానన్ యొక్క సెమినల్ పేపర్‌తో 1948 నాటికి

222
00:15:35,040 --> 00:15:39,400
బిట్‌ల పరంగా సమాచారం గురించి ఆలోచించడం నిజంగా పూర్తి సిద్ధాంతంగా కలిసిపోయింది.

223
00:15:39,400 --> 00:15:43,400
హామింగ్ తన అల్గారిథమ్‌ను అభివృద్ధి చేసినప్పుడు ఇది తప్పనిసరిగా సమానంగా ఉంటుంది.

224
00:15:43,440 --> 00:15:47,300
బిట్ ఫ్లిప్‌ల సంభావ్యత ఎంత ఎక్కువగా ఉన్నా, కనీసం

225
00:15:47,300 --> 00:15:52,080
థియరీలో అయినా సమర్థవంతమైన లోపాన్ని సరిదిద్దడం ఎల్లప్పుడూ సాధ్యమేనని

226
00:15:52,080 --> 00:15:53,920
ఒక నిర్దిష్ట కోణంలో చూపించిన అదే పునాది పేపర్.

227
00:15:53,920 --> 00:15:58,120
షానన్ మరియు హామింగ్, చాలా భిన్నమైన విషయాలపై పనిచేసినప్పటికీ, బెల్

228
00:15:58,120 --> 00:16:02,400
ల్యాబ్స్‌లో కార్యాలయాన్ని పంచుకున్నారు, ఇది ఇక్కడ యాదృచ్ఛికంగా కనిపించదు.

229
00:16:02,400 --> 00:16:06,960
కొన్ని దశాబ్దాలుగా ఫాస్ట్ ఫార్వార్డ్, మరియు ఈ రోజుల్లో, మనలో చాలా మంది బిట్స్ మరియు

230
00:16:06,960 --> 00:16:13,080
సమాచారం గురించి ఆలోచించడంలో మునిగిపోయారు, ఈ ఆలోచనా విధానం ఎంత విభిన్నంగా ఉందో పట్టించుకోవడం సులభం.

231
00:16:13,080 --> 00:16:17,920
హాస్యాస్పదంగా, భవిష్యత్ తరం ఆలోచించే మార్గాలను చాలా లోతుగా రూపొందించే

232
00:16:17,920 --> 00:16:22,640
ఆలోచనలు ఆ భవిష్యత్తు తరానికి నిజంగా ఉన్నదానికంటే సరళంగా కనిపిస్తాయి.

