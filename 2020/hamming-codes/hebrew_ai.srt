1
00:00:00,000 --> 00:00:03,120
אני מניח שכולם כאן מגיעים מחלק 1.

2
00:00:03,120 --> 00:00:06,920
דיברנו על קודי Hamming, דרך ליצור גוש נתונים שבו

3
00:00:06,920 --> 00:00:11,640
רוב הביטים נושאים מסר משמעותי, בעוד שכמה אחרים פועלים

4
00:00:11,640 --> 00:00:15,800
כסוג של יתירות, באופן כזה שאם ביט כלשהו יתהפך,

5
00:00:15,800 --> 00:00:20,560
או הודעה סיביות או סיביות יתירות, כל דבר בבלוק

6
00:00:20,560 --> 00:00:21,920
הזה, מקלט יוכל לזהות שהייתה שגיאה ואיך לתקן אותה.

7
00:00:21,920 --> 00:00:25,900
הרעיון הבסיסי שהוצג שם היה כיצד להשתמש בבדיקות זוגיות

8
00:00:25,900 --> 00:00:29,800
מרובות כדי לחפש בינארי בדרך למטה אל השגיאה.

9
00:00:29,800 --> 00:00:33,920
בסרטון ההוא המטרה הייתה לגרום לקודי האמינג

10
00:00:33,920 --> 00:00:35,420
להרגיש מעשיים וניתנים לגילוי מחדש ככל האפשר.

11
00:00:35,420 --> 00:00:40,040
אבל כשאתה מתחיל לחשוב על יישום זה בפועל, בתוכנה או בחומרה,

12
00:00:40,040 --> 00:00:44,120
המסגור הזה עשוי למעשה להמחיש עד כמה הקודים האלה אלגנטיים באמת.

13
00:00:44,120 --> 00:00:47,620
אולי אתה חושב שאתה צריך לכתוב אלגוריתם שעוקב אחר כל

14
00:00:47,620 --> 00:00:52,320
מיקומי השגיאות האפשריים וחותך את הקבוצה הזו לשניים עם

15
00:00:52,320 --> 00:00:54,160
כל בדיקה, אבל זה למעשה הרבה יותר פשוט מזה.

16
00:00:54,160 --> 00:00:58,720
אם אתה קורא את התשובות לארבעת בדיקות השוויון שעשינו בסרטון האחרון, כולן בתור

17
00:00:58,760 --> 00:01:04,800
1 ו-0 במקום כן ולא, זה ממש מפרט את מיקום השגיאה בבינארי.

18
00:01:04,800 --> 00:01:10,160
לדוגמה, המספר 7 בבינארי נראה כמו 0111, בעצם

19
00:01:10,160 --> 00:01:12,640
אומר שהוא 4 ועוד 2 ועוד 1.

20
00:01:12,640 --> 00:01:17,960
ושימו לב היכן יושבת עמדה 7, היא אכן משפיעה על

21
00:01:17,960 --> 00:01:22,280
הראשונה בקבוצות השוויוניות שלנו, והשנייה, והשלישית, אך לא האחרונה.

22
00:01:22,280 --> 00:01:26,560
אז קריאת התוצאות של ארבעת הבדיקות הללו מלמטה

23
00:01:26,560 --> 00:01:28,000
למעלה אכן מפרטת את מיקומו של השגיאה.

24
00:01:28,520 --> 00:01:32,240
אין שום דבר מיוחד בדוגמה 7, זה עובד באופן כללי,

25
00:01:32,240 --> 00:01:37,440
וזה הופך את ההיגיון ליישום כל הסכימה בחומרה לפשוטה להחריד.

26
00:01:37,440 --> 00:01:43,380
עכשיו אם אתה רוצה לראות למה הקסם הזה קורה, קח את

27
00:01:43,380 --> 00:01:48,480
16 תוויות האינדקס האלה עבור העמדות שלנו, אבל במקום לכתוב אותן

28
00:01:48,480 --> 00:01:50,720
בבסיס 10, בוא נכתוב את כולם בבינארי, החל מ-0000 עד 1111.

29
00:01:50,720 --> 00:01:55,880
כשאנחנו מחזירים את התוויות הבינאריות האלה לקופסאות שלהן,

30
00:01:56,080 --> 00:01:58,440
הרשו לי להדגיש שהן שונות מהנתונים שנשלחים בפועל.

31
00:01:58,440 --> 00:02:02,200
הם לא יותר מאשר תווית מושגית כדי לעזור

32
00:02:02,200 --> 00:02:04,200
לך ולי להבין מאיפה הגיעו ארבע קבוצות השוויון.

33
00:02:04,200 --> 00:02:08,840
האלגנטיות של זה שכל מה שאנחנו מסתכלים עליו יתואר בבינארי הוא אולי

34
00:02:08,840 --> 00:02:13,160
תחת הבלבול של זה שכל מה שאנחנו מסתכלים עליו מתואר בבינארי.

35
00:02:13,160 --> 00:02:15,040
אבל זה שווה את זה.

36
00:02:15,040 --> 00:02:20,740
מקד את תשומת לבך רק לחלק האחרון של כל התוויות הללו,

37
00:02:20,740 --> 00:02:24,280
ולאחר מכן הדגש את המיקומים שבהם הקטע האחרון הוא 1.

38
00:02:24,280 --> 00:02:28,800
מה שאנחנו מקבלים היא הראשונה מבין ארבע קבוצות השוויון שלנו, מה

39
00:02:28,800 --> 00:02:34,480
שאומר שאתה יכול לפרש את הסימון הראשון הזה כשואל, היי,

40
00:02:34,480 --> 00:02:36,680
אם יש שגיאה, האם הביט האחרון במיקום השגיאה הוא 1?

41
00:02:36,680 --> 00:02:42,600
באופן דומה, אם אתה מתמקד בחלק השני עד האחרון, ומדגיש את כל

42
00:02:42,600 --> 00:02:47,040
המיקומים שבהם זה 1, אתה מקבל את קבוצת השוויון השנייה מהתוכנית שלנו.

43
00:02:47,040 --> 00:02:51,960
במילים אחרות, הבדיקה השנייה שואלת, היי, שוב אני, אם יש

44
00:02:51,960 --> 00:02:56,160
שגיאה, האם החלק השני אחרון במיקום הזה הוא 1?

45
00:02:56,160 --> 00:02:57,160
וכולי.

46
00:02:57,160 --> 00:03:03,320
בדיקת השוויון השלישית מכסה כל עמדה שהביט השלישי עד האחרון שלה מופעל, והאחרון

47
00:03:03,320 --> 00:03:10,120
מכסה את שמונת העמדות האחרונות, אלה שהביט הסדר הגבוה ביותר שלהן הוא 1.

48
00:03:10,120 --> 00:03:15,680
כל מה שעשינו קודם לכן זהה למענה על ארבע

49
00:03:15,680 --> 00:03:18,800
השאלות הללו, וזה בתורו זהה לאיית מיקום בבינארי.

50
00:03:19,800 --> 00:03:22,080
אני מקווה שזה מבהיר שני דברים יותר.

51
00:03:22,080 --> 00:03:27,140
הראשון הוא איך להכליל באופן שיטתי לגדלי בלוקים שהם עצמות גדולות יותר של שניים.

52
00:03:27,140 --> 00:03:33,180
אם צריך יותר ביטים כדי לתאר כל מיקום, כמו שישה ביטים כדי לתאר 64

53
00:03:33,180 --> 00:03:38,640
נקודות, אז כל אחד מהסיביות האלה נותן לך אחת מקבוצות הזוגיות שעלינו לבדוק.

54
00:03:38,640 --> 00:03:42,060
אלו מכם שצפו בפאזל לוח השחמט שעשיתי עם מאט

55
00:03:42,060 --> 00:03:43,400
פארקר עשויים למצוא את כל זה מוכר מאוד.

56
00:03:43,400 --> 00:03:48,200
זה אותו היגיון הליבה, אבל פתרון בעיה אחרת,

57
00:03:48,200 --> 00:03:49,880
מיושם על לוח שחמט של 64 ריבוע.

58
00:03:49,880 --> 00:03:54,000
הדבר השני שאני מקווה שזה מבהיר הוא מדוע סיביות השוויון שלנו

59
00:03:54,000 --> 00:03:58,320
יושבות בעמדות שהן חזקות של שתיים, למשל 1, 2, 4 ו-8.

60
00:03:58,320 --> 00:04:03,640
אלו הן העמדות שהייצוג הבינארי שלהן הופעל רק ביט בודד.

61
00:04:03,640 --> 00:04:09,000
המשמעות היא שכל אחד מאותם סיביות זוגיות

62
00:04:09,000 --> 00:04:12,640
יושב בתוך אחת ויחידה מארבע קבוצות הזוגיות.

63
00:04:12,640 --> 00:04:16,840
אתה יכול לראות זאת גם בדוגמאות גדולות יותר, שבהן לא משנה כמה

64
00:04:16,840 --> 00:04:25,920
גדול אתה מקבל, כל סיביות זוגיות נוגעת בנוחות רק באחת מהקבוצות.

65
00:04:25,920 --> 00:04:29,680
ברגע שתבינו שבדיקות השוויון האלה שהתמקדנו בהן כל כך הרבה

66
00:04:29,680 --> 00:04:34,320
מזמננו הן לא יותר מאשר דרך חכמה לאיית את מיקומה

67
00:04:34,320 --> 00:04:37,880
של שגיאה בבינארי, אז נוכל ליצור קשר עם דרך אחרת

68
00:04:37,880 --> 00:04:42,160
לחשוב על האמינג. קודים, אחד שהוא ללא ספק הרבה יותר

69
00:04:42,160 --> 00:04:43,880
פשוט ואלגנטי, ושאפשר לכתוב אותו בעצם עם שורת קוד אחת.

70
00:04:43,920 --> 00:04:46,200
זה מבוסס על פונקציית XOR.

71
00:04:46,200 --> 00:04:50,960
XOR, למי מכם שלא יודע, מייצג בלעדי או.

72
00:04:50,960 --> 00:04:55,440
כאשר אתה לוקח את ה-XOR של שני סיביות, זה יחזיר 1 אם

73
00:04:55,440 --> 00:05:00,200
אחד מהסיביות האלה מופעל, אבל לא אם שניהם מופעלים או כבויים.

74
00:05:00,200 --> 00:05:03,760
בניסוח שונה, זה השוויון של שני הביטים האלה.

75
00:05:03,760 --> 00:05:07,840
כאדם מתמטיקה, אני מעדיף לחשוב על זה כעל מוד 2 של תוספת.

76
00:05:07,840 --> 00:05:12,000
אנחנו גם מדברים בדרך כלל על XOR של שתי מחרוזות

77
00:05:12,040 --> 00:05:14,040
סיביות שונות, שבעצם עושה את זה רכיב אחר רכיב.

78
00:05:14,040 --> 00:05:16,280
זה כמו תוספת, אבל איפה שאתה אף פעם לא נושא.

79
00:05:16,280 --> 00:05:21,240
שוב, בעלי נטייה מתמטית יותר עשויים להעדיף לחשוב על

80
00:05:21,240 --> 00:05:23,520
זה כעל הוספת שני וקטורים והקטנת מוד 2.

81
00:05:23,520 --> 00:05:28,720
אם אתה פותח איזה Python עכשיו ומיישם את פעולת ה-caret בין שני מספרים שלמים,

82
00:05:28,720 --> 00:05:35,400
זה מה שהוא עושה מלבד ייצוגי הסיביות של המספרים האלה מתחת למכסה המנוע.

83
00:05:35,400 --> 00:05:40,920
נקודת המפתח עבורך ולי היא שלקיחת ה-XOR של מחרוזות סיביות

84
00:05:40,960 --> 00:05:45,960
שונות היא למעשה דרך לחשב את הפרודיות של חבורה של

85
00:05:45,960 --> 00:05:51,320
קבוצות נפרדות, כמו כך עם העמודות, הכל במכה אחת.

86
00:05:51,320 --> 00:05:54,520
זה נותן לנו דרך די מטופשת לחשוב על בדיקות השוויון

87
00:05:54,520 --> 00:05:59,680
המרובות מאלגוריתם קוד Hamming שלנו, כשהם ארוזים יחד לפעולה אחת.

88
00:05:59,680 --> 00:06:02,800
למרות שבמבט ראשון זה נראה שונה מאוד.

89
00:06:02,800 --> 00:06:08,360
רשום ספציפית את 16 המיקומים בבינארי, כמו שהיה לנו בעבר,

90
00:06:08,640 --> 00:06:14,800
ועכשיו סמן את המיקומים שבהם ביט ההודעה מופעל ל-1, ואז

91
00:06:14,800 --> 00:06:19,400
אסוף את המיקומים האלה לעמודה אחת גדולה ולקחת את ה-XOR.

92
00:06:19,400 --> 00:06:23,480
אתם בוודאי יכולים לנחש ש-4 הביטים שיושבים בתחתית

93
00:06:23,480 --> 00:06:27,480
כתוצאה מכך זהים ל-4 בדיקות השוויון שלמדנו להכיר

94
00:06:27,480 --> 00:06:32,720
ואוהבים, אבל קחו רגע לחשוב באמת למה בדיוק.

95
00:06:32,720 --> 00:06:37,880
העמודה האחרונה הזו, למשל, סופרת את כל המיקומים שהחלק האחרון שלהם

96
00:06:38,400 --> 00:06:42,400
הוא 1, אבל אנחנו כבר מוגבלים רק למיקומים המודגשים, כך

97
00:06:42,400 --> 00:06:45,960
שהיא למעשה סופרת כמה עמדות מודגשות הגיעו מקבוצת השוויון הראשונה.

98
00:06:45,960 --> 00:06:48,520
האם זה הגיוני?

99
00:06:48,520 --> 00:06:53,600
כמו כן, העמודה הבאה סופרת כמה עמדות יש

100
00:06:53,600 --> 00:06:59,640
בקבוצת השוויון השנייה, המיקומים שהביט השני אחרון שלהם

101
00:06:59,640 --> 00:07:00,640
הוא 1, ואשר גם הם מודגשים, וכן הלאה.

102
00:07:00,640 --> 00:07:06,640
זה באמת רק שינוי קטן בפרספקטיבה על אותו הדבר שעשינו.

103
00:07:07,640 --> 00:07:10,000
וכך אתה יודע לאן זה הולך מכאן.

104
00:07:10,000 --> 00:07:14,400
השולח אחראי על החלפת חלק מהסיביות השוויוניות

105
00:07:14,400 --> 00:07:19,640
המיוחדות כדי לוודא שהסכום יגיע ל-0000.

106
00:07:19,640 --> 00:07:23,600
עכשיו ברגע שיש לנו את זה ככה, זה נותן לנו דרך ממש נחמדה

107
00:07:23,600 --> 00:07:28,720
לחשוב מדוע ארבעת הביטים המתקבלים האלה בתחתית מאייתים ישירות את המיקום של שגיאה.

108
00:07:28,720 --> 00:07:32,680
נניח שחלק מהגוש הזה עובר מ-0 ל-1.

109
00:07:32,720 --> 00:07:37,320
מה שזה אומר הוא שהמיקום של הביט הזה

110
00:07:37,320 --> 00:07:42,960
ייכלל כעת ב-XOR הכולל, מה שמשנה את הסכום

111
00:07:42,960 --> 00:07:44,800
מ-0 לערך זה החדש שנכלל, מיקום השגיאה.

112
00:07:44,800 --> 00:07:48,800
מעט פחות ברור, הדבר נכון אם

113
00:07:48,800 --> 00:07:49,800
יש שגיאה שמשנה 1 ל-0.

114
00:07:49,800 --> 00:07:54,720
אתה מבין, אם אתה מוסיף קצת מחרוזת יחד פעמיים, זה אותו דבר כמו

115
00:07:54,720 --> 00:07:59,000
לא להיות שם בכלל, בעיקרון כי בעולם הזה 1 ועוד 1 שווה 0.

116
00:07:59,000 --> 00:08:03,720
אז להוספת עותק של המיקום הזה לסכום הכולל

117
00:08:03,720 --> 00:08:05,400
יש את אותה השפעה כמו שאנחנו מעבירים אותו.

118
00:08:05,400 --> 00:08:10,080
והאפקט הזה, שוב, הוא שהתוצאה הכוללת

119
00:08:10,080 --> 00:08:13,480
בתחתית כאן מפרטת את מיקום השגיאה.

120
00:08:13,480 --> 00:08:17,720
כדי להמחיש עד כמה זה אלגנטי, הרשו לי להראות את השורה האחת של

121
00:08:17,720 --> 00:08:22,120
קוד Python שהתייחסתי אליה קודם, שתלכוד כמעט את כל ההיגיון בקצה המקלט.

122
00:08:22,120 --> 00:08:27,160
נתחיל ביצירת מערך אקראי של 16 1 ו-0 כדי לדמות את

123
00:08:27,160 --> 00:08:31,160
בלוק הנתונים, ואני אתן לו את סיביות השם, אבל כמובן

124
00:08:31,160 --> 00:08:36,160
שבפועל זה יהיה משהו שאנחנו מקבלים מהשולח, ובמקום בהיותו אקראי

125
00:08:36,160 --> 00:08:38,600
הוא יוביל 11 סיביות נתונים יחד עם 5 סיביות זוגיות.

126
00:08:38,600 --> 00:08:43,160
אם אני קורא לפונקציה enumerateBits, מה שהיא עושה זה לצמד כל

127
00:08:43,160 --> 00:08:48,240
אחד מהסיביות האלה עם אינדקס מתאים, במקרה הזה מ-0 עד 15.

128
00:08:48,240 --> 00:08:53,200
אז אם אנחנו יוצרים רשימה שמסתובבת בלולאה על כל הזוגות האלה, זוגות שנראים כמו

129
00:08:53,200 --> 00:08:59,160
i, ואז נוציא רק את ערך i, רק את המדד, ובכן, זה לא כל

130
00:08:59,160 --> 00:09:01,920
כך מרגש, אנחנו פשוט מקבלים בחזרה את המדדים האלה 0 עד 15 .

131
00:09:01,920 --> 00:09:07,520
אבל אם נוסיף את התנאי לעשות את זה רק אם ביט, כלומר אם הביט הזה

132
00:09:07,520 --> 00:09:13,400
הוא 1 ולא 0, ובכן, אז הוא שולף רק את המיקומים שבהם הביט המקביל מופעל.

133
00:09:13,400 --> 00:09:20,320
במקרה זה נראה שהמיקומים האלה הם 0, 4, 6, 9 וכו&#39;.

134
00:09:20,720 --> 00:09:24,640
מה שאנחנו רוצים זה לאסוף את כל המיקומים האלה,

135
00:09:24,640 --> 00:09:29,960
את המיקומים של הביטים המופעלים, ואז XOR אותם יחד.

136
00:09:29,960 --> 00:09:33,960
כדי לעשות זאת ב- Python, תחילה תן לי לייבא כמה פונקציות מועילות.

137
00:09:33,960 --> 00:09:39,140
כך נוכל לקרוא ל-reduce() ברשימה זו, ולהשתמש בפונקציה XOR כדי להקטין אותה.

138
00:09:39,140 --> 00:09:44,840
זה בעצם אוכל את הדרך ברשימה, ולוקח XORs לאורך הדרך.

139
00:09:44,840 --> 00:09:48,760
אם אתה מעדיף, אתה יכול לכתוב במפורש את

140
00:09:48,800 --> 00:09:52,200
פונקציית XOR מבלי לייבא אותה מכל מקום.

141
00:09:52,200 --> 00:09:56,880
אז כרגע נראה שאם נעשה זאת על הבלוק האקראי שלנו של

142
00:09:56,880 --> 00:10:02,080
16 סיביות, זה מחזיר 9, שיש לו את הייצוג הבינארי 1001.

143
00:10:02,080 --> 00:10:05,960
לא נעשה את זה כאן, אבל אתה יכול לכתוב פונקציה שבה השולח משתמש בייצוג הבינארי

144
00:10:05,960 --> 00:10:11,560
הזה כדי להגדיר את ארבעת סיביות הזוגיות לפי הצורך, ובסופו של דבר להביא את

145
00:10:11,560 --> 00:10:16,200
הבלוק הזה למצב שבו הפעלת שורת קוד זו ברשימת הביטים המלאה מחזירה א 0.

146
00:10:17,200 --> 00:10:20,200
זה ייחשב לבלוק מוכן היטב.

147
00:10:20,200 --> 00:10:24,640
מה שמגניב הוא שאם נחליף כל אחד מהסיביות ברשימה הזו, המדמה שגיאה אקראית מרעש,

148
00:10:24,640 --> 00:10:30,600
אז אם אתה מפעיל את אותה שורת קוד, הוא מדפיס את השגיאה הזו.

149
00:10:30,600 --> 00:10:31,920
זה לא מסודר?

150
00:10:31,920 --> 00:10:37,200
אתה יכול לקבל את הבלוק הזה ישר, להריץ עליו את השורה הבודדת הזו,

151
00:10:37,200 --> 00:10:42,920
והוא ינוק אוטומטית את המיקום של שגיאה, או 0 אם לא הייתה כזו.

152
00:10:42,920 --> 00:10:45,520
ואין כאן שום דבר מיוחד במידה 16.

153
00:10:45,520 --> 00:10:52,280
אותה שורת קוד תעבוד אם הייתה לך רשימה של, נניח, 256 סיביות.

154
00:10:52,280 --> 00:10:56,280
מיותר לציין שיש עוד קוד לכתוב כאן, כמו ביצוע בדיקת מטא

155
00:10:56,280 --> 00:11:01,440
זוגיות כדי לזהות שגיאות של 2 סיביות, אבל הרעיון הוא

156
00:11:01,440 --> 00:11:05,080
שכמעט כל הלוגיקה הליבה מהסכמה שלנו מסתכמת בהפחתת XOR אחת.

157
00:11:05,080 --> 00:11:10,600
כעת, בהתאם לנוחות שלך עם רכיבי בינארי ו-XOR ותוכנה באופן כללי,

158
00:11:10,600 --> 00:11:15,880
ייתכן שתמצא את הפרספקטיבה הזו קצת מבלבלת, או הרבה יותר

159
00:11:15,880 --> 00:11:19,320
אלגנטי ופשוט שאתה תוהה למה לא התחלנו איתה מההתחלה -ללכת.

160
00:11:19,320 --> 00:11:22,880
באופן רופף, קל יותר לחשוב על פרספקטיבה של בדיקת זוגיות מרובה בעת

161
00:11:22,880 --> 00:11:27,560
יישום קודי Hamming בחומרה באופן ישיר מאוד, ואת פרספקטיבה של XOR

162
00:11:27,560 --> 00:11:31,380
קל יותר לחשוב עליה כאשר עושים זאת בתוכנה, מרמה גבוהה יותר.

163
00:11:31,380 --> 00:11:35,640
את הראשון הכי קל לעשות ביד, ולדעתי הוא עושה עבודה טובה יותר

164
00:11:35,640 --> 00:11:40,720
בהחדרת האינטואיציה הליבה העומדת בבסיס כל זה, והיא שהמידע הנדרש לאיתור

165
00:11:40,720 --> 00:11:46,840
שגיאה בודדת קשור ללוג של גודל הבלוק , או במילים אחרות,

166
00:11:46,840 --> 00:11:51,020
הוא גדל טיפה בכל פעם ככל שגודל הבלוק מכפיל את עצמו.

167
00:11:51,020 --> 00:11:55,440
העובדה הרלוונטית כאן היא שהמידע הזה

168
00:11:55,440 --> 00:11:56,440
מתאים ישירות לכמות היתירות שאנחנו צריכים.

169
00:11:56,440 --> 00:12:00,320
זה באמת מה שנוגד את התגובה המופרכת של רוב האנשים כשהם

170
00:12:00,320 --> 00:12:05,280
חושבים לראשונה על הפיכת הודעה לעמידה בפני שגיאות, כאשר בדרך

171
00:12:05,280 --> 00:12:07,520
כלל העתקה של כל ההודעה היא האינסטינקט הראשון שעולה בראש.

172
00:12:07,520 --> 00:12:11,120
ואז, אגב, יש את כל הדרך האחרת הזו שלפעמים רואים את

173
00:12:11,120 --> 00:12:14,800
קודי האמינג מוצגים, שבה אתה מכפיל את המסר במטריצה אחת גדולה.

174
00:12:14,800 --> 00:12:18,580
זה די נחמד כי זה מקשר את זה למשפחה הרחבה יותר של קודים ליניאריים, אבל

175
00:12:18,580 --> 00:12:25,160
אני חושב שזה כמעט לא נותן אינטואיציה מאיפה זה מגיע או איך זה מתרחב.

176
00:12:25,160 --> 00:12:29,340
ואם כבר מדברים על קנה מידה, אולי תשים לב שהיעילות של

177
00:12:29,340 --> 00:12:32,200
תכנית זו רק משתפרת ככל שאנו מגדילים את גודל הבלוק.

178
00:12:32,200 --> 00:12:40,560
לדוגמה, ראינו שעם 256 סיביות, אתה משתמש רק ב-3%

179
00:12:40,560 --> 00:12:43,480
מהשטח הזה עבור יתירות, ומשם זה רק הולך ומשתפר.

180
00:12:43,480 --> 00:12:49,040
ככל שמספר סיביות הזוגיות גדל בזה אחר זה, גודל הבלוק ממשיך להכפיל את עצמו.

181
00:12:49,040 --> 00:12:53,840
ואם אתה לוקח את זה לקיצוניות, אתה יכול לקבל בלוק

182
00:12:53,840 --> 00:12:58,800
עם, נגיד, מיליון ביטים, שבו אתה ממש משחק 20 שאלות

183
00:12:58,800 --> 00:13:00,800
עם בדיקות השוויון שלך, והוא משתמש רק ב-21 ביטים זוגיות.

184
00:13:00,800 --> 00:13:05,760
ואם אתה חוזר אחורה כדי לחשוב על להסתכל על

185
00:13:05,760 --> 00:13:08,640
מיליון ביטים ולאתר שגיאה בודדת, זה באמת מרגיש מטורף.

186
00:13:08,640 --> 00:13:12,680
הבעיה, כמובן, היא שעם בלוק גדול יותר, ההסתברות לראות יותר משגיאת סיביות

187
00:13:12,680 --> 00:13:18,360
אחת או שתיים עולה, וקודי Hamming לא מטפלים בשום דבר מעבר לזה.

188
00:13:18,360 --> 00:13:22,020
אז בפועל, מה שתרצו זה למצוא את הגודל הנכון כך

189
00:13:22,020 --> 00:13:25,520
שההסתברות של יותר מדי ביט לא תהיה גבוהה מדי.

190
00:13:26,520 --> 00:13:30,920
כמו כן, בפועל, שגיאות נוטות להגיע בהתפרצויות קטנות, מה שיהרוס לחלוטין בלוק בודד,

191
00:13:30,920 --> 00:13:35,680
אז טקטיקה נפוצה אחת כדי לעזור להפיץ פרץ של שגיאות על פני בלוקים

192
00:13:35,680 --> 00:13:41,720
רבים ושונים היא לשלב את הבלוקים האלה, ככה, לפני שהם נשלח או נשמר.

193
00:13:45,480 --> 00:13:49,920
אז שוב, הרבה מזה הופך ללא ספק על ידי קודים מודרניים יותר, כמו

194
00:13:49,920 --> 00:13:55,060
אלגוריתם ריד-סולומון הנפוץ הרבה יותר, המטפל בשגיאות פרץ בצורה טובה במיוחד, וניתן לכוון

195
00:13:55,100 --> 00:13:59,580
אותו כך שיהיה עמיד למספר גדול יותר של שגיאות בכל בלוק .

196
00:13:59,580 --> 00:14:03,000
אבל זה נושא לפעם אחרת.

197
00:14:03,000 --> 00:14:07,660
בספרו The Art of Doing Science and Engineering, האמינג הוא

198
00:14:07,660 --> 00:14:10,700
כנה להפליא לגבי מידת הפיתול של גילוי הקוד הזה.

199
00:14:10,700 --> 00:14:15,180
תחילה הוא ניסה כל מיני תוכניות שונות שכללו ארגון הסיביות

200
00:14:15,180 --> 00:14:18,420
לחלקים של סריג ממדי גבוה יותר ודברים מוזרים כמו זה.

201
00:14:18,420 --> 00:14:22,520
הרעיון שאולי אפשר לקבל בדיקות זוגיות כדי ליצור קשר

202
00:14:22,520 --> 00:14:26,360
בצורה שתפרט את המיקום של שגיאה, הגיע להאמינג

203
00:14:26,360 --> 00:14:30,800
רק כשהוא נסוג לאחר שלל ניתוחים אחרים ושאל, בסדר,

204
00:14:30,800 --> 00:14:32,860
מה הכי יעיל שיכולתי. אפשר לחשוב על זה?

205
00:14:32,860 --> 00:14:36,760
הוא גם היה כנה לגבי כמה חשוב שבדיקות זוגיות כבר היו

206
00:14:36,760 --> 00:14:42,040
בראש שלו, מה שהיה הרבה פחות נפוץ בשנות הארבעים מאשר היום.

207
00:14:42,040 --> 00:14:46,040
יש כמו חצי תריסר פעמים במהלך הספר הזה שהוא

208
00:14:46,040 --> 00:14:49,640
מתייחס לציטוט של לואי פסטר, המזל מעדיף מוח מוכן.

209
00:14:49,640 --> 00:14:55,120
רעיונות חכמים נראים לעתים קרובות פשוטים בצורה מטעה במבט לאחור, מה שמקל על הערכה נמוכה יותר.

210
00:14:55,120 --> 00:14:59,680
כרגע תקוותי הכנה היא שקודי האמינג, או לפחות

211
00:14:59,680 --> 00:15:01,820
האפשרות של קודים כאלה, מרגישים לך כמעט ברורים.

212
00:15:01,820 --> 00:15:05,440
אבל אתה לא צריך להטעות את עצמך לחשוב

213
00:15:05,440 --> 00:15:08,000
שהם בעצם ברורים, כי הם בהחלט לא.

214
00:15:08,000 --> 00:15:12,080
חלק מהסיבה שרעיונות חכמים נראים קלים בצורה מטעה היא שאנחנו רואים

215
00:15:12,080 --> 00:15:17,360
רק את התוצאה הסופית, מנקים את מה שהיה מבולגן, אף פעם

216
00:15:17,360 --> 00:15:22,400
לא מזכירים את כל הפניות הלא נכונות, ומדגישים עד כמה עצום

217
00:15:22,400 --> 00:15:23,980
המרחב של האפשרויות הניתנות לחקירה בתחילת בעיה תהליך פתרון, כל זה.

218
00:15:23,980 --> 00:15:25,280
אבל זה נכון באופן כללי.

219
00:15:25,280 --> 00:15:29,880
אני חושב שלכמה המצאות מיוחדות, יש סיבה שנייה,

220
00:15:29,880 --> 00:15:31,040
עמוקה יותר לכך שאנחנו פחות מעריכים אותן.

221
00:15:31,040 --> 00:15:35,040
חשיבה על מידע במונחים של ביטים התלכדה לתיאוריה מלאה רק

222
00:15:35,040 --> 00:15:39,400
ב-1948, עם המאמר המכונן של קלוד שאנון על תורת המידע.

223
00:15:39,400 --> 00:15:43,400
זה היה בעצם במקביל לזמן שבו האמינג פיתח את האלגוריתם שלו.

224
00:15:43,440 --> 00:15:47,300
זה היה אותו מאמר יסוד שהראה, במובן מסוים,

225
00:15:47,300 --> 00:15:52,080
שתיקון שגיאות יעיל תמיד אפשרי, לא משנה

226
00:15:52,080 --> 00:15:53,920
כמה גבוהה ההסתברות להיפוך סיביות, לפחות בתיאוריה.

227
00:15:53,920 --> 00:15:58,120
שאנון והאמינג, אגב, חלקו משרד ב-Bell Labs, למרות שעבדו על

228
00:15:58,120 --> 00:16:02,400
דברים שונים מאוד, מה שכמעט ולא נראה מקרי כאן.

229
00:16:02,400 --> 00:16:06,960
הרץ קדימה כמה עשורים, ובימים אלה, רבים מאיתנו שקועים כל כך בחשיבה

230
00:16:06,960 --> 00:16:13,080
על פיסות ומידע שקל להתעלם עד כמה הייתה צורת החשיבה הזו מובחנת.

231
00:16:13,080 --> 00:16:17,920
למרבה האירוניה, הרעיונות שמעצבים בצורה העמוקה ביותר את הדרכים שדור העתיד חושב יסתכלו

232
00:16:17,920 --> 00:16:22,640
בסופו של דבר על אותו דור העתיד פשוטות יותר ממה שהם באמת.

