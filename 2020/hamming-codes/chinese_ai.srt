1
00:00:00,000 --> 00:00:03,120
我假设这里的每个人都来自第 1 部分。

2
00:00:03,120 --> 00:00:06,920
我们讨论的是汉明码，这是一种创建数据块的方法，其中大多数位携带有意义的消息，而其他一些位则充当一种冗余，这样如果任何位被翻转，要么是一条消息位或冗余位，该块中的任何内容，接收器将能够识别出存在错误，以及如何修复它。

3
00:00:06,920 --> 00:00:11,640


4
00:00:11,640 --> 00:00:15,800


5
00:00:15,800 --> 00:00:20,560


6
00:00:20,560 --> 00:00:21,920


7
00:00:21,920 --> 00:00:25,900
那里提出的基本思想是如何使用多个奇偶校验来进行二进制搜索以找出错误。

8
00:00:25,900 --> 00:00:29,800


9
00:00:29,800 --> 00:00:33,920
在该视频中，我们的目标是让汉明码尽可能具有动手操作和可重新发现的感觉。

10
00:00:33,920 --> 00:00:35,420


11
00:00:35,420 --> 00:00:40,040
但是，当您开始考虑在软件或硬件中实际实现这一点时，该框架实际上可能低估了这些代码的真正优雅程度。

12
00:00:40,040 --> 00:00:44,120


13
00:00:44,120 --> 00:00:47,620
您可能认为您需要编写一个算法来跟踪所有可能的错误位置，并在每次检查时将该组切成两半，但实际上比这简单得多。

14
00:00:47,620 --> 00:00:52,320


15
00:00:52,320 --> 00:00:54,160


16
00:00:54,160 --> 00:00:58,720
如果你读出我们在上一个视频中所做的四次奇偶校验的答案，全部都是 1

17
00:00:58,760 --> 00:01:04,800
和 0，而不是是和否，它实际上以二进制形式说明了错误的位置。

18
00:01:04,800 --> 00:01:10,160
例如，二进制中的数字 7 看起来像 0111，本质上是说它是 4

19
00:01:10,160 --> 00:01:12,640
加 2 加 1。

20
00:01:12,640 --> 00:01:17,960
请注意位置 7

21
00:01:17,960 --> 00:01:22,280
所在的位置，它确实影响我们的第一个奇偶组，以及第二个和第三个，但不影响最后一个。

22
00:01:22,280 --> 00:01:26,560
因此，从下到上读取这四次检查的结果确实可以阐明错误的位置。

23
00:01:26,560 --> 00:01:28,000


24
00:01:28,520 --> 00:01:32,240
示例 7

25
00:01:32,240 --> 00:01:37,440
没有什么特别的，这在一般情况下是有效的，这使得在硬件中实现整个方案的逻辑非常简单。

26
00:01:37,440 --> 00:01:43,380
现在，如果您想了解为什么会发生这种神奇的情况，请将这 16 个索引标签作为我们的位置，但不要将它们写入基数

27
00:01:43,380 --> 00:01:48,480
10，而是将它们全部写入二进制，从 0000

28
00:01:48,480 --> 00:01:50,720
到 1111。

29
00:01:50,720 --> 00:01:55,880
当我们将这些二进制标签放回它们的盒子时，让我强调它们与实际发送的数据不同。

30
00:01:56,080 --> 00:01:58,440


31
00:01:58,440 --> 00:02:02,200
它们只不过是一个概念标签，可以帮助你我理解四个奇偶组的来源。

32
00:02:02,200 --> 00:02:04,200


33
00:02:04,200 --> 00:02:08,840
用二进制描述我们所看到的一切的优雅可能会因为我们所看到的一切都以二进制描述的混乱而被削弱。

34
00:02:08,840 --> 00:02:13,160


35
00:02:13,160 --> 00:02:15,040
不过，这是值得的。

36
00:02:15,040 --> 00:02:20,740
将您的注意力集中在所有这些标签的最后一位上，然后突出显示最后一位为 1

37
00:02:20,740 --> 00:02:24,280
的位置。

38
00:02:24,280 --> 00:02:28,800
我们得到的是四个奇偶校验组中的第一个，这意味着您可以将第一个检查解释为询问，嘿，如果有错误，该错误位置的最后一位是否为

39
00:02:28,800 --> 00:02:34,480
1？

40
00:02:34,480 --> 00:02:36,680


41
00:02:36,680 --> 00:02:42,600
同样，如果您关注倒数第二位，并突出显示所有为 1

42
00:02:42,600 --> 00:02:47,040
的位置，您就会从我们的方案中获得第二个奇偶校验组。

43
00:02:47,040 --> 00:02:51,960
换句话说，第二次检查会问，嘿，我再说一遍，如果有错误，该位置的倒数第二位是 1

44
00:02:51,960 --> 00:02:56,160
吗？

45
00:02:56,160 --> 00:02:57,160
等等。

46
00:02:57,160 --> 00:03:03,320
第三个奇偶校验涵盖倒数第三位打开的每个位置，最后一个奇偶校验涵盖最后八个位置，即最高位为 1

47
00:03:03,320 --> 00:03:10,120
的位置。

48
00:03:10,120 --> 00:03:15,680
我们之前所做的一切都与回答这四个问题相同，而这又与以二进制拼出一个位置相同。

49
00:03:15,680 --> 00:03:18,800


50
00:03:19,800 --> 00:03:22,080
我希望这能让两件事变得更清楚。

51
00:03:22,080 --> 00:03:27,140
第一个是如何系统地推广到大于 2 的幂的块大小。

52
00:03:27,140 --> 00:03:33,180
如果需要更多位来描述每个位置，例如用 6 位来描述

53
00:03:33,180 --> 00:03:38,640
64 个点，那么这些位中的每一位都会为您提供我们需要检查的奇偶校验组之一。

54
00:03:38,640 --> 00:03:42,060
那些看过我和马特·帕克一起做的棋盘拼图的人可能会发现这一切非常熟悉。

55
00:03:42,060 --> 00:03:43,400


56
00:03:43,400 --> 00:03:48,200
它是相同的核心逻辑，但解决不同的问题，并应用于 64

57
00:03:48,200 --> 00:03:49,880
方格的棋盘。

58
00:03:49,880 --> 00:03:54,000
我希望这能澄清的第二件事是为什么我们的奇偶校验位位于 2 的幂的位置，例如

59
00:03:54,000 --> 00:03:58,320
1、2、4 和 8。

60
00:03:58,320 --> 00:04:03,640
这些位置的二进制表示仅打开了一位。

61
00:04:03,640 --> 00:04:09,000
这意味着这些奇偶校验位中的每一个都位于四个奇偶校验组中的一个且仅一个内。

62
00:04:09,000 --> 00:04:12,640


63
00:04:12,640 --> 00:04:16,840
您还可以在更大的示例中看到这一点，无论您有多大，每个奇偶校验位都只方便地触及其中一个组。

64
00:04:16,840 --> 00:04:25,920


65
00:04:25,920 --> 00:04:29,680
一旦您明白我们花费大量时间关注的这些奇偶校验只不过是一种巧妙的方式来阐明二进制错误的位置，那么我们就可以用不同的方式来思考汉明代码，可以说更简单、更优雅，基本上可以用一行代码写下来。

66
00:04:29,680 --> 00:04:34,320


67
00:04:34,320 --> 00:04:37,880


68
00:04:37,880 --> 00:04:42,160


69
00:04:42,160 --> 00:04:43,880


70
00:04:43,920 --> 00:04:46,200
它基于 XOR 函数。

71
00:04:46,200 --> 00:04:50,960
XOR，对于那些不知道的人来说，代表异或。

72
00:04:50,960 --> 00:04:55,440
当您对两位进行异或时，如果其中一位打开，它将返回 1，但如果两者都打开或关闭，则不会返回

73
00:04:55,440 --> 00:05:00,200
1。

74
00:05:00,200 --> 00:05:03,760
换句话说，它是这两个位的奇偶校验。

75
00:05:03,760 --> 00:05:07,840
作为一个数学家，我更喜欢将其视为加法 mod 2。

76
00:05:07,840 --> 00:05:12,000
我们还经常谈论两个不同位串的异或，它基本上是逐个组件地执行此操作。

77
00:05:12,040 --> 00:05:14,040


78
00:05:14,040 --> 00:05:16,280
这就像加法，但你永远不会携带。

79
00:05:16,280 --> 00:05:21,240
同样，更倾向于数学的人可能更愿意将其视为添加两个向量并减少 mod

80
00:05:21,240 --> 00:05:23,520
2。

81
00:05:23,520 --> 00:05:28,720
如果你现在打开一些Python并在两个整数之间应用插入符号操作，这就是它正在做的事情，但只是在幕后处理这些数字的位表示。

82
00:05:28,720 --> 00:05:35,400


83
00:05:35,400 --> 00:05:40,920
对你和我来说，关键点在于，对许多不同的位串进行异或运算实际上是一种计算一堆单独组的模仿的方法，就像列一样，一举完成。

84
00:05:40,960 --> 00:05:45,960


85
00:05:45,960 --> 00:05:51,320


86
00:05:51,320 --> 00:05:54,520
这为我们提供了一种相当时髦的方式来思考汉明码算法中的多个奇偶校验，因为所有这些都被打包到一个操作中。

87
00:05:54,520 --> 00:05:59,680


88
00:05:59,680 --> 00:06:02,800
虽然乍一看确实很不一样。

89
00:06:02,800 --> 00:06:08,360
像我们之前那样，专门写下二进制的 16

90
00:06:08,640 --> 00:06:14,800
个位置，现在突出显示消息位变为 1

91
00:06:14,800 --> 00:06:19,400
的位置，然后将这些位置收集到一大列中并进行异或。

92
00:06:19,400 --> 00:06:23,480
您可能会猜到，结果位于底部的 4

93
00:06:23,480 --> 00:06:27,480
位与我们所了解和喜爱的 4

94
00:06:27,480 --> 00:06:32,720
个奇偶校验相同，但请花点时间思考一下到底是为什么。

95
00:06:32,720 --> 00:06:37,880
例如，最后一列正在计算最后一位为

96
00:06:38,400 --> 00:06:42,400
1

97
00:06:42,400 --> 00:06:45,960
的所有位置，但我们已经仅限于突出显示的位置，因此它有效地计算有多少突出显示的位置来自第一个奇偶校验组。

98
00:06:45,960 --> 00:06:48,520
那有意义吗？

99
00:06:48,520 --> 00:06:53,600
同样，下一列计算第二个奇偶校验组中有多少个位置、倒数第二个位为

100
00:06:53,600 --> 00:06:59,640
1

101
00:06:59,640 --> 00:07:00,640
的位置以及也突出显示的位置，依此类推。

102
00:07:00,640 --> 00:07:06,640
这实际上只是对我们一直在做的同一件事的看法的一个小小的转变。

103
00:07:07,640 --> 00:07:10,000
所以你知道它从这里走向何方。

104
00:07:10,000 --> 00:07:14,400
发送方负责切换一些特殊奇偶校验位，以确保总和为

105
00:07:14,400 --> 00:07:19,640
0000。

106
00:07:19,640 --> 00:07:23,600
现在，一旦我们有了这样的结果，这给了我们一个非常好的方法来思考为什么底部的这四个结果位直接拼出错误的位置。

107
00:07:23,600 --> 00:07:28,720


108
00:07:28,720 --> 00:07:32,680
假设此块中的某些位从 0 切换到 1。

109
00:07:32,720 --> 00:07:37,320
这意味着该位的位置现在将包含在总 XOR

110
00:07:37,320 --> 00:07:42,960
中，这会将总和从 0

111
00:07:42,960 --> 00:07:44,800
更改为这个新包含的值，即错误的位置。

112
00:07:44,800 --> 00:07:48,800
不太明显的是，如果出现将 1 更改为

113
00:07:48,800 --> 00:07:49,800
0 的错误，情况也是如此。

114
00:07:49,800 --> 00:07:54,720
你看，如果你将一个位串加在一起两次，那就和根本没有它一样，基本上是因为在这个世界上 1 加

115
00:07:54,720 --> 00:07:59,000
1 等于 0。

116
00:07:59,000 --> 00:08:03,720
因此，将此位置的副本添加到总和中与我们移动它具有相同的效果。

117
00:08:03,720 --> 00:08:05,400


118
00:08:05,400 --> 00:08:10,080
同样，这种效果是底部的总结果阐明了错误的位置。

119
00:08:10,080 --> 00:08:13,480


120
00:08:13,480 --> 00:08:17,720
为了说明这是多么优雅，让我展示我之前引用的一行 Python

121
00:08:17,720 --> 00:08:22,120
代码，它将捕获接收器端的几乎所有逻辑。

122
00:08:22,120 --> 00:08:27,160
我们将首先创建一个由 16 个

123
00:08:27,160 --> 00:08:31,160
1 和 0

124
00:08:31,160 --> 00:08:36,160
组成的随机数组来模拟数据块，我将给它命名位，但当然，在实践中，这将是我们从发送方接收的内容，而不是如果是随机的，它将携带 11 个数据位和

125
00:08:36,160 --> 00:08:38,600
5 个奇偶校验位。

126
00:08:38,600 --> 00:08:43,160
如果我调用函数 enumerateBits，它的作用是将每个位与相应的索引配对在一起，在本例中为从 0

127
00:08:43,160 --> 00:08:48,240
到 15。

128
00:08:48,240 --> 00:08:53,200
因此，如果我们创建一个列表，循环遍历所有这些对，看起来像 i 的对，然后我们只取出

129
00:08:53,200 --> 00:08:59,160
i 值，只取出索引，好吧，这并不是那么令人兴奋，我们只是取回那些索引 0

130
00:08:59,160 --> 00:09:01,920
到 15 。

131
00:09:01,920 --> 00:09:07,520
但是，如果我们添加条件以仅执行此 if 位，即如果该位是

132
00:09:07,520 --> 00:09:13,400
1 而不是 0，那么它只会提取相应位打开的位置。

133
00:09:13,400 --> 00:09:20,320
在本例中，这些位置看起来是 0、4、6、9 等。

134
00:09:20,720 --> 00:09:24,640
我们想要的是将所有这些位置（打开的位的位置）收集在一起，然后将它们异或在一起。

135
00:09:24,640 --> 00:09:29,960


136
00:09:29,960 --> 00:09:33,960
为了在 Python 中执行此操作，让我首先导入几个有用的函数。

137
00:09:33,960 --> 00:09:39,140
这样我们就可以在这个列表上调用reduce()，并使用XOR函数来减少它。

138
00:09:39,140 --> 00:09:44,840
这基本上会遍历列表，并一路进行异或运算。

139
00:09:44,840 --> 00:09:48,760
如果您愿意，您可以显式写出该 XOR

140
00:09:48,800 --> 00:09:52,200
函数，而无需从任何地方导入它。

141
00:09:52,200 --> 00:09:56,880
所以目前看来，如果我们对 16 位随机块执行此操作，它会返回

142
00:09:56,880 --> 00:10:02,080
9，其二进制表示为 1001。

143
00:10:02,080 --> 00:10:05,960
我们不会在这里这样做，但您可以编写一个函数，其中发送方使用该二进制表示形式根据需要设置四个奇偶校验位，最终使该块达到在完整位列表上运行这行代码的状态一个

144
00:10:05,960 --> 00:10:11,560
0。

145
00:10:11,560 --> 00:10:16,200


146
00:10:17,200 --> 00:10:20,200
这将被认为是一个准备充分的区块。

147
00:10:20,200 --> 00:10:24,640
很酷的是，如果我们切换此列表中的任何一位，模拟噪声引起的随机错误，那么如果您运行同一行代码，它就会打印出该错误。

148
00:10:24,640 --> 00:10:30,600


149
00:10:30,600 --> 00:10:31,920
这不是很整洁吗？

150
00:10:31,920 --> 00:10:37,200
你可以突然得到这个块，在上面运行这一行，它会自动吐出错误的位置，如果没有错误则吐出

151
00:10:37,200 --> 00:10:42,920
0。

152
00:10:42,920 --> 00:10:45,520
16号没有什么特别的。

153
00:10:45,520 --> 00:10:52,280
如果您有一个 256 位的列表，那么同一行代码也可以工作。

154
00:10:52,280 --> 00:10:56,280
不用说，这里需要编写更多代码，例如进行元奇偶校验来检测 2

155
00:10:56,280 --> 00:11:01,440
位错误，但我们的想法是，我们方案中的几乎所有核心逻辑都归结为单个 XOR

156
00:11:01,440 --> 00:11:05,080
减少。

157
00:11:05,080 --> 00:11:10,600
现在，根据您对二进制、异或和软件的熟悉程度，您可能会发现这种观点有点令人困惑，或者更加优雅和简单，以至于您想知道为什么我们不从一开始就开始使用它-去。

158
00:11:10,600 --> 00:11:15,880


159
00:11:15,880 --> 00:11:19,320


160
00:11:19,320 --> 00:11:22,880
宽松地说，当非常直接地在硬件中实现汉明码时，更容易考虑多重奇偶校验的观点，而当在软件中从更高的层次上实现汉明码时，最容易考虑异或的观点。

161
00:11:22,880 --> 00:11:27,560


162
00:11:27,560 --> 00:11:31,380


163
00:11:31,380 --> 00:11:35,640
第一个实际上最容易手动完成，我认为它可以更好地灌输所有这一切背后的核心直觉，即定位单个错误所需的信息与块大小的日志相关，或者换句话说，随着块大小加倍，它一次增长一位。

164
00:11:35,640 --> 00:11:40,720


165
00:11:40,720 --> 00:11:46,840


166
00:11:46,840 --> 00:11:51,020


167
00:11:51,020 --> 00:11:55,440
这里的相关事实是，该信息直接对应于我们需要多少冗余。

168
00:11:55,440 --> 00:11:56,440


169
00:11:56,440 --> 00:12:00,320
这确实与大多数人在第一次考虑使消息能够抵御错误时的下意识反应相悖，通常复制整个消息是想到的第一个本能。

170
00:12:00,320 --> 00:12:05,280


171
00:12:05,280 --> 00:12:07,520


172
00:12:07,520 --> 00:12:11,120
然后，顺便说一句，有时您会看到汉明码的另一种呈现方式，即您将消息乘以一个大矩阵。

173
00:12:11,120 --> 00:12:14,800


174
00:12:14,800 --> 00:12:18,580
这很好，因为它将它与更广泛的线性代码家族联系起来，但我认为这几乎没有给出它来自何处或如何扩展的直觉。

175
00:12:18,580 --> 00:12:25,160


176
00:12:25,160 --> 00:12:29,340
说到扩展，您可能会注意到，当我们增加块大小时，该方案的效率只会变得更好。

177
00:12:29,340 --> 00:12:32,200


178
00:12:32,200 --> 00:12:40,560
例如，我们看到，对于 256 位，您仅使用该空间的

179
00:12:40,560 --> 00:12:43,480
3% 进行冗余，并且从那里开始变得越来越好。

180
00:12:43,480 --> 00:12:49,040
随着奇偶校验位的数量逐个增加，块大小不断加倍。

181
00:12:49,040 --> 00:12:53,840
如果你把它发挥到极致，你可能会拥有一个具有 100 万位的块，实际上你会用奇偶校验来回答

182
00:12:53,840 --> 00:12:58,800
20 个问题，而它只使用

183
00:12:58,800 --> 00:13:00,800
21 个奇偶校验位。

184
00:13:00,800 --> 00:13:05,760
如果你退后一步考虑查看一百万位并找到一个错误，那真的感觉很疯狂。

185
00:13:05,760 --> 00:13:08,640


186
00:13:08,640 --> 00:13:12,680
当然，问题在于，对于较大的块，看到超过一或两个位错误的概率会上升，而汉明码无法处理超出此范围的任何内容。

187
00:13:12,680 --> 00:13:18,360


188
00:13:18,360 --> 00:13:22,020
因此，在实践中，您需要找到正确的大小，以便太多位翻转的概率不会太高。

189
00:13:22,020 --> 00:13:25,520


190
00:13:26,520 --> 00:13:30,920
此外，在实践中，错误往往会突然出现，这会完全破坏单个块，因此帮助将错误突发分散到许多不同块的一种常见策略是在这些块被破坏之前将这些块交错，就像这样。发出或存储。

191
00:13:30,920 --> 00:13:35,680


192
00:13:35,680 --> 00:13:41,720


193
00:13:45,480 --> 00:13:49,920
话又说回来，其中很多内容在更现代的代码中完全没有意义，比如更常用的里德-所罗门算法，它可以很好地处理突发错误，并且可以对其进行调整以适应每个块的更多错误。

194
00:13:49,920 --> 00:13:55,060


195
00:13:55,100 --> 00:13:59,580


196
00:13:59,580 --> 00:14:03,000
但这是另一个话题了。

197
00:14:03,000 --> 00:14:07,660
汉明在他的《科学与工程的艺术》一书中非常坦诚地讲述了他发现这段代码的过程是多么曲折。

198
00:14:07,660 --> 00:14:10,700


199
00:14:10,700 --> 00:14:15,180
他首先尝试了各种不同的方案，包括将这些位组织成更高维晶格的部分以及诸如此类的奇怪事物。

200
00:14:15,180 --> 00:14:18,420


201
00:14:18,420 --> 00:14:22,520
汉明在进行了一系列其他分析后退后一步，问道：“好吧，我能做到的最有效的方法是什么”时，他才想到了通过奇偶校验来共谋以阐明错误位置的想法。可能是关于这个的？

202
00:14:22,520 --> 00:14:26,360


203
00:14:26,360 --> 00:14:30,800


204
00:14:30,800 --> 00:14:32,860


205
00:14:32,860 --> 00:14:36,760
他还坦诚地表示，奇偶校验已经在他的脑海中发挥了重要作用，而在 20 世纪

206
00:14:36,760 --> 00:14:42,040
40 年代，奇偶校验比今天要少得多。

207
00:14:42,040 --> 00:14:46,040
在这本书中，他大约有六次引用了路易斯·巴斯德的名言：幸运眷顾有准备的头脑。

208
00:14:46,040 --> 00:14:49,640


209
00:14:49,640 --> 00:14:55,120
事后看来，聪明的想法往往看似简单，这使得它们很容易被低估。

210
00:14:55,120 --> 00:14:59,680
现在我真诚地希望汉明码，或者至少是这种代码的可能性，对你来说几乎是显而易见的。

211
00:14:59,680 --> 00:15:01,820


212
00:15:01,820 --> 00:15:05,440
但你不应该自欺欺人地认为它们实际上是显而易见的，因为它们绝对不是。

213
00:15:05,440 --> 00:15:08,000


214
00:15:08,000 --> 00:15:12,080
聪明的想法看似简单，部分原因是我们只看到最终结果，清理混乱的部分，从不提及所有错误的转折，低估了问题开始时可探索可能性的空间有多大解决过程，所有这一切。

215
00:15:12,080 --> 00:15:17,360


216
00:15:17,360 --> 00:15:22,400


217
00:15:22,400 --> 00:15:23,980


218
00:15:23,980 --> 00:15:25,280
但总的来说确实如此。

219
00:15:25,280 --> 00:15:29,880
我认为对于一些特殊的发明，我们低估它们还有第二个更深层次的原因。

220
00:15:29,880 --> 00:15:31,040


221
00:15:31,040 --> 00:15:35,040
直到 1948

222
00:15:35,040 --> 00:15:39,400
年，随着克劳德·香农（Claude Shannon）关于信息论的开创性论文的出现，用比特来思考信息才真正融合成一个完整的理论。

223
00:15:39,400 --> 00:15:43,400
这基本上与汉明开发他的算法的时间同时发生。

224
00:15:43,440 --> 00:15:47,300
这篇基础论文在某种意义上表明，无论位翻转的概率有多高，有效的纠错总是可能的，至少在理论上是这样。

225
00:15:47,300 --> 00:15:52,080


226
00:15:52,080 --> 00:15:53,920


227
00:15:53,920 --> 00:15:58,120
顺便说一句，香农和汉明在贝尔实验室共用一间办公室，尽管他们从事的工作截然不同，这在这里似乎并非巧合。

228
00:15:58,120 --> 00:16:02,400


229
00:16:02,400 --> 00:16:06,960
快进几十年，如今，我们中的许多人都沉浸在对比特和信息的思考中，很容易忽视这种思维方式的独特性。

230
00:16:06,960 --> 00:16:13,080


231
00:16:13,080 --> 00:16:17,920
具有讽刺意味的是，那些最深刻地塑造下一代思维方式的想法最终会在下一代人看来比实际情况更简单。

232
00:16:17,920 --> 00:16:22,640


