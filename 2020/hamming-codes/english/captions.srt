1
00:00:03,620 --> 00:00:06,804
Have you ever wondered how it's possible to scratch a CD 

2
00:00:06,804 --> 00:00:10,100
or a DVD and still have it play back whatever it's storing?

3
00:00:10,900 --> 00:00:14,301
The scratch really does affect the 1s and 0s on the disk, 

4
00:00:14,301 --> 00:00:17,410
so it reads off different data from what was stored, 

5
00:00:17,410 --> 00:00:21,574
but unless it's really scratched up, the bits it reads off are decoded 

6
00:00:21,574 --> 00:00:25,973
into precisely the same file that was encoded onto it, a bit for bit copy, 

7
00:00:25,973 --> 00:00:27,440
despite all those errors.

8
00:00:27,440 --> 00:00:32,079
There is a whole pile of mathematical cleverness that allows us to store data, 

9
00:00:32,079 --> 00:00:36,660
and just as importantly to transmit data, in a way that's resilient to errors.

10
00:00:37,520 --> 00:00:41,600
Well, actually it doesn't take that much cleverness to come up with a way to do this.

11
00:00:42,060 --> 00:00:45,952
Any file, whether it's a video, sound, text, code, 

12
00:00:45,952 --> 00:00:50,380
image, whatever, is ultimately some sequence of 1s and 0s.

13
00:00:50,680 --> 00:00:53,026
nstead of yeses and nos, it literally spells out the position of the error in binary. 

14
00:00:53,026 --> 00:00:54,472
For example, the number 7 in binary looks like 0111, 

15
00:00:54,472 --> 00:00:56,000
essentially saying that it's 4 plus 2 plus 1. And notice

16
00:00:57,580 --> 00:01:03,519
where the position 7 sits, it does affect the first of our parity groups, and the second, 

17
00:01:03,519 --> 00:01:08,930
and the third, but not the last. So reading the results of those four checks from 

18
00:01:08,930 --> 00:01:14,540
bottom to top indeed does spell out the position of the error. There's nothing specia

19
00:01:14,540 --> 00:01:18,920
But what that means is using two thirds of your space for redundancy.

20
00:01:18,920 --> 00:01:21,997
And even then, for all of that space given up, 

21
00:01:21,997 --> 00:01:27,300
there's no strong guarantee about what happens if more than one bit gets flipped.

22
00:01:27,600 --> 00:01:33,605
The much more interesting question is how to make it so that 

23
00:01:33,605 --> 00:01:40,300
errors can be corrected while giving up as little space as possible.

24
00:01:40,900 --> 00:01:44,811
c for implementing the whole scheme in hardware shockingly simple. 

25
00:01:44,811 --> 00:01:47,554
Now if you want to see why this magic happens, 

26
00:01:47,554 --> 00:01:52,575
take these 16 index labels for our positions, but instead of writing them in base 10, 

27
00:01:52,575 --> 00:01:56,194
let's write them all in binary, running from 0000 up to 1111. 

28
00:01:56,194 --> 00:01:59,580
As we put these binary labels back into their boxes, let m

29
00:01:59,580 --> 00:02:04,765
e emphasize that they are distinct from the data that's actually being sent. 

30
00:02:04,765 --> 00:02:08,940
They're nothing more than a conceptual label to help you and m

31
00:02:08,940 --> 00:02:11,490
And it will still be the case that if any bit gets flipped here, 

32
00:02:11,490 --> 00:02:13,373
just by looking at this block and nothing more, 

33
00:02:13,373 --> 00:02:16,472
a machine will be able to identify that there was an error and precisely where 

34
00:02:16,472 --> 00:02:18,120
it was so that it knows how to correct it.

35
00:02:18,120 --> 00:02:21,940
And honestly, that feels like magic.

36
00:02:22,840 --> 00:02:24,838
And for this particular scheme, if two bits get flipped, 

37
00:02:24,838 --> 00:02:27,362
the machine will at least be able to detect that there were two errors, 

38
00:02:27,362 --> 00:02:28,660
though it won't know how to fix them.

39
00:02:29,520 --> 00:02:28,660
We'll talk a little bit later about how this scales for blocks with different sizes.

40
00:02:29,520 --> 00:02:31,452
where that's a 1, you get the second parity group from our scheme. 

41
00:02:31,452 --> 00:02:33,183
In other words, that second check is asking, hey, me again, 

42
00:02:33,183 --> 00:02:35,260
if there's an error, is the second to last bit of that position a 1? And

43
00:02:35,260 --> 00:02:39,530
so on. The third parity check covers every position whose third to last bit is turned on, 

44
00:02:39,530 --> 00:02:41,902
and the last one covers the last eight positions, 

45
00:02:41,902 --> 00:02:44,560
those ones whose highest order bit is a 1. Everything we

46
00:02:44,560 --> 00:02:48,394
The goal here is to give you a very thorough understanding 

47
00:02:48,394 --> 00:02:52,100
of one of the earliest examples, known as a Hamming code.

48
00:02:52,100 --> 00:02:56,240
four questions, which in turn is the same as spelling out a position in binary. 

49
00:02:56,240 --> 00:03:00,018
I hope this makes two things clearer. The first is how to systematically 

50
00:03:00,018 --> 00:03:02,968
generalize to block sizes that are bigger powers of two. 

51
00:03:02,968 --> 00:03:07,367
If it takes more bits to describe each position, like six bits to describe 64 spots, 

52
00:03:07,367 --> 00:03:11,560
then each of those bits gives you one of the parity groups that we need to check.

53
00:03:11,560 --> 00:03:16,199
So when you feel like you see where it's going at some point, take that moment to pause, 

54
00:03:16,199 --> 00:03:19,640
actively predict what the scheme is going to be before I tell you.

55
00:03:19,640 --> 00:03:24,692
Also, if you want your understanding to get down to the hardware level, 

56
00:03:24,692 --> 00:03:29,956
Ben Eater has made a video in conjunction with this one showing you how to 

57
00:03:29,956 --> 00:03:35,500
actually implement Hamming codes on breadboards, which is extremely satisfying.

58
00:03:35,500 --> 00:03:39,560
You should know, Hamming codes are not as widely used as more modern codes, 

59
00:03:39,560 --> 00:03:43,247
like the Reed-Solomon algorithm, but there is a certain magic to the 

60
00:03:43,247 --> 00:03:46,827
contrast between just how impossible this task feels at the start, 

61
00:03:46,827 --> 00:03:50,300
and how utterly reasonable it seems once you learn about Hamming.

62
00:03:50,300 --> 00:03:56,473
The basic principle of error correction is that in a vast space of all possible messages, 

63
00:03:56,473 --> 00:04:00,520
only some subset are going to be considered valid messages.

64
00:04:00,520 --> 00:04:03,560
As an analogy, think about correctly spelled words versus incorrectly spelled words.

65
00:04:03,560 --> 00:04:07,423
also see this in larger examples, where no matter how big you get, 

66
00:04:07,423 --> 00:04:10,940
each parity bit conveniently touches only one of the groups. 

67
00:04:10,940 --> 00:04:15,784
Once you understand that these parity checks that we've focused so much of our time 

68
00:04:15,784 --> 00:04:20,800
on are nothing more than a clever way to spell out the position of an error in binary, 

69
00:04:20,800 --> 00:04:23,280
then we can draw a connection with a differ

70
00:04:23,280 --> 00:04:25,731
ent way to think about hamming codes, one that is arguably a lot simpler and 

71
00:04:25,731 --> 00:04:28,120
more elegant, and which can basically be written down with a single line of

72
00:04:28,120 --> 00:04:31,388
code. It's based on the XOR function. XOR, for those of you who don't know, 

73
00:04:31,388 --> 00:04:33,968
stands for exclusive or. When you take the XOR of two bits, 

74
00:04:33,968 --> 00:04:36,849
it's going to return a 1 if either one of those bits is turned on, 

75
00:04:36,849 --> 00:04:39,300
but not if both are turned on or off. Phrased differently

76
00:04:39,300 --> 00:04:43,546
And the programs he kept putting through it kept failing, 

77
00:04:43,546 --> 00:04:47,280
because every now and then a bit would get misread.

78
00:04:48,600 --> 00:04:50,870
Frustration being the crucible of invention, he got so fed 

79
00:04:50,870 --> 00:04:53,180
up that he invented the world's first error correction code.

80
00:04:53,180 --> 00:04:56,405
There are many different ways to frame Hamming codes, 

81
00:04:56,405 --> 00:05:00,765
but as a first pass we're going to go through it the way Hamming himself 

82
00:05:00,765 --> 00:05:01,900
thought about them.

83
00:05:01,900 --> 00:05:08,060
Let's use an example that's simple, but not too simple, a block of 16 bits.

84
00:05:08,400 --> 00:05:08,560
We'll number the positions of these bits from 0 up to 15.

85
00:05:08,560 --> 00:05:12,251
bit representations of those numbers under the hood. 

86
00:05:12,251 --> 00:05:18,172
The key point for you and me is that taking the XOR of many different bit strings is 

87
00:05:18,172 --> 00:05:23,256
effectively a way to compute the parodies of a bunch of separate groups, 

88
00:05:23,256 --> 00:05:26,600
like so with the columns, all in one fell swoop.

89
00:05:26,780 --> 00:05:31,572
The word redundant here doesn't simply mean copy, after all, 

90
00:05:31,572 --> 00:05:36,600
those 4 bits don't give us enough room to blindly copy the data.

91
00:05:36,600 --> 00:05:37,419
Instead, they'll need to be a much more nuanced and clever kind of redundancy, 

92
00:05:37,419 --> 00:05:37,980
not adding any new information, but adding resilience.

93
00:05:38,140 --> 00:05:44,402
s, so it's effectively counting how many highlighted positions came from the first parity 

94
00:05:44,402 --> 00:05:50,524
group. Does that make sense? Likewise, the next column counts how many positions are in 

95
00:05:50,524 --> 00:05:56,300
the second parity group, the positions whose second to last bit is a 1, and which a

96
00:05:56,880 --> 00:05:59,960
re also highlighted, and so on. It's really just a small shift in 

97
00:05:59,960 --> 00:06:02,200
perspective on the same thing we've been doing. 

98
00:06:02,200 --> 00:06:06,120
And so you know where it goes from here. The sender is responsible for toggling some

99
00:06:06,120 --> 00:06:10,080
of the special parity bits to make sure the sum works out to be 0000. 

100
00:06:10,080 --> 00:06:14,153
Now once we have it like this, this gives us a really nice way to think 

101
00:06:14,153 --> 00:06:18,680
about why these four resulting bits at the bottom directly spell out the positio

102
00:06:19,000 --> 00:06:23,453
Like any error correction algorithm, this will involve two players, a sender, 

103
00:06:23,453 --> 00:06:27,621
who's responsible for setting these 4 special bits, and then a receiver, 

104
00:06:27,621 --> 00:06:32,360
who's responsible for performing some kind of check and then correcting the errors.

105
00:06:32,360 --> 00:06:36,101
Of course, the words sender and receiver really refer to 

106
00:06:36,101 --> 00:06:40,039
machines or software that's doing checks, and the idea of a 

107
00:06:40,039 --> 00:06:44,240
message is meant really broadly, to include things like storage.

108
00:06:44,240 --> 00:06:45,330
After all, storing data is the same thing as sending a message, 

109
00:06:45,330 --> 00:06:46,540
just from the past to the future, instead of from one place to another.

110
00:06:47,980 --> 00:06:50,731
So that's the setup, but before we can dive in, 

111
00:06:50,731 --> 00:06:55,889
we need to talk about a related idea which was fresh on Hamming's mind in the time of his 

112
00:06:55,889 --> 00:07:01,047
discovery, a method which lets you detect any single bit errors, but not to correct them, 

113
00:07:01,047 --> 00:07:03,340
known in the business as a parity check.

114
00:07:04,860 --> 00:07:07,050
For a parity check, we separate out only one single bit that the sender 

115
00:07:07,050 --> 00:07:09,120
is responsible for tuning, and the rest are free to carry a message.

116
00:07:09,120 --> 00:07:10,916
The only job of this special bit is to make sure that 

117
00:07:10,916 --> 00:07:12,780
the total number of 1s in the message is an even number.

118
00:07:12,780 --> 00:07:15,574
So for example right now, that total number of 1s is 7, that's odd, 

119
00:07:15,574 --> 00:07:18,780
so the sender needs to flip that special bit to be a 1, making the count even.

120
00:07:18,780 --> 00:07:22,433
But if the block had already started off with an even number of 1s, 

121
00:07:22,433 --> 00:07:25,120
then this special bit would have been kept at a 0.

122
00:07:25,120 --> 00:07:30,037
This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill 

123
00:07:30,037 --> 00:07:34,900
the idea of change anywhere in a message to be reflected in a single bit of information.

124
00:07:34,900 --> 00:07:37,917
ctice this would be something we're receiving from a sender, 

125
00:07:37,917 --> 00:07:42,370
and instead of being random it would be carrying 11 data bits together with 5 parity bits.

126
00:07:42,370 --> 00:07:46,179
 If I call the function enumerateBits, what it does is pair together each of 

127
00:07:46,179 --> 00:07:49,940
those bits with a corresponding index, in this case running from 0 up to 15.

128
00:07:49,940 --> 00:07:52,168
So if you're the receiver, you look at this message, 

129
00:07:52,168 --> 00:07:55,741
and you see an odd number of 1s, you can know for sure that some error has occurred, 

130
00:07:55,741 --> 00:07:57,760
even though you might have no idea where it was.

131
00:07:57,760 --> 00:07:59,903
In the jargon, whether a group of bits has an 

132
00:07:59,903 --> 00:08:02,280
even or an odd number of 1s is known as its parity.

133
00:08:02,280 --> 00:08:05,773
o collect together all of those positions, the positions of the bits that are turned on, 

134
00:08:05,773 --> 00:08:07,736
and then XOR them together. To do this in Python, 

135
00:08:07,736 --> 00:08:09,620
let me first import a couple helpful functions. 

136
00:08:09,620 --> 00:08:12,840
That way we can call reduce() on this list, and use the XOR function to reduce it.

137
00:08:12,840 --> 00:08:15,878
And actually, we should be clear, if the receiver sees an odd parity, 

138
00:08:15,878 --> 00:08:18,222
it doesn't necessarily mean there was just one error, 

139
00:08:18,222 --> 00:08:20,870
there might have been 3 errors or 5 or any other odd number, 

140
00:08:20,870 --> 00:08:22,780
but they can know for sure that it wasn't 0.

141
00:08:22,780 --> 00:08:26,036
On the other hand, if there had been 2 errors, or any even number of errors, 

142
00:08:26,036 --> 00:08:29,250
that final count of 1s would still be even, so the receiver can't have full 

143
00:08:29,250 --> 00:08:32,380
confidence that an even count necessarily means the message is error-free.

144
00:08:32,760 --> 00:08:36,253
So at the moment it looks like if we do this on our random block of 16 bits, 

145
00:08:36,253 --> 00:08:39,746
it returns 9, which has the binary representation 1001. We won't do it here, 

146
00:08:39,746 --> 00:08:43,375
but you could write a function where the sender uses that binary representation 

147
00:08:43,375 --> 00:08:46,960
to set the four parity bits as needed, ultimately getting this block to a state

148
00:08:46,960 --> 00:08:50,168
where running this line of code on the full list of bits returns a 0. 

149
00:08:50,168 --> 00:08:52,367
This would be considered a well-prepared block. 

150
00:08:52,367 --> 00:08:55,438
What's cool is that if we toggle any one of the bits in this list, 

151
00:08:55,438 --> 00:08:59,380
simulating a random error from noise, then if you run this same line of code, it print

152
00:09:00,100 --> 00:09:05,112
s out that error. Isn't that neat? You could get this block from out of the blue, 

153
00:09:05,112 --> 00:09:10,430
run this single line on it, and it'll automatically spit out the position of an error, 

154
00:09:10,430 --> 00:09:15,260
or a 0 if there wasn't any. And there's nothing special about the size 16 here.

155
00:09:15,260 --> 00:09:22,915
Instead, the goal is to come up with a scheme that's robust up to a certain maximum 

156
00:09:22,915 --> 00:09:30,480
number of errors, or maybe to reduce the probability of a false positive like this.

157
00:09:30,480 --> 00:09:34,086
a parity check to detect 2-bit errors, but the idea is that almost all of 

158
00:09:34,086 --> 00:09:37,693
the core logic from our scheme comes down to a single XOR reduction. Now, 

159
00:09:37,693 --> 00:09:41,202
depending on your comfort with binary and XORs and software in general, 

160
00:09:41,202 --> 00:09:44,760
you may either find this perspective a little bit confusing, or so much m

161
00:09:44,760 --> 00:09:49,403
For example, as Hamming was searching for a way to identify where an error happened, 

162
00:09:49,403 --> 00:09:53,991
not just that it happened, his key insight was that if you apply some parity checks 

163
00:09:53,991 --> 00:09:57,706
not to the full message, but to certain carefully selected subsets, 

164
00:09:57,706 --> 00:10:02,131
you can ask a more refined series of questions that pin down the location of any 

165
00:10:02,131 --> 00:10:03,060
single bit error.

166
00:10:03,060 --> 00:10:08,718
The overall feeling is a bit like playing a game of 20 questions, 

167
00:10:08,718 --> 00:10:14,720
asking yes or no queries that chop the space of possibilities in half.

168
00:10:14,720 --> 00:10:18,735
of the size of the block, or in other words, it grows one bit at a time as the block size 

169
00:10:18,735 --> 00:10:22,751
doubles. The relevant fact here is that that information directly corresponds to how much 

170
00:10:22,751 --> 00:10:26,500
redundancy we need. That's really what runs against most people's knee-jerk reaction

171
00:10:26,940 --> 00:10:28,694
Then, if an error is detected, it gives the receiver a little more information 

172
00:10:28,694 --> 00:10:30,360
about where specifically the error is, namely that it's in an odd position.

173
00:10:30,360 --> 00:10:34,531
ent to errors, where usually copying the whole message is the first instinct that 

174
00:10:34,531 --> 00:10:38,397
comes to mind. And then, by the way, there is this whole other way that you 

175
00:10:38,397 --> 00:10:42,924
sometimes see Hamming codes presented, where you multiply the message by one big matrix. 

176
00:10:42,924 --> 00:10:46,740
It's kind of nice because it relates it to the broader family of linear cod

177
00:10:46,740 --> 00:10:52,277
You might think that limiting a parity check to half the bits makes it less effective, 

178
00:10:52,277 --> 00:10:56,414
but when it's done in conjunction with other well-chosen checks, 

179
00:10:56,414 --> 00:11:00,360
it counter-intuitively gives us something a lot more powerful.

180
00:11:00,360 --> 00:11:03,398
To actually set up that parity check, remember, 

181
00:11:03,398 --> 00:11:07,957
it requires earmarking some special bit that has control for the parity 

182
00:11:07,957 --> 00:11:09,160
of that full group.

183
00:11:09,160 --> 00:11:10,100
Here let's just choose position 1.

184
00:11:10,100 --> 00:11:12,932
For the example shown, the parity of these 8 bits is currently odd, 

185
00:11:12,932 --> 00:11:16,140
so the sender is responsible for toggling that parity bit, and now it's even.

186
00:11:16,440 --> 00:11:16,980
This is only 1 out of 4 parity checks that we'll do.

187
00:11:16,980 --> 00:11:17,456
The second check is among the 8 bits on the right half of the grid, 

188
00:11:17,456 --> 00:11:17,680
at least as we've drawn it here.

189
00:11:17,680 --> 00:11:20,900
This time we might use position 2 as a parity bit.

190
00:11:21,380 --> 00:11:22,777
So these 8 bits already have an even parity, and the 

191
00:11:22,777 --> 00:11:24,280
sender can feel good leaving that bit number 2 unchanged.

192
00:11:24,280 --> 00:11:28,237
d if you take that to an extreme, you could have a block with, say, a million bits, 

193
00:11:28,237 --> 00:11:32,053
where you would quite literally be playing 20 questions with your parity checks, 

194
00:11:32,053 --> 00:11:35,916
and it uses only 21 parity bits. And if you step back to think about looking at a 

195
00:11:35,916 --> 00:11:39,780
million bits and locating a single error, that genuinely feels crazy. The problem,

196
00:11:40,040 --> 00:11:39,780
Otherwise, it means either there's no error, or the error is somewhere on the left half.

197
00:11:40,040 --> 00:11:46,635
Or I guess there could have been two errors, but for right now we're 

198
00:11:46,635 --> 00:11:53,040
going to assume that there's at most one error in the entire block.

199
00:11:53,040 --> 00:11:53,840
Things break down completely for more than that.

200
00:11:53,840 --> 00:11:56,847
Here, before we look at the next two checks, take a moment to think 

201
00:11:56,847 --> 00:12:00,120
about what these first two allow us to do when you consider them together.

202
00:12:00,120 --> 00:12:04,460
Let's say you detect an error among the odd columns and among the right half.

203
00:12:04,460 --> 00:12:04,460
It necessarily means the error is somewhere in the last column.

204
00:12:04,460 --> 00:12:05,841
If there was no error in the odd column but there was one in the right half, 

205
00:12:05,841 --> 00:12:06,720
that tells you it's in the second to last column.

206
00:12:06,720 --> 00:12:13,680
Likewise, if there is an error in the odd columns but not in the right half, 

207
00:12:13,680 --> 00:12:18,200
you know that it's somewhere in the second column.

208
00:12:18,660 --> 00:12:20,068
like the much more commonly used Reed-Solomon algorithm, 

209
00:12:20,068 --> 00:12:22,219
which handles burst errors particularly well, and it can be tuned to be resilient to a 

210
00:12:22,219 --> 00:12:23,060
larger number of errors per block.

211
00:12:23,500 --> 00:12:31,540
But it also might simply mean there's no error at all.

212
00:12:31,540 --> 00:12:32,665
Which is all a rather belabored way to say that 

213
00:12:32,665 --> 00:12:33,720
two parity checks let us pin down the column.

214
00:12:33,720 --> 00:12:36,060
From here, you can probably guess what follows.

215
00:12:36,440 --> 00:12:43,530
spire in a way that spells out the position of an error only came to Hamming when 

216
00:12:43,530 --> 00:12:50,880
he stepped back after a bunch of other analysis and asked, okay, what is the most eff

217
00:12:50,880 --> 00:12:51,241
icient I could conceivably be about this? He was 

218
00:12:51,241 --> 00:12:51,640
also candid about how important it was that parity che

219
00:12:51,640 --> 00:12:54,760
So in this example, that group already has an even parity, so bit 4 would be set to a 0.

220
00:12:54,760 --> 00:12:57,812
it is today. There are like half a dozen times throughout this book that 

221
00:12:57,812 --> 00:13:00,740
he references the Louis Pasteur quote, luck favors a prepared mind. Cl

222
00:13:00,740 --> 00:13:05,680
In this case, it looks like the sender needs to turn 

223
00:13:05,680 --> 00:13:10,620
that bit 8 on in order to give the group even parity.

224
00:13:10,620 --> 00:13:14,458
Part of the reason that clever ideas look deceptively easy is that we only ever 

225
00:13:14,458 --> 00:13:18,440
see the final result, cleaning up what was messy, never mentioning all of the wrong

226
00:13:18,440 --> 00:13:29,360
As an example, imagine that during the transmission there's an error at, say, position 3.

227
00:13:29,880 --> 00:13:34,306
Well, this affects the first parity group, and it also affects the second parity group, 

228
00:13:34,306 --> 00:13:38,080
so the receiver knows that there's an error somewhere in that right column.

229
00:13:38,080 --> 00:13:41,000
But it doesn't affect the third group, and it doesn't affect the fourth group.

230
00:13:41,720 --> 00:13:45,667
And that lets the receiver pinpoint the error up to the first row, 

231
00:13:45,667 --> 00:13:49,320
which necessarily means position 3, so they can fix the error.

232
00:13:49,320 --> 00:13:54,207
You might enjoy taking a moment to convince yourself that the 

233
00:13:54,207 --> 00:14:01,222
answers to these four questions really will always let you pin down a specific location, 

234
00:14:01,222 --> 00:14:04,060
no matter where they turn out to be.

235
00:14:04,060 --> 00:14:04,479
In fact, the astute among you might even notice a 

236
00:14:04,479 --> 00:14:04,940
connection between these questions and binary counting.

237
00:14:04,940 --> 00:14:07,430
And if you do, again let me emphasize, pause, try 

238
00:14:07,430 --> 00:14:10,120
for yourself to draw the connection before I spoil it.

239
00:14:10,120 --> 00:14:10,412
If you're wondering what happens if a parity bit itself gets affected, 

240
00:14:10,412 --> 00:14:10,520
well, you can just try it.

241
00:14:10,520 --> 00:14:15,409
Take a moment to think about how any error among these four special bits is going 

242
00:14:15,409 --> 00:14:20,060
to be tracked down just like any other, with the same group of four questions.

243
00:14:20,060 --> 00:14:22,254
It doesn't really matter, since at the end of the day what we want is to 

244
00:14:22,254 --> 00:14:24,480
protect the message bits, the error correction bits are just riding along.

245
00:14:24,480 --> 00:14:29,628
But protecting those bits as well is something that 

246
00:14:29,628 --> 00:14:34,480
naturally falls out of the scheme as a byproduct.

247
00:14:34,480 --> 00:14:34,860
You might also enjoy anticipating how this scales.

248
00:14:35,280 --> 00:14:37,166
If we used a block of size 256 bits, for example, in order to pin down a location, 

249
00:14:37,166 --> 00:14:39,166
you need only eight yes or no questions to binary search your way down to some specific 

250
00:14:39,166 --> 00:14:39,280
spot.

251
00:14:39,280 --> 00:14:39,403
And remember, each question requires giving up only 

252
00:14:39,403 --> 00:14:39,520
a single bit to set the appropriate parity check.

253
00:14:39,520 --> 00:14:41,200
Some of you may already see it, but we'll talk later about the 

254
00:14:41,200 --> 00:14:43,120
systematic way to find what these questions are in just a minute or two.

255
00:14:43,120 --> 00:14:43,291
Hopefully this sketch is enough to appreciate 

256
00:14:43,291 --> 00:14:43,460
the efficiency of what we're developing here.

257
00:14:44,240 --> 00:14:46,734
Everything except for those eight highlighted parity bits can be 

258
00:14:46,734 --> 00:14:49,460
whatever you want it to be, carrying whatever message or data you want.

259
00:14:49,460 --> 00:14:54,103
The eight bits are redundant in the sense that they're completely determined by the rest 

260
00:14:54,103 --> 00:14:58,800
of the message, but it's in a much smarter way than simply copying the message as a whole.

261
00:14:59,860 --> 00:15:01,463
And still, for so little given up, you would be 

262
00:15:01,463 --> 00:15:03,000
able to identify and fix any single bit error.

263
00:15:03,000 --> 00:15:04,160
Well, almost.

264
00:15:04,160 --> 00:15:07,640
Okay, so the one problem here is that if none of the four parity checks detect an error, 

265
00:15:07,640 --> 00:15:10,847
meaning that the specially selected subsets of eight bits all have even parities, 

266
00:15:10,847 --> 00:15:13,936
just like the sender intended, then it either means there was no error at all, 

267
00:15:13,936 --> 00:15:15,540
or it narrows us down into position zero.

268
00:15:16,160 --> 00:15:21,865
You see, with four yes or no questions, we have 16 possible outcomes for our parity 

269
00:15:21,865 --> 00:15:27,502
checks, and at first that feels perfect for pinpointing one out of 16 positions in 

270
00:15:27,502 --> 00:15:33,140
the block, but you also need to communicate a 17th outcome, the no error condition.

271
00:15:33,140 --> 00:15:37,180
The solution here is actually pretty simple.

272
00:15:37,180 --> 00:15:41,620
Just forget about that zeroth bit entirely.

273
00:15:41,620 --> 00:15:48,343
So when we do our four parity checks and we see that they're all even, 

274
00:15:48,343 --> 00:15:52,700
it unambiguously means that there is no error.

275
00:15:53,520 --> 00:15:55,260
What that means is rather than working with a 16-bit block, we work with a 15-bit block, 

276
00:15:55,260 --> 00:15:56,824
where 11 of the bits are free to carry a message and four of them are there for 

277
00:15:56,824 --> 00:15:57,040
redundancy.

278
00:15:57,040 --> 00:16:01,042
And with that, we now have what people in the 

279
00:16:01,042 --> 00:16:05,220
business would refer to as a 15-11 Hamming code.

280
00:16:06,540 --> 00:16:08,433
That said, it is nice to have a block size that's a clean power of two, 

281
00:16:08,433 --> 00:16:09,958
and there's a clever way that we can keep that zeroth bit 

282
00:16:09,958 --> 00:16:11,300
around and get it to do a little extra work for us.

283
00:16:11,300 --> 00:16:12,444
If we use it as a parity bit across the whole block, 

284
00:16:12,444 --> 00:16:14,020
it lets us actually detect, even though we can't correct, two-bit errors.

285
00:16:14,020 --> 00:16:14,600
Here's how it works.

286
00:16:14,600 --> 00:16:17,874
After setting those four special error correcting bits, 

287
00:16:17,874 --> 00:16:21,908
we set that zeroth one so that the parity of the full block is even, 

288
00:16:21,908 --> 00:16:23,780
just like a normal parity check.

289
00:16:23,780 --> 00:16:26,417
Now, if there's a single bit error, then the parity of the full block toggles to be odd, 

290
00:16:26,417 --> 00:16:28,640
but we would catch that anyway, thanks to the four error correcting checks.

291
00:16:28,640 --> 00:16:32,281
However, if there's two errors, then the overall parity is going to toggle 

292
00:16:32,281 --> 00:16:35,875
back to being even, but the receiver would still see that there's been at 

293
00:16:35,875 --> 00:16:39,760
least some error because of what's going on with those four usual parity checks.

294
00:16:39,760 --> 00:16:43,567
So if they notice an even parity overall, but something non-zero happening 

295
00:16:43,567 --> 00:16:47,020
with the other checks, it tells them there were at least two errors.

296
00:16:52,720 --> 00:16:47,020
Isn't that clever?

297
00:16:52,720 --> 00:16:55,945
Even though we can't correct those two-bit errors, 

298
00:16:55,945 --> 00:17:00,245
just by putting that one little bothersome zeroth bit back to work, 

299
00:17:00,245 --> 00:17:01,700
it lets us detect them.

300
00:17:01,700 --> 00:17:03,320
This is pretty standard, it's known as an extended Hamming code.

301
00:17:05,339 --> 00:17:10,258
Technically speaking, you now have a full description of what a Hamming code does, 

302
00:17:10,258 --> 00:17:14,465
at least for the example of a 16-bit block, but I think you'll find it 

303
00:17:14,465 --> 00:17:18,849
more satisfying to check your understanding and solidify everything up to 

304
00:17:18,849 --> 00:17:22,819
this point by doing one full example from start to finish yourself.

305
00:17:22,819 --> 00:17:22,819
I'll step through it with you though so you can check yourself.

306
00:17:22,819 --> 00:17:31,820
To set up a message, whether that's a literal message that you're translating over space, 

307
00:17:31,820 --> 00:17:36,520
or some data that you want to store over time, 

308
00:17:36,520 --> 00:17:41,820
the first step is to divide it up into 11-bit chunks.

309
00:17:41,820 --> 00:17:50,200
Each chunk is going to get packaged into an error-resistant 16-bit block.

310
00:17:50,620 --> 00:17:54,320
So let's take this one as an example and actually work it out.

311
00:17:54,320 --> 00:17:55,000
Go ahead, actually do it!

312
00:17:55,000 --> 00:17:56,820
Pause and try putting together this block.

313
00:17:57,080 --> 00:17:59,780
Okay, you ready?

314
00:18:00,020 --> 00:18:03,238
Remember, position 0 along with the other powers of 2 are reserved for error correction 

315
00:18:03,238 --> 00:18:06,420
duty, so you start by placing the message bits in all of the remaining spots, in order.

316
00:18:06,420 --> 00:18:17,495
You need this group to have an even parity, which it already does, 

317
00:18:17,495 --> 00:18:27,910
so you should have set that parity bit in position 1 to be a 0.

318
00:18:28,800 --> 00:18:27,910
The next group starts off with an odd parity, 

319
00:18:29,690 --> 00:18:28,800
so you should have set its parity bit to be 1.

320
00:18:29,690 --> 00:18:33,322
The group after that starts with an odd parity, 

321
00:18:33,322 --> 00:18:37,030
so again you should have set its parity bit to 1.

322
00:18:38,550 --> 00:18:40,381
And the final group also has an odd parity, meaning 

323
00:18:40,381 --> 00:18:41,790
we set that bit in position 8 to be a 1.

324
00:18:42,650 --> 00:18:47,399
And then as the final step, the full block now has an even parity, 

325
00:18:47,399 --> 00:18:53,070
meaning that you can set that bit number 0, the overarching parity bit, to be 0.

326
00:18:53,070 --> 00:18:56,667
So as this block is sent off, the parity of the four special 

327
00:18:56,667 --> 00:18:59,970
subsets and the block as a whole will all be even, or 0.

328
00:19:01,310 --> 00:19:07,610
As the second part of the exercise, let's have you play the role of the receiver.

329
00:19:07,610 --> 00:19:17,810
Of course, that would mean you don't already know what this message is.

330
00:19:18,030 --> 00:19:24,910
Maybe some of you memorized it, but let's assume that you haven't.

331
00:19:24,910 --> 00:19:27,702
What I'm going to do is change either 0, 1, or 2 of the bits in that block, 

332
00:19:27,702 --> 00:19:29,650
and then ask you to figure out what it is that I did.

333
00:19:29,650 --> 00:19:29,650
So again, pause and try working it out.

334
00:19:29,650 --> 00:19:33,348
Okay, so you as the receiver now check the first parity group, 

335
00:19:33,348 --> 00:19:37,869
and you can see that it's even, so any error that exists would have to be in 

336
00:19:37,869 --> 00:19:38,750
an even column.

337
00:19:39,430 --> 00:19:40,568
The next check gives us an odd number, telling us both that there's at least one error, 

338
00:19:40,568 --> 00:19:41,190
and narrowing us down into this specific column.

339
00:19:41,190 --> 00:19:41,310
The third check is even, chopping down the possibilities even further.

340
00:19:41,310 --> 00:19:41,310
And the last parity check is odd, telling us there's an error somewhere in the bottom, 

341
00:19:41,310 --> 00:19:41,310
which by now we can see must be in position number 10.

342
00:19:41,310 --> 00:19:41,310
What's more, the parity of the whole block is odd, 

343
00:19:41,310 --> 00:19:41,310
giving us confidence that there was one flip and not two.

344
00:19:41,310 --> 00:19:41,310
If it's three or more, all bets are off.

345
00:19:41,310 --> 00:19:41,310
After correcting that bit number 10, pulling out the 11 bits that were not 

346
00:19:41,310 --> 00:19:41,310
used for correction gives us the relevant segment of the original message, 

347
00:19:41,310 --> 00:19:41,310
which if you rewind and compare is indeed exactly what we started the example with.

348
00:19:41,310 --> 00:19:41,310
And now that you know how to do all this by hand, 

349
00:19:41,310 --> 00:19:41,310
I'd like to show you how you can carry out the core part of all of this logic with 

350
00:19:41,310 --> 00:19:41,310
a single line of Python code.

351
00:19:41,310 --> 00:19:41,310
You see, what I haven't told you yet is just how elegant this algorithm really is, 

352
00:19:41,310 --> 00:19:41,310
how simple it is to get a machine to point to the position of an error, 

353
00:19:41,310 --> 00:19:41,310
how to systematically scale it, and how we can frame all of this as one 

354
00:19:41,310 --> 00:19:41,310
single operation rather than multiple separate parity checks.

355
00:19:41,310 --> 00:19:41,310
To see what I mean, come join me in part two.

