1
00:00:00,000 --> 00:00:03,120
ఇక్కడ అందరూ పార్ట్ 1 నుండి వస్తున్నారని నేను ఊహిస్తున్నాను.

2
00:00:03,120 --> 00:00:07,878
మేము హామింగ్ కోడ్‌ల గురించి మాట్లాడుతున్నాము, చాలా బిట్‌లు అర్థవంతమైన సందేశాన్ని

3
00:00:07,878 --> 00:00:13,166
కలిగి ఉండే డేటా బ్లాక్‌ను సృష్టించే మార్గం, మరికొన్ని ఒక రకమైన రిడెండెన్సీగా పనిచేస్తాయి,

4
00:00:13,166 --> 00:00:18,218
ఆ విధంగా ఏదైనా బిట్ తిప్పబడితే, సందేశం బిట్ లేదా రిడెండెన్సీ బిట్, ఈ బ్లాక్‌లో ఏదైనా,

5
00:00:18,218 --> 00:00:21,920
రిసీవర్ లోపం ఉందని మరియు దాన్ని ఎలా పరిష్కరించాలో గుర్తించగలదు.

6
00:00:21,920 --> 00:00:26,509
బైనరీ శోధన కోసం బహుళ పారిటీ తనిఖీలను ఎలా ఉపయోగించాలి

7
00:00:26,509 --> 00:00:29,800
అనేది అక్కడ అందించబడిన ప్రాథమిక ఆలోచన.

8
00:00:29,800 --> 00:00:32,830
ఆ వీడియోలో హామింగ్ కోడ్‌లను సాధ్యమైనంత వరకు అందుబాటులో

9
00:00:32,830 --> 00:00:35,420
ఉంచడం మరియు తిరిగి కనుగొనగలిగేలా చేయడం లక్ష్యం.

10
00:00:35,420 --> 00:00:39,292
సాఫ్ట్‌వేర్ లేదా హార్డ్‌వేర్‌లో దీన్ని అమలు చేయడం గురించి మీరు ఆలోచించడం

11
00:00:39,292 --> 00:00:43,695
ప్రారంభించినప్పుడు, ఈ కోడ్‌లు నిజంగా ఎంత సొగసైనవో ఆ ఫ్రేమింగ్ వాస్తవానికి తక్కువగా

12
00:00:43,695 --> 00:00:44,120
ఉంటుంది.

13
00:00:44,120 --> 00:00:47,290
సాధ్యమయ్యే అన్ని ఎర్రర్ లొకేషన్‌లను ట్రాక్ చేసే మరియు ప్రతి

14
00:00:47,290 --> 00:00:50,778
చెక్‌తో ఆ సమూహాన్ని సగానికి తగ్గించే అల్గారిథమ్‌ను మీరు వ్రాయవలసి

15
00:00:50,778 --> 00:00:54,160
ఉంటుందని మీరు అనుకోవచ్చు, అయితే ఇది నిజానికి దాని కంటే సరళమైనది.

16
00:00:54,160 --> 00:00:58,668
మేము చివరి వీడియోలో చేసిన నాలుగు సమానత్వ తనిఖీలకు సమాధానాలను మీరు చదివితే,

17
00:00:58,668 --> 00:01:04,018
అవును మరియు సంఖ్యలకు బదులుగా 1 సె మరియు 0 సె, ఇది బైనరీలో లోపం యొక్క స్థానాన్ని అక్షరాలా

18
00:01:04,018 --> 00:01:04,800
వివరిస్తుంది.

19
00:01:04,800 --> 00:01:08,926
ఉదాహరణకు, బైనరీలో 7 సంఖ్య 0111 లాగా కనిపిస్తుంది,

20
00:01:08,926 --> 00:01:12,640
ముఖ్యంగా ఇది 4 ప్లస్ 2 ప్లస్ 1 అని చెబుతోంది.

21
00:01:12,640 --> 00:01:17,058
మరియు స్థానం 7 ఎక్కడ కూర్చుందో గమనించండి, ఇది మా సమానత్వ సమూహాలలో

22
00:01:17,058 --> 00:01:22,280
మొదటిదానిని ప్రభావితం చేస్తుంది మరియు రెండవది మరియు మూడవది, కానీ చివరిది కాదు.

23
00:01:22,280 --> 00:01:25,463
కాబట్టి ఆ నాలుగు చెక్‌ల ఫలితాలను దిగువ నుండి పైకి

24
00:01:25,463 --> 00:01:28,520
చదవడం నిజంగా లోపం యొక్క స్థితిని తెలియజేస్తుంది.

25
00:01:28,520 --> 00:01:32,657
ఉదాహరణ 7 గురించి ప్రత్యేకంగా ఏమీ లేదు, ఇది సాధారణంగా పని చేస్తుంది మరియు ఇది

26
00:01:32,657 --> 00:01:37,440
హార్డ్‌వేర్‌లో మొత్తం పథకాన్ని అమలు చేయడానికి తర్కాన్ని దిగ్భ్రాంతికరంగా సులభం చేస్తుంది.

27
00:01:37,440 --> 00:01:40,998
ఇప్పుడు మీరు ఈ మాయాజాలం ఎందుకు జరుగుతుందో చూడాలనుకుంటే,

28
00:01:40,998 --> 00:01:44,111
మా స్థానాల కోసం ఈ 16 సూచిక లేబుల్‌లను తీసుకోండి,

29
00:01:44,111 --> 00:01:48,178
కానీ వాటిని బేస్ 10లో వ్రాయడానికి బదులుగా, 0000 నుండి 1111 వరకు

30
00:01:48,178 --> 00:01:50,720
నడుస్తున్న బైనరీలో అన్నింటినీ వ్రాస్దాం.

31
00:01:50,720 --> 00:01:54,020
మేము ఈ బైనరీ లేబుల్‌లను వాటి పెట్టెల్లోకి తిరిగి ఉంచినప్పుడు,

32
00:01:54,020 --> 00:01:58,440
అవి వాస్తవానికి పంపబడుతున్న డేటా నుండి విభిన్నంగా ఉన్నాయని నేను నొక్కిచెబుతున్నాను.

33
00:01:58,440 --> 00:02:01,410
నాలుగు సమానత్వ సమూహాలు ఎక్కడ నుండి వచ్చాయో అర్థం చేసుకోవడంలో మీకు

34
00:02:01,410 --> 00:02:04,200
మరియు నాకు సహాయం చేయడానికి అవి సంభావిత లేబుల్ తప్ప మరేమీ కాదు.

35
00:02:04,200 --> 00:02:08,398
మనం చూస్తున్న ప్రతిదీ బైనరీలో వర్ణించబడటం యొక్క సొగసైనది బహుశా మనం

36
00:02:08,398 --> 00:02:13,160
చూస్తున్న ప్రతిదాన్ని బైనరీలో వివరించడం వల్ల కలిగే గందరగోళం వల్ల తగ్గుతుంది.

37
00:02:13,160 --> 00:02:15,040
అయితే ఇది విలువైనదే.

38
00:02:15,040 --> 00:02:20,552
ఈ లేబుల్‌లన్నింటిలో చివరి బిట్‌పై మాత్రమే మీ దృష్టిని కేంద్రీకరించండి,

39
00:02:20,552 --> 00:02:24,280
ఆపై ఆ చివరి బిట్ 1 ఉన్న స్థానాలను హైలైట్ చేయండి.

40
00:02:24,280 --> 00:02:28,077
మేము పొందేది మా నాలుగు సమానత్వ సమూహాలలో మొదటిది,

41
00:02:28,077 --> 00:02:34,432
అంటే మీరు ఆ మొదటి చెక్‌ని అడుగుతున్నట్లు అర్థం చేసుకోవచ్చు, హే, లోపం ఉన్నట్లయితే,

42
00:02:34,432 --> 00:02:36,680
ఆ లోపం యొక్క స్థానం 1గా ఉందా?

43
00:02:36,680 --> 00:02:40,685
అదేవిధంగా, మీరు రెండవ నుండి చివరి బిట్‌పై దృష్టి సారించి,

44
00:02:40,685 --> 00:02:45,658
అది 1 ఉన్న అన్ని స్థానాలను హైలైట్ చేస్తే, మీరు మా పథకం నుండి రెండవ సమాన

45
00:02:45,658 --> 00:02:47,040
సమూహాన్ని పొందుతారు.

46
00:02:47,040 --> 00:02:52,028
మరో మాటలో చెప్పాలంటే, ఆ రెండవ చెక్ అడుగుతోంది, హే, నన్ను మళ్లీ,

47
00:02:52,028 --> 00:02:56,160
లోపం ఉంటే, ఆ స్థానం యొక్క రెండవ నుండి చివరి బిట్ 1నా?

48
00:02:56,160 --> 00:02:57,160
మరియు అందువలన న.

49
00:02:57,160 --> 00:03:03,524
మూడవ పారిటీ చెక్ మూడవ నుండి చివరి బిట్ ఆన్ చేయబడిన ప్రతి స్థానాన్ని కవర్ చేస్తుంది

50
00:03:03,524 --> 00:03:10,120
మరియు చివరిది చివరి ఎనిమిది స్థానాలను కవర్ చేస్తుంది, అత్యధిక ఆర్డర్ బిట్ 1గా ఉంటుంది.

51
00:03:10,120 --> 00:03:15,661
మేము ఇంతకు ముందు చేసినవన్నీ ఈ నాలుగు ప్రశ్నలకు సమాధానమివ్వడం వలెనే ఉంటాయి,

52
00:03:15,661 --> 00:03:19,800
ఇది బైనరీలో ఒక స్థానాన్ని స్పెల్లింగ్ చేయడం వలె ఉంటుంది.

53
00:03:19,800 --> 00:03:22,080
ఇది రెండు విషయాలను స్పష్టం చేస్తుందని నేను ఆశిస్తున్నాను.

54
00:03:22,080 --> 00:03:24,854
మొదటిది రెండు పెద్ద శక్తులు ఉండే పరిమాణాలను బ్లాక్

55
00:03:24,854 --> 00:03:27,140
చేయడానికి క్రమపద్ధతిలో సాధారణీకరించడం ఎలా.

56
00:03:27,140 --> 00:03:30,891
64 స్పాట్‌లను వివరించడానికి ఆరు బిట్‌ల వంటి ప్రతి స్థానాన్ని

57
00:03:30,891 --> 00:03:34,888
వివరించడానికి మరిన్ని బిట్‌లు తీసుకుంటే, ఆ బిట్‌లలో ప్రతి ఒక్కటి

58
00:03:34,888 --> 00:03:38,640
మేము తనిఖీ చేయాల్సిన సమాన సమూహాలలో ఒకదాన్ని మీకు అందిస్తుంది.

59
00:03:38,640 --> 00:03:43,400
మీలో మాట్ పార్కర్‌తో నేను చేసిన చదరంగం పజిల్‌ని చూసిన వారికి ఇవన్నీ బాగా తెలిసి ఉండవచ్చు.

60
00:03:43,400 --> 00:03:46,820
ఇది అదే ప్రధాన తర్కం, కానీ వేరొక సమస్యను పరిష్కరిస్తుంది

61
00:03:46,820 --> 00:03:49,880
మరియు 64-స్క్వేర్డ్ చెస్‌బోర్డ్‌కు వర్తించబడుతుంది.

62
00:03:49,880 --> 00:03:53,233
ఇది స్పష్టం చేస్తుందని నేను ఆశిస్తున్న రెండవ విషయం ఏమిటంటే,

63
00:03:53,233 --> 00:03:57,593
మా సమానత్వ బిట్‌లు రెండు శక్తులైన స్థానాల్లో ఎందుకు కూర్చున్నాయో, ఉదాహరణకు 1,

64
00:03:57,593 --> 00:03:58,320
2, 4 మరియు 8.

65
00:03:58,320 --> 00:04:03,640
బైనరీ ప్రాతినిధ్యం కేవలం ఒక్క బిట్ మాత్రమే ఆన్ చేసిన స్థానాలు ఇవి.

66
00:04:03,640 --> 00:04:08,575
దాని అర్థం ఏమిటంటే, ఆ పారిటీ బిట్‌లలో ప్రతి ఒక్కటి

67
00:04:08,575 --> 00:04:12,640
నాలుగు సమాన సమూహాలలో ఒకటి మాత్రమే ఉంటుంది.

68
00:04:12,640 --> 00:04:19,564
మీరు దీన్ని పెద్ద ఉదాహరణలలో కూడా చూడవచ్చు, ఇక్కడ మీరు ఎంత పెద్దదైనా సరే,

69
00:04:19,564 --> 00:04:25,920
ప్రతి పారిటీ బిట్ సౌకర్యవంతంగా సమూహాలలో ఒకదానిని మాత్రమే తాకుతుంది.

70
00:04:25,920 --> 00:04:30,445
మేము మా సమయాన్ని ఎక్కువగా కేంద్రీకరించిన ఈ సమానత్వ తనిఖీలు బైనరీలో లోపం యొక్క స్థానాన్ని

71
00:04:30,445 --> 00:04:34,411
వివరించడానికి ఒక తెలివైన మార్గం తప్ప మరేమీ కాదని మీరు అర్థం చేసుకున్న తర్వాత,

72
00:04:34,411 --> 00:04:38,581
మేము హామింగ్ గురించి ఆలోచించడానికి వేరొక మార్గంతో కనెక్షన్‌ని పొందవచ్చు. కోడ్‌లు,

73
00:04:38,581 --> 00:04:42,801
ఇది నిస్సందేహంగా చాలా సరళమైనది మరియు మరింత సొగసైనది మరియు ఇది ప్రాథమికంగా ఒకే లైన్

74
00:04:42,801 --> 00:04:43,920
కోడ్‌తో వ్రాయబడుతుంది.

75
00:04:43,920 --> 00:04:46,200
ఇది XOR ఫంక్షన్‌పై ఆధారపడి ఉంటుంది.

76
00:04:46,200 --> 00:04:50,960
XOR, మీలో తెలియని వారికి, ప్రత్యేకమైనది లేదా.

77
00:04:50,960 --> 00:04:55,219
మీరు రెండు బిట్‌ల XORను తీసుకున్నప్పుడు, ఆ బిట్‌లలో ఒకదానిని ఆన్

78
00:04:55,219 --> 00:05:00,200
చేసినట్లయితే అది 1ని తిరిగి ఇస్తుంది, కానీ రెండూ ఆన్ లేదా ఆఫ్ చేయబడితే కాదు.

79
00:05:00,200 --> 00:05:03,760
విభిన్నంగా పదబంధం, ఇది ఈ రెండు బిట్‌ల సమానత్వం.

80
00:05:03,760 --> 00:05:07,840
గణిత వ్యక్తిగా, నేను దాని గురించి అదనపు మోడ్ 2గా ఆలోచించాలనుకుంటున్నాను.

81
00:05:07,840 --> 00:05:11,348
మేము సాధారణంగా రెండు వేర్వేరు బిట్ స్ట్రింగ్‌ల XOR గురించి మాట్లాడుతాము,

82
00:05:11,348 --> 00:05:14,040
ఇది ప్రాథమికంగా ఈ కాంపోనెంట్‌ను కాంపోనెంట్‌గా చేస్తుంది.

83
00:05:14,040 --> 00:05:16,280
ఇది అదనంగా వంటిది, కానీ మీరు ఎక్కడికి తీసుకెళ్లలేరు.

84
00:05:16,280 --> 00:05:19,700
మళ్ళీ, గణితశాస్త్రపరంగా ఎక్కువ మొగ్గు ఉన్నవారు దీనిని రెండు

85
00:05:19,700 --> 00:05:23,520
వెక్టర్‌లను జోడించడం మరియు మోడ్ 2ను తగ్గించడం వంటిదిగా భావించవచ్చు.

86
00:05:23,520 --> 00:05:29,315
మీరు ప్రస్తుతం కొన్ని పైథాన్‌ని తెరిచి, రెండు పూర్ణాంకాల మధ్య కేరెట్ ఆపరేషన్‌ను

87
00:05:29,315 --> 00:05:35,400
వర్తింపజేస్తే, ఇది హుడ్ కింద ఉన్న ఆ సంఖ్యల బిట్ రిప్రజెంటేషన్‌లకు మాత్రమే చేస్తుంది.

88
00:05:35,400 --> 00:05:43,590
మీకు మరియు నాకు ముఖ్యమైన అంశం ఏమిటంటే, అనేక విభిన్న బిట్ స్ట్రింగ్‌ల యొక్క XOR తీసుకోవడం

89
00:05:43,590 --> 00:05:51,320
అనేది నిలువు వరుసల మాదిరిగానే, ప్రత్యేక సమూహాల యొక్క పేరడీలను గణించడానికి ఒక మార్గం.

90
00:05:51,320 --> 00:05:55,603
ఇది మా హామింగ్ కోడ్ అల్గారిథమ్ నుండి బహుళ పారిటీ చెక్‌ల గురించి ఆలోచించడానికి చాలా

91
00:05:55,603 --> 00:05:59,680
చురుకైన మార్గాన్ని అందిస్తుంది, ఎందుకంటే అన్నీ ఒకే ఆపరేషన్‌లో ప్యాక్ చేయబడతాయి.

92
00:05:59,680 --> 00:06:02,800
మొదటి చూపులో ఇది చాలా భిన్నంగా కనిపించినప్పటికీ.

93
00:06:02,800 --> 00:06:08,875
ప్రత్యేకంగా బైనరీలో 16 స్థానాలను వ్రాయండి, మనం ఇంతకు ముందు ఉన్నట్లుగా,

94
00:06:08,875 --> 00:06:14,094
ఇప్పుడు మెసేజ్ బిట్ 1కి ఆన్ చేయబడిన స్థానాలను హైలైట్ చేయండి,

95
00:06:14,094 --> 00:06:19,400
ఆపై ఈ స్థానాలను ఒక పెద్ద నిలువు వరుసలో సేకరించి XOR తీసుకోండి.

96
00:06:19,400 --> 00:06:23,962
ఫలితంగా దిగువన కూర్చున్న 4 బిట్‌లు మనకు తెలిసిన మరియు ఇష్టపడే

97
00:06:23,962 --> 00:06:28,230
4 పారిటీ చెక్‌ల మాదిరిగానే ఉంటాయని మీరు బహుశా ఊహించవచ్చు,

98
00:06:28,230 --> 00:06:32,720
అయితే సరిగ్గా ఎందుకు అని ఆలోచించడానికి కొంత సమయం కేటాయించండి.

99
00:06:32,720 --> 00:06:37,039
ఈ చివరి నిలువు వరుస, ఉదాహరణకు, చివరి బిట్ 1 ఉన్న అన్ని స్థానాలను గణిస్తోంది,

100
00:06:37,039 --> 00:06:40,742
కానీ మేము ఇప్పటికే హైలైట్ చేసిన స్థానాలకు మాత్రమే పరిమితం చేసాము,

101
00:06:40,742 --> 00:06:45,174
కాబట్టి ఇది మొదటి సమూహ సమూహం నుండి ఎన్ని హైలైట్ చేయబడిన స్థానాలను ప్రభావవంతంగా

102
00:06:45,174 --> 00:06:45,960
లెక్కిస్తుంది.

103
00:06:45,960 --> 00:06:48,520
అది సమంజసమా?

104
00:06:48,520 --> 00:06:53,575
అదేవిధంగా, తదుపరి నిలువు వరుస రెండవ సమాన సమూహంలో ఎన్ని స్థానాలు ఉన్నాయి,

105
00:06:53,575 --> 00:06:59,601
రెండవ నుండి చివరి బిట్ 1 వరకు ఉన్న స్థానాలు మరియు హైలైట్ చేయబడినవి మరియు మొదలైనవి కూడా

106
00:06:59,601 --> 00:07:00,640
లెక్కించబడతాయి.

107
00:07:00,640 --> 00:07:07,640
ఇది నిజంగా మనం చేస్తున్న అదే పనిపై దృష్టికోణంలో చిన్న మార్పు.

108
00:07:07,640 --> 00:07:10,000
మరియు అది ఇక్కడ నుండి ఎక్కడికి వెళుతుందో మీకు తెలుసు.

109
00:07:10,000 --> 00:07:14,483
మొత్తం 0000 వరకు పని చేస్తుందని నిర్ధారించుకోవడానికి కొన్ని

110
00:07:14,483 --> 00:07:19,640
ప్రత్యేక పారిటీ బిట్‌లను టోగుల్ చేయడానికి పంపినవారు బాధ్యత వహిస్తారు.

111
00:07:19,640 --> 00:07:22,570
ఇప్పుడు మనం దీన్ని ఇలా కలిగి ఉంటే, దిగువన ఉన్న ఈ నాలుగు ఫలిత

112
00:07:22,570 --> 00:07:25,693
బిట్‌లు నేరుగా లోపం యొక్క స్థానాన్ని ఎందుకు వివరిస్తాయి అనే దాని

113
00:07:25,693 --> 00:07:28,720
గురించి ఆలోచించడానికి ఇది మాకు నిజంగా మంచి మార్గాన్ని ఇస్తుంది.

114
00:07:28,720 --> 00:07:32,720
ఈ బ్లాక్‌లోని కొంత బిట్ 0 నుండి 1కి టోగుల్ చేయబడిందని అనుకుందాం.

115
00:07:32,720 --> 00:07:38,250
దీని అర్థం ఏమిటంటే, ఆ బిట్ యొక్క స్థానం ఇప్పుడు మొత్తం XORలో చేర్చబడుతుంది,

116
00:07:38,250 --> 00:07:44,800
ఇది మొత్తాన్ని 0 నుండి బదులుగా ఈ కొత్తగా చేర్చబడిన విలువ, లోపం యొక్క స్థానంగా మారుస్తుంది.

117
00:07:44,800 --> 00:07:49,800
కొంచెం తక్కువ స్పష్టంగా, 1 నుండి 0కి మార్చే లోపం ఉన్నట్లయితే అదే నిజం.

118
00:07:49,800 --> 00:07:54,287
మీరు చూడండి, మీరు ఒక బిట్ స్ట్రింగ్‌ని రెండుసార్లు కలిపితే,

119
00:07:54,287 --> 00:07:59,000
అది అక్కడ లేనట్లే, ప్రాథమికంగా ఈ ప్రపంచంలో 1 ప్లస్ 1 0కి సమానం.

120
00:07:59,000 --> 00:08:01,953
కాబట్టి మొత్తం మొత్తానికి ఈ స్థానం యొక్క కాపీని

121
00:08:01,953 --> 00:08:05,400
జోడించడం వలన మనం దానిని తరలిస్తున్నట్లే ప్రభావం ఉంటుంది.

122
00:08:05,400 --> 00:08:09,703
మరియు ఆ ప్రభావం, మళ్ళీ, ఇక్కడ దిగువన ఉన్న మొత్తం

123
00:08:09,703 --> 00:08:13,480
ఫలితం లోపం యొక్క స్థానాన్ని తెలియజేస్తుంది.

124
00:08:13,480 --> 00:08:17,854
ఇది ఎంత సొగసైనదో వివరించడానికి, నేను ఇంతకు ముందు ప్రస్తావించిన పైథాన్ కోడ్‌లోని

125
00:08:17,854 --> 00:08:22,120
ఒక లైన్‌ను చూపుతాను, ఇది రిసీవర్ చివరన దాదాపు అన్ని లాజిక్‌లను సంగ్రహిస్తుంది.

126
00:08:22,120 --> 00:08:26,268
మేము డేటా బ్లాక్‌ను అనుకరించడానికి 16 1సె మరియు 0 సె యాదృచ్ఛిక శ్రేణిని

127
00:08:26,268 --> 00:08:30,244
సృష్టించడం ద్వారా ప్రారంభిస్తాము మరియు నేను దానికి బిట్‌లను ఇస్తాను,

128
00:08:30,244 --> 00:08:34,451
అయితే ఆచరణలో ఇది మనం పంపినవారి నుండి స్వీకరించేదే అవుతుంది మరియు బదులుగా

129
00:08:34,451 --> 00:08:38,600
యాదృచ్ఛికంగా ఇది 5 పారిటీ బిట్‌లతో కలిపి 11 డేటా బిట్‌లను కలిగి ఉంటుంది.

130
00:08:38,600 --> 00:08:45,302
నేను ఫంక్షన్ enumerateBits అని పిలిస్తే, అది చేసేది ఆ బిట్‌లను సంబంధిత సూచికతో జత చేయడం,

131
00:08:45,302 --> 00:08:48,240
ఈ సందర్భంలో 0 నుండి 15 వరకు నడుస్తుంది.

132
00:08:48,240 --> 00:08:52,293
కాబట్టి మనం ఈ అన్ని జతలపై లూప్ చేసే జాబితాను సృష్టించినట్లయితే,

133
00:08:52,293 --> 00:08:57,043
i లాగా కనిపించే జంటలు, ఆపై మేము కేవలం i విలువను, కేవలం సూచికను తీసివేస్తే,

134
00:08:57,043 --> 00:09:01,920
అది అంత ఉత్తేజకరమైనది కాదు, మేము ఆ సూచికలను 0 నుండి 15 వరకు తిరిగి పొందుతాము.

135
00:09:01,920 --> 00:09:06,392
కానీ మనం దీన్ని బిట్ అయితే మాత్రమే చేయాలనే షరతును జోడిస్తే,

136
00:09:06,392 --> 00:09:12,207
అంటే ఆ బిట్ 1 మరియు 0 కాకపోతే, అది సంబంధిత బిట్ ఆన్ చేయబడిన స్థానాలను మాత్రమే

137
00:09:12,207 --> 00:09:13,400
బయటకు తీస్తుంది.

138
00:09:13,400 --> 00:09:20,720
ఈ సందర్భంలో ఆ స్థానాలు 0, 4, 6, 9, మొదలైనవి ఉన్నట్లు కనిపిస్తోంది.

139
00:09:20,720 --> 00:09:27,561
మనకు కావలసినది ఏమిటంటే, ఆ స్థానాలు, ఆన్ చేయబడిన బిట్‌ల స్థానాలు అన్నీ కలిపి,

140
00:09:27,561 --> 00:09:29,960
ఆపై వాటిని కలిపి XOR చేయడం.

141
00:09:29,960 --> 00:09:33,960
పైథాన్‌లో దీన్ని చేయడానికి, నేను ముందుగా ఒక జంట సహాయక ఫంక్షన్‌లను దిగుమతి చేస్తాను.

142
00:09:33,960 --> 00:09:36,403
ఆ విధంగా మనం ఈ జాబితాలో తగ్గించు() అని పిలుస్తాము

143
00:09:36,403 --> 00:09:39,140
మరియు దానిని తగ్గించడానికి XOR ఫంక్షన్‌ని ఉపయోగించవచ్చు.

144
00:09:39,140 --> 00:09:44,840
ఇది ప్రాథమికంగా జాబితా ద్వారా దాని మార్గాన్ని తింటుంది, మార్గం వెంట XORలను తీసుకుంటుంది.

145
00:09:44,840 --> 00:09:48,443
మీరు కావాలనుకుంటే, మీరు ఎక్కడి నుండైనా దిగుమతి

146
00:09:48,443 --> 00:09:52,200
చేయకుండానే ఆ XOR ఫంక్షన్‌ని స్పష్టంగా వ్రాయవచ్చు.

147
00:09:52,200 --> 00:09:57,514
కాబట్టి ప్రస్తుతానికి మనం దీన్ని 16 బిట్‌ల యాదృచ్ఛిక బ్లాక్‌లో చేస్తే,

148
00:09:57,514 --> 00:10:02,080
అది బైనరీ ప్రాతినిధ్యం 1001ని కలిగి ఉన్న 9ని తిరిగి ఇస్తుంది.

149
00:10:02,080 --> 00:10:07,040
మేము దీన్ని ఇక్కడ చేయము, కానీ పంపినవారు నాలుగు పారిటీ బిట్‌లను అవసరమైన విధంగా సెట్

150
00:10:07,040 --> 00:10:11,462
చేయడానికి బైనరీ ప్రాతినిధ్యాన్ని ఉపయోగించే ఒక ఫంక్షన్‌ను మీరు వ్రాయవచ్చు,

151
00:10:11,462 --> 00:10:16,841
చివరికి ఈ బ్లాక్‌ని బిట్‌ల పూర్తి జాబితాలో ఈ లైన్ కోడ్‌ని అమలు చేసే స్థితికి చేరుకుంటుంది.

152
00:10:16,841 --> 00:10:17,200
ఒక 0.

153
00:10:17,200 --> 00:10:20,200
ఇది బాగా సిద్ధమైన బ్లాక్‌గా పరిగణించబడుతుంది.

154
00:10:20,200 --> 00:10:23,965
మంచి విషయం ఏమిటంటే, శబ్దం నుండి యాదృచ్ఛిక లోపాన్ని అనుకరిస్తూ,

155
00:10:23,965 --> 00:10:28,866
ఈ జాబితాలోని ఏదైనా బిట్‌లను మనం టోగుల్ చేస్తే, మీరు ఇదే లైన్ కోడ్‌ను అమలు చేస్తే,

156
00:10:28,866 --> 00:10:30,600
అది ఆ లోపాన్ని ముద్రిస్తుంది.

157
00:10:30,600 --> 00:10:31,920
అది చక్కగా లేదా?

158
00:10:31,920 --> 00:10:37,522
మీరు ఈ బ్లాక్‌ను నీలిరంగు నుండి పొందవచ్చు, దానిపై ఈ సింగిల్ లైన్‌ను అమలు చేయవచ్చు

159
00:10:37,522 --> 00:10:42,920
మరియు అది స్వయంచాలకంగా లోపం యొక్క స్థానం లేదా ఏదైనా లేకుంటే 0ని ఉమ్మివేస్తుంది.

160
00:10:42,920 --> 00:10:45,520
మరియు ఇక్కడ పరిమాణం 16 గురించి ప్రత్యేకంగా ఏమీ లేదు.

161
00:10:45,520 --> 00:10:52,280
మీరు 256 బిట్‌ల జాబితాను కలిగి ఉంటే అదే లైన్ కోడ్ పని చేస్తుంది.

162
00:10:52,280 --> 00:10:56,740
2-బిట్ ఎర్రర్‌లను గుర్తించడానికి మెటా పారిటీ చెక్ చేయడం వంటి మరిన్ని

163
00:10:56,740 --> 00:11:00,166
కోడ్‌లు ఇక్కడ వ్రాయాలని ప్రత్యేకంగా చెప్పనవసరం లేదు,

164
00:11:00,166 --> 00:11:05,080
అయితే మా స్కీమ్‌లోని దాదాపు అన్ని కోర్ లాజిక్‌లు ఒకే XOR తగ్గింపుకు వస్తాయి.

165
00:11:05,080 --> 00:11:10,054
ఇప్పుడు, బైనరీ మరియు XORలు మరియు సాధారణంగా సాఫ్ట్‌వేర్‌తో మీ సౌకర్యాన్ని బట్టి,

166
00:11:10,054 --> 00:11:15,029
మీరు ఈ దృక్పథాన్ని కొంచెం గందరగోళంగా లేదా చాలా సొగసైన మరియు సరళంగా కనుగొనవచ్చు,

167
00:11:15,029 --> 00:11:19,320
మేము దీన్ని ఎందుకు ప్రారంభించలేదని మీరు ఆశ్చర్యపోతున్నారు. -వెళ్ళండి.

168
00:11:19,320 --> 00:11:23,543
వదులుగా చెప్పాలంటే, హార్డ్‌వేర్‌లో హామింగ్ కోడ్‌లను నేరుగా అమలు చేసేటప్పుడు

169
00:11:23,543 --> 00:11:26,378
బహుళ పారిటీ తనిఖీ దృక్పథం గురించి ఆలోచించడం సులభం,

170
00:11:26,378 --> 00:11:31,380
మరియు XOR దృక్పథాన్ని సాఫ్ట్‌వేర్‌లో చేసేటప్పుడు, ఉన్నత స్థాయి నుండి ఆలోచించడం చాలా సులభం.

171
00:11:31,380 --> 00:11:36,114
మొదటిది వాస్తవానికి చేతితో చేయడం చాలా సులభం, మరియు వీటన్నింటికీ అంతర్లీనంగా ఉన్న

172
00:11:36,114 --> 00:11:40,381
ప్రధాన అంతర్ దృష్టిని కలిగించడం మంచి పని చేస్తుందని నేను భావిస్తున్నాను,

173
00:11:40,381 --> 00:11:44,940
అంటే ఒకే లోపాన్ని గుర్తించడానికి అవసరమైన సమాచారం బ్లాక్ పరిమాణం యొక్క లాగ్‌కు

174
00:11:44,940 --> 00:11:50,084
సంబంధించినది. , లేదా మరో మాటలో చెప్పాలంటే, బ్లాక్ సైజు రెట్టింపు అయ్యే కొద్దీ ఒక్కోసారి

175
00:11:50,084 --> 00:11:51,020
అది పెరుగుతుంది.

176
00:11:51,020 --> 00:11:53,703
ఇక్కడ సంబంధిత వాస్తవం ఏమిటంటే, ఆ సమాచారం మనకు ఎంత

177
00:11:53,703 --> 00:11:56,440
రిడెండెన్సీ అవసరమో దానికి నేరుగా అనుగుణంగా ఉంటుంది.

178
00:11:56,440 --> 00:12:00,149
చాలా మంది వ్యక్తుల యొక్క మోకాలి కుదుపు ప్రతిచర్యకు వ్యతిరేకంగా జరిగేది అదే,

179
00:12:00,149 --> 00:12:03,810
వారు ఒక సందేశాన్ని లోపాలను తట్టుకునేలా చేయడం గురించి మొదట ఆలోచించినప్పుడు,

180
00:12:03,810 --> 00:12:07,520
సాధారణంగా మొత్తం సందేశాన్ని కాపీ చేయడం అనేది గుర్తుకు వచ్చే మొదటి ప్రవృత్తి.

181
00:12:07,520 --> 00:12:11,089
ఆపై, మార్గం ద్వారా, మీరు కొన్నిసార్లు హామింగ్ కోడ్‌లను ప్రదర్శించే ఈ మొత్తం

182
00:12:11,089 --> 00:12:14,800
ఇతర మార్గం ఉంది, ఇక్కడ మీరు సందేశాన్ని ఒక పెద్ద మ్యాట్రిక్స్ ద్వారా గుణిస్తారు.

183
00:12:14,800 --> 00:12:18,913
ఇది చాలా బాగుంది ఎందుకంటే ఇది సరళ కోడ్‌ల యొక్క విస్తృత కుటుంబానికి సంబంధించినది,

184
00:12:18,913 --> 00:12:22,214
కానీ అది ఎక్కడ నుండి వస్తుంది లేదా ఎలా స్కేల్ చేస్తుంది అనే దాని

185
00:12:22,214 --> 00:12:25,160
గురించి దాదాపు అంతర్ దృష్టిని ఇవ్వదని నేను భావిస్తున్నాను.

186
00:12:25,160 --> 00:12:29,004
మరియు స్కేలింగ్ గురించి చెప్పాలంటే, మేము బ్లాక్ పరిమాణాన్ని పెంచుతున్నప్పుడు

187
00:12:29,004 --> 00:12:32,200
మాత్రమే ఈ పథకం యొక్క సామర్థ్యం మెరుగుపడుతుందని మీరు గమనించవచ్చు.

188
00:12:32,200 --> 00:12:37,840
ఉదాహరణకు, 256 బిట్‌లతో, మీరు రిడెండెన్సీ కోసం ఆ స్థలంలో 3% మాత్రమే

189
00:12:37,840 --> 00:12:43,480
ఉపయోగిస్తున్నారని మేము చూశాము మరియు అది అక్కడ నుండి మెరుగుపడుతోంది.

190
00:12:43,480 --> 00:12:46,683
పారిటీ బిట్‌ల సంఖ్య ఒక్కొక్కటిగా పెరుగుతున్న కొద్దీ,

191
00:12:46,683 --> 00:12:49,040
బ్లాక్ పరిమాణం రెట్టింపు అవుతూ ఉంటుంది.

192
00:12:49,040 --> 00:12:54,055
మరియు మీరు దానిని విపరీతంగా తీసుకుంటే, మీరు మిలియన్ బిట్‌లతో బ్లాక్‌ను కలిగి ఉండవచ్చు,

193
00:12:54,055 --> 00:12:57,860
ఇక్కడ మీరు మీ పారిటీ తనిఖీలతో అక్షరాలా 20 ప్రశ్నలను ప్లే చేస్తారు

194
00:12:57,860 --> 00:13:00,800
మరియు ఇది 21 పారిటీ బిట్‌లను మాత్రమే ఉపయోగిస్తుంది.

195
00:13:00,800 --> 00:13:04,522
మరియు మీరు మిలియన్ బిట్‌లను చూడటం మరియు ఒక్క ఎర్రర్‌ను గుర్తించడం

196
00:13:04,522 --> 00:13:08,640
గురించి ఆలోచించడానికి వెనుకడుగు వేస్తే, అది నిజంగా పిచ్చిగా అనిపిస్తుంది.

197
00:13:08,640 --> 00:13:13,405
సమస్య ఏమిటంటే, పెద్ద బ్లాక్‌తో, ఒకటి లేదా రెండు కంటే ఎక్కువ బిట్ ఎర్రర్‌లను

198
00:13:13,405 --> 00:13:18,360
చూసే సంభావ్యత పెరుగుతుంది మరియు హామింగ్ కోడ్‌లు అంతకు మించి దేనినీ నిర్వహించవు.

199
00:13:18,360 --> 00:13:22,271
కాబట్టి ఆచరణలో, మీకు కావలసినది సరైన పరిమాణాన్ని కనుగొనడం,

200
00:13:22,271 --> 00:13:26,520
తద్వారా చాలా ఎక్కువ బిట్ ఫ్లిప్‌ల సంభావ్యత చాలా ఎక్కువగా ఉండదు.

201
00:13:26,520 --> 00:13:32,935
అలాగే, ఆచరణలో, లోపాలు చిన్న పేలుళ్లలో వస్తాయి, ఇది ఒక బ్లాక్‌ను పూర్తిగా నాశనం చేస్తుంది,

202
00:13:32,935 --> 00:13:38,779
కాబట్టి అనేక విభిన్న బ్లాక్‌లలో లోపాలను వ్యాప్తి చేయడంలో సహాయపడే ఒక సాధారణ వ్యూహం

203
00:13:38,779 --> 00:13:42,700
ఏమిటంటే, ఆ బ్లాక్‌లను వాటి ముందు ఇలా ఇంటర్‌లేస్ చేయడం.

204
00:13:42,700 --> 00:13:45,480
బయటకు పంపబడింది లేదా నిల్వ చేయబడుతుంది.

205
00:13:45,480 --> 00:13:50,236
మరలా, చాలా సాధారణంగా ఉపయోగించే రీడ్-సోలమన్ అల్గోరిథం వంటి ఆధునిక కోడ్‌ల ద్వారా చాలా

206
00:13:50,236 --> 00:13:55,049
వరకు పూర్తిగా మూట్ చేయబడింది, ఇది బరస్ట్ ఎర్రర్‌లను ప్రత్యేకంగా నిర్వహిస్తుంది మరియు

207
00:13:55,049 --> 00:13:59,580
ప్రతి బ్లాక్‌కు పెద్ద సంఖ్యలో ఎర్రర్‌లకు స్థితిస్థాపకంగా ఉండేలా ట్యూన్ చేయవచ్చు.

208
00:13:59,580 --> 00:14:03,000
కానీ అది మరొక సారి చర్చనీయాంశం.

209
00:14:03,000 --> 00:14:06,434
అతని పుస్తకం ది ఆర్ట్ ఆఫ్ డూయింగ్ సైన్స్ అండ్ ఇంజినీరింగ్‌లో,

210
00:14:06,434 --> 00:14:10,700
హామింగ్ ఈ కోడ్‌ని తన కనిపెట్టడం ఎంత మెలికలు తిరిగిపోయిందో అద్భుతంగా చెప్పాడు.

211
00:14:10,700 --> 00:14:14,639
అతను మొదట బిట్‌లను అధిక డైమెన్షనల్ లాటిస్‌లోని భాగాలుగా నిర్వహించడం మరియు

212
00:14:14,639 --> 00:14:18,420
ఇలాంటి వింత విషయాలతో కూడిన అన్ని రకాల విభిన్న స్కీమ్‌లను ప్రయత్నించాడు.

213
00:14:18,420 --> 00:14:22,723
లోపం యొక్క స్థితిని వివరించే విధంగా కుట్ర చేయడానికి సమానత్వ తనిఖీలను పొందడం

214
00:14:22,723 --> 00:14:27,537
సాధ్యమవుతుందనే ఆలోచన హామింగ్‌కు వచ్చినప్పుడు అతను ఇతర విశ్లేషణల సమూహం తర్వాత వెనక్కి

215
00:14:27,537 --> 00:14:31,387
వెళ్లి, సరే, నేను చేయగలిగిన అత్యంత సమర్థవంతమైనది ఏమిటి అని అడిగాడు.

216
00:14:31,387 --> 00:14:32,860
దీని గురించి ఆలోచించవచ్చా?

217
00:14:32,860 --> 00:14:37,304
1940 లలో ఈనాటి కంటే తక్కువ సాధారణం అయ్యే పారిటీ తనిఖీలు అతని

218
00:14:37,304 --> 00:14:42,040
మనస్సులో ఇప్పటికే ఉండటం ఎంత ముఖ్యమో కూడా అతను నిజాయితీగా ఉన్నాడు.

219
00:14:42,040 --> 00:14:46,876
అతను లూయిస్ పాశ్చర్ కోట్‌ను ప్రస్తావించిన అరడజను సార్లు ఈ పుస్తకంలో ఉన్నాయి,

220
00:14:46,876 --> 00:14:49,640
అదృష్టం సిద్ధమైన మనస్సుకు అనుకూలంగా ఉంటుంది.

221
00:14:49,640 --> 00:14:52,836
తెలివైన ఆలోచనలు తరచుగా వెనుకకు చూస్తే మోసపూరితంగా సరళంగా కనిపిస్తాయి,

222
00:14:52,836 --> 00:14:55,120
ఇది వాటిని తక్కువ అంచనా వేయడానికి సులభం చేస్తుంది.

223
00:14:55,120 --> 00:14:58,377
హామింగ్ కోడ్‌లు లేదా కనీసం అలాంటి కోడ్‌ల అవకాశం మీకు

224
00:14:58,377 --> 00:15:01,820
దాదాపు స్పష్టంగా కనిపిస్తుందని ప్రస్తుతం నా నిజాయితీ ఆశ.

225
00:15:01,820 --> 00:15:06,367
అయితే అవి స్పష్టంగా కనిపిస్తున్నాయని భావించి మిమ్మల్ని మీరు మోసం చేసుకోకూడదు,

226
00:15:06,367 --> 00:15:08,000
ఎందుకంటే అవి ఖచ్చితంగా కావు.

227
00:15:08,000 --> 00:15:11,516
తెలివైన ఆలోచనలు మోసపూరితంగా తేలికగా కనిపించడానికి ఒక కారణం ఏమిటంటే,

228
00:15:11,516 --> 00:15:15,757
మనం ఎప్పుడైనా తుది ఫలితాన్ని మాత్రమే చూస్తాము, గజిబిజిగా ఉన్నవాటిని శుభ్రం చేయడం,

229
00:15:15,757 --> 00:15:18,291
తప్పు మలుపులన్నింటినీ ఎప్పుడూ ప్రస్తావించకపోవడం,

230
00:15:18,291 --> 00:15:22,428
సమస్య ప్రారంభంలో అన్వేషించదగిన అవకాశాల స్థలం ఎంత విశాలంగా ఉందో తక్కువగా అమ్మడం.

231
00:15:22,428 --> 00:15:23,980
పరిష్కార ప్రక్రియ, అన్నింటినీ.

232
00:15:23,980 --> 00:15:25,280
కానీ ఇది సాధారణంగా నిజం.

233
00:15:25,280 --> 00:15:29,103
కొన్ని ప్రత్యేక ఆవిష్కరణల కోసం, మనం వాటిని తక్కువగా అంచనా వేయడానికి రెండవ,

234
00:15:29,103 --> 00:15:31,040
లోతైన కారణం ఉందని నేను భావిస్తున్నాను.

235
00:15:31,040 --> 00:15:35,306
సమాచార సిద్ధాంతంపై క్లాడ్ షానన్ యొక్క సెమినల్ పేపర్‌తో 1948 నాటికి బిట్‌ల

236
00:15:35,306 --> 00:15:39,400
పరంగా సమాచారం గురించి ఆలోచించడం నిజంగా పూర్తి సిద్ధాంతంగా కలిసిపోయింది.

237
00:15:39,400 --> 00:15:43,440
హామింగ్ తన అల్గారిథమ్‌ను అభివృద్ధి చేసినప్పుడు ఇది తప్పనిసరిగా సమానంగా ఉంటుంది.

238
00:15:43,440 --> 00:15:48,840
బిట్ ఫ్లిప్‌ల సంభావ్యత ఎంత ఎక్కువగా ఉన్నా, కనీసం థియరీలో అయినా సమర్థవంతమైన లోపాన్ని

239
00:15:48,840 --> 00:15:53,920
సరిదిద్దడం ఎల్లప్పుడూ సాధ్యమేనని ఒక నిర్దిష్ట కోణంలో చూపించిన అదే పునాది పేపర్.

240
00:15:53,920 --> 00:15:57,641
షానన్ మరియు హామింగ్, చాలా భిన్నమైన విషయాలపై పనిచేసినప్పటికీ,

241
00:15:57,641 --> 00:16:02,400
బెల్ ల్యాబ్స్‌లో కార్యాలయాన్ని పంచుకున్నారు, ఇది ఇక్కడ యాదృచ్ఛికంగా కనిపించదు.

242
00:16:02,400 --> 00:16:05,686
కొన్ని దశాబ్దాలుగా ఫాస్ట్ ఫార్వార్డ్, మరియు ఈ రోజుల్లో,

243
00:16:05,686 --> 00:16:09,793
మనలో చాలా మంది బిట్స్ మరియు సమాచారం గురించి ఆలోచించడంలో మునిగిపోయారు,

244
00:16:09,793 --> 00:16:13,080
ఈ ఆలోచనా విధానం ఎంత విభిన్నంగా ఉందో పట్టించుకోవడం సులభం.

245
00:16:13,080 --> 00:16:15,535
హాస్యాస్పదంగా, భవిష్యత్ తరం ఆలోచించే మార్గాలను చాలా లోతుగా రూపొందించే

246
00:16:15,535 --> 00:16:17,920
ఆలోచనలు ఆ భవిష్యత్తు తరానికి నిజంగా ఉన్నదానికంటే సరళంగా కనిపిస్తాయి.

