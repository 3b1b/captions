1
00:00:00,000 --> 00:00:03,120
ఇక్కడ అందరూ పార్ట్ 1 నుండి వస్తున్నారని నేను ఊహిస్తున్నాను.

2
00:00:03,120 --> 00:00:07,878
మేము హామింగ్ కోడ్‌ల గురించి మాట్లాడుతున్నాము, చాలా బిట్‌లు అర్థవంతమైన సందేశాన్ని

3
00:00:07,878 --> 00:00:12,402
కలిగి ఉండే డేటా బ్లాక్‌ను సృష్టించే మార్గం, మరికొన్ని ఒక రకమైన రిడెండెన్సీగా

4
00:00:12,402 --> 00:00:17,102
పనిచేస్తాయి, ఆ విధంగా ఏదైనా బిట్ తిప్పబడితే, సందేశం బిట్ లేదా రిడెండెన్సీ బిట్,

5
00:00:17,102 --> 00:00:21,920
ఈ బ్లాక్‌లో ఏదైనా, రిసీవర్ లోపం ఉందని మరియు దాన్ని ఎలా పరిష్కరించాలో గుర్తించగలదు.

6
00:00:21,920 --> 00:00:26,509
బైనరీ శోధన కోసం బహుళ పారిటీ తనిఖీలను ఎలా ఉపయోగించాలి

7
00:00:26,509 --> 00:00:29,800
అనేది అక్కడ అందించబడిన ప్రాథమిక ఆలోచన.

8
00:00:29,800 --> 00:00:32,830
ఆ వీడియోలో హామింగ్ కోడ్‌లను సాధ్యమైనంత వరకు అందుబాటులో

9
00:00:32,830 --> 00:00:35,420
ఉంచడం మరియు తిరిగి కనుగొనగలిగేలా చేయడం లక్ష్యం.

10
00:00:35,420 --> 00:00:39,292
సాఫ్ట్‌వేర్ లేదా హార్డ్‌వేర్‌లో దీన్ని అమలు చేయడం గురించి మీరు ఆలోచించడం

11
00:00:39,292 --> 00:00:43,695
ప్రారంభించినప్పుడు, ఈ కోడ్‌లు నిజంగా ఎంత సొగసైనవో ఆ ఫ్రేమింగ్ వాస్తవానికి తక్కువగా

12
00:00:43,695 --> 00:00:44,120
ఉంటుంది.

13
00:00:44,120 --> 00:00:47,290
సాధ్యమయ్యే అన్ని ఎర్రర్ లొకేషన్‌లను ట్రాక్ చేసే మరియు ప్రతి

14
00:00:47,290 --> 00:00:50,778
చెక్‌తో ఆ సమూహాన్ని సగానికి తగ్గించే అల్గారిథమ్‌ను మీరు వ్రాయవలసి

15
00:00:50,778 --> 00:00:54,160
ఉంటుందని మీరు అనుకోవచ్చు, అయితే ఇది నిజానికి దాని కంటే సరళమైనది.

16
00:00:54,160 --> 00:00:59,389
మేము చివరి వీడియోలో చేసిన నాలుగు సమానత్వ తనిఖీలకు సమాధానాలను మీరు చదివితే, అవును మరియు

17
00:00:59,389 --> 00:01:04,800
సంఖ్యలకు బదులుగా 1 సె మరియు 0 సె, ఇది బైనరీలో లోపం యొక్క స్థానాన్ని అక్షరాలా వివరిస్తుంది.

18
00:01:04,800 --> 00:01:08,926
ఉదాహరణకు, బైనరీలో 7 సంఖ్య 0111 లాగా కనిపిస్తుంది,

19
00:01:08,926 --> 00:01:12,640
ముఖ్యంగా ఇది 4 ప్లస్ 2 ప్లస్ 1 అని చెబుతోంది.

20
00:01:12,640 --> 00:01:17,058
మరియు స్థానం 7 ఎక్కడ కూర్చుందో గమనించండి, ఇది మా సమానత్వ సమూహాలలో

21
00:01:17,058 --> 00:01:22,280
మొదటిదానిని ప్రభావితం చేస్తుంది మరియు రెండవది మరియు మూడవది, కానీ చివరిది కాదు.

22
00:01:22,280 --> 00:01:25,463
కాబట్టి ఆ నాలుగు చెక్‌ల ఫలితాలను దిగువ నుండి పైకి

23
00:01:25,463 --> 00:01:28,520
చదవడం నిజంగా లోపం యొక్క స్థితిని తెలియజేస్తుంది.

24
00:01:28,520 --> 00:01:32,657
ఉదాహరణ 7 గురించి ప్రత్యేకంగా ఏమీ లేదు, ఇది సాధారణంగా పని చేస్తుంది మరియు ఇది

25
00:01:32,657 --> 00:01:37,440
హార్డ్‌వేర్‌లో మొత్తం పథకాన్ని అమలు చేయడానికి తర్కాన్ని దిగ్భ్రాంతికరంగా సులభం చేస్తుంది.

26
00:01:37,440 --> 00:01:41,697
ఇప్పుడు మీరు ఈ మాయాజాలం ఎందుకు జరుగుతుందో చూడాలనుకుంటే, మా స్థానాల

27
00:01:41,697 --> 00:01:46,272
కోసం ఈ 16 సూచిక లేబుల్‌లను తీసుకోండి, కానీ వాటిని బేస్ 10లో వ్రాయడానికి

28
00:01:46,272 --> 00:01:50,720
బదులుగా, 0000 నుండి 1111 వరకు నడుస్తున్న బైనరీలో అన్నింటినీ వ్రాస్దాం.

29
00:01:50,720 --> 00:01:54,233
మేము ఈ బైనరీ లేబుల్‌లను వాటి పెట్టెల్లోకి తిరిగి ఉంచినప్పుడు, అవి

30
00:01:54,233 --> 00:01:58,440
వాస్తవానికి పంపబడుతున్న డేటా నుండి విభిన్నంగా ఉన్నాయని నేను నొక్కిచెబుతున్నాను.

31
00:01:58,440 --> 00:02:01,410
నాలుగు సమానత్వ సమూహాలు ఎక్కడ నుండి వచ్చాయో అర్థం చేసుకోవడంలో మీకు

32
00:02:01,410 --> 00:02:04,200
మరియు నాకు సహాయం చేయడానికి అవి సంభావిత లేబుల్ తప్ప మరేమీ కాదు.

33
00:02:04,200 --> 00:02:08,398
మనం చూస్తున్న ప్రతిదీ బైనరీలో వర్ణించబడటం యొక్క సొగసైనది బహుశా మనం

34
00:02:08,398 --> 00:02:13,160
చూస్తున్న ప్రతిదాన్ని బైనరీలో వివరించడం వల్ల కలిగే గందరగోళం వల్ల తగ్గుతుంది.

35
00:02:13,160 --> 00:02:15,040
అయితే ఇది విలువైనదే.

36
00:02:15,040 --> 00:02:19,232
ఈ లేబుల్‌లన్నింటిలో చివరి బిట్‌పై మాత్రమే మీ దృష్టిని

37
00:02:19,232 --> 00:02:24,280
కేంద్రీకరించండి, ఆపై ఆ చివరి బిట్ 1 ఉన్న స్థానాలను హైలైట్ చేయండి.

38
00:02:24,280 --> 00:02:30,092
మేము పొందేది మా నాలుగు సమానత్వ సమూహాలలో మొదటిది, అంటే మీరు ఆ మొదటి చెక్‌ని

39
00:02:30,092 --> 00:02:36,680
అడుగుతున్నట్లు అర్థం చేసుకోవచ్చు, హే, లోపం ఉన్నట్లయితే, ఆ లోపం యొక్క స్థానం 1గా ఉందా?

40
00:02:36,680 --> 00:02:41,860
అదేవిధంగా, మీరు రెండవ నుండి చివరి బిట్‌పై దృష్టి సారించి, అది 1 ఉన్న అన్ని

41
00:02:41,860 --> 00:02:47,040
స్థానాలను హైలైట్ చేస్తే, మీరు మా పథకం నుండి రెండవ సమాన సమూహాన్ని పొందుతారు.

42
00:02:47,040 --> 00:02:51,483
మరో మాటలో చెప్పాలంటే, ఆ రెండవ చెక్ అడుగుతోంది, హే, నన్ను

43
00:02:51,483 --> 00:02:56,160
మళ్లీ, లోపం ఉంటే, ఆ స్థానం యొక్క రెండవ నుండి చివరి బిట్ 1నా?

44
00:02:56,160 --> 00:02:57,160
మరియు అందువలన న.

45
00:02:57,160 --> 00:03:03,524
మూడవ పారిటీ చెక్ మూడవ నుండి చివరి బిట్ ఆన్ చేయబడిన ప్రతి స్థానాన్ని కవర్ చేస్తుంది

46
00:03:03,524 --> 00:03:10,120
మరియు చివరిది చివరి ఎనిమిది స్థానాలను కవర్ చేస్తుంది, అత్యధిక ఆర్డర్ బిట్ 1గా ఉంటుంది.

47
00:03:10,120 --> 00:03:15,070
మేము ఇంతకు ముందు చేసినవన్నీ ఈ నాలుగు ప్రశ్నలకు సమాధానమివ్వడం వలెనే

48
00:03:15,070 --> 00:03:19,800
ఉంటాయి, ఇది బైనరీలో ఒక స్థానాన్ని స్పెల్లింగ్ చేయడం వలె ఉంటుంది.

49
00:03:19,800 --> 00:03:22,080
ఇది రెండు విషయాలను స్పష్టం చేస్తుందని నేను ఆశిస్తున్నాను.

50
00:03:22,080 --> 00:03:24,854
మొదటిది రెండు పెద్ద శక్తులు ఉండే పరిమాణాలను బ్లాక్

51
00:03:24,854 --> 00:03:27,140
చేయడానికి క్రమపద్ధతిలో సాధారణీకరించడం ఎలా.

52
00:03:27,140 --> 00:03:30,891
64 స్పాట్‌లను వివరించడానికి ఆరు బిట్‌ల వంటి ప్రతి స్థానాన్ని

53
00:03:30,891 --> 00:03:34,888
వివరించడానికి మరిన్ని బిట్‌లు తీసుకుంటే, ఆ బిట్‌లలో ప్రతి ఒక్కటి

54
00:03:34,888 --> 00:03:38,640
మేము తనిఖీ చేయాల్సిన సమాన సమూహాలలో ఒకదాన్ని మీకు అందిస్తుంది.

55
00:03:38,640 --> 00:03:43,400
మీలో మాట్ పార్కర్‌తో నేను చేసిన చదరంగం పజిల్‌ని చూసిన వారికి ఇవన్నీ బాగా తెలిసి ఉండవచ్చు.

56
00:03:43,400 --> 00:03:46,820
ఇది అదే ప్రధాన తర్కం, కానీ వేరొక సమస్యను పరిష్కరిస్తుంది

57
00:03:46,820 --> 00:03:49,880
మరియు 64-స్క్వేర్డ్ చెస్‌బోర్డ్‌కు వర్తించబడుతుంది.

58
00:03:49,880 --> 00:03:53,848
ఇది స్పష్టం చేస్తుందని నేను ఆశిస్తున్న రెండవ విషయం ఏమిటంటే, మా సమానత్వ

59
00:03:53,848 --> 00:03:58,320
బిట్‌లు రెండు శక్తులైన స్థానాల్లో ఎందుకు కూర్చున్నాయో, ఉదాహరణకు 1, 2, 4 మరియు 8.

60
00:03:58,320 --> 00:04:03,640
బైనరీ ప్రాతినిధ్యం కేవలం ఒక్క బిట్ మాత్రమే ఆన్ చేసిన స్థానాలు ఇవి.

61
00:04:03,640 --> 00:04:08,575
దాని అర్థం ఏమిటంటే, ఆ పారిటీ బిట్‌లలో ప్రతి ఒక్కటి

62
00:04:08,575 --> 00:04:12,640
నాలుగు సమాన సమూహాలలో ఒకటి మాత్రమే ఉంటుంది.

63
00:04:12,640 --> 00:04:19,090
మీరు దీన్ని పెద్ద ఉదాహరణలలో కూడా చూడవచ్చు, ఇక్కడ మీరు ఎంత పెద్దదైనా

64
00:04:19,090 --> 00:04:25,920
సరే, ప్రతి పారిటీ బిట్ సౌకర్యవంతంగా సమూహాలలో ఒకదానిని మాత్రమే తాకుతుంది.

65
00:04:25,920 --> 00:04:30,445
మేము మా సమయాన్ని ఎక్కువగా కేంద్రీకరించిన ఈ సమానత్వ తనిఖీలు బైనరీలో లోపం యొక్క స్థానాన్ని

66
00:04:30,445 --> 00:04:34,665
వివరించడానికి ఒక తెలివైన మార్గం తప్ప మరేమీ కాదని మీరు అర్థం చేసుకున్న తర్వాత, మేము

67
00:04:34,665 --> 00:04:38,784
హామింగ్ గురించి ఆలోచించడానికి వేరొక మార్గంతో కనెక్షన్‌ని పొందవచ్చు. కోడ్‌లు, ఇది

68
00:04:38,784 --> 00:04:43,208
నిస్సందేహంగా చాలా సరళమైనది మరియు మరింత సొగసైనది మరియు ఇది ప్రాథమికంగా ఒకే లైన్ కోడ్‌తో

69
00:04:43,208 --> 00:04:43,920
వ్రాయబడుతుంది.

70
00:04:43,920 --> 00:04:46,200
ఇది XOR ఫంక్షన్‌పై ఆధారపడి ఉంటుంది.

71
00:04:46,200 --> 00:04:50,960
XOR, మీలో తెలియని వారికి, ప్రత్యేకమైనది లేదా.

72
00:04:50,960 --> 00:04:55,219
మీరు రెండు బిట్‌ల XORను తీసుకున్నప్పుడు, ఆ బిట్‌లలో ఒకదానిని ఆన్

73
00:04:55,219 --> 00:05:00,200
చేసినట్లయితే అది 1ని తిరిగి ఇస్తుంది, కానీ రెండూ ఆన్ లేదా ఆఫ్ చేయబడితే కాదు.

74
00:05:00,200 --> 00:05:03,760
విభిన్నంగా పదబంధం, ఇది ఈ రెండు బిట్‌ల సమానత్వం.

75
00:05:03,760 --> 00:05:07,840
గణిత వ్యక్తిగా, నేను దాని గురించి అదనపు మోడ్ 2గా ఆలోచించాలనుకుంటున్నాను.

76
00:05:07,840 --> 00:05:10,675
మేము సాధారణంగా రెండు వేర్వేరు బిట్ స్ట్రింగ్‌ల XOR గురించి

77
00:05:10,675 --> 00:05:14,040
మాట్లాడుతాము, ఇది ప్రాథమికంగా ఈ కాంపోనెంట్‌ను కాంపోనెంట్‌గా చేస్తుంది.

78
00:05:14,040 --> 00:05:16,280
ఇది అదనంగా వంటిది, కానీ మీరు ఎక్కడికి తీసుకెళ్లలేరు.

79
00:05:16,280 --> 00:05:19,700
మళ్ళీ, గణితశాస్త్రపరంగా ఎక్కువ మొగ్గు ఉన్నవారు దీనిని రెండు

80
00:05:19,700 --> 00:05:23,520
వెక్టర్‌లను జోడించడం మరియు మోడ్ 2ను తగ్గించడం వంటిదిగా భావించవచ్చు.

81
00:05:23,520 --> 00:05:29,315
మీరు ప్రస్తుతం కొన్ని పైథాన్‌ని తెరిచి, రెండు పూర్ణాంకాల మధ్య కేరెట్ ఆపరేషన్‌ను

82
00:05:29,315 --> 00:05:35,400
వర్తింపజేస్తే, ఇది హుడ్ కింద ఉన్న ఆ సంఖ్యల బిట్ రిప్రజెంటేషన్‌లకు మాత్రమే చేస్తుంది.

83
00:05:35,400 --> 00:05:43,590
మీకు మరియు నాకు ముఖ్యమైన అంశం ఏమిటంటే, అనేక విభిన్న బిట్ స్ట్రింగ్‌ల యొక్క XOR తీసుకోవడం

84
00:05:43,590 --> 00:05:51,320
అనేది నిలువు వరుసల మాదిరిగానే, ప్రత్యేక సమూహాల యొక్క పేరడీలను గణించడానికి ఒక మార్గం.

85
00:05:51,320 --> 00:05:55,603
ఇది మా హామింగ్ కోడ్ అల్గారిథమ్ నుండి బహుళ పారిటీ చెక్‌ల గురించి ఆలోచించడానికి చాలా

86
00:05:55,603 --> 00:05:59,680
చురుకైన మార్గాన్ని అందిస్తుంది, ఎందుకంటే అన్నీ ఒకే ఆపరేషన్‌లో ప్యాక్ చేయబడతాయి.

87
00:05:59,680 --> 00:06:02,800
మొదటి చూపులో ఇది చాలా భిన్నంగా కనిపించినప్పటికీ.

88
00:06:02,800 --> 00:06:07,848
ప్రత్యేకంగా బైనరీలో 16 స్థానాలను వ్రాయండి, మనం ఇంతకు ముందు

89
00:06:07,848 --> 00:06:13,410
ఉన్నట్లుగా, ఇప్పుడు మెసేజ్ బిట్ 1కి ఆన్ చేయబడిన స్థానాలను హైలైట్

90
00:06:13,410 --> 00:06:19,400
చేయండి, ఆపై ఈ స్థానాలను ఒక పెద్ద నిలువు వరుసలో సేకరించి XOR తీసుకోండి.

91
00:06:19,400 --> 00:06:23,962
ఫలితంగా దిగువన కూర్చున్న 4 బిట్‌లు మనకు తెలిసిన మరియు ఇష్టపడే

92
00:06:23,962 --> 00:06:28,230
4 పారిటీ చెక్‌ల మాదిరిగానే ఉంటాయని మీరు బహుశా ఊహించవచ్చు,

93
00:06:28,230 --> 00:06:32,720
అయితే సరిగ్గా ఎందుకు అని ఆలోచించడానికి కొంత సమయం కేటాయించండి.

94
00:06:32,720 --> 00:06:37,039
ఈ చివరి నిలువు వరుస, ఉదాహరణకు, చివరి బిట్ 1 ఉన్న అన్ని స్థానాలను గణిస్తోంది,

95
00:06:37,039 --> 00:06:41,415
కానీ మేము ఇప్పటికే హైలైట్ చేసిన స్థానాలకు మాత్రమే పరిమితం చేసాము, కాబట్టి ఇది

96
00:06:41,415 --> 00:06:45,960
మొదటి సమూహ సమూహం నుండి ఎన్ని హైలైట్ చేయబడిన స్థానాలను ప్రభావవంతంగా లెక్కిస్తుంది.

97
00:06:45,960 --> 00:06:48,520
అది సమంజసమా?

98
00:06:48,520 --> 00:06:54,406
అదేవిధంగా, తదుపరి నిలువు వరుస రెండవ సమాన సమూహంలో ఎన్ని స్థానాలు ఉన్నాయి, రెండవ నుండి

99
00:06:54,406 --> 00:07:00,640
చివరి బిట్ 1 వరకు ఉన్న స్థానాలు మరియు హైలైట్ చేయబడినవి మరియు మొదలైనవి కూడా లెక్కించబడతాయి.

100
00:07:00,640 --> 00:07:07,640
ఇది నిజంగా మనం చేస్తున్న అదే పనిపై దృష్టికోణంలో చిన్న మార్పు.

101
00:07:07,640 --> 00:07:10,000
మరియు అది ఇక్కడ నుండి ఎక్కడికి వెళుతుందో మీకు తెలుసు.

102
00:07:10,000 --> 00:07:14,483
మొత్తం 0000 వరకు పని చేస్తుందని నిర్ధారించుకోవడానికి కొన్ని

103
00:07:14,483 --> 00:07:19,640
ప్రత్యేక పారిటీ బిట్‌లను టోగుల్ చేయడానికి పంపినవారు బాధ్యత వహిస్తారు.

104
00:07:19,640 --> 00:07:22,570
ఇప్పుడు మనం దీన్ని ఇలా కలిగి ఉంటే, దిగువన ఉన్న ఈ నాలుగు ఫలిత

105
00:07:22,570 --> 00:07:25,693
బిట్‌లు నేరుగా లోపం యొక్క స్థానాన్ని ఎందుకు వివరిస్తాయి అనే దాని

106
00:07:25,693 --> 00:07:28,720
గురించి ఆలోచించడానికి ఇది మాకు నిజంగా మంచి మార్గాన్ని ఇస్తుంది.

107
00:07:28,720 --> 00:07:32,720
ఈ బ్లాక్‌లోని కొంత బిట్ 0 నుండి 1కి టోగుల్ చేయబడిందని అనుకుందాం.

108
00:07:32,720 --> 00:07:38,541
దీని అర్థం ఏమిటంటే, ఆ బిట్ యొక్క స్థానం ఇప్పుడు మొత్తం XORలో చేర్చబడుతుంది, ఇది

109
00:07:38,541 --> 00:07:44,800
మొత్తాన్ని 0 నుండి బదులుగా ఈ కొత్తగా చేర్చబడిన విలువ, లోపం యొక్క స్థానంగా మారుస్తుంది.

110
00:07:44,800 --> 00:07:49,800
కొంచెం తక్కువ స్పష్టంగా, 1 నుండి 0కి మార్చే లోపం ఉన్నట్లయితే అదే నిజం.

111
00:07:49,800 --> 00:07:54,287
మీరు చూడండి, మీరు ఒక బిట్ స్ట్రింగ్‌ని రెండుసార్లు కలిపితే,

112
00:07:54,287 --> 00:07:59,000
అది అక్కడ లేనట్లే, ప్రాథమికంగా ఈ ప్రపంచంలో 1 ప్లస్ 1 0కి సమానం.

113
00:07:59,000 --> 00:08:01,953
కాబట్టి మొత్తం మొత్తానికి ఈ స్థానం యొక్క కాపీని

114
00:08:01,953 --> 00:08:05,400
జోడించడం వలన మనం దానిని తరలిస్తున్నట్లే ప్రభావం ఉంటుంది.

115
00:08:05,400 --> 00:08:09,703
మరియు ఆ ప్రభావం, మళ్ళీ, ఇక్కడ దిగువన ఉన్న మొత్తం

116
00:08:09,703 --> 00:08:13,480
ఫలితం లోపం యొక్క స్థానాన్ని తెలియజేస్తుంది.

117
00:08:13,480 --> 00:08:17,854
ఇది ఎంత సొగసైనదో వివరించడానికి, నేను ఇంతకు ముందు ప్రస్తావించిన పైథాన్ కోడ్‌లోని

118
00:08:17,854 --> 00:08:22,120
ఒక లైన్‌ను చూపుతాను, ఇది రిసీవర్ చివరన దాదాపు అన్ని లాజిక్‌లను సంగ్రహిస్తుంది.

119
00:08:22,120 --> 00:08:26,268
మేము డేటా బ్లాక్‌ను అనుకరించడానికి 16 1సె మరియు 0 సె యాదృచ్ఛిక శ్రేణిని

120
00:08:26,268 --> 00:08:30,244
సృష్టించడం ద్వారా ప్రారంభిస్తాము మరియు నేను దానికి బిట్‌లను ఇస్తాను,

121
00:08:30,244 --> 00:08:34,451
అయితే ఆచరణలో ఇది మనం పంపినవారి నుండి స్వీకరించేదే అవుతుంది మరియు బదులుగా

122
00:08:34,451 --> 00:08:38,600
యాదృచ్ఛికంగా ఇది 5 పారిటీ బిట్‌లతో కలిపి 11 డేటా బిట్‌లను కలిగి ఉంటుంది.

123
00:08:38,600 --> 00:08:43,344
నేను ఫంక్షన్ enumerateBits అని పిలిస్తే, అది చేసేది ఆ బిట్‌లను

124
00:08:43,344 --> 00:08:48,240
సంబంధిత సూచికతో జత చేయడం, ఈ సందర్భంలో 0 నుండి 15 వరకు నడుస్తుంది.

125
00:08:48,240 --> 00:08:52,736
కాబట్టి మనం ఈ అన్ని జతలపై లూప్ చేసే జాబితాను సృష్టించినట్లయితే, i లాగా

126
00:08:52,736 --> 00:08:57,296
కనిపించే జంటలు, ఆపై మేము కేవలం i విలువను, కేవలం సూచికను తీసివేస్తే, అది

127
00:08:57,296 --> 00:09:01,920
అంత ఉత్తేజకరమైనది కాదు, మేము ఆ సూచికలను 0 నుండి 15 వరకు తిరిగి పొందుతాము.

128
00:09:01,920 --> 00:09:07,436
కానీ మనం దీన్ని బిట్ అయితే మాత్రమే చేయాలనే షరతును జోడిస్తే, అంటే ఆ బిట్ 1

129
00:09:07,436 --> 00:09:13,400
మరియు 0 కాకపోతే, అది సంబంధిత బిట్ ఆన్ చేయబడిన స్థానాలను మాత్రమే బయటకు తీస్తుంది.

130
00:09:13,400 --> 00:09:20,720
ఈ సందర్భంలో ఆ స్థానాలు 0, 4, 6, 9, మొదలైనవి ఉన్నట్లు కనిపిస్తోంది.

131
00:09:20,720 --> 00:09:25,606
మనకు కావలసినది ఏమిటంటే, ఆ స్థానాలు, ఆన్ చేయబడిన బిట్‌ల

132
00:09:25,606 --> 00:09:29,960
స్థానాలు అన్నీ కలిపి, ఆపై వాటిని కలిపి XOR చేయడం.

133
00:09:29,960 --> 00:09:33,960
పైథాన్‌లో దీన్ని చేయడానికి, నేను ముందుగా ఒక జంట సహాయక ఫంక్షన్‌లను దిగుమతి చేస్తాను.

134
00:09:33,960 --> 00:09:36,403
ఆ విధంగా మనం ఈ జాబితాలో తగ్గించు() అని పిలుస్తాము

135
00:09:36,403 --> 00:09:39,140
మరియు దానిని తగ్గించడానికి XOR ఫంక్షన్‌ని ఉపయోగించవచ్చు.

136
00:09:39,140 --> 00:09:44,840
ఇది ప్రాథమికంగా జాబితా ద్వారా దాని మార్గాన్ని తింటుంది, మార్గం వెంట XORలను తీసుకుంటుంది.

137
00:09:44,840 --> 00:09:48,443
మీరు కావాలనుకుంటే, మీరు ఎక్కడి నుండైనా దిగుమతి

138
00:09:48,443 --> 00:09:52,200
చేయకుండానే ఆ XOR ఫంక్షన్‌ని స్పష్టంగా వ్రాయవచ్చు.

139
00:09:52,200 --> 00:09:56,915
కాబట్టి ప్రస్తుతానికి మనం దీన్ని 16 బిట్‌ల యాదృచ్ఛిక బ్లాక్‌లో

140
00:09:56,915 --> 00:10:02,080
చేస్తే, అది బైనరీ ప్రాతినిధ్యం 1001ని కలిగి ఉన్న 9ని తిరిగి ఇస్తుంది.

141
00:10:02,080 --> 00:10:07,040
మేము దీన్ని ఇక్కడ చేయము, కానీ పంపినవారు నాలుగు పారిటీ బిట్‌లను అవసరమైన విధంగా సెట్

142
00:10:07,040 --> 00:10:12,060
చేయడానికి బైనరీ ప్రాతినిధ్యాన్ని ఉపయోగించే ఒక ఫంక్షన్‌ను మీరు వ్రాయవచ్చు, చివరికి ఈ

143
00:10:12,060 --> 00:10:17,200
బ్లాక్‌ని బిట్‌ల పూర్తి జాబితాలో ఈ లైన్ కోడ్‌ని అమలు చేసే స్థితికి చేరుకుంటుంది. ఒక 0.

144
00:10:17,200 --> 00:10:20,200
ఇది బాగా సిద్ధమైన బ్లాక్‌గా పరిగణించబడుతుంది.

145
00:10:20,200 --> 00:10:25,101
మంచి విషయం ఏమిటంటే, శబ్దం నుండి యాదృచ్ఛిక లోపాన్ని అనుకరిస్తూ, ఈ జాబితాలోని ఏదైనా

146
00:10:25,101 --> 00:10:29,763
బిట్‌లను మనం టోగుల్ చేస్తే, మీరు ఇదే లైన్ కోడ్‌ను అమలు చేస్తే, అది ఆ లోపాన్ని

147
00:10:29,763 --> 00:10:30,600
ముద్రిస్తుంది.

148
00:10:30,600 --> 00:10:31,920
అది చక్కగా లేదా?

149
00:10:31,920 --> 00:10:37,522
మీరు ఈ బ్లాక్‌ను నీలిరంగు నుండి పొందవచ్చు, దానిపై ఈ సింగిల్ లైన్‌ను అమలు చేయవచ్చు

150
00:10:37,522 --> 00:10:42,920
మరియు అది స్వయంచాలకంగా లోపం యొక్క స్థానం లేదా ఏదైనా లేకుంటే 0ని ఉమ్మివేస్తుంది.

151
00:10:42,920 --> 00:10:45,520
మరియు ఇక్కడ పరిమాణం 16 గురించి ప్రత్యేకంగా ఏమీ లేదు.

152
00:10:45,520 --> 00:10:52,280
మీరు 256 బిట్‌ల జాబితాను కలిగి ఉంటే అదే లైన్ కోడ్ పని చేస్తుంది.

153
00:10:52,280 --> 00:10:56,740
2-బిట్ ఎర్రర్‌లను గుర్తించడానికి మెటా పారిటీ చెక్ చేయడం వంటి మరిన్ని

154
00:10:56,740 --> 00:11:00,748
కోడ్‌లు ఇక్కడ వ్రాయాలని ప్రత్యేకంగా చెప్పనవసరం లేదు, అయితే మా

155
00:11:00,748 --> 00:11:05,080
స్కీమ్‌లోని దాదాపు అన్ని కోర్ లాజిక్‌లు ఒకే XOR తగ్గింపుకు వస్తాయి.

156
00:11:05,080 --> 00:11:09,619
ఇప్పుడు, బైనరీ మరియు XORలు మరియు సాధారణంగా సాఫ్ట్‌వేర్‌తో మీ సౌకర్యాన్ని

157
00:11:09,619 --> 00:11:14,220
బట్టి, మీరు ఈ దృక్పథాన్ని కొంచెం గందరగోళంగా లేదా చాలా సొగసైన మరియు సరళంగా

158
00:11:14,220 --> 00:11:19,320
కనుగొనవచ్చు, మేము దీన్ని ఎందుకు ప్రారంభించలేదని మీరు ఆశ్చర్యపోతున్నారు. -వెళ్ళండి.

159
00:11:19,320 --> 00:11:23,543
వదులుగా చెప్పాలంటే, హార్డ్‌వేర్‌లో హామింగ్ కోడ్‌లను నేరుగా అమలు చేసేటప్పుడు

160
00:11:23,543 --> 00:11:27,600
బహుళ పారిటీ తనిఖీ దృక్పథం గురించి ఆలోచించడం సులభం, మరియు XOR దృక్పథాన్ని

161
00:11:27,600 --> 00:11:31,380
సాఫ్ట్‌వేర్‌లో చేసేటప్పుడు, ఉన్నత స్థాయి నుండి ఆలోచించడం చాలా సులభం.

162
00:11:31,380 --> 00:11:36,114
మొదటిది వాస్తవానికి చేతితో చేయడం చాలా సులభం, మరియు వీటన్నింటికీ అంతర్లీనంగా ఉన్న

163
00:11:36,114 --> 00:11:40,907
ప్రధాన అంతర్ దృష్టిని కలిగించడం మంచి పని చేస్తుందని నేను భావిస్తున్నాను, అంటే ఒకే

164
00:11:40,907 --> 00:11:45,759
లోపాన్ని గుర్తించడానికి అవసరమైన సమాచారం బ్లాక్ పరిమాణం యొక్క లాగ్‌కు సంబంధించినది.

165
00:11:45,759 --> 00:11:51,020
, లేదా మరో మాటలో చెప్పాలంటే, బ్లాక్ సైజు రెట్టింపు అయ్యే కొద్దీ ఒక్కోసారి అది పెరుగుతుంది.

166
00:11:51,020 --> 00:11:53,703
ఇక్కడ సంబంధిత వాస్తవం ఏమిటంటే, ఆ సమాచారం మనకు ఎంత

167
00:11:53,703 --> 00:11:56,440
రిడెండెన్సీ అవసరమో దానికి నేరుగా అనుగుణంగా ఉంటుంది.

168
00:11:56,440 --> 00:12:00,149
చాలా మంది వ్యక్తుల యొక్క మోకాలి కుదుపు ప్రతిచర్యకు వ్యతిరేకంగా జరిగేది అదే,

169
00:12:00,149 --> 00:12:03,810
వారు ఒక సందేశాన్ని లోపాలను తట్టుకునేలా చేయడం గురించి మొదట ఆలోచించినప్పుడు,

170
00:12:03,810 --> 00:12:07,520
సాధారణంగా మొత్తం సందేశాన్ని కాపీ చేయడం అనేది గుర్తుకు వచ్చే మొదటి ప్రవృత్తి.

171
00:12:07,520 --> 00:12:11,089
ఆపై, మార్గం ద్వారా, మీరు కొన్నిసార్లు హామింగ్ కోడ్‌లను ప్రదర్శించే ఈ మొత్తం

172
00:12:11,089 --> 00:12:14,800
ఇతర మార్గం ఉంది, ఇక్కడ మీరు సందేశాన్ని ఒక పెద్ద మ్యాట్రిక్స్ ద్వారా గుణిస్తారు.

173
00:12:14,800 --> 00:12:18,202
ఇది చాలా బాగుంది ఎందుకంటే ఇది సరళ కోడ్‌ల యొక్క విస్తృత కుటుంబానికి

174
00:12:18,202 --> 00:12:21,757
సంబంధించినది, కానీ అది ఎక్కడ నుండి వస్తుంది లేదా ఎలా స్కేల్ చేస్తుంది

175
00:12:21,757 --> 00:12:25,160
అనే దాని గురించి దాదాపు అంతర్ దృష్టిని ఇవ్వదని నేను భావిస్తున్నాను.

176
00:12:25,160 --> 00:12:29,004
మరియు స్కేలింగ్ గురించి చెప్పాలంటే, మేము బ్లాక్ పరిమాణాన్ని పెంచుతున్నప్పుడు

177
00:12:29,004 --> 00:12:32,200
మాత్రమే ఈ పథకం యొక్క సామర్థ్యం మెరుగుపడుతుందని మీరు గమనించవచ్చు.

178
00:12:32,200 --> 00:12:37,840
ఉదాహరణకు, 256 బిట్‌లతో, మీరు రిడెండెన్సీ కోసం ఆ స్థలంలో 3% మాత్రమే

179
00:12:37,840 --> 00:12:43,480
ఉపయోగిస్తున్నారని మేము చూశాము మరియు అది అక్కడ నుండి మెరుగుపడుతోంది.

180
00:12:43,480 --> 00:12:46,683
పారిటీ బిట్‌ల సంఖ్య ఒక్కొక్కటిగా పెరుగుతున్న కొద్దీ,

181
00:12:46,683 --> 00:12:49,040
బ్లాక్ పరిమాణం రెట్టింపు అవుతూ ఉంటుంది.

182
00:12:49,040 --> 00:12:53,132
మరియు మీరు దానిని విపరీతంగా తీసుకుంటే, మీరు మిలియన్ బిట్‌లతో బ్లాక్‌ను

183
00:12:53,132 --> 00:12:57,052
కలిగి ఉండవచ్చు, ఇక్కడ మీరు మీ పారిటీ తనిఖీలతో అక్షరాలా 20 ప్రశ్నలను

184
00:12:57,052 --> 00:13:00,800
ప్లే చేస్తారు మరియు ఇది 21 పారిటీ బిట్‌లను మాత్రమే ఉపయోగిస్తుంది.

185
00:13:00,800 --> 00:13:04,522
మరియు మీరు మిలియన్ బిట్‌లను చూడటం మరియు ఒక్క ఎర్రర్‌ను గుర్తించడం

186
00:13:04,522 --> 00:13:08,640
గురించి ఆలోచించడానికి వెనుకడుగు వేస్తే, అది నిజంగా పిచ్చిగా అనిపిస్తుంది.

187
00:13:08,640 --> 00:13:13,405
సమస్య ఏమిటంటే, పెద్ద బ్లాక్‌తో, ఒకటి లేదా రెండు కంటే ఎక్కువ బిట్ ఎర్రర్‌లను

188
00:13:13,405 --> 00:13:18,360
చూసే సంభావ్యత పెరుగుతుంది మరియు హామింగ్ కోడ్‌లు అంతకు మించి దేనినీ నిర్వహించవు.

189
00:13:18,360 --> 00:13:22,271
కాబట్టి ఆచరణలో, మీకు కావలసినది సరైన పరిమాణాన్ని కనుగొనడం,

190
00:13:22,271 --> 00:13:26,520
తద్వారా చాలా ఎక్కువ బిట్ ఫ్లిప్‌ల సంభావ్యత చాలా ఎక్కువగా ఉండదు.

191
00:13:26,520 --> 00:13:32,935
అలాగే, ఆచరణలో, లోపాలు చిన్న పేలుళ్లలో వస్తాయి, ఇది ఒక బ్లాక్‌ను పూర్తిగా నాశనం చేస్తుంది,

192
00:13:32,935 --> 00:13:38,779
కాబట్టి అనేక విభిన్న బ్లాక్‌లలో లోపాలను వ్యాప్తి చేయడంలో సహాయపడే ఒక సాధారణ వ్యూహం

193
00:13:38,779 --> 00:13:44,624
ఏమిటంటే, ఆ బ్లాక్‌లను వాటి ముందు ఇలా ఇంటర్‌లేస్ చేయడం. బయటకు పంపబడింది లేదా నిల్వ

194
00:13:44,624 --> 00:13:45,480
చేయబడుతుంది.

195
00:13:45,480 --> 00:13:50,236
మరలా, చాలా సాధారణంగా ఉపయోగించే రీడ్-సోలమన్ అల్గోరిథం వంటి ఆధునిక కోడ్‌ల ద్వారా చాలా

196
00:13:50,236 --> 00:13:55,049
వరకు పూర్తిగా మూట్ చేయబడింది, ఇది బరస్ట్ ఎర్రర్‌లను ప్రత్యేకంగా నిర్వహిస్తుంది మరియు

197
00:13:55,049 --> 00:13:59,580
ప్రతి బ్లాక్‌కు పెద్ద సంఖ్యలో ఎర్రర్‌లకు స్థితిస్థాపకంగా ఉండేలా ట్యూన్ చేయవచ్చు.

198
00:13:59,580 --> 00:14:03,000
కానీ అది మరొక సారి చర్చనీయాంశం.

199
00:14:03,000 --> 00:14:06,877
అతని పుస్తకం ది ఆర్ట్ ఆఫ్ డూయింగ్ సైన్స్ అండ్ ఇంజినీరింగ్‌లో, హామింగ్

200
00:14:06,877 --> 00:14:10,700
ఈ కోడ్‌ని తన కనిపెట్టడం ఎంత మెలికలు తిరిగిపోయిందో అద్భుతంగా చెప్పాడు.

201
00:14:10,700 --> 00:14:14,639
అతను మొదట బిట్‌లను అధిక డైమెన్షనల్ లాటిస్‌లోని భాగాలుగా నిర్వహించడం మరియు

202
00:14:14,639 --> 00:14:18,420
ఇలాంటి వింత విషయాలతో కూడిన అన్ని రకాల విభిన్న స్కీమ్‌లను ప్రయత్నించాడు.

203
00:14:18,420 --> 00:14:22,723
లోపం యొక్క స్థితిని వివరించే విధంగా కుట్ర చేయడానికి సమానత్వ తనిఖీలను పొందడం

204
00:14:22,723 --> 00:14:27,537
సాధ్యమవుతుందనే ఆలోచన హామింగ్‌కు వచ్చినప్పుడు అతను ఇతర విశ్లేషణల సమూహం తర్వాత వెనక్కి

205
00:14:27,537 --> 00:14:32,123
వెళ్లి, సరే, నేను చేయగలిగిన అత్యంత సమర్థవంతమైనది ఏమిటి అని అడిగాడు. దీని గురించి

206
00:14:32,123 --> 00:14:32,860
ఆలోచించవచ్చా?

207
00:14:32,860 --> 00:14:37,304
1940 లలో ఈనాటి కంటే తక్కువ సాధారణం అయ్యే పారిటీ తనిఖీలు అతని

208
00:14:37,304 --> 00:14:42,040
మనస్సులో ఇప్పటికే ఉండటం ఎంత ముఖ్యమో కూడా అతను నిజాయితీగా ఉన్నాడు.

209
00:14:42,040 --> 00:14:45,682
అతను లూయిస్ పాశ్చర్ కోట్‌ను ప్రస్తావించిన అరడజను సార్లు ఈ

210
00:14:45,682 --> 00:14:49,640
పుస్తకంలో ఉన్నాయి, అదృష్టం సిద్ధమైన మనస్సుకు అనుకూలంగా ఉంటుంది.

211
00:14:49,640 --> 00:14:52,243
తెలివైన ఆలోచనలు తరచుగా వెనుకకు చూస్తే మోసపూరితంగా సరళంగా

212
00:14:52,243 --> 00:14:55,120
కనిపిస్తాయి, ఇది వాటిని తక్కువ అంచనా వేయడానికి సులభం చేస్తుంది.

213
00:14:55,120 --> 00:14:58,377
హామింగ్ కోడ్‌లు లేదా కనీసం అలాంటి కోడ్‌ల అవకాశం మీకు

214
00:14:58,377 --> 00:15:01,820
దాదాపు స్పష్టంగా కనిపిస్తుందని ప్రస్తుతం నా నిజాయితీ ఆశ.

215
00:15:01,820 --> 00:15:05,026
అయితే అవి స్పష్టంగా కనిపిస్తున్నాయని భావించి మిమ్మల్ని

216
00:15:05,026 --> 00:15:08,000
మీరు మోసం చేసుకోకూడదు, ఎందుకంటే అవి ఖచ్చితంగా కావు.

217
00:15:08,000 --> 00:15:11,723
తెలివైన ఆలోచనలు మోసపూరితంగా తేలికగా కనిపించడానికి ఒక కారణం ఏమిటంటే, మనం

218
00:15:11,723 --> 00:15:15,757
ఎప్పుడైనా తుది ఫలితాన్ని మాత్రమే చూస్తాము, గజిబిజిగా ఉన్నవాటిని శుభ్రం చేయడం,

219
00:15:15,757 --> 00:15:19,894
తప్పు మలుపులన్నింటినీ ఎప్పుడూ ప్రస్తావించకపోవడం, సమస్య ప్రారంభంలో అన్వేషించదగిన

220
00:15:19,894 --> 00:15:23,980
అవకాశాల స్థలం ఎంత విశాలంగా ఉందో తక్కువగా అమ్మడం. పరిష్కార ప్రక్రియ, అన్నింటినీ.

221
00:15:23,980 --> 00:15:25,280
కానీ ఇది సాధారణంగా నిజం.

222
00:15:25,280 --> 00:15:28,236
కొన్ని ప్రత్యేక ఆవిష్కరణల కోసం, మనం వాటిని తక్కువగా అంచనా

223
00:15:28,236 --> 00:15:31,040
వేయడానికి రెండవ, లోతైన కారణం ఉందని నేను భావిస్తున్నాను.

224
00:15:31,040 --> 00:15:35,306
సమాచార సిద్ధాంతంపై క్లాడ్ షానన్ యొక్క సెమినల్ పేపర్‌తో 1948 నాటికి బిట్‌ల

225
00:15:35,306 --> 00:15:39,400
పరంగా సమాచారం గురించి ఆలోచించడం నిజంగా పూర్తి సిద్ధాంతంగా కలిసిపోయింది.

226
00:15:39,400 --> 00:15:43,440
హామింగ్ తన అల్గారిథమ్‌ను అభివృద్ధి చేసినప్పుడు ఇది తప్పనిసరిగా సమానంగా ఉంటుంది.

227
00:15:43,440 --> 00:15:48,840
బిట్ ఫ్లిప్‌ల సంభావ్యత ఎంత ఎక్కువగా ఉన్నా, కనీసం థియరీలో అయినా సమర్థవంతమైన లోపాన్ని

228
00:15:48,840 --> 00:15:53,920
సరిదిద్దడం ఎల్లప్పుడూ సాధ్యమేనని ఒక నిర్దిష్ట కోణంలో చూపించిన అదే పునాది పేపర్.

229
00:15:53,920 --> 00:15:57,946
షానన్ మరియు హామింగ్, చాలా భిన్నమైన విషయాలపై పనిచేసినప్పటికీ, బెల్

230
00:15:57,946 --> 00:16:02,400
ల్యాబ్స్‌లో కార్యాలయాన్ని పంచుకున్నారు, ఇది ఇక్కడ యాదృచ్ఛికంగా కనిపించదు.

231
00:16:02,400 --> 00:16:05,979
కొన్ని దశాబ్దాలుగా ఫాస్ట్ ఫార్వార్డ్, మరియు ఈ రోజుల్లో, మనలో

232
00:16:05,979 --> 00:16:09,793
చాలా మంది బిట్స్ మరియు సమాచారం గురించి ఆలోచించడంలో మునిగిపోయారు,

233
00:16:09,793 --> 00:16:13,080
ఈ ఆలోచనా విధానం ఎంత విభిన్నంగా ఉందో పట్టించుకోవడం సులభం.

234
00:16:13,080 --> 00:16:15,535
హాస్యాస్పదంగా, భవిష్యత్ తరం ఆలోచించే మార్గాలను చాలా లోతుగా రూపొందించే

235
00:16:15,535 --> 00:16:17,920
ఆలోచనలు ఆ భవిష్యత్తు తరానికి నిజంగా ఉన్నదానికంటే సరళంగా కనిపిస్తాయి.

