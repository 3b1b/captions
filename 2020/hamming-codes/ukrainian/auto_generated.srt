1
00:00:00,000 --> 00:00:03,120
Я припускаю, що всі тут походять із частини 1.

2
00:00:03,120 --> 00:00:06,463
Ми говорили про коди Хеммінга, спосіб створення блоку даних,

3
00:00:06,463 --> 00:00:09,094
де більшість бітів несуть значуще повідомлення,

4
00:00:09,094 --> 00:00:12,876
тоді як кілька інших діють як свого роду надлишковість, таким чином,

5
00:00:12,876 --> 00:00:17,370
що якщо будь-який біт перевертається, або повідомлення біт або біт надлишковості,

6
00:00:17,370 --> 00:00:21,920
будь-що в цьому блоці, приймач зможе визначити, що була помилка, і як її виправити.

7
00:00:21,920 --> 00:00:24,717
Основна ідея, представлена там, полягала в тому,

8
00:00:24,717 --> 00:00:29,800
як використовувати кілька перевірок на парність для бінарного пошуку на шляху до помилки.

9
00:00:29,800 --> 00:00:32,583
У цьому відео мета полягала в тому, щоб зробити коди

10
00:00:32,583 --> 00:00:35,420
Хеммінга максимально практичними та відкритими заново.

11
00:00:35,420 --> 00:00:39,903
Але коли ви починаєте думати про те, щоб реалізувати це в програмному чи апаратному

12
00:00:39,903 --> 00:00:44,120
забезпеченні, таке фреймування може фактично знизити вартість елегантного коду.

13
00:00:44,120 --> 00:00:46,966
Ви можете подумати, що вам потрібно написати алгоритм,

14
00:00:46,966 --> 00:00:50,123
який відстежує всі можливі місця помилок і скорочує цю групу

15
00:00:50,123 --> 00:00:54,160
навпіл під час кожної перевірки, але насправді це набагато, набагато простіше.

16
00:00:54,160 --> 00:00:57,550
Якщо ви зачитаєте відповіді на чотири перевірки парності,

17
00:00:57,550 --> 00:01:01,584
які ми робили в останньому відео, усі як 1 і 0 замість «так» і «ні»,

18
00:01:01,584 --> 00:01:04,800
це буквально вказує місце помилки в двійковому вигляді.

19
00:01:04,800 --> 00:01:09,504
Наприклад, число 7 у двійковій системі виглядає як 0111,

20
00:01:09,504 --> 00:01:12,640
по суті кажучи, що це 4 плюс 2 плюс 1.

21
00:01:12,640 --> 00:01:19,212
І зауважте, де знаходиться позиція 7, вона дійсно впливає на першу з наших груп парності,

22
00:01:19,212 --> 00:01:22,280
і на другу, і на третю, але не на останню.

23
00:01:22,280 --> 00:01:25,640
Отже, читання результатів цих чотирьох перевірок

24
00:01:25,640 --> 00:01:28,520
знизу вгору справді пояснює місце помилки.

25
00:01:28,520 --> 00:01:32,002
У прикладі 7 немає нічого особливого, загалом це працює,

26
00:01:32,002 --> 00:01:37,440
і це робить логіку реалізації всієї схеми на апаратному забезпеченні надзвичайно простою.

27
00:01:37,440 --> 00:01:41,008
Тепер, якщо ви хочете зрозуміти, чому відбувається ця магія,

28
00:01:41,008 --> 00:01:44,986
візьміть ці 16 індексних міток для наших позицій, але замість того,

29
00:01:44,986 --> 00:01:49,140
щоб записувати їх у базі 10, давайте запишемо їх у двійковому вигляді,

30
00:01:49,140 --> 00:01:50,720
починаючи від 0000 до 1111.

31
00:01:50,720 --> 00:01:53,818
Коли ми повертаємо ці двійкові мітки назад у свої коробки,

32
00:01:53,818 --> 00:01:58,440
дозвольте мені підкреслити, що вони відрізняються від даних, які насправді надсилаються.

33
00:01:58,440 --> 00:02:02,313
Вони не що інше, як концептуальний ярлик, який допоможе вам і мені зрозуміти,

34
00:02:02,313 --> 00:02:04,200
звідки взялися чотири паритетні групи.

35
00:02:04,200 --> 00:02:07,925
Елегантність того, що все, на що ми дивимося, описується у двійковому форматі,

36
00:02:07,925 --> 00:02:10,754
можливо, підривається плутаниною, пов’язаною з тим, що все,

37
00:02:10,754 --> 00:02:13,160
на що ми дивимося, описується у двійковому форматі.

38
00:02:13,160 --> 00:02:15,040
Проте воно того варте.

39
00:02:15,040 --> 00:02:20,518
Зосередьте свою увагу лише на останньому фрагменті всіх цих міток,

40
00:02:20,518 --> 00:02:24,280
а потім виділіть позиції, де останній біт є 1.

41
00:02:24,280 --> 00:02:28,065
Що ми отримуємо, це перша з наших чотирьох груп парності,

42
00:02:28,065 --> 00:02:32,829
що означає, що ви можете інтерпретувати цю першу перевірку як запитання:

43
00:02:32,829 --> 00:02:36,680
якщо є помилка, чи є останній біт у позиції цієї помилки 1?

44
00:02:36,680 --> 00:02:42,729
Так само, якщо ви зосередитеся на передостанньому біті та виділите всі позиції,

45
00:02:42,729 --> 00:02:47,040
де це 1, ви отримаєте другу групу парності з нашої схеми.

46
00:02:47,040 --> 00:02:51,274
Іншими словами, ця друга перевірка запитує, привіт,

47
00:02:51,274 --> 00:02:56,160
я знову, якщо є помилка, передостанній біт цієї позиції є 1?

48
00:02:56,160 --> 00:02:57,160
І так далі.

49
00:02:57,160 --> 00:03:04,105
Третя перевірка парності охоплює кожну позицію, передостанній біт якої ввімкнено,

50
00:03:04,105 --> 00:03:10,120
а остання охоплює останні вісім позицій, у яких старший біт дорівнює 1.

51
00:03:10,120 --> 00:03:15,282
Усе, що ми робили раніше, те саме, що відповіді на ці чотири запитання,

52
00:03:15,282 --> 00:03:19,800
що, у свою чергу, те саме, що виклад позиції в двійковому коді.

53
00:03:19,800 --> 00:03:22,080
Сподіваюся, це зрозуміє дві речі.

54
00:03:22,080 --> 00:03:27,140
По-перше, як систематично узагальнювати розміри блоків, які є більшими степенями двійки.

55
00:03:27,140 --> 00:03:31,298
Якщо для опису кожної позиції потрібно більше бітів, наприклад,

56
00:03:31,298 --> 00:03:36,820
шість бітів для опису 64 плям, тоді кожен із цих бітів дає вам одну з груп парності,

57
00:03:36,820 --> 00:03:38,640
яку нам потрібно перевірити.

58
00:03:38,640 --> 00:03:40,443
Тим із вас, хто дивився головоломку на шахівниці,

59
00:03:40,443 --> 00:03:43,400
яку я розгадував із Метом Паркером, можливо, все це здасться надзвичайно знайомим.

60
00:03:43,400 --> 00:03:46,860
Це та сама основна логіка, але розв’язує іншу проблему

61
00:03:46,860 --> 00:03:49,880
та застосована до шахової дошки з 64 квадратами.

62
00:03:49,880 --> 00:03:55,196
Друге, що, я сподіваюся, це пояснює, чому наші біти парності сидять у позиціях,

63
00:03:55,196 --> 00:03:58,320
які є степенями двійки, наприклад, 1, 2, 4 і 8.

64
00:03:58,320 --> 00:04:03,640
Це позиції, двійкове представлення яких має лише один біт.

65
00:04:03,640 --> 00:04:08,492
Це означає, що кожен із цих бітів парності знаходиться

66
00:04:08,492 --> 00:04:12,640
в одній і лише одній із чотирьох груп парності.

67
00:04:12,640 --> 00:04:18,737
Ви також можете побачити це на більших прикладах, де незалежно від того,

68
00:04:18,737 --> 00:04:25,920
наскільки великим ви станете, кожен біт парності зручно стосується лише однієї з груп.

69
00:04:25,920 --> 00:04:28,513
Як тільки ви зрозумієте, що ці перевірки парності,

70
00:04:28,513 --> 00:04:31,411
на яких ми зосередили стільки нашого часу, є не що інше,

71
00:04:31,411 --> 00:04:34,767
як розумний спосіб виразити позицію помилки в двійковому форматі,

72
00:04:34,767 --> 00:04:39,343
тоді ми зможемо провести зв’язок з іншим способом уявлення про хемінг коди, який, мабуть,

73
00:04:39,343 --> 00:04:43,920
є набагато простішим і елегантнішим, і який можна записати за допомогою одного рядка коду.

74
00:04:43,920 --> 00:04:46,200
Він заснований на функції XOR.

75
00:04:46,200 --> 00:04:50,960
XOR, для тих із вас, хто не знає, означає ексклюзивне або.

76
00:04:50,960 --> 00:04:54,869
Коли ви використовуєте XOR двох бітів, він повертає 1,

77
00:04:54,869 --> 00:05:00,200
якщо один із цих бітів увімкнено, але не якщо обидва увімкнено чи вимкнено.

78
00:05:00,200 --> 00:05:03,760
Іншими словами, це парність цих двох бітів.

79
00:05:03,760 --> 00:05:07,840
Як математик я вважаю за краще думати про це як про додавання 2.

80
00:05:07,840 --> 00:05:11,236
Ми також зазвичай говоримо про XOR двох різних бітових рядків,

81
00:05:11,236 --> 00:05:14,040
що в основному виконує цей компонент за компонентом.

82
00:05:14,040 --> 00:05:16,280
Це як доповнення, але куди ніколи не понесеш.

83
00:05:16,280 --> 00:05:19,984
Знову ж таки, більш схильні до математики можуть вважати за краще

84
00:05:19,984 --> 00:05:23,520
думати про це як про додавання двох векторів і зменшення mod 2.

85
00:05:23,520 --> 00:05:27,668
Якщо ви прямо зараз відкриєте якийсь Python і застосуєте операцію

86
00:05:27,668 --> 00:05:31,817
каретки між двома цілими числами, це буде саме те, що він робить,

87
00:05:31,817 --> 00:05:35,400
але лише до розрядних представлень цих чисел під капотом.

88
00:05:35,400 --> 00:05:40,563
Ключовим моментом для нас із вами є те, що використання XOR

89
00:05:40,563 --> 00:05:46,070
багатьох різних бітових рядків є ефективним способом обчислення

90
00:05:46,070 --> 00:05:51,320
пародії на купу окремих груп, як і зі стовпцями, одним махом.

91
00:05:51,320 --> 00:05:55,307
Це дає нам досить хитрий спосіб уявити, що численні перевірки

92
00:05:55,307 --> 00:05:59,680
парності з нашого алгоритму коду Хеммінга об’єднані в одну операцію.

93
00:05:59,680 --> 00:06:02,800
Хоча на перший погляд виглядає зовсім інакше.

94
00:06:02,800 --> 00:06:08,902
Зокрема, запишіть 16 позицій у двійковому вигляді, як ми це робили раніше,

95
00:06:08,902 --> 00:06:13,948
а тепер виділіть позиції, де біт повідомлення ввімкнуто на 1,

96
00:06:13,948 --> 00:06:19,400
а потім зберіть ці позиції в один великий стовпець і виконайте XOR.

97
00:06:19,400 --> 00:06:25,397
Ви, напевно, можете здогадатися, що 4 біти, які лежать у нижній частині в результаті,

98
00:06:25,397 --> 00:06:29,442
такі ж, як і 4 перевірки парності, які ми знали і любимо,

99
00:06:29,442 --> 00:06:32,720
але знайдіть хвилинку, щоб подумати, чому саме.

100
00:06:32,720 --> 00:06:37,875
Цей останній стовпець, наприклад, підраховує всі позиції, останній біт яких дорівнює 1,

101
00:06:37,875 --> 00:06:42,386
але ми вже обмежені лише виділеними позиціями, тому фактично підраховується,

102
00:06:42,386 --> 00:06:45,960
скільки виділених позицій походить від першої групи парності.

103
00:06:45,960 --> 00:06:48,520
Чи має це сенс?

104
00:06:48,520 --> 00:06:54,355
Подібним чином у наступному стовпці підраховується кількість позицій у другій

105
00:06:54,355 --> 00:07:00,640
групі парності, позиції, передостанній біт яких дорівнює 1, які також виділені тощо.

106
00:07:00,640 --> 00:07:07,640
Насправді це лише невелика зміна погляду на те саме, що ми робили.

107
00:07:07,640 --> 00:07:10,000
І ви знаєте, куди це йде.

108
00:07:10,000 --> 00:07:16,197
Відправник відповідає за перемикання деяких спеціальних бітів парності,

109
00:07:16,197 --> 00:07:19,640
щоб переконатися, що сума дорівнює 0000.

110
00:07:19,640 --> 00:07:24,372
Тепер, коли ми маємо це таким чином, це дає нам дійсно гарний спосіб подумати про те,

111
00:07:24,372 --> 00:07:28,720
чому ці чотири результуючих біта внизу безпосередньо вказують на місце помилки.

112
00:07:28,720 --> 00:07:32,720
Припустимо, якийсь біт у цьому блоці перемикається з 0 на 1.

113
00:07:32,720 --> 00:07:38,937
Це означає, що позиція цього біта тепер буде включена в загальне XOR,

114
00:07:38,937 --> 00:07:44,800
яке змінює суму з 0 на це нове включене значення, позицію помилки.

115
00:07:44,800 --> 00:07:49,800
Трохи менш очевидно, те ж саме вірно, якщо є помилка, яка змінює 1 на 0.

116
00:07:49,800 --> 00:07:54,253
Розумієте, якщо ви двічі додаєте бітовий рядок, це все одно,

117
00:07:54,253 --> 00:07:59,000
що його взагалі немає, тому що в цьому світі 1 плюс 1 дорівнює 0.

118
00:07:59,000 --> 00:08:04,008
Тож додавання копії цієї позиції до загальної суми має той самий ефект,

119
00:08:04,008 --> 00:08:05,400
що й її переміщення.

120
00:08:05,400 --> 00:08:09,116
І цей ефект, знову ж таки, полягає в тому, що

121
00:08:09,116 --> 00:08:13,480
загальний результат унизу тут вказує на місце помилки.

122
00:08:13,480 --> 00:08:17,698
Щоб проілюструвати, наскільки це елегантно, дозвольте мені показати той рядок коду

123
00:08:17,698 --> 00:08:22,120
Python, на який я посилався раніше, який захопить майже всю логіку на стороні приймача.

124
00:08:22,120 --> 00:08:27,152
Ми почнемо зі створення випадкового масиву з 16 1 і 0 для імітації блоку даних,

125
00:08:27,152 --> 00:08:31,303
і я дам йому біти назви, але, звичайно, на практиці це буде щось,

126
00:08:31,303 --> 00:08:35,203
що ми отримуємо від відправника, а замість будучи випадковим,

127
00:08:35,203 --> 00:08:38,600
він містив би 11 біт даних разом із 5 бітами парності.

128
00:08:38,600 --> 00:08:43,381
Якщо я викликаю функцію enumerateBits, вона об’єднає кожен із

129
00:08:43,381 --> 00:08:48,240
цих бітів із відповідним індексом, у цьому випадку від 0 до 15.

130
00:08:48,240 --> 00:08:52,777
Отже, якщо ми створимо список, який циклічно перебирає всі ці пари,

131
00:08:52,777 --> 00:08:56,915
пари, які виглядають як i, а потім витягуємо лише значення i,

132
00:08:56,915 --> 00:09:01,920
лише індекс, це не так цікаво, ми просто повертаємо ті індекси від 0 до 15.

133
00:09:01,920 --> 00:09:07,585
Але якщо ми додамо умову робити це тільки якщо біт, тобто якщо цей біт є 1,

134
00:09:07,585 --> 00:09:13,400
а не 0, добре, тоді він вилучає лише ті позиції, де відповідний біт увімкнено.

135
00:09:13,400 --> 00:09:20,720
У цьому випадку виглядає так, ніби ці позиції 0, 4, 6, 9 тощо.

136
00:09:20,720 --> 00:09:25,340
Те, що ми хочемо, це зібрати разом усі ці позиції,

137
00:09:25,340 --> 00:09:29,960
позиції бітів, які ввімкнено, а потім XOR їх разом.

138
00:09:29,960 --> 00:09:33,960
Щоб зробити це в Python, дозвольте мені спочатку імпортувати кілька корисних функцій.

139
00:09:33,960 --> 00:09:38,260
Таким чином ми можемо викликати reduce() у цьому списку та використовувати функцію XOR,

140
00:09:38,260 --> 00:09:39,140
щоб зменшити його.

141
00:09:39,140 --> 00:09:44,840
Це в основному з&#39;їдає собі шлях через список, використовуючи по дорозі XOR.

142
00:09:44,840 --> 00:09:48,416
Якщо ви бажаєте, ви можете явно написати цю функцію

143
00:09:48,416 --> 00:09:52,200
XOR без необхідності імпортувати її з будь-якого місця.

144
00:09:52,200 --> 00:09:56,739
Отже, на даний момент виглядає так, що якщо ми зробимо це на нашому

145
00:09:56,739 --> 00:10:02,080
випадковому блоці з 16 біт, він поверне 9, який має двійкове представлення 1001.

146
00:10:02,080 --> 00:10:05,569
Ми не будемо цього робити тут, але ви можете написати функцію,

147
00:10:05,569 --> 00:10:08,781
у якій відправник використовує це двійкове представлення,

148
00:10:08,781 --> 00:10:13,433
щоб за потреби встановити чотири біти парності, зрештою переводячи цей блок у стан,

149
00:10:13,433 --> 00:10:17,200
коли виконання цього рядка коду з повним списком бітів повертає а 0.

150
00:10:17,200 --> 00:10:20,200
Це буде вважатися добре підготовленим блоком.

151
00:10:20,200 --> 00:10:24,300
Цікаво те, що якщо ми перемикаємо будь-який із бітів у цьому списку,

152
00:10:24,300 --> 00:10:29,292
імітуючи випадкову помилку через шум, тоді, якщо ви запустите цей самий рядок коду,

153
00:10:29,292 --> 00:10:30,600
він виведе цю помилку.

154
00:10:30,600 --> 00:10:31,920
Хіба це не гарно?

155
00:10:31,920 --> 00:10:37,849
Ви можете отримати цей блок зненацька, запустити на ньому цей єдиний рядок,

156
00:10:37,849 --> 00:10:42,920
і він автоматично видасть позицію помилки або 0, якщо її не було.

157
00:10:42,920 --> 00:10:45,520
І нічого особливого в 16 розмірі тут немає.

158
00:10:45,520 --> 00:10:52,280
Той самий рядок коду спрацював би, якби у вас був список із, скажімо, 256 біт.

159
00:10:52,280 --> 00:10:55,450
Зайве говорити, що тут потрібно написати більше коду,

160
00:10:55,450 --> 00:10:59,149
як-от мета-перевірку парності для виявлення 2-бітових помилок,

161
00:10:59,149 --> 00:11:03,553
але ідея полягає в тому, що майже вся основна логіка нашої схеми зводиться

162
00:11:03,553 --> 00:11:05,080
до єдиного скорочення XOR.

163
00:11:05,080 --> 00:11:10,009
Тепер, залежно від вашого комфорту з двійковими кодами та XOR та програмним забезпеченням

164
00:11:10,009 --> 00:11:13,514
загалом, ви можете або вважати цю перспективу трохи заплутаною,

165
00:11:13,514 --> 00:11:16,800
або настільки більш елегантною та простою, що ви дивуєтеся,

166
00:11:16,800 --> 00:11:19,320
чому ми не почали з неї з самого початку -іди.

167
00:11:19,320 --> 00:11:22,785
Грубо кажучи, про перспективу множинної перевірки парності легше подумати,

168
00:11:22,785 --> 00:11:26,435
якщо реалізовувати коди Хеммінга в апаратному забезпеченні дуже безпосередньо,

169
00:11:26,435 --> 00:11:30,271
а про перспективу XOR найпростіше подумати, роблячи це в програмному забезпеченні,

170
00:11:30,271 --> 00:11:31,380
на більш високому рівні.

171
00:11:31,380 --> 00:11:34,350
Перший з них найлегше зробити вручну, і я думаю,

172
00:11:34,350 --> 00:11:37,987
що він краще справляється з прищепленням основної інтуїції,

173
00:11:37,987 --> 00:11:41,745
яка лежить в основі всього цього, а саме того, що інформація,

174
00:11:41,745 --> 00:11:46,291
необхідна для пошуку однієї помилки, пов’язана з журналом розміру блоку. ,

175
00:11:46,291 --> 00:11:51,020
або іншими словами, він зростає по одному біту, коли розмір блоку подвоюється.

176
00:11:51,020 --> 00:11:54,779
Релевантним фактом тут є те, що ця інформація безпосередньо відповідає тому,

177
00:11:54,779 --> 00:11:56,440
скільки резервування нам потрібно.

178
00:11:56,440 --> 00:11:59,570
Це насправді суперечить реагування більшості людей на колінах,

179
00:11:59,570 --> 00:12:03,445
коли вони вперше думають про те, щоб зробити повідомлення стійким до помилок,

180
00:12:03,445 --> 00:12:07,520
де зазвичай скопіювати все повідомлення є першим інстинктом, який спадає на думку.

181
00:12:07,520 --> 00:12:12,036
І, до речі, є цілий інший спосіб, у який ви іноді бачите представлені коди Хеммінга,

182
00:12:12,036 --> 00:12:14,800
коли ви множите повідомлення на одну велику матрицю.

183
00:12:14,800 --> 00:12:19,545
Це начебто добре, тому що це пов’язує його з більш широкою сім’єю лінійних кодів,

184
00:12:19,545 --> 00:12:22,555
але я думаю, що це майже не дає інтуїції щодо того,

185
00:12:22,555 --> 00:12:25,160
звідки він походить або як він масштабується.

186
00:12:25,160 --> 00:12:27,863
Говорячи про масштабування, ви можете помітити,

187
00:12:27,863 --> 00:12:32,200
що ефективність цієї схеми стає лише кращою, коли ми збільшуємо розмір блоку.

188
00:12:32,200 --> 00:12:37,753
Наприклад, ми бачили, що з 256 бітами ви використовуєте лише 3%

189
00:12:37,753 --> 00:12:43,480
цього простору для резервування, і з цього моменту все стає краще.

190
00:12:43,480 --> 00:12:46,887
Оскільки кількість бітів парності зростає один за одним,

191
00:12:46,887 --> 00:12:49,040
розмір блоку продовжує подвоюватися.

192
00:12:49,040 --> 00:12:53,165
І якщо ви доведете це до крайності, у вас може бути блок, скажімо,

193
00:12:53,165 --> 00:12:58,337
з мільйоном біт, де ви б буквально відтворювали 20 запитань із перевіркою парності,

194
00:12:58,337 --> 00:13:00,800
і він використовує лише 21 біт парності.

195
00:13:00,800 --> 00:13:04,751
І якщо ви відступите назад, щоб подумати про перегляд мільйона

196
00:13:04,751 --> 00:13:08,640
бітів і пошук однієї помилки, це справді виглядає божевільним.

197
00:13:08,640 --> 00:13:13,330
Проблема, звісно, полягає в тому, що з більшим блоком зростає ймовірність побачити

198
00:13:13,330 --> 00:13:18,360
більше однієї або двох бітових помилок, а коди Хеммінга не обробляють нічого, крім цього.

199
00:13:18,360 --> 00:13:21,635
Тож на практиці вам потрібно знайти правильний розмір,

200
00:13:21,635 --> 00:13:26,520
щоб ймовірність занадто великої кількості перевертань бітів не була надто високою.

201
00:13:26,520 --> 00:13:31,228
Крім того, на практиці помилки, як правило, виникають невеликими пакетами,

202
00:13:31,228 --> 00:13:35,183
які повністю знищують один блок, тому одна з поширених тактик,

203
00:13:35,183 --> 00:13:39,641
щоб допомогти розподілити сплеск помилок між багатьма різними блоками,

204
00:13:39,641 --> 00:13:42,654
полягає в тому, щоб переплести ці блоки, як це,

205
00:13:42,654 --> 00:13:45,480
перш ніж вони будуть розіслано або збережено.

206
00:13:45,480 --> 00:13:49,704
Знову ж таки, багато чого з цього стає абсолютно спірним через більш сучасні коди,

207
00:13:49,704 --> 00:13:52,962
як-от набагато частіше використовуваний алгоритм Ріда-Соломона,

208
00:13:52,962 --> 00:13:56,831
який особливо добре обробляє пакетні помилки, і його можна налаштувати так,

209
00:13:56,831 --> 00:13:59,580
щоб бути стійким до більшої кількості помилок на блок.

210
00:13:59,580 --> 00:14:03,000
Але це тема іншого разу.

211
00:14:03,000 --> 00:14:06,750
У своїй книзі «Мистецтво займатися наукою та технікою» Хеммінг надзвичайно

212
00:14:06,750 --> 00:14:10,700
відверто розповідає про те, наскільки звивистим було його відкриття цього коду.

213
00:14:10,700 --> 00:14:14,813
Спочатку він випробував усілякі різні схеми, що передбачають організацію

214
00:14:14,813 --> 00:14:18,420
бітів у частини решітки вищого виміру та такі дивні речі, як ця.

215
00:14:18,420 --> 00:14:22,734
Ідея про те, що можна змусити перевірку парності конспірувати таким чином,

216
00:14:22,734 --> 00:14:26,186
щоб визначити місце помилки, прийшла до Геммінга лише тоді,

217
00:14:26,186 --> 00:14:31,134
коли він відступив після купи інших аналізів і запитав: гаразд, що є найефективнішим,

218
00:14:31,134 --> 00:14:32,860
що я можу можливо бути про це?

219
00:14:32,860 --> 00:14:38,123
Він також був відвертим, наскільки важливо, щоб він уже думав про перевірку парності,

220
00:14:38,123 --> 00:14:42,040
яка була б набагато менш поширеною в 1940-х роках, ніж сьогодні.

221
00:14:42,040 --> 00:14:47,032
У цій книзі він півдюжини разів посилається на цитату Луї Пастера:

222
00:14:47,032 --> 00:14:49,640
удача сприяє підготовленому розуму.

223
00:14:49,640 --> 00:14:55,120
Розумні ідеї часто виглядають оманливо простими, тому їх легко недооцінити.

224
00:14:55,120 --> 00:14:58,591
Наразі я щиро сподіваюся, що коди Хеммінга або принаймні

225
00:14:58,591 --> 00:15:01,820
можливість таких кодів здаються вам майже очевидними.

226
00:15:01,820 --> 00:15:06,455
Але ви не повинні обманювати себе, думаючи, що вони насправді очевидні,

227
00:15:06,455 --> 00:15:08,000
тому що це точно не так.

228
00:15:08,000 --> 00:15:11,683
Однією з причин того, що розумні ідеї виглядають оманливо легко, є те,

229
00:15:11,683 --> 00:15:15,574
що ми завжди бачимо лише кінцевий результат, очищаємо те, що було брудним,

230
00:15:15,574 --> 00:15:18,636
ніколи не згадуємо всі неправильні повороти, недооцінюючи,

231
00:15:18,636 --> 00:15:22,682
наскільки величезним є простір досліджуваних можливостей на початку проблеми.

232
00:15:22,682 --> 00:15:23,980
процес вирішення, все це.

233
00:15:23,980 --> 00:15:25,280
Але в цілому це вірно.

234
00:15:25,280 --> 00:15:28,535
Я думаю, що для деяких особливих винаходів є друга,

235
00:15:28,535 --> 00:15:31,040
глибша причина, чому ми їх недооцінюємо.

236
00:15:31,040 --> 00:15:35,194
Розуміння інформації в термінах бітів справді об’єдналося в повну теорію лише до

237
00:15:35,194 --> 00:15:39,400
1948 року, коли Клод Шеннон опублікував фундаментальну статтю з теорії інформації.

238
00:15:39,400 --> 00:15:43,440
Це практично збігалося з тим, коли Хеммінг розробив свій алгоритм.

239
00:15:43,440 --> 00:15:47,100
Це був той самий основоположний документ, який показав, у певному сенсі,

240
00:15:47,100 --> 00:15:50,560
що ефективне виправлення помилок завжди можливе, незалежно від того,

241
00:15:50,560 --> 00:15:53,920
наскільки висока ймовірність перевертань бітів, принаймні в теорії.

242
00:15:53,920 --> 00:15:58,131
Шеннон і Хеммінг, до речі, ділилися офісом у Bell Labs, незважаючи на те,

243
00:15:58,131 --> 00:16:02,400
що працювали над дуже різними речами, що навряд чи здається тут випадковим.

244
00:16:02,400 --> 00:16:05,940
Перемотуємо вперед на кілька десятиліть, і сьогодні багато з

245
00:16:05,940 --> 00:16:09,249
нас настільки занурені в роздуми про біти та інформацію,

246
00:16:09,249 --> 00:16:13,080
що легко не помітити, наскільки відмінним був цей спосіб мислення.

247
00:16:13,080 --> 00:16:15,531
За іронією долі, ідеї, які найглибше формують уявлення майбутнього покоління,

248
00:16:15,531 --> 00:16:17,920
зрештою виглядатимуть це майбутнє покоління простішим, ніж воно є насправді.

