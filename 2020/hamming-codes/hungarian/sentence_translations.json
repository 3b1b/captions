[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing?",
  "translatedText": "Gondolkodott már azon, hogyan lehetséges, hogy egy CD-t vagy DVD-t megkarcolva mégis lejátsszon mindent, amit tárol?",
  "model": "DeepL",
  "time_range": [
   3.62,
   10.1
  ]
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors.",
  "translatedText": "A karcolás valóban hatással van a lemezen lévő 1-esekre és 0-akra, így a lemez más adatokat olvas ki, mint amiket tárolt, de hacsak nem nagyon karcos a lemez, a kiolvasott bitek pontosan ugyanabba a fájlba dekódolódnak, mint ami rá volt kódolva, bitről bitre másolva, a hibák ellenére.",
  "model": "DeepL",
  "time_range": [
   10.9,
   27.44
  ]
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors.",
  "translatedText": "Van egy csomó matematikai okosság, amely lehetővé teszi számunkra az adatok tárolását, és ami ugyanilyen fontos, az adatok továbbítását, olyan módon, amely ellenáll a hibáknak.",
  "model": "DeepL",
  "time_range": [
   27.44,
   36.66
  ]
 },
 {
  "input": "Well, actually it doesn't take that much cleverness to come up with a way to do this.",
  "translatedText": "Nos, valójában nem kell túl sok okosság ahhoz, hogy kitaláljuk, hogyan lehet ezt megtenni.",
  "model": "DeepL",
  "time_range": [
   37.52,
   41.6
  ]
 },
 {
  "input": "Any file, whether it's a video, sound, text, code, image, whatever, is ultimately some sequence of 1s and 0s.",
  "translatedText": "Bármilyen fájl, legyen az videó, hang, szöveg, kód, kép, bármi, végső soron 1ek és 0k sorozata.",
  "model": "DeepL",
  "time_range": [
   42.06,
   50.38
  ]
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit.",
  "translatedText": "És egy egyszerű stratégia a felcserélődött bitek kijavítására az lenne, ha minden bit három példányát tárolnánk.",
  "model": "DeepL",
  "time_range": [
   50.68,
   56.0
  ]
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy.",
  "translatedText": "Ezután a fájlt olvasó gép össze tudná hasonlítani ezt a három másolatot, és mindig a háromból a legjobb kettőt választaná, ha eltérés van.",
  "model": "DeepL",
  "time_range": [
   57.58,
   64.06
  ]
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy.",
  "translatedText": "De ez azt jelenti, hogy a hely kétharmadát redundanciára használja.",
  "model": "DeepL",
  "time_range": [
   67.16,
   70.86
  ]
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped.",
  "translatedText": "És még így is, a feláldozott hely ellenére sincs erős garancia arra, hogy mi történik, ha egynél több bit felcserélődik.",
  "model": "DeepL",
  "time_range": [
   71.48,
   77.24
  ]
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible.",
  "translatedText": "Sokkal érdekesebb kérdés, hogy hogyan lehet úgy alakítani, hogy a hibák javíthatók legyenek, miközben a lehető legkevesebb helyet kelljen feladni.",
  "model": "DeepL",
  "time_range": [
   77.98,
   84.02
  ]
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9!",
  "translatedText": "Például a videóban megismert módszerrel 256 bites blokkokban tárolhatod az adatokat, ahol minden blokk 9 bitet használ, 9!",
  "model": "DeepL",
  "time_range": [
   84.52,
   93.36
  ]
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want.",
  "translatedText": "hogy egyfajta redundanciaként működjön, a többi 247 bit pedig szabadon hordozhat bármilyen értelmes üzenetet vagy adatot.",
  "model": "DeepL",
  "time_range": [
   93.76,
   100.3
  ]
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it.",
  "translatedText": "És még mindig az lesz a helyzet, hogy ha bármelyik bit itt felborul, csak ezt a blokkot megnézve és semmi mást, egy gép képes lesz azonosítani, hogy hiba történt, és pontosan hol, hogy tudja, hogyan kell korrigálni.",
  "model": "DeepL",
  "time_range": [
   100.9,
   112.66
  ]
 },
 {
  "input": "And honestly, that feels like magic.",
  "translatedText": "És őszintén szólva, ez olyan, mint a varázslat.",
  "model": "DeepL",
  "time_range": [
   112.66,
   114.62
  ]
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them.",
  "translatedText": "És ennél a konkrét sémánál, ha két bit felcserélődik, a gép legalább képes lesz felismerni, hogy két hiba történt, bár azt nem tudja, hogyan kell kijavítani.",
  "model": "DeepL",
  "time_range": [
   115.44,
   122.86
  ]
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes.",
  "translatedText": "Kicsit később még beszélünk arról, hogy ez hogyan skálázódik a különböző méretű blokkok esetében.",
  "model": "DeepL",
  "time_range": [
   123.52,
   126.9
  ]
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes.",
  "translatedText": "Az ilyen hibák kijavítását lehetővé tevő módszereket - ésszerűen - hibajavító kódoknak nevezik.",
  "model": "DeepL",
  "time_range": [
   127.86,
   132.9
  ]
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day.",
  "translatedText": "Az elmúlt évszázad nagy részében ez a terület a meglepően mély matematika igazán gazdag forrása volt, amelyet a mindennapokban használt eszközökbe építettek be.",
  "model": "DeepL",
  "time_range": [
   133.66,
   141.94
  ]
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code.",
  "translatedText": "A cél az, hogy nagyon alaposan megismerje az egyik legkorábbi példát, az úgynevezett Hamming-kódot.",
  "model": "DeepL",
  "time_range": [
   142.84,
   148.66
  ]
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there.",
  "translatedText": "És egyébként, ahogyan a videó felépítéséről gondolkodom, az kevésbé arról szól, hogy a lehető legközvetlenebbül elmagyarázzam, sokkal inkább arról, hogy arra ösztönözzelek benneteket, hogy találjátok ki magatoknak, egy kis gyengéd útmutatással itt-ott.",
  "model": "DeepL",
  "time_range": [
   149.52,
   159.82
  ]
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you.",
  "translatedText": "Tehát amikor úgy érzed, hogy látod, hova fog ez a dolog menni egy bizonyos ponton, akkor vedd ki azt a pillanatot, hogy megállj, és aktívan megjósold, hogy mi lesz a séma, mielőtt elmondanám neked.",
  "model": "DeepL",
  "time_range": [
   160.12,
   166.72
  ]
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying.",
  "translatedText": "Továbbá, ha szeretnéd, hogy a megértésed leérjen a hardver szintjére, Ben Eater készített egy videót ezzel a videóval kapcsolatban, amely bemutatja, hogyan lehet a Hamming-kódokat ténylegesen megvalósítani kenyérlapokon, ami rendkívül kielégítő.",
  "model": "DeepL",
  "time_range": [
   167.24,
   178.24
  ]
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming.",
  "translatedText": "Tudni kell, hogy a Hamming-kódokat nem használják olyan széles körben, mint a modernebb kódokat, például a Reed-Solomon algoritmust, de van egyfajta varázslatos kontraszt aközött, hogy mennyire lehetetlennek tűnik ez a feladat az elején, és mennyire teljesen ésszerűnek tűnik, amint megismerkedsz a Hamming-kódokkal.",
  "model": "DeepL",
  "time_range": [
   179.3,
   193.0
  ]
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages.",
  "translatedText": "A hibajavítás alapelve az, hogy a lehetséges üzenetek hatalmas terében csak néhány részhalmaz tekinthető érvényes üzenetnek.",
  "model": "DeepL",
  "time_range": [
   193.72,
   202.18
  ]
 },
 {
  "input": "As an analogy, think about correctly spelled words versus incorrectly spelled words.",
  "translatedText": "Analógia gyanánt gondoljon a helyesen és a helytelenül írt szavakra.",
  "model": "DeepL",
  "time_range": [
   202.8,
   206.94
  ]
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo.",
  "translatedText": "Amikor egy érvényes üzenet megváltozik, a címzett felelős azért, hogy a látottakat a legközelebbi érvényes szomszédra korrigálja, ahogyan egy elírás esetén is tenné.",
  "model": "DeepL",
  "time_range": [
   208.9,
   217.34
  ]
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, take a certain cleverness.",
  "translatedText": "Az ilyen üzenetek hatékony kategorizálására alkalmas konkrét algoritmus kidolgozásához azonban szükség van némi okosságra.",
  "model": "DeepL",
  "time_range": [
   218.22,
   224.06
  ]
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to.",
  "translatedText": "A történet az 1940-es években kezdődik, amikor a fiatal Richard Hamming a Bell Labs-nél dolgozott, és munkájának egy része egy nagyon nagy, drága lyukkártyás számítógép használatával járt, amelyhez csak korlátozottan volt hozzáférése.",
  "model": "DeepL",
  "time_range": [
   226.78,
   237.42
  ]
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread.",
  "translatedText": "És a programok, amelyeket folyamatosan átküldött rajta, folyamatosan kudarcot vallottak, mert időnként egy-egy bitet félreolvasott.",
  "model": "DeepL",
  "time_range": [
   237.8,
   242.4
  ]
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code.",
  "translatedText": "Mivel a frusztráció a találmányok olvasztótégelye, annyira elege lett, hogy feltalálta a világ első hibajavító kódját.",
  "model": "DeepL",
  "time_range": [
   243.12,
   248.42
  ]
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them.",
  "translatedText": "A Hamming-kódokat sokféleképpen lehet keretbe foglalni, de első körben úgy fogjuk végigvenni, ahogy maga Hamming gondolta őket.",
  "model": "DeepL",
  "time_range": [
   249.06,
   255.38
  ]
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits.",
  "translatedText": "Használjunk egy egyszerű, de nem túl egyszerű példát, egy 16 bites blokkot.",
  "model": "DeepL",
  "time_range": [
   256.52,
   260.94
  ]
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15.",
  "translatedText": "A bitek pozícióit 0-tól 15-ig számozzuk.",
  "model": "DeepL",
  "time_range": [
   261.82,
   264.74
  ]
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are going to be reserved as a kind of redundancy.",
  "translatedText": "A tárolni kívánt tényleges adatok csak 12 bitet fognak kitenni ezekből a bitekből, míg 4 pozíciót egyfajta redundanciaként foglalunk le.",
  "model": "DeepL",
  "time_range": [
   265.62,
   273.0
  ]
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data.",
  "translatedText": "A redundáns szó itt nem egyszerűen másolást jelent, elvégre ez a 4 bit nem ad elég helyet ahhoz, hogy vakon másoljuk az adatokat.",
  "model": "DeepL",
  "time_range": [
   273.9,
   280.04
  ]
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience.",
  "translatedText": "Ehelyett sokkal árnyaltabb és okosabb redundanciára lesz szükség, amely nem ad hozzá új információt, de növeli a rugalmasságot.",
  "model": "DeepL",
  "time_range": [
   280.72,
   287.28
  ]
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end.",
  "translatedText": "Azt várhatnánk, hogy ez a 4 különleges darab szépen össze lesz csomagolva, talán a végén, vagy valami ilyesmi, de mint látni fogjuk, ha olyan pozíciókban vannak, amelyek 2 hatványai, akkor a végére valami igazán elegánsat kapunk.",
  "model": "DeepL",
  "time_range": [
   288.6,
   299.62
  ]
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks.",
  "translatedText": "Ez egy kis támpontot adhat arra vonatkozóan is, hogy ez hogyan skálázódik nagyobb blokkok esetén.",
  "model": "DeepL",
  "time_range": [
   300.2,
   303.54
  ]
 },
 {
  "input": "Also, technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now.",
  "translatedText": "Továbbá, technikailag csak 11 bitnyi adatot tartalmaz, és egy enyhe árnyalatnyi eltérés van a 0. pozícióban, de ez most ne aggódj emiatt.",
  "model": "DeepL",
  "time_range": [
   304.9,
   313.26
  ]
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender, who's responsible for setting these 4 special bits, and then a receiver, who's responsible for performing some kind of check and then correcting the errors.",
  "translatedText": "Mint minden hibajavító algoritmusban, ebben is két szereplő vesz részt: egy feladó, aki felelős a 4 speciális bit beállításáért, és egy vevő, aki felelős valamilyen ellenőrzés elvégzéséért, majd a hibák kijavításáért.",
  "model": "DeepL",
  "time_range": [
   314.14,
   325.54
  ]
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing checks, and the idea of a message is meant really broadly, to include things like storage.",
  "translatedText": "Természetesen a feladó és a címzett szavak valójában az ellenőrzéseket végző gépekre vagy szoftverekre utalnak, és az üzenet fogalma nagyon tágan értendő, hogy olyan dolgokat is magában foglaljon, mint a tárolás.",
  "model": "DeepL",
  "time_range": [
   326.3,
   334.74
  ]
 },
 {
  "input": "After all, storing data is the same thing as sending a message, just from the past to the future, instead of from one place to another.",
  "translatedText": "Végül is az adatok tárolása ugyanaz, mint egy üzenet küldése, csak a múltból a jövőbe, nem pedig egyik helyről a másikra.",
  "model": "DeepL",
  "time_range": [
   335.34,
   341.68
  ]
 },
 {
  "input": "So that's the setup, but before we can dive in, we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check.",
  "translatedText": "Ez tehát a felállás, de mielőtt belevetnénk magunkat, beszélnünk kell egy kapcsolódó ötletről, amely Hamming fejében még frissen élt felfedezése idején, egy olyan módszerről, amely lehetővé teszi az egyes bithibák észlelését, de nem javítja azokat, és amelyet a szakmában paritás-ellenőrzésként ismerünk.",
  "model": "DeepL",
  "time_range": [
   342.56,
   356.3
  ]
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message.",
  "translatedText": "A paritásellenőrzésnél csak egyetlen bitet különítünk el, amelynek hangolásáért a küldő felelős, a többi szabadon hordozhatja az üzenetet.",
  "model": "DeepL",
  "time_range": [
   356.88,
   363.82
  ]
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number.",
  "translatedText": "Ennek a speciális bitnek csak az a feladata, hogy biztosítsa, hogy az üzenetben lévő 1-esek száma páros legyen.",
  "model": "DeepL",
  "time_range": [
   364.88,
   371.28
  ]
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even.",
  "translatedText": "Tehát például most az 1-esek száma 7, ami páratlan, ezért a küldőnek meg kell fordítania ezt a speciális bitet 1-esre, hogy a számolás páros legyen.",
  "model": "DeepL",
  "time_range": [
   372.08,
   379.96
  ]
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0.",
  "translatedText": "De ha a blokk már páros számú 1-essel indult volna, akkor ez a speciális bit 0 maradt volna.",
  "model": "DeepL",
  "time_range": [
   380.8,
   386.42
  ]
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information.",
  "translatedText": "Ez elég egyszerű, megtévesztően egyszerű, de hihetetlenül elegáns módja annak, hogy a változás gondolatát bárhol egy üzenetben úgy desztilláljuk, hogy az egyetlen információdarabban tükröződjön.",
  "model": "DeepL",
  "time_range": [
   387.34,
   396.78
  ]
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd.",
  "translatedText": "Figyeljük meg, hogy ha az üzenet bármelyik bitje felcserélődik, akár 0-ról 1-re, akár 1-ről 0-ra, akkor az 1-ek száma párosról páratlanra változik.",
  "model": "DeepL",
  "time_range": [
   397.5,
   406.54
  ]
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was.",
  "translatedText": "Tehát ha a címzettként megnézed ezt az üzenetet, és páratlan számú 1-est látsz, akkor biztosan tudhatod, hogy valamilyen hiba történt, még ha fogalmad sincs, hogy hol volt az.",
  "model": "DeepL",
  "time_range": [
   407.98,
   417.46
  ]
 },
 {
  "input": "In the jargon, whether a group of bits has an even or an odd number of 1s is known as its parity.",
  "translatedText": "A szakzsargonban a bitek páros vagy páratlan számú 1-est tartalmazó csoportját paritásnak nevezik.",
  "model": "DeepL",
  "time_range": [
   418.5,
   423.34
  ]
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea, and this special bit that the sender uses to control the parity is called the parity bit.",
  "translatedText": "Használhatsz számokat is, és mondhatod, hogy a paritás 0 vagy 1, ami általában hasznosabb, ha egyszer elkezdesz matematikázni az ötlettel, és ezt a speciális bitet, amelyet a feladó a paritás ellenőrzésére használ, paritásbitnek nevezzük.",
  "model": "DeepL",
  "time_range": [
   424.86,
   435.52
  ]
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors or 5 or any other odd number, but they can know for sure that it wasn't 0.",
  "translatedText": "És valójában, tisztázzuk, ha a vevő páratlan paritást lát, az nem feltétlenül jelenti azt, hogy csak egy hiba volt, lehetett 3 hiba, 5 vagy bármilyen más páratlan szám, de biztosan tudhatják, hogy nem 0 volt.",
  "model": "DeepL",
  "time_range": [
   437.56,
   449.26
  ]
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free.",
  "translatedText": "Másrészt, ha 2 hiba történt volna, vagy bármilyen páros számú hiba, akkor is páros lenne a végső 1-es szám, így a vevő nem bízhat teljes mértékben abban, hogy a páros szám szükségszerűen azt jelenti, hogy az üzenet hibátlan.",
  "model": "DeepL",
  "time_range": [
   449.98,
   462.3
  ]
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right.",
  "translatedText": "Panaszkodhatsz, hogy egy olyan üzenet, amelyet csak 2 bit felcserélése zavar, elég gyenge, és teljesen igazad lenne.",
  "model": "DeepL",
  "time_range": [
   462.84,
   469.08
  ]
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended.",
  "translatedText": "Ne feledje azonban, hogy nincs olyan hibafelderítési vagy hibajavítási módszer, amely 100%-os biztonságot adna abban, hogy a kapott üzenet a feladó szándéka szerint érkezik.",
  "model": "DeepL",
  "time_range": [
   469.7,
   478.9
  ]
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance.",
  "translatedText": "Elvégre elég véletlenszerű zaj mindig megváltoztathat egy érvényes üzenetet egy másik érvényes üzenetté, pusztán a véletlen folytán.",
  "model": "DeepL",
  "time_range": [
   479.58,
   485.44
  ]
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this.",
  "translatedText": "Ehelyett a cél egy olyan rendszer kidolgozása, amely egy bizonyos maximális hibaszámig robusztus, vagy esetleg az ilyen hamis pozitívumok valószínűségének csökkentése.",
  "model": "DeepL",
  "time_range": [
   486.24,
   495.38
  ]
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes.",
  "translatedText": "A paritásellenőrzés önmagában elég gyenge, de a teljes üzenetben bekövetkező változás gondolatának egyetlen bitre történő leegyszerűsítésével egy erőteljes építőelemet adnak a kifinomultabb rendszerekhez.",
  "model": "DeepL",
  "time_range": [
   496.26,
   507.16
  ]
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error.",
  "translatedText": "Például, mivel Hamming azt kereste, hogyan lehet azonosítani, hogy hol történt egy hiba, nem csak azt, hogy megtörtént, a legfontosabb felismerése az volt, hogy ha nem a teljes üzenetre, hanem bizonyos gondosan kiválasztott részhalmazokra alkalmazunk paritásellenőrzést, akkor egy olyan kifinomultabb kérdéssort tehetünk fel, amely pontosan meghatározza bármelyik bit hibájának helyét.",
  "model": "DeepL",
  "time_range": [
   507.94,
   525.94
  ]
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half.",
  "translatedText": "Az általános érzés egy kicsit olyan, mintha egy 20 kérdéses játékot játszanánk, ahol igen vagy nem kérdéseket teszünk fel, amelyek kettévágják a lehetőségek terét.",
  "model": "DeepL",
  "time_range": [
   526.68,
   533.38
  ]
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions.",
  "translatedText": "Tegyük fel, hogy például csak ezen a 8 biten, az összes páratlan számozott pozícióban paritásellenőrzést végzünk.",
  "model": "DeepL",
  "time_range": [
   534.16,
   539.38
  ]
 },
 {
  "input": "Then, if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position.",
  "translatedText": "Ezután, ha hibát észlel, a vevőnek egy kicsit több információt ad arról, hogy pontosan hol van a hiba, nevezetesen, hogy egy furcsa pozícióban van.",
  "model": "DeepL",
  "time_range": [
   540.1,
   548.24
  ]
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions.",
  "translatedText": "Ha a 8 bit között nem észlelünk hibát, az vagy azt jelenti, hogy egyáltalán nincs hiba, vagy valahol a páros pozíciók között van.",
  "model": "DeepL",
  "time_range": [
   548.94,
   556.24
  ]
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counter-intuitively gives us something a lot more powerful.",
  "translatedText": "Azt gondolhatnánk, hogy a paritás-ellenőrzés a bitek felére való korlátozása csökkenti annak hatékonyságát, de ha más, jól megválasztott ellenőrzésekkel együtt végezzük, akkor az intuitív módon sokkal hatékonyabbá teszi azt.",
  "model": "DeepL",
  "time_range": [
   557.18,
   567.2
  ]
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group.",
  "translatedText": "A paritásellenőrzés tényleges beállításához, ne feledje, hogy ehhez meg kell jelölni néhány speciális bitet, amely az adott teljes csoport paritását vezérli.",
  "model": "DeepL",
  "time_range": [
   569.24,
   576.62
  ]
 },
 {
  "input": "Here let's just choose position 1.",
  "translatedText": "Itt csak az 1-es pozíciót válasszuk.",
  "model": "DeepL",
  "time_range": [
   577.48,
   579.18
  ]
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even.",
  "translatedText": "A bemutatott példában a 8 bit paritása jelenleg páratlan, így a feladó feladata a paritásbit átkapcsolása, és most páros.",
  "model": "DeepL",
  "time_range": [
   579.72,
   586.98
  ]
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do.",
  "translatedText": "Ez csak 1 a 4 paritás-ellenőrzésből, amelyet elvégezünk.",
  "model": "DeepL",
  "time_range": [
   587.94,
   590.68
  ]
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here.",
  "translatedText": "A második ellenőrzés a rács jobb felén lévő 8 bit között van, legalábbis ahogyan itt megrajzoltuk.",
  "model": "DeepL",
  "time_range": [
   590.92,
   596.3
  ]
 },
 {
  "input": "This time we might use position 2 as a parity bit.",
  "translatedText": "Ezúttal a 2. pozíciót használhatjuk paritásbitként.",
  "model": "DeepL",
  "time_range": [
   596.68,
   599.58
  ]
 },
 {
  "input": "So these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged.",
  "translatedText": "Tehát ez a 8 bit már páros paritású, és a feladó nyugodtan hagyhatja a 2. bitet változatlanul.",
  "model": "DeepL",
  "time_range": [
   600.02,
   606.06
  ]
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right.",
  "translatedText": "A másik oldalon, ha a vevő ellenőrzi ennek a csoportnak a paritását, és azt találja, hogy az páratlan, akkor tudni fogja, hogy a hiba valahol a jobb oldali 8 bit között van.",
  "model": "DeepL",
  "time_range": [
   607.02,
   615.38
  ]
 },
 {
  "input": "Otherwise, it means either there's no error, or the error is somewhere on the left half.",
  "translatedText": "Ellenkező esetben ez azt jelenti, hogy vagy nincs hiba, vagy a hiba valahol a bal oldalon van.",
  "model": "DeepL",
  "time_range": [
   615.82,
   620.58
  ]
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block.",
  "translatedText": "Vagy azt hiszem, lehetett volna két hiba is, de egyelőre feltételezzük, hogy az egész blokkban legfeljebb egy hiba van.",
  "model": "DeepL",
  "time_range": [
   621.12,
   626.5
  ]
 },
 {
  "input": "Things break down completely for more than that.",
  "translatedText": "Ennél többre teljesen összeomlanak a dolgok.",
  "model": "DeepL",
  "time_range": [
   626.94,
   628.74
  ]
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together.",
  "translatedText": "Mielőtt megnézzük a következő két ellenőrzést, szánjunk egy pillanatot arra, hogy átgondoljuk, mit tesz lehetővé számunkra ez az első kettő, ha együtt vesszük őket figyelembe.",
  "model": "DeepL",
  "time_range": [
   629.16,
   635.1
  ]
 },
 {
  "input": "Let's say you detect an error among the odd columns and among the right half.",
  "translatedText": "Tegyük fel, hogy a páratlan oszlopok között és a jobb oldali felénél hibát észlel.",
  "model": "DeepL",
  "time_range": [
   635.8,
   639.66
  ]
 },
 {
  "input": "It necessarily means the error is somewhere in the last column.",
  "translatedText": "Ez szükségszerűen azt jelenti, hogy a hiba valahol az utolsó oszlopban van.",
  "model": "DeepL",
  "time_range": [
   640.2,
   643.04
  ]
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column.",
  "translatedText": "Ha a páratlan oszlopban nem volt hiba, de a jobb felében volt, akkor az azt jelenti, hogy az utolsó előtti oszlopban van.",
  "model": "DeepL",
  "time_range": [
   643.82,
   649.7
  ]
 },
 {
  "input": "Likewise, if there is an error in the odd columns but not in the right half, you know that it's somewhere in the second column.",
  "translatedText": "Hasonlóképpen, ha a páratlan oszlopokban van hiba, de a jobb felében nincs, akkor tudja, hogy valahol a második oszlopban van a hiba.",
  "model": "DeepL",
  "time_range": [
   650.44,
   656.02
  ]
 },
 {
  "input": "And then if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column.",
  "translatedText": "És ha a két paritásellenőrzés egyike sem észlel semmit, akkor ez azt jelenti, hogy az egyetlen hely, ahol hiba lehet, az a bal szélső oszlop.",
  "model": "DeepL",
  "time_range": [
   656.02,
   663.12
  ]
 },
 {
  "input": "But it also might simply mean there's no error at all.",
  "translatedText": "De az is lehet, hogy egyszerűen csak azt jelenti, hogy egyáltalán nincs hiba.",
  "model": "DeepL",
  "time_range": [
   663.34,
   666.12
  ]
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column.",
  "translatedText": "Mindez eléggé elnagyoltan azt jelenti, hogy két paritás-ellenőrzéssel le tudjuk szögezni az oszlopot.",
  "model": "DeepL",
  "time_range": [
   666.3,
   670.84
  ]
 },
 {
  "input": "From here, you can probably guess what follows.",
  "translatedText": "Innen valószínűleg kitalálhatod, mi következik.",
  "model": "DeepL",
  "time_range": [
   671.48,
   673.64
  ]
 },
 {
  "input": "We do basically the same thing but for the rows.",
  "translatedText": "Alapvetően ugyanezt tesszük, de a sorok esetében.",
  "model": "DeepL",
  "time_range": [
   673.8,
   676.14
  ]
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit.",
  "translatedText": "A páratlan sorokban paritásellenőrzés lesz, a 4-es pozíciót használva paritásbitként.",
  "model": "DeepL",
  "time_range": [
   676.44,
   680.9
  ]
 },
 {
  "input": "So in this example, that group already has an even parity, so bit 4 would be set to a 0.",
  "translatedText": "Ebben a példában tehát a csoport már páros paritású, így a 4. bit 0-ra lesz állítva.",
  "model": "DeepL",
  "time_range": [
   681.38,
   685.82
  ]
 },
 {
  "input": "And finally, there's a parity check on the bottom two rows, using position 8 as a parity bit.",
  "translatedText": "Végül az alsó két sorban paritásellenőrzés van, a 8-as pozíciót használva paritásbitként.",
  "model": "DeepL",
  "time_range": [
   686.56,
   691.58
  ]
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity.",
  "translatedText": "Ebben az esetben úgy tűnik, hogy a küldőnek be kell kapcsolnia a 8-as bitet, hogy a csoportnak páros paritást adjon.",
  "model": "DeepL",
  "time_range": [
   692.12,
   696.82
  ]
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row.",
  "translatedText": "Ahogy az első két ellenőrzéssel az oszlopot, úgy a következő kettővel a sort lehet meghatározni.",
  "model": "DeepL",
  "time_range": [
   697.7,
   701.84
  ]
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3.",
  "translatedText": "Képzeljük el, hogy az átvitel során hiba lép fel, mondjuk a 3. pozícióban.",
  "model": "DeepL",
  "time_range": [
   702.88,
   707.54
  ]
 },
 {
  "input": "Well, this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column.",
  "translatedText": "Nos, ez érinti az első paritáscsoportot, és érinti a második paritáscsoportot is, így a vevő tudja, hogy valahol a jobb oldali oszlopban hiba van.",
  "model": "DeepL",
  "time_range": [
   708.18,
   715.56
  ]
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group.",
  "translatedText": "De nem érinti a harmadik csoportot, és nem érinti a negyedik csoportot.",
  "model": "DeepL",
  "time_range": [
   716.1,
   720.54
  ]
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error.",
  "translatedText": "Ez lehetővé teszi a vevő számára, hogy a hibát az első sorig, azaz szükségszerűen a 3. pozícióig lokalizálja, és így kijavíthassa a hibát.",
  "model": "DeepL",
  "time_range": [
   721.24,
   727.52
  ]
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be.",
  "translatedText": "Egy pillanatra meggyőződhet arról, hogy az erre a négy kérdésre adott válaszok valóban mindig lehetővé teszik egy konkrét helyszín meghatározását, függetlenül attól, hogy hová kerülnek.",
  "model": "DeepL",
  "time_range": [
   728.58,
   737.1
  ]
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting.",
  "translatedText": "Sőt, az éles eszűek talán még azt is észreveszik, hogy van kapcsolat e kérdések és a bináris számolás között.",
  "model": "DeepL",
  "time_range": [
   737.72,
   743.06
  ]
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it.",
  "translatedText": "És ha mégis, még egyszer hangsúlyozom, tartsatok szünetet, próbáljátok meg magatoknak felidézni az összefüggést, mielőtt elrontom.",
  "model": "DeepL",
  "time_range": [
   743.5,
   748.92
  ]
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it.",
  "translatedText": "Ha kíváncsi vagy, mi történik, ha egy paritásbit maga is sérül, nos, csak próbáld ki.",
  "model": "DeepL",
  "time_range": [
   750.5,
   756.06
  ]
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions.",
  "translatedText": "Gondoljon egy pillanatra arra, hogy e négy különleges bit között bármilyen hiba ugyanúgy nyomon követhető, mint bármelyik másik, ugyanannak a négy kérdéscsoportnak a segítségével.",
  "model": "DeepL",
  "time_range": [
   756.44,
   764.18
  ]
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along.",
  "translatedText": "Ez nem igazán számít, mivel végső soron az üzenet bitjeit akarjuk védeni, a hibajavító bitek csak kísérik a folyamatot.",
  "model": "DeepL",
  "time_range": [
   767.06,
   773.1
  ]
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct.",
  "translatedText": "De ezeknek a részeknek a védelme is olyan dolog, ami természetesen melléktermékként kiesik a rendszerből.",
  "model": "DeepL",
  "time_range": [
   773.6,
   777.82
  ]
 },
 {
  "input": "You might also enjoy anticipating how this scales.",
  "translatedText": "Azt is élvezheted, hogy előre láthatod, hogyan skálázódik.",
  "model": "DeepL",
  "time_range": [
   779.2,
   781.76
  ]
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot.",
  "translatedText": "Ha például egy 256 bit méretű blokkot használnánk egy hely meghatározásához, akkor csak nyolc igen vagy nem kérdésre lenne szükségünk ahhoz, hogy binárisan keressük az utat egy adott pontig.",
  "model": "DeepL",
  "time_range": [
   782.3,
   792.78
  ]
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check.",
  "translatedText": "És ne feledje, hogy minden kérdésnél csak egyetlen bitet kell feladni a megfelelő paritásellenőrzés beállításához.",
  "model": "DeepL",
  "time_range": [
   795.64,
   800.5
  ]
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two.",
  "translatedText": "Néhányan talán már látják, de később beszélni fogunk arról, hogyan lehet szisztematikusan megtalálni, hogy mik ezek a kérdések egy-két perc múlva.",
  "model": "DeepL",
  "time_range": [
   803.16,
   809.36
  ]
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here.",
  "translatedText": "Remélhetőleg ez a vázlat elég ahhoz, hogy értékeljük annak hatékonyságát, amit itt fejlesztünk.",
  "model": "DeepL",
  "time_range": [
   809.88,
   813.66
  ]
 },
 {
  "input": "Everything except for those eight highlighted parity bits can be whatever you want it to be, carrying whatever message or data you want.",
  "translatedText": "A nyolc kiemelt paritásbit kivételével minden olyan lehet, amilyennek csak akarod, bármilyen üzenetet vagy adatot hordozhatsz.",
  "model": "DeepL",
  "time_range": [
   813.66,
   821.0
  ]
 },
 {
  "input": "The eight bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole.",
  "translatedText": "A nyolc bit redundáns abban az értelemben, hogy teljesen az üzenet többi része határozza meg őket, de ez sokkal okosabb módon történik, mintha egyszerűen az üzenet egészét másolnánk.",
  "model": "DeepL",
  "time_range": [
   821.72,
   830.02
  ]
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error.",
  "translatedText": "És mégis, ilyen kevésért, amit feladtál, képes lennél azonosítani és kijavítani minden egyes bit hibát.",
  "model": "DeepL",
  "time_range": [
   833.6,
   838.38
  ]
 },
 {
  "input": "Well, almost.",
  "translatedText": "Nos, majdnem.",
  "model": "DeepL",
  "time_range": [
   839.2,
   840.4
  ]
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of eight bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position zero.",
  "translatedText": "Oké, tehát az egyetlen probléma itt az, hogy ha a négy paritásellenőrzés egyike sem észlel hibát, ami azt jelenti, hogy a nyolc bit speciálisan kiválasztott részhalmazai mind páros paritásúak, ahogyan a feladó tervezte, akkor ez vagy azt jelenti, hogy egyáltalán nem volt hiba, vagy leszűkít minket a nulladik pozícióra.",
  "model": "DeepL",
  "time_range": [
   840.96,
   856.86
  ]
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing one out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition.",
  "translatedText": "Négy igen vagy nem kérdéssel 16 lehetséges kimenetelű paritásellenőrzésünk van, és ez elsőre tökéletesnek tűnik ahhoz, hogy a blokk 16 pozíciójából egyet pontosan meghatározzunk, de egy 17. kimenetet is közölnünk kell, a hiba nélküli állapotot.",
  "model": "DeepL",
  "time_range": [
   857.74,
   871.9
  ]
 },
 {
  "input": "The solution here is actually pretty simple.",
  "translatedText": "A megoldás itt valójában nagyon egyszerű.",
  "model": "DeepL",
  "time_range": [
   873.02,
   874.86
  ]
 },
 {
  "input": "Just forget about that zeroth bit entirely.",
  "translatedText": "Felejtsd el teljesen a nulladik részt.",
  "model": "DeepL",
  "time_range": [
   875.28,
   877.3
  ]
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error.",
  "translatedText": "Amikor tehát elvégezzük a négy paritásellenőrzést, és azt látjuk, hogy mindegyiket párosnak találjuk, az egyértelműen azt jelenti, hogy nincs hiba.",
  "model": "DeepL",
  "time_range": [
   877.84,
   883.46
  ]
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and four of them are there for redundancy.",
  "translatedText": "Ez azt jelenti, hogy ahelyett, hogy 16 bites blokkokkal dolgoznánk, 15 bites blokkokkal dolgozunk, ahol 11 bit szabadon hordozhatja az üzenetet, négy pedig a redundancia miatt van.",
  "model": "DeepL",
  "time_range": [
   884.24,
   893.22
  ]
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code.",
  "translatedText": "És ezzel megvan az, amit a szakmában 15-11-es Hamming-kódnak neveznek.",
  "model": "DeepL",
  "time_range": [
   893.78,
   898.8
  ]
 },
 {
  "input": "That said, it is nice to have a block size that's a clean power of two, and there's a clever way that we can keep that zeroth bit around and get it to do a little extra work for us.",
  "translatedText": "Ennek ellenére jó, ha van egy olyan blokkméretünk, amely tiszta kettes hatványa, és van egy okos módja annak, hogy a nulladik bitet megtartsuk, és rávegyük, hogy egy kis extra munkát végezzen el nekünk.",
  "model": "DeepL",
  "time_range": [
   899.86,
   908.14
  ]
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, two-bit errors.",
  "translatedText": "Ha ezt paritásbitként használjuk az egész blokkban, akkor lehetővé teszi számunkra a kétbites hibák felismerését, még ha nem is tudjuk kijavítani azokat.",
  "model": "DeepL",
  "time_range": [
   908.7,
   915.54
  ]
 },
 {
  "input": "Here's how it works.",
  "translatedText": "Így működik.",
  "model": "DeepL",
  "time_range": [
   916.16,
   916.82
  ]
 },
 {
  "input": "After setting those four special error correcting bits, we set that zeroth one so that the parity of the full block is even, just like a normal parity check.",
  "translatedText": "A négy speciális hibajavító bit beállítása után a nulladik bitet úgy állítjuk be, hogy a teljes blokk paritása páros legyen, akárcsak a normál paritásellenőrzésnél.",
  "model": "DeepL",
  "time_range": [
   917.18,
   924.94
  ]
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway, thanks to the four error correcting checks.",
  "translatedText": "Most, ha egyetlen bit hiba van, akkor a teljes blokk paritása páratlanná változik, de a négy hibajavító ellenőrzésnek köszönhetően ezt mindenképpen észrevennénk.",
  "model": "DeepL",
  "time_range": [
   925.7,
   933.6
  ]
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four usual parity checks.",
  "translatedText": "Ha azonban két hiba van, akkor a teljes paritás visszaváltozik párosra, de a vevő még mindig látja, hogy legalább némi hiba történt, mivel a négy szokásos paritásellenőrzéssel történik.",
  "model": "DeepL",
  "time_range": [
   934.16,
   945.18
  ]
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors.",
  "translatedText": "Ha tehát azt veszik észre, hogy a paritás összességében páros, de a többi ellenőrzésnél valami nem nulla, akkor ez azt jelenti, hogy legalább két hiba történt.",
  "model": "DeepL",
  "time_range": [
   945.18,
   952.7
  ]
 },
 {
  "input": "Isn't that clever?",
  "translatedText": "Hát nem okos?",
  "model": "DeepL",
  "time_range": [
   953.52,
   954.0
  ]
 },
 {
  "input": "Even though we can't correct those two-bit errors, just by putting that one little bothersome zeroth bit back to work, it lets us detect them.",
  "translatedText": "Még ha nem is tudjuk kijavítani ezeket a kétbites hibákat, csak azáltal, hogy azt a kis zavaró nulladik bitet újra munkába állítjuk, lehetővé teszi számunkra, hogy felismerjük őket.",
  "model": "DeepL",
  "time_range": [
   954.3,
   961.26
  ]
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code.",
  "translatedText": "Ez eléggé szabványos, kiterjesztett Hamming-kódként ismert.",
  "model": "DeepL",
  "time_range": [
   962.26,
   965.22
  ]
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block, but I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself.",
  "translatedText": "Technikailag most már teljes leírást kaptál arról, hogy mit csinál egy Hamming-kód, legalábbis a 16 bites blokk példájára, de azt hiszem, sokkal kielégítőbbnek fogod találni, ha ellenőrzöd a megértésedet és megszilárdítasz mindent, amit eddig a pontig megértettél, ha egy teljes példát csinálsz az elejétől a végéig.",
  "model": "DeepL",
  "time_range": [
   966.54,
   981.32
  ]
 },
 {
  "input": "I'll step through it with you though so you can check yourself.",
  "translatedText": "De azért végigmegyek veled, hogy te magad is ellenőrizhesd.",
  "model": "DeepL",
  "time_range": [
   982.08,
   984.3
  ]
 },
 {
  "input": "To set up a message, whether that's a literal message that you're translating over space, or some data that you want to store over time, the first step is to divide it up into 11-bit chunks.",
  "translatedText": "Egy üzenet beállításához, legyen szó akár szó szerinti üzenetről, amelyet a térben kell lefordítani, vagy valamilyen adatról, amelyet időben akarunk tárolni, az első lépés az, hogy 11 bites darabokra osztjuk.",
  "model": "DeepL",
  "time_range": [
   985.12,
   994.66
  ]
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block.",
  "translatedText": "Minden egyes darabot egy hibaálló 16 bites blokkba csomagolunk.",
  "model": "DeepL",
  "time_range": [
   995.58,
   999.76
  ]
 },
 {
  "input": "So let's take this one as an example and actually work it out.",
  "translatedText": "Vegyük tehát ezt az egyet példának, és dolgozzuk ki.",
  "model": "DeepL",
  "time_range": [
   999.76,
   1003.22
  ]
 },
 {
  "input": "Go ahead, actually do it!",
  "translatedText": "Gyerünk, csináld meg!",
  "model": "DeepL",
  "time_range": [
   1003.74,
   1004.94
  ]
 },
 {
  "input": "Pause and try putting together this block.",
  "translatedText": "Állj meg, és próbáld meg összerakni ezt a blokkot.",
  "model": "DeepL",
  "time_range": [
   1005.22,
   1007.02
  ]
 },
 {
  "input": "Okay, you ready?",
  "translatedText": "Oké, készen állsz?",
  "model": "DeepL",
  "time_range": [
   1012.72,
   1013.68
  ]
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order.",
  "translatedText": "Ne feledjük, hogy a 0. pozíció és a többi 2-es hatvány a hibajavítási feladatra van fenntartva, ezért az üzenetbiteket az összes többi helyre kell elhelyezni, sorrendben.",
  "model": "DeepL",
  "time_range": [
   1014.24,
   1023.32
  ]
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0.",
  "translatedText": "Ennek a csoportnak páros paritásúnak kell lennie, ami már megvan, ezért az 1-es pozícióban lévő paritásbitet 0-ra kellett volna állítani.",
  "model": "DeepL",
  "time_range": [
   1025.34,
   1032.34
  ]
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1.",
  "translatedText": "A következő csoport páratlan paritással kezdődik, ezért a paritásbitjét 1-esre kell állítani.",
  "model": "DeepL",
  "time_range": [
   1033.02,
   1037.88
  ]
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1.",
  "translatedText": "Az ezt követő csoport páratlan paritással kezdődik, ezért a paritásbitet ismét 1-re kell állítani.",
  "model": "DeepL",
  "time_range": [
   1039.16,
   1044.24
  ]
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1.",
  "translatedText": "És az utolsó csoport is páratlan paritású, ami azt jelenti, hogy a 8-as pozícióban lévő bitet 1-esre állítjuk.",
  "model": "DeepL",
  "time_range": [
   1044.78,
   1050.06
  ]
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning that you can set that bit number 0, the overarching parity bit, to be 0.",
  "translatedText": "Az utolsó lépésként a teljes blokk most már páros paritású, ami azt jelenti, hogy a 0-s számú bitet, az átfogó paritásbitet 0-ra állíthatjuk.",
  "model": "DeepL",
  "time_range": [
   1051.3,
   1060.32
  ]
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0.",
  "translatedText": "Így amikor ez a blokk elküldésre kerül, a négy speciális részhalmaz és a blokk egésze paritása mind páros, azaz 0 lesz.",
  "model": "DeepL",
  "time_range": [
   1061.34,
   1068.14
  ]
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver.",
  "translatedText": "A gyakorlat második részeként játsszuk el a befogadó szerepét.",
  "model": "DeepL",
  "time_range": [
   1068.82,
   1072.18
  ]
 },
 {
  "input": "Of course, that would mean you don't already know what this message is.",
  "translatedText": "Ez persze azt jelentené, hogy még nem tudod, mi ez az üzenet.",
  "model": "DeepL",
  "time_range": [
   1073.48,
   1076.82
  ]
 },
 {
  "input": "Maybe some of you memorized it, but let's assume that you haven't.",
  "translatedText": "Talán néhányan közületek megjegyezték, de tegyük fel, hogy nem.",
  "model": "DeepL",
  "time_range": [
   1077.08,
   1079.78
  ]
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did.",
  "translatedText": "Azt fogom tenni, hogy megváltoztatom a blokk 0, 1 vagy 2 bitjét, majd megkérlek, hogy találd ki, mit csináltam.",
  "model": "DeepL",
  "time_range": [
   1080.02,
   1087.74
  ]
 },
 {
  "input": "So again, pause and try working it out.",
  "translatedText": "Tehát ismét szünet, és próbáld meg kidolgozni.",
  "model": "DeepL",
  "time_range": [
   1088.26,
   1090.81
  ]
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group, and you can see that it's even, so any error that exists would have to be in an even column.",
  "translatedText": "Oké, tehát a vevőként most ellenőrizheted az első paritáscsoportot, és láthatod, hogy az páros, tehát bármilyen hibának a páros oszlopban kell lennie.",
  "model": "DeepL",
  "time_range": [
   1098.79,
   1107.91
  ]
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column.",
  "translatedText": "A következő ellenőrzés páratlan számot ad, ami egyrészt azt jelzi, hogy legalább egy hiba van, másrészt pedig leszűkíti a kört erre a konkrét oszlopra.",
  "model": "DeepL",
  "time_range": [
   1109.69,
   1117.03
  ]
 },
 {
  "input": "The third check is even, chopping down the possibilities even further.",
  "translatedText": "A harmadik csekk páros, ami még tovább csökkenti a lehetőségeket.",
  "model": "DeepL",
  "time_range": [
   1118.55,
   1121.79
  ]
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10.",
  "translatedText": "Az utolsó paritásellenőrzés pedig furcsa, és azt mondja, hogy valahol az alján van egy hiba, aminek mostanra már látjuk, hogy a 10-es pozícióban kell lennie.",
  "model": "DeepL",
  "time_range": [
   1122.65,
   1129.65
  ]
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two.",
  "translatedText": "Ráadásul az egész blokk paritása páratlan, így biztosak lehetünk benne, hogy egy szaltó volt, és nem kettő.",
  "model": "DeepL",
  "time_range": [
   1131.49,
   1137.53
  ]
 },
 {
  "input": "If it's three or more, all bets are off.",
  "translatedText": "Ha három vagy több, minden tétnek vége.",
  "model": "DeepL",
  "time_range": [
   1138.07,
   1139.97
  ]
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with.",
  "translatedText": "Miután kijavítottuk a 10-es számú bitet, a korrekcióra nem használt 11 bit kihúzásával megkapjuk az eredeti üzenet megfelelő szegmensét, amely, ha visszatekerjük és összehasonlítjuk, valóban pontosan az, amivel a példát kezdtük.",
  "model": "DeepL",
  "time_range": [
   1141.31,
   1154.39
  ]
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code.",
  "translatedText": "És most, hogy már tudod, hogyan kell mindezt kézzel csinálni, szeretném megmutatni, hogyan tudod egyetlen sor Python kóddal végrehajtani ennek a logikának a központi részét.",
  "model": "DeepL",
  "time_range": [
   1155.71,
   1163.17
  ]
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks.",
  "translatedText": "Látod, amit még nem mondtam el neked, az az, hogy mennyire elegáns ez az algoritmus, milyen egyszerű rávenni egy gépet, hogy rámutasson a hiba helyére, hogyan lehet szisztematikusan skálázni, és hogyan tudjuk mindezt egyetlen műveletként keretezni, nem pedig több különálló paritás-ellenőrzésként.",
  "model": "DeepL",
  "time_range": [
   1163.87,
   1178.75
  ]
 },
 {
  "input": "To see what I mean, come join me in part two.",
  "translatedText": "Hogy lásd, mire gondolok, gyere velem a második részbe.",
  "model": "DeepL",
  "time_range": [
   1179.43,
   1181.31
  ]
 }
]