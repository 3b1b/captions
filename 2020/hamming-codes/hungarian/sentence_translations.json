[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing?",
  "model": "nmt",
  "translatedText": "Elgondolkodtál már azon, hogyan lehetséges az, ha egy CD vagy DVD megkarcolódik, még mindig le lehet játszani amit tárol?",
  "time_range": [
   3.62,
   10.1
  ]
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors.",
  "model": "nmt",
  "translatedText": "A karcolás valóban hatással van a lemezen lévő 1-ekre és 0-kra, tehát a tárolttól eltérő adatok olvasódnak ki. Viszont hacsak nem teljesen karcolódott össze, a kiolvasott bitek pontosan ugyanazon fájllá dekódolódnak, amelyik eredetileg rá volt égetve. Egy tökéletes másolat, mindezen hibák ellenére.",
  "time_range": [
   10.9,
   27.44
  ]
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors.",
  "model": "nmt",
  "translatedText": "Számtalan ötletes matematikai trükk van, amely lehetővé teszi az adatok tárolását, és ami ugyanilyen fontos, az adatok továbbítását oly módon, amely ellenáll a hibáknak.",
  "time_range": [
   27.44,
   36.2
  ]
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this.",
  "model": "nmt",
  "translatedText": "Nos, oké, valójában nincs szükség akkora ötletre, hogy kitaláljunk erre egy módszert.",
  "time_range": [
   36.2,
   40.88
  ]
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s.",
  "model": "nmt",
  "translatedText": "Bármely fájl, legyen szó videóról, hangról, szövegről, vagy valamilyen kódról, képről vagy bármi másról, végső soron 1-esek és 0-k sorozata.",
  "time_range": [
   40.88,
   50.38
  ]
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit.",
  "model": "nmt",
  "translatedText": "Az átbillent bitek kijavítására egy egyszerű stratégia az lenne, ha minden bitből három másolatot tárolnánk.",
  "time_range": [
   50.68,
   56.0
  ]
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy.",
  "model": "nmt",
  "translatedText": "Ekkor a fájlt olvasó gép össze tudja hasonlítani ezt a három másolatot, és eltérés esetén mindig azt az értéket tartja helyesnek, amely legalább 2-szer fordul elő.",
  "time_range": [
   57.58,
   64.06
  ]
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy.",
  "model": "nmt",
  "translatedText": "De ez azt jelenti, hogy a hely kétharmadát redundanciára használjuk.",
  "time_range": [
   67.16,
   70.86
  ]
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped.",
  "model": "nmt",
  "translatedText": "És még ennyi hely feladása sem garantálja a helyes működést akkor, ha egynél több bit billen át.",
  "time_range": [
   71.48,
   77.24
  ]
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible.",
  "model": "nmt",
  "translatedText": "Sokkal érdekesebb kérdés, hogy hogyan lehet egy olyan módszert találni, amellyel a lehető legkevesebb hely felhasználása mellett ki lehet javítani a hibákat.",
  "time_range": [
   77.98,
   84.02
  ]
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9!",
  "model": "nmt",
  "translatedText": "Például az a módszer, amit hamarosan bemutatok, 256 bites blokkokban tárolja az adatokat, ahol minden blokk csak kilenc bitet használ. 9-et!",
  "time_range": [
   84.52000000000001,
   93.36
  ]
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want.",
  "model": "nmt",
  "translatedText": "ezek egyfajta redundanciaként működnek, a többi 247 bit pedig szabadon hordozhat bármilyen értelmes üzenetet vagy adatot, amit csak akarunk.",
  "time_range": [
   93.76,
   100.3
  ]
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it.",
  "model": "nmt",
  "translatedText": "Ez azt fogja eredményezni, hogy ha itt bármelyik bit megfordul, csak erre a blokkra nézve, és semmi másra, a gép képes lesz azonosítani, hogy hiba történt, és hogy pontosan hol volt, így tudja, hogyan kell kijavítani.",
  "time_range": [
   100.9,
   112.66
  ]
 },
 {
  "input": "And honestly, that feels like magic.",
  "model": "nmt",
  "translatedText": "Őszintén szólva, ez varázslatnak tűnik.",
  "time_range": [
   112.66,
   114.62
  ]
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them.",
  "model": "nmt",
  "translatedText": "És ennél a konkrét sémánál, ha két bit billen át, a gép legalább észlelni fogja a két hibát, bár nem tudja, hogyan javítsa ki őket.",
  "time_range": [
   115.44,
   122.86
  ]
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes.",
  "model": "nmt",
  "translatedText": "Egy kicsit később beszélünk arról is, hogy ez hogyan skálázható különböző méretű blokkokhoz.",
  "time_range": [
   123.52,
   126.9
  ]
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes.",
  "model": "nmt",
  "translatedText": "Az ehhez hasonló hibák kijavítását lehetővé tevő módszereket, talán nem meglepő módon, hibajavító kódoknak nevezik.",
  "time_range": [
   127.86,
   132.9
  ]
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day.",
  "model": "nmt",
  "translatedText": "Ez a terület meglepően komoly matematikai eredmények gazdag forrása volt a múlt század jelentős hányadában, és ezek nagy része beépült az általunk nap mint nap használt eszközökbe.",
  "time_range": [
   133.66,
   141.94
  ]
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code.",
  "model": "nmt",
  "translatedText": "A célom az, hogy segítsek alaposan megérteni az egyik legkorábbi, Hamming-kódként ismert módszert.",
  "time_range": [
   142.84,
   148.66
  ]
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there.",
  "model": "nmt",
  "translatedText": "És mellesleg, ahogyan ennek a videónak a felépítésére gondolok, nem szájbarágósan szeretném elmagyarázni, ezért inkább arra foglak ösztönözni, hogy jöjj rá magadtól, itt-ott egy kis célzott segítséggel.",
  "time_range": [
   149.52,
   159.82
  ]
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you.",
  "model": "nmt",
  "translatedText": "Tehát amikor úgy érzed egy ponton, hogy látod mire akarok kilyukadni, nyugodtan szüneteltesd a videót, és aktívan jósold meg, mi lesz a megoldás, mielőtt elmondanám.",
  "time_range": [
   160.12,
   166.72
  ]
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying.",
  "model": "nmt",
  "translatedText": "Továbbá, ha azt szeretnéd, hogy ennek a hardver szintű működését is megértsed, Ben Eater készített egy ehhez kapcsolódó videót, amely bemutatja, hogyan kell próbapanelen implementálni a Hamming-kódokat, ami rendkívül kielégítő.",
  "time_range": [
   167.24,
   178.24
  ]
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming.",
  "model": "nmt",
  "translatedText": "Érdemes tudni, hogy a Hamming-kódokat nem használják már olyan széles körben, mint a modernebb kódokat, például a Reed-Solomon algoritmust. Ellenben van egy bizonyos varázsa annak a kontrasztnak, hogy mennyire lehetetlennek tűnik ez a feladat az elején, és mennyire ésszerűnek miután megismered a Hamming-kódot.",
  "time_range": [
   179.3,
   193.0
  ]
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages.",
  "model": "nmt",
  "translatedText": "A hibajavítás alapelve, hogy az összes lehetséges üzenetet tartalmazó hatalmas térnek csak egy részhalmazát fogunk érvényes üzenetnek tekinteni.",
  "time_range": [
   193.72,
   202.18
  ]
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words.",
  "model": "nmt",
  "translatedText": "Analógiaként gondolhatunk a helyesen és a helytelenül írt szavakra.",
  "time_range": [
   202.8,
   206.94
  ]
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo.",
  "model": "nmt",
  "translatedText": "Amikor egy elküldött üzenet módosul, a fogadó felelős azért, hogy amit lát, a legközelebbi értelmes üzenetté alakítsa, pont ahogy azt mi az elírások esetén tesszük.",
  "time_range": [
   208.9,
   217.34
  ]
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness.",
  "model": "nmt",
  "translatedText": "Egy konkrét algoritmus kidolgozása az ehhez hasonló üzenetek hatékony kategorizálására azonban bizonyos okosságot igényel.",
  "time_range": [
   218.22,
   224.06
  ]
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to.",
  "model": "nmt",
  "translatedText": "A történet az 1940-es években kezdődik, amikor a fiatal Richard Hamming a Bell Labs-nál dolgozott, és néhány feladata egy nagyon nagy és drága lyukkártyás számítógép használatát igényelte, amelyhez csak korlátozott hozzáférése volt.",
  "time_range": [
   226.78,
   237.42
  ]
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread.",
  "model": "nmt",
  "translatedText": "Az általa készített programok futását folyamatos hibák akadályozták, mert a gép időnként félreolvasott biteket.",
  "time_range": [
   237.8,
   242.4
  ]
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code.",
  "model": "nmt",
  "translatedText": "Mivel a frusztráció a találékonyság bölcsője, annyira elege lett, hogy feltalálta a világ első hibajavító kódját.",
  "time_range": [
   243.12,
   248.42
  ]
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them.",
  "model": "nmt",
  "translatedText": "A Hamming-kód értelmezésének sokféle módja van, de érdemes azt a gondolatmenetet követni, amellyel Hamming is rájött a nyitjára.",
  "time_range": [
   249.06,
   255.38
  ]
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits.",
  "model": "nmt",
  "translatedText": "Használjunk egy egyszerű, ám de nem túlzottan egyszerű példát. Mondjuk egy 16 bites blokkot.",
  "time_range": [
   256.52,
   260.94
  ]
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15.",
  "model": "nmt",
  "translatedText": "Számozzuk a bitek pozícióit 0-tól 15-ig.",
  "time_range": [
   261.82,
   264.74
  ]
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy.",
  "model": "nmt",
  "translatedText": "A tényleges tárolni kívánt adatok ebből csak 12 bitet tesznek ki, míg a maradék 4 helyet egyfajta redundanciaként tartjuk fenn.",
  "time_range": [
   265.62,
   273.0
  ]
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data.",
  "model": "nmt",
  "translatedText": "A redundáns szó itt nem egyszerűen másolatot jelent, elvégre az a 4 bit nem elegendő az adatok gondolkodás nélküli többszörözésére.",
  "time_range": [
   273.9,
   280.04
  ]
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience.",
  "model": "nmt",
  "translatedText": "Ehelyett sokkal árnyaltabb és okosabb redundanciát kell alkalmazni. Nem új információ hozzáadásával, hanem az ellenálló képesség növelésével.",
  "time_range": [
   280.72,
   287.28
  ]
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end.",
  "model": "nmt",
  "translatedText": "Számíthatnál arra, hogy ez a 4 speciális bit szépen össze van csomagolva a blokk végén, vagy valami hasonló, de amint látni fogod, sokkal elegánsabb megoldás adódik, ha a 2 hatványainak helyén vannak.",
  "time_range": [
   288.6,
   299.62
  ]
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks.",
  "model": "nmt",
  "translatedText": "Ez rögtön ad egy kis utalást arra, hogy mindez hogyan skálázódik a nagyobb blokkméreteknél.",
  "time_range": [
   300.2,
   303.54
  ]
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now.",
  "model": "nmt",
  "translatedText": "Mellékesen a gyakorlatban csak 11 bit hasznos adat lesz, mint ahogy később látni fogod van egy apróság ami a 0. pozíció tartalmát meghatározza, de még korai ezzel foglalkozni.",
  "time_range": [
   304.90000000000003,
   313.26
  ]
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors.",
  "model": "nmt",
  "translatedText": "Mint minden hibajavító algoritmus, ez is két játékost foglal magába. Egy feladót, aki a 4 speciális bit beállításáért felelős, és egy vevőt, aki valamilyen ellenőrzés elvégzéséért és a hibák kijavításáért felelős.",
  "time_range": [
   314.14,
   325.2
  ]
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage.",
  "model": "nmt",
  "translatedText": "Természetesen a küldő és fogadó szavak itt olyan gépekre vagy szoftverekre utalnak, amelyek elvégzik ezeket az ellenőrzéseket. Az üzenet pedig tágan értelmezve a tárolást is jelentheti.",
  "time_range": [
   325.2,
   334.74
  ]
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another.",
  "model": "nmt",
  "translatedText": "Végül is az adatok tárolása ugyanaz, mint üzenetet küldeni a múltból a jövőbe, nem pedig egyik helyről a másikra.",
  "time_range": [
   335.34,
   341.68
  ]
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check.",
  "model": "nmt",
  "translatedText": "Tehát ez a kiindulási pontunk. Mielőtt továbbmegyünk, beszélnünk kell egy kapcsolódó ötletről, amely komoly szerepet játszott Hamming felfedezésében. Ez a módszer lehetővé teszi, hogy bármilyen egy bites hibát észleljünk, ám a kijavításában nem segít. A szakmában ez paritásellenőrzésként ismeretes.",
  "time_range": [
   342.56,
   356.3
  ]
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message.",
  "model": "nmt",
  "translatedText": "A paritásellenőrzéshez csak egyetlen bit szükséges, amely értékét a küldő állítja be a többi üzenetet hordozó bit alapján.",
  "time_range": [
   356.88,
   363.82
  ]
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number.",
  "model": "nmt",
  "translatedText": "Ennek a speciális bitnek az az egyetlen feladata, hogy vele együtt az üzenetben szereplő 1-ek száma páros szám legyen.",
  "time_range": [
   364.88,
   371.28
  ]
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even.",
  "model": "nmt",
  "translatedText": "Ebben a példában jelenleg 7 darab 1-es van. Ez páratlan, tehát a küldőnek 0-ról 1-re kell állítania a speciális bitet, hogy a darabszám páros legyen.",
  "time_range": [
   372.08,
   379.96
  ]
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0.",
  "model": "nmt",
  "translatedText": "De ha a blokk már páros számú 1-gyel indult volna, akkor ez a speciális bit 0-ban maradt volna.",
  "time_range": [
   380.8,
   386.42
  ]
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information.",
  "model": "nmt",
  "translatedText": "Ez roppant egyszerű, de hihetetlenül elegáns módja annak, hogy az üzenetben bárhol végbemenő változás eredménye, egyetlen bitnyi információban tükröződjön.",
  "time_range": [
   387.34,
   396.78
  ]
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd.",
  "model": "nmt",
  "translatedText": "Figyeljed meg, ha ennek az üzenetnek bármely bitje átbillen, akár 0-ról 1-re, vagy fordítva, az 1-ek darabszámát párosról páratlanra változtatja.",
  "time_range": [
   397.5,
   406.54
  ]
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was.",
  "model": "nmt",
  "translatedText": "Tehát ha te vagy a címzett, és megnézed ezt az üzenetet, és páratlan számú 1-et lát, akkor biztosra veheted, hogy hiba történt. Még akkor is, ha azt nem tudod, hol.",
  "time_range": [
   407.98,
   417.46
  ]
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity.",
  "model": "nmt",
  "translatedText": "Azt, hogy egy bitcsoport páros vagy páratlan darab 1-essel rendelkezik, a szakzsargonban paritásnak nevezik.",
  "time_range": [
   418.5,
   423.34
  ]
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea.",
  "model": "nmt",
  "translatedText": "Számokkal is jelölhetjük, hogy a paritás 0 vagy 1, ami akkor lesz nagyon hasznos, amint elkezdünk ezzel matekosan foglalkozni.",
  "time_range": [
   424.86,
   430.72
  ]
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit.",
  "model": "nmt",
  "translatedText": "Ezt a speciális bitet pedig, amellyel a küldő beállítja a paritást, paritásbitnek nevezzük.",
  "time_range": [
   431.22,
   435.52
  ]
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0.",
  "model": "nmt",
  "translatedText": "Azzal érdemes tisztában lenni, ha a vevő páratlan paritást lát, az nem feltétlenül azt jelenti, hogy csak egy hiba volt, lehet, hogy 3 hiba volt, vagy 5, vagy bármilyen más páratlan szám, de biztosan tudhatjuk hogy nem 0.",
  "time_range": [
   437.56,
   449.26
  ]
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free.",
  "model": "nmt",
  "translatedText": "Másrészt, ha 2 vagy páros számú hiba történt, az 1-ek száma továbbra is páros marad, így a fogadó nem lehet teljesen biztos abban, hogy a páros szám szükségszerűen azt jelenti, hogy az üzenet hibamentes.",
  "time_range": [
   449.98,
   462.3
  ]
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right.",
  "model": "nmt",
  "translatedText": "Mondhatnád, hogy csekély annak az esélye, hogy az üzenet pontosan 2 bitje módosuljon egyszerre, és ez így is van.",
  "time_range": [
   462.84000000000003,
   469.08
  ]
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended.",
  "model": "nmt",
  "translatedText": "De ne feledd azonban, hogy nincs olyan hibaészlelési vagy -javítási módszer, amellyel 100%-ban meggyőződhetnél afelől, hogy a kapott üzenet a küldő szándéka szerinti.",
  "time_range": [
   469.7,
   478.9
  ]
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance.",
  "model": "nmt",
  "translatedText": "Végtére is, a véletlenszerű zaj megváltoztathatja az egyik érvényes üzenetet akár épp egy másik érvényes üzenetté.",
  "time_range": [
   479.58,
   485.44
  ]
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this.",
  "model": "nmt",
  "translatedText": "Ehelyett az a cél, hogy egy bizonyos maximális számú hibáig robusztus sémát dolgozzunk ki, vagy csökkentsük az ehhez hasonló téves pozitív eredmény valószínűségét.",
  "time_range": [
   486.24,
   495.38
  ]
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes.",
  "model": "nmt",
  "translatedText": "A paritásellenőrzések önmagukban meglehetősen gyengék, ellenben kifejezetten hasznosak, ha ezt az üzeneten belül bekövetkezett változás érzékelésének gondolatát építőelemként tudjuk felhasználni.",
  "time_range": [
   496.26,
   507.16
  ]
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error.",
  "model": "nmt",
  "translatedText": "Hamming kulcsfontosságú meglátása az volt, hogy ha a paritásellenőrzést nem a teljes üzenetre, hanem bizonyos gondosan kiválasztott részhalmazokra alkalmazza, akkor a hiba létezésének detekcióján felül a hiba helyét is könnyebben azonosítani lehet. Mint egy kifinomult kérdéssor, amely meghatározza bármely bithiba helyét.",
  "time_range": [
   507.94,
   525.94
  ]
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half.",
  "model": "nmt",
  "translatedText": "Úgy is fel lehet fogni, mintha egy 20 kérdésből álló játékot játszanánk, ahol igen vagy nem kérdéseket teszünk fel, amelyek kettévágják a lehetőségek terét.",
  "time_range": [
   526.68,
   533.38
  ]
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions.",
  "model": "nmt",
  "translatedText": "Tegyük fel például, hogy csak ezen a 8 biten végezzük el a paritásellenőrzést, az összes páratlan számú pozíciót.",
  "time_range": [
   534.16,
   539.38
  ]
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position.",
  "model": "nmt",
  "translatedText": "Aztán ha hibát észlel, egy kicsit több információt ad a vevőnek arról, hogy pontosan hol van a hiba, nevezetesen, hogy páratlan helyzetben van.",
  "time_range": [
   540.1,
   548.24
  ]
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions.",
  "model": "nmt",
  "translatedText": "Ha a 8 bit között nem észlelünk hibát, az vagy azt jelenti, hogy nincs hiba, vagy valahol a páros pozíciókban van.",
  "time_range": [
   548.94,
   556.24
  ]
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful.",
  "model": "nmt",
  "translatedText": "Azt gondolhatnánk, hogy ha a paritásellenőrzést a bitek felére korlátozzuk, az kevésbé hatékony, de ha más jól megválasztott ellenőrzésekkel együtt hajtjuk végre, akkor az intuitív módon sokkal erősebbet ad.",
  "time_range": [
   557.18,
   567.2
  ]
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group.",
  "model": "nmt",
  "translatedText": "Ne feledje, hogy a paritásellenőrzés tényleges beállításához speciális bitet kell kijelölni, amely szabályozza a teljes csoport paritását.",
  "time_range": [
   569.24,
   576.62
  ]
 },
 {
  "input": "Here let's just choose position 1.",
  "model": "nmt",
  "translatedText": "Itt csak válasszuk ki az 1. pozíciót.",
  "time_range": [
   577.48,
   579.18
  ]
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even.",
  "model": "nmt",
  "translatedText": "A bemutatott példában ennek a 8 bitnek a paritása jelenleg páratlan, tehát a feladó felelős a paritásbit átkapcsolásáért, most pedig páros.",
  "time_range": [
   579.72,
   586.98
  ]
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do.",
  "model": "nmt",
  "translatedText": "Ez csak 1 a 4 paritásellenőrzésből, amit elvégezünk.",
  "time_range": [
   587.94,
   590.68
  ]
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here.",
  "model": "nmt",
  "translatedText": "A második ellenőrzés a rács jobb felében található 8 bit között van, legalábbis ahogy itt megrajzoltuk.",
  "time_range": [
   590.92,
   596.3
  ]
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged.",
  "model": "nmt",
  "translatedText": "Ezúttal a 2-es pozíciót használhatjuk paritásbitként, így ennek a 8 bitnek már van páros paritása, és a küldő jól érezheti magát, ha a 2-es bitet változatlanul hagyja.",
  "time_range": [
   596.68,
   606.06
  ]
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right.",
  "model": "nmt",
  "translatedText": "Aztán a másik végén, ha a vevő ellenőrzi ennek a csoportnak a paritását, és azt találja, hogy ez furcsa, akkor tudni fogja, hogy a hiba valahol a jobb oldali 8 bit között van.",
  "time_range": [
   607.02,
   615.38
  ]
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half.",
  "model": "nmt",
  "translatedText": "Ellenkező esetben ez azt jelenti, hogy nincs hiba, vagy a hiba valahol a bal oldalon van.",
  "time_range": [
   615.82,
   620.58
  ]
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block.",
  "model": "nmt",
  "translatedText": "Vagy azt hiszem, két hiba is lehetett, de jelenleg azt feltételezzük, hogy legfeljebb egy hiba van az egész blokkban.",
  "time_range": [
   621.12,
   626.5
  ]
 },
 {
  "input": "Things break down completely for more than that.",
  "model": "nmt",
  "translatedText": "Ennél többért teljesen összeomlanak a dolgok.",
  "time_range": [
   626.94,
   628.74
  ]
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together.",
  "model": "nmt",
  "translatedText": "Mielőtt megvizsgálnánk a következő két ellenőrzést, gondoljunk át egy pillanatra, hogy az első kettő mit tesz lehetővé, ha együtt tekintjük őket.",
  "time_range": [
   629.16,
   635.1
  ]
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half.",
  "model": "nmt",
  "translatedText": "Tegyük fel, hogy hibát észlel a páratlan oszlopok között és a jobb felében.",
  "time_range": [
   635.8,
   639.66
  ]
 },
 {
  "input": "It necessarily means the error is somewhere in the last column.",
  "model": "nmt",
  "translatedText": "Ez szükségszerűen azt jelenti, hogy a hiba valahol az utolsó oszlopban van.",
  "time_range": [
   640.2,
   643.04
  ]
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column.",
  "model": "nmt",
  "translatedText": "Ha a páratlan oszlopban nem volt hiba, de a jobb felében volt, akkor ez azt jelzi, hogy a másodiktól az utolsóig terjedő oszlopban van.",
  "time_range": [
   643.82,
   649.7
  ]
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column.",
  "model": "nmt",
  "translatedText": "Hasonlóképpen, ha hiba van a páratlan oszlopokban, de nem a jobb felében, akkor tudja, hogy valahol a második oszlopban van.",
  "time_range": [
   650.44,
   656.56
  ]
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column.",
  "model": "nmt",
  "translatedText": "És ha a két paritásellenőrzés egyike sem észlel semmit, akkor az egyetlen hely, ahol hiba lehet, a bal szélső oszlopban lehet.",
  "time_range": [
   656.56,
   663.12
  ]
 },
 {
  "input": "But it also might simply mean there's no error at all.",
  "model": "nmt",
  "translatedText": "De ez azt is jelentheti, hogy egyáltalán nincs hiba.",
  "time_range": [
   663.34,
   666.12
  ]
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column.",
  "model": "nmt",
  "translatedText": "Ez egy meglehetősen elcsépelt módja annak, hogy két paritásellenőrzés segítségével rögzítsük az oszlopot.",
  "time_range": [
   666.3,
   670.84
  ]
 },
 {
  "input": "From here, you can probably guess what follows.",
  "model": "nmt",
  "translatedText": "Innentől valószínűleg sejtheti, mi következik.",
  "time_range": [
   671.48,
   673.64
  ]
 },
 {
  "input": "We do basically the same thing but for the rows.",
  "model": "nmt",
  "translatedText": "Alapvetően ugyanazt csináljuk, csak a sorok esetében.",
  "time_range": [
   673.8,
   676.14
  ]
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit.",
  "model": "nmt",
  "translatedText": "A páratlan sorokon paritásellenőrzés történik, a 4-es pozíciót használva paritásbitként.",
  "time_range": [
   676.44,
   680.9
  ]
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0.",
  "model": "nmt",
  "translatedText": "Tehát ebben a példában ennek a csoportnak már van páros paritása, így a 4. bit 0-ra lesz állítva.",
  "time_range": [
   681.38,
   685.82
  ]
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit.",
  "model": "nmt",
  "translatedText": "És végül van egy paritásellenőrzés az alsó két sorban, a 8-as pozíciót használva paritásbitként.",
  "time_range": [
   686.56,
   691.58
  ]
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity.",
  "model": "nmt",
  "translatedText": "Ebben az esetben úgy tűnik, hogy a küldőnek be kell kapcsolnia a 8-as bitet, hogy egyenletes paritást biztosítson a csoportnak.",
  "time_range": [
   692.12,
   696.82
  ]
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row.",
  "model": "nmt",
  "translatedText": "Ahogy az első két ellenőrzés lehetővé teszi az oszlop rögzítését, a következő kettő lehetővé teszi a sor rögzítését.",
  "time_range": [
   697.7,
   701.84
  ]
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3.",
  "model": "nmt",
  "translatedText": "Példaként képzeljük el, hogy az átvitel során hiba történik, mondjuk a 3. pozícióban.",
  "time_range": [
   702.88,
   707.54
  ]
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column.",
  "model": "nmt",
  "translatedText": "Nos, ez érinti az első paritáscsoportot, és a második paritáscsoportot is, tehát a vevő tudja, hogy valahol hiba van abban a jobb oldali oszlopban.",
  "time_range": [
   708.18,
   715.56
  ]
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group.",
  "model": "nmt",
  "translatedText": "De ez nem érinti a harmadik csoportot, és nem érinti a negyedik csoportot.",
  "time_range": [
   716.1,
   720.54
  ]
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error.",
  "model": "nmt",
  "translatedText": "Ez pedig lehetővé teszi, hogy a vevő pontosan az első sorig azonosítsa a hibát, ami szükségszerűen a 3. pozíciót jelenti, így ki tudja javítani a hibát.",
  "time_range": [
   721.24,
   727.52
  ]
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be.",
  "model": "nmt",
  "translatedText": "Szívesen szánhat egy pillanatot arra, hogy meggyőzze magát arról, hogy a négy kérdésre adott válaszok valóban mindig lehetővé teszik, hogy meghatározzon egy adott helyet, függetlenül attól, hogy hol van.",
  "time_range": [
   728.58,
   737.1
  ]
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting.",
  "model": "nmt",
  "translatedText": "Valójában az okoskodók még azt is észrevehetik, hogy van kapcsolat e kérdések és a bináris számolás között.",
  "time_range": [
   737.72,
   743.06
  ]
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it.",
  "model": "nmt",
  "translatedText": "És ha igen, hadd hangsúlyozzam ismét, állj meg, próbáld meg magad megvonni az összefüggést, mielőtt elrontom.",
  "time_range": [
   743.5,
   748.92
  ]
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it.",
  "model": "nmt",
  "translatedText": "Ha kíváncsi arra, hogy mi történik, ha magát a paritásbitet érinti, akkor megpróbálhatja.",
  "time_range": [
   750.5,
   756.06
  ]
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions.",
  "model": "nmt",
  "translatedText": "Szánjon egy pillanatot arra, hogy gondolja végig, hogyan lehet e négy speciális bit közötti hibát ugyanúgy nyomon követni, mint bármely mást, ugyanazzal a négy kérdésből álló csoporttal.",
  "time_range": [
   756.44,
   764.18
  ]
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along.",
  "model": "nmt",
  "translatedText": "Teljesen mindegy, hiszen végső soron az üzenetbiteket akarjuk megvédeni, a hibajavító bitek csak haladnak.",
  "time_range": [
   767.0600000000001,
   773.1
  ]
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct.",
  "model": "nmt",
  "translatedText": "De ezeknek a biteknek a védelme is melléktermékként természetesen kiesik a rendszerből.",
  "time_range": [
   773.6,
   777.82
  ]
 },
 {
  "input": "You might also enjoy anticipating how this scales.",
  "model": "nmt",
  "translatedText": "Azt is élvezheti, ha előre látja, hogy ez hogyan skálázódik.",
  "time_range": [
   779.2,
   781.76
  ]
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot.",
  "model": "nmt",
  "translatedText": "Ha például egy 256 bites méretű blokkot használtunk egy hely meghatározásához, akkor mindössze nyolc igen vagy nem kérdésre van szüksége, hogy binárisan keressen egy bizonyos helyre.",
  "time_range": [
   782.3,
   792.78
  ]
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check.",
  "model": "nmt",
  "translatedText": "És ne feledje, minden kérdés csak egyetlen bitet igényel a megfelelő paritásellenőrzés beállításához.",
  "time_range": [
   795.64,
   800.5
  ]
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two.",
  "model": "nmt",
  "translatedText": "Lehet, hogy néhányan már látják, de később beszélünk arról, hogyan lehet szisztematikusan egy-két percen belül kideríteni, mik ezek a kérdések.",
  "time_range": [
   803.16,
   809.36
  ]
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here.",
  "model": "nmt",
  "translatedText": "Remélhetőleg ez a vázlat elegendő ahhoz, hogy értékeljük az itt fejlesztendő tevékenységünk hatékonyságát.",
  "time_range": [
   809.88,
   813.26
  ]
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want.",
  "model": "nmt",
  "translatedText": "Az első dolog, a nyolc kiemelt paritásbit kivételével, bármi lehet, bármilyen üzenetet vagy adatot hordozhat.",
  "time_range": [
   813.26,
   821.82
  ]
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole.",
  "model": "nmt",
  "translatedText": "A 8 bit redundáns abban az értelemben, hogy teljesen az üzenet többi része határozza meg őket, de ez sokkal okosabb módszer, mint az üzenet egészének másolása.",
  "time_range": [
   821.82,
   830.02
  ]
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error.",
  "model": "nmt",
  "translatedText": "És mégis, ennyire kevés feladással képes lenne azonosítani és kijavítani bármelyik bithibát.",
  "time_range": [
   833.6,
   838.38
  ]
 },
 {
  "input": "Well, almost.",
  "model": "nmt",
  "translatedText": "Hát majdnem.",
  "time_range": [
   839.2,
   840.4
  ]
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0.",
  "model": "nmt",
  "translatedText": "Oké, itt az egyetlen probléma az, hogy ha a négy paritásellenőrzés egyike sem észlel hibát, ami azt jelenti, hogy a speciálisan kiválasztott 8 bites részhalmazok mindegyikének páros paritása van, ahogy a küldő szándéka szerint, akkor ez vagy azt jelenti, hogy egyáltalán nem volt hiba. , vagy leszűkít minket a 0. pozícióba.",
  "time_range": [
   840.96,
   856.86
  ]
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition.",
  "model": "nmt",
  "translatedText": "Négy igen vagy nem kérdés esetén 16 lehetséges kimenetelünk van a paritásellenőrzésünkhöz, és ez elsőre tökéletesnek tűnik a blokk 16 pozíciójából 1 pontos meghatározásához, de közölnie kell a 17. eredményt is, a nem hibát. feltétel.",
  "time_range": [
   857.74,
   871.9
  ]
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely.",
  "model": "nmt",
  "translatedText": "A megoldás itt valójában nagyon egyszerű, csak felejtsd el teljesen a 0. bitet.",
  "time_range": [
   873.02,
   877.3
  ]
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error.",
  "model": "nmt",
  "translatedText": "Tehát amikor elvégezzük a négy paritásellenőrzésünket, és azt látjuk, hogy mindegyik páros, az egyértelműen azt jelenti, hogy nincs hiba.",
  "time_range": [
   877.84,
   883.46
  ]
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy.",
  "model": "nmt",
  "translatedText": "Ez azt jelenti, hogy ahelyett, hogy egy 16 bites blokkal dolgoznánk, mi egy 15 bites blokkkal dolgozunk, ahol a bitek közül 11 szabadon hordozhat üzenetet, és közülük 4 redundancia miatt van.",
  "time_range": [
   884.24,
   893.22
  ]
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code.",
  "model": "nmt",
  "translatedText": "És ezzel most megvan, amit az üzletemberek 15-11 Hamming-kódként emlegetnének.",
  "time_range": [
   893.78,
   900.2
  ]
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us.",
  "model": "nmt",
  "translatedText": "Ennek ellenére jó, hogy van egy blokkméret, amely 2-es tiszta hatványt jelent, és van egy okos módszer, amellyel megtarthatjuk a 0. bitet, és rávehetjük, hogy egy kis plusz munkát végezzen el helyettünk.",
  "time_range": [
   900.46,
   908.14
  ]
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors.",
  "model": "nmt",
  "translatedText": "Ha paritásbitként használjuk az egész blokkon, akkor ténylegesen felismerjük a 2 bites hibákat, bár nem tudjuk kijavítani.",
  "time_range": [
   908.7,
   915.54
  ]
 },
 {
  "input": "Here's how it works.",
  "model": "nmt",
  "translatedText": "Íme, hogyan működik.",
  "time_range": [
   916.16,
   916.82
  ]
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check.",
  "model": "nmt",
  "translatedText": "Miután beállítottuk a négy speciális hibajavító bitet, beállítjuk azt a 0-at, hogy a teljes blokk paritása páros legyen, akárcsak egy normál paritásellenőrzésnél.",
  "time_range": [
   917.18,
   924.94
  ]
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks.",
  "model": "nmt",
  "translatedText": "Most, ha egyetlen bites hiba van, akkor a teljes blokk paritása páratlanra vált, de a négy hibajavító ellenőrzésnek köszönhetően ezt mindenképpen megfognánk.",
  "time_range": [
   925.7,
   933.6
  ]
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks.",
  "model": "nmt",
  "translatedText": "Ha azonban két hiba van, akkor a teljes paritás vissza fog váltani párosra, de a vevő továbbra is látja, hogy legalább valami hiba történt a négy paritásellenőrzés miatt.",
  "time_range": [
   934.16,
   945.18
  ]
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors.",
  "model": "nmt",
  "translatedText": "Tehát ha összességében egyenletes paritást észlelnek, de a többi ellenőrzésnél valami nem nulla történik, akkor azt jelzi, hogy legalább két hiba történt.",
  "time_range": [
   945.18,
   952.7
  ]
 },
 {
  "input": "Isn't that clever?",
  "model": "nmt",
  "translatedText": "Hát nem okos?",
  "time_range": [
   953.52,
   954.0
  ]
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them.",
  "model": "nmt",
  "translatedText": "Annak ellenére, hogy ezeket a 2 bites hibákat nem tudjuk kijavítani, pusztán az egyetlen zavaró 0. bit visszaállításával lehetővé teszi számunkra, hogy észleljük őket.",
  "time_range": [
   954.3,
   961.26
  ]
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code.",
  "model": "nmt",
  "translatedText": "Ez meglehetősen szabványos, kiterjesztett Hamming-kódként ismert.",
  "time_range": [
   962.26,
   965.22
  ]
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block.",
  "model": "nmt",
  "translatedText": "Technikailag szólva, most már teljes leírása van arról, hogy mit csinál egy Hamming-kód, legalábbis egy 16 bites blokk esetében.",
  "time_range": [
   966.54,
   972.88
  ]
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself.",
  "model": "nmt",
  "translatedText": "De azt hiszem, sokkal elégedettebb lesz, ha ellenőrizni fogja a megértését, és mindent megszilárdít idáig úgy, hogy egy teljes példát tesz az elejétől a végéig.",
  "time_range": [
   972.88,
   981.32
  ]
 },
 {
  "input": "I'll step through it with you though so you can check yourself.",
  "model": "nmt",
  "translatedText": "De végigcsinálom veled, hogy ellenőrizd magad.",
  "time_range": [
   982.08,
   984.3
  ]
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks.",
  "model": "nmt",
  "translatedText": "Üzenet beállításához, legyen szó szó szerinti üzenetről, amelyet térben fordít le, vagy bizonyos adatokat, amelyeket idővel tárolni szeretne, az első lépés az, hogy fel kell osztani 11 bites részekre.",
  "time_range": [
   985.12,
   994.66
  ]
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block.",
  "model": "nmt",
  "translatedText": "Minden egyes darab egy hibaálló 16 bites blokkba kerül.",
  "time_range": [
   995.58,
   999.76
  ]
 },
 {
  "input": "So let's take this one as an example and actually work it out.",
  "model": "nmt",
  "translatedText": "Tehát vegyük ezt példaként, és dolgozzuk ki ténylegesen.",
  "time_range": [
   999.76,
   1003.22
  ]
 },
 {
  "input": "Go ahead, actually do it!",
  "model": "nmt",
  "translatedText": "Hajrá, tényleg tedd meg!",
  "time_range": [
   1003.74,
   1004.74
  ]
 },
 {
  "input": "Let's pause and try putting together this block.",
  "model": "nmt",
  "translatedText": "Álljunk meg, és próbáljuk összerakni ezt a blokkot.",
  "time_range": [
   1004.74,
   1007.02
  ]
 },
 {
  "input": "Okay, you ready?",
  "model": "nmt",
  "translatedText": "Oké, készen állsz?",
  "time_range": [
   1012.72,
   1013.68
  ]
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order.",
  "model": "nmt",
  "translatedText": "Ne feledje, hogy a 0 pozíció a 2 többi hatványával együtt hibajavítási feladatra van fenntartva, tehát először az üzenetbiteket az összes többi helyre, sorrendben helyezze el.",
  "time_range": [
   1014.24,
   1023.32
  ]
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0.",
  "model": "nmt",
  "translatedText": "Ennek a csoportnak páros paritásúnak kell lennie, ami már így is van, tehát azt a paritásbitet az 1-es pozícióban 0-ra kellett volna állítani.",
  "time_range": [
   1025.34,
   1032.34
  ]
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1.",
  "model": "nmt",
  "translatedText": "A következő csoport páratlan paritással kezdődik, ezért a paritásbitjét 1-re kellett volna állítani.",
  "time_range": [
   1033.02,
   1037.88
  ]
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1.",
  "model": "nmt",
  "translatedText": "Az ezt követő csoport páratlan paritással kezdődik, tehát ismét 1-re kellett volna állítani a paritásbitjét.",
  "time_range": [
   1039.16,
   1044.24
  ]
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1.",
  "model": "nmt",
  "translatedText": "És az utolsó csoportnak is van páratlan paritása, vagyis azt a bitet a 8-as pozícióban 1-re állítjuk be.",
  "time_range": [
   1044.78,
   1050.06
  ]
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0.",
  "model": "nmt",
  "translatedText": "Utolsó lépésként a teljes blokk páros paritású, vagyis beállíthatja a 0 bitszámot, az átfogó paritásbitet 0-ra.",
  "time_range": [
   1051.3,
   1060.32
  ]
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0.",
  "model": "nmt",
  "translatedText": "Tehát amikor ez a blokk elküldésre kerül, a négy speciális részhalmaz és a blokk egészének paritása páros vagy 0 lesz.",
  "time_range": [
   1061.34,
   1068.14
  ]
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver.",
  "model": "nmt",
  "translatedText": "A gyakorlat második részeként játsszuk a befogadó szerepét.",
  "time_range": [
   1068.82,
   1072.18
  ]
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't.",
  "model": "nmt",
  "translatedText": "Természetesen ez azt jelentené, hogy még nem tudja, mi ez az üzenet, talán néhányan megjegyezték, de tegyük fel, hogy még nem.",
  "time_range": [
   1073.48,
   1079.78
  ]
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did.",
  "model": "nmt",
  "translatedText": "Azt fogom tenni, hogy megváltoztatom a 0, 1 vagy 2 bitet ebben a blokkban, majd megkérem, hogy találja ki, mit csináltam.",
  "time_range": [
   1080.02,
   1087.74
  ]
 },
 {
  "input": "So again, pause and try working it out.",
  "model": "nmt",
  "translatedText": "Tehát ismét álljon meg, és próbálja meg megoldani.",
  "time_range": [
   1088.26,
   1090.81
  ]
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column.",
  "model": "nmt",
  "translatedText": "Oké, tehát Ön, mint vevő, most ellenőrizze az első paritáscsoportot, és láthatja, hogy az páros, tehát minden létező hibának páros oszlopban kell lennie.",
  "time_range": [
   1098.79,
   1107.91
  ]
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column.",
  "model": "nmt",
  "translatedText": "A következő ellenőrzés páratlan számot ad nekünk, jelezve, hogy legalább egy hiba van, és leszűkítve erre a konkrét oszlopra.",
  "time_range": [
   1109.69,
   1117.03
  ]
 },
 {
  "input": "The third check is even, chopping down the possibilities even further.",
  "model": "nmt",
  "translatedText": "A harmadik ellenőrzés kiegyenlített, ami még tovább csökkenti a lehetőségeket.",
  "time_range": [
   1118.55,
   1121.79
  ]
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10.",
  "model": "nmt",
  "translatedText": "Az utolsó paritásellenőrzés pedig páratlan, és azt jelzi, hogy valahol alul van egy hiba, amiről mostanra láthatjuk, hogy a 10-es pozícióban kell lennie.",
  "time_range": [
   1122.65,
   1129.65
  ]
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two.",
  "model": "nmt",
  "translatedText": "Sőt, az egész blokk paritása furcsa, ami azt a bizonyosságot ad nekünk, hogy egy átfordulás volt, és nem kettő.",
  "time_range": [
   1131.49,
   1137.53
  ]
 },
 {
  "input": "If it's three or more, all bets are off.",
  "model": "nmt",
  "translatedText": "Ha három vagy több, akkor minden fogadás megszűnik.",
  "time_range": [
   1138.07,
   1139.97
  ]
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with.",
  "model": "nmt",
  "translatedText": "A 10-es számú bit kijavítása után a korrekcióhoz nem használt 11 bitet kihúzva megkapjuk az eredeti üzenet megfelelő szegmensét, amely ha visszatekerjük és összehasonlítjuk, valóban pontosan az, amivel kezdtük a példát.",
  "time_range": [
   1141.31,
   1154.39
  ]
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code.",
  "model": "nmt",
  "translatedText": "És most, hogy tudja, hogyan kell mindezt kézzel megtenni, szeretném megmutatni, hogyan hajthatja végre ennek a logikának a lényegét egyetlen Python-kódsorral.",
  "time_range": [
   1155.71,
   1163.17
  ]
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks.",
  "model": "nmt",
  "translatedText": "Látod, amit még nem mondtam el, az az, hogy valójában mennyire elegáns ez az algoritmus, milyen egyszerű rávenni a gépet, hogy rámutasson a hiba helyére, hogyan lehet szisztematikusan skálázni, és hogyan tudjuk keretbe foglalni az egészet. ez egyetlen művelet, nem pedig több különálló paritásellenőrzés.",
  "time_range": [
   1163.87,
   1178.75
  ]
 },
 {
  "input": "To see what I mean, come join me in part 2.",
  "model": "nmt",
  "translatedText": "Ha szeretnéd tudni, mire gondolok, csatlakozz hozzám a 2. részben.",
  "time_range": [
   1179.43,
   1181.31
  ]
 }
]