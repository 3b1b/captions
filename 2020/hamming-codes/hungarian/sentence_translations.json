[
 {
  "input": "I'm assuming that everybody here is coming from part 1.",
  "model": "nmt",
  "translatedText": "Feltételezem, hogy itt mindenki az 1. részből jön.",
  "time_range": [
   0.0,
   2.56
  ]
 },
 {
  "input": "We were talking about Hamming codes, a way to create a block of data where most of the bits carry a meaningful message, while a few others act as a kind of redundancy, in such a way that if any bit gets flipped, either a message bit or a redundancy bit, anything in this block, a receiver is going to be able to identify that there was an error, and how to fix it.",
  "model": "nmt",
  "translatedText": "Hamming-kódokról beszéltünk, egy olyan adatblokk létrehozásának módszeréről, amelyben a bitek többsége értelmes üzenetet hordoz, míg néhány másik egyfajta redundanciaként működik, oly módon, hogy ha bármelyik bit megfordul, akkor vagy üzenet bit vagy redundancia bit, bármi ebben a blokkban, a vevő képes lesz azonosítani, hogy hiba történt, és hogyan lehet kijavítani.",
  "time_range": [
   3.06,
   21.24
  ]
 },
 {
  "input": "The basic idea presented there was how to use multiple parity checks to binary search your way down to the error.",
  "model": "nmt",
  "translatedText": "Az ott bemutatott alapötlet az volt, hogyan lehet többszörös paritásellenőrzést használni a bináris kereséshez a hibáig.",
  "time_range": [
   21.88,
   27.16
  ]
 },
 {
  "input": "In that video the goal was to make Hamming codes feel as hands-on and rediscoverable as possible.",
  "model": "nmt",
  "translatedText": "Ebben a videóban az volt a cél, hogy a Hamming-kódok a lehető leggyakrabban és újra felfedezhetővé váljanak.",
  "time_range": [
   28.980000000000008,
   34.6
  ]
 },
 {
  "input": "But as you start to think about actually implementing this, either in software or hardware, that framing may actually undersell how elegant these codes really are.",
  "model": "nmt",
  "translatedText": "De ahogy elkezd gondolkodni ennek tényleges megvalósításán, akár szoftverben, akár hardverben, ez a keretezés valójában alááshatja, mennyire elegánsak ezek a kódok.",
  "time_range": [
   35.18,
   43.46
  ]
 },
 {
  "input": "You might think that you need to write an algorithm that keeps track of all the possible error locations and cuts that group in half with each check, but it's actually way, way simpler than that.",
  "model": "nmt",
  "translatedText": "Azt gondolhatnánk, hogy olyan algoritmust kell írnia, amely nyomon követi az összes lehetséges hibahelyet, és minden egyes ellenőrzéssel kettévágja azt a csoportot, de valójában sokkal, de sokkal egyszerűbb ennél.",
  "time_range": [
   43.92,
   53.48
  ]
 },
 {
  "input": "If you read out the answers to the four parity checks we did in the last video, all as 1s and 0s instead of yeses and nos, it literally spells out the position of the error in binary.",
  "model": "nmt",
  "translatedText": "Ha felolvasod a négy paritásellenőrzésre adott válaszokat, amelyeket az előző videóban végeztünk, 1-es és 0-s formában igen és nem helyett, akkor szó szerint kiírja a hiba helyzetét binárisan.",
  "time_range": [
   53.94,
   64.08
  ]
 },
 {
  "input": "For example, the number 7 in binary looks like 0111, essentially saying that it's 4 plus 2 plus 1.",
  "model": "nmt",
  "translatedText": "Például a 7-es szám binárisan úgy néz ki, mint 0111, lényegében azt mondva, hogy 4 plusz 2 plusz 1.",
  "time_range": [
   64.78,
   71.26
  ]
 },
 {
  "input": "And notice where the position 7 sits, it does affect the first of our parity groups, and the second, and the third, but not the last.",
  "model": "nmt",
  "translatedText": "És figyeld meg, hogy a 7-es pozíció hol helyezkedik el, ez érinti az első paritáscsoportunkat, a másodikat és a harmadikat, de nem az utolsót.",
  "time_range": [
   72.54,
   81.74
  ]
 },
 {
  "input": "So reading the results of those four checks from bottom to top indeed does spell out the position of the error.",
  "model": "nmt",
  "translatedText": "Tehát e négy ellenőrzés eredményének alulról felfelé történő elolvasása valóban meghatározza a hiba helyzetét.",
  "time_range": [
   82.22,
   87.54
  ]
 },
 {
  "input": "There's nothing special about the example 7, this works in general, and this makes the logic for implementing the whole scheme in hardware shockingly simple.",
  "model": "nmt",
  "translatedText": "A 7-es példában nincs semmi különös, ez általában működik, és ez megdöbbentően egyszerűvé teszi az egész séma hardveres megvalósításának logikáját.",
  "time_range": [
   88.32,
   95.82
  ]
 },
 {
  "input": "Now if you want to see why this magic happens, take these 16 index labels for our positions, but instead of writing them in base 10, let's write them all in binary, running from 0000 up to 1111.",
  "model": "nmt",
  "translatedText": "Ha szeretnéd látni, miért történik ez a varázslat, vegyük ezt a 16 indexcímkét a pozícióinkhoz, de ahelyett, hogy 10-es alapba írnánk, írjuk őket binárisan, 0000-től 1111-ig.",
  "time_range": [
   97.24,
   109.88
  ]
 },
 {
  "input": "As we put these binary labels back into their boxes, let me emphasize that they are distinct from the data that's actually being sent.",
  "model": "nmt",
  "translatedText": "Miközben ezeket a bináris címkéket visszahelyezzük a dobozukba, hadd hangsúlyozzam, hogy különböznek a ténylegesen elküldött adatoktól.",
  "time_range": [
   110.55999999999999,
   117.8
  ]
 },
 {
  "input": "They're nothing more than a conceptual label to help you and me understand where the four parity groups came from.",
  "model": "nmt",
  "translatedText": "Nem mások, mint egy fogalmi címke, amely segít neked és nekem megérteni, honnan jött a négy paritásos csoport.",
  "time_range": [
   118.32,
   123.5
  ]
 },
 {
  "input": "The elegance of having everything we're looking at be described in binary is maybe undercut by the confusion of having everything we're looking at being described in binary.",
  "model": "nmt",
  "translatedText": "Azt az eleganciát, hogy mindent, amit nézünk, binárisan írunk le, talán aláássa az a zavar, hogy mindent, amit nézünk, binárisan írunk le.",
  "time_range": [
   124.14,
   132.36
  ]
 },
 {
  "input": "It's worth it, though.",
  "model": "nmt",
  "translatedText": "Pedig megéri.",
  "time_range": [
   133.02,
   134.12
  ]
 },
 {
  "input": "Focus your attention just on that last bit of all of these labels, and then highlight the positions where that final bit is a 1.",
  "model": "nmt",
  "translatedText": "A címkék közül csak az utolsó bitre összpontosítsa figyelmét, majd jelölje ki azokat a helyeket, ahol az utolsó bit 1.",
  "time_range": [
   134.8,
   143.22
  ]
 },
 {
  "input": "What we get is the first of our four parity groups, which means you can interpret that first check as asking, hey, if there's an error, is the final bit in the position of that error a 1?",
  "model": "nmt",
  "translatedText": "A négy paritáscsoport közül az elsőt kapjuk, ami azt jelenti, hogy az első ellenőrzést úgy értelmezheti, hogy azt kérdezi, hé, ha hiba van, akkor a hiba helyének utolsó bitje 1?",
  "time_range": [
   144.24,
   155.74
  ]
 },
 {
  "input": "Similarly, if you focus on the second to last bit, and highlight all the positions where that's a 1, you get the second parity group from our scheme.",
  "model": "nmt",
  "translatedText": "Hasonlóképpen, ha a másodiktól az utolsóig fókuszál, és kiemeli az összes olyan pozíciót, ahol ez 1, akkor megkapja a második paritáscsoportot a rendszerünkből.",
  "time_range": [
   158.2,
   166.16
  ]
 },
 {
  "input": "In other words, that second check is asking, hey, me again, if there's an error, is the second to last bit of that position a 1?",
  "model": "nmt",
  "translatedText": "Más szóval, a második ellenőrzés azt kérdezi, hé, megint én, ha hiba van, akkor a pozíció második és utolsó bitje 1?",
  "time_range": [
   166.74,
   174.5
  ]
 },
 {
  "input": "And so on.",
  "model": "nmt",
  "translatedText": "Stb.",
  "time_range": [
   175.76,
   176.9
  ]
 },
 {
  "input": "The third parity check covers every position whose third to last bit is turned on, and the last one covers the last eight positions, those ones whose highest order bit is a 1.",
  "model": "nmt",
  "translatedText": "A harmadik paritásellenőrzés minden olyan pozícióra kiterjed, amelynek harmadik bitje be van kapcsolva, az utolsó pedig az utolsó nyolc pozíciót fedi le, azokat, amelyeknek a legmagasabb sorrendű bitje 1.",
  "time_range": [
   177.22,
   188.74
  ]
 },
 {
  "input": "Everything we did earlier is the same as answering these four questions, which in turn is the same as spelling out a position in binary.",
  "model": "nmt",
  "translatedText": "Minden, amit korábban tettünk, ugyanaz, mint ennek a négy kérdésnek a megválaszolása, ami viszont ugyanaz, mint egy pozíció kiírása binárisan.",
  "time_range": [
   189.74,
   197.74
  ]
 },
 {
  "input": "I hope this makes two things clearer.",
  "model": "nmt",
  "translatedText": "Remélem, ez két dolgot tisztáz.",
  "time_range": [
   199.62,
   201.48
  ]
 },
 {
  "input": "The first is how to systematically generalize to block sizes that are bigger powers of two.",
  "model": "nmt",
  "translatedText": "Az első az, hogyan lehet szisztematikusan általánosítani olyan blokkméretekre, amelyek kettőnél nagyobb hatványok.",
  "time_range": [
   202.04,
   206.46
  ]
 },
 {
  "input": "If it takes more bits to describe each position, like six bits to describe 64 spots, then each of those bits gives you one of the parity groups that we need to check.",
  "model": "nmt",
  "translatedText": "Ha több bitre van szükség az egyes pozíciók leírásához, például hat bitre van szükség 64 folt leírásához, akkor ezek a bitek mindegyike megadja az egyik paritáscsoportot, amelyet ellenőriznünk kell.",
  "time_range": [
   206.96,
   216.68
  ]
 },
 {
  "input": "Those of you who watched the chessboard puzzle I did with Matt Parker might find all this exceedingly familiar.",
  "model": "nmt",
  "translatedText": "Azok, akik megnézték azt a sakktábla-rejtvényt, amit Matt Parkerrel csináltam, mindezt rendkívül ismerősnek találhatták.",
  "time_range": [
   218.4,
   223.18
  ]
 },
 {
  "input": "It's the same core logic, but solving a different problem, and applied to a 64-squared chessboard.",
  "model": "nmt",
  "translatedText": "Ugyanaz az alapvető logika, de más problémát old meg, és egy 64 négyzetes sakktáblára alkalmazzák.",
  "time_range": [
   223.66,
   228.78
  ]
 },
 {
  "input": "The second thing I hope this makes clear is why our parity bits are sitting in the positions that are powers of two, for example 1, 2, 4, and 8.",
  "model": "nmt",
  "translatedText": "A második dolog, remélem, ez világossá teszi, hogy a paritásbitjeink miért vannak olyan pozíciókban, amelyek kettő hatványai, például 1, 2, 4 és 8.",
  "time_range": [
   229.88,
   237.32
  ]
 },
 {
  "input": "These are the positions whose binary representation has just a single bit turned on.",
  "model": "nmt",
  "translatedText": "Ezek azok a pozíciók, amelyek bináris reprezentációjában csak egyetlen bit van bekapcsolva.",
  "time_range": [
   238.0,
   243.0
  ]
 },
 {
  "input": "What that means is each of those parity bits sits inside one and only one of the four parity groups.",
  "model": "nmt",
  "translatedText": "Ez azt jelenti, hogy a paritásbitek mindegyike a négy paritáscsoport egyikén belül található.",
  "time_range": [
   243.6,
   249.46
  ]
 },
 {
  "input": "You can also see this in larger examples, where no matter how big you get, each parity bit conveniently touches only one of the groups.",
  "model": "nmt",
  "translatedText": "Ezt láthatod nagyobb példákon is, ahol akármekkora is leszel, minden paritásbit kényelmesen csak az egyik csoportot érinti.",
  "time_range": [
   252.04,
   259.34
  ]
 },
 {
  "input": "Once you understand that these parity checks that we've focused so much of our time on are nothing more than a clever way to spell out the position of an error in binary, then we can draw a connection with a different way to think about hamming codes, one that is arguably a lot simpler and more elegant, and which can basically be written down with a single line of code.",
  "model": "nmt",
  "translatedText": "Ha megértjük, hogy ezek a paritásellenőrzések, amelyekre az időnk nagy részét összpontosítottuk, nem más, mint egy okos módszer a hiba helyének binárisban történő megfogalmazására, akkor összefüggést vonhatunk le a hamming másfajta gondolkodásmódjával. kódokat, amelyek vitathatatlanul sokkal egyszerűbbek és elegánsabbak, és alapvetően egyetlen kódsorral leírhatók.",
  "time_range": [
   265.6,
   283.24
  ]
 },
 {
  "input": "It's based on the XOR function.",
  "model": "nmt",
  "translatedText": "Az XOR függvényen alapul.",
  "time_range": [
   283.66,
   285.5
  ]
 },
 {
  "input": "XOR, for those of you who don't know, stands for exclusive or.",
  "model": "nmt",
  "translatedText": "Az XOR azoknak, akik nem ismerik, az exkluzív ill.",
  "time_range": [
   286.94,
   290.22
  ]
 },
 {
  "input": "When you take the XOR of two bits, it's going to return a 1 if either one of those bits is turned on, but not if both are turned on or off.",
  "model": "nmt",
  "translatedText": "Ha két bit XOR-jét veszed, akkor 1-et ad vissza, ha az egyik bit be van kapcsolva, de nem, ha mindkettő be vagy ki van kapcsolva.",
  "time_range": [
   290.78,
   299.36
  ]
 },
 {
  "input": "Phrased differently, it's the parity of these two bits.",
  "model": "nmt",
  "translatedText": "Másképpen fogalmazva ez a két bit paritása.",
  "time_range": [
   300.1,
   302.98
  ]
 },
 {
  "input": "As a math person, I prefer to think about it as addition mod 2.",
  "model": "nmt",
  "translatedText": "Matematikusként szívesebben gondolok rá, mint 2. kiegészítésre.",
  "time_range": [
   303.54,
   306.76
  ]
 },
 {
  "input": "We also commonly talk about the XOR of two different bit strings, which basically does this component by component.",
  "model": "nmt",
  "translatedText": "Gyakran beszélünk két különböző bitsor XOR-járól is, amely alapvetően komponensenként hajtja végre ezt.",
  "time_range": [
   307.36,
   313.44
  ]
 },
 {
  "input": "It's like addition, but where you never carry.",
  "model": "nmt",
  "translatedText": "Ez olyan, mint egy kiegészítés, de ahol soha nem viszed magaddal.",
  "time_range": [
   313.68,
   315.72
  ]
 },
 {
  "input": "Again, the more mathematically inclined might prefer to think of this as adding two vectors and reducing mod 2.",
  "model": "nmt",
  "translatedText": "Ismét a matematikailag hajlamosabbak ezt inkább úgy gondolhatják, mintha két vektort adnának hozzá, és csökkentenék a mod 2-t.",
  "time_range": [
   316.5,
   322.48
  ]
 },
 {
  "input": "If you open up some Python right now and apply the caret operation between two integers, this is what it's doing but to the bit representations of those numbers under the hood.",
  "model": "nmt",
  "translatedText": "Ha most megnyit egy Pythont, és alkalmazza a caret műveletet két egész szám között, akkor ez az, amit csinál, csak a tető alatti számok bitreprezentációira.",
  "time_range": [
   323.5,
   332.94
  ]
 },
 {
  "input": "The key point for you and me is that taking the XOR of many different bit strings is effectively a way to compute the parodies of a bunch of separate groups, like so with the columns, all in one fell swoop.",
  "model": "nmt",
  "translatedText": "Számodra és nekem az a kulcsfontosságú, hogy a sok különböző bitsor XOR-értékének vétele hatékony módja annak, hogy egy csomó különálló csoport paródiáit számítsuk ki, mint ahogyan az oszlopoknál is, mindezt egy csapásra.",
  "time_range": [
   334.96000000000004,
   347.14
  ]
 },
 {
  "input": "This gives us a rather snazzy way to think about the multiple parity checks from our Hamming code algorithm as all being packaged together into one single operation.",
  "model": "nmt",
  "translatedText": "Ez egy meglehetősen pofás módot ad arra, hogy elgondolkodjunk a Hamming-kód algoritmusunkból származó többszörös paritásellenőrzéseken, mivel mindez egyetlen műveletbe van csomagolva.",
  "time_range": [
   351.26,
   358.78
  ]
 },
 {
  "input": "Though at first glance it does look very different.",
  "model": "nmt",
  "translatedText": "Bár első pillantásra nagyon másképp néz ki.",
  "time_range": [
   359.47999999999996,
   362.18
  ]
 },
 {
  "input": "Specifically write down the 16 positions in binary, like we had before, and now highlight the positions where the message bit is turned on to a 1, and then collect these positions into one big column and take the XOR.",
  "model": "nmt",
  "translatedText": "Konkrétan írja fel a 16 pozíciót binárisan, mint korábban, és most jelölje ki azokat a pozíciókat, ahol az üzenetbit 1-re van kapcsolva, majd gyűjtse össze ezeket a pozíciókat egy nagy oszlopba, és vegye fel az XOR-t.",
  "time_range": [
   362.82,
   377.1
  ]
 },
 {
  "input": "You can probably guess that the 4 bits sitting at the bottom as a result are the same as the 4 parity checks we've come to know and love, but take a moment to actually think about why exactly.",
  "model": "nmt",
  "translatedText": "Valószínűleg sejtheti, hogy az eredményül kapott 4 bit megegyezik az általunk megismert és kedvelt 4 paritásellenőrzéssel, de szánjunk egy percet, hogy átgondoljuk, miért pontosan.",
  "time_range": [
   379.26,
   389.2
  ]
 },
 {
  "input": "This last column, for example, is counting all of the positions whose last bit is a 1, but we're already limited only to the highlighted positions, so it's effectively counting how many highlighted positions came from the first parity group.",
  "model": "nmt",
  "translatedText": "Ez az utolsó oszlop például az összes olyan pozíciót számolja, amelynek utolsó bitje 1, de már csak a kiemelt pozíciókra korlátozódik, tehát gyakorlatilag azt számolja, hogy hány kiemelt pozíció származott az első paritáscsoportból.",
  "time_range": [
   392.22,
   405.76
  ]
 },
 {
  "input": "Does that make sense?",
  "model": "nmt",
  "translatedText": "Ennek van értelme?",
  "time_range": [
   406.24,
   406.8
  ]
 },
 {
  "input": "Likewise, the next column counts how many positions are in the second parity group, the positions whose second to last bit is a 1, and which are also highlighted, and so on.",
  "model": "nmt",
  "translatedText": "Hasonlóképpen, a következő oszlop azt számolja, hogy hány pozíció van a második paritáscsoportban, azokat a pozíciókat, amelyek második és utolsó bitje 1, és amelyek szintén kiemelve vannak, és így tovább.",
  "time_range": [
   409.08,
   420.0
  ]
 },
 {
  "input": "It's really just a small shift in perspective on the same thing we've been doing.",
  "model": "nmt",
  "translatedText": "Valójában ez csak egy kis perspektívaváltás ugyanabban a dologban, amit mi csináltunk.",
  "time_range": [
   420.26,
   423.96
  ]
 },
 {
  "input": "And so you know where it goes from here.",
  "model": "nmt",
  "translatedText": "És hogy tudd, hová vezet innen.",
  "time_range": [
   427.76,
   429.6
  ]
 },
 {
  "input": "The sender is responsible for toggling some of the special parity bits to make sure the sum works out to be 0000.",
  "model": "nmt",
  "translatedText": "A küldő felelős néhány speciális paritásbit átkapcsolásáért, hogy megbizonyosodjon arról, hogy az összeg 0000 lesz.",
  "time_range": [
   430.0,
   435.72
  ]
 },
 {
  "input": "Now once we have it like this, this gives us a really nice way to think about why these four resulting bits at the bottom directly spell out the position of an error.",
  "model": "nmt",
  "translatedText": "Ha már így van, akkor ez egy nagyon jó módot ad arra, hogy elgondolkodjunk azon, hogy ez a négy eredményül kapott bit az alján miért írja le közvetlenül a hiba helyzetét.",
  "time_range": [
   435.72,
   447.58
  ]
 },
 {
  "input": "Let's say some bit in this block gets toggled from a 0 to a 1.",
  "model": "nmt",
  "translatedText": "Tegyük fel, hogy ebben a blokkban egy kicsit 0-ról 1-re vált.",
  "time_range": [
   448.46,
   451.86
  ]
 },
 {
  "input": "What that means is that the position of that bit is now going to be included in the total XOR, which changes the sum from being 0 to instead being this newly included value, the position of the error.",
  "model": "nmt",
  "translatedText": "Ez azt jelenti, hogy ennek a bitnek a pozíciója bekerül a teljes XOR-be, ami 0-ról az összeget az újonnan hozzáadott értékre, a hiba helyére változtatja.",
  "time_range": [
   452.6,
   463.82
  ]
 },
 {
  "input": "Slightly less obviously, the same is true if there's an error that changes a 1 to a 0.",
  "model": "nmt",
  "translatedText": "Valamivel kevésbé nyilvánvaló, ugyanez igaz arra az esetre is, ha olyan hiba történik, amely 1-et 0-ra változtat.",
  "time_range": [
   464.46,
   469.36
  ]
 },
 {
  "input": "You see, if you add a bit string together twice, it's the same as not having it there at all, basically because in this world 1 plus 1 equals 0.",
  "model": "nmt",
  "translatedText": "Tudod, ha kétszer összeadsz egy bites karakterláncot, az ugyanaz, mintha egyáltalán nem lenne ott, alapvetően azért, mert ebben a világban 1 plusz 1 egyenlő 0-val.",
  "time_range": [
   470.18,
   477.58
  ]
 },
 {
  "input": "So adding a copy of this position to the total sum has the same effect as we're moving it.",
  "model": "nmt",
  "translatedText": "Tehát ennek a pozíciónak a másolatának hozzáadása a végösszeghez ugyanazt a hatást eredményezi, mint ahogy mozgatjuk.",
  "time_range": [
   477.58,
   484.3
  ]
 },
 {
  "input": "And that effect, again, is that the total result at the bottom here spells out the position of the error.",
  "model": "nmt",
  "translatedText": "És ez a hatás ismét az, hogy az összesített eredmény itt alul jelzi a hiba helyzetét.",
  "time_range": [
   485.16,
   490.7
  ]
 },
 {
  "input": "To illustrate how elegant this is, let me show that one line of Python code I referenced before, which will capture almost all of the logic on the receiver's end.",
  "model": "nmt",
  "translatedText": "Annak szemléltetésére, hogy ez milyen elegáns, hadd mutassam meg azt a Python-kód egy sort, amelyre korábban hivatkoztam, és amely szinte az összes logikát rögzíti a vevő oldalán.",
  "time_range": [
   493.03999999999996,
   501.44
  ]
 },
 {
  "input": "We'll start by creating a random array of 16 1s and 0s to simulate the data block, and I'll give it the name bits, but of course in practice this would be something we're receiving from a sender, and instead of being random it would be carrying 11 data bits together with 5 parity bits.",
  "model": "nmt",
  "translatedText": "Kezdjük azzal, hogy létrehozunk egy véletlenszerű 16 1-es és 0-s tömböt az adatblokk szimulálására, és megadom neki a névbiteket, de természetesen a gyakorlatban ezt a küldőtől kapjuk, és ahelyett, hogy véletlenszerű lévén 11 adatbitet hordozna 5 paritásbittel együtt.",
  "time_range": [
   502.08,
   517.0
  ]
 },
 {
  "input": "If I call the function enumerateBits, what it does is pair together each of those bits with a corresponding index, in this case running from 0 up to 15.",
  "model": "nmt",
  "translatedText": "Ha az enumerateBits függvényt hívom, akkor azt csinálja, hogy ezeket a biteket párosítja a megfelelő indexszel, ebben az esetben 0-tól 15-ig.",
  "time_range": [
   517.0,
   527.0
  ]
 },
 {
  "input": "So if we then create a list that loops over all of these pairs, pairs that look like i, and then we pull out just the i value, just the index, well it's not that exciting, we just get back those indices 0 through 15.",
  "model": "nmt",
  "translatedText": "Tehát ha ezután létrehozunk egy listát, amely az összes ilyen páron áthurkol, olyan párokon, amelyek i-nek néznek ki, majd csak az i értéket vesszük ki, csak az indexet, akkor ez nem olyan izgalmas, csak visszakapjuk azokat az indexeket 0 és 15 között.",
  "time_range": [
   528.18,
   541.34
  ]
 },
 {
  "input": "But if we add on the condition to only do this if bit, meaning if that bit is a 1 and not a 0, well then it pulls out only the positions where the corresponding bit is turned on.",
  "model": "nmt",
  "translatedText": "De ha hozzátesszük azt a feltételt, hogy ezt csak if bit, azaz ha ez a bit 1 és nem 0, akkor csak azokat a pozíciókat húzza ki, ahol a megfelelő bit be van kapcsolva.",
  "time_range": [
   541.68,
   552.66
  ]
 },
 {
  "input": "In this case it looks like those positions are 0, 4, 6, 9, etc.",
  "model": "nmt",
  "translatedText": "Ebben az esetben úgy tűnik, hogy ezek a pozíciók 0, 4, 6, 9 stb.",
  "time_range": [
   553.38,
   560.36
  ]
 },
 {
  "input": "What we want is to collect together all of those positions, the positions of the bits that are turned on, and then XOR them together.",
  "model": "nmt",
  "translatedText": "Azt akarjuk, hogy összegyűjtsük ezeket a pozíciókat, a bekapcsolt bitek pozícióit, majd együtt XOR-eljük őket.",
  "time_range": [
   560.72,
   567.24
  ]
 },
 {
  "input": "To do this in Python, let me first import a couple helpful functions.",
  "model": "nmt",
  "translatedText": "Ahhoz, hogy ezt Pythonban megtegye, először importáljak néhány hasznos funkciót.",
  "time_range": [
   569.18,
   573.22
  ]
 },
 {
  "input": "That way we can call reduce() on this list, and use the XOR function to reduce it.",
  "model": "nmt",
  "translatedText": "Így meghívhatjuk a redukció()-t ezen a listán, és az XOR függvény segítségével csökkenthetjük.",
  "time_range": [
   573.9,
   578.7
  ]
 },
 {
  "input": "This basically eats its way through the list, taking XORs along the way.",
  "model": "nmt",
  "translatedText": "Ez alapvetően átveszi a listát, és végigviszi az XOR-t.",
  "time_range": [
   579.1,
   582.68
  ]
 },
 {
  "input": "If you prefer, you can explicitly write out that XOR function without having to import it from anywhere.",
  "model": "nmt",
  "translatedText": "Ha úgy tetszik, kifejezetten kiírhatja az XOR függvényt anélkül, hogy bárhonnan importálnia kellene.",
  "time_range": [
   584.8,
   589.44
  ]
 },
 {
  "input": "So at the moment it looks like if we do this on our random block of 16 bits, it returns 9, which has the binary representation 1001.",
  "model": "nmt",
  "translatedText": "Tehát jelenleg úgy néz ki, hogy ha ezt tesszük a 16 bites véletlenszerű blokkon, akkor 9-et ad vissza, aminek a bináris reprezentációja 1001.",
  "time_range": [
   591.94,
   601.28
  ]
 },
 {
  "input": "We won't do it here, but you could write a function where the sender uses that binary representation to set the four parity bits as needed, ultimately getting this block to a state where running this line of code on the full list of bits returns a 0.",
  "model": "nmt",
  "translatedText": "Itt nem fogjuk megtenni, de írhat egy függvényt, ahol a küldő ezt a bináris reprezentációt használja a négy paritásbit igény szerinti beállításához, így végül a blokk olyan állapotba kerül, ahol ennek a kódsornak a futtatása a teljes bitlistán visszatér. egy 0.",
  "time_range": [
   601.98,
   615.46
  ]
 },
 {
  "input": "This would be considered a well-prepared block.",
  "model": "nmt",
  "translatedText": "Ez egy jól előkészített blokknak tekinthető.",
  "time_range": [
   616.08,
   620.1
  ]
 },
 {
  "input": "What's cool is that if we toggle any one of the bits in this list, simulating a random error from noise, then if you run this same line of code, it prints out that error.",
  "model": "nmt",
  "translatedText": "A jó dolog az, hogy ha a listában szereplő bitek bármelyikét átkapcsoljuk, véletlenszerű zajból eredő hibát szimulálva, akkor ha ugyanazt a kódsort futtatja, kiírja a hibát.",
  "time_range": [
   620.1,
   630.22
  ]
 },
 {
  "input": "Isn't that neat?",
  "model": "nmt",
  "translatedText": "Hát nem ügyes?",
  "time_range": [
   630.96,
   631.52
  ]
 },
 {
  "input": "You could get this block from out of the blue, run this single line on it, and it'll automatically spit out the position of an error, or a 0 if there wasn't any.",
  "model": "nmt",
  "translatedText": "Megkaphatja ezt a blokkot a semmiből, futtathatja rajta ezt az egyetlen sort, és automatikusan kiköpi a hiba pozícióját, vagy egy 0-t, ha nincs.",
  "time_range": [
   631.82,
   641.06
  ]
 },
 {
  "input": "And there's nothing special about the size 16 here.",
  "model": "nmt",
  "translatedText": "A 16-os méretben pedig nincs itt semmi különös.",
  "time_range": [
   642.5,
   644.84
  ]
 },
 {
  "input": "The same line of code would work if you had a list of, say, 256 bits.",
  "model": "nmt",
  "translatedText": "Ugyanez a kódsor működne, ha mondjuk 256 bites listája lenne.",
  "time_range": [
   644.84,
   649.86
  ]
 },
 {
  "input": "Needless to say, there is more code to write here, like doing the meta parity check to detect 2-bit errors, but the idea is that almost all of the core logic from our scheme comes down to a single XOR reduction.",
  "model": "nmt",
  "translatedText": "Mondanunk sem kell, hogy több kódot kell ide írni, például a meta paritásellenőrzést a 2 bites hibák észlelésére, de az ötlet az, hogy a sémánk szinte minden alapvető logikája egyetlen XOR-csökkentésre vezethető vissza.",
  "time_range": [
   651.88,
   663.76
  ]
 },
 {
  "input": "Now, depending on your comfort with binary and XORs and software in general, you may either find this perspective a little bit confusing, or so much more elegant and simple that you're wondering why we didn't just start with it from the get-go.",
  "model": "nmt",
  "translatedText": "A bináris és XOR-ok és általában a szoftverek kényelmétől függően előfordulhat, hogy ezt a perspektívát kissé zavarónak találja, vagy sokkal elegánsabbnak és egyszerűbbnek, hogy azon töpreng, miért nem kezdtük el vele. -megy.",
  "time_range": [
   666.12,
   678.42
  ]
 },
 {
  "input": "Loosely speaking, the multiple parity check perspective is easier to think about when implementing Hamming codes in hardware very directly, and the XOR perspective is easiest to think about when doing it in software, from kind of a higher level.",
  "model": "nmt",
  "translatedText": "Lazán szólva, a többszörös paritásellenőrzési perspektíva könnyebben átgondolható, ha a Hamming-kódokat nagyon közvetlenül implementálják hardverben, az XOR perspektívára pedig akkor a legegyszerűbb, ha szoftveresen, valamivel magasabb szintről.",
  "time_range": [
   679.14,
   690.5
  ]
 },
 {
  "input": "The first one is easiest to actually do by hand, and I think it does a better job instilling the core intuition underlying all of this, which is that the information required to locate a single error is related to the log of the size of the block, or in other words, it grows one bit at a time as the block size doubles.",
  "model": "nmt",
  "translatedText": "Az elsőt a legegyszerűbb kézzel elvégezni, és úgy gondolom, hogy ez jobban beépíti a mindennek hátterében álló alapvető intuíciót, vagyis azt, hogy az egyetlen hiba megtalálásához szükséges információ a blokk méretének naplójához kapcsolódik. , vagy más szóval, a blokk méretének megduplázódásával egy kicsit növekszik.",
  "time_range": [
   691.36,
   710.0
  ]
 },
 {
  "input": "The relevant fact here is that that information directly corresponds to how much redundancy we need.",
  "model": "nmt",
  "translatedText": "A lényeges tény itt az, hogy ez az információ közvetlenül megfelel annak, hogy mekkora redundanciára van szükségünk.",
  "time_range": [
   711.02,
   716.06
  ]
 },
 {
  "input": "That's really what runs against most people's knee-jerk reaction when they first think about making a message resilient to errors, where usually copying the whole message is the first instinct that comes to mind.",
  "model": "nmt",
  "translatedText": "Valójában ez az, ami ellentétes a legtöbb ember térdrángó reakciójával, amikor először arra gondol, hogy egy üzenetet tegyen ellenállóvá a hibákkal szemben, ahol általában a teljes üzenet lemásolása az első ösztön, ami eszébe jut.",
  "time_range": [
   716.66,
   726.54
  ]
 },
 {
  "input": "And then, by the way, there is this whole other way that you sometimes see Hamming codes presented, where you multiply the message by one big matrix.",
  "model": "nmt",
  "translatedText": "És akkor, egyébként, van egy egészen más mód, hogy néha Hamming-kódokat látunk bemutatva, ahol az üzenetet megszorozzuk egy nagy mátrixszal.",
  "time_range": [
   727.5,
   734.0
  ]
 },
 {
  "input": "It's kind of nice because it relates it to the broader family of linear codes, but I think that gives almost no intuition for where it comes from or how it scales.",
  "model": "nmt",
  "translatedText": "Ez kedves, mert a lineáris kódok tágabb családjához kapcsolódik, de szerintem ez szinte semmilyen megérzést nem ad arról, honnan származik vagy hogyan skálázódik.",
  "time_range": [
   734.67,
   743.06
  ]
 },
 {
  "input": "And speaking of scaling, you might notice that the efficiency of this scheme only gets better as we increase the block size.",
  "model": "nmt",
  "translatedText": "És ha a skálázásról beszélünk, észreveheti, hogy ennek a sémának a hatékonysága csak javul, ha növeljük a blokk méretét.",
  "time_range": [
   745.2,
   751.16
  ]
 },
 {
  "input": "For example, we saw that with 256 bits, you're using only 3% of that space for redundancy, and it just keeps getting better from there.",
  "model": "nmt",
  "translatedText": "Például azt láttuk, hogy 256 bittel ennek a helynek csak 3%-át használjuk fel a redundanciára, és onnantól kezdve egyre jobb lesz.",
  "time_range": [
   755.0,
   762.66
  ]
 },
 {
  "input": "As the number of parity bits grows one by one, the block size keeps doubling.",
  "model": "nmt",
  "translatedText": "Ahogy a paritásbitek száma egyesével nő, a blokk mérete folyamatosan megduplázódik.",
  "time_range": [
   763.3,
   767.34
  ]
 },
 {
  "input": "And if you take that to an extreme, you could have a block with, say, a million bits, where you would quite literally be playing 20 questions with your parity checks, and it uses only 21 parity bits.",
  "model": "nmt",
  "translatedText": "És ha ezt túlzásba viszed, akkor lehet egy millió bites blokk, ahol szó szerint 20 kérdést játszanál a paritásellenőrzéssel, és csak 21 paritásbitet használ.",
  "time_range": [
   769.0,
   780.02
  ]
 },
 {
  "input": "And if you step back to think about looking at a million bits and locating a single error, that genuinely feels crazy.",
  "model": "nmt",
  "translatedText": "És ha visszalép, és arra gondol, hogy megnézzen egymillió bitet, és megkeressen egyetlen hibát, az valóban őrültségnek tűnik.",
  "time_range": [
   780.74,
   787.06
  ]
 },
 {
  "input": "The problem, of course, is that with a larger block, the probability of seeing more than one or two bit errors goes up, and Hamming codes do not handle anything beyond that.",
  "model": "nmt",
  "translatedText": "A probléma persze az, hogy egy nagyobb blokknál megnő annak a valószínűsége, hogy egy-két bitnél több hibát látunk, és a Hamming kódok ezen kívül semmit sem kezelnek.",
  "time_range": [
   788.1999999999999,
   797.66
  ]
 },
 {
  "input": "So in practice, what you'd want is to find the right size so that the probability of too many bit flips isn't too high.",
  "model": "nmt",
  "translatedText": "Tehát a gyakorlatban a megfelelő méretet szeretné megtalálni, hogy ne legyen túl nagy a valószínűsége a túl sok bitváltásnak.",
  "time_range": [
   798.32,
   804.3
  ]
 },
 {
  "input": "Also, in practice, errors tend to come in little bursts, which would totally ruin a single block, so one common tactic to help spread out a burst of errors across many different blocks is to interlace those blocks, like this, before they're sent out or stored.",
  "model": "nmt",
  "translatedText": "Ezenkívül a gyakorlatban a hibák általában kis sorozatokban érkeznek, ami teljesen tönkretesz egy blokkot, ezért az egyik gyakori taktika a hibák sorozatának szétosztására a különböző blokkok között az, hogy ezeket a blokkokat összefűzi, mielőtt kiküldve vagy tárolva.",
  "time_range": [
   806.6,
   820.98
  ]
 },
 {
  "input": "Then again, a lot of this is rendered completely moot by more modern codes, like the much more commonly used Reed-Solomon algorithm, which handles burst errors particularly well, and it can be tuned to be resilient to a larger number of errors per block.",
  "model": "nmt",
  "translatedText": "Viszont ennek nagy részét teljesen megkérdőjelezik a modernebb kódok, mint például a sokkal gyakrabban használt Reed-Solomon algoritmus, amely különösen jól kezeli a sorozathibákat, és blokkonként nagyobb számú hibával szemben is ellenállóra hangolható.",
  "time_range": [
   825.58,
   838.82
  ]
 },
 {
  "input": "But that's a topic for another time.",
  "model": "nmt",
  "translatedText": "De ez egy másik alkalom témája.",
  "time_range": [
   839.36,
   841.34
  ]
 },
 {
  "input": "In his book The Art of Doing Science and Engineering, Hamming is wonderfully candid about just how meandering his discovery of this code was.",
  "model": "nmt",
  "translatedText": "A tudomány és mérnöki tevékenység művészete című könyvében Hamming csodálatosan őszintén beszél arról, hogy milyen kanyargós volt a kód felfedezése.",
  "time_range": [
   842.5,
   849.94
  ]
 },
 {
  "input": "He first tried all sorts of different schemes involving organizing the bits into parts of a higher dimensional lattice and strange things like this.",
  "model": "nmt",
  "translatedText": "Először mindenféle különféle sémát próbált ki, beleértve a biteket egy magasabb dimenziós rács részeire rendezve, és ehhez hasonló furcsa dolgokat.",
  "time_range": [
   850.62,
   857.78
  ]
 },
 {
  "input": "The idea that it might be possible to get parity checks to conspire in a way that spells out the position of an error only came to Hamming when he stepped back after a bunch of other analysis and asked, okay, what is the most efficient I could conceivably be about this?",
  "model": "nmt",
  "translatedText": "Az ötlet, hogy a paritásellenőrzések összeesküvésre késztethetők oly módon, hogy kifejtsék a hiba helyzetét, csak akkor jutott Hamminghez, amikor egy csomó egyéb elemzés után visszalépett, és megkérdezte: oké, mi a leghatékonyabb, amit tudok. elképzelhető, hogy erről van szó?",
  "time_range": [
   858.3,
   871.52
  ]
 },
 {
  "input": "He was also candid about how important it was that parity checks were already on his mind, which would have been way less common back in the 1940s than it is today.",
  "model": "nmt",
  "translatedText": "Arról is őszintén beszélt, mennyire fontos, hogy már a paritásellenőrzés járt a fejében, ami az 1940-es években sokkal kevésbé volt elterjedt, mint manapság.",
  "time_range": [
   872.62,
   881.22
  ]
 },
 {
  "input": "There are like half a dozen times throughout this book that he references the Louis Pasteur quote, luck favors a prepared mind.",
  "model": "nmt",
  "translatedText": "A könyvben vagy fél tucatszor hivatkozik Louis Pasteur idézetére, a szerencse a felkészült elmének kedvez.",
  "time_range": [
   881.92,
   888.22
  ]
 },
 {
  "input": "Clever ideas often look deceptively simple in hindsight, which makes them easy to underappreciate.",
  "model": "nmt",
  "translatedText": "Az okos ötletek gyakran megtévesztően egyszerűnek tűnnek utólag visszagondolva, ami miatt könnyen alulértékelhetők.",
  "time_range": [
   889.32,
   894.3
  ]
 },
 {
  "input": "Right now my honest hope is that Hamming codes, or at least the possibility of such codes, feels almost obvious to you.",
  "model": "nmt",
  "translatedText": "Jelenleg őszintén remélem, hogy a Hamming-kódok, vagy legalábbis az ilyen kódok lehetősége, szinte magától értetődőnek tűnik számodra.",
  "time_range": [
   894.96,
   901.3
  ]
 },
 {
  "input": "But you shouldn't fool yourself into thinking that they actually are obvious, because they definitely aren't.",
  "model": "nmt",
  "translatedText": "De nem szabad becsapnia magát azzal, hogy azt gondolja, hogy ezek valójában nyilvánvalóak, mert biztosan nem.",
  "time_range": [
   901.66,
   906.82
  ]
 },
 {
  "input": "Part of the reason that clever ideas look deceptively easy is that we only ever see the final result, cleaning up what was messy, never mentioning all of the wrong turns, underselling just how vast the space of explorable possibilities is at the start of a problem solving process, all of that.",
  "model": "nmt",
  "translatedText": "Az okos ötletek megtévesztően egyszerűnek tűnnek, részben az az oka, hogy mindig csak a végeredményt látjuk, tisztázzuk azt, ami rendetlen volt, soha nem említjük meg az összes rossz fordulatot, alábecsüljük, hogy a felfedezhető lehetőségek mekkora tere van a probléma kezdetén. megoldási folyamat, mindez.",
  "time_range": [
   907.88,
   922.86
  ]
 },
 {
  "input": "But this is true in general.",
  "model": "nmt",
  "translatedText": "De ez általánosságban igaz.",
  "time_range": [
   923.82,
   924.9
  ]
 },
 {
  "input": "I think for some special inventions, there's a second, deeper reason that we underappreciate them.",
  "model": "nmt",
  "translatedText": "Azt hiszem, néhány különleges találmánynak van egy másik, mélyebb oka is annak, hogy alulbecsüljük őket.",
  "time_range": [
   924.9,
   930.04
  ]
 },
 {
  "input": "Thinking of information in terms of bits had only really coalesced into a full theory by 1948, with Claude Shannon's seminal paper on information theory.",
  "model": "nmt",
  "translatedText": "Az információ bitekben való gondolkodása csak 1948-ra vált igazán teljes elméletté, Claude Shannon információelméletről szóló alapvető tanulmányával.",
  "time_range": [
   930.84,
   938.64
  ]
 },
 {
  "input": "This was essentially concurrent with when Hamming developed his algorithm.",
  "model": "nmt",
  "translatedText": "Ez lényegében egybeesett azzal, amikor Hamming kidolgozta az algoritmusát.",
  "time_range": [
   939.28,
   942.54
  ]
 },
 {
  "input": "This was the same foundational paper that showed, in a certain sense, that efficient error correction is always possible, no matter how high the probability of bit flips, at least in theory.",
  "model": "nmt",
  "translatedText": "Ez ugyanaz az alapdolgozat, amely bizonyos értelemben megmutatta, hogy a hatékony hibajavítás mindig lehetséges, függetlenül attól, hogy mekkora a valószínűsége a bitváltásnak, legalábbis elméletben.",
  "time_range": [
   943.3,
   952.9
  ]
 },
 {
  "input": "Shannon and Hamming, by the way, shared an office in Bell Labs, despite working on very different things, which hardly seems coincidental here.",
  "model": "nmt",
  "translatedText": "Shannon és Hamming egyébként a Bell Labs-ban osztozott egy irodában, annak ellenére, hogy nagyon különböző dolgokon dolgoztak, ami itt aligha tűnik véletlennek.",
  "time_range": [
   953.7,
   961.16
  ]
 },
 {
  "input": "Fast forward several decades, and these days, many of us are so immersed in thinking about bits and information that it's easy to overlook just how distinct this way of thinking was.",
  "model": "nmt",
  "translatedText": "Gyorsan előre több évtizedet, és manapság sokan annyira elmerülünk a bitekről és információkról való gondolkodásban, hogy könnyű figyelmen kívül hagyni, mennyire eltérő volt ez a gondolkodásmód.",
  "time_range": [
   962.38,
   972.34
  ]
 },
 {
  "input": "Ironically, the ideas that most profoundly shape the ways that a future generation thinks will end up looking to that future generation simpler than they really are.",
  "model": "nmt",
  "translatedText": "Ironikus módon azok az ötletek, amelyek a legmélyebben alakítják a jövő nemzedékének gondolkodásmódját, végül egyszerűbbnek tekintik a jövő generációját, mint amilyenek valójában.",
  "time_range": [
   973.1,
   982.26
  ]
 }
]