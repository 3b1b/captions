1
00:00:00,000 --> 00:00:03,120
Feltételezem, hogy itt mindenki az 1. részből jön.

2
00:00:03,120 --> 00:00:07,043
Hamming-kódokról beszéltünk, egy olyan adatblokk létrehozásának módszeréről,

3
00:00:07,043 --> 00:00:10,558
amelyben a bitek többsége értelmes üzenetet hordoz, míg néhány másik

4
00:00:10,558 --> 00:00:14,532
egyfajta redundanciaként működik, oly módon, hogy ha bármelyik bit megfordul,

5
00:00:14,532 --> 00:00:18,353
akkor vagy üzenet bit vagy redundancia bit, bármi ebben a blokkban, a vevő

6
00:00:18,353 --> 00:00:21,920
képes lesz azonosítani, hogy hiba történt, és hogyan lehet kijavítani.

7
00:00:21,920 --> 00:00:25,925
Az ott bemutatott alapötlet az volt, hogyan lehet többszörös

8
00:00:25,925 --> 00:00:29,800
paritásellenőrzést használni a bináris kereséshez a hibáig.

9
00:00:29,800 --> 00:00:32,557
Ebben a videóban az volt a cél, hogy a Hamming-kódok

10
00:00:32,557 --> 00:00:35,420
a lehető leggyakrabban és újra felfedezhetővé váljanak.

11
00:00:35,420 --> 00:00:39,823
De ahogy elkezd gondolkodni ennek tényleges megvalósításán, akár szoftverben, akár

12
00:00:39,823 --> 00:00:44,120
hardverben, ez a keretezés valójában alááshatja, mennyire elegánsak ezek a kódok.

13
00:00:44,120 --> 00:00:47,608
Azt gondolhatnánk, hogy olyan algoritmust kell írnia, amely nyomon követi

14
00:00:47,608 --> 00:00:51,096
az összes lehetséges hibahelyet, és minden egyes ellenőrzéssel kettévágja

15
00:00:51,096 --> 00:00:54,160
azt a csoportot, de valójában sokkal, de sokkal egyszerűbb ennél.

16
00:00:54,160 --> 00:00:57,429
Ha felolvasod a négy paritásellenőrzésre adott válaszokat,

17
00:00:57,429 --> 00:01:01,031
amelyeket az előző videóban végeztünk, 1-es és 0-s formában igen

18
00:01:01,031 --> 00:01:04,800
és nem helyett, akkor szó szerint kiírja a hiba helyzetét binárisan.

19
00:01:04,800 --> 00:01:08,522
Például a 7-es szám binárisan úgy néz ki, mint

20
00:01:08,522 --> 00:01:12,640
0111, lényegében azt mondva, hogy 4 plusz 2 plusz 1.

21
00:01:12,640 --> 00:01:17,324
És figyeld meg, hogy a 7-es pozíció hol helyezkedik el, ez érinti az

22
00:01:17,324 --> 00:01:22,280
első paritáscsoportunkat, a másodikat és a harmadikat, de nem az utolsót.

23
00:01:22,280 --> 00:01:25,286
Tehát e négy ellenőrzés eredményének alulról felfelé

24
00:01:25,286 --> 00:01:28,520
történő elolvasása valóban meghatározza a hiba helyzetét.

25
00:01:28,520 --> 00:01:33,313
A 7-es példában nincs semmi különös, ez általában működik, és ez megdöbbentően

26
00:01:33,313 --> 00:01:37,440
egyszerűvé teszi az egész séma hardveres megvalósításának logikáját.

27
00:01:37,440 --> 00:01:43,622
Ha szeretnéd látni, miért történik ez a varázslat, vegyük ezt a 16 indexcímkét a

28
00:01:43,622 --> 00:01:50,109
pozícióinkhoz, de ahelyett, hogy 10-es alapba írnánk, írjuk őket binárisan, 0000-től

29
00:01:50,109 --> 00:01:50,720
1111-ig.

30
00:01:50,720 --> 00:01:54,665
Miközben ezeket a bináris címkéket visszahelyezzük a dobozukba, hadd

31
00:01:54,665 --> 00:01:58,440
hangsúlyozzam, hogy különböznek a ténylegesen elküldött adatoktól.

32
00:01:58,440 --> 00:02:01,372
Nem mások, mint egy fogalmi címke, amely segít neked és

33
00:02:01,372 --> 00:02:04,200
nekem megérteni, honnan jött a négy paritásos csoport.

34
00:02:04,200 --> 00:02:08,485
Azt az eleganciát, hogy mindent, amit nézünk, binárisan írunk le,

35
00:02:08,485 --> 00:02:13,160
talán aláássa az a zavar, hogy mindent, amit nézünk, binárisan írunk le.

36
00:02:13,160 --> 00:02:15,040
Pedig megéri.

37
00:02:15,040 --> 00:02:19,894
A címkék közül csak az utolsó bitre összpontosítsa figyelmét,

38
00:02:19,894 --> 00:02:24,280
majd jelölje ki azokat a helyeket, ahol az utolsó bit 1.

39
00:02:24,280 --> 00:02:30,374
A négy paritáscsoport közül az elsőt kapjuk, ami azt jelenti, hogy az első ellenőrzést

40
00:02:30,374 --> 00:02:36,680
úgy értelmezheti, hogy azt kérdezi, hé, ha hiba van, akkor a hiba helyének utolsó bitje 1?

41
00:02:36,680 --> 00:02:41,860
Hasonlóképpen, ha a másodiktól az utolsóig fókuszál, és kiemeli az összes olyan

42
00:02:41,860 --> 00:02:47,040
pozíciót, ahol ez 1, akkor megkapja a második paritáscsoportot a rendszerünkből.

43
00:02:47,040 --> 00:02:51,521
Más szóval, a második ellenőrzés azt kérdezi, hé, megint

44
00:02:51,521 --> 00:02:56,160
én, ha hiba van, akkor a pozíció második és utolsó bitje 1?

45
00:02:56,160 --> 00:02:57,160
Stb.

46
00:02:57,160 --> 00:03:01,670
A harmadik paritásellenőrzés minden olyan pozícióra kiterjed, amelynek

47
00:03:01,670 --> 00:03:05,800
harmadik bitje be van kapcsolva, az utolsó pedig az utolsó nyolc

48
00:03:05,800 --> 00:03:10,120
pozíciót fedi le, azokat, amelyeknek a legmagasabb sorrendű bitje 1.

49
00:03:10,120 --> 00:03:14,891
Minden, amit korábban tettünk, ugyanaz, mint ennek a négy kérdésnek a

50
00:03:14,891 --> 00:03:19,800
megválaszolása, ami viszont ugyanaz, mint egy pozíció kiírása binárisan.

51
00:03:19,800 --> 00:03:22,080
Remélem, ez két dolgot tisztáz.

52
00:03:22,080 --> 00:03:24,610
Az első az, hogyan lehet szisztematikusan általánosítani

53
00:03:24,610 --> 00:03:27,140
olyan blokkméretekre, amelyek kettőnél nagyobb hatványok.

54
00:03:27,140 --> 00:03:30,857
Ha több bitre van szükség az egyes pozíciók leírásához, például

55
00:03:30,857 --> 00:03:34,400
hat bitre van szükség 64 folt leírásához, akkor ezek a bitek

56
00:03:34,400 --> 00:03:38,640
mindegyike megadja az egyik paritáscsoportot, amelyet ellenőriznünk kell.

57
00:03:38,640 --> 00:03:40,940
Azok, akik megnézték azt a sakktábla-rejtvényt, amit Matt

58
00:03:40,940 --> 00:03:43,400
Parkerrel csináltam, mindezt rendkívül ismerősnek találhatták.

59
00:03:43,400 --> 00:03:46,640
Ugyanaz az alapvető logika, de más problémát old

60
00:03:46,640 --> 00:03:49,880
meg, és egy 64 négyzetes sakktáblára alkalmazzák.

61
00:03:49,880 --> 00:03:54,186
A második dolog, remélem, ez világossá teszi, hogy a paritásbitjeink miért

62
00:03:54,186 --> 00:03:58,320
vannak olyan pozíciókban, amelyek kettő hatványai, például 1, 2, 4 és 8.

63
00:03:58,320 --> 00:04:01,652
Ezek azok a pozíciók, amelyek bináris reprezentációjában

64
00:04:01,652 --> 00:04:03,640
csak egyetlen bit van bekapcsolva.

65
00:04:03,640 --> 00:04:08,188
Ez azt jelenti, hogy a paritásbitek mindegyike

66
00:04:08,188 --> 00:04:12,640
a négy paritáscsoport egyikén belül található.

67
00:04:12,640 --> 00:04:19,333
Ezt láthatod nagyobb példákon is, ahol akármekkora is leszel,

68
00:04:19,333 --> 00:04:25,920
minden paritásbit kényelmesen csak az egyik csoportot érinti.

69
00:04:25,920 --> 00:04:29,411
Ha megértjük, hogy ezek a paritásellenőrzések, amelyekre az időnk nagy

70
00:04:29,411 --> 00:04:33,001
részét összpontosítottuk, nem más, mint egy okos módszer a hiba helyének

71
00:04:33,001 --> 00:04:36,493
binárisban történő megfogalmazására, akkor összefüggést vonhatunk le a

72
00:04:36,493 --> 00:04:39,985
hamming másfajta gondolkodásmódjával. kódokat, amelyek vitathatatlanul

73
00:04:39,985 --> 00:04:43,920
sokkal egyszerűbbek és elegánsabbak, és alapvetően egyetlen kódsorral leírhatók.

74
00:04:43,920 --> 00:04:46,200
Az XOR függvényen alapul.

75
00:04:46,200 --> 00:04:50,960
Az XOR azoknak, akik nem ismerik, az exkluzív ill.

76
00:04:50,960 --> 00:04:55,615
Ha két bit XOR-jét veszed, akkor 1-et ad vissza, ha az egyik bit

77
00:04:55,615 --> 00:05:00,200
be van kapcsolva, de nem, ha mindkettő be vagy ki van kapcsolva.

78
00:05:00,200 --> 00:05:03,760
Másképpen fogalmazva ez a két bit paritása.

79
00:05:03,760 --> 00:05:07,840
Matematikusként szívesebben gondolok rá, mint 2. kiegészítésre.

80
00:05:07,840 --> 00:05:10,789
Gyakran beszélünk két különböző bitsor XOR-járól

81
00:05:10,789 --> 00:05:14,040
is, amely alapvetően komponensenként hajtja végre ezt.

82
00:05:14,040 --> 00:05:16,280
Ez olyan, mint egy kiegészítés, de ahol soha nem viszed magaddal.

83
00:05:16,280 --> 00:05:20,072
Ismét a matematikailag hajlamosabbak ezt inkább úgy gondolhatják,

84
00:05:20,072 --> 00:05:23,520
mintha két vektort adnának hozzá, és csökkentenék a mod 2-t.

85
00:05:23,520 --> 00:05:29,307
Ha most megnyit egy Pythont, és alkalmazza a caret műveletet két egész szám

86
00:05:29,307 --> 00:05:35,400
között, akkor ez az, amit csinál, csak a tető alatti számok bitreprezentációira.

87
00:05:35,400 --> 00:05:40,298
Számodra és nekem az a kulcsfontosságú, hogy a sok különböző bitsor

88
00:05:40,298 --> 00:05:45,773
XOR-értékének vétele hatékony módja annak, hogy egy csomó különálló csoport

89
00:05:45,773 --> 00:05:51,320
paródiáit számítsuk ki, mint ahogyan az oszlopoknál is, mindezt egy csapásra.

90
00:05:51,320 --> 00:05:54,152
Ez egy meglehetősen pofás módot ad arra, hogy elgondolkodjunk

91
00:05:54,152 --> 00:05:56,482
a Hamming-kód algoritmusunkból származó többszörös

92
00:05:56,482 --> 00:05:59,680
paritásellenőrzéseken, mivel mindez egyetlen műveletbe van csomagolva.

93
00:05:59,680 --> 00:06:02,800
Bár első pillantásra nagyon másképp néz ki.

94
00:06:02,800 --> 00:06:08,537
Konkrétan írja fel a 16 pozíciót binárisan, mint korábban, és most jelölje

95
00:06:08,537 --> 00:06:14,274
ki azokat a pozíciókat, ahol az üzenetbit 1-re van kapcsolva, majd gyűjtse

96
00:06:14,274 --> 00:06:19,400
össze ezeket a pozíciókat egy nagy oszlopba, és vegye fel az XOR-t.

97
00:06:19,400 --> 00:06:25,912
Valószínűleg sejtheti, hogy az eredményül kapott 4 bit megegyezik az általunk megismert

98
00:06:25,912 --> 00:06:32,054
és kedvelt 4 paritásellenőrzéssel, de szánjunk egy percet, hogy átgondoljuk, miért

99
00:06:32,054 --> 00:06:32,720
pontosan.

100
00:06:32,720 --> 00:06:37,228
Ez az utolsó oszlop például az összes olyan pozíciót számolja, amelynek utolsó

101
00:06:37,228 --> 00:06:41,565
bitje 1, de már csak a kiemelt pozíciókra korlátozódik, tehát gyakorlatilag

102
00:06:41,565 --> 00:06:45,960
azt számolja, hogy hány kiemelt pozíció származott az első paritáscsoportból.

103
00:06:45,960 --> 00:06:48,520
Ennek van értelme?

104
00:06:48,520 --> 00:06:52,422
Hasonlóképpen, a következő oszlop azt számolja, hogy hány pozíció

105
00:06:52,422 --> 00:06:56,560
van a második paritáscsoportban, azokat a pozíciókat, amelyek második

106
00:06:56,560 --> 00:07:00,640
és utolsó bitje 1, és amelyek szintén kiemelve vannak, és így tovább.

107
00:07:00,640 --> 00:07:07,640
Valójában ez csak egy kis perspektívaváltás ugyanabban a dologban, amit mi csináltunk.

108
00:07:07,640 --> 00:07:10,000
És hogy tudd, hová vezet innen.

109
00:07:10,000 --> 00:07:15,113
A küldő felelős néhány speciális paritásbit átkapcsolásáért,

110
00:07:15,113 --> 00:07:19,640
hogy megbizonyosodjon arról, hogy az összeg 0000 lesz.

111
00:07:19,640 --> 00:07:24,233
Ha már így van, akkor ez egy nagyon jó módot ad arra, hogy elgondolkodjunk azon, hogy

112
00:07:24,233 --> 00:07:28,720
ez a négy eredményül kapott bit az alján miért írja le közvetlenül a hiba helyzetét.

113
00:07:28,720 --> 00:07:32,720
Tegyük fel, hogy ebben a blokkban egy kicsit 0-ról 1-re vált.

114
00:07:32,720 --> 00:07:38,799
Ez azt jelenti, hogy ennek a bitnek a pozíciója bekerül a teljes XOR-be, ami

115
00:07:38,799 --> 00:07:44,800
0-ról az összeget az újonnan hozzáadott értékre, a hiba helyére változtatja.

116
00:07:44,800 --> 00:07:47,410
Valamivel kevésbé nyilvánvaló, ugyanez igaz arra az esetre

117
00:07:47,410 --> 00:07:49,800
is, ha olyan hiba történik, amely 1-et 0-ra változtat.

118
00:07:49,800 --> 00:07:54,541
Tudod, ha kétszer összeadsz egy bites karakterláncot, az ugyanaz, mintha egyáltalán

119
00:07:54,541 --> 00:07:59,000
nem lenne ott, alapvetően azért, mert ebben a világban 1 plusz 1 egyenlő 0-val.

120
00:07:59,000 --> 00:08:01,844
Tehát ennek a pozíciónak a másolatának hozzáadása a

121
00:08:01,844 --> 00:08:05,400
végösszeghez ugyanazt a hatást eredményezi, mint ahogy mozgatjuk.

122
00:08:05,400 --> 00:08:13,480
És ez a hatás ismét az, hogy az összesített eredmény itt alul jelzi a hiba helyzetét.

123
00:08:13,480 --> 00:08:17,631
Annak szemléltetésére, hogy ez milyen elegáns, hadd mutassam meg azt a Python-kód egy

124
00:08:17,631 --> 00:08:21,733
sort, amelyre korábban hivatkoztam, és amely szinte az összes logikát rögzíti a vevő

125
00:08:21,733 --> 00:08:22,120
oldalán.

126
00:08:22,120 --> 00:08:27,346
Kezdjük azzal, hogy létrehozunk egy véletlenszerű 16 1-es és 0-s tömböt az adatblokk

127
00:08:27,346 --> 00:08:32,450
szimulálására, és megadom neki a névbiteket, de természetesen a gyakorlatban ezt a

128
00:08:32,450 --> 00:08:37,308
küldőtől kapjuk, és ahelyett, hogy véletlenszerű lévén 11 adatbitet hordozna 5

129
00:08:37,308 --> 00:08:38,600
paritásbittel együtt.

130
00:08:38,600 --> 00:08:43,317
Ha az enumerateBits függvényt hívom, akkor azt csinálja, hogy ezeket

131
00:08:43,317 --> 00:08:48,240
a biteket párosítja a megfelelő indexszel, ebben az esetben 0-tól 15-ig.

132
00:08:48,240 --> 00:08:52,800
Tehát ha ezután létrehozunk egy listát, amely az összes ilyen páron áthurkol, olyan

133
00:08:52,800 --> 00:08:57,468
párokon, amelyek i-nek néznek ki, majd csak az i értéket vesszük ki, csak az indexet,

134
00:08:57,468 --> 00:09:01,920
akkor ez nem olyan izgalmas, csak visszakapjuk azokat az indexeket 0 és 15 között.

135
00:09:01,920 --> 00:09:07,729
De ha hozzátesszük azt a feltételt, hogy ezt csak if bit, azaz ha ez a bit 1 és nem

136
00:09:07,729 --> 00:09:13,400
0, akkor csak azokat a pozíciókat húzza ki, ahol a megfelelő bit be van kapcsolva.

137
00:09:13,400 --> 00:09:20,720
Ebben az esetben úgy tűnik, hogy ezek a pozíciók 0, 4, 6, 9 stb.

138
00:09:20,720 --> 00:09:25,340
Azt akarjuk, hogy összegyűjtsük ezeket a pozíciókat, a

139
00:09:25,340 --> 00:09:29,960
bekapcsolt bitek pozícióit, majd együtt XOR-eljük őket.

140
00:09:29,960 --> 00:09:33,960
Ahhoz, hogy ezt Pythonban megtegye, először importáljak néhány hasznos funkciót.

141
00:09:33,960 --> 00:09:36,550
Így meghívhatjuk a redukció()-t ezen a listán,

142
00:09:36,550 --> 00:09:39,140
és az XOR függvény segítségével csökkenthetjük.

143
00:09:39,140 --> 00:09:44,840
Ez alapvetően átveszi a listát, és végigviszi az XOR-t.

144
00:09:44,840 --> 00:09:48,225
Ha úgy tetszik, kifejezetten kiírhatja az XOR

145
00:09:48,225 --> 00:09:52,200
függvényt anélkül, hogy bárhonnan importálnia kellene.

146
00:09:52,200 --> 00:09:57,245
Tehát jelenleg úgy néz ki, hogy ha ezt tesszük a 16 bites véletlenszerű

147
00:09:57,245 --> 00:10:02,080
blokkon, akkor 9-et ad vissza, aminek a bináris reprezentációja 1001.

148
00:10:02,080 --> 00:10:06,482
Itt nem fogjuk megtenni, de írhat egy függvényt, ahol a küldő ezt a bináris

149
00:10:06,482 --> 00:10:11,406
reprezentációt használja a négy paritásbit igény szerinti beállításához, így végül a

150
00:10:11,406 --> 00:10:16,215
blokk olyan állapotba kerül, ahol ennek a kódsornak a futtatása a teljes bitlistán

151
00:10:16,215 --> 00:10:17,200
visszatér. egy 0.

152
00:10:17,200 --> 00:10:20,200
Ez egy jól előkészített blokknak tekinthető.

153
00:10:20,200 --> 00:10:25,550
A jó dolog az, hogy ha a listában szereplő bitek bármelyikét átkapcsoljuk, véletlenszerű

154
00:10:25,550 --> 00:10:30,600
zajból eredő hibát szimulálva, akkor ha ugyanazt a kódsort futtatja, kiírja a hibát.

155
00:10:30,600 --> 00:10:31,920
Hát nem ügyes?

156
00:10:31,920 --> 00:10:37,420
Megkaphatja ezt a blokkot a semmiből, futtathatja rajta ezt az egyetlen

157
00:10:37,420 --> 00:10:42,920
sort, és automatikusan kiköpi a hiba pozícióját, vagy egy 0-t, ha nincs.

158
00:10:42,920 --> 00:10:45,520
A 16-os méretben pedig nincs itt semmi különös.

159
00:10:45,520 --> 00:10:52,280
Ugyanez a kódsor működne, ha mondjuk 256 bites listája lenne.

160
00:10:52,280 --> 00:10:56,137
Mondanunk sem kell, hogy több kódot kell ide írni, például a meta

161
00:10:56,137 --> 00:11:00,287
paritásellenőrzést a 2 bites hibák észlelésére, de az ötlet az, hogy a

162
00:11:00,287 --> 00:11:05,080
sémánk szinte minden alapvető logikája egyetlen XOR-csökkentésre vezethető vissza.

163
00:11:05,080 --> 00:11:10,143
A bináris és XOR-ok és általában a szoftverek kényelmétől függően előfordulhat,

164
00:11:10,143 --> 00:11:14,889
hogy ezt a perspektívát kissé zavarónak találja, vagy sokkal elegánsabbnak

165
00:11:14,889 --> 00:11:19,320
és egyszerűbbnek, hogy azon töpreng, miért nem kezdtük el vele. -megy.

166
00:11:19,320 --> 00:11:23,405
Lazán szólva, a többszörös paritásellenőrzési perspektíva könnyebben átgondolható,

167
00:11:23,405 --> 00:11:27,048
ha a Hamming-kódokat nagyon közvetlenül implementálják hardverben, az XOR

168
00:11:27,048 --> 00:11:31,380
perspektívára pedig akkor a legegyszerűbb, ha szoftveresen, valamivel magasabb szintről.

169
00:11:31,380 --> 00:11:35,997
Az elsőt a legegyszerűbb kézzel elvégezni, és úgy gondolom, hogy ez jobban

170
00:11:35,997 --> 00:11:40,676
beépíti a mindennek hátterében álló alapvető intuíciót, vagyis azt, hogy az

171
00:11:40,676 --> 00:11:45,540
egyetlen hiba megtalálásához szükséges információ a blokk méretének naplójához

172
00:11:45,540 --> 00:11:51,020
kapcsolódik. , vagy más szóval, a blokk méretének megduplázódásával egy kicsit növekszik.

173
00:11:51,020 --> 00:11:53,730
A lényeges tény itt az, hogy ez az információ közvetlenül

174
00:11:53,730 --> 00:11:56,440
megfelel annak, hogy mekkora redundanciára van szükségünk.

175
00:11:56,440 --> 00:12:00,245
Valójában ez az, ami ellentétes a legtöbb ember térdrángó reakciójával, amikor

176
00:12:00,245 --> 00:12:04,003
először arra gondol, hogy egy üzenetet tegyen ellenállóvá a hibákkal szemben,

177
00:12:04,003 --> 00:12:07,520
ahol általában a teljes üzenet lemásolása az első ösztön, ami eszébe jut.

178
00:12:07,520 --> 00:12:11,264
És akkor, egyébként, van egy egészen más mód, hogy néha Hamming-kódokat

179
00:12:11,264 --> 00:12:14,800
látunk bemutatva, ahol az üzenetet megszorozzuk egy nagy mátrixszal.

180
00:12:14,800 --> 00:12:19,980
Ez kedves, mert a lineáris kódok tágabb családjához kapcsolódik, de szerintem ez

181
00:12:19,980 --> 00:12:25,160
szinte semmilyen megérzést nem ad arról, honnan származik vagy hogyan skálázódik.

182
00:12:25,160 --> 00:12:28,504
És ha a skálázásról beszélünk, észreveheti, hogy ennek a

183
00:12:28,504 --> 00:12:32,200
sémának a hatékonysága csak javul, ha növeljük a blokk méretét.

184
00:12:32,200 --> 00:12:37,666
Például azt láttuk, hogy 256 bittel ennek a helynek csak 3%-át

185
00:12:37,666 --> 00:12:43,480
használjuk fel a redundanciára, és onnantól kezdve egyre jobb lesz.

186
00:12:43,480 --> 00:12:49,040
Ahogy a paritásbitek száma egyesével nő, a blokk mérete folyamatosan megduplázódik.

187
00:12:49,040 --> 00:12:55,032
És ha ezt túlzásba viszed, akkor lehet egy millió bites blokk, ahol szó szerint

188
00:12:55,032 --> 00:13:00,800
20 kérdést játszanál a paritásellenőrzéssel, és csak 21 paritásbitet használ.

189
00:13:00,800 --> 00:13:04,876
És ha visszalép, és arra gondol, hogy megnézzen egymillió bitet,

190
00:13:04,876 --> 00:13:08,640
és megkeressen egyetlen hibát, az valóban őrültségnek tűnik.

191
00:13:08,640 --> 00:13:13,441
A probléma persze az, hogy egy nagyobb blokknál megnő annak a valószínűsége, hogy

192
00:13:13,441 --> 00:13:18,360
egy-két bitnél több hibát látunk, és a Hamming kódok ezen kívül semmit sem kezelnek.

193
00:13:18,360 --> 00:13:22,407
Tehát a gyakorlatban a megfelelő méretet szeretné megtalálni,

194
00:13:22,407 --> 00:13:26,520
hogy ne legyen túl nagy a valószínűsége a túl sok bitváltásnak.

195
00:13:26,520 --> 00:13:32,391
Ezenkívül a gyakorlatban a hibák általában kis sorozatokban érkeznek, ami teljesen

196
00:13:32,391 --> 00:13:38,688
tönkretesz egy blokkot, ezért az egyik gyakori taktika a hibák sorozatának szétosztására

197
00:13:38,688 --> 00:13:44,914
a különböző blokkok között az, hogy ezeket a blokkokat összefűzi, mielőtt kiküldve vagy

198
00:13:44,914 --> 00:13:45,480
tárolva.

199
00:13:45,480 --> 00:13:50,105
Viszont ennek nagy részét teljesen megkérdőjelezik a modernebb kódok, mint például

200
00:13:50,105 --> 00:13:54,731
a sokkal gyakrabban használt Reed-Solomon algoritmus, amely különösen jól kezeli a

201
00:13:54,731 --> 00:13:59,580
sorozathibákat, és blokkonként nagyobb számú hibával szemben is ellenállóra hangolható.

202
00:13:59,580 --> 00:14:03,000
De ez egy másik alkalom témája.

203
00:14:03,000 --> 00:14:07,162
A tudomány és mérnöki tevékenység művészete című könyvében Hamming csodálatosan

204
00:14:07,162 --> 00:14:10,700
őszintén beszél arról, hogy milyen kanyargós volt a kód felfedezése.

205
00:14:10,700 --> 00:14:14,428
Először mindenféle különféle sémát próbált ki, beleértve a biteket egy

206
00:14:14,428 --> 00:14:18,420
magasabb dimenziós rács részeire rendezve, és ehhez hasonló furcsa dolgokat.

207
00:14:18,420 --> 00:14:22,030
Az ötlet, hogy a paritásellenőrzések összeesküvésre késztethetők oly

208
00:14:22,030 --> 00:14:25,692
módon, hogy kifejtsék a hiba helyzetét, csak akkor jutott Hamminghez,

209
00:14:25,692 --> 00:14:29,406
amikor egy csomó egyéb elemzés után visszalépett, és megkérdezte: oké,

210
00:14:29,406 --> 00:14:32,860
mi a leghatékonyabb, amit tudok. elképzelhető, hogy erről van szó?

211
00:14:32,860 --> 00:14:37,420
Arról is őszintén beszélt, mennyire fontos, hogy már a paritásellenőrzés járt

212
00:14:37,420 --> 00:14:42,040
a fejében, ami az 1940-es években sokkal kevésbé volt elterjedt, mint manapság.

213
00:14:42,040 --> 00:14:45,983
A könyvben vagy fél tucatszor hivatkozik Louis Pasteur

214
00:14:45,983 --> 00:14:49,640
idézetére, a szerencse a felkészült elmének kedvez.

215
00:14:49,640 --> 00:14:52,356
Az okos ötletek gyakran megtévesztően egyszerűnek tűnnek

216
00:14:52,356 --> 00:14:55,120
utólag visszagondolva, ami miatt könnyen alulértékelhetők.

217
00:14:55,120 --> 00:14:58,520
Jelenleg őszintén remélem, hogy a Hamming-kódok, vagy legalábbis az

218
00:14:58,520 --> 00:15:01,820
ilyen kódok lehetősége, szinte magától értetődőnek tűnik számodra.

219
00:15:01,820 --> 00:15:04,995
De nem szabad becsapnia magát azzal, hogy azt gondolja,

220
00:15:04,995 --> 00:15:08,000
hogy ezek valójában nyilvánvalóak, mert biztosan nem.

221
00:15:08,000 --> 00:15:11,864
Az okos ötletek megtévesztően egyszerűnek tűnnek, részben az az oka, hogy

222
00:15:11,864 --> 00:15:15,833
mindig csak a végeredményt látjuk, tisztázzuk azt, ami rendetlen volt, soha

223
00:15:15,833 --> 00:15:19,958
nem említjük meg az összes rossz fordulatot, alábecsüljük, hogy a felfedezhető

224
00:15:19,958 --> 00:15:23,980
lehetőségek mekkora tere van a probléma kezdetén. megoldási folyamat, mindez.

225
00:15:23,980 --> 00:15:25,280
De ez általánosságban igaz.

226
00:15:25,280 --> 00:15:28,104
Azt hiszem, néhány különleges találmánynak van egy

227
00:15:28,104 --> 00:15:31,040
másik, mélyebb oka is annak, hogy alulbecsüljük őket.

228
00:15:31,040 --> 00:15:35,135
Az információ bitekben való gondolkodása csak 1948-ra vált igazán teljes

229
00:15:35,135 --> 00:15:39,400
elméletté, Claude Shannon információelméletről szóló alapvető tanulmányával.

230
00:15:39,400 --> 00:15:43,440
Ez lényegében egybeesett azzal, amikor Hamming kidolgozta az algoritmusát.

231
00:15:43,440 --> 00:15:46,915
Ez ugyanaz az alapdolgozat, amely bizonyos értelemben megmutatta,

232
00:15:46,915 --> 00:15:50,391
hogy a hatékony hibajavítás mindig lehetséges, függetlenül attól,

233
00:15:50,391 --> 00:15:53,920
hogy mekkora a valószínűsége a bitváltásnak, legalábbis elméletben.

234
00:15:53,920 --> 00:15:57,895
Shannon és Hamming egyébként a Bell Labs-ban osztozott egy irodában, annak

235
00:15:57,895 --> 00:16:02,400
ellenére, hogy nagyon különböző dolgokon dolgoztak, ami itt aligha tűnik véletlennek.

236
00:16:02,400 --> 00:16:06,088
Gyorsan előre több évtizedet, és manapság sokan annyira elmerülünk

237
00:16:06,088 --> 00:16:09,501
a bitekről és információkról való gondolkodásban, hogy könnyű

238
00:16:09,501 --> 00:16:13,080
figyelmen kívül hagyni, mennyire eltérő volt ez a gondolkodásmód.

239
00:16:13,080 --> 00:16:15,378
Ironikus módon azok az ötletek, amelyek a legmélyebben alakítják a jövő nemzedékének

240
00:16:15,378 --> 00:16:17,649
gondolkodásmódját, végül egyszerűbbnek tekintik a jövő generációját, mint amilyenek

241
00:16:17,649 --> 00:16:17,920
valójában.

