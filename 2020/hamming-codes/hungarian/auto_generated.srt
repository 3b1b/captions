1
00:00:00,000 --> 00:00:03,120
Feltételezem, hogy itt mindenki az 1. részből jön.

2
00:00:03,120 --> 00:00:07,043
Hamming-kódokról beszéltünk, egy olyan adatblokk létrehozásának módszeréről,

3
00:00:07,043 --> 00:00:09,692
amelyben a bitek többsége értelmes üzenetet hordoz,

4
00:00:09,692 --> 00:00:12,851
míg néhány másik egyfajta redundanciaként működik, oly módon,

5
00:00:12,851 --> 00:00:16,774
hogy ha bármelyik bit megfordul, akkor vagy üzenet bit vagy redundancia bit,

6
00:00:16,774 --> 00:00:20,544
bármi ebben a blokkban, a vevő képes lesz azonosítani, hogy hiba történt,

7
00:00:20,544 --> 00:00:21,920
és hogyan lehet kijavítani.

8
00:00:21,920 --> 00:00:25,925
Az ott bemutatott alapötlet az volt, hogyan lehet többszörös

9
00:00:25,925 --> 00:00:29,800
paritásellenőrzést használni a bináris kereséshez a hibáig.

10
00:00:29,800 --> 00:00:32,557
Ebben a videóban az volt a cél, hogy a Hamming-kódok

11
00:00:32,557 --> 00:00:35,420
a lehető leggyakrabban és újra felfedezhetővé váljanak.

12
00:00:35,420 --> 00:00:39,557
De ahogy elkezd gondolkodni ennek tényleges megvalósításán, akár szoftverben,

13
00:00:39,557 --> 00:00:44,120
akár hardverben, ez a keretezés valójában alááshatja, mennyire elegánsak ezek a kódok.

14
00:00:44,120 --> 00:00:46,665
Azt gondolhatnánk, hogy olyan algoritmust kell írnia,

15
00:00:46,665 --> 00:00:49,163
amely nyomon követi az összes lehetséges hibahelyet,

16
00:00:49,163 --> 00:00:52,887
és minden egyes ellenőrzéssel kettévágja azt a csoportot, de valójában sokkal,

17
00:00:52,887 --> 00:00:54,160
de sokkal egyszerűbb ennél.

18
00:00:54,160 --> 00:00:57,429
Ha felolvasod a négy paritásellenőrzésre adott válaszokat,

19
00:00:57,429 --> 00:01:01,918
amelyeket az előző videóban végeztünk, 1-es és 0-s formában igen és nem helyett,

20
00:01:01,918 --> 00:01:04,800
akkor szó szerint kiírja a hiba helyzetét binárisan.

21
00:01:04,800 --> 00:01:08,997
Például a 7-es szám binárisan úgy néz ki, mint 0111,

22
00:01:08,997 --> 00:01:12,640
lényegében azt mondva, hogy 4 plusz 2 plusz 1.

23
00:01:12,640 --> 00:01:16,441
És figyeld meg, hogy a 7-es pozíció hol helyezkedik el,

24
00:01:16,441 --> 00:01:22,280
ez érinti az első paritáscsoportunkat, a másodikat és a harmadikat, de nem az utolsót.

25
00:01:22,280 --> 00:01:25,286
Tehát e négy ellenőrzés eredményének alulról felfelé

26
00:01:25,286 --> 00:01:28,520
történő elolvasása valóban meghatározza a hiba helyzetét.

27
00:01:28,520 --> 00:01:32,100
A 7-es példában nincs semmi különös, ez általában működik,

28
00:01:32,100 --> 00:01:37,440
és ez megdöbbentően egyszerűvé teszi az egész séma hardveres megvalósításának logikáját.

29
00:01:37,440 --> 00:01:41,332
Ha szeretnéd látni, miért történik ez a varázslat,

30
00:01:41,332 --> 00:01:47,743
vegyük ezt a 16 indexcímkét a pozícióinkhoz, de ahelyett, hogy 10-es alapba írnánk,

31
00:01:47,743 --> 00:01:50,720
írjuk őket binárisan, 0000-től 1111-ig.

32
00:01:50,720 --> 00:01:54,379
Miközben ezeket a bináris címkéket visszahelyezzük a dobozukba,

33
00:01:54,379 --> 00:01:58,440
hadd hangsúlyozzam, hogy különböznek a ténylegesen elküldött adatoktól.

34
00:01:58,440 --> 00:02:02,262
Nem mások, mint egy fogalmi címke, amely segít neked és nekem megérteni,

35
00:02:02,262 --> 00:02:04,200
honnan jött a négy paritásos csoport.

36
00:02:04,200 --> 00:02:08,485
Azt az eleganciát, hogy mindent, amit nézünk, binárisan írunk le,

37
00:02:08,485 --> 00:02:13,160
talán aláássa az a zavar, hogy mindent, amit nézünk, binárisan írunk le.

38
00:02:13,160 --> 00:02:15,040
Pedig megéri.

39
00:02:15,040 --> 00:02:19,894
A címkék közül csak az utolsó bitre összpontosítsa figyelmét,

40
00:02:19,894 --> 00:02:24,280
majd jelölje ki azokat a helyeket, ahol az utolsó bit 1.

41
00:02:24,280 --> 00:02:28,623
A négy paritáscsoport közül az elsőt kapjuk, ami azt jelenti,

42
00:02:28,623 --> 00:02:34,087
hogy az első ellenőrzést úgy értelmezheti, hogy azt kérdezi, hé, ha hiba van,

43
00:02:34,087 --> 00:02:36,680
akkor a hiba helyének utolsó bitje 1?

44
00:02:36,680 --> 00:02:42,507
Hasonlóképpen, ha a másodiktól az utolsóig fókuszál, és kiemeli az összes olyan pozíciót,

45
00:02:42,507 --> 00:02:47,040
ahol ez 1, akkor megkapja a második paritáscsoportot a rendszerünkből.

46
00:02:47,040 --> 00:02:51,835
Más szóval, a második ellenőrzés azt kérdezi, hé, megint én,

47
00:02:51,835 --> 00:02:56,160
ha hiba van, akkor a pozíció második és utolsó bitje 1?

48
00:02:56,160 --> 00:02:57,160
Stb.

49
00:02:57,160 --> 00:03:01,098
A harmadik paritásellenőrzés minden olyan pozícióra kiterjed,

50
00:03:01,098 --> 00:03:05,418
amelynek harmadik bitje be van kapcsolva, az utolsó pedig az utolsó

51
00:03:05,418 --> 00:03:10,120
nyolc pozíciót fedi le, azokat, amelyeknek a legmagasabb sorrendű bitje 1.

52
00:03:10,120 --> 00:03:15,982
Minden, amit korábban tettünk, ugyanaz, mint ennek a négy kérdésnek a megválaszolása,

53
00:03:15,982 --> 00:03:19,800
ami viszont ugyanaz, mint egy pozíció kiírása binárisan.

54
00:03:19,800 --> 00:03:22,080
Remélem, ez két dolgot tisztáz.

55
00:03:22,080 --> 00:03:25,586
Az első az, hogyan lehet szisztematikusan általánosítani olyan blokkméretekre,

56
00:03:25,586 --> 00:03:27,140
amelyek kettőnél nagyobb hatványok.

57
00:03:27,140 --> 00:03:30,392
Ha több bitre van szükség az egyes pozíciók leírásához,

58
00:03:30,392 --> 00:03:33,296
például hat bitre van szükség 64 folt leírásához,

59
00:03:33,296 --> 00:03:37,071
akkor ezek a bitek mindegyike megadja az egyik paritáscsoportot,

60
00:03:37,071 --> 00:03:38,640
amelyet ellenőriznünk kell.

61
00:03:38,640 --> 00:03:40,544
Azok, akik megnézték azt a sakktábla-rejtvényt,

62
00:03:40,544 --> 00:03:43,400
amit Matt Parkerrel csináltam, mindezt rendkívül ismerősnek találhatták.

63
00:03:43,400 --> 00:03:46,970
Ugyanaz az alapvető logika, de más problémát old meg,

64
00:03:46,970 --> 00:03:49,880
és egy 64 négyzetes sakktáblára alkalmazzák.

65
00:03:49,880 --> 00:03:54,186
A második dolog, remélem, ez világossá teszi, hogy a paritásbitjeink miért

66
00:03:54,186 --> 00:03:58,320
vannak olyan pozíciókban, amelyek kettő hatványai, például 1, 2, 4 és 8.

67
00:03:58,320 --> 00:04:01,652
Ezek azok a pozíciók, amelyek bináris reprezentációjában

68
00:04:01,652 --> 00:04:03,640
csak egyetlen bit van bekapcsolva.

69
00:04:03,640 --> 00:04:08,188
Ez azt jelenti, hogy a paritásbitek mindegyike

70
00:04:08,188 --> 00:04:12,640
a négy paritáscsoport egyikén belül található.

71
00:04:12,640 --> 00:04:19,333
Ezt láthatod nagyobb példákon is, ahol akármekkora is leszel,

72
00:04:19,333 --> 00:04:25,920
minden paritásbit kényelmesen csak az egyik csoportot érinti.

73
00:04:25,920 --> 00:04:28,231
Ha megértjük, hogy ezek a paritásellenőrzések,

74
00:04:28,231 --> 00:04:31,133
amelyekre az időnk nagy részét összpontosítottuk, nem más,

75
00:04:31,133 --> 00:04:34,821
mint egy okos módszer a hiba helyének binárisban történő megfogalmazására,

76
00:04:34,821 --> 00:04:38,362
akkor összefüggést vonhatunk le a hamming másfajta gondolkodásmódjával.

77
00:04:38,362 --> 00:04:41,805
kódokat, amelyek vitathatatlanul sokkal egyszerűbbek és elegánsabbak,

78
00:04:41,805 --> 00:04:43,920
és alapvetően egyetlen kódsorral leírhatók.

79
00:04:43,920 --> 00:04:46,200
Az XOR függvényen alapul.

80
00:04:46,200 --> 00:04:50,960
Az XOR azoknak, akik nem ismerik, az exkluzív ill.

81
00:04:50,960 --> 00:04:54,469
Ha két bit XOR-jét veszed, akkor 1-et ad vissza,

82
00:04:54,469 --> 00:05:00,200
ha az egyik bit be van kapcsolva, de nem, ha mindkettő be vagy ki van kapcsolva.

83
00:05:00,200 --> 00:05:03,760
Másképpen fogalmazva ez a két bit paritása.

84
00:05:03,760 --> 00:05:07,840
Matematikusként szívesebben gondolok rá, mint 2. kiegészítésre.

85
00:05:07,840 --> 00:05:11,030
Gyakran beszélünk két különböző bitsor XOR-járól is,

86
00:05:11,030 --> 00:05:14,040
amely alapvetően komponensenként hajtja végre ezt.

87
00:05:14,040 --> 00:05:16,280
Ez olyan, mint egy kiegészítés, de ahol soha nem viszed magaddal.

88
00:05:16,280 --> 00:05:20,072
Ismét a matematikailag hajlamosabbak ezt inkább úgy gondolhatják,

89
00:05:20,072 --> 00:05:23,520
mintha két vektort adnának hozzá, és csökkentenék a mod 2-t.

90
00:05:23,520 --> 00:05:29,916
Ha most megnyit egy Pythont, és alkalmazza a caret műveletet két egész szám között,

91
00:05:29,916 --> 00:05:35,400
akkor ez az, amit csinál, csak a tető alatti számok bitreprezentációira.

92
00:05:35,400 --> 00:05:40,298
Számodra és nekem az a kulcsfontosságú, hogy a sok különböző bitsor

93
00:05:40,298 --> 00:05:45,773
XOR-értékének vétele hatékony módja annak, hogy egy csomó különálló csoport

94
00:05:45,773 --> 00:05:51,320
paródiáit számítsuk ki, mint ahogyan az oszlopoknál is, mindezt egy csapásra.

95
00:05:51,320 --> 00:05:54,152
Ez egy meglehetősen pofás módot ad arra, hogy elgondolkodjunk

96
00:05:54,152 --> 00:05:57,532
a Hamming-kód algoritmusunkból származó többszörös paritásellenőrzéseken,

97
00:05:57,532 --> 00:05:59,680
mivel mindez egyetlen műveletbe van csomagolva.

98
00:05:59,680 --> 00:06:02,800
Bár első pillantásra nagyon másképp néz ki.

99
00:06:02,800 --> 00:06:07,313
Konkrétan írja fel a 16 pozíciót binárisan, mint korábban,

100
00:06:07,313 --> 00:06:13,280
és most jelölje ki azokat a pozíciókat, ahol az üzenetbit 1-re van kapcsolva,

101
00:06:13,280 --> 00:06:19,400
majd gyűjtse össze ezeket a pozíciókat egy nagy oszlopba, és vegye fel az XOR-t.

102
00:06:19,400 --> 00:06:25,912
Valószínűleg sejtheti, hogy az eredményül kapott 4 bit megegyezik az általunk megismert

103
00:06:25,912 --> 00:06:31,610
és kedvelt 4 paritásellenőrzéssel, de szánjunk egy percet, hogy átgondoljuk,

104
00:06:31,610 --> 00:06:32,720
miért pontosan.

105
00:06:32,720 --> 00:06:37,742
Ez az utolsó oszlop például az összes olyan pozíciót számolja, amelynek utolsó bitje 1,

106
00:06:37,742 --> 00:06:42,364
de már csak a kiemelt pozíciókra korlátozódik, tehát gyakorlatilag azt számolja,

107
00:06:42,364 --> 00:06:45,960
hogy hány kiemelt pozíció származott az első paritáscsoportból.

108
00:06:45,960 --> 00:06:48,520
Ennek van értelme?

109
00:06:48,520 --> 00:06:51,357
Hasonlóképpen, a következő oszlop azt számolja,

110
00:06:51,357 --> 00:06:55,614
hogy hány pozíció van a második paritáscsoportban, azokat a pozíciókat,

111
00:06:55,614 --> 00:07:00,640
amelyek második és utolsó bitje 1, és amelyek szintén kiemelve vannak, és így tovább.

112
00:07:00,640 --> 00:07:07,640
Valójában ez csak egy kis perspektívaváltás ugyanabban a dologban, amit mi csináltunk.

113
00:07:07,640 --> 00:07:10,000
És hogy tudd, hová vezet innen.

114
00:07:10,000 --> 00:07:15,113
A küldő felelős néhány speciális paritásbit átkapcsolásáért,

115
00:07:15,113 --> 00:07:19,640
hogy megbizonyosodjon arról, hogy az összeg 0000 lesz.

116
00:07:19,640 --> 00:07:23,966
Ha már így van, akkor ez egy nagyon jó módot ad arra, hogy elgondolkodjunk azon,

117
00:07:23,966 --> 00:07:28,720
hogy ez a négy eredményül kapott bit az alján miért írja le közvetlenül a hiba helyzetét.

118
00:07:28,720 --> 00:07:32,720
Tegyük fel, hogy ebben a blokkban egy kicsit 0-ról 1-re vált.

119
00:07:32,720 --> 00:07:38,483
Ez azt jelenti, hogy ennek a bitnek a pozíciója bekerül a teljes XOR-be,

120
00:07:38,483 --> 00:07:44,800
ami 0-ról az összeget az újonnan hozzáadott értékre, a hiba helyére változtatja.

121
00:07:44,800 --> 00:07:47,587
Valamivel kevésbé nyilvánvaló, ugyanez igaz arra az esetre is,

122
00:07:47,587 --> 00:07:49,800
ha olyan hiba történik, amely 1-et 0-ra változtat.

123
00:07:49,800 --> 00:07:53,525
Tudod, ha kétszer összeadsz egy bites karakterláncot, az ugyanaz,

124
00:07:53,525 --> 00:07:56,403
mintha egyáltalán nem lenne ott, alapvetően azért,

125
00:07:56,403 --> 00:07:59,000
mert ebben a világban 1 plusz 1 egyenlő 0-val.

126
00:07:59,000 --> 00:08:01,844
Tehát ennek a pozíciónak a másolatának hozzáadása a

127
00:08:01,844 --> 00:08:05,400
végösszeghez ugyanazt a hatást eredményezi, mint ahogy mozgatjuk.

128
00:08:05,400 --> 00:08:13,480
És ez a hatás ismét az, hogy az összesített eredmény itt alul jelzi a hiba helyzetét.

129
00:08:13,480 --> 00:08:15,748
Annak szemléltetésére, hogy ez milyen elegáns,

130
00:08:15,748 --> 00:08:19,368
hadd mutassam meg azt a Python-kód egy sort, amelyre korábban hivatkoztam,

131
00:08:19,368 --> 00:08:22,120
és amely szinte az összes logikát rögzíti a vevő oldalán.

132
00:08:22,120 --> 00:08:27,346
Kezdjük azzal, hogy létrehozunk egy véletlenszerű 16 1-es és 0-s tömböt az adatblokk

133
00:08:27,346 --> 00:08:32,450
szimulálására, és megadom neki a névbiteket, de természetesen a gyakorlatban ezt a

134
00:08:32,450 --> 00:08:37,308
küldőtől kapjuk, és ahelyett, hogy véletlenszerű lévén 11 adatbitet hordozna 5

135
00:08:37,308 --> 00:08:38,600
paritásbittel együtt.

136
00:08:38,600 --> 00:08:42,497
Ha az enumerateBits függvényt hívom, akkor azt csinálja,

137
00:08:42,497 --> 00:08:48,240
hogy ezeket a biteket párosítja a megfelelő indexszel, ebben az esetben 0-tól 15-ig.

138
00:08:48,240 --> 00:08:52,474
Tehát ha ezután létrehozunk egy listát, amely az összes ilyen páron áthurkol,

139
00:08:52,474 --> 00:08:56,545
olyan párokon, amelyek i-nek néznek ki, majd csak az i értéket vesszük ki,

140
00:08:56,545 --> 00:09:01,105
csak az indexet, akkor ez nem olyan izgalmas, csak visszakapjuk azokat az indexeket

141
00:09:01,105 --> 00:09:01,920
0 és 15 között.

142
00:09:01,920 --> 00:09:07,936
De ha hozzátesszük azt a feltételt, hogy ezt csak if bit, azaz ha ez a bit 1 és nem 0,

143
00:09:07,936 --> 00:09:13,400
akkor csak azokat a pozíciókat húzza ki, ahol a megfelelő bit be van kapcsolva.

144
00:09:13,400 --> 00:09:20,720
Ebben az esetben úgy tűnik, hogy ezek a pozíciók 0, 4, 6, 9 stb.

145
00:09:20,720 --> 00:09:25,172
Azt akarjuk, hogy összegyűjtsük ezeket a pozíciókat,

146
00:09:25,172 --> 00:09:29,960
a bekapcsolt bitek pozícióit, majd együtt XOR-eljük őket.

147
00:09:29,960 --> 00:09:33,960
Ahhoz, hogy ezt Pythonban megtegye, először importáljak néhány hasznos funkciót.

148
00:09:33,960 --> 00:09:36,550
Így meghívhatjuk a redukció()-t ezen a listán,

149
00:09:36,550 --> 00:09:39,140
és az XOR függvény segítségével csökkenthetjük.

150
00:09:39,140 --> 00:09:44,840
Ez alapvetően átveszi a listát, és végigviszi az XOR-t.

151
00:09:44,840 --> 00:09:49,624
Ha úgy tetszik, kifejezetten kiírhatja az XOR függvényt anélkül,

152
00:09:49,624 --> 00:09:52,200
hogy bárhonnan importálnia kellene.

153
00:09:52,200 --> 00:09:57,875
Tehát jelenleg úgy néz ki, hogy ha ezt tesszük a 16 bites véletlenszerű blokkon,

154
00:09:57,875 --> 00:10:02,080
akkor 9-et ad vissza, aminek a bináris reprezentációja 1001.

155
00:10:02,080 --> 00:10:04,918
Itt nem fogjuk megtenni, de írhat egy függvényt,

156
00:10:04,918 --> 00:10:09,842
ahol a küldő ezt a bináris reprezentációt használja a négy paritásbit igény szerinti

157
00:10:09,842 --> 00:10:13,086
beállításához, így végül a blokk olyan állapotba kerül,

158
00:10:13,086 --> 00:10:17,200
ahol ennek a kódsornak a futtatása a teljes bitlistán visszatér. egy 0.

159
00:10:17,200 --> 00:10:20,200
Ez egy jól előkészített blokknak tekinthető.

160
00:10:20,200 --> 00:10:24,708
A jó dolog az, hogy ha a listában szereplő bitek bármelyikét átkapcsoljuk,

161
00:10:24,708 --> 00:10:29,698
véletlenszerű zajból eredő hibát szimulálva, akkor ha ugyanazt a kódsort futtatja,

162
00:10:29,698 --> 00:10:30,600
kiírja a hibát.

163
00:10:30,600 --> 00:10:31,920
Hát nem ügyes?

164
00:10:31,920 --> 00:10:37,878
Megkaphatja ezt a blokkot a semmiből, futtathatja rajta ezt az egyetlen sort,

165
00:10:37,878 --> 00:10:42,920
és automatikusan kiköpi a hiba pozícióját, vagy egy 0-t, ha nincs.

166
00:10:42,920 --> 00:10:45,520
A 16-os méretben pedig nincs itt semmi különös.

167
00:10:45,520 --> 00:10:52,280
Ugyanez a kódsor működne, ha mondjuk 256 bites listája lenne.

168
00:10:52,280 --> 00:10:55,260
Mondanunk sem kell, hogy több kódot kell ide írni,

169
00:10:55,260 --> 00:10:59,878
például a meta paritásellenőrzést a 2 bites hibák észlelésére, de az ötlet az,

170
00:10:59,878 --> 00:11:05,080
hogy a sémánk szinte minden alapvető logikája egyetlen XOR-csökkentésre vezethető vissza.

171
00:11:05,080 --> 00:11:10,143
A bináris és XOR-ok és általában a szoftverek kényelmétől függően előfordulhat,

172
00:11:10,143 --> 00:11:13,244
hogy ezt a perspektívát kissé zavarónak találja,

173
00:11:13,244 --> 00:11:17,231
vagy sokkal elegánsabbnak és egyszerűbbnek, hogy azon töpreng,

174
00:11:17,231 --> 00:11:19,320
miért nem kezdtük el vele. -megy.

175
00:11:19,320 --> 00:11:23,405
Lazán szólva, a többszörös paritásellenőrzési perspektíva könnyebben átgondolható,

176
00:11:23,405 --> 00:11:26,703
ha a Hamming-kódokat nagyon közvetlenül implementálják hardverben,

177
00:11:26,703 --> 00:11:30,001
az XOR perspektívára pedig akkor a legegyszerűbb, ha szoftveresen,

178
00:11:30,001 --> 00:11:31,380
valamivel magasabb szintről.

179
00:11:31,380 --> 00:11:35,074
Az elsőt a legegyszerűbb kézzel elvégezni, és úgy gondolom,

180
00:11:35,074 --> 00:11:40,184
hogy ez jobban beépíti a mindennek hátterében álló alapvető intuíciót, vagyis azt,

181
00:11:40,184 --> 00:11:44,863
hogy az egyetlen hiba megtalálásához szükséges információ a blokk méretének

182
00:11:44,863 --> 00:11:49,727
naplójához kapcsolódik. , vagy más szóval, a blokk méretének megduplázódásával

183
00:11:49,727 --> 00:11:51,020
egy kicsit növekszik.

184
00:11:51,020 --> 00:11:54,477
A lényeges tény itt az, hogy ez az információ közvetlenül megfelel annak,

185
00:11:54,477 --> 00:11:56,440
hogy mekkora redundanciára van szükségünk.

186
00:11:56,440 --> 00:11:59,908
Valójában ez az, ami ellentétes a legtöbb ember térdrángó reakciójával,

187
00:11:59,908 --> 00:12:04,003
amikor először arra gondol, hogy egy üzenetet tegyen ellenállóvá a hibákkal szemben,

188
00:12:04,003 --> 00:12:07,520
ahol általában a teljes üzenet lemásolása az első ösztön, ami eszébe jut.

189
00:12:07,520 --> 00:12:12,200
És akkor, egyébként, van egy egészen más mód, hogy néha Hamming-kódokat látunk bemutatva,

190
00:12:12,200 --> 00:12:14,800
ahol az üzenetet megszorozzuk egy nagy mátrixszal.

191
00:12:14,800 --> 00:12:18,956
Ez kedves, mert a lineáris kódok tágabb családjához kapcsolódik,

192
00:12:18,956 --> 00:12:22,601
de szerintem ez szinte semmilyen megérzést nem ad arról,

193
00:12:22,601 --> 00:12:25,160
honnan származik vagy hogyan skálázódik.

194
00:12:25,160 --> 00:12:28,504
És ha a skálázásról beszélünk, észreveheti, hogy ennek a

195
00:12:28,504 --> 00:12:32,200
sémának a hatékonysága csak javul, ha növeljük a blokk méretét.

196
00:12:32,200 --> 00:12:37,666
Például azt láttuk, hogy 256 bittel ennek a helynek csak 3%-át

197
00:12:37,666 --> 00:12:43,480
használjuk fel a redundanciára, és onnantól kezdve egyre jobb lesz.

198
00:12:43,480 --> 00:12:49,040
Ahogy a paritásbitek száma egyesével nő, a blokk mérete folyamatosan megduplázódik.

199
00:12:49,040 --> 00:12:53,758
És ha ezt túlzásba viszed, akkor lehet egy millió bites blokk,

200
00:12:53,758 --> 00:12:58,403
ahol szó szerint 20 kérdést játszanál a paritásellenőrzéssel,

201
00:12:58,403 --> 00:13:00,800
és csak 21 paritásbitet használ.

202
00:13:00,800 --> 00:13:04,876
És ha visszalép, és arra gondol, hogy megnézzen egymillió bitet,

203
00:13:04,876 --> 00:13:08,640
és megkeressen egyetlen hibát, az valóban őrültségnek tűnik.

204
00:13:08,640 --> 00:13:13,148
A probléma persze az, hogy egy nagyobb blokknál megnő annak a valószínűsége,

205
00:13:13,148 --> 00:13:18,360
hogy egy-két bitnél több hibát látunk, és a Hamming kódok ezen kívül semmit sem kezelnek.

206
00:13:18,360 --> 00:13:22,407
Tehát a gyakorlatban a megfelelő méretet szeretné megtalálni,

207
00:13:22,407 --> 00:13:26,520
hogy ne legyen túl nagy a valószínűsége a túl sok bitváltásnak.

208
00:13:26,520 --> 00:13:31,472
Ezenkívül a gyakorlatban a hibák általában kis sorozatokban érkeznek,

209
00:13:31,472 --> 00:13:37,697
ami teljesen tönkretesz egy blokkot, ezért az egyik gyakori taktika a hibák sorozatának

210
00:13:37,697 --> 00:13:43,357
szétosztására a különböző blokkok között az, hogy ezeket a blokkokat összefűzi,

211
00:13:43,357 --> 00:13:45,480
mielőtt kiküldve vagy tárolva.

212
00:13:45,480 --> 00:13:49,381
Viszont ennek nagy részét teljesen megkérdőjelezik a modernebb kódok,

213
00:13:49,381 --> 00:13:53,115
mint például a sokkal gyakrabban használt Reed-Solomon algoritmus,

214
00:13:53,115 --> 00:13:57,685
amely különösen jól kezeli a sorozathibákat, és blokkonként nagyobb számú hibával

215
00:13:57,685 --> 00:13:59,580
szemben is ellenállóra hangolható.

216
00:13:59,580 --> 00:14:03,000
De ez egy másik alkalom témája.

217
00:14:03,000 --> 00:14:07,162
A tudomány és mérnöki tevékenység művészete című könyvében Hamming csodálatosan

218
00:14:07,162 --> 00:14:10,700
őszintén beszél arról, hogy milyen kanyargós volt a kód felfedezése.

219
00:14:10,700 --> 00:14:13,168
Először mindenféle különféle sémát próbált ki,

220
00:14:13,168 --> 00:14:16,686
beleértve a biteket egy magasabb dimenziós rács részeire rendezve,

221
00:14:16,686 --> 00:14:18,420
és ehhez hasonló furcsa dolgokat.

222
00:14:18,420 --> 00:14:22,396
Az ötlet, hogy a paritásellenőrzések összeesküvésre késztethetők oly módon,

223
00:14:22,396 --> 00:14:25,692
hogy kifejtsék a hiba helyzetét, csak akkor jutott Hamminghez,

224
00:14:25,692 --> 00:14:29,406
amikor egy csomó egyéb elemzés után visszalépett, és megkérdezte: oké,

225
00:14:29,406 --> 00:14:32,860
mi a leghatékonyabb, amit tudok. elképzelhető, hogy erről van szó?

226
00:14:32,860 --> 00:14:38,063
Arról is őszintén beszélt, mennyire fontos, hogy már a paritásellenőrzés járt a fejében,

227
00:14:38,063 --> 00:14:42,040
ami az 1940-es években sokkal kevésbé volt elterjedt, mint manapság.

228
00:14:42,040 --> 00:14:46,772
A könyvben vagy fél tucatszor hivatkozik Louis Pasteur idézetére,

229
00:14:46,772 --> 00:14:49,640
a szerencse a felkészült elmének kedvez.

230
00:14:49,640 --> 00:14:53,452
Az okos ötletek gyakran megtévesztően egyszerűnek tűnnek utólag visszagondolva,

231
00:14:53,452 --> 00:14:55,120
ami miatt könnyen alulértékelhetők.

232
00:14:55,120 --> 00:14:57,570
Jelenleg őszintén remélem, hogy a Hamming-kódok,

233
00:14:57,570 --> 00:15:01,820
vagy legalábbis az ilyen kódok lehetősége, szinte magától értetődőnek tűnik számodra.

234
00:15:01,820 --> 00:15:04,995
De nem szabad becsapnia magát azzal, hogy azt gondolja,

235
00:15:04,995 --> 00:15:08,000
hogy ezek valójában nyilvánvalóak, mert biztosan nem.

236
00:15:08,000 --> 00:15:11,603
Az okos ötletek megtévesztően egyszerűnek tűnnek, részben az az oka,

237
00:15:11,603 --> 00:15:15,572
hogy mindig csak a végeredményt látjuk, tisztázzuk azt, ami rendetlen volt,

238
00:15:15,572 --> 00:15:18,914
soha nem említjük meg az összes rossz fordulatot, alábecsüljük,

239
00:15:18,914 --> 00:15:22,570
hogy a felfedezhető lehetőségek mekkora tere van a probléma kezdetén.

240
00:15:22,570 --> 00:15:23,980
megoldási folyamat, mindez.

241
00:15:23,980 --> 00:15:25,280
De ez általánosságban igaz.

242
00:15:25,280 --> 00:15:28,492
Azt hiszem, néhány különleges találmánynak van egy másik,

243
00:15:28,492 --> 00:15:31,040
mélyebb oka is annak, hogy alulbecsüljük őket.

244
00:15:31,040 --> 00:15:35,753
Az információ bitekben való gondolkodása csak 1948-ra vált igazán teljes elméletté,

245
00:15:35,753 --> 00:15:39,400
Claude Shannon információelméletről szóló alapvető tanulmányával.

246
00:15:39,400 --> 00:15:43,440
Ez lényegében egybeesett azzal, amikor Hamming kidolgozta az algoritmusát.

247
00:15:43,440 --> 00:15:46,915
Ez ugyanaz az alapdolgozat, amely bizonyos értelemben megmutatta,

248
00:15:46,915 --> 00:15:50,391
hogy a hatékony hibajavítás mindig lehetséges, függetlenül attól,

249
00:15:50,391 --> 00:15:53,920
hogy mekkora a valószínűsége a bitváltásnak, legalábbis elméletben.

250
00:15:53,920 --> 00:15:58,425
Shannon és Hamming egyébként a Bell Labs-ban osztozott egy irodában, annak ellenére,

251
00:15:58,425 --> 00:16:02,400
hogy nagyon különböző dolgokon dolgoztak, ami itt aligha tűnik véletlennek.

252
00:16:02,400 --> 00:16:06,088
Gyorsan előre több évtizedet, és manapság sokan annyira elmerülünk

253
00:16:06,088 --> 00:16:08,841
a bitekről és információkról való gondolkodásban,

254
00:16:08,841 --> 00:16:13,080
hogy könnyű figyelmen kívül hagyni, mennyire eltérő volt ez a gondolkodásmód.

255
00:16:13,080 --> 00:16:15,378
Ironikus módon azok az ötletek, amelyek a legmélyebben alakítják a jövő nemzedékének

256
00:16:15,378 --> 00:16:17,244
gondolkodásmódját, végül egyszerűbbnek tekintik a jövő generációját,

257
00:16:17,244 --> 00:16:17,920
mint amilyenek valójában.

