1
00:00:00,000 --> 00:00:03,120
Buradaki herkesin 1. bölümden geldiğini varsayıyorum.

2
00:00:03,120 --> 00:00:07,715
Bitlerin çoğunun anlamlı bir mesaj taşıdığı, diğer birkaç parçanın ise bir tür artıklık

3
00:00:07,715 --> 00:00:11,736
işlevi gördüğü bir veri bloğu oluşturmanın bir yolu olan Hamming kodlarından

4
00:00:11,736 --> 00:00:16,332
bahsediyorduk; herhangi bir bit ters çevrildiğinde ya bir mesaj Bit veya artıklık biti,

5
00:00:16,332 --> 00:00:20,875
bu bloktaki herhangi bir şeyde, alıcı bir hata olduğunu ve bunun nasıl düzeltileceğini

6
00:00:20,875 --> 00:00:21,920
tanımlayabilecektir.

7
00:00:21,920 --> 00:00:25,826
Orada sunulan temel fikir, hataya giden yolda ikili arama

8
00:00:25,826 --> 00:00:29,800
yapmak için çoklu eşlik kontrolünün nasıl kullanılacağıydı.

9
00:00:29,800 --> 00:00:32,507
Bu videoda amaç, Hamming kodlarının mümkün olduğunca

10
00:00:32,507 --> 00:00:35,420
uygulamalı ve yeniden keşfedilebilir olmasını sağlamaktı.

11
00:00:35,420 --> 00:00:39,639
Ancak bunu yazılım veya donanımda gerçekten uygulamayı düşünmeye başladığınızda,

12
00:00:39,639 --> 00:00:44,120
bu çerçeveleme aslında bu kodların gerçekte ne kadar zarif olduğunun altını çizebilir.

13
00:00:44,120 --> 00:00:47,319
Tüm olası hata konumlarını takip eden ve her kontrolde bu

14
00:00:47,319 --> 00:00:51,401
grubu yarıya indiren bir algoritma yazmanız gerektiğini düşünebilirsiniz,

15
00:00:51,401 --> 00:00:54,160
ancak aslında bu bundan çok ama çok daha basittir.

16
00:00:54,160 --> 00:00:59,450
Son videoda yaptığımız dört eşlik kontrolünün yanıtlarını evet ve hayır yerine 1&#39;ler

17
00:00:59,450 --> 00:01:04,800
ve 0&#39;lar olarak okursanız, bu tam anlamıyla hatanın ikili dosyadaki konumunu belirtir.

18
00:01:04,800 --> 00:01:09,231
Örneğin, ikili sistemde 7 sayısı 0111&#39;e benzer,

19
00:01:09,231 --> 00:01:12,640
aslında 4 artı 2 artı 1 olduğunu söyler.

20
00:01:12,640 --> 00:01:18,201
Ve 7. pozisyonun nerede olduğuna dikkat edin, bu durum eşitlik gruplarımızın birincisini,

21
00:01:18,201 --> 00:01:22,280
ikincisini ve üçüncüsünü etkiliyor, ancak sonuncusunu etkilemiyor.

22
00:01:22,280 --> 00:01:25,259
Yani bu dört kontrolün sonuçlarını aşağıdan yukarıya

23
00:01:25,259 --> 00:01:28,520
doğru okumak gerçekten de hatanın konumunu ortaya koyuyor.

24
00:01:28,520 --> 00:01:32,458
Örnek 7&#39;de özel bir şey yok, bu genel olarak işe yarıyor ve bu,

25
00:01:32,458 --> 00:01:37,440
tüm şemanın donanıma uygulanmasının mantığını şaşırtıcı derecede basit hale getiriyor.

26
00:01:37,440 --> 00:01:40,938
Şimdi bu sihrin neden oluştuğunu görmek istiyorsanız,

27
00:01:40,938 --> 00:01:44,177
pozisyonlarımız için bu 16 indeks etiketini alın,

28
00:01:44,177 --> 00:01:48,258
ancak bunları 10 tabanında yazmak yerine, hepsini 0000&#39;den

29
00:01:48,258 --> 00:01:50,720
1111&#39;e kadar ikili olarak yazalım.

30
00:01:50,720 --> 00:01:54,641
Bu ikili etiketleri kutularına geri koyarken, bunların gerçekte

31
00:01:54,641 --> 00:01:58,440
gönderilen verilerden farklı olduklarını vurgulamam gerekiyor.

32
00:01:58,440 --> 00:02:01,125
Bunlar sizin ve benim dört eşitlik grubunun nereden geldiğini

33
00:02:01,125 --> 00:02:04,200
anlamamıza yardımcı olacak kavramsal bir etiketten başka bir şey değil.

34
00:02:04,200 --> 00:02:07,325
Baktığımız her şeyin ikili olarak tanımlanmasının zarafeti,

35
00:02:07,325 --> 00:02:11,805
belki de baktığımız her şeyin ikili olarak tanımlanmasının yarattığı kafa karışıklığı

36
00:02:11,805 --> 00:02:13,160
nedeniyle gölgede kalıyor.

37
00:02:13,160 --> 00:02:15,040
Yine de buna değer.

38
00:02:15,040 --> 00:02:19,860
Dikkatinizi tüm bu etiketlerin sadece son kısmına odaklayın

39
00:02:19,860 --> 00:02:24,280
ve ardından bu son bitin 1 olduğu konumları vurgulayın.

40
00:02:24,280 --> 00:02:28,111
Elde ettiğimiz şey, dört eşlik grubumuzun ilkidir; bu,

41
00:02:28,111 --> 00:02:34,172
ilk kontrolü şu soruyla yorumlayabileceğiniz anlamına gelir: hey, eğer bir hata varsa,

42
00:02:34,172 --> 00:02:36,680
bu hatanın konumundaki son bit 1 mi?

43
00:02:36,680 --> 00:02:41,895
Benzer şekilde, ikinciden sonuncuya odaklanırsanız ve bunun 1 olduğu tüm

44
00:02:41,895 --> 00:02:47,040
konumları vurgularsanız, şemamızdan ikinci eşlik grubunu elde edersiniz.

45
00:02:47,040 --> 00:02:51,855
Başka bir deyişle, bu ikinci kontrol şunu soruyor: Hey, ben yine,

46
00:02:51,855 --> 00:02:56,160
eğer bir hata varsa, bu konumun ikinciden sondan biti 1 mi?

47
00:02:56,160 --> 00:02:57,160
Ve benzeri.

48
00:02:57,160 --> 00:03:03,597
Üçüncü eşlik kontrolü, üçüncü bitten son bitine kadar açık olan her konumu

49
00:03:03,597 --> 00:03:10,120
kapsar ve sonuncusu, en yüksek dereceli biti 1 olan son sekiz konumu kapsar.

50
00:03:10,120 --> 00:03:15,231
Daha önce yaptığımız her şey bu dört soruyu yanıtlamakla aynıydı,

51
00:03:15,231 --> 00:03:19,800
bu da ikili sistemde bir konumun hecelenmesiyle aynı şeydi.

52
00:03:19,800 --> 00:03:22,080
Umarım bu iki şeyi daha açık hale getirir.

53
00:03:22,080 --> 00:03:24,831
Birincisi, ikinin daha büyük kuvvetleri olan blok boyutlarına

54
00:03:24,831 --> 00:03:27,140
sistematik olarak nasıl genelleştirme yapılacağıdır.

55
00:03:27,140 --> 00:03:30,353
Her bir konumu tanımlamak daha fazla bit gerektiriyorsa,

56
00:03:30,353 --> 00:03:33,566
örneğin 64 noktayı tanımlamak için altı bit gerekiyorsa,

57
00:03:33,566 --> 00:03:38,640
o zaman bu bitlerin her biri size kontrol etmemiz gereken eşlik gruplarından birini verir.

58
00:03:38,640 --> 00:03:41,020
Matt Parker&#39;la yaptığım satranç tahtası bulmacasını

59
00:03:41,020 --> 00:03:43,400
izleyenleriniz tüm bunları fazlasıyla tanıdık bulabilir.

60
00:03:43,400 --> 00:03:46,292
Bu aynı temel mantıktır ancak farklı bir problemi

61
00:03:46,292 --> 00:03:49,880
çözmektedir ve 64 karelik bir satranç tahtasına uygulanmıştır.

62
00:03:49,880 --> 00:03:52,911
Bunun açıklığa kavuşturacağını umduğum ikinci şey,

63
00:03:52,911 --> 00:03:57,071
eşlik bitlerimizin neden ikinin kuvvetleri olan konumlarda olduğudur,

64
00:03:57,071 --> 00:03:58,320
örneğin 1, 2, 4 ve 8.

65
00:03:58,320 --> 00:04:03,640
Bunlar, ikili gösterimi yalnızca tek bir bitin açık olduğu konumlardır.

66
00:04:03,640 --> 00:04:07,630
Bunun anlamı, bu eşlik bitlerinin her birinin,

67
00:04:07,630 --> 00:04:12,640
dört eşlik grubundan yalnızca birinin içinde yer almasıdır.

68
00:04:12,640 --> 00:04:19,963
Bunu daha büyük örneklerde de görebilirsiniz; ne kadar büyürseniz büyüsün,

69
00:04:19,963 --> 00:04:25,920
her eşlik biti rahatlıkla gruplardan yalnızca birine dokunur.

70
00:04:25,920 --> 00:04:29,953
Zamanımızın büyük bir kısmını üzerinde yoğunlaştığımız bu eşlik kontrollerinin,

71
00:04:29,953 --> 00:04:34,188
ikili sistemde bir hatanın konumunu açıklamanın akıllıca bir yolundan başka bir şey

72
00:04:34,188 --> 00:04:38,373
olmadığını anladığınızda, hamming hakkında düşünmenin farklı bir yolu ile bağlantı

73
00:04:38,373 --> 00:04:42,457
kurabiliriz. Muhtemelen çok daha basit ve daha zarif olan ve temelde tek bir kod

74
00:04:42,457 --> 00:04:43,920
satırıyla yazılabilen kodlar.

75
00:04:43,920 --> 00:04:46,200
XOR fonksiyonuna dayanmaktadır.

76
00:04:46,200 --> 00:04:50,960
Bilmeyenler için XOR, özel veya anlamına gelir.

77
00:04:50,960 --> 00:04:56,617
İki bitin XOR&#39;unu aldığınızda, bu bitlerden herhangi biri açıksa 1 değerini döndürür,

78
00:04:56,617 --> 00:05:00,200
ancak her ikisi de açık veya kapalıysa bu sonuç değişmez.

79
00:05:00,200 --> 00:05:03,760
Farklı bir ifadeyle bu iki bitin paritesidir.

80
00:05:03,760 --> 00:05:07,840
Bir matematikçi olarak bunu toplama modu 2 olarak düşünmeyi tercih ederim.

81
00:05:07,840 --> 00:05:11,346
Ayrıca genellikle iki farklı bit dizisinin XOR&#39;undan bahsederiz,

82
00:05:11,346 --> 00:05:14,040
bu da temel olarak bu bileşeni bileşen bazında yapar.

83
00:05:14,040 --> 00:05:16,280
Toplama gibi ama asla taşımadığınız yer.

84
00:05:16,280 --> 00:05:19,985
Yine, matematiğe daha yatkın olanlar bunu iki vektörün eklenmesi

85
00:05:19,985 --> 00:05:23,520
ve mod 2&#39;nin azaltılması olarak düşünmeyi tercih edebilir.

86
00:05:23,520 --> 00:05:28,926
Şu anda Python&#39;u açarsanız ve iki tamsayı arasında düzeltme işareti işlemini

87
00:05:28,926 --> 00:05:34,665
uygularsanız, yaptığı şey budur, ancak bu sayıların başlık altındaki bit temsillerine

88
00:05:34,665 --> 00:05:35,400
yöneliktir.

89
00:05:35,400 --> 00:05:41,737
Sizin ve benim için kilit nokta, birçok farklı bit dizisinin XOR&#39;unu almanın,

90
00:05:41,737 --> 00:05:46,760
sütunlarda olduğu gibi bir grup ayrı grubun parodilerini tek bir

91
00:05:46,760 --> 00:05:51,320
hamlede etkili bir şekilde hesaplamanın bir yolu olmasıdır.

92
00:05:51,320 --> 00:05:55,385
Bu bize, Hamming kod algoritmamızın çoklu eşlik kontrollerinin tek bir

93
00:05:55,385 --> 00:05:59,680
işlemde paketlenmesi hakkında düşünmemiz için oldukça şık bir yol sağlıyor.

94
00:05:59,680 --> 00:06:02,800
Her ne kadar ilk bakışta çok farklı görünse de.

95
00:06:02,800 --> 00:06:08,388
Daha önce yaptığımız gibi, ikili olarak 16 konumu özel olarak yazın

96
00:06:08,388 --> 00:06:13,894
ve şimdi mesaj bitinin 1&#39;e açık olduğu konumları vurgulayın ve

97
00:06:13,894 --> 00:06:19,400
ardından bu konumları büyük bir sütunda toplayın ve XOR&#39;u alın.

98
00:06:19,400 --> 00:06:23,681
Sonuç olarak altta bulunan 4 bitin, bildiğimiz ve sevdiğimiz 4

99
00:06:23,681 --> 00:06:28,098
eşlik kontrolüyle aynı olduğunu muhtemelen tahmin edebilirsiniz,

100
00:06:28,098 --> 00:06:32,720
ancak bunun nedenini tam olarak düşünmek için bir dakikanızı ayırın.

101
00:06:32,720 --> 00:06:36,571
Örneğin bu son sütun, son biti 1 olan tüm pozisyonları sayıyor,

102
00:06:36,571 --> 00:06:40,122
ancak biz zaten yalnızca vurgulanan konumlarla sınırlıyız,

103
00:06:40,122 --> 00:06:44,335
dolayısıyla kaç tane vurgulanan konumun ilk eşlik grubundan geldiğini

104
00:06:44,335 --> 00:06:45,960
etkili bir şekilde sayıyor.

105
00:06:45,960 --> 00:06:48,520
bu mantıklı mı?

106
00:06:48,520 --> 00:06:55,058
Benzer şekilde, bir sonraki sütun, ikinci eşlik grubunda kaç konumun bulunduğunu,

107
00:06:55,058 --> 00:07:00,640
ikinciden sondan biti 1 olan ve hangilerinin vurgulandığını vb. sayar.

108
00:07:00,640 --> 00:07:07,640
Aslında bu, yapmakta olduğumuz şeye ilişkin perspektifte küçük bir değişiklik.

109
00:07:07,640 --> 00:07:10,000
Yani buradan nereye gideceğini biliyorsun.

110
00:07:10,000 --> 00:07:14,820
Gönderen, toplamın 0000 olmasını sağlamak için bazı

111
00:07:14,820 --> 00:07:19,640
özel eşlik bitlerinin değiştirilmesinden sorumludur.

112
00:07:19,640 --> 00:07:22,633
Şimdi bu şekilde elde ettiğimizde, bu bize, alttaki sonuçta

113
00:07:22,633 --> 00:07:25,626
ortaya çıkan dört bitin neden doğrudan bir hatanın konumunu

114
00:07:25,626 --> 00:07:28,720
gösterdiğini düşünmemiz için gerçekten güzel bir yol sağlıyor.

115
00:07:28,720 --> 00:07:32,720
Diyelim ki bu bloktaki bir bit 0&#39;dan 1&#39;e değiştirildi.

116
00:07:32,720 --> 00:07:38,270
Bunun anlamı, o bitin konumu artık toplam XOR&#39;a dahil edilecek,

117
00:07:38,270 --> 00:07:44,800
bu da toplamı 0&#39;dan yeni eklenen değere, yani hatanın konumuna dönüştürecek.

118
00:07:44,800 --> 00:07:47,300
Biraz daha az açık bir şekilde, 1&#39;i 0&#39;a

119
00:07:47,300 --> 00:07:49,800
değiştiren bir hata varsa aynı durum geçerlidir.

120
00:07:49,800 --> 00:07:53,803
Görüyorsunuz, eğer bir bit dizisini iki kez toplarsanız,

121
00:07:53,803 --> 00:07:59,000
bu orada hiç olmamasıyla aynı şeydir, çünkü bu dünyada 1 artı 1 eşittir 0.

122
00:07:59,000 --> 00:08:02,880
Yani bu pozisyonun bir kopyasını toplam toplama eklemek,

123
00:08:02,880 --> 00:08:05,400
onu taşımamızla aynı etkiye sahiptir.

124
00:08:05,400 --> 00:08:13,480
Ve bu etki yine, alttaki toplam sonucun hatanın konumunu ortaya koymasıdır.

125
00:08:13,480 --> 00:08:17,849
Bunun ne kadar zarif olduğunu göstermek için, daha önce bahsettiğim Python kodunun alıcı

126
00:08:17,849 --> 00:08:22,120
tarafındaki mantığın neredeyse tamamını yakalayacak bir satırını göstermeme izin verin.

127
00:08:22,120 --> 00:08:26,088
Veri bloğunu simüle etmek için 16 1 ve 0&#39;lardan oluşan rastgele bir

128
00:08:26,088 --> 00:08:29,560
dizi oluşturarak başlayacağız ve ona bitlerin adını vereceğim,

129
00:08:29,560 --> 00:08:33,694
ancak elbette pratikte bu, bir göndericiden aldığımız bir şey olacaktır ve

130
00:08:33,694 --> 00:08:38,600
bunun yerine rastgele olduğundan 5 eşlik bitiyle birlikte 11 veri biti taşıyor olacaktır.

131
00:08:38,600 --> 00:08:43,287
EnumerateBits fonksiyonunu çağırırsam, bu bitlerin her birini karşılık

132
00:08:43,287 --> 00:08:48,240
gelen bir indeksle eşleştirir, bu durumda 0&#39;dan 15&#39;e kadar çalışır.

133
00:08:48,240 --> 00:08:52,873
Yani eğer daha sonra tüm bu çiftleri, i&#39;ye benzeyen çiftleri kapsayan bir liste

134
00:08:52,873 --> 00:08:56,624
oluşturursak ve sonra sadece i değerini, sadece indeksi çıkarırsak,

135
00:08:56,624 --> 00:09:01,258
bu o kadar da heyecan verici değil, sadece 0&#39;dan 15&#39;e kadar olan indeksleri

136
00:09:01,258 --> 00:09:01,920
geri alırız.

137
00:09:01,920 --> 00:09:08,314
Ancak bunu yalnızca if biti yapma koşulunu eklersek, yani bu bit 0 değil de 1 ise,

138
00:09:08,314 --> 00:09:13,400
o zaman yalnızca karşılık gelen bitin açık olduğu konumları çeker.

139
00:09:13,400 --> 00:09:20,720
Bu durumda bu konumlar 0, 4, 6, 9 vb. gibi görünüyor.

140
00:09:20,720 --> 00:09:25,340
İstediğimiz şey, tüm bu konumları, açık olan bitlerin konumlarını

141
00:09:25,340 --> 00:09:29,960
bir araya toplamak ve ardından bunları XOR ile bir araya getirmek.

142
00:09:29,960 --> 00:09:33,960
Bunu Python&#39;da yapmak için önce birkaç yararlı işlevi içe aktarayım.

143
00:09:33,960 --> 00:09:36,523
Bu şekilde bu listede reduc()&#39;u çağırabilir

144
00:09:36,523 --> 00:09:39,140
ve azaltmak için XOR fonksiyonunu kullanabiliriz.

145
00:09:39,140 --> 00:09:44,840
Bu, temelde XOR&#39;ları da alarak liste boyunca yolunu yiyor.

146
00:09:44,840 --> 00:09:48,337
İsterseniz, herhangi bir yerden içe aktarmanıza

147
00:09:48,337 --> 00:09:52,200
gerek kalmadan bu XOR işlevini açıkça yazabilirsiniz.

148
00:09:52,200 --> 00:09:58,786
Yani şu anda öyle görünüyor ki eğer bunu 16 bitlik rastgele bloğumuz üzerinde yaparsak,

149
00:09:58,786 --> 00:10:02,080
ikili temsili 1001 olan 9 değerini döndürür.

150
00:10:02,080 --> 00:10:07,006
Bunu burada yapmayacağız, ancak gönderenin, dört eşlik bitini gerektiği gibi ayarlamak

151
00:10:07,006 --> 00:10:10,177
için bu ikili gösterimi kullandığı ve sonuçta bu bloğu,

152
00:10:10,177 --> 00:10:15,161
bu kod satırını bitlerin tam listesinde çalıştırmanın geri döndüğü bir duruma getirdiği

153
00:10:15,161 --> 00:10:17,200
bir fonksiyon yazabilirsiniz. bir 0.

154
00:10:17,200 --> 00:10:20,200
Bu iyi hazırlanmış bir blok olarak kabul edilir.

155
00:10:20,200 --> 00:10:24,065
İşin güzel yanı, bu listedeki bitlerden herhangi birini değiştirirsek,

156
00:10:24,065 --> 00:10:27,278
gürültüden kaynaklanan rastgele bir hatayı simüle edersek,

157
00:10:27,278 --> 00:10:30,600
o zaman aynı kod satırını çalıştırırsanız, o hatayı yazdırır.

158
00:10:30,600 --> 00:10:31,920
Çok hoş değil mi?

159
00:10:31,920 --> 00:10:37,496
Bu bloğu birdenbire alabilir, üzerinde bu tek satırı çalıştırabilirsiniz

160
00:10:37,496 --> 00:10:42,920
ve otomatik olarak bir hatanın konumunu veya eğer yoksa 0&#39;ı söyler.

161
00:10:42,920 --> 00:10:45,520
Ve burada 16 bedenin özel bir yanı yok.

162
00:10:45,520 --> 00:10:52,280
Örneğin 256 bitlik bir listeniz varsa aynı kod satırı işe yarar.

163
00:10:52,280 --> 00:10:56,719
Söylemeye gerek yok, 2 bitlik hataları tespit etmek için meta eşlik kontrolü

164
00:10:56,719 --> 00:11:00,640
yapmak gibi buraya yazılacak daha fazla kod var, ancak fikir şu ki,

165
00:11:00,640 --> 00:11:05,080
şemamızdaki temel mantığın neredeyse tamamı tek bir XOR azaltımına dayanıyor.

166
00:11:05,080 --> 00:11:10,109
Şimdi, ikili ve XOR&#39;lar ve genel olarak yazılım konusundaki rahatınıza bağlı olarak,

167
00:11:10,109 --> 00:11:14,686
bu bakış açısını ya biraz kafa karıştırıcı bulabilir ya da çok daha şık ve basit

168
00:11:14,686 --> 00:11:19,320
bulabilir ve neden en baştan bununla başlamadığımızı merak edebilirsiniz. -Gitmek.

169
00:11:19,320 --> 00:11:22,335
Kabaca konuşursak, çoklu eşlik kontrolü perspektifini,

170
00:11:22,335 --> 00:11:26,336
Hamming kodlarını donanıma doğrudan uygularken düşünmek daha kolaydır ve

171
00:11:26,336 --> 00:11:30,174
XOR perspektifini, bunu yazılımda yaparken, daha yüksek bir seviyeden

172
00:11:30,174 --> 00:11:31,380
düşünmek en kolayıdır.

173
00:11:31,380 --> 00:11:36,159
İlkini elle yapmak en kolay olanıdır ve bence tüm bunların altında yatan

174
00:11:36,159 --> 00:11:40,087
temel sezgiyi aşılamak açısından daha iyi bir iş çıkarıyor;

175
00:11:40,087 --> 00:11:45,717
yani tek bir hatayı bulmak için gereken bilgi, bloğun boyutunun günlüğüyle ilgilidir.

176
00:11:45,717 --> 00:11:51,020
, başka bir deyişle, blok boyutu iki katına çıktıkça her seferinde bir bit büyür.

177
00:11:51,020 --> 00:11:53,652
Buradaki ilgili gerçek şu ki, bu bilgi doğrudan ne

178
00:11:53,652 --> 00:11:56,440
kadar fazlalığa ihtiyacımız olduğuna karşılık geliyor.

179
00:11:56,440 --> 00:11:59,841
Bu aslında çoğu insanın, bir mesajı hatalara karşı dayanıklı hale

180
00:11:59,841 --> 00:12:03,861
getirmeyi ilk düşündüklerinde, düşünmeden verdikleri tepkiyle çelişen şeydir;

181
00:12:03,861 --> 00:12:07,520
burada genellikle mesajın tamamını kopyalamak akla gelen ilk içgüdüdür.

182
00:12:07,520 --> 00:12:10,939
Ve bu arada, bazen Hamming kodlarının sunulduğunu gördüğünüz,

183
00:12:10,939 --> 00:12:14,800
mesajı büyük bir matrisle çarptığınız tamamen farklı bir yol daha var.

184
00:12:14,800 --> 00:12:19,022
Bu biraz hoş çünkü onu daha geniş doğrusal kod ailesiyle ilişkilendiriyor,

185
00:12:19,022 --> 00:12:22,513
ancak bunun nereden geldiği veya nasıl ölçeklendiği konusunda

186
00:12:22,513 --> 00:12:25,160
neredeyse hiçbir sezgi vermediğini düşünüyorum.

187
00:12:25,160 --> 00:12:28,648
Ölçeklendirmeden bahsetmişken, blok boyutunu artırdıkça

188
00:12:28,648 --> 00:12:32,200
bu planın verimliliğinin de arttığını fark edebilirsiniz.

189
00:12:32,200 --> 00:12:37,522
Örneğin, 256 bit ile bu alanın yalnızca %3&#39;ünü yedeklilik için

190
00:12:37,522 --> 00:12:43,480
kullandığınızı ve bu noktadan sonra giderek daha iyi hale geldiğini gördük.

191
00:12:43,480 --> 00:12:49,040
Eşlik bitlerinin sayısı birer birer arttıkça blok boyutu da iki katına çıkar.

192
00:12:49,040 --> 00:12:53,982
Ve eğer bunu aşırıya götürürseniz, diyelim ki bir milyon bitlik bir bloğunuz olabilir,

193
00:12:53,982 --> 00:12:58,243
burada kelimenin tam anlamıyla eşlik kontrollerinizle 20 soru oynuyorsunuz

194
00:12:58,243 --> 00:13:00,800
ve bu blok yalnızca 21 eşlik biti kullanıyor.

195
00:13:00,800 --> 00:13:06,576
Milyonlarca parçaya bakıp tek bir hatayı bulmayı düşünmek için geri adım atarsanız,

196
00:13:06,576 --> 00:13:08,640
bu gerçekten çılgınca geliyor.

197
00:13:08,640 --> 00:13:13,354
Sorun, elbette, daha büyük bir blokla, bir veya iki bitten daha fazla hata görme

198
00:13:13,354 --> 00:13:18,360
olasılığının artması ve Hamming kodlarının bunun ötesinde hiçbir şeyi ele almamasıdır.

199
00:13:18,360 --> 00:13:22,153
Yani pratikte isteyeceğiniz şey, çok fazla bit dönme

200
00:13:22,153 --> 00:13:26,520
olasılığının çok yüksek olmaması için doğru boyutu bulmaktır.

201
00:13:26,520 --> 00:13:31,110
Ayrıca pratikte hatalar küçük patlamalar halinde ortaya çıkma eğilimindedir,

202
00:13:31,110 --> 00:13:35,880
bu da tek bir bloğu tamamen mahveder, bu nedenle bir dizi hatanın birçok farklı

203
00:13:35,880 --> 00:13:39,040
bloğa yayılmasına yardımcı olacak yaygın bir taktik,

204
00:13:39,040 --> 00:13:43,989
bu blokları bu şekilde birbirine geçirmeden önce bu şekilde birbirine geçirmektir.

205
00:13:43,989 --> 00:13:45,480
gönderilir veya saklanır.

206
00:13:45,480 --> 00:13:48,514
Öte yandan, bunların birçoğu, çok daha yaygın olarak kullanılan,

207
00:13:48,514 --> 00:13:52,203
patlama hatalarını özellikle iyi bir şekilde ele alan Reed-Solomon algoritması

208
00:13:52,203 --> 00:13:55,658
gibi daha modern kodlar tarafından tamamen tartışmalı hale getiriliyor ve

209
00:13:55,658 --> 00:13:59,580
blok başına daha fazla sayıda hataya karşı dayanıklı olacak şekilde ayarlanabiliyor.

210
00:13:59,580 --> 00:14:03,000
Ama bu başka bir zamanın konusu.

211
00:14:03,000 --> 00:14:06,603
Hamming, The Art of Doing Science and Engineering adlı kitabında bu kodu

212
00:14:06,603 --> 00:14:10,700
keşfetmesinin ne kadar dolambaçlı olduğunu son derece samimi bir şekilde anlatıyor.

213
00:14:10,700 --> 00:14:14,754
İlk önce, parçaları daha yüksek boyutlu bir kafesin parçalarına ayırmayı

214
00:14:14,754 --> 00:14:18,420
ve bunun gibi tuhaf şeyleri içeren her türlü farklı şemayı denedi.

215
00:14:18,420 --> 00:14:21,928
Bir hatanın konumunu ortaya koyacak şekilde eşlik kontrollerinin bir

216
00:14:21,928 --> 00:14:24,318
araya getirilmesinin mümkün olabileceği fikri,

217
00:14:24,318 --> 00:14:28,029
Hamming&#39;in aklına ancak bir sürü başka analizden sonra geri çekilip,

218
00:14:28,029 --> 00:14:31,487
tamam, yapabileceğim en verimli şeyin ne olduğunu sorduğunda geldi.

219
00:14:31,487 --> 00:14:32,860
bunun hakkında olabilir mi?

220
00:14:32,860 --> 00:14:37,069
Ayrıca, 1940&#39;larda bugün olduğundan çok daha az yaygın olan eşitlik

221
00:14:37,069 --> 00:14:42,040
kontrollerinin zaten aklında olmasının ne kadar önemli olduğu konusunda da samimiydi.

222
00:14:42,040 --> 00:14:45,810
Bu kitap boyunca neredeyse yarım düzine kez Louis Pasteur&#39;ün

223
00:14:45,810 --> 00:14:49,640
bir sözüne gönderme yapıyor; şans hazırlıklı bir zihinden yanadır.

224
00:14:49,640 --> 00:14:53,410
Zekice fikirler genellikle geriye dönüp bakıldığında aldatıcı derecede basit görünür,

225
00:14:53,410 --> 00:14:55,120
bu da onları küçümsemeyi kolaylaştırır.

226
00:14:55,120 --> 00:14:58,525
Şu anda samimi umudum, Hamming kodlarının veya en azından bu

227
00:14:58,525 --> 00:15:01,820
tür kodların olasılığının size neredeyse apaçık gelmesidir.

228
00:15:01,820 --> 00:15:04,592
Ancak bunların aslında bariz olduğunu düşünerek

229
00:15:04,592 --> 00:15:08,000
kendinizi kandırmamalısınız çünkü kesinlikle öyle değiller.

230
00:15:08,000 --> 00:15:11,631
Zekice fikirlerin aldatıcı derecede kolay görünmesinin bir nedeni de,

231
00:15:11,631 --> 00:15:14,744
yalnızca nihai sonucu görmemiz, dağınık olanı temizlememiz,

232
00:15:14,744 --> 00:15:19,051
tüm yanlış dönüşlerden hiç bahsetmememiz, bir sorunun başlangıcında keşfedilebilir

233
00:15:19,051 --> 00:15:23,201
olasılıklar alanının ne kadar geniş olduğunun altını çizmemizdir. çözme süreci,

234
00:15:23,201 --> 00:15:23,980
bunların hepsi.

235
00:15:23,980 --> 00:15:25,280
Ancak bu genel olarak doğrudur.

236
00:15:25,280 --> 00:15:28,239
Bazı özel icatlarda onları yeterince takdir etmememizin

237
00:15:28,239 --> 00:15:31,040
ikinci ve daha derin bir nedeni olduğunu düşünüyorum.

238
00:15:31,040 --> 00:15:35,161
Bilgiyi bitler cinsinden düşünmek, Claude Shannon&#39;ın bilgi teorisi

239
00:15:35,161 --> 00:15:39,400
üzerine ufuk açıcı makalesiyle ancak 1948&#39;de tam bir teoriye dönüştü.

240
00:15:39,400 --> 00:15:43,440
Bu aslında Hamming&#39;in algoritmasını geliştirmesiyle eşzamanlıydı.

241
00:15:43,440 --> 00:15:48,180
Bu, en azından teoride, bit kayması olasılığı ne kadar yüksek olursa olsun,

242
00:15:48,180 --> 00:15:53,296
bir anlamda etkili hata düzeltmenin her zaman mümkün olduğunu gösteren aynı temel

243
00:15:53,296 --> 00:15:53,920
makaleydi.

244
00:15:53,920 --> 00:15:57,870
Bu arada Shannon ve Hamming, çok farklı şeyler üzerinde çalışmalarına rağmen Bell

245
00:15:57,870 --> 00:16:01,870
Laboratuvarları&#39;nda bir ofisi paylaşıyorlardı ki bu da burada pek rastlantısal

246
00:16:01,870 --> 00:16:02,400
görünmüyor.

247
00:16:02,400 --> 00:16:05,978
Birkaç on yıl ileri saralım ve bu günlerde çoğumuz küçük parçalar

248
00:16:05,978 --> 00:16:09,230
ve bilgiler üzerine düşünmeye o kadar dalmış durumdayız ki,

249
00:16:09,230 --> 00:16:13,080
bu düşünce tarzının ne kadar farklı olduğunu gözden kaçırmak çok kolay.

250
00:16:13,080 --> 00:16:15,691
İroniktir ki, gelecek neslin düşünme biçimini en derinden şekillendiren fikirler,

251
00:16:15,691 --> 00:16:17,920
gelecek nesile gerçekte olduğundan daha basit görünmeye yol açacaktır.

