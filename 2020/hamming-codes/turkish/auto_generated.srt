1
00:00:00,000 --> 00:00:03,120
Buradaki herkesin 1. bölümden geldiğini varsayıyorum.

2
00:00:03,120 --> 00:00:07,715
Bitlerin çoğunun anlamlı bir mesaj taşıdığı, diğer birkaç parçanın ise bir tür artıklık

3
00:00:07,715 --> 00:00:11,736
işlevi gördüğü bir veri bloğu oluşturmanın bir yolu olan Hamming kodlarından

4
00:00:11,736 --> 00:00:16,332
bahsediyorduk; herhangi bir bit ters çevrildiğinde ya bir mesaj Bit veya artıklık biti,

5
00:00:16,332 --> 00:00:20,875
bu bloktaki herhangi bir şeyde, alıcı bir hata olduğunu ve bunun nasıl düzeltileceğini

6
00:00:20,875 --> 00:00:21,920
tanımlayabilecektir.

7
00:00:21,920 --> 00:00:25,826
Orada sunulan temel fikir, hataya giden yolda ikili arama

8
00:00:25,826 --> 00:00:29,800
yapmak için çoklu eşlik kontrolünün nasıl kullanılacağıydı.

9
00:00:29,800 --> 00:00:32,507
Bu videoda amaç, Hamming kodlarının mümkün olduğunca

10
00:00:32,507 --> 00:00:35,420
uygulamalı ve yeniden keşfedilebilir olmasını sağlamaktı.

11
00:00:35,420 --> 00:00:39,796
Ancak bunu yazılım veya donanımda gerçekten uygulamayı düşünmeye başladığınızda, bu

12
00:00:39,796 --> 00:00:44,120
çerçeveleme aslında bu kodların gerçekte ne kadar zarif olduğunun altını çizebilir.

13
00:00:44,120 --> 00:00:47,319
Tüm olası hata konumlarını takip eden ve her kontrolde bu

14
00:00:47,319 --> 00:00:50,408
grubu yarıya indiren bir algoritma yazmanız gerektiğini

15
00:00:50,408 --> 00:00:54,160
düşünebilirsiniz, ancak aslında bu bundan çok ama çok daha basittir.

16
00:00:54,160 --> 00:00:59,450
Son videoda yaptığımız dört eşlik kontrolünün yanıtlarını evet ve hayır yerine 1&#39;ler

17
00:00:59,450 --> 00:01:04,800
ve 0&#39;lar olarak okursanız, bu tam anlamıyla hatanın ikili dosyadaki konumunu belirtir.

18
00:01:04,800 --> 00:01:09,231
Örneğin, ikili sistemde 7 sayısı 0111&#39;e benzer,

19
00:01:09,231 --> 00:01:12,640
aslında 4 artı 2 artı 1 olduğunu söyler.

20
00:01:12,640 --> 00:01:17,398
Ve 7. pozisyonun nerede olduğuna dikkat edin, bu durum eşitlik gruplarımızın

21
00:01:17,398 --> 00:01:22,280
birincisini, ikincisini ve üçüncüsünü etkiliyor, ancak sonuncusunu etkilemiyor.

22
00:01:22,280 --> 00:01:25,259
Yani bu dört kontrolün sonuçlarını aşağıdan yukarıya

23
00:01:25,259 --> 00:01:28,520
doğru okumak gerçekten de hatanın konumunu ortaya koyuyor.

24
00:01:28,520 --> 00:01:33,153
Örnek 7&#39;de özel bir şey yok, bu genel olarak işe yarıyor ve bu, tüm şemanın

25
00:01:33,153 --> 00:01:37,440
donanıma uygulanmasının mantığını şaşırtıcı derecede basit hale getiriyor.

26
00:01:37,440 --> 00:01:41,974
Şimdi bu sihrin neden oluştuğunu görmek istiyorsanız, pozisyonlarımız

27
00:01:41,974 --> 00:01:46,379
için bu 16 indeks etiketini alın, ancak bunları 10 tabanında yazmak

28
00:01:46,379 --> 00:01:50,720
yerine, hepsini 0000&#39;den 1111&#39;e kadar ikili olarak yazalım.

29
00:01:50,720 --> 00:01:54,641
Bu ikili etiketleri kutularına geri koyarken, bunların gerçekte

30
00:01:54,641 --> 00:01:58,440
gönderilen verilerden farklı olduklarını vurgulamam gerekiyor.

31
00:01:58,440 --> 00:02:01,125
Bunlar sizin ve benim dört eşitlik grubunun nereden geldiğini

32
00:02:01,125 --> 00:02:04,200
anlamamıza yardımcı olacak kavramsal bir etiketten başka bir şey değil.

33
00:02:04,200 --> 00:02:08,575
Baktığımız her şeyin ikili olarak tanımlanmasının zarafeti, belki de baktığımız her

34
00:02:08,575 --> 00:02:13,160
şeyin ikili olarak tanımlanmasının yarattığı kafa karışıklığı nedeniyle gölgede kalıyor.

35
00:02:13,160 --> 00:02:15,040
Yine de buna değer.

36
00:02:15,040 --> 00:02:19,860
Dikkatinizi tüm bu etiketlerin sadece son kısmına odaklayın

37
00:02:19,860 --> 00:02:24,280
ve ardından bu son bitin 1 olduğu konumları vurgulayın.

38
00:02:24,280 --> 00:02:29,783
Elde ettiğimiz şey, dört eşlik grubumuzun ilkidir; bu, ilk kontrolü şu soruyla

39
00:02:29,783 --> 00:02:36,053
yorumlayabileceğiniz anlamına gelir: hey, eğer bir hata varsa, bu hatanın konumundaki son

40
00:02:36,053 --> 00:02:36,680
bit 1 mi?

41
00:02:36,680 --> 00:02:41,895
Benzer şekilde, ikinciden sonuncuya odaklanırsanız ve bunun 1 olduğu tüm

42
00:02:41,895 --> 00:02:47,040
konumları vurgularsanız, şemamızdan ikinci eşlik grubunu elde edersiniz.

43
00:02:47,040 --> 00:02:51,417
Başka bir deyişle, bu ikinci kontrol şunu soruyor: Hey, ben

44
00:02:51,417 --> 00:02:56,160
yine, eğer bir hata varsa, bu konumun ikinciden sondan biti 1 mi?

45
00:02:56,160 --> 00:02:57,160
Ve benzeri.

46
00:02:57,160 --> 00:03:03,597
Üçüncü eşlik kontrolü, üçüncü bitten son bitine kadar açık olan her konumu

47
00:03:03,597 --> 00:03:10,120
kapsar ve sonuncusu, en yüksek dereceli biti 1 olan son sekiz konumu kapsar.

48
00:03:10,120 --> 00:03:15,231
Daha önce yaptığımız her şey bu dört soruyu yanıtlamakla aynıydı,

49
00:03:15,231 --> 00:03:19,800
bu da ikili sistemde bir konumun hecelenmesiyle aynı şeydi.

50
00:03:19,800 --> 00:03:22,080
Umarım bu iki şeyi daha açık hale getirir.

51
00:03:22,080 --> 00:03:24,831
Birincisi, ikinin daha büyük kuvvetleri olan blok boyutlarına

52
00:03:24,831 --> 00:03:27,140
sistematik olarak nasıl genelleştirme yapılacağıdır.

53
00:03:27,140 --> 00:03:30,973
Her bir konumu tanımlamak daha fazla bit gerektiriyorsa, örneğin 64

54
00:03:30,973 --> 00:03:34,693
noktayı tanımlamak için altı bit gerekiyorsa, o zaman bu bitlerin

55
00:03:34,693 --> 00:03:38,640
her biri size kontrol etmemiz gereken eşlik gruplarından birini verir.

56
00:03:38,640 --> 00:03:41,020
Matt Parker&#39;la yaptığım satranç tahtası bulmacasını

57
00:03:41,020 --> 00:03:43,400
izleyenleriniz tüm bunları fazlasıyla tanıdık bulabilir.

58
00:03:43,400 --> 00:03:46,292
Bu aynı temel mantıktır ancak farklı bir problemi

59
00:03:46,292 --> 00:03:49,880
çözmektedir ve 64 karelik bir satranç tahtasına uygulanmıştır.

60
00:03:49,880 --> 00:03:54,040
Bunun açıklığa kavuşturacağını umduğum ikinci şey, eşlik bitlerimizin

61
00:03:54,040 --> 00:03:58,320
neden ikinin kuvvetleri olan konumlarda olduğudur, örneğin 1, 2, 4 ve 8.

62
00:03:58,320 --> 00:04:03,640
Bunlar, ikili gösterimi yalnızca tek bir bitin açık olduğu konumlardır.

63
00:04:03,640 --> 00:04:08,055
Bunun anlamı, bu eşlik bitlerinin her birinin, dört

64
00:04:08,055 --> 00:04:12,640
eşlik grubundan yalnızca birinin içinde yer almasıdır.

65
00:04:12,640 --> 00:04:19,084
Bunu daha büyük örneklerde de görebilirsiniz; ne kadar büyürseniz

66
00:04:19,084 --> 00:04:25,920
büyüsün, her eşlik biti rahatlıkla gruplardan yalnızca birine dokunur.

67
00:04:25,920 --> 00:04:30,256
Zamanımızın büyük bir kısmını üzerinde yoğunlaştığımız bu eşlik kontrollerinin, ikili

68
00:04:30,256 --> 00:04:34,743
sistemde bir hatanın konumunu açıklamanın akıllıca bir yolundan başka bir şey olmadığını

69
00:04:34,743 --> 00:04:39,029
anladığınızda, hamming hakkında düşünmenin farklı bir yolu ile bağlantı kurabiliriz.

70
00:04:39,029 --> 00:04:43,567
Muhtemelen çok daha basit ve daha zarif olan ve temelde tek bir kod satırıyla yazılabilen

71
00:04:43,567 --> 00:04:43,920
kodlar.

72
00:04:43,920 --> 00:04:46,200
XOR fonksiyonuna dayanmaktadır.

73
00:04:46,200 --> 00:04:50,960
Bilmeyenler için XOR, özel veya anlamına gelir.

74
00:04:50,960 --> 00:04:55,422
İki bitin XOR&#39;unu aldığınızda, bu bitlerden herhangi biri açıksa 1

75
00:04:55,422 --> 00:05:00,200
değerini döndürür, ancak her ikisi de açık veya kapalıysa bu sonuç değişmez.

76
00:05:00,200 --> 00:05:03,760
Farklı bir ifadeyle bu iki bitin paritesidir.

77
00:05:03,760 --> 00:05:07,840
Bir matematikçi olarak bunu toplama modu 2 olarak düşünmeyi tercih ederim.

78
00:05:07,840 --> 00:05:10,736
Ayrıca genellikle iki farklı bit dizisinin XOR&#39;undan

79
00:05:10,736 --> 00:05:14,040
bahsederiz, bu da temel olarak bu bileşeni bileşen bazında yapar.

80
00:05:14,040 --> 00:05:16,280
Toplama gibi ama asla taşımadığınız yer.

81
00:05:16,280 --> 00:05:19,985
Yine, matematiğe daha yatkın olanlar bunu iki vektörün eklenmesi

82
00:05:19,985 --> 00:05:23,520
ve mod 2&#39;nin azaltılması olarak düşünmeyi tercih edebilir.

83
00:05:23,520 --> 00:05:28,926
Şu anda Python&#39;u açarsanız ve iki tamsayı arasında düzeltme işareti işlemini

84
00:05:28,926 --> 00:05:34,665
uygularsanız, yaptığı şey budur, ancak bu sayıların başlık altındaki bit temsillerine

85
00:05:34,665 --> 00:05:35,400
yöneliktir.

86
00:05:35,400 --> 00:05:41,041
Sizin ve benim için kilit nokta, birçok farklı bit dizisinin XOR&#39;unu

87
00:05:41,041 --> 00:05:46,142
almanın, sütunlarda olduğu gibi bir grup ayrı grubun parodilerini

88
00:05:46,142 --> 00:05:51,320
tek bir hamlede etkili bir şekilde hesaplamanın bir yolu olmasıdır.

89
00:05:51,320 --> 00:05:55,385
Bu bize, Hamming kod algoritmamızın çoklu eşlik kontrollerinin tek bir

90
00:05:55,385 --> 00:05:59,680
işlemde paketlenmesi hakkında düşünmemiz için oldukça şık bir yol sağlıyor.

91
00:05:59,680 --> 00:06:02,800
Her ne kadar ilk bakışta çok farklı görünse de.

92
00:06:02,800 --> 00:06:08,388
Daha önce yaptığımız gibi, ikili olarak 16 konumu özel olarak yazın

93
00:06:08,388 --> 00:06:13,894
ve şimdi mesaj bitinin 1&#39;e açık olduğu konumları vurgulayın ve

94
00:06:13,894 --> 00:06:19,400
ardından bu konumları büyük bir sütunda toplayın ve XOR&#39;u alın.

95
00:06:19,400 --> 00:06:23,681
Sonuç olarak altta bulunan 4 bitin, bildiğimiz ve sevdiğimiz 4

96
00:06:23,681 --> 00:06:28,098
eşlik kontrolüyle aynı olduğunu muhtemelen tahmin edebilirsiniz,

97
00:06:28,098 --> 00:06:32,720
ancak bunun nedenini tam olarak düşünmek için bir dakikanızı ayırın.

98
00:06:32,720 --> 00:06:37,173
Örneğin bu son sütun, son biti 1 olan tüm pozisyonları sayıyor, ancak biz

99
00:06:37,173 --> 00:06:41,386
zaten yalnızca vurgulanan konumlarla sınırlıyız, dolayısıyla kaç tane

100
00:06:41,386 --> 00:06:45,960
vurgulanan konumun ilk eşlik grubundan geldiğini etkili bir şekilde sayıyor.

101
00:06:45,960 --> 00:06:48,520
bu mantıklı mı?

102
00:06:48,520 --> 00:06:55,058
Benzer şekilde, bir sonraki sütun, ikinci eşlik grubunda kaç konumun bulunduğunu,

103
00:06:55,058 --> 00:07:00,640
ikinciden sondan biti 1 olan ve hangilerinin vurgulandığını vb. sayar.

104
00:07:00,640 --> 00:07:07,640
Aslında bu, yapmakta olduğumuz şeye ilişkin perspektifte küçük bir değişiklik.

105
00:07:07,640 --> 00:07:10,000
Yani buradan nereye gideceğini biliyorsun.

106
00:07:10,000 --> 00:07:14,820
Gönderen, toplamın 0000 olmasını sağlamak için bazı

107
00:07:14,820 --> 00:07:19,640
özel eşlik bitlerinin değiştirilmesinden sorumludur.

108
00:07:19,640 --> 00:07:22,633
Şimdi bu şekilde elde ettiğimizde, bu bize, alttaki sonuçta

109
00:07:22,633 --> 00:07:25,626
ortaya çıkan dört bitin neden doğrudan bir hatanın konumunu

110
00:07:25,626 --> 00:07:28,720
gösterdiğini düşünmemiz için gerçekten güzel bir yol sağlıyor.

111
00:07:28,720 --> 00:07:32,720
Diyelim ki bu bloktaki bir bit 0&#39;dan 1&#39;e değiştirildi.

112
00:07:32,720 --> 00:07:38,760
Bunun anlamı, o bitin konumu artık toplam XOR&#39;a dahil edilecek, bu da

113
00:07:38,760 --> 00:07:44,800
toplamı 0&#39;dan yeni eklenen değere, yani hatanın konumuna dönüştürecek.

114
00:07:44,800 --> 00:07:47,300
Biraz daha az açık bir şekilde, 1&#39;i 0&#39;a

115
00:07:47,300 --> 00:07:49,800
değiştiren bir hata varsa aynı durum geçerlidir.

116
00:07:49,800 --> 00:07:54,435
Görüyorsunuz, eğer bir bit dizisini iki kez toplarsanız, bu orada

117
00:07:54,435 --> 00:07:59,000
hiç olmamasıyla aynı şeydir, çünkü bu dünyada 1 artı 1 eşittir 0.

118
00:07:59,000 --> 00:08:02,268
Yani bu pozisyonun bir kopyasını toplam toplama

119
00:08:02,268 --> 00:08:05,400
eklemek, onu taşımamızla aynı etkiye sahiptir.

120
00:08:05,400 --> 00:08:13,480
Ve bu etki yine, alttaki toplam sonucun hatanın konumunu ortaya koymasıdır.

121
00:08:13,480 --> 00:08:17,849
Bunun ne kadar zarif olduğunu göstermek için, daha önce bahsettiğim Python kodunun alıcı

122
00:08:17,849 --> 00:08:22,120
tarafındaki mantığın neredeyse tamamını yakalayacak bir satırını göstermeme izin verin.

123
00:08:22,120 --> 00:08:26,088
Veri bloğunu simüle etmek için 16 1 ve 0&#39;lardan oluşan rastgele bir

124
00:08:26,088 --> 00:08:30,332
dizi oluşturarak başlayacağız ve ona bitlerin adını vereceğim, ancak elbette

125
00:08:30,332 --> 00:08:34,411
pratikte bu, bir göndericiden aldığımız bir şey olacaktır ve bunun yerine

126
00:08:34,411 --> 00:08:38,600
rastgele olduğundan 5 eşlik bitiyle birlikte 11 veri biti taşıyor olacaktır.

127
00:08:38,600 --> 00:08:43,287
EnumerateBits fonksiyonunu çağırırsam, bu bitlerin her birini karşılık

128
00:08:43,287 --> 00:08:48,240
gelen bir indeksle eşleştirir, bu durumda 0&#39;dan 15&#39;e kadar çalışır.

129
00:08:48,240 --> 00:08:52,873
Yani eğer daha sonra tüm bu çiftleri, i&#39;ye benzeyen çiftleri kapsayan bir liste

130
00:08:52,873 --> 00:08:57,396
oluşturursak ve sonra sadece i değerini, sadece indeksi çıkarırsak, bu o kadar da

131
00:08:57,396 --> 00:09:01,920
heyecan verici değil, sadece 0&#39;dan 15&#39;e kadar olan indeksleri geri alırız.

132
00:09:01,920 --> 00:09:07,544
Ancak bunu yalnızca if biti yapma koşulunu eklersek, yani bu bit 0 değil

133
00:09:07,544 --> 00:09:13,400
de 1 ise, o zaman yalnızca karşılık gelen bitin açık olduğu konumları çeker.

134
00:09:13,400 --> 00:09:20,720
Bu durumda bu konumlar 0, 4, 6, 9 vb. gibi görünüyor.

135
00:09:20,720 --> 00:09:25,340
İstediğimiz şey, tüm bu konumları, açık olan bitlerin konumlarını

136
00:09:25,340 --> 00:09:29,960
bir araya toplamak ve ardından bunları XOR ile bir araya getirmek.

137
00:09:29,960 --> 00:09:33,960
Bunu Python&#39;da yapmak için önce birkaç yararlı işlevi içe aktarayım.

138
00:09:33,960 --> 00:09:36,523
Bu şekilde bu listede reduc()&#39;u çağırabilir

139
00:09:36,523 --> 00:09:39,140
ve azaltmak için XOR fonksiyonunu kullanabiliriz.

140
00:09:39,140 --> 00:09:44,840
Bu, temelde XOR&#39;ları da alarak liste boyunca yolunu yiyor.

141
00:09:44,840 --> 00:09:48,337
İsterseniz, herhangi bir yerden içe aktarmanıza

142
00:09:48,337 --> 00:09:52,200
gerek kalmadan bu XOR işlevini açıkça yazabilirsiniz.

143
00:09:52,200 --> 00:09:57,364
Yani şu anda öyle görünüyor ki eğer bunu 16 bitlik rastgele bloğumuz

144
00:09:57,364 --> 00:10:02,080
üzerinde yaparsak, ikili temsili 1001 olan 9 değerini döndürür.

145
00:10:02,080 --> 00:10:07,006
Bunu burada yapmayacağız, ancak gönderenin, dört eşlik bitini gerektiği gibi ayarlamak

146
00:10:07,006 --> 00:10:11,820
için bu ikili gösterimi kullandığı ve sonuçta bu bloğu, bu kod satırını bitlerin tam

147
00:10:11,820 --> 00:10:16,860
listesinde çalıştırmanın geri döndüğü bir duruma getirdiği bir fonksiyon yazabilirsiniz.

148
00:10:16,860 --> 00:10:17,200
bir 0.

149
00:10:17,200 --> 00:10:20,200
Bu iyi hazırlanmış bir blok olarak kabul edilir.

150
00:10:20,200 --> 00:10:23,249
İşin güzel yanı, bu listedeki bitlerden herhangi birini

151
00:10:23,249 --> 00:10:26,788
değiştirirsek, gürültüden kaynaklanan rastgele bir hatayı simüle

152
00:10:26,788 --> 00:10:30,600
edersek, o zaman aynı kod satırını çalıştırırsanız, o hatayı yazdırır.

153
00:10:30,600 --> 00:10:31,920
Çok hoş değil mi?

154
00:10:31,920 --> 00:10:37,496
Bu bloğu birdenbire alabilir, üzerinde bu tek satırı çalıştırabilirsiniz

155
00:10:37,496 --> 00:10:42,920
ve otomatik olarak bir hatanın konumunu veya eğer yoksa 0&#39;ı söyler.

156
00:10:42,920 --> 00:10:45,520
Ve burada 16 bedenin özel bir yanı yok.

157
00:10:45,520 --> 00:10:52,280
Örneğin 256 bitlik bir listeniz varsa aynı kod satırı işe yarar.

158
00:10:52,280 --> 00:10:56,719
Söylemeye gerek yok, 2 bitlik hataları tespit etmek için meta eşlik kontrolü

159
00:10:56,719 --> 00:11:00,640
yapmak gibi buraya yazılacak daha fazla kod var, ancak fikir şu ki,

160
00:11:00,640 --> 00:11:05,080
şemamızdaki temel mantığın neredeyse tamamı tek bir XOR azaltımına dayanıyor.

161
00:11:05,080 --> 00:11:09,657
Şimdi, ikili ve XOR&#39;lar ve genel olarak yazılım konusundaki rahatınıza bağlı

162
00:11:09,657 --> 00:11:14,347
olarak, bu bakış açısını ya biraz kafa karıştırıcı bulabilir ya da çok daha şık ve

163
00:11:14,347 --> 00:11:19,320
basit bulabilir ve neden en baştan bununla başlamadığımızı merak edebilirsiniz. -Gitmek.

164
00:11:19,320 --> 00:11:23,321
Kabaca konuşursak, çoklu eşlik kontrolü perspektifini, Hamming kodlarını

165
00:11:23,321 --> 00:11:27,378
donanıma doğrudan uygularken düşünmek daha kolaydır ve XOR perspektifini,

166
00:11:27,378 --> 00:11:31,380
bunu yazılımda yaparken, daha yüksek bir seviyeden düşünmek en kolayıdır.

167
00:11:31,380 --> 00:11:36,159
İlkini elle yapmak en kolay olanıdır ve bence tüm bunların altında yatan

168
00:11:36,159 --> 00:11:40,938
temel sezgiyi aşılamak açısından daha iyi bir iş çıkarıyor; yani tek bir

169
00:11:40,938 --> 00:11:45,848
hatayı bulmak için gereken bilgi, bloğun boyutunun günlüğüyle ilgilidir. ,

170
00:11:45,848 --> 00:11:51,020
başka bir deyişle, blok boyutu iki katına çıktıkça her seferinde bir bit büyür.

171
00:11:51,020 --> 00:11:53,652
Buradaki ilgili gerçek şu ki, bu bilgi doğrudan ne

172
00:11:53,652 --> 00:11:56,440
kadar fazlalığa ihtiyacımız olduğuna karşılık geliyor.

173
00:11:56,440 --> 00:11:59,841
Bu aslında çoğu insanın, bir mesajı hatalara karşı dayanıklı hale

174
00:11:59,841 --> 00:12:03,448
getirmeyi ilk düşündüklerinde, düşünmeden verdikleri tepkiyle çelişen

175
00:12:03,448 --> 00:12:07,520
şeydir; burada genellikle mesajın tamamını kopyalamak akla gelen ilk içgüdüdür.

176
00:12:07,520 --> 00:12:11,325
Ve bu arada, bazen Hamming kodlarının sunulduğunu gördüğünüz, mesajı

177
00:12:11,325 --> 00:12:14,800
büyük bir matrisle çarptığınız tamamen farklı bir yol daha var.

178
00:12:14,800 --> 00:12:18,009
Bu biraz hoş çünkü onu daha geniş doğrusal kod ailesiyle

179
00:12:18,009 --> 00:12:21,218
ilişkilendiriyor, ancak bunun nereden geldiği veya nasıl

180
00:12:21,218 --> 00:12:25,160
ölçeklendiği konusunda neredeyse hiçbir sezgi vermediğini düşünüyorum.

181
00:12:25,160 --> 00:12:28,648
Ölçeklendirmeden bahsetmişken, blok boyutunu artırdıkça

182
00:12:28,648 --> 00:12:32,200
bu planın verimliliğinin de arttığını fark edebilirsiniz.

183
00:12:32,200 --> 00:12:37,522
Örneğin, 256 bit ile bu alanın yalnızca %3&#39;ünü yedeklilik için

184
00:12:37,522 --> 00:12:43,480
kullandığınızı ve bu noktadan sonra giderek daha iyi hale geldiğini gördük.

185
00:12:43,480 --> 00:12:49,040
Eşlik bitlerinin sayısı birer birer arttıkça blok boyutu da iki katına çıkar.

186
00:12:49,040 --> 00:12:52,903
Ve eğer bunu aşırıya götürürseniz, diyelim ki bir milyon bitlik bir

187
00:12:52,903 --> 00:12:57,050
bloğunuz olabilir, burada kelimenin tam anlamıyla eşlik kontrollerinizle

188
00:12:57,050 --> 00:13:00,800
20 soru oynuyorsunuz ve bu blok yalnızca 21 eşlik biti kullanıyor.

189
00:13:00,800 --> 00:13:04,788
Milyonlarca parçaya bakıp tek bir hatayı bulmayı düşünmek

190
00:13:04,788 --> 00:13:08,640
için geri adım atarsanız, bu gerçekten çılgınca geliyor.

191
00:13:08,640 --> 00:13:13,354
Sorun, elbette, daha büyük bir blokla, bir veya iki bitten daha fazla hata görme

192
00:13:13,354 --> 00:13:18,360
olasılığının artması ve Hamming kodlarının bunun ötesinde hiçbir şeyi ele almamasıdır.

193
00:13:18,360 --> 00:13:22,153
Yani pratikte isteyeceğiniz şey, çok fazla bit dönme

194
00:13:22,153 --> 00:13:26,520
olasılığının çok yüksek olmaması için doğru boyutu bulmaktır.

195
00:13:26,520 --> 00:13:31,289
Ayrıca pratikte hatalar küçük patlamalar halinde ortaya çıkma eğilimindedir, bu

196
00:13:31,289 --> 00:13:35,880
da tek bir bloğu tamamen mahveder, bu nedenle bir dizi hatanın birçok farklı

197
00:13:35,880 --> 00:13:40,412
bloğa yayılmasına yardımcı olacak yaygın bir taktik, bu blokları bu şekilde

198
00:13:40,412 --> 00:13:45,480
birbirine geçirmeden önce bu şekilde birbirine geçirmektir. gönderilir veya saklanır.

199
00:13:45,480 --> 00:13:48,888
Öte yandan, bunların birçoğu, çok daha yaygın olarak kullanılan, patlama

200
00:13:48,888 --> 00:13:52,436
hatalarını özellikle iyi bir şekilde ele alan Reed-Solomon algoritması gibi

201
00:13:52,436 --> 00:13:55,891
daha modern kodlar tarafından tamamen tartışmalı hale getiriliyor ve blok

202
00:13:55,891 --> 00:13:59,580
başına daha fazla sayıda hataya karşı dayanıklı olacak şekilde ayarlanabiliyor.

203
00:13:59,580 --> 00:14:03,000
Ama bu başka bir zamanın konusu.

204
00:14:03,000 --> 00:14:06,603
Hamming, The Art of Doing Science and Engineering adlı kitabında bu kodu

205
00:14:06,603 --> 00:14:10,700
keşfetmesinin ne kadar dolambaçlı olduğunu son derece samimi bir şekilde anlatıyor.

206
00:14:10,700 --> 00:14:14,754
İlk önce, parçaları daha yüksek boyutlu bir kafesin parçalarına ayırmayı

207
00:14:14,754 --> 00:14:18,420
ve bunun gibi tuhaf şeyleri içeren her türlü farklı şemayı denedi.

208
00:14:18,420 --> 00:14:21,928
Bir hatanın konumunu ortaya koyacak şekilde eşlik kontrollerinin bir

209
00:14:21,928 --> 00:14:25,436
araya getirilmesinin mümkün olabileceği fikri, Hamming&#39;in aklına

210
00:14:25,436 --> 00:14:29,097
ancak bir sürü başka analizden sonra geri çekilip, tamam, yapabileceğim

211
00:14:29,097 --> 00:14:32,860
en verimli şeyin ne olduğunu sorduğunda geldi. bunun hakkında olabilir mi?

212
00:14:32,860 --> 00:14:37,069
Ayrıca, 1940&#39;larda bugün olduğundan çok daha az yaygın olan eşitlik

213
00:14:37,069 --> 00:14:42,040
kontrollerinin zaten aklında olmasının ne kadar önemli olduğu konusunda da samimiydi.

214
00:14:42,040 --> 00:14:45,810
Bu kitap boyunca neredeyse yarım düzine kez Louis Pasteur&#39;ün

215
00:14:45,810 --> 00:14:49,640
bir sözüne gönderme yapıyor; şans hazırlıklı bir zihinden yanadır.

216
00:14:49,640 --> 00:14:52,358
Zekice fikirler genellikle geriye dönüp bakıldığında aldatıcı

217
00:14:52,358 --> 00:14:55,120
derecede basit görünür, bu da onları küçümsemeyi kolaylaştırır.

218
00:14:55,120 --> 00:14:58,525
Şu anda samimi umudum, Hamming kodlarının veya en azından bu

219
00:14:58,525 --> 00:15:01,820
tür kodların olasılığının size neredeyse apaçık gelmesidir.

220
00:15:01,820 --> 00:15:04,592
Ancak bunların aslında bariz olduğunu düşünerek

221
00:15:04,592 --> 00:15:08,000
kendinizi kandırmamalısınız çünkü kesinlikle öyle değiller.

222
00:15:08,000 --> 00:15:12,098
Zekice fikirlerin aldatıcı derecede kolay görünmesinin bir nedeni de, yalnızca

223
00:15:12,098 --> 00:15:16,145
nihai sonucu görmemiz, dağınık olanı temizlememiz, tüm yanlış dönüşlerden hiç

224
00:15:16,145 --> 00:15:20,140
bahsetmememiz, bir sorunun başlangıcında keşfedilebilir olasılıklar alanının

225
00:15:20,140 --> 00:15:23,980
ne kadar geniş olduğunun altını çizmemizdir. çözme süreci, bunların hepsi.

226
00:15:23,980 --> 00:15:25,280
Ancak bu genel olarak doğrudur.

227
00:15:25,280 --> 00:15:28,239
Bazı özel icatlarda onları yeterince takdir etmememizin

228
00:15:28,239 --> 00:15:31,040
ikinci ve daha derin bir nedeni olduğunu düşünüyorum.

229
00:15:31,040 --> 00:15:35,161
Bilgiyi bitler cinsinden düşünmek, Claude Shannon&#39;ın bilgi teorisi

230
00:15:35,161 --> 00:15:39,400
üzerine ufuk açıcı makalesiyle ancak 1948&#39;de tam bir teoriye dönüştü.

231
00:15:39,400 --> 00:15:43,440
Bu aslında Hamming&#39;in algoritmasını geliştirmesiyle eşzamanlıydı.

232
00:15:43,440 --> 00:15:48,430
Bu, en azından teoride, bit kayması olasılığı ne kadar yüksek olursa olsun, bir

233
00:15:48,430 --> 00:15:53,920
anlamda etkili hata düzeltmenin her zaman mümkün olduğunu gösteren aynı temel makaleydi.

234
00:15:53,920 --> 00:15:57,870
Bu arada Shannon ve Hamming, çok farklı şeyler üzerinde çalışmalarına rağmen Bell

235
00:15:57,870 --> 00:16:01,870
Laboratuvarları&#39;nda bir ofisi paylaşıyorlardı ki bu da burada pek rastlantısal

236
00:16:01,870 --> 00:16:02,400
görünmüyor.

237
00:16:02,400 --> 00:16:05,978
Birkaç on yıl ileri saralım ve bu günlerde çoğumuz küçük parçalar

238
00:16:05,978 --> 00:16:09,393
ve bilgiler üzerine düşünmeye o kadar dalmış durumdayız ki, bu

239
00:16:09,393 --> 00:16:13,080
düşünce tarzının ne kadar farklı olduğunu gözden kaçırmak çok kolay.

240
00:16:13,080 --> 00:16:15,372
İroniktir ki, gelecek neslin düşünme biçimini en derinden şekillendiren

241
00:16:15,372 --> 00:16:17,920
fikirler, gelecek nesile gerçekte olduğundan daha basit görünmeye yol açacaktır.

