[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing?",
  "model": "nmt",
  "translatedText": "Bir CD'yi veya DVD'yi çizerken, içinde sakladığı şeyi oynatmanın nasıl mümkün olduğunu hiç merak ettiniz mi?",
  "time_range": [
   3.62,
   10.1
  ]
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors.",
  "model": "nmt",
  "translatedText": "Çizik gerçekten diskteki 1'leri ve 0'ları etkiler, bu nedenle depolanan verilerden farklı verileri okur, ancak gerçekten çizilmediği sürece okuduğu bitlerin kodu, üzerine kodlanmış olanla tam olarak aynı dosyaya dönüştürülür. tüm bu hatalara rağmen bit bit kopya.",
  "time_range": [
   10.9,
   27.44
  ]
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors.",
  "model": "nmt",
  "translatedText": "Verileri depolamamıza ve aynı derecede önemlisi, hatalara karşı dirençli bir şekilde veri iletmemize olanak tanıyan bir sürü matematiksel zeka var.",
  "time_range": [
   27.44,
   36.2
  ]
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this.",
  "model": "nmt",
  "translatedText": "Tamam, aslında bunu yapmanın bir yolunu bulmak o kadar da zeki olmayı gerektirmiyor.",
  "time_range": [
   36.2,
   40.88
  ]
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s.",
  "model": "nmt",
  "translatedText": "Herhangi bir dosya, ister video, ister ses, ister metin, ister bir kod, ister bir görüntü olsun, sonuçta 1'ler ve 0'lardan oluşan bir dizidir.",
  "time_range": [
   40.88,
   50.38
  ]
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit.",
  "model": "nmt",
  "translatedText": "Ve ters çevrilen herhangi bir biti düzeltmek için basit bir strateji, her bitin üç kopyasını saklamak olacaktır.",
  "time_range": [
   50.68,
   56.0
  ]
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy.",
  "model": "nmt",
  "translatedText": "Daha sonra bu dosyayı okuyan makine bu üç kopyayı karşılaştırabilir ve bir tutarsızlık olduğunda her zaman 3 üzerinden en iyi 2'yi alabilir.",
  "time_range": [
   57.58,
   64.06
  ]
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy.",
  "model": "nmt",
  "translatedText": "Ancak bunun anlamı, alanınızın üçte ikisini yedeklilik için kullanmaktır.",
  "time_range": [
   67.16,
   70.86
  ]
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped.",
  "model": "nmt",
  "translatedText": "Ve o zaman bile, kaybedilen tüm bu alana rağmen, birden fazla bitin ters çevrilmesi durumunda ne olacağına dair güçlü bir garanti yoktur.",
  "time_range": [
   71.48,
   77.24
  ]
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible.",
  "model": "nmt",
  "translatedText": "Çok daha ilginç olan soru, mümkün olduğunca az yer kaplarken hataların düzeltilebilmesi için bunun nasıl yapılacağıdır.",
  "time_range": [
   77.98,
   84.02
  ]
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9!",
  "model": "nmt",
  "translatedText": "Örneğin, bu videoda öğreneceğiniz yöntemi kullanarak verilerinizi 256 bitlik bloklarda saklayabilirsiniz; burada her blok 9 bit, 9!",
  "time_range": [
   84.52000000000001,
   93.36
  ]
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want.",
  "model": "nmt",
  "translatedText": "bir tür artıklık görevi görür ve diğer 247 bit, istediğiniz anlamlı mesajı veya veriyi taşımakta özgürdür.",
  "time_range": [
   93.76,
   100.3
  ]
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it.",
  "model": "nmt",
  "translatedText": "Ve yine de burada herhangi bir bit ters çevrilirse, sadece bu bloğa bakarak ve başka hiçbir şeye bakmadan, bir makine bir hata olduğunu ve tam olarak nerede olduğunu tespit edebilecek ve böylece onu nasıl düzelteceğini bilebilecektir.",
  "time_range": [
   100.9,
   112.66
  ]
 },
 {
  "input": "And honestly, that feels like magic.",
  "model": "nmt",
  "translatedText": "Ve dürüst olmak gerekirse, bu sihir gibi geliyor.",
  "time_range": [
   112.66,
   114.62
  ]
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them.",
  "model": "nmt",
  "translatedText": "Ve bu özel şema için, eğer iki bit ters çevrilirse, makine en azından iki hata olduğunu tespit edebilecektir, ancak bunları nasıl düzelteceğini bilemeyecektir.",
  "time_range": [
   115.44,
   122.86
  ]
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes.",
  "model": "nmt",
  "translatedText": "Bunun farklı boyutlardaki bloklar için nasıl ölçeklendirileceği hakkında biraz sonra konuşacağız.",
  "time_range": [
   123.52,
   126.9
  ]
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes.",
  "model": "nmt",
  "translatedText": "Bunun gibi hataları düzeltmenize izin veren yöntemler, makul olarak, hata düzeltme kodları olarak bilinir.",
  "time_range": [
   127.86,
   132.9
  ]
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day.",
  "model": "nmt",
  "translatedText": "Geçen yüzyılın büyük bir bölümünde bu alan, her gün kullandığımız cihazlara dahil edilen, şaşırtıcı derecede derin bir matematik açısından gerçekten zengin bir kaynak oldu.",
  "time_range": [
   133.66,
   141.94
  ]
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code.",
  "model": "nmt",
  "translatedText": "Buradaki amaç size Hamming kodu olarak bilinen en eski örneklerden biri hakkında kapsamlı bir anlayış kazandırmaktır.",
  "time_range": [
   142.84,
   148.66
  ]
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there.",
  "model": "nmt",
  "translatedText": "Bu arada, bu videonun yapısı hakkında düşünme biçimim, onu mümkün olduğunca doğrudan açıklamaktan çok, ara sıra hafif bir rehberlikle sizi onu kendiniz icat etmeye teşvik etmekle ilgili.",
  "time_range": [
   149.52,
   159.82
  ]
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you.",
  "model": "nmt",
  "translatedText": "Yani bir noktada işlerin nereye gideceğini gördüğünüzü hissettiğinizde, o anı duraklatın ve ben size söylemeden önce planın ne olacağını aktif olarak tahmin edin.",
  "time_range": [
   160.12,
   166.72
  ]
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying.",
  "model": "nmt",
  "translatedText": "Ayrıca, anlayışınızın donanım düzeyine inmesini istiyorsanız, Ben Eater bununla bağlantılı olarak Hamming kodlarını devre tahtalarına nasıl uygulayacağınızı gösteren bir video hazırladı ki bu son derece tatmin edici.",
  "time_range": [
   167.24,
   178.24
  ]
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming.",
  "model": "nmt",
  "translatedText": "Hamming kodlarının, Reed-Solomon algoritması gibi daha modern kodlar kadar yaygın kullanılmadığını bilmelisiniz, ancak bu görevin başlangıçta ne kadar imkansız hissettirdiği ile bir kez ne kadar mantıklı göründüğü arasındaki karşıtlıkta belli bir sihir var. Hamming'i öğreniyorsun.",
  "time_range": [
   179.3,
   193.0
  ]
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages.",
  "model": "nmt",
  "translatedText": "Hata düzeltmenin temel ilkesi, olası tüm mesajların geniş bir alanında yalnızca bazı alt kümelerin geçerli mesaj olarak kabul edilmesidir.",
  "time_range": [
   193.72,
   202.18
  ]
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words.",
  "model": "nmt",
  "translatedText": "Bir benzetme olarak, doğru yazılan sözcükler ile yanlış yazılan sözcükleri düşünün.",
  "time_range": [
   202.8,
   206.94
  ]
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo.",
  "model": "nmt",
  "translatedText": "Geçerli bir mesaj değiştirildiğinde, tıpkı bir yazım hatasında yapabileceğiniz gibi, alıcı gördüklerini en yakın geçerli komşuya düzeltmekten sorumludur.",
  "time_range": [
   208.9,
   217.34
  ]
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness.",
  "model": "nmt",
  "translatedText": "Ancak bunun gibi mesajları etkili bir şekilde kategorize etmek için somut bir algoritma bulmak belli bir zeka gerektirir.",
  "time_range": [
   218.22,
   224.06
  ]
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to.",
  "model": "nmt",
  "translatedText": "Hikaye 1940'larda, genç Richard Hamming'in Bell Laboratuvarları için çalıştığı ve bazı işlerinin sınırlı erişime sahip olduğu çok büyük, pahalı bir delikli kart bilgisayarını kullandığı zaman başlıyor.",
  "time_range": [
   226.78,
   237.42
  ]
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread.",
  "model": "nmt",
  "translatedText": "Ve uygulamaya koyduğu programlar sürekli başarısız oluyordu çünkü ara sıra bazı kısımlar yanlış okunuyordu.",
  "time_range": [
   237.8,
   242.4
  ]
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code.",
  "model": "nmt",
  "translatedText": "Hayal kırıklığı buluşun potası olduğundan o kadar bıktı ki dünyanın ilk hata düzeltme kodunu icat etti.",
  "time_range": [
   243.12,
   248.42
  ]
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them.",
  "model": "nmt",
  "translatedText": "Hamming kodlarını çerçevelemenin pek çok farklı yolu vardır, ancak ilk geçiş olarak biz bunu Hamming'in kendisinin onlar hakkında düşündüğü şekilde ele alacağız.",
  "time_range": [
   249.06,
   255.38
  ]
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits.",
  "model": "nmt",
  "translatedText": "Basit ama çok da basit olmayan bir örnek, 16 bitlik bir blok kullanalım.",
  "time_range": [
   256.52,
   260.94
  ]
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15.",
  "model": "nmt",
  "translatedText": "Bu bitlerin konumlarını 0'dan 15'e kadar numaralandıracağız.",
  "time_range": [
   261.82,
   264.74
  ]
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy.",
  "model": "nmt",
  "translatedText": "Saklamak istediğimiz gerçek veriler bu bitlerden yalnızca 12'sini oluşturacak, konumların 4'ü ise bir tür artıklık olarak ayrılmış durumda.",
  "time_range": [
   265.62,
   273.0
  ]
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data.",
  "model": "nmt",
  "translatedText": "Buradaki gereksiz kelimesi sadece kopyalama anlamına gelmiyor, sonuçta bu 4 bit bize verileri körü körüne kopyalamak için yeterli alan vermiyor.",
  "time_range": [
   273.9,
   280.04
  ]
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience.",
  "model": "nmt",
  "translatedText": "Bunun yerine, bunların çok daha incelikli ve akıllı bir tür fazlalık olması, herhangi bir yeni bilgi eklemesi değil, esneklik sağlaması gerekecek.",
  "time_range": [
   280.72,
   287.28
  ]
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end.",
  "model": "nmt",
  "translatedText": "Bu 4 özel parçanın, belki sonunda ya da buna benzer bir şekilde güzel bir şekilde bir araya gelmesini bekleyebilirsiniz, ancak göreceğiniz gibi, bunların 2'nin kuvvetleri olan konumlara yerleştirilmesi, sonunda gerçekten zarif bir şeye olanak tanır.",
  "time_range": [
   288.6,
   299.62
  ]
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks.",
  "model": "nmt",
  "translatedText": "Ayrıca, bunun daha büyük bloklar için nasıl ölçeklendiğine dair size küçük bir ipucu verebilir.",
  "time_range": [
   300.2,
   303.54
  ]
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now.",
  "model": "nmt",
  "translatedText": "Ayrıca teknik olarak sadece 11 bitlik bir veriden ibarettir, 0 konumunda olup bitenlerle ilgili hafif bir nüans olduğunu göreceksiniz, ancak şimdilik bunun için endişelenmeyin.",
  "time_range": [
   304.90000000000003,
   313.26
  ]
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors.",
  "model": "nmt",
  "translatedText": "Herhangi bir hata düzeltme algoritması gibi, bu da iki oyuncuyu içerecektir; bu 4 özel bitin ayarlanmasından sorumlu olan bir gönderici ve bir tür kontrolün gerçekleştirilmesinden ve hataların düzeltilmesinden sorumlu olan bir alıcı.",
  "time_range": [
   314.14,
   325.2
  ]
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage.",
  "model": "nmt",
  "translatedText": "Elbette, gönderen ve alıcı kelimeleri aslında tüm kontrolleri yapan makinelere veya yazılımlara atıfta bulunur ve mesaj fikri, depolama gibi şeyleri de içerecek şekilde oldukça geniş bir anlama gelir.",
  "time_range": [
   325.2,
   334.74
  ]
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another.",
  "model": "nmt",
  "translatedText": "Sonuçta veri depolamak, mesajın bir yerden başka bir yere değil, geçmişten geleceğe gönderilmesiyle aynı şeydir.",
  "time_range": [
   335.34,
   341.68
  ]
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check.",
  "model": "nmt",
  "translatedText": "Kurulum bu, ancak konuya dalmadan önce, keşfi sırasında Hamming'in aklında yeni olan ilgili bir fikir hakkında konuşmamız gerekiyor; herhangi bir tek bit hatasını tespit etmenize izin veren ancak bunları düzeltmenize izin vermeyen bir yöntem, bilinen iş dünyasında parite kontrolü olarak.",
  "time_range": [
   342.56,
   356.3
  ]
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message.",
  "model": "nmt",
  "translatedText": "Eşlik kontrolü için, gönderenin ayarlamadan sorumlu olduğu tek bir biti ayırıyoruz ve geri kalanı mesaj taşımakta özgür.",
  "time_range": [
   356.88,
   363.82
  ]
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number.",
  "model": "nmt",
  "translatedText": "Bu özel bitin tek görevi mesajdaki 1'lerin toplam sayısının çift sayı olmasını sağlamaktır.",
  "time_range": [
   364.88,
   371.28
  ]
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even.",
  "model": "nmt",
  "translatedText": "Örneğin şu anda, 1'lerin toplam sayısı 7'dir, bu tek sayıdır, dolayısıyla gönderenin bu özel biti 1 olacak şekilde çevirmesi gerekir, böylece sayı çift olur.",
  "time_range": [
   372.08,
   379.96
  ]
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0.",
  "model": "nmt",
  "translatedText": "Ancak blok zaten çift sayıda 1'lerle başlamış olsaydı, bu özel bit 0'da tutulurdu.",
  "time_range": [
   380.8,
   386.42
  ]
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information.",
  "model": "nmt",
  "translatedText": "Bu oldukça basit, yanıltıcı derecede basit, ancak bir mesajın herhangi bir yerindeki değişimin tek bir bilgi parçasına yansıtılacağı fikrini damıtmanın inanılmaz derecede zarif bir yolu.",
  "time_range": [
   387.34,
   396.78
  ]
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd.",
  "model": "nmt",
  "translatedText": "Bu mesajın herhangi bir bitinin 0'dan 1'e veya 1'den 0'a çevrilmesi durumunda, 1'lerin toplam sayısının çiftten teke değişmesine dikkat edin.",
  "time_range": [
   397.5,
   406.54
  ]
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was.",
  "model": "nmt",
  "translatedText": "Yani eğer alıcıysanız, bu mesaja baktığınızda ve tek sayıda 1'ler görüyorsanız, nerede olduğu hakkında hiçbir fikriniz olmasa bile bir hatanın meydana geldiğinden emin olabilirsiniz.",
  "time_range": [
   407.98,
   417.46
  ]
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity.",
  "model": "nmt",
  "translatedText": "Jargonda, bir bit grubunun çift veya tek sayıda 1'e sahip olup olmadığı, eşlik olarak bilinir.",
  "time_range": [
   418.5,
   423.34
  ]
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea.",
  "model": "nmt",
  "translatedText": "Ayrıca sayıları kullanabilir ve paritenin 0 veya 1 olduğunu söyleyebilirsiniz; bu fikirle matematik yapmaya başladığınızda genellikle daha yararlı olur.",
  "time_range": [
   424.86,
   430.72
  ]
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit.",
  "model": "nmt",
  "translatedText": "Ve göndericinin pariteyi kontrol etmek için kullandığı bu özel bit, eşlik biti olarak adlandırılır.",
  "time_range": [
   431.22,
   435.52
  ]
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0.",
  "model": "nmt",
  "translatedText": "Ve aslında, açık olmalıyız ki, eğer alıcı tek bir parite görürse, bu sadece bir hata olduğu anlamına gelmez, 3 hata, 5 hata veya başka herhangi bir tek sayı olabilir, ancak kesin olarak bilebilir. 0 değildi.",
  "time_range": [
   437.56,
   449.26
  ]
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free.",
  "model": "nmt",
  "translatedText": "Öte yandan, 2 hata veya herhangi bir çift sayıda hata olsaydı, son 1 sayısı hâlâ çift sayı olurdu, dolayısıyla alıcı, çift sayının mutlaka mesajın hatasız olduğu anlamına geldiğine tam olarak güvenemez.",
  "time_range": [
   449.98,
   462.3
  ]
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right.",
  "model": "nmt",
  "translatedText": "Yalnızca 2 bitlik geçişlerle bozulan bir mesajın oldukça zayıf olduğundan şikayet edebilirsiniz ve kesinlikle haklısınız.",
  "time_range": [
   462.84000000000003,
   469.08
  ]
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended.",
  "model": "nmt",
  "translatedText": "Ancak, aldığınız mesajın gönderenin amaçladığı mesaj olduğuna dair size %100 güven verecek bir hata tespiti veya düzeltme yöntemi olmadığını unutmayın.",
  "time_range": [
   469.7,
   478.9
  ]
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance.",
  "model": "nmt",
  "translatedText": "Sonuçta, yeterince rastgele gürültü her zaman geçerli bir mesajı tamamen şans eseri başka bir geçerli mesaja dönüştürebilir.",
  "time_range": [
   479.58,
   485.44
  ]
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this.",
  "model": "nmt",
  "translatedText": "Bunun yerine amaç, belirli bir maksimum hata sayısına kadar dayanıklı bir şema bulmak veya bunun gibi yanlış pozitif olasılığını azaltmaktır.",
  "time_range": [
   486.24,
   495.38
  ]
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes.",
  "model": "nmt",
  "translatedText": "Eşlik kontrolleri kendi başlarına oldukça zayıftır, ancak tüm mesajdaki değişim fikrini tek bir bit'e indirgeyerek bize verdikleri şey, daha karmaşık planlar için güçlü bir yapı taşıdır.",
  "time_range": [
   496.26,
   507.16
  ]
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error.",
  "model": "nmt",
  "translatedText": "Örneğin, Hamming bir hatanın sadece meydana geldiğini değil, nerede meydana geldiğini de belirlemenin bir yolunu ararken, onun temel görüşü şuydu: Eğer bazı eşitlik kontrollerini mesajın tamamına değil de dikkatle seçilmiş belirli alt kümelere uygularsanız, şu soruyu sorabilirsiniz: herhangi bir bit hatasının yerini belirleyen daha rafine bir dizi soru.",
  "time_range": [
   507.94,
   525.94
  ]
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half.",
  "model": "nmt",
  "translatedText": "Genel his biraz 20 soruluk bir oyun oynamaya, olasılıklar alanını yarıya indiren evet veya hayır soruları sormaya benziyor.",
  "time_range": [
   526.68,
   533.38
  ]
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions.",
  "model": "nmt",
  "translatedText": "Örneğin, diyelim ki sadece bu 8 bit üzerinde, tek sayılı konumların tümü üzerinde bir eşlik kontrolü yaptığımızı varsayalım.",
  "time_range": [
   534.16,
   539.38
  ]
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position.",
  "model": "nmt",
  "translatedText": "Daha sonra bir hata tespit edilirse, alıcıya hatanın tam olarak nerede olduğu, yani tek bir konumda olduğu hakkında biraz daha bilgi verilir.",
  "time_range": [
   540.1,
   548.24
  ]
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions.",
  "model": "nmt",
  "translatedText": "Bu 8 bit arasında herhangi bir hata tespit edilmezse, bu ya hiç hata olmadığı anlamına gelir ya da çift konumlarda bir yerde bulunur.",
  "time_range": [
   548.94,
   556.24
  ]
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful.",
  "model": "nmt",
  "translatedText": "Eşlik kontrolünü bitlerin yarısıyla sınırlandırmanın onu daha az etkili hale getirdiğini düşünebilirsiniz, ancak diğer iyi seçilmiş kontrollerle birlikte yapıldığında, mantıksız bir şekilde bize çok daha güçlü bir şey verir.",
  "time_range": [
   557.18,
   567.2
  ]
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group.",
  "model": "nmt",
  "translatedText": "Eşlik kontrolünü gerçekten ayarlamak için, unutmayın, o tam grubun eşliğini kontrol eden bazı özel bitlerin tahsis edilmesi gerekir.",
  "time_range": [
   569.24,
   576.62
  ]
 },
 {
  "input": "Here let's just choose position 1.",
  "model": "nmt",
  "translatedText": "Burada sadece konum 1'i seçelim.",
  "time_range": [
   577.48,
   579.18
  ]
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even.",
  "model": "nmt",
  "translatedText": "Gösterilen örnekte, bu 8 bitin paritesi şu anda tektir, dolayısıyla gönderen bu eşlik bitinin değiştirilmesinden sorumludur ve artık çifttir.",
  "time_range": [
   579.72,
   586.98
  ]
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do.",
  "model": "nmt",
  "translatedText": "Bu, yapacağımız 4 eşlik kontrolünden yalnızca 1'idir.",
  "time_range": [
   587.94,
   590.68
  ]
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here.",
  "model": "nmt",
  "translatedText": "İkinci kontrol, en azından burada çizdiğimiz şekliyle, ızgaranın sağ yarısındaki 8 bit arasındadır.",
  "time_range": [
   590.92,
   596.3
  ]
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged.",
  "model": "nmt",
  "translatedText": "Bu kez konum 2'yi eşlik biti olarak kullanabiliriz, böylece bu 8 bit zaten eşit bir eşliğe sahiptir ve gönderen, bu 2 numaralı biti değiştirmeden bırakmanın kendisini iyi hissedebilir.",
  "time_range": [
   596.68,
   606.06
  ]
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right.",
  "model": "nmt",
  "translatedText": "Diğer taraftan eğer alıcı bu grubun paritesini kontrol ederse ve bunun tuhaf olduğunu görürse, hatanın sağdaki bu 8 bit arasında bir yerde olduğunu anlayacaktır.",
  "time_range": [
   607.02,
   615.38
  ]
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half.",
  "model": "nmt",
  "translatedText": "Aksi takdirde bu, ya hata olmadığı ya da hatanın sol yarıda bir yerde olduğu anlamına gelir.",
  "time_range": [
   615.82,
   620.58
  ]
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block.",
  "model": "nmt",
  "translatedText": "Ya da sanırım iki hata olabilirdi ama şimdilik tüm blokta en fazla bir hata olduğunu varsayacağız.",
  "time_range": [
   621.12,
   626.5
  ]
 },
 {
  "input": "Things break down completely for more than that.",
  "model": "nmt",
  "translatedText": "Bundan daha fazlası için işler tamamen bozulur.",
  "time_range": [
   626.94,
   628.74
  ]
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together.",
  "model": "nmt",
  "translatedText": "Burada, sonraki iki kontrole bakmadan önce, bir dakika durup bu ilk ikisinin birlikte değerlendirildiğinde bize ne yapmamıza olanak sağladığını düşünün.",
  "time_range": [
   629.16,
   635.1
  ]
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half.",
  "model": "nmt",
  "translatedText": "Diyelim ki tek sütunlar arasında ve sağ yarıda bir hata tespit ettiniz.",
  "time_range": [
   635.8,
   639.66
  ]
 },
 {
  "input": "It necessarily means the error is somewhere in the last column.",
  "model": "nmt",
  "translatedText": "Bu mutlaka hatanın son sütunda bir yerde olduğu anlamına gelir.",
  "time_range": [
   640.2,
   643.04
  ]
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column.",
  "model": "nmt",
  "translatedText": "Tek sütunda hata yoksa ancak sağ yarıda bir hata varsa, bu size sorunun sondan ikinci sütunda olduğunu gösterir.",
  "time_range": [
   643.82,
   649.7
  ]
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column.",
  "model": "nmt",
  "translatedText": "Benzer şekilde, tek sütunlarda bir hata varsa ancak sağ yarıda değilse, bunun ikinci sütunda bir yerde olduğunu bilirsiniz.",
  "time_range": [
   650.44,
   656.56
  ]
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column.",
  "model": "nmt",
  "translatedText": "Ve eğer bu iki eşlik kontrolünden hiçbiri bir şey tespit etmezse, bu, hatanın olabileceği tek yerin en soldaki sütun olduğu anlamına gelir.",
  "time_range": [
   656.56,
   663.12
  ]
 },
 {
  "input": "But it also might simply mean there's no error at all.",
  "model": "nmt",
  "translatedText": "Ancak bu aynı zamanda hiçbir hatanın olmadığı anlamına da gelebilir.",
  "time_range": [
   663.34,
   666.12
  ]
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column.",
  "model": "nmt",
  "translatedText": "Bu, iki eşlik kontrolünün sütunu belirlememize izin verdiğini söylemenin oldukça ayrıntılı bir yolu.",
  "time_range": [
   666.3,
   670.84
  ]
 },
 {
  "input": "From here, you can probably guess what follows.",
  "model": "nmt",
  "translatedText": "Buradan sonrasını muhtemelen tahmin edebilirsiniz.",
  "time_range": [
   671.48,
   673.64
  ]
 },
 {
  "input": "We do basically the same thing but for the rows.",
  "model": "nmt",
  "translatedText": "Temelde aynı şeyi yapıyoruz ancak satırlar için.",
  "time_range": [
   673.8,
   676.14
  ]
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit.",
  "model": "nmt",
  "translatedText": "Konum 4'ü eşlik biti olarak kullanarak tek satırlarda bir eşlik kontrolü yapılacak.",
  "time_range": [
   676.44,
   680.9
  ]
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0.",
  "model": "nmt",
  "translatedText": "Yani bu örnekte bu grup zaten çift eşlikli olduğundan bit 4, 0'a ayarlanacaktır.",
  "time_range": [
   681.38,
   685.82
  ]
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit.",
  "model": "nmt",
  "translatedText": "Ve son olarak, alt iki satırda, konum 8'i eşlik biti olarak kullanan bir eşlik kontrolü var.",
  "time_range": [
   686.56,
   691.58
  ]
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity.",
  "model": "nmt",
  "translatedText": "Bu durumda, gruba eşit eşitlik sağlamak için gönderenin 8. biti açması gerekiyor gibi görünüyor.",
  "time_range": [
   692.12,
   696.82
  ]
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row.",
  "model": "nmt",
  "translatedText": "İlk iki kontrol sütunu belirlememize izin verdiği gibi, sonraki iki kontrol de satırı belirlemenize olanak sağlar.",
  "time_range": [
   697.7,
   701.84
  ]
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3.",
  "model": "nmt",
  "translatedText": "Örnek olarak, iletim sırasında örneğin 3. pozisyonda bir hata olduğunu hayal edin.",
  "time_range": [
   702.88,
   707.54
  ]
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column.",
  "model": "nmt",
  "translatedText": "Bu, birinci eşlik grubunu etkiler ve aynı zamanda ikinci eşlik grubunu da etkiler, böylece alıcı, sağ sütunda bir yerde bir hata olduğunu bilir.",
  "time_range": [
   708.18,
   715.56
  ]
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group.",
  "model": "nmt",
  "translatedText": "Ama üçüncü grubu etkilemediği gibi dördüncü grubu da etkilemez.",
  "time_range": [
   716.1,
   720.54
  ]
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error.",
  "model": "nmt",
  "translatedText": "Ve bu, alıcının hatayı ilk satıra kadar tespit etmesini sağlar, bu da zorunlu olarak 3. konum anlamına gelir, böylece hatayı düzeltebilirler.",
  "time_range": [
   721.24,
   727.52
  ]
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be.",
  "model": "nmt",
  "translatedText": "Bu dört sorunun yanıtlarının, nerede olursa olsun, belirli bir konumu belirlemenize gerçekten olanak sağlayacağına kendinizi ikna etmek için bir dakikanızı ayırmanın tadını çıkarabilirsiniz.",
  "time_range": [
   728.58,
   737.1
  ]
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting.",
  "model": "nmt",
  "translatedText": "Hatta aranızdaki zeki biri bu sorularla ikili sayım arasında bir bağlantı bile fark edebilir.",
  "time_range": [
   737.72,
   743.06
  ]
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it.",
  "model": "nmt",
  "translatedText": "Ve eğer yaparsanız, tekrar vurgulayayım, duraklatın, ben onu bozmadan bağlantıyı kendiniz kurmaya çalışın.",
  "time_range": [
   743.5,
   748.92
  ]
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it.",
  "model": "nmt",
  "translatedText": "Bir eşlik bitinin kendisi etkilenirse ne olacağını merak ediyorsanız, bunu deneyebilirsiniz.",
  "time_range": [
   750.5,
   756.06
  ]
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions.",
  "model": "nmt",
  "translatedText": "Bir dakikanızı ayırıp bu dört özel parça arasındaki herhangi bir hatanın, tıpkı diğerleri gibi, dört sorudan oluşan aynı grupla nasıl bulunacağını düşünün.",
  "time_range": [
   756.44,
   764.18
  ]
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along.",
  "model": "nmt",
  "translatedText": "Aslında bunun bir önemi yok, çünkü günün sonunda istediğimiz şey mesaj bitlerini korumaktır, hata düzeltme bitleri yoluna devam eder.",
  "time_range": [
   767.0600000000001,
   773.1
  ]
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct.",
  "model": "nmt",
  "translatedText": "Ancak bu parçaların da korunması, doğal olarak bir yan ürün olarak planın dışında kalan bir şeydir.",
  "time_range": [
   773.6,
   777.82
  ]
 },
 {
  "input": "You might also enjoy anticipating how this scales.",
  "model": "nmt",
  "translatedText": "Bunun nasıl ölçekleneceğini tahmin etmekten de keyif alabilirsiniz.",
  "time_range": [
   779.2,
   781.76
  ]
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot.",
  "model": "nmt",
  "translatedText": "Örneğin, bir konumu belirlemek için 256 bit boyutunda bir blok kullansaydık, belirli bir noktaya giden yolu ikili olarak aramak için yalnızca sekiz evet veya hayır sorusuna ihtiyacınız olurdu.",
  "time_range": [
   782.3,
   792.78
  ]
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check.",
  "model": "nmt",
  "translatedText": "Ve unutmayın, her soru uygun eşlik kontrolünü ayarlamak için yalnızca tek bir bitten vazgeçmeyi gerektirir.",
  "time_range": [
   795.64,
   800.5
  ]
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two.",
  "model": "nmt",
  "translatedText": "Bazılarınız bunu zaten görmüş olabilir, ancak daha sonra bu soruların ne olduğunu bir veya iki dakika içinde bulmanın sistematik yolundan bahsedeceğiz.",
  "time_range": [
   803.16,
   809.36
  ]
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here.",
  "model": "nmt",
  "translatedText": "Umarım bu taslak, burada geliştirdiğimiz şeyin verimliliğini takdir etmek için yeterlidir.",
  "time_range": [
   809.88,
   813.26
  ]
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want.",
  "model": "nmt",
  "translatedText": "İlk şey, vurgulanan sekiz eşlik biti dışında, istediğiniz her şey olabilir, istediğiniz mesajı veya veriyi taşıyabilir.",
  "time_range": [
   813.26,
   821.82
  ]
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole.",
  "model": "nmt",
  "translatedText": "8 bit, tamamen mesajın geri kalanı tarafından belirlenmeleri anlamında gereksizdir, ancak bu, mesajın bir bütün olarak kopyalanmasından çok daha akıllı bir yoldur.",
  "time_range": [
   821.82,
   830.02
  ]
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error.",
  "model": "nmt",
  "translatedText": "Ve yine de, bu kadar az vazgeçmekle, herhangi bir tek bit hatasını tespit edip düzeltebileceksiniz.",
  "time_range": [
   833.6,
   838.38
  ]
 },
 {
  "input": "Well, almost.",
  "model": "nmt",
  "translatedText": "Neredeyse.",
  "time_range": [
   839.2,
   840.4
  ]
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0.",
  "model": "nmt",
  "translatedText": "Tamam, buradaki sorun şu ki, eğer dört eşlik kontrolünden hiçbiri bir hata tespit etmezse, yani özel olarak seçilmiş 8 bitlik alt kümelerin tümü, gönderenin amaçladığı gibi eşit eşliklere sahipse, o zaman bu da hiçbir hata olmadığı anlamına gelir. veya bizi 0 pozisyonuna daraltır.",
  "time_range": [
   840.96,
   856.86
  ]
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition.",
  "model": "nmt",
  "translatedText": "Görüyorsunuz, dört evet veya hayır sorusuyla, eşitlik kontrollerimiz için 16 olası sonuç var ve ilk başta bu, bloktaki 16 konumdan 1'inin yerini belirlemek için mükemmel gibi geliyor, ancak aynı zamanda 17. sonucu da iletmeniz gerekiyor, yani hata yok durum.",
  "time_range": [
   857.74,
   871.9
  ]
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely.",
  "model": "nmt",
  "translatedText": "Buradaki çözüm aslında oldukça basit, sadece o 0'ıncı biti tamamen unutun.",
  "time_range": [
   873.02,
   877.3
  ]
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error.",
  "model": "nmt",
  "translatedText": "Yani dört eşlik kontrolümüzü yaptığımızda ve hepsinin eşit olduğunu gördüğümüzde, bu açıkça hiçbir hata olmadığı anlamına gelir.",
  "time_range": [
   877.84,
   883.46
  ]
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy.",
  "model": "nmt",
  "translatedText": "Bunun anlamı, 16 bitlik bir blokla çalışmak yerine, 15 bitlik bir blokla çalışıyoruz; burada bitlerin 11'i mesaj taşımak için serbest ve 4'ü yedeklik için orada.",
  "time_range": [
   884.24,
   893.22
  ]
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code.",
  "model": "nmt",
  "translatedText": "Ve bununla birlikte, artık sektördeki insanların 15-11 Hamming kodu olarak adlandıracağı şeye sahibiz.",
  "time_range": [
   893.78,
   900.2
  ]
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us.",
  "model": "nmt",
  "translatedText": "Bununla birlikte, 2'nin temiz kuvveti olan bir blok boyutuna sahip olmak güzel ve bu 0'ıncı biti etrafta tutmanın ve bizim için biraz fazladan iş yapmasını sağlamanın akıllıca bir yolu var.",
  "time_range": [
   900.46,
   908.14
  ]
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors.",
  "model": "nmt",
  "translatedText": "Bunu tüm blok boyunca bir eşlik biti olarak kullanırsak, 2 bitlik hataları düzeltemesek bile aslında tespit etmemizi sağlar.",
  "time_range": [
   908.7,
   915.54
  ]
 },
 {
  "input": "Here's how it works.",
  "model": "nmt",
  "translatedText": "İşte nasıl çalışıyor?",
  "time_range": [
   916.16,
   916.82
  ]
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check.",
  "model": "nmt",
  "translatedText": "Bu dört özel hata düzeltme bitini ayarladıktan sonra, tam bloğun paritesi normal bir eşlik kontrolü gibi çift olacak şekilde 0'ıncı biti ayarladık.",
  "time_range": [
   917.18,
   924.94
  ]
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks.",
  "model": "nmt",
  "translatedText": "Şimdi, eğer tek bir bit hatası varsa, o zaman tam bloğun paritesi tek olacak şekilde değişir, ancak dört hata düzeltme kontrolü sayesinde bunu yine de yakalarız.",
  "time_range": [
   925.7,
   933.6
  ]
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks.",
  "model": "nmt",
  "translatedText": "Bununla birlikte, eğer iki hata varsa, o zaman genel parite tekrar eşit duruma dönecektir, ancak alıcı yine de bu dört eşlik kontrolünde olup bitenlerden dolayı en azından bir miktar hata olduğunu görecektir.",
  "time_range": [
   934.16,
   945.18
  ]
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors.",
  "model": "nmt",
  "translatedText": "Yani genel olarak eşit bir eşitlik fark ederlerse ancak diğer kontrollerde sıfırdan farklı bir şey oluyorsa, bu onlara en az iki hata olduğunu söyler.",
  "time_range": [
   945.18,
   952.7
  ]
 },
 {
  "input": "Isn't that clever?",
  "model": "nmt",
  "translatedText": "Bu çok akıllıca değil mi?",
  "time_range": [
   953.52,
   954.0
  ]
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them.",
  "model": "nmt",
  "translatedText": "Her ne kadar bu 2 bitlik hataları düzeltemesek de, o küçük can sıkıcı 0'ıncı biti tekrar devreye sokarak, onları tespit etmemizi sağlıyor.",
  "time_range": [
   954.3,
   961.26
  ]
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code.",
  "model": "nmt",
  "translatedText": "Bu oldukça standarttır, genişletilmiş Hamming kodu olarak bilinir.",
  "time_range": [
   962.26,
   965.22
  ]
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block.",
  "model": "nmt",
  "translatedText": "Teknik açıdan konuşursak, artık en azından 16 bitlik bir blok örneği için Hamming kodunun ne yaptığının tam bir açıklamasına sahipsiniz.",
  "time_range": [
   966.54,
   972.88
  ]
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself.",
  "model": "nmt",
  "translatedText": "Ancak, baştan sona kendi başınıza tam bir örnek yaparak anlayışınızı kontrol etmeyi ve bu noktaya kadar her şeyi sağlamlaştırmayı daha tatmin edici bulacağınızı düşünüyorum.",
  "time_range": [
   972.88,
   981.32
  ]
 },
 {
  "input": "I'll step through it with you though so you can check yourself.",
  "model": "nmt",
  "translatedText": "Kendinizi kontrol edebilmeniz için ben de sizinle birlikte üzerinden geçeceğim.",
  "time_range": [
   982.08,
   984.3
  ]
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks.",
  "model": "nmt",
  "translatedText": "İster uzayda çevirdiğiniz gerçek bir mesaj, ister zaman içinde depolamak istediğiniz bazı veriler olsun, bir mesaj oluşturmak için ilk adım, onu 11 bitlik parçalara bölmektir.",
  "time_range": [
   985.12,
   994.66
  ]
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block.",
  "model": "nmt",
  "translatedText": "Her parça, hataya dayanıklı 16 bitlik bir blok halinde paketlenecek.",
  "time_range": [
   995.58,
   999.76
  ]
 },
 {
  "input": "So let's take this one as an example and actually work it out.",
  "model": "nmt",
  "translatedText": "Hadi bunu bir örnek olarak alalım ve gerçekten üzerinde çalışalım.",
  "time_range": [
   999.76,
   1003.22
  ]
 },
 {
  "input": "Go ahead, actually do it!",
  "model": "nmt",
  "translatedText": "Devam edin, gerçekten yapın!",
  "time_range": [
   1003.74,
   1004.74
  ]
 },
 {
  "input": "Let's pause and try putting together this block.",
  "model": "nmt",
  "translatedText": "Durup bu bloğu bir araya getirmeyi deneyelim.",
  "time_range": [
   1004.74,
   1007.02
  ]
 },
 {
  "input": "Okay, you ready?",
  "model": "nmt",
  "translatedText": "Tamam, hazır mısın?",
  "time_range": [
   1012.72,
   1013.68
  ]
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order.",
  "model": "nmt",
  "translatedText": "Unutmayın, 0 konumu ve 2'nin diğer kuvvetleri hata düzeltme görevi için ayrılmıştır, bu nedenle mesaj bitlerini kalan tüm noktalara sırayla yerleştirerek başlarsınız.",
  "time_range": [
   1014.24,
   1023.32
  ]
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0.",
  "model": "nmt",
  "translatedText": "Bu grubun çift eşlikli olması gerekir ki zaten öyledir, dolayısıyla 1 konumundaki eşlik bitini 0 olacak şekilde ayarlamanız gerekir.",
  "time_range": [
   1025.34,
   1032.34
  ]
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1.",
  "model": "nmt",
  "translatedText": "Bir sonraki grup tek bir eşlikle başlar, dolayısıyla eşlik bitini 1 olarak ayarlamanız gerekir.",
  "time_range": [
   1033.02,
   1037.88
  ]
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1.",
  "model": "nmt",
  "translatedText": "Bundan sonraki grup tek eşlikle başlar, dolayısıyla eşlik bitini yine 1'e ayarlamanız gerekir.",
  "time_range": [
   1039.16,
   1044.24
  ]
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1.",
  "model": "nmt",
  "translatedText": "Ve son grubun da tek bir paritesi var, yani bu biti 8 pozisyonuna 1 olarak ayarladık.",
  "time_range": [
   1044.78,
   1050.06
  ]
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0.",
  "model": "nmt",
  "translatedText": "Ve son adım olarak, tam bloğun artık çift bir eşlik durumu var; bu, 0 numaralı bit sayısını, yani kapsayıcı eşlik bitini 0 olarak ayarlayabileceğiniz anlamına geliyor.",
  "time_range": [
   1051.3,
   1060.32
  ]
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0.",
  "model": "nmt",
  "translatedText": "Yani bu blok gönderildiğinde, dört özel alt kümenin ve bir bütün olarak bloğun paritesi çift veya 0 olacaktır.",
  "time_range": [
   1061.34,
   1068.14
  ]
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver.",
  "model": "nmt",
  "translatedText": "Alıştırmanın ikinci bölümünde alıcı rolünü oynamanızı sağlayalım.",
  "time_range": [
   1068.82,
   1072.18
  ]
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't.",
  "model": "nmt",
  "translatedText": "Tabii bu, bu mesajın ne olduğunu henüz bilmediğiniz anlamına gelir, belki bazılarınız ezberlemiştir, ama varsayalım ki ezberlemediniz.",
  "time_range": [
   1073.48,
   1079.78
  ]
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did.",
  "model": "nmt",
  "translatedText": "Yapacağım şey, o bloktaki bitlerden 0, 1 veya 2'sini değiştirmek ve sonra sizden ne yaptığımı bulmanızı istemek.",
  "time_range": [
   1080.02,
   1087.74
  ]
 },
 {
  "input": "So again, pause and try working it out.",
  "model": "nmt",
  "translatedText": "Tekrar duraklatın ve çözmeye çalışın.",
  "time_range": [
   1088.26,
   1090.81
  ]
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column.",
  "model": "nmt",
  "translatedText": "Tamam, şimdi alıcı olarak siz ilk eşlik grubunu kontrol ediyorsunuz ve bunun çift olduğunu görebiliyorsunuz, dolayısıyla mevcut herhangi bir hatanın çift sütunda olması gerekir.",
  "time_range": [
   1098.79,
   1107.91
  ]
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column.",
  "model": "nmt",
  "translatedText": "Bir sonraki kontrol bize tek bir sayı veriyor, ikimize de en az bir hata olduğunu söylüyor ve bizi bu spesifik sütuna daraltıyor.",
  "time_range": [
   1109.69,
   1117.03
  ]
 },
 {
  "input": "The third check is even, chopping down the possibilities even further.",
  "model": "nmt",
  "translatedText": "Üçüncü kontrol eşittir, olasılıkları daha da azaltır.",
  "time_range": [
   1118.55,
   1121.79
  ]
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10.",
  "model": "nmt",
  "translatedText": "Ve son eşlik kontrolü tuhaf, bize altta bir yerde bir hata olduğunu söylüyor, şu anda bunun 10 numaralı konumda olması gerektiğini görebiliyoruz.",
  "time_range": [
   1122.65,
   1129.65
  ]
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two.",
  "model": "nmt",
  "translatedText": "Dahası, tüm bloğun paritesi tuhaftır ve bize iki değil, tek bir atış olduğu konusunda güven verir.",
  "time_range": [
   1131.49,
   1137.53
  ]
 },
 {
  "input": "If it's three or more, all bets are off.",
  "model": "nmt",
  "translatedText": "Üç veya daha fazla ise tüm bahisler kapalıdır.",
  "time_range": [
   1138.07,
   1139.97
  ]
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with.",
  "model": "nmt",
  "translatedText": "10 numaralı biti düzelttikten sonra, düzeltme için kullanılmayan 11 biti çıkarmak bize orijinal mesajın ilgili bölümünü verir; geri sararsanız ve karşılaştırırsanız, bu gerçekten de örneğe başladığımız şeyin tam olarak aynısıdır.",
  "time_range": [
   1141.31,
   1154.39
  ]
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code.",
  "model": "nmt",
  "translatedText": "Artık tüm bunları elle nasıl yapacağınızı bildiğinize göre, size tüm bu mantığın temel kısmını tek bir Python kodu satırıyla nasıl gerçekleştirebileceğinizi göstermek istiyorum.",
  "time_range": [
   1155.71,
   1163.17
  ]
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks.",
  "model": "nmt",
  "translatedText": "Görüyorsunuz, size henüz söylemediğim şey, bu algoritmanın gerçekte ne kadar zarif olduğu, bir makinenin hatanın konumunu göstermesinin ne kadar basit olduğu, bunu sistematik olarak nasıl ölçeklendireceğimiz ve tüm bunları nasıl çerçeveleyebileceğimizdir. bu, birden fazla ayrı eşlik kontrolü yerine tek bir işlem olarak yapılır.",
  "time_range": [
   1163.87,
   1178.75
  ]
 },
 {
  "input": "To see what I mean, come join me in part 2.",
  "model": "nmt",
  "translatedText": "Ne demek istediğimi anlamak için 2. bölümde bana katılın.",
  "time_range": [
   1179.43,
   1181.31
  ]
 }
]