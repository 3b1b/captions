1
00:00:00,000 --> 00:00:02,560
여기 계신 분들은 모두 1부에서 오신 분들인 것 같아요.

2
00:00:03,060 --> 00:00:11,768
우리는 대부분의 비트가 의미 있는 메시지를 전달하는 반면 다른 비트는 일종의 중복 역할을 하는 데이터 블록을 생성하는 방법인 해밍 코드에 대해 

3
00:00:11,768 --> 00:00:21,240
이야기하고 있었습니다. 비트 또는 중복 비트 등 이 블록에 있는 모든 항목을 통해 수신자는 오류가 있음을 식별하고 이를 수정하는 방법을 확인할 수 있습니다.

4
00:00:21,880 --> 00:00:27,160
거기에 제시된 기본 아이디어는 다중 패리티 검사를 사용하여 오류까지 이진 검색하는 방법이었습니다.

5
00:00:28,980 --> 00:00:34,600
해당 비디오의 목표는 Hamming 코드를 가능한 한 직접 사용하고 재발견할 수 있도록 만드는 것이었습니다.

6
00:00:35,180 --> 00:00:39,320
그러나 소프트웨어나 하드웨어에서 이를 실제로 구현하는 것에 대해 생각하기 시작하면 

7
00:00:39,320 --> 00:00:43,460
해당 프레임은 실제로 이러한 코드가 실제로 얼마나 우아한지 과소평가할 수 있습니다.

8
00:00:43,920 --> 00:00:53,480
가능한 모든 오류 위치를 추적하고 검사할 때마다 해당 그룹을 절반으로 줄이는 알고리즘을 작성해야 한다고 생각할 수도 있지만 실제로는 그보다 훨씬 더 간단합니다.

9
00:00:53,940 --> 00:01:04,080
지난 비디오에서 우리가 했던 네 가지 패리티 검사에 대한 답을 모두 예와 아니오 대신 1과 0으로 읽으면 문자 그대로 이진수로 오류 위치를 설명합니다.

10
00:01:04,780 --> 00:01:11,260
예를 들어, 이진수 7은 0111처럼 보입니다. 이는 본질적으로 4 더하기 2 더하기 1을 의미합니다.

11
00:01:12,540 --> 00:01:21,740
그리고 위치 7이 어디에 있는지 확인하세요. 이는 패리티 그룹 중 첫 번째, 두 번째, 세 번째에 영향을 주지만 마지막에는 영향을 미치지 않습니다.

12
00:01:22,220 --> 00:01:27,540
따라서 이 네 가지 검사 결과를 아래에서 위로 읽으면 실제로 오류의 위치를 알 수 있습니다.

13
00:01:28,320 --> 00:01:35,820
예제 7에는 특별한 것이 없습니다. 이는 일반적으로 작동하며 하드웨어에서 전체 구성표를 구현하는 논리를 놀라울 정도로 단순하게 만듭니다.

14
00:01:37,240 --> 00:01:43,440
이제 이 마법이 왜 일어나는지 알고 싶다면 위치에 대한 16개의 인덱스 레이블을 사용하세요. 

15
00:01:43,440 --> 00:01:49,880
단, 10진수로 작성하는 대신 0000부터 1111까지 실행되는 이진수로 모두 작성해 보겠습니다.

16
00:01:50,559 --> 00:01:57,800
이러한 바이너리 레이블을 상자에 다시 넣을 때 실제로 전송되는 데이터와 구별된다는 점을 강조하겠습니다.

17
00:01:58,320 --> 00:02:03,500
이는 여러분과 제가 네 개의 패리티 그룹이 어디에서 왔는지 이해하는 데 도움이 되는 개념적 레이블에 지나지 않습니다.

18
00:02:04,140 --> 00:02:12,360
우리가 보고 있는 모든 것을 이진법으로 기술하는 것의 우아함은 우리가 보고 있는 모든 것을 이진법으로 기술하는 것의 혼란으로 인해 약화될 수도 있습니다.

19
00:02:13,020 --> 00:02:14,120
그래도 그만한 가치가 있습니다.

20
00:02:14,800 --> 00:02:23,220
모든 레이블의 마지막 비트에만 주의를 집중한 다음 마지막 비트가 1인 위치를 강조 표시하세요.

21
00:02:24,240 --> 00:02:32,244
우리가 얻는 것은 네 개의 패리티 그룹 중 첫 번째입니다. 즉, 첫 번째 검사를 다음과 같이 묻는 것으로 해석할 수 있습니다. 

22
00:02:32,244 --> 00:02:35,740
오류가 있으면 해당 오류 위치의 마지막 비트가 1인가요?

23
00:02:38,200 --> 00:02:46,160
마찬가지로, 마지막 비트에서 두 번째 비트에 초점을 맞추고 해당 비트가 1인 모든 위치를 강조 표시하면 구성표에서 두 번째 패리티 그룹을 얻게 됩니다.

24
00:02:46,740 --> 00:02:54,500
즉, 두 번째 확인은 &#39;안녕하세요, 다시 한 번 말씀드리지만, 오류가 있는 경우 해당 위치의 마지막에서 두 번째 비트가 1인가요? &#39;라고 묻습니다.

25
00:02:55,760 --> 00:02:56,900
등등.

26
00:02:57,220 --> 00:03:08,740
세 번째 패리티 검사는 마지막에서 세 번째 비트가 켜져 있는 모든 위치를 다루고, 마지막 패리티 검사는 가장 높은 순서 비트가 1인 마지막 8개 위치를 다룹니다.

27
00:03:09,740 --> 00:03:17,740
이전에 우리가 했던 모든 것은 이 네 가지 질문에 답하는 것과 동일하며, 이는 다시 이진법으로 위치를 철자하는 것과 동일합니다.

28
00:03:19,620 --> 00:03:21,480
이것이 두 가지를 더 명확하게 해주기를 바랍니다.

29
00:03:22,040 --> 00:03:26,460
첫 번째는 2의 거듭제곱보다 큰 블록 크기를 체계적으로 일반화하는 방법입니다.

30
00:03:26,960 --> 00:03:36,680
64개 지점을 설명하는 데 6비트가 필요한 것처럼 각 위치를 설명하는 데 더 많은 비트가 필요한 경우 각 비트는 확인해야 할 패리티 그룹 중 하나를 제공합니다.

31
00:03:38,400 --> 00:03:43,180
제가 Matt Parker와 함께 했던 체스판 퍼즐을 본 분들이라면 이 모든 것이 매우 익숙할 것입니다.

32
00:03:43,660 --> 00:03:48,780
동일한 핵심 논리이지만 다른 문제를 해결하고 64제곱 체스판에 적용됩니다.

33
00:03:49,880 --> 00:03:57,320
두 번째로 명확해지기를 바라는 것은 패리티 비트가 1, 2, 4, 8과 같이 2의 거듭제곱 위치에 있는 이유입니다.

34
00:03:58,000 --> 00:04:03,000
이는 이진 표현이 단일 비트만 켜져 있는 위치입니다.

35
00:04:03,600 --> 00:04:09,460
이는 각 패리티 비트가 4개의 패리티 그룹 중 하나에만 위치한다는 것을 의미합니다.

36
00:04:12,040 --> 00:04:19,339
얼마나 큰지 상관없이 각 패리티 비트가 그룹 중 하나에만 편리하게 닿는 더 큰 예에서도 이를 볼 수 있습니다.

37
00:04:25,600 --> 00:04:34,242
우리가 많은 시간을 투자해 온 이러한 패리티 검사가 오류의 위치를 바이너리로 설명하는 영리한 방법일 뿐이라는 점을 이해하면 해밍에 

38
00:04:34,242 --> 00:04:43,240
대해 생각하는 다른 방식으로 연결을 그릴 수 있습니다. 훨씬 더 간단하고 우아하며 기본적으로 한 줄의 코드로 작성할 수 있는 코드입니다.

39
00:04:43,660 --> 00:04:45,500
XOR 함수를 기반으로 합니다.

40
00:04:46,940 --> 00:04:50,220
XOR은 모르시는 분들을 위해 설명하자면, Exclusive or의 약자입니다.

41
00:04:50,780 --> 00:04:59,360
두 비트의 XOR을 수행하면 해당 비트 중 하나가 켜져 있으면 1이 반환되지만 둘 다 켜져 있거나 꺼져 있으면 반환되지 않습니다.

42
00:05:00,100 --> 00:05:02,980
다르게 말하면, 이 두 비트의 패리티입니다.

43
00:05:03,540 --> 00:05:06,760
수학적인 사람으로서 나는 그것을 추가 모드 2로 생각하는 것을 선호합니다.

44
00:05:07,360 --> 00:05:13,440
또한 기본적으로 이 구성 요소를 구성 요소별로 수행하는 두 개의 서로 다른 비트 문자열의 XOR에 대해서도 일반적으로 이야기합니다.

45
00:05:13,680 --> 00:05:15,720
그것은 덧셈과 비슷하지만 결코 가지고 다니지 않습니다.

46
00:05:16,500 --> 00:05:22,480
다시 말하지만, 수학적으로 더 기울어진 사람은 이를 두 개의 벡터를 추가하고 mod 2를 줄이는 것으로 생각하는 것을 선호할 수 있습니다.

47
00:05:23,500 --> 00:05:32,940
지금 당장 Python을 열고 두 정수 사이에 캐럿 연산을 적용하면 이것이 수행되는 작업이지만 내부적으로 해당 숫자의 비트 표현이 수행됩니다.

48
00:05:34,960 --> 00:05:41,250
여러분과 저에게 중요한 점은 다양한 비트 문자열의 XOR을 취하는 것이 열의 경우와 

49
00:05:41,250 --> 00:05:47,140
같이 여러 개별 그룹의 패러디를 한꺼번에 계산하는 효과적인 방법이라는 것입니다.

50
00:05:51,260 --> 00:05:58,780
이는 해밍 코드 알고리즘의 다중 패리티 검사를 모두 하나의 단일 작업으로 함께 패키지하는 것으로 생각하는 다소 멋진 방법을 제공합니다.

51
00:05:59,479 --> 00:06:02,180
언뜻 보면 매우 달라 보이지만.

52
00:06:02,820 --> 00:06:09,883
이전처럼 16개 위치를 이진수로 구체적으로 기록하고 이제 메시지 비트가 1로 켜진 

53
00:06:09,883 --> 00:06:17,100
위치를 강조 표시한 다음 이러한 위치를 하나의 큰 열로 수집하고 XOR을 수행합니다.

54
00:06:19,260 --> 00:06:29,200
결과적으로 맨 아래에 있는 4비트는 우리가 알고 사랑하게 된 4개의 패리티 검사와 동일하다고 추측할 수 있지만 실제로 그 이유가 무엇인지 잠시 생각해 보세요.

55
00:06:32,220 --> 00:06:38,661
예를 들어 이 마지막 열은 마지막 비트가 1인 모든 위치를 계산하지만 이미 강조 표시된 

56
00:06:38,661 --> 00:06:45,760
위치로만 제한되어 있으므로 첫 번째 패리티 그룹에서 강조 표시된 위치 수를 효과적으로 계산합니다.

57
00:06:46,240 --> 00:06:46,800
말이 돼?

58
00:06:49,080 --> 00:07:00,000
마찬가지로 다음 열에서는 두 번째 패리티 그룹에 위치가 몇 개 있는지, 마지막 비트에서 두 번째 비트가 1이고 역시 강조 표시된 위치 등을 계산합니다.

59
00:07:00,260 --> 00:07:03,960
이는 우리가 해왔던 동일한 일에 대한 관점의 작은 변화일 뿐입니다.

60
00:07:07,760 --> 00:07:09,600
그래서 여기서부터 어디로 가는지 알 수 있습니다.

61
00:07:10,000 --> 00:07:15,720
보낸 사람은 합계가 0000이 되도록 특수 패리티 비트 중 일부를 전환할 책임이 있습니다.

62
00:07:15,720 --> 00:07:27,580
이제 이와 같은 결과가 나오면 하단에 있는 4개의 결과 비트가 오류 위치를 직접적으로 설명하는 이유를 생각할 수 있는 정말 좋은 방법을 제공합니다.

63
00:07:28,460 --> 00:07:31,860
이 블록의 일부 비트가 0에서 1로 전환된다고 가정해 보겠습니다.

64
00:07:32,600 --> 00:07:43,820
이는 해당 비트의 위치가 이제 전체 XOR에 포함되어 합계가 0에서 새로 포함된 값인 오류 위치로 변경된다는 의미입니다.

65
00:07:44,460 --> 00:07:49,360
약간 덜 명확하게 말하면 1을 0으로 변경하는 오류가 있는 경우에도 마찬가지입니다.

66
00:07:50,180 --> 00:07:57,580
알다시피, 비트 문자열을 두 번 더하면 거기에 전혀 없는 것과 같습니다. 기본적으로 이 세상에서는 1 더하기 1이 0이기 때문입니다.

67
00:07:57,580 --> 00:08:04,300
따라서 이 위치의 복사본을 총 합계에 추가하면 이동하는 것과 동일한 효과가 있습니다.

68
00:08:05,160 --> 00:08:10,700
그리고 그 효과는 여기 하단의 전체 결과가 오류의 위치를 설명한다는 것입니다.

69
00:08:13,039 --> 00:08:21,440
이것이 얼마나 우아한지 설명하기 위해 이전에 참조한 Python 코드 한 줄을 보여 드리겠습니다. 이 코드는 수신자 측의 거의 모든 논리를 캡처합니다.

70
00:08:22,080 --> 00:08:31,859
데이터 블록을 시뮬레이션하기 위해 16개의 1과 0으로 구성된 임의의 배열을 생성하는 것부터 시작하고 여기에 이름 비트를 부여할 것입니다. 

71
00:08:31,859 --> 00:08:37,000
무작위이므로 5개의 패리티 비트와 함께 11개의 데이터 비트를 전달합니다.

72
00:08:37,000 --> 00:08:47,000
enumerateBits 함수를 호출하면 각 비트를 해당 인덱스와 쌍으로 연결합니다. 이 경우에는 0에서 15까지 실행됩니다.

73
00:08:48,180 --> 00:08:58,273
그래서 우리가 이 모든 쌍, 즉 i처럼 보이는 쌍을 반복하는 목록을 생성하고 i 값만 추출하고 인덱스만 추출하면 그다지 흥미롭지는 않습니다. 

74
00:08:58,273 --> 00:09:01,340
0부터 15까지의 인덱스만 다시 가져옵니다.

75
00:09:01,680 --> 00:09:12,660
하지만 만약 비트인 경우에만 이 작업을 수행한다는 조건을 추가하면, 즉 해당 비트가 1이고 0이 아닌 경우 해당 비트가 켜져 있는 위치만 꺼냅니다.

76
00:09:13,380 --> 00:09:20,360
이 경우 해당 위치는 0, 4, 6, 9 등인 것처럼 보입니다.

77
00:09:20,720 --> 00:09:27,240
우리가 원하는 것은 모든 위치, 즉 켜져 있는 비트의 위치를 함께 수집한 다음 함께 XOR하는 것입니다.

78
00:09:29,180 --> 00:09:33,220
Python에서 이 작업을 수행하려면 먼저 몇 가지 유용한 함수를 가져오겠습니다.

79
00:09:33,900 --> 00:09:38,700
그런 식으로 우리는 이 목록에서 Reduce()를 호출하고 XOR 함수를 사용하여 목록을 줄일 수 있습니다.

80
00:09:39,100 --> 00:09:42,680
이것은 기본적으로 목록을 통해 XOR을 수행합니다.

81
00:09:44,800 --> 00:09:49,440
원하는 경우 XOR 함수를 어디에서든 가져올 필요 없이 명시적으로 작성할 수 있습니다.

82
00:09:51,940 --> 00:10:01,280
따라서 현재로서는 16비트의 무작위 블록에 대해 이 작업을 수행하면 이진 표현 1001을 갖는 9가 반환되는 것처럼 보입니다.

83
00:10:01,980 --> 00:10:09,744
여기서는 수행하지 않겠지만 송신자가 이진 표현을 사용하여 필요에 따라 4개의 패리티 비트를 설정하는 함수를 작성할 수 있습니다. 

84
00:10:09,744 --> 00:10:15,460
그러면 궁극적으로 이 블록을 전체 비트 목록에서 이 코드 줄을 실행하는 상태가 반환됩니다. 0.

85
00:10:16,080 --> 00:10:20,100
이는 잘 준비된 블록으로 간주됩니다.

86
00:10:20,100 --> 00:10:30,220
멋진 점은 이 목록의 비트 중 하나를 전환하여 노이즈로 인한 임의 오류를 시뮬레이션한 다음 동일한 코드 줄을 실행하면 해당 오류가 인쇄된다는 것입니다.

87
00:10:30,960 --> 00:10:31,520
깔끔하지 않나요?

88
00:10:31,820 --> 00:10:41,060
갑자기 이 블록을 가져와서 이 한 줄을 실행하면 오류 위치가 자동으로 표시되고, 오류가 없으면 0이 표시됩니다.

89
00:10:42,500 --> 00:10:44,840
그리고 사이즈 16에는 특별한 것이 없습니다.

90
00:10:44,840 --> 00:10:49,860
예를 들어 256비트 목록이 있는 경우 동일한 코드 줄이 작동합니다.

91
00:10:51,880 --> 00:10:58,971
말할 필요도 없이 여기에 작성해야 할 코드가 더 있습니다. 예를 들어 2비트 오류를 감지하기 위한 메타 패리티 검사를 수행하는 것입니다. 

92
00:10:58,971 --> 00:11:03,760
그러나 아이디어는 우리 체계의 거의 모든 핵심 논리가 단일 XOR 감소로 귀결된다는 것입니다.

93
00:11:06,120 --> 00:11:12,215
이제 바이너리, XOR 및 일반적인 소프트웨어에 대한 편안함에 따라 이 관점이 약간 혼란스러울 수도 

94
00:11:12,215 --> 00:11:18,420
있고 훨씬 더 우아하고 단순하여 왜 우리가 처음부터 시작하지 않았는지 궁금해할 수도 있습니다. -가다.

95
00:11:19,140 --> 00:11:25,584
대략적으로 말하면 다중 패리티 검사 관점은 하드웨어에서 해밍 코드를 직접 구현할 때 생각하기가 더 쉽고, 

96
00:11:25,584 --> 00:11:30,500
XOR 관점은 소프트웨어에서 수행할 때 더 높은 수준에서 생각하기 가장 쉽습니다.

97
00:11:31,360 --> 00:11:40,219
첫 번째는 실제로 손으로 하는 것이 가장 쉽고, 이 모든 것의 기초가 되는 핵심 직관을 심어주는 것이 더 나은 일이라고 생각합니다. 즉, 

98
00:11:40,219 --> 00:11:50,000
단일 오류를 찾는 데 필요한 정보는 블록 크기의 로그와 관련이 있다는 것입니다. 즉, 블록 크기가 두 배로 증가함에 따라 한 번에 한 비트씩 증가합니다.

99
00:11:51,020 --> 00:11:56,060
여기서 관련 사실은 해당 정보가 필요한 중복 정도와 직접적으로 일치한다는 것입니다.

100
00:11:56,660 --> 00:12:03,068
이는 오류에 대해 탄력적인 메시지를 만드는 것에 대해 처음 생각할 때 대부분의 사람들이 무작정 반응하는 것과 반대되는 것입니다. 

101
00:12:03,068 --> 00:12:06,540
일반적으로 전체 메시지를 복사하는 것이 가장 먼저 떠오르는 본능입니다.

102
00:12:07,500 --> 00:12:14,000
그런데 때로는 해밍 코드가 표시되는 완전히 다른 방식이 있는데, 여기서 메시지에 하나의 큰 행렬을 곱합니다.

103
00:12:14,670 --> 00:12:19,047
더 넓은 범위의 선형 코드 제품군과 관련되어 있기 때문에 다소 좋지만, 그것이 어디서 

104
00:12:19,047 --> 00:12:23,060
왔는지 또는 어떻게 확장되는지에 대한 직관을 거의 제공하지 않는다고 생각합니다.

105
00:12:25,200 --> 00:12:31,160
확장에 관해 말하자면, 블록 크기를 늘릴수록 이 체계의 효율성이 더 좋아진다는 것을 알 수 있습니다.

106
00:12:35,000 --> 00:12:42,660
예를 들어, 256비트의 경우 중복성을 위해 해당 공간의 3%만 사용하고 그 이후로 점점 더 좋아지는 것을 확인했습니다.

107
00:12:43,300 --> 00:12:47,340
패리티 비트 수가 하나씩 증가함에 따라 블록 크기는 계속 두 배로 늘어납니다.

108
00:12:49,000 --> 00:12:54,142
그리고 이를 극단적으로 받아들인다면, 예를 들어 백만 비트의 블록을 가질 수 있습니다. 

109
00:12:54,142 --> 00:13:00,020
여기서 패리티 검사로 문자 그대로 20개의 질문을 플레이하고 21개의 패리티 비트만 사용하게 됩니다.

110
00:13:00,740 --> 00:13:07,060
그리고 한 걸음 물러서서 백만 개의 비트를 살펴보고 단일 오류를 찾는 것에 대해 생각한다면 그것은 정말로 미친 것처럼 느껴집니다.

111
00:13:08,199 --> 00:13:17,660
물론 문제는 블록이 클수록 비트 오류가 1~2개 이상 나올 확률이 높아지고, 해밍 코드는 그 이상은 처리하지 못한다는 점이다.

112
00:13:18,320 --> 00:13:24,300
따라서 실제로 원하는 것은 비트 플립이 너무 많이 발생할 확률이 너무 높지 않도록 올바른 크기를 찾는 것입니다.

113
00:13:26,600 --> 00:13:31,585
또한 실제로 오류는 작은 단위로 발생하는 경향이 있어 단일 블록을 완전히 망칠 수 있습니다. 

114
00:13:31,585 --> 00:13:39,829
따라서 여러 블록에 걸쳐 오류를 분산시키는 데 도움이 되는 일반적인 전술 중 하나는 해당 블록이 블록에 포함되기 전에 이와 같이 인터레이스하는 것입니다. 

115
00:13:39,829 --> 00:13:40,980
발송 또는 보관됩니다.

116
00:13:45,580 --> 00:13:52,200
그런 다음 다시 말하지만, 이 중 많은 부분은 버스트 오류를 특히 잘 처리하고 블록당 더 많은 수의 오류에 탄력적으로 조정될 

117
00:13:52,200 --> 00:13:58,820
수 있는 훨씬 더 일반적으로 사용되는 Reed-Solomon 알고리즘과 같은 최신 코드에 의해 완전히 논쟁의 여지가 있습니다.

118
00:13:59,360 --> 00:14:01,340
그러나 그것은 다른 시간에 다룰 주제입니다.

119
00:14:02,500 --> 00:14:06,680
Hamming은 자신의 저서 The Art of Doing Science and Engineering에서 

120
00:14:06,680 --> 00:14:09,940
자신이 발견한 이 코드가 얼마나 의미심장한 일이었는지 놀랍도록 솔직하게 밝혔습니다.

121
00:14:10,620 --> 00:14:17,780
그는 먼저 비트를 더 높은 차원의 격자 부분으로 구성하는 것과 이와 같은 이상한 것들을 포함하는 모든 종류의 다양한 계획을 시도했습니다.

122
00:14:18,300 --> 00:14:24,795
오류의 위치를 명시하는 방식으로 패리티 검사를 공모하여 음모를 꾸미는 것이 가능할 수도 있다는 생각은 Hamming이 여러 가지 다른 분석을 한 후 한 

123
00:14:24,795 --> 00:14:31,520
걸음 물러나서 &quot;알겠습니다. 제가 할 수 있는 가장 효율적인 방법은 무엇입니까? &quot;라고 물었을 때부터였습니다. 아마도 이것에 관한 것입니까?

124
00:14:32,620 --> 00:14:41,220
그는 또한 패리티 검사가 이미 그의 마음 속에 있다는 것이 얼마나 중요한지 솔직하게 말했습니다. 1940년대에는 오늘날보다 훨씬 덜 일반적이었을 것입니다.

125
00:14:41,920 --> 00:14:48,220
이 책 전체에 걸쳐 그는 루이 파스퇴르의 명언을 여섯 번이나 언급합니다. 행운은 준비된 마음을 선호합니다.

126
00:14:49,320 --> 00:14:54,300
영리한 아이디어는 돌이켜보면 믿을 수 없을 만큼 단순해 보이는 경우가 많아 과소평가되기 쉽습니다.

127
00:14:54,960 --> 00:15:01,300
지금 당장은 해밍 코드, 또는 적어도 그러한 코드의 가능성이 여러분에게 거의 명백하게 느껴지기를 진심으로 바랍니다.

128
00:15:01,660 --> 00:15:06,820
하지만 그것들이 실제로 명백하다고 생각하도록 자신을 속여서는 안 됩니다. 왜냐하면 그것들은 확실히 그렇지 않기 때문입니다.

129
00:15:07,880 --> 00:15:15,217
영리한 아이디어가 믿을 수 없을 정도로 쉬워 보이는 이유 중 하나는 우리가 최종 결과만 보고 지저분한 것을 정리하고 모든 잘못된 

130
00:15:15,217 --> 00:15:22,860
방향을 언급하지 않고 문제가 시작될 때 탐색 가능한 가능성의 공간이 얼마나 광대한지 과소평가하기 때문입니다. 해결 과정, 그 모든 것.

131
00:15:23,820 --> 00:15:24,900
그러나 이것은 일반적으로 사실입니다.

132
00:15:24,900 --> 00:15:30,040
저는 몇몇 특별한 발명품에 대해 우리가 그것을 과소평가하는 두 번째로 더 깊은 이유가 있다고 생각합니다.

133
00:15:30,840 --> 00:15:38,640
정보를 비트 단위로 생각하는 것은 정보 이론에 관한 Claude Shannon의 중요한 논문을 통해 1948년에 비로소 완전한 이론으로 통합되었습니다.

134
00:15:39,280 --> 00:15:42,540
이는 Hamming이 자신의 알고리즘을 개발했을 때와 본질적으로 동시에 발생했습니다.

135
00:15:43,300 --> 00:15:52,900
이것은 적어도 이론적으로는 비트 플립 확률이 아무리 높더라도 어떤 의미에서는 효율적인 오류 수정이 항상 가능하다는 것을 보여주는 동일한 기본 논문이었습니다.

136
00:15:53,700 --> 00:16:01,160
그런데 Shannon과 Hamming은 매우 다른 일을 하고 있음에도 불구하고 Bell Labs에서 사무실을 공유했는데, 여기서는 우연이 아닌 것 같습니다.

137
00:16:02,380 --> 00:16:12,340
수십 년이 지난 지금, 우리 중 많은 사람들이 비트와 정보에 대한 생각에 너무 몰두하여 이러한 사고 방식이 얼마나 뚜렷한지 간과하기 쉽습니다.

138
00:16:13,100 --> 00:16:22,260
아이러니하게도 미래 세대가 생각하는 방식을 가장 근본적으로 형성하는 아이디어는 결국 미래 세대를 실제보다 더 단순하게 보게 될 것입니다.

