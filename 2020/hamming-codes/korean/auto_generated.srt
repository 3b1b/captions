1
00:00:03,620 --> 00:00:06,796
CD나 DVD를 긁어도 저장된 내용을 그대로 

2
00:00:06,796 --> 00:00:10,100
재생할 수 있는 방법이 궁금한 적이 있으신가요?

3
00:00:10,900 --> 00:00:13,940
스크래치는 실제로 디스크의 1과 0에 영향을 

4
00:00:13,940 --> 00:00:16,980
미치기 때문에 저장된 데이터와 다른 데이터를 

5
00:00:16,980 --> 00:00:20,386
읽어오지만, 정말 긁힌 것이 아니라면 이러한 모든 

6
00:00:20,386 --> 00:00:23,669
오류에도 불구하고 읽어온 비트는 인코딩된 파일과 

7
00:00:23,669 --> 00:00:26,710
정확히 동일한 파일로 디코딩되어 비트 단위로 

8
00:00:26,710 --> 00:00:27,440
복사됩니다.

9
00:00:27,440 --> 00:00:30,337
수학적 영리함에는 오류에 강한 방식으로 

10
00:00:30,337 --> 00:00:33,103
데이터를 저장하고, 마찬가지로 중요한 

11
00:00:33,103 --> 00:00:36,660
데이터를 전송할 수 있는 수많은 기술이 있습니다.

12
00:00:37,520 --> 00:00:39,612
사실 이렇게 하는 방법을 생각해내는 

13
00:00:39,612 --> 00:00:41,600
데 그렇게 똑똑할 필요는 없습니다.

14
00:00:42,060 --> 00:00:45,221
동영상, 사운드, 텍스트, 코드, 

15
00:00:45,221 --> 00:00:49,381
이미지 등 모든 파일은 궁극적으로 1과 0의 

16
00:00:49,381 --> 00:00:50,380
연속입니다.

17
00:00:50,680 --> 00:00:53,233
뒤집힌 비트를 수정하기 위한 간단한 전략은 

18
00:00:53,233 --> 00:00:56,000
각 비트의 복사본을 세 개씩 저장하는 것입니다.

19
00:00:57,580 --> 00:00:59,531
그러면 이 파일을 읽는 컴퓨터가 이 세 개의 

20
00:00:59,531 --> 00:01:01,717
사본을 비교하여 불일치가 있을 때마다 항상 3개의 

21
00:01:01,717 --> 00:01:04,060
사본 중 가장 좋은 2개의 사본을 선택할 수 있습니다.

22
00:01:07,160 --> 00:01:08,912
하지만 이는 공간의 3분의 2를 

23
00:01:08,912 --> 00:01:10,860
중복성을 위해 사용한다는 의미입니다.

24
00:01:11,480 --> 00:01:13,343
그리고 그렇게 포기한 모든 공간에 대해 

25
00:01:13,343 --> 00:01:15,122
하나 이상의 비트가 뒤집힐 경우 어떤 

26
00:01:15,122 --> 00:01:17,240
일이 벌어질지에 대한 확실한 보장도 없습니다.

27
00:01:17,980 --> 00:01:20,841
훨씬 더 흥미로운 질문은 가능한 한 적은 공간을 

28
00:01:20,841 --> 00:01:24,020
포기하면서 오류를 수정할 수 있도록 만드는 방법입니다.

29
00:01:24,520 --> 00:01:27,250
예를 들어, 이 동영상에서 배우게 될 

30
00:01:27,250 --> 00:01:29,850
방법을 사용하면 각 블록이 9비트인 

31
00:01:29,850 --> 00:01:33,360
256비트 블록으로 데이터를 저장할 수 있습니다!

32
00:01:33,760 --> 00:01:35,878
를 사용하여 일종의 중복성 역할을 하고, 

33
00:01:35,878 --> 00:01:37,905
나머지 247 비트는 원하는 의미 있는 

34
00:01:37,905 --> 00:01:40,300
메시지나 데이터를 자유롭게 전달할 수 있습니다.

35
00:01:40,900 --> 00:01:44,641
그리고 여기서 비트가 하나라도 뒤바뀌면 이 블록만 

36
00:01:44,641 --> 00:01:48,517
보고도 기계가 오류가 발생했음을 파악하고 그 위치를 

37
00:01:48,517 --> 00:01:51,991
정확히 파악하여 어떻게 수정해야 하는지 알 수 

38
00:01:51,991 --> 00:01:52,660
있습니다.

39
00:01:52,660 --> 00:01:54,620
솔직히 마법처럼 느껴집니다.

40
00:01:55,440 --> 00:01:57,742
이 특정 방식에서는 두 개의 비트가 뒤집히더라도 

41
00:01:57,742 --> 00:02:00,301
기계가 오류를 수정하는 방법을 알 수는 없지만 최소한 

42
00:02:00,301 --> 00:02:02,860
두 개의 오류가 발생했다는 사실은 감지할 수 있습니다.

43
00:02:03,520 --> 00:02:05,142
크기가 다른 블록에 대해 이 기능이 어떻게 

44
00:02:05,142 --> 00:02:06,900
확장되는지에 대해서는 잠시 후에 설명하겠습니다.

45
00:02:07,860 --> 00:02:10,380
이와 같은 오류를 수정할 수 있는 

46
00:02:10,380 --> 00:02:12,900
방법을 오류 수정 코드라고 합니다.

47
00:02:13,660 --> 00:02:16,551
지난 세기 동안 이 분야는 우리가 매일 

48
00:02:16,551 --> 00:02:19,442
사용하는 기기에 통합되는 놀랍도록 심도 

49
00:02:19,442 --> 00:02:21,940
있는 수학의 풍부한 원천이었습니다.

50
00:02:22,840 --> 00:02:25,857
이 글의 목표는 해밍 코드라고 알려진 가장 초기의 

51
00:02:25,857 --> 00:02:28,660
예시 중 하나에 대해 자세히 이해하는 것입니다.

52
00:02:29,520 --> 00:02:31,796
참고로 이 동영상의 구조에 대해 제가 

53
00:02:31,796 --> 00:02:34,073
생각하는 방식은 가능한 한 직접적으로 

54
00:02:34,073 --> 00:02:36,458
설명하기보다는 여기저기서 약간의 안내를 

55
00:02:36,458 --> 00:02:38,735
통해 시청자가 스스로 만들 수 있도록 

56
00:02:38,735 --> 00:02:39,820
유도하는 것입니다.

57
00:02:40,120 --> 00:02:42,128
그러니 어느 순간 어디로 튈지 알 것 

58
00:02:42,128 --> 00:02:44,328
같으면 잠시 멈춰서 제가 말씀드리기 전에 

59
00:02:44,328 --> 00:02:46,720
계획이 어떻게 될지 적극적으로 예측해 보세요.

60
00:02:47,240 --> 00:02:49,938
또한 하드웨어 수준까지 이해하고자 하는 분들을 

61
00:02:49,938 --> 00:02:52,740
위해 벤 이터는 이 동영상과 함께 브레드보드에서 

62
00:02:52,740 --> 00:02:55,334
해밍 코드를 실제로 구현하는 방법을 보여주는 

63
00:02:55,334 --> 00:02:58,240
동영상을 제작했는데, 매우 만족스러운 동영상입니다.

64
00:02:59,300 --> 00:03:02,293
해밍 코드는 리드-솔로몬 알고리즘과 같은 최신 

65
00:03:02,293 --> 00:03:04,480
코드만큼 널리 사용되지는 않지만, 

66
00:03:04,480 --> 00:03:07,589
처음에 이 작업이 얼마나 불가능하게 느껴졌는지와 

67
00:03:07,589 --> 00:03:10,812
해밍에 대해 알고 나면 얼마나 합리적으로 보이는지 

68
00:03:10,812 --> 00:03:13,000
대조되는 마법 같은 점이 있습니다.

69
00:03:13,720 --> 00:03:16,453
오류 수정의 기본 원칙은 가능한 모든 

70
00:03:16,453 --> 00:03:19,056
메시지의 방대한 공간에서 일부 하위 

71
00:03:19,056 --> 00:03:22,180
집합만 유효한 메시지로 간주한다는 것입니다.

72
00:03:22,800 --> 00:03:24,991
철자가 맞는 단어와 철자가 틀린 

73
00:03:24,991 --> 00:03:26,940
단어를 비유로 생각해 보세요.

74
00:03:28,900 --> 00:03:31,787
유효한 메시지가 변경될 때마다 수신자는 오타가 

75
00:03:31,787 --> 00:03:34,341
있을 때와 마찬가지로 가장 가까운 유효한 

76
00:03:34,341 --> 00:03:37,340
이웃에게 표시되는 내용을 수정할 책임이 있습니다.

77
00:03:38,220 --> 00:03:40,106
하지만 이와 같은 메시지를 효율적으로 

78
00:03:40,106 --> 00:03:41,813
분류하기 위한 구체적인 알고리즘을 

79
00:03:41,813 --> 00:03:44,060
고안하는 데는 어느 정도 영리함이 필요합니다.

80
00:03:46,780 --> 00:03:49,546
이 이야기는 1940년대에 젊은 리처드 해밍이 

81
00:03:49,546 --> 00:03:51,887
벨 연구소에서 일하던 시절에 시작되며, 

82
00:03:51,887 --> 00:03:54,653
그의 작업 중 일부는 접근이 제한된 매우 크고 

83
00:03:54,653 --> 00:03:57,420
비싼 펀치 카드 컴퓨터를 사용하는 것이었습니다.

84
00:03:57,800 --> 00:04:00,143
그리고 가끔씩 잘못 읽히는 부분이 있었기 때문에 

85
00:04:00,143 --> 00:04:02,400
그가 계속 실행한 프로그램은 계속 실패했습니다.

86
00:04:03,120 --> 00:04:05,202
좌절은 발명의 도가니라는 말이 있듯이, 

87
00:04:05,202 --> 00:04:07,757
그는 좌절에 지쳐 세계 최초의 오류 수정 코드를 

88
00:04:07,757 --> 00:04:08,420
발명했습니다.

89
00:04:09,060 --> 00:04:12,114
해밍 코드를 구성하는 방법에는 여러 가지가 있지만, 

90
00:04:12,114 --> 00:04:14,748
우선 해밍이 직접 생각한 방식대로 살펴보도록 

91
00:04:14,748 --> 00:04:15,380
하겠습니다.

92
00:04:16,519 --> 00:04:18,497
간단하지만 너무 단순하지 않은 

93
00:04:18,497 --> 00:04:20,940
16비트 블록을 예로 들어 보겠습니다.

94
00:04:21,820 --> 00:04:24,740
이러한 비트의 위치는 0에서 15까지 번호를 매깁니다.

95
00:04:25,620 --> 00:04:29,245
우리가 저장하려는 실제 데이터는 이 중 12비트만 

96
00:04:29,245 --> 00:04:33,000
차지하며, 나머지 4개는 일종의 여분으로 남겨둡니다.

97
00:04:33,900 --> 00:04:35,921
여기서 중복이라는 단어는 단순히 복사를 의미하는 

98
00:04:35,921 --> 00:04:38,018
것이 아닙니다. 4비트는 데이터를 무턱대고 복사할 

99
00:04:38,018 --> 00:04:40,040
수 있는 충분한 공간을 제공하지 않기 때문입니다.

100
00:04:40,720 --> 00:04:43,001
대신, 새로운 정보를 추가하는 것이 아니라 

101
00:04:43,001 --> 00:04:45,283
복원력을 추가하는 훨씬 더 미묘하고 영리한 

102
00:04:45,283 --> 00:04:47,280
종류의 중복성이 필요하게 될 것입니다.

103
00:04:48,600 --> 00:04:51,060
이 4개의 특별한 비트가 마지막에 멋지게 

104
00:04:51,060 --> 00:04:53,628
포장되어 있을 거라고 생각할 수도 있지만, 

105
00:04:53,628 --> 00:04:56,196
보시다시피 2의 거듭제곱에 해당하는 위치에 

106
00:04:56,196 --> 00:04:58,871
배치하면 마지막에 정말 우아한 무언가를 만들 

107
00:04:58,871 --> 00:04:59,620
수 있습니다.

108
00:05:00,200 --> 00:05:02,015
또한 더 큰 블록에 대해 어떻게 확장되는지에 

109
00:05:02,015 --> 00:05:03,540
대한 약간의 힌트를 얻을 수 있습니다.

110
00:05:04,900 --> 00:05:07,837
또한 기술적으로는 11비트 데이터에 불과하며, 

111
00:05:07,837 --> 00:05:10,322
위치 0에서 일어나는 일에 대해 약간의 

112
00:05:10,322 --> 00:05:13,260
뉘앙스가 있지만 지금은 걱정하지 않아도 됩니다.

113
00:05:14,140 --> 00:05:16,725
다른 오류 수정 알고리즘과 마찬가지로, 

114
00:05:16,725 --> 00:05:19,428
여기에는 이 4개의 특수 비트를 설정하는 

115
00:05:19,428 --> 00:05:22,014
발신자와 일종의 검사를 수행하고 오류를 

116
00:05:22,014 --> 00:05:25,540
수정하는 수신자, 두 명의 플레이어가 참여하게 됩니다.

117
00:05:26,300 --> 00:05:28,318
물론 발신자와 수신자라는 단어는 실제로 

118
00:05:28,318 --> 00:05:30,611
모든 검사를 수행하는 기계 또는 소프트웨어를 

119
00:05:30,611 --> 00:05:32,630
의미하며, 메시지라는 개념은 스토리지와 

120
00:05:32,630 --> 00:05:34,740
같은 것을 포함하는 매우 넓은 의미입니다.

121
00:05:35,340 --> 00:05:37,365
결국 데이터를 저장하는 것은 한 장소에서 

122
00:05:37,365 --> 00:05:39,390
다른 장소로 메시지를 보내는 것이 아니라 

123
00:05:39,390 --> 00:05:41,680
과거에서 미래로 메시지를 보내는 것과 같습니다.

124
00:05:42,560 --> 00:05:45,020
이것이 설정입니다만, 자세히 알아보기 전에 

125
00:05:45,020 --> 00:05:47,789
해밍이 발견할 당시 해밍의 머릿속에 떠오른 관련 

126
00:05:47,789 --> 00:05:50,352
아이디어, 즉 단일 비트 오류를 감지할 수는 

127
00:05:50,352 --> 00:05:52,198
있지만 수정할 수는 없는 방법, 

128
00:05:52,198 --> 00:05:54,864
업계에서는 패리티 체크라고 알려진 방법에 대해 

129
00:05:54,864 --> 00:05:56,300
이야기할 필요가 있습니다.

130
00:05:56,880 --> 00:05:59,293
패리티 검사를 위해 발신자가 조정할 책임이 

131
00:05:59,293 --> 00:06:01,406
있는 하나의 비트만 분리하고 나머지는 

132
00:06:01,406 --> 00:06:03,820
자유롭게 메시지를 전달할 수 있도록 합니다.

133
00:06:04,880 --> 00:06:08,207
이 특수 비트의 유일한 역할은 메시지에 포함된 

134
00:06:08,207 --> 00:06:11,280
1의 총 개수가 짝수인지 확인하는 것입니다.

135
00:06:12,080 --> 00:06:14,911
예를 들어 지금 1의 총 개수가 7이므로 

136
00:06:14,911 --> 00:06:17,497
홀수이므로 발신자는 이 특별한 비트를 

137
00:06:17,497 --> 00:06:19,960
1로 뒤집어 짝수로 만들어야 합니다.

138
00:06:20,800 --> 00:06:23,667
그러나 블록이 이미 짝수인 1로 시작되었다면 

139
00:06:23,667 --> 00:06:26,420
이 특수 비트는 0으로 유지되었을 것입니다.

140
00:06:27,340 --> 00:06:29,974
이것은 매우 간단하고 믿을 수 없을 정도로 

141
00:06:29,974 --> 00:06:32,938
간단하지만, 메시지 어디에서나 변화의 아이디어를 

142
00:06:32,938 --> 00:06:36,121
추출하여 하나의 정보에 반영할 수 있는 매우 우아한 

143
00:06:36,121 --> 00:06:36,780
방법입니다.

144
00:06:37,500 --> 00:06:41,330
이 메시지에서 0에서 1 또는 1에서 0으로 

145
00:06:41,330 --> 00:06:45,773
조금이라도 뒤집히면 1의 총 개수가 짝수에서 홀수로 

146
00:06:45,773 --> 00:06:46,540
바뀝니다.

147
00:06:47,980 --> 00:06:51,257
따라서 수신자인 여러분이 이 메시지를 보고 홀수인 

148
00:06:51,257 --> 00:06:54,065
1이 표시되면 오류가 어디에서 발생했는지는 

149
00:06:54,065 --> 00:06:57,460
모르더라도 오류가 발생했음을 확실히 알 수 있습니다.

150
00:06:58,500 --> 00:07:00,758
전문 용어로는 비트 그룹에 짝수 또는 

151
00:07:00,758 --> 00:07:03,340
홀수 1이 있는지 여부를 패리티라고 합니다.

152
00:07:04,860 --> 00:07:06,786
숫자를 사용하여 패리티가 0 또는 1이라고 

153
00:07:06,786 --> 00:07:08,873
말할 수도 있는데, 이는 일반적으로 아이디어를 

154
00:07:08,873 --> 00:07:10,720
가지고 수학을 시작하면 더 도움이 됩니다.

155
00:07:11,220 --> 00:07:13,417
발신자가 패리티를 제어하기 위해 사용하는 

156
00:07:13,417 --> 00:07:15,520
이 특수 비트를 패리티 비트라고 합니다.

157
00:07:17,560 --> 00:07:20,312
수신자가 홀수 패리티를 본다고 해서 반드시 

158
00:07:20,312 --> 00:07:22,836
오류가 하나만 있었다는 의미는 아니며, 

159
00:07:22,836 --> 00:07:25,704
오류가 3개나 5개 또는 다른 홀수가 있었을 

160
00:07:25,704 --> 00:07:28,457
수도 있지만 0이 아니라는 것은 확실히 알 

161
00:07:28,457 --> 00:07:29,260
수 있습니다.

162
00:07:29,980 --> 00:07:32,999
반면에 오류가 2개, 또는 짝수 개의 오류가 

163
00:07:32,999 --> 00:07:35,777
있었다면 최종 1의 개수는 여전히 짝수가 

164
00:07:35,777 --> 00:07:38,797
되므로 수신자는 짝수 개수가 반드시 메시지에 

165
00:07:38,797 --> 00:07:42,300
오류가 없음을 의미한다고 완전히 확신할 수 없습니다.

166
00:07:42,840 --> 00:07:44,752
단 2번의 비트 플립으로 메시지가 

167
00:07:44,752 --> 00:07:47,771
엉망이 되는 것은 매우 취약하다고 불평할 수 있으며, 

168
00:07:47,771 --> 00:07:49,080
이는 전적으로 옳습니다.

169
00:07:49,700 --> 00:07:52,550
하지만 수신한 메시지가 발신자가 의도한 

170
00:07:52,550 --> 00:07:55,530
메시지인지 100% 확신할 수 있는 오류 

171
00:07:55,530 --> 00:07:58,900
감지 또는 수정 방법은 없다는 점에 유의하세요.

172
00:07:59,580 --> 00:08:01,533
결국, 충분한 무작위 노이즈는 순수한 

173
00:08:01,533 --> 00:08:03,393
우연에 의해 하나의 유효한 메시지를 

174
00:08:03,393 --> 00:08:05,440
다른 유효한 메시지로 바꿀 수 있습니다.

175
00:08:06,240 --> 00:08:10,248
대신, 특정 최대 오류 수까지 견고한 체계를 

176
00:08:10,248 --> 00:08:14,417
마련하거나 이와 같은 오탐 확률을 줄이는 것이 

177
00:08:14,417 --> 00:08:15,380
목표입니다.

178
00:08:16,260 --> 00:08:19,091
패리티 검사 자체는 매우 약하지만, 

179
00:08:19,091 --> 00:08:22,488
전체 메시지의 변경 아이디어를 단일 비트로 

180
00:08:22,488 --> 00:08:26,027
압축하면 더 정교한 계획을 위한 강력한 구성 

181
00:08:26,027 --> 00:08:27,160
요소가 됩니다.

182
00:08:27,940 --> 00:08:30,998
예를 들어, 해밍은 오류가 발생했다는 사실뿐만 

183
00:08:30,998 --> 00:08:33,940
아니라 오류가 발생한 위치를 파악하는 방법을 

184
00:08:33,940 --> 00:08:36,998
찾던 중, 전체 메시지가 아닌 신중하게 선택한 

185
00:08:36,998 --> 00:08:40,057
특정 하위 집합에 패리티 검사를 적용하면 단일 

186
00:08:40,057 --> 00:08:42,763
비트 오류의 위치를 파악하는 보다 정교한 

187
00:08:42,763 --> 00:08:45,940
일련의 질문을 할 수 있다는 사실을 발견했습니다.

188
00:08:46,680 --> 00:08:48,941
전체적인 느낌은 20개의 질문으로 구성된 게임을 

189
00:08:48,941 --> 00:08:51,202
하는 것과 비슷하며, 예 또는 아니오로 질문하여 

190
00:08:51,202 --> 00:08:53,380
가능성의 공간을 반으로 줄이는 것과 비슷합니다.

191
00:08:54,160 --> 00:08:56,770
예를 들어, 홀수 위치의 8비트에 대해서만 

192
00:08:56,770 --> 00:08:59,380
패리티 검사를 수행한다고 가정해 보겠습니다.

193
00:09:00,100 --> 00:09:02,887
그런 다음 오류가 감지되면 수신자에게 오류가 

194
00:09:02,887 --> 00:09:05,675
구체적으로 어디에 있는지, 즉 오류가 이상한 

195
00:09:05,675 --> 00:09:08,240
위치에 있다는 정보를 조금 더 알려줍니다.

196
00:09:08,940 --> 00:09:12,736
8비트 중 오류가 감지되지 않으면 오류가 전혀 

197
00:09:12,736 --> 00:09:16,240
없거나 짝수 위치 어딘가에 있다는 뜻입니다.

198
00:09:17,180 --> 00:09:19,452
패리티 검사를 비트의 절반으로 제한하면 

199
00:09:19,452 --> 00:09:22,035
효율성이 떨어질 것이라고 생각할 수 있지만, 

200
00:09:22,035 --> 00:09:24,204
잘 선택된 다른 검사와 함께 사용하면 

201
00:09:24,204 --> 00:09:27,200
직관적으로 훨씬 더 강력한 결과를 얻을 수 있습니다.

202
00:09:29,240 --> 00:09:31,661
실제로 패리티 검사를 설정하려면 전체 

203
00:09:31,661 --> 00:09:34,083
그룹의 패리티를 제어할 수 있는 특수 

204
00:09:34,083 --> 00:09:36,620
비트를 할당해야 한다는 점을 기억하세요.

205
00:09:37,480 --> 00:09:39,180
여기서는 위치 1을 선택하겠습니다.

206
00:09:39,720 --> 00:09:42,140
표시된 예시에서는 이 8비트의 패리티가 

207
00:09:42,140 --> 00:09:44,450
현재 홀수이므로 발신자가 해당 패리티 

208
00:09:44,450 --> 00:09:46,980
비트를 토글해야 하며, 현재는 짝수입니다.

209
00:09:47,940 --> 00:09:50,680
이것은 4번의 패리티 검사 중 1번만 수행합니다.

210
00:09:50,920 --> 00:09:53,537
두 번째 체크는 그리드의 오른쪽 

211
00:09:53,537 --> 00:09:56,300
절반에 있는 8비트 중 하나입니다.

212
00:09:56,680 --> 00:09:58,741
이번에는 2번 위치를 패리티 비트로 

213
00:09:58,741 --> 00:10:00,906
사용할 수 있으므로 이 8개의 비트는 

214
00:10:00,906 --> 00:10:03,070
이미 짝수 패리티를 가지며, 발신자는 

215
00:10:03,070 --> 00:10:06,060
2번 비트를 변경하지 않고 그대로 두어도 괜찮습니다.

216
00:10:07,020 --> 00:10:10,013
그런 다음 다른 쪽에서 수신자가 이 그룹의 패리티를 

217
00:10:10,013 --> 00:10:12,902
확인하여 이상하다는 것을 발견하면 오른쪽의 8비트 

218
00:10:12,902 --> 00:10:15,380
중 어딘가에 오류가 있음을 알 수 있습니다.

219
00:10:15,820 --> 00:10:18,081
그렇지 않으면 오류가 없거나 왼쪽 

220
00:10:18,081 --> 00:10:20,580
절반 어딘가에 오류가 있다는 뜻입니다.

221
00:10:21,120 --> 00:10:23,668
또는 두 개의 오류가 있었을 수도 있지만 지금은 

222
00:10:23,668 --> 00:10:26,500
전체 블록에 최대 하나의 오류가 있다고 가정하겠습니다.

223
00:10:26,940 --> 00:10:28,740
그 이상이면 모든 것이 완전히 무너집니다.

224
00:10:29,160 --> 00:10:31,113
다음 두 가지 점검 사항을 살펴보기 전에 이 

225
00:10:31,113 --> 00:10:32,989
첫 번째 두 가지 사항을 함께 고려했을 때 

226
00:10:32,989 --> 00:10:35,100
우리가 무엇을 할 수 있는지 잠시 생각해 보세요.

227
00:10:35,800 --> 00:10:37,573
홀수 열과 오른쪽 절반 열에서 

228
00:10:37,573 --> 00:10:39,660
오류를 감지했다고 가정해 보겠습니다.

229
00:10:40,200 --> 00:10:41,835
이는 반드시 마지막 열의 어딘가에 

230
00:10:41,835 --> 00:10:43,040
오류가 있음을 의미합니다.

231
00:10:43,820 --> 00:10:45,621
홀수 열에는 오류가 없지만 오른쪽 

232
00:10:45,621 --> 00:10:47,423
절반에 오류가 있는 경우 두 번째 

233
00:10:47,423 --> 00:10:49,700
열에서 마지막 열에 오류가 있다는 뜻입니다.

234
00:10:50,440 --> 00:10:52,163
마찬가지로 홀수 열에는 오류가 있지만 

235
00:10:52,163 --> 00:10:53,968
오른쪽 절반에는 없는 경우 두 번째 열 

236
00:10:53,968 --> 00:10:56,020
어딘가에 오류가 있다는 것을 알 수 있습니다.

237
00:10:56,020 --> 00:10:58,180
이 두 가지 패리티 검사에서 아무것도 

238
00:10:58,180 --> 00:11:00,444
감지되지 않으면 오류가 발생할 수 있는 

239
00:11:00,444 --> 00:11:03,120
유일한 위치가 가장 왼쪽 열에 있다는 뜻입니다.

240
00:11:03,340 --> 00:11:04,811
그러나 이는 단순히 오류가 전혀 

241
00:11:04,811 --> 00:11:06,120
없다는 의미일 수도 있습니다.

242
00:11:06,300 --> 00:11:08,353
두 번의 패리티 검사를 통해 열을 

243
00:11:08,353 --> 00:11:10,840
고정할 수 있다는 다소 지루한 설명입니다.

244
00:11:11,480 --> 00:11:13,640
여기에서 다음 내용을 짐작할 수 있을 것입니다.

245
00:11:13,800 --> 00:11:15,218
기본적으로 동일한 작업을 수행하지만 

246
00:11:15,218 --> 00:11:16,140
행에 대해서는 다릅니다.

247
00:11:16,440 --> 00:11:18,776
위치 4를 패리티 비트로 사용하여 홀수 

248
00:11:18,776 --> 00:11:20,900
행에 대한 패리티 검사가 수행됩니다.

249
00:11:21,380 --> 00:11:23,764
따라서 이 예제에서 해당 그룹은 이미 짝수 패리티를 

250
00:11:23,764 --> 00:11:25,820
가지고 있으므로 비트 4는 0으로 설정됩니다.

251
00:11:26,560 --> 00:11:28,869
마지막으로 아래쪽 두 행에서 8번 위치를 

252
00:11:28,869 --> 00:11:31,580
패리티 비트로 사용하여 패리티 검사를 수행합니다.

253
00:11:32,120 --> 00:11:34,470
이 경우 그룹에 균등한 패리티를 부여하기 위해 

254
00:11:34,470 --> 00:11:36,820
발신자가 비트 8을 켜야 하는 것처럼 보입니다.

255
00:11:37,700 --> 00:11:38,921
처음 두 번의 확인을 통해 열을 

256
00:11:38,921 --> 00:11:40,211
고정할 수 있는 것처럼, 다음 두 

257
00:11:40,211 --> 00:11:41,840
번의 확인을 통해 행을 고정할 수 있습니다.

258
00:11:42,880 --> 00:11:45,266
예를 들어, 전송 중에 3번 위치에서 

259
00:11:45,266 --> 00:11:47,540
오류가 발생했다고 가정해 보겠습니다.

260
00:11:48,180 --> 00:11:50,552
이것은 첫 번째 패리티 그룹에 영향을 미치고 두 

261
00:11:50,552 --> 00:11:52,836
번째 패리티 그룹에도 영향을 미치므로 수신자는 

262
00:11:52,836 --> 00:11:55,120
오른쪽 열 어딘가에 오류가 있다는 것을 알 수 

263
00:11:55,120 --> 00:11:55,560
있습니다.

264
00:11:56,100 --> 00:11:58,093
그러나 세 번째 그룹에는 영향을 미치지 

265
00:11:58,093 --> 00:12:00,540
않으며 네 번째 그룹에는 영향을 미치지 않습니다.

266
00:12:01,240 --> 00:12:03,196
그러면 수신자는 첫 번째 행까지, 

267
00:12:03,196 --> 00:12:05,049
즉 3번 위치를 의미하는 오류를 

268
00:12:05,049 --> 00:12:07,520
정확히 찾아내어 오류를 수정할 수 있습니다.

269
00:12:08,580 --> 00:12:11,491
이 네 가지 질문에 대한 답을 통해 특정 위치가 

270
00:12:11,491 --> 00:12:14,403
어디에 있든 항상 특정 위치를 파악할 수 있다고 

271
00:12:14,403 --> 00:12:17,100
스스로에게 확신할 수 있는 시간을 가져보세요.

272
00:12:17,720 --> 00:12:20,337
사실, 영리한 분이라면 이러한 질문과 이진수 

273
00:12:20,337 --> 00:12:23,060
계산 사이의 연관성을 알아차리실 수도 있습니다.

274
00:12:23,500 --> 00:12:26,009
그리고 만약 그렇다면 다시 한 번 강조하고, 

275
00:12:26,009 --> 00:12:28,920
잠시 멈추고, 연결 고리를 직접 그려보시기 바랍니다.

276
00:12:30,500 --> 00:12:33,109
패리티 비트 자체가 영향을 받으면 어떻게 

277
00:12:33,109 --> 00:12:36,060
되는지 궁금하다면, 직접 체험해 보시면 됩니다.

278
00:12:36,440 --> 00:12:39,059
이 네 가지 특수 비트 중 어떤 오류가 

279
00:12:39,059 --> 00:12:41,679
발생하면 다른 오류와 마찬가지로 어떻게 

280
00:12:41,679 --> 00:12:44,180
추적할 수 있을지 잠시 생각해 보세요.

281
00:12:47,060 --> 00:12:48,985
결국 우리가 원하는 것은 메시지 비트를 

282
00:12:48,985 --> 00:12:50,999
보호하는 것이므로 오류 정정 비트는 그냥 

283
00:12:50,999 --> 00:12:53,100
따라다니는 것이므로 크게 중요하지 않습니다.

284
00:12:53,600 --> 00:12:55,893
그러나 이러한 비트도 보호하는 것은 계획에서 

285
00:12:55,893 --> 00:12:57,820
자연스럽게 부산물로 빠지는 부분입니다.

286
00:12:59,200 --> 00:13:00,781
이 기능이 어떻게 확장될지 예상해보는 

287
00:13:00,781 --> 00:13:01,760
것도 재미있을 것입니다.

288
00:13:02,300 --> 00:13:05,878
예를 들어 256비트 크기의 블록을 사용하여 특정 

289
00:13:05,878 --> 00:13:09,073
지점을 찾아내는 경우, 예 또는 아니오 질문 

290
00:13:09,073 --> 00:13:12,780
8개만 있으면 특정 지점을 이진 검색할 수 있습니다.

291
00:13:15,640 --> 00:13:17,980
각 질문은 적절한 패리티 검사를 설정하기 위해 

292
00:13:17,980 --> 00:13:20,500
단 하나의 비트만 포기하면 된다는 점을 기억하세요.

293
00:13:23,160 --> 00:13:24,687
이미 보신 분들도 계시겠지만, 

294
00:13:24,687 --> 00:13:26,664
이러한 질문이 무엇인지 체계적으로 찾는 

295
00:13:26,664 --> 00:13:29,360
방법에 대해서는 나중에 1~2분 정도에 설명하겠습니다.

296
00:13:29,880 --> 00:13:31,770
이 스케치만으로도 우리가 개발 중인 제품의 

297
00:13:31,770 --> 00:13:33,660
효율성을 충분히 이해할 수 있기를 바랍니다.

298
00:13:33,660 --> 00:13:35,861
첫 번째는 강조 표시된 8개의 패리티 

299
00:13:35,861 --> 00:13:38,378
비트를 제외하고는 원하는 메시지나 데이터를 

300
00:13:38,378 --> 00:13:41,000
전달할 수 있는 어떤 것이든 될 수 있습니다.

301
00:13:41,720 --> 00:13:44,107
8비트는 나머지 메시지에 의해 완전히 

302
00:13:44,107 --> 00:13:46,040
결정된다는 점에서 중복되지만, 

303
00:13:46,040 --> 00:13:48,769
단순히 메시지 전체를 복사하는 것보다 훨씬 

304
00:13:48,769 --> 00:13:50,020
스마트한 방식입니다.

305
00:13:53,600 --> 00:13:56,040
그럼에도 불구하고 거의 포기하지 않고 단일 

306
00:13:56,040 --> 00:13:58,380
비트 오류를 식별하고 수정할 수 있습니다.

307
00:13:59,200 --> 00:14:00,400
뭐, 거의요.

308
00:14:00,960 --> 00:14:04,802
여기서 한 가지 문제는 4개의 패리티 검사 중 어느 

309
00:14:04,802 --> 00:14:07,187
하나도 오류를 감지하지 못하면, 

310
00:14:07,187 --> 00:14:11,162
즉 특별히 선택된 8비트의 하위 집합이 모두 발신자의 

311
00:14:11,162 --> 00:14:14,872
의도대로 짝수 패리티를 가지면 오류가 전혀 없거나 

312
00:14:14,872 --> 00:14:16,860
0으로 좁혀진다는 것입니다.

313
00:14:17,740 --> 00:14:21,007
네 가지 예 또는 아니오 질문으로 패리티 검사에 

314
00:14:21,007 --> 00:14:23,307
16가지 결과가 나올 수 있는데, 

315
00:14:23,307 --> 00:14:26,453
처음에는 블록의 16개 위치 중 1개를 정확히 

316
00:14:26,453 --> 00:14:29,963
찾아내는 데는 완벽해 보이지만 17번째 결과인 오류 

317
00:14:29,963 --> 00:14:31,900
없음 조건도 전달해야 합니다.

318
00:14:33,020 --> 00:14:35,160
여기서 해결책은 사실 매우 간단합니다. 

319
00:14:35,160 --> 00:14:37,300
0번째 비트는 완전히 잊어버리면 됩니다.

320
00:14:37,840 --> 00:14:39,713
따라서 네 번의 패리티 검사를 수행한 

321
00:14:39,713 --> 00:14:41,675
결과 모두 짝수인 것을 확인하면 오류가 

322
00:14:41,675 --> 00:14:43,460
없다는 것을 분명히 알 수 있습니다.

323
00:14:44,240 --> 00:14:47,158
즉, 16비트 블록으로 작업하는 대신 15비트 

324
00:14:47,158 --> 00:14:49,852
블록으로 작업하며, 11개 비트는 메시지를 

325
00:14:49,852 --> 00:14:53,220
전달할 수 있고 4개 비트는 중복성을 위해 사용됩니다.

326
00:14:53,780 --> 00:14:56,231
이를 통해 이제 업계에서는 15-11 

327
00:14:56,231 --> 00:14:58,800
해밍 코드라고 부르는 코드가 생겼습니다.

328
00:14:59,860 --> 00:15:03,019
즉, 블록 크기가 2의 깨끗한 제곱인 것이 좋으며, 

329
00:15:03,019 --> 00:15:05,743
0번째 비트를 유지하면서 약간의 추가 작업을 

330
00:15:05,743 --> 00:15:08,140
수행할 수 있는 현명한 방법이 있습니다.

331
00:15:08,700 --> 00:15:12,002
이를 전체 블록에서 패리티 비트로 사용하면 수정할 

332
00:15:12,002 --> 00:15:15,540
수는 없지만 실제로 2비트 오류를 감지할 수 있습니다.

333
00:15:16,160 --> 00:15:16,820
작동 방식은 다음과 같습니다.

334
00:15:17,180 --> 00:15:19,918
4개의 특수 오류 수정 비트를 설정한 후, 

335
00:15:19,918 --> 00:15:22,657
일반 패리티 검사처럼 전체 블록의 패리티가 

336
00:15:22,657 --> 00:15:24,940
균등하도록 0번째 비트를 설정합니다.

337
00:15:25,700 --> 00:15:28,264
이제 단일 비트 오류가 발생하면 전체 블록의 

338
00:15:28,264 --> 00:15:30,727
패리티가 홀수로 전환되지만, 네 가지 오류 

339
00:15:30,727 --> 00:15:33,600
수정 검사 덕분에 어쨌든 이를 포착할 수 있습니다.

340
00:15:34,160 --> 00:15:37,877
그러나 오류가 두 번 발생하면 전체 패리티는 다시 

341
00:15:37,877 --> 00:15:41,595
짝수로 전환되지만 수신자는 네 번의 패리티 검사로 

342
00:15:41,595 --> 00:15:45,180
인해 최소한의 오류가 발생했음을 알 수 있습니다.

343
00:15:45,180 --> 00:15:47,758
따라서 전체적으로 패리티가 균등하지만 다른 

344
00:15:47,758 --> 00:15:50,121
검사에서 0이 아닌 것이 발견되면 최소 

345
00:15:50,121 --> 00:15:52,700
두 가지 오류가 발생했음을 알 수 있습니다.

346
00:15:53,520 --> 00:15:54,000
영리하지 않나요?

347
00:15:54,300 --> 00:15:56,545
2비트 오류를 수정할 수는 없지만, 

348
00:15:56,545 --> 00:15:58,902
조금 귀찮은 0비트를 다시 작동시키는 

349
00:15:58,902 --> 00:16:01,260
것만으로도 오류를 감지할 수 있습니다.

350
00:16:02,260 --> 00:16:03,925
이는 확장된 해밍 코드라고 하는 

351
00:16:03,925 --> 00:16:05,220
매우 표준적인 코드입니다.

352
00:16:06,540 --> 00:16:08,557
기술적으로 말하자면, 적어도 16비트 

353
00:16:08,557 --> 00:16:10,574
블록의 예시에서는 해밍 코드가 어떻게 

354
00:16:10,574 --> 00:16:12,880
작동하는지에 대한 완전한 설명을 얻었습니다.

355
00:16:12,880 --> 00:16:15,815
하지만 하나의 예제를 처음부터 끝까지 직접 

356
00:16:15,815 --> 00:16:18,384
해보면서 이해도를 점검하고 여기까지의 

357
00:16:18,384 --> 00:16:21,320
내용을 다지는 것이 더 만족스러울 것입니다.

358
00:16:22,080 --> 00:16:24,300
직접 확인하실 수 있도록 제가 함께 설명해드리겠습니다.

359
00:16:25,120 --> 00:16:28,014
공간에 걸쳐 번역하는 문자 그대로의 메시지이든, 

360
00:16:28,014 --> 00:16:30,801
시간이 지남에 따라 저장하려는 일부 데이터이든 

361
00:16:30,801 --> 00:16:33,802
메시지를 설정하려면 먼저 메시지를 11비트 청크로 

362
00:16:33,802 --> 00:16:34,660
나눠야 합니다.

363
00:16:35,580 --> 00:16:39,760
각 청크는 오류 방지 16비트 블록으로 패키징됩니다.

364
00:16:39,760 --> 00:16:43,220
이 사례를 예로 들어 실제로 해결해 보겠습니다.

365
00:16:43,740 --> 00:16:44,940
어서, 실제로 해보세요!

366
00:16:45,220 --> 00:16:47,020
잠시 멈추고 이 블록을 조합해 보겠습니다.

367
00:16:52,720 --> 00:16:53,680
자, 준비됐나요?

368
00:16:54,240 --> 00:16:57,228
0번 자리와 2의 다른 제곱은 오류 수정용으로 

369
00:16:57,228 --> 00:17:00,216
예약되어 있으므로, 나머지 모든 자리에 메시지 

370
00:17:00,216 --> 00:17:03,320
비트를 순서대로 배치하는 것부터 시작해야 합니다.

371
00:17:05,339 --> 00:17:08,641
이 그룹은 이미 짝수 패리티를 가져야 하므로 

372
00:17:08,641 --> 00:17:12,339
위치 1의 패리티 비트를 0으로 설정했어야 합니다.

373
00:17:13,020 --> 00:17:15,509
다음 그룹은 홀수 패리티로 시작하므로 

374
00:17:15,509 --> 00:17:17,880
패리티 비트를 1로 설정해야 합니다.

375
00:17:19,160 --> 00:17:21,754
그 이후의 그룹은 홀수 패리티로 시작하므로 

376
00:17:21,754 --> 00:17:24,240
다시 패리티 비트를 1로 설정해야 합니다.

377
00:17:24,780 --> 00:17:27,596
또한 마지막 그룹은 홀수 패리티를 가지므로 

378
00:17:27,596 --> 00:17:30,060
8번 위치의 비트를 1로 설정했습니다.

379
00:17:31,300 --> 00:17:34,426
그리고 마지막 단계로, 이제 전체 블록이 짝수 

380
00:17:34,426 --> 00:17:37,433
패리티를 가지므로 가장 중요한 패리티 비트인 

381
00:17:37,433 --> 00:17:40,320
비트 번호 0을 0으로 설정할 수 있습니다.

382
00:17:41,340 --> 00:17:44,799
따라서 이 블록이 전송되면 4개의 특수 하위 집합과 

383
00:17:44,799 --> 00:17:48,140
블록 전체의 패리티는 모두 짝수, 즉 0이 됩니다.

384
00:17:48,820 --> 00:17:50,740
연습의 두 번째 부분으로, 여러분이 

385
00:17:50,740 --> 00:17:52,180
리시버 역할을 해보겠습니다.

386
00:17:53,480 --> 00:17:56,300
물론 이 메시지가 무엇인지 모르는 분도 계실 것이고, 

387
00:17:56,300 --> 00:17:58,087
외우신 분도 계실 수도 있겠지만, 

388
00:17:58,087 --> 00:17:59,780
그렇지 않다고 가정해 보겠습니다.

389
00:18:00,020 --> 00:18:02,670
제가 할 일은 해당 블록의 비트 중 0, 

390
00:18:02,670 --> 00:18:05,320
1 또는 2를 변경한 다음 제가 한 일이 

391
00:18:05,320 --> 00:18:07,740
무엇인지 알아내도록 요청하는 것입니다.

392
00:18:08,260 --> 00:18:10,810
다시 한 번 잠시 멈춰서 문제를 해결해 보세요.

393
00:18:18,790 --> 00:18:21,691
이제 수신자는 첫 번째 패리티 그룹을 

394
00:18:21,691 --> 00:18:25,008
확인하여 짝수임을 알 수 있으므로 존재하는 

395
00:18:25,008 --> 00:18:27,910
오류는 모두 짝수 열에 있어야 합니다.

396
00:18:29,690 --> 00:18:33,360
다음 검사에서는 홀수 숫자가 표시되어 오류가 하나 

397
00:18:33,360 --> 00:18:37,030
이상 있음을 알려주고 특정 열로 범위를 좁혀줍니다.

398
00:18:38,550 --> 00:18:41,790
세 번째 점검은 짝수로, 가능성을 더욱 줄여줍니다.

399
00:18:42,650 --> 00:18:44,650
그리고 마지막 패리티 검사는 홀수이며, 

400
00:18:44,650 --> 00:18:46,831
아래쪽 어딘가에 오류가 있음을 알려주는데, 

401
00:18:46,831 --> 00:18:49,013
지금쯤이면 10번 위치에 오류가 있음을 알 

402
00:18:49,013 --> 00:18:49,650
수 있습니다.

403
00:18:51,490 --> 00:18:54,561
게다가 전체 블록의 패리티가 홀수이기 때문에 두 번이 

404
00:18:54,561 --> 00:18:57,530
아닌 한 번의 뒤집기가 있었다는 확신을 갖게 됩니다.

405
00:18:58,070 --> 00:18:59,970
3개 이상이면 모든 베팅이 종료됩니다.

406
00:19:01,310 --> 00:19:04,546
10번 비트를 수정한 후, 수정에 사용되지 

407
00:19:04,546 --> 00:19:07,917
않은 11번 비트를 빼면 원래 메시지의 관련 

408
00:19:07,917 --> 00:19:10,884
세그먼트가 나오는데, 되감아 비교해보면 

409
00:19:10,884 --> 00:19:14,390
실제로 예제에서 시작한 것과 정확히 일치합니다.

410
00:19:15,710 --> 00:19:18,406
이제 이 모든 작업을 직접 수행하는 방법을 알았으니, 

411
00:19:18,406 --> 00:19:20,743
이 모든 로직의 핵심 부분을 Python 코드 

412
00:19:20,743 --> 00:19:23,170
한 줄로 수행할 수 있는 방법을 보여드리겠습니다.

413
00:19:23,870 --> 00:19:26,865
제가 아직 말씀드리지 않은 것은 이 알고리즘이 얼마나 

414
00:19:26,865 --> 00:19:29,762
우아한지, 기계가 오류 위치를 가리키도록 하는 것이 

415
00:19:29,762 --> 00:19:32,358
얼마나 간단한지, 어떻게 체계적으로 확장할 수 

416
00:19:32,358 --> 00:19:35,354
있는지, 이 모든 것을 여러 번의 개별 패리티 검사가 

417
00:19:35,354 --> 00:19:38,250
아닌 하나의 단일 작업으로 구성할 수 있는지에 대한 

418
00:19:38,250 --> 00:19:38,750
것입니다.

419
00:19:39,430 --> 00:19:41,310
무슨 말인지 알아보려면 2부에서 함께하세요.

