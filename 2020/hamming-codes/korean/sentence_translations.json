[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing?",
  "translatedText": "CD나 DVD를 긁으면서도 저장되어 있는 내용을 재생할 수 있는 방법에 대해 궁금한 적이 있습니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.62,
  "end": 10.1
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors.",
  "translatedText": "스크래치는 실제로 디스크의 1과 0에 영향을 미치므로 저장된 데이터와 다른 데이터를 읽습니다. 그러나 실제로 긁지 않는 한 읽은 비트는 인코딩된 것과 정확히 동일한 파일로 디코딩됩니다. 모든 오류에도 불구하고 비트 복사용 비트입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 10.9,
  "end": 27.44
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors.",
  "translatedText": "오류에 탄력적인 방식으로 데이터를 저장하고 데이터를 전송할 수 있게 해주는 수많은 수학적 영리함이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 27.44,
  "end": 36.66
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this.",
  "translatedText": "글쎄요, 사실 이 일을 할 수 있는 방법을 찾는 데는 그렇게 많은 영리함이 필요하지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 37.52,
  "end": 41.6
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s.",
  "translatedText": "비디오, 사운드, 텍스트, 일부 코드, 이미지 등 모든 파일은 궁극적으로 1과 0의 시퀀스입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 42.06,
  "end": 50.38
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit.",
  "translatedText": "그리고 뒤집힌 비트를 수정하는 간단한 전략은 각 비트의 복사본 3개를 저장하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 50.68,
  "end": 56.0
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy.",
  "translatedText": "그런 다음 이 파일을 읽는 기계는 이 세 개의 복사본을 비교하고 불일치가 있을 때마다 항상 3개 중 가장 좋은 2개를 선택할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 57.58,
  "end": 64.06
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy.",
  "translatedText": "하지만 이는 공간의 2/3를 중복성을 위해 사용한다는 의미입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 67.16,
  "end": 70.86
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped.",
  "translatedText": "그리고 그럼에도 불구하고, 그 모든 공간이 포기되었음에도 불구하고, 한 비트 이상이 뒤집힐 경우 무슨 일이 일어날지에 대한 강력한 보장은 없습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 71.48,
  "end": 77.24
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible.",
  "translatedText": "훨씬 더 흥미로운 질문은 가능한 한 적은 공간을 포기하면서 오류를 수정할 수 있도록 만드는 방법입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 77.98,
  "end": 84.02
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9!",
  "translatedText": "예를 들어, 이 비디오에서 배우게 될 방법을 사용하면 각 블록이 9비트, 9! 를 사용하는 256비트 블록에 데이터를 저장할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 84.52,
  "end": 93.36
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want.",
  "translatedText": "일종의 중복성 역할을 하며 나머지 247비트는 원하는 의미 있는 메시지나 데이터를 자유롭게 전달할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 93.76,
  "end": 100.3
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it.",
  "translatedText": "그리고 여기서 비트가 반전되는 경우에도 이 블록만 보고 기계는 오류가 있었음을 식별하고 오류가 발생한 위치를 정확하게 식별하여 오류를 수정하는 방법을 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 100.9,
  "end": 112.66
 },
 {
  "input": "And honestly, that feels like magic.",
  "translatedText": "그리고 솔직히 그것은 마술처럼 느껴집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 112.66,
  "end": 114.62
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them.",
  "translatedText": "그리고 이 특정 방식의 경우 두 비트가 뒤집히면 컴퓨터는 적어도 두 개의 오류가 있음을 감지할 수 있지만 이를 수정하는 방법은 알 수 없습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 115.44,
  "end": 122.86
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes.",
  "translatedText": "다양한 크기의 블록에 대해 이것이 어떻게 확장되는지에 대해서는 나중에 조금 이야기하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 123.52,
  "end": 126.9
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes.",
  "translatedText": "이와 같은 오류를 수정하는 방법은 합리적으로 오류 수정 코드로 알려져 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 127.86,
  "end": 132.9
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day.",
  "translatedText": "지난 세기 대부분 동안 이 분야는 우리가 매일 사용하는 장치에 통합되는 놀라울 정도로 심오한 수학의 풍부한 소스였습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.66,
  "end": 141.94
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code.",
  "translatedText": "여기서 목표는 해밍 코드(Hamming code)로 알려진 초기 예제 중 하나를 철저하게 이해하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 142.84,
  "end": 148.66
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there.",
  "translatedText": "그건 그렇고, 제가 이 영상의 구조에 대해 생각하는 방식은 가능한 한 직접적으로 설명하는 것이 아니라, 여기저기서 약간의 부드러운 안내를 받아 여러분 스스로 영상을 만들어내도록 유도하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 149.52,
  "end": 159.82
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you.",
  "translatedText": "따라서 어느 시점에서 그것이 어디로 가는지 알 수 있을 것 같으면 그 순간을 잠시 멈추고 내가 말하기 전에 그 계획이 어떻게 될지 적극적으로 예측하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 160.12,
  "end": 166.72
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying.",
  "translatedText": "또한 하드웨어 수준까지 이해를 돕고 싶다면 Ben Eater가 이 영상과 함께 실제로 브레드보드에 해밍 코드를 구현하는 방법을 보여주는 영상을 제작했는데 매우 만족스럽습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 167.24,
  "end": 178.24
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming.",
  "translatedText": "해밍 코드는 Reed-Solomon 알고리즘과 같은 최신 코드만큼 널리 사용되지는 않지만 이 작업이 처음에는 얼마나 불가능하다고 느껴지는지와 일단 얼마나 합리적으로 보이는지 사이에는 어떤 마법이 있습니다. 해밍에 대해 배웁니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 179.3,
  "end": 193.0
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages.",
  "translatedText": "오류 수정의 기본 원칙은 가능한 모든 메시지의 광대한 공간에서 일부 하위 집합만 유효한 메시지로 간주된다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 193.72,
  "end": 202.18
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words.",
  "translatedText": "비유하자면, 철자가 올바른 단어와 철자가 틀린 단어를 생각해 보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.8,
  "end": 206.94
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo.",
  "translatedText": "유효한 메시지가 변경될 때마다 수신자는 오타로 인해 발생할 수 있는 가장 가까운 유효한 이웃으로 보이는 내용을 수정할 책임이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 208.9,
  "end": 217.34
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness.",
  "translatedText": "하지만 이와 같은 메시지를 효율적으로 분류하기 위한 구체적인 알고리즘을 생각해 내려면 어느 정도 영리함이 필요합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.22,
  "end": 224.06
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to.",
  "translatedText": "이야기는 젊은 Richard Hamming이 Bell Labs에서 일하고 있던 1940년대에 시작됩니다. 그의 작업 중 일부는 그가 접근할 수 없었던 매우 크고 값비싼 펀치 카드 컴퓨터를 사용하는 것과 관련이 있었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 226.78,
  "end": 237.42
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread.",
  "translatedText": "그리고 그가 계속해서 적용한 프로그램은 계속 실패했습니다. 왜냐하면 때때로 약간의 오해가 있기 때문입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 237.8,
  "end": 242.4
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code.",
  "translatedText": "좌절은 발명의 도가니이기 때문에 그는 너무 지쳐서 세계 최초의 오류 정정 코드를 발명했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.12,
  "end": 248.42
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them.",
  "translatedText": "Hamming 코드를 구성하는 방법에는 여러 가지가 있지만 먼저 Hamming 자신이 생각한 방식을 살펴보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 249.06,
  "end": 255.38
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits.",
  "translatedText": "간단하지만 너무 단순하지는 않은 16비트 블록의 예를 사용해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 256.52,
  "end": 260.94
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15.",
  "translatedText": "이 비트의 위치에 0부터 15까지 번호를 매깁니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 261.82,
  "end": 264.74
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy.",
  "translatedText": "우리가 저장하려는 실제 데이터는 이러한 비트 중 12개만 구성할 예정이며 위치 중 4개는 일종의 중복으로 예약되어 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.62,
  "end": 273.0
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data.",
  "translatedText": "여기서 중복이라는 단어는 단순히 복사를 의미하는 것이 아닙니다. 결국 이 4비트는 데이터를 맹목적으로 복사할 충분한 공간을 제공하지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 273.9,
  "end": 280.04
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience.",
  "translatedText": "대신, 새로운 정보를 추가하는 것이 아니라 탄력성을 추가하는 훨씬 더 미묘하고 영리한 종류의 중복성이 필요합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 280.72,
  "end": 287.28
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end.",
  "translatedText": "이 4개의 특수 비트가 끝 부분이나 그와 유사한 방식으로 함께 멋지게 패키지되어 있을 것으로 기대할 수 있지만, 보시다시피 2의 거듭제곱인 위치에 배치하면 마지막에는 정말 우아한 작업이 가능해집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 288.6,
  "end": 299.62
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks.",
  "translatedText": "또한 더 큰 블록에 대해 이것이 어떻게 확장되는지에 대한 약간의 힌트를 줄 수도 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.2,
  "end": 303.54
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now.",
  "translatedText": "또한 기술적으로는 단지 11비트의 데이터로 끝나므로 위치 0에서 일어나는 일에 약간의 차이가 있다는 것을 알 수 있지만 지금은 그것에 대해 걱정하지 마십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 304.9,
  "end": 313.26
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors.",
  "translatedText": "다른 오류 수정 알고리즘과 마찬가지로 여기에는 4개의 특수 비트 설정을 담당하는 송신자, 일종의 검사 수행 및 오류 수정을 담당하는 수신자라는 두 명의 플레이어가 참여합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 314.14,
  "end": 325.54
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage.",
  "translatedText": "물론, 보낸 사람과 받는 사람이라는 단어는 실제로 모든 확인을 수행하는 기계나 소프트웨어를 의미하며, 메시지라는 개념은 저장소와 같은 것을 포함하여 매우 광범위하게 의미됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 326.3,
  "end": 334.74
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another.",
  "translatedText": "결국 데이터를 저장한다는 것은 한 장소에서 다른 장소로 메시지를 보내는 것이 아니라 과거에서 미래로 메시지를 보내는 것과 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 335.34,
  "end": 341.68
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check.",
  "translatedText": "이것이 설정입니다. 그러나 본격적으로 시작하기 전에 Hamming이 발견 당시 마음에 떠올랐던 관련 아이디어에 대해 이야기해야 합니다. 이 방법은 단일 비트 오류를 감지할 수 있지만 이를 수정하지는 않는 방법입니다. 비즈니스에서는 패리티 검사로 사용됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 342.56,
  "end": 356.3
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message.",
  "translatedText": "패리티 검사를 위해 송신자가 튜닝을 담당하는 단일 비트 하나만 분리하고 나머지는 자유롭게 메시지를 전달할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 356.88,
  "end": 363.82
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number.",
  "translatedText": "이 특수 비트의 유일한 역할은 메시지에 있는 1의 총 개수가 짝수인지 확인하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 364.88,
  "end": 371.28
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even.",
  "translatedText": "예를 들어 지금 당장 1의 총 개수는 7입니다. 홀수입니다. 따라서 송신자는 해당 특수 비트를 1로 뒤집어서 짝수로 만들어야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 372.08,
  "end": 379.96
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0.",
  "translatedText": "그러나 블록이 이미 짝수인 1로 시작했다면 이 특수 비트는 0으로 유지되었을 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 380.8,
  "end": 386.42
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information.",
  "translatedText": "이것은 매우 간단하고 믿을 수 없을 정도로 단순하지만 단일 정보에 반영되도록 메시지의 어느 위치에서나 변경 아이디어를 정제하는 믿을 수 없을 정도로 우아한 방법입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 387.34,
  "end": 396.78
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd.",
  "translatedText": "이 메시지의 비트가 0에서 1로 또는 1에서 0으로 반전되면 1의 총 개수가 짝수에서 홀수로 변경됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 397.5,
  "end": 406.54
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was.",
  "translatedText": "따라서 수신자인 경우 이 메시지를 보고 홀수의 1이 표시되면 오류가 어디에 있었는지 전혀 모르더라도 오류가 발생했음을 확실히 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 407.98,
  "end": 417.46
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity.",
  "translatedText": "전문 용어로 비트 그룹에 짝수 또는 홀수 개의 1이 있는지 여부를 패리티라고 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 418.5,
  "end": 423.34
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea.",
  "translatedText": "숫자를 사용하여 패리티가 0 또는 1이라고 말할 수도 있습니다. 이는 일반적으로 아이디어로 수학을 시작하면 더 유용합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 424.86,
  "end": 430.72
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit.",
  "translatedText": "그리고 송신자가 패리티를 제어하기 위해 사용하는 이 특수 비트를 패리티 비트라고 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 431.22,
  "end": 435.52
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0.",
  "translatedText": "그리고 실제로, 수신자가 홀수 패리티를 본다고 해서 반드시 하나의 오류가 있었다는 의미는 아니며, 3개 또는 5개 또는 기타 홀수 오류가 있었을 수도 있지만 수신자는 확실히 알 수 있습니다. 0이 아니었다는 거죠.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 437.56,
  "end": 449.26
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free.",
  "translatedText": "반면에 2개의 오류가 있거나 오류 수가 짝수인 경우 1의 최종 개수는 여전히 짝수이므로 수신자는 짝수 개수가 반드시 메시지에 오류가 없음을 의미한다는 완전한 확신을 가질 수 없습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 449.98,
  "end": 462.3
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right.",
  "translatedText": "당신은 단지 2비트 플립만으로 엉망이 된 메시지가 꽤 약하다고 불평할 수도 있고, 당신의 말이 절대적으로 옳을 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 462.84,
  "end": 469.08
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended.",
  "translatedText": "그러나 수신한 메시지가 보낸 사람이 의도한 메시지인지 100% 확신할 수 있는 오류 감지 또는 수정 방법은 없다는 점을 명심하세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 469.7,
  "end": 478.9
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance.",
  "translatedText": "결국 충분한 무작위 노이즈로 인해 항상 하나의 유효한 메시지가 순전히 우연에 의해 다른 유효한 메시지로 바뀔 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 479.58,
  "end": 485.44
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this.",
  "translatedText": "대신 목표는 특정 최대 오류 수까지 견고한 체계를 마련하거나 이와 같은 거짓 긍정 가능성을 줄이는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 486.24,
  "end": 495.38
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes.",
  "translatedText": "패리티 검사 자체는 매우 약하지만 전체 메시지에 대한 변경 아이디어를 단일 비트로 압축함으로써 우리에게 제공하는 것은 보다 정교한 체계를 위한 강력한 구성 요소입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 496.26,
  "end": 507.16
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error.",
  "translatedText": "예를 들어, Hamming은 오류가 발생한 위치뿐만 아니라 오류가 발생한 위치를 식별하는 방법을 찾고 있을 때 그의 핵심 통찰력은 전체 메시지가 아닌 일부 신중하게 선택된 특정 하위 집합에 일부 패리티 검사를 적용하면 다음과 같이 질문할 수 있다는 것입니다. 단일 비트 오류의 위치를 찾아내는 보다 세련된 일련의 질문입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 507.94,
  "end": 525.94
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half.",
  "translatedText": "전체적인 느낌은 가능성의 공간을 절반으로 줄이는 예 또는 아니오 질문을 하는 20개의 질문 게임을 하는 것과 약간 비슷합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 526.68,
  "end": 533.38
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions.",
  "translatedText": "예를 들어, 모든 홀수 위치인 이 8비트에 대해서만 패리티 검사를 수행한다고 가정해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 534.16,
  "end": 539.38
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position.",
  "translatedText": "그런 다음 오류가 감지되면 수신자에게 오류가 구체적으로 어디에 있는지, 즉 오류가 이상한 위치에 있는지에 대한 추가 정보를 제공합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 540.1,
  "end": 548.24
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions.",
  "translatedText": "8비트 중에서 오류가 감지되지 않으면 오류가 전혀 없거나 짝수 위치에 있다는 의미입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 548.94,
  "end": 556.24
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful.",
  "translatedText": "패리티 검사를 비트의 절반으로 제한하면 효율성이 떨어진다고 생각할 수도 있지만, 잘 선택된 다른 검사와 함께 수행하면 직관에 반하여 훨씬 더 강력한 기능을 제공합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 557.18,
  "end": 567.2
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group.",
  "translatedText": "실제로 패리티 검사를 설정하려면 전체 그룹의 패리티를 제어할 수 있는 특수 비트를 지정해야 한다는 점을 기억하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.24,
  "end": 576.62
 },
 {
  "input": "Here let's just choose position 1.",
  "translatedText": "여기서는 위치 1을 선택하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 577.48,
  "end": 579.18
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even.",
  "translatedText": "표시된 예에서 이 8비트의 패리티는 현재 홀수이므로 송신자가 해당 패리티 비트를 전환해야 하며 이제는 짝수입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.72,
  "end": 586.98
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do.",
  "translatedText": "이것은 우리가 수행할 패리티 검사 4개 중 1개에 불과합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 587.94,
  "end": 590.68
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here.",
  "translatedText": "두 번째 검사는 적어도 우리가 여기에 그린 것처럼 그리드의 오른쪽 절반에 있는 8비트 중 하나입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 590.92,
  "end": 596.3
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged.",
  "translatedText": "이번에는 위치 2를 패리티 비트로 사용할 수 있으므로 이 8비트는 이미 짝수 패리티를 가지며 송신자는 해당 비트 번호 2를 변경하지 않고 그대로 두는 것이 좋다고 느낄 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 596.68,
  "end": 606.06
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right.",
  "translatedText": "그런 다음 다른 쪽 끝에서 수신자가 이 그룹의 패리티를 확인하고 그것이 이상하다는 것을 발견하면 오류가 오른쪽에 있는 8비트 중 어딘가에 있다는 것을 알게 될 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 607.02,
  "end": 615.38
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half.",
  "translatedText": "그렇지 않으면 오류가 없거나 오류가 왼쪽 어딘가에 있음을 의미합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 615.82,
  "end": 620.58
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block.",
  "translatedText": "아니면 두 개의 오류가 있었을 수도 있지만 지금은 전체 블록에 최대 하나의 오류가 있다고 가정하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 621.12,
  "end": 626.5
 },
 {
  "input": "Things break down completely for more than that.",
  "translatedText": "그 이상으로 상황이 완전히 무너집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 626.94,
  "end": 628.74
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together.",
  "translatedText": "여기에서 다음 두 가지 확인 사항을 살펴보기 전에 처음 두 가지 확인 사항을 함께 고려할 때 무엇을 할 수 있는지 잠시 생각해 보십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 629.16,
  "end": 635.1
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half.",
  "translatedText": "홀수 열과 오른쪽 절반 사이에서 오류를 발견했다고 가정해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 635.8,
  "end": 639.66
 },
 {
  "input": "It necessarily means the error is somewhere in the last column.",
  "translatedText": "이는 반드시 오류가 마지막 열 어딘가에 있음을 의미합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 640.2,
  "end": 643.04
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column.",
  "translatedText": "홀수 열에 오류가 없었지만 오른쪽 절반에 오류가 있는 경우 이는 마지막 열에서 두 번째에 있다는 것을 의미합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 643.82,
  "end": 649.7
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column.",
  "translatedText": "마찬가지로 홀수 열에는 오류가 있지만 오른쪽 절반에는 오류가 없으면 두 번째 열 어딘가에 오류가 있다는 것을 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 650.44,
  "end": 656.02
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column.",
  "translatedText": "그리고 두 패리티 검사 중 어느 것도 아무것도 감지하지 못하면 오류가 있을 수 있는 유일한 위치는 가장 왼쪽 열에 있다는 의미입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 656.02,
  "end": 663.12
 },
 {
  "input": "But it also might simply mean there's no error at all.",
  "translatedText": "하지만 이는 단순히 오류가 전혀 없다는 의미일 수도 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 663.34,
  "end": 666.12
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column.",
  "translatedText": "이는 두 개의 패리티 검사를 통해 열을 고정할 수 있다고 말하는 다소 복잡한 방법입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.3,
  "end": 670.84
 },
 {
  "input": "From here, you can probably guess what follows.",
  "translatedText": "여기에서 아마도 다음 내용을 추측할 수 있을 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 671.48,
  "end": 673.64
 },
 {
  "input": "We do basically the same thing but for the rows.",
  "translatedText": "기본적으로 동일한 작업을 수행하지만 행에 대해 수행합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 673.8,
  "end": 676.14
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit.",
  "translatedText": "위치 4를 패리티 비트로 사용하여 홀수 행에 대한 패리티 검사가 수행됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 676.44,
  "end": 680.9
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0.",
  "translatedText": "따라서 이 예에서 해당 그룹에는 이미 짝수 패리티가 있으므로 비트 4는 0으로 설정됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 681.38,
  "end": 685.82
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit.",
  "translatedText": "마지막으로 위치 8을 패리티 비트로 사용하여 아래쪽 두 행에 대한 패리티 검사가 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 686.56,
  "end": 691.58
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity.",
  "translatedText": "이 경우 그룹에 균등한 패리티를 제공하기 위해 발신자가 해당 비트 8을 켜야 하는 것처럼 보입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 692.12,
  "end": 696.82
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row.",
  "translatedText": "처음 두 검사를 통해 열을 고정할 수 있는 것처럼 다음 두 검사를 통해 행을 고정할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 697.7,
  "end": 701.84
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3.",
  "translatedText": "예를 들어, 전송 중에 위치 3에 오류가 있다고 가정해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 702.88,
  "end": 707.54
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column.",
  "translatedText": "글쎄, 이것은 첫 번째 패리티 그룹에 영향을 미치고 두 번째 패리티 그룹에도 영향을 미치므로 수신자는 오른쪽 열 어딘가에 오류가 있음을 알게 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 708.18,
  "end": 715.56
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group.",
  "translatedText": "하지만 세 번째 그룹에는 영향을 주지 않고, 네 번째 그룹에도 영향을 주지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.1,
  "end": 720.54
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error.",
  "translatedText": "그리고 이를 통해 수신자는 위치 3을 의미하는 첫 번째 행까지 오류를 정확히 찾아낼 수 있으므로 오류를 수정할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 721.24,
  "end": 727.52
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be.",
  "translatedText": "잠시 시간을 내어 이 네 가지 질문에 대한 답을 통해 그것이 어디에 있든 특정 위치를 정확히 찾아낼 수 있다는 점을 스스로 확신하는 것이 즐거울 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 728.58,
  "end": 737.1
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting.",
  "translatedText": "사실, 기민한 여러분은 이러한 질문과 이진수 계산 사이의 연관성을 알아차릴 수도 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 737.72,
  "end": 743.06
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it.",
  "translatedText": "만약 그렇다면 다시 한 번 강조하고, 잠시 멈춰서 제가 그것을 망치기 전에 스스로 연결점을 그려보도록 하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 743.5,
  "end": 748.92
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it.",
  "translatedText": "패리티 비트 자체가 영향을 받으면 어떻게 되는지 궁금하다면 시도해 볼 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 750.5,
  "end": 756.06
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions.",
  "translatedText": "4개의 질문으로 구성된 동일한 그룹을 사용하여 이 4개의 특수 비트 중 오류가 다른 오류와 마찬가지로 어떻게 추적될 것인지 잠시 생각해 보십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 756.44,
  "end": 764.18
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along.",
  "translatedText": "결국 우리가 원하는 것은 메시지 비트를 보호하는 것이고 오류 수정 비트는 그대로 따라가기 때문에 실제로는 중요하지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 767.06,
  "end": 773.1
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct.",
  "translatedText": "그러나 이러한 비트를 보호하는 것 역시 부산물로 자연스럽게 계획에서 제외됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 773.6,
  "end": 777.82
 },
 {
  "input": "You might also enjoy anticipating how this scales.",
  "translatedText": "이것이 어떻게 확장되는지 기대하는 것도 재미있을 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 779.2,
  "end": 781.76
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot.",
  "translatedText": "예를 들어 위치를 파악하기 위해 256비트 크기의 블록을 사용한 경우 특정 지점까지 이진 검색을 수행하려면 8개의 예 또는 아니요 질문만 필요합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 782.3,
  "end": 792.78
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check.",
  "translatedText": "그리고 각 질문에는 적절한 패리티 검사를 설정하기 위해 단 하나의 비트만 포기해야 한다는 점을 기억하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 795.64,
  "end": 800.5
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two.",
  "translatedText": "이미 보신 분들도 계시겠지만, 이러한 질문이 무엇인지 단 1~2분 만에 찾아낼 수 있는 체계적인 방법에 대해서는 나중에 이야기하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 803.16,
  "end": 809.36
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here.",
  "translatedText": "이 스케치가 우리가 여기서 개발 중인 것의 효율성을 평가하는 데 충분하기를 바랍니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 809.88,
  "end": 813.66
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want.",
  "translatedText": "강조 표시된 8개의 패리티 비트를 제외하고 첫 번째 항목은 원하는 메시지나 데이터를 전달하는 무엇이든 원하는 대로 될 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 813.66,
  "end": 821.0
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole.",
  "translatedText": "8비트는 메시지의 나머지 부분에 의해 완전히 결정된다는 점에서 중복되지만 단순히 메시지 전체를 복사하는 것보다 훨씬 더 현명한 방법입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 821.72,
  "end": 830.02
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error.",
  "translatedText": "그럼에도 불구하고 포기한 것이 거의 없기 때문에 단일 비트 오류를 식별하고 수정할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 833.6,
  "end": 838.38
 },
 {
  "input": "Well, almost.",
  "translatedText": "글쎄, 거의.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.2,
  "end": 840.4
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0.",
  "translatedText": "좋아요, 여기서 한 가지 문제는 4개의 패리티 검사 중 어느 것도 오류를 감지하지 못한다는 것입니다. 즉, 특별히 선택된 8비트의 하위 집합이 모두 짝수 패리티를 가지고 있다는 의미입니다. 보낸 사람이 의도한 것처럼 이는 오류가 전혀 없다는 의미입니다. , 또는 위치 0으로 범위를 좁힙니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 840.96,
  "end": 856.86
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition.",
  "translatedText": "4개의 예 또는 아니오 질문으로 패리티 검사를 위한 16개의 가능한 결과가 있으며 처음에는 블록의 16개 위치 중 1개 위치를 정확히 찾아내는 데 완벽하다고 느껴지지만 17번째 결과도 전달해야 합니다. 상태.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 857.74,
  "end": 871.9
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely.",
  "translatedText": "여기의 해결책은 실제로 매우 간단합니다. 0번째 비트를 완전히 잊어버리면 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 873.02,
  "end": 877.3
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error.",
  "translatedText": "따라서 4개의 패리티 검사를 수행하여 모두 짝수임을 확인하면 오류가 없음을 의미합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 877.84,
  "end": 883.46
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy.",
  "translatedText": "이것이 의미하는 바는 16비트 블록으로 작업하는 것이 아니라 15비트 블록으로 작업한다는 것입니다. 여기서 비트 중 11개는 메시지를 전달하는 데 자유롭게 사용되고 그 중 4개는 중복성을 위해 존재합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 884.24,
  "end": 893.22
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code.",
  "translatedText": "이제 우리는 업계 사람들이 15-11 해밍 코드라고 부르는 것을 갖게 되었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 893.78,
  "end": 898.8
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us.",
  "translatedText": "즉, 2의 깨끗한 거듭제곱인 블록 크기를 갖는 것이 좋으며, 0번째 비트를 유지하고 약간의 추가 작업을 수행하도록 할 수 있는 영리한 방법이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 899.86,
  "end": 908.14
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors.",
  "translatedText": "이를 전체 블록에 걸쳐 패리티 비트로 사용하면 수정할 수는 없지만 2비트 오류를 실제로 감지할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 908.7,
  "end": 915.54
 },
 {
  "input": "Here's how it works.",
  "translatedText": "작동 방식은 다음과 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 916.16,
  "end": 916.82
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check.",
  "translatedText": "4개의 특수 오류 수정 비트를 설정한 후 일반적인 패리티 검사와 마찬가지로 전체 블록의 패리티가 짝수가 되도록 0번째 비트를 설정합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 917.18,
  "end": 924.94
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks.",
  "translatedText": "이제 단일 비트 오류가 있으면 전체 블록의 패리티가 홀수로 전환되지만 네 가지 오류 수정 검사 덕분에 어쨌든 이를 포착할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 925.7,
  "end": 933.6
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks.",
  "translatedText": "그러나 두 개의 오류가 있는 경우 전체 패리티는 다시 짝수로 전환되지만 수신자는 여전히 네 개의 패리티 검사로 인해 최소한 일부 오류가 있음을 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 934.16,
  "end": 945.18
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors.",
  "translatedText": "따라서 전체적으로 짝수 패리티를 발견했지만 다른 검사에서 0이 아닌 일이 발생하면 적어도 두 개의 오류가 있음을 알려줍니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 945.18,
  "end": 952.7
 },
 {
  "input": "Isn't that clever?",
  "translatedText": "영리하지 않나요?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.52,
  "end": 954.0
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them.",
  "translatedText": "이러한 2비트 오류를 수정할 수는 없지만 약간 귀찮은 0번째 비트를 다시 작동하게 하면 오류를 감지할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 954.3,
  "end": 961.26
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code.",
  "translatedText": "이것은 매우 표준적인 것으로 확장된 해밍 코드(extended Hamming code)로 알려져 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.26,
  "end": 965.22
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block.",
  "translatedText": "기술적으로 말하자면, 이제 적어도 16비트 블록의 예에 대해 해밍 코드가 수행하는 작업에 대한 전체 설명을 갖게 되었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 966.54,
  "end": 972.88
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself.",
  "translatedText": "하지만 처음부터 끝까지 하나의 전체 예제를 직접 수행하여 지금까지의 이해를 확인하고 모든 것을 확고히 하는 것이 더 만족스러울 것이라고 생각합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 972.88,
  "end": 981.32
 },
 {
  "input": "I'll step through it with you though so you can check yourself.",
  "translatedText": "그래도 직접 확인해 볼 수 있도록 단계별로 안내해 드리겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 982.08,
  "end": 984.3
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks.",
  "translatedText": "공간을 통해 변환하는 문자 메시지이든 시간이 지남에 따라 저장하려는 일부 데이터이든 메시지를 설정하려면 첫 번째 단계는 메시지를 11비트 청크로 나누는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 985.12,
  "end": 994.66
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block.",
  "translatedText": "각 청크는 오류 방지 16비트 블록으로 패키징됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 995.58,
  "end": 999.76
 },
 {
  "input": "So let's take this one as an example and actually work it out.",
  "translatedText": "그럼 이것을 예로 들어 실제로 시도해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 999.76,
  "end": 1003.22
 },
 {
  "input": "Go ahead, actually do it!",
  "translatedText": "어서, 실제로 해보세요!",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1003.74,
  "end": 1004.94
 },
 {
  "input": "Let's pause and try putting together this block.",
  "translatedText": "잠시 멈추고 이 블록을 조립해 봅시다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1005.22,
  "end": 1007.02
 },
 {
  "input": "Okay, you ready?",
  "translatedText": "알았어, 준비됐어?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1012.72,
  "end": 1013.68
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order.",
  "translatedText": "2의 다른 거듭제곱과 함께 위치 0은 오류 수정 임무를 위해 예약되어 있으므로 나머지 모든 지점에 메시지 비트를 순서대로 배치하는 것부터 시작합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1014.24,
  "end": 1023.32
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0.",
  "translatedText": "이 그룹에는 짝수 패리티가 필요합니다. 이미 그렇습니다. 따라서 위치 1의 패리티 비트를 0으로 설정해야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1025.34,
  "end": 1032.34
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1.",
  "translatedText": "다음 그룹은 홀수 패리티로 시작하므로 패리티 비트를 1로 설정해야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1033.02,
  "end": 1037.88
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1.",
  "translatedText": "그 이후의 그룹은 홀수 패리티로 시작하므로 다시 패리티 비트를 1로 설정해야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1039.16,
  "end": 1044.24
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1.",
  "translatedText": "그리고 마지막 그룹에도 홀수 패리티가 있습니다. 즉, 위치 8의 해당 비트를 1로 설정했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1044.78,
  "end": 1050.06
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0.",
  "translatedText": "그런 다음 마지막 단계로 이제 전체 블록에 짝수 패리티가 있습니다. 즉, 가장 중요한 패리티 비트인 비트 번호 0을 0으로 설정할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1051.3,
  "end": 1060.32
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0.",
  "translatedText": "따라서 이 블록이 전송되면 4개의 특수 하위 집합과 블록 전체의 패리티는 모두 짝수 또는 0이 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1061.34,
  "end": 1068.14
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver.",
  "translatedText": "연습의 두 번째 부분으로 여러분에게 수신자의 역할을 맡아 보도록 하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1068.82,
  "end": 1072.18
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't.",
  "translatedText": "물론, 그것은 여러분이 아직 이 메시지가 무엇인지 모른다는 것을 의미할 것입니다. 여러분 중 일부는 그것을 외웠을 수도 있지만, 암기하지 않았다고 가정해 봅시다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1073.48,
  "end": 1079.78
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did.",
  "translatedText": "내가 하려는 일은 해당 블록의 비트 중 0, 1 또는 2를 변경한 다음 내가 한 일이 무엇인지 알아내도록 요청하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1080.02,
  "end": 1087.74
 },
 {
  "input": "So again, pause and try working it out.",
  "translatedText": "그러니 다시 잠시 멈춰서 시도해 보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1088.26,
  "end": 1090.81
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column.",
  "translatedText": "좋아, 이제 수신자로서 첫 번째 패리티 그룹을 확인하면 그것이 짝수라는 것을 알 수 있습니다. 따라서 존재하는 모든 오류는 짝수 열에 있어야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1098.79,
  "end": 1107.91
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column.",
  "translatedText": "다음 확인에서는 홀수를 제공하여 적어도 하나의 오류가 있음을 알려주고 이 특정 열로 범위를 좁힙니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1109.69,
  "end": 1117.03
 },
 {
  "input": "The third check is even, chopping down the possibilities even further.",
  "translatedText": "세 번째 확인은 균등하여 가능성을 더욱 줄입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1118.55,
  "end": 1121.79
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10.",
  "translatedText": "그리고 마지막 패리티 검사는 홀수이며, 아래쪽 어딘가에 오류가 있음을 알려주며, 이제 우리는 이 오류가 위치 번호 10에 있음을 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1122.65,
  "end": 1129.65
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two.",
  "translatedText": "게다가 전체 블록의 패리티가 홀수이므로 두 번이 아니라 한 번 뒤집혔다는 확신을 갖게 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1131.49,
  "end": 1137.53
 },
 {
  "input": "If it's three or more, all bets are off.",
  "translatedText": "3개 이상이면 모든 베팅이 취소됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1138.07,
  "end": 1139.97
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with.",
  "translatedText": "해당 비트 번호 10을 수정한 후 수정에 사용되지 않은 11비트를 꺼내면 원본 메시지의 관련 세그먼트가 제공됩니다. 되감아서 비교하면 실제로 우리가 예제를 시작한 것과 정확히 일치합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1141.31,
  "end": 1154.39
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code.",
  "translatedText": "이제 이 모든 작업을 직접 수행하는 방법을 알았으므로 Python 코드 한 줄로 이 모든 논리의 핵심 부분을 수행하는 방법을 보여 드리겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1155.71,
  "end": 1163.17
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks.",
  "translatedText": "내가 아직 말하지 않은 것은 이 알고리즘이 실제로 얼마나 우아한지, 기계가 오류 위치를 가리키도록 하는 것이 얼마나 간단한지, 체계적으로 오류의 크기를 조정하는 방법, 모든 것을 프레임으로 구성하는 방법에 대한 것입니다. 이는 여러 개의 개별 패리티 검사가 아닌 하나의 단일 작업입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1163.87,
  "end": 1178.75
 },
 {
  "input": "To see what I mean, come join me in part 2.",
  "translatedText": "무슨 뜻인지 보려면 2부에 참여하세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1179.43,
  "end": 1181.31
 }
]