[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing?",
  "translatedText": "CD나 DVD를 긁어도 저장된 내용을 그대로 재생할 수 있는 방법이 궁금한 적이 있으신가요?",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 3.62,
  "end": 10.1
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors.",
  "translatedText": "스크래치는 실제로 디스크의 1과 0에 영향을 미치기 때문에 저장된 데이터와 다른 데이터를 읽어오지만, 정말 긁힌 것이 아니라면 이러한 모든 오류에도 불구하고 읽어온 비트는 인코딩된 파일과 정확히 동일한 파일로 디코딩되어 비트 단위로 복사됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 10.9,
  "end": 27.44
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors.",
  "translatedText": "수학적 영리함에는 오류에 강한 방식으로 데이터를 저장하고, 마찬가지로 중요한 데이터를 전송할 수 있는 수많은 기술이 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 27.44,
  "end": 36.66
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this.",
  "translatedText": "사실 이렇게 하는 방법을 생각해내는 데 그렇게 똑똑할 필요는 없습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 37.52,
  "end": 41.6
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s.",
  "translatedText": "동영상, 사운드, 텍스트, 코드, 이미지 등 모든 파일은 궁극적으로 1과 0의 연속입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 42.06,
  "end": 50.38
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit.",
  "translatedText": "그리고 뒤집힌 비트를 수정하는 간단한 전략은 각 비트의 복사본을 세 개씩 저장하는 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 50.68,
  "end": 56.0
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy.",
  "translatedText": "그러면 이 파일을 읽는 컴퓨터가 이 세 개의 사본을 비교하여 불일치가 있을 때마다 항상 3개의 사본 중 가장 좋은 2개의 사본을 선택할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 57.58,
  "end": 64.06
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy.",
  "translatedText": "하지만 이는 공간의 3분의 2를 중복성을 위해 사용한다는 의미입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 67.16,
  "end": 70.86
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped.",
  "translatedText": "그리고 그렇게 포기한 모든 공간에 대해 하나 이상의 비트가 뒤집힐 경우 어떤 일이 벌어질지에 대한 확실한 보장도 없습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 71.48,
  "end": 77.24
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible.",
  "translatedText": "훨씬 더 흥미로운 질문은 가능한 한 적은 공간을 포기하면서 오류를 수정할 수 있도록 만드는 방법입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 77.98,
  "end": 84.02
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9(!), to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want.",
  "translatedText": "예를 들어, 이 동영상에서 배우게 될 방법을 사용하면 256비트 블록에 데이터를 저장할 수 있는데, 각 블록은 9비트인 9(!)를 사용하여 일종의 중복성 역할을 하고 나머지 247비트에는 원하는 의미 있는 메시지나 데이터를 자유롭게 담을 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 84.52,
  "end": 100.3
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it.",
  "translatedText": "그리고 여기서 비트가 하나라도 뒤바뀌면 이 블록만 보고도 기계가 오류가 발생했음을 파악하고 그 위치를 정확히 파악하여 어떻게 수정해야 하는지 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 100.9,
  "end": 112.66
 },
 {
  "input": "And honestly, that feels like magic.",
  "translatedText": "솔직히 마법처럼 느껴집니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 112.66,
  "end": 114.62
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them.",
  "translatedText": "이 특정 방식에서는 두 개의 비트가 뒤집히더라도 기계가 오류를 수정하는 방법을 알 수는 없지만 최소한 두 개의 오류가 발생했다는 사실은 감지할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 115.44,
  "end": 122.86
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes.",
  "translatedText": "크기가 다른 블록에 대해 이 기능이 어떻게 확장되는지에 대해서는 잠시 후에 설명하겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 123.52,
  "end": 126.9
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes.",
  "translatedText": "이와 같은 오류를 수정할 수 있는 방법을 오류 수정 코드라고 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 127.86,
  "end": 132.9
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day.",
  "translatedText": "지난 세기 동안 이 분야는 우리가 매일 사용하는 기기에 통합되는 놀랍도록 깊은 수학의 풍부한 원천이었습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 133.66,
  "end": 141.94
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code.",
  "translatedText": "이 글의 목표는 해밍 코드라고 알려진 가장 초기의 예시 중 하나에 대해 자세히 이해하는 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 142.84,
  "end": 148.66
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there.",
  "translatedText": "참고로 이 동영상의 구조에 대해 제가 생각하는 방식은 가능한 한 직접적으로 설명하기보다는 여기저기서 약간의 안내를 통해 시청자가 스스로 만들 수 있도록 유도하는 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 149.52,
  "end": 159.82
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you.",
  "translatedText": "그러니 어느 순간 어디로 튈지 알 것 같으면 잠시 멈춰서 제가 말씀드리기 전에 계획이 어떻게 될지 적극적으로 예측해 보세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 160.12,
  "end": 166.72
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying.",
  "translatedText": "또한 하드웨어 수준까지 이해하고자 하는 분들을 위해 벤 이터는 이 동영상과 함께 브레드보드에서 해밍 코드를 실제로 구현하는 방법을 보여주는 동영상을 제작했는데, 매우 만족스러운 동영상입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 167.24,
  "end": 178.24
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming.",
  "translatedText": "해밍 코드는 리드-솔로몬 알고리즘과 같은 최신 코드만큼 널리 사용되지는 않지만, 처음에 이 작업이 얼마나 불가능하게 느껴졌는지와 해밍에 대해 알고 나면 얼마나 합리적으로 보이는지 대조되는 마법 같은 점이 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 179.3,
  "end": 193.0
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages.",
  "translatedText": "오류 수정의 기본 원칙은 가능한 모든 메시지의 방대한 공간에서 일부 하위 집합만 유효한 메시지로 간주한다는 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 193.72,
  "end": 202.18
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words.",
  "translatedText": "철자가 맞는 단어와 철자가 틀린 단어를 비유로 생각해 보세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 202.8,
  "end": 206.94
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo.",
  "translatedText": "유효한 메시지가 변경될 때마다 수신자는 오타가 있을 때와 마찬가지로 가장 가까운 유효한 이웃에게 표시되는 내용을 수정할 책임이 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 208.9,
  "end": 217.34
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness.",
  "translatedText": "하지만 이와 같은 메시지를 효율적으로 분류하기 위한 구체적인 알고리즘을 고안하는 데는 어느 정도 영리함이 필요합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 218.22,
  "end": 224.06
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to.",
  "translatedText": "이 이야기는 1940년대 벨 연구소에서 일하던 젊은 리처드 해밍이 일부 작업에는 접근이 제한된 매우 큰 고가의 펀치 카드 컴퓨터를 사용해야 했던 것으로부터 시작됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 226.78,
  "end": 237.42
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread.",
  "translatedText": "그리고 가끔씩 잘못 읽히는 부분이 있었기 때문에 그가 계속 실행한 프로그램은 계속 실패했습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 237.8,
  "end": 242.4
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code.",
  "translatedText": "좌절이 발명의 도가니가 되자 그는 지쳐서 세계 최초로 오류 수정 코드를 발명했습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 243.12,
  "end": 248.42
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them.",
  "translatedText": "해밍 코드를 구성하는 방법에는 여러 가지가 있지만, 우선 해밍이 직접 생각한 방식대로 살펴보도록 하겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 249.06,
  "end": 255.38
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits.",
  "translatedText": "간단하지만 너무 단순하지 않은 16비트 블록을 예로 들어 보겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 256.52,
  "end": 260.94
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15.",
  "translatedText": "이러한 비트의 위치는 0에서 15까지 번호를 매깁니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 261.82,
  "end": 264.74
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy.",
  "translatedText": "우리가 저장하려는 실제 데이터는 이 중 12비트만 차지하며, 나머지 4개는 일종의 여분으로 남겨둡니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 265.62,
  "end": 273.0
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data.",
  "translatedText": "여기서 중복이라는 단어는 단순히 복사를 의미하는 것이 아닙니다. 4비트는 데이터를 무턱대고 복사할 수 있는 충분한 공간을 제공하지 않기 때문입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 273.9,
  "end": 280.04
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience.",
  "translatedText": "대신, 새로운 정보를 추가하는 것이 아니라 복원력을 추가하는 훨씬 더 미묘하고 영리한 종류의 중복성이 필요하게 될 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 280.72,
  "end": 287.28
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end.",
  "translatedText": "이 4개의 특별한 비트가 마지막에 멋지게 포장되어 있을 거라고 생각할 수도 있지만, 보시다시피 2의 거듭제곱에 해당하는 위치에 배치하면 마지막에 정말 우아한 무언가를 만들 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 288.6,
  "end": 299.62
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks.",
  "translatedText": "또한 더 큰 블록에 대해 어떻게 확장되는지에 대한 약간의 힌트를 얻을 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 300.2,
  "end": 303.54
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now.",
  "translatedText": "또한 기술적으로는 11비트 데이터에 불과하므로 0번 위치에서 일어나는 일에 대해 약간의 뉘앙스가 있지만 지금은 걱정하지 않아도 됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 304.9,
  "end": 313.26
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors.",
  "translatedText": "다른 오류 수정 알고리즘과 마찬가지로, 여기에는 이 4가지 특수 비트를 설정하는 발신자와 일종의 검사를 수행하고 오류를 수정하는 수신자, 두 명의 플레이어가 참여하게 됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 314.14,
  "end": 325.54
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage.",
  "translatedText": "물론 발신자와 수신자라는 단어는 실제로 모든 검사를 수행하는 기계 또는 소프트웨어를 의미하며, 메시지라는 개념은 스토리지와 같은 것을 포함하는 매우 넓은 의미입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 326.3,
  "end": 334.74
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another.",
  "translatedText": "결국 데이터를 저장하는 것은 한 곳에서 다른 곳으로 메시지를 보내는 것이 아니라 과거에서 미래로 메시지를 보내는 것과 마찬가지입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 335.34,
  "end": 341.68
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check.",
  "translatedText": "이것이 설정입니다만, 자세히 알아보기 전에 해밍이 발견할 당시 신선한 아이디어였던 단일 비트 오류를 감지할 수는 있지만 수정할 수는 없는 방법, 즉 업계에서는 패리티 검사라고 알려진 관련 아이디어에 대해 이야기할 필요가 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 342.56,
  "end": 356.3
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message.",
  "translatedText": "패리티 검사를 위해 발신자가 조정할 책임이 있는 단일 비트만 분리하고 나머지는 자유롭게 메시지를 전달할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 356.88,
  "end": 363.82
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number.",
  "translatedText": "이 특수 비트의 유일한 역할은 메시지에 포함된 1의 총 개수가 짝수인지 확인하는 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 364.88,
  "end": 371.28
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even.",
  "translatedText": "예를 들어 지금 1의 총 개수가 7이므로 홀수이므로 발신자는 이 특별한 비트를 1로 뒤집어 짝수로 만들어야 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 372.08,
  "end": 379.96
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0.",
  "translatedText": "그러나 블록이 이미 짝수인 1로 시작되었다면 이 특수 비트는 0으로 유지되었을 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 380.8,
  "end": 386.42
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information.",
  "translatedText": "이것은 매우 간단하고 믿을 수 없을 정도로 간단하지만, 메시지 어디에서나 변화의 아이디어를 하나의 정보에 반영할 수 있는 놀랍도록 우아한 방법입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 387.34,
  "end": 396.78
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd.",
  "translatedText": "이 메시지에서 0에서 1 또는 1에서 0으로 조금이라도 뒤집히면 1의 총 개수가 짝수에서 홀수로 바뀝니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 397.5,
  "end": 406.54
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was.",
  "translatedText": "따라서 수신자가 이 메시지를 보고 홀수 개의 1이 표시되면 오류가 어디에서 발생했는지 모르더라도 오류가 발생했음을 확실히 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 407.98,
  "end": 417.46
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity.",
  "translatedText": "전문 용어로는 비트 그룹에 짝수 또는 홀수 1이 있는지 여부를 패리티라고 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 418.5,
  "end": 423.34
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea.",
  "translatedText": "숫자를 사용하여 패리티가 0 또는 1이라고 말할 수도 있는데, 이는 일반적으로 아이디어를 가지고 수학을 시작하면 더 도움이 됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 424.86,
  "end": 430.72
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit.",
  "translatedText": "발신자가 패리티를 제어하기 위해 사용하는 이 특수 비트를 패리티 비트라고 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 431.22,
  "end": 435.52
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0.",
  "translatedText": "수신자가 홀수 패리티를 본다고 해서 반드시 오류가 하나만 있었다는 의미는 아니며, 오류가 3개나 5개 또는 다른 홀수가 있었을 수도 있지만 0이 아니라는 것은 확실히 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 437.56,
  "end": 449.26
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free.",
  "translatedText": "반면에 오류가 2개, 또는 짝수 개의 오류가 있었다면 최종 1의 개수는 여전히 짝수가 되므로 수신자는 짝수 개수가 반드시 메시지에 오류가 없음을 의미한다고 완전히 확신할 수 없습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 449.98,
  "end": 462.3
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right.",
  "translatedText": "단 2번의 비트 플립으로 메시지가 엉망이 되는 것은 매우 취약하다고 불평할 수 있으며, 이는 전적으로 옳습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 462.84,
  "end": 469.08
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended.",
  "translatedText": "하지만 수신한 메시지가 발신자가 의도한 메시지인지 100% 확신할 수 있는 오류 감지 또는 수정 방법은 없다는 점에 유의하세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 469.7,
  "end": 478.9
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance.",
  "translatedText": "결국, 충분한 무작위 노이즈는 순수한 우연에 의해 하나의 유효한 메시지를 다른 유효한 메시지로 바꿀 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 479.58,
  "end": 485.44
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this.",
  "translatedText": "대신, 특정 최대 오류 수까지 견고한 체계를 마련하거나 이와 같은 오탐 확률을 줄이는 것이 목표입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 486.24,
  "end": 495.38
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes.",
  "translatedText": "패리티 검사 자체는 매우 약하지만, 전체 메시지의 변경 아이디어를 단일 비트로 압축하면 더 정교한 계획을 위한 강력한 구성 요소가 됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 496.26,
  "end": 507.16
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error.",
  "translatedText": "예를 들어, 해밍은 오류가 발생했다는 사실뿐만 아니라 오류가 발생한 위치를 파악하는 방법을 찾던 중, 전체 메시지가 아닌 신중하게 선택한 특정 하위 집합에 패리티 검사를 적용하면 단일 비트 오류의 위치를 정확히 파악하는 보다 정교한 일련의 질문을 할 수 있다는 핵심 통찰을 얻게 되었습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 507.94,
  "end": 525.94
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half.",
  "translatedText": "전체적인 느낌은 마치 20개의 질문으로 이루어진 게임을 하는 것과 비슷하며, 예 또는 아니오를 묻는 질문으로 가능성의 공간을 반으로 잘라냅니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 526.68,
  "end": 533.38
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions.",
  "translatedText": "예를 들어 홀수 위치의 8비트에 대해서만 패리티 검사를 한다고 가정해 보겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 534.16,
  "end": 539.38
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position.",
  "translatedText": "그런 다음 오류가 감지되면 수신자에게 오류가 구체적으로 어디에 있는지, 즉 이상한 위치에 있다는 정보를 조금 더 알려줍니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 540.1,
  "end": 548.24
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions.",
  "translatedText": "8비트 중 오류가 감지되지 않으면 오류가 전혀 없거나 짝수 위치 어딘가에 있다는 뜻입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 548.94,
  "end": 556.24
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful.",
  "translatedText": "패리티 검사를 비트의 절반으로 제한하면 효율성이 떨어질 것이라고 생각할 수 있지만, 잘 선택된 다른 검사와 함께 사용하면 직관적으로 훨씬 더 강력한 결과를 얻을 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 557.18,
  "end": 567.2
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group.",
  "translatedText": "실제로 패리티 검사를 설정하려면 전체 그룹의 패리티를 제어할 수 있는 특수 비트를 할당해야 한다는 점을 기억하세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 569.24,
  "end": 576.62
 },
 {
  "input": "Here let's just choose position 1.",
  "translatedText": "여기서는 위치 1을 선택하겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 577.48,
  "end": 579.18
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even.",
  "translatedText": "표시된 예시에서는 이 8비트의 패리티가 현재 홀수이므로 발신자가 해당 패리티 비트를 토글해야 하며, 현재는 짝수입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 579.72,
  "end": 586.98
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do.",
  "translatedText": "이것은 4번의 패리티 검사 중 1번만 수행합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 587.94,
  "end": 590.68
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here.",
  "translatedText": "두 번째 체크는 그리드의 오른쪽 절반에 있는 8비트 중 하나입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 590.92,
  "end": 596.3
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged.",
  "translatedText": "이번에는 2번 위치를 패리티 비트로 사용할 수 있으므로 이 8개의 비트는 이미 짝수 패리티를 가지며, 발신자는 2번 비트를 변경하지 않고 그대로 두어도 괜찮습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 596.68,
  "end": 606.06
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right.",
  "translatedText": "그런 다음 다른 쪽에서 수신자가 이 그룹의 패리티를 확인하여 이상하다는 것을 발견하면 오른쪽의 8비트 중 어딘가에 오류가 있음을 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 607.02,
  "end": 615.38
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half.",
  "translatedText": "그렇지 않으면 오류가 없거나 왼쪽 절반 어딘가에 오류가 있다는 뜻입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 615.82,
  "end": 620.58
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block.",
  "translatedText": "또는 두 개의 오류가 있을 수도 있지만 지금은 전체 블록에 최대 하나의 오류가 있다고 가정하겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 621.12,
  "end": 626.5
 },
 {
  "input": "Things break down completely for more than that.",
  "translatedText": "그 이상이면 모든 것이 완전히 무너집니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 626.94,
  "end": 628.74
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together.",
  "translatedText": "다음 두 가지 점검 사항을 살펴보기 전에 이 첫 번째 두 가지 사항을 함께 고려했을 때 우리가 무엇을 할 수 있는지 잠시 생각해 보세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 629.16,
  "end": 635.1
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half.",
  "translatedText": "홀수 열과 오른쪽 절반 열에서 오류를 감지했다고 가정해 보겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 635.8,
  "end": 639.66
 },
 {
  "input": "It necessarily means the error is somewhere in the last column.",
  "translatedText": "이는 반드시 마지막 열의 어딘가에 오류가 있음을 의미합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 640.2,
  "end": 643.04
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column.",
  "translatedText": "홀수 열에는 오류가 없지만 오른쪽 절반에 오류가 있는 경우 두 번째 열에서 마지막 열에 오류가 있다는 뜻입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 643.82,
  "end": 649.7
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column.",
  "translatedText": "마찬가지로 홀수 열에는 오류가 있지만 오른쪽 절반에는 없는 경우 두 번째 열 어딘가에 오류가 있다는 것을 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 650.44,
  "end": 656.02
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column.",
  "translatedText": "이 두 가지 패리티 검사 중 어느 것도 감지되지 않으면 오류가 있을 수 있는 유일한 위치가 가장 왼쪽 열이라는 뜻입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 656.02,
  "end": 663.12
 },
 {
  "input": "But it also might simply mean there's no error at all.",
  "translatedText": "그러나 이는 단순히 오류가 전혀 없다는 의미일 수도 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 663.34,
  "end": 666.12
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column.",
  "translatedText": "두 번의 패리티 검사를 통해 열을 고정할 수 있다는 다소 지루한 설명입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 666.3,
  "end": 670.84
 },
 {
  "input": "From here, you can probably guess what follows.",
  "translatedText": "여기에서 다음 내용을 짐작할 수 있을 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 671.48,
  "end": 673.64
 },
 {
  "input": "We do basically the same thing but for the rows.",
  "translatedText": "기본적으로 동일한 작업을 수행하지만 행에 대해서는 다릅니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 673.8,
  "end": 676.14
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit.",
  "translatedText": "위치 4를 패리티 비트로 사용하여 홀수 행에 대한 패리티 검사가 있을 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 676.44,
  "end": 680.9
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0.",
  "translatedText": "따라서 이 예제에서는 해당 그룹이 이미 짝수 패리티를 가지고 있으므로 비트 4가 0으로 설정됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 681.38,
  "end": 685.82
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit.",
  "translatedText": "마지막으로 아래쪽 두 행에 패리티 체크가 있으며, 8번 위치를 패리티 비트로 사용합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 686.56,
  "end": 691.58
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity.",
  "translatedText": "이 경우 그룹에 균등한 패리티를 부여하기 위해 발신자가 비트 8을 켜야 하는 것처럼 보입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 692.12,
  "end": 696.82
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row.",
  "translatedText": "처음 두 번의 확인을 통해 열을 고정할 수 있는 것처럼, 다음 두 번의 확인을 통해 행을 고정할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 697.7,
  "end": 701.84
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3.",
  "translatedText": "예를 들어, 전송 중에 3번 위치에서 오류가 발생했다고 가정해 보겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 702.88,
  "end": 707.54
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column.",
  "translatedText": "이것은 첫 번째 패리티 그룹에 영향을 미치고 두 번째 패리티 그룹에도 영향을 미치므로 수신자는 오른쪽 열 어딘가에 오류가 있다는 것을 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 708.18,
  "end": 715.56
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group.",
  "translatedText": "그러나 세 번째 그룹에는 영향을 미치지 않으며 네 번째 그룹에는 영향을 미치지 않습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 716.1,
  "end": 720.54
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error.",
  "translatedText": "그러면 수신자는 첫 번째 행까지, 즉 3번 위치를 의미하는 오류를 정확히 찾아내어 오류를 수정할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 721.24,
  "end": 727.52
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be.",
  "translatedText": "이 네 가지 질문에 대한 답을 통해 특정 위치가 어디에 있든 항상 특정 위치를 파악할 수 있다고 스스로에게 확신할 수 있는 시간을 가져보세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 728.58,
  "end": 737.1
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting.",
  "translatedText": "사실, 영리한 분이라면 이러한 질문과 이진수 계산 사이의 연관성을 알아차리실 수도 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 737.72,
  "end": 743.06
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it.",
  "translatedText": "그리고 만약 그렇다면 다시 한 번 강조하고, 잠시 멈추고, 연결 고리를 직접 그려보시기 바랍니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 743.5,
  "end": 748.92
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it.",
  "translatedText": "패리티 비트 자체가 영향을 받으면 어떻게 되는지 궁금하다면, 직접 체험해 보시면 됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 750.5,
  "end": 756.06
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions.",
  "translatedText": "이 네 가지 특수 비트 중 어떤 오류가 다른 네 가지 질문과 마찬가지로 어떻게 추적될지 잠시 생각해 보세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 756.44,
  "end": 764.18
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along.",
  "translatedText": "결국 우리가 원하는 것은 메시지 비트를 보호하는 것이므로 오류 정정 비트는 그냥 따라다니는 것이므로 크게 중요하지 않습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 767.06,
  "end": 773.1
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct.",
  "translatedText": "그러나 이러한 비트도 보호하는 것은 계획에서 자연스럽게 부산물로 빠지는 부분입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 773.6,
  "end": 777.82
 },
 {
  "input": "You might also enjoy anticipating how this scales.",
  "translatedText": "이 기능이 어떻게 확장될지 예상해보는 것도 재미있을 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 779.2,
  "end": 781.76
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot.",
  "translatedText": "예를 들어 256비트 크기의 블록을 사용하여 특정 지점을 찾아내는 경우, 예 또는 아니오 질문 8개만 있으면 특정 지점을 이진 검색할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 782.3,
  "end": 792.78
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check.",
  "translatedText": "각 질문은 적절한 패리티 검사를 설정하기 위해 단 하나의 비트만 포기하면 된다는 점을 기억하세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 795.64,
  "end": 800.5
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two.",
  "translatedText": "이미 보신 분들도 계시겠지만, 이러한 질문이 무엇인지 체계적으로 찾는 방법에 대해서는 나중에 1~2분 정도에 설명하겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 803.16,
  "end": 809.36
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here.",
  "translatedText": "이 스케치만으로도 우리가 개발 중인 기능의 효율성을 충분히 이해할 수 있기를 바랍니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 809.88,
  "end": 813.66
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want.",
  "translatedText": "첫 번째는 강조 표시된 8개의 패리티 비트를 제외하고는 원하는 메시지나 데이터를 전달할 수 있는 어떤 것이든 될 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 813.66,
  "end": 821.0
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole.",
  "translatedText": "8비트는 나머지 메시지에 의해 완전히 결정된다는 점에서 중복되지만, 단순히 메시지 전체를 복사하는 것보다 훨씬 스마트한 방식입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 821.72,
  "end": 830.02
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error.",
  "translatedText": "그럼에도 불구하고 거의 포기하지 않고 단일 비트 오류를 식별하고 수정할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 833.6,
  "end": 838.38
 },
 {
  "input": "Well, almost.",
  "translatedText": "뭐, 거의요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 839.2,
  "end": 840.4
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0.",
  "translatedText": "여기서 한 가지 문제는 네 번의 패리티 검사에서 오류가 감지되지 않는다면, 즉 특별히 선택한 8비트 하위 집합이 모두 발신자의 의도대로 짝수 패리티를 갖는다면 오류가 전혀 없거나 0으로 좁혀진다는 뜻입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 840.96,
  "end": 856.86
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition.",
  "translatedText": "네 가지 예 또는 아니오 질문으로 패리티 검사에 16가지 결과가 나올 수 있는데, 처음에는 블록의 16개 위치 중 1개를 정확히 찾아내는 데는 완벽해 보이지만 17번째 결과인 오류 없음 조건도 전달해야 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 857.74,
  "end": 871.9
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely.",
  "translatedText": "여기서 해결책은 사실 매우 간단합니다. 0번째 비트는 완전히 잊어버리면 됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 873.02,
  "end": 877.3
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error.",
  "translatedText": "따라서 네 번의 패리티 검사를 수행한 결과 모두 짝수인 것을 확인하면 오류가 없다는 것을 분명히 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 877.84,
  "end": 883.46
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy.",
  "translatedText": "즉, 16비트 블록으로 작업하는 대신 15비트 블록으로 작업하며, 11개 비트는 메시지를 전달할 수 있고 4개 비트는 중복성을 위해 사용됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 884.24,
  "end": 893.22
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code.",
  "translatedText": "이를 통해 이제 업계에서는 15-11 해밍 코드라고 부르는 코드가 생겼습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 893.78,
  "end": 898.8
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us.",
  "translatedText": "즉, 블록 크기가 2의 깨끗한 제곱인 것이 좋으며, 0번째 비트를 유지하면서 약간의 추가 작업을 수행할 수 있는 현명한 방법이 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 899.86,
  "end": 908.14
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors.",
  "translatedText": "이를 전체 블록에서 패리티 비트로 사용하면 수정할 수는 없지만 실제로 2비트 오류를 감지할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 908.7,
  "end": 915.54
 },
 {
  "input": "Here's how it works.",
  "translatedText": "작동 방식은 다음과 같습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 916.16,
  "end": 916.82
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check.",
  "translatedText": "4개의 특수 오류 수정 비트를 설정한 후, 일반 패리티 검사처럼 전체 블록의 패리티가 균등하도록 0번째 비트를 설정합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 917.18,
  "end": 924.94
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks.",
  "translatedText": "이제 단일 비트 오류가 발생하면 전체 블록의 패리티가 홀수로 전환되지만, 네 가지 오류 수정 검사 덕분에 어쨌든 이를 잡아낼 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 925.7,
  "end": 933.6
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks.",
  "translatedText": "그러나 오류가 두 번 발생하면 전체 패리티는 다시 짝수로 전환되지만 수신자는 네 번의 패리티 검사로 인해 최소한의 오류가 발생했음을 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 934.16,
  "end": 945.18
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors.",
  "translatedText": "따라서 전체적으로 패리티가 균등하지만 다른 검사에서 0이 아닌 것이 발견되면 최소 두 가지 오류가 발생했음을 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 945.18,
  "end": 952.7
 },
 {
  "input": "Isn't that clever?",
  "translatedText": "영리하지 않나요?",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 953.52,
  "end": 954.0
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them.",
  "translatedText": "2비트 오류를 수정할 수는 없지만, 귀찮은 0비트 하나를 다시 작동시키는 것만으로도 오류를 감지할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 954.3,
  "end": 961.26
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code.",
  "translatedText": "이것은 확장된 해밍 코드라고 하는 매우 표준적인 코드입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 962.26,
  "end": 965.22
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block.",
  "translatedText": "기술적으로 말하자면, 적어도 16비트 블록의 예시에서는 해밍 코드가 어떻게 작동하는지에 대한 완전한 설명을 얻었습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 966.54,
  "end": 972.88
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself.",
  "translatedText": "하지만 하나의 예제를 처음부터 끝까지 직접 해보면서 이해도를 점검하고 여기까지의 모든 내용을 탄탄하게 다지는 것이 더 만족스러울 것이라고 생각합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 972.88,
  "end": 981.32
 },
 {
  "input": "I'll step through it with you though so you can check yourself.",
  "translatedText": "직접 확인하실 수 있도록 제가 함께 설명해드리겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 982.08,
  "end": 984.3
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks.",
  "translatedText": "공간에 걸쳐 번역하는 문자 그대로의 메시지이든, 시간이 지남에 따라 저장하려는 일부 데이터이든 메시지를 설정하려면 먼저 메시지를 11비트 청크로 나눠야 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 985.12,
  "end": 994.66
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block.",
  "translatedText": "각 청크는 오류 방지 16비트 블록으로 패키징됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 995.58,
  "end": 999.76
 },
 {
  "input": "So let's take this one as an example and actually work it out.",
  "translatedText": "이 사례를 예로 들어 실제로 해결해 보겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 999.76,
  "end": 1003.22
 },
 {
  "input": "Go ahead, actually do it!",
  "translatedText": "어서, 실제로 해보세요!",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1003.74,
  "end": 1004.94
 },
 {
  "input": "Let's pause and try putting together this block.",
  "translatedText": "잠시 멈추고 이 블록을 조합해 보겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1005.22,
  "end": 1007.02
 },
 {
  "input": "Okay, you ready?",
  "translatedText": "자, 준비됐나요?",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1012.72,
  "end": 1013.68
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order.",
  "translatedText": "0번 자리와 2의 다른 제곱은 오류 수정용으로 예약되어 있으므로, 나머지 모든 자리에 메시지 비트를 순서대로 배치하는 것부터 시작해야 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1014.24,
  "end": 1023.32
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0.",
  "translatedText": "이 그룹은 짝수 패리티를 가져야 하는데 이미 그렇게 되어 있으므로 위치 1의 패리티 비트를 0으로 설정했어야 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1025.34,
  "end": 1032.34
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1.",
  "translatedText": "다음 그룹은 홀수 패리티로 시작하므로 패리티 비트를 1로 설정해야 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1033.02,
  "end": 1037.88
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1.",
  "translatedText": "그 이후의 그룹은 홀수 패리티로 시작하므로 다시 패리티 비트를 1로 설정해야 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1039.16,
  "end": 1044.24
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1.",
  "translatedText": "또한 마지막 그룹은 홀수 패리티를 가지므로 8번 위치의 비트를 1로 설정했습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1044.78,
  "end": 1050.06
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0.",
  "translatedText": "그리고 마지막 단계로, 이제 전체 블록이 짝수 패리티를 가지므로 가장 중요한 패리티 비트인 비트 번호 0을 0으로 설정할 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1051.3,
  "end": 1060.32
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0.",
  "translatedText": "따라서 이 블록이 전송되면 네 개의 특수 하위 집합과 블록 전체의 패리티는 모두 짝수, 즉 0이 됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1061.34,
  "end": 1068.14
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver.",
  "translatedText": "연습의 두 번째 부분으로, 여러분이 리시버 역할을 해보겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1068.82,
  "end": 1072.18
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't.",
  "translatedText": "물론 이 메시지가 무엇인지 모르는 분도 계실 것이고, 외우신 분도 계실 수도 있겠지만, 그렇지 않다고 가정해 보겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1073.48,
  "end": 1079.78
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did.",
  "translatedText": "제가 할 일은 해당 블록의 비트 중 0, 1 또는 2를 변경한 다음 제가 한 일이 무엇인지 알아내도록 요청하는 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1080.02,
  "end": 1087.74
 },
 {
  "input": "So again, pause and try working it out.",
  "translatedText": "다시 한 번 잠시 멈춰서 해결해 보세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1088.26,
  "end": 1090.81
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column.",
  "translatedText": "이제 수신자는 첫 번째 패리티 그룹을 확인하여 짝수임을 알 수 있으므로 존재하는 오류는 모두 짝수 열에 있어야 합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1098.79,
  "end": 1107.91
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column.",
  "translatedText": "다음 검사에서는 홀수 숫자가 표시되어 오류가 하나 이상 있음을 알려주고 특정 열로 범위를 좁혀줍니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1109.69,
  "end": 1117.03
 },
 {
  "input": "The third check is even, chopping down the possibilities even further.",
  "translatedText": "세 번째 점검은 짝수로, 가능성을 더욱 줄여줍니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1118.55,
  "end": 1121.79
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10.",
  "translatedText": "그리고 마지막 패리티 검사는 홀수이며, 아래쪽 어딘가에 오류가 있음을 알려주는데, 지금쯤이면 10번 위치에 오류가 있음을 알 수 있습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1122.65,
  "end": 1129.65
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two.",
  "translatedText": "게다가 전체 블록의 패리티가 홀수이기 때문에 두 번이 아닌 한 번의 뒤집기가 있었다는 확신을 갖게 됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1131.49,
  "end": 1137.53
 },
 {
  "input": "If it's three or more, all bets are off.",
  "translatedText": "3개 이상이면 모든 베팅이 종료됩니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1138.07,
  "end": 1139.97
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with.",
  "translatedText": "10번 비트를 수정한 후, 수정에 사용되지 않은 11번 비트를 빼면 원래 메시지의 관련 세그먼트가 나오는데, 되감아 비교해보면 실제로 예제에서 시작한 것과 정확히 일치합니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1141.31,
  "end": 1154.39
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code.",
  "translatedText": "이제 이 모든 작업을 직접 수행하는 방법을 알았으니, 이 모든 로직의 핵심 부분을 Python 코드 한 줄로 수행할 수 있는 방법을 보여드리겠습니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1155.71,
  "end": 1163.17
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks.",
  "translatedText": "제가 아직 말씀드리지 않은 것은 이 알고리즘이 얼마나 우아한지, 기계가 오류 위치를 가리키도록 하는 것이 얼마나 간단한지, 어떻게 체계적으로 확장할 수 있는지, 이 모든 것을 여러 번의 개별 패리티 검사가 아닌 하나의 단일 작업으로 구성할 수 있는지에 대한 것입니다.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1163.87,
  "end": 1178.75
 },
 {
  "input": "To see what I mean, come join me in part 2.",
  "translatedText": "무슨 말인지 알아보려면 2부에서 함께하세요.",
  "model": "DeepL",
  "n_reviews": 0,
  "start": 1179.43,
  "end": 1181.31
 }
]