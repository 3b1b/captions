1
00:00:00,000 --> 00:00:03,120
मैं मान रहा हूं कि यहां हर कोई भाग 1 से आ रहा है।

2
00:00:03,120 --> 00:00:06,745
हम हैमिंग कोड के बारे में बात कर रहे थे, डेटा का एक ब्लॉक बनाने का एक

3
00:00:06,745 --> 00:00:09,490
तरीका जहां अधिकांश बिट्स एक सार्थक संदेश ले जाते हैं,

4
00:00:09,490 --> 00:00:12,649
जबकि कुछ अन्य एक प्रकार की अतिरेक के रूप में कार्य करते हैं,

5
00:00:12,649 --> 00:00:16,844
इस तरह से कि यदि कोई बिट फ़्लिप हो जाता है, तो या तो एक संदेश बिट या अतिरेक बिट,

6
00:00:16,844 --> 00:00:20,573
इस ब्लॉक में कुछ भी, रिसीवर यह पहचानने में सक्षम होगा कि कोई त्रुटि थी,

7
00:00:20,573 --> 00:00:21,920
और इसे कैसे ठीक किया जाए।

8
00:00:21,920 --> 00:00:25,860
वहां प्रस्तुत मूल विचार यह था कि त्रुटि तक पहुंचने के लिए

9
00:00:25,860 --> 00:00:29,800
बाइनरी खोज के लिए एकाधिक समता जांच का उपयोग कैसे किया जाए।

10
00:00:29,800 --> 00:00:35,420
उस वीडियो में लक्ष्य हैमिंग कोड को यथासंभव व्यावहारिक और पुनः खोज योग्य बनाना था।

11
00:00:35,420 --> 00:00:38,380
लेकिन जैसे ही आप वास्तव में इसे सॉफ़्टवेयर या हार्डवेयर में लागू

12
00:00:38,380 --> 00:00:41,204
करने के बारे में सोचना शुरू करते हैं, वह फ़्रेमिंग वास्तव में

13
00:00:41,204 --> 00:00:44,120
कम बिक्री कर सकती है कि ये कोड वास्तव में कितने सुरुचिपूर्ण हैं।

14
00:00:44,120 --> 00:00:47,380
आप सोच सकते हैं कि आपको एक एल्गोरिदम लिखने की ज़रूरत है जो सभी

15
00:00:47,380 --> 00:00:51,934
संभावित त्रुटि स्थानों पर नज़र रखता है और प्रत्येक चेक के साथ उस समूह को आधा कर देता है,

16
00:00:51,934 --> 00:00:54,160
लेकिन वास्तव में यह उससे कहीं अधिक सरल है।

17
00:00:54,160 --> 00:00:59,449
यदि आप पिछले वीडियो में हमारे द्वारा की गई चार समता जांचों के उत्तरों को हां और ना के

18
00:00:59,449 --> 00:01:04,800
बजाय 1s और 0s के रूप में पढ़ते हैं, तो यह वस्तुतः बाइनरी में त्रुटि की स्थिति बताता है।

19
00:01:04,800 --> 00:01:08,827
उदाहरण के लिए, बाइनरी में संख्या 7 0111 की तरह दिखती है,

20
00:01:08,827 --> 00:01:12,640
अनिवार्य रूप से यह कहती है कि यह 4 प्लस 2 प्लस 1 है।

21
00:01:12,640 --> 00:01:17,891
और ध्यान दें कि स्थिति 7 कहाँ बैठती है, यह हमारे समता समूहों में से पहले,

22
00:01:17,891 --> 00:01:22,280
और दूसरे, और तीसरे को प्रभावित करती है, लेकिन अंतिम को नहीं।

23
00:01:22,280 --> 00:01:25,251
इसलिए नीचे से ऊपर तक उन चार जांचों के परिणामों को

24
00:01:25,251 --> 00:01:28,520
पढ़ने से वास्तव में त्रुटि की स्थिति का पता चल जाता है।

25
00:01:28,520 --> 00:01:32,433
उदाहरण 7 के बारे में कुछ खास नहीं है, यह सामान्य रूप से काम करता है,

26
00:01:32,433 --> 00:01:37,440
और यह हार्डवेयर में पूरी योजना को लागू करने के तर्क को आश्चर्यजनक रूप से सरल बनाता है।

27
00:01:37,440 --> 00:01:40,955
अब यदि आप यह देखना चाहते हैं कि यह जादू क्यों होता है,

28
00:01:40,955 --> 00:01:44,340
तो हमारी स्थिति के लिए इन 16 सूचकांक लेबलों को लें,

29
00:01:44,340 --> 00:01:49,027
लेकिन उन्हें आधार 10 में लिखने के बजाय, आइए उन सभी को बाइनरी में लिखें,

30
00:01:49,027 --> 00:01:50,720
0000 से 1111 तक चलते हुए।

31
00:01:50,720 --> 00:01:54,114
जैसे ही हम इन बाइनरी लेबलों को उनके बक्सों में वापस डालते हैं,

32
00:01:54,114 --> 00:01:58,440
मैं इस बात पर जोर देना चाहता हूं कि वे वास्तव में भेजे जा रहे डेटा से अलग हैं।

33
00:01:58,440 --> 00:02:01,320
वे आपको और मुझे यह समझने में मदद करने के लिए एक वैचारिक

34
00:02:01,320 --> 00:02:04,200
लेबल से ज्यादा कुछ नहीं हैं कि चार समता समूह कहां से आए।

35
00:02:04,200 --> 00:02:08,596
हम जो कुछ भी देख रहे हैं उसे बाइनरी में वर्णित करने की सुंदरता शायद इस भ्रम के

36
00:02:08,596 --> 00:02:13,160
कारण कम हो गई है कि हम जो कुछ भी देख रहे हैं उसका वर्णन बाइनरी में किया जा रहा है।

37
00:02:13,160 --> 00:02:15,040
हालाँकि, यह इसके लायक है।

38
00:02:15,040 --> 00:02:19,660
अपना ध्यान केवल इन सभी लेबलों के अंतिम बिट पर केंद्रित करें,

39
00:02:19,660 --> 00:02:24,280
और फिर उन स्थितियों को हाइलाइट करें जहां वह अंतिम बिट 1 है।

40
00:02:24,280 --> 00:02:27,942
हमें जो मिलता है वह हमारे चार समता समूहों में से पहला है,

41
00:02:27,942 --> 00:02:32,054
जिसका अर्थ है कि आप उस पहले चेक की व्याख्या यह पूछ सकते हैं कि,

42
00:02:32,054 --> 00:02:36,680
अरे, यदि कोई त्रुटि है, तो क्या उस त्रुटि की स्थिति में अंतिम बिट 1 है?

43
00:02:36,680 --> 00:02:40,572
इसी तरह, यदि आप दूसरे से अंतिम बिट पर ध्यान केंद्रित करते हैं,

44
00:02:40,572 --> 00:02:43,963
और उन सभी स्थितियों को हाइलाइट करते हैं जहां वह 1 है,

45
00:02:43,963 --> 00:02:47,040
तो आपको हमारी योजना से दूसरा समता समूह मिलता है।

46
00:02:47,040 --> 00:02:51,455
दूसरे शब्दों में, वह दूसरा चेक पूछ रहा है, अरे, मुझसे फिर से,

47
00:02:51,455 --> 00:02:56,160
यदि कोई त्रुटि है, तो क्या उस स्थिति का दूसरा से अंतिम बिट 1 है?

48
00:02:56,160 --> 00:02:57,160
और इसी तरह।

49
00:02:57,160 --> 00:03:04,002
तीसरी समता जांच प्रत्येक स्थिति को कवर करती है जिसका तीसरा से अंतिम बिट चालू होता है,

50
00:03:04,002 --> 00:03:10,120
और अंतिम अंतिम आठ स्थितियों को कवर करता है, वे जिनकी उच्चतम ऑर्डर बिट 1 है।

51
00:03:10,120 --> 00:03:15,463
हमने पहले जो कुछ भी किया वह इन चार प्रश्नों का उत्तर देने के समान है,

52
00:03:15,463 --> 00:03:19,800
जो बदले में बाइनरी में किसी स्थिति को बताने के समान है।

53
00:03:19,800 --> 00:03:22,080
मुझे आशा है कि इससे दो बातें स्पष्ट हो जाएंगी।

54
00:03:22,080 --> 00:03:24,610
पहला यह है कि उन आकारों को ब्लॉक करने के लिए व्यवस्थित

55
00:03:24,610 --> 00:03:27,140
रूप से सामान्यीकरण कैसे किया जाए जो दो की बड़ी घात हैं।

56
00:03:27,140 --> 00:03:30,955
यदि प्रत्येक स्थिति का वर्णन करने के लिए अधिक बिट्स की आवश्यकता होती है,

57
00:03:30,955 --> 00:03:33,446
जैसे 64 स्थानों का वर्णन करने के लिए छह बिट्स,

58
00:03:33,446 --> 00:03:37,209
तो उनमें से प्रत्येक बिट आपको समता समूहों में से एक देता है जिसे हमें

59
00:03:37,209 --> 00:03:38,640
जांचने की आवश्यकता होती है।

60
00:03:38,640 --> 00:03:41,989
आपमें से जिन लोगों ने मैट पार्कर के साथ मेरी शतरंज की बिसात पहेली देखी होगी,

61
00:03:41,989 --> 00:03:43,400
उन्हें यह सब बहुत परिचित लगेगा।

62
00:03:43,400 --> 00:03:46,611
यह वही मूल तर्क है, लेकिन एक अलग समस्या को हल कर रहा है,

63
00:03:46,611 --> 00:03:49,880
और इसे 64-वर्ग वाली शतरंज की बिसात पर लागू किया जाता है।

64
00:03:49,880 --> 00:03:54,017
दूसरी बात जो मुझे आशा है कि यह स्पष्ट करती है वह यह है कि हमारे समता बिट्स

65
00:03:54,017 --> 00:03:58,320
उन स्थितियों में क्यों बैठे हैं जो दो की घात हैं, उदाहरण के लिए 1, 2, 4, और 8।

66
00:03:58,320 --> 00:04:03,640
ये वे स्थितियाँ हैं जिनका द्विआधारी प्रतिनिधित्व केवल एक बिट चालू है।

67
00:04:03,640 --> 00:04:08,140
इसका मतलब यह है कि उनमें से प्रत्येक समता बिट चार

68
00:04:08,140 --> 00:04:12,640
समता समूहों में से एक और केवल एक के अंदर बैठता है।

69
00:04:12,640 --> 00:04:20,566
आप इसे बड़े उदाहरणों में भी देख सकते हैं, जहां चाहे आप कितना भी बड़ा हो जाएं,

70
00:04:20,566 --> 00:04:25,920
प्रत्येक समता बिट आसानी से केवल एक समूह को छूती है।

71
00:04:25,920 --> 00:04:30,522
एक बार जब आप समझ जाते हैं कि ये समता जाँचें जिन पर हमने अपना अधिकांश समय केंद्रित किया है,

72
00:04:30,522 --> 00:04:34,357
बाइनरी में त्रुटि की स्थिति बताने के एक चतुर तरीके से ज्यादा कुछ नहीं हैं,

73
00:04:34,357 --> 00:04:38,346
तो हम हैमिंग के बारे में सोचने के लिए एक अलग तरीके से संबंध बना सकते हैं कोड,

74
00:04:38,346 --> 00:04:40,851
एक ऐसा जो यकीनन बहुत सरल और अधिक सुरुचिपूर्ण है,

75
00:04:40,851 --> 00:04:43,920
और जिसे मूल रूप से कोड की एक पंक्ति के साथ लिखा जा सकता है।

76
00:04:43,920 --> 00:04:46,200
यह XOR फ़ंक्शन पर आधारित है.

77
00:04:46,200 --> 00:04:50,960
आपमें से जो लोग नहीं जानते उनके लिए XOR का मतलब एक्सक्लूसिव या है।

78
00:04:50,960 --> 00:04:57,240
जब आप दो बिट्स का एक्सओआर लेते हैं, तो यदि इनमें से कोई एक बिट चालू है तो यह 1 लौटाएगा,

79
00:04:57,240 --> 00:05:00,200
लेकिन यदि दोनों चालू या बंद हैं तो नहीं।

80
00:05:00,200 --> 00:05:03,760
अलग-अलग शब्दों में, यह इन दो बिट्स की समता है।

81
00:05:03,760 --> 00:05:07,840
एक गणितज्ञ के रूप में, मैं इसके बारे में अतिरिक्त मॉड 2 के रूप में सोचना पसंद करता हूँ।

82
00:05:07,840 --> 00:05:11,803
हम आम तौर पर दो अलग-अलग बिट स्ट्रिंग्स के एक्सओआर के बारे में भी बात करते हैं,

83
00:05:11,803 --> 00:05:14,040
जो मूल रूप से इस घटक को घटक द्वारा करता है।

84
00:05:14,040 --> 00:05:16,280
यह जोड़ की तरह है, लेकिन जहां आप कभी नहीं ले जाते।

85
00:05:16,280 --> 00:05:19,965
फिर, गणितीय रूप से अधिक इच्छुक लोग इसे दो वैक्टर जोड़ने

86
00:05:19,965 --> 00:05:23,520
और मॉड 2 को कम करने के रूप में सोचना पसंद कर सकते हैं।

87
00:05:23,520 --> 00:05:29,764
यदि आप अभी कुछ पायथन खोलते हैं और दो पूर्णांकों के बीच कैरेट ऑपरेशन लागू करते हैं,

88
00:05:29,764 --> 00:05:35,400
तो यह हुड के नीचे उन संख्याओं के बिट प्रतिनिधित्व के अलावा यही कर रहा है।

89
00:05:35,400 --> 00:05:40,571
आपके और मेरे लिए मुख्य बिंदु यह है कि कई अलग-अलग बिट स्ट्रिंग्स

90
00:05:40,571 --> 00:05:45,743
का एक्सओआर लेना प्रभावी रूप से अलग-अलग समूहों के समूह की पैरोडी

91
00:05:45,743 --> 00:05:51,320
की गणना करने का एक तरीका है, जैसे कि कॉलम के साथ, सभी एक ही झटके में।

92
00:05:51,320 --> 00:05:55,555
यह हमें हमारे हैमिंग कोड एल्गोरिदम से कई समता जांचों के बारे में सोचने का एक

93
00:05:55,555 --> 00:05:59,680
आसान तरीका देता है क्योंकि सभी को एक ही ऑपरेशन में एक साथ पैक किया जाता है।

94
00:05:59,680 --> 00:06:02,800
हालाँकि पहली नज़र में यह बहुत अलग दिखता है।

95
00:06:02,800 --> 00:06:08,384
विशेष रूप से 16 स्थितियों को बाइनरी में लिखें, जैसा कि हमने पहले किया था,

96
00:06:08,384 --> 00:06:14,198
और अब उन स्थितियों को हाइलाइट करें जहां संदेश बिट को 1 पर चालू किया गया है,

97
00:06:14,198 --> 00:06:19,400
और फिर इन स्थितियों को एक बड़े कॉलम में इकट्ठा करें और एक्सओआर लें।

98
00:06:19,400 --> 00:06:23,750
आप शायद अनुमान लगा सकते हैं कि परिणामस्वरूप नीचे बैठे 4 बिट्स उन

99
00:06:23,750 --> 00:06:28,034
4 समता जांचों के समान हैं जिन्हें हम जानते हैं और पसंद करते हैं,

100
00:06:28,034 --> 00:06:32,720
लेकिन वास्तव में ऐसा क्यों है इसके बारे में सोचने के लिए एक क्षण लें।

101
00:06:32,720 --> 00:06:37,346
उदाहरण के लिए, यह अंतिम कॉलम उन सभी स्थितियों की गिनती कर रहा है, जिनका अंतिम बिट 1 है,

102
00:06:37,346 --> 00:06:40,855
लेकिन हम पहले से ही केवल हाइलाइट की गई स्थितियों तक ही सीमित हैं,

103
00:06:40,855 --> 00:06:45,215
इसलिए यह प्रभावी रूप से गिनती कर रहा है कि पहले समता समूह से कितनी हाइलाइट की गई

104
00:06:45,215 --> 00:06:45,960
स्थिति आई हैं।

105
00:06:45,960 --> 00:06:48,520
समझ आया?

106
00:06:48,520 --> 00:06:53,932
इसी तरह, अगला कॉलम गिनता है कि दूसरे समता समूह में कितनी स्थितियाँ हैं,

107
00:06:53,932 --> 00:07:00,640
वे स्थितियाँ जिनका दूसरा से अंतिम बिट 1 है, और जिन्हें हाइलाइट भी किया गया है, इत्यादि।

108
00:07:00,640 --> 00:07:07,640
यह वास्तव में उसी चीज के परिप्रेक्ष्य में एक छोटा सा बदलाव है जो हम कर रहे हैं।

109
00:07:07,640 --> 00:07:10,000
और इसलिए आप जानते हैं कि यह यहाँ से कहाँ जाता है।

110
00:07:10,000 --> 00:07:14,485
प्रेषक यह सुनिश्चित करने के लिए कुछ विशेष समता

111
00:07:14,485 --> 00:07:19,640
बिट्स को टॉगल करने के लिए जिम्मेदार है कि योग 0000 हो।

112
00:07:19,640 --> 00:07:24,207
अब एक बार जब हमारे पास यह इस तरह हो जाता है, तो यह हमें यह सोचने का एक बहुत अच्छा

113
00:07:24,207 --> 00:07:28,720
तरीका देता है कि नीचे ये चार परिणामी बिट्स सीधे त्रुटि की स्थिति क्यों बताते हैं।

114
00:07:28,720 --> 00:07:32,720
मान लीजिए कि इस ब्लॉक में कुछ बिट 0 से 1 पर टॉगल हो जाता है।

115
00:07:32,720 --> 00:07:38,677
इसका मतलब यह है कि उस बिट की स्थिति अब कुल XOR में शामिल होने जा रही है,

116
00:07:38,677 --> 00:07:44,800
जो योग को 0 से बदलकर इस नए शामिल मूल्य, त्रुटि की स्थिति में बदल देती है।

117
00:07:44,800 --> 00:07:49,800
थोड़ा कम स्पष्ट रूप से, यदि कोई त्रुटि है जो 1 को 0 में बदल देती है तो भी यही सच है।

118
00:07:49,800 --> 00:07:53,120
आप देखिए, यदि आप एक बिट स्ट्रिंग को दो बार एक साथ जोड़ते हैं,

119
00:07:53,120 --> 00:07:56,060
तो यह वैसा ही है जैसे कि वहां इसका बिल्कुल भी न होना,

120
00:07:56,060 --> 00:07:59,000
मूल रूप से क्योंकि इस दुनिया में 1 प्लस 1 बराबर 0 है।

121
00:07:59,000 --> 00:08:02,168
इसलिए कुल योग में इस स्थिति की एक प्रति जोड़ने का

122
00:08:02,168 --> 00:08:05,400
वही प्रभाव होता है जो हम इसे आगे बढ़ा रहे होते हैं।

123
00:08:05,400 --> 00:08:13,480
और वह प्रभाव, फिर से, यह है कि यहां नीचे कुल परिणाम त्रुटि की स्थिति बताता है।

124
00:08:13,480 --> 00:08:17,851
यह समझाने के लिए कि यह कितना सुंदर है, मैं आपको पायथन कोड की वह एक पंक्ति दिखाता हूँ

125
00:08:17,851 --> 00:08:22,120
जिसका मैंने पहले उल्लेख किया था, जो रिसीवर के अंत में लगभग सभी तर्कों को पकड़ लेगा।

126
00:08:22,120 --> 00:08:27,410
हम डेटा ब्लॉक को अनुकरण करने के लिए 16 1s और 0s की एक यादृच्छिक सरणी बनाकर शुरू करेंगे,

127
00:08:27,410 --> 00:08:31,424
और मैं इसे बिट्स नाम दूंगा, लेकिन व्यवहार में यह कुछ ऐसा होगा जो

128
00:08:31,424 --> 00:08:35,498
हम एक प्रेषक से प्राप्त कर रहे हैं, और इसके बजाय यादृच्छिक होने के

129
00:08:35,498 --> 00:08:38,600
कारण इसमें 5 समता बिट्स के साथ 11 डेटा बिट्स होंगे।

130
00:08:38,600 --> 00:08:41,977
यदि मैं फ़ंक्शन एन्यूमरेट बिट्स को कॉल करता हूं,

131
00:08:41,977 --> 00:08:48,240
तो यह प्रत्येक बिट को संबंधित इंडेक्स के साथ जोड़ता है, इस मामले में 0 से 15 तक चलता है।

132
00:08:48,240 --> 00:08:52,227
इसलिए यदि हम एक सूची बनाते हैं जो इन सभी जोड़ियों पर लूप करती है,

133
00:08:52,227 --> 00:08:57,135
जो जोड़े जो i की तरह दिखते हैं, और फिर हम केवल i मान, केवल सूचकांक निकालते हैं,

134
00:08:57,135 --> 00:09:01,920
खैर यह उतना रोमांचक नहीं है, हम बस उन सूचकांकों को 0 से 15 तक वापस लाते हैं .

135
00:09:01,920 --> 00:09:05,746
लेकिन अगर हम केवल बिट होने पर ऐसा करने की शर्त जोड़ते हैं,

136
00:09:05,746 --> 00:09:08,847
जिसका अर्थ है कि यदि वह बिट 1 है और 0 नहीं है,

137
00:09:08,847 --> 00:09:13,400
तो यह केवल उन स्थितियों को बाहर निकालता है जहां संबंधित बिट चालू है।

138
00:09:13,400 --> 00:09:20,720
इस मामले में ऐसा लगता है कि वे स्थितियाँ 0, 4, 6, 9, आदि हैं।

139
00:09:20,720 --> 00:09:25,055
हम जो चाहते हैं वह उन सभी स्थितियों को, चालू किए गए बिट्स की

140
00:09:25,055 --> 00:09:29,960
स्थितियों को एक साथ इकट्ठा करना है, और फिर उन्हें एक साथ XOR करना है।

141
00:09:29,960 --> 00:09:33,960
पायथन में ऐसा करने के लिए, मुझे पहले कुछ उपयोगी फ़ंक्शन आयात करने दीजिए।

142
00:09:33,960 --> 00:09:36,296
इस तरह हम इस सूची में कम() को कॉल कर सकते हैं,

143
00:09:36,296 --> 00:09:39,140
और इसे कम करने के लिए XOR फ़ंक्शन का उपयोग कर सकते हैं।

144
00:09:39,140 --> 00:09:44,840
यह मूल रूप से सूची के माध्यम से अपना रास्ता खाता है, रास्ते में एक्सओआर ले जाता है।

145
00:09:44,840 --> 00:09:52,200
यदि आप चाहें, तो आप उस XOR फ़ंक्शन को कहीं से भी आयात किए बिना स्पष्ट रूप से लिख सकते हैं।

146
00:09:52,200 --> 00:09:58,128
तो फिलहाल ऐसा लगता है कि अगर हम 16 बिट्स के अपने यादृच्छिक ब्लॉक पर ऐसा करते हैं,

147
00:09:58,128 --> 00:10:02,080
तो यह 9 लौटाता है, जिसका बाइनरी प्रतिनिधित्व 1001 है।

148
00:10:02,080 --> 00:10:05,914
हम इसे यहां नहीं करेंगे, लेकिन आप एक फ़ंक्शन लिख सकते हैं जहां प्रेषक

149
00:10:05,914 --> 00:10:10,571
आवश्यकतानुसार चार समता बिट्स सेट करने के लिए उस बाइनरी प्रतिनिधित्व का उपयोग करता है,

150
00:10:10,571 --> 00:10:14,296
अंततः इस ब्लॉक को उस स्थिति में ले जाता है जहां बिट्स की पूरी सूची

151
00:10:14,296 --> 00:10:17,200
पर कोड की इस पंक्ति को चलाने पर रिटर्न मिलता है एक 0.

152
00:10:17,200 --> 00:10:20,200
इसे एक अच्छी तरह से तैयार ब्लॉक माना जाएगा।

153
00:10:20,200 --> 00:10:23,757
अच्छी बात यह है कि यदि हम शोर से यादृच्छिक त्रुटि का अनुकरण करते

154
00:10:23,757 --> 00:10:26,385
हुए इस सूची में से किसी एक बिट को टॉगल करते हैं,

155
00:10:26,385 --> 00:10:30,600
तो यदि आप कोड की इसी पंक्ति को चलाते हैं, तो यह उस त्रुटि को प्रिंट करता है।

156
00:10:30,600 --> 00:10:31,920
क्या वह साफ़-सुथरा नहीं है?

157
00:10:31,920 --> 00:10:37,287
आप इस ब्लॉक को अचानक से प्राप्त कर सकते हैं, इस पर इस एकल पंक्ति को चला सकते हैं,

158
00:10:37,287 --> 00:10:42,920
और यह स्वचालित रूप से किसी त्रुटि की स्थिति या यदि कोई त्रुटि नहीं है तो 0 बता देगा।

159
00:10:42,920 --> 00:10:45,520
और यहां साइज 16 के बारे में कुछ खास नहीं है।

160
00:10:45,520 --> 00:10:52,280
यदि आपके पास, मान लीजिए, 256 बिट्स की सूची है, तो कोड की वही पंक्ति काम करेगी।

161
00:10:52,280 --> 00:10:56,175
कहने की जरूरत नहीं है, यहां लिखने के लिए और भी कोड हैं, जैसे 2-

162
00:10:56,175 --> 00:10:59,638
बिट त्रुटियों का पता लगाने के लिए मेटा पैरिटी जांच करना,

163
00:10:59,638 --> 00:11:05,080
लेकिन विचार यह है कि हमारी योजना के लगभग सभी मुख्य तर्क एक ही एक्सओआर कटौती पर आते हैं।

164
00:11:05,080 --> 00:11:09,712
अब, सामान्य रूप से बाइनरी और एक्सओआर और सॉफ़्टवेयर के साथ आपकी सुविधा के आधार पर,

165
00:11:09,712 --> 00:11:13,257
आपको या तो यह परिप्रेक्ष्य थोड़ा भ्रमित करने वाला लग सकता है,

166
00:11:13,257 --> 00:11:18,176
या इतना अधिक सुरुचिपूर्ण और सरल कि आप सोच रहे होंगे कि हमने शुरुआत से ही इसकी शुरुआत

167
00:11:18,176 --> 00:11:19,320
क्यों नहीं की -जाना।

168
00:11:19,320 --> 00:11:23,494
संक्षेप में कहें तो, हार्डवेयर में हैमिंग कोड को बहुत सीधे लागू करते समय मल्टीपल

169
00:11:23,494 --> 00:11:26,329
पैरिटी चेक परिप्रेक्ष्य के बारे में सोचना आसान होता है,

170
00:11:26,329 --> 00:11:30,452
और सॉफ़्टवेयर में इसे उच्च स्तर से करते समय XOR परिप्रेक्ष्य के बारे में सोचना

171
00:11:30,452 --> 00:11:31,380
सबसे आसान होता है।

172
00:11:31,380 --> 00:11:36,365
पहला वास्तव में हाथ से करना सबसे आसान है, और मुझे लगता है कि यह इन सबके अंतर्निहित

173
00:11:36,365 --> 00:11:39,548
मूल अंतर्ज्ञान को स्थापित करने में बेहतर काम करता है,

174
00:11:39,548 --> 00:11:44,473
जो यह है कि एक त्रुटि का पता लगाने के लिए आवश्यक जानकारी ब्लॉक के आकार के लॉग से

175
00:11:44,473 --> 00:11:49,158
संबंधित है , या दूसरे शब्दों में, जैसे-जैसे ब्लॉक का आकार दोगुना होता जाता है,

176
00:11:49,158 --> 00:11:51,020
यह एक बार में एक बिट बढ़ता है।

177
00:11:51,020 --> 00:11:53,730
यहां प्रासंगिक तथ्य यह है कि वह जानकारी सीधे तौर पर इस

178
00:11:53,730 --> 00:11:56,440
बात से मेल खाती है कि हमें कितनी अतिरेक की आवश्यकता है।

179
00:11:56,440 --> 00:12:00,084
यह वास्तव में ज्यादातर लोगों की त्वरित प्रतिक्रिया के विपरीत है जब वे पहली

180
00:12:00,084 --> 00:12:03,535
बार किसी संदेश को त्रुटियों के प्रति लचीला बनाने के बारे में सोचते हैं,

181
00:12:03,535 --> 00:12:07,520
जहां आम तौर पर पूरे संदेश की नकल करना पहली प्रवृत्ति होती है जो दिमाग में आती है।

182
00:12:07,520 --> 00:12:12,082
और फिर, वैसे, यह एक और तरीका है जिसमें आप कभी-कभी हैमिंग कोड प्रस्तुत करते हुए देखते हैं,

183
00:12:12,082 --> 00:12:14,800
जहां आप संदेश को एक बड़े मैट्रिक्स से गुणा करते हैं।

184
00:12:14,800 --> 00:12:18,931
यह अच्छा है क्योंकि यह इसे रैखिक कोड के व्यापक परिवार से जोड़ता है,

185
00:12:18,931 --> 00:12:24,050
लेकिन मुझे लगता है कि यह लगभग कोई अंतर्ज्ञान नहीं देता है कि यह कहां से आता है या

186
00:12:24,050 --> 00:12:25,160
इसका आकार कैसा है।

187
00:12:25,160 --> 00:12:28,218
और स्केलिंग की बात करते हुए, आप देख सकते हैं कि जैसे-

188
00:12:28,218 --> 00:12:32,200
जैसे हम ब्लॉक आकार बढ़ाते हैं, इस योजना की दक्षता बेहतर होती जाती है।

189
00:12:32,200 --> 00:12:37,840
उदाहरण के लिए, हमने देखा कि 256 बिट्स के साथ, आप उस स्थान का केवल 3%

190
00:12:37,840 --> 00:12:43,480
अतिरेक के लिए उपयोग कर रहे हैं, और यह वहां से बेहतर होता जा रहा है।

191
00:12:43,480 --> 00:12:46,901
जैसे-जैसे समता बिट्स की संख्या एक-एक करके बढ़ती जाती है,

192
00:12:46,901 --> 00:12:49,040
ब्लॉक का आकार दोगुना होता जाता है।

193
00:12:49,040 --> 00:12:53,019
और यदि आप इसे चरम सीमा तक ले जाते हैं, तो आपके पास एक मिलियन बिट्स

194
00:12:53,019 --> 00:12:58,246
वाला एक ब्लॉक हो सकता है, जहां आप वस्तुतः अपने समता जांच के साथ 20 प्रश्न खेल रहे होंगे,

195
00:12:58,246 --> 00:13:00,800
और यह केवल 21 समता बिट्स का उपयोग करता है।

196
00:13:00,800 --> 00:13:04,632
और यदि आप एक लाख बिट्स को देखने और एक त्रुटि का पता लगाने के बारे

197
00:13:04,632 --> 00:13:08,640
में सोचने के लिए पीछे हटते हैं, तो यह वास्तव में पागलपन जैसा लगता है।

198
00:13:08,640 --> 00:13:13,407
निस्संदेह, समस्या यह है कि बड़े ब्लॉक के साथ, एक या दो से अधिक बिट त्रुटियाँ

199
00:13:13,407 --> 00:13:18,360
देखने की संभावना बढ़ जाती है, और हैमिंग कोड इससे आगे कुछ भी संभाल नहीं पाते हैं।

200
00:13:18,360 --> 00:13:22,402
इसलिए व्यवहार में, आप जो चाहते हैं वह सही आकार ढूंढना

201
00:13:22,402 --> 00:13:26,520
है ताकि बहुत अधिक बिट फ़्लिप की संभावना बहुत अधिक न हो।

202
00:13:26,520 --> 00:13:30,617
इसके अलावा, व्यवहार में, त्रुटियां छोटे-छोटे विस्फोटों में आती हैं,

203
00:13:30,617 --> 00:13:34,348
जो एक ब्लॉक को पूरी तरह से बर्बाद कर देती हैं, इसलिए कई अलग-

204
00:13:34,348 --> 00:13:39,119
अलग ब्लॉकों में त्रुटियों के विस्फोट को फैलाने में मदद करने के लिए एक सामान्य

205
00:13:39,119 --> 00:13:43,889
रणनीति उन ब्लॉकों को इस तरह से जोड़ना है, इससे पहले कि वे समाप्त हो जाएं बाहर

206
00:13:43,889 --> 00:13:45,480
भेजा या संग्रहीत किया गया।

207
00:13:45,480 --> 00:13:49,494
फिर, इसमें से बहुत कुछ को अधिक आधुनिक कोड द्वारा पूरी तरह से म्यूट कर दिया गया है,

208
00:13:49,494 --> 00:13:52,725
जैसे कि अधिक सामान्यतः उपयोग किया जाने वाला रीड-सोलोमन एल्गोरिदम,

209
00:13:52,725 --> 00:13:55,761
जो विशेष रूप से विस्फोट त्रुटियों को अच्छी तरह से संभालता है,

210
00:13:55,761 --> 00:13:59,580
और इसे प्रति ब्लॉक बड़ी संख्या में त्रुटियों के लिए लचीला बनाया जा सकता है। .

211
00:13:59,580 --> 00:14:03,000
लेकिन यह अगली बार का विषय है।

212
00:14:03,000 --> 00:14:05,790
अपनी पुस्तक द आर्ट ऑफ डूइंग साइंस एंड इंजीनियरिंग में,

213
00:14:05,790 --> 00:14:10,234
हैमिंग ने आश्चर्यजनक रूप से स्पष्ट रूप से बताया है कि इस कोड की उनकी खोज कितनी टेढ़ी-

214
00:14:10,234 --> 00:14:10,700
मेढ़ी थी।

215
00:14:10,700 --> 00:14:14,483
उन्होंने सबसे पहले बिट्स को उच्च आयामी जाली के हिस्सों में व्यवस्थित करने

216
00:14:14,483 --> 00:14:18,420
और इस तरह की अजीब चीजों से संबंधित सभी प्रकार की विभिन्न योजनाओं की कोशिश की।

217
00:14:18,420 --> 00:14:23,890
यह विचार कि किसी त्रुटि की स्थिति बताने के लिए समता जांच प्राप्त करना संभव हो सकता है,

218
00:14:23,890 --> 00:14:28,725
हेमिंग को तभी आया जब वह कई अन्य विश्लेषणों के बाद पीछे हटे और पूछा, ठीक है,

219
00:14:28,725 --> 00:14:32,860
मैं सबसे कुशल क्या कर सकता हूं क्या आप इस बारे में सोच सकते हैं?

220
00:14:32,860 --> 00:14:37,479
वह इस बारे में भी स्पष्ट थे कि यह कितना महत्वपूर्ण है कि समता जांच पहले से ही

221
00:14:37,479 --> 00:14:42,040
उनके दिमाग में थी, जो कि आज की तुलना में 1940 के दशक में बहुत कम आम रही होगी।

222
00:14:42,040 --> 00:14:45,872
इस पुस्तक में लगभग आधा दर्जन बार उन्होंने लुई पाश्चर के इस

223
00:14:45,872 --> 00:14:49,640
कथन का संदर्भ दिया है कि भाग्य तैयार दिमाग का साथ देता है।

224
00:14:49,640 --> 00:14:52,763
चतुर विचार अक्सर बाद में भ्रामक रूप से सरल दिखते हैं,

225
00:14:52,763 --> 00:14:55,120
जिससे उनकी सराहना करना आसान हो जाता है।

226
00:14:55,120 --> 00:15:00,060
अभी मेरी ईमानदार आशा यह है कि हैमिंग कोड, या कम से कम ऐसे कोड की संभावना,

227
00:15:00,060 --> 00:15:01,820
आपको लगभग स्पष्ट लगती है।

228
00:15:01,820 --> 00:15:06,048
लेकिन आपको यह सोचकर खुद को मूर्ख नहीं बनाना चाहिए कि वे वास्तव में स्पष्ट हैं,

229
00:15:06,048 --> 00:15:08,000
क्योंकि वे निश्चित रूप से नहीं हैं।

230
00:15:08,000 --> 00:15:11,952
चतुर विचारों के भ्रामक रूप से आसान दिखने का एक कारण यह है कि हम केवल

231
00:15:11,952 --> 00:15:14,815
अंतिम परिणाम देखते हैं, जो गड़बड़ था उसे साफ करना,

232
00:15:14,815 --> 00:15:18,653
सभी गलत मोड़ों का कभी उल्लेख नहीं करना, किसी समस्या की शुरुआत में

233
00:15:18,653 --> 00:15:23,579
अन्वेषण योग्य संभावनाओं का स्थान कितना विशाल है, इसकी कम बिक्री करना समाधान प्रक्रिया,

234
00:15:23,579 --> 00:15:23,980
वह सब।

235
00:15:23,980 --> 00:15:25,280
लेकिन यह सामान्य तौर पर सच है.

236
00:15:25,280 --> 00:15:28,453
मुझे लगता है कि कुछ विशेष आविष्कारों के लिए, एक दूसरा,

237
00:15:28,453 --> 00:15:31,040
गहरा कारण है कि हम उनकी कम सराहना करते हैं।

238
00:15:31,040 --> 00:15:33,721
सूचना सिद्धांत पर क्लाउड शैनन के मौलिक पेपर के साथ,

239
00:15:33,721 --> 00:15:37,664
बिट्स के संदर्भ में जानकारी के बारे में सोचना वास्तव में 1948 तक एक पूर्ण

240
00:15:37,664 --> 00:15:39,400
सिद्धांत में परिवर्तित हो गया था।

241
00:15:39,400 --> 00:15:43,440
यह अनिवार्य रूप से तब समवर्ती था जब हैमिंग ने अपना एल्गोरिदम विकसित किया था।

242
00:15:43,440 --> 00:15:49,121
यह वही मूलभूत पेपर था जिसने एक निश्चित अर्थ में दिखाया कि कुशल त्रुटि सुधार हमेशा संभव है,

243
00:15:49,121 --> 00:15:53,920
चाहे बिट फ़्लिप की संभावना कितनी भी अधिक क्यों न हो, कम से कम सिद्धांत में।

244
00:15:53,920 --> 00:15:56,916
वैसे, बहुत अलग-अलग चीजों पर काम करने के बावजूद,

245
00:15:56,916 --> 00:16:02,400
शैनन और हैमिंग ने बेल लैब्स में एक कार्यालय साझा किया, जो यहां शायद ही संयोग लगता है।

246
00:16:02,400 --> 00:16:05,716
कई दशक तेजी से आगे बढ़े, और इन दिनों, हममें से कई लोग छोटी-

247
00:16:05,716 --> 00:16:09,201
छोटी बातों और सूचनाओं के बारे में सोचने में इतने डूबे हुए हैं

248
00:16:09,201 --> 00:16:13,080
कि इस बात को नजरअंदाज करना आसान है कि सोचने का यह तरीका कितना अलग था।

249
00:16:13,080 --> 00:16:15,484
विडंबना यह है कि जो विचार भविष्य की पीढ़ी के सोचने के तरीकों को सबसे गहराई से

250
00:16:15,484 --> 00:16:17,920
आकार देते हैं, वे भविष्य की पीढ़ी को वास्तव में उनकी तुलना में अधिक सरल लगेंगे।

