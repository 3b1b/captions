1
00:00:00,000 --> 00:00:03,120
मैं मान रहा हूं कि यहां हर कोई भाग 1 से आ रहा है।

2
00:00:03,120 --> 00:00:06,920
हम हैमिंग कोड के बारे में बात कर रहे थे, डेटा का एक ब्लॉक बनाने का एक

3
00:00:06,920 --> 00:00:11,640
तरीका जहां अधिकांश बिट्स एक सार्थक संदेश ले जाते हैं, जबकि कुछ अन्य एक प्रकार की

4
00:00:11,640 --> 00:00:15,800
अतिरेक के रूप में कार्य करते हैं, इस तरह से कि यदि कोई बिट फ़्लिप हो

5
00:00:15,800 --> 00:00:20,560
जाता है, तो या तो एक संदेश बिट या अतिरेक बिट, इस ब्लॉक में कुछ भी,

6
00:00:20,560 --> 00:00:21,920
रिसीवर यह पहचानने में सक्षम होगा कि कोई त्रुटि थी, और इसे कैसे ठीक किया जाए।

7
00:00:21,920 --> 00:00:25,900
वहां प्रस्तुत मूल विचार यह था कि त्रुटि तक पहुंचने के लिए

8
00:00:25,900 --> 00:00:29,800
बाइनरी खोज के लिए एकाधिक समता जांच का उपयोग कैसे किया जाए।

9
00:00:29,800 --> 00:00:33,920
उस वीडियो में लक्ष्य हैमिंग कोड को यथासंभव

10
00:00:33,920 --> 00:00:35,420
व्यावहारिक और पुनः खोज योग्य बनाना था।

11
00:00:35,420 --> 00:00:40,040
लेकिन जैसे ही आप वास्तव में इसे सॉफ़्टवेयर या हार्डवेयर में लागू करने के बारे में सोचना शुरू करते

12
00:00:40,040 --> 00:00:44,120
हैं, वह फ़्रेमिंग वास्तव में कम बिक्री कर सकती है कि ये कोड वास्तव में कितने सुरुचिपूर्ण हैं।

13
00:00:44,120 --> 00:00:47,620
आप सोच सकते हैं कि आपको एक एल्गोरिदम लिखने की ज़रूरत है जो सभी

14
00:00:47,620 --> 00:00:52,320
संभावित त्रुटि स्थानों पर नज़र रखता है और प्रत्येक चेक के साथ उस समूह

15
00:00:52,320 --> 00:00:54,160
को आधा कर देता है, लेकिन वास्तव में यह उससे कहीं अधिक सरल है।

16
00:00:54,160 --> 00:00:58,720
यदि आप पिछले वीडियो में हमारे द्वारा की गई चार समता जांचों के उत्तरों को हां और ना के

17
00:00:58,760 --> 00:01:04,800
बजाय 1s और 0s के रूप में पढ़ते हैं, तो यह वस्तुतः बाइनरी में त्रुटि की स्थिति बताता है।

18
00:01:04,800 --> 00:01:10,160
उदाहरण के लिए, बाइनरी में संख्या 7 0111 की तरह दिखती है, अनिवार्य

19
00:01:10,160 --> 00:01:12,640
रूप से यह कहती है कि यह 4 प्लस 2 प्लस 1 है।

20
00:01:12,640 --> 00:01:17,960
और ध्यान दें कि स्थिति 7 कहाँ बैठती है, यह हमारे समता समूहों में

21
00:01:17,960 --> 00:01:22,280
से पहले, और दूसरे, और तीसरे को प्रभावित करती है, लेकिन अंतिम को नहीं।

22
00:01:22,280 --> 00:01:26,560
इसलिए नीचे से ऊपर तक उन चार जांचों के परिणामों को पढ़ने

23
00:01:26,560 --> 00:01:28,000
से वास्तव में त्रुटि की स्थिति का पता चल जाता है।

24
00:01:28,520 --> 00:01:32,240
उदाहरण 7 के बारे में कुछ खास नहीं है, यह सामान्य रूप से काम करता है, और

25
00:01:32,240 --> 00:01:37,440
यह हार्डवेयर में पूरी योजना को लागू करने के तर्क को आश्चर्यजनक रूप से सरल बनाता है।

26
00:01:37,440 --> 00:01:43,380
अब यदि आप यह देखना चाहते हैं कि यह जादू क्यों होता है, तो हमारी

27
00:01:43,380 --> 00:01:48,480
स्थिति के लिए इन 16 सूचकांक लेबलों को लें, लेकिन उन्हें आधार 10 में लिखने

28
00:01:48,480 --> 00:01:50,720
के बजाय, आइए उन सभी को बाइनरी में लिखें, 0000 से 1111 तक चलते हुए।

29
00:01:50,720 --> 00:01:55,880
जैसे ही हम इन बाइनरी लेबलों को उनके बक्सों में वापस डालते हैं, मैं इस बात

30
00:01:56,080 --> 00:01:58,440
पर जोर देना चाहता हूं कि वे वास्तव में भेजे जा रहे डेटा से अलग हैं।

31
00:01:58,440 --> 00:02:02,200
वे आपको और मुझे यह समझने में मदद करने के लिए एक वैचारिक

32
00:02:02,200 --> 00:02:04,200
लेबल से ज्यादा कुछ नहीं हैं कि चार समता समूह कहां से आए।

33
00:02:04,200 --> 00:02:08,840
हम जो कुछ भी देख रहे हैं उसे बाइनरी में वर्णित करने की सुंदरता शायद इस भ्रम के कारण कम

34
00:02:08,840 --> 00:02:13,160
हो गई है कि हम जो कुछ भी देख रहे हैं उसका वर्णन बाइनरी में किया जा रहा है।

35
00:02:13,160 --> 00:02:15,040
हालाँकि, यह इसके लायक है।

36
00:02:15,040 --> 00:02:20,740
अपना ध्यान केवल इन सभी लेबलों के अंतिम बिट पर केंद्रित करें, और

37
00:02:20,740 --> 00:02:24,280
फिर उन स्थितियों को हाइलाइट करें जहां वह अंतिम बिट 1 है।

38
00:02:24,280 --> 00:02:28,800
हमें जो मिलता है वह हमारे चार समता समूहों में से पहला है, जिसका अर्थ

39
00:02:28,800 --> 00:02:34,480
है कि आप उस पहले चेक की व्याख्या यह पूछ सकते हैं कि, अरे, यदि

40
00:02:34,480 --> 00:02:36,680
कोई त्रुटि है, तो क्या उस त्रुटि की स्थिति में अंतिम बिट 1 है?

41
00:02:36,680 --> 00:02:42,600
इसी तरह, यदि आप दूसरे से अंतिम बिट पर ध्यान केंद्रित करते हैं, और उन सभी स्थितियों को

42
00:02:42,600 --> 00:02:47,040
हाइलाइट करते हैं जहां वह 1 है, तो आपको हमारी योजना से दूसरा समता समूह मिलता है।

43
00:02:47,040 --> 00:02:51,960
दूसरे शब्दों में, वह दूसरा चेक पूछ रहा है, अरे, मुझसे फिर से, यदि

44
00:02:51,960 --> 00:02:56,160
कोई त्रुटि है, तो क्या उस स्थिति का दूसरा से अंतिम बिट 1 है?

45
00:02:56,160 --> 00:02:57,160
और इसी तरह।

46
00:02:57,160 --> 00:03:03,320
तीसरी समता जांच प्रत्येक स्थिति को कवर करती है जिसका तीसरा से अंतिम बिट चालू होता है,

47
00:03:03,320 --> 00:03:10,120
और अंतिम अंतिम आठ स्थितियों को कवर करता है, वे जिनकी उच्चतम ऑर्डर बिट 1 है।

48
00:03:10,120 --> 00:03:15,680
हमने पहले जो कुछ भी किया वह इन चार प्रश्नों का उत्तर देने के

49
00:03:15,680 --> 00:03:18,800
समान है, जो बदले में बाइनरी में किसी स्थिति को बताने के समान है।

50
00:03:19,800 --> 00:03:22,080
मुझे आशा है कि इससे दो बातें स्पष्ट हो जाएंगी।

51
00:03:22,080 --> 00:03:27,140
पहला यह है कि उन आकारों को ब्लॉक करने के लिए व्यवस्थित रूप से सामान्यीकरण कैसे किया जाए जो दो की बड़ी घात हैं।

52
00:03:27,140 --> 00:03:33,180
यदि प्रत्येक स्थिति का वर्णन करने के लिए अधिक बिट्स की आवश्यकता होती है, जैसे 64 स्थानों का वर्णन करने के लिए

53
00:03:33,180 --> 00:03:38,640
छह बिट्स, तो उनमें से प्रत्येक बिट आपको समता समूहों में से एक देता है जिसे हमें जांचने की आवश्यकता होती है।

54
00:03:38,640 --> 00:03:42,060
आपमें से जिन लोगों ने मैट पार्कर के साथ मेरी शतरंज

55
00:03:42,060 --> 00:03:43,400
की बिसात पहेली देखी होगी, उन्हें यह सब बहुत परिचित लगेगा।

56
00:03:43,400 --> 00:03:48,200
यह वही मूल तर्क है, लेकिन एक अलग समस्या को हल कर रहा

57
00:03:48,200 --> 00:03:49,880
है, और इसे 64-वर्ग वाली शतरंज की बिसात पर लागू किया जाता है।

58
00:03:49,880 --> 00:03:54,000
दूसरी बात जो मुझे आशा है कि इससे स्पष्ट हो जाएगी वह यह है कि हमारे समता बिट्स उन

59
00:03:54,000 --> 00:03:58,320
स्थितियों में क्यों बैठे हैं जो दो की घात हैं, उदाहरण के लिए 1, 2, 4, और 8।

60
00:03:58,320 --> 00:04:03,640
ये वे स्थितियाँ हैं जिनका द्विआधारी प्रतिनिधित्व केवल एक बिट चालू है।

61
00:04:03,640 --> 00:04:09,000
इसका मतलब यह है कि उनमें से प्रत्येक समता बिट चार समता

62
00:04:09,000 --> 00:04:12,640
समूहों में से एक और केवल एक के अंदर बैठता है।

63
00:04:12,640 --> 00:04:16,840
आप इसे बड़े उदाहरणों में भी देख सकते हैं, जहां चाहे आप कितना भी

64
00:04:16,840 --> 00:04:25,920
बड़ा हो जाएं, प्रत्येक समता बिट आसानी से केवल एक समूह को छूती है।

65
00:04:25,920 --> 00:04:29,680
एक बार जब आप समझ जाते हैं कि ये समता जाँचें जिन पर हमने अपना अधिकांश

66
00:04:29,680 --> 00:04:34,320
समय केंद्रित किया है, बाइनरी में त्रुटि की स्थिति बताने के एक चतुर तरीके से ज्यादा

67
00:04:34,320 --> 00:04:37,880
कुछ नहीं हैं, तो हम हैमिंग के बारे में सोचने के लिए एक अलग तरीके

68
00:04:37,880 --> 00:04:42,160
से संबंध बना सकते हैं कोड, एक ऐसा जो यकीनन बहुत सरल और अधिक सुरुचिपूर्ण है,

69
00:04:42,160 --> 00:04:43,880
और जिसे मूल रूप से कोड की एक पंक्ति के साथ लिखा जा सकता है।

70
00:04:43,920 --> 00:04:46,200
यह XOR फ़ंक्शन पर आधारित है.

71
00:04:46,200 --> 00:04:50,960
आपमें से जो लोग नहीं जानते उनके लिए XOR का मतलब एक्सक्लूसिव या है।

72
00:04:50,960 --> 00:04:55,440
जब आप दो बिट्स का एक्सओआर लेते हैं, तो यदि इनमें से कोई भी एक बिट

73
00:04:55,440 --> 00:05:00,200
चालू है तो यह 1 लौटाएगा, लेकिन यदि दोनों चालू या बंद हैं तो नहीं।

74
00:05:00,200 --> 00:05:03,760
अलग-अलग शब्दों में, यह इन दो बिट्स की समता है।

75
00:05:03,760 --> 00:05:07,840
एक गणितज्ञ के रूप में, मैं इसके बारे में अतिरिक्त मॉड 2 के रूप में सोचना पसंद करता हूँ।

76
00:05:07,840 --> 00:05:12,000
हम आम तौर पर दो अलग-अलग बिट स्ट्रिंग्स के एक्सओआर के बारे में भी

77
00:05:12,040 --> 00:05:14,040
बात करते हैं, जो मूल रूप से इस घटक को घटक द्वारा करता है।

78
00:05:14,040 --> 00:05:16,280
यह जोड़ की तरह है, लेकिन जहां आप कभी नहीं ले जाते।

79
00:05:16,280 --> 00:05:21,240
फिर, गणितीय रूप से अधिक इच्छुक लोग इसे दो वैक्टर जोड़ने और मॉड

80
00:05:21,240 --> 00:05:23,520
2 को कम करने के रूप में सोचना पसंद कर सकते हैं।

81
00:05:23,520 --> 00:05:28,720
यदि आप अभी कुछ पायथन खोलते हैं और दो पूर्णांकों के बीच कैरेट ऑपरेशन लागू करते हैं,

82
00:05:28,720 --> 00:05:35,400
तो यह हुड के नीचे उन संख्याओं के बिट प्रतिनिधित्व के अलावा यही कर रहा है।

83
00:05:35,400 --> 00:05:40,920
आपके और मेरे लिए मुख्य बिंदु यह है कि कई अलग-अलग बिट स्ट्रिंग्स का

84
00:05:40,960 --> 00:05:45,960
एक्सओआर लेना प्रभावी रूप से अलग-अलग समूहों के समूह की पैरोडी की गणना करने

85
00:05:45,960 --> 00:05:51,320
का एक तरीका है, जैसे कि कॉलम के साथ, सभी एक ही झटके में।

86
00:05:51,320 --> 00:05:54,520
यह हमें हमारे हैमिंग कोड एल्गोरिदम से कई समता जांचों के बारे में सोचने का एक आसान

87
00:05:54,520 --> 00:05:59,680
तरीका देता है क्योंकि सभी को एक ही ऑपरेशन में एक साथ पैक किया जाता है।

88
00:05:59,680 --> 00:06:02,800
हालाँकि पहली नज़र में यह बहुत अलग दिखता है।

89
00:06:02,800 --> 00:06:08,360
विशेष रूप से 16 स्थितियों को बाइनरी में लिखें, जैसा कि हमने पहले किया था, और

90
00:06:08,640 --> 00:06:14,800
अब उन स्थितियों को हाइलाइट करें जहां संदेश बिट को 1 पर चालू किया गया

91
00:06:14,800 --> 00:06:19,400
है, और फिर इन स्थितियों को एक बड़े कॉलम में इकट्ठा करें और एक्सओआर लें।

92
00:06:19,400 --> 00:06:23,480
आप शायद अनुमान लगा सकते हैं कि परिणामस्वरूप नीचे बैठे 4 बिट्स उन 4

93
00:06:23,480 --> 00:06:27,480
समता जांचों के समान हैं जिन्हें हम जानते हैं और पसंद करते हैं, लेकिन

94
00:06:27,480 --> 00:06:32,720
वास्तव में ऐसा क्यों है इसके बारे में सोचने के लिए एक क्षण लें।

95
00:06:32,720 --> 00:06:37,880
उदाहरण के लिए, यह अंतिम कॉलम उन सभी स्थितियों की गिनती कर रहा है, जिनका अंतिम बिट 1

96
00:06:38,400 --> 00:06:42,400
है, लेकिन हम पहले से ही केवल हाइलाइट की गई स्थितियों तक ही सीमित हैं, इसलिए यह प्रभावी

97
00:06:42,400 --> 00:06:45,960
रूप से गिनती कर रहा है कि पहले समता समूह से कितनी हाइलाइट की गई स्थिति आई हैं।

98
00:06:45,960 --> 00:06:48,520
समझ आया?

99
00:06:48,520 --> 00:06:53,600
इसी तरह, अगला कॉलम गिनता है कि दूसरे समता समूह में

100
00:06:53,600 --> 00:06:59,640
कितनी स्थितियाँ हैं, वे स्थितियाँ जिनका दूसरा से अंतिम बिट

101
00:06:59,640 --> 00:07:00,640
1 है, और जिन्हें हाइलाइट भी किया गया है, इत्यादि।

102
00:07:00,640 --> 00:07:06,640
यह वास्तव में उसी चीज के परिप्रेक्ष्य में एक छोटा सा बदलाव है जो हम कर रहे हैं।

103
00:07:07,640 --> 00:07:10,000
और इसलिए आप जानते हैं कि यह यहाँ से कहाँ जाता है।

104
00:07:10,000 --> 00:07:14,400
प्रेषक यह सुनिश्चित करने के लिए कुछ विशेष समता बिट्स को

105
00:07:14,400 --> 00:07:19,640
टॉगल करने के लिए जिम्मेदार है कि योग 0000 हो।

106
00:07:19,640 --> 00:07:23,600
अब एक बार जब हमारे पास यह इस तरह हो जाता है, तो यह हमें यह सोचने का एक

107
00:07:23,600 --> 00:07:28,720
बहुत अच्छा तरीका देता है कि नीचे ये चार परिणामी बिट्स सीधे त्रुटि की स्थिति क्यों बताते हैं।

108
00:07:28,720 --> 00:07:32,680
मान लीजिए कि इस ब्लॉक में कुछ बिट 0 से 1 पर टॉगल हो जाता है।

109
00:07:32,720 --> 00:07:37,320
इसका मतलब यह है कि उस बिट की स्थिति अब कुल XOR

110
00:07:37,320 --> 00:07:42,960
में शामिल होने जा रही है, जो योग को 0 से बदलकर

111
00:07:42,960 --> 00:07:44,800
इस नए शामिल मूल्य, त्रुटि की स्थिति में बदल देती है।

112
00:07:44,800 --> 00:07:48,800
थोड़ा कम स्पष्ट रूप से, यदि कोई त्रुटि है जो 1

113
00:07:48,800 --> 00:07:49,800
को 0 में बदल देती है तो भी यही सच है।

114
00:07:49,800 --> 00:07:54,720
आप देखते हैं, यदि आप एक बिट स्ट्रिंग को दो बार एक साथ जोड़ते हैं, तो यह वैसा ही है जैसे

115
00:07:54,720 --> 00:07:59,000
कि वहां इसका बिल्कुल भी न होना, मूल रूप से क्योंकि इस दुनिया में 1 प्लस 1 बराबर 0 है।

116
00:07:59,000 --> 00:08:03,720
इसलिए कुल योग में इस स्थिति की एक प्रति जोड़ने का वही

117
00:08:03,720 --> 00:08:05,400
प्रभाव होता है जो हम इसे आगे बढ़ा रहे होते हैं।

118
00:08:05,400 --> 00:08:10,080
और वह प्रभाव, फिर से, यह है कि यहां

119
00:08:10,080 --> 00:08:13,480
नीचे कुल परिणाम त्रुटि की स्थिति बताता है।

120
00:08:13,480 --> 00:08:17,720
यह समझाने के लिए कि यह कितना सुंदर है, मैं आपको पायथन कोड की वह एक पंक्ति दिखाता

121
00:08:17,720 --> 00:08:22,120
हूँ जिसका मैंने पहले उल्लेख किया था, जो रिसीवर के अंत में लगभग सभी तर्कों को पकड़ लेगा।

122
00:08:22,120 --> 00:08:27,160
हम डेटा ब्लॉक को अनुकरण करने के लिए 16 1s और 0s की एक यादृच्छिक

123
00:08:27,160 --> 00:08:31,160
सरणी बनाकर शुरू करेंगे, और मैं इसे बिट्स नाम दूंगा, लेकिन व्यवहार में यह

124
00:08:31,160 --> 00:08:36,160
कुछ ऐसा होगा जो हम एक प्रेषक से प्राप्त कर रहे हैं, और इसके बजाय

125
00:08:36,160 --> 00:08:38,600
यादृच्छिक होने के कारण इसमें 5 समता बिट्स के साथ 11 डेटा बिट्स होंगे।

126
00:08:38,600 --> 00:08:43,160
यदि मैं फ़ंक्शन एन्यूमरेट बिट्स को कॉल करता हूं, तो यह प्रत्येक बिट को संबंधित

127
00:08:43,160 --> 00:08:48,240
इंडेक्स के साथ जोड़ता है, इस मामले में 0 से 15 तक चलता है।

128
00:08:48,240 --> 00:08:53,200
तो यदि हम एक सूची बनाते हैं जो इन सभी जोड़ियों पर लूप करती है, जो जोड़े जो

129
00:08:53,200 --> 00:08:59,160
i की तरह दिखते हैं, और फिर हम केवल i मान, केवल सूचकांक निकालते हैं, खैर यह

130
00:08:59,160 --> 00:09:01,920
उतना रोमांचक नहीं है, हम बस उन सूचकांकों को 0 से 15 तक वापस लाते हैं .

131
00:09:01,920 --> 00:09:07,520
लेकिन अगर हम केवल बिट होने पर ऐसा करने की शर्त जोड़ते हैं, जिसका अर्थ है कि यदि वह बिट

132
00:09:07,520 --> 00:09:13,400
1 है और 0 नहीं है, तो यह केवल उन स्थितियों को बाहर निकालता है जहां संबंधित बिट चालू है।

133
00:09:13,400 --> 00:09:20,320
इस मामले में ऐसा लगता है कि वे स्थितियाँ 0, 4, 6, 9, आदि हैं।

134
00:09:20,720 --> 00:09:24,640
हम जो चाहते हैं वह उन सभी स्थितियों को, चालू किए गए बिट्स की स्थितियों

135
00:09:24,640 --> 00:09:29,960
को एक साथ इकट्ठा करना है, और फिर उन्हें एक साथ XOR करना है।

136
00:09:29,960 --> 00:09:33,960
पायथन में ऐसा करने के लिए, मुझे पहले कुछ उपयोगी फ़ंक्शन आयात करने दीजिए।

137
00:09:33,960 --> 00:09:39,140
इस तरह हम इस सूची में कम() को कॉल कर सकते हैं, और इसे कम करने के लिए XOR फ़ंक्शन का उपयोग कर सकते हैं।

138
00:09:39,140 --> 00:09:44,840
यह मूल रूप से सूची के माध्यम से अपना रास्ता खाता है, रास्ते में एक्सओआर ले जाता है।

139
00:09:44,840 --> 00:09:48,760
यदि आप चाहें, तो आप उस XOR फ़ंक्शन को कहीं से

140
00:09:48,800 --> 00:09:52,200
भी आयात किए बिना स्पष्ट रूप से लिख सकते हैं।

141
00:09:52,200 --> 00:09:56,880
तो फिलहाल ऐसा लगता है कि अगर हम इसे 16 बिट्स के अपने यादृच्छिक

142
00:09:56,880 --> 00:10:02,080
ब्लॉक पर करते हैं, तो यह 9 लौटाता है, जिसका बाइनरी प्रतिनिधित्व 1001 है।

143
00:10:02,080 --> 00:10:05,960
हम इसे यहां नहीं करेंगे, लेकिन आप एक फ़ंक्शन लिख सकते हैं जहां प्रेषक आवश्यकतानुसार चार समता बिट्स सेट

144
00:10:05,960 --> 00:10:11,560
करने के लिए उस बाइनरी प्रतिनिधित्व का उपयोग करता है, अंततः इस ब्लॉक को उस स्थिति में ले जाता

145
00:10:11,560 --> 00:10:16,200
है जहां बिट्स की पूरी सूची पर कोड की इस पंक्ति को चलाने पर रिटर्न मिलता है एक 0.

146
00:10:17,200 --> 00:10:20,200
इसे एक अच्छी तरह से तैयार ब्लॉक माना जाएगा।

147
00:10:20,200 --> 00:10:24,640
अच्छी बात यह है कि यदि हम शोर से यादृच्छिक त्रुटि का अनुकरण करते हुए इस सूची में से किसी एक बिट

148
00:10:24,640 --> 00:10:30,600
को टॉगल करते हैं, तो यदि आप कोड की इसी पंक्ति को चलाते हैं, तो यह उस त्रुटि को प्रिंट करता है।

149
00:10:30,600 --> 00:10:31,920
क्या वह साफ़-सुथरा नहीं है?

150
00:10:31,920 --> 00:10:37,200
आप इस ब्लॉक को अचानक से प्राप्त कर सकते हैं, इस पर इस एकल पंक्ति को चला सकते हैं,

151
00:10:37,200 --> 00:10:42,920
और यह स्वचालित रूप से किसी त्रुटि की स्थिति, या यदि कोई त्रुटि नहीं थी तो 0 बता देगा।

152
00:10:42,920 --> 00:10:45,520
और यहां साइज 16 के बारे में कुछ खास नहीं है।

153
00:10:45,520 --> 00:10:52,280
यदि आपके पास, मान लीजिए, 256 बिट्स की सूची है, तो कोड की वही पंक्ति काम करेगी।

154
00:10:52,280 --> 00:10:56,280
कहने की जरूरत नहीं है, यहां लिखने के लिए और भी कोड हैं, जैसे 2-बिट

155
00:10:56,280 --> 00:11:01,440
त्रुटियों का पता लगाने के लिए मेटा पैरिटी जांच करना, लेकिन विचार यह है कि

156
00:11:01,440 --> 00:11:05,080
हमारी योजना के लगभग सभी मुख्य तर्क एक ही एक्सओआर कटौती पर आते हैं।

157
00:11:05,080 --> 00:11:10,600
अब, सामान्य रूप से बाइनरी और एक्सओआर और सॉफ़्टवेयर के साथ आपकी सुविधा के आधार पर, आपको

158
00:11:10,600 --> 00:11:15,880
या तो यह परिप्रेक्ष्य थोड़ा भ्रमित करने वाला लग सकता है, या इतना अधिक सुरुचिपूर्ण और सरल

159
00:11:15,880 --> 00:11:19,320
कि आप सोच रहे होंगे कि हमने शुरुआत से ही इसकी शुरुआत क्यों नहीं की -जाना।

160
00:11:19,320 --> 00:11:22,880
संक्षेप में कहें तो, हार्डवेयर में हैमिंग कोड को बहुत सीधे लागू करते समय मल्टीपल

161
00:11:22,880 --> 00:11:27,560
पैरिटी चेक परिप्रेक्ष्य के बारे में सोचना आसान होता है, और सॉफ़्टवेयर में इसे उच्च

162
00:11:27,560 --> 00:11:31,380
स्तर से करते समय XOR परिप्रेक्ष्य के बारे में सोचना सबसे आसान होता है।

163
00:11:31,380 --> 00:11:35,640
पहला वास्तव में हाथ से करना सबसे आसान है, और मुझे लगता है कि यह इन सबके अंतर्निहित

164
00:11:35,640 --> 00:11:40,720
मूल अंतर्ज्ञान को स्थापित करने में बेहतर काम करता है, जो यह है कि एक त्रुटि का

165
00:11:40,720 --> 00:11:46,840
पता लगाने के लिए आवश्यक जानकारी ब्लॉक के आकार के लॉग से संबंधित है , या दूसरे शब्दों

166
00:11:46,840 --> 00:11:51,020
में, जैसे-जैसे ब्लॉक का आकार दोगुना होता जाता है, यह एक बार में एक बिट बढ़ता है।

167
00:11:51,020 --> 00:11:55,440
यहां प्रासंगिक तथ्य यह है कि वह जानकारी सीधे तौर पर इस

168
00:11:55,440 --> 00:11:56,440
बात से मेल खाती है कि हमें कितनी अतिरेक की आवश्यकता है।

169
00:11:56,440 --> 00:12:00,320
यह वास्तव में ज्यादातर लोगों की त्वरित प्रतिक्रिया के विपरीत है जब वे पहली बार किसी

170
00:12:00,320 --> 00:12:05,280
संदेश को त्रुटियों के प्रति लचीला बनाने के बारे में सोचते हैं, जहां आम तौर

171
00:12:05,280 --> 00:12:07,520
पर पूरे संदेश की नकल करना पहली प्रवृत्ति होती है जो दिमाग में आती है।

172
00:12:07,520 --> 00:12:11,120
और फिर, वैसे, यह एक और तरीका है जिसमें आप कभी-कभी हैमिंग कोड प्रस्तुत करते

173
00:12:11,120 --> 00:12:14,800
हुए देखते हैं, जहां आप संदेश को एक बड़े मैट्रिक्स से गुणा करते हैं।

174
00:12:14,800 --> 00:12:18,580
यह अच्छा है क्योंकि यह इसे रैखिक कोड के व्यापक परिवार से जोड़ता है, लेकिन मुझे लगता है कि

175
00:12:18,580 --> 00:12:25,160
यह लगभग कोई अंतर्ज्ञान नहीं देता है कि यह कहां से आता है या इसका आकार कैसा है।

176
00:12:25,160 --> 00:12:29,340
और स्केलिंग की बात करते हुए, आप देख सकते हैं कि जैसे-जैसे हम

177
00:12:29,340 --> 00:12:32,200
ब्लॉक आकार बढ़ाते हैं, इस योजना की दक्षता बेहतर होती जाती है।

178
00:12:32,200 --> 00:12:40,560
उदाहरण के लिए, हमने देखा कि 256 बिट्स के साथ, आप उस स्थान का केवल 3%

179
00:12:40,560 --> 00:12:43,480
अतिरेक के लिए उपयोग कर रहे हैं, और यह वहां से बेहतर होता जा रहा है।

180
00:12:43,480 --> 00:12:49,040
जैसे-जैसे समता बिट्स की संख्या एक-एक करके बढ़ती जाती है, ब्लॉक का आकार दोगुना होता जाता है।

181
00:12:49,040 --> 00:12:53,840
और यदि आप इसे चरम पर ले जाते हैं, तो आपके पास एक मिलियन बिट्स

182
00:12:53,840 --> 00:12:58,800
वाला एक ब्लॉक हो सकता है, जहां आप वस्तुतः अपने समता जांच के साथ 20

183
00:12:58,800 --> 00:13:00,800
प्रश्न खेल रहे होंगे, और यह केवल 21 समता बिट्स का उपयोग करता है।

184
00:13:00,800 --> 00:13:05,760
और यदि आप एक लाख बिट्स को देखने और एक त्रुटि का पता लगाने के बारे

185
00:13:05,760 --> 00:13:08,640
में सोचने के लिए पीछे हटते हैं, तो यह वास्तव में पागलपन जैसा लगता है।

186
00:13:08,640 --> 00:13:12,680
निस्संदेह, समस्या यह है कि बड़े ब्लॉक के साथ, एक या दो से अधिक बिट त्रुटियाँ देखने

187
00:13:12,680 --> 00:13:18,360
की संभावना बढ़ जाती है, और हैमिंग कोड इससे आगे कुछ भी संभाल नहीं पाते हैं।

188
00:13:18,360 --> 00:13:22,020
इसलिए व्यवहार में, आप जो चाहते हैं वह सही आकार ढूंढना है

189
00:13:22,020 --> 00:13:25,520
ताकि बहुत अधिक बिट फ़्लिप की संभावना बहुत अधिक न हो।

190
00:13:26,520 --> 00:13:30,920
इसके अलावा, व्यवहार में, त्रुटियां छोटे विस्फोटों में आती हैं, जो एक ब्लॉक को पूरी तरह से बर्बाद कर देगी,

191
00:13:30,920 --> 00:13:35,680
इसलिए कई अलग-अलग ब्लॉकों में त्रुटियों के विस्फोट को फैलाने में मदद करने के लिए एक सामान्य रणनीति उन ब्लॉकों

192
00:13:35,680 --> 00:13:41,720
को इस तरह से जोड़ना है, इससे पहले कि वे समाप्त हो जाएं बाहर भेजा या संग्रहीत किया गया।

193
00:13:45,480 --> 00:13:49,920
फिर, इसमें से बहुत कुछ को अधिक आधुनिक कोड द्वारा पूरी तरह से म्यूट कर दिया गया है, जैसे

194
00:13:49,920 --> 00:13:55,060
कि अधिक सामान्यतः उपयोग किया जाने वाला रीड-सोलोमन एल्गोरिदम, जो विशेष रूप से विस्फोट त्रुटियों को अच्छी तरह से

195
00:13:55,100 --> 00:13:59,580
संभालता है, और इसे प्रति ब्लॉक बड़ी संख्या में त्रुटियों के लिए लचीला बनाया जा सकता है। .

196
00:13:59,580 --> 00:14:03,000
लेकिन यह अगली बार का विषय है।

197
00:14:03,000 --> 00:14:07,660
अपनी पुस्तक द आर्ट ऑफ डूइंग साइंस एंड इंजीनियरिंग में, हैमिंग ने आश्चर्यजनक रूप से

198
00:14:07,660 --> 00:14:10,700
स्पष्ट रूप से बताया है कि इस कोड की उनकी खोज कितनी टेढ़ी-मेढ़ी थी।

199
00:14:10,700 --> 00:14:15,180
उन्होंने सबसे पहले बिट्स को उच्च आयामी जाली के हिस्सों में व्यवस्थित करने और इस

200
00:14:15,180 --> 00:14:18,420
तरह की अजीब चीजों से संबंधित सभी प्रकार की विभिन्न योजनाओं की कोशिश की।

201
00:14:18,420 --> 00:14:22,520
यह विचार कि किसी त्रुटि की स्थिति बताने के लिए समता जांच प्राप्त

202
00:14:22,520 --> 00:14:26,360
करना संभव हो सकता है, हेमिंग के दिमाग में तभी आया जब वह

203
00:14:26,360 --> 00:14:30,800
कई अन्य विश्लेषणों के बाद पीछे हटे और पूछा, ठीक है, मैं सबसे

204
00:14:30,800 --> 00:14:32,860
कुशल क्या कर सकता हूं क्या आप इस बारे में सोच सकते हैं?

205
00:14:32,860 --> 00:14:36,760
वह इस बारे में भी स्पष्ट थे कि यह कितना महत्वपूर्ण है कि समता जांच पहले से ही उनके

206
00:14:36,760 --> 00:14:42,040
दिमाग में थी, जो कि आज की तुलना में 1940 के दशक में बहुत कम आम रही होगी।

207
00:14:42,040 --> 00:14:46,040
इस पुस्तक में लगभग आधा दर्जन बार उन्होंने लुई पाश्चर के इस कथन

208
00:14:46,040 --> 00:14:49,640
का संदर्भ दिया है कि भाग्य तैयार दिमाग का साथ देता है।

209
00:14:49,640 --> 00:14:55,120
चतुर विचार अक्सर बाद में भ्रामक रूप से सरल दिखते हैं, जिससे उनकी सराहना करना आसान हो जाता है।

210
00:14:55,120 --> 00:14:59,680
अभी मेरी ईमानदार आशा यह है कि हैमिंग कोड, या कम

211
00:14:59,680 --> 00:15:01,820
से कम ऐसे कोड की संभावना, आपको लगभग स्पष्ट लगती है।

212
00:15:01,820 --> 00:15:05,440
लेकिन आपको यह सोचकर खुद को मूर्ख नहीं बनाना चाहिए कि वे

213
00:15:05,440 --> 00:15:08,000
वास्तव में स्पष्ट हैं, क्योंकि वे निश्चित रूप से नहीं हैं।

214
00:15:08,000 --> 00:15:12,080
चतुर विचारों के भ्रामक रूप से आसान दिखने का एक कारण यह है कि

215
00:15:12,080 --> 00:15:17,360
हम केवल अंतिम परिणाम देखते हैं, जो गड़बड़ था उसे साफ करना, सभी गलत

216
00:15:17,360 --> 00:15:22,400
मोड़ों का कभी उल्लेख नहीं करना, किसी समस्या की शुरुआत में अन्वेषण योग्य संभावनाओं

217
00:15:22,400 --> 00:15:23,980
का स्थान कितना विशाल है, इसकी कम बिक्री करना समाधान प्रक्रिया, वह सब।

218
00:15:23,980 --> 00:15:25,280
लेकिन यह सामान्य तौर पर सच है.

219
00:15:25,280 --> 00:15:29,880
मुझे लगता है कि कुछ विशेष आविष्कारों के लिए, एक दूसरा,

220
00:15:29,880 --> 00:15:31,040
गहरा कारण है कि हम उनकी कम सराहना करते हैं।

221
00:15:31,040 --> 00:15:35,040
सूचना सिद्धांत पर क्लाउड शैनन के मौलिक पेपर के साथ, बिट्स के संदर्भ में जानकारी के

222
00:15:35,040 --> 00:15:39,400
बारे में सोचना वास्तव में 1948 तक एक पूर्ण सिद्धांत में परिवर्तित हो गया था।

223
00:15:39,400 --> 00:15:43,400
यह अनिवार्य रूप से तब समवर्ती था जब हैमिंग ने अपना एल्गोरिदम विकसित किया था।

224
00:15:43,440 --> 00:15:47,300
यह वही मूलभूत पेपर था जिसने एक निश्चित अर्थ में दिखाया कि

225
00:15:47,300 --> 00:15:52,080
कुशल त्रुटि सुधार हमेशा संभव है, चाहे बिट फ़्लिप की संभावना

226
00:15:52,080 --> 00:15:53,920
कितनी भी अधिक क्यों न हो, कम से कम सिद्धांत में।

227
00:15:53,920 --> 00:15:58,120
वैसे, बहुत अलग-अलग चीजों पर काम करने के बावजूद, शैनन और हैमिंग ने बेल

228
00:15:58,120 --> 00:16:02,400
लैब्स में एक कार्यालय साझा किया, जो यहां शायद ही संयोग लगता है।

229
00:16:02,400 --> 00:16:06,960
कई दशक तेजी से आगे बढ़े, और इन दिनों, हममें से कई लोग छोटी-छोटी बातों और सूचनाओं के बारे में सोचने

230
00:16:06,960 --> 00:16:13,080
में इतने डूबे हुए हैं कि इस बात को नजरअंदाज करना आसान है कि सोचने का यह तरीका कितना अलग था।

231
00:16:13,080 --> 00:16:17,920
विडंबना यह है कि जो विचार भविष्य की पीढ़ी के सोचने के तरीकों को सबसे गहराई से

232
00:16:17,920 --> 00:16:22,640
आकार देते हैं, वे भविष्य की पीढ़ी को वास्तव में उनकी तुलना में अधिक सरल लगेंगे।

