1
00:00:00,000 --> 00:00:03,120
मैं मान रहा हूं कि यहां हर कोई भाग 1 से आ रहा है।

2
00:00:03,120 --> 00:00:06,745
हम हैमिंग कोड के बारे में बात कर रहे थे, डेटा का एक ब्लॉक बनाने का एक

3
00:00:06,745 --> 00:00:10,422
तरीका जहां अधिकांश बिट्स एक सार्थक संदेश ले जाते हैं, जबकि कुछ अन्य एक

4
00:00:10,422 --> 00:00:13,996
प्रकार की अतिरेक के रूप में कार्य करते हैं, इस तरह से कि यदि कोई बिट

5
00:00:13,996 --> 00:00:17,776
फ़्लिप हो जाता है, तो या तो एक संदेश बिट या अतिरेक बिट, इस ब्लॉक में कुछ

6
00:00:17,776 --> 00:00:21,920
भी, रिसीवर यह पहचानने में सक्षम होगा कि कोई त्रुटि थी, और इसे कैसे ठीक किया जाए।

7
00:00:21,920 --> 00:00:25,860
वहां प्रस्तुत मूल विचार यह था कि त्रुटि तक पहुंचने के लिए

8
00:00:25,860 --> 00:00:29,800
बाइनरी खोज के लिए एकाधिक समता जांच का उपयोग कैसे किया जाए।

9
00:00:29,800 --> 00:00:35,420
उस वीडियो में लक्ष्य हैमिंग कोड को यथासंभव व्यावहारिक और पुनः खोज योग्य बनाना था।

10
00:00:35,420 --> 00:00:38,380
लेकिन जैसे ही आप वास्तव में इसे सॉफ़्टवेयर या हार्डवेयर में लागू

11
00:00:38,380 --> 00:00:41,204
करने के बारे में सोचना शुरू करते हैं, वह फ़्रेमिंग वास्तव में

12
00:00:41,204 --> 00:00:44,120
कम बिक्री कर सकती है कि ये कोड वास्तव में कितने सुरुचिपूर्ण हैं।

13
00:00:44,120 --> 00:00:47,380
आप सोच सकते हैं कि आपको एक एल्गोरिदम लिखने की ज़रूरत है जो सभी

14
00:00:47,380 --> 00:00:50,744
संभावित त्रुटि स्थानों पर नज़र रखता है और प्रत्येक चेक के साथ उस

15
00:00:50,744 --> 00:00:54,160
समूह को आधा कर देता है, लेकिन वास्तव में यह उससे कहीं अधिक सरल है।

16
00:00:54,160 --> 00:00:59,449
यदि आप पिछले वीडियो में हमारे द्वारा की गई चार समता जांचों के उत्तरों को हां और ना के

17
00:00:59,449 --> 00:01:04,800
बजाय 1s और 0s के रूप में पढ़ते हैं, तो यह वस्तुतः बाइनरी में त्रुटि की स्थिति बताता है।

18
00:01:04,800 --> 00:01:08,612
उदाहरण के लिए, बाइनरी में संख्या 7 0111 की तरह दिखती

19
00:01:08,612 --> 00:01:12,640
है, अनिवार्य रूप से यह कहती है कि यह 4 प्लस 2 प्लस 1 है।

20
00:01:12,640 --> 00:01:17,531
और ध्यान दें कि स्थिति 7 कहाँ बैठती है, यह हमारे समता समूहों में से

21
00:01:17,531 --> 00:01:22,280
पहले, और दूसरे, और तीसरे को प्रभावित करती है, लेकिन अंतिम को नहीं।

22
00:01:22,280 --> 00:01:25,251
इसलिए नीचे से ऊपर तक उन चार जांचों के परिणामों को

23
00:01:25,251 --> 00:01:28,520
पढ़ने से वास्तव में त्रुटि की स्थिति का पता चल जाता है।

24
00:01:28,520 --> 00:01:32,836
उदाहरण 7 के बारे में कुछ खास नहीं है, यह सामान्य रूप से काम करता है, और यह

25
00:01:32,836 --> 00:01:37,440
हार्डवेयर में पूरी योजना को लागू करने के तर्क को आश्चर्यजनक रूप से सरल बनाता है।

26
00:01:37,440 --> 00:01:42,061
अब यदि आप यह देखना चाहते हैं कि यह जादू क्यों होता है, तो हमारी स्थिति

27
00:01:42,061 --> 00:01:46,423
के लिए इन 16 सूचकांक लेबलों को लें, लेकिन उन्हें आधार 10 में लिखने

28
00:01:46,423 --> 00:01:50,720
के बजाय, आइए उन सभी को बाइनरी में लिखें, 0000 से 1111 तक चलते हुए।

29
00:01:50,720 --> 00:01:54,552
जैसे ही हम इन बाइनरी लेबलों को उनके बक्सों में वापस डालते हैं, मैं इस

30
00:01:54,552 --> 00:01:58,440
बात पर जोर देना चाहता हूं कि वे वास्तव में भेजे जा रहे डेटा से अलग हैं।

31
00:01:58,440 --> 00:02:01,320
वे आपको और मुझे यह समझने में मदद करने के लिए एक वैचारिक

32
00:02:01,320 --> 00:02:04,200
लेबल से ज्यादा कुछ नहीं हैं कि चार समता समूह कहां से आए।

33
00:02:04,200 --> 00:02:08,596
हम जो कुछ भी देख रहे हैं उसे बाइनरी में वर्णित करने की सुंदरता शायद इस भ्रम के

34
00:02:08,596 --> 00:02:13,160
कारण कम हो गई है कि हम जो कुछ भी देख रहे हैं उसका वर्णन बाइनरी में किया जा रहा है।

35
00:02:13,160 --> 00:02:15,040
हालाँकि, यह इसके लायक है।

36
00:02:15,040 --> 00:02:19,737
अपना ध्यान केवल इन सभी लेबलों के अंतिम बिट पर केंद्रित करें,

37
00:02:19,737 --> 00:02:24,280
और फिर उन स्थितियों को हाइलाइट करें जहां वह अंतिम बिट 1 है।

38
00:02:24,280 --> 00:02:28,391
हमें जो मिलता है वह हमारे चार समता समूहों में से पहला है, जिसका

39
00:02:28,391 --> 00:02:32,439
अर्थ है कि आप उस पहले चेक की व्याख्या यह पूछ सकते हैं कि, अरे,

40
00:02:32,439 --> 00:02:36,680
यदि कोई त्रुटि है, तो क्या उस त्रुटि की स्थिति में अंतिम बिट 1 है?

41
00:02:36,680 --> 00:02:41,891
इसी तरह, यदि आप दूसरे से अंतिम बिट पर ध्यान केंद्रित करते हैं, और उन सभी स्थितियों

42
00:02:41,891 --> 00:02:47,040
को हाइलाइट करते हैं जहां वह 1 है, तो आपको हमारी योजना से दूसरा समता समूह मिलता है।

43
00:02:47,040 --> 00:02:51,527
दूसरे शब्दों में, वह दूसरा चेक पूछ रहा है, अरे, मुझसे फिर से,

44
00:02:51,527 --> 00:02:56,160
यदि कोई त्रुटि है, तो क्या उस स्थिति का दूसरा से अंतिम बिट 1 है?

45
00:02:56,160 --> 00:02:57,160
और इसी तरह।

46
00:02:57,160 --> 00:03:03,760
तीसरी समता जांच प्रत्येक स्थिति को कवर करती है जिसका तीसरा से अंतिम बिट चालू होता

47
00:03:03,760 --> 00:03:10,120
है, और अंतिम अंतिम आठ स्थितियों को कवर करता है, वे जिनकी उच्चतम ऑर्डर बिट 1 है।

48
00:03:10,120 --> 00:03:14,843
हमने पहले जो कुछ भी किया वह इन चार प्रश्नों का उत्तर देने के

49
00:03:14,843 --> 00:03:19,800
समान है, जो बदले में बाइनरी में किसी स्थिति को बताने के समान है।

50
00:03:19,800 --> 00:03:22,080
मुझे आशा है कि इससे दो बातें स्पष्ट हो जाएंगी।

51
00:03:22,080 --> 00:03:24,610
पहला यह है कि उन आकारों को ब्लॉक करने के लिए व्यवस्थित

52
00:03:24,610 --> 00:03:27,140
रूप से सामान्यीकरण कैसे किया जाए जो दो की बड़ी घात हैं।

53
00:03:27,140 --> 00:03:31,008
यदि प्रत्येक स्थिति का वर्णन करने के लिए अधिक बिट्स की आवश्यकता होती है,

54
00:03:31,008 --> 00:03:34,824
जैसे 64 स्थानों का वर्णन करने के लिए छह बिट्स, तो उनमें से प्रत्येक बिट

55
00:03:34,824 --> 00:03:38,640
आपको समता समूहों में से एक देता है जिसे हमें जांचने की आवश्यकता होती है।

56
00:03:38,640 --> 00:03:41,020
आपमें से जिन लोगों ने मैट पार्कर के साथ मेरी शतरंज की

57
00:03:41,020 --> 00:03:43,400
बिसात पहेली देखी होगी, उन्हें यह सब बहुत परिचित लगेगा।

58
00:03:43,400 --> 00:03:46,668
यह वही मूल तर्क है, लेकिन एक अलग समस्या को हल कर रहा है,

59
00:03:46,668 --> 00:03:49,880
और इसे 64-वर्ग वाली शतरंज की बिसात पर लागू किया जाता है।

60
00:03:49,880 --> 00:03:54,017
दूसरी बात जो मुझे आशा है कि यह स्पष्ट करती है वह यह है कि हमारे समता बिट्स

61
00:03:54,017 --> 00:03:58,320
उन स्थितियों में क्यों बैठे हैं जो दो की घात हैं, उदाहरण के लिए 1, 2, 4, और 8।

62
00:03:58,320 --> 00:04:03,640
ये वे स्थितियाँ हैं जिनका द्विआधारी प्रतिनिधित्व केवल एक बिट चालू है।

63
00:04:03,640 --> 00:04:08,140
इसका मतलब यह है कि उनमें से प्रत्येक समता बिट चार

64
00:04:08,140 --> 00:04:12,640
समता समूहों में से एक और केवल एक के अंदर बैठता है।

65
00:04:12,640 --> 00:04:19,228
आप इसे बड़े उदाहरणों में भी देख सकते हैं, जहां चाहे आप कितना भी

66
00:04:19,228 --> 00:04:25,920
बड़ा हो जाएं, प्रत्येक समता बिट आसानी से केवल एक समूह को छूती है।

67
00:04:25,920 --> 00:04:30,368
एक बार जब आप समझ जाते हैं कि ये समता जाँचें जिन पर हमने अपना अधिकांश समय केंद्रित किया

68
00:04:30,368 --> 00:04:34,715
है, बाइनरी में त्रुटि की स्थिति बताने के एक चतुर तरीके से ज्यादा कुछ नहीं हैं, तो हम

69
00:04:34,715 --> 00:04:39,215
हैमिंग के बारे में सोचने के लिए एक अलग तरीके से संबंध बना सकते हैं कोड, एक ऐसा जो यकीनन

70
00:04:39,215 --> 00:04:43,766
बहुत सरल और अधिक सुरुचिपूर्ण है, और जिसे मूल रूप से कोड की एक पंक्ति के साथ लिखा जा सकता

71
00:04:43,766 --> 00:04:43,920
है।

72
00:04:43,920 --> 00:04:46,200
यह XOR फ़ंक्शन पर आधारित है.

73
00:04:46,200 --> 00:04:50,960
आपमें से जो लोग नहीं जानते उनके लिए XOR का मतलब एक्सक्लूसिव या है।

74
00:04:50,960 --> 00:04:55,507
जब आप दो बिट्स का एक्सओआर लेते हैं, तो यदि इनमें से कोई एक बिट

75
00:04:55,507 --> 00:05:00,200
चालू है तो यह 1 लौटाएगा, लेकिन यदि दोनों चालू या बंद हैं तो नहीं।

76
00:05:00,200 --> 00:05:03,760
अलग-अलग शब्दों में, यह इन दो बिट्स की समता है।

77
00:05:03,760 --> 00:05:07,840
एक गणितज्ञ के रूप में, मैं इसके बारे में अतिरिक्त मॉड 2 के रूप में सोचना पसंद करता हूँ।

78
00:05:07,840 --> 00:05:10,990
हम आम तौर पर दो अलग-अलग बिट स्ट्रिंग्स के एक्सओआर के बारे में

79
00:05:10,990 --> 00:05:14,040
भी बात करते हैं, जो मूल रूप से इस घटक को घटक द्वारा करता है।

80
00:05:14,040 --> 00:05:16,280
यह जोड़ की तरह है, लेकिन जहां आप कभी नहीं ले जाते।

81
00:05:16,280 --> 00:05:19,965
फिर, गणितीय रूप से अधिक इच्छुक लोग इसे दो वैक्टर जोड़ने

82
00:05:19,965 --> 00:05:23,520
और मॉड 2 को कम करने के रूप में सोचना पसंद कर सकते हैं।

83
00:05:23,520 --> 00:05:29,460
यदि आप अभी कुछ पायथन खोलते हैं और दो पूर्णांकों के बीच कैरेट ऑपरेशन लागू करते

84
00:05:29,460 --> 00:05:35,400
हैं, तो यह हुड के नीचे उन संख्याओं के बिट प्रतिनिधित्व के अलावा यही कर रहा है।

85
00:05:35,400 --> 00:05:40,571
आपके और मेरे लिए मुख्य बिंदु यह है कि कई अलग-अलग बिट स्ट्रिंग्स

86
00:05:40,571 --> 00:05:45,743
का एक्सओआर लेना प्रभावी रूप से अलग-अलग समूहों के समूह की पैरोडी

87
00:05:45,743 --> 00:05:51,320
की गणना करने का एक तरीका है, जैसे कि कॉलम के साथ, सभी एक ही झटके में।

88
00:05:51,320 --> 00:05:55,555
यह हमें हमारे हैमिंग कोड एल्गोरिदम से कई समता जांचों के बारे में सोचने का एक

89
00:05:55,555 --> 00:05:59,680
आसान तरीका देता है क्योंकि सभी को एक ही ऑपरेशन में एक साथ पैक किया जाता है।

90
00:05:59,680 --> 00:06:02,800
हालाँकि पहली नज़र में यह बहुत अलग दिखता है।

91
00:06:02,800 --> 00:06:08,154
विशेष रूप से 16 स्थितियों को बाइनरी में लिखें, जैसा कि हमने पहले किया

92
00:06:08,154 --> 00:06:13,662
था, और अब उन स्थितियों को हाइलाइट करें जहां संदेश बिट को 1 पर चालू किया

93
00:06:13,662 --> 00:06:19,400
गया है, और फिर इन स्थितियों को एक बड़े कॉलम में इकट्ठा करें और एक्सओआर लें।

94
00:06:19,400 --> 00:06:23,750
आप शायद अनुमान लगा सकते हैं कि परिणामस्वरूप नीचे बैठे 4 बिट्स उन

95
00:06:23,750 --> 00:06:28,101
4 समता जांचों के समान हैं जिन्हें हम जानते हैं और पसंद करते हैं,

96
00:06:28,101 --> 00:06:32,720
लेकिन वास्तव में ऐसा क्यों है इसके बारे में सोचने के लिए एक क्षण लें।

97
00:06:32,720 --> 00:06:37,080
उदाहरण के लिए, यह अंतिम कॉलम उन सभी स्थितियों की गिनती कर रहा है, जिनका अंतिम बिट

98
00:06:37,080 --> 00:06:41,387
1 है, लेकिन हम पहले से ही केवल हाइलाइट की गई स्थितियों तक ही सीमित हैं, इसलिए यह

99
00:06:41,387 --> 00:06:45,960
प्रभावी रूप से गिनती कर रहा है कि पहले समता समूह से कितनी हाइलाइट की गई स्थिति आई हैं।

100
00:06:45,960 --> 00:06:48,520
समझ आया?

101
00:06:48,520 --> 00:06:54,236
इसी तरह, अगला कॉलम गिनता है कि दूसरे समता समूह में कितनी स्थितियाँ हैं, वे

102
00:06:54,236 --> 00:07:00,640
स्थितियाँ जिनका दूसरा से अंतिम बिट 1 है, और जिन्हें हाइलाइट भी किया गया है, इत्यादि।

103
00:07:00,640 --> 00:07:07,640
यह वास्तव में उसी चीज के परिप्रेक्ष्य में एक छोटा सा बदलाव है जो हम कर रहे हैं।

104
00:07:07,640 --> 00:07:10,000
और इसलिए आप जानते हैं कि यह यहाँ से कहाँ जाता है।

105
00:07:10,000 --> 00:07:14,485
प्रेषक यह सुनिश्चित करने के लिए कुछ विशेष समता

106
00:07:14,485 --> 00:07:19,640
बिट्स को टॉगल करने के लिए जिम्मेदार है कि योग 0000 हो।

107
00:07:19,640 --> 00:07:24,207
अब एक बार जब हमारे पास यह इस तरह हो जाता है, तो यह हमें यह सोचने का एक बहुत अच्छा

108
00:07:24,207 --> 00:07:28,720
तरीका देता है कि नीचे ये चार परिणामी बिट्स सीधे त्रुटि की स्थिति क्यों बताते हैं।

109
00:07:28,720 --> 00:07:32,720
मान लीजिए कि इस ब्लॉक में कुछ बिट 0 से 1 पर टॉगल हो जाता है।

110
00:07:32,720 --> 00:07:38,760
इसका मतलब यह है कि उस बिट की स्थिति अब कुल XOR में शामिल होने जा रही है,

111
00:07:38,760 --> 00:07:44,800
जो योग को 0 से बदलकर इस नए शामिल मूल्य, त्रुटि की स्थिति में बदल देती है।

112
00:07:44,800 --> 00:07:49,800
थोड़ा कम स्पष्ट रूप से, यदि कोई त्रुटि है जो 1 को 0 में बदल देती है तो भी यही सच है।

113
00:07:49,800 --> 00:07:54,372
आप देखिए, यदि आप एक बिट स्ट्रिंग को दो बार एक साथ जोड़ते हैं, तो यह वैसा ही है जैसे

114
00:07:54,372 --> 00:07:59,000
कि वहां इसका बिल्कुल भी न होना, मूल रूप से क्योंकि इस दुनिया में 1 प्लस 1 बराबर 0 है।

115
00:07:59,000 --> 00:08:02,168
इसलिए कुल योग में इस स्थिति की एक प्रति जोड़ने का

116
00:08:02,168 --> 00:08:05,400
वही प्रभाव होता है जो हम इसे आगे बढ़ा रहे होते हैं।

117
00:08:05,400 --> 00:08:13,480
और वह प्रभाव, फिर से, यह है कि यहां नीचे कुल परिणाम त्रुटि की स्थिति बताता है।

118
00:08:13,480 --> 00:08:17,851
यह समझाने के लिए कि यह कितना सुंदर है, मैं आपको पायथन कोड की वह एक पंक्ति दिखाता हूँ

119
00:08:17,851 --> 00:08:22,120
जिसका मैंने पहले उल्लेख किया था, जो रिसीवर के अंत में लगभग सभी तर्कों को पकड़ लेगा।

120
00:08:22,120 --> 00:08:26,316
हम डेटा ब्लॉक को अनुकरण करने के लिए 16 1s और 0s की एक यादृच्छिक सरणी

121
00:08:26,316 --> 00:08:30,451
बनाकर शुरू करेंगे, और मैं इसे बिट्स नाम दूंगा, लेकिन व्यवहार में यह

122
00:08:30,451 --> 00:08:34,403
कुछ ऐसा होगा जो हम एक प्रेषक से प्राप्त कर रहे हैं, और इसके बजाय

123
00:08:34,403 --> 00:08:38,600
यादृच्छिक होने के कारण इसमें 5 समता बिट्स के साथ 11 डेटा बिट्स होंगे।

124
00:08:38,600 --> 00:08:43,384
यदि मैं फ़ंक्शन एन्यूमरेट बिट्स को कॉल करता हूं, तो यह प्रत्येक बिट

125
00:08:43,384 --> 00:08:48,240
को संबंधित इंडेक्स के साथ जोड़ता है, इस मामले में 0 से 15 तक चलता है।

126
00:08:48,240 --> 00:08:52,840
इसलिए यदि हम एक सूची बनाते हैं जो इन सभी जोड़ियों पर लूप करती है, जो जोड़े

127
00:08:52,840 --> 00:08:57,441
जो i की तरह दिखते हैं, और फिर हम केवल i मान, केवल सूचकांक निकालते हैं, खैर

128
00:08:57,441 --> 00:09:01,920
यह उतना रोमांचक नहीं है, हम बस उन सूचकांकों को 0 से 15 तक वापस लाते हैं .

129
00:09:01,920 --> 00:09:07,660
लेकिन अगर हम केवल बिट होने पर ऐसा करने की शर्त जोड़ते हैं, जिसका अर्थ है कि यदि वह बिट

130
00:09:07,660 --> 00:09:13,400
1 है और 0 नहीं है, तो यह केवल उन स्थितियों को बाहर निकालता है जहां संबंधित बिट चालू है।

131
00:09:13,400 --> 00:09:20,720
इस मामले में ऐसा लगता है कि वे स्थितियाँ 0, 4, 6, 9, आदि हैं।

132
00:09:20,720 --> 00:09:25,055
हम जो चाहते हैं वह उन सभी स्थितियों को, चालू किए गए बिट्स की

133
00:09:25,055 --> 00:09:29,960
स्थितियों को एक साथ इकट्ठा करना है, और फिर उन्हें एक साथ XOR करना है।

134
00:09:29,960 --> 00:09:33,960
पायथन में ऐसा करने के लिए, मुझे पहले कुछ उपयोगी फ़ंक्शन आयात करने दीजिए।

135
00:09:33,960 --> 00:09:36,499
इस तरह हम इस सूची में कम() को कॉल कर सकते हैं, और

136
00:09:36,499 --> 00:09:39,140
इसे कम करने के लिए XOR फ़ंक्शन का उपयोग कर सकते हैं।

137
00:09:39,140 --> 00:09:44,840
यह मूल रूप से सूची के माध्यम से अपना रास्ता खाता है, रास्ते में एक्सओआर ले जाता है।

138
00:09:44,840 --> 00:09:52,200
यदि आप चाहें, तो आप उस XOR फ़ंक्शन को कहीं से भी आयात किए बिना स्पष्ट रूप से लिख सकते हैं।

139
00:09:52,200 --> 00:09:57,176
तो फिलहाल ऐसा लगता है कि अगर हम 16 बिट्स के अपने यादृच्छिक ब्लॉक पर

140
00:09:57,176 --> 00:10:02,080
ऐसा करते हैं, तो यह 9 लौटाता है, जिसका बाइनरी प्रतिनिधित्व 1001 है।

141
00:10:02,080 --> 00:10:05,914
हम इसे यहां नहीं करेंगे, लेकिन आप एक फ़ंक्शन लिख सकते हैं जहां प्रेषक

142
00:10:05,914 --> 00:10:09,640
आवश्यकतानुसार चार समता बिट्स सेट करने के लिए उस बाइनरी प्रतिनिधित्व

143
00:10:09,640 --> 00:10:13,255
का उपयोग करता है, अंततः इस ब्लॉक को उस स्थिति में ले जाता है जहां

144
00:10:13,255 --> 00:10:17,200
बिट्स की पूरी सूची पर कोड की इस पंक्ति को चलाने पर रिटर्न मिलता है एक 0.

145
00:10:17,200 --> 00:10:20,200
इसे एक अच्छी तरह से तैयार ब्लॉक माना जाएगा।

146
00:10:20,200 --> 00:10:23,757
अच्छी बात यह है कि यदि हम शोर से यादृच्छिक त्रुटि का अनुकरण करते

147
00:10:23,757 --> 00:10:27,206
हुए इस सूची में से किसी एक बिट को टॉगल करते हैं, तो यदि आप कोड

148
00:10:27,206 --> 00:10:30,600
की इसी पंक्ति को चलाते हैं, तो यह उस त्रुटि को प्रिंट करता है।

149
00:10:30,600 --> 00:10:31,920
क्या वह साफ़-सुथरा नहीं है?

150
00:10:31,920 --> 00:10:37,353
आप इस ब्लॉक को अचानक से प्राप्त कर सकते हैं, इस पर इस एकल पंक्ति को चला सकते हैं,

151
00:10:37,353 --> 00:10:42,920
और यह स्वचालित रूप से किसी त्रुटि की स्थिति या यदि कोई त्रुटि नहीं है तो 0 बता देगा।

152
00:10:42,920 --> 00:10:45,520
और यहां साइज 16 के बारे में कुछ खास नहीं है।

153
00:10:45,520 --> 00:10:52,280
यदि आपके पास, मान लीजिए, 256 बिट्स की सूची है, तो कोड की वही पंक्ति काम करेगी।

154
00:10:52,280 --> 00:10:56,422
कहने की जरूरत नहीं है, यहां लिखने के लिए और भी कोड हैं, जैसे 2-बिट

155
00:10:56,422 --> 00:11:00,627
त्रुटियों का पता लगाने के लिए मेटा पैरिटी जांच करना, लेकिन विचार यह

156
00:11:00,627 --> 00:11:05,080
है कि हमारी योजना के लगभग सभी मुख्य तर्क एक ही एक्सओआर कटौती पर आते हैं।

157
00:11:05,080 --> 00:11:09,769
अब, सामान्य रूप से बाइनरी और एक्सओआर और सॉफ़्टवेयर के साथ आपकी सुविधा के आधार पर,

158
00:11:09,769 --> 00:11:14,744
आपको या तो यह परिप्रेक्ष्य थोड़ा भ्रमित करने वाला लग सकता है, या इतना अधिक सुरुचिपूर्ण

159
00:11:14,744 --> 00:11:19,320
और सरल कि आप सोच रहे होंगे कि हमने शुरुआत से ही इसकी शुरुआत क्यों नहीं की -जाना।

160
00:11:19,320 --> 00:11:23,494
संक्षेप में कहें तो, हार्डवेयर में हैमिंग कोड को बहुत सीधे लागू करते समय मल्टीपल

161
00:11:23,494 --> 00:11:27,514
पैरिटी चेक परिप्रेक्ष्य के बारे में सोचना आसान होता है, और सॉफ़्टवेयर में इसे

162
00:11:27,514 --> 00:11:31,380
उच्च स्तर से करते समय XOR परिप्रेक्ष्य के बारे में सोचना सबसे आसान होता है।

163
00:11:31,380 --> 00:11:36,365
पहला वास्तव में हाथ से करना सबसे आसान है, और मुझे लगता है कि यह इन सबके अंतर्निहित

164
00:11:36,365 --> 00:11:41,109
मूल अंतर्ज्ञान को स्थापित करने में बेहतर काम करता है, जो यह है कि एक त्रुटि का

165
00:11:41,109 --> 00:11:45,794
पता लगाने के लिए आवश्यक जानकारी ब्लॉक के आकार के लॉग से संबंधित है , या दूसरे

166
00:11:45,794 --> 00:11:51,020
शब्दों में, जैसे-जैसे ब्लॉक का आकार दोगुना होता जाता है, यह एक बार में एक बिट बढ़ता है।

167
00:11:51,020 --> 00:11:53,730
यहां प्रासंगिक तथ्य यह है कि वह जानकारी सीधे तौर पर इस

168
00:11:53,730 --> 00:11:56,440
बात से मेल खाती है कि हमें कितनी अतिरेक की आवश्यकता है।

169
00:11:56,440 --> 00:12:00,084
यह वास्तव में ज्यादातर लोगों की त्वरित प्रतिक्रिया के विपरीत है जब वे पहली

170
00:12:00,084 --> 00:12:03,826
बार किसी संदेश को त्रुटियों के प्रति लचीला बनाने के बारे में सोचते हैं, जहां

171
00:12:03,826 --> 00:12:07,520
आम तौर पर पूरे संदेश की नकल करना पहली प्रवृत्ति होती है जो दिमाग में आती है।

172
00:12:07,520 --> 00:12:11,108
और फिर, वैसे, यह एक और तरीका है जिसमें आप कभी-कभी हैमिंग कोड प्रस्तुत

173
00:12:11,108 --> 00:12:14,800
करते हुए देखते हैं, जहां आप संदेश को एक बड़े मैट्रिक्स से गुणा करते हैं।

174
00:12:14,800 --> 00:12:19,980
यह अच्छा है क्योंकि यह इसे रैखिक कोड के व्यापक परिवार से जोड़ता है, लेकिन मुझे लगता

175
00:12:19,980 --> 00:12:25,160
है कि यह लगभग कोई अंतर्ज्ञान नहीं देता है कि यह कहां से आता है या इसका आकार कैसा है।

176
00:12:25,160 --> 00:12:28,680
और स्केलिंग की बात करते हुए, आप देख सकते हैं कि जैसे-जैसे हम

177
00:12:28,680 --> 00:12:32,200
ब्लॉक आकार बढ़ाते हैं, इस योजना की दक्षता बेहतर होती जाती है।

178
00:12:32,200 --> 00:12:37,922
उदाहरण के लिए, हमने देखा कि 256 बिट्स के साथ, आप उस स्थान का केवल 3%

179
00:12:37,922 --> 00:12:43,480
अतिरेक के लिए उपयोग कर रहे हैं, और यह वहां से बेहतर होता जा रहा है।

180
00:12:43,480 --> 00:12:46,412
जैसे-जैसे समता बिट्स की संख्या एक-एक करके बढ़ती

181
00:12:46,412 --> 00:12:49,040
जाती है, ब्लॉक का आकार दोगुना होता जाता है।

182
00:12:49,040 --> 00:12:53,019
और यदि आप इसे चरम सीमा तक ले जाते हैं, तो आपके पास एक मिलियन बिट्स

183
00:12:53,019 --> 00:12:56,998
वाला एक ब्लॉक हो सकता है, जहां आप वस्तुतः अपने समता जांच के साथ 20

184
00:12:56,998 --> 00:13:00,800
प्रश्न खेल रहे होंगे, और यह केवल 21 समता बिट्स का उपयोग करता है।

185
00:13:00,800 --> 00:13:04,632
और यदि आप एक लाख बिट्स को देखने और एक त्रुटि का पता लगाने के बारे

186
00:13:04,632 --> 00:13:08,640
में सोचने के लिए पीछे हटते हैं, तो यह वास्तव में पागलपन जैसा लगता है।

187
00:13:08,640 --> 00:13:13,407
निस्संदेह, समस्या यह है कि बड़े ब्लॉक के साथ, एक या दो से अधिक बिट त्रुटियाँ

188
00:13:13,407 --> 00:13:18,360
देखने की संभावना बढ़ जाती है, और हैमिंग कोड इससे आगे कुछ भी संभाल नहीं पाते हैं।

189
00:13:18,360 --> 00:13:22,402
इसलिए व्यवहार में, आप जो चाहते हैं वह सही आकार ढूंढना

190
00:13:22,402 --> 00:13:26,520
है ताकि बहुत अधिक बिट फ़्लिप की संभावना बहुत अधिक न हो।

191
00:13:26,520 --> 00:13:31,045
इसके अलावा, व्यवहार में, त्रुटियां छोटे-छोटे विस्फोटों में आती हैं, जो एक

192
00:13:31,045 --> 00:13:35,938
ब्लॉक को पूरी तरह से बर्बाद कर देती हैं, इसलिए कई अलग-अलग ब्लॉकों में त्रुटियों

193
00:13:35,938 --> 00:13:40,587
के विस्फोट को फैलाने में मदद करने के लिए एक सामान्य रणनीति उन ब्लॉकों को इस

194
00:13:40,587 --> 00:13:45,480
तरह से जोड़ना है, इससे पहले कि वे समाप्त हो जाएं बाहर भेजा या संग्रहीत किया गया।

195
00:13:45,480 --> 00:13:48,907
फिर, इसमें से बहुत कुछ को अधिक आधुनिक कोड द्वारा पूरी तरह से म्यूट कर

196
00:13:48,907 --> 00:13:52,236
दिया गया है, जैसे कि अधिक सामान्यतः उपयोग किया जाने वाला रीड-सोलोमन

197
00:13:52,236 --> 00:13:55,810
एल्गोरिदम, जो विशेष रूप से विस्फोट त्रुटियों को अच्छी तरह से संभालता है,

198
00:13:55,810 --> 00:13:59,580
और इसे प्रति ब्लॉक बड़ी संख्या में त्रुटियों के लिए लचीला बनाया जा सकता है। .

199
00:13:59,580 --> 00:14:03,000
लेकिन यह अगली बार का विषय है।

200
00:14:03,000 --> 00:14:06,927
अपनी पुस्तक द आर्ट ऑफ डूइंग साइंस एंड इंजीनियरिंग में, हैमिंग ने आश्चर्यजनक

201
00:14:06,927 --> 00:14:10,700
रूप से स्पष्ट रूप से बताया है कि इस कोड की उनकी खोज कितनी टेढ़ी-मेढ़ी थी।

202
00:14:10,700 --> 00:14:14,483
उन्होंने सबसे पहले बिट्स को उच्च आयामी जाली के हिस्सों में व्यवस्थित करने

203
00:14:14,483 --> 00:14:18,420
और इस तरह की अजीब चीजों से संबंधित सभी प्रकार की विभिन्न योजनाओं की कोशिश की।

204
00:14:18,420 --> 00:14:23,190
यह विचार कि किसी त्रुटि की स्थिति बताने के लिए समता जांच प्राप्त करना संभव

205
00:14:23,190 --> 00:14:27,898
हो सकता है, हेमिंग को तभी आया जब वह कई अन्य विश्लेषणों के बाद पीछे हटे और

206
00:14:27,898 --> 00:14:32,860
पूछा, ठीक है, मैं सबसे कुशल क्या कर सकता हूं क्या आप इस बारे में सोच सकते हैं?

207
00:14:32,860 --> 00:14:37,479
वह इस बारे में भी स्पष्ट थे कि यह कितना महत्वपूर्ण है कि समता जांच पहले से ही

208
00:14:37,479 --> 00:14:42,040
उनके दिमाग में थी, जो कि आज की तुलना में 1940 के दशक में बहुत कम आम रही होगी।

209
00:14:42,040 --> 00:14:45,872
इस पुस्तक में लगभग आधा दर्जन बार उन्होंने लुई पाश्चर के इस

210
00:14:45,872 --> 00:14:49,640
कथन का संदर्भ दिया है कि भाग्य तैयार दिमाग का साथ देता है।

211
00:14:49,640 --> 00:14:52,527
चतुर विचार अक्सर बाद में भ्रामक रूप से सरल दिखते

212
00:14:52,527 --> 00:14:55,120
हैं, जिससे उनकी सराहना करना आसान हो जाता है।

213
00:14:55,120 --> 00:14:58,368
अभी मेरी ईमानदार आशा यह है कि हैमिंग कोड, या कम

214
00:14:58,368 --> 00:15:01,820
से कम ऐसे कोड की संभावना, आपको लगभग स्पष्ट लगती है।

215
00:15:01,820 --> 00:15:04,855
लेकिन आपको यह सोचकर खुद को मूर्ख नहीं बनाना चाहिए कि वे

216
00:15:04,855 --> 00:15:08,000
वास्तव में स्पष्ट हैं, क्योंकि वे निश्चित रूप से नहीं हैं।

217
00:15:08,000 --> 00:15:11,952
चतुर विचारों के भ्रामक रूप से आसान दिखने का एक कारण यह है कि हम केवल

218
00:15:11,952 --> 00:15:15,904
अंतिम परिणाम देखते हैं, जो गड़बड़ था उसे साफ करना, सभी गलत मोड़ों का

219
00:15:15,904 --> 00:15:20,027
कभी उल्लेख नहीं करना, किसी समस्या की शुरुआत में अन्वेषण योग्य संभावनाओं

220
00:15:20,027 --> 00:15:23,980
का स्थान कितना विशाल है, इसकी कम बिक्री करना समाधान प्रक्रिया, वह सब।

221
00:15:23,980 --> 00:15:25,280
लेकिन यह सामान्य तौर पर सच है.

222
00:15:25,280 --> 00:15:28,101
मुझे लगता है कि कुछ विशेष आविष्कारों के लिए, एक

223
00:15:28,101 --> 00:15:31,040
दूसरा, गहरा कारण है कि हम उनकी कम सराहना करते हैं।

224
00:15:31,040 --> 00:15:35,246
सूचना सिद्धांत पर क्लाउड शैनन के मौलिक पेपर के साथ, बिट्स के संदर्भ में जानकारी

225
00:15:35,246 --> 00:15:39,400
के बारे में सोचना वास्तव में 1948 तक एक पूर्ण सिद्धांत में परिवर्तित हो गया था।

226
00:15:39,400 --> 00:15:43,440
यह अनिवार्य रूप से तब समवर्ती था जब हैमिंग ने अपना एल्गोरिदम विकसित किया था।

227
00:15:43,440 --> 00:15:48,616
यह वही मूलभूत पेपर था जिसने एक निश्चित अर्थ में दिखाया कि कुशल त्रुटि सुधार हमेशा

228
00:15:48,616 --> 00:15:53,920
संभव है, चाहे बिट फ़्लिप की संभावना कितनी भी अधिक क्यों न हो, कम से कम सिद्धांत में।

229
00:15:53,920 --> 00:15:58,128
वैसे, बहुत अलग-अलग चीजों पर काम करने के बावजूद, शैनन और हैमिंग ने

230
00:15:58,128 --> 00:16:02,400
बेल लैब्स में एक कार्यालय साझा किया, जो यहां शायद ही संयोग लगता है।

231
00:16:02,400 --> 00:16:05,997
कई दशक तेजी से आगे बढ़े, और इन दिनों, हममें से कई लोग छोटी-छोटी

232
00:16:05,997 --> 00:16:09,538
बातों और सूचनाओं के बारे में सोचने में इतने डूबे हुए हैं कि इस

233
00:16:09,538 --> 00:16:13,080
बात को नजरअंदाज करना आसान है कि सोचने का यह तरीका कितना अलग था।

234
00:16:13,080 --> 00:16:15,484
विडंबना यह है कि जो विचार भविष्य की पीढ़ी के सोचने के तरीकों को सबसे गहराई से

235
00:16:15,484 --> 00:16:17,920
आकार देते हैं, वे भविष्य की पीढ़ी को वास्तव में उनकी तुलना में अधिक सरल लगेंगे।

