[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing? ",
  "translatedText": "คุณเคยสงสัยบ้างไหมว่าเป็นไปได้อย่างไรที่จะเกาซีดีหรือดีวีดีแต่ยังคงเล่นไฟล์ที่เก็บไว้อยู่ได้?  ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.62,
  "end": 10.1
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 10.9,
  "end": 27.44
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 27.44,
  "end": 36.66
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 37.52,
  "end": 41.6
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s. ",
  "translatedText": "รอยขีดข่วนส่งผลต่อเลข 1 และ 0 บนดิสก์จริงๆ ดังนั้นจึงอ่านข้อมูลที่แตกต่างจากข้อมูลที่เก็บไว้ แต่เว้นแต่ว่าจะมีรอยขีดข่วนจริงๆ บิตที่อ่านออกจะถูกถอดรหัสเป็นไฟล์เดียวกับที่เข้ารหัสลงบนดิสก์ bit for bit copy แม้ว่าจะมีข้อผิดพลาดทั้งหมดก็ตาม มีความฉลาดทางคณิตศาสตร์มากมายที่ช่วยให้เราสามารถจัดเก็บข้อมูลได้ และที่สำคัญไม่แพ้กันในการส่งข้อมูล ในลักษณะที่ทนทานต่อข้อผิดพลาด โอเค จริงๆ แล้ว มันไม่ต้องใช้ความฉลาดขนาดนั้นในการคิดวิธีการทำเช่นนี้ ไฟล์ใดๆ ไม่ว่าจะเป็นวิดีโอ เสียง หรือข้อความ โค้ดบางส่วน รูปภาพ หรืออะไรก็ตาม สุดท้ายแล้วก็คือลำดับของ 1 และ 0 และกลยุทธ์ง่ายๆ ในการแก้ไขบิตใดๆ ที่ถูกพลิกคือเก็บสำเนาสามชุดของแต่ละบิต จากนั้นเครื่องที่อ่านไฟล์นี้สามารถเปรียบเทียบสำเนาทั้งสามชุดนี้ และนำ 2 ใน 3 ที่ดีที่สุดเสมอทุกครั้งที่มีความคลาดเคลื่อน แต่นั่นหมายความว่าคือการใช้พื้นที่สองในสามของคุณเพื่อความซ้ำซ้อน และถึงอย่างนั้น สำหรับพื้นที่ทั้งหมดที่สละไปนั้น ก็ไม่มีการรับประกันที่ชัดเจนเกี่ยวกับสิ่งที่จะเกิดขึ้นหากมีการพลิกบิตมากกว่าหนึ่งบิต คำถามที่น่าสนใจกว่านั้นคือต้องทำอย่างไรจึงจะสามารถแก้ไขข้อผิดพลาดได้โดยยอมสละพื้นที่ให้น้อยที่สุด  ตัวอย่างเช่น เมื่อใช้วิธีการที่คุณจะได้เรียนรู้เกี่ยวกับวิดีโอนี้ คุณสามารถจัดเก็บข้อมูลของคุณในรูปแบบบล็อก 256 บิต โดยแต่ละบล็อกใช้ 9 บิต 9! ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 42.06,
  "end": 50.38
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 50.68,
  "end": 56.0
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 57.58,
  "end": 64.06
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 67.16,
  "end": 70.86
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 71.48,
  "end": 77.24
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 77.98,
  "end": 84.02
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9! ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 84.52,
  "end": 93.36
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want. ",
  "translatedText": "เพื่อทำหน้าที่เป็นความซ้ำซ้อน และอีก 247 บิตมีอิสระในการส่งข้อความหรือข้อมูลที่มีความหมายตามที่คุณต้องการ และยังคงเป็นกรณีที่หากมีการพลิกตรงนี้เพียงดูที่บล็อกนี้แล้วไม่มีอะไรเพิ่มเติมเครื่องก็จะสามารถระบุได้ว่ามีข้อผิดพลาดและอยู่ที่ไหนอย่างแม่นยำเพื่อให้รู้วิธีแก้ไข .  ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 93.76,
  "end": 100.3
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 100.9,
  "end": 112.66
 },
 {
  "input": "And honestly, that feels like magic. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 112.66,
  "end": 114.62
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 115.44,
  "end": 122.86
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 123.52,
  "end": 126.9
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 127.86,
  "end": 132.9
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.66,
  "end": 141.94
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 142.84,
  "end": 148.66
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 149.52,
  "end": 159.82
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 160.12,
  "end": 166.72
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 167.24,
  "end": 178.24
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 179.3,
  "end": 193.0
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 193.72,
  "end": 202.18
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.8,
  "end": 206.94
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 208.9,
  "end": 217.34
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.22,
  "end": 224.06
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 226.78,
  "end": 237.42
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 237.8,
  "end": 242.4
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.12,
  "end": 248.42
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 249.06,
  "end": 255.38
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 256.52,
  "end": 260.94
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 261.82,
  "end": 264.74
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.62,
  "end": 273.0
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 273.9,
  "end": 280.04
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience. ",
  "translatedText": "และจริงๆ แล้วนั่นให้ความรู้สึกเหมือนเป็นเวทย์มนตร์ และสำหรับรูปแบบเฉพาะนี้ ถ้ามีการพลิกสองบิต อย่างน้อยเครื่องจะสามารถตรวจพบว่ามีข้อผิดพลาดสองรายการ แม้ว่าจะไม่ทราบวิธีแก้ไขก็ตาม เราจะพูดคุยกันในภายหลังเกี่ยวกับวิธีการปรับขนาดบล็อกที่มีขนาดต่างกัน วิธีที่ช่วยให้คุณแก้ไขข้อผิดพลาดเช่นนี้เป็นที่ทราบกันดีอยู่แล้วว่าเป็นรหัสแก้ไขข้อผิดพลาด  ในช่วงที่ดีขึ้นของศตวรรษที่ผ่านมา สาขานี้เป็นแหล่งคณิตศาสตร์เชิงลึกที่น่าประหลาดใจมากมาย ซึ่งรวมอยู่ในอุปกรณ์ที่เราใช้ทุกวัน เป้าหมายคือการทำให้คุณมีความเข้าใจอย่างถ่องแท้เกี่ยวกับหนึ่งในตัวอย่างแรกสุดที่เรียกว่ารหัส Hamming อย่างไรก็ตาม วิธีที่ฉันคิดเกี่ยวกับโครงสร้างของวิดีโอนี้ ไม่ได้เน้นไปที่การอธิบายโดยตรงที่สุดเท่าที่จะเป็นไปได้ แต่เป็นการกระตุ้นให้คุณประดิษฐ์มันขึ้นมาเองมากกว่า โดยมีคำแนะนำที่อ่อนโยนเล็กน้อยตรงนี้และตรงนั้น ดังนั้น เมื่อคุณรู้สึกว่าคุณเห็นว่ามันจะเป็นอย่างไร ณ จุดใดจุดหนึ่ง ให้ใช้เวลาสักครู่เพื่อหยุดชั่วคราว คาดการณ์อย่างแข็งขันว่าแผนการจะเป็นอย่างไรก่อนที่ฉันจะบอกคุณ นอกจากนี้ หากคุณต้องการให้ความเข้าใจของคุณลงไปจนถึงระดับฮาร์ดแวร์ Ben Eater ได้สร้างวิดีโอร่วมกับวิดีโอนี้เพื่อแสดงให้คุณเห็นวิธีการใช้โค้ด Hamming บน breadboards ซึ่งน่าพึงพอใจอย่างยิ่ง คุณควรรู้ไว้ว่า รหัส Hamming ไม่ได้ใช้กันอย่างแพร่หลายเท่ากับรหัสสมัยใหม่ เช่น อัลกอริธึม Reed-Solomon แต่มีเวทย์มนตร์บางอย่างที่ทำให้เกิดความแตกต่างระหว่างความรู้สึกที่เป็นไปไม่ได้ในตอนแรกกับความรู้สึกที่สมเหตุสมผลอย่างยิ่งในครั้งเดียว คุณเรียนรู้เกี่ยวกับแฮมมิง หลักการพื้นฐานของการแก้ไขข้อผิดพลาดคือในพื้นที่อันกว้างใหญ่ของข้อความที่เป็นไปได้ทั้งหมด มีเพียงบางส่วนเท่านั้นที่จะถือว่าข้อความที่ถูกต้อง ในการเปรียบเทียบ ลองนึกถึงคำที่สะกดถูกและคำที่สะกดผิด เมื่อใดก็ตามที่ข้อความที่ถูกต้องถูกแก้ไข ผู้รับจะต้องรับผิดชอบในการแก้ไขสิ่งที่พวกเขาเห็นกลับไปยังเพื่อนบ้านที่ถูกต้องที่ใกล้ที่สุด เช่นเดียวกับที่คุณทำกับการพิมพ์ผิด การสร้างอัลกอริธึมที่เป็นรูปธรรมเพื่อจัดหมวดหมู่ข้อความเช่นนี้ได้อย่างมีประสิทธิภาพนั้นต้องใช้ความฉลาดพอสมควร  เรื่องราวเริ่มต้นในปี 1940 เมื่อ Richard Hamming วัยเยาว์ทำงานให้กับ Bell Labs และงานบางส่วนของเขาเกี่ยวข้องกับการใช้คอมพิวเตอร์ Punch Card ขนาดใหญ่ราคาแพงซึ่งเขาเข้าถึงได้เพียงอย่างจำกัดเท่านั้น และโปรแกรมที่เขาทำอย่างต่อเนื่องก็ล้มเหลว เพราะบางครั้งอาจอ่านผิดบ้าง ความหงุดหงิดเป็นบ่อเกิดของการประดิษฐ์ เขาเบื่อหน่ายจนคิดค้นรหัสแก้ไขข้อผิดพลาดตัวแรกของโลก มีหลายวิธีในการวางกรอบโค้ดของ Hamming แต่เมื่อผ่านครั้งแรก เราจะพูดถึงวิธีที่ Hamming คิดเกี่ยวกับมัน ลองใช้ตัวอย่างที่เรียบง่ายแต่ไม่ง่ายเกินไป บล็อกขนาด 16 บิต เราจะกำหนดหมายเลขตำแหน่งของบิตเหล่านี้ตั้งแต่ 0 ถึง 15 ข้อมูลจริงที่เราต้องการจัดเก็บจะประกอบขึ้นเป็น 12 บิตของบิตเหล่านี้เท่านั้น ในขณะที่ 4 ตำแหน่งจะถูกสงวนไว้เป็นการสำรองประเภทหนึ่ง คำว่าซ้ำซ้อนในที่นี้ไม่ได้หมายถึงการคัดลอกเท่านั้น อย่างไรก็ตาม 4 บิตเหล่านั้นไม่ได้ให้พื้นที่เพียงพอที่จะคัดลอกข้อมูลแบบสุ่มสี่สุ่มห้า แต่จะต้องมีความซ้ำซ้อนที่เหมาะสมและชาญฉลาดมากขึ้น โดยไม่ต้องเพิ่มข้อมูลใหม่ใดๆ แต่เพิ่มความยืดหยุ่น คุณอาจคาดหวังว่าชิ้นส่วนพิเศษทั้ง 4 ชิ้นนี้จะบรรจุรวมกันอย่างสวยงาม อาจจะเป็นตอนท้ายหรืออะไรทำนองนั้น แต่อย่างที่คุณเห็น การวางพวกมันในตำแหน่งที่เป็นกำลัง 2 จะทำให้ได้บางสิ่งที่ดูหรูหราจริงๆ ในตอนท้าย นอกจากนี้ยังอาจให้คำแนะนำเล็กน้อยเกี่ยวกับวิธีการปรับขนาดสำหรับบล็อกขนาดใหญ่ ในทางเทคนิคแล้ว ข้อมูลจะมีเพียง 11 บิต คุณจะพบว่าสิ่งที่เกิดขึ้นที่ตำแหน่ง 0 มีความแตกต่างเล็กน้อย แต่อย่าเพิ่งกังวลไปในตอนนี้ เช่นเดียวกับอัลกอริธึมการแก้ไขข้อผิดพลาดใดๆ สิ่งนี้จะเกี่ยวข้องกับผู้เล่นสองคน ผู้ส่งที่รับผิดชอบในการตั้งค่าบิตพิเศษ 4 บิตนี้ และผู้รับที่รับผิดชอบในการดำเนินการตรวจสอบและแก้ไขข้อผิดพลาดบางประเภท แน่นอนว่าคำว่าผู้ส่งและผู้รับหมายถึงเครื่องจักรหรือซอฟต์แวร์ที่ทำการตรวจสอบทั้งหมด และแนวคิดของข้อความก็มีความหมายกว้างมาก โดยรวมถึงสิ่งต่างๆ เช่น พื้นที่เก็บข้อมูล ท้ายที่สุดแล้ว การจัดเก็บข้อมูลก็เหมือนกับการส่งข้อความจากอดีตสู่อนาคต แทนที่จะส่งจากที่หนึ่งไปอีกที่หนึ่ง นั่นคือการตั้งค่า แต่ก่อนที่เราจะดำดิ่งลงไปได้ เราต้องพูดถึงแนวคิดที่เกี่ยวข้องซึ่งยังอยู่ในใจของแฮมมิงในช่วงเวลาที่เขาค้นพบ ซึ่งเป็นวิธีการที่ช่วยให้คุณตรวจพบข้อผิดพลาดเล็กๆ น้อยๆ ใดๆ ได้ แต่ไม่สามารถแก้ไขได้ ตามที่ทราบกันดี ในการประกอบธุรกิจเป็นการตรวจสอบความเท่าเทียมกัน สำหรับการตรวจสอบพาริตี เราจะแยกออกเพียงบิตเดียวที่ผู้ส่งรับผิดชอบในการปรับแต่ง และส่วนที่เหลือสามารถส่งข้อความได้อย่างอิสระ งานเดียวของบิตพิเศษนี้คือต้องแน่ใจว่าจำนวน 1 ทั้งหมดในข้อความเป็นเลขคู่ ตัวอย่างเช่น ตอนนี้ จำนวนรวมของ 1 คือ 7 ซึ่งเป็นเลขคี่ ดังนั้นผู้ส่งจึงต้องพลิกบิตพิเศษนั้นให้เป็น 1 เพื่อให้การนับเลขคู่ แต่ถ้าบล็อกเริ่มต้นด้วยเลขคู่เป็น 1 แล้ว บิตพิเศษนี้ก็จะคงไว้ที่ 0 นี่เป็นวิธีที่ค่อนข้างเรียบง่าย เรียบง่ายหลอกลวง แต่เป็นวิธีที่สวยงามอย่างเหลือเชื่อในการกลั่นกรองแนวคิดเรื่องการเปลี่ยนแปลงที่ใดก็ได้ในข้อความเพื่อให้สะท้อนให้เห็นเป็นข้อมูลเพียงส่วนเดียว สังเกตว่าหากมีการพลิกข้อความส่วนใดส่วนหนึ่งของข้อความนี้ จาก 0 เป็น 1 หรือ 1 เป็น 0 มันจะเปลี่ยนจำนวนรวมของ 1 จากเป็นคู่เป็นคี่ ดังนั้น หากคุณเป็นผู้รับ คุณดูข้อความนี้ และคุณเห็นเลขคี่เป็น 1 คุณสามารถรู้ได้อย่างแน่นอนว่ามีข้อผิดพลาดเกิดขึ้น แม้ว่าคุณอาจไม่รู้ว่ามันอยู่ที่ไหนก็ตาม ในศัพท์แสง ไม่ว่ากลุ่มของบิตจะมีเลข 1 เป็นคู่หรือคี่ก็ตาม เรียกว่าความเท่าเทียมกัน คุณยังสามารถใช้ตัวเลขและบอกว่าความเท่าเทียมกันคือ 0 หรือ 1 ซึ่งโดยทั่วไปจะมีประโยชน์มากกว่าเมื่อคุณเริ่มคำนวณแนวคิดนี้ และบิตพิเศษนี้ที่ผู้ส่งใช้ในการควบคุมพาริตี เรียกว่าพาริตีบิต และจริงๆ แล้วเราควรชัดเจนว่าถ้าผู้รับเห็นความเท่าเทียมกันของเลขคี่ก็ไม่ได้หมายความว่ามีข้อผิดพลาดเพียงจุดเดียว อาจมีข้อผิดพลาด 3 จุด หรือ 5 หรือเลขคี่อื่นๆ แต่พวกเขาสามารถรู้ได้อย่างแน่นอน ว่ามันไม่ใช่ 0 ในทางกลับกัน หากมีข้อผิดพลาด 2 ข้อ หรือข้อผิดพลาดเป็นจำนวนคู่ การนับ 1 สุดท้ายนั้นจะยังคงเป็นเลขคู่ ดังนั้นผู้รับจึงไม่มั่นใจเต็มที่ว่าการนับเลขคู่หมายความว่าข้อความนั้นปราศจากข้อผิดพลาด . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 280.72,
  "end": 287.28
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 288.6,
  "end": 299.62
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.2,
  "end": 303.54
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 304.9,
  "end": 313.26
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 314.14,
  "end": 325.54
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 326.3,
  "end": 334.74
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 335.34,
  "end": 341.68
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 342.56,
  "end": 356.3
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 356.88,
  "end": 363.82
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 364.88,
  "end": 371.28
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 372.08,
  "end": 379.96
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 380.8,
  "end": 386.42
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 387.34,
  "end": 396.78
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 397.5,
  "end": 406.54
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 407.98,
  "end": 417.46
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 418.5,
  "end": 423.34
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 424.86,
  "end": 430.72
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 431.22,
  "end": 435.52
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 437.56,
  "end": 449.26
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 449.98,
  "end": 462.3
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 462.84,
  "end": 469.08
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 469.7,
  "end": 478.9
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 479.58,
  "end": 485.44
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 486.24,
  "end": 495.38
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 496.26,
  "end": 507.16
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 507.94,
  "end": 525.94
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 526.68,
  "end": 533.38
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 534.16,
  "end": 539.38
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 540.1,
  "end": 548.24
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 548.94,
  "end": 556.24
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 557.18,
  "end": 567.2
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.24,
  "end": 576.62
 },
 {
  "input": "Here let's just choose position 1. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 577.48,
  "end": 579.18
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.72,
  "end": 586.98
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 587.94,
  "end": 590.68
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 590.92,
  "end": 596.3
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 596.68,
  "end": 606.06
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 607.02,
  "end": 615.38
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 615.82,
  "end": 620.58
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 621.12,
  "end": 626.5
 },
 {
  "input": "Things break down completely for more than that. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 626.94,
  "end": 628.74
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 629.16,
  "end": 635.1
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 635.8,
  "end": 639.66
 },
 {
  "input": "It necessarily means the error is somewhere in the last column. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 640.2,
  "end": 643.04
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 643.82,
  "end": 649.7
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 650.44,
  "end": 656.02
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 656.02,
  "end": 663.12
 },
 {
  "input": "But it also might simply mean there's no error at all. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 663.34,
  "end": 666.12
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column. ",
  "translatedText": "คุณอาจบ่นว่าข้อความที่เลอะเทอะด้วยการพลิกเพียง 2 บิตนั้นค่อนข้างอ่อนแอ และคุณพูดถูกอย่างแน่นอน อย่างไรก็ตาม โปรดทราบว่าไม่มีวิธีการใดในการตรวจจับหรือแก้ไขข้อผิดพลาดที่จะทำให้คุณมั่นใจได้ 100% ว่าข้อความที่คุณได้รับคือข้อความที่ผู้ส่งตั้งใจไว้ ท้ายที่สุดแล้ว สัญญาณรบกวนแบบสุ่มที่เพียงพอสามารถเปลี่ยนข้อความที่ถูกต้องหนึ่งข้อความให้เป็นข้อความที่ถูกต้องอีกข้อความหนึ่งได้เพียงโดยบังเอิญ เป้าหมายคือการสร้างรูปแบบที่แข็งแกร่งจนถึงจำนวนข้อผิดพลาดสูงสุดที่กำหนด หรืออาจลดความน่าจะเป็นของผลบวกลวงเช่นนี้ การตรวจสอบความเท่าเทียมกันด้วยตัวเองนั้นค่อนข้างอ่อนแอ แต่ด้วยการกลั่นกรองแนวคิดเรื่องการเปลี่ยนแปลงในข้อความทั้งหมดให้เหลือเพียงนิดเดียว สิ่งที่พวกเขามอบให้เราคือแบบเอกสารสำเร็จรูปที่มีประสิทธิภาพสำหรับแผนงานที่มีความซับซ้อนมากขึ้น ตัวอย่างเช่น ขณะที่ Hamming กำลังค้นหาวิธีในการระบุว่าข้อผิดพลาดเกิดขึ้นที่ใด ไม่ใช่แค่ว่ามันเกิดขึ้นเท่านั้น ข้อมูลเชิงลึกที่สำคัญของเขาก็คือ ถ้าคุณใช้การตรวจสอบความเท่าเทียมกันบางอย่างกับข้อความทั้งหมด แต่กับชุดย่อยที่เลือกอย่างระมัดระวังบางชุด คุณสามารถถามได้ ชุดคำถามที่ได้รับการปรับปรุงมากขึ้นซึ่งจะปักหมุดตำแหน่งของข้อผิดพลาดบิตเดียว ความรู้สึกโดยรวมก็เหมือนกับการเล่นเกมคำถาม 20 ข้อ การถามคำถามใช่หรือไม่ใช่ที่จะตัดพื้นที่ของความเป็นไปได้ลงครึ่งหนึ่ง ตัวอย่างเช่น สมมติว่าเราทำการตรวจสอบความเท่าเทียมกันบน 8 บิตเหล่านี้ ซึ่งเป็นตำแหน่งที่เป็นเลขคี่ทั้งหมด จากนั้นหากตรวจพบข้อผิดพลาด จะทำให้ผู้รับได้รับข้อมูลเพิ่มเติมอีกเล็กน้อยว่าข้อผิดพลาดนั้นอยู่ที่ตำแหน่งใดโดยเฉพาะ กล่าวคือ ข้อผิดพลาดนั้นอยู่ในตำแหน่งคี่ หากตรวจไม่พบข้อผิดพลาดใน 8 บิตเหล่านั้น อาจหมายความว่าไม่มีข้อผิดพลาดเลย หรืออยู่ที่ตำแหน่งคู่ คุณอาจคิดว่าการจำกัดการตรวจสอบพาริตีให้เหลือเพียงครึ่งบิตจะทำให้มีประสิทธิภาพน้อยลง แต่เมื่อทำร่วมกับการตรวจสอบอื่นๆ ที่ได้รับการคัดเลือกมาอย่างดี มันจะทำให้เรามีบางสิ่งที่ทรงพลังมากขึ้นโดยไม่ได้ตั้งใจ หากต้องการตั้งค่าการตรวจสอบพาริตีจริงๆ โปรดจำไว้ว่า จำเป็นต้องมีการจัดสรรบิตพิเศษบางส่วนที่สามารถควบคุมความเท่าเทียมกันของกลุ่มทั้งหมดนั้นได้ เรามาเลือกตำแหน่งที่ 1 กันดีกว่า สำหรับตัวอย่างที่แสดง แพริตีของ 8 บิตเหล่านี้ในปัจจุบันเป็นเลขคี่ ดังนั้นผู้ส่งจึงมีหน้าที่ในการสลับบิตพาริตีนั้น และตอนนี้ก็เป็นเลขคู่ นี่เป็นเพียง 1 ใน 4 ของการตรวจสอบความเท่าเทียมกันที่เราจะทำ การตรวจสอบครั้งที่สองเป็นหนึ่งใน 8 บิตบนครึ่งขวาของตาราง อย่างน้อยก็ตามที่เราได้วาดไว้ที่นี่ คราวนี้เราอาจใช้ตำแหน่ง 2 เป็นพาริตีบิต ดังนั้น 8 บิตเหล่านี้จึงมีความเท่าเทียมกันอยู่แล้ว และผู้ส่งก็รู้สึกดีที่จะปล่อยบิตหมายเลข 2 ไว้ไม่เปลี่ยนแปลง อีกด้านหนึ่ง หากผู้รับตรวจสอบความเท่าเทียมกันของกลุ่มนี้ และพวกเขาพบว่ามันแปลก พวกเขาจะรู้ว่าข้อผิดพลาดอยู่ที่ไหนสักแห่งใน 8 บิตเหล่านี้ทางด้านขวา มิฉะนั้นอาจหมายความว่าไม่มีข้อผิดพลาด หรือข้อผิดพลาดอยู่ที่ครึ่งซ้าย หรือฉันเดาว่าอาจมีข้อผิดพลาดสองประการ แต่ตอนนี้เราจะถือว่ามีข้อผิดพลาดมากที่สุดหนึ่งข้อในบล็อกทั้งหมด สิ่งต่าง ๆ พังทลายลงอย่างสมบูรณ์มากกว่านั้น ก่อนที่เราจะดูการตรวจสอบสองรายการถัดไป โปรดใช้เวลาสักครู่เพื่อพิจารณาว่าสองรายการแรกนี้ช่วยให้เราทำอะไรได้บ้างเมื่อคุณพิจารณาทั้งสองรายการร่วมกัน สมมติว่าคุณตรวจพบข้อผิดพลาดในคอลัมน์คี่ และในคอลัมน์ครึ่งขวา จำเป็นต้องหมายความว่ามีข้อผิดพลาดอยู่ที่ไหนสักแห่งในคอลัมน์สุดท้าย หากไม่มีข้อผิดพลาดในคอลัมน์คี่แต่มีข้อผิดพลาดในครึ่งขวา นั่นจะบอกคุณว่าอยู่ในคอลัมน์ที่สองจากคอลัมน์สุดท้าย ในทำนองเดียวกัน หากมีข้อผิดพลาดในคอลัมน์คี่แต่ไม่ใช่ครึ่งขวา คุณจะรู้ว่ามันอยู่ที่ไหนสักแห่งในคอลัมน์ที่สอง และถ้าการตรวจสอบพาริตีทั้งสองตรวจไม่พบสิ่งใดเลย นั่นหมายความว่าที่เดียวที่อาจเกิดข้อผิดพลาดได้คือในคอลัมน์ซ้ายสุดนั้น แต่ก็อาจหมายความว่าไม่มีข้อผิดพลาดเลยด้วย ซึ่งเป็นวิธีที่ค่อนข้างซับซ้อนในการบอกว่าการตรวจสอบความเท่าเทียมกันสองครั้งช่วยให้เราปักหมุดคอลัมน์ได้  จากตรงนี้คุณคงเดาได้ว่าอะไรจะเกิดขึ้นตามมา โดยพื้นฐานแล้วเราทำสิ่งเดียวกันแต่สำหรับแถว จะมีการตรวจสอบความเท่าเทียมกันในแถวคี่ โดยใช้ตำแหน่ง 4 เป็นบิตความเท่าเทียมกัน ดังนั้นในตัวอย่างนี้ กลุ่มนั้นมีความเท่าเทียมกันอยู่แล้ว ดังนั้นบิต 4 จะถูกตั้งค่าเป็น 0 และสุดท้ายจะมีการตรวจสอบความเท่าเทียมกันในสองแถวล่าง โดยใช้ตำแหน่ง 8 เป็นบิตความเท่าเทียมกัน ในกรณีนี้ ดูเหมือนว่าผู้ส่งจะต้องเปิดบิต 8 นั้นเพื่อให้กลุ่มมีความเท่าเทียมกัน เหมือนกับที่เช็คสองอันแรกให้เราปักหมุดคอลัมน์ไว้ ส่วนสองอันถัดไปนี้ให้คุณปักหมุดแถวนั้นได้ ตามตัวอย่าง ลองนึกภาพว่าในระหว่างการส่งสัญญาณมีข้อผิดพลาดที่ตำแหน่ง 3 สิ่งนี้ส่งผลต่อกลุ่มพาริตีกลุ่มแรก และส่งผลต่อกลุ่มพาริตีกลุ่มที่สองด้วย ดังนั้นผู้รับจึงรู้ว่ามีข้อผิดพลาดอยู่ที่ไหนสักแห่งในคอลัมน์ด้านขวานั้น แต่ไม่กระทบกลุ่มที่สาม และไม่กระทบกลุ่มที่สี่ และนั่นทำให้ผู้รับระบุข้อผิดพลาดได้จนถึงแถวแรก ซึ่งหมายถึงตำแหน่งที่ 3 จึงสามารถแก้ไขข้อผิดพลาดได้ คุณอาจสนุกกับการใช้เวลาสักครู่เพื่อโน้มน้าวตัวเองว่าคำตอบสำหรับคำถามทั้งสี่ข้อนี้จะช่วยให้คุณระบุสถานที่ที่เฉพาะเจาะจงได้เสมอ ไม่ว่าพวกเขาจะอยู่ที่ไหนก็ตาม อันที่จริง ความฉลาดในหมู่พวกคุณอาจสังเกตเห็นความเชื่อมโยงระหว่างคำถามเหล่านี้กับการนับเลขฐานสองด้วยซ้ำ และถ้าคุณทำเช่นนั้น ฉันขอย้ำอีกครั้ง หยุดชั่วคราว พยายามดึงการเชื่อมต่อด้วยตัวเองก่อนที่ฉันจะสปอยล์ หากคุณสงสัยว่าจะเกิดอะไรขึ้นหาก parity bit ได้รับผลกระทบ คุณก็สามารถลองดูได้ ใช้เวลาสักครู่เพื่อพิจารณาว่าข้อผิดพลาดใด ๆ ในบิตพิเศษทั้งสี่นี้จะถูกติดตามอย่างไรเหมือนกับที่อื่น ๆ โดยมีคำถามสี่กลุ่มกลุ่มเดียวกัน มันไม่สำคัญเลย เพราะท้ายที่สุดแล้ว สิ่งที่เราต้องการคือการปกป้องบิตของข้อความ บิตการแก้ไขข้อผิดพลาดก็ยังคงดำเนินต่อไป แต่การปกป้องบิตเหล่านั้นก็เป็นสิ่งที่หลุดออกจากโครงการโดยเป็นผลพลอยได้  คุณอาจสนุกกับการคาดเดาว่าสิ่งนี้จะขยายขนาดได้อย่างไร ตัวอย่างเช่น หากเราใช้บล็อกขนาด 256 บิต เพื่อปักหมุดตำแหน่ง คุณมีคำถามใช่หรือไม่ใช่เพียงแปดคำถามในการค้นหาแบบไบนารี่ไปยังจุดใดจุดหนึ่งโดยเฉพาะ และอย่าลืมว่าแต่ละคำถามจำเป็นต้องสละเวลาเพียงเล็กน้อยเพื่อตั้งค่าการตรวจสอบความเท่าเทียมกันที่เหมาะสม  บางท่านอาจเห็นแล้ว แต่เราจะพูดถึงวิธีที่เป็นระบบเพื่อค้นหาว่าคำถามเหล่านี้คืออะไรในเวลาเพียงไม่กี่นาที หวังว่าภาพร่างนี้จะเพียงพอที่จะชื่นชมประสิทธิภาพของสิ่งที่เรากำลังพัฒนาที่นี่  สิ่งแรก ยกเว้นพาริตี้บิตที่เน้นไว้แปดบิตนั้น สามารถเป็นอะไรก็ได้ที่คุณต้องการให้เป็น โดยพกพาข้อความหรือข้อมูลอะไรก็ได้ที่คุณต้องการ 8 บิตนั้นซ้ำซ้อนในแง่ที่ว่าถูกกำหนดโดยส่วนที่เหลือของข้อความ แต่มันเป็นวิธีที่ฉลาดกว่าการคัดลอกข้อความโดยรวม ถึงกระนั้น หากยอมแพ้เพียงเล็กน้อย คุณจะสามารถระบุและแก้ไขข้อผิดพลาดเล็กๆ น้อยๆ ได้ เกือบแล้ว โอเค ปัญหาหนึ่งที่นี่คือ หากไม่มีการตรวจสอบพาริตี้ทั้งสี่รายการตรวจพบข้อผิดพลาด หมายความว่าชุดย่อยที่เลือกเป็นพิเศษของ 8 บิตทั้งหมดมีความเท่าเทียมกัน เช่นเดียวกับที่ผู้ส่งตั้งใจไว้ นั่นหมายความว่าไม่มีข้อผิดพลาดเลย หรือมันจำกัดเราให้แคบลงเหลือตำแหน่ง 0 คุณคงเห็นว่าด้วยคำถามใช่หรือไม่ใช่สี่ข้อ เรามีผลลัพธ์ที่เป็นไปได้ 16 รายการสำหรับการตรวจสอบความเท่าเทียมกันของเรา และในตอนแรกนั้นให้ความรู้สึกที่สมบูรณ์แบบในการระบุ 1 จาก 16 ตำแหน่งในบล็อก แต่คุณยังต้องสื่อสารผลลัพธ์ที่ 17 ด้วย ไม่มีข้อผิดพลาด เงื่อนไข. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.3,
  "end": 670.84
 },
 {
  "input": "From here, you can probably guess what follows. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 671.48,
  "end": 673.64
 },
 {
  "input": "We do basically the same thing but for the rows. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 673.8,
  "end": 676.14
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 676.44,
  "end": 680.9
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 681.38,
  "end": 685.82
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 686.56,
  "end": 691.58
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 692.12,
  "end": 696.82
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 697.7,
  "end": 701.84
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 702.88,
  "end": 707.54
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 708.18,
  "end": 715.56
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.1,
  "end": 720.54
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 721.24,
  "end": 727.52
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 728.58,
  "end": 737.1
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 737.72,
  "end": 743.06
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 743.5,
  "end": 748.92
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 750.5,
  "end": 756.06
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 756.44,
  "end": 764.18
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 767.06,
  "end": 773.1
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 773.6,
  "end": 777.82
 },
 {
  "input": "You might also enjoy anticipating how this scales. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 779.2,
  "end": 781.76
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 782.3,
  "end": 792.78
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 795.64,
  "end": 800.5
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 803.16,
  "end": 809.36
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 809.88,
  "end": 813.66
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 813.66,
  "end": 821.0
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 821.72,
  "end": 830.02
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 833.6,
  "end": 838.38
 },
 {
  "input": "Well, almost. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.2,
  "end": 840.4
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 840.96,
  "end": 856.86
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 857.74,
  "end": 871.9
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 873.02,
  "end": 877.3
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 877.84,
  "end": 883.46
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 884.24,
  "end": 893.22
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 893.78,
  "end": 898.8
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 899.86,
  "end": 908.14
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors. ",
  "translatedText": "วิธีแก้ปัญหาตรงนี้ค่อนข้างง่าย เพียงลืมเรื่องบิตที่ 0 ไปโดยสิ้นเชิง ดังนั้นเมื่อเราตรวจสอบความเท่าเทียมกันทั้งสี่ครั้ง และเราเห็นว่าทุกรายการเท่ากัน หมายความว่าไม่มีข้อผิดพลาดอย่างชัดเจน ความหมายคือแทนที่จะทำงานกับบล็อก 16 บิต แต่เราทำงานกับบล็อก 15 บิต โดยที่ 11 บิตในนั้นว่างในการส่งข้อความ และ 4 บิตในนั้นมีไว้สำหรับการซ้ำซ้อน และด้วยเหตุนี้ ตอนนี้เราจึงมีสิ่งที่ผู้คนในธุรกิจเรียกว่ารหัส 15-11 Hamming ที่กล่าวว่า เป็นเรื่องดีที่มีขนาดบล็อกที่มีพลังสะอาดเท่ากับ 2 และมีวิธีที่ชาญฉลาดที่เราสามารถเก็บบิตที่ 0 ไว้รอบๆ และทำให้มันทำงานพิเศษเล็กๆ น้อยๆ ให้เราได้ หากเราใช้มันเป็นพาริตีบิตทั่วทั้งบล็อก มันช่วยให้เราตรวจจับได้จริง แม้ว่าเราจะแก้ไขข้อผิดพลาด 2 บิตไม่ได้ก็ตาม นี่คือวิธีการทำงาน หลังจากตั้งค่าบิตแก้ไขข้อผิดพลาดพิเศษทั้งสี่บิตแล้ว เราก็ตั้งค่าบิตนั้นเป็น 0 เพื่อให้พาริตีของบล็อกทั้งหมดเท่ากัน เช่นเดียวกับการตรวจสอบพาริตีปกติ ทีนี้ หากมีข้อผิดพลาดบิตเดียว ความเท่าเทียมกันของบล็อกทั้งหมดจะสลับเป็นคี่ แต่เราจะจับได้อยู่ดีด้วยการตรวจสอบแก้ไขข้อผิดพลาดทั้งสี่ครั้ง อย่างไรก็ตาม หากมีข้อผิดพลาดสองประการ ความเท่าเทียมกันโดยรวมจะสลับกลับไปเป็นค่าคู่ แต่ผู้รับจะยังคงเห็นว่ามีข้อผิดพลาดบางอย่างเป็นอย่างน้อยเนื่องจากสิ่งที่เกิดขึ้นกับการตรวจสอบความเท่าเทียมกันทั้งสี่ครั้งนั้น ดังนั้นหากพวกเขาสังเกตเห็นความเท่าเทียมกันโดยรวม แต่มีบางสิ่งที่ไม่เป็นศูนย์เกิดขึ้นกับเช็คอื่นๆ มันจะบอกว่ามีข้อผิดพลาดอย่างน้อยสองครั้ง นั่นไม่ฉลาดเหรอ? ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 908.7,
  "end": 915.54
 },
 {
  "input": "Here's how it works. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 916.16,
  "end": 916.82
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 917.18,
  "end": 924.94
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 925.7,
  "end": 933.6
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 934.16,
  "end": 945.18
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 945.18,
  "end": 952.7
 },
 {
  "input": "Isn't that clever? ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.52,
  "end": 954.0
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 954.3,
  "end": 961.26
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.26,
  "end": 965.22
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 966.54,
  "end": 972.88
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself. ",
  "translatedText": "แม้ว่าเราจะไม่สามารถแก้ไขข้อผิดพลาด 2 บิตเหล่านั้นได้ เพียงแค่นำบิต 0 ที่น่ารำคาญเล็กน้อยกลับมาทำงาน ก็ช่วยให้เราตรวจพบข้อผิดพลาดเหล่านั้นได้ นี่เป็นมาตรฐานที่ค่อนข้างดี เรียกว่ารหัส Hamming แบบขยาย ในทางเทคนิคแล้ว ตอนนี้คุณมีคำอธิบายโดยละเอียดแล้วว่าโค้ด Hamming ทำอะไรได้บ้าง อย่างน้อยก็ตัวอย่างบล็อก 16 บิต แต่ฉันคิดว่าคุณจะพบว่าการตรวจสอบความเข้าใจของคุณและทำให้ทุกอย่างมั่นคงขึ้นจนถึงจุดนี้จะน่าพึงพอใจมากขึ้นโดยการทำตัวอย่างเต็มๆ หนึ่งตัวอย่างตั้งแต่ต้นจนจบด้วยตนเอง ฉันจะก้าวผ่านมันไปกับคุณเพื่อให้คุณสามารถตรวจสอบตัวเองได้ ในการตั้งค่าข้อความ ไม่ว่าจะเป็นข้อความตามตัวอักษรที่คุณกำลังแปลในพื้นที่หรือข้อมูลบางอย่างที่คุณต้องการจัดเก็บเมื่อเวลาผ่านไป ขั้นตอนแรกคือการแบ่งข้อความออกเป็นชิ้นขนาด 11 บิต แต่ละชิ้นจะถูกบรรจุลงในบล็อก 16 บิตที่ป้องกันข้อผิดพลาด ลองเอาอันนี้เป็นตัวอย่างแล้วลองทำจริงดู เอาเลย ทำได้จริง! ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 972.88,
  "end": 981.32
 },
 {
  "input": "I'll step through it with you though so you can check yourself. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 982.08,
  "end": 984.3
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 985.12,
  "end": 994.66
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 995.58,
  "end": 999.76
 },
 {
  "input": "So let's take this one as an example and actually work it out. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 999.76,
  "end": 1003.22
 },
 {
  "input": "Go ahead, actually do it! ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1003.74,
  "end": 1004.94
 },
 {
  "input": "Let's pause and try putting together this block. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1005.22,
  "end": 1007.02
 },
 {
  "input": "Okay, you ready? ",
  "translatedText": "ลองหยุดและลองประกอบบล็อกนี้ดู โอเค คุณพร้อมหรือยัง? ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1012.72,
  "end": 1013.68
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1014.24,
  "end": 1023.32
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1025.34,
  "end": 1032.34
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1033.02,
  "end": 1037.88
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1039.16,
  "end": 1044.24
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1044.78,
  "end": 1050.06
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1051.3,
  "end": 1060.32
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1061.34,
  "end": 1068.14
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1068.82,
  "end": 1072.18
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1073.48,
  "end": 1079.78
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1080.02,
  "end": 1087.74
 },
 {
  "input": "So again, pause and try working it out. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1088.26,
  "end": 1090.81
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1098.79,
  "end": 1107.91
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1109.69,
  "end": 1117.03
 },
 {
  "input": "The third check is even, chopping down the possibilities even further. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1118.55,
  "end": 1121.79
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1122.65,
  "end": 1129.65
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1131.49,
  "end": 1137.53
 },
 {
  "input": "If it's three or more, all bets are off. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1138.07,
  "end": 1139.97
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1141.31,
  "end": 1154.39
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1155.71,
  "end": 1163.17
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1163.87,
  "end": 1178.75
 },
 {
  "input": "To see what I mean, come join me in part 2. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1179.43,
  "end": 1181.31
 }
]