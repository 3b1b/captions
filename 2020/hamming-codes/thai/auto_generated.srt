1
00:00:00,000 --> 00:00:03,120
ฉันเดาว่าทุกคนที่นี่มาจากภาค 1

2
00:00:03,120 --> 00:00:06,920
เรากำลังพูดถึงโค้ด Hamming ซึ่งเป็นวิธีในการสร้างบล็อกข้อมูลที่บิตส่วนใหญ่มีข้อความที่มีความหมาย

3
00:00:06,920 --> 00:00:11,640
ในขณะที่บิตอื่นๆ บางส่วนทำหน้าที่เป็นการซ้ำซ้อน ในลักษณะที่ว่าหากบิตใด

4
00:00:11,640 --> 00:00:15,800
ๆ พลิกกลับ

5
00:00:15,800 --> 00:00:20,560
ข้อความก็อาจเป็นข้อความหนึ่งก็ได้ บิตหรือบิตสำรอง อะไรก็ตามในบล็อกนี้

6
00:00:20,560 --> 00:00:21,920
ผู้รับจะสามารถระบุได้ว่ามีข้อผิดพลาด และวิธีการแก้ไข

7
00:00:21,920 --> 00:00:25,900
แนวคิดพื้นฐานที่นำเสนอคือวิธีใช้การตรวจสอบพาริตีหลายรายการเพื่อค้นหาแบบไบนารี่ไปจนถึงข้อผิดพลาด

8
00:00:25,900 --> 00:00:29,800


9
00:00:29,800 --> 00:00:33,920
ในวิดีโอนั้นเป้าหมายคือการทำให้โค้ด Hamming

10
00:00:33,920 --> 00:00:35,420
รู้สึกเหมือนได้ลงมือปฏิบัติจริงและสามารถค้นพบใหม่ได้มากที่สุดเท่าที่จะเป็นไปได้

11
00:00:35,420 --> 00:00:40,040
แต่เมื่อคุณเริ่มคิดถึงการนำสิ่งนี้ไปใช้จริง ทั้งในซอฟต์แวร์หรือฮาร์ดแวร์

12
00:00:40,040 --> 00:00:44,120
เฟรมนั้นอาจตอกย้ำว่าโค้ดเหล่านี้สวยงามเพียงใด

13
00:00:44,120 --> 00:00:47,620
คุณอาจคิดว่าคุณจำเป็นต้องเขียนอัลกอริทึมที่ติดตามตำแหน่งข้อผิดพลาดที่เป็นไปได้ทั้งหมด และลดกลุ่มนั้นลงครึ่งหนึ่งในการตรวจสอบแต่ละครั้ง

14
00:00:47,620 --> 00:00:52,320
แต่จริงๆ

15
00:00:52,320 --> 00:00:54,160
แล้วเป็นวิธีที่ง่ายกว่านั้นมาก

16
00:00:54,160 --> 00:00:58,720
หากคุณอ่านคำตอบของการตรวจสอบความเท่าเทียมกันทั้งสี่ครั้งที่เราทำในวิดีโอที่แล้ว ทั้งหมดเป็น 1 และ

17
00:00:58,760 --> 00:01:04,800
0 แทนที่จะเป็นใช่และไม่ใช่ มันจะสะกดตำแหน่งของข้อผิดพลาดในรูปแบบไบนารี่

18
00:01:04,800 --> 00:01:10,160
ตัวอย่างเช่น เลข 7 ในไบนารี่ดูเหมือน 0111 โดยพื้นฐานแล้วบอกว่ามันคือ

19
00:01:10,160 --> 00:01:12,640
4 บวก 2 บวก 1

20
00:01:12,640 --> 00:01:17,960
และสังเกตว่าตำแหน่งที่ 7 อยู่ที่ใด

21
00:01:17,960 --> 00:01:22,280
มันจะส่งผลต่อกลุ่มพาริตีกลุ่มแรกของเรา และกลุ่มที่สองและกลุ่มที่สาม แต่ไม่ใช่กลุ่มสุดท้าย

22
00:01:22,280 --> 00:01:26,560
ดังนั้นการอ่านผลการตรวจสอบทั้งสี่ครั้งจากล่างขึ้นบนจะช่วยระบุตำแหน่งของข้อผิดพลาดได้อย่างแน่นอน

23
00:01:26,560 --> 00:01:28,000


24
00:01:28,520 --> 00:01:32,240
ไม่มีอะไรพิเศษเกี่ยวกับตัวอย่างที่ 7

25
00:01:32,240 --> 00:01:37,440
ซึ่งใช้งานได้โดยทั่วไป และทำให้ตรรกะในการใช้โครงร่างทั้งหมดในฮาร์ดแวร์เป็นเรื่องง่ายอย่างน่าตกใจ

26
00:01:37,440 --> 00:01:43,380
ตอนนี้ หากคุณต้องการดูว่าเหตุใดเหตุการณ์มหัศจรรย์นี้จึงเกิดขึ้น ให้นำป้ายกำกับดัชนีทั้ง 16

27
00:01:43,380 --> 00:01:48,480
รายการสำหรับตำแหน่งของเรา แต่แทนที่จะเขียนเป็นฐาน 10 ให้เขียนทั้งหมดในรูปแบบไบนารี่

28
00:01:48,480 --> 00:01:50,720
โดยเริ่มจาก 0000 ถึง 1111

29
00:01:50,720 --> 00:01:55,880
ขณะที่เราใส่ป้ายกำกับไบนารี่เหล่านี้กลับเข้าไปในกล่อง

30
00:01:56,080 --> 00:01:58,440
ฉันขอย้ำว่าป้ายเหล่านี้แตกต่างจากข้อมูลที่ถูกส่งจริง

31
00:01:58,440 --> 00:02:02,200
สิ่งเหล่านี้เป็นเพียงป้ายกำกับแนวคิดที่จะช่วยให้คุณและฉันเข้าใจว่ากลุ่มความเท่าเทียมกันทั้งสี่มาจากไหน

32
00:02:02,200 --> 00:02:04,200


33
00:02:04,200 --> 00:02:08,840
ความสง่างามของการมีทุกสิ่งที่เรากำลังดูถูกอธิบายในรูปแบบไบนารี่อาจถูกลดทอนลงด้วยความสับสนของการมีทุกสิ่งที่เรากำลังดูถูกอธิบายในรูปแบบไบนารี

34
00:02:08,840 --> 00:02:13,160


35
00:02:13,160 --> 00:02:15,040
มันก็คุ้มค่านะ

36
00:02:15,040 --> 00:02:20,740
มุ่งความสนใจของคุณไปที่ส่วนสุดท้ายของป้ายกำกับเหล่านี้ทั้งหมด จากนั้นไฮไลต์ตำแหน่งที่บิตสุดท้ายคือ

37
00:02:20,740 --> 00:02:24,280
1

38
00:02:24,280 --> 00:02:28,800
สิ่งที่เราได้รับคือกลุ่มพาริตีกลุ่มแรกจากสี่กลุ่ม ซึ่งหมายความว่าคุณสามารถตีความการตรวจสอบครั้งแรกเป็นการถามว่า เฮ้

39
00:02:28,800 --> 00:02:34,480
หากมีข้อผิดพลาด บิตสุดท้ายในตำแหน่งของข้อผิดพลาดนั้นเป็น

40
00:02:34,480 --> 00:02:36,680
1 หรือไม่

41
00:02:36,680 --> 00:02:42,600
ในทำนองเดียวกัน หากคุณเน้นที่บิตที่สองถึงบิตสุดท้าย และเน้นตำแหน่งทั้งหมดที่เป็น

42
00:02:42,600 --> 00:02:47,040
1 คุณจะได้กลุ่มแพริตีที่สองจากแผนของเรา

43
00:02:47,040 --> 00:02:51,960
กล่าวอีกนัยหนึ่ง การตรวจสอบครั้งที่สองจะถามว่า เฮ้ ฉันอีกครั้ง

44
00:02:51,960 --> 00:02:56,160
หากมีข้อผิดพลาด บิตที่สองจากบิตสุดท้ายของตำแหน่งนั้นเป็น 1 หรือไม่

45
00:02:56,160 --> 00:02:57,160
และอื่นๆ

46
00:02:57,160 --> 00:03:03,320
การตรวจสอบพาริตี้ครั้งที่สามครอบคลุมทุกตำแหน่งที่เปิดบิตที่สามถึงสุดท้าย และการตรวจสอบสุดท้ายครอบคลุมแปดตำแหน่งสุดท้าย

47
00:03:03,320 --> 00:03:10,120
ซึ่งบิตลำดับสูงสุดคือ 1

48
00:03:10,120 --> 00:03:15,680
ทุกสิ่งที่เราทำก่อนหน้านี้เหมือนกับการตอบคำถามสี่ข้อนี้

49
00:03:15,680 --> 00:03:18,800
ซึ่งในทางกลับกันก็เหมือนกับการสะกดตำแหน่งในรูปแบบไบนารี่

50
00:03:19,800 --> 00:03:22,080
ฉันหวังว่านี่จะทำให้สองสิ่งชัดเจนขึ้น

51
00:03:22,080 --> 00:03:27,140
ประการแรกคือวิธีการสรุปอย่างเป็นระบบเกี่ยวกับขนาดบล็อกที่มีพลังมากกว่าสอง

52
00:03:27,140 --> 00:03:33,180
หากต้องใช้บิตมากกว่าในการอธิบายแต่ละตำแหน่ง เช่น หกบิตเพื่ออธิบาย

53
00:03:33,180 --> 00:03:38,640
64 จุด แต่ละบิตเหล่านั้นจะให้หนึ่งในกลุ่มพาริตีที่เราต้องตรวจสอบ

54
00:03:38,640 --> 00:03:42,060
บรรดาผู้ที่ดูปริศนากระดานหมากรุกที่ฉันทำกับแมตต์

55
00:03:42,060 --> 00:03:43,400
ปาร์กเกอร์อาจพบว่าทั้งหมดนี้คุ้นเคยอย่างยิ่ง

56
00:03:43,400 --> 00:03:48,200
มันเป็นตรรกะหลักเดียวกัน แต่แก้ปัญหาที่แตกต่าง และนำไปใช้กับกระดานหมากรุกขนาด

57
00:03:48,200 --> 00:03:49,880
64 สี่เหลี่ยม

58
00:03:49,880 --> 00:03:54,000
สิ่งที่สองที่ฉันหวังว่าสิ่งนี้จะทำให้ชัดเจนคือเหตุใดแพริตีบิตของเราจึงนั่งอยู่ในตำแหน่งที่เป็นกำลังของสอง เช่น 1, 2,

59
00:03:54,000 --> 00:03:58,320
4 และ 8

60
00:03:58,320 --> 00:04:03,640
ตำแหน่งเหล่านี้คือตำแหน่งที่การแสดงไบนารี่เปิดขึ้นเพียงเล็กน้อย

61
00:04:03,640 --> 00:04:09,000
นั่นหมายความว่าแต่ละแพริตีบิตเหล่านั้นอยู่ภายในกลุ่มพาริตีเพียงกลุ่มเดียวจากสี่กลุ่มเท่านั้น

62
00:04:09,000 --> 00:04:12,640


63
00:04:12,640 --> 00:04:16,840
คุณยังสามารถดูสิ่งนี้ได้ในตัวอย่างที่ใหญ่กว่า โดยไม่ว่าคุณจะได้ขนาดใหญ่แค่ไหน

64
00:04:16,840 --> 00:04:25,920
แต่ละบิตของพาริตีจะแตะเพียงกลุ่มใดกลุ่มหนึ่งได้อย่างสะดวก

65
00:04:25,920 --> 00:04:29,680
เมื่อคุณเข้าใจว่าการตรวจสอบความเท่าเทียมกันเหล่านี้ที่เราทุ่มเทเวลาส่วนใหญ่นั้นไม่มีอะไรมากไปกว่าวิธีที่ชาญฉลาดในการระบุตำแหน่งของข้อผิดพลาดในรูปแบบไบนารี่

66
00:04:29,680 --> 00:04:34,320
จากนั้นเราก็สามารถเชื่อมโยงด้วยวิธีคิดที่แตกต่างออกไปเกี่ยวกับการแฮมมิง

67
00:04:34,320 --> 00:04:37,880
รหัส

68
00:04:37,880 --> 00:04:42,160
ซึ่งอาจจะเรียบง่ายกว่าและสวยงามกว่ามาก

69
00:04:42,160 --> 00:04:43,880
และโดยทั่วไปแล้วสามารถเขียนลงไปได้ด้วยโค้ดเพียงบรรทัดเดียว

70
00:04:43,920 --> 00:04:46,200
มันขึ้นอยู่กับฟังก์ชัน XOR

71
00:04:46,200 --> 00:04:50,960
XOR สำหรับคนที่ไม่รู้จัก ย่อมาจาก Exclusive or

72
00:04:50,960 --> 00:04:55,440
เมื่อคุณรับ XOR ของสองบิต มันจะคืนค่า

73
00:04:55,440 --> 00:05:00,200
1 หากบิตใดบิตหนึ่งนั้นเปิดอยู่ แต่จะไม่ได้ถ้าทั้งสองเปิดหรือปิด

74
00:05:00,200 --> 00:05:03,760
หากใช้ถ้อยคำต่างกัน มันคือความเท่าเทียมกันของสองบิตนี้

75
00:05:03,760 --> 00:05:07,840
ในฐานะคนคณิต ฉันชอบคิดว่ามันเป็นการบวก mod 2

76
00:05:07,840 --> 00:05:12,000
โดยทั่วไปเรายังพูดถึง XOR

77
00:05:12,040 --> 00:05:14,040
ของสตริงบิตที่แตกต่างกันสองตัว ซึ่งโดยพื้นฐานแล้วจะทำส่วนประกอบนี้ทีละส่วนประกอบ

78
00:05:14,040 --> 00:05:16,280
มันเหมือนกับการเติม แต่ที่คุณไม่เคยพกติดตัว

79
00:05:16,280 --> 00:05:21,240
ขอย้ำอีกครั้งว่ายิ่งมีความโน้มเอียงทางคณิตศาสตร์มากขึ้นอาจชอบคิดว่านี่เป็นการเพิ่มเวกเตอร์สองตัวและลด mod

80
00:05:21,240 --> 00:05:23,520
2

81
00:05:23,520 --> 00:05:28,720
หากคุณเปิด Python ขึ้นมาตอนนี้และใช้การดำเนินการเครื่องหมายรูปหมวกระหว่างจำนวนเต็มสองตัว

82
00:05:28,720 --> 00:05:35,400
นี่คือสิ่งที่มันกำลังทำอยู่ ยกเว้นการแสดงบิตของตัวเลขเหล่านั้นภายใต้ประทุน

83
00:05:35,400 --> 00:05:40,920
ประเด็นสำคัญสำหรับคุณและฉันคือการรับ XOR

84
00:05:40,960 --> 00:05:45,960
ของสตริงบิตต่างๆ มากมายเป็นวิธีที่มีประสิทธิภาพในการคำนวณการล้อเลียนกลุ่มกลุ่มที่แยกจากกัน

85
00:05:45,960 --> 00:05:51,320
เช่นเดียวกับคอลัมน์ ทั้งหมดในคราวเดียว

86
00:05:51,320 --> 00:05:54,520
สิ่งนี้ทำให้เรามีวิธีที่ค่อนข้างเก๋ในการคิดเกี่ยวกับการตรวจสอบพาริตีหลายรายการจากอัลกอริธึมโค้ด Hamming

87
00:05:54,520 --> 00:05:59,680
ของเรา โดยที่ทั้งหมดนี้ถูกรวมเข้าด้วยกันเป็นการดำเนินการเดียว

88
00:05:59,680 --> 00:06:02,800
แม้ว่ามองแวบแรกจะดูแตกต่างออกไปมากก็ตาม

89
00:06:02,800 --> 00:06:08,360
เขียนตำแหน่งทั้ง 16 ตำแหน่งในรูปแบบไบนารี่อย่างที่เราเคยมีมาก่อน

90
00:06:08,640 --> 00:06:14,800
และตอนนี้เน้นตำแหน่งที่บิตข้อความเปิดเป็น 1

91
00:06:14,800 --> 00:06:19,400
จากนั้นรวบรวมตำแหน่งเหล่านี้เป็นคอลัมน์ขนาดใหญ่คอลัมน์เดียวแล้วรับ XOR

92
00:06:19,400 --> 00:06:23,480
คุณอาจเดาได้ว่าผลลัพธ์ 4 บิตที่อยู่ด้านล่างนั้นเหมือนกับการตรวจสอบความเท่าเทียมกัน

93
00:06:23,480 --> 00:06:27,480
4 รายการที่เรารู้จักและชื่นชอบ

94
00:06:27,480 --> 00:06:32,720
แต่ใช้เวลาสักครู่เพื่อคิดจริงๆ ว่าเหตุใดจึงเป็นเช่นนั้น

95
00:06:32,720 --> 00:06:37,880
ตัวอย่างเช่น คอลัมน์สุดท้ายนี้

96
00:06:38,400 --> 00:06:42,400
กำลังนับตำแหน่งทั้งหมดที่มีบิตสุดท้ายเป็น 1

97
00:06:42,400 --> 00:06:45,960
แต่เราจำกัดไว้เฉพาะตำแหน่งที่ไฮไลต์อยู่แล้ว ดังนั้นจึงเป็นการนับอย่างมีประสิทธิภาพว่าตำแหน่งที่ไฮไลต์กี่ตำแหน่งมาจากกลุ่มแพริตีกลุ่มแรก

98
00:06:45,960 --> 00:06:48,520
นั่นสมเหตุสมผลไหม?

99
00:06:48,520 --> 00:06:53,600
ในทำนองเดียวกัน คอลัมน์ถัดไปจะนับจำนวนตำแหน่งที่อยู่ในกลุ่มพาริตีที่สอง

100
00:06:53,600 --> 00:06:59,640
ตำแหน่งที่บิตที่สองถึงสุดท้ายคือ 1

101
00:06:59,640 --> 00:07:00,640
และตำแหน่งที่ถูกไฮไลต์ด้วย และอื่นๆ

102
00:07:00,640 --> 00:07:06,640
มันเป็นเพียงการเปลี่ยนแปลงเล็กๆ น้อยๆ ในมุมมองต่อสิ่งเดียวกันที่เราทำอยู่

103
00:07:07,640 --> 00:07:10,000
แล้วคุณจะรู้ว่ามันไปจากที่นี่ที่ไหน

104
00:07:10,000 --> 00:07:14,400
ผู้ส่งมีหน้าที่รับผิดชอบในการสลับบิตพาริตีพิเศษบางส่วนเพื่อให้แน่ใจว่าผลรวมจะเป็น

105
00:07:14,400 --> 00:07:19,640
0000

106
00:07:19,640 --> 00:07:23,600
ตอนนี้เมื่อเรามีแบบนี้แล้ว

107
00:07:23,600 --> 00:07:28,720
นี่ทำให้เรามีวิธีที่ดีที่จะคิดว่าเหตุใดผลลัพธ์สี่บิตที่อยู่ด้านล่างจึงสะกดตำแหน่งของข้อผิดพลาดได้โดยตรง

108
00:07:28,720 --> 00:07:32,680
สมมติว่าบางส่วนในบล็อกนี้มีการสลับจาก 0 เป็น 1

109
00:07:32,720 --> 00:07:37,320
ความหมายก็คือตอนนี้ตำแหน่งของบิตนั้นจะถูกรวมไว้ใน XOR ทั้งหมด

110
00:07:37,320 --> 00:07:42,960
ซึ่งเปลี่ยนผลรวมจาก 0

111
00:07:42,960 --> 00:07:44,800
เป็นค่าที่รวมใหม่แทน ซึ่งเป็นตำแหน่งของข้อผิดพลาด

112
00:07:44,800 --> 00:07:48,800
เห็นได้ชัดว่าน้อยกว่าเล็กน้อย กรณีเดียวกันนี้จะเกิดขึ้นหากมีข้อผิดพลาดที่เปลี่ยน 1

113
00:07:48,800 --> 00:07:49,800
เป็น 0

114
00:07:49,800 --> 00:07:54,720
คุณจะเห็นว่า ถ้าคุณบวกสตริงบิตเข้าด้วยกันสองครั้ง มันก็เหมือนกับการไม่มีมันเลย โดยพื้นฐานแล้ว เพราะในโลกนี้

115
00:07:54,720 --> 00:07:59,000
1 บวก 1 เท่ากับ 0

116
00:07:59,000 --> 00:08:03,720
ดังนั้นการเพิ่มสำเนาของตำแหน่งนี้เข้ากับผลรวมทั้งหมดจะมีผลเช่นเดียวกับที่เรากำลังย้ายตำแหน่ง

117
00:08:03,720 --> 00:08:05,400


118
00:08:05,400 --> 00:08:10,080
และผลกระทบนั้นอีกครั้ง ก็คือผลลัพธ์รวมที่อยู่ด้านล่างสุดนี้

119
00:08:10,080 --> 00:08:13,480
ระบุตำแหน่งของข้อผิดพลาด

120
00:08:13,480 --> 00:08:17,720
เพื่อแสดงให้เห็นว่าสิ่งนี้สวยงามเพียงใด ฉันขอแสดงโค้ด Python

121
00:08:17,720 --> 00:08:22,120
หนึ่งบรรทัดที่ฉันอ้างถึงก่อนหน้านี้ ซึ่งจะรวบรวมตรรกะเกือบทั้งหมดในส่วนท้ายของผู้รับ

122
00:08:22,120 --> 00:08:27,160
เราจะเริ่มต้นด้วยการสร้างอาร์เรย์สุ่ม 16 1 วินาทีและ

123
00:08:27,160 --> 00:08:31,160
0 เพื่อจำลองบล็อกข้อมูล และฉันจะตั้งชื่อบิตให้กับมัน แต่แน่นอนว่าในทางปฏิบัติ

124
00:08:31,160 --> 00:08:36,160
นี่จะเป็นสิ่งที่เราได้รับจากผู้ส่ง และแทนที่จะเป็น ถ้าสุ่มก็จะบรรทุกข้อมูล 11

125
00:08:36,160 --> 00:08:38,600
บิตพร้อมกับพาริตีบิต 5 บิต

126
00:08:38,600 --> 00:08:43,160
ถ้าฉันเรียกใช้ฟังก์ชัน enumerateBits สิ่งที่มันทำคือจับคู่แต่ละบิตเหล่านั้นกับดัชนีที่สอดคล้องกัน ในกรณีนี้คือทำงานตั้งแต่

127
00:08:43,160 --> 00:08:48,240
0 ถึง 15

128
00:08:48,240 --> 00:08:53,200
ดังนั้นหากเราสร้างรายการที่วนซ้ำคู่เหล่านี้ทั้งหมด คู่ที่ดูเหมือน i แล้วเราดึงเฉพาะค่า i

129
00:08:53,200 --> 00:08:59,160
ออกมา แค่ดัชนี มันไม่น่าตื่นเต้นขนาดนั้น เราแค่นำดัชนีเหล่านั้นกลับมา

130
00:08:59,160 --> 00:09:01,920
0 ถึง 15 .

131
00:09:01,920 --> 00:09:07,520
แต่ถ้าเราเพิ่มเงื่อนไขให้ทำสิ่งนี้เฉพาะ if bit ซึ่งหมายความว่าถ้าบิตนั้นเป็น

132
00:09:07,520 --> 00:09:13,400
1 ไม่ใช่ 0 มันก็จะดึงเฉพาะตำแหน่งที่เปิดบิตที่เกี่ยวข้องออกมาเท่านั้น

133
00:09:13,400 --> 00:09:20,320
ในกรณีนี้ ดูเหมือนว่าตำแหน่งเหล่านั้นคือ 0, 4, 6, 9 เป็นต้น

134
00:09:20,720 --> 00:09:24,640
สิ่งที่เราต้องการคือการรวบรวมตำแหน่งทั้งหมดเหล่านั้น ตำแหน่งของบิตที่เปิดอยู่ จากนั้น

135
00:09:24,640 --> 00:09:29,960
XOR เข้าด้วยกัน

136
00:09:29,960 --> 00:09:33,960
หากต้องการทำสิ่งนี้ใน Python ก่อนอื่นให้ฉันนำเข้าฟังก์ชันที่เป็นประโยชน์สองสามรายการก่อน

137
00:09:33,960 --> 00:09:39,140
ด้วยวิธีนี้เราสามารถเรียกย่อ () ในรายการนี้ และใช้ฟังก์ชัน XOR เพื่อลดค่านั้น

138
00:09:39,140 --> 00:09:44,840
โดยพื้นฐานแล้วสิ่งนี้จะกินทางผ่านรายการโดยนำ XOR ไปพร้อมกัน

139
00:09:44,840 --> 00:09:48,760
หากต้องการ คุณสามารถเขียนฟังก์ชัน

140
00:09:48,800 --> 00:09:52,200
XOR นั้นอย่างชัดเจนโดยไม่ต้องนำเข้าจากที่ใดก็ได้

141
00:09:52,200 --> 00:09:56,880
ดังนั้นในขณะนี้ ดูเหมือนว่าถ้าเราทำเช่นนี้กับบล็อกสุ่มของเราที่มีขนาด 16 บิต

142
00:09:56,880 --> 00:10:02,080
มันจะคืนค่า 9 ซึ่งมีเลขฐานสองแทน 1001

143
00:10:02,080 --> 00:10:05,960
เราจะไม่ทำที่นี่ แต่คุณสามารถเขียนฟังก์ชันที่ผู้ส่งใช้การแทนค่าไบนารีนั้นเพื่อตั้งค่าบิตพาริตีทั้งสี่ตามต้องการ

144
00:10:05,960 --> 00:10:11,560
ในท้ายที่สุดทำให้บล็อกนี้อยู่ในสถานะที่รันโค้ดบรรทัดนี้ในรายการบิตทั้งหมดส่งคืน

145
00:10:11,560 --> 00:10:16,200
0

146
00:10:17,200 --> 00:10:20,200
นี่ถือเป็นบล็อกที่เตรียมไว้อย่างดี

147
00:10:20,200 --> 00:10:24,640
สิ่งที่ยอดเยี่ยมก็คือหากเราสลับบิตใดบิตหนึ่งในรายการนี้ จำลองข้อผิดพลาดแบบสุ่มจากสัญญาณรบกวน

148
00:10:24,640 --> 00:10:30,600
จากนั้นหากคุณเรียกใช้โค้ดบรรทัดเดียวกัน มันจะพิมพ์ข้อผิดพลาดนั้นออกมา

149
00:10:30,600 --> 00:10:31,920
นั่นไม่เรียบร้อยเหรอ?

150
00:10:31,920 --> 00:10:37,200
คุณสามารถดึงบล็อกนี้ขึ้นมาใหม่ รันบรรทัดเดียวบนบล็อกนั้น และมันจะแยกตำแหน่งของข้อผิดพลาดออกโดยอัตโนมัติ

151
00:10:37,200 --> 00:10:42,920
หรือจะเป็น 0 หากไม่มีเลย

152
00:10:42,920 --> 00:10:45,520
และไม่มีอะไรพิเศษเกี่ยวกับไซส์ 16 ที่นี่

153
00:10:45,520 --> 00:10:52,280
โค้ดบรรทัดเดียวกันนี้จะใช้ได้ถ้าคุณมีรายการ เช่น 256 บิต

154
00:10:52,280 --> 00:10:56,280
ไม่จำเป็นต้องพูดว่า มีโค้ดให้เขียนมากกว่านี้ เช่น

155
00:10:56,280 --> 00:11:01,440
การตรวจสอบเมตาพาริตี้เพื่อตรวจจับข้อผิดพลาด 2 บิต

156
00:11:01,440 --> 00:11:05,080
แต่แนวคิดก็คือตรรกะหลักเกือบทั้งหมดจากโครงการของเราลดลงเหลือเพียงการลด XOR เพียงครั้งเดียว

157
00:11:05,080 --> 00:11:10,600
ตอนนี้ ขึ้นอยู่กับความสะดวกสบายของคุณกับไบนารี่และ XOR

158
00:11:10,600 --> 00:11:15,880
และซอฟต์แวร์โดยทั่วไป คุณอาจพบว่ามุมมองนี้สับสนเล็กน้อย

159
00:11:15,880 --> 00:11:19,320
หรือหรูหราและเรียบง่ายกว่านั้นมากจนคุณสงสัยว่าทำไมเราไม่เพียงแค่เริ่มต้นจากจุดเริ่มต้น -ไป.

160
00:11:19,320 --> 00:11:22,880
พูดง่ายๆ ก็คือ มุมมองการตรวจสอบความเท่าเทียมกันหลายรายการจะคิดได้ง่ายกว่าเมื่อใช้โค้ด

161
00:11:22,880 --> 00:11:27,560
Hamming ในฮาร์ดแวร์โดยตรง และมุมมอง

162
00:11:27,560 --> 00:11:31,380
XOR นั้นคิดได้ง่ายที่สุดเมื่อทำในซอฟต์แวร์จากระดับที่สูงกว่า

163
00:11:31,380 --> 00:11:35,640
วิธีแรกนั้นง่ายที่สุดที่ทำด้วยมือจริง ๆ

164
00:11:35,640 --> 00:11:40,720
และฉันคิดว่ามันจะทำงานได้ดีกว่าโดยปลูกฝังสัญชาตญาณหลักที่เป็นรากฐานทั้งหมดนี้

165
00:11:40,720 --> 00:11:46,840
ซึ่งก็คือข้อมูลที่จำเป็นต้องใช้ในการค้นหาข้อผิดพลาดเดียวนั้นเกี่ยวข้องกับบันทึกขนาดของบล็อก หรืออีกนัยหนึ่ง

166
00:11:46,840 --> 00:11:51,020
มันจะขยายทีละบิตเมื่อขนาดบล็อกเพิ่มขึ้นสองเท่า

167
00:11:51,020 --> 00:11:55,440
ข้อเท็จจริงที่เกี่ยวข้องในที่นี้คือข้อมูลนั้นสอดคล้องโดยตรงกับปริมาณความซ้ำซ้อนที่เราต้องการ

168
00:11:55,440 --> 00:11:56,440


169
00:11:56,440 --> 00:12:00,320
นั่นคือสิ่งที่ขัดแย้งกับปฏิกิริยากระตุกเข่าของคนส่วนใหญ่เมื่อพวกเขาคิดถึงการสร้างข้อความที่ยืดหยุ่นต่อข้อผิดพลาด

170
00:12:00,320 --> 00:12:05,280
ซึ่งโดยปกติแล้วการคัดลอกข้อความทั้งหมดถือเป็นสัญชาตญาณแรกที่เข้ามาในใจ

171
00:12:05,280 --> 00:12:07,520


172
00:12:07,520 --> 00:12:11,120
แล้ว ยังมีอีกวิธีหนึ่ง

173
00:12:11,120 --> 00:12:14,800
ที่บางครั้งคุณจะเห็นโค้ดแฮมมิงนำเสนอ โดยคุณคูณข้อความด้วยเมทริกซ์ขนาดใหญ่ตัวเดียว

174
00:12:14,800 --> 00:12:18,580
เป็นเรื่องดีเพราะมันเกี่ยวข้องกับกลุ่มโค้ดเชิงเส้นที่กว้างกว่า

175
00:12:18,580 --> 00:12:25,160
แต่ฉันคิดว่านั่นแทบไม่ได้ให้สัญชาตญาณเลยว่ามันมาจากไหนหรือปรับขนาดอย่างไร

176
00:12:25,160 --> 00:12:29,340
และเมื่อพูดถึงการปรับขนาด

177
00:12:29,340 --> 00:12:32,200
คุณอาจสังเกตเห็นว่าประสิทธิภาพของโครงร่างนี้จะดีขึ้นเมื่อเราเพิ่มขนาดบล็อกเท่านั้น

178
00:12:32,200 --> 00:12:40,560
ตัวอย่างเช่น เราเห็นว่าด้วย 256 บิต คุณใช้พื้นที่เพียง

179
00:12:40,560 --> 00:12:43,480
3% ของพื้นที่นั้นในการสำรอง และมันจะดีขึ้นเรื่อยๆ จากจุดนั้น

180
00:12:43,480 --> 00:12:49,040
เมื่อจำนวนบิตพาริตีเพิ่มขึ้นทีละบิต ขนาดบล็อกก็จะเพิ่มขึ้นเป็นสองเท่า

181
00:12:49,040 --> 00:12:53,840
และถ้าคุณใช้มันสุดโต่ง คุณสามารถมีบล็อกที่มีหนึ่งล้านบิต ซึ่งคุณคงจะเล่นคำถาม

182
00:12:53,840 --> 00:12:58,800
20 ข้อกับการตรวจสอบพาริตีของคุณ และมันใช้เพียง

183
00:12:58,800 --> 00:13:00,800
21 พาริตีบิตเท่านั้น

184
00:13:00,800 --> 00:13:05,760
และถ้าคุณย้อนกลับไปคิดถึงการดูล้านบิตและค้นหาข้อผิดพลาดเพียงจุดเดียว

185
00:13:05,760 --> 00:13:08,640
นั่นคงรู้สึกบ้าไปแล้วจริงๆ

186
00:13:08,640 --> 00:13:12,680
แน่นอนว่าปัญหาก็คือ เมื่อมีบล็อกขนาดใหญ่ ความน่าจะเป็นที่จะเห็นข้อผิดพลาดมากกว่าหนึ่งหรือสองบิตก็จะเพิ่มขึ้น

187
00:13:12,680 --> 00:13:18,360
และโค้ด Hamming ก็ไม่สามารถจัดการอะไรนอกเหนือจากนั้นได้

188
00:13:18,360 --> 00:13:22,020
ในทางปฏิบัติ สิ่งที่คุณต้องการคือการหาขนาดที่เหมาะสม

189
00:13:22,020 --> 00:13:25,520
เพื่อไม่ให้ความน่าจะเป็นที่จะพลิกบิตมากเกินไป

190
00:13:26,520 --> 00:13:30,920
นอกจากนี้ ในทางปฏิบัติ ข้อผิดพลาดมักจะเกิดขึ้นเป็นชุดเล็กๆ น้อยๆ

191
00:13:30,920 --> 00:13:35,680
ซึ่งจะทำให้บล็อกเดียวเสียหายโดยสิ้นเชิง ดังนั้นกลวิธีทั่วไปประการหนึ่งที่จะช่วยกระจายข้อผิดพลาดแบบต่อเนื่องไปยังบล็อกต่างๆ มากมายคือการสอดประสานบล็อกเหล่านั้น

192
00:13:35,680 --> 00:13:41,720
เช่นนี้ ก่อนที่จะ ส่งหรือเก็บไว้

193
00:13:45,480 --> 00:13:49,920
อีกครั้ง สิ่งเหล่านี้ส่วนใหญ่ถูกโต้แย้งอย่างสมบูรณ์ด้วยโค้ดที่ทันสมัยกว่า เช่น อัลกอริธึม

194
00:13:49,920 --> 00:13:55,060
Reed-Solomon ที่ใช้กันทั่วไปมากกว่า ซึ่งจัดการข้อผิดพลาดแบบ Burst

195
00:13:55,100 --> 00:13:59,580
ได้ดีเป็นพิเศษ และสามารถปรับให้มีความยืดหยุ่นต่อจำนวนข้อผิดพลาดที่มากขึ้นต่อบล็อก .

196
00:13:59,580 --> 00:14:03,000
แต่นั่นเป็นหัวข้อสำหรับอีกครั้ง

197
00:14:03,000 --> 00:14:07,660
ในหนังสือของเขา The Art of Doing

198
00:14:07,660 --> 00:14:10,700
Science and Engineering แฮมมิงเปิดเผยอย่างตรงไปตรงมาว่าการค้นพบรหัสนี้คดเคี้ยวเพียงใด

199
00:14:10,700 --> 00:14:15,180
ขั้นแรกเขาลองใช้แผนงานต่างๆ

200
00:14:15,180 --> 00:14:18,420
มากมายที่เกี่ยวข้องกับการจัดชิ้นส่วนให้เป็นส่วนหนึ่งของโครงตาข่ายมิติที่สูงกว่าและสิ่งแปลกประหลาดเช่นนี้

201
00:14:18,420 --> 00:14:22,520
ความคิดที่ว่าอาจเป็นไปได้ที่จะได้รับการตรวจสอบความเท่าเทียมกันเพื่อสมรู้ร่วมคิดในลักษณะที่สะกดตำแหน่งของข้อผิดพลาดเท่านั้นที่มาถึงแฮมมิงเมื่อเขาก้าวถอยหลังหลังจากการวิเคราะห์อื่น

202
00:14:22,520 --> 00:14:26,360
ๆ

203
00:14:26,360 --> 00:14:30,800
มากมายและถามว่าโอเคอะไรคือสิ่งที่มีประสิทธิภาพมากที่สุดที่ฉันสามารถทำได้

204
00:14:30,800 --> 00:14:32,860
คงจะเกี่ยวกับเรื่องนี้ใช่ไหม?

205
00:14:32,860 --> 00:14:36,760
นอกจากนี้ เขายังพูดอย่างตรงไปตรงมาเกี่ยวกับความสำคัญของการตรวจสอบความเท่าเทียมกันที่อยู่ในใจของเขาอยู่แล้ว ซึ่งจะเป็นเรื่องธรรมดาน้อยกว่าในทศวรรษที่

206
00:14:36,760 --> 00:14:42,040
1940 กว่าที่เป็นอยู่ทุกวันนี้

207
00:14:42,040 --> 00:14:46,040
มีประมาณครึ่งโหลในหนังสือเล่มนี้ที่เขาอ้างอิงถึงคำพูดของหลุยส์ ปาสเตอร์

208
00:14:46,040 --> 00:14:49,640
โชคช่วยให้จิตใจเตรียมพร้อม

209
00:14:49,640 --> 00:14:55,120
แนวคิดที่ชาญฉลาดมักจะดูเรียบง่ายเมื่อมองย้อนกลับไป ซึ่งทำให้ง่ายต่อการถูกประเมินค่าต่ำไป

210
00:14:55,120 --> 00:14:59,680
ตอนนี้ความหวังที่แท้จริงของฉันคือรหัส Hamming

211
00:14:59,680 --> 00:15:01,820
หรืออย่างน้อยความเป็นไปได้ของรหัสดังกล่าว ให้ความรู้สึกที่เกือบจะชัดเจนสำหรับคุณ

212
00:15:01,820 --> 00:15:05,440
แต่คุณไม่ควรหลอกตัวเองให้คิดว่ามันชัดเจนจริงๆ

213
00:15:05,440 --> 00:15:08,000
เพราะมันไม่ได้เป็นเช่นนั้นอย่างแน่นอน

214
00:15:08,000 --> 00:15:12,080
เหตุผลส่วนหนึ่งที่ทำให้แนวคิดที่ชาญฉลาดดูง่ายอย่างหลอกลวงก็คือ เราเคยเห็นแต่ผลลัพธ์สุดท้ายเท่านั้น

215
00:15:12,080 --> 00:15:17,360
ทำความสะอาดสิ่งที่ยุ่งเหยิง

216
00:15:17,360 --> 00:15:22,400
ไม่เคยพูดถึงการเลี้ยวผิดทั้งหมด เน้นย้ำว่าพื้นที่แห่งความเป็นไปได้ที่สำรวจได้กว้างใหญ่นั้นอยู่ที่จุดเริ่มต้นของปัญหา

217
00:15:22,400 --> 00:15:23,980
กระบวนการแก้ปัญหาทั้งหมดนั้น

218
00:15:23,980 --> 00:15:25,280
แต่นี่เป็นเรื่องจริงโดยทั่วไป

219
00:15:25,280 --> 00:15:29,880
ฉันคิดว่าสำหรับสิ่งประดิษฐ์พิเศษบางอย่าง มีเหตุผลประการที่สองที่ลึกซึ้งกว่านั้น

220
00:15:29,880 --> 00:15:31,040
ที่ทำให้เราไม่เห็นค่าสิ่งประดิษฐ์เหล่านั้น

221
00:15:31,040 --> 00:15:35,040
การคิดข้อมูลในรูปของบิตได้รวมตัวกันจนกลายเป็นทฤษฎีที่สมบูรณ์ภายในปี 1948 โดยมีรายงานสำคัญของ

222
00:15:35,040 --> 00:15:39,400
Claude Shannon เกี่ยวกับทฤษฎีสารสนเทศ

223
00:15:39,400 --> 00:15:43,400
สิ่งนี้เกิดขึ้นพร้อมกันกับตอนที่ Hamming พัฒนาอัลกอริทึมของเขา

224
00:15:43,440 --> 00:15:47,300
นี่เป็นรายงานพื้นฐานแบบเดียวกับที่แสดงให้เห็นในแง่หนึ่งว่าการแก้ไขข้อผิดพลาดที่มีประสิทธิภาพนั้นเป็นไปได้เสมอ

225
00:15:47,300 --> 00:15:52,080
ไม่ว่าความน่าจะเป็นของการพลิกบิตจะสูงแค่ไหน

226
00:15:52,080 --> 00:15:53,920
อย่างน้อยก็ในทางทฤษฎี

227
00:15:53,920 --> 00:15:58,120
อย่างไรก็ตาม Shannon และ Hamming ต่างก็ใช้สำนักงานร่วมกันใน

228
00:15:58,120 --> 00:16:02,400
Bell Labs แม้ว่าจะทำงานในหลายๆ เรื่องที่แตกต่างกันมาก ซึ่งแทบจะไม่ใช่เรื่องบังเอิญที่นี่เลย

229
00:16:02,400 --> 00:16:06,960
ก้าวไปข้างหน้าอย่างรวดเร็วหลายทศวรรษ และทุกวันนี้ พวกเราหลายคนหมกมุ่นอยู่กับการคิดถึงเรื่องเล็กๆ

230
00:16:06,960 --> 00:16:13,080
น้อยๆ และข้อมูลจนมองข้ามได้ง่ายว่าวิธีคิดนี้มีความแตกต่างกันเพียงใด

231
00:16:13,080 --> 00:16:17,920
น่าแปลกที่ความคิดที่หล่อหลอมวิธีที่คนรุ่นอนาคตคิดอย่างลึกซึ้งที่สุด

232
00:16:17,920 --> 00:16:22,640
กลับกลายเป็นการมองว่าคนรุ่นอนาคตนั้นเรียบง่ายกว่าที่เป็นจริง

