[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing? ",
  "translatedText": "CD や DVD に傷を付けても、保存されている ものを再生できる方法を考えたことはありますか? ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.62,
  "end": 10.1
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors. ",
  "translatedText": "スクラッチはディスク上の 1 と 0 に実際に影響を与えるため、保存されてい たものとは異なるデータを読み取りますが、実際にスクラッチが発生しない限り、読 み取られたビットは、エンコードされたファイルとまったく同じファイルにデコード されます。それらすべてのエラーにもかかわらず、ビットごとにコピーしました。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 10.9,
  "end": 27.44
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors. ",
  "translatedText": "エラーに強い方法でデータを保存すること、そして同様に重要なことに 、データを送信することを可能にする数学的賢さは山ほどあります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 27.44,
  "end": 36.66
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this. ",
  "translatedText": "そうですね、実際、これを行う方法を思いつ くのに、それほど賢さは必要ありません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 37.52,
  "end": 41.6
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s. ",
  "translatedText": "ビデオ、サウンド、テキスト、コード、画像など、あらゆる ファイルは、最終的には 1 と 0 のシーケンスです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 42.06,
  "end": 50.38
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit. ",
  "translatedText": "反転したビットを修正するための簡単な戦略は、 各ビットのコピーを 3 つ保存することです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 50.68,
  "end": 56.0
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy. ",
  "translatedText": "次に、このファイルを読み取るマシンは、これら 3 つのコピーを比較 し、矛盾がある場合は常に 3 つのうち最良の 2 つを選択します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 57.58,
  "end": 64.06
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy. ",
  "translatedText": "しかし、これが意味するのは、スペースの 3 分の 2 を冗長性のために使用することです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 67.16,
  "end": 70.86
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped. ",
  "translatedText": "そして、それでも、そのスペースがすべて放棄されたにもかかわらず、複数の ビットが反転された場合に何が起こるかについて強力な保証はありません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 71.48,
  "end": 77.24
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible. ",
  "translatedText": "さらに興味深い問題は、スペースをできるだけ少なくしながらエラ ーを修正できるようにするにはどうすればよいかということです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 77.98,
  "end": 84.02
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9! ",
  "translatedText": "たとえば、このビデオで説明する方法を使用すると、データを 256 ビット ブロックに保 存できます。各ブロックは 9 ビットを使用します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 84.52,
  "end": 93.36
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want. ",
  "translatedText": "ある種の冗長性として機能し、残り の 247 ビットは、必要な意味のあるメッセージやデータを自由に伝送できます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 93.76,
  "end": 100.3
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it. ",
  "translatedText": "そして、ここでビットが反転した場合でも、このブロックだけを見る だけで、マシンはエラーがあったことと、エラーがどこにあったか を正確に特定できるため、それを修正する方法がわかります。。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 100.9,
  "end": 112.66
 },
 {
  "input": "And honestly, that feels like magic. ",
  "translatedText": "正直に言うと、それは魔法のように感じます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 112.66,
  "end": 114.62
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them. ",
  "translatedText": "そして、この特定のスキームでは、2 つのビットが反転された場合、マシンは少なくとも 2 つのエラーがあったことを検出できますが、それらを修正する方法はわかりません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 115.44,
  "end": 122.86
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes. ",
  "translatedText": "さまざまなサイズのブロックに対してこれがどのように拡張されるかについては、後で少し説明します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 123.52,
  "end": 126.9
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes. ",
  "translatedText": "このようなエラーを修正できる方法は、エラ ー修正コードとして十分に知られています。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 127.86,
  "end": 132.9
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day. ",
  "translatedText": "過去 1 世紀の大部分において、この分野は驚くほど奥深い数学の実に豊 富な情報源であり、私たちが毎日使用するデバイスに組み込まれています。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.66,
  "end": 141.94
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code. ",
  "translatedText": "ここでの目標は、ハミング コードとして知られる最 も初期の例の 1 つを徹底的に理解することです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 142.84,
  "end": 148.66
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there. ",
  "translatedText": "ちなみに、このビデオの構成について私が考えているのは、で きるだけ直接説明するというよりも、ところどころに少し優 しい指導を加えながら、自分で考え出すよう促すことです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 149.52,
  "end": 159.82
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you. ",
  "translatedText": "したがって、ある時点でどうなるか分かったと感じたら、その瞬間を一時停 止し、私が言う前に計画がどのようになるかを積極的に予測してください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 160.12,
  "end": 166.72
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying. ",
  "translatedText": "また、ハードウェア レベルまで理解してもらいたい場合は、Ben Eat er がこのビデオと併せて、実際にブレッドボードにハミング コードを実 装する方法を示すビデオを作成しました。これは非常に満足のいくものです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 167.24,
  "end": 178.24
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming. ",
  "translatedText": "ハミング コードは、リード ソロモン アルゴリズムのような最新のコードほど広く使用されていないことを 知っておく必要があります。しかし、このタスクが最初はいかに不可能に感じられるか、そして一度は完全に 合理的であるように見えるというコントラストには、ある種の魔法があります。ハミングについて学びます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 179.3,
  "end": 193.0
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages. ",
  "translatedText": "エラー修正の基本原理は、考えられるすべてのメッセージの膨大な空間の中で 、一部のサブセットのみが有効なメッセージとみなされるということです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 193.72,
  "end": 202.18
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words. ",
  "translatedText": "例えとして、正しく綴られた単語と間違って綴られた単語について考えてみましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.8,
  "end": 206.94
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo. ",
  "translatedText": "有効なメッセージが変更されるたびに、受信者は、タイプミスの場合と同様に、 表示された内容を最も近い有効な隣接メッセージに修正する責任があります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 208.9,
  "end": 217.34
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness. ",
  "translatedText": "ただし、このようなメッセージを効率的に分類するための具体的 なアルゴリズムを考え出すには、ある程度の賢さが必要です。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.22,
  "end": 224.06
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to. ",
  "translatedText": "物語は 1940 年代に始まります。当時、若いリチャード・ハミングはベル 研究所で働いていました。彼の仕事の一部には、アクセスが制限されていた非 常に大型で高価なパンチカード コンピューターの使用が含まれていました。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 226.78,
  "end": 237.42
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread. ",
  "translatedText": "そして、彼がやり続けたプログラムは失敗し続けました 。なぜなら、時折、少し読み間違えられるからです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 237.8,
  "end": 242.4
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code. ",
  "translatedText": "欲求不満は発明の坩堝であるため、彼はうんざ りして世界初の誤り訂正符号を発明しました。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.12,
  "end": 248.42
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them. ",
  "translatedText": "ハミング コードを組み立てるにはさまざまな方法がありますが、最 初のパスとして、ハミング自身が考えた方法を試してみましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 249.06,
  "end": 255.38
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits. ",
  "translatedText": "シンプルではありますが、単純すぎない 16 ビットのブロックの例を使用してみましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 256.52,
  "end": 260.94
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15. ",
  "translatedText": "これらのビットの位置に 0 から 15 までの番号を付けます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 261.82,
  "end": 264.74
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy. ",
  "translatedText": "保存したい実際のデータはこれらのビットのうち 12 ビットのみを構 成し、位置のうちの 4 つは一種の冗長性として予約されています。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.62,
  "end": 273.0
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data. ",
  "translatedText": "ここでの冗長という言葉は単にコピーを意味するものではありません。結局のところ、こ れらの 4 ビットではデータをやみくもにコピーするのに十分な余地がありません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 273.9,
  "end": 280.04
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience. ",
  "translatedText": "代わりに、新しい情報を追加するのではなく、回復力を追 加する、より微妙で賢い種類の冗長性が必要になります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 280.72,
  "end": 287.28
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end. ",
  "translatedText": "これら 4 つの特別なビットが、おそらく最後などでうまくパッケージ化され ることを期待するかもしれませんが、ご覧のとおり、これらを 2 のべき乗 の位置に配置することで、最後までに非常にエレガントなものが得られます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 288.6,
  "end": 299.62
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks. ",
  "translatedText": "また、より大きなブロックに対してこれがどのように拡張されるかについてのちょっとしたヒントも得られるかもしれません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.2,
  "end": 303.54
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now. ",
  "translatedText": "また、技術的には、最終的にはわずか 11 ビットのデータになるため、位置 0 で何が起こって いるかについて若干のニュアンスがあることがわかりますが、今のところは心配しないでください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 304.9,
  "end": 313.26
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors. ",
  "translatedText": "他のエラー修正アルゴリズムと同様に、これには 2 人のプレイヤーが関 与します。送信者はこれら 4 つの特別なビットを設定する責任を負い、 受信者は何らかのチェックを実行してエラーを修正する責任を負います。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 314.14,
  "end": 325.54
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage. ",
  "translatedText": "もちろん、送信者と受信者という言葉は実際にはすべてのチ ェックを行うマシンまたはソフトウェアを指し、メッセージ の概念はストレージなどを含む非常に広い意味を指します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 326.3,
  "end": 334.74
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another. ",
  "translatedText": "結局のところ、データを保存することは、ある場所から別の場所へで はなく、過去から未来へメッセージを送信することと同じことです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 335.34,
  "end": 341.68
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check. ",
  "translatedText": "これがセットアップですが、本題に入る前に、ハミングが発見した当時に 彼の頭の中に新たにあった関連するアイデアについて話す必要がありま す。それは、単一ビットのエラーを検出できるが、修正はできないという 既知の方法です。ビジネスではパリティチェックとして使用されます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 342.56,
  "end": 356.3
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message. ",
  "translatedText": "パリティ チェックでは、送信者が調整を担当する 1 つのビ ットのみを分離し、残りは自由にメッセージを送信できます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 356.88,
  "end": 363.82
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number. ",
  "translatedText": "この特別なビットの唯一の役割は、メッセージ内の 1 の合計数が偶数であることを確認することです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 364.88,
  "end": 371.28
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even. ",
  "translatedText": "たとえば、現時点では 1 の合計数は 7 で、これは奇数であるため、送信者 はその特別なビットを 1 に反転してカウントを偶数にする必要があります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 372.08,
  "end": 379.96
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0. ",
  "translatedText": "ただし、ブロックがすでに偶数個の 1 で始まって いた場合、この特別なビットは 0 に保たれます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 380.8,
  "end": 386.42
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information. ",
  "translatedText": "これは非常にシンプルで、一見シンプルですが、メッセージ内のどこかに変更があると いうアイデアを抽出して、わずかな情報に反映させる非常にエレガントな方法です。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 387.34,
  "end": 396.78
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd. ",
  "translatedText": "このメッセージのビットが 0 から 1、または 1 から 0 に反転 すると、1 の合計数が偶数から奇数に変化することに注意してください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 397.5,
  "end": 406.54
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was. ",
  "translatedText": "したがって、あなたが受信者である場合、このメッセージを見て、奇数 の 1 が表示されれば、たとえどこでエラーが発生したかは分からな くても、何らかのエラーが発生したことを確実に知ることができます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 407.98,
  "end": 417.46
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity. ",
  "translatedText": "専門用語では、ビットのグループに偶数個の 1 が含まれ るか奇数個の 1 が含まれるかをパリティと呼びます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 418.5,
  "end": 423.34
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea. ",
  "translatedText": "数値を使用して、パリティが 0 または 1 であると表現することもできま す。通常は、その考えに基づいて数学を始めると、この方がより役立ちます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 424.86,
  "end": 430.72
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit. ",
  "translatedText": "送信側がパリティを制御するために使用するこの特 別なビットは、パリティ ビットと呼ばれます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 431.22,
  "end": 435.52
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0. ",
  "translatedText": "実際、明確にしておきたいのは、受信側が奇数のパリティを認識した場合、それは必ずしも 1 つのエ ラーがあったことを意味するわけではなく、3 つのエラー、5 つのエラー、またはその他の奇数のエ ラーがあった可能性がありますが、受信者は確実に知ることができます。0ではなかったということ。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 437.56,
  "end": 449.26
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free. ",
  "translatedText": "一方、2 つのエラーがあった場合、または偶数のエラーがあった場合、最終的な 1 のカウントは依然として偶数であるため、受信側は、偶数のカウントが必ずしも メッセージにエラーがないことを意味すると完全に確信することはできません。。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 449.98,
  "end": 462.3
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right. ",
  "translatedText": "たった 2 ビットの反転で台無しになるメッセージは非常に弱い と不満を言うかもしれませんが、それはまったくその通りです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 462.84,
  "end": 469.08
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended. ",
  "translatedText": "ただし、受信したメッセージが送信者が意図したものであることを 100 % 確信できるエラー検出または修正方法はないことに留意してください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 469.7,
  "end": 478.9
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance. ",
  "translatedText": "結局のところ、十分なランダム ノイズがあれば、まったくの偶然で、ある有 効なメッセージが別の有効なメッセージに常に変更される可能性があります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 479.58,
  "end": 485.44
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this. ",
  "translatedText": "代わりに、目標は、特定の最大エラー数まで堅牢なスキームを考え出 すこと、またはおそらくこのような誤検知の確率を減らすことです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 486.24,
  "end": 495.38
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes. ",
  "translatedText": "パリティ チェック自体は非常に弱いですが、メッセージ全体に わたる変更のアイデアを単一のビットにまで絞り出すことで、よ り洗練されたスキームのための強力な構成要素を提供します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 496.26,
  "end": 507.16
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error. ",
  "translatedText": "たとえば、ハミング氏は、エラーが発生したことだけでなく、どこでエラーが発生したかを 特定する方法を探していました。彼の重要な洞察は、メッセージ全体ではなく、慎重に選択 された特定のサブセットにパリティ チェックを適用すると、次のようにできるということ でした。より洗練された一連の質問により、単一ビット エラーの位置が特定されます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 507.94,
  "end": 525.94
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half. ",
  "translatedText": "全体的な感覚は、可能性の空間を半分に切り取る「はい」または「いいえ」 の質問をする 20 の質問のゲームをプレイしているようなものです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 526.68,
  "end": 533.38
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions. ",
  "translatedText": "たとえば、これらの 8 ビット、すべての奇数番号の位 置についてのみパリティ チェックを実行するとします。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 534.16,
  "end": 539.38
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position. ",
  "translatedText": "その後、エラーが検出された場合、エラーが具体的にどこにあるのか、つまり、エラ ーが奇数の位置にあることに関するもう少し詳しい情報が受信機に提供されます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 540.1,
  "end": 548.24
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions. ",
  "translatedText": "これらの 8 ビットでエラーが検出されない場合は、エラ ーがまったくないか、偶数の位置にあることを意味します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 548.94,
  "end": 556.24
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful. ",
  "translatedText": "パリティ チェックをビットの半分に制限すると効果が薄れると思 うかもしれませんが、他の適切に選択されたチェックと組み合わ せて実行すると、直感に反してさらに強力なものが得られます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 557.18,
  "end": 567.2
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group. ",
  "translatedText": "実際にパリティ チェックを設定するには、グループ全体のパリティを制 御する特別なビットを割り当てる必要があることに注意してください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.24,
  "end": 576.62
 },
 {
  "input": "Here let's just choose position 1. ",
  "translatedText": "ここでは位置 1 を選択しましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 577.48,
  "end": 579.18
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even. ",
  "translatedText": "示されている例では、これらの 8 ビットのパリティは現在奇数であるため、送信 側はそのパリティ ビットを切り替える必要があり、現在は偶数になっています。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.72,
  "end": 586.98
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do. ",
  "translatedText": "これは、実行する 4 つのパリティ チェックのうちの 1 つだけです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 587.94,
  "end": 590.68
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here. ",
  "translatedText": "2 番目のチェックは、少なくともここで描画したよう に、グリッドの右半分の 8 ビットの中にあります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 590.92,
  "end": 596.3
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged. ",
  "translatedText": "今回は位置 2 をパリティ ビットとして使用する可能性があるため、これらの 8 ビットに はすでに偶数パリティがあり、送信者はビット番号 2 を変更しないままで問題ありません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 596.68,
  "end": 606.06
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right. ",
  "translatedText": "次に、反対側で、受信側がこのグループのパリティをチェックし、それが奇数であるこ とが判明した場合、エラーが右側の 8 ビットのどこかにあることがわかります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 607.02,
  "end": 615.38
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half. ",
  "translatedText": "それ以外の場合は、エラーがないか、左半分のどこかにエラーがあることを意味します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 615.82,
  "end": 620.58
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block. ",
  "translatedText": "あるいは、エラーが 2 つあった可能性もあると思いますが、今のと ころは、ブロック全体で最大 1 つのエラーがあると仮定します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 621.12,
  "end": 626.5
 },
 {
  "input": "Things break down completely for more than that. ",
  "translatedText": "それを超えると物事は完全に壊れます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 626.94,
  "end": 628.74
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together. ",
  "translatedText": "ここで、次の 2 つのチェックを検討する前に、最初の 2 つのチェッ クを一緒に考えると何ができるようになるのかを少し考えてみましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 629.16,
  "end": 635.1
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half. ",
  "translatedText": "奇数列と右半分でエラーを検出したとします。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 635.8,
  "end": 639.66
 },
 {
  "input": "It necessarily means the error is somewhere in the last column. ",
  "translatedText": "これは必然的に、エラーが最後の列のどこかにあることを意味します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 640.2,
  "end": 643.04
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column. ",
  "translatedText": "奇数列にエラーがなく、右半分にエラーがあった場合は、 それが最後から 2 番目の列にあることがわかります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 643.82,
  "end": 649.7
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column. ",
  "translatedText": "同様に、奇数列にエラーがあり、右半分にはエラーがない場 合は、2 列目のどこかにエラーがあることがわかります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 650.44,
  "end": 656.02
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column. ",
  "translatedText": "これら 2 つのパリティ チェックのどちらでも何も検出されなかった場合、エ ラーが存在する可能性がある唯一の場所はその左端の列であることを意味します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 656.02,
  "end": 663.12
 },
 {
  "input": "But it also might simply mean there's no error at all. ",
  "translatedText": "ただし、単にエラーがまったくないことを意味する場合もあります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 663.34,
  "end": 666.12
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column. ",
  "translatedText": "これは、2 つのパリティ チェックによって列を 特定できると言うための、かなり面倒な方法です。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.3,
  "end": 670.84
 },
 {
  "input": "From here, you can probably guess what follows. ",
  "translatedText": "ここから、おそらく次のことが推測できるでしょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 671.48,
  "end": 673.64
 },
 {
  "input": "We do basically the same thing but for the rows. ",
  "translatedText": "行について以外は基本的に同じことを行います。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 673.8,
  "end": 676.14
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit. ",
  "translatedText": "位置 4 をパリティ ビットとして使用して、奇数行のパリティ チェックが行われます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 676.44,
  "end": 680.9
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0. ",
  "translatedText": "したがって、この例では、そのグループはすでに偶数パリティ を持っているため、ビット 4 は 0 に設定されます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 681.38,
  "end": 685.82
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit. ",
  "translatedText": "最後に、位置 8 をパリティ ビットとして使用して 、下位 2 行のパリティ チェックが行われます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 686.56,
  "end": 691.58
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity. ",
  "translatedText": "この場合、グループに偶数パリティを与えるために、送 信者はビット 8 をオンにする必要があるようです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 692.12,
  "end": 696.82
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row. ",
  "translatedText": "最初の 2 つのチェックで列を特定できるのと同じよ うに、次の 2 つのチェックで行を特定できます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 697.7,
  "end": 701.84
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3. ",
  "translatedText": "例として、送信中に、たとえば位置 3 でエラーが発生したと想像してください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 702.88,
  "end": 707.54
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column. ",
  "translatedText": "これは最初のパリティ グループに影響し、2 番目のパリティ グループにも 影響するため、受信側は右側の列のどこかにエラーがあることがわかります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 708.18,
  "end": 715.56
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group. ",
  "translatedText": "しかし、それは 3 番目のグループには影響せず、4 番目のグループにも影響を与えません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.1,
  "end": 720.54
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error. ",
  "translatedText": "これにより、受信側は最初の行 (必然的に位置 3 を意味しま す) までのエラーを特定できるため、エラーを修正できます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 721.24,
  "end": 727.52
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be. ",
  "translatedText": "これら 4 つの質問への答えによって、たとえそれがどこであったとしても、常に特定の場所を突き止 めることができるということを、少し時間をかけて自分に納得させてみるのも楽しいかもしれません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 728.58,
  "end": 737.1
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting. ",
  "translatedText": "実際、賢明な方は、これらの質問と二進数の数え方と の間に関連性があることに気づくかもしれません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 737.72,
  "end": 743.06
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it. ",
  "translatedText": "もしそうなら、私が台無しにする前に、もう一度強調して、 立ち止まって、自分でそのつながりを描いてみてください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 743.5,
  "end": 748.92
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it. ",
  "translatedText": "パリティ ビット自体が影響を受けるとどうな るか気になる場合は、試してみてください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 750.5,
  "end": 756.06
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions. ",
  "translatedText": "これら 4 つの特別なビットのエラーが、他のものと同じように、同じ 4 つの質問グループを使用してどのように追跡されるのかを少し考えてください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 756.44,
  "end": 764.18
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along. ",
  "translatedText": "結局のところ、私たちが望んでいるのはメッセージ ビットを保護することであり、エラ ー訂正ビットはそのまま使われているだけなので、これはあまり問題ではありません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 767.06,
  "end": 773.1
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct. ",
  "translatedText": "しかし、これらのビットも保護することは 、副産物として自然に計画から外れます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 773.6,
  "end": 777.82
 },
 {
  "input": "You might also enjoy anticipating how this scales. ",
  "translatedText": "これがどのようにスケールされるかを予想するのも楽しいかもしれません。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 779.2,
  "end": 781.76
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot. ",
  "translatedText": "たとえば、場所を特定するためにサイズ 256 ビットのブロックを使用した場合、特定の場所にた どり着くまでにバイナリ検索を行うには、8 つの「はい」または「いいえ」の質問だけが必要です。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 782.3,
  "end": 792.78
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check. ",
  "translatedText": "各質問では、適切なパリティ チェックを設定するために 1 ビットだけを放棄する必要があることを覚えておいてください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 795.64,
  "end": 800.5
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two. ",
  "translatedText": "すでにご覧になっている方もいるかもしれませんが、これらの質問の内容を 1 ～ 2 分で見つける体系的な方法については後ほど説明します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 803.16,
  "end": 809.36
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here. ",
  "translatedText": "このスケッチが、ここで開発しているものの効率性を理 解していただくのに十分であることを願っています。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 809.88,
  "end": 813.66
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want. ",
  "translatedText": "最初のものは、強調表示されている 8 つのパリティ ビットを除いて、任意 のものにすることができ、必要なメッセージやデータを運ぶことができます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 813.66,
  "end": 821.0
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole. ",
  "translatedText": "8 ビットはメッセージの残りの部分によって完全に決定されるという意味で冗 長ですが、メッセージ全体を単にコピーするよりもはるかに賢明な方法です。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 821.72,
  "end": 830.02
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error. ",
  "translatedText": "それでも、ほとんど諦めずに、どんなシングルビット エラーでも特定して修正することができるでしょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 833.6,
  "end": 838.38
 },
 {
  "input": "Well, almost. ",
  "translatedText": "よくほとんど。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.2,
  "end": 840.4
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0. ",
  "translatedText": "さて、ここでの 1 つの問題は、4 つのパリティ チェックのいずれもエラーを 検出しなかった場合、つまり、送信者の意図どおり、特別に選択された 8 ビッ トのサブセットがすべて偶数パリティを持つことを意味し、それはエラーがまったく なかったことを意味するかどうかです。、または位置 0 に絞り込まれます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 840.96,
  "end": 856.86
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition. ",
  "translatedText": "ご覧のとおり、はいまたはいいえの質問が 4 つあるため、パリティ チェックには 16 の可能な結果があり、ブロック内の 16 の位置のうち 1 つを正確に特定するには最初 は完璧に思えますが、17 番目の結果、つまりエラーなしを伝える必要もあります。状態。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 857.74,
  "end": 871.9
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely. ",
  "translatedText": "ここでの解決策は実際には非常に簡単で、0 番目のビットを完全に忘れるだけです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 873.02,
  "end": 877.3
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error. ",
  "translatedText": "したがって、4 つのパリティ チェックを実行し、それらがすべて偶数であ ることが確認できれば、それは間違いなくエラーがないことを意味します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 877.84,
  "end": 883.46
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy. ",
  "translatedText": "これが意味するのは、16 ビット ブロックを扱うのではなく、15 ビット ブロックを扱うということです。この場合、ビッ トのうち 11 ビットがメッセージを伝送するために自由に使用され、そのうちの 4 ビットは冗長性のために存在します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 884.24,
  "end": 893.22
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code. ",
  "translatedText": "これにより、業界の人々が 15-11 ハ ミング コードと呼ぶものが完成しました。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 893.78,
  "end": 898.8
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us. ",
  "translatedText": "そうは言っても、ブロック サイズが 2 のきれいな累乗であるのは良いことであり、そ の 0 番目のビットを保持して、それに少し追加の作業をさせる賢い方法があります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 899.86,
  "end": 908.14
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors. ",
  "translatedText": "これをブロック全体にわたるパリティ ビットとして使用すると、修正はで きなくても、実際に 2 ビット エラーを検出できるようになります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 908.7,
  "end": 915.54
 },
 {
  "input": "Here's how it works. ",
  "translatedText": "仕組みは次のとおりです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 916.16,
  "end": 916.82
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check. ",
  "translatedText": "これら 4 つの特別なエラー訂正ビットを設定した後、通常のパリティ チェックと同 様に、ブロック全体のパリティが偶数になるように 0 番目のビットを設定します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 917.18,
  "end": 924.94
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks. ",
  "translatedText": "ここで、単一ビット エラーがある場合、ブロック全体のパリティが奇数に切り替わりま すが、4 つのエラー修正チェックのおかげで、いずれにせよそれをキャッチできます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 925.7,
  "end": 933.6
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks. ",
  "translatedText": "ただし、エラーが 2 つある場合、全体のパリティは偶数に戻りますが 、受信側では、これら 4 つのパリティ チェックで何が起こっている かにより、少なくとも何らかのエラーが発生していることがわかります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 934.16,
  "end": 945.18
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors. ",
  "translatedText": "そのため、全体としては偶数パリティであるにもかかわらず、他のチェックでゼロ以外の何かが 発生していることに気付いた場合は、少なくとも 2 つのエラーがあったことがわかります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 945.18,
  "end": 952.7
 },
 {
  "input": "Isn't that clever? ",
  "translatedText": "それは賢明ではないでしょうか？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.52,
  "end": 954.0
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them. ",
  "translatedText": "これらの 2 ビット エラーを修正することはできませんが、少し面 倒な 0 番目のビットを動作に戻すだけで、エラーを検出できます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 954.3,
  "end": 961.26
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code. ",
  "translatedText": "これは非常に標準的なもので、拡張ハミング コードとして知られています。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.26,
  "end": 965.22
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block. ",
  "translatedText": "技術的に言えば、少なくとも 16 ビット ブロックの例について は、ハミング コードが何を行うかについて完全に説明できました。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 966.54,
  "end": 972.88
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself. ",
  "translatedText": "ただし、最初から最後まで 1 つの完全な例を自分で実行して、理解度 を確認し、ここまでのすべてを定着させる方が満足できると思います。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 972.88,
  "end": 981.32
 },
 {
  "input": "I'll step through it with you though so you can check yourself. ",
  "translatedText": "ただし、私はあなたと一緒にそれを段階的に確認していきますので、あなた自身を確認してください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 982.08,
  "end": 984.3
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks. ",
  "translatedText": "メッセージを設定するには、それが空間を介して変換するリテラル メ ッセージであっても、長期間保存したいデータであっても、最初のステ ップはメッセージを 11 ビットのチャンクに分割することです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 985.12,
  "end": 994.66
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block. ",
  "translatedText": "各チャンクは、エラー耐性のある 16 ビット ブロックにパッケージ化されます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 995.58,
  "end": 999.76
 },
 {
  "input": "So let's take this one as an example and actually work it out. ",
  "translatedText": "では、これを例として実際にやってみましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 999.76,
  "end": 1003.22
 },
 {
  "input": "Go ahead, actually do it! ",
  "translatedText": "さあ、実際にやってみましょう！",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1003.74,
  "end": 1004.94
 },
 {
  "input": "Let's pause and try putting together this block. ",
  "translatedText": "立ち止まってこのブロックを組み立ててみましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1005.22,
  "end": 1007.02
 },
 {
  "input": "Okay, you ready? ",
  "translatedText": "はい、準備はできましたか？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1012.72,
  "end": 1013.68
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order. ",
  "translatedText": "位置 0 と他の 2 の累乗はエラー訂正義務のために予約されているので、残 りのすべてのスポットにメッセージ ビットを順番に配置することから始めます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1014.24,
  "end": 1023.32
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0. ",
  "translatedText": "このグループには偶数パリティが必要ですが、すでにそうされているため 、位置 1 のパリティ ビットを 0 に設定する必要があります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1025.34,
  "end": 1032.34
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1. ",
  "translatedText": "次のグループは奇数パリティで始まるため、そのパリ ティ ビットを 1 に設定する必要があります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1033.02,
  "end": 1037.88
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1. ",
  "translatedText": "その後のグループは奇数パリティで始まるため、やはりそ のパリティ ビットを 1 に設定する必要があります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1039.16,
  "end": 1044.24
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1. ",
  "translatedText": "また、最後のグループにも奇数パリティがあり 、8 番目のビットを 1 に設定します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1044.78,
  "end": 1050.06
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0. ",
  "translatedText": "そして最後のステップとして、ブロック全体が偶数パリティを持つようになりました。これは、 ビット番号 0 (包括的なパリティ ビット) を 0 に設定できることを意味します。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1051.3,
  "end": 1060.32
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0. ",
  "translatedText": "したがって、このブロックが送信されると、4 つの特別なサブセット とブロック全体のパリティはすべて偶数、つまり 0 になります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1061.34,
  "end": 1068.14
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver. ",
  "translatedText": "演習の 2 番目の部分として、あなたに受信者の役割を果たしてもらいましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1068.82,
  "end": 1072.18
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't. ",
  "translatedText": "もちろん、それはあなたがこのメッセージが何であるかをまだ知らないことを意味します。もしかしたら覚えている人もいるかもしれませんが、まだ覚えていないと仮定しましょう。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1073.48,
  "end": 1079.78
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did. ",
  "translatedText": "私がやろうとしているのは、そのブロック内のビットの 0、1、また は 2 を変更して、私が何をしたのかを理解してもらうことです。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1080.02,
  "end": 1087.74
 },
 {
  "input": "So again, pause and try working it out. ",
  "translatedText": "もう一度立ち止まって、問題を解決してみてください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1088.26,
  "end": 1090.81
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column. ",
  "translatedText": "さて、受信者として最初のパリティ グループをチェックすると、それが偶 数であることがわかり、存在するエラーは偶数列にある必要があります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1098.79,
  "end": 1107.91
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column. ",
  "translatedText": "次のチェックでは奇数が得られ、少なくとも 1 つのエラ ーがあることがわかり、この特定の列に絞り込まれます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1109.69,
  "end": 1117.03
 },
 {
  "input": "The third check is even, chopping down the possibilities even further. ",
  "translatedText": "3 番目のチェックは均等であり、可能性をさらに切り詰めます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1118.55,
  "end": 1121.79
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10. ",
  "translatedText": "そして、最後のパリティ チェックは奇妙で、下部のどこかにエラーがあるこ とがわかりますが、今では位置 10 にあるはずであることがわかります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1122.65,
  "end": 1129.65
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two. ",
  "translatedText": "さらに、ブロック全体のパリティは奇数であるため、フリップ が 2 回ではなく 1 回であるという確信が得られます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1131.49,
  "end": 1137.53
 },
 {
  "input": "If it's three or more, all bets are off. ",
  "translatedText": "3 つ以上の場合、すべての賭けは無効になります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1138.07,
  "end": 1139.97
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with. ",
  "translatedText": "ビット番号 10 を修正した後、修正に使用されなかった 11 ビットを取り出すと、元のメッセージの関連セグメントが得られま す。巻き戻して比較すると、まさに例の開始点と同じになります。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1141.31,
  "end": 1154.39
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code. ",
  "translatedText": "これらすべてを手動で行う方法がわかったので、次は、このロジックすべての中核部 分を 1 行の Python コードで実行する方法を説明したいと思います。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1155.71,
  "end": 1163.17
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks. ",
  "translatedText": "ご存知のとおり、私がまだお伝えしていないのは、このアルゴリズムが実際にどれほど洗練 されているか、マシンにエラーの位置を指示させるのがどれほど簡単であるか、体系的に スケールを調整する方法、そしてすべてをどのようにフレーム化できるかということです。これは、複数の個別のパリティ チェックではなく、1 つの操作として実行されます。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1163.87,
  "end": 1178.75
 },
 {
  "input": "To see what I mean, come join me in part 2. ",
  "translatedText": "私の言いたいことを理解するには、パート 2 に参加してください。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1179.43,
  "end": 1181.31
 }
]