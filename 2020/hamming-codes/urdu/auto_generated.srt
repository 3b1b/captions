1
00:00:00,000 --> 00:00:03,120
میں فرض کر رہا ہوں کہ یہاں ہر کوئی حصہ 1 سے آ رہا ہے۔

2
00:00:03,120 --> 00:00:06,920
ہم ہیمنگ کوڈز کے بارے میں بات کر رہے تھے، ڈیٹا کا ایک بلاک بنانے کا ایک طریقہ

3
00:00:06,920 --> 00:00:11,640
جہاں زیادہ تر بٹس ایک بامعنی پیغام لے جاتے ہیں، جب کہ کچھ دوسرے ایک قسم کی

4
00:00:11,640 --> 00:00:15,800
فالتو پن کے طور پر کام کرتے ہیں، اس طرح کہ اگر کوئی بٹ پلٹ جائے، یا تو

5
00:00:15,800 --> 00:00:20,560
ایک پیغام۔ bit یا redundancy bit، اس بلاک میں کوئی بھی چیز، وصول کنندہ اس قابل ہو

6
00:00:20,560 --> 00:00:21,920
جائے گا کہ یہ شناخت کر سکے کہ کوئی خرابی تھی، اور اسے کیسے ٹھیک کیا جائے۔

7
00:00:21,920 --> 00:00:25,900
وہاں پیش کیا گیا بنیادی خیال یہ تھا کہ غلطی تک پہنچنے کے

8
00:00:25,900 --> 00:00:29,800
لیے بائنری تلاش کرنے کے لیے متعدد برابری چیک کا استعمال کیسے کریں۔

9
00:00:29,800 --> 00:00:33,920
اس ویڈیو میں مقصد ہیمنگ کوڈز کو ممکنہ حد تک

10
00:00:33,920 --> 00:00:35,420
ہینڈ آن اور دوبارہ دریافت کرنے کا احساس دلانا تھا۔

11
00:00:35,420 --> 00:00:40,040
لیکن جیسے ہی آپ سافٹ ویئر یا ہارڈ ویئر میں اس کو عملی جامہ پہنانے کے بارے میں سوچنا شروع کر

12
00:00:40,040 --> 00:00:44,120
دیتے ہیں، وہ فریمنگ حقیقت میں اس بات کو کم کر سکتی ہے کہ یہ کوڈز واقعی کتنے خوبصورت ہیں۔

13
00:00:44,120 --> 00:00:47,620
آپ سوچ سکتے ہیں کہ آپ کو ایک الگورتھم لکھنے کی ضرورت ہے جو غلطی

14
00:00:47,620 --> 00:00:52,320
کے تمام ممکنہ مقامات پر نظر رکھے اور ہر چیک کے ساتھ اس گروپ کو

15
00:00:52,320 --> 00:00:54,160
نصف میں کاٹ دے، لیکن یہ حقیقت میں اس سے کہیں زیادہ آسان طریقہ ہے۔

16
00:00:54,160 --> 00:00:58,720
اگر آپ پچھلی ویڈیو میں ہم نے جو چار برابری کی جانچ پڑتال کی تھی، ان کے جوابات پڑھتے ہیں، جیسے کہ

17
00:00:58,760 --> 00:01:04,800
yeses اور nos کے بجائے 1s اور 0s، یہ لفظی طور پر بائنری میں غلطی کی پوزیشن کو واضح کرتا ہے۔

18
00:01:04,800 --> 00:01:10,160
مثال کے طور پر، بائنری میں نمبر 7 0111 کی طرح لگتا ہے، بنیادی

19
00:01:10,160 --> 00:01:12,640
طور پر یہ کہہ رہا ہے کہ یہ 4 جمع 2 جمع 1 ہے۔

20
00:01:12,640 --> 00:01:17,960
اور دیکھیں کہ پوزیشن 7 کہاں بیٹھتی ہے، یہ ہمارے برابری گروپوں میں سے

21
00:01:17,960 --> 00:01:22,280
پہلے کو متاثر کرتی ہے، اور دوسرے، اور تیسرے کو، لیکن آخری نہیں۔

22
00:01:22,280 --> 00:01:26,560
لہذا نیچے سے اوپر تک ان چار چیکوں کے نتائج

23
00:01:26,560 --> 00:01:28,000
کو پڑھنا واقعی غلطی کی پوزیشن کو واضح کرتا ہے۔

24
00:01:28,520 --> 00:01:32,240
مثال 7 کے بارے میں کچھ خاص نہیں ہے، یہ عام طور پر کام کرتا ہے، اور یہ ہارڈ

25
00:01:32,240 --> 00:01:37,440
ویئر میں پوری اسکیم کو لاگو کرنے کی منطق کو حیران کن حد تک آسان بنا دیتا ہے۔

26
00:01:37,440 --> 00:01:43,380
اب اگر آپ یہ دیکھنا چاہتے ہیں کہ یہ جادو کیوں ہوتا ہے، تو ان 16

27
00:01:43,380 --> 00:01:48,480
انڈیکس لیبلز کو ہماری پوزیشنوں کے لیے لیں، لیکن ان کو بیس 10 میں لکھنے کے

28
00:01:48,480 --> 00:01:50,720
بجائے، آئیے ان سب کو بائنری میں لکھیں، جو 0000 سے 1111 تک چلتے ہیں۔

29
00:01:50,720 --> 00:01:55,880
جیسا کہ ہم ان بائنری لیبلز کو ان کے خانوں میں واپس ڈالتے ہیں، میں اس

30
00:01:56,080 --> 00:01:58,440
بات پر زور دیتا ہوں کہ وہ اصل میں بھیجے جانے والے ڈیٹا سے الگ ہیں۔

31
00:01:58,440 --> 00:02:02,200
وہ ایک تصوراتی لیبل سے زیادہ کچھ نہیں ہیں جو آپ اور مجھے یہ

32
00:02:02,200 --> 00:02:04,200
سمجھنے میں مدد کرتے ہیں کہ چار برابری والے گروپ کہاں سے آئے ہیں۔

33
00:02:04,200 --> 00:02:08,840
ہر وہ چیز جس کو ہم بائنری میں بیان کر رہے ہیں اس کی خوبصورتی شاید بائنری

34
00:02:08,840 --> 00:02:13,160
میں بیان کیے جانے والے ہر چیز کے ہونے کی الجھن کی وجہ سے کم ہے۔

35
00:02:13,160 --> 00:02:15,040
یہ اس کے قابل ہے، اگرچہ.

36
00:02:15,040 --> 00:02:20,740
اپنی توجہ صرف ان تمام لیبلز کے آخری بٹ پر مرکوز کریں، اور

37
00:02:20,740 --> 00:02:24,280
پھر ان پوزیشنوں کو نمایاں کریں جہاں وہ آخری بٹ 1 ہے۔

38
00:02:24,280 --> 00:02:28,800
ہمیں جو ملتا ہے وہ ہمارے چار برابری گروپوں میں سے پہلا ہے، جس کا

39
00:02:28,800 --> 00:02:34,480
مطلب ہے کہ آپ اس پہلے چیک کو پوچھنے سے تعبیر کر سکتے ہیں، ارے،

40
00:02:34,480 --> 00:02:36,680
اگر کوئی خرابی ہے، تو کیا اس غلطی کی پوزیشن میں آخری حصہ 1 ہے؟

41
00:02:36,680 --> 00:02:42,600
اسی طرح، اگر آپ دوسرے سے آخری بٹ پر توجہ مرکوز کرتے ہیں، اور ان تمام پوزیشنوں کو

42
00:02:42,600 --> 00:02:47,040
نمایاں کرتے ہیں جہاں وہ 1 ہے، تو آپ کو ہماری اسکیم سے دوسرا برابری گروپ ملتا ہے۔

43
00:02:47,040 --> 00:02:51,960
دوسرے لفظوں میں، وہ دوسرا چیک پوچھ رہا ہے، ارے، مجھے دوبارہ، اگر

44
00:02:51,960 --> 00:02:56,160
کوئی غلطی ہے، تو کیا اس پوزیشن کا دوسرا آخری حصہ 1 ہے؟

45
00:02:56,160 --> 00:02:57,160
اور اسی طرح.

46
00:02:57,160 --> 00:03:03,320
تیسرا برابری چیک ہر اس پوزیشن کا احاطہ کرتا ہے جس کا تیسرا سے آخری بٹ آن ہے، اور

47
00:03:03,320 --> 00:03:10,120
آخری ایک آخری آٹھ پوزیشنوں کا احاطہ کرتا ہے، وہ جن کا سب سے زیادہ آرڈر بٹ 1 ہے۔

48
00:03:10,120 --> 00:03:15,680
ہم نے پہلے جو کچھ کیا وہ ان چار سوالوں کے جوابات کے

49
00:03:15,680 --> 00:03:18,800
برابر ہے، جو کہ بائنری میں پوزیشن کو ہجے کرنے کے مترادف ہے۔

50
00:03:19,800 --> 00:03:22,080
مجھے امید ہے کہ اس سے دو چیزیں واضح ہو جائیں گی۔

51
00:03:22,080 --> 00:03:27,140
پہلا یہ ہے کہ کس طرح منظم طریقے سے ان سائزوں کو بلاک کرنا ہے جو دو کی بڑی طاقتیں ہیں۔

52
00:03:27,140 --> 00:03:33,180
اگر ہر پوزیشن کو بیان کرنے میں مزید بٹس لگتے ہیں، جیسے 64 مقامات کو بیان کرنے کے لیے چھ بٹس، تو ان

53
00:03:33,180 --> 00:03:38,640
بٹس میں سے ہر ایک آپ کو برابری والے گروپوں میں سے ایک دیتا ہے جسے ہمیں چیک کرنے کی ضرورت ہے۔

54
00:03:38,640 --> 00:03:42,060
آپ میں سے وہ لوگ جنہوں نے میٹ پارکر کے ساتھ میں نے شطرنج کی

55
00:03:42,060 --> 00:03:43,400
تختی کی پہیلی دیکھی ہے شاید وہ یہ سب کچھ بہت زیادہ مانوس محسوس کریں۔

56
00:03:43,400 --> 00:03:48,200
یہ ایک ہی بنیادی منطق ہے، لیکن ایک مختلف مسئلہ کو

57
00:03:48,200 --> 00:03:49,880
حل کرنا، اور 64 مربع شطرنج پر لاگو ہوتا ہے۔

58
00:03:49,880 --> 00:03:54,000
دوسری چیز جو مجھے امید ہے کہ اس سے واضح ہوتا ہے کہ ہمارے برابری بٹس ان پوزیشنوں

59
00:03:54,000 --> 00:03:58,320
پر کیوں بیٹھے ہیں جو دو کی طاقتیں ہیں، مثال کے طور پر 1، 2، 4، اور 8۔

60
00:03:58,320 --> 00:04:03,640
یہ وہ پوزیشنیں ہیں جن کی بائنری نمائندگی صرف ایک بٹ آن ہوئی ہے۔

61
00:04:03,640 --> 00:04:09,000
اس کا مطلب یہ ہے کہ ان میں سے ہر ایک برابری بٹس

62
00:04:09,000 --> 00:04:12,640
ایک کے اندر بیٹھتا ہے اور چار برابری گروپوں میں سے صرف ایک۔

63
00:04:12,640 --> 00:04:16,840
آپ اسے بڑی مثالوں میں بھی دیکھ سکتے ہیں، جہاں اس سے کوئی فرق نہیں پڑتا ہے کہ آپ

64
00:04:16,840 --> 00:04:25,920
کتنے ہی بڑے کیوں نہ ہوں، ہر برابری بٹ آسانی سے گروپوں میں سے صرف ایک کو چھوتا ہے۔

65
00:04:25,920 --> 00:04:29,680
ایک بار جب آپ یہ سمجھ لیں کہ یہ برابری کی جانچ پڑتال جن پر ہم نے

66
00:04:29,680 --> 00:04:34,320
اپنا بہت زیادہ وقت صرف کیا ہے وہ بائنری میں خرابی کی پوزیشن کو واضح کرنے

67
00:04:34,320 --> 00:04:37,880
کے ایک ہوشیار طریقے سے زیادہ کچھ نہیں ہیں، پھر ہم ہیمنگ کے بارے میں سوچنے کے

68
00:04:37,880 --> 00:04:42,160
ایک مختلف طریقے سے تعلق کھینچ سکتے ہیں۔ کوڈز، جو کہ بہت آسان اور زیادہ خوبصورت

69
00:04:42,160 --> 00:04:43,880
ہے، اور جسے بنیادی طور پر کوڈ کی ایک لائن کے ساتھ لکھا جا سکتا ہے۔

70
00:04:43,920 --> 00:04:46,200
یہ XOR فنکشن پر مبنی ہے۔

71
00:04:46,200 --> 00:04:50,960
XOR، آپ میں سے ان لوگوں کے لیے جو نہیں جانتے، خصوصی یا کے لیے کھڑا ہے۔

72
00:04:50,960 --> 00:04:55,440
جب آپ دو بٹس کا XOR لیتے ہیں، تو یہ 1 واپس کرنے جا رہا ہے اگر

73
00:04:55,440 --> 00:05:00,200
ان میں سے کوئی ایک بٹس آن ہو، لیکن نہیں اگر دونوں آن یا آف ہوں۔

74
00:05:00,200 --> 00:05:03,760
مختلف طریقے سے جملے، یہ ان دو بٹس کی برابری ہے۔

75
00:05:03,760 --> 00:05:07,840
ایک ریاضی کے فرد کے طور پر، میں اس کے بارے میں اضافی موڈ 2 کے طور پر سوچنا پسند کرتا ہوں۔

76
00:05:07,840 --> 00:05:12,000
ہم عام طور پر دو مختلف بٹ سٹرنگز کے XOR کے بارے میں بھی بات

77
00:05:12,040 --> 00:05:14,040
کرتے ہیں، جو بنیادی طور پر اس جزو کو جزو کے لحاظ سے کرتا ہے۔

78
00:05:14,040 --> 00:05:16,280
یہ اضافے کی طرح ہے، لیکن جہاں آپ کبھی نہیں لے جاتے ہیں۔

79
00:05:16,280 --> 00:05:21,240
ایک بار پھر، زیادہ ریاضی کی طرف مائل اس کے بارے میں سوچنا پسند

80
00:05:21,240 --> 00:05:23,520
کریں گے کہ دو ویکٹر کو شامل کرنا اور موڈ 2 کو کم کرنا۔

81
00:05:23,520 --> 00:05:28,720
اگر آپ ابھی کچھ Python کھولتے ہیں اور کیریٹ آپریشن کو دو عدد کے درمیان لاگو کرتے ہیں، تو

82
00:05:28,720 --> 00:05:35,400
یہ وہی کام کر رہا ہے لیکن ہڈ کے نیچے ان نمبروں کی تھوڑا سا نمائندگی کرنے کے لئے۔

83
00:05:35,400 --> 00:05:40,920
آپ کے اور میرے لیے اہم نکتہ یہ ہے کہ بہت سے مختلف بٹ سٹرنگز

84
00:05:40,960 --> 00:05:45,960
کا XOR لینا مؤثر طریقے سے الگ الگ گروپس کی پیروڈیز کی گنتی کرنے

85
00:05:45,960 --> 00:05:51,320
کا ایک طریقہ ہے، جیسا کہ کالموں کے ساتھ، سبھی ایک ساتھ جھپٹ پڑے۔

86
00:05:51,320 --> 00:05:54,520
یہ ہمیں ہمارے ہیمنگ کوڈ الگورتھم سے متعدد برابری کی جانچ پڑتال کے بارے میں سوچنے کا ایک

87
00:05:54,520 --> 00:05:59,680
آسان طریقہ فراہم کرتا ہے کیونکہ سبھی کو ایک ہی آپریشن میں ایک ساتھ پیک کیا جاتا ہے۔

88
00:05:59,680 --> 00:06:02,800
اگرچہ پہلی نظر میں یہ بہت مختلف نظر آتا ہے۔

89
00:06:02,800 --> 00:06:08,360
خاص طور پر بائنری میں 16 پوزیشنز کو لکھیں، جیسا کہ ہمارے پاس پہلے تھا، اور

90
00:06:08,640 --> 00:06:14,800
اب ان پوزیشنز کو ہائی لائٹ کریں جہاں میسج بٹ کو 1 پر آن کیا گیا

91
00:06:14,800 --> 00:06:19,400
ہے، اور پھر ان پوزیشنز کو ایک بڑے کالم میں اکٹھا کریں اور XOR لیں۔

92
00:06:19,400 --> 00:06:23,480
آپ شاید اندازہ لگا سکتے ہیں کہ نتیجے کے طور پر نیچے بیٹھے 4 بٹس

93
00:06:23,480 --> 00:06:27,480
4 برابری کی جانچ کے برابر ہیں جو ہم جانتے ہیں اور پسند کرتے

94
00:06:27,480 --> 00:06:32,720
ہیں، لیکن حقیقت میں اس کے بارے میں سوچنے کے لیے ایک لمحہ نکالیں۔

95
00:06:32,720 --> 00:06:37,880
مثال کے طور پر، یہ آخری کالم ان تمام پوزیشنوں کو گن رہا ہے جن کا آخری بٹ

96
00:06:38,400 --> 00:06:42,400
ایک 1 ہے، لیکن ہم پہلے سے ہی صرف نمایاں کردہ پوزیشنوں تک محدود ہیں، اس لیے

97
00:06:42,400 --> 00:06:45,960
یہ مؤثر طریقے سے شمار کر رہا ہے کہ پہلے برابری گروپ سے کتنی نمایاں پوزیشنیں آئیں۔

98
00:06:45,960 --> 00:06:48,520
کیا اسکا کوئ مطلب بنتا ہے؟

99
00:06:48,520 --> 00:06:53,600
اسی طرح، اگلا کالم شمار کرتا ہے کہ دوسرے برابری گروپ

100
00:06:53,600 --> 00:06:59,640
میں کتنی پوزیشنیں ہیں، وہ پوزیشنیں جن کا دوسرا سے آخری

101
00:06:59,640 --> 00:07:00,640
بٹ 1 ہے، اور جن پر روشنی ڈالی گئی ہے، وغیرہ۔

102
00:07:00,640 --> 00:07:06,640
یہ وہی چیز ہے جو ہم کر رہے ہیں کے نقطہ نظر میں واقعی صرف ایک چھوٹی سی تبدیلی ہے۔

103
00:07:07,640 --> 00:07:10,000
اور اس طرح آپ جانتے ہیں کہ یہ یہاں سے کہاں جاتا ہے۔

104
00:07:10,000 --> 00:07:14,400
بھیجنے والا کچھ خاص برابری بٹس کو ٹوگل کرنے کے لیے ذمہ دار

105
00:07:14,400 --> 00:07:19,640
ہے تاکہ یہ یقینی بنایا جا سکے کہ رقم 0000 بنتی ہے۔

106
00:07:19,640 --> 00:07:23,600
اب ایک بار جب ہمارے پاس یہ اس طرح ہو جائے تو، یہ ہمیں یہ سوچنے کا ایک بہت اچھا طریقہ فراہم

107
00:07:23,600 --> 00:07:28,720
کرتا ہے کہ نچلے حصے میں یہ چار نتیجے والے بٹس براہ راست غلطی کی پوزیشن کو کیوں ظاہر کرتے ہیں۔

108
00:07:28,720 --> 00:07:32,680
آئیے کہتے ہیں کہ اس بلاک میں تھوڑا سا 0 سے 1 تک ٹوگل ہوجاتا ہے۔

109
00:07:32,720 --> 00:07:37,320
اس کا مطلب یہ ہے کہ اس بٹ کی پوزیشن اب کل XOR

110
00:07:37,320 --> 00:07:42,960
میں شامل ہونے جا رہی ہے، جو رقم کو 0 سے بدل کر

111
00:07:42,960 --> 00:07:44,800
اس نئی شامل ویلیو، غلطی کی پوزیشن میں تبدیل کر دیتی ہے۔

112
00:07:44,800 --> 00:07:48,800
قدرے کم واضح طور پر، یہی بات درست ہے اگر کوئی

113
00:07:48,800 --> 00:07:49,800
ایسی غلطی ہو جو 1 کو 0 میں بدل دیتی ہے۔

114
00:07:49,800 --> 00:07:54,720
آپ دیکھتے ہیں، اگر آپ دو بار ایک ساتھ تھوڑا سا سٹرنگ جوڑتے ہیں، تو یہ بالکل ایسا ہی ہے جیسا

115
00:07:54,720 --> 00:07:59,000
کہ اس کا وہاں بالکل نہ ہونا، بنیادی طور پر کیونکہ اس دنیا میں 1 جمع 1 برابر 0 ہے۔

116
00:07:59,000 --> 00:08:03,720
لہذا اس پوزیشن کی ایک کاپی کو کل رقم میں شامل کرنے کا

117
00:08:03,720 --> 00:08:05,400
وہی اثر ہوتا ہے جیسا کہ ہم اسے منتقل کر رہے ہیں۔

118
00:08:05,400 --> 00:08:10,080
اور وہ اثر، ایک بار پھر، یہ ہے کہ یہاں نیچے

119
00:08:10,080 --> 00:08:13,480
کا کل نتیجہ غلطی کی پوزیشن کو ظاہر کرتا ہے۔

120
00:08:13,480 --> 00:08:17,720
یہ بتانے کے لیے کہ یہ کتنا خوبصورت ہے، میں دکھاتا ہوں کہ ازگر کے کوڈ کی ایک لائن جس کا

121
00:08:17,720 --> 00:08:22,120
میں نے پہلے حوالہ دیا تھا، جو وصول کنندہ کے سرے پر موجود تقریباً تمام منطق کو پکڑ لے گی۔

122
00:08:22,120 --> 00:08:27,160
ہم ڈیٹا بلاک کی نقل کرنے کے لیے 16 1s اور 0s کی بے ترتیب صف بنا کر

123
00:08:27,160 --> 00:08:31,160
شروع کریں گے، اور میں اسے نام کے بٹس دوں گا، لیکن یقیناً عملی طور پر یہ

124
00:08:31,160 --> 00:08:36,160
وہ چیز ہوگی جو ہم بھیجنے والے سے وصول کر رہے ہیں، اور اس کے بجائے بے ترتیب

125
00:08:36,160 --> 00:08:38,600
ہونے کی وجہ سے یہ 5 برابری بٹس کے ساتھ 11 ڈیٹا بٹس لے کر جائے گا۔

126
00:08:38,600 --> 00:08:43,160
اگر میں فنکشن کو enumerateBits کہتا ہوں، تو یہ جو کرتا ہے ان میں سے ہر ایک بٹس

127
00:08:43,160 --> 00:08:48,240
کو متعلقہ انڈیکس کے ساتھ جوڑتا ہے، اس صورت میں 0 سے 15 تک چل رہا ہے۔

128
00:08:48,240 --> 00:08:53,200
لہذا اگر ہم پھر ایک فہرست بناتے ہیں جو ان تمام جوڑوں پر نظر آتی ہے، جوڑے جو i

129
00:08:53,200 --> 00:08:59,160
کی طرح نظر آتے ہیں، اور پھر ہم صرف i ویلیو کو نکالتے ہیں، صرف انڈیکس، ٹھیک ہے یہ

130
00:08:59,160 --> 00:09:01,920
اتنا دلچسپ نہیں ہے، ہم صرف ان انڈیکس کو 0 سے 15 تک واپس کر دیتے ہیں۔ .

131
00:09:01,920 --> 00:09:07,520
لیکن اگر ہم اس شرط کو شامل کریں کہ یہ صرف اگر بٹ ہے، یعنی اگر وہ بٹ 1

132
00:09:07,520 --> 00:09:13,400
ہے نہ کہ 0، تو یہ صرف ان پوزیشنوں کو نکالتا ہے جہاں متعلقہ بٹ آن ہوتا ہے۔

133
00:09:13,400 --> 00:09:20,320
اس معاملے میں ایسا لگتا ہے کہ وہ پوزیشنیں 0، 4، 6، 9، وغیرہ ہیں۔

134
00:09:20,720 --> 00:09:24,640
ہم جو چاہتے ہیں وہ ان تمام پوزیشنوں کو اکٹھا کرنا ہے، بٹس

135
00:09:24,640 --> 00:09:29,960
کی پوزیشنز جو آن ہیں، اور پھر ان کو ایک ساتھ XOR کریں۔

136
00:09:29,960 --> 00:09:33,960
Python میں ایسا کرنے کے لیے، مجھے پہلے ایک دو مددگار فنکشنز درآمد کرنے دیں۔

137
00:09:33,960 --> 00:09:39,140
اس طرح ہم اس فہرست میں reduce() کو کال کر سکتے ہیں، اور اسے کم کرنے کے لیے XOR فنکشن کا استعمال کر سکتے ہیں۔

138
00:09:39,140 --> 00:09:44,840
یہ بنیادی طور پر فہرست کے ذریعے اپنا راستہ کھاتا ہے، راستے میں XORs کو لے جاتا ہے۔

139
00:09:44,840 --> 00:09:48,760
اگر آپ چاہیں تو، آپ واضح طور پر اس XOR

140
00:09:48,800 --> 00:09:52,200
فنکشن کو کہیں سے درآمد کیے بغیر لکھ سکتے ہیں۔

141
00:09:52,200 --> 00:09:56,880
تو اس وقت ایسا لگتا ہے کہ اگر ہم یہ اپنے 16 بٹس کے بے ترتیب

142
00:09:56,880 --> 00:10:02,080
بلاک پر کرتے ہیں، تو یہ 9 لوٹاتا ہے، جس کی بائنری نمائندگی 1001 ہے۔

143
00:10:02,080 --> 00:10:05,960
ہم یہ یہاں نہیں کریں گے، لیکن آپ ایک فنکشن لکھ سکتے ہیں جہاں بھیجنے والا اس بائنری نمائندگی کا استعمال

144
00:10:05,960 --> 00:10:11,560
کرتے ہوئے ضرورت کے مطابق چار برابری بٹس کو سیٹ کرتا ہے، بالآخر اس بلاک کو ایسی حالت میں لے

145
00:10:11,560 --> 00:10:16,200
جاتا ہے جہاں بٹس کی مکمل فہرست پر کوڈ کی اس لائن کو چلانے سے واپسی ہوتی ہے۔ ایک 0

146
00:10:17,200 --> 00:10:20,200
یہ ایک اچھی طرح سے تیار شدہ بلاک سمجھا جائے گا۔

147
00:10:20,200 --> 00:10:24,640
اچھی بات یہ ہے کہ اگر ہم اس فہرست میں سے کسی ایک بٹ کو ٹوگل کرتے ہیں، شور سے بے ترتیب غلطی

148
00:10:24,640 --> 00:10:30,600
کی نقل کرتے ہیں، پھر اگر آپ کوڈ کی اسی لائن کو چلاتے ہیں، تو یہ اس غلطی کو پرنٹ کرتا ہے۔

149
00:10:30,600 --> 00:10:31,920
کیا یہ صاف نہیں ہے؟

150
00:10:31,920 --> 00:10:37,200
آپ اس بلاک کو نیلے رنگ سے حاصل کر سکتے ہیں، اس پر اس سنگل لائن کو چلائیں، اور

151
00:10:37,200 --> 00:10:42,920
یہ خود بخود کسی غلطی کی پوزیشن کو ختم کر دے گا، یا اگر کوئی نہیں ہے تو 0۔

152
00:10:42,920 --> 00:10:45,520
اور یہاں سائز 16 کے بارے میں کچھ خاص نہیں ہے۔

153
00:10:45,520 --> 00:10:52,280
کوڈ کی ایک ہی لائن کام کرے گی اگر آپ کے پاس 256 بٹس کی فہرست ہو۔

154
00:10:52,280 --> 00:10:56,280
یہ کہنے کی ضرورت نہیں کہ یہاں لکھنے کے لیے مزید کوڈ موجود ہیں، جیسے کہ

155
00:10:56,280 --> 00:11:01,440
2 بٹ کی غلطیوں کا پتہ لگانے کے لیے میٹا پیریٹی چیک کرنا، لیکن خیال یہ

156
00:11:01,440 --> 00:11:05,080
ہے کہ ہماری اسکیم سے تقریباً تمام بنیادی منطق ایک XOR میں کمی پر آتی ہے۔

157
00:11:05,080 --> 00:11:10,600
اب، بائنری اور XORs اور عام طور پر سافٹ ویئر کے ساتھ آپ کے آرام پر منحصر ہے، آپ

158
00:11:10,600 --> 00:11:15,880
کو یا تو یہ نقطہ نظر تھوڑا سا الجھا ہوا، یا اتنا زیادہ خوبصورت اور سادہ لگ سکتا ہے

159
00:11:15,880 --> 00:11:19,320
کہ آپ سوچ رہے ہوں گے کہ ہم نے اس کے ساتھ شروع ہی کیوں نہیں کیا۔ -جاؤ.

160
00:11:19,320 --> 00:11:22,880
ڈھیلے الفاظ میں، ہارڈ ویئر میں ہیمنگ کوڈز کو براہ راست لاگو کرتے وقت ایک سے زیادہ

161
00:11:22,880 --> 00:11:27,560
برابری کی جانچ کے نقطہ نظر کے بارے میں سوچنا آسان ہے، اور XOR نقطہ نظر کے

162
00:11:27,560 --> 00:11:31,380
بارے میں سوچنا آسان ہے کہ اسے سافٹ ویئر میں کرتے وقت، ایک اعلی سطح سے۔

163
00:11:31,380 --> 00:11:35,640
پہلا اصل میں ہاتھ سے کرنا سب سے آسان ہے، اور مجھے لگتا ہے کہ یہ ان سب

164
00:11:35,640 --> 00:11:40,720
کے بنیادی وجدان کو پیدا کرنے میں ایک بہتر کام کرتا ہے، جو کہ ایک غلطی کا

165
00:11:40,720 --> 00:11:46,840
پتہ لگانے کے لیے درکار معلومات کا تعلق بلاک کے سائز کے لاگ سے ہے۔ ، یا دوسرے

166
00:11:46,840 --> 00:11:51,020
الفاظ میں، یہ ایک وقت میں تھوڑا سا بڑھتا ہے کیونکہ بلاک کا سائز دوگنا ہوتا ہے۔

167
00:11:51,020 --> 00:11:55,440
یہاں متعلقہ حقیقت یہ ہے کہ وہ معلومات براہ راست اس بات

168
00:11:55,440 --> 00:11:56,440
سے مطابقت رکھتی ہے کہ ہمیں کتنی بے کاری کی ضرورت ہے۔

169
00:11:56,440 --> 00:12:00,320
یہی وہ چیز ہے جو زیادہ تر لوگوں کے گھٹنے ٹیکنے والے ردعمل کے خلاف چلتی ہے

170
00:12:00,320 --> 00:12:05,280
جب وہ پہلی بار کسی پیغام کو غلطیوں کے لیے لچکدار بنانے کے بارے میں سوچتے ہیں،

171
00:12:05,280 --> 00:12:07,520
جہاں عام طور پر پورے پیغام کو کاپی کرنا ذہن میں آنے والی پہلی جبلت ہے۔

172
00:12:07,520 --> 00:12:11,120
اور پھر، ویسے، یہ پورا دوسرا طریقہ ہے کہ آپ کبھی کبھی ہیمنگ کوڈز کو پیش

173
00:12:11,120 --> 00:12:14,800
کرتے ہوئے دیکھتے ہیں، جہاں آپ پیغام کو ایک بڑے میٹرکس سے ضرب دیتے ہیں۔

174
00:12:14,800 --> 00:12:18,580
یہ ایک طرح کا اچھا ہے کیونکہ اس کا تعلق لکیری کوڈز کے وسیع تر خاندان سے ہے، لیکن مجھے لگتا ہے

175
00:12:18,580 --> 00:12:25,160
کہ یہ کہاں سے آتا ہے یا اس کی پیمائش کیسے ہوتی ہے اس کے بارے میں تقریباً کوئی وجدان نہیں دیتا۔

176
00:12:25,160 --> 00:12:29,340
اور اسکیلنگ کی بات کرتے ہوئے، آپ محسوس کر سکتے ہیں کہ اس اسکیم کی

177
00:12:29,340 --> 00:12:32,200
کارکردگی صرف اسی وقت بہتر ہوتی ہے جب ہم بلاک سائز میں اضافہ کرتے ہیں۔

178
00:12:32,200 --> 00:12:40,560
مثال کے طور پر، ہم نے دیکھا کہ 256 بٹس کے ساتھ، آپ اس جگہ کا صرف 3%

179
00:12:40,560 --> 00:12:43,480
فالتو پن کے لیے استعمال کر رہے ہیں، اور یہ وہاں سے بہتر ہوتا جا رہا ہے۔

180
00:12:43,480 --> 00:12:49,040
جیسے جیسے برابری بٹس کی تعداد ایک ایک کرکے بڑھتی ہے، بلاک کا سائز دوگنا ہوتا رہتا ہے۔

181
00:12:49,040 --> 00:12:53,840
اور اگر آپ اسے انتہائی حد تک لے جاتے ہیں، تو آپ کے پاس ایک ملین بٹس

182
00:12:53,840 --> 00:12:58,800
کا بلاک ہو سکتا ہے، جہاں آپ لفظی طور پر اپنے برابری کی جانچ کے ساتھ

183
00:12:58,800 --> 00:13:00,800
20 سوالات کھیل رہے ہوں گے، اور یہ صرف 21 برابری بٹس کا استعمال کرتا ہے۔

184
00:13:00,800 --> 00:13:05,760
اور اگر آپ ایک ملین بٹس کو دیکھنے اور ایک غلطی کا پتہ لگانے کے

185
00:13:05,760 --> 00:13:08,640
بارے میں سوچنے کے لئے پیچھے ہٹتے ہیں، تو یہ واقعی پاگل محسوس ہوتا ہے۔

186
00:13:08,640 --> 00:13:12,680
مسئلہ، یقیناً، یہ ہے کہ بڑے بلاک کے ساتھ، ایک یا دو سے زیادہ خرابیاں

187
00:13:12,680 --> 00:13:18,360
دیکھنے کا امکان بڑھ جاتا ہے، اور ہیمنگ کوڈز اس سے آگے کچھ نہیں سنبھالتے۔

188
00:13:18,360 --> 00:13:22,020
لہذا عملی طور پر، آپ صحیح سائز تلاش کرنا چاہتے ہیں

189
00:13:22,020 --> 00:13:25,520
تاکہ بہت زیادہ بٹ پلٹنے کا امکان بہت زیادہ نہ ہو۔

190
00:13:26,520 --> 00:13:30,920
اس کے علاوہ، عملی طور پر، غلطیاں تھوڑی دیر میں آتی ہیں، جو ایک ہی بلاک کو مکمل طور پر برباد کر

191
00:13:30,920 --> 00:13:35,680
دیتی ہیں، لہذا بہت سے مختلف بلاکس میں غلطیوں کو پھیلانے میں مدد کرنے کے لیے ایک عام حربہ یہ ہے

192
00:13:35,680 --> 00:13:41,720
کہ ان بلاکس کو آپس میں جوڑنا، اس طرح، ان کے ہونے سے پہلے۔ بھیج دیا گیا یا ذخیرہ کیا گیا۔

193
00:13:45,480 --> 00:13:49,920
پھر ایک بار پھر، اس میں سے بہت کچھ کو زیادہ جدید کوڈز کے ذریعے مکمل طور پر پیش کیا جاتا ہے، جیسے

194
00:13:49,920 --> 00:13:55,060
کہ بہت زیادہ عام طور پر استعمال ہونے والا Reed-Solomon الگورتھم، جو برسٹ کی غلطیوں کو خاص طور پر اچھی طرح سے ہینڈل

195
00:13:55,100 --> 00:13:59,580
کرتا ہے، اور اسے فی بلاک میں بڑی تعداد میں غلطیوں کے لیے لچکدار ہونے کے لیے بنایا جا سکتا ہے۔ .

196
00:13:59,580 --> 00:14:03,000
لیکن یہ کسی اور وقت کا موضوع ہے۔

197
00:14:03,000 --> 00:14:07,660
اپنی کتاب دی آرٹ آف ڈوئنگ سائنس اینڈ انجینئرنگ میں، ہیمنگ حیرت انگیز طور پر اس بات

198
00:14:07,660 --> 00:14:10,700
کے بارے میں واضح ہے کہ اس کوڈ کے بارے میں ان کی دریافت کتنی گھمبیر تھی۔

199
00:14:10,700 --> 00:14:15,180
اس نے سب سے پہلے ہر طرح کی مختلف اسکیموں کو آزمایا جس میں بٹس کو اعلی

200
00:14:15,180 --> 00:14:18,420
جہتی جالی کے حصوں میں ترتیب دینا اور اس طرح کی عجیب و غریب چیزیں شامل تھیں۔

201
00:14:18,420 --> 00:14:22,520
یہ خیال کہ اس طرح سے سازش کرنے کے لیے برابری کی جانچ پڑتال ممکن ہو سکتی

202
00:14:22,520 --> 00:14:26,360
ہے جس سے غلطی کی پوزیشن کو واضح کیا جا سکتا ہے، ہیمنگ کو صرف اس

203
00:14:26,360 --> 00:14:30,800
وقت آیا جب اس نے دوسرے تجزیوں کے ایک گروپ کے بعد پیچھے ہٹ کر پوچھا،

204
00:14:30,800 --> 00:14:32,860
ٹھیک ہے، میں سب سے زیادہ موثر کون سا ہے؟ شاید اس کے بارے میں ہو؟

205
00:14:32,860 --> 00:14:36,760
وہ اس بارے میں بھی واضح تھا کہ یہ کتنا اہم تھا کہ برابری کی جانچ پڑتال پہلے سے

206
00:14:36,760 --> 00:14:42,040
ہی اس کے ذہن میں تھی، جو آج کی نسبت 1940 کی دہائی میں بہت کم عام ہوتی۔

207
00:14:42,040 --> 00:14:46,040
اس پوری کتاب میں نصف درجن کے قریب بار ہے کہ وہ لوئس پاسچر

208
00:14:46,040 --> 00:14:49,640
کے اقتباس کا حوالہ دیتے ہیں، قسمت ایک تیار دماغ کی حمایت کرتی ہے۔

209
00:14:49,640 --> 00:14:55,120
ہوشیار خیالات اکثر پیچھے کی نظر میں دھوکے سے سادہ نظر آتے ہیں، جس کی وجہ سے ان کی قدر کرنا آسان ہو جاتا ہے۔

210
00:14:55,120 --> 00:14:59,680
ابھی میری ایماندارانہ امید یہ ہے کہ ہیمنگ کوڈز، یا کم از کم اس

211
00:14:59,680 --> 00:15:01,820
طرح کے کوڈز کا امکان، آپ کے لیے تقریباً واضح محسوس ہوتا ہے۔

212
00:15:01,820 --> 00:15:05,440
لیکن آپ کو یہ سوچ کر اپنے آپ کو بیوقوف نہیں بنانا چاہئے

213
00:15:05,440 --> 00:15:08,000
کہ وہ حقیقت میں واضح ہیں، کیونکہ وہ یقینی طور پر نہیں ہیں۔

214
00:15:08,000 --> 00:15:12,080
ہوشیار خیالات دھوکہ دہی سے آسان نظر آنے کی ایک وجہ یہ ہے کہ ہم صرف

215
00:15:12,080 --> 00:15:17,360
حتمی نتیجہ دیکھتے ہیں، جو گندا تھا اسے صاف کرتے ہیں، تمام غلط موڑ کا

216
00:15:17,360 --> 00:15:22,400
کبھی ذکر نہیں کرتے، اس بات کو کم کرتے ہیں کہ کسی مسئلے کے آغاز

217
00:15:22,400 --> 00:15:23,980
میں قابل دریافت امکانات کی جگہ کتنی وسیع ہے۔ حل کرنے کا عمل، یہ سب۔

218
00:15:23,980 --> 00:15:25,280
لیکن یہ عام طور پر سچ ہے۔

219
00:15:25,280 --> 00:15:29,880
میرے خیال میں کچھ خاص ایجادات کے لیے، ایک دوسری،

220
00:15:29,880 --> 00:15:31,040
گہری وجہ ہے کہ ہم ان کی قدر نہیں کرتے۔

221
00:15:31,040 --> 00:15:35,040
بٹس کے لحاظ سے معلومات کے بارے میں سوچنا صرف 1948 تک ایک مکمل تھیوری میں

222
00:15:35,040 --> 00:15:39,400
یکجا ہو گیا تھا، جس میں انفارمیشن تھیوری پر کلاڈ شینن کا سیمینل پیپر تھا۔

223
00:15:39,400 --> 00:15:43,400
یہ بنیادی طور پر اس کے ساتھ ہم آہنگ تھا جب ہیمنگ نے اپنا الگورتھم تیار کیا۔

224
00:15:43,440 --> 00:15:47,300
یہ وہی بنیادی کاغذ تھا جس نے ظاہر کیا، ایک خاص معنوں

225
00:15:47,300 --> 00:15:52,080
میں، غلطی کی مؤثر اصلاح ہمیشہ ممکن ہے، چاہے بٹ پلٹنے

226
00:15:52,080 --> 00:15:53,920
کا امکان کتنا ہی زیادہ ہو، کم از کم تھیوری میں۔

227
00:15:53,920 --> 00:15:58,120
شینن اور ہیمنگ، ویسے، بہت مختلف چیزوں پر کام کرنے کے باوجود، بیل لیبز

228
00:15:58,120 --> 00:16:02,400
میں ایک دفتر کا اشتراک کرتے ہیں، جو یہاں شاید ہی اتفاقیہ لگیں۔

229
00:16:02,400 --> 00:16:06,960
کئی دہائیوں سے تیزی سے آگے بڑھیں، اور ان دنوں، ہم میں سے بہت سے لوگ بٹس اور معلومات کے بارے میں

230
00:16:06,960 --> 00:16:13,080
سوچنے میں اتنے ڈوبے ہوئے ہیں کہ یہ نظر انداز کرنا آسان ہے کہ سوچنے کا یہ طریقہ کتنا الگ تھا۔

231
00:16:13,080 --> 00:16:17,920
ستم ظریفی یہ ہے کہ وہ خیالات جو سب سے زیادہ گہرائی سے ان طریقوں کو تشکیل دیتے ہیں جن کے بارے

232
00:16:17,920 --> 00:16:22,640
میں ایک آنے والی نسل سوچتی ہے کہ وہ اس آنے والی نسل کو حقیقت سے کہیں زیادہ آسان نظر آئیں گے۔

