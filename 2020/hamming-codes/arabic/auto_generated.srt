1
00:00:00,000 --> 00:00:03,120
أفترض أن الجميع هنا قادمون من الجزء الأول.

2
00:00:03,120 --> 00:00:06,920
كنا نتحدث عن رموز هامينج، وهي طريقة لإنشاء كتلة من البيانات

3
00:00:06,920 --> 00:00:11,640
حيث تحمل معظم البتات رسالة ذات معنى، بينما يعمل عدد قليل

4
00:00:11,640 --> 00:00:15,800
آخر كنوع من التكرار، بطريقة بحيث إذا تم قلب أي جزء،

5
00:00:15,800 --> 00:00:20,560
إما رسالة بت أو بت متكرر، أي شيء في هذه الكتلة،

6
00:00:20,560 --> 00:00:21,920
سيكون جهاز الاستقبال قادرًا على تحديد وجود خطأ، وكيفية إصلاحه.

7
00:00:21,920 --> 00:00:25,900
كانت الفكرة الأساسية المقدمة هناك هي كيفية استخدام عمليات التحقق

8
00:00:25,900 --> 00:00:29,800
من التكافؤ المتعددة للبحث الثنائي في طريقك إلى الخطأ.

9
00:00:29,800 --> 00:00:33,920
كان الهدف في هذا الفيديو هو جعل رموز

10
00:00:33,920 --> 00:00:35,420
هامينج تبدو عملية وقابلة لإعادة الاكتشاف قدر الإمكان.

11
00:00:35,420 --> 00:00:40,040
ولكن عندما تبدأ في التفكير في تنفيذ هذا فعليًا، سواء في البرامج أو الأجهزة،

12
00:00:40,040 --> 00:00:44,120
فإن هذا الإطار قد يقلل في الواقع من مدى أناقة هذه الرموز حقًا.

13
00:00:44,120 --> 00:00:47,620
قد تظن أنك بحاجة إلى كتابة خوارزمية تتتبع جميع مواقع

14
00:00:47,620 --> 00:00:52,320
الأخطاء المحتملة وتقطع تلك المجموعة إلى النصف مع كل

15
00:00:52,320 --> 00:00:54,160
عملية تحقق، ولكنها في الواقع أبسط من ذلك بكثير.

16
00:00:54,160 --> 00:00:58,720
إذا قرأت الإجابات على عمليات التحقق من التكافؤ الأربعة التي قمنا بها في الفيديو الأخير، كلها

17
00:00:58,760 --> 00:01:04,800
كـ 1 و0 بدلاً من نعم ولا، فإنها توضح حرفيًا موضع الخطأ في النظام الثنائي.

18
00:01:04,800 --> 00:01:10,160
على سبيل المثال، الرقم 7 في النظام الثنائي يبدو مثل

19
00:01:10,160 --> 00:01:12,640
0111، مما يعني أنه 4 زائد 2 زائد 1.

20
00:01:12,640 --> 00:01:17,960
ولاحظ أين يقع الموضع 7، فهو يؤثر بالفعل على المجموعة

21
00:01:17,960 --> 00:01:22,280
الأولى من مجموعات التكافؤ، والثانية، والثالثة، ولكن ليس الأخيرة.

22
00:01:22,280 --> 00:01:26,560
لذا فإن قراءة نتائج عمليات التحقق الأربعة هذه

23
00:01:26,560 --> 00:01:28,000
من الأسفل إلى الأعلى توضح بالفعل موضع الخطأ.

24
00:01:28,520 --> 00:01:32,240
لا يوجد شيء خاص في المثال 7، وهذا يعمل بشكل عام،

25
00:01:32,240 --> 00:01:37,440
وهذا يجعل منطق تنفيذ المخطط بأكمله في الأجهزة بسيطًا بشكل صادم.

26
00:01:37,440 --> 00:01:43,380
الآن إذا كنت تريد معرفة سبب حدوث هذا السحر، فخذ تسميات

27
00:01:43,380 --> 00:01:48,480
الفهرس الستة عشر هذه لمواقعنا، ولكن بدلاً من كتابتها في الأساس

28
00:01:48,480 --> 00:01:50,720
10، دعنا نكتبها جميعًا بالنظام الثنائي، بدءًا من 0000 حتى 1111.

29
00:01:50,720 --> 00:01:55,880
عندما نعيد هذه التصنيفات الثنائية إلى صناديقها، اسمحوا لي أن

30
00:01:56,080 --> 00:01:58,440
أؤكد أنها مختلفة عن البيانات التي يتم إرسالها بالفعل.

31
00:01:58,440 --> 00:02:02,200
إنها ليست أكثر من مجرد تسمية مفاهيمية لمساعدتي ومساعدتك

32
00:02:02,200 --> 00:02:04,200
في فهم من أين أتت مجموعات التكافؤ الأربع.

33
00:02:04,200 --> 00:02:08,840
ربما يتم تقويض أناقة الحصول على كل ما نتطلع إليه موصوفًا في النظام الثنائي

34
00:02:08,840 --> 00:02:13,160
بسبب الارتباك المتمثل في وجود كل ما نتطلع إليه موصوفًا في النظام الثنائي.

35
00:02:13,160 --> 00:02:15,040
إنه يستحق ذلك، على الرغم من ذلك.

36
00:02:15,040 --> 00:02:20,740
ركز انتباهك فقط على الجزء الأخير من كل هذه التسميات، ثم قم

37
00:02:20,740 --> 00:02:24,280
بتسليط الضوء على المواضع التي يكون فيها الجزء الأخير هو 1.

38
00:02:24,280 --> 00:02:28,800
ما حصلنا عليه هو المجموعة الأولى من مجموعات التكافؤ الأربع لدينا، مما

39
00:02:28,800 --> 00:02:34,480
يعني أنه يمكنك تفسير هذا التحقق الأول كسؤال، مهلاً، إذا كان

40
00:02:34,480 --> 00:02:36,680
هناك خطأ، فهل البت الأخير في موضع هذا الخطأ هو 1؟

41
00:02:36,680 --> 00:02:42,600
وبالمثل، إذا ركزت على الجزء الثاني قبل الأخير، وقمت بتمييز جميع المواضع

42
00:02:42,600 --> 00:02:47,040
التي يكون فيها الرقم 1، فستحصل على مجموعة التكافؤ الثانية من مخططنا.

43
00:02:47,040 --> 00:02:51,960
بمعنى آخر، هذا الفحص الثاني يسألني مرة أخرى، إذا كان هناك

44
00:02:51,960 --> 00:02:56,160
خطأ، فهل الجزء الثاني قبل الأخير من هذا الموضع هو 1؟

45
00:02:56,160 --> 00:02:57,160
وما إلى ذلك وهلم جرا.

46
00:02:57,160 --> 00:03:03,320
يغطي فحص التكافؤ الثالث كل موضع تم تشغيل البت من الثالث إلى الأخير،

47
00:03:03,320 --> 00:03:10,120
ويغطي الأخير المواضع الثمانية الأخيرة، تلك التي يكون أعلى بت لها هو 1.

48
00:03:10,120 --> 00:03:15,680
كل ما فعلناه سابقًا هو نفس الإجابة على هذه الأسئلة

49
00:03:15,680 --> 00:03:18,800
الأربعة، والتي بدورها هي نفس توضيح الموضع في النظام الثنائي.

50
00:03:19,800 --> 00:03:22,080
آمل أن يجعل هذا شيئين أكثر وضوحا.

51
00:03:22,080 --> 00:03:27,140
الأول هو كيفية التعميم بشكل منهجي على أحجام الكتل التي تكون أكبر من قوى اثنين.

52
00:03:27,140 --> 00:03:33,180
إذا كان الأمر يتطلب المزيد من البتات لوصف كل موضع، مثل ستة بتات لوصف 64 نقطة،

53
00:03:33,180 --> 00:03:38,640
فإن كل واحدة من هذه البتات تمنحك إحدى مجموعات التكافؤ التي نحتاج إلى التحقق منها.

54
00:03:38,640 --> 00:03:42,060
أولئك منكم الذين شاهدوا لغز رقعة الشطرنج الذي قمت به

55
00:03:42,060 --> 00:03:43,400
مع مات باركر قد يجدون كل هذا مألوفًا للغاية.

56
00:03:43,400 --> 00:03:48,200
إنه نفس المنطق الأساسي، لكنه يحل مشكلة مختلفة، ويتم

57
00:03:48,200 --> 00:03:49,880
تطبيقه على رقعة شطرنج مكونة من 64 مربعًا.

58
00:03:49,880 --> 00:03:54,000
الأمر الثاني الذي آمل أن يوضحه هذا هو سبب وجود بتات التكافؤ لدينا

59
00:03:54,000 --> 00:03:58,320
في مواضع تمثل قوى العدد اثنين، على سبيل المثال 1 و2 و4 و8.

60
00:03:58,320 --> 00:04:03,640
هذه هي المواضع التي تم تشغيل تمثيلها الثنائي بمقدار بت واحد فقط.

61
00:04:03,640 --> 00:04:09,000
ما يعنيه ذلك هو أن كل واحدة من بتات التكافؤ

62
00:04:09,000 --> 00:04:12,640
هذه تقع داخل مجموعة واحدة فقط من مجموعات التكافؤ الأربع.

63
00:04:12,640 --> 00:04:16,840
يمكنك أيضًا رؤية ذلك في أمثلة أكبر، حيث بغض النظر عن حجمها،

64
00:04:16,840 --> 00:04:25,920
فإن كل بتة تكافؤ تلامس بسهولة مجموعة واحدة فقط من المجموعات.

65
00:04:25,920 --> 00:04:29,680
بمجرد أن تفهم أن عمليات التحقق من التكافؤ هذه التي ركزنا

66
00:04:29,680 --> 00:04:34,320
عليها كثيرًا من وقتنا ليست أكثر من طريقة ذكية لتوضيح موضع

67
00:04:34,320 --> 00:04:37,880
الخطأ في النظام الثنائي، فيمكننا بعد ذلك رسم اتصال بطريقة مختلفة

68
00:04:37,880 --> 00:04:42,160
للتفكير في الهام الرموز، التي يمكن القول إنها أبسط بكثير وأكثر

69
00:04:42,160 --> 00:04:43,880
أناقة، والتي يمكن كتابتها أساسًا باستخدام سطر واحد من التعليمات البرمجية.

70
00:04:43,920 --> 00:04:46,200
يعتمد على وظيفة XOR.

71
00:04:46,200 --> 00:04:50,960
XOR، لأولئك منكم الذين لا يعرفون، يرمز إلى حصري أو.

72
00:04:50,960 --> 00:04:55,440
عندما تأخذ XOR لبتين، فسوف يُرجع 1 إذا تم تشغيل أي من

73
00:04:55,440 --> 00:05:00,200
تلك البتات، ولكن ليس إذا تم تشغيل كليهما أو إيقاف تشغيلهما.

74
00:05:00,200 --> 00:05:03,760
بصياغة مختلفة، إنه التكافؤ بين هاتين القطعتين.

75
00:05:03,760 --> 00:05:07,840
باعتباري متخصصًا في الرياضيات، أفضّل التفكير في الأمر على أنه تعديل الإضافة 2.

76
00:05:07,840 --> 00:05:12,000
نتحدث أيضًا بشكل شائع عن XOR لسلسلتين مختلفتين من البتات،

77
00:05:12,040 --> 00:05:14,040
والتي تقوم بشكل أساسي بتنفيذ هذا المكون تلو الآخر.

78
00:05:14,040 --> 00:05:16,280
إنها مثل الإضافة، ولكن حيث لا تحملها أبدًا.

79
00:05:16,280 --> 00:05:21,240
مرة أخرى، قد يفضل الأشخاص الأكثر ميلاً للرياضيات التفكير

80
00:05:21,240 --> 00:05:23,520
في هذا على أنه إضافة متجهين وتقليل التعديل 2.

81
00:05:23,520 --> 00:05:28,720
إذا قمت بفتح بعض لغة Python الآن وقمت بتطبيق عملية علامة الإقحام بين عددين

82
00:05:28,720 --> 00:05:35,400
صحيحين، فهذا ما تفعله ولكن على تمثيلات البت لتلك الأرقام الموجودة أسفل الغطاء.

83
00:05:35,400 --> 00:05:40,920
النقطة الأساسية بالنسبة لي ولكم هي أن أخذ XOR للعديد من سلاسل

84
00:05:40,960 --> 00:05:45,960
البت المختلفة هو وسيلة فعالة لحساب المحاكاة الساخرة لمجموعة من المجموعات

85
00:05:45,960 --> 00:05:51,320
المنفصلة، كما هو الحال مع الأعمدة، كل ذلك في ضربة واحدة.

86
00:05:51,320 --> 00:05:54,520
وهذا يمنحنا طريقة رائعة إلى حد ما للتفكير في عمليات التحقق من التكافؤ المتعددة

87
00:05:54,520 --> 00:05:59,680
من خوارزمية كود هامينج الخاصة بنا حيث يتم تجميعها جميعًا معًا في عملية واحدة.

88
00:05:59,680 --> 00:06:02,800
على الرغم من أنها تبدو للوهلة الأولى مختلفة تمامًا.

89
00:06:02,800 --> 00:06:08,360
اكتب على وجه التحديد المواضع الستة عشر في النظام الثنائي، كما فعلنا من

90
00:06:08,640 --> 00:06:14,800
قبل، وقم الآن بتمييز المواضع التي تم فيها تشغيل بت الرسالة إلى

91
00:06:14,800 --> 00:06:19,400
1، ثم قم بتجميع هذه المواضع في عمود واحد كبير وأخذ XOR.

92
00:06:19,400 --> 00:06:23,480
ربما يمكنك تخمين أن البتات الأربعة الموجودة في الأسفل نتيجة

93
00:06:23,480 --> 00:06:27,480
لذلك هي نفس عمليات التحقق من التكافؤ الأربعة التي

94
00:06:27,480 --> 00:06:32,720
عرفناها ونحبها، ولكن خذ لحظة للتفكير في السبب بالضبط.

95
00:06:32,720 --> 00:06:37,880
هذا العمود الأخير، على سبيل المثال، يقوم بإحصاء جميع المواضع التي يكون الجزء

96
00:06:38,400 --> 00:06:42,400
الأخير منها هو 1، ولكننا يقتصرون بالفعل على المواضع المميزة فقط، لذا

97
00:06:42,400 --> 00:06:45,960
فهو يحسب فعليًا عدد المواضع المميزة التي جاءت من مجموعة التكافؤ الأولى.

98
00:06:45,960 --> 00:06:48,520
هل هذا منطقي؟

99
00:06:48,520 --> 00:06:53,600
وبالمثل، يقوم العمود التالي بحساب عدد المواضع الموجودة في مجموعة

100
00:06:53,600 --> 00:06:59,640
التكافؤ الثانية، والمواضع التي يكون البت الثاني قبل الأخير

101
00:06:59,640 --> 00:07:00,640
هو 1، والتي يتم تمييزها أيضًا، وما إلى ذلك.

102
00:07:00,640 --> 00:07:06,640
إنه في الحقيقة مجرد تحول بسيط في المنظور حول نفس الشيء الذي كنا نفعله.

103
00:07:07,640 --> 00:07:10,000
وهكذا تعرف إلى أين يتجه الأمر من هنا.

104
00:07:10,000 --> 00:07:14,400
يكون المرسل مسؤولاً عن تبديل بعض بتات التكافؤ

105
00:07:14,400 --> 00:07:19,640
الخاصة للتأكد من أن المبلغ يصل إلى 0000.

106
00:07:19,640 --> 00:07:23,600
الآن، بمجرد أن يصبح الأمر بهذا الشكل، فهذا يمنحنا طريقة رائعة للتفكير في

107
00:07:23,600 --> 00:07:28,720
السبب وراء توضيح هذه البتات الأربعة الناتجة في الأسفل موضع الخطأ بشكل مباشر.

108
00:07:28,720 --> 00:07:32,680
لنفترض أنه تم تبديل جزء ما في هذه الكتلة من 0 إلى 1.

109
00:07:32,720 --> 00:07:37,320
ما يعنيه ذلك هو أن موضع هذا البت سيتم الآن

110
00:07:37,320 --> 00:07:42,960
تضمينه في إجمالي XOR، مما يغير المجموع من 0 إلى

111
00:07:42,960 --> 00:07:44,800
هذه القيمة المضمنة حديثًا بدلاً من ذلك، وهو موضع الخطأ.

112
00:07:44,800 --> 00:07:48,800
وبشكل أقل وضوحًا، ينطبق الأمر نفسه إذا كان

113
00:07:48,800 --> 00:07:49,800
هناك خطأ يؤدي إلى تغيير 1 إلى 0.

114
00:07:49,800 --> 00:07:54,720
كما ترى، إذا قمت بإضافة سلسلة صغيرة معًا مرتين، فهذا يعني عدم

115
00:07:54,720 --> 00:07:59,000
وجودها على الإطلاق، لأنه في هذا العالم 1 زائد 1 يساوي 0.

116
00:07:59,000 --> 00:08:03,720
لذا فإن إضافة نسخة من هذا الموضع إلى

117
00:08:03,720 --> 00:08:05,400
المجموع الإجمالي له نفس التأثير الذي نحركه به.

118
00:08:05,400 --> 00:08:10,080
وهذا التأثير، مرة أخرى، هو أن النتيجة

119
00:08:10,080 --> 00:08:13,480
الإجمالية في الأسفل توضح موضع الخطأ.

120
00:08:13,480 --> 00:08:17,720
لتوضيح مدى روعة هذا الأمر، اسمحوا لي أن أعرض سطرًا واحدًا من كود بايثون

121
00:08:17,720 --> 00:08:22,120
الذي أشرت إليه من قبل، والذي سيلتقط تقريبًا كل المنطق في نهاية المتلقي.

122
00:08:22,120 --> 00:08:27,160
سنبدأ بإنشاء مصفوفة عشوائية مكونة من 16 1 و0 لمحاكاة كتلة

123
00:08:27,160 --> 00:08:31,160
البيانات، وسأعطيها بتات الاسم، ولكن بالطبع من الناحية العملية سيكون

124
00:08:31,160 --> 00:08:36,160
هذا شيئًا نتلقاه من المرسل، وبدلاً من ذلك نظرًا لكونها

125
00:08:36,160 --> 00:08:38,600
عشوائية، فإنها ستحمل 11 بتة بيانات مع 5 بتات تكافؤ.

126
00:08:38,600 --> 00:08:43,160
إذا قمت باستدعاء الدالة enumerateBits، فإن ما تفعله هو إقران كل من تلك

127
00:08:43,160 --> 00:08:48,240
البتات مع فهرس مناظر، في هذه الحالة يعمل من 0 إلى 15.

128
00:08:48,240 --> 00:08:53,200
لذا، إذا قمنا بعد ذلك بإنشاء قائمة تدور حول كل هذه الأزواج، الأزواج

129
00:08:53,200 --> 00:08:59,160
التي تبدو مثل i، ثم قمنا بسحب قيمة i فقط، فقط الفهرس،

130
00:08:59,160 --> 00:09:01,920
حسنًا، الأمر ليس مثيرًا، سنستعيد تلك المؤشرات من 0 إلى 15 .

131
00:09:01,920 --> 00:09:07,520
ولكن إذا أضفنا شرطًا للقيام بذلك فقط إذا كانت البتة، مما يعني أنه إذا كانت تلك

132
00:09:07,520 --> 00:09:13,400
البتة هي 1 وليس 0، فحسنًا فإنها تسحب فقط المواضع التي يتم فيها تشغيل البتة المقابلة.

133
00:09:13,400 --> 00:09:20,320
في هذه الحالة يبدو أن هذه المواضع هي 0، 4، 6، 9، إلخ.

134
00:09:20,720 --> 00:09:24,640
ما نريده هو جمع كل تلك المواضع معًا،

135
00:09:24,640 --> 00:09:29,960
مواضع البتات التي تم تشغيلها، ثم XOR معًا.

136
00:09:29,960 --> 00:09:33,960
للقيام بذلك في بايثون، اسمحوا لي أولاً باستيراد وظيفتين مفيدتين.

137
00:09:33,960 --> 00:09:39,140
بهذه الطريقة يمكننا استدعاء الدالة تقليل() في هذه القائمة، واستخدام الدالة XOR لتقليلها.

138
00:09:39,140 --> 00:09:44,840
وهذا في الأساس يشق طريقه عبر القائمة، ويأخذ XORs على طول الطريق.

139
00:09:44,840 --> 00:09:48,760
إذا كنت تفضل ذلك، يمكنك كتابة دالة XOR

140
00:09:48,800 --> 00:09:52,200
بوضوح دون الحاجة إلى استيرادها من أي مكان.

141
00:09:52,200 --> 00:09:56,880
لذا، في الوقت الحالي، يبدو أننا إذا فعلنا ذلك على الكتلة العشوائية

142
00:09:56,880 --> 00:10:02,080
المكونة من 16 بت، فإنها ستُرجع 9، والتي لها التمثيل الثنائي 1001.

143
00:10:02,080 --> 00:10:05,960
لن نفعل ذلك هنا، ولكن يمكنك كتابة دالة يستخدم فيها المرسل هذا التمثيل الثنائي لتعيين

144
00:10:05,960 --> 00:10:11,560
وحدات البت التماثلية الأربعة حسب الحاجة، وفي النهاية توصيل هذه الكتلة إلى حالة حيث

145
00:10:11,560 --> 00:10:16,200
يؤدي تشغيل هذا السطر من التعليمات البرمجية على القائمة الكاملة للبتات إلى إرجاعها 0.

146
00:10:17,200 --> 00:10:20,200
سيتم اعتبار هذا كتلة جيدة الإعداد.

147
00:10:20,200 --> 00:10:24,640
الأمر الرائع هو أنه إذا قمنا بتبديل أي من البتات في هذه القائمة، لمحاكاة خطأ عشوائي

148
00:10:24,640 --> 00:10:30,600
من الضوضاء، ثم إذا قمت بتشغيل نفس السطر من التعليمات البرمجية، فإنه يطبع هذا الخطأ.

149
00:10:30,600 --> 00:10:31,920
أليس هذا أنيق؟

150
00:10:31,920 --> 00:10:37,200
يمكنك الحصول على هذه الكتلة فجأة، وتشغيل هذا السطر الفردي عليها، وسيظهر

151
00:10:37,200 --> 00:10:42,920
تلقائيًا موضع الخطأ، أو 0 إذا لم يكن هناك أي خطأ.

152
00:10:42,920 --> 00:10:45,520
وليس هناك شيء خاص بخصوص الحجم 16 هنا.

153
00:10:45,520 --> 00:10:52,280
سيعمل نفس السطر من التعليمات البرمجية إذا كان لديك قائمة، على سبيل المثال، 256 بت.

154
00:10:52,280 --> 00:10:56,280
وغني عن القول أن هناك المزيد من التعليمات البرمجية التي يجب كتابتها هنا،

155
00:10:56,280 --> 00:11:01,440
مثل إجراء فحص التكافؤ التعريفي لاكتشاف أخطاء 2 بت، ولكن الفكرة هي

156
00:11:01,440 --> 00:11:05,080
أن كل المنطق الأساسي تقريبًا من مخططنا يعود إلى تقليل XOR واحد.

157
00:11:05,080 --> 00:11:10,600
الآن، اعتمادًا على راحتك مع الثنائيات وXORs والبرامج بشكل عام، قد

158
00:11:10,600 --> 00:11:15,880
تجد هذا المنظور مربكًا بعض الشيء، أو أكثر أناقة وبساطة

159
00:11:15,880 --> 00:11:19,320
لدرجة أنك تتساءل لماذا لم نبدأ به من البداية -يذهب.

160
00:11:19,320 --> 00:11:22,880
بشكل عام، من الأسهل التفكير في منظور التحقق من التكافؤ المتعدد عند

161
00:11:22,880 --> 00:11:27,560
تنفيذ رموز Hamming في الأجهزة بشكل مباشر جدًا، ومن الأسهل التفكير في

162
00:11:27,560 --> 00:11:31,380
منظور XOR عند القيام بذلك في البرامج، من مستوى أعلى نوعًا ما.

163
00:11:31,380 --> 00:11:35,640
الأول هو الأسهل في الواقع للقيام به يدويًا، وأعتقد أنه يقوم بعمل

164
00:11:35,640 --> 00:11:40,720
أفضل في غرس الحدس الأساسي الكامن وراء كل هذا، وهو أن المعلومات

165
00:11:40,720 --> 00:11:46,840
المطلوبة لتحديد موقع خطأ واحد مرتبطة بسجل حجم الكتلة أو بعبارة أخرى،

166
00:11:46,840 --> 00:11:51,020
فإنه ينمو قطعة واحدة في كل مرة مع تضاعف حجم الكتلة.

167
00:11:51,020 --> 00:11:55,440
الحقيقة ذات الصلة هنا هي أن هذه المعلومات

168
00:11:55,440 --> 00:11:56,440
تتوافق بشكل مباشر مع مقدار التكرار الذي نحتاجه.

169
00:11:56,440 --> 00:12:00,320
وهذا حقًا ما يتعارض مع رد فعل معظم الأشخاص غير المحسوبين

170
00:12:00,320 --> 00:12:05,280
عندما يفكرون لأول مرة في جعل رسالة مقاومة للأخطاء، حيث عادةً

171
00:12:05,280 --> 00:12:07,520
ما يكون نسخ الرسالة بأكملها هو أول غريزة تتبادر إلى ذهنهم.

172
00:12:07,520 --> 00:12:11,120
وبعد ذلك، بالمناسبة، هناك طريقة أخرى تمامًا حيث ترى أحيانًا رموز

173
00:12:11,120 --> 00:12:14,800
هامينج معروضة، حيث تقوم بضرب الرسالة في مصفوفة واحدة كبيرة.

174
00:12:14,800 --> 00:12:18,580
إنه لطيف نوعًا ما لأنه يرتبط بعائلة أوسع من الرموز الخطية، لكنني أعتقد

175
00:12:18,580 --> 00:12:25,160
أن هذا لا يعطي أي فكرة تقريبًا عن مصدرها أو كيفية قياسها.

176
00:12:25,160 --> 00:12:29,340
وبالحديث عن القياس، قد تلاحظ أن كفاءة هذا

177
00:12:29,340 --> 00:12:32,200
المخطط تتحسن فقط عندما نزيد حجم الكتلة.

178
00:12:32,200 --> 00:12:40,560
على سبيل المثال، رأينا أنه مع 256 بت، فإنك تستخدم 3%

179
00:12:40,560 --> 00:12:43,480
فقط من تلك المساحة للتكرار، ويستمر الأمر في التحسن من هناك.

180
00:12:43,480 --> 00:12:49,040
ومع زيادة عدد البتات المتماثلة واحدة تلو الأخرى، يستمر حجم الكتلة في التضاعف.

181
00:12:49,040 --> 00:12:53,840
وإذا أخذت ذلك إلى أقصى الحدود، يمكن أن يكون لديك كتلة

182
00:12:53,840 --> 00:12:58,800
تحتوي، على سبيل المثال، على مليون بت، حيث يمكنك حرفيًا تشغيل

183
00:12:58,800 --> 00:13:00,800
20 سؤالًا مع اختبارات التكافؤ الخاصة بك، وتستخدم 21 بتة فقط.

184
00:13:00,800 --> 00:13:05,760
وإذا عدت إلى الوراء للتفكير في النظر إلى مليون بت

185
00:13:05,760 --> 00:13:08,640
وتحديد موقع خطأ واحد، فإن هذا يبدو جنونًا حقًا.

186
00:13:08,640 --> 00:13:12,680
المشكلة بالطبع هي أنه مع وجود كتلة أكبر، فإن احتمال رؤية أكثر من خطأ واحد

187
00:13:12,680 --> 00:13:18,360
أو اثنين من الأخطاء، ولا تتعامل رموز هامينج مع أي شيء أبعد من ذلك.

188
00:13:18,360 --> 00:13:22,020
لذا، من الناحية العملية، ما تريده هو العثور على الحجم المناسب بحيث

189
00:13:22,020 --> 00:13:25,520
لا يكون احتمال حدوث عدد كبير جدًا من تقلبات البتات مرتفعًا جدًا.

190
00:13:26,520 --> 00:13:30,920
أيضًا، من الناحية العملية، تميل الأخطاء إلى الظهور على شكل دفعات صغيرة، مما قد يؤدي إلى تدمير

191
00:13:30,920 --> 00:13:35,680
كتلة واحدة تمامًا، لذا فإن أحد الأساليب الشائعة للمساعدة في نشر موجة من الأخطاء عبر العديد

192
00:13:35,680 --> 00:13:41,720
من الكتل المختلفة هو تشبيك تلك الكتل، مثل هذا، قبل أن يتم دمجها إرسالها أو تخزينها.

193
00:13:45,480 --> 00:13:49,920
ثم مرة أخرى، أصبح الكثير من هذا موضع نقاش تمامًا من خلال أكواد أكثر

194
00:13:49,920 --> 00:13:55,060
حداثة، مثل خوارزمية Reed-Solomon الأكثر استخدامًا، والتي تتعامل مع أخطاء الاندفاع بشكل جيد، ويمكن

195
00:13:55,100 --> 00:13:59,580
ضبطها لتكون مرنة في التعامل مع عدد أكبر من الأخطاء لكل كتلة .

196
00:13:59,580 --> 00:14:03,000
ولكن هذا موضوع لوقت آخر.

197
00:14:03,000 --> 00:14:07,660
في كتابه &quot;فن ممارسة العلوم والهندسة&quot;، كان هامينغ صريحًا

198
00:14:07,660 --> 00:14:10,700
بشكل رائع حول مدى تعقيد اكتشافه لهذا الرمز.

199
00:14:10,700 --> 00:14:15,180
لقد جرب أولاً جميع أنواع المخططات المختلفة التي تتضمن تنظيم البتات

200
00:14:15,180 --> 00:14:18,420
إلى أجزاء من شبكة ذات أبعاد أعلى وأشياء غريبة مثل هذه.

201
00:14:18,420 --> 00:14:22,520
فكرة أنه قد يكون من الممكن الحصول على فحوصات التكافؤ للتآمر

202
00:14:22,520 --> 00:14:26,360
بطريقة توضح موضع الخطأ جاءت إلى هامينج فقط عندما تراجع

203
00:14:26,360 --> 00:14:30,800
بعد مجموعة من التحليلات الأخرى وسأل، حسنًا، ما هو الأكثر

204
00:14:30,800 --> 00:14:32,860
كفاءة الذي يمكنني فعله من الممكن أن يكون حول هذا؟

205
00:14:32,860 --> 00:14:36,760
وكان صريحًا أيضًا بشأن مدى أهمية وجود ضوابط التكافؤ في ذهنه بالفعل،

206
00:14:36,760 --> 00:14:42,040
وهو الأمر الذي كان أقل شيوعًا في الأربعينيات مما هو عليه اليوم.

207
00:14:42,040 --> 00:14:46,040
هناك حوالي ست مرات خلال هذا الكتاب يشير فيها

208
00:14:46,040 --> 00:14:49,640
إلى مقولة لويس باستور، الحظ يفضل العقل المستعد.

209
00:14:49,640 --> 00:14:55,120
غالبًا ما تبدو الأفكار الذكية بسيطة بشكل خادع بعد فوات الأوان، مما يجعل من السهل التقليل من قيمتها.

210
00:14:55,120 --> 00:14:59,680
في الوقت الحالي، أملي الصادق هو أن تكون رموز هامينج، أو

211
00:14:59,680 --> 00:15:01,820
على الأقل إمكانية وجود مثل هذه الرموز، واضحة تقريبًا بالنسبة لك.

212
00:15:01,820 --> 00:15:05,440
لكن لا ينبغي أن تخدع نفسك بالاعتقاد

213
00:15:05,440 --> 00:15:08,000
بأنها واضحة بالفعل، لأنها بالتأكيد ليست كذلك.

214
00:15:08,000 --> 00:15:12,080
جزء من السبب الذي يجعل الأفكار الذكية تبدو سهلة بشكل خادع

215
00:15:12,080 --> 00:15:17,360
هو أننا لا نرى سوى النتيجة النهائية، وننظف ما كان فوضويًا،

216
00:15:17,360 --> 00:15:22,400
ولا نذكر أبدًا كل المنعطفات الخاطئة، ونقلل من مدى اتساع مساحة

217
00:15:22,400 --> 00:15:23,980
الإمكانيات القابلة للاستكشاف في بداية المشكلة. عملية الحل، كل ذلك.

218
00:15:23,980 --> 00:15:25,280
ولكن هذا صحيح بشكل عام.

219
00:15:25,280 --> 00:15:29,880
أعتقد أنه بالنسبة لبعض الاختراعات الخاصة، هناك

220
00:15:29,880 --> 00:15:31,040
سبب ثانٍ وأعمق لعدم تقديرنا لها.

221
00:15:31,040 --> 00:15:35,040
إن التفكير في المعلومات من حيث البتات قد اندمج فعليًا في نظرية

222
00:15:35,040 --> 00:15:39,400
كاملة بحلول عام 1948، مع ورقة كلود شانون الأساسية حول نظرية المعلومات.

223
00:15:39,400 --> 00:15:43,400
كان هذا متزامنًا بشكل أساسي مع قيام هامينج بتطوير خوارزميته.

224
00:15:43,440 --> 00:15:47,300
كانت هذه هي نفس الورقة التأسيسية التي أظهرت، إلى حد

225
00:15:47,300 --> 00:15:52,080
ما، أن التصحيح الفعال للأخطاء أمر ممكن دائمًا، بغض النظر

226
00:15:52,080 --> 00:15:53,920
عن مدى احتمالية قلب البتات، على الأقل من الناحية النظرية.

227
00:15:53,920 --> 00:15:58,120
بالمناسبة، كان شانون وهامينج يشتركان في مكتب واحد في Bell Labs، على الرغم من

228
00:15:58,120 --> 00:16:02,400
العمل على أشياء مختلفة تمامًا، وهو الأمر الذي لا يبدو من قبيل الصدفة هنا.

229
00:16:02,400 --> 00:16:06,960
بعد مرور عدة عقود، وفي هذه الأيام، الكثير منا منغمسون جدًا في التفكير في

230
00:16:06,960 --> 00:16:13,080
أجزاء ومعلومات، مما يجعل من السهل التغاضي عن مدى تميز طريقة التفكير هذه.

231
00:16:13,080 --> 00:16:17,920
ومن عجيب المفارقات أن الأفكار التي تشكل بشكل أعمق الطرق التي يفكر بها جيل المستقبل

232
00:16:17,920 --> 00:16:22,640
ستنتهي في النهاية إلى النظر إلى جيل المستقبل بشكل أبسط مما هو عليه بالفعل.

