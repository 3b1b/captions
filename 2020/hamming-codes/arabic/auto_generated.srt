1
00:00:00,000 --> 00:00:02,560
أفترض أن الجميع هنا قادمون من الجزء الأول. 

2
00:00:03,060 --> 00:00:07,540
كنا نتحدث عن رموز هامينج، وهي طريقة لإنشاء كتلة من البيانات حيث تحمل 

3
00:00:07,540 --> 00:00:12,020
معظم البتات رسالة ذات معنى، بينما يعمل عدد قليل آخر كنوع من التكرار، 

4
00:00:12,020 --> 00:00:16,630
بطريقة بحيث إذا تم قلب أي جزء، إما رسالة بت أو بت متكرر، أي شيء في هذه 

5
00:00:16,630 --> 00:00:21,240
الكتلة، سيكون جهاز الاستقبال قادرًا على تحديد وجود خطأ، وكيفية إصلاحه. 

6
00:00:21,880 --> 00:00:24,453
كانت الفكرة الأساسية المقدمة هناك هي كيفية استخدام عمليات 

7
00:00:24,453 --> 00:00:27,160
التحقق من التكافؤ المتعددة للبحث الثنائي في طريقك إلى الخطأ. 

8
00:00:28,980 --> 00:00:34,538
كان الهدف في هذا الفيديو هو جعل رموز هامينج تبدو عملية وقابلة لإعادة الاكتشاف قدر الإمكان.

9
00:00:34,538 --> 00:00:34,600
 

10
00:00:35,180 --> 00:00:39,171
ولكن عندما تبدأ في التفكير في تنفيذ هذا فعليًا، سواء في البرامج أو 

11
00:00:39,171 --> 00:00:43,460
الأجهزة، فإن هذا الإطار قد يقلل في الواقع من مدى أناقة هذه الرموز حقًا. 

12
00:00:43,920 --> 00:00:48,668
قد تظن أنك بحاجة إلى كتابة خوارزمية تتتبع جميع مواقع الأخطاء المحتملة وتقطع 

13
00:00:48,668 --> 00:00:53,480
تلك المجموعة إلى النصف مع كل عملية تحقق، ولكنها في الواقع أبسط من ذلك بكثير. 

14
00:00:53,940 --> 00:00:58,797
إذا قرأت الإجابات على عمليات التحقق من التكافؤ الأربعة التي قمنا بها في الفيديو 

15
00:00:58,797 --> 00:01:04,080
الأخير، كلها كـ 1 و0 بدلاً من نعم ولا، فإنها توضح حرفيًا موضع الخطأ في النظام الثنائي. 

16
00:01:04,780 --> 00:01:11,260
على سبيل المثال، الرقم 7 في النظام الثنائي يبدو مثل 0111، مما يعني أنه 4 زائد 2 زائد 1. 

17
00:01:12,540 --> 00:01:17,217
ولاحظ أين يقع الموضع 7، فهو يؤثر بالفعل على المجموعة الأولى 

18
00:01:17,217 --> 00:01:21,740
من مجموعات التكافؤ، والثانية، والثالثة، ولكن ليس الأخيرة. 

19
00:01:22,220 --> 00:01:27,481
لذا فإن قراءة نتائج عمليات التحقق الأربعة هذه من الأسفل إلى الأعلى توضح بالفعل موضع الخطأ.

20
00:01:27,481 --> 00:01:27,540
 

21
00:01:28,320 --> 00:01:31,904
لا يوجد شيء خاص في المثال 7، وهذا يعمل بشكل عام، وهذا 

22
00:01:31,904 --> 00:01:35,820
يجعل منطق تنفيذ المخطط بأكمله في الأجهزة بسيطًا بشكل صادم. 

23
00:01:37,240 --> 00:01:41,545
الآن إذا كنت تريد معرفة سبب حدوث هذا السحر، فخذ تسميات الفهرس 

24
00:01:41,545 --> 00:01:45,712
الستة عشر هذه لمواقعنا، ولكن بدلاً من كتابتها في الأساس 10، 

25
00:01:45,712 --> 00:01:49,880
دعنا نكتبها جميعًا بالنظام الثنائي، بدءًا من 0000 حتى 1111. 

26
00:01:50,559 --> 00:01:54,211
عندما نعيد هذه التصنيفات الثنائية إلى صناديقها، اسمحوا لي 

27
00:01:54,211 --> 00:01:57,800
أن أؤكد أنها مختلفة عن البيانات التي يتم إرسالها بالفعل. 

28
00:01:58,320 --> 00:02:00,804
إنها ليست أكثر من مجرد تسمية مفاهيمية لمساعدتي 

29
00:02:00,804 --> 00:02:03,500
ومساعدتك في فهم من أين أتت مجموعات التكافؤ الأربع. 

30
00:02:04,140 --> 00:02:08,277
ربما يتم تقويض أناقة الحصول على كل ما نتطلع إليه موصوفًا في النظام الثنائي 

31
00:02:08,277 --> 00:02:12,360
بسبب الارتباك المتمثل في وجود كل ما نتطلع إليه موصوفًا في النظام الثنائي. 

32
00:02:13,020 --> 00:02:14,120
إنه يستحق ذلك، على الرغم من ذلك. 

33
00:02:14,800 --> 00:02:19,010
ركز انتباهك فقط على الجزء الأخير من كل هذه التسميات، ثم قم 

34
00:02:19,010 --> 00:02:23,220
بتسليط الضوء على المواضع التي يكون فيها الجزء الأخير هو 1. 

35
00:02:24,240 --> 00:02:29,670
ما حصلنا عليه هو المجموعة الأولى من مجموعات التكافؤ الأربع لدينا، مما يعني أنه يمكنك 

36
00:02:29,670 --> 00:02:35,356
تفسير هذا التحقق الأول على أنه يسأل، إذا كان هناك خطأ، فهل البت الأخير في موضع هذا الخطأ 

37
00:02:35,356 --> 00:02:35,740
هو 1؟ 

38
00:02:38,200 --> 00:02:42,264
وبالمثل، إذا ركزت على الجزء الثاني قبل الأخير، وقمت بتمييز جميع المواضع 

39
00:02:42,264 --> 00:02:46,160
التي يكون فيها الرقم 1، فستحصل على مجموعة التكافؤ الثانية من مخططنا. 

40
00:02:46,740 --> 00:02:50,445
بمعنى آخر، هذا الفحص الثاني يسألني مرة أخرى، إذا كان 

41
00:02:50,445 --> 00:02:54,500
هناك خطأ، فهل الجزء الثاني قبل الأخير من هذا الموضع هو 1؟ 

42
00:02:55,760 --> 00:02:56,900
وما إلى ذلك وهلم جرا. 

43
00:02:57,220 --> 00:03:02,855
يغطي فحص التكافؤ الثالث كل موضع تم تشغيل البت من الثالث إلى الأخير، 

44
00:03:02,855 --> 00:03:08,740
ويغطي الأخير المواضع الثمانية الأخيرة، تلك التي يكون أعلى بت لها هو 1. 

45
00:03:09,740 --> 00:03:14,025
كل ما فعلناه سابقًا هو نفس الإجابة على هذه الأسئلة الأربعة، 

46
00:03:14,025 --> 00:03:17,740
والتي بدورها هي نفس توضيح الموضع في النظام الثنائي. 

47
00:03:19,620 --> 00:03:21,480
آمل أن يجعل هذا شيئين أكثر وضوحا. 

48
00:03:22,040 --> 00:03:26,460
الأول هو كيفية التعميم بشكل منهجي على أحجام الكتل التي تكون أكبر من قوى اثنين. 

49
00:03:26,960 --> 00:03:31,698
إذا كان الأمر يتطلب المزيد من البتات لوصف كل موضع، مثل ستة بتات لوصف 64 نقطة، 

50
00:03:31,698 --> 00:03:36,680
فإن كل واحدة من هذه البتات تمنحك إحدى مجموعات التكافؤ التي نحتاج إلى التحقق منها. 

51
00:03:38,400 --> 00:03:40,838
أولئك منكم الذين شاهدوا لغز رقعة الشطرنج الذي قمت 

52
00:03:40,838 --> 00:03:43,180
به مع مات باركر قد يجدون كل هذا مألوفًا للغاية. 

53
00:03:43,660 --> 00:03:46,220
إنه نفس المنطق الأساسي، لكنه يحل مشكلة مختلفة، 

54
00:03:46,220 --> 00:03:48,780
ويتم تطبيقه على رقعة شطرنج مكونة من 64 مربعًا. 

55
00:03:49,880 --> 00:03:53,451
الأمر الثاني الذي آمل أن يوضحه هذا هو سبب وجود بتات التكافؤ 

56
00:03:53,451 --> 00:03:57,320
لدينا في مواضع تمثل قوى العدد اثنين، على سبيل المثال 1 و2 و4 و8. 

57
00:03:58,000 --> 00:04:03,000
هذه هي المواضع التي تم تشغيل تمثيلها الثنائي بمقدار بت واحد فقط. 

58
00:04:03,600 --> 00:04:06,384
ما يعنيه ذلك هو أن كل واحدة من بتات التكافؤ هذه 

59
00:04:06,384 --> 00:04:09,460
تقع داخل مجموعة واحدة فقط من مجموعات التكافؤ الأربع. 

60
00:04:12,040 --> 00:04:15,659
يمكنك أيضًا رؤية ذلك في أمثلة أكبر، حيث بغض النظر عن حجمها، 

61
00:04:15,659 --> 00:04:19,339
فإن كل بتة تكافؤ تلامس بسهولة مجموعة واحدة فقط من المجموعات. 

62
00:04:25,600 --> 00:04:29,996
بمجرد أن تفهم أن عمليات التحقق من التكافؤ هذه التي ركزنا عليها كثيرًا من وقتنا 

63
00:04:29,996 --> 00:04:34,280
ليست أكثر من طريقة ذكية لتوضيح موضع الخطأ في النظام الثنائي، فيمكننا بعد ذلك 

64
00:04:34,280 --> 00:04:38,788
رسم اتصال بطريقة مختلفة للتفكير في الهام الرموز، التي يمكن القول إنها أبسط بكثير 

65
00:04:38,788 --> 00:04:43,240
وأكثر أناقة، والتي يمكن كتابتها أساسًا باستخدام سطر واحد من التعليمات البرمجية. 

66
00:04:43,660 --> 00:04:45,500
يعتمد على وظيفة XOR. 

67
00:04:46,940 --> 00:04:50,220
XOR، لأولئك منكم الذين لا يعرفون، يرمز إلى حصري أو. 

68
00:04:50,780 --> 00:04:55,145
عندما تأخذ XOR لبتين، فسوف يُرجع 1 إذا تم تشغيل أي من تلك 

69
00:04:55,145 --> 00:04:59,360
البتات، ولكن ليس إذا تم تشغيل كليهما أو إيقاف تشغيلهما. 

70
00:05:00,100 --> 00:05:02,980
بصياغة مختلفة، إنه التكافؤ بين هاتين القطعتين. 

71
00:05:03,540 --> 00:05:06,760
باعتباري متخصصًا في الرياضيات، أفضّل التفكير في الأمر على أنه تعديل الإضافة 2. 

72
00:05:07,360 --> 00:05:10,148
نتحدث أيضًا بشكل شائع عن XOR لسلسلتين مختلفتين من 

73
00:05:10,148 --> 00:05:13,440
البتات، والتي تقوم بشكل أساسي بتنفيذ هذا المكون تلو الآخر. 

74
00:05:13,680 --> 00:05:15,720
إنها مثل الإضافة، ولكن حيث لا تحملها أبدًا. 

75
00:05:16,500 --> 00:05:19,344
مرة أخرى، قد يفضل الأشخاص الأكثر ميلاً للرياضيات 

76
00:05:19,344 --> 00:05:22,480
التفكير في هذا على أنه إضافة متجهين وتقليل التعديل 2. 

77
00:05:23,500 --> 00:05:28,097
إذا قمت بفتح بعض لغة Python الآن وقمت بتطبيق عملية علامة الإقحام بين عددين 

78
00:05:28,097 --> 00:05:32,940
صحيحين، فهذا ما تفعله ولكن على تمثيلات البت لتلك الأرقام الموجودة أسفل الغطاء. 

79
00:05:34,960 --> 00:05:38,893
النقطة الأساسية بالنسبة لي ولكم هي أن أخذ XOR للعديد من سلاسل 

80
00:05:38,893 --> 00:05:42,889
البت المختلفة هو وسيلة فعالة لحساب المحاكاة الساخرة لمجموعة من 

81
00:05:42,889 --> 00:05:47,140
المجموعات المنفصلة، كما هو الحال مع الأعمدة، كل ذلك في ضربة واحدة. 

82
00:05:51,260 --> 00:05:55,043
وهذا يمنحنا طريقة رائعة إلى حد ما للتفكير في عمليات التحقق من التكافؤ المتعددة 

83
00:05:55,043 --> 00:05:58,780
من خوارزمية كود هامينج الخاصة بنا حيث يتم تجميعها جميعًا معًا في عملية واحدة. 

84
00:05:59,479 --> 00:06:02,180
على الرغم من أنها تبدو للوهلة الأولى مختلفة تمامًا. 

85
00:06:02,820 --> 00:06:07,479
اكتب على وجه التحديد المواضع الستة عشر في النظام الثنائي، كما 

86
00:06:07,479 --> 00:06:11,989
فعلنا من قبل، وقم الآن بتمييز المواضع التي تم فيها تشغيل بت 

87
00:06:11,989 --> 00:06:17,100
الرسالة إلى 1، ثم قم بتجميع هذه المواضع في عمود واحد كبير وأخذ XOR. 

88
00:06:19,260 --> 00:06:24,048
ربما يمكنك تخمين أن البتات الأربعة الموجودة في الأسفل نتيجة لذلك هي نفس عمليات 

89
00:06:24,048 --> 00:06:29,200
التحقق من التكافؤ الأربعة التي عرفناها ونحبها، ولكن خذ لحظة للتفكير في السبب بالضبط. 

90
00:06:32,220 --> 00:06:36,569
هذا العمود الأخير، على سبيل المثال، يقوم بإحصاء جميع المواضع التي يكون 

91
00:06:36,569 --> 00:06:40,919
الجزء الأخير منها هو 1، ولكننا يقتصرون بالفعل على المواضع المميزة فقط، 

92
00:06:40,919 --> 00:06:45,760
لذا فهو يحسب بشكل فعال عدد المواضع المميزة التي جاءت من مجموعة التكافؤ الأولى. 

93
00:06:46,240 --> 00:06:46,800
هل هذا منطقي؟ 

94
00:06:49,080 --> 00:06:54,409
وبالمثل، يقوم العمود التالي بحساب عدد المواضع الموجودة في مجموعة التكافؤ الثانية، 

95
00:06:54,409 --> 00:07:00,000
والمواضع التي يكون البت الثاني قبل الأخير هو 1، والتي يتم تمييزها أيضًا، وما إلى ذلك. 

96
00:07:00,260 --> 00:07:03,960
إنه في الحقيقة مجرد تحول بسيط في المنظور حول نفس الشيء الذي كنا نفعله. 

97
00:07:07,760 --> 00:07:09,600
وهكذا تعرف إلى أين يتجه الأمر من هنا. 

98
00:07:10,000 --> 00:07:15,720
يكون المرسل مسؤولاً عن تبديل بعض بتات التكافؤ الخاصة للتأكد من أن المبلغ يصل إلى 0000. 

99
00:07:15,720 --> 00:07:21,491
الآن، بمجرد أن يصبح الأمر بهذا الشكل، فهذا يمنحنا طريقة رائعة للتفكير في 

100
00:07:21,491 --> 00:07:27,580
السبب وراء توضيح هذه البتات الأربعة الناتجة في الأسفل موضع الخطأ بشكل مباشر. 

101
00:07:28,460 --> 00:07:31,860
لنفترض أنه تم تبديل جزء ما في هذه الكتلة من 0 إلى 1. 

102
00:07:32,600 --> 00:07:38,248
ما يعنيه ذلك هو أن موضع هذا البت سيتم الآن تضمينه في إجمالي XOR، مما يغير 

103
00:07:38,248 --> 00:07:43,820
المجموع من 0 إلى هذه القيمة المضمنة حديثًا بدلاً من ذلك، وهو موضع الخطأ. 

104
00:07:44,460 --> 00:07:49,360
وبشكل أقل وضوحًا، ينطبق الأمر نفسه إذا كان هناك خطأ يؤدي إلى تغيير 1 إلى 0. 

105
00:07:50,180 --> 00:07:53,786
كما ترى، إذا قمت بإضافة سلسلة صغيرة معًا مرتين، فهذا يعني 

106
00:07:53,786 --> 00:07:57,580
عدم وجودها على الإطلاق، لأنه في هذا العالم 1 زائد 1 يساوي 0. 

107
00:07:57,580 --> 00:08:04,300
لذا فإن إضافة نسخة من هذا الموضع إلى المجموع الإجمالي له نفس التأثير الذي نحركه به. 

108
00:08:05,160 --> 00:08:10,700
وهذا التأثير، مرة أخرى، هو أن النتيجة الإجمالية في الأسفل توضح موضع الخطأ. 

109
00:08:13,039 --> 00:08:17,240
لتوضيح مدى روعة هذا الأمر، اسمحوا لي أن أعرض سطرًا واحدًا من كود بايثون 

110
00:08:17,240 --> 00:08:21,440
الذي أشرت إليه من قبل، والذي سيلتقط تقريبًا كل المنطق في نهاية المتلقي. 

111
00:08:22,080 --> 00:08:27,010
سنبدأ بإنشاء مصفوفة عشوائية مكونة من 16 1 و0 لمحاكاة كتلة البيانات، وسأعطيها 

112
00:08:27,010 --> 00:08:31,941
بتات الاسم، ولكن بالطبع من الناحية العملية سيكون هذا شيئًا نتلقاه من المرسل، 

113
00:08:31,941 --> 00:08:37,000
وبدلاً من ذلك نظرًا لكونها عشوائية، فإنها ستحمل 11 بتة بيانات مع 5 بتات تكافؤ. 

114
00:08:37,000 --> 00:08:41,880
إذا قمت باستدعاء الدالة enumerateBits، فإن ما تفعله هو إقران 

115
00:08:41,880 --> 00:08:47,000
كل من تلك البتات مع فهرس مناظر، في هذه الحالة يعمل من 0 إلى 15. 

116
00:08:48,180 --> 00:08:52,518
لذا، إذا قمنا بعد ذلك بإنشاء قائمة تدور حول كل هذه الأزواج، 

117
00:08:52,518 --> 00:08:57,001
الأزواج التي تبدو مثل i، ثم قمنا بسحب قيمة i فقط، فقط الفهرس، 

118
00:08:57,001 --> 00:09:01,340
حسنًا، الأمر ليس مثيرًا، سنستعيد تلك المؤشرات من 0 إلى 15 . 

119
00:09:01,680 --> 00:09:06,969
ولكن إذا أضفنا شرطًا للقيام بذلك فقط إذا كانت البتة، مما يعني أنه إذا كانت تلك 

120
00:09:06,969 --> 00:09:12,660
البتة هي 1 وليس 0، فحسنًا فإنها تسحب فقط المواضع التي يتم فيها تشغيل البتة المقابلة. 

121
00:09:13,380 --> 00:09:20,360
في هذه الحالة يبدو أن هذه المواضع هي 0، 4، 6، 9، إلخ. 

122
00:09:20,720 --> 00:09:27,240
ما نريده هو جمع كل تلك المواضع معًا، مواضع البتات التي تم تشغيلها، ثم XOR معًا. 

123
00:09:29,180 --> 00:09:33,220
للقيام بذلك في بايثون، اسمحوا لي أولاً باستيراد وظيفتين مفيدتين. 

124
00:09:33,900 --> 00:09:38,700
بهذه الطريقة يمكننا استدعاء الدالة تقليل() في هذه القائمة، واستخدام الدالة XOR لتقليلها. 

125
00:09:39,100 --> 00:09:42,680
وهذا في الأساس يشق طريقه عبر القائمة، ويأخذ XORs على طول الطريق. 

126
00:09:44,800 --> 00:09:49,440
إذا كنت تفضل ذلك، يمكنك كتابة دالة XOR بوضوح دون الحاجة إلى استيرادها من أي مكان. 

127
00:09:51,940 --> 00:09:56,645
لذا، في الوقت الحالي، يبدو أننا إذا فعلنا ذلك على الكتلة العشوائية 

128
00:09:56,645 --> 00:10:01,280
المكونة من 16 بت، فإنها ستُرجع 9، والتي لها التمثيل الثنائي 1001. 

129
00:10:01,980 --> 00:10:06,508
لن نفعل ذلك هنا، ولكن يمكنك كتابة دالة يستخدم فيها المرسل هذا التمثيل الثنائي لتعيين 

130
00:10:06,508 --> 00:10:10,931
وحدات البت التماثلية الأربعة حسب الحاجة، وفي النهاية توصيل هذه الكتلة إلى حالة حيث 

131
00:10:10,931 --> 00:10:15,460
يؤدي تشغيل هذا السطر من التعليمات البرمجية على القائمة الكاملة للبتات إلى إرجاعها 0. 

132
00:10:16,080 --> 00:10:20,100
سيتم اعتبار هذا كتلة جيدة الإعداد. 

133
00:10:20,100 --> 00:10:25,160
الأمر الرائع هو أنه إذا قمنا بتبديل أي من البتات في هذه القائمة، لمحاكاة خطأ عشوائي 

134
00:10:25,160 --> 00:10:30,220
من الضوضاء، ثم إذا قمت بتشغيل نفس السطر من التعليمات البرمجية، فإنه يطبع هذا الخطأ. 

135
00:10:30,960 --> 00:10:31,520
أليس هذا أنيق؟ 

136
00:10:31,820 --> 00:10:36,212
يمكنك الحصول على هذه الكتلة فجأة، وتشغيل هذا السطر الفردي 

137
00:10:36,212 --> 00:10:41,060
عليها، وسيظهر تلقائيًا موضع الخطأ، أو 0 إذا لم يكن هناك أي خطأ. 

138
00:10:42,500 --> 00:10:44,840
وليس هناك شيء خاص بخصوص الحجم 16 هنا. 

139
00:10:44,840 --> 00:10:49,860
سيعمل نفس السطر من التعليمات البرمجية إذا كان لديك قائمة، على سبيل المثال، 256 بت. 

140
00:10:51,880 --> 00:10:55,859
وغني عن القول أن هناك المزيد من التعليمات البرمجية التي يجب كتابتها 

141
00:10:55,859 --> 00:10:59,839
هنا، مثل إجراء فحص التكافؤ التعريفي لاكتشاف أخطاء 2 بت، ولكن الفكرة 

142
00:10:59,839 --> 00:11:03,760
هي أن كل المنطق الأساسي تقريبًا من مخططنا يعود إلى تقليل XOR واحد. 

143
00:11:06,120 --> 00:11:12,447
الآن، اعتمادًا على راحتك مع الثنائيات وXORs والبرامج بشكل عام، قد تجد هذا المنظور مربكًا 

144
00:11:12,447 --> 00:11:18,420
بعض الشيء، أو أكثر أناقة وبساطة لدرجة أنك تتساءل لماذا لم نبدأ به من البداية -يذهب. 

145
00:11:19,140 --> 00:11:22,984
بشكل عام، من الأسهل التفكير في منظور التحقق من التكافؤ المتعدد عند 

146
00:11:22,984 --> 00:11:26,770
تنفيذ رموز Hamming في الأجهزة بشكل مباشر جدًا، ومن الأسهل التفكير 

147
00:11:26,770 --> 00:11:30,500
في منظور XOR عند القيام بذلك في البرامج، من مستوى أعلى نوعًا ما. 

148
00:11:31,360 --> 00:11:37,573
الأول هو الأسهل في الواقع للقيام به يدويًا، وأعتقد أنه يقوم بعمل أفضل في غرس الحدس 

149
00:11:37,573 --> 00:11:43,711
الأساسي الكامن وراء كل هذا، وهو أن المعلومات المطلوبة لتحديد موقع خطأ واحد مرتبطة 

150
00:11:43,711 --> 00:11:50,000
بسجل حجم الكتلة أو بعبارة أخرى، فإنه ينمو قطعة واحدة في كل مرة مع تضاعف حجم الكتلة. 

151
00:11:51,020 --> 00:11:56,060
الحقيقة ذات الصلة هنا هي أن هذه المعلومات تتوافق بشكل مباشر مع مقدار التكرار الذي نحتاجه. 

152
00:11:56,660 --> 00:12:01,460
وهذا حقًا ما يتعارض مع رد فعل معظم الأشخاص غير المحسوبين عندما يفكرون لأول مرة في جعل 

153
00:12:01,460 --> 00:12:06,484
رسالة مقاومة للأخطاء، حيث عادةً ما يكون نسخ الرسالة بأكملها هو أول غريزة تتبادر إلى ذهنهم.

154
00:12:06,484 --> 00:12:06,540
 

155
00:12:07,500 --> 00:12:10,620
وبعد ذلك، بالمناسبة، هناك طريقة أخرى تمامًا حيث ترى أحيانًا 

156
00:12:10,620 --> 00:12:14,000
رموز هامينج معروضة، حيث تقوم بضرب الرسالة في مصفوفة واحدة كبيرة. 

157
00:12:14,670 --> 00:12:18,897
إنه لطيف نوعًا ما لأنه يرتبط بعائلة أوسع من الرموز الخطية، لكنني 

158
00:12:18,897 --> 00:12:23,060
أعتقد أن هذا لا يعطي أي فكرة تقريبًا عن مصدرها أو كيفية قياسها. 

159
00:12:25,200 --> 00:12:31,160
وبالحديث عن القياس، قد تلاحظ أن كفاءة هذا المخطط تتحسن فقط عندما نزيد حجم الكتلة. 

160
00:12:35,000 --> 00:12:38,863
على سبيل المثال، رأينا أنه مع 256 بت، فإنك تستخدم 3% فقط 

161
00:12:38,863 --> 00:12:42,660
من تلك المساحة للتكرار، ويستمر الأمر في التحسن من هناك. 

162
00:12:43,300 --> 00:12:47,340
ومع زيادة عدد البتات المتماثلة واحدة تلو الأخرى، يستمر حجم الكتلة في التضاعف. 

163
00:12:49,000 --> 00:12:54,510
وإذا أخذت ذلك إلى أقصى الحدود، يمكن أن يكون لديك كتلة تحتوي، على سبيل المثال، على مليون 

164
00:12:54,510 --> 00:13:00,020
بت، حيث يمكنك حرفيًا تشغيل 20 سؤالًا مع اختبارات التكافؤ الخاصة بك، وتستخدم 21 بتة فقط. 

165
00:13:00,740 --> 00:13:03,964
وإذا عدت إلى الوراء للتفكير في النظر إلى مليون بت 

166
00:13:03,964 --> 00:13:07,060
وتحديد موقع خطأ واحد، فإن هذا يبدو جنونًا حقًا. 

167
00:13:08,199 --> 00:13:12,829
المشكلة بالطبع هي أنه مع وجود كتلة أكبر، فإن احتمال رؤية أكثر من خطأ 

168
00:13:12,829 --> 00:13:17,660
واحد أو اثنين من الأخطاء، ولا تتعامل رموز هامينج مع أي شيء أبعد من ذلك. 

169
00:13:18,320 --> 00:13:21,355
لذا، من الناحية العملية، ما تريده هو العثور على الحجم المناسب بحيث 

170
00:13:21,355 --> 00:13:24,300
لا يكون احتمال حدوث عدد كبير جدًا من تقلبات البتات مرتفعًا جدًا. 

171
00:13:26,600 --> 00:13:31,304
أيضًا، من الناحية العملية، تميل الأخطاء إلى الظهور على شكل دفعات صغيرة، مما قد يؤدي إلى 

172
00:13:31,304 --> 00:13:36,115
تدمير كتلة واحدة تمامًا، لذا فإن أحد الأساليب الشائعة للمساعدة في نشر موجة من الأخطاء عبر 

173
00:13:36,115 --> 00:13:40,926
العديد من الكتل المختلفة هو تشبيك تلك الكتل، مثل هذا، قبل أن يتم دمجها إرسالها أو تخزينها.

174
00:13:40,926 --> 00:13:40,980
 

175
00:13:45,580 --> 00:13:49,935
ثم مرة أخرى، أصبح الكثير من هذا موضع نقاش تمامًا من خلال أكواد أكثر حداثة، 

176
00:13:49,935 --> 00:13:54,290
مثل خوارزمية Reed-Solomon الأكثر استخدامًا، والتي تتعامل مع أخطاء الاندفاع 

177
00:13:54,290 --> 00:13:58,820
بشكل جيد، ويمكن ضبطها لتكون مرنة في التعامل مع عدد أكبر من الأخطاء لكل كتلة . 

178
00:13:59,360 --> 00:14:01,340
ولكن هذا موضوع لوقت آخر. 

179
00:14:02,500 --> 00:14:06,017
في كتابه &quot;فن ممارسة العلوم والهندسة&quot;، كان 

180
00:14:06,017 --> 00:14:09,940
هامينغ صريحًا بشكل رائع حول مدى تعقيد اكتشافه لهذا الرمز. 

181
00:14:10,620 --> 00:14:14,141
لقد جرب أولاً جميع أنواع المخططات المختلفة التي تتضمن تنظيم 

182
00:14:14,141 --> 00:14:17,780
البتات إلى أجزاء من شبكة ذات أبعاد أعلى وأشياء غريبة مثل هذه. 

183
00:14:18,300 --> 00:14:22,587
فكرة أنه قد يكون من الممكن الحصول على فحوصات التكافؤ للتآمر بطريقة توضح 

184
00:14:22,587 --> 00:14:26,994
موضع الخطأ جاءت إلى هامينج فقط عندما تراجع بعد مجموعة من التحليلات الأخرى 

185
00:14:26,994 --> 00:14:31,520
وسأل، حسنًا، ما هو الأكثر كفاءة الذي يمكنني فعله من الممكن أن يكون حول هذا؟ 

186
00:14:32,620 --> 00:14:37,050
وكان صريحًا أيضًا بشأن مدى أهمية وجود ضوابط التكافؤ في ذهنه بالفعل، 

187
00:14:37,050 --> 00:14:41,220
وهو الأمر الذي كان أقل شيوعًا في الأربعينيات مما هو عليه اليوم. 

188
00:14:41,920 --> 00:14:45,239
هناك حوالي ست مرات خلال هذا الكتاب يشير فيها إلى 

189
00:14:45,239 --> 00:14:48,220
مقولة لويس باستور، الحظ يفضل العقل المستعد. 

190
00:14:49,320 --> 00:14:51,810
غالبًا ما تبدو الأفكار الذكية بسيطة بشكل خادع بعد 

191
00:14:51,810 --> 00:14:54,300
فوات الأوان، مما يجعل من السهل التقليل من قيمتها. 

192
00:14:54,960 --> 00:14:58,103
في الوقت الحالي، أملي الصادق هو أن تكون رموز هامينج، أو على 

193
00:14:58,103 --> 00:15:01,300
الأقل إمكانية وجود مثل هذه الرموز، واضحة تقريبًا بالنسبة لك. 

194
00:15:01,660 --> 00:15:06,820
لكن لا ينبغي أن تخدع نفسك بالاعتقاد بأنها واضحة بالفعل، لأنها بالتأكيد ليست كذلك. 

195
00:15:07,880 --> 00:15:13,056
جزء من السبب الذي يجعل الأفكار الذكية تبدو سهلة بشكل خادع هو أننا لا نرى سوى النتيجة 

196
00:15:13,056 --> 00:15:18,049
النهائية، وننظف ما كان فوضويًا، ولا نذكر أبدًا كل المنعطفات الخاطئة، ونقلل من مدى 

197
00:15:18,049 --> 00:15:22,860
اتساع مساحة الإمكانيات القابلة للاستكشاف في بداية المشكلة. عملية الحل، كل ذلك. 

198
00:15:23,820 --> 00:15:24,900
ولكن هذا صحيح بشكل عام. 

199
00:15:24,900 --> 00:15:30,040
أعتقد أنه بالنسبة لبعض الاختراعات الخاصة، هناك سبب ثانٍ وأعمق لعدم تقديرنا لها. 

200
00:15:30,840 --> 00:15:34,856
إن التفكير في المعلومات من حيث البتات قد اندمج فعليًا في نظرية كاملة 

201
00:15:34,856 --> 00:15:38,640
بحلول عام 1948، مع ورقة كلود شانون الأساسية حول نظرية المعلومات. 

202
00:15:39,280 --> 00:15:42,540
كان هذا متزامنًا بشكل أساسي مع قيام هامينج بتطوير خوارزميته. 

203
00:15:43,300 --> 00:15:48,013
كانت هذه هي نفس الورقة التأسيسية التي أظهرت، إلى حد ما، أن التصحيح الفعال للأخطاء 

204
00:15:48,013 --> 00:15:52,900
أمر ممكن دائمًا، بغض النظر عن مدى احتمالية قلب البتات، على الأقل من الناحية النظرية. 

205
00:15:53,700 --> 00:15:57,355
بالمناسبة، كان شانون وهامينج يشتركان في مكتب واحد في Bell Labs، على الرغم 

206
00:15:57,355 --> 00:16:01,160
من العمل على أشياء مختلفة تمامًا، وهو الأمر الذي لا يبدو من قبيل الصدفة هنا. 

207
00:16:02,380 --> 00:16:07,360
بعد مرور عدة عقود، وفي هذه الأيام، الكثير منا منغمسون جدًا في التفكير في 

208
00:16:07,360 --> 00:16:12,340
أجزاء ومعلومات، مما يجعل من السهل التغاضي عن مدى تميز طريقة التفكير هذه. 

209
00:16:13,100 --> 00:16:17,911
ومن عجيب المفارقات أن الأفكار التي تشكل بشكل أعمق الطرق التي يفكر بها جيل المستقبل 

210
00:16:17,911 --> 00:16:22,260
ستنتهي في النهاية إلى النظر إلى جيل المستقبل بشكل أبسط مما هو عليه بالفعل. 

