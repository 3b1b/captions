1
00:00:03,620 --> 00:00:06,827
هل سبق لك أن تساءلت كيف يمكن خدش قرص مضغوط أو قرص 

2
00:00:06,827 --> 00:00:10,100
DVD مع الاستمرار في تشغيله مهما كان ما يتم تخزينه؟ 

3
00:00:10,900 --> 00:00:16,436
تؤثر عملية الخدش بالفعل على 1 و0 على القرص، لذا فهي تقرأ بيانات مختلفة عما تم 

4
00:00:16,436 --> 00:00:21,973
تخزينه، ولكن ما لم يتم خدشها بالفعل، فسيتم فك تشفير البتات التي تقرأها في نفس 

5
00:00:21,973 --> 00:00:27,440
الملف الذي تم ترميزه عليه بالضبط، بت للنسخة بت، على الرغم من كل تلك الأخطاء. 

6
00:00:27,440 --> 00:00:31,926
هناك قدر كبير من الذكاء الرياضي الذي يسمح لنا بتخزين البيانات، 

7
00:00:31,926 --> 00:00:36,200
وبنفس القدر من الأهمية نقل البيانات، بطريقة مقاومة للأخطاء. 

8
00:00:36,200 --> 00:00:40,880
حسنًا، حسنًا، في الواقع لا يتطلب الأمر الكثير من الذكاء للتوصل إلى طريقة للقيام بذلك. 

9
00:00:40,880 --> 00:00:45,706
أي ملف، سواء كان مقطع فيديو أو صوتًا أو نصًا، أو بعض التعليمات 

10
00:00:45,706 --> 00:00:50,380
البرمجية، أو صورة، أو أيًا كان، هو في النهاية تسلسل من 1 و0. 

11
00:00:50,680 --> 00:00:56,000
والاستراتيجية البسيطة لتصحيح أي جزء يتم قلبه هي تخزين ثلاث نسخ من كل جزء. 

12
00:00:57,580 --> 00:01:00,903
ثم يمكن للآلة التي تقرأ هذا الملف أن تقارن هذه النسخ الثلاث 

13
00:01:00,903 --> 00:01:04,060
وتأخذ دائمًا أفضل نسختين من أصل 3 عندما يكون هناك تناقض. 

14
00:01:07,160 --> 00:01:10,860
ولكن ما يعنيه ذلك هو استخدام ثلثي المساحة الخاصة بك للتكرار. 

15
00:01:11,480 --> 00:01:14,360
وحتى في هذه الحالة، ورغم كل تلك المساحة التي تم التخلي عنها، 

16
00:01:14,360 --> 00:01:17,240
ليس هناك ضمان قوي بشأن ما يحدث إذا تم قلب أكثر من بتة واحدة. 

17
00:01:17,980 --> 00:01:21,061
السؤال الأكثر إثارة للاهتمام هو كيفية القيام بذلك 

18
00:01:21,061 --> 00:01:24,020
بحيث يمكن تصحيح الأخطاء مع ترك أقل مساحة ممكنة. 

19
00:01:24,520 --> 00:01:28,940
على سبيل المثال، باستخدام الطريقة التي ستتعرف عليها في هذا الفيديو، 

20
00:01:28,940 --> 00:01:33,360
يمكنك تخزين بياناتك في كتل بحجم 256 بت، حيث تستخدم كل كتلة 9 بت، 9! 

21
00:01:33,760 --> 00:01:37,064
لتكون بمثابة نوع من التكرار، والـ 247 بت الأخرى 

22
00:01:37,064 --> 00:01:40,300
حرة في حمل أي رسالة أو بيانات ذات معنى تريدها. 

23
00:01:40,900 --> 00:01:46,886
وسيظل الأمر كذلك، إذا تم قلب أي جزء هنا، فقط من خلال النظر إلى هذه الكتلة وليس أكثر 

24
00:01:46,886 --> 00:01:52,660
من ذلك، ستتمكن الآلة من تحديد وجود خطأ وتحديد مكانه بدقة حتى تعرف كيفية تصحيحه . 

25
00:01:52,660 --> 00:01:54,620
وبصراحة، هذا يبدو وكأنه سحر. 

26
00:01:55,440 --> 00:01:59,247
وبالنسبة لهذا المخطط بالذات، إذا تم قلب اثنين من البتات، فسيكون الجهاز قادرًا 

27
00:01:59,247 --> 00:02:02,860
على الأقل على اكتشاف وجود خطأين، على الرغم من أنه لن يعرف كيفية إصلاحهما. 

28
00:02:03,520 --> 00:02:06,900
سنتحدث بعد قليل عن كيفية قياس ذلك للكتل ذات الأحجام المختلفة. 

29
00:02:07,860 --> 00:02:12,900
تُعرف الطرق التي تتيح لك تصحيح أخطاء مثل هذه، بشكل معقول، باسم رموز تصحيح الأخطاء. 

30
00:02:13,660 --> 00:02:17,570
خلال الجزء الأكبر من القرن الماضي، كان هذا المجال مصدرًا غنيًا حقًا 

31
00:02:17,570 --> 00:02:21,940
للرياضيات العميقة بشكل مدهش والتي تم دمجها في الأجهزة التي نستخدمها كل يوم. 

32
00:02:22,840 --> 00:02:28,660
الهدف هنا هو إعطاؤك فهمًا شاملاً لأحد أقدم الأمثلة، والمعروف باسم كود هامينغ. 

33
00:02:29,520 --> 00:02:34,670
وبالمناسبة، الطريقة التي أفكر بها في بنية هذا الفيديو لا تتعلق بشرحها بشكل مباشر قدر 

34
00:02:34,670 --> 00:02:39,820
الإمكان، بل تتعلق أكثر بدفعك لابتكارها بنفسك، مع القليل من التوجيه اللطيف هنا وهناك. 

35
00:02:40,120 --> 00:02:43,394
لذلك عندما تشعر وكأنك ترى إلى أين ستتجه الأمور في مرحلة ما، توقف 

36
00:02:43,394 --> 00:02:46,720
في تلك اللحظة، وتوقع بشكل فعال ما سيكون عليه المخطط قبل أن أخبرك. 

37
00:02:47,240 --> 00:02:50,868
أيضًا، إذا كنت تريد أن يصل فهمك إلى مستوى الأجهزة، فقد قام Ben 

38
00:02:50,868 --> 00:02:54,438
Eater بإنشاء مقطع فيديو بالتزامن مع هذا الفيديو يوضح لك كيفية 

39
00:02:54,438 --> 00:02:58,240
تنفيذ رموز Hamming فعليًا على لوحات التجارب، وهو أمر مرضٍ للغاية. 

40
00:02:59,300 --> 00:03:03,947
يجب أن تعلم أن رموز هامينج لا تُستخدم على نطاق واسع مثل الرموز الأكثر حداثة، 

41
00:03:03,947 --> 00:03:08,533
مثل خوارزمية ريد-سولومون، ولكن هناك سحرًا معينًا في التناقض بين مدى استحالة 

42
00:03:08,533 --> 00:03:13,000
هذه المهمة في البداية، وكيف تبدو معقولة تمامًا مرة واحدة تتعلم عن هامينج. 

43
00:03:13,720 --> 00:03:17,654
المبدأ الأساسي لتصحيح الأخطاء هو أنه في مساحة واسعة من جميع 

44
00:03:17,654 --> 00:03:22,180
الرسائل المحتملة، سيتم اعتبار بعض المجموعات الفرعية فقط رسائل صالحة. 

45
00:03:22,800 --> 00:03:26,940
على سبيل القياس، فكر في الكلمات المكتوبة بشكل صحيح مقابل الكلمات المكتوبة بشكل غير صحيح. 

46
00:03:28,900 --> 00:03:32,893
عندما يتم تغيير رسالة صالحة، يكون المتلقي مسؤولاً عن 

47
00:03:32,893 --> 00:03:37,340
تصحيح ما يراه إلى أقرب جار صالح، كما قد تفعل مع خطأ مطبعي. 

48
00:03:38,220 --> 00:03:41,198
ومع ذلك، فإن التوصل إلى خوارزمية ملموسة لتصنيف مثل 

49
00:03:41,198 --> 00:03:44,060
هذه الرسائل بكفاءة يتطلب قدرًا معينًا من الذكاء. 

50
00:03:46,780 --> 00:03:50,390
تبدأ القصة في الأربعينيات من القرن العشرين، عندما كان الشاب ريتشارد هامينج 

51
00:03:50,390 --> 00:03:53,809
يعمل في مختبرات بيل، وكانت بعض أعماله تتضمن استخدام كمبيوتر كبير الحجم 

52
00:03:53,809 --> 00:03:57,420
ومكلف للغاية يعمل بنظام البطاقة المثقبة، ولم يكن لديه سوى وصول محدود إليه. 

53
00:03:57,800 --> 00:04:02,400
والبرامج التي ظل يطبقها ظلت تفشل، لأنه بين الحين والآخر سيتم إساءة قراءة جزء منها. 

54
00:04:03,120 --> 00:04:05,821
نظرًا لأن الإحباط هو بوتقة الاختراع، فقد سئم كثيرًا 

55
00:04:05,821 --> 00:04:08,420
لدرجة أنه اخترع أول رمز لتصحيح الأخطاء في العالم. 

56
00:04:09,060 --> 00:04:12,056
هناك العديد من الطرق المختلفة لتأطير رموز هامينج، ولكن 

57
00:04:12,056 --> 00:04:15,380
كمرحلة أولى سنتناول الأمر بالطريقة التي فكر بها هامينج نفسه. 

58
00:04:16,519 --> 00:04:20,940
دعونا نستخدم مثالاً بسيطًا، ولكن ليس بسيطًا للغاية، وهو كتلة مكونة من 16 بت. 

59
00:04:21,820 --> 00:04:24,740
سنقوم بترقيم مواضع هذه البتات من 0 إلى 15. 

60
00:04:25,620 --> 00:04:29,241
البيانات الفعلية التي نريد تخزينها ستشكل 12 بتًا فقط 

61
00:04:29,241 --> 00:04:33,000
من هذه البتات، في حين يتم حجز 4 مواضع كنوع من التكرار. 

62
00:04:33,900 --> 00:04:36,946
كلمة زائدة عن الحاجة هنا لا تعني ببساطة النسخ، ففي نهاية المطاف، 

63
00:04:36,946 --> 00:04:40,040
هذه البتات الأربعة لا تمنحنا مساحة كافية لنسخ البيانات بشكل أعمى. 

64
00:04:40,720 --> 00:04:43,789
وبدلاً من ذلك، سيحتاجون إلى نوع أكثر دقة وذكاءً من 

65
00:04:43,789 --> 00:04:47,280
التكرار، وليس إضافة أي معلومات جديدة، ولكن إضافة المرونة. 

66
00:04:48,600 --> 00:04:54,110
قد تتوقع أن تأتي هذه القطع الأربعة الخاصة مجمعة بشكل جيد معًا، ربما في النهاية أو شيء من 

67
00:04:54,110 --> 00:04:59,620
هذا القبيل، ولكن كما سترى، فإن وضعها في مواضع تمثل قوى 2 يسمح بشيء أنيق حقًا في النهاية. 

68
00:05:00,200 --> 00:05:03,540
قد يمنحك أيضًا تلميحًا بسيطًا حول كيفية قياس هذا للكتل الأكبر حجمًا. 

69
00:05:04,900 --> 00:05:08,999
ومن الناحية الفنية أيضًا، سينتهي الأمر بـ 11 بتًا فقط من البيانات، وستجد أن 

70
00:05:08,999 --> 00:05:13,260
هناك فارقًا بسيطًا لما يحدث في الموضع 0، لكن لا تقلق بشأن ذلك في الوقت الحالي. 

71
00:05:14,140 --> 00:05:19,597
مثل أي خوارزمية لتصحيح الأخطاء، سيتضمن ذلك لاعبين، مرسل مسؤول عن تعيين هذه 

72
00:05:19,597 --> 00:05:25,200
البتات الأربعة الخاصة، ومتلقي مسؤول عن إجراء نوع ما من الفحص وتصحيح الأخطاء. 

73
00:05:25,200 --> 00:05:30,058
بالطبع، تشير كلمتا المرسل والمستقبل إلى الأجهزة أو البرامج التي تقوم بجميع عمليات 

74
00:05:30,058 --> 00:05:34,740
التحقق، والمقصود بفكرة الرسالة على نطاق واسع جدًا، هو تضمين أشياء مثل التخزين. 

75
00:05:35,340 --> 00:05:38,539
ففي نهاية المطاف، تخزين البيانات هو نفس إرسال رسالة من 

76
00:05:38,539 --> 00:05:41,680
الماضي إلى المستقبل بدلاً من إرسالها من مكان إلى آخر. 

77
00:05:42,560 --> 00:05:47,193
إذن هذا هو الإعداد، ولكن قبل أن نتمكن من التعمق في الأمر، نحتاج إلى التحدث عن فكرة ذات 

78
00:05:47,193 --> 00:05:51,560
صلة كانت جديدة في ذهن هامينج في وقت اكتشافه، وهي طريقة تتيح لك اكتشاف أي أخطاء في 

79
00:05:51,560 --> 00:05:56,300
البتات، ولكن ليس تصحيحها، كما هو معروف. في الأعمال التجارية باعتبارها التحقق من التكافؤ. 

80
00:05:56,880 --> 00:06:00,558
للتحقق من التكافؤ، نقوم بفصل بت واحد فقط يكون المرسل 

81
00:06:00,558 --> 00:06:03,820
مسؤولاً عن ضبطه، والباقي أحرار في حمل الرسالة. 

82
00:06:04,880 --> 00:06:08,148
الوظيفة الوحيدة لهذا البت الخاص هي التأكد من أن 

83
00:06:08,148 --> 00:06:11,280
العدد الإجمالي للآحاد في الرسالة هو رقم زوجي. 

84
00:06:12,080 --> 00:06:15,966
على سبيل المثال، في الوقت الحالي، إجمالي عدد الآحاد هو 7، وهذا أمر غريب، 

85
00:06:15,966 --> 00:06:19,960
لذلك يحتاج المرسل إلى قلب هذا البت الخاص ليصبح 1، مما يجعل العدد متساويًا. 

86
00:06:20,800 --> 00:06:26,420
ولكن إذا كانت الكتلة قد بدأت بالفعل بعدد زوجي من 1، فسيتم الاحتفاظ بهذا البت الخاص عند 0. 

87
00:06:27,340 --> 00:06:32,128
هذا أمر بسيط جدًا، وبسيط بشكل خادع، ولكنه طريقة أنيقة للغاية لاستخلاص 

88
00:06:32,128 --> 00:06:36,780
فكرة التغيير في أي مكان في الرسالة لتنعكس في جزء واحد من المعلومات. 

89
00:06:37,500 --> 00:06:41,983
لاحظ أنه إذا تم قلب أي جزء من هذه الرسالة، إما من 0 إلى 1 أو 

90
00:06:41,983 --> 00:06:46,540
من 1 إلى 0، فإنه يغير العدد الإجمالي للآحاد من زوجي إلى فردي. 

91
00:06:47,980 --> 00:06:52,689
لذلك، إذا كنت المتلقي، ونظرت إلى هذه الرسالة، ورأيت عددًا فرديًا من 1، فيمكنك 

92
00:06:52,689 --> 00:06:57,460
التأكد من حدوث خطأ ما، على الرغم من أنه قد لا يكون لديك أي فكرة عن مكان حدوثه. 

93
00:06:58,500 --> 00:07:00,919
في المصطلحات، يُعرف ما إذا كانت مجموعة البتات 

94
00:07:00,919 --> 00:07:03,340
تحتوي على عدد زوجي أو فردي من 1 باسم التكافؤ. 

95
00:07:04,860 --> 00:07:07,830
يمكنك أيضًا استخدام الأرقام والقول إن التكافؤ هو 0 أو 1، وهو ما يكون أكثر 

96
00:07:07,830 --> 00:07:10,720
فائدة عادةً بمجرد البدء في إجراء العمليات الحسابية باستخدام هذه الفكرة. 

97
00:07:11,220 --> 00:07:15,520
وهذه البتة الخاصة التي يستخدمها المرسل للتحكم في التكافؤ تسمى بت التكافؤ. 

98
00:07:17,560 --> 00:07:21,368
وفي الواقع، يجب أن نكون واضحين، إذا رأى المتلقي تكافؤًا فرديًا، فهذا 

99
00:07:21,368 --> 00:07:25,231
لا يعني بالضرورة أنه كان هناك خطأ واحد فقط، ربما كان هناك 3 أخطاء، أو 

100
00:07:25,231 --> 00:07:29,260
5، أو أي رقم فردي آخر، لكن يمكنهم معرفة ذلك على وجه اليقين أنه لم يكن 0. 

101
00:07:29,980 --> 00:07:33,870
من ناحية أخرى، إذا كان هناك خطأين، أو أي عدد زوجي من الأخطاء، فإن 

102
00:07:33,870 --> 00:07:37,761
العدد النهائي للأرقام 1 سيظل زوجيًا، لذلك لا يمكن للمستلم أن يكون 

103
00:07:37,761 --> 00:07:42,300
واثقًا تمامًا من أن العدد الزوجي يعني بالضرورة أن الرسالة خالية من الأخطاء . 

104
00:07:42,840 --> 00:07:45,931
قد تشكو من أن الرسالة التي يتم إفسادها من خلال تقلبات 

105
00:07:45,931 --> 00:07:49,080
بمقدار 2 بت فقط تكون ضعيفة جدًا، وستكون على حق تمامًا. 

106
00:07:49,700 --> 00:07:54,240
ومع ذلك، ضع في اعتبارك أنه لا توجد طريقة لاكتشاف الأخطاء أو تصحيحها يمكن أن 

107
00:07:54,240 --> 00:07:58,900
تمنحك ثقة بنسبة 100% في أن الرسالة التي تتلقاها هي الرسالة التي قصدها المرسل. 

108
00:07:59,580 --> 00:08:02,408
بعد كل شيء، يمكن للضوضاء العشوائية الكافية دائمًا تغيير 

109
00:08:02,408 --> 00:08:05,440
رسالة صالحة إلى رسالة صالحة أخرى فقط عن طريق الصدفة البحتة. 

110
00:08:06,240 --> 00:08:10,810
بدلاً من ذلك، الهدف هو التوصل إلى مخطط قوي يصل إلى حد أقصى معين من 

111
00:08:10,810 --> 00:08:15,380
الأخطاء، أو ربما لتقليل احتمالية حدوث نتيجة إيجابية كاذبة مثل هذا. 

112
00:08:16,260 --> 00:08:19,795
تعتبر عمليات التحقق من التكافؤ في حد ذاتها ضعيفة جدًا، ولكن 

113
00:08:19,795 --> 00:08:23,330
من خلال استخلاص فكرة التغيير عبر رسالة كاملة وصولاً إلى جزء 

114
00:08:23,330 --> 00:08:27,160
واحد، فإن ما يقدمونه لنا هو لبنة بناء قوية لمخططات أكثر تعقيدًا. 

115
00:08:27,940 --> 00:08:32,484
على سبيل المثال، بينما كان هامينج يبحث عن طريقة لتحديد مكان حدوث الخطأ، وليس 

116
00:08:32,484 --> 00:08:36,969
فقط مكان حدوثه، كانت رؤيته الرئيسية هي أنه إذا قمت بتطبيق بعض عمليات التحقق 

117
00:08:36,969 --> 00:08:41,218
من التكافؤ ليس على الرسالة الكاملة، ولكن على مجموعات فرعية معينة مختارة 

118
00:08:41,218 --> 00:08:45,940
بعناية، فيمكنك أن تسأل سلسلة أكثر دقة من الأسئلة التي تحدد موقع أي خطأ بت واحد. 

119
00:08:46,680 --> 00:08:50,030
الشعور العام يشبه إلى حد ما ممارسة لعبة مكونة من 20 سؤالًا، حيث يتم 

120
00:08:50,030 --> 00:08:53,380
طرح أسئلة بنعم أو لا مما يؤدي إلى تقطيع مساحة الاحتمالات إلى النصف. 

121
00:08:54,160 --> 00:08:56,703
على سبيل المثال، لنفترض أننا قمنا بإجراء فحص التكافؤ على 

122
00:08:56,703 --> 00:08:59,380
هذه البتات الثمانية فقط، وجميع المواضع ذات الأرقام الفردية. 

123
00:09:00,100 --> 00:09:04,460
ثم إذا تم اكتشاف خطأ، فإنه يمنح المتلقي المزيد من المعلومات 

124
00:09:04,460 --> 00:09:08,240
حول مكان الخطأ على وجه التحديد، أي أنه في وضع فردي. 

125
00:09:08,940 --> 00:09:12,644
إذا لم يتم اكتشاف أي خطأ بين تلك البتات الثمانية، فهذا يعني إما عدم 

126
00:09:12,644 --> 00:09:16,240
وجود خطأ على الإطلاق، أو أنه موجود في مكان ما في المواضع الزوجية. 

127
00:09:17,180 --> 00:09:22,069
قد تظن أن قصر فحص التكافؤ على نصف البتات يجعله أقل فعالية، ولكن عندما يتم إجراؤه 

128
00:09:22,069 --> 00:09:27,200
بالتزامن مع عمليات فحص أخرى مختارة جيدًا، فإنه يمنحنا شيئًا أكثر قوة بشكل غير متوقع. 

129
00:09:29,240 --> 00:09:36,620
لإعداد فحص التكافؤ هذا، تذكر أنه يتطلب تخصيص جزء خاص يتحكم في تكافؤ تلك المجموعة الكاملة. 

130
00:09:37,480 --> 00:09:39,180
هنا دعونا فقط نختار الموضع 1. 

131
00:09:39,720 --> 00:09:43,486
في المثال الموضح، يعد تكافؤ هذه البتات الثمانية أمرًا فرديًا حاليًا، 

132
00:09:43,486 --> 00:09:46,980
لذا يكون المرسل مسؤولاً عن تبديل بت التكافؤ هذا، وهو الآن زوجي. 

133
00:09:47,940 --> 00:09:50,680
هذه عملية واحدة فقط من أصل 4 عمليات فحص تكافؤ سنجريها. 

134
00:09:50,920 --> 00:09:56,300
الفحص الثاني يكون من بين 8 بتات في النصف الأيمن من الشبكة، على الأقل كما رسمناها هنا. 

135
00:09:56,680 --> 00:10:01,513
هذه المرة قد نستخدم الموضع 2 كبت تكافؤ، وبالتالي فإن هذه البتات الثمانية لها بالفعل 

136
00:10:01,513 --> 00:10:06,060
تكافؤ متساوي، ويمكن أن يشعر المرسل بالارتياح عند ترك هذا البت رقم 2 دون تغيير. 

137
00:10:07,020 --> 00:10:11,227
ومن ثم على الطرف الآخر، إذا تحقق المتلقي من تكافؤ هذه المجموعة ووجد أنه أمر 

138
00:10:11,227 --> 00:10:15,380
غريب، فسيعرف أن الخطأ موجود في مكان ما بين هذه البتات الثمانية على اليمين. 

139
00:10:15,820 --> 00:10:20,580
وإلا فهذا يعني أنه لا يوجد خطأ، أو أن الخطأ موجود في مكان ما في النصف الأيسر. 

140
00:10:21,120 --> 00:10:23,675
أو أعتقد أنه من الممكن أن يكون هناك خطأين، ولكن في الوقت 

141
00:10:23,675 --> 00:10:26,500
الحالي سنفترض أن هناك خطأ واحدًا على الأكثر في الكتلة بأكملها. 

142
00:10:26,940 --> 00:10:28,740
تنهار الأمور تمامًا لأكثر من ذلك. 

143
00:10:29,160 --> 00:10:32,005
هنا، قبل أن ننظر إلى الفحصين التاليين، توقف لحظة للتفكير 

144
00:10:32,005 --> 00:10:35,100
فيما يسمح لنا بهذين الاختبارين الأولين عندما تفكر فيهما معًا. 

145
00:10:35,800 --> 00:10:39,660
لنفترض أنك اكتشفت خطأ بين الأعمدة الفردية وبين النصف الأيمن. 

146
00:10:40,200 --> 00:10:43,040
وهذا يعني بالضرورة أن الخطأ موجود في مكان ما في العمود الأخير. 

147
00:10:43,820 --> 00:10:46,615
إذا لم يكن هناك خطأ في العمود الفردي ولكن كان هناك خطأ في 

148
00:10:46,615 --> 00:10:49,700
النصف الأيمن، فهذا يخبرك أنه موجود في العمود الثاني قبل الأخير. 

149
00:10:50,440 --> 00:10:53,447
وبالمثل، إذا كان هناك خطأ في الأعمدة الفردية ولكن ليس في 

150
00:10:53,447 --> 00:10:56,560
النصف الأيمن، فاعلم أنه موجود في مكان ما في العمود الثاني. 

151
00:10:56,560 --> 00:10:59,885
وإذا لم يكتشف أي من هذين التحققين من التكافؤ أي شيء، فهذا يعني أن المكان 

152
00:10:59,885 --> 00:11:03,120
الوحيد الذي يمكن أن يوجد فيه خطأ هو ذلك العمود الموجود في أقصى اليسار. 

153
00:11:03,340 --> 00:11:06,120
ولكنه قد يعني أيضًا أنه لا يوجد خطأ على الإطلاق. 

154
00:11:06,300 --> 00:11:10,840
وهي طريقة متقنة إلى حد ما للقول إن فحصي التكافؤ يسمحان لنا بتحديد العمود. 

155
00:11:11,480 --> 00:11:13,640
من هنا، ربما يمكنك تخمين ما يلي. 

156
00:11:13,800 --> 00:11:16,140
نحن نفعل نفس الشيء بشكل أساسي ولكن بالنسبة للصفوف. 

157
00:11:16,440 --> 00:11:20,900
سيكون هناك فحص للتكافؤ في الصفوف الفردية، باستخدام الموضع 4 كبت تكافؤ. 

158
00:11:21,380 --> 00:11:25,820
لذلك في هذا المثال، هذه المجموعة لديها بالفعل تكافؤ زوجي، لذا سيتم تعيين البت 4 على 0. 

159
00:11:26,560 --> 00:11:31,580
وأخيرًا، هناك فحص تكافؤ في الصفين السفليين، باستخدام الموضع 8 كبت تكافؤ. 

160
00:11:32,120 --> 00:11:36,820
في هذه الحالة، يبدو أن المرسل بحاجة إلى تشغيل هذا البت 8 من أجل منح المجموعة التكافؤ. 

161
00:11:37,700 --> 00:11:39,770
تمامًا كما تتيح لنا عمليتا التحقق الأولين تثبيت 

162
00:11:39,770 --> 00:11:41,840
العمود، تتيح لك الوظيفتان التاليتان تثبيت الصف. 

163
00:11:42,880 --> 00:11:47,540
على سبيل المثال، تخيل أنه أثناء الإرسال، حدث خطأ في الموضع 3 على سبيل المثال. 

164
00:11:48,180 --> 00:11:51,920
حسنًا، يؤثر هذا على مجموعة التكافؤ الأولى، ويؤثر أيضًا على مجموعة التكافؤ 

165
00:11:51,920 --> 00:11:55,560
الثانية، لذلك يعرف المتلقي أن هناك خطأ في مكان ما في هذا العمود الأيمن. 

166
00:11:56,100 --> 00:12:00,540
لكنه لا يؤثر على المجموعة الثالثة، ولا يؤثر على المجموعة الرابعة. 

167
00:12:01,240 --> 00:12:04,409
وهذا يتيح للمتلقي تحديد الخطأ حتى الصف الأول، وهو ما 

168
00:12:04,409 --> 00:12:07,520
يعني بالضرورة الموضع 3، حتى يتمكنوا من إصلاح الخطأ. 

169
00:12:08,580 --> 00:12:12,808
قد تستمتع بتخصيص بعض الوقت لإقناع نفسك بأن الإجابات على هذه الأسئلة 

170
00:12:12,808 --> 00:12:17,100
الأربعة ستسمح لك دائمًا بتحديد موقع معين، بغض النظر عن مكان تواجدهم. 

171
00:12:17,720 --> 00:12:23,060
في الواقع، قد يلاحظ الأذكياء بينكم وجود صلة بين هذه الأسئلة والعد الثنائي. 

172
00:12:23,500 --> 00:12:28,920
وإذا قمت بذلك، دعني أؤكد مرة أخرى، توقف مؤقتًا، حاول بنفسك أن ترسم الارتباط قبل أن أفسده. 

173
00:12:30,500 --> 00:12:36,060
إذا كنت تتساءل عما يحدث إذا تأثرت بتة التكافؤ نفسها، حسنًا، يمكنك تجربتها فقط. 

174
00:12:36,440 --> 00:12:40,457
خذ لحظة للتفكير في كيفية تعقب أي خطأ بين هذه الأجزاء الأربعة الخاصة 

175
00:12:40,457 --> 00:12:44,180
تمامًا مثل أي خطأ آخر، مع نفس المجموعة المكونة من أربعة أسئلة. 

176
00:12:47,060 --> 00:12:50,080
لا يهم حقًا، نظرًا لأن ما نريده في نهاية المطاف هو حماية 

177
00:12:50,080 --> 00:12:53,100
أجزاء الرسالة، فإن وحدات بت تصحيح الأخطاء هي التي تستمر. 

178
00:12:53,600 --> 00:12:57,820
لكن حماية تلك البتات أيضًا هو أمر يخرج بشكل طبيعي عن المخطط كمنتج ثانوي. 

179
00:12:59,200 --> 00:13:01,760
قد تستمتع أيضًا بتوقع كيفية قياس هذا الأمر. 

180
00:13:02,300 --> 00:13:07,287
إذا استخدمنا كتلة بحجم 256 بت، على سبيل المثال، لتحديد موقع ما، فأنت 

181
00:13:07,287 --> 00:13:12,780
تحتاج فقط إلى ثمانية أسئلة بنعم أو لا للبحث الثنائي في طريقك إلى مكان محدد. 

182
00:13:15,640 --> 00:13:20,500
وتذكر أن كل سؤال يتطلب التخلي عن جزء واحد فقط لتعيين التحقق من التكافؤ المناسب. 

183
00:13:23,160 --> 00:13:26,365
ربما يراها البعض منكم بالفعل، لكننا سنتحدث لاحقًا عن الطريقة 

184
00:13:26,365 --> 00:13:29,360
المنهجية للعثور على هذه الأسئلة في دقيقة أو دقيقتين فقط. 

185
00:13:29,880 --> 00:13:33,260
نأمل أن يكون هذا المخطط كافيًا لتقدير كفاءة ما نقوم بتطويره هنا. 

186
00:13:33,260 --> 00:13:37,577
أول شيء، باستثناء تلك البتات الثمانية المتماثلة المميزة، 

187
00:13:37,577 --> 00:13:41,820
يمكن أن تكون كما تريد، وتحمل أي رسالة أو بيانات تريدها. 

188
00:13:41,820 --> 00:13:45,832
تعتبر البتات الثمانية زائدة عن الحاجة، بمعنى أنه يتم تحديدها بالكامل 

189
00:13:45,832 --> 00:13:50,020
من خلال بقية الرسالة، ولكنها بطريقة أكثر ذكاءً من مجرد نسخ الرسالة ككل. 

190
00:13:53,600 --> 00:13:58,380
ومع ذلك، مقابل القليل جدًا من الاستسلام، ستكون قادرًا على تحديد وإصلاح أي خطأ في البتات. 

191
00:13:59,200 --> 00:14:00,400
حسنًا تقريبًا. 

192
00:14:00,960 --> 00:14:04,978
حسنًا، المشكلة الوحيدة هنا هي أنه إذا لم تكتشف أي من عمليات التحقق من 

193
00:14:04,978 --> 00:14:09,110
التكافؤ وجود خطأ، مما يعني أن المجموعات الفرعية المحددة خصيصًا والمكونة 

194
00:14:09,110 --> 00:14:13,071
من 8 بتات جميعها لها تماثلات زوجية، تمامًا كما قصد المرسل، فهذا يعني 

195
00:14:13,071 --> 00:14:16,860
إما أنه لم يكن هناك خطأ على الإطلاق أو أنه يضيق بنا إلى الموضع 0. 

196
00:14:17,740 --> 00:14:22,378
كما ترى، مع أربعة أسئلة بنعم أو لا، لدينا 16 نتيجة محتملة لعمليات التحقق من 

197
00:14:22,378 --> 00:14:26,956
التكافؤ، وفي البداية يبدو ذلك مثاليًا لتحديد موضع واحد من أصل 16 موضعًا في 

198
00:14:26,956 --> 00:14:31,900
الكتلة، ولكنك تحتاج أيضًا إلى توصيل النتيجة السابعة عشرة، وهي عدم وجود خطأ حالة. 

199
00:14:33,020 --> 00:14:37,300
الحل هنا بسيط جدًا في الواقع، فقط انسَ هذا الجزء 0 تمامًا. 

200
00:14:37,840 --> 00:14:40,722
لذلك عندما نقوم بعمليات التحقق من التكافؤ الأربعة ونرى أنها 

201
00:14:40,722 --> 00:14:43,460
كلها متساوية، فهذا يعني بشكل لا لبس فيه أنه لا يوجد خطأ. 

202
00:14:44,240 --> 00:14:48,848
ما يعنيه ذلك هو أنه بدلًا من العمل مع كتلة مكونة من 16 بت، فإننا نعمل مع كتلة 

203
00:14:48,848 --> 00:14:53,220
مكونة من 15 بت، حيث يكون 11 بتًا مجانيًا لحمل رسالة و4 بتات منها للتكرار. 

204
00:14:53,780 --> 00:15:00,200
وبهذا، أصبح لدينا الآن ما يشير إليه الأشخاص في هذا المجال برمز هامينغ 15-11. 

205
00:15:00,460 --> 00:15:04,371
ومع ذلك، من الجيد أن يكون لدينا حجم كتلة يساوي قوة نظيفة تبلغ 2، وهناك طريقة ذكية 

206
00:15:04,371 --> 00:15:08,140
يمكننا من خلالها الاحتفاظ بهذا الجزء الصفري وجعله يقوم ببعض العمل الإضافي لنا. 

207
00:15:08,700 --> 00:15:12,064
إذا استخدمناها كبتة تكافؤ عبر الكتلة بأكملها، فإنها تتيح لنا 

208
00:15:12,064 --> 00:15:15,540
بالفعل اكتشاف أخطاء 2 بت، على الرغم من أننا لا نستطيع تصحيحها. 

209
00:15:16,160 --> 00:15:16,820
وإليك كيف يعمل. 

210
00:15:17,180 --> 00:15:21,032
بعد تعيين تلك البتات الأربعة الخاصة لتصحيح الأخطاء، قمنا بتعيين البت 0 

211
00:15:21,032 --> 00:15:24,940
بحيث يكون تكافؤ الكتلة الكاملة متساويًا، تمامًا مثل فحص التكافؤ العادي. 

212
00:15:25,700 --> 00:15:29,567
الآن، إذا كان هناك خطأ بت واحد، فإن تكافؤ الكتلة الكاملة يصبح غريبًا، 

213
00:15:29,567 --> 00:15:33,600
لكننا سنكتشف ذلك على أي حال بفضل عمليات التحقق الأربعة من تصحيح الأخطاء. 

214
00:15:34,160 --> 00:15:37,813
ومع ذلك، إذا كان هناك خطأان، فسيتم تبديل التكافؤ الإجمالي مرة 

215
00:15:37,813 --> 00:15:41,526
أخرى إلى كونه متساويًا، لكن المتلقي سيظل يرى أن هناك على الأقل 

216
00:15:41,526 --> 00:15:45,180
بعض الأخطاء بسبب ما يحدث مع عمليات التحقق من التكافؤ الأربعة. 

217
00:15:45,180 --> 00:15:48,789
لذا، إذا لاحظوا تكافؤًا متساويًا بشكل عام، ولكن حدث شيء غير 

218
00:15:48,789 --> 00:15:52,700
صفري مع عمليات التحقق الأخرى، فهذا يخبرهم بوجود خطأين على الأقل. 

219
00:15:53,520 --> 00:15:54,000
أليس هذا ذكيا؟ 

220
00:15:54,300 --> 00:15:57,607
على الرغم من أننا لا نستطيع تصحيح تلك الأخطاء ذات البتتين، إلا أنه 

221
00:15:57,607 --> 00:16:01,260
بمجرد إعادة البتة الصفرية المزعجة هذه إلى العمل، فإنها تتيح لنا اكتشافها. 

222
00:16:02,260 --> 00:16:05,220
يعد هذا أمرًا قياسيًا جدًا، ويُعرف باسم كود هامينج الممتد. 

223
00:16:06,540 --> 00:16:09,710
من الناحية الفنية، لديك الآن وصف كامل لما تفعله 

224
00:16:09,710 --> 00:16:12,880
كود هامينج، على الأقل بالنسبة لمثال كتلة 16 بت. 

225
00:16:12,880 --> 00:16:17,100
لكنني أعتقد أنك ستجد الأمر أكثر إرضاءً للتحقق من فهمك وترسيخ كل شيء حتى 

226
00:16:17,100 --> 00:16:21,320
هذه النقطة من خلال القيام بمثال واحد كامل من البداية إلى النهاية بنفسك. 

227
00:16:22,080 --> 00:16:24,300
سأقوم بالخطوات معك حتى تتمكن من التحقق بنفسك. 

228
00:16:25,120 --> 00:16:29,922
لإعداد رسالة، سواء كانت رسالة حرفية تترجمها عبر مساحة أو بعض البيانات التي 

229
00:16:29,922 --> 00:16:34,660
تريد تخزينها مع مرور الوقت، فإن الخطوة الأولى هي تقسيمها إلى أجزاء 11 بت. 

230
00:16:35,580 --> 00:16:39,760
سيتم تجميع كل قطعة في كتلة 16 بت مقاومة للأخطاء. 

231
00:16:39,760 --> 00:16:43,220
لذلك دعونا نأخذ هذا كمثال ونعمل عليه بالفعل. 

232
00:16:43,740 --> 00:16:44,740
المضي قدما، في الواقع القيام بذلك! 

233
00:16:44,740 --> 00:16:47,020
دعونا نتوقف مؤقتًا ونحاول تجميع هذه الكتلة معًا. 

234
00:16:52,720 --> 00:16:53,680
حسنًا، هل أنت مستعد؟ 

235
00:16:54,240 --> 00:16:58,936
تذكر أن الموضع 0 إلى جانب القوى الأخرى للرقم 2 محجوزة لمهمة تصحيح الأخطاء، 

236
00:16:58,936 --> 00:17:03,320
لذا عليك أن تبدأ بوضع بتات الرسالة في جميع الأماكن المتبقية بالترتيب. 

237
00:17:05,339 --> 00:17:08,811
أنت بحاجة إلى أن يكون لهذه المجموعة تكافؤ متساوي، وهو ما يحدث 

238
00:17:08,811 --> 00:17:12,339
بالفعل، لذا يجب عليك تعيين بت التكافؤ هذا في الموضع 1 ليكون 0. 

239
00:17:13,020 --> 00:17:17,880
تبدأ المجموعة التالية بتعادل فردي، لذا يجب عليك تعيين بت التكافؤ الخاص بها ليكون 1. 

240
00:17:19,160 --> 00:17:24,240
تبدأ المجموعة بعد ذلك بتكافؤ فردي، لذلك يجب عليك مرة أخرى ضبط بت التكافؤ الخاص بها على 1. 

241
00:17:24,780 --> 00:17:27,391
والمجموعة الأخيرة لديها أيضًا تكافؤ فردي، مما 

242
00:17:27,391 --> 00:17:30,060
يعني أننا وضعنا هذا الجزء في الموضع 8 ليكون 1. 

243
00:17:31,300 --> 00:17:35,810
وبعد ذلك كخطوة أخيرة، أصبح للكتلة الكاملة الآن تكافؤ متساوي، مما 

244
00:17:35,810 --> 00:17:40,320
يعني أنه يمكنك تعيين رقم البت 0، وهو بت التكافؤ الشامل، ليكون 0. 

245
00:17:41,340 --> 00:17:44,828
لذلك عندما يتم إرسال هذه الكتلة، فإن التكافؤ بين المجموعات 

246
00:17:44,828 --> 00:17:48,140
الفرعية الأربع الخاصة والكتلة ككل سيكون متساويًا، أو 0. 

247
00:17:48,820 --> 00:17:52,180
في الجزء الثاني من التمرين، لنجعلك تلعب دور المتلقي. 

248
00:17:53,480 --> 00:17:56,688
بالطبع، هذا يعني أنك لا تعرف بالفعل ما هي هذه الرسالة، 

249
00:17:56,688 --> 00:17:59,780
ربما البعض منكم يحفظها، ولكن لنفترض أنك لم تفعل ذلك. 

250
00:18:00,020 --> 00:18:07,740
ما سأفعله هو تغيير إما 0 أو 1 أو 2 من البتات في تلك الكتلة، ثم أطلب منك معرفة ما فعلته. 

251
00:18:08,260 --> 00:18:10,810
لذا مرة أخرى، توقف مؤقتًا وحاول حلها. 

252
00:18:18,790 --> 00:18:23,385
حسنًا، أنت الآن كمستلم تتحقق من مجموعة التكافؤ الأولى ويمكنك أن 

253
00:18:23,385 --> 00:18:27,910
ترى أنها زوجية، لذا فإن أي خطأ موجود يجب أن يكون في عمود زوجي. 

254
00:18:29,690 --> 00:18:33,395
الفحص التالي يعطينا رقمًا فرديًا، ويخبرنا بوجود خطأ 

255
00:18:33,395 --> 00:18:37,030
واحد على الأقل، ويضيق نطاقنا في هذا العمود المحدد. 

256
00:18:38,550 --> 00:18:41,790
الفحص الثالث متساوي، مما يقلل من الاحتمالات بشكل أكبر. 

257
00:18:42,650 --> 00:18:46,014
وآخر فحص للتكافؤ أمر غريب، حيث يخبرنا بوجود خطأ في مكان ما في 

258
00:18:46,014 --> 00:18:49,650
الأسفل، والذي يمكننا الآن أن نرى أنه يجب أن يكون في الموضع رقم 10. 

259
00:18:51,490 --> 00:18:54,635
علاوة على ذلك، فإن تكافؤ الكتلة بأكملها أمر غريب، 

260
00:18:54,635 --> 00:18:57,530
مما يمنحنا الثقة في وجود قلب واحد وليس اثنين. 

261
00:18:58,070 --> 00:18:59,970
إذا كان هناك ثلاثة أو أكثر، كل الرهانات ملغاة. 

262
00:19:01,310 --> 00:19:05,361
بعد تصحيح البت رقم 10، فإن سحب البتات الـ 11 التي لم يتم 

263
00:19:05,361 --> 00:19:09,627
استخدامها للتصحيح يعطينا الجزء ذي الصلة من الرسالة الأصلية، 

264
00:19:09,627 --> 00:19:14,390
والذي إذا قمت بالترجيع والمقارنة فهو في الواقع ما بدأنا به المثال. 

265
00:19:15,710 --> 00:19:19,492
والآن بعد أن عرفت كيفية القيام بكل هذا يدويًا، أود أن أوضح لك كيف يمكنك 

266
00:19:19,492 --> 00:19:23,170
تنفيذ الجزء الأساسي من كل هذا المنطق باستخدام سطر واحد من كود بايثون. 

267
00:19:23,870 --> 00:19:28,719
كما ترى، ما لم أخبرك به بعد هو مدى أناقة هذه الخوارزمية حقًا، ومدى بساطة 

268
00:19:28,719 --> 00:19:33,635
جعل الآلة تشير إلى موضع الخطأ، وكيفية قياسه بشكل منهجي، وكيف يمكننا تأطير 

269
00:19:33,635 --> 00:19:38,750
كل ذلك هذا كعملية واحدة بدلاً من عمليات التحقق من التكافؤ المنفصلة المتعددة. 

270
00:19:39,430 --> 00:19:41,310
لتعرف ما أعنيه، تعال وانضم إلي في الجزء الثاني. 

