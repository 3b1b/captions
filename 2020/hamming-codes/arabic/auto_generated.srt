1
00:00:00,000 --> 00:00:03,120
أفترض أن الجميع هنا قادمون من الجزء الأول.

2
00:00:03,120 --> 00:00:07,752
كنا نتحدث عن رموز هامينج، وهي طريقة لإنشاء كتلة من البيانات حيث تحمل

3
00:00:07,752 --> 00:00:12,385
معظم البتات رسالة ذات معنى، بينما يعمل عدد قليل آخر كنوع من التكرار،

4
00:00:12,385 --> 00:00:17,152
بطريقة بحيث إذا تم قلب أي جزء، إما رسالة بت أو بت متكرر، أي شيء في هذه

5
00:00:17,152 --> 00:00:21,920
الكتلة، سيكون جهاز الاستقبال قادرًا على تحديد وجود خطأ، وكيفية إصلاحه.

6
00:00:21,920 --> 00:00:25,760
كانت الفكرة الأساسية المقدمة هناك هي كيفية استخدام عمليات

7
00:00:25,760 --> 00:00:29,800
التحقق من التكافؤ المتعددة للبحث الثنائي في طريقك إلى الخطأ.

8
00:00:29,800 --> 00:00:32,826
كان الهدف في هذا الفيديو هو جعل رموز هامينج تبدو

9
00:00:32,826 --> 00:00:35,420
عملية وقابلة لإعادة الاكتشاف قدر الإمكان.

10
00:00:35,420 --> 00:00:39,613
ولكن عندما تبدأ في التفكير في تنفيذ هذا فعليًا، سواء في البرامج أو

11
00:00:39,613 --> 00:00:44,120
الأجهزة، فإن هذا الإطار قد يقلل في الواقع من مدى أناقة هذه الرموز حقًا.

12
00:00:44,120 --> 00:00:49,107
قد تظن أنك بحاجة إلى كتابة خوارزمية تتتبع جميع مواقع الأخطاء المحتملة وتقطع

13
00:00:49,107 --> 00:00:54,160
تلك المجموعة إلى النصف مع كل عملية تحقق، ولكنها في الواقع أبسط من ذلك بكثير.

14
00:00:54,160 --> 00:00:59,257
إذا قرأت الإجابات على عمليات التحقق من التكافؤ الأربعة التي قمنا بها في الفيديو

15
00:00:59,257 --> 00:01:04,800
الأخير، كلها كـ 1 و0 بدلاً من نعم ولا، فإنها توضح حرفيًا موضع الخطأ في النظام الثنائي.

16
00:01:04,800 --> 00:01:12,640
على سبيل المثال، الرقم 7 في النظام الثنائي يبدو مثل 0111، مما يعني أنه 4 زائد 2 زائد 1.

17
00:01:12,640 --> 00:01:17,541
ولاحظ أين يقع الموضع 7، فهو يؤثر بالفعل على المجموعة الأولى

18
00:01:17,541 --> 00:01:22,280
من مجموعات التكافؤ، والثانية، والثالثة، ولكن ليس الأخيرة.

19
00:01:22,280 --> 00:01:25,171
لذا فإن قراءة نتائج عمليات التحقق الأربعة هذه

20
00:01:25,171 --> 00:01:28,000
من الأسفل إلى الأعلى توضح بالفعل موضع الخطأ.

21
00:01:28,000 --> 00:01:32,511
لا يوجد شيء خاص في المثال 7، وهذا يعمل بشكل عام، وهذا

22
00:01:32,511 --> 00:01:37,440
يجعل منطق تنفيذ المخطط بأكمله في الأجهزة بسيطًا بشكل صادم.

23
00:01:37,440 --> 00:01:41,963
الآن إذا كنت تريد معرفة سبب حدوث هذا السحر، فخذ تسميات الفهرس

24
00:01:41,963 --> 00:01:46,341
الستة عشر هذه لمواقعنا، ولكن بدلاً من كتابتها في الأساس 10،

25
00:01:46,341 --> 00:01:50,720
دعنا نكتبها جميعًا بالنظام الثنائي، بدءًا من 0000 حتى 1111.

26
00:01:50,720 --> 00:01:54,613
عندما نعيد هذه التصنيفات الثنائية إلى صناديقها، اسمحوا لي

27
00:01:54,613 --> 00:01:58,440
أن أؤكد أنها مختلفة عن البيانات التي يتم إرسالها بالفعل.

28
00:01:58,440 --> 00:02:01,202
إنها ليست أكثر من مجرد تسمية مفاهيمية لمساعدتي

29
00:02:01,202 --> 00:02:04,200
ومساعدتك في فهم من أين أتت مجموعات التكافؤ الأربع.

30
00:02:04,200 --> 00:02:08,710
ربما يتم تقويض أناقة الحصول على كل ما نتطلع إليه موصوفًا في النظام الثنائي

31
00:02:08,710 --> 00:02:13,160
بسبب الارتباك المتمثل في وجود كل ما نتطلع إليه موصوفًا في النظام الثنائي.

32
00:02:13,160 --> 00:02:15,040
إنه يستحق ذلك، على الرغم من ذلك.

33
00:02:15,040 --> 00:02:19,660
ركز انتباهك فقط على الجزء الأخير من كل هذه التسميات، ثم قم

34
00:02:19,660 --> 00:02:24,280
بتسليط الضوء على المواضع التي يكون فيها الجزء الأخير هو 1.

35
00:02:24,280 --> 00:02:30,135
ما حصلنا عليه هو المجموعة الأولى من مجموعات التكافؤ الأربع لدينا، مما يعني أنه يمكنك

36
00:02:30,135 --> 00:02:36,266
تفسير هذا التحقق الأول على أنه يسأل، إذا كان هناك خطأ، فهل البت الأخير في موضع هذا الخطأ

37
00:02:36,266 --> 00:02:36,680
هو 1؟

38
00:02:36,680 --> 00:02:41,970
وبالمثل، إذا ركزت على الجزء الثاني قبل الأخير، وقمت بتمييز جميع المواضع

39
00:02:41,970 --> 00:02:47,040
التي يكون فيها الرقم 1، فستحصل على مجموعة التكافؤ الثانية من مخططنا.

40
00:02:47,040 --> 00:02:51,394
بمعنى آخر، هذا الفحص الثاني يسألني مرة أخرى، إذا كان

41
00:02:51,394 --> 00:02:56,160
هناك خطأ، فهل الجزء الثاني قبل الأخير من هذا الموضع هو 1؟

42
00:02:56,160 --> 00:02:57,160
وما إلى ذلك وهلم جرا.

43
00:02:57,160 --> 00:03:03,500
يغطي فحص التكافؤ الثالث كل موضع تم تشغيل البت من الثالث إلى الأخير،

44
00:03:03,500 --> 00:03:10,120
ويغطي الأخير المواضع الثمانية الأخيرة، تلك التي يكون أعلى بت لها هو 1.

45
00:03:10,120 --> 00:03:14,770
كل ما فعلناه سابقًا هو نفس الإجابة على هذه الأسئلة الأربعة،

46
00:03:14,770 --> 00:03:18,800
والتي بدورها هي نفس توضيح الموضع في النظام الثنائي.

47
00:03:18,800 --> 00:03:22,080
آمل أن يجعل هذا شيئين أكثر وضوحا.

48
00:03:22,080 --> 00:03:27,140
الأول هو كيفية التعميم بشكل منهجي على أحجام الكتل التي تكون أكبر من قوى اثنين.

49
00:03:27,140 --> 00:03:32,746
إذا كان الأمر يتطلب المزيد من البتات لوصف كل موضع، مثل ستة بتات لوصف 64 نقطة،

50
00:03:32,746 --> 00:03:38,640
فإن كل واحدة من هذه البتات تمنحك إحدى مجموعات التكافؤ التي نحتاج إلى التحقق منها.

51
00:03:38,640 --> 00:03:41,068
أولئك منكم الذين شاهدوا لغز رقعة الشطرنج الذي قمت

52
00:03:41,068 --> 00:03:43,400
به مع مات باركر قد يجدون كل هذا مألوفًا للغاية.

53
00:03:43,400 --> 00:03:46,640
إنه نفس المنطق الأساسي، لكنه يحل مشكلة مختلفة،

54
00:03:46,640 --> 00:03:49,880
ويتم تطبيقه على رقعة شطرنج مكونة من 64 مربعًا.

55
00:03:49,880 --> 00:03:53,931
الأمر الثاني الذي آمل أن يوضحه هذا هو سبب وجود بتات التكافؤ

56
00:03:53,931 --> 00:03:58,320
لدينا في مواضع تمثل قوى العدد اثنين، على سبيل المثال 1 و2 و4 و8.

57
00:03:58,320 --> 00:04:03,640
هذه هي المواضع التي تم تشغيل تمثيلها الثنائي بمقدار بت واحد فقط.

58
00:04:03,640 --> 00:04:07,917
ما يعنيه ذلك هو أن كل واحدة من بتات التكافؤ هذه

59
00:04:07,917 --> 00:04:12,640
تقع داخل مجموعة واحدة فقط من مجموعات التكافؤ الأربع.

60
00:04:12,640 --> 00:04:19,225
يمكنك أيضًا رؤية ذلك في أمثلة أكبر، حيث بغض النظر عن حجمها،

61
00:04:19,225 --> 00:04:25,920
فإن كل بتة تكافؤ تلامس بسهولة مجموعة واحدة فقط من المجموعات.

62
00:04:25,920 --> 00:04:30,395
بمجرد أن تفهم أن عمليات التحقق من التكافؤ هذه التي ركزنا عليها كثيرًا من وقتنا

63
00:04:30,395 --> 00:04:34,758
ليست أكثر من طريقة ذكية لتوضيح موضع الخطأ في النظام الثنائي، فيمكننا بعد ذلك

64
00:04:34,758 --> 00:04:39,347
رسم اتصال بطريقة مختلفة للتفكير في الهام الرموز، التي يمكن القول إنها أبسط بكثير

65
00:04:39,347 --> 00:04:43,880
وأكثر أناقة، والتي يمكن كتابتها أساسًا باستخدام سطر واحد من التعليمات البرمجية.

66
00:04:43,880 --> 00:04:46,200
يعتمد على وظيفة XOR.

67
00:04:46,200 --> 00:04:50,960
XOR، لأولئك منكم الذين لا يعرفون، يرمز إلى حصري أو.

68
00:04:50,960 --> 00:04:55,661
عندما تأخذ XOR لبتين، فسوف يُرجع 1 إذا تم تشغيل أي من تلك

69
00:04:55,661 --> 00:05:00,200
البتات، ولكن ليس إذا تم تشغيل كليهما أو إيقاف تشغيلهما.

70
00:05:00,200 --> 00:05:03,760
بصياغة مختلفة، إنه التكافؤ بين هاتين القطعتين.

71
00:05:03,760 --> 00:05:07,840
باعتباري متخصصًا في الرياضيات، أفضّل التفكير في الأمر على أنه تعديل الإضافة 2.

72
00:05:07,840 --> 00:05:10,684
نتحدث أيضًا بشكل شائع عن XOR لسلسلتين مختلفتين من

73
00:05:10,684 --> 00:05:14,040
البتات، والتي تقوم بشكل أساسي بتنفيذ هذا المكون تلو الآخر.

74
00:05:14,040 --> 00:05:16,280
إنها مثل الإضافة، ولكن حيث لا تحملها أبدًا.

75
00:05:16,280 --> 00:05:19,724
مرة أخرى، قد يفضل الأشخاص الأكثر ميلاً للرياضيات

76
00:05:19,724 --> 00:05:23,520
التفكير في هذا على أنه إضافة متجهين وتقليل التعديل 2.

77
00:05:23,520 --> 00:05:29,305
إذا قمت بفتح بعض لغة Python الآن وقمت بتطبيق عملية علامة الإقحام بين عددين

78
00:05:29,305 --> 00:05:35,400
صحيحين، فهذا ما تفعله ولكن على تمثيلات البت لتلك الأرقام الموجودة أسفل الغطاء.

79
00:05:35,400 --> 00:05:40,540
النقطة الأساسية بالنسبة لي ولكم هي أن أخذ XOR للعديد من سلاسل

80
00:05:40,540 --> 00:05:45,764
البت المختلفة هو وسيلة فعالة لحساب المحاكاة الساخرة لمجموعة من

81
00:05:45,764 --> 00:05:51,320
المجموعات المنفصلة، كما هو الحال مع الأعمدة، كل ذلك في ضربة واحدة.

82
00:05:51,320 --> 00:05:55,526
وهذا يمنحنا طريقة رائعة إلى حد ما للتفكير في عمليات التحقق من التكافؤ المتعددة

83
00:05:55,526 --> 00:05:59,680
من خوارزمية كود هامينج الخاصة بنا حيث يتم تجميعها جميعًا معًا في عملية واحدة.

84
00:05:59,680 --> 00:06:02,800
على الرغم من أنها تبدو للوهلة الأولى مختلفة تمامًا.

85
00:06:02,800 --> 00:06:08,216
اكتب على وجه التحديد المواضع الستة عشر في النظام الثنائي، كما

86
00:06:08,216 --> 00:06:13,458
فعلنا من قبل، وقم الآن بتمييز المواضع التي تم فيها تشغيل بت

87
00:06:13,458 --> 00:06:19,400
الرسالة إلى 1، ثم قم بتجميع هذه المواضع في عمود واحد كبير وأخذ XOR.

88
00:06:19,400 --> 00:06:25,816
ربما يمكنك تخمين أن البتات الأربعة الموجودة في الأسفل نتيجة لذلك هي نفس عمليات

89
00:06:25,816 --> 00:06:32,720
التحقق من التكافؤ الأربعة التي عرفناها ونحبها، ولكن خذ لحظة للتفكير في السبب بالضبط.

90
00:06:32,720 --> 00:06:36,973
هذا العمود الأخير، على سبيل المثال، يقوم بإحصاء جميع المواضع التي يكون

91
00:06:36,973 --> 00:06:41,227
الجزء الأخير منها هو 1، ولكننا يقتصرون بالفعل على المواضع المميزة فقط،

92
00:06:41,227 --> 00:06:45,960
لذا فهو يحسب بشكل فعال عدد المواضع المميزة التي جاءت من مجموعة التكافؤ الأولى.

93
00:06:45,960 --> 00:06:48,520
هل هذا منطقي؟

94
00:06:48,520 --> 00:06:54,435
وبالمثل، يقوم العمود التالي بحساب عدد المواضع الموجودة في مجموعة التكافؤ الثانية،

95
00:06:54,435 --> 00:07:00,640
والمواضع التي يكون البت الثاني قبل الأخير هو 1، والتي يتم تمييزها أيضًا، وما إلى ذلك.

96
00:07:00,640 --> 00:07:06,640
إنه في الحقيقة مجرد تحول بسيط في المنظور حول نفس الشيء الذي كنا نفعله.

97
00:07:06,640 --> 00:07:10,000
وهكذا تعرف إلى أين يتجه الأمر من هنا.

98
00:07:10,000 --> 00:07:19,640
يكون المرسل مسؤولاً عن تبديل بعض بتات التكافؤ الخاصة للتأكد من أن المبلغ يصل إلى 0000.

99
00:07:19,640 --> 00:07:24,058
الآن، بمجرد أن يصبح الأمر بهذا الشكل، فهذا يمنحنا طريقة رائعة للتفكير في

100
00:07:24,058 --> 00:07:28,720
السبب وراء توضيح هذه البتات الأربعة الناتجة في الأسفل موضع الخطأ بشكل مباشر.

101
00:07:28,720 --> 00:07:32,680
لنفترض أنه تم تبديل جزء ما في هذه الكتلة من 0 إلى 1.

102
00:07:32,680 --> 00:07:38,781
ما يعنيه ذلك هو أن موضع هذا البت سيتم الآن تضمينه في إجمالي XOR، مما يغير

103
00:07:38,781 --> 00:07:44,800
المجموع من 0 إلى هذه القيمة المضمنة حديثًا بدلاً من ذلك، وهو موضع الخطأ.

104
00:07:44,800 --> 00:07:49,800
وبشكل أقل وضوحًا، ينطبق الأمر نفسه إذا كان هناك خطأ يؤدي إلى تغيير 1 إلى 0.

105
00:07:49,800 --> 00:07:54,284
كما ترى، إذا قمت بإضافة سلسلة صغيرة معًا مرتين، فهذا يعني

106
00:07:54,284 --> 00:07:59,000
عدم وجودها على الإطلاق، لأنه في هذا العالم 1 زائد 1 يساوي 0.

107
00:07:59,000 --> 00:08:05,400
لذا فإن إضافة نسخة من هذا الموضع إلى المجموع الإجمالي له نفس التأثير الذي نحركه به.

108
00:08:05,400 --> 00:08:13,480
وهذا التأثير، مرة أخرى، هو أن النتيجة الإجمالية في الأسفل توضح موضع الخطأ.

109
00:08:13,480 --> 00:08:17,800
لتوضيح مدى روعة هذا الأمر، اسمحوا لي أن أعرض سطرًا واحدًا من كود بايثون

110
00:08:17,800 --> 00:08:22,120
الذي أشرت إليه من قبل، والذي سيلتقط تقريبًا كل المنطق في نهاية المتلقي.

111
00:08:22,120 --> 00:08:27,566
سنبدأ بإنشاء مصفوفة عشوائية مكونة من 16 1 و0 لمحاكاة كتلة البيانات، وسأعطيها

112
00:08:27,566 --> 00:08:33,012
بتات الاسم، ولكن بالطبع من الناحية العملية سيكون هذا شيئًا نتلقاه من المرسل،

113
00:08:33,012 --> 00:08:38,600
وبدلاً من ذلك نظرًا لكونها عشوائية، فإنها ستحمل 11 بتة بيانات مع 5 بتات تكافؤ.

114
00:08:38,600 --> 00:08:43,304
إذا قمت باستدعاء الدالة enumerateBits، فإن ما تفعله هو إقران

115
00:08:43,304 --> 00:08:48,240
كل من تلك البتات مع فهرس مناظر، في هذه الحالة يعمل من 0 إلى 15.

116
00:08:48,240 --> 00:08:52,749
لذا، إذا قمنا بعد ذلك بإنشاء قائمة تدور حول كل هذه الأزواج،

117
00:08:52,749 --> 00:08:57,410
الأزواج التي تبدو مثل i، ثم قمنا بسحب قيمة i فقط، فقط الفهرس،

118
00:08:57,410 --> 00:09:01,920
حسنًا، الأمر ليس مثيرًا، سنستعيد تلك المؤشرات من 0 إلى 15 .

119
00:09:01,920 --> 00:09:07,450
ولكن إذا أضفنا شرطًا للقيام بذلك فقط إذا كانت البتة، مما يعني أنه إذا كانت تلك

120
00:09:07,450 --> 00:09:13,400
البتة هي 1 وليس 0، فحسنًا فإنها تسحب فقط المواضع التي يتم فيها تشغيل البتة المقابلة.

121
00:09:13,400 --> 00:09:20,320
في هذه الحالة يبدو أن هذه المواضع هي 0، 4، 6، 9، إلخ.

122
00:09:20,320 --> 00:09:29,960
ما نريده هو جمع كل تلك المواضع معًا، مواضع البتات التي تم تشغيلها، ثم XOR معًا.

123
00:09:29,960 --> 00:09:33,960
للقيام بذلك في بايثون، اسمحوا لي أولاً باستيراد وظيفتين مفيدتين.

124
00:09:33,960 --> 00:09:39,140
بهذه الطريقة يمكننا استدعاء الدالة تقليل() في هذه القائمة، واستخدام الدالة XOR لتقليلها.

125
00:09:39,140 --> 00:09:44,840
وهذا في الأساس يشق طريقه عبر القائمة، ويأخذ XORs على طول الطريق.

126
00:09:44,840 --> 00:09:52,200
إذا كنت تفضل ذلك، يمكنك كتابة دالة XOR بوضوح دون الحاجة إلى استيرادها من أي مكان.

127
00:09:52,200 --> 00:09:57,177
لذا، في الوقت الحالي، يبدو أننا إذا فعلنا ذلك على الكتلة العشوائية

128
00:09:57,177 --> 00:10:02,080
المكونة من 16 بت، فإنها ستُرجع 9، والتي لها التمثيل الثنائي 1001.

129
00:10:02,080 --> 00:10:06,823
لن نفعل ذلك هنا، ولكن يمكنك كتابة دالة يستخدم فيها المرسل هذا التمثيل الثنائي لتعيين

130
00:10:06,823 --> 00:10:11,456
وحدات البت التماثلية الأربعة حسب الحاجة، وفي النهاية توصيل هذه الكتلة إلى حالة حيث

131
00:10:11,456 --> 00:10:16,200
يؤدي تشغيل هذا السطر من التعليمات البرمجية على القائمة الكاملة للبتات إلى إرجاعها 0.

132
00:10:16,200 --> 00:10:20,200
سيتم اعتبار هذا كتلة جيدة الإعداد.

133
00:10:20,200 --> 00:10:25,400
الأمر الرائع هو أنه إذا قمنا بتبديل أي من البتات في هذه القائمة، لمحاكاة خطأ عشوائي

134
00:10:25,400 --> 00:10:30,600
من الضوضاء، ثم إذا قمت بتشغيل نفس السطر من التعليمات البرمجية، فإنه يطبع هذا الخطأ.

135
00:10:30,600 --> 00:10:31,920
أليس هذا أنيق؟

136
00:10:31,920 --> 00:10:37,149
يمكنك الحصول على هذه الكتلة فجأة، وتشغيل هذا السطر الفردي

137
00:10:37,149 --> 00:10:42,920
عليها، وسيظهر تلقائيًا موضع الخطأ، أو 0 إذا لم يكن هناك أي خطأ.

138
00:10:42,920 --> 00:10:45,520
وليس هناك شيء خاص بخصوص الحجم 16 هنا.

139
00:10:45,520 --> 00:10:52,280
سيعمل نفس السطر من التعليمات البرمجية إذا كان لديك قائمة، على سبيل المثال، 256 بت.

140
00:10:52,280 --> 00:10:56,567
وغني عن القول أن هناك المزيد من التعليمات البرمجية التي يجب كتابتها

141
00:10:56,567 --> 00:11:00,855
هنا، مثل إجراء فحص التكافؤ التعريفي لاكتشاف أخطاء 2 بت، ولكن الفكرة

142
00:11:00,855 --> 00:11:05,080
هي أن كل المنطق الأساسي تقريبًا من مخططنا يعود إلى تقليل XOR واحد.

143
00:11:05,080 --> 00:11:12,405
الآن، اعتمادًا على راحتك مع الثنائيات وXORs والبرامج بشكل عام، قد تجد هذا المنظور مربكًا

144
00:11:12,405 --> 00:11:19,320
بعض الشيء، أو أكثر أناقة وبساطة لدرجة أنك تتساءل لماذا لم نبدأ به من البداية -يذهب.

145
00:11:19,320 --> 00:11:23,400
بشكل عام، من الأسهل التفكير في منظور التحقق من التكافؤ المتعدد عند

146
00:11:23,400 --> 00:11:27,420
تنفيذ رموز Hamming في الأجهزة بشكل مباشر جدًا، ومن الأسهل التفكير

147
00:11:27,420 --> 00:11:31,380
في منظور XOR عند القيام بذلك في البرامج، من مستوى أعلى نوعًا ما.

148
00:11:31,380 --> 00:11:37,926
الأول هو الأسهل في الواقع للقيام به يدويًا، وأعتقد أنه يقوم بعمل أفضل في غرس الحدس

149
00:11:37,926 --> 00:11:44,394
الأساسي الكامن وراء كل هذا، وهو أن المعلومات المطلوبة لتحديد موقع خطأ واحد مرتبطة

150
00:11:44,394 --> 00:11:51,020
بسجل حجم الكتلة أو بعبارة أخرى، فإنه ينمو قطعة واحدة في كل مرة مع تضاعف حجم الكتلة.

151
00:11:51,020 --> 00:11:56,440
الحقيقة ذات الصلة هنا هي أن هذه المعلومات تتوافق بشكل مباشر مع مقدار التكرار الذي نحتاجه.

152
00:11:56,440 --> 00:12:01,823
وهذا حقًا ما يتعارض مع رد فعل معظم الأشخاص غير المحسوبين عندما يفكرون لأول مرة في جعل

153
00:12:01,823 --> 00:12:07,081
رسالة مقاومة للأخطاء، حيث عادةً ما يكون نسخ الرسالة بأكملها هو أول غريزة تتبادر إلى

154
00:12:07,081 --> 00:12:07,520
ذهنهم.

155
00:12:07,520 --> 00:12:11,014
وبعد ذلك، بالمناسبة، هناك طريقة أخرى تمامًا حيث ترى أحيانًا

156
00:12:11,014 --> 00:12:14,800
رموز هامينج معروضة، حيث تقوم بضرب الرسالة في مصفوفة واحدة كبيرة.

157
00:12:14,800 --> 00:12:20,020
إنه لطيف نوعًا ما لأنه يرتبط بعائلة أوسع من الرموز الخطية، لكنني

158
00:12:20,020 --> 00:12:25,160
أعتقد أن هذا لا يعطي أي فكرة تقريبًا عن مصدرها أو كيفية قياسها.

159
00:12:25,160 --> 00:12:32,200
وبالحديث عن القياس، قد تلاحظ أن كفاءة هذا المخطط تتحسن فقط عندما نزيد حجم الكتلة.

160
00:12:32,200 --> 00:12:37,889
على سبيل المثال، رأينا أنه مع 256 بت، فإنك تستخدم 3% فقط

161
00:12:37,889 --> 00:12:43,480
من تلك المساحة للتكرار، ويستمر الأمر في التحسن من هناك.

162
00:12:43,480 --> 00:12:49,040
ومع زيادة عدد البتات المتماثلة واحدة تلو الأخرى، يستمر حجم الكتلة في التضاعف.

163
00:12:49,040 --> 00:12:54,920
وإذا أخذت ذلك إلى أقصى الحدود، يمكن أن يكون لديك كتلة تحتوي، على سبيل المثال، على مليون

164
00:12:54,920 --> 00:13:00,800
بت، حيث يمكنك حرفيًا تشغيل 20 سؤالًا مع اختبارات التكافؤ الخاصة بك، وتستخدم 21 بتة فقط.

165
00:13:00,800 --> 00:13:04,800
وإذا عدت إلى الوراء للتفكير في النظر إلى مليون بت

166
00:13:04,800 --> 00:13:08,640
وتحديد موقع خطأ واحد، فإن هذا يبدو جنونًا حقًا.

167
00:13:08,640 --> 00:13:13,396
المشكلة بالطبع هي أنه مع وجود كتلة أكبر، فإن احتمال رؤية أكثر من خطأ

168
00:13:13,396 --> 00:13:18,360
واحد أو اثنين من الأخطاء، ولا تتعامل رموز هامينج مع أي شيء أبعد من ذلك.

169
00:13:18,360 --> 00:13:21,994
لذا، من الناحية العملية، ما تريده هو العثور على الحجم المناسب بحيث

170
00:13:21,994 --> 00:13:25,520
لا يكون احتمال حدوث عدد كبير جدًا من تقلبات البتات مرتفعًا جدًا.

171
00:13:25,520 --> 00:13:30,819
أيضًا، من الناحية العملية، تميل الأخطاء إلى الظهور على شكل دفعات صغيرة، مما قد يؤدي إلى

172
00:13:30,819 --> 00:13:36,239
تدمير كتلة واحدة تمامًا، لذا فإن أحد الأساليب الشائعة للمساعدة في نشر موجة من الأخطاء عبر

173
00:13:36,239 --> 00:13:41,177
العديد من الكتل المختلفة هو تشبيك تلك الكتل، مثل هذا، قبل أن يتم دمجها إرسالها أو

174
00:13:41,177 --> 00:13:41,720
تخزينها.

175
00:13:41,720 --> 00:13:47,595
ثم مرة أخرى، أصبح الكثير من هذا موضع نقاش تمامًا من خلال أكواد أكثر حداثة،

176
00:13:47,595 --> 00:13:53,470
مثل خوارزمية Reed-Solomon الأكثر استخدامًا، والتي تتعامل مع أخطاء الاندفاع

177
00:13:53,470 --> 00:13:59,580
بشكل جيد، ويمكن ضبطها لتكون مرنة في التعامل مع عدد أكبر من الأخطاء لكل كتلة .

178
00:13:59,580 --> 00:14:03,000
ولكن هذا موضوع لوقت آخر.

179
00:14:03,000 --> 00:14:06,640
في كتابه &quot;فن ممارسة العلوم والهندسة&quot;، كان

180
00:14:06,640 --> 00:14:10,700
هامينغ صريحًا بشكل رائع حول مدى تعقيد اكتشافه لهذا الرمز.

181
00:14:10,700 --> 00:14:14,496
لقد جرب أولاً جميع أنواع المخططات المختلفة التي تتضمن تنظيم

182
00:14:14,496 --> 00:14:18,420
البتات إلى أجزاء من شبكة ذات أبعاد أعلى وأشياء غريبة مثل هذه.

183
00:14:18,420 --> 00:14:23,103
فكرة أنه قد يكون من الممكن الحصول على فحوصات التكافؤ للتآمر بطريقة توضح

184
00:14:23,103 --> 00:14:27,916
موضع الخطأ جاءت إلى هامينج فقط عندما تراجع بعد مجموعة من التحليلات الأخرى

185
00:14:27,916 --> 00:14:32,860
وسأل، حسنًا، ما هو الأكثر كفاءة الذي يمكنني فعله من الممكن أن يكون حول هذا؟

186
00:14:32,860 --> 00:14:37,589
وكان صريحًا أيضًا بشأن مدى أهمية وجود ضوابط التكافؤ في ذهنه بالفعل،

187
00:14:37,589 --> 00:14:42,040
وهو الأمر الذي كان أقل شيوعًا في الأربعينيات مما هو عليه اليوم.

188
00:14:42,040 --> 00:14:46,044
هناك حوالي ست مرات خلال هذا الكتاب يشير فيها إلى

189
00:14:46,044 --> 00:14:49,640
مقولة لويس باستور، الحظ يفضل العقل المستعد.

190
00:14:49,640 --> 00:14:52,380
غالبًا ما تبدو الأفكار الذكية بسيطة بشكل خادع بعد

191
00:14:52,380 --> 00:14:55,120
فوات الأوان، مما يجعل من السهل التقليل من قيمتها.

192
00:14:55,120 --> 00:14:58,442
في الوقت الحالي، أملي الصادق هو أن تكون رموز هامينج، أو على

193
00:14:58,442 --> 00:15:01,820
الأقل إمكانية وجود مثل هذه الرموز، واضحة تقريبًا بالنسبة لك.

194
00:15:01,820 --> 00:15:08,000
لكن لا ينبغي أن تخدع نفسك بالاعتقاد بأنها واضحة بالفعل، لأنها بالتأكيد ليست كذلك.

195
00:15:08,000 --> 00:15:13,521
جزء من السبب الذي يجعل الأفكار الذكية تبدو سهلة بشكل خادع هو أننا لا نرى سوى النتيجة

196
00:15:13,521 --> 00:15:18,848
النهائية، وننظف ما كان فوضويًا، ولا نذكر أبدًا كل المنعطفات الخاطئة، ونقلل من مدى

197
00:15:18,848 --> 00:15:23,980
اتساع مساحة الإمكانيات القابلة للاستكشاف في بداية المشكلة. عملية الحل، كل ذلك.

198
00:15:23,980 --> 00:15:25,280
ولكن هذا صحيح بشكل عام.

199
00:15:25,280 --> 00:15:31,040
أعتقد أنه بالنسبة لبعض الاختراعات الخاصة، هناك سبب ثانٍ وأعمق لعدم تقديرنا لها.

200
00:15:31,040 --> 00:15:35,344
إن التفكير في المعلومات من حيث البتات قد اندمج فعليًا في نظرية كاملة

201
00:15:35,344 --> 00:15:39,400
بحلول عام 1948، مع ورقة كلود شانون الأساسية حول نظرية المعلومات.

202
00:15:39,400 --> 00:15:43,400
كان هذا متزامنًا بشكل أساسي مع قيام هامينج بتطوير خوارزميته.

203
00:15:43,400 --> 00:15:48,565
كانت هذه هي نفس الورقة التأسيسية التي أظهرت، إلى حد ما، أن التصحيح الفعال للأخطاء

204
00:15:48,565 --> 00:15:53,920
أمر ممكن دائمًا، بغض النظر عن مدى احتمالية قلب البتات، على الأقل من الناحية النظرية.

205
00:15:53,920 --> 00:15:58,075
بالمناسبة، كان شانون وهامينج يشتركان في مكتب واحد في Bell Labs، على الرغم

206
00:15:58,075 --> 00:16:02,400
من العمل على أشياء مختلفة تمامًا، وهو الأمر الذي لا يبدو من قبيل الصدفة هنا.

207
00:16:02,400 --> 00:16:07,740
بعد مرور عدة عقود، وفي هذه الأيام، الكثير منا منغمسون جدًا في التفكير في

208
00:16:07,740 --> 00:16:13,080
أجزاء ومعلومات، مما يجعل من السهل التغاضي عن مدى تميز طريقة التفكير هذه.

209
00:16:13,080 --> 00:16:18,102
ومن عجيب المفارقات أن الأفكار التي تشكل بشكل أعمق الطرق التي يفكر بها جيل المستقبل

210
00:16:18,102 --> 00:16:22,640
ستنتهي في النهاية إلى النظر إلى جيل المستقبل بشكل أبسط مما هو عليه بالفعل.

