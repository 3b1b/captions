[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing? ",
  "translatedText": "هل سبق لك أن تساءلت كيف يمكن خدش قرص مضغوط أو قرص DVD مع الاستمرار في تشغيله مهما كان ما يتم تخزينه؟ ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.62,
  "end": 10.1
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors. ",
  "translatedText": "تؤثر عملية الخدش بالفعل على 1 و0 على القرص، لذا فهي تقرأ بيانات مختلفة عما تم تخزينه، ولكن ما لم يتم خدشها بالفعل، فسيتم فك تشفير البتات التي تقرأها في نفس الملف الذي تم ترميزه عليه بالضبط، بت للنسخة بت، على الرغم من كل تلك الأخطاء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 10.9,
  "end": 27.44
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors. ",
  "translatedText": "هناك قدر كبير من الذكاء الرياضي الذي يسمح لنا بتخزين البيانات، وبنفس القدر من الأهمية نقل البيانات، بطريقة مقاومة للأخطاء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 27.44,
  "end": 36.66
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this. ",
  "translatedText": "حسنًا، حسنًا، في الواقع لا يتطلب الأمر الكثير من الذكاء للتوصل إلى طريقة للقيام بذلك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 37.52,
  "end": 41.6
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s. ",
  "translatedText": "أي ملف، سواء كان مقطع فيديو أو صوتًا أو نصًا، أو بعض التعليمات البرمجية، أو صورة، أو أيًا كان، هو في النهاية تسلسل من 1 و0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 42.06,
  "end": 50.38
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit. ",
  "translatedText": "والاستراتيجية البسيطة لتصحيح أي جزء يتم قلبه هي تخزين ثلاث نسخ من كل جزء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 50.68,
  "end": 56.0
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy. ",
  "translatedText": "ثم يمكن للآلة التي تقرأ هذا الملف أن تقارن هذه النسخ الثلاث وتأخذ دائمًا أفضل نسختين من أصل 3 عندما يكون هناك تناقض. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 57.58,
  "end": 64.06
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy. ",
  "translatedText": "ولكن ما يعنيه ذلك هو استخدام ثلثي المساحة الخاصة بك للتكرار. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 67.16,
  "end": 70.86
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped. ",
  "translatedText": "وحتى في هذه الحالة، ورغم كل تلك المساحة التي تم التخلي عنها، ليس هناك ضمان قوي بشأن ما يحدث إذا تم قلب أكثر من بتة واحدة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 71.48,
  "end": 77.24
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible. ",
  "translatedText": "السؤال الأكثر إثارة للاهتمام هو كيفية القيام بذلك بحيث يمكن تصحيح الأخطاء مع ترك أقل مساحة ممكنة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 77.98,
  "end": 84.02
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9! ",
  "translatedText": "على سبيل المثال، باستخدام الطريقة التي ستتعرف عليها في هذا الفيديو، يمكنك تخزين بياناتك في كتل بحجم 256 بت، حيث تستخدم كل كتلة 9 بت، 9! ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 84.52,
  "end": 93.36
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want. ",
  "translatedText": "لتكون بمثابة نوع من التكرار، والـ 247 بت الأخرى حرة في حمل أي رسالة أو بيانات ذات معنى تريدها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 93.76,
  "end": 100.3
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it. ",
  "translatedText": "وسيظل الأمر كذلك، إذا تم قلب أي جزء هنا، فقط من خلال النظر إلى هذه الكتلة وليس أكثر من ذلك، ستتمكن الآلة من تحديد وجود خطأ وتحديد مكانه بدقة حتى تعرف كيفية تصحيحه . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 100.9,
  "end": 112.66
 },
 {
  "input": "And honestly, that feels like magic. ",
  "translatedText": "وبصراحة، هذا يبدو وكأنه سحر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 112.66,
  "end": 114.62
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them. ",
  "translatedText": "وبالنسبة لهذا المخطط بالذات، إذا تم قلب اثنين من البتات، فسيكون الجهاز قادرًا على الأقل على اكتشاف وجود خطأين، على الرغم من أنه لن يعرف كيفية إصلاحهما. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 115.44,
  "end": 122.86
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes. ",
  "translatedText": "سنتحدث بعد قليل عن كيفية قياس ذلك للكتل ذات الأحجام المختلفة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 123.52,
  "end": 126.9
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes. ",
  "translatedText": "تُعرف الطرق التي تتيح لك تصحيح أخطاء مثل هذه، بشكل معقول، باسم رموز تصحيح الأخطاء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 127.86,
  "end": 132.9
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day. ",
  "translatedText": "خلال الجزء الأكبر من القرن الماضي، كان هذا المجال مصدرًا غنيًا حقًا للرياضيات العميقة بشكل مدهش والتي تم دمجها في الأجهزة التي نستخدمها كل يوم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.66,
  "end": 141.94
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code. ",
  "translatedText": "الهدف هنا هو إعطاؤك فهمًا شاملاً لأحد أقدم الأمثلة، والمعروف باسم كود هامينغ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 142.84,
  "end": 148.66
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there. ",
  "translatedText": "وبالمناسبة، الطريقة التي أفكر بها في بنية هذا الفيديو لا تتعلق بشرحها بشكل مباشر قدر الإمكان، بل تتعلق أكثر بدفعك لابتكارها بنفسك، مع القليل من التوجيه اللطيف هنا وهناك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 149.52,
  "end": 159.82
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you. ",
  "translatedText": "لذلك عندما تشعر وكأنك ترى إلى أين ستتجه الأمور في مرحلة ما، توقف في تلك اللحظة، وتوقع بشكل فعال ما سيكون عليه المخطط قبل أن أخبرك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 160.12,
  "end": 166.72
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying. ",
  "translatedText": "أيضًا، إذا كنت تريد أن يصل فهمك إلى مستوى الأجهزة، فقد قام Ben Eater بإنشاء مقطع فيديو بالتزامن مع هذا الفيديو يوضح لك كيفية تنفيذ رموز Hamming فعليًا على لوحات التجارب، وهو أمر مرضٍ للغاية. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 167.24,
  "end": 178.24
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming. ",
  "translatedText": "يجب أن تعلم أن رموز هامينج لا تُستخدم على نطاق واسع مثل الرموز الأكثر حداثة، مثل خوارزمية ريد-سولومون، ولكن هناك سحرًا معينًا في التناقض بين مدى استحالة هذه المهمة في البداية، وكيف تبدو معقولة تمامًا مرة واحدة تتعلم عن هامينج. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 179.3,
  "end": 193.0
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages. ",
  "translatedText": "المبدأ الأساسي لتصحيح الأخطاء هو أنه في مساحة واسعة من جميع الرسائل المحتملة، سيتم اعتبار بعض المجموعات الفرعية فقط رسائل صالحة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 193.72,
  "end": 202.18
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words. ",
  "translatedText": "على سبيل القياس، فكر في الكلمات المكتوبة بشكل صحيح مقابل الكلمات المكتوبة بشكل غير صحيح. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.8,
  "end": 206.94
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo. ",
  "translatedText": "عندما يتم تغيير رسالة صالحة، يكون المتلقي مسؤولاً عن تصحيح ما يراه إلى أقرب جار صالح، كما قد تفعل مع خطأ مطبعي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 208.9,
  "end": 217.34
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness. ",
  "translatedText": "ومع ذلك، فإن التوصل إلى خوارزمية ملموسة لتصنيف مثل هذه الرسائل بكفاءة يتطلب قدرًا معينًا من الذكاء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.22,
  "end": 224.06
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to. ",
  "translatedText": "تبدأ القصة في الأربعينيات من القرن العشرين، عندما كان الشاب ريتشارد هامينج يعمل في مختبرات بيل، وكانت بعض أعماله تتضمن استخدام كمبيوتر كبير الحجم ومكلف للغاية يعمل بنظام البطاقة المثقبة، ولم يكن لديه سوى وصول محدود إليه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 226.78,
  "end": 237.42
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread. ",
  "translatedText": "والبرامج التي ظل يطبقها ظلت تفشل، لأنه بين الحين والآخر سيتم إساءة قراءة جزء منها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 237.8,
  "end": 242.4
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code. ",
  "translatedText": "نظرًا لأن الإحباط هو بوتقة الاختراع، فقد سئم كثيرًا لدرجة أنه اخترع أول رمز لتصحيح الأخطاء في العالم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.12,
  "end": 248.42
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them. ",
  "translatedText": "هناك العديد من الطرق المختلفة لتأطير رموز هامينج، ولكن كمرحلة أولى سنتناول الأمر بالطريقة التي فكر بها هامينج نفسه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 249.06,
  "end": 255.38
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits. ",
  "translatedText": "دعونا نستخدم مثالاً بسيطًا، ولكن ليس بسيطًا للغاية، وهو كتلة مكونة من 16 بت. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 256.52,
  "end": 260.94
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15. ",
  "translatedText": "سنقوم بترقيم مواضع هذه البتات من 0 إلى 15. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 261.82,
  "end": 264.74
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy. ",
  "translatedText": "البيانات الفعلية التي نريد تخزينها ستشكل 12 بتًا فقط من هذه البتات، في حين يتم حجز 4 مواضع كنوع من التكرار. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.62,
  "end": 273.0
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data. ",
  "translatedText": "كلمة زائدة عن الحاجة هنا لا تعني ببساطة النسخ، ففي نهاية المطاف، هذه البتات الأربعة لا تمنحنا مساحة كافية لنسخ البيانات بشكل أعمى. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 273.9,
  "end": 280.04
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience. ",
  "translatedText": "وبدلاً من ذلك، سيحتاجون إلى نوع أكثر دقة وذكاءً من التكرار، وليس إضافة أي معلومات جديدة، ولكن إضافة المرونة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 280.72,
  "end": 287.28
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end. ",
  "translatedText": "قد تتوقع أن تأتي هذه القطع الأربعة الخاصة مجمعة بشكل جيد معًا، ربما في النهاية أو شيء من هذا القبيل، ولكن كما سترى، فإن وضعها في مواضع تمثل قوى 2 يسمح بشيء أنيق حقًا في النهاية. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 288.6,
  "end": 299.62
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks. ",
  "translatedText": "قد يمنحك أيضًا تلميحًا بسيطًا حول كيفية قياس هذا للكتل الأكبر حجمًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.2,
  "end": 303.54
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now. ",
  "translatedText": "ومن الناحية الفنية أيضًا، سينتهي الأمر بـ 11 بتًا فقط من البيانات، وستجد أن هناك فارقًا بسيطًا لما يحدث في الموضع 0، لكن لا تقلق بشأن ذلك في الوقت الحالي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 304.9,
  "end": 313.26
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors. ",
  "translatedText": "مثل أي خوارزمية لتصحيح الأخطاء، سيتضمن ذلك لاعبين، مرسل مسؤول عن تعيين هذه البتات الأربعة الخاصة، ومتلقي مسؤول عن إجراء نوع ما من الفحص وتصحيح الأخطاء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 314.14,
  "end": 325.54
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage. ",
  "translatedText": "بالطبع، تشير كلمتا المرسل والمستقبل إلى الأجهزة أو البرامج التي تقوم بجميع عمليات التحقق، والمقصود بفكرة الرسالة على نطاق واسع جدًا، هو تضمين أشياء مثل التخزين. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 326.3,
  "end": 334.74
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another. ",
  "translatedText": "ففي نهاية المطاف، تخزين البيانات هو نفس إرسال رسالة من الماضي إلى المستقبل بدلاً من إرسالها من مكان إلى آخر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 335.34,
  "end": 341.68
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check. ",
  "translatedText": "إذن هذا هو الإعداد، ولكن قبل أن نتمكن من التعمق في الأمر، نحتاج إلى التحدث عن فكرة ذات صلة كانت جديدة في ذهن هامينج في وقت اكتشافه، وهي طريقة تتيح لك اكتشاف أي أخطاء في البتات، ولكن ليس تصحيحها، كما هو معروف. في الأعمال التجارية باعتبارها التحقق من التكافؤ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 342.56,
  "end": 356.3
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message. ",
  "translatedText": "للتحقق من التكافؤ، نقوم بفصل بت واحد فقط يكون المرسل مسؤولاً عن ضبطه، والباقي أحرار في حمل الرسالة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 356.88,
  "end": 363.82
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number. ",
  "translatedText": "الوظيفة الوحيدة لهذا البت الخاص هي التأكد من أن العدد الإجمالي للآحاد في الرسالة هو رقم زوجي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 364.88,
  "end": 371.28
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even. ",
  "translatedText": "على سبيل المثال، في الوقت الحالي، إجمالي عدد الآحاد هو 7، وهذا أمر غريب، لذلك يحتاج المرسل إلى قلب هذا البت الخاص ليصبح 1، مما يجعل العدد متساويًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 372.08,
  "end": 379.96
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0. ",
  "translatedText": "ولكن إذا كانت الكتلة قد بدأت بالفعل بعدد زوجي من 1، فسيتم الاحتفاظ بهذا البت الخاص عند 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 380.8,
  "end": 386.42
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information. ",
  "translatedText": "هذا أمر بسيط جدًا، وبسيط بشكل خادع، ولكنه طريقة أنيقة للغاية لاستخلاص فكرة التغيير في أي مكان في الرسالة لتنعكس في جزء واحد من المعلومات. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 387.34,
  "end": 396.78
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd. ",
  "translatedText": "لاحظ أنه إذا تم قلب أي جزء من هذه الرسالة، إما من 0 إلى 1 أو من 1 إلى 0، فإنه يغير العدد الإجمالي للآحاد من زوجي إلى فردي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 397.5,
  "end": 406.54
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was. ",
  "translatedText": "لذلك، إذا كنت المتلقي، ونظرت إلى هذه الرسالة، ورأيت عددًا فرديًا من 1، فيمكنك التأكد من حدوث خطأ ما، على الرغم من أنه قد لا يكون لديك أي فكرة عن مكان حدوثه. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 407.98,
  "end": 417.46
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity. ",
  "translatedText": "في المصطلحات، يُعرف ما إذا كانت مجموعة البتات تحتوي على عدد زوجي أو فردي من 1 باسم التكافؤ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 418.5,
  "end": 423.34
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea. ",
  "translatedText": "يمكنك أيضًا استخدام الأرقام والقول إن التكافؤ هو 0 أو 1، وهو ما يكون أكثر فائدة عادةً بمجرد البدء في إجراء العمليات الحسابية باستخدام هذه الفكرة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 424.86,
  "end": 430.72
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit. ",
  "translatedText": "وهذه البتة الخاصة التي يستخدمها المرسل للتحكم في التكافؤ تسمى بت التكافؤ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 431.22,
  "end": 435.52
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0. ",
  "translatedText": "وفي الواقع، يجب أن نكون واضحين، إذا رأى المتلقي تكافؤًا فرديًا، فهذا لا يعني بالضرورة أنه كان هناك خطأ واحد فقط، ربما كان هناك 3 أخطاء، أو 5، أو أي رقم فردي آخر، لكن يمكنهم معرفة ذلك على وجه اليقين أنه لم يكن 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 437.56,
  "end": 449.26
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free. ",
  "translatedText": "من ناحية أخرى، إذا كان هناك خطأين، أو أي عدد زوجي من الأخطاء، فإن العدد النهائي للأرقام 1 سيظل زوجيًا، لذلك لا يمكن للمستلم أن يكون واثقًا تمامًا من أن العدد الزوجي يعني بالضرورة أن الرسالة خالية من الأخطاء . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 449.98,
  "end": 462.3
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right. ",
  "translatedText": "قد تشكو من أن الرسالة التي يتم إفسادها من خلال تقلبات بمقدار 2 بت فقط تكون ضعيفة جدًا، وستكون على حق تمامًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 462.84,
  "end": 469.08
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended. ",
  "translatedText": "ومع ذلك، ضع في اعتبارك أنه لا توجد طريقة لاكتشاف الأخطاء أو تصحيحها يمكن أن تمنحك ثقة بنسبة 100% في أن الرسالة التي تتلقاها هي الرسالة التي قصدها المرسل. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 469.7,
  "end": 478.9
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance. ",
  "translatedText": "بعد كل شيء، يمكن للضوضاء العشوائية الكافية دائمًا تغيير رسالة صالحة إلى رسالة صالحة أخرى فقط عن طريق الصدفة البحتة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 479.58,
  "end": 485.44
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this. ",
  "translatedText": "بدلاً من ذلك، الهدف هو التوصل إلى مخطط قوي يصل إلى حد أقصى معين من الأخطاء، أو ربما لتقليل احتمالية حدوث نتيجة إيجابية كاذبة مثل هذا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 486.24,
  "end": 495.38
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes. ",
  "translatedText": "تعتبر عمليات التحقق من التكافؤ في حد ذاتها ضعيفة جدًا، ولكن من خلال استخلاص فكرة التغيير عبر رسالة كاملة وصولاً إلى جزء واحد، فإن ما يقدمونه لنا هو لبنة بناء قوية لمخططات أكثر تعقيدًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 496.26,
  "end": 507.16
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error. ",
  "translatedText": "على سبيل المثال، بينما كان هامينج يبحث عن طريقة لتحديد مكان حدوث الخطأ، وليس فقط مكان حدوثه، كانت رؤيته الرئيسية هي أنه إذا قمت بتطبيق بعض عمليات التحقق من التكافؤ ليس على الرسالة الكاملة، ولكن على مجموعات فرعية معينة مختارة بعناية، فيمكنك أن تسأل سلسلة أكثر دقة من الأسئلة التي تحدد موقع أي خطأ بت واحد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 507.94,
  "end": 525.94
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half. ",
  "translatedText": "الشعور العام يشبه إلى حد ما ممارسة لعبة مكونة من 20 سؤالًا، حيث يتم طرح أسئلة بنعم أو لا مما يؤدي إلى تقطيع مساحة الاحتمالات إلى النصف. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 526.68,
  "end": 533.38
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions. ",
  "translatedText": "على سبيل المثال، لنفترض أننا قمنا بإجراء فحص التكافؤ على هذه البتات الثمانية فقط، وجميع المواضع ذات الأرقام الفردية. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 534.16,
  "end": 539.38
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position. ",
  "translatedText": "ثم إذا تم اكتشاف خطأ، فإنه يمنح المتلقي المزيد من المعلومات حول مكان الخطأ على وجه التحديد، أي أنه في وضع فردي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 540.1,
  "end": 548.24
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions. ",
  "translatedText": "إذا لم يتم اكتشاف أي خطأ بين تلك البتات الثمانية، فهذا يعني إما عدم وجود خطأ على الإطلاق، أو أنه موجود في مكان ما في المواضع الزوجية. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 548.94,
  "end": 556.24
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful. ",
  "translatedText": "قد تظن أن قصر فحص التكافؤ على نصف البتات يجعله أقل فعالية، ولكن عندما يتم إجراؤه بالتزامن مع عمليات فحص أخرى مختارة جيدًا، فإنه يمنحنا شيئًا أكثر قوة بشكل غير متوقع. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 557.18,
  "end": 567.2
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group. ",
  "translatedText": "لإعداد فحص التكافؤ هذا، تذكر أنه يتطلب تخصيص جزء خاص يتحكم في تكافؤ تلك المجموعة الكاملة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.24,
  "end": 576.62
 },
 {
  "input": "Here let's just choose position 1. ",
  "translatedText": "هنا دعونا فقط نختار الموضع 1. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 577.48,
  "end": 579.18
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even. ",
  "translatedText": "في المثال الموضح، يعد تكافؤ هذه البتات الثمانية أمرًا فرديًا حاليًا، لذا يكون المرسل مسؤولاً عن تبديل بت التكافؤ هذا، وهو الآن زوجي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.72,
  "end": 586.98
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do. ",
  "translatedText": "هذه عملية واحدة فقط من أصل 4 عمليات فحص تكافؤ سنجريها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 587.94,
  "end": 590.68
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here. ",
  "translatedText": "الفحص الثاني يكون من بين 8 بتات في النصف الأيمن من الشبكة، على الأقل كما رسمناها هنا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 590.92,
  "end": 596.3
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged. ",
  "translatedText": "هذه المرة قد نستخدم الموضع 2 كبت تكافؤ، وبالتالي فإن هذه البتات الثمانية لها بالفعل تكافؤ متساوي، ويمكن أن يشعر المرسل بالارتياح عند ترك هذا البت رقم 2 دون تغيير. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 596.68,
  "end": 606.06
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right. ",
  "translatedText": "ومن ثم على الطرف الآخر، إذا تحقق المتلقي من تكافؤ هذه المجموعة ووجد أنه أمر غريب، فسيعرف أن الخطأ موجود في مكان ما بين هذه البتات الثمانية على اليمين. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 607.02,
  "end": 615.38
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half. ",
  "translatedText": "وإلا فهذا يعني أنه لا يوجد خطأ، أو أن الخطأ موجود في مكان ما في النصف الأيسر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 615.82,
  "end": 620.58
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block. ",
  "translatedText": "أو أعتقد أنه من الممكن أن يكون هناك خطأين، ولكن في الوقت الحالي سنفترض أن هناك خطأ واحدًا على الأكثر في الكتلة بأكملها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 621.12,
  "end": 626.5
 },
 {
  "input": "Things break down completely for more than that. ",
  "translatedText": "تنهار الأمور تمامًا لأكثر من ذلك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 626.94,
  "end": 628.74
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together. ",
  "translatedText": "هنا، قبل أن ننظر إلى الفحصين التاليين، توقف لحظة للتفكير فيما يسمح لنا بهذين الاختبارين الأولين عندما تفكر فيهما معًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 629.16,
  "end": 635.1
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half. ",
  "translatedText": "لنفترض أنك اكتشفت خطأ بين الأعمدة الفردية وبين النصف الأيمن. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 635.8,
  "end": 639.66
 },
 {
  "input": "It necessarily means the error is somewhere in the last column. ",
  "translatedText": "وهذا يعني بالضرورة أن الخطأ موجود في مكان ما في العمود الأخير. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 640.2,
  "end": 643.04
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column. ",
  "translatedText": "إذا لم يكن هناك خطأ في العمود الفردي ولكن كان هناك خطأ في النصف الأيمن، فهذا يخبرك أنه موجود في العمود الثاني قبل الأخير. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 643.82,
  "end": 649.7
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column. ",
  "translatedText": "وبالمثل، إذا كان هناك خطأ في الأعمدة الفردية ولكن ليس في النصف الأيمن، فاعلم أنه موجود في مكان ما في العمود الثاني. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 650.44,
  "end": 656.02
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column. ",
  "translatedText": "وإذا لم يكتشف أي من هذين التحققين من التكافؤ أي شيء، فهذا يعني أن المكان الوحيد الذي يمكن أن يوجد فيه خطأ هو ذلك العمود الموجود في أقصى اليسار. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 656.02,
  "end": 663.12
 },
 {
  "input": "But it also might simply mean there's no error at all. ",
  "translatedText": "ولكنه قد يعني أيضًا أنه لا يوجد خطأ على الإطلاق. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 663.34,
  "end": 666.12
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column. ",
  "translatedText": "وهي طريقة متقنة إلى حد ما للقول إن فحصي التكافؤ يسمحان لنا بتحديد العمود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.3,
  "end": 670.84
 },
 {
  "input": "From here, you can probably guess what follows. ",
  "translatedText": "من هنا، ربما يمكنك تخمين ما يلي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 671.48,
  "end": 673.64
 },
 {
  "input": "We do basically the same thing but for the rows. ",
  "translatedText": "نحن نفعل نفس الشيء بشكل أساسي ولكن بالنسبة للصفوف. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 673.8,
  "end": 676.14
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit. ",
  "translatedText": "سيكون هناك فحص للتكافؤ في الصفوف الفردية، باستخدام الموضع 4 كبت تكافؤ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 676.44,
  "end": 680.9
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0. ",
  "translatedText": "لذلك في هذا المثال، هذه المجموعة لديها بالفعل تكافؤ زوجي، لذا سيتم تعيين البت 4 على 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 681.38,
  "end": 685.82
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit. ",
  "translatedText": "وأخيرًا، هناك فحص تكافؤ في الصفين السفليين، باستخدام الموضع 8 كبت تكافؤ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 686.56,
  "end": 691.58
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity. ",
  "translatedText": "في هذه الحالة، يبدو أن المرسل بحاجة إلى تشغيل هذا البت 8 من أجل منح المجموعة التكافؤ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 692.12,
  "end": 696.82
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row. ",
  "translatedText": "تمامًا كما تتيح لنا عمليتا التحقق الأولين تثبيت العمود، تتيح لك الوظيفتان التاليتان تثبيت الصف. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 697.7,
  "end": 701.84
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3. ",
  "translatedText": "على سبيل المثال، تخيل أنه أثناء الإرسال، حدث خطأ في الموضع 3 على سبيل المثال. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 702.88,
  "end": 707.54
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column. ",
  "translatedText": "حسنًا، يؤثر هذا على مجموعة التكافؤ الأولى، ويؤثر أيضًا على مجموعة التكافؤ الثانية، لذلك يعرف المتلقي أن هناك خطأ في مكان ما في هذا العمود الأيمن. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 708.18,
  "end": 715.56
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group. ",
  "translatedText": "لكنه لا يؤثر على المجموعة الثالثة، ولا يؤثر على المجموعة الرابعة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.1,
  "end": 720.54
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error. ",
  "translatedText": "وهذا يتيح للمتلقي تحديد الخطأ حتى الصف الأول، وهو ما يعني بالضرورة الموضع 3، حتى يتمكنوا من إصلاح الخطأ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 721.24,
  "end": 727.52
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be. ",
  "translatedText": "قد تستمتع بتخصيص بعض الوقت لإقناع نفسك بأن الإجابات على هذه الأسئلة الأربعة ستسمح لك دائمًا بتحديد موقع معين، بغض النظر عن مكان تواجدهم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 728.58,
  "end": 737.1
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting. ",
  "translatedText": "في الواقع، قد يلاحظ الأذكياء بينكم وجود صلة بين هذه الأسئلة والعد الثنائي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 737.72,
  "end": 743.06
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it. ",
  "translatedText": "وإذا قمت بذلك، دعني أؤكد مرة أخرى، توقف مؤقتًا، حاول بنفسك أن ترسم الارتباط قبل أن أفسده. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 743.5,
  "end": 748.92
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it. ",
  "translatedText": "إذا كنت تتساءل عما يحدث إذا تأثرت بتة التكافؤ نفسها، حسنًا، يمكنك تجربتها فقط. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 750.5,
  "end": 756.06
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions. ",
  "translatedText": "خذ لحظة للتفكير في كيفية تعقب أي خطأ بين هذه الأجزاء الأربعة الخاصة تمامًا مثل أي خطأ آخر، مع نفس المجموعة المكونة من أربعة أسئلة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 756.44,
  "end": 764.18
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along. ",
  "translatedText": "لا يهم حقًا، نظرًا لأن ما نريده في نهاية المطاف هو حماية أجزاء الرسالة، فإن وحدات بت تصحيح الأخطاء هي التي تستمر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 767.06,
  "end": 773.1
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct. ",
  "translatedText": "لكن حماية تلك البتات أيضًا هو أمر يخرج بشكل طبيعي عن المخطط كمنتج ثانوي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 773.6,
  "end": 777.82
 },
 {
  "input": "You might also enjoy anticipating how this scales. ",
  "translatedText": "قد تستمتع أيضًا بتوقع كيفية قياس هذا الأمر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 779.2,
  "end": 781.76
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot. ",
  "translatedText": "إذا استخدمنا كتلة بحجم 256 بت، على سبيل المثال، لتحديد موقع ما، فأنت تحتاج فقط إلى ثمانية أسئلة بنعم أو لا للبحث الثنائي في طريقك إلى مكان محدد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 782.3,
  "end": 792.78
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check. ",
  "translatedText": "وتذكر أن كل سؤال يتطلب التخلي عن جزء واحد فقط لتعيين التحقق من التكافؤ المناسب. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 795.64,
  "end": 800.5
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two. ",
  "translatedText": "ربما يراها البعض منكم بالفعل، لكننا سنتحدث لاحقًا عن الطريقة المنهجية للعثور على هذه الأسئلة في دقيقة أو دقيقتين فقط. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 803.16,
  "end": 809.36
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here. ",
  "translatedText": "نأمل أن يكون هذا المخطط كافيًا لتقدير كفاءة ما نقوم بتطويره هنا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 809.88,
  "end": 813.66
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want. ",
  "translatedText": "أول شيء، باستثناء تلك البتات الثمانية المتماثلة المميزة، يمكن أن تكون كما تريد، وتحمل أي رسالة أو بيانات تريدها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 813.66,
  "end": 821.0
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole. ",
  "translatedText": "تعتبر البتات الثمانية زائدة عن الحاجة، بمعنى أنه يتم تحديدها بالكامل من خلال بقية الرسالة، ولكنها بطريقة أكثر ذكاءً من مجرد نسخ الرسالة ككل. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 821.72,
  "end": 830.02
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error. ",
  "translatedText": "ومع ذلك، مقابل القليل جدًا من الاستسلام، ستكون قادرًا على تحديد وإصلاح أي خطأ في البتات. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 833.6,
  "end": 838.38
 },
 {
  "input": "Well, almost. ",
  "translatedText": "حسنًا تقريبًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.2,
  "end": 840.4
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0. ",
  "translatedText": "حسنًا، المشكلة الوحيدة هنا هي أنه إذا لم تكتشف أي من عمليات التحقق من التكافؤ وجود خطأ، مما يعني أن المجموعات الفرعية المحددة خصيصًا والمكونة من 8 بتات جميعها لها تماثلات زوجية، تمامًا كما قصد المرسل، فهذا يعني إما أنه لم يكن هناك خطأ على الإطلاق أو أنه يضيق بنا إلى الموضع 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 840.96,
  "end": 856.86
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition. ",
  "translatedText": "كما ترى، مع أربعة أسئلة بنعم أو لا، لدينا 16 نتيجة محتملة لعمليات التحقق من التكافؤ، وفي البداية يبدو ذلك مثاليًا لتحديد موضع واحد من أصل 16 موضعًا في الكتلة، ولكنك تحتاج أيضًا إلى توصيل النتيجة السابعة عشرة، وهي عدم وجود خطأ حالة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 857.74,
  "end": 871.9
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely. ",
  "translatedText": "الحل هنا بسيط جدًا في الواقع، فقط انسَ هذا الجزء 0 تمامًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 873.02,
  "end": 877.3
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error. ",
  "translatedText": "لذلك عندما نقوم بعمليات التحقق من التكافؤ الأربعة ونرى أنها كلها متساوية، فهذا يعني بشكل لا لبس فيه أنه لا يوجد خطأ. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 877.84,
  "end": 883.46
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy. ",
  "translatedText": "ما يعنيه ذلك هو أنه بدلًا من العمل مع كتلة مكونة من 16 بت، فإننا نعمل مع كتلة مكونة من 15 بت، حيث يكون 11 بتًا مجانيًا لحمل رسالة و4 بتات منها للتكرار. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 884.24,
  "end": 893.22
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code. ",
  "translatedText": "وبهذا، أصبح لدينا الآن ما يشير إليه الأشخاص في هذا المجال برمز هامينغ 15-11. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 893.78,
  "end": 898.8
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us. ",
  "translatedText": "ومع ذلك، من الجيد أن يكون لدينا حجم كتلة يساوي قوة نظيفة تبلغ 2، وهناك طريقة ذكية يمكننا من خلالها الاحتفاظ بهذا الجزء الصفري وجعله يقوم ببعض العمل الإضافي لنا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 899.86,
  "end": 908.14
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors. ",
  "translatedText": "إذا استخدمناها كبتة تكافؤ عبر الكتلة بأكملها، فإنها تتيح لنا بالفعل اكتشاف أخطاء 2 بت، على الرغم من أننا لا نستطيع تصحيحها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 908.7,
  "end": 915.54
 },
 {
  "input": "Here's how it works. ",
  "translatedText": "وإليك كيف يعمل. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 916.16,
  "end": 916.82
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check. ",
  "translatedText": "بعد تعيين تلك البتات الأربعة الخاصة لتصحيح الأخطاء، قمنا بتعيين البت 0 بحيث يكون تكافؤ الكتلة الكاملة متساويًا، تمامًا مثل فحص التكافؤ العادي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 917.18,
  "end": 924.94
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks. ",
  "translatedText": "الآن، إذا كان هناك خطأ بت واحد، فإن تكافؤ الكتلة الكاملة يصبح غريبًا، لكننا سنكتشف ذلك على أي حال بفضل عمليات التحقق الأربعة من تصحيح الأخطاء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 925.7,
  "end": 933.6
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks. ",
  "translatedText": "ومع ذلك، إذا كان هناك خطأان، فسيتم تبديل التكافؤ الإجمالي مرة أخرى إلى كونه متساويًا، لكن المتلقي سيظل يرى أن هناك على الأقل بعض الأخطاء بسبب ما يحدث مع عمليات التحقق من التكافؤ الأربعة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 934.16,
  "end": 945.18
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors. ",
  "translatedText": "لذا، إذا لاحظوا تكافؤًا متساويًا بشكل عام، ولكن حدث شيء غير صفري مع عمليات التحقق الأخرى، فهذا يخبرهم بوجود خطأين على الأقل. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 945.18,
  "end": 952.7
 },
 {
  "input": "Isn't that clever? ",
  "translatedText": "أليس هذا ذكيا؟ ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.52,
  "end": 954.0
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them. ",
  "translatedText": "على الرغم من أننا لا نستطيع تصحيح تلك الأخطاء ذات البتتين، إلا أنه بمجرد إعادة البتة الصفرية المزعجة هذه إلى العمل، فإنها تتيح لنا اكتشافها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 954.3,
  "end": 961.26
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code. ",
  "translatedText": "يعد هذا أمرًا قياسيًا جدًا، ويُعرف باسم كود هامينج الممتد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.26,
  "end": 965.22
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block. ",
  "translatedText": "من الناحية الفنية، لديك الآن وصف كامل لما تفعله كود هامينج، على الأقل بالنسبة لمثال كتلة 16 بت. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 966.54,
  "end": 972.88
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself. ",
  "translatedText": "لكنني أعتقد أنك ستجد الأمر أكثر إرضاءً للتحقق من فهمك وترسيخ كل شيء حتى هذه النقطة من خلال القيام بمثال واحد كامل من البداية إلى النهاية بنفسك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 972.88,
  "end": 981.32
 },
 {
  "input": "I'll step through it with you though so you can check yourself. ",
  "translatedText": "سأقوم بالخطوات معك حتى تتمكن من التحقق بنفسك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 982.08,
  "end": 984.3
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks. ",
  "translatedText": "لإعداد رسالة، سواء كانت رسالة حرفية تترجمها عبر مساحة أو بعض البيانات التي تريد تخزينها مع مرور الوقت، فإن الخطوة الأولى هي تقسيمها إلى أجزاء 11 بت. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 985.12,
  "end": 994.66
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block. ",
  "translatedText": "سيتم تجميع كل قطعة في كتلة 16 بت مقاومة للأخطاء. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 995.58,
  "end": 999.76
 },
 {
  "input": "So let's take this one as an example and actually work it out. ",
  "translatedText": "لذلك دعونا نأخذ هذا كمثال ونعمل عليه بالفعل. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 999.76,
  "end": 1003.22
 },
 {
  "input": "Go ahead, actually do it! ",
  "translatedText": "المضي قدما، في الواقع القيام بذلك! ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1003.74,
  "end": 1004.94
 },
 {
  "input": "Let's pause and try putting together this block. ",
  "translatedText": "دعونا نتوقف مؤقتًا ونحاول تجميع هذه الكتلة معًا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1005.22,
  "end": 1007.02
 },
 {
  "input": "Okay, you ready? ",
  "translatedText": "حسنًا، هل أنت مستعد؟ ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1012.72,
  "end": 1013.68
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order. ",
  "translatedText": "تذكر أن الموضع 0 إلى جانب القوى الأخرى للرقم 2 محجوزة لمهمة تصحيح الأخطاء، لذا عليك أن تبدأ بوضع بتات الرسالة في جميع الأماكن المتبقية بالترتيب. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1014.24,
  "end": 1023.32
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0. ",
  "translatedText": "أنت بحاجة إلى أن يكون لهذه المجموعة تكافؤ متساوي، وهو ما يحدث بالفعل، لذا يجب عليك تعيين بت التكافؤ هذا في الموضع 1 ليكون 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1025.34,
  "end": 1032.34
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1. ",
  "translatedText": "تبدأ المجموعة التالية بتعادل فردي، لذا يجب عليك تعيين بت التكافؤ الخاص بها ليكون 1. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1033.02,
  "end": 1037.88
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1. ",
  "translatedText": "تبدأ المجموعة بعد ذلك بتكافؤ فردي، لذلك يجب عليك مرة أخرى ضبط بت التكافؤ الخاص بها على 1. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1039.16,
  "end": 1044.24
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1. ",
  "translatedText": "والمجموعة الأخيرة لديها أيضًا تكافؤ فردي، مما يعني أننا وضعنا هذا الجزء في الموضع 8 ليكون 1. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1044.78,
  "end": 1050.06
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0. ",
  "translatedText": "وبعد ذلك كخطوة أخيرة، أصبح للكتلة الكاملة الآن تكافؤ متساوي، مما يعني أنه يمكنك تعيين رقم البت 0، وهو بت التكافؤ الشامل، ليكون 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1051.3,
  "end": 1060.32
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0. ",
  "translatedText": "لذلك عندما يتم إرسال هذه الكتلة، فإن التكافؤ بين المجموعات الفرعية الأربع الخاصة والكتلة ككل سيكون متساويًا، أو 0. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1061.34,
  "end": 1068.14
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver. ",
  "translatedText": "في الجزء الثاني من التمرين، لنجعلك تلعب دور المتلقي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1068.82,
  "end": 1072.18
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't. ",
  "translatedText": "بالطبع، هذا يعني أنك لا تعرف بالفعل ما هي هذه الرسالة، ربما البعض منكم يحفظها، ولكن لنفترض أنك لم تفعل ذلك. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1073.48,
  "end": 1079.78
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did. ",
  "translatedText": "ما سأفعله هو تغيير إما 0 أو 1 أو 2 من البتات في تلك الكتلة، ثم أطلب منك معرفة ما فعلته. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1080.02,
  "end": 1087.74
 },
 {
  "input": "So again, pause and try working it out. ",
  "translatedText": "لذا مرة أخرى، توقف مؤقتًا وحاول حلها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1088.26,
  "end": 1090.81
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column. ",
  "translatedText": "حسنًا، أنت الآن كمستلم تتحقق من مجموعة التكافؤ الأولى ويمكنك أن ترى أنها زوجية، لذا فإن أي خطأ موجود يجب أن يكون في عمود زوجي. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1098.79,
  "end": 1107.91
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column. ",
  "translatedText": "الفحص التالي يعطينا رقمًا فرديًا، ويخبرنا بوجود خطأ واحد على الأقل، ويضيق نطاقنا في هذا العمود المحدد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1109.69,
  "end": 1117.03
 },
 {
  "input": "The third check is even, chopping down the possibilities even further. ",
  "translatedText": "الفحص الثالث متساوي، مما يقلل من الاحتمالات بشكل أكبر. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1118.55,
  "end": 1121.79
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10. ",
  "translatedText": "وآخر فحص للتكافؤ أمر غريب، حيث يخبرنا بوجود خطأ في مكان ما في الأسفل، والذي يمكننا الآن أن نرى أنه يجب أن يكون في الموضع رقم 10. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1122.65,
  "end": 1129.65
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two. ",
  "translatedText": "علاوة على ذلك، فإن تكافؤ الكتلة بأكملها أمر غريب، مما يمنحنا الثقة في وجود قلب واحد وليس اثنين. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1131.49,
  "end": 1137.53
 },
 {
  "input": "If it's three or more, all bets are off. ",
  "translatedText": "إذا كان هناك ثلاثة أو أكثر، كل الرهانات ملغاة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1138.07,
  "end": 1139.97
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with. ",
  "translatedText": "بعد تصحيح البت رقم 10، فإن سحب البتات الـ 11 التي لم يتم استخدامها للتصحيح يعطينا الجزء ذي الصلة من الرسالة الأصلية، والذي إذا قمت بالترجيع والمقارنة فهو في الواقع ما بدأنا به المثال. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1141.31,
  "end": 1154.39
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code. ",
  "translatedText": "والآن بعد أن عرفت كيفية القيام بكل هذا يدويًا، أود أن أوضح لك كيف يمكنك تنفيذ الجزء الأساسي من كل هذا المنطق باستخدام سطر واحد من كود بايثون. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1155.71,
  "end": 1163.17
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks. ",
  "translatedText": "كما ترى، ما لم أخبرك به بعد هو مدى أناقة هذه الخوارزمية حقًا، ومدى بساطة جعل الآلة تشير إلى موضع الخطأ، وكيفية قياسه بشكل منهجي، وكيف يمكننا تأطير كل ذلك هذا كعملية واحدة بدلاً من عمليات التحقق من التكافؤ المنفصلة المتعددة. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1163.87,
  "end": 1178.75
 },
 {
  "input": "To see what I mean, come join me in part 2. ",
  "translatedText": "لتعرف ما أعنيه، تعال وانضم إلي في الجزء الثاني. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1179.43,
  "end": 1181.31
 }
]