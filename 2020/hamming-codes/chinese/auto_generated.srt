1
00:00:03,620 --> 00:00:07,040
您是否想过如何在刮擦 CD 或 DV 

2
00:00:07,040 --> 00:00:10,100
D 后仍然可以播放其中存储的内容？

3
00:00:10,900 --> 00:00:13,969
划痕确实会影响磁盘上的 1 和 0，

4
00:00:13,969 --> 00:00:17,209
因此它会读取 与存储的数据不同的数据，

5
00:00:17,209 --> 00:00:21,301
但除非它确实被划伤，否 则它读取的位会被解码为与

6
00:00:21,301 --> 00:00:26,075
编码到其上的文件完全相同 的文件，尽管存在所有这些错误，

7
00:00:26,075 --> 00:00:27,440
但还是逐位复制。

8
00:00:27,440 --> 00:00:33,280
大量的数学智慧使我们能够以一种能够抵御错误的 方式存储数据，

9
00:00:33,280 --> 00:00:36,200
并且同样重要的是能够传输数据。

10
00:00:36,200 --> 00:00:38,610
好吧，好吧，实际上并不需要那么聪 

11
00:00:38,610 --> 00:00:40,880
明就能想出一种方法来做到这一点。

12
00:00:40,880 --> 00:00:46,580
任何文件，无论是视频、声音还是文本、代码、图 像等等，

13
00:00:46,580 --> 00:00:50,380
最终都是由 1 和 0 组成的序列。

14
00:00:50,680 --> 00:00:56,000
纠正任何被翻转的位的一个简单 策略是存储每个位的三个副本。

15
00:00:57,580 --> 00:01:00,357
然后，读取该文件的机器可以比较这三个副本，

16
00:01:00,357 --> 00:01:04,060
并在出 现差异时始终从 3 个副本中取出最好的 2 个。

17
00:01:07,160 --> 00:01:10,860
但这意味着将三分之二的空间用于冗余。

18
00:01:11,480 --> 00:01:14,504
即便如此，对于所有放弃的空间，也不能强有 

19
00:01:14,504 --> 00:01:17,240
力地保证如果超过一位被翻转会发生什么。

20
00:01:17,980 --> 00:01:21,167
更有趣的问题是如何做到这一点，以便在 

21
00:01:21,167 --> 00:01:24,020
放弃尽可能少的空间的同时纠正错误。

22
00:01:24,520 --> 00:01:27,702
例如，使用您将在本视频中了解的方法，

23
00:01:27,702 --> 00:01:33,006
您可以将数据存储在 256 位块中，其中每个块使用 9 位，

24
00:01:33,006 --> 00:01:33,360
9！

25
00:01:33,760 --> 00:01:36,946
作为一种冗余，其他 2 47 位可以自

26
00:01:36,946 --> 00:01:40,300
由地携带任何您想要的有意义的消息或数据。

27
00:01:40,900 --> 00:01:44,693
情况仍然是这样，如果这里有任何位被翻转，

28
00:01:44,693 --> 00:01:48,866
 只需查看这个块，机器就能够识别出存在错误 

29
00:01:48,866 --> 00:01:52,660
以及错误的确切位置，以便知道如何纠正它。

30
00:01:52,660 --> 00:01:54,620
老实说，这感觉就像魔法一样。

31
00:01:55,440 --> 00:01:58,317
对于这个特定的方案，如果两个位被翻转，

32
00:01:58,317 --> 00:02:02,860
机器至少能 够检测到存在两个错误，尽管它不知道如何修复它们。

33
00:02:03,520 --> 00:02:06,900
稍后我们将讨论如何针对不同大小的块进行缩放。

34
00:02:07,860 --> 00:02:12,900
可以合理地纠正此类错 误的方法称为纠错码。

35
00:02:13,660 --> 00:02:17,953
在上个世纪的大部分时间里，这个领域一直是令人惊讶的深度 

36
00:02:17,953 --> 00:02:21,940
数学的丰富来源，这些数学被纳入我们每天使用的设备中。

37
00:02:22,840 --> 00:02:28,660
这里的目标是让您非常彻底地了 解最早的示例之一，即汉明码。

38
00:02:29,520 --> 00:02:33,125
顺便说一句，我对这个视频结构的思考方式并 

39
00:02:33,125 --> 00:02:37,245
不是尽可能直接地解释它，而是提示你自己 发明它，

40
00:02:37,245 --> 00:02:39,820
并时不时地给予一些温和的指导。

41
00:02:40,120 --> 00:02:43,053
因此，当你觉得你在某个时刻看到了它的发展方向时，

42
00:02:43,053 --> 00:02:46,720
请花点 时间停下来，在我告诉你之前积极预测该计划将会是什么。

43
00:02:47,240 --> 00:02:50,253
另外，如果你想让你的理解深入到硬件层面，

44
00:02:50,253 --> 00:02:53,719
Ben Eater 制作了一个与此相关的视频，

45
00:02:53,719 --> 00:02:58,240
向你展示如 何在面包板上实际实现汉明码，这是非常令人满意的。

46
00:02:59,300 --> 00:03:03,974
您应该知道，汉明码并不像里德-所罗门算法等更现代的代码那 

47
00:03:03,974 --> 00:03:07,358
样广泛使用，但是这项任务一开始感觉不可能，

48
00:03:07,358 --> 00:03:11,871
而一旦完成却显 得多么合理，两者之间的对比有一定的魔力。

49
00:03:11,871 --> 00:03:13,000
你了解了汉明。

50
00:03:13,720 --> 00:03:18,926
纠错的基本原理是，在所有可能消息的巨大 空间中，

51
00:03:18,926 --> 00:03:22,180
只有某些子集将被视为有效消息。

52
00:03:22,800 --> 00:03:26,940
打个比方，想想拼写正确的单词和拼写错误的单词。

53
00:03:28,900 --> 00:03:33,199
每当有效消息被更改时，接收者就有责任将他们看到的内容 

54
00:03:33,199 --> 00:03:37,340
纠正回最近的有效邻居，就像您可能会处理拼写错误一样。

55
00:03:38,220 --> 00:03:41,218
不过，想出一个具体的算法来有效地对这 

56
00:03:41,218 --> 00:03:44,060
样的消息进行分类需要一定的聪明才智。

57
00:03:46,780 --> 00:03:48,754
故事开始于 20 世纪 40 年代，

58
00:03:48,754 --> 00:03:51,167
当时年轻的理查德·汉明 (R ichard 

59
00:03:51,167 --> 00:03:53,142
Hamming) 在贝尔实验室工作，

60
00:03:53,142 --> 00:03:55,884
他的一些工作涉 及使用一台非常昂贵的打孔卡计算机，

61
00:03:55,884 --> 00:03:57,420
而他只能有限地使用该计算机。

62
00:03:57,800 --> 00:04:02,400
他不断执行的程序总是失败， 因为时不时会有一点被误读。

63
00:04:03,120 --> 00:04:05,769
挫折是发明的严峻考验，他受够了，

64
00:04:05,769 --> 00:04:08,420
 因此发明了世界上第一个纠错码。

65
00:04:09,060 --> 00:04:12,142
构建汉明码的方法有很多种，但作为第一步，

66
00:04:12,142 --> 00:04:15,380
 我们将按照汉明本人对它们的看法来了解它。

67
00:04:16,519 --> 00:04:20,940
让我们使用一个简单但又不太简单的例子，一个 16 位的块。

68
00:04:21,820 --> 00:04:24,740
我们将这些位的位置从 0 到 15 进行编号。

69
00:04:25,620 --> 00:04:29,813
我们想要存储的实际数据仅由其中的 12 位组 成，

70
00:04:29,813 --> 00:04:33,000
而其中 4 个位置被保留作为一种冗余。

71
00:04:33,900 --> 00:04:36,411
这里的冗余一词并不简单地意味着复制，

72
00:04:36,411 --> 00:04:40,040
毕竟这4 位并没有给我们足够的空间来盲目地复制数据。

73
00:04:40,720 --> 00:04:44,000
相反，它们需要更加细致和巧妙的冗余，

74
00:04:44,000 --> 00:04:47,280
 不是添加任何新信息，而是增加弹性。

75
00:04:48,600 --> 00:04:52,223
您可能期望这 4 个特殊位能够很好地打包在一起，

76
00:04:52,223 --> 00:04:55,695
 也许是在最后或类似的地方，但正如您所看到的，

77
00:04:55,695 --> 00:04:59,620
让它 们位于 2 的幂的位置可以让最终变得非常优雅。

78
00:05:00,200 --> 00:05:03,540
它还可能会给您一些关于如何扩展到更大块的提示。

79
00:05:04,900 --> 00:05:08,244
另外，从技术上讲，它最终只有 11 位数据，

80
00:05:08,244 --> 00:05:12,044
您会发现位 置 0 处发生的情况有轻微的细微差别，

81
00:05:12,044 --> 00:05:13,260
但现在不用担心。

82
00:05:14,140 --> 00:05:18,002
与任何纠错算法一样，这将涉及两个参与者：一 

83
00:05:18,002 --> 00:05:21,162
个负责设置这 4 个特殊位的发送者，

84
00:05:21,162 --> 00:05:25,200
以及 一个负责执行某种检查和纠正错误的接收者。

85
00:05:25,200 --> 00:05:28,539
当然，“发送者”和“接收者”这两个词实际 

86
00:05:28,539 --> 00:05:31,082
上是指执行所有检查的机器或软件，

87
00:05:31,082 --> 00:05:34,740
并且消 息的概念含义非常广泛，包括存储等内容。

88
00:05:35,340 --> 00:05:39,113
毕竟，存储数据与将消息从过去发送到未来是一 样的，

89
00:05:39,113 --> 00:05:41,680
而不是从一个地方发送到另一个地方。

90
00:05:42,560 --> 00:05:45,214
这就是设置，但在我们深入讨论之前，

91
00:05:45,214 --> 00:05:49,898
我们需要讨 论一个相关的想法，这是汉明在发现时的新鲜想 法，

92
00:05:49,898 --> 00:05:54,270
这种方法可以让您检测到任何单个位错误， 但不能纠正它们，

93
00:05:54,270 --> 00:05:56,300
已知在业务中作为奇偶校验。

94
00:05:56,880 --> 00:06:01,445
对于奇偶校验，我们只分离出发送者负责调 整的一位，

95
00:06:01,445 --> 00:06:03,820
其余的可以自由地携带消息。

96
00:06:04,880 --> 00:06:11,280
该特殊位的唯一作用是确保消 息中 1 的总数为偶数。

97
00:06:12,080 --> 00:06:15,506
例如，现在 1 的总数是 7，这是奇数，

98
00:06:15,506 --> 00:06:19,960
因此发 送方需要将该特殊位翻转为 1，使计数为偶数。

99
00:06:20,800 --> 00:06:23,961
但如果该块已经以偶数个 1 开始 ，

100
00:06:23,961 --> 00:06:26,420
那么这个特殊位将保持为 0。

101
00:06:27,340 --> 00:06:31,385
这非常简单，看似简单，但它是一种极其优雅的方式，

102
00:06:31,385 --> 00:06:35,094
可以将消 息中任何位置的变化的想法提炼出来，

103
00:06:35,094 --> 00:06:36,780
并反映在单个信息中。

104
00:06:37,500 --> 00:06:41,773
请注意，如果此消息的任何位被翻转（从 0 变为 1 

105
00:06:41,773 --> 00:06:46,540
或从 1 变为 0），它会将 1 的总数从偶数更改为奇数。

106
00:06:47,980 --> 00:06:52,639
因此，如果您是接收者，您查看此消息，并 且看到奇数个 1，

107
00:06:52,639 --> 00:06:57,460
您可以确定发生了某些 错误，即使您可能不知道错误发生在哪里。

108
00:06:58,500 --> 00:07:02,247
用行话来说，一组位的 1 数量 是偶数还是奇数，

109
00:07:02,247 --> 00:07:03,340
称为奇偶校验。

110
00:07:04,860 --> 00:07:07,555
您还可以使用数字并表示奇偶校验为 0 或 1，

111
00:07:07,555 --> 00:07:10,720
一旦 您开始用这个想法进行数学计算，这通常会更有帮助。

112
00:07:11,220 --> 00:07:15,520
发送方用来控制奇偶校验的 特殊位称为奇偶校验位。

113
00:07:17,560 --> 00:07:21,127
实际上，我们应该清楚，如果接收器看到奇数奇偶校验，

114
00:07:21,127 --> 00:07:24,694
并不 一定意味着只有一个错误，可能有 3 个错误，

115
00:07:24,694 --> 00:07:27,119
或 5 个 错误，或任何其他奇数，

116
00:07:27,119 --> 00:07:29,260
但他们可以肯定知道它不是 0。

117
00:07:29,980 --> 00:07:34,732
另一方面，如果出现 2 个错误，或者任何偶数个 错误，

118
00:07:34,732 --> 00:07:38,428
则最终的 1 计数仍然是偶数，因此接收方 

119
00:07:38,428 --> 00:07:42,300
无法完全确信偶数计数一定意味着消息没有错误。

120
00:07:42,840 --> 00:07:47,611
您可能会抱怨仅通过 2 位翻转就搞 乱的消息非常弱，

121
00:07:47,611 --> 00:07:49,080
您是绝对正确的。

122
00:07:49,700 --> 00:07:54,108
但请记住，没有任何错误检测或纠正方法可以让您 

123
00:07:54,108 --> 00:07:58,900
1 00% 确信您收到的消息正是发件人想要的消息。

124
00:07:59,580 --> 00:08:02,598
毕竟，足够多的随机噪声总能偶然将 

125
00:08:02,598 --> 00:08:05,440
一条有效消息变成另一条有效消息。

126
00:08:06,240 --> 00:08:10,907
相反，我们的目标是提出一种在一定的最大错误数范 

127
00:08:10,907 --> 00:08:15,380
围内稳健的方案，或者减少像这样的误报的可能性。

128
00:08:16,260 --> 00:08:20,033
奇偶校验本身相当弱，但通过将整个消 

129
00:08:20,033 --> 00:08:23,806
息的变化思想提炼为单个位，它们为我 

130
00:08:23,806 --> 00:08:27,160
们提供了更复杂方案的强大构建块。

131
00:08:27,940 --> 00:08:32,156
例如，由于汉明正在寻找一种方法来识别错误发生的位置，

132
00:08:32,156 --> 00:08:35,723
而 不仅仅是错误发生的地方，他的主要见解是，

133
00:08:35,723 --> 00:08:40,102
如果您不对完整 消息而是对某些精心选择的子集应用一些奇

134
00:08:40,102 --> 00:08:43,669
偶校验检查，您可 以询问一系列更精确的问题，

135
00:08:43,669 --> 00:08:45,940
可以确定任何一位错误的位置。

136
00:08:46,680 --> 00:08:49,784
总体感觉有点像玩 20 个问题的游戏，

137
00:08:49,784 --> 00:08:53,380
提 出是或否的问题，从而将可能性的空间减半。

138
00:08:54,160 --> 00:08:59,380
例如，假设我们仅对这 8 位（ 所有奇数位置）进行奇偶校验。

139
00:09:00,100 --> 00:09:04,260
然后，如果检测到错误，它会向接收器提供更多有 

140
00:09:04,260 --> 00:09:08,240
关错误具体位置的信息，即错误位于奇怪的位置。

141
00:09:08,940 --> 00:09:12,122
如果在这 8 位中没有检测到错误，

142
00:09:12,122 --> 00:09:16,240
则意 味着根本没有错误，或者它位于偶数位置。

143
00:09:17,180 --> 00:09:20,918
您可能认为将奇偶校验检查限制为一半会降低其效 率，

144
00:09:20,918 --> 00:09:23,909
但是当它与其他精心选择的检查结合使用时，

145
00:09:23,909 --> 00:09:27,200
 它会给我们带来更强大的东西，这与直觉相反。

146
00:09:29,240 --> 00:09:32,267
请记住，要实际设置奇偶校验检查，

147
00:09:32,267 --> 00:09:36,620
它需要 指定一些特殊位来控制整个组的奇偶校验。

148
00:09:37,480 --> 00:09:39,180
这里我们只选择位置1。

149
00:09:39,720 --> 00:09:43,350
对于所示的示例，这 8 位的奇偶校验当前是奇数，

150
00:09:43,350 --> 00:09:46,980
 因此发送方负责切换该奇偶校验位，现在它是偶数。

151
00:09:47,940 --> 00:09:50,680
这只是我们要做的 4 次奇偶校验中的 1 次。

152
00:09:50,920 --> 00:09:54,058
第二个检查位于网格右半部分的 8 位 中，

153
00:09:54,058 --> 00:09:56,300
至少我们在这里绘制的是这样的。

154
00:09:56,680 --> 00:09:59,963
这次我们可能使用位置 2 作为奇偶校验位，

155
00:09:59,963 --> 00:10:04,340
因此这 8 位已经 具有偶校验，并且发送方可以感觉良好，

156
00:10:04,340 --> 00:10:06,060
保持该位号 2 不变。

157
00:10:07,020 --> 00:10:11,349
然后在另一端，如果接收器检查该组的奇偶校验并且发现奇偶校 

158
00:10:11,349 --> 00:10:15,380
验，他们就会知道错误位于右侧的这 8 位中的某个位置。

159
00:10:15,820 --> 00:10:20,580
否则，这意味着要么没有错误，要么错误位于左半部分。

160
00:10:21,120 --> 00:10:23,978
或者我猜可能有两个错误，但现在我 

161
00:10:23,978 --> 00:10:26,500
们假设整个块中最多有一个错误。

162
00:10:26,940 --> 00:10:28,740
事情远不止于此。

163
00:10:29,160 --> 00:10:31,320
在这里，在我们查看接下来的两项检查之前，

164
00:10:31,320 --> 00:10:34,236
请花点时间思考 一下，当您将前两项检查放在一起考虑时，

165
00:10:34,236 --> 00:10:35,100
我们可以做什么。

166
00:10:35,800 --> 00:10:39,660
假设您在奇数列和右半列中检测到错误。

167
00:10:40,200 --> 00:10:43,040
这必然意味着错误出现在最后一列的某个位置。

168
00:10:43,820 --> 00:10:47,561
如果奇数列中没有错误，但右半部分 有错误，

169
00:10:47,561 --> 00:10:49,700
则说明它位于倒数第二列。

170
00:10:50,440 --> 00:10:54,049
同样，如果奇数列中有错误但右半部分没有 错误，

171
00:10:54,049 --> 00:10:56,560
您就知道它在第二列中的某个位置。

172
00:10:56,560 --> 00:10:59,611
如果这两个奇偶校验都没有检测到任何内容，

173
00:10:59,611 --> 00:11:03,120
则 意味着唯一可能出现错误的位置是最左边的列。

174
00:11:03,340 --> 00:11:06,120
但这也可能仅仅意味着根本没有错误。

175
00:11:06,300 --> 00:11:10,840
这是一种相当繁琐的说法，两次 奇偶校验让我们确定了该列。

176
00:11:11,480 --> 00:11:13,640
从这里，你大概可以猜到接下来会发生什么。

177
00:11:13,800 --> 00:11:16,140
除了行之外，我们基本上做相同的事情。

178
00:11:16,440 --> 00:11:20,900
将使用位置 4 作为奇偶校验位对奇数行进行奇偶校验。

179
00:11:21,380 --> 00:11:24,070
因此，在此示例中，该组已经具有偶 校验，

180
00:11:24,070 --> 00:11:25,820
因此位 4 将设置为 0。

181
00:11:26,560 --> 00:11:29,150
最后，对底部两行进行奇偶校验， 

182
00:11:29,150 --> 00:11:31,580
使用位置 8 作为奇偶校验位。

183
00:11:32,120 --> 00:11:34,616
在这种情况下，发送方似乎需要打开 

184
00:11:34,616 --> 00:11:36,820
第 8 位才能为组提供偶校验。

185
00:11:37,700 --> 00:11:39,970
正如前两项检查让我们确定列一样 ，

186
00:11:39,970 --> 00:11:41,840
接下来的两项检查让您确定行。

187
00:11:42,880 --> 00:11:47,540
举个例子，假设在传输过程中，位置 3 处出现错误。

188
00:11:48,180 --> 00:11:52,608
这会影响第一个奇偶校验组，也会影响第二个奇偶 校验组，

189
00:11:52,608 --> 00:11:55,560
因此接收器知道右列中的某处存在错误。

190
00:11:56,100 --> 00:12:00,540
但不影响第三组，也不影响第四组。

191
00:12:01,240 --> 00:12:04,522
这可以让接收者精确定位到第一行（这必然意味着 

192
00:12:04,522 --> 00:12:07,520
位置 3）的错误，这样他们就可以修复错误。

193
00:12:08,580 --> 00:12:12,923
您可能会喜欢花点时间说服自己，这四个问题的答案确实 

194
00:12:12,923 --> 00:12:17,100
总是能让您确定一个特定的位置，无论它们最终在哪里。

195
00:12:17,720 --> 00:12:20,547
事实上，精明的你们甚至可能会注意到 

196
00:12:20,547 --> 00:12:23,060
这些问题和二进制计数之间的联系。

197
00:12:23,500 --> 00:12:25,822
如果你这样做了，请再次让我强调一下，

198
00:12:25,822 --> 00:12:28,920
暂停一 下，在我破坏之前尝试自己找出其中的联系。

199
00:12:30,500 --> 00:12:34,515
如果您想知道如果奇偶校验位本身受到影 响会发生什么，

200
00:12:34,515 --> 00:12:36,060
那么您可以尝试一下。

201
00:12:36,440 --> 00:12:40,471
花点时间思考一下，如何使用同一组四个问题来追踪这 

202
00:12:40,471 --> 00:12:44,180
四个特殊位中的任何错误，就像任何其他错误一样。

203
00:12:47,060 --> 00:12:51,269
这并不重要，因为最终我们想要的是 保护消息位，

204
00:12:51,269 --> 00:12:53,100
纠错位只是随之而来。

205
00:12:53,600 --> 00:12:57,820
但保护这些位也是 该计划的副产品。

206
00:12:59,200 --> 00:13:01,760
您可能还喜欢预测其规模如何。

207
00:13:02,300 --> 00:13:07,825
例如，如果我们使用大小为 256 位的块，为了确定位置 ，

208
00:13:07,825 --> 00:13:12,780
您只需要八个是或否问题即可二进制搜索到某个特定位置。

209
00:13:15,640 --> 00:13:20,500
请记住，每个问题只需要放弃一 位即可设置适当的奇偶校验。

210
00:13:23,160 --> 00:13:26,407
你们中的一些人可能已经看到了，但我们稍后会 

211
00:13:26,407 --> 00:13:29,360
讨论在一两分钟内找到这些问题的系统方法。

212
00:13:29,880 --> 00:13:33,260
希望这个草图足以让我们了解 我们正在开发的产品的效率。

213
00:13:33,260 --> 00:13:37,197
第一件事，除了那八个突出显示的奇偶校验位之外，

214
00:13:37,197 --> 00:13:41,820
可以 是您想要的任何内容，携带您想要的任何消息或数据。

215
00:13:41,820 --> 00:13:46,665
8 位是冗余的，因为它们完全由消息的其余部分 决定，

216
00:13:46,665 --> 00:13:50,020
但它比简单地复制整个消息要聪明得多。

217
00:13:53,600 --> 00:13:58,380
尽管如此，只要放弃一点点，您就 能够识别并修复任何一位错误。

218
00:13:59,200 --> 00:14:00,400
嗯，差不多了。

219
00:14:00,960 --> 00:14:05,048
好的，所以这里的一个问题是，如果四个奇偶校验检查都没 

220
00:14:05,048 --> 00:14:08,985
有检测到错误，这意味着专门选择的 8 位子集都具有 

221
00:14:08,985 --> 00:14:11,711
偶数奇偶校验，就像发送者预期的那样，

222
00:14:11,711 --> 00:14:14,134
那么这要么意味着 根本没有错误，

223
00:14:14,134 --> 00:14:16,860
或者它会将我们的范围缩小到位置 0。

224
00:14:17,740 --> 00:14:22,567
你看，有四个是或否问题，我们的奇偶校验有 16 种可能的结 

225
00:14:22,567 --> 00:14:27,233
果，一开始感觉非常适合精确定位块中 16 个位置中的 1 

226
00:14:27,233 --> 00:14:31,900
个，但你还需要传达第 17 个结果，即没有错误健康）状况。

227
00:14:33,020 --> 00:14:37,300
这里的解决方案实际上非常简单，只需完全忘记第 0 位即可。

228
00:14:37,840 --> 00:14:41,833
因此，当我们进行四次奇偶校验并且发现它 们都是偶数时，

229
00:14:41,833 --> 00:14:43,460
就明确意味着没有错误。

230
00:14:44,240 --> 00:14:48,974
这意味着我们不是使用 16 位块，而是使用 15 位块 ，

231
00:14:48,974 --> 00:14:53,220
其中 11 位可自由携带消息，其中 4 位用于冗余。

232
00:14:53,780 --> 00:15:00,200
这样，我们现在就有了业内人士 所说的 15-11 汉明码。

233
00:15:00,460 --> 00:15:03,340
也就是说，块大小是 2 的幂次方是件好事，

234
00:15:03,340 --> 00:15:05,945
并且有一种聪明 的方法可以保留第 0 

235
00:15:05,945 --> 00:15:08,140
位并让它为我们做一些额外的工作。

236
00:15:08,700 --> 00:15:11,319
如果我们将它用作整个块的奇偶校验位，

237
00:15:11,319 --> 00:15:15,540
即使我们无 法纠正，它也可以让我们实际检测到 2 位错误。

238
00:15:16,160 --> 00:15:16,820
这是它的工作原理。

239
00:15:17,180 --> 00:15:20,910
设置完这四个特殊的纠错位后，我们设置第 0 个位，

240
00:15:20,910 --> 00:15:24,940
以 便整个块的奇偶校验是偶数，就像正常的奇偶校验一样。

241
00:15:25,700 --> 00:15:30,009
现在，如果存在单个位错误，则整个块的奇偶校验会切换为奇 数，

242
00:15:30,009 --> 00:15:33,600
但由于四次纠错检查，我们无论如何都会捕获到这一点。

243
00:15:34,160 --> 00:15:39,037
然而，如果有两个错误，那么整体奇偶校验将 切换回偶数，

244
00:15:39,037 --> 00:15:42,650
但接收器仍然会看到由于这四个 奇偶校验检

245
00:15:42,650 --> 00:15:45,180
查的情况而至少存在一些错误。

246
00:15:45,180 --> 00:15:48,153
因此，如果他们注意到整体奇偶校验，

247
00:15:48,153 --> 00:15:52,700
但其他检 查发生非零的情况，则表明至少存在两个错误。

248
00:15:53,520 --> 00:15:54,000
这不是很聪明吗？

249
00:15:54,300 --> 00:15:56,575
尽管我们无法纠正这些 2 位错误，

250
00:15:56,575 --> 00:15:59,787
但只需将那个有点麻 烦的第 0 位重新投入工作，

251
00:15:59,787 --> 00:16:01,260
我们就可以检测到它们。

252
00:16:02,260 --> 00:16:05,220
这是非常标准的，被称为扩展汉明码。

253
00:16:06,540 --> 00:16:10,313
从技术上讲，您现在已经完整地描述了汉明码的 作用，

254
00:16:10,313 --> 00:16:12,880
至少对于 16 位块的示例是这样。

255
00:16:12,880 --> 00:16:17,262
但我认为您会发现通过自己从头到尾做一个完整的示例来检 

256
00:16:17,262 --> 00:16:21,320
查您的理解并巩固到目前为止的所有内容会更令人满意。

257
00:16:22,080 --> 00:16:24,300
不过我会和你一起逐步完成，这样你就可以自己检查一下。

258
00:16:25,120 --> 00:16:28,360
要设置消息，无论是在空间上转换的文 

259
00:16:28,360 --> 00:16:31,420
字消息还是要随时间存储的某些数据，

260
00:16:31,420 --> 00:16:34,660
 第一步都是将其划分为 11 位块。

261
00:16:35,580 --> 00:16:39,760
每个块将被打包成一个防错的 16 位块。

262
00:16:39,760 --> 00:16:43,220
那我们就以这个为例，实际操作一下吧。

263
00:16:43,740 --> 00:16:44,740
话不多说，实际行动起来吧！

264
00:16:44,740 --> 00:16:47,020
让我们暂停一下并尝试将这个块放在一起。

265
00:16:52,720 --> 00:16:53,680
好吧，你准备好了吗？

266
00:16:54,240 --> 00:16:59,225
请记住，位置 0 以及 2 的其他幂保留用于纠错职 责，

267
00:16:59,225 --> 00:17:03,320
因此您首先将消息位按顺序放置在所有剩余位置中。

268
00:17:05,339 --> 00:17:08,362
您需要该组具有偶校验，它已经这样做了，

269
00:17:08,362 --> 00:17:12,339
因此您 应该将位置 1 中的奇偶校验位设置为 0。

270
00:17:13,020 --> 00:17:15,601
下一组以奇数奇偶校验开始，因此您 

271
00:17:15,601 --> 00:17:17,880
应该将其奇偶校验位设置为 1。

272
00:17:19,160 --> 00:17:21,772
之后的组以奇数奇偶校验开始，因此您 

273
00:17:21,772 --> 00:17:24,240
应该再次将其奇偶校验位设置为 1。

274
00:17:24,780 --> 00:17:27,566
最后一组也有奇数奇偶校验，这意味着我 

275
00:17:27,566 --> 00:17:30,060
们将位置 8 中的该位设置为 1。

276
00:17:31,300 --> 00:17:34,580
最后一步，整个块现在具有偶校验，

277
00:17:34,580 --> 00:17:40,320
这意味着您可 以将位号 0（总体奇偶校验位）设置为 0。

278
00:17:41,340 --> 00:17:44,827
因此，当该块被发送出去时，四个特殊子集 

279
00:17:44,827 --> 00:17:48,140
和整个块的奇偶校验都将为偶数，即 0。

280
00:17:48,820 --> 00:17:52,180
作为练习的第二部分，让您扮演接收者的角色。

281
00:17:53,480 --> 00:17:56,082
当然，这意味着您还不知道该消息是什么，

282
00:17:56,082 --> 00:17:59,780
也许你们 中的一些人记住了它，但我们假设您还没有记住。

283
00:18:00,020 --> 00:18:04,737
我要做的是更改该块中的 0、1 或 2 位，

284
00:18:04,737 --> 00:18:07,740
然后要求您弄清楚我做了什么。

285
00:18:08,260 --> 00:18:10,810
所以，再次，暂停并尝试解决它。

286
00:18:18,790 --> 00:18:22,747
好的，作为接收者，您现在检查第一个奇偶校验组，

287
00:18:22,747 --> 00:18:27,910
您可以 看到它是偶数，因此存在的任何错误都必须位于偶数列中。

288
00:18:29,690 --> 00:18:34,233
下一次检查给我们一个奇数，告诉我们至少有一 个错误，

289
00:18:34,233 --> 00:18:37,030
并将我们的范围缩小到这一特定列。

290
00:18:38,550 --> 00:18:41,790
第三次检查是均匀的，进一步减少了可能性。

291
00:18:42,650 --> 00:18:46,671
最后的奇偶校验很奇怪，告诉我们底部的某个地方有 错误，

292
00:18:46,671 --> 00:18:49,650
现在我们可以看到它一定在位置 10 处。

293
00:18:51,490 --> 00:18:54,510
更重要的是，整个区块的奇偶性是奇怪的，

294
00:18:54,510 --> 00:18:57,530
 这让我们确信只有一次翻转而不是两次。

295
00:18:58,070 --> 00:18:59,970
如果是三个或更多，则所有赌注都失败了。

296
00:19:01,310 --> 00:19:06,049
纠正第 10 位后，取出未用于纠正的 11 位 ，

297
00:19:06,049 --> 00:19:10,598
即可得到原始消息的相关片段，如果您倒回并比 较，

298
00:19:10,598 --> 00:19:14,390
该片段确实正是我们开始示例时所用的片段。

299
00:19:15,710 --> 00:19:18,282
现在您已经知道如何手动完成所有这些操作，

300
00:19:18,282 --> 00:19:20,983
我想向您展示如何使 用一行 Python 

301
00:19:20,983 --> 00:19:23,170
代码来执行所有这些逻辑的核心部分。

302
00:19:23,870 --> 00:19:28,097
你看，我还没有告诉你的是这个算法到底有多么优 雅，

303
00:19:28,097 --> 00:19:32,493
让机器指出错误的位置是多么简单，如何系 统地缩放它，

304
00:19:32,493 --> 00:19:36,213
以及我们如何构建所有错误这是一 个单一操作，

305
00:19:36,213 --> 00:19:38,750
而不是多个单独的奇偶校验检查。

306
00:19:39,430 --> 00:19:41,310
要明白我的意思，请跟我一起看第二部分。

