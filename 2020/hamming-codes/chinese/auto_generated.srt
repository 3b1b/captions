1
00:00:00,000 --> 00:00:03,120
我假设这里的每个人都来自第 1 部分。

2
00:00:03,120 --> 00:00:07,015
我们讨论的是汉明码，这是一种创建数据块的方法

3
00:00:07,015 --> 00:00:10,741
，其中大多数位携带有意义的消息，而其他一些

4
00:00:10,741 --> 00:00:14,637
位则充当一种冗余，这样如果任何位被翻转，要么

5
00:00:14,637 --> 00:00:18,363
是一条消息位或冗余位，该块中的任何内容，接

6
00:00:18,363 --> 00:00:21,920
收器将能够识别出存在错误，以及如何修复它。

7
00:00:21,920 --> 00:00:25,972
那里提出的基本思想是如何使用多个奇

8
00:00:25,972 --> 00:00:29,800
偶校验来进行二进制搜索以找出错误。

9
00:00:29,800 --> 00:00:32,766
在该视频中，我们的目标是让汉明码尽可

10
00:00:32,766 --> 00:00:35,420
能具有动手操作和可重新发现的感觉。

11
00:00:35,420 --> 00:00:39,858
但是，当您开始考虑在软件或硬件中实际实现这一点时

12
00:00:39,858 --> 00:00:44,120
，该框架实际上可能低估了这些代码的真正优雅程度。

13
00:00:44,120 --> 00:00:47,588
您可能认为您需要编写一个算法来跟踪所

14
00:00:47,588 --> 00:00:51,056
有可能的错误位置，并在每次检查时将该

15
00:00:51,056 --> 00:00:54,160
组切成两半，但实际上比这简单得多。

16
00:00:54,160 --> 00:00:57,651
如果你读出我们在上一个视频中所做的四次奇偶

17
00:00:57,651 --> 00:01:01,142
校验的答案，全部都是 1 和 0，而不是是

18
00:01:01,142 --> 00:01:04,800
和否，它实际上以二进制形式说明了错误的位置。

19
00:01:04,800 --> 00:01:08,906
例如，二进制中的数字 7 看起来像 011

20
00:01:08,906 --> 00:01:12,640
1，本质上是说它是 4 加 2 加 1。

21
00:01:12,640 --> 00:01:17,558
请注意位置 7 所在的位置，它确实影响我们的第一

22
00:01:17,558 --> 00:01:22,280
个奇偶组，以及第二个和第三个，但不影响最后一个。

23
00:01:22,280 --> 00:01:28,520
因此，从下到上读取这四次检查的 结果确实可以阐明错误的位置。

24
00:01:28,520 --> 00:01:33,074
示例 7 没有什么特别的，这在一般情况下是有效

25
00:01:33,074 --> 00:01:37,440
的，这使得在硬件中实现整个方案的逻辑非常简单。

26
00:01:37,440 --> 00:01:41,609
现在，如果您想了解为什么会发生这种神奇的情况，请将这

27
00:01:41,609 --> 00:01:45,933
1 6 个索引标签作为我们的位置，但不要将它们写入基数

28
00:01:45,933 --> 00:01:49,947
10 ，而是将它们全部写入二进制，从 0000 到

29
00:01:49,947 --> 00:01:50,720
1111。

30
00:01:50,720 --> 00:01:54,783
当我们将这些二进制标签放回它们的盒子时

31
00:01:54,783 --> 00:01:58,440
，让我强调它们与实际发送的数据不同。

32
00:01:58,440 --> 00:02:01,412
它们只不过是一个概念标签，可以

33
00:02:01,412 --> 00:02:04,200
帮助你我理解四个奇偶组的来源。

34
00:02:04,200 --> 00:02:08,874
用二进制描述我们所看到的一切的优雅可能会因为我

35
00:02:08,874 --> 00:02:13,160
们所看到的一切都以二进制描述的混乱而被削弱。

36
00:02:13,160 --> 00:02:15,040
不过，这是值得的。

37
00:02:15,040 --> 00:02:19,772
将您的注意力集中在所有这些标签的最后一位

38
00:02:19,772 --> 00:02:24,280
上，然后突出显示最后一位为 1 的位置。

39
00:02:24,280 --> 00:02:28,542
我们得到的是四个奇偶校验组中的第一个，这意

40
00:02:28,542 --> 00:02:32,805
味着您可以将第一个检查解释为询问，嘿，如果

41
00:02:32,805 --> 00:02:36,680
有错误，该错误位置的最后一位是否为 1？

42
00:02:36,680 --> 00:02:41,860
同样，如果您关注倒数第二位，并突出显示所有为 1

43
00:02:41,860 --> 00:02:47,040
的位置，您就会从我们的方案中获得第二个奇偶校验组。

44
00:02:47,040 --> 00:02:51,706
换句话说，第二次检查会问，嘿，我再说一次，

45
00:02:51,706 --> 00:02:56,160
如果有错误，该位置的倒数第二位是 1 吗？

46
00:02:56,160 --> 00:02:57,160
等等。

47
00:02:57,160 --> 00:03:03,889
第三个奇偶校验涵盖倒数第三位打开的每个位置，最后一个

48
00:03:03,889 --> 00:03:10,120
奇偶校验涵盖最后八个位置，即最高位为 1 的位置。

49
00:03:10,120 --> 00:03:15,084
我们之前所做的一切都与回答这四个问题相

50
00:03:15,084 --> 00:03:19,800
同，而这又与以二进制拼出一个位置相同。

51
00:03:19,800 --> 00:03:22,080
我希望这能让两件事变得更清楚。

52
00:03:22,080 --> 00:03:27,140
第一个是如何系统地推广到大于 2 的幂的块大小。

53
00:03:27,140 --> 00:03:32,506
如果需要更多位来描述每个位置，例如 6 位来描述 64

54
00:03:32,506 --> 00:03:38,256
个点 ，那么其中每一位都会为您提供我们需要检查的奇偶校验组之

55
00:03:38,256 --> 00:03:38,640
一。

56
00:03:38,640 --> 00:03:41,088
那些看过我和马特·帕克一起做的棋盘

57
00:03:41,088 --> 00:03:43,400
拼图的人可能会发现这一切非常熟悉。

58
00:03:43,400 --> 00:03:46,830
它是相同的核心逻辑，但解决不同的问

59
00:03:46,830 --> 00:03:49,880
题，并应用于 64 方格的棋盘。

60
00:03:49,880 --> 00:03:54,186
我希望这能澄清的第二件事是为什么我们的奇偶校验位

61
00:03:54,186 --> 00:03:58,320
位于 2 的幂的位置，例如 1、2、4 和 8。

62
00:03:58,320 --> 00:04:03,640
这些位置的二进制表示仅打开了一位。

63
00:04:03,640 --> 00:04:08,261
这意味着这些奇偶校验位中的每一个都位

64
00:04:08,261 --> 00:04:12,640
于四个奇偶校验组中的一个且仅一个内。

65
00:04:12,640 --> 00:04:19,427
您还可以在更大的示例中看到这一点，无论您有多

66
00:04:19,427 --> 00:04:25,920
大，每个奇偶校验位都只方便地触及其中一个组。

67
00:04:25,920 --> 00:04:29,709
一旦您明白我们花费大量时间关注的这些奇

68
00:04:29,709 --> 00:04:33,309
偶校验只不过是一种巧妙的方式来阐明二

69
00:04:33,309 --> 00:04:36,909
进制错误的位置，那么我们就可以用不同

70
00:04:36,909 --> 00:04:40,509
的方式来思考汉明代码，可以说更简单、

71
00:04:40,509 --> 00:04:43,920
更优雅，基本上可以用一行代码写下来。

72
00:04:43,920 --> 00:04:46,200
它基于 XOR 函数。

73
00:04:46,200 --> 00:04:50,960
XOR，对于那些不知道的人来说，代表异或。

74
00:04:50,960 --> 00:04:55,874
当您对两位进行异或时，如果其中一位打开，它将返回

75
00:04:55,874 --> 00:05:00,200
1，但如果两者都打开或关闭，则不会返回 1。

76
00:05:00,200 --> 00:05:03,760
换句话说，它是这两个位的奇偶校验。

77
00:05:03,760 --> 00:05:07,840
作为一个数学家，我更喜欢将其视为加法 mod 2。

78
00:05:07,840 --> 00:05:11,122
我们还经常谈论两个不同位串的异或，

79
00:05:11,122 --> 00:05:14,040
它基本上是逐个组件地执行此操作。

80
00:05:14,040 --> 00:05:16,280
这就像加法，但你永远不会携带。

81
00:05:16,280 --> 00:05:19,997
同样，更倾向于数学的人可能更愿意将其

82
00:05:19,997 --> 00:05:23,520
视为添加两个向量并减少 mod 2。

83
00:05:23,520 --> 00:05:26,777
如果您现在打开一些 Python

84
00:05:26,777 --> 00:05:30,609
并在两个整数之间应用插入符号 操作，这就

85
00:05:30,609 --> 00:05:35,400
是它正在做的事情，但只是针对这些数字的位表示形式。

86
00:05:35,400 --> 00:05:40,972
对你和我来说，关键点在于，对许多不同的位

87
00:05:40,972 --> 00:05:46,278
串进行异或运算实际上是一种计算一堆单独

88
00:05:46,278 --> 00:05:51,320
组的模仿的方法，就像列一样，一举完成。

89
00:05:51,320 --> 00:05:55,581
这为我们提供了一种相当时髦的方式来思考汉明码算法中

90
00:05:55,581 --> 00:05:59,680
的多个奇偶校验，因为所有这些都被打包到一个操作中。

91
00:05:59,680 --> 00:06:02,800
虽然乍一看确实很不一样。

92
00:06:02,800 --> 00:06:07,987
像我们之前那样，专门写下二进制的 16

93
00:06:07,987 --> 00:06:12,915
个 位置，现在突出显示消息位变为 1

94
00:06:12,915 --> 00:06:19,400
的位置， 然后将这些位置收集到一大列中并进行异或。

95
00:06:19,400 --> 00:06:26,289
您可能会猜到，结果位于底部的 4 位与 我们所了解和喜爱的

96
00:06:26,289 --> 00:06:32,720
4 个奇偶校验相同 ，但请花点时间思考一下到底是为什么。

97
00:06:32,720 --> 00:06:37,317
例如，最后一列正在计算最后一位为 1 的所有位置

98
00:06:37,317 --> 00:06:41,730
，但我们已经仅限于突出显示的位置，因此它有效地

99
00:06:41,730 --> 00:06:45,960
计算有多少突出显示的位置来自第一个奇偶校验组。

100
00:06:45,960 --> 00:06:48,520
那有意义吗？

101
00:06:48,520 --> 00:06:52,706
同样，下一列计算第二个奇偶校验组中有

102
00:06:52,706 --> 00:06:56,893
多少个位置、倒数第二个位为 1 的位

103
00:06:56,893 --> 00:07:00,640
置以及也突出显示的位置，依此类推。

104
00:07:00,640 --> 00:07:07,640
这实际上只是对我们一直在做的同一件事的看法的一个小小的转变。

105
00:07:07,640 --> 00:07:10,000
所以你知道它从这里走向何方。

106
00:07:10,000 --> 00:07:19,640
发送方负责切换一些特殊奇偶校验 位，以确保总和为 0000。

107
00:07:19,640 --> 00:07:24,348
现在，一旦我们有了这样的结果，这给了我们一个非常好的方

108
00:07:24,348 --> 00:07:28,720
法来思考为什么底部的这四个结果位直接拼出错误的位置。

109
00:07:28,720 --> 00:07:32,720
假设此块中的某些位从 0 切换到 1。

110
00:07:32,720 --> 00:07:37,694
这意味着该位的位置现在将包含在总 XOR

111
00:07:37,694 --> 00:07:44,800
中，这会将总和从 0 更改 为这个新包含的值，即错误的位置。

112
00:07:44,800 --> 00:07:47,375
不太明显的是，如果出现将 1 更

113
00:07:47,375 --> 00:07:49,800
改为 0 的错误，情况也是如此。

114
00:07:49,800 --> 00:07:54,570
你看，如果你将一个位串加在一起两次，那就和根本没有它一

115
00:07:54,570 --> 00:07:59,000
样，基本上是因为在这个世界上 1 加 1 等于 0。

116
00:07:59,000 --> 00:08:02,303
因此，将此位置的副本添加到总和

117
00:08:02,303 --> 00:08:05,400
中与我们移动它具有相同的效果。

118
00:08:05,400 --> 00:08:13,480
同样，这种效果是底部的总 结果阐明了错误的位置。

119
00:08:13,480 --> 00:08:17,545
为了说明这是多么优雅，让我展示我之前引用的一行

120
00:08:17,545 --> 00:08:22,120
P ython 代码，它将捕获接收器端的几乎所有逻辑。

121
00:08:22,120 --> 00:08:26,398
我们将首先创建一个由 16 个 1 和 0 组成的随

122
00:08:26,398 --> 00:08:30,518
机数组来模拟数据块，我将给它命名位，但当然，在实践

123
00:08:30,518 --> 00:08:34,638
中，这将是我们从发送方接收的内容，而不是如果是随机

124
00:08:34,638 --> 00:08:38,600
的，它将携带 11 个数据位和 5 个奇偶校验位。

125
00:08:38,600 --> 00:08:43,586
如果我调用函数 enumerateBits，它的作用是将每

126
00:08:43,586 --> 00:08:48,240
个位与相应的索引配对在一起，在本例中为从 0 到 15。

127
00:08:48,240 --> 00:08:52,907
因此，如果我们创建一个列表，循环遍历所有这些对，看起来像

128
00:08:52,907 --> 00:08:57,574
i 的对，然后我们只取出 i 值，只取出索引，好吧，这并

129
00:08:57,574 --> 00:09:01,920
不是那么令人兴奋，我们只是取回那些索引 0 到 15。

130
00:09:01,920 --> 00:09:07,872
但是，如果我们添加条件以仅执行此 if 位，即如果该位

131
00:09:07,872 --> 00:09:13,400
是 1 而不是 0，那么它只会提取相应位打开的位置。

132
00:09:13,400 --> 00:09:20,720
在本例中，这些位置看起来是 0、4、6、9 等。

133
00:09:20,720 --> 00:09:25,571
我们想要的是将所有这些位置（打开的位的位

134
00:09:25,571 --> 00:09:29,960
置）收集在一起，然后将它们异或在一起。

135
00:09:29,960 --> 00:09:31,960
为了在 Python 中执行此操

136
00:09:31,960 --> 00:09:33,960
作，让我首先导入几个有用的函数。

137
00:09:33,960 --> 00:09:36,480
这样我们就可以在这个列表上调用red

138
00:09:36,480 --> 00:09:39,140
uce()，并使用XOR函数来减少它。

139
00:09:39,140 --> 00:09:44,840
这基本上会遍历列表，并一路进行异或运算。

140
00:09:44,840 --> 00:09:48,625
如果您愿意，您可以显式写出该 XO

141
00:09:48,625 --> 00:09:52,200
R 函数，而无需从任何地方导入它。

142
00:09:52,200 --> 00:09:57,245
所以目前看来，如果我们对 16 位随机块执行此

143
00:09:57,245 --> 00:10:02,080
操作，它会返回 9，其二进制表示为 1001。

144
00:10:02,080 --> 00:10:07,306
我们不会在这里这样做，但您可以编写一个函数，其中发送方

145
00:10:07,306 --> 00:10:12,346
使用该二进制表示形式根据需要设置四个奇偶校验位，最终

146
00:10:12,346 --> 00:10:17,200
使该块达到在完整位列表上运行这行代码的状态一个 0。

147
00:10:17,200 --> 00:10:20,200
这将被认为是一个准备充分的区块。

148
00:10:20,200 --> 00:10:25,491
很酷的是，如果我们切换此列表中的任何一位，模拟噪声引起的

149
00:10:25,491 --> 00:10:30,600
随机错误，那么如果您运行同一行代码，它就会打印出该错误。

150
00:10:30,600 --> 00:10:31,920
这不是很整洁吗？

151
00:10:31,920 --> 00:10:37,542
你可以突然得到这个块，在上面运行这一行，它会

152
00:10:37,542 --> 00:10:42,920
自动吐出错误的位置，如果没有错误则吐出 0。

153
00:10:42,920 --> 00:10:45,520
16号没有什么特别的。

154
00:10:45,520 --> 00:10:52,280
如果您有一个 256 位的列表，那么同一行代码也可以工作。

155
00:10:52,280 --> 00:10:56,724
不用说，这里需要编写更多代码，例如进行元奇偶校验

156
00:10:56,724 --> 00:11:00,991
来检测 2 位错误，但我们的想法是，我们方案中

157
00:11:00,991 --> 00:11:05,080
的几乎所有核心逻辑都归结为单个 XOR 减少。

158
00:11:05,080 --> 00:11:09,888
现在，根据您对二进制、异或和软件的熟悉程度，您可能

159
00:11:09,888 --> 00:11:14,696
会发现这种观点有点令人困惑，或者更加优雅和简单，以

160
00:11:14,696 --> 00:11:19,320
至于您想知道为什么我们不从一开始就开始使用它-去。

161
00:11:19,320 --> 00:11:23,454
宽松地说，当非常直接地在硬件中实现汉明码时，更

162
00:11:23,454 --> 00:11:27,589
容易考虑多重奇偶校验的观点，而当在软件中从更高

163
00:11:27,589 --> 00:11:31,380
的层次上实现汉明码时，最容易考虑异或的观点。

164
00:11:31,380 --> 00:11:36,404
第一个实际上最容易手动完成，我认为它可以更

165
00:11:36,404 --> 00:11:41,428
好地灌输所有这一切背后的核心直觉，即定位单

166
00:11:41,428 --> 00:11:46,452
个错误所需的信息与块大小的日志相关，或者换

167
00:11:46,452 --> 00:11:51,020
句话说，随着块大小加倍，它一次增长一位。

168
00:11:51,020 --> 00:11:56,440
这里的相关事实是，该信息直 接对应于我们需要多少冗余。

169
00:11:56,440 --> 00:12:00,275
这确实与大多数人在第一次考虑使消息

170
00:12:00,275 --> 00:12:04,110
能够抵御错误时的下意识反应相悖，通

171
00:12:04,110 --> 00:12:07,520
常复制整个消息是首先想到的本能。

172
00:12:07,520 --> 00:12:11,248
然后，顺便说一句，有时您会看到汉明码的另

173
00:12:11,248 --> 00:12:14,800
一种呈现方式，即您将消息乘以一个大矩阵。

174
00:12:14,800 --> 00:12:20,081
这很好，因为它将它与更广泛的线性代码家族联系起来，

175
00:12:20,081 --> 00:12:25,160
但我认为这几乎没有给出它来自何处或如何扩展的直觉。

176
00:12:25,160 --> 00:12:28,775
说到扩展，您可能会注意到，当我们增加

177
00:12:28,775 --> 00:12:32,200
块大小时，该方案的效率只会变得更好。

178
00:12:32,200 --> 00:12:37,955
例如，我们看到，对于 256 位，您仅使用该空间

179
00:12:37,955 --> 00:12:43,480
的 3% 进行冗余，并且从那里开始变得越来越好。

180
00:12:43,480 --> 00:12:49,040
随着奇偶校验位的数量逐个增加，块大小不断加倍。

181
00:12:49,040 --> 00:12:52,736
如果你把它发挥到极致，你可能会拥有一个具有

182
00:12:52,736 --> 00:12:56,768
1 00 万位的块，实际上你会用奇偶校验来回答

183
00:12:56,768 --> 00:13:00,800
2 0 个问题，而它只使用 21 个奇偶校验位。

184
00:13:00,800 --> 00:13:04,838
如果你退后一步考虑查看一百万位并

185
00:13:04,838 --> 00:13:08,640
找到一个错误，那真的感觉很疯狂。

186
00:13:08,640 --> 00:13:13,591
当然，问题在于，对于较大的块，看到超过一或两个位错误

187
00:13:13,591 --> 00:13:18,360
的概率会上升，而汉明码无法处理超出此范围的任何内容。

188
00:13:18,360 --> 00:13:22,556
因此，在实践中，您需要找到正确的大

189
00:13:22,556 --> 00:13:26,520
小，以便太多位翻转的概率不会太高。

190
00:13:26,520 --> 00:13:32,916
此外，在实践中，错误往往会突然出现，这会完全破坏单个块

191
00:13:32,916 --> 00:13:39,312
，因此帮助将错误突发分散到许多不同块的一种常见策略是在

192
00:13:39,312 --> 00:13:45,480
这些块被破坏之前将这些块交错，就像这样。 发出或存储。

193
00:13:45,480 --> 00:13:50,298
话又说回来，其中很多内容在更现代的代码中完全没有意义

194
00:13:50,298 --> 00:13:55,117
，比如更常用的里德-所罗门算法，它可以很好地处理突发

195
00:13:55,117 --> 00:13:59,580
错误，并且可以对其进行调整以适应每个块的更多错误。

196
00:13:59,580 --> 00:14:03,000
但这是另一个话题了。

197
00:14:03,000 --> 00:14:06,939
汉明在他的《科学与工程的艺术》一书中非常坦

198
00:14:06,939 --> 00:14:10,700
诚地讲述了他发现这段代码的过程是多么曲折。

199
00:14:10,700 --> 00:14:14,735
他首先尝试了各种不同的方案，包括将这些位组织

200
00:14:14,735 --> 00:14:18,420
成更高维晶格的部分以及诸如此类的奇怪事物。

201
00:14:18,420 --> 00:14:22,163
汉明在进行了一系列其他分析后退后一步，问

202
00:14:22,163 --> 00:14:25,729
道：“好吧，我能做到的最有效的方法是什

203
00:14:25,729 --> 00:14:29,294
么”时，他才想到了通过奇偶校验来共谋以

204
00:14:29,294 --> 00:14:32,860
阐明错误位置的想法。 可能是关于这个的？

205
00:14:32,860 --> 00:14:37,533
他还坦诚地表示，奇偶校验已经在他的脑海中变得多么重要，

206
00:14:37,533 --> 00:14:42,040
而在 20 世纪 40 年代，奇偶校验比今天要少得多。

207
00:14:42,040 --> 00:14:46,040
在这本书中，他大约有六次引用了路易斯·

208
00:14:46,040 --> 00:14:49,640
巴斯德的名言：幸运眷顾有准备的头脑。

209
00:14:49,640 --> 00:14:55,120
事后看来，聪明的想法往往看似简单，这使得它们很容易被低估。

210
00:14:55,120 --> 00:14:58,637
现在我真诚地希望汉明码，或者至少是这种代

211
00:14:58,637 --> 00:15:01,820
码的可能性，对你来说几乎是显而易见的。

212
00:15:01,820 --> 00:15:05,091
但你不应该自欺欺人地认为它们实际上

213
00:15:05,091 --> 00:15:08,000
是显而易见的，因为它们绝对不是。

214
00:15:08,000 --> 00:15:11,995
聪明的想法看起来看似简单，部分原因是我们

215
00:15:11,995 --> 00:15:15,990
只看到最终结果，清理混乱的部分，从不提及

216
00:15:15,990 --> 00:15:19,985
所有错误的转折，低估了问题开始时可探索的

217
00:15:19,985 --> 00:15:23,980
可能性空间有多大。 解决过程，所有这一切。

218
00:15:23,980 --> 00:15:25,280
但总的来说确实如此。

219
00:15:25,280 --> 00:15:28,247
我认为对于一些特殊的发明，我们低

220
00:15:28,247 --> 00:15:31,040
估它们还有第二个更深层次的原因。

221
00:15:31,040 --> 00:15:34,058
直到 1948 年，随着克劳德·香农（Claude

222
00:15:34,058 --> 00:15:36,845
Shannon）关于 信息论的开创性论文的出现，

223
00:15:36,845 --> 00:15:39,400
用比特来思考信息才真正融合成一个完整的理论。

224
00:15:39,400 --> 00:15:43,440
这基本上与汉明开发他的算法的时间同时发生。

225
00:15:43,440 --> 00:15:47,003
这篇基础论文在某种意义上表明，无

226
00:15:47,003 --> 00:15:50,566
论位翻转的概率有多高，有效的纠错

227
00:15:50,566 --> 00:15:53,920
总是可能的，至少在理论上是这样。

228
00:15:53,920 --> 00:15:58,243
顺便说一句，香农和汉明在贝尔实验室共用一间办公室，

229
00:15:58,243 --> 00:16:02,400
尽管他们从事的工作截然不同，这在这里似乎并非巧合。

230
00:16:02,400 --> 00:16:07,962
快进几十年，如今，我们中的许多人都沉浸在对比特和

231
00:16:07,962 --> 00:16:13,080
信息的思考中，很容易忽视这种思维方式的独特性。

232
00:16:13,080 --> 00:16:15,551
具有讽刺意味的是，那些最深刻地塑造下一代思维方

233
00:16:15,551 --> 00:16:17,920
式的想法最终会在下一代人看来比实际情况更简单。

