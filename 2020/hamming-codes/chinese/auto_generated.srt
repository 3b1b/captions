1
00:00:00,000 --> 00:00:02,560
我假设这里的每个人都来自第 1 部分。

2
00:00:03,060 --> 00:00:06,827
我们讨论的是汉明码，这是一种创建数据块的方法 

3
00:00:06,827 --> 00:00:10,430
，其中大多数位携带有意义的消息，而其他一些 

4
00:00:10,430 --> 00:00:14,197
位则充当一种冗余，这样如果任何位被翻转，要么 

5
00:00:14,197 --> 00:00:17,800
是一条消息位或冗余位，该块中的任何内容，接 

6
00:00:17,800 --> 00:00:21,240
收器将能够识别出存在错误，以及如何修复它。

7
00:00:21,880 --> 00:00:24,595
那里提出的基本思想是如何使用多个奇 

8
00:00:24,595 --> 00:00:27,160
偶校验来进行二进制搜索以找出错误。

9
00:00:28,980 --> 00:00:31,946
在该视频中，我们的目标是让汉明码尽可 

10
00:00:31,946 --> 00:00:34,600
能具有动手操作和可重新发现的感觉。

11
00:00:35,180 --> 00:00:39,404
但是，当您开始考虑在软件或硬件中实际实现这一点时 

12
00:00:39,404 --> 00:00:43,460
，该框架实际上可能低估了这些代码的真正优雅程度。

13
00:00:43,920 --> 00:00:47,222
您可能认为您需要编写一个算法来跟踪所 

14
00:00:47,222 --> 00:00:50,525
有可能的错误位置，并在每次检查时将该 

15
00:00:50,525 --> 00:00:53,480
组切成两半，但实际上比这简单得多。

16
00:00:53,940 --> 00:00:57,267
如果你读出我们在上一个视频中所做的四次奇偶

17
00:00:57,267 --> 00:01:00,594
校验的答案，全部都是 1 和 0，而不是是

18
00:01:00,594 --> 00:01:04,080
和否，它实际上以二进制形式说明了错误的位置。

19
00:01:04,780 --> 00:01:08,174
例如，二进制中的数字 7 看起来像 011 

20
00:01:08,174 --> 00:01:11,260
1，本质上是说它是 4 加 2 加 1。

21
00:01:12,540 --> 00:01:17,233
请注意位置 7 所在的位置，它确实影响我们的第一 

22
00:01:17,233 --> 00:01:21,740
个奇偶组，以及第二个和第三个，但不影响最后一个。

23
00:01:22,220 --> 00:01:27,540
因此，从下到上读取这四次检查的 结果确实可以阐明错误的位置。

24
00:01:28,320 --> 00:01:32,149
示例 7 没有什么特别的，这在一般情况下是有效 

25
00:01:32,149 --> 00:01:35,820
的，这使得在硬件中实现整个方案的逻辑非常简单。

26
00:01:37,240 --> 00:01:41,208
现在，如果您想了解为什么会发生这种神奇的情况，请将这 

27
00:01:41,208 --> 00:01:45,323
1 6 个索引标签作为我们的位置，但不要将它们写入基数 

28
00:01:45,323 --> 00:01:49,145
10 ，而是将它们全部写入二进制，从 0000 到 

29
00:01:49,145 --> 00:01:49,880
1111。

30
00:01:50,559 --> 00:01:54,370
当我们将这些二进制标签放回它们的盒子时 

31
00:01:54,370 --> 00:01:57,800
，让我强调它们与实际发送的数据不同。

32
00:01:58,320 --> 00:02:00,993
它们只不过是一个概念标签，可以 

33
00:02:00,993 --> 00:02:03,500
帮助你我理解四个奇偶组的来源。

34
00:02:04,140 --> 00:02:08,428
用二进制描述我们所看到的一切的优雅可能会因为我 

35
00:02:08,428 --> 00:02:12,360
们所看到的一切都以二进制描述的混乱而被削弱。

36
00:02:13,020 --> 00:02:14,120
不过，这是值得的。

37
00:02:14,800 --> 00:02:19,112
将您的注意力集中在所有这些标签的最后一位 

38
00:02:19,112 --> 00:02:23,220
上，然后突出显示最后一位为 1 的位置。

39
00:02:24,240 --> 00:02:28,193
我们得到的是四个奇偶校验组中的第一个，这意 

40
00:02:28,193 --> 00:02:32,146
味着您可以将第一个检查解释为询问，嘿，如果 

41
00:02:32,146 --> 00:02:35,740
有错误，该错误位置的最后一位是否为 1？

42
00:02:38,200 --> 00:02:42,180
同样，如果您关注倒数第二位，并突出显示所有为 1 

43
00:02:42,180 --> 00:02:46,160
的位置，您就会从我们的方案中获得第二个奇偶校验组。

44
00:02:46,740 --> 00:02:50,710
换句话说，第二次检查会问，嘿，我再说一次， 

45
00:02:50,710 --> 00:02:54,500
如果有错误，该位置的倒数第二位是 1 吗？

46
00:02:55,760 --> 00:02:56,900
等等。

47
00:02:57,220 --> 00:03:03,201
第三个奇偶校验涵盖倒数第三位打开的每个位置，最后一个 

48
00:03:03,201 --> 00:03:08,740
奇偶校验涵盖最后八个位置，即最高位为 1 的位置。

49
00:03:09,740 --> 00:03:13,842
我们之前所做的一切都与回答这四个问题相 

50
00:03:13,842 --> 00:03:17,740
同，而这又与以二进制拼出一个位置相同。

51
00:03:19,620 --> 00:03:21,480
我希望这能让两件事变得更清楚。

52
00:03:22,040 --> 00:03:26,460
第一个是如何系统地推广到大于 2 的幂的块大小。

53
00:03:26,960 --> 00:03:31,496
如果需要更多位来描述每个位置，例如 6 位来描述 64 

54
00:03:31,496 --> 00:03:36,356
个点 ，那么其中每一位都会为您提供我们需要检查的奇偶校验组之

55
00:03:36,356 --> 00:03:36,680
一。

56
00:03:38,400 --> 00:03:40,858
那些看过我和马特·帕克一起做的棋盘 

57
00:03:40,858 --> 00:03:43,180
拼图的人可能会发现这一切非常熟悉。

58
00:03:43,660 --> 00:03:46,370
它是相同的核心逻辑，但解决不同的问 

59
00:03:46,370 --> 00:03:48,780
题，并应用于 64 方格的棋盘。

60
00:03:49,880 --> 00:03:53,675
我希望这能澄清的第二件事是为什么我们的奇偶校验位 

61
00:03:53,675 --> 00:03:57,320
位于 2 的幂的位置，例如 1、2、4 和 8。

62
00:03:58,000 --> 00:04:03,000
这些位置的二进制表示仅打开了一位。

63
00:04:03,600 --> 00:04:06,609
这意味着这些奇偶校验位中的每一个都位 

64
00:04:06,609 --> 00:04:09,460
于四个奇偶校验组中的一个且仅一个内。

65
00:04:12,040 --> 00:04:15,771
您还可以在更大的示例中看到这一点，无论您有多 

66
00:04:15,771 --> 00:04:19,339
大，每个奇偶校验位都只方便地触及其中一个组。

67
00:04:25,600 --> 00:04:29,313
一旦您明白我们花费大量时间关注的这些奇 

68
00:04:29,313 --> 00:04:32,841
偶校验只不过是一种巧妙的方式来阐明二 

69
00:04:32,841 --> 00:04:36,369
进制错误的位置，那么我们就可以用不同 

70
00:04:36,369 --> 00:04:39,897
的方式来思考汉明代码，可以说更简单、 

71
00:04:39,897 --> 00:04:43,240
更优雅，基本上可以用一行代码写下来。

72
00:04:43,660 --> 00:04:45,500
它基于 XOR 函数。

73
00:04:46,940 --> 00:04:50,220
XOR，对于那些不知道的人来说，代表异或。

74
00:04:50,780 --> 00:04:55,343
当您对两位进行异或时，如果其中一位打开，它将返回 

75
00:04:55,343 --> 00:04:59,360
1，但如果两者都打开或关闭，则不会返回 1。

76
00:05:00,100 --> 00:05:02,980
换句话说，它是这两个位的奇偶校验。

77
00:05:03,540 --> 00:05:06,760
作为一个数学家，我更喜欢将其视为加法 mod 2。

78
00:05:07,360 --> 00:05:10,578
我们还经常谈论两个不同位串的异或， 

79
00:05:10,578 --> 00:05:13,440
它基本上是逐个组件地执行此操作。

80
00:05:13,680 --> 00:05:15,720
这就像加法，但你永远不会携带。

81
00:05:16,500 --> 00:05:19,570
同样，更倾向于数学的人可能更愿意将其 

82
00:05:19,570 --> 00:05:22,480
视为添加两个向量并减少 mod 2。

83
00:05:23,500 --> 00:05:26,088
如果您现在打开一些 Python 

84
00:05:26,088 --> 00:05:29,133
并在两个整数之间应用插入符号 操作，这就

85
00:05:29,133 --> 00:05:32,940
是它正在做的事情，但只是针对这些数字的位表示形式。

86
00:05:34,960 --> 00:05:39,223
对你和我来说，关键点在于，对许多不同的位 

87
00:05:39,223 --> 00:05:43,283
串进行异或运算实际上是一种计算一堆单独 

88
00:05:43,283 --> 00:05:47,140
组的模仿的方法，就像列一样，一举完成。

89
00:05:51,260 --> 00:05:55,093
这为我们提供了一种相当时髦的方式来思考汉明码算法中 

90
00:05:55,093 --> 00:05:58,780
的多个奇偶校验，因为所有这些都被打包到一个操作中。

91
00:05:59,479 --> 00:06:02,180
虽然乍一看确实很不一样。

92
00:06:02,820 --> 00:06:07,282
像我们之前那样，专门写下二进制的 16 

93
00:06:07,282 --> 00:06:11,521
个 位置，现在突出显示消息位变为 1 

94
00:06:11,521 --> 00:06:17,100
的位置， 然后将这些位置收集到一大列中并进行异或。

95
00:06:19,260 --> 00:06:24,401
您可能会猜到，结果位于底部的 4 位与 我们所了解和喜爱的 

96
00:06:24,401 --> 00:06:29,200
4 个奇偶校验相同 ，但请花点时间思考一下到底是为什么。

97
00:06:32,220 --> 00:06:36,921
例如，最后一列正在计算最后一位为 1 的所有位置 

98
00:06:36,921 --> 00:06:41,434
，但我们已经仅限于突出显示的位置，因此它有效地 

99
00:06:41,434 --> 00:06:45,760
计算有多少突出显示的位置来自第一个奇偶校验组。

100
00:06:46,240 --> 00:06:46,800
那有意义吗？

101
00:06:49,080 --> 00:06:52,852
同样，下一列计算第二个奇偶校验组中有 

102
00:06:52,852 --> 00:06:56,624
多少个位置、倒数第二个位为 1 的位 

103
00:06:56,624 --> 00:07:00,000
置以及也突出显示的位置，依此类推。

104
00:07:00,260 --> 00:07:03,960
这实际上只是对我们一直在做的同一件事的看法的一个小小的转变。

105
00:07:07,760 --> 00:07:09,600
所以你知道它从这里走向何方。

106
00:07:10,000 --> 00:07:15,720
发送方负责切换一些特殊奇偶校验 位，以确保总和为 0000。

107
00:07:15,720 --> 00:07:21,869
现在，一旦我们有了这样的结果，这给了我们一个非常好的方 

108
00:07:21,869 --> 00:07:27,580
法来思考为什么底部的这四个结果位直接拼出错误的位置。

109
00:07:28,460 --> 00:07:31,860
假设此块中的某些位从 0 切换到 1。

110
00:07:32,600 --> 00:07:37,220
这意味着该位的位置现在将包含在总 XOR 

111
00:07:37,220 --> 00:07:43,820
中，这会将总和从 0 更改 为这个新包含的值，即错误的位置。

112
00:07:44,460 --> 00:07:46,984
不太明显的是，如果出现将 1 更 

113
00:07:46,984 --> 00:07:49,360
改为 0 的错误，情况也是如此。

114
00:07:50,180 --> 00:07:54,017
你看，如果你将一个位串加在一起两次，那就和根本没有它一 

115
00:07:54,017 --> 00:07:57,580
样，基本上是因为在这个世界上 1 加 1 等于 0。

116
00:07:57,580 --> 00:08:01,048
因此，将此位置的副本添加到总和 

117
00:08:01,048 --> 00:08:04,300
中与我们移动它具有相同的效果。

118
00:08:05,160 --> 00:08:10,700
同样，这种效果是底部的总 结果阐明了错误的位置。

119
00:08:13,039 --> 00:08:16,992
为了说明这是多么优雅，让我展示我之前引用的一行 

120
00:08:16,992 --> 00:08:21,440
P ython 代码，它将捕获接收器端的几乎所有逻辑。

121
00:08:22,080 --> 00:08:25,953
我们将首先创建一个由 16 个 1 和 0 组成的随 

122
00:08:25,953 --> 00:08:29,683
机数组来模拟数据块，我将给它命名位，但当然，在实践 

123
00:08:29,683 --> 00:08:33,413
中，这将是我们从发送方接收的内容，而不是如果是随机 

124
00:08:33,413 --> 00:08:37,000
的，它将携带 11 个数据位和 5 个奇偶校验位。

125
00:08:37,000 --> 00:08:42,172
如果我调用函数 enumerateBits，它的作用是将每 

126
00:08:42,172 --> 00:08:47,000
个位与相应的索引配对在一起，在本例中为从 0 到 15。

127
00:08:48,180 --> 00:08:52,669
因此，如果我们创建一个列表，循环遍历所有这些对，看起来像 

128
00:08:52,669 --> 00:08:57,159
i 的对，然后我们只取出 i 值，只取出索引，好吧，这并 

129
00:08:57,159 --> 00:09:01,340
不是那么令人兴奋，我们只是取回那些索引 0 到 15。

130
00:09:01,680 --> 00:09:07,373
但是，如果我们添加条件以仅执行此 if 位，即如果该位 

131
00:09:07,373 --> 00:09:12,660
是 1 而不是 0，那么它只会提取相应位打开的位置。

132
00:09:13,380 --> 00:09:20,360
在本例中，这些位置看起来是 0、4、6、9 等。

133
00:09:20,720 --> 00:09:24,143
我们想要的是将所有这些位置（打开的位的位 

134
00:09:24,143 --> 00:09:27,240
置）收集在一起，然后将它们异或在一起。

135
00:09:29,180 --> 00:09:31,200
为了在 Python 中执行此操

136
00:09:31,200 --> 00:09:33,220
作，让我首先导入几个有用的函数。

137
00:09:33,900 --> 00:09:36,235
这样我们就可以在这个列表上调用red

138
00:09:36,235 --> 00:09:38,700
uce()，并使用XOR函数来减少它。

139
00:09:39,100 --> 00:09:42,680
这基本上会遍历列表，并一路进行异或运算。

140
00:09:44,800 --> 00:09:47,186
如果您愿意，您可以显式写出该 XO 

141
00:09:47,186 --> 00:09:49,440
R 函数，而无需从任何地方导入它。

142
00:09:51,940 --> 00:09:56,709
所以目前看来，如果我们对 16 位随机块执行此 

143
00:09:56,709 --> 00:10:01,280
操作，它会返回 9，其二进制表示为 1001。

144
00:10:01,980 --> 00:10:06,639
我们不会在这里这样做，但您可以编写一个函数，其中发送方 

145
00:10:06,639 --> 00:10:11,133
使用该二进制表示形式根据需要设置四个奇偶校验位，最终 

146
00:10:11,133 --> 00:10:15,460
使该块达到在完整位列表上运行这行代码的状态一个 0。

147
00:10:16,080 --> 00:10:20,100
这将被认为是一个准备充分的区块。

148
00:10:20,100 --> 00:10:25,248
很酷的是，如果我们切换此列表中的任何一位，模拟噪声引起的 

149
00:10:25,248 --> 00:10:30,220
随机错误，那么如果您运行同一行代码，它就会打印出该错误。

150
00:10:30,960 --> 00:10:31,520
这不是很整洁吗？

151
00:10:31,820 --> 00:10:36,542
你可以突然得到这个块，在上面运行这一行，它会 

152
00:10:36,542 --> 00:10:41,060
自动吐出错误的位置，如果没有错误则吐出 0。

153
00:10:42,500 --> 00:10:44,840
16号没有什么特别的。

154
00:10:44,840 --> 00:10:49,860
如果您有一个 256 位的列表，那么同一行代码也可以工作。

155
00:10:51,880 --> 00:10:56,005
不用说，这里需要编写更多代码，例如进行元奇偶校验 

156
00:10:56,005 --> 00:10:59,964
来检测 2 位错误，但我们的想法是，我们方案中 

157
00:10:59,964 --> 00:11:03,760
的几乎所有核心逻辑都归结为单个 XOR 减少。

158
00:11:06,120 --> 00:11:10,273
现在，根据您对二进制、异或和软件的熟悉程度，您可能 

159
00:11:10,273 --> 00:11:14,426
会发现这种观点有点令人困惑，或者更加优雅和简单，以 

160
00:11:14,426 --> 00:11:18,420
至于您想知道为什么我们不从一开始就开始使用它-去。

161
00:11:19,140 --> 00:11:23,034
宽松地说，当非常直接地在硬件中实现汉明码时，更 

162
00:11:23,034 --> 00:11:26,929
容易考虑多重奇偶校验的观点，而当在软件中从更高 

163
00:11:26,929 --> 00:11:30,500
的层次上实现汉明码时，最容易考虑异或的观点。

164
00:11:31,360 --> 00:11:36,128
第一个实际上最容易手动完成，我认为它可以更 

165
00:11:36,128 --> 00:11:40,896
好地灌输所有这一切背后的核心直觉，即定位单 

166
00:11:40,896 --> 00:11:45,665
个错误所需的信息与块大小的日志相关，或者换 

167
00:11:45,665 --> 00:11:50,000
句话说，随着块大小加倍，它一次增长一位。

168
00:11:51,020 --> 00:11:56,060
这里的相关事实是，该信息直 接对应于我们需要多少冗余。

169
00:11:56,660 --> 00:12:00,079
这确实与大多数人在第一次考虑使消息 

170
00:12:00,079 --> 00:12:03,500
能够抵御错误时的下意识反应相悖，通 

171
00:12:03,500 --> 00:12:06,540
常复制整个消息是首先想到的本能。

172
00:12:07,500 --> 00:12:10,829
然后，顺便说一句，有时您会看到汉明码的另 

173
00:12:10,829 --> 00:12:14,000
一种呈现方式，即您将消息乘以一个大矩阵。

174
00:12:14,670 --> 00:12:18,947
这很好，因为它将它与更广泛的线性代码家族联系起来， 

175
00:12:18,947 --> 00:12:23,060
但我认为这几乎没有给出它来自何处或如何扩展的直觉。

176
00:12:25,200 --> 00:12:28,260
说到扩展，您可能会注意到，当我们增加 

177
00:12:28,260 --> 00:12:31,160
块大小时，该方案的效率只会变得更好。

178
00:12:35,000 --> 00:12:38,908
例如，我们看到，对于 256 位，您仅使用该空间 

179
00:12:38,908 --> 00:12:42,660
的 3% 进行冗余，并且从那里开始变得越来越好。

180
00:12:43,300 --> 00:12:47,340
随着奇偶校验位的数量逐个增加，块大小不断加倍。

181
00:12:49,000 --> 00:12:52,463
如果你把它发挥到极致，你可能会拥有一个具有 

182
00:12:52,463 --> 00:12:56,241
1 00 万位的块，实际上你会用奇偶校验来回答 

183
00:12:56,241 --> 00:13:00,020
2 0 个问题，而它只使用 21 个奇偶校验位。

184
00:13:00,740 --> 00:13:03,995
如果你退后一步考虑查看一百万位并 

185
00:13:03,995 --> 00:13:07,060
找到一个错误，那真的感觉很疯狂。

186
00:13:08,199 --> 00:13:13,019
当然，问题在于，对于较大的块，看到超过一或两个位错误 

187
00:13:13,019 --> 00:13:17,660
的概率会上升，而汉明码无法处理超出此范围的任何内容。

188
00:13:18,320 --> 00:13:21,395
因此，在实践中，您需要找到正确的大 

189
00:13:21,395 --> 00:13:24,300
小，以便太多位翻转的概率不会太高。

190
00:13:26,600 --> 00:13:31,451
此外，在实践中，错误往往会突然出现，这会完全破坏单个块 

191
00:13:31,451 --> 00:13:36,302
，因此帮助将错误突发分散到许多不同块的一种常见策略是在 

192
00:13:36,302 --> 00:13:40,980
这些块被破坏之前将这些块交错，就像这样。 发出或存储。

193
00:13:45,580 --> 00:13:50,105
话又说回来，其中很多内容在更现代的代码中完全没有意义 

194
00:13:50,105 --> 00:13:54,630
，比如更常用的里德-所罗门算法，它可以很好地处理突发 

195
00:13:54,630 --> 00:13:58,820
错误，并且可以对其进行调整以适应每个块的更多错误。

196
00:13:59,360 --> 00:14:01,340
但这是另一个话题了。

197
00:14:02,500 --> 00:14:06,306
汉明在他的《科学与工程的艺术》一书中非常坦 

198
00:14:06,306 --> 00:14:09,940
诚地讲述了他发现这段代码的过程是多么曲折。

199
00:14:10,620 --> 00:14:14,362
他首先尝试了各种不同的方案，包括将这些位组织 

200
00:14:14,362 --> 00:14:17,780
成更高维晶格的部分以及诸如此类的奇怪事物。

201
00:14:18,300 --> 00:14:21,727
汉明在进行了一系列其他分析后退后一步，问 

202
00:14:21,727 --> 00:14:24,991
道：“好吧，我能做到的最有效的方法是什 

203
00:14:24,991 --> 00:14:29,887
么”时，他才想到了通过奇偶校验来共谋以 阐明错误位置的想法。

204
00:14:29,887 --> 00:14:31,520
 可能是关于这个的？

205
00:14:32,620 --> 00:14:36,998
他还坦诚地表示，奇偶校验已经在他的脑海中变得多么重要， 

206
00:14:36,998 --> 00:14:41,220
而在 20 世纪 40 年代，奇偶校验比今天要少得多。

207
00:14:41,920 --> 00:14:45,235
在这本书中，他大约有六次引用了路易斯· 

208
00:14:45,235 --> 00:14:48,220
巴斯德的名言：幸运眷顾有准备的头脑。

209
00:14:49,320 --> 00:14:54,300
事后看来，聪明的想法往往看似简单，这使得它们很容易被低估。

210
00:14:54,960 --> 00:14:58,288
现在我真诚地希望汉明码，或者至少是这种代 

211
00:14:58,288 --> 00:15:01,300
码的可能性，对你来说几乎是显而易见的。

212
00:15:01,660 --> 00:15:04,391
但你不应该自欺欺人地认为它们实际上 

213
00:15:04,391 --> 00:15:06,820
是显而易见的，因为它们绝对不是。

214
00:15:07,880 --> 00:15:11,625
聪明的想法看起来看似简单，部分原因是我们 

215
00:15:11,625 --> 00:15:15,370
只看到最终结果，清理混乱的部分，从不提及 

216
00:15:15,370 --> 00:15:20,720
所有错误的转折，低估了问题开始时可探索的 可能性空间有多大。

217
00:15:20,720 --> 00:15:22,860
 解决过程，所有这一切。

218
00:15:23,820 --> 00:15:24,900
但总的来说确实如此。

219
00:15:24,900 --> 00:15:27,547
我认为对于一些特殊的发明，我们低 

220
00:15:27,547 --> 00:15:30,040
估它们还有第二个更深层次的原因。

221
00:15:30,840 --> 00:15:33,656
直到 1948 年，随着克劳德·香农（Claude 

222
00:15:33,656 --> 00:15:36,256
Shannon）关于 信息论的开创性论文的出现，

223
00:15:36,256 --> 00:15:38,640
用比特来思考信息才真正融合成一个完整的理论。

224
00:15:39,280 --> 00:15:42,540
这基本上与汉明开发他的算法的时间同时发生。

225
00:15:43,300 --> 00:15:46,563
这篇基础论文在某种意义上表明，无 

226
00:15:46,563 --> 00:15:49,828
论位翻转的概率有多高，有效的纠错 

227
00:15:49,828 --> 00:15:52,900
总是可能的，至少在理论上是这样。

228
00:15:53,700 --> 00:15:57,503
顺便说一句，香农和汉明在贝尔实验室共用一间办公室， 

229
00:15:57,503 --> 00:16:01,160
尽管他们从事的工作截然不同，这在这里似乎并非巧合。

230
00:16:02,380 --> 00:16:07,567
快进几十年，如今，我们中的许多人都沉浸在对比特和 

231
00:16:07,567 --> 00:16:12,340
信息的思考中，很容易忽视这种思维方式的独特性。

232
00:16:13,100 --> 00:16:17,777
具有讽刺意味的是，那些最深刻地塑造下一代思维方 

233
00:16:17,777 --> 00:16:22,260
式的想法最终会在下一代人看来比实际情况更简单。

