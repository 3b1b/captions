1
00:00:00,000 --> 00:00:03,120
இங்குள்ள அனைவரும் பாகம் 1ல் இருந்து வந்தவர்கள் என்று எண்ணுகிறேன்.

2
00:00:03,120 --> 00:00:06,880
நாங்கள் ஹேமிங் குறியீடுகளைப் பற்றி பேசிக் கொண்டிருந்தோம்,

3
00:00:06,880 --> 00:00:11,742
பெரும்பாலான பிட்கள் அர்த்தமுள்ள செய்தியைக் கொண்டு செல்லும் தரவுத் தொகுதியை

4
00:00:11,742 --> 00:00:17,122
உருவாக்கும் ஒரு வழி பிட் அல்லது ஒரு பணிநீக்கம் பிட், இந்த பிளாக்கில் உள்ள எதையும்,

5
00:00:17,122 --> 00:00:21,920
ஒரு பெறுநரால் பிழை இருப்பதை அடையாளம் காண முடியும், அதை எவ்வாறு சரிசெய்வது.

6
00:00:21,920 --> 00:00:25,802
அங்கு வழங்கப்பட்ட அடிப்படை யோசனையானது, பிழைக்கான உங்கள் வழியை பைனரி

7
00:00:25,802 --> 00:00:29,800
தேடுவதற்கு பல சமநிலை சரிபார்ப்புகளை எவ்வாறு பயன்படுத்துவது என்பதுதான்.

8
00:00:29,800 --> 00:00:32,610
அந்த வீடியோவில், ஹேமிங் குறியீடுகளை முடிந்தவரை மீண்டும்

9
00:00:32,610 --> 00:00:35,420
கண்டுபிடிக்கக்கூடியதாக உணர வைப்பதே குறிக்கோளாக இருந்தது.

10
00:00:35,420 --> 00:00:38,392
ஆனால் மென்பொருளில் அல்லது வன்பொருளில் இதை நடைமுறைப்படுத்துவது பற்றி

11
00:00:38,392 --> 00:00:41,103
நீங்கள் சிந்திக்கத் தொடங்கும்போது, இந்த குறியீடுகள் உண்மையில்

12
00:00:41,103 --> 00:00:44,120
எவ்வளவு நேர்த்தியானவை என்பதை அந்த ஃப்ரேமிங் உண்மையில் குறைத்துவிடும்.

13
00:00:44,120 --> 00:00:47,569
சாத்தியமான அனைத்து பிழை இருப்பிடங்களையும் கண்காணிக்கும் ஒரு வழிமுறையை நீங்கள்

14
00:00:47,569 --> 00:00:50,975
எழுத வேண்டும் என்று நீங்கள் நினைக்கலாம் மற்றும் ஒவ்வொரு சரிபார்ப்பிலும் அந்த

15
00:00:50,975 --> 00:00:54,160
குழுவை பாதியாக குறைக்கலாம், ஆனால் அது உண்மையில் வழி, அதை விட எளிமையானது.

16
00:00:54,160 --> 00:00:58,071
கடந்த வீடியோவில் நாங்கள் செய்த நான்கு சமநிலை சரிபார்ப்புகளுக்கான பதில்களை,

17
00:00:58,071 --> 00:01:01,774
ஆம் மற்றும் இல்லை என்பதற்குப் பதிலாக 1கள் மற்றும் 0கள் எனப் படித்தால்,

18
00:01:01,774 --> 00:01:04,800
அது பைனரியில் உள்ள பிழையின் நிலையை உண்மையில் விவரிக்கிறது.

19
00:01:04,800 --> 00:01:09,411
எடுத்துக்காட்டாக, பைனரியில் உள்ள எண் 7 0111 போல் தெரிகிறது,

20
00:01:09,411 --> 00:01:12,640
இது 4 கூட்டல் 2 கூட்டல் 1 என்று கூறுகிறது.

21
00:01:12,640 --> 00:01:16,315
மற்றும் நிலை 7 எங்கு அமர்ந்திருக்கிறது என்பதைக் கவனியுங்கள்,

22
00:01:16,315 --> 00:01:21,075
இது எங்கள் சமத்துவக் குழுக்களில் முதலாவது மற்றும் இரண்டாவது மற்றும் மூன்றாவது,

23
00:01:21,075 --> 00:01:22,280
ஆனால் கடைசியாக அல்ல.

24
00:01:22,280 --> 00:01:25,309
எனவே அந்த நான்கு காசோலைகளின் முடிவுகளை கீழிருந்து

25
00:01:25,309 --> 00:01:28,520
மேல் வரை படிப்பது பிழையின் நிலையை வெளிப்படுத்துகிறது.

26
00:01:28,520 --> 00:01:32,002
எடுத்துக்காட்டு 7 இல் சிறப்பு எதுவும் இல்லை, இது பொதுவாக வேலை செய்கிறது,

27
00:01:32,002 --> 00:01:34,959
மேலும் இது வன்பொருளில் முழு திட்டத்தையும் செயல்படுத்துவதற்கான

28
00:01:34,959 --> 00:01:37,440
தர்க்கத்தை அதிர்ச்சியூட்டும் வகையில் எளிதாக்குகிறது.

29
00:01:37,440 --> 00:01:40,934
இப்போது இந்த மேஜிக் ஏன் நடக்கிறது என்பதைப் பார்க்க விரும்பினால்,

30
00:01:40,934 --> 00:01:44,698
இந்த 16 இன்டெக்ஸ் லேபிள்களை எங்கள் நிலைகளுக்கு எடுத்துக் கொள்ளுங்கள்,

31
00:01:44,698 --> 00:01:47,440
ஆனால் அவற்றை அடிப்படை 10 இல் எழுதுவதற்குப் பதிலாக,

32
00:01:47,440 --> 00:01:50,720
0000 முதல் 1111 வரை இயங்கும் பைனரியில் அனைத்தையும் எழுதுவோம்.

33
00:01:50,720 --> 00:01:54,180
இந்த பைனரி லேபிள்களை அவற்றின் பெட்டிகளில் மீண்டும் வைக்கும்போது,

34
00:01:54,180 --> 00:01:58,440
அவை உண்மையில் அனுப்பப்படும் தரவுகளிலிருந்து வேறுபட்டவை என்பதை வலியுறுத்துகிறேன்.

35
00:01:58,440 --> 00:02:01,217
நான்கு சமத்துவக் குழுக்கள் எங்கிருந்து வந்தன என்பதைப் புரிந்துகொள்ள

36
00:02:01,217 --> 00:02:04,200
உங்களுக்கும் எனக்கும் உதவும் ஒரு கருத்தியல் லேபிளைத் தவிர வேறொன்றுமில்லை.

37
00:02:04,200 --> 00:02:08,040
நாம் பார்க்கும் அனைத்தும் பைனரியில் விவரிக்கப்படுவதன் நேர்த்தியானது,

38
00:02:08,040 --> 00:02:12,269
நாம் பார்க்கும் அனைத்தும் பைனரியில் விவரிக்கப்பட வேண்டும் என்ற குழப்பத்தால்

39
00:02:12,269 --> 00:02:13,160
குறைக்கப்படலாம்.

40
00:02:13,160 --> 00:02:15,040
இருந்தாலும் அது மதிப்புக்குரியது.

41
00:02:15,040 --> 00:02:19,916
இந்த லேபிள்கள் அனைத்தின் கடைசி பிட்டில் மட்டும் உங்கள் கவனத்தை செலுத்தவும்,

42
00:02:19,916 --> 00:02:24,280
பின்னர் அந்த இறுதி பிட் 1 ஆக இருக்கும் நிலைகளை முன்னிலைப்படுத்தவும்.

43
00:02:24,280 --> 00:02:28,626
நாங்கள் பெறுவது எங்களின் நான்கு சமத்துவக் குழுக்களில் முதன்மையானது,

44
00:02:28,626 --> 00:02:32,589
அதாவது அந்த முதல் காசோலையைக் கேட்பது போல் நீங்கள் விளக்கலாம்,

45
00:02:32,589 --> 00:02:36,680
ஏய், பிழை இருந்தால், அந்த பிழையின் நிலையில் இறுதி பிட் 1 உள்ளதா?

46
00:02:36,680 --> 00:02:40,115
இதேபோல், நீங்கள் இரண்டாவது முதல் கடைசி பிட் வரை கவனம் செலுத்தி,

47
00:02:40,115 --> 00:02:43,443
அது 1 ஆக இருக்கும் அனைத்து நிலைகளையும் முன்னிலைப்படுத்தினால்,

48
00:02:43,443 --> 00:02:47,040
எங்கள் திட்டத்தில் இருந்து இரண்டாவது பாரிட்டி குழுவைப் பெறுவீர்கள்.

49
00:02:47,040 --> 00:02:51,212
வேறு வார்த்தைகளில் கூறுவதானால், அந்த இரண்டாவது காசோலை கேட்கிறது, ஏய்,

50
00:02:51,212 --> 00:02:56,160
மீண்டும் என்னிடம், பிழை இருந்தால், அந்த நிலையின் இரண்டாவது முதல் கடைசி பிட் 1 தானா?

51
00:02:56,160 --> 00:02:57,160
மற்றும் பல.

52
00:02:57,160 --> 00:03:01,480
மூன்றாவது பாரிட்டி காசோலையானது, மூன்றாவது முதல் கடைசி பிட் வரை

53
00:03:01,480 --> 00:03:05,800
இயக்கப்பட்ட ஒவ்வொரு நிலையையும் உள்ளடக்கியது, மேலும் கடைசியானது

54
00:03:05,800 --> 00:03:10,120
கடைசி எட்டு நிலைகளை உள்ளடக்கியது, அதிகபட்ச ஆர்டர் பிட் 1 ஆகும்.

55
00:03:10,120 --> 00:03:16,287
நாம் முன்பு செய்த அனைத்தும் இந்த நான்கு கேள்விகளுக்குப் பதிலளிப்பதைப் போன்றது,

56
00:03:16,287 --> 00:03:19,800
இது பைனரியில் ஒரு நிலையை உச்சரிப்பது போன்றது.

57
00:03:19,800 --> 00:03:22,080
இது இரண்டு விஷயங்களை தெளிவாக்குகிறது என்று நம்புகிறேன்.

58
00:03:22,080 --> 00:03:24,771
முதலாவதாக, இரண்டின் பெரிய சக்திகளைக் கொண்ட தொகுதி

59
00:03:24,771 --> 00:03:27,140
அளவுகளை முறையாகப் பொதுமைப்படுத்துவது எப்படி.

60
00:03:27,140 --> 00:03:31,111
64 புள்ளிகளை விவரிக்க ஆறு பிட்கள் போல, ஒவ்வொரு நிலையையும் விவரிக்க

61
00:03:31,111 --> 00:03:35,201
அதிக பிட்கள் தேவைப்பட்டால், அந்த பிட்கள் ஒவ்வொன்றும் நாம் சரிபார்க்க

62
00:03:35,201 --> 00:03:38,640
வேண்டிய சமநிலைக் குழுக்களில் ஒன்றை உங்களுக்கு வழங்குகிறது.

63
00:03:38,640 --> 00:03:41,420
மேட் பார்க்கருடன் நான் செய்த சதுரங்கப் புதிரைப் பார்த்த உங்களில்,

64
00:03:41,420 --> 00:03:43,400
இவை அனைத்தும் மிகவும் பரிச்சயமானதாக இருக்கலாம்.

65
00:03:43,400 --> 00:03:46,827
இது அதே முக்கிய தர்க்கம், ஆனால் வேறு ஒரு சிக்கலைத் தீர்க்கிறது,

66
00:03:46,827 --> 00:03:49,880
மேலும் 64-சதுர சதுரங்கப் பலகைக்கு இது பயன்படுத்தப்பட்டது.

67
00:03:49,880 --> 00:03:53,105
இது தெளிவுபடுத்தும் இரண்டாவது விஷயம் என்னவென்றால், 1, 2, 4,

68
00:03:53,105 --> 00:03:57,728
மற்றும் 8 ஆகிய இரண்டு சக்திகளின் நிலைகளில் நமது சமநிலை பிட்கள் ஏன் அமர்ந்திருக்கின்றன

69
00:03:57,728 --> 00:03:58,320
என்பதுதான்.

70
00:03:58,320 --> 00:04:03,640
பைனரி பிரதிநிதித்துவம் ஒரு பிட் மட்டுமே இயக்கப்பட்டிருக்கும் நிலைகள் இவை.

71
00:04:03,640 --> 00:04:07,918
இதன் பொருள் என்னவென்றால், அந்த ஒவ்வொரு பாரிட்டி பிட்களும்

72
00:04:07,918 --> 00:04:12,640
ஒன்றுக்குள் அமர்ந்து நான்கு சமத்துவக் குழுக்களில் ஒன்று மட்டுமே.

73
00:04:12,640 --> 00:04:17,259
நீங்கள் இதைப் பெரிய எடுத்துக்காட்டுகளிலும் பார்க்கலாம்,

74
00:04:17,259 --> 00:04:24,187
நீங்கள் எவ்வளவு பெரியதாக இருந்தாலும், ஒவ்வொரு பாரிட்டி பிட்டும் வசதியாக குழுக்களில்

75
00:04:24,187 --> 00:04:25,920
ஒன்றை மட்டுமே தொடும்.

76
00:04:25,920 --> 00:04:29,529
நாம் அதிக நேரத்தைச் செலுத்திய இந்த சமநிலைச் சரிபார்ப்புகள் பைனரியில் உள்ள

77
00:04:29,529 --> 00:04:33,237
பிழையின் நிலையை உச்சரிப்பதற்கான ஒரு புத்திசாலித்தனமான வழியைத் தவிர வேறில்லை

78
00:04:33,237 --> 00:04:36,895
என்பதை நீங்கள் புரிந்துகொண்டவுடன், ஹேமிங்கைப் பற்றி சிந்திக்க வேறு வழியில்

79
00:04:36,895 --> 00:04:41,090
நாம் இணைப்பை உருவாக்கலாம். குறியீடுகள், இது மிகவும் எளிமையானது மற்றும் நேர்த்தியானது,

80
00:04:41,090 --> 00:04:43,920
மேலும் இது ஒரு ஒற்றை வரி குறியீட்டைக் கொண்டு எழுதப்படலாம்.

81
00:04:43,920 --> 00:04:46,200
இது XOR செயல்பாட்டை அடிப்படையாகக் கொண்டது.

82
00:04:46,200 --> 00:04:50,960
XOR, உங்களில் தெரியாதவர்களுக்கு, பிரத்தியேகமான அல்லது.

83
00:04:50,960 --> 00:04:55,060
நீங்கள் இரண்டு பிட்களின் XOR ஐ எடுக்கும்போது, அந்த பிட்களில் ஏதேனும் ஒன்று

84
00:04:55,060 --> 00:04:59,926
இயக்கப்பட்டிருந்தால் அது 1ஐத் தரும், ஆனால் இரண்டும் ஆன் அல்லது ஆஃப் செய்யப்பட்டிருந்தால்

85
00:04:59,926 --> 00:05:00,200
அல்ல.

86
00:05:00,200 --> 00:05:03,760
வித்தியாசமாக சொற்றொடர், இந்த இரண்டு பிட்களின் சமநிலை.

87
00:05:03,760 --> 00:05:07,840
ஒரு கணித நபராக, நான் அதை கூட்டல் மோட் 2 என நினைக்க விரும்புகிறேன்.

88
00:05:07,840 --> 00:05:11,405
நாங்கள் பொதுவாக இரண்டு வெவ்வேறு பிட் சரங்களின் XOR பற்றி பேசுகிறோம்,

89
00:05:11,405 --> 00:05:14,040
இது அடிப்படையில் இந்த கூறுகளை கூறு மூலம் செய்கிறது.

90
00:05:14,040 --> 00:05:16,280
இது கூட்டல் போன்றது, ஆனால் நீங்கள் எடுத்துச் செல்லவே இல்லை.

91
00:05:16,280 --> 00:05:19,560
மீண்டும், கணித ரீதியாக அதிக விருப்பமுள்ளவர்கள் இதை இரண்டு

92
00:05:19,560 --> 00:05:23,520
திசையன்களைச் சேர்ப்பது மற்றும் மோட் 2 ஐக் குறைப்பது என்று நினைக்கலாம்.

93
00:05:23,520 --> 00:05:28,602
நீங்கள் இப்போது சில பைத்தானைத் திறந்து, இரண்டு முழு எண்களுக்கு இடையில் கேரட்

94
00:05:28,602 --> 00:05:33,354
செயல்பாட்டைப் பயன்படுத்தினால், இது பேட்டைக்குக் கீழே அந்த எண்களின் பிட்

95
00:05:33,354 --> 00:05:35,400
பிரதிநிதித்துவங்களைச் செய்யும்.

96
00:05:35,400 --> 00:05:40,427
உங்களுக்கும் எனக்கும் முக்கியமான விஷயம் என்னவென்றால்,

97
00:05:40,427 --> 00:05:45,082
பல வேறுபட்ட பிட் சரங்களின் XORஐ எடுத்துக்கொள்வது,

98
00:05:45,082 --> 00:05:51,320
தனித்தனி குழுக்களின் கேலிக்கூத்துகளை கணக்கிடுவதற்கான ஒரு வழியாகும்.

99
00:05:51,320 --> 00:05:54,341
எங்கள் ஹேமிங் குறியீடு அல்காரிதத்தில் இருந்து பல சமநிலை சரிபார்ப்புகளைப்

100
00:05:54,341 --> 00:05:57,114
பற்றி சிந்திக்க இது எங்களுக்கு மிகவும் எளிமையான வழியை வழங்குகிறது,

101
00:05:57,114 --> 00:05:59,680
ஏனெனில் அனைத்தும் ஒன்றாக ஒரே செயல்பாட்டில் தொகுக்கப்படுகின்றன.

102
00:05:59,680 --> 00:06:02,800
முதல் பார்வையில் இது மிகவும் வித்தியாசமாகத் தெரிந்தாலும்.

103
00:06:02,800 --> 00:06:07,926
குறிப்பாக பைனரியில் 16 நிலைகளை எழுதவும், முன்பு இருந்தது போல்,

104
00:06:07,926 --> 00:06:13,541
இப்போது செய்தி பிட் 1 க்கு இயக்கப்பட்ட நிலைகளை முன்னிலைப்படுத்தவும்,

105
00:06:13,541 --> 00:06:19,400
பின்னர் இந்த நிலைகளை ஒரு பெரிய நெடுவரிசையில் சேகரித்து XOR ஐ எடுக்கவும்.

106
00:06:19,400 --> 00:06:23,897
இதன் விளைவாக கீழே அமர்ந்திருக்கும் 4 பிட்கள், நாங்கள் அறிந்த மற்றும் விரும்பி

107
00:06:23,897 --> 00:06:28,452
வைத்திருக்கும் 4 சமநிலை சரிபார்ப்புகளைப் போலவே இருக்கும் என்று நீங்கள் ஒருவேளை

108
00:06:28,452 --> 00:06:32,720
யூகிக்கலாம், ஆனால் ஏன் என்று சரியாகச் சிந்திக்க சிறிது நேரம் ஒதுக்குங்கள்.

109
00:06:32,720 --> 00:06:35,925
இந்த கடைசி நெடுவரிசை, எடுத்துக்காட்டாக, கடைசி பிட் 1 ஆக உள்ள அனைத்து

110
00:06:35,925 --> 00:06:39,084
நிலைகளையும் கணக்கிடுகிறது, ஆனால் நாங்கள் ஏற்கனவே ஹைலைட் செய்யப்பட்ட

111
00:06:39,084 --> 00:06:42,057
நிலைகளுக்கு மட்டுமே வரம்பிடப்பட்டுள்ளோம், எனவே இது முதல் சமநிலை

112
00:06:42,057 --> 00:06:45,960
குழுவிலிருந்து எத்தனை ஹைலைட் செய்யப்பட்ட நிலைகள் வந்தன என்பதை திறம்பட கணக்கிடுகிறது.

113
00:06:45,960 --> 00:06:48,520
அதில் ஏதாவது பொருளிருக்கிறதா? அதில் அர்த்தமிருக்கிறதா?

114
00:06:48,520 --> 00:06:53,380
அதேபோல, அடுத்த நெடுவரிசை, இரண்டாவது சமத்துவக் குழுவில் எத்தனை நிலைகள் உள்ளன,

115
00:06:53,380 --> 00:06:56,347
இரண்டாவது முதல் கடைசி பிட் வரையிலான நிலைகள் 1,

116
00:06:56,347 --> 00:07:00,640
மற்றும் அவையும் தனிப்படுத்தப்பட்டவை மற்றும் பலவற்றைக் கணக்கிடுகிறது.

117
00:07:00,640 --> 00:07:04,692
இது உண்மையில் நாம் செய்துகொண்டிருக்கும் அதே விஷயத்தைப்

118
00:07:04,692 --> 00:07:07,640
பற்றிய கண்ணோட்டத்தில் ஒரு சிறிய மாற்றம்.

119
00:07:07,640 --> 00:07:10,000
அது இங்கிருந்து எங்கு செல்கிறது என்பது உங்களுக்குத் தெரியும்.

120
00:07:10,000 --> 00:07:14,950
தொகை 0000 ஆக இருக்கும் என்பதை உறுதிப்படுத்த, சில சிறப்பு

121
00:07:14,950 --> 00:07:19,640
சமநிலை பிட்களை மாற்றுவதற்கு அனுப்புநரின் பொறுப்பாகும்.

122
00:07:19,640 --> 00:07:24,208
இப்போது நாம் இதைப் பெற்றவுடன், கீழே உள்ள இந்த நான்கு பிட்கள் ஏன் பிழையின் நிலையை

123
00:07:24,208 --> 00:07:28,720
நேரடியாக உச்சரிக்கின்றன என்பதைப் பற்றி சிந்திக்க இது ஒரு நல்ல வழியை வழங்குகிறது.

124
00:07:28,720 --> 00:07:32,720
இந்த பிளாக்கில் சில பிட்கள் 0 இலிருந்து 1 ஆக மாறுகிறது என்று வைத்துக்கொள்வோம்.

125
00:07:32,720 --> 00:07:38,229
இதன் பொருள் என்னவென்றால், அந்த பிட்டின் நிலை இப்போது மொத்த XOR இல் சேர்க்கப்படும்,

126
00:07:38,229 --> 00:07:43,870
இது கூட்டுத்தொகையை 0 என்பதிலிருந்து புதிதாக சேர்க்கப்பட்ட இந்த மதிப்பாக மாற்றுகிறது,

127
00:07:43,870 --> 00:07:44,800
பிழையின் நிலை.

128
00:07:44,800 --> 00:07:49,800
சற்று குறைவாக வெளிப்படையாக, 1 ஐ 0 ஆக மாற்றும் பிழை இருந்தால் அதுவே உண்மை.

129
00:07:49,800 --> 00:07:54,515
நீங்கள் பார்க்கிறீர்கள், நீங்கள் ஒரு பிட் சரத்தை இரண்டு முறை ஒன்றாகச் சேர்த்தால்,

130
00:07:54,515 --> 00:07:59,000
அது இல்லை என்பதற்கு சமம், அடிப்படையில் இந்த உலகில் 1 கூட்டல் 1 என்பது 0 ஆகும்.

131
00:07:59,000 --> 00:08:02,296
எனவே இந்த நிலையின் நகலை மொத்தத் தொகையில் சேர்ப்பது

132
00:08:02,296 --> 00:08:05,400
நாம் அதை நகர்த்தும்போது அதே விளைவை ஏற்படுத்தும்.

133
00:08:05,400 --> 00:08:13,480
அந்த விளைவு, மீண்டும், இங்கே கீழே உள்ள மொத்த முடிவு பிழையின் நிலையை உச்சரிக்கிறது.

134
00:08:13,480 --> 00:08:15,697
இது எவ்வளவு நேர்த்தியானது என்பதை விளக்குவதற்கு,

135
00:08:15,697 --> 00:08:18,931
நான் முன்பு குறிப்பிட்ட பைதான் குறியீட்டின் ஒரு வரியைக் காட்டுகிறேன்,

136
00:08:18,931 --> 00:08:22,120
இது பெறுநரின் முடிவில் கிட்டத்தட்ட எல்லா தர்க்கங்களையும் கைப்பற்றும்.

137
00:08:22,120 --> 00:08:26,540
தரவுத் தொகுதியை உருவகப்படுத்த 16 1s மற்றும் 0s என்ற சீரற்ற வரிசையை உருவாக்குவதன்

138
00:08:26,540 --> 00:08:29,596
மூலம் தொடங்குவோம், நான் அதற்கு பெயர் பிட்களை தருகிறேன்,

139
00:08:29,596 --> 00:08:33,143
ஆனால் நடைமுறையில் இது ஒரு அனுப்புநரிடமிருந்து நாம் பெறும் ஒன்று,

140
00:08:33,143 --> 00:08:37,072
அதற்கு பதிலாக சீரற்றதாக இருந்தால், அது 11 டேட்டா பிட்களையும் 5 பேரிட்டி

141
00:08:37,072 --> 00:08:38,600
பிட்களையும் கொண்டு செல்லும்.

142
00:08:38,600 --> 00:08:43,481
நான் செயல்பாடு enumerateBits என்று அழைத்தால், அது 0 முதல் 15 வரை இயங்கும் இந்த

143
00:08:43,481 --> 00:08:48,240
விஷயத்தில், அந்த பிட்கள் ஒவ்வொன்றையும் தொடர்புடைய குறியீட்டுடன் இணைப்பதாகும்.

144
00:08:48,240 --> 00:08:52,378
எனவே, இந்த ஜோடிகள் அனைத்தின் மீதும் சுழலும் ஒரு பட்டியலை உருவாக்கினால்,

145
00:08:52,378 --> 00:08:57,321
i போல தோற்றமளிக்கும் ஜோடிகள், பின்னர் i மதிப்பை, குறியீட்டை மட்டும் வெளியே இழுத்தால்,

146
00:08:57,321 --> 00:09:01,920
அது அவ்வளவு உற்சாகமாக இல்லை, அந்த குறியீடுகளை 0 முதல் 15 வரை திரும்பப் பெறுவோம்.

147
00:09:01,920 --> 00:09:06,657
ஆனால் பிட் என்றால் மட்டுமே இதைச் செய்ய வேண்டும் என்ற நிபந்தனையைச் சேர்த்தால்,

148
00:09:06,657 --> 00:09:10,484
அதாவது அந்த பிட் 1 மற்றும் 0 அல்ல என்றால், அது தொடர்புடைய பிட்

149
00:09:10,484 --> 00:09:13,400
இயக்கப்பட்டிருக்கும் நிலைகளை மட்டும் இழுக்கிறது.

150
00:09:13,400 --> 00:09:20,720
இந்த வழக்கில், அந்த நிலைகள் 0, 4, 6, 9, போன்றவை போல் தெரிகிறது.

151
00:09:20,720 --> 00:09:25,307
நாம் விரும்புவது, அந்த நிலைகள் அனைத்தையும் ஒன்றாகச் சேகரிக்க வேண்டும்,

152
00:09:25,307 --> 00:09:29,960
இயக்கப்பட்ட பிட்களின் நிலைகள், பின்னர் அவற்றை ஒன்றாக XOR செய்ய வேண்டும்.

153
00:09:29,960 --> 00:09:33,960
பைத்தானில் இதைச் செய்ய, முதலில் இரண்டு பயனுள்ள செயல்பாடுகளை இறக்குமதி செய்கிறேன்.

154
00:09:33,960 --> 00:09:36,731
அந்த வகையில் நாம் இந்த பட்டியலில் குறைக்க() என்று அழைக்கலாம்

155
00:09:36,731 --> 00:09:39,140
மற்றும் அதை குறைக்க XOR செயல்பாட்டைப் பயன்படுத்தலாம்.

156
00:09:39,140 --> 00:09:44,840
இது அடிப்படையில் பட்டியலில் அதன் வழியை உண்கிறது, வழியில் XOR களை எடுத்துக்கொள்கிறது.

157
00:09:44,840 --> 00:09:48,911
நீங்கள் விரும்பினால், XOR செயல்பாட்டை எங்கிருந்தும்

158
00:09:48,911 --> 00:09:52,200
இறக்குமதி செய்யாமல் வெளிப்படையாக எழுதலாம்.

159
00:09:52,200 --> 00:09:57,099
எனவே தற்போது 16 பிட்களின் சீரற்ற தொகுதியில் இதைச் செய்தால்,

160
00:09:57,099 --> 00:10:02,080
அது 9 ஐத் தருகிறது, இதில் பைனரி பிரதிநிதித்துவம் 1001 உள்ளது.

161
00:10:02,080 --> 00:10:06,334
நாங்கள் அதை இங்கே செய்ய மாட்டோம், ஆனால் அனுப்புநர் அந்த பைனரி பிரதிநிதித்துவத்தைப்

162
00:10:06,334 --> 00:10:10,126
பயன்படுத்தி நான்கு பேரிட்டி பிட்களை தேவைக்கேற்ப அமைக்கும் ஒரு செயல்பாட்டை

163
00:10:10,126 --> 00:10:13,919
நீங்கள் எழுதலாம், இறுதியில் இந்தத் தொகுதியை பிட்களின் முழுப் பட்டியலிலும்

164
00:10:13,919 --> 00:10:17,200
இந்த குறியீட்டு வரியை இயக்கும் நிலைக்கு கொண்டு செல்லலாம். ஒரு 0.

165
00:10:17,200 --> 00:10:20,200
இது நன்கு தயாரிக்கப்பட்ட தொகுதியாகக் கருதப்படும்.

166
00:10:20,200 --> 00:10:24,578
நல்ல விஷயம் என்னவென்றால், இந்த பட்டியலில் உள்ள பிட்களில் ஏதேனும் ஒன்றை நாம் மாற்றினால்,

167
00:10:24,578 --> 00:10:27,415
இரைச்சலில் இருந்து ஒரு சீரற்ற பிழையை உருவகப்படுத்தினால்,

168
00:10:27,415 --> 00:10:30,600
நீங்கள் இதே குறியீட்டை இயக்கினால், அது அந்த பிழையை அச்சிடுகிறது.

169
00:10:30,600 --> 00:10:31,920
அது சுத்தமாக இல்லையா?

170
00:10:31,920 --> 00:10:37,712
இந்தத் தொகுதியை நீங்கள் நீல நிறத்தில் இருந்து பெறலாம், இந்த ஒற்றை வரியை அதில் இயக்கலாம்,

171
00:10:37,712 --> 00:10:42,920
மேலும் அது பிழையின் நிலையை தானாகவே துப்பிவிடும், அல்லது எதுவும் இல்லை என்றால் 0.

172
00:10:42,920 --> 00:10:45,520
இங்கே அளவு 16 பற்றி சிறப்பு எதுவும் இல்லை.

173
00:10:45,520 --> 00:10:52,280
உங்களிடம் 256 பிட்களின் பட்டியல் இருந்தால் அதே வரி குறியீடு வேலை செய்யும்.

174
00:10:52,280 --> 00:10:56,810
2-பிட் பிழைகளைக் கண்டறிய மெட்டா பாரிட்டி செக் செய்வது போன்ற கூடுதல் குறியீடுகள்

175
00:10:56,810 --> 00:11:01,115
இங்கே எழுத வேண்டும் என்று சொல்லத் தேவையில்லை, ஆனால் எங்கள் திட்டத்தில் உள்ள

176
00:11:01,115 --> 00:11:05,080
அனைத்து முக்கிய தர்க்கங்களும் ஒரே XOR குறைப்புக்கு வரும் என்பது யோசனை.

177
00:11:05,080 --> 00:11:10,510
இப்போது, பைனரி மற்றும் XORகள் மற்றும் பொதுவாக மென்பொருளில் உள்ள உங்கள் வசதியைப் பொறுத்து,

178
00:11:10,510 --> 00:11:15,458
இந்த முன்னோக்கைக் கொஞ்சம் குழப்பமாகவோ அல்லது மிகவும் நேர்த்தியாகவும் எளிமையாகவும்

179
00:11:15,458 --> 00:11:19,320
நாம் ஏன் தொடங்கவில்லை என்று நீங்கள் ஆச்சரியப்படுகிறீர்கள். -போ.

180
00:11:19,320 --> 00:11:23,323
தளர்வாகச் சொன்னால், வன்பொருளில் ஹேமிங் குறியீடுகளை நேரடியாகச் செயல்படுத்தும் போது,

181
00:11:23,323 --> 00:11:26,652
மல்டிபிள் பேரிட்டி காசோலைக் கண்ணோட்டத்தைப் பற்றி சிந்திக்க எளிதானது,

182
00:11:26,652 --> 00:11:30,463
மேலும் XOR முன்னோக்கு மென்பொருளில், உயர் மட்டத்தில் இருந்து அதைச் செய்யும்போது

183
00:11:30,463 --> 00:11:31,380
சிந்திக்க எளிதானது.

184
00:11:31,380 --> 00:11:35,025
முதலாவது கையால் செய்வது மிகவும் எளிதானது, மேலும் இவை அனைத்திற்கும்

185
00:11:35,025 --> 00:11:38,942
அடிப்படையான உள்ளுணர்வை ஏற்படுத்துவதில் இது ஒரு சிறந்த வேலையைச் செய்யும்

186
00:11:38,942 --> 00:11:42,968
என்று நான் நினைக்கிறேன், அதாவது ஒரு பிழையைக் கண்டறிவதற்குத் தேவையான தகவல்

187
00:11:42,968 --> 00:11:47,429
தொகுதியின் அளவின் பதிவுடன் தொடர்புடையது. , அல்லது வேறு வார்த்தைகளில் கூறுவதானால்,

188
00:11:47,429 --> 00:11:51,020
தொகுதி அளவு இரட்டிப்பாகும் போது அது ஒரு நேரத்தில் ஒரு பிட் வளரும்.

189
00:11:51,020 --> 00:11:53,832
இங்கே பொருத்தமான உண்மை என்னவென்றால், அந்த தகவல் நமக்கு

190
00:11:53,832 --> 00:11:56,440
எவ்வளவு பணிநீக்கம் தேவை என்பதை நேரடியாக ஒத்துள்ளது.

191
00:11:56,440 --> 00:12:00,577
ஒரு செய்தியை பிழைகளைத் தடுக்கும் வகையில் உருவாக்குவதைப் பற்றி முதலில் நினைக்கும் போது,

192
00:12:00,577 --> 00:12:03,858
பெரும்பாலானவர்களின் மொக்கை எதிர்வினைக்கு எதிராக அதுதான் இயங்குகிறது,

193
00:12:03,858 --> 00:12:07,520
பொதுவாக முழுச் செய்தியையும் நகலெடுப்பதுதான் மனதில் தோன்றும் முதல் உள்ளுணர்வு.

194
00:12:07,520 --> 00:12:10,973
பின்னர், இந்த முழு வேறு வழியும் உள்ளது, சில சமயங்களில் ஹேமிங் குறியீடுகள்

195
00:12:10,973 --> 00:12:14,800
வழங்கப்படுகின்றன, அங்கு நீங்கள் செய்தியை ஒரு பெரிய மேட்ரிக்ஸால் பெருக்குகிறீர்கள்.

196
00:12:14,800 --> 00:12:18,332
இது ஒருவகையில் நன்றாக இருக்கிறது, ஏனெனில் இது நேரியல் குறியீடுகளின் பரந்த

197
00:12:18,332 --> 00:12:21,865
குடும்பத்துடன் தொடர்புடையது, ஆனால் அது எங்கிருந்து வருகிறது அல்லது எப்படி

198
00:12:21,865 --> 00:12:25,160
அளவிடுகிறது என்பதற்கான உள்ளுணர்வைக் கொடுக்கவில்லை என்று நினைக்கிறேன்.

199
00:12:25,160 --> 00:12:28,656
மற்றும் அளவிடுதல் பற்றி பேசுகையில், தொகுதி அளவை அதிகரிக்கும்போது மட்டுமே

200
00:12:28,656 --> 00:12:32,200
இந்த திட்டத்தின் செயல்திறன் சிறப்பாக இருக்கும் என்பதை நீங்கள் கவனிக்கலாம்.

201
00:12:32,200 --> 00:12:37,775
எடுத்துக்காட்டாக, 256 பிட்கள் மூலம், நீங்கள் பணிநீக்கத்திற்கு அந்த இடத்தில் 3% மட்டுமே

202
00:12:37,775 --> 00:12:43,480
பயன்படுத்துகிறீர்கள் என்பதை நாங்கள் பார்த்தோம், மேலும் அது அங்கிருந்து சிறப்பாக வருகிறது.

203
00:12:43,480 --> 00:12:49,040
சமநிலை பிட்களின் எண்ணிக்கை ஒவ்வொன்றாக வளரும்போது, தொகுதி அளவு இரட்டிப்பாகிறது.

204
00:12:49,040 --> 00:12:51,336
நீங்கள் அதை ஒரு தீவிரத்திற்கு எடுத்துக் கொண்டால்,

205
00:12:51,336 --> 00:12:54,368
நீங்கள் ஒரு மில்லியன் பிட்கள் கொண்ட ஒரு தொகுதியை வைத்திருக்கலாம்,

206
00:12:54,368 --> 00:12:58,319
அங்கு நீங்கள் உண்மையில் உங்கள் சமநிலை சரிபார்ப்புகளுடன் 20 கேள்விகளை விளையாடுவீர்கள்,

207
00:12:58,319 --> 00:13:00,800
மேலும் அது 21 சமநிலை பிட்களை மட்டுமே பயன்படுத்துகிறது.

208
00:13:00,800 --> 00:13:04,516
ஒரு மில்லியன் பிட்களைப் பார்த்து ஒரு பிழையைக் கண்டறிவதைப் பற்றி

209
00:13:04,516 --> 00:13:08,640
சிந்திக்க நீங்கள் பின்வாங்கினால், அது உண்மையிலேயே பைத்தியமாக உணர்கிறது.

210
00:13:08,640 --> 00:13:13,701
பிரச்சனை, நிச்சயமாக, ஒரு பெரிய தொகுதியுடன், ஒன்று அல்லது இரண்டு பிட் பிழைகளை பார்க்கும்

211
00:13:13,701 --> 00:13:18,360
நிகழ்தகவு அதிகரிக்கிறது, மேலும் ஹேமிங் குறியீடுகள் அதைத் தாண்டி எதையும் கையாளாது.

212
00:13:18,360 --> 00:13:22,744
எனவே நடைமுறையில், நீங்கள் விரும்புவது சரியான அளவைக் கண்டுபிடிப்பதாகும்,

213
00:13:22,744 --> 00:13:26,520
இதனால் பல பிட் ஃபிளிப்புகளின் நிகழ்தகவு மிக அதிகமாக இருக்காது.

214
00:13:26,520 --> 00:13:30,312
மேலும், நடைமுறையில், பிழைகள் சிறிய வெடிப்புகளில் வருகின்றன,

215
00:13:30,312 --> 00:13:34,925
இது ஒரு தொகுதியை முற்றிலுமாக அழித்துவிடும், எனவே பல்வேறு தொகுதிகளில் ஒரு

216
00:13:34,925 --> 00:13:39,981
வெடிப்பு பிழைகளை பரப்ப உதவும் ஒரு பொதுவான தந்திரம், அந்த தொகுதிகளை, இது போன்று,

217
00:13:39,981 --> 00:13:45,480
அவை உருவாகும் முன், பின்னிணைக்க வேண்டும். வெளியே அனுப்பப்பட்டது அல்லது சேமிக்கப்பட்டது.

218
00:13:45,480 --> 00:13:49,031
மீண்டும், இது மிகவும் நவீன குறியீடுகளால் முழுமையாக மாற்றப்படுகிறது,

219
00:13:49,031 --> 00:13:52,164
பொதுவாகப் பயன்படுத்தப்படும் ரீட்-சாலமன் அல்காரிதம் போன்றது,

220
00:13:52,164 --> 00:13:54,618
இது வெடிப்புப் பிழைகளை சிறப்பாகக் கையாளுகிறது,

221
00:13:54,618 --> 00:13:58,483
மேலும் இது ஒரு தொகுதிக்கு அதிக எண்ணிக்கையிலான பிழைகளை எதிர்க்கும் வகையில்

222
00:13:58,483 --> 00:13:59,580
மாற்றியமைக்கப்படலாம்.

223
00:13:59,580 --> 00:14:03,000
ஆனால் அது மற்றொரு நேரத்திற்கு ஒரு தலைப்பு.

224
00:14:03,000 --> 00:14:06,140
அவரது தி ஆர்ட் ஆஃப் டூயிங் சயின்ஸ் அண்ட் இன்ஜினியரிங் என்ற புத்தகத்தில்,

225
00:14:06,140 --> 00:14:09,882
ஹாமிங் இந்த குறியீட்டின் கண்டுபிடிப்பு எவ்வளவு வளைந்திருந்தது என்பதைப் பற்றி அற்புதமாக

226
00:14:09,882 --> 00:14:10,700
நேர்மையாக கூறினார்.

227
00:14:10,700 --> 00:14:14,515
பிட்களை உயர் பரிமாண லட்டியின் பகுதிகளாக ஒழுங்கமைப்பது மற்றும் இது போன்ற விசித்திரமான

228
00:14:14,515 --> 00:14:18,420
விஷயங்களை உள்ளடக்கிய அனைத்து வகையான வெவ்வேறு திட்டங்களையும் அவர் முதலில் முயற்சித்தார்.

229
00:14:18,420 --> 00:14:22,908
ஒரு பிழையின் நிலையை வெளிப்படுத்தும் விதத்தில் சதி செய்ய சமநிலை காசோலைகளைப் பெறுவது

230
00:14:22,908 --> 00:14:27,451
சாத்தியம் என்ற எண்ணம் ஹேமிங்கிற்கு வந்தது, அவர் வேறு சில பகுப்பாய்வுகளுக்குப் பிறகு

231
00:14:27,451 --> 00:14:31,183
பின்வாங்கி, சரி, என்னால் முடிந்த திறமையானது எது என்று கேட்டபோதுதான்.

232
00:14:31,183 --> 00:14:32,860
இதைப் பற்றி சிந்திக்க முடியுமா?

233
00:14:32,860 --> 00:14:37,228
1940 களில் இன்று இருப்பதை விட சமச்சீர் சோதனைகள் அவரது மனதில் ஏற்கனவே

234
00:14:37,228 --> 00:14:42,040
இருந்திருப்பது எவ்வளவு முக்கியம் என்பது குறித்தும் அவர் நேர்மையாக இருந்தார்.

235
00:14:42,040 --> 00:14:45,840
லூயிஸ் பாஸ்டர் மேற்கோள்களை அவர் குறிப்பிடும் இந்த புத்தகம் முழுவதும்

236
00:14:45,840 --> 00:14:49,640
அரை டஜன் முறைகள் உள்ளன, அதிர்ஷ்டம் தயாராக இருக்கும் மனதை ஆதரிக்கிறது.

237
00:14:49,640 --> 00:14:52,294
புத்திசாலித்தனமான யோசனைகள் பெரும்பாலும் பின்னோக்கிப் பார்க்கும்போது ஏமாற்றும்

238
00:14:52,294 --> 00:14:55,120
வகையில் எளிமையாகத் தோன்றுகின்றன, இது அவற்றைக் குறைத்து மதிப்பிடுவதை எளிதாக்குகிறது.

239
00:14:55,120 --> 00:14:57,100
இப்போது எனது நேர்மையான நம்பிக்கை என்னவென்றால்,

240
00:14:57,100 --> 00:15:00,429
ஹேமிங் குறியீடுகள் அல்லது குறைந்தபட்சம் அத்தகைய குறியீடுகளின் சாத்தியக்கூறுகள்

241
00:15:00,429 --> 00:15:01,820
உங்களுக்குத் தெளிவாகத் தெரிகிறது.

242
00:15:01,820 --> 00:15:06,455
ஆனால் அவை உண்மையில் வெளிப்படையானவை என்று நினைத்து உங்களை நீங்களே ஏமாற்றிக் கொள்ளக்கூடாது,

243
00:15:06,455 --> 00:15:08,000
ஏனென்றால் அவை நிச்சயமாக இல்லை.

244
00:15:08,000 --> 00:15:11,099
புத்திசாலித்தனமான யோசனைகள் ஏமாற்றும் வகையில் எளிமையாக இருப்பதற்கான ஒரு

245
00:15:11,099 --> 00:15:14,199
காரணம் என்னவென்றால், நாம் எப்போதும் இறுதி முடிவை மட்டுமே பார்க்கிறோம்,

246
00:15:14,199 --> 00:15:17,780
குழப்பமாக இருந்ததை சுத்தம் செய்வது, தவறான திருப்பங்கள் அனைத்தையும் குறிப்பிடாமல்,

247
00:15:17,780 --> 00:15:20,880
ஒரு சிக்கலின் தொடக்கத்தில் ஆராயக்கூடிய சாத்தியக்கூறுகளின் இடம் எவ்வளவு

248
00:15:20,880 --> 00:15:23,980
பெரியது என்பதை குறைத்து விற்பனை செய்வது. தீர்க்கும் செயல்முறை, அனைத்து.

249
00:15:23,980 --> 00:15:25,280
ஆனால் இது பொதுவாக உண்மை.

250
00:15:25,280 --> 00:15:29,180
சில சிறப்புக் கண்டுபிடிப்புகளுக்கு, நாம் அவற்றைக் குறைத்து மதிப்பிடுவதற்கு இரண்டாவது,

251
00:15:29,180 --> 00:15:31,040
ஆழமான காரணம் இருப்பதாக நான் நினைக்கிறேன்.

252
00:15:31,040 --> 00:15:35,356
பிட்களின் அடிப்படையில் தகவல்களைச் சிந்திப்பது 1948 ஆம் ஆண்டளவில் ஒரு முழுமையான

253
00:15:35,356 --> 00:15:39,400
கோட்பாடாக ஒன்றிணைந்தது, தகவல் கோட்பாட்டில் கிளாட் ஷானனின் செமினல் பேப்பர்.

254
00:15:39,400 --> 00:15:43,440
ஹாமிங் தனது வழிமுறையை உருவாக்கியபோது இது அடிப்படையில் ஒத்துப்போனது.

255
00:15:43,440 --> 00:15:47,778
ஒரு குறிப்பிட்ட அர்த்தத்தில், பிட் ஃபிளிப்புகளின் நிகழ்தகவு எவ்வளவு அதிகமாக இருந்தாலும்,

256
00:15:47,778 --> 00:15:51,482
குறைந்தபட்சம் கோட்பாட்டில், திறமையான பிழை திருத்தம் எப்போதும் சாத்தியமாகும்

257
00:15:51,482 --> 00:15:53,920
என்பதைக் காட்டிய அதே அடிப்படைக் கட்டுரை இதுவாகும்.

258
00:15:53,920 --> 00:15:57,706
ஷானனும் ஹாமிங்கும், பெல் லேப்ஸில் ஒரு அலுவலகத்தைப் பகிர்ந்து கொண்டனர்,

259
00:15:57,706 --> 00:16:02,400
மிகவும் வித்தியாசமான விஷயங்களில் பணிபுரிந்த போதிலும், இது இங்கு தற்செயலாகத் தெரியவில்லை.

260
00:16:02,400 --> 00:16:05,139
பல தசாப்தங்களாக வேகமாக முன்னேறி, இந்த நாட்களில்,

261
00:16:05,139 --> 00:16:09,389
நம்மில் பலர் பிட்கள் மற்றும் தகவல்களைப் பற்றி சிந்திப்பதில் மூழ்கிவிட்டோம்,

262
00:16:09,389 --> 00:16:13,080
இந்த சிந்தனை முறை எவ்வளவு வித்தியாசமானது என்பதைக் கவனிப்பது எளிது.

263
00:16:13,080 --> 00:16:15,677
முரண்பாடாக, வருங்கால சந்ததியினர் நினைக்கும் வழிகளை மிக ஆழமாக வடிவமைக்கும் கருத்துக்கள்,

264
00:16:15,677 --> 00:16:17,920
அந்த எதிர்கால சந்ததியினருக்கு அவை உண்மையில் இருப்பதை விட எளிமையாக இருக்கும்.

