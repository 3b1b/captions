1
00:00:00,000 --> 00:00:03,120
இங்குள்ள அனைவரும் பாகம் 1ல் இருந்து வந்தவர்கள் என்று எண்ணுகிறேன்.

2
00:00:03,120 --> 00:00:06,920
நாங்கள் ஹேமிங் குறியீடுகளைப் பற்றி பேசிக் கொண்டிருந்தோம், பெரும்பாலான பிட்கள்

3
00:00:06,920 --> 00:00:11,640
அர்த்தமுள்ள செய்தியைக் கொண்டு செல்லும் தரவுத் தொகுதியை உருவாக்கும்

4
00:00:11,640 --> 00:00:15,800
ஒரு வழி பிட் அல்லது ஒரு பணிநீக்கம் பிட்,

5
00:00:15,800 --> 00:00:20,560
இந்த பிளாக்கில் உள்ள எதையும், ஒரு பெறுநரால் பிழை

6
00:00:20,560 --> 00:00:21,920
இருப்பதை அடையாளம் காண முடியும், அதை எவ்வாறு சரிசெய்வது.

7
00:00:21,920 --> 00:00:25,900
அங்கு வழங்கப்பட்ட அடிப்படை யோசனையானது, பிழைக்கான உங்கள் வழியை பைனரி

8
00:00:25,900 --> 00:00:29,800
தேடுவதற்கு பல சமநிலை சரிபார்ப்புகளை எவ்வாறு பயன்படுத்துவது என்பதுதான்.

9
00:00:29,800 --> 00:00:33,920
அந்த வீடியோவில், ஹேமிங் குறியீடுகளை முடிந்தவரை மீண்டும்

10
00:00:33,920 --> 00:00:35,420
கண்டுபிடிக்கக்கூடியதாக உணர வைப்பதே குறிக்கோளாக இருந்தது.

11
00:00:35,420 --> 00:00:40,040
ஆனால் மென்பொருளில் அல்லது வன்பொருளில் இதை நடைமுறைப்படுத்துவது பற்றி நீங்கள் சிந்திக்கத் தொடங்கும்போது,

12
00:00:40,040 --> 00:00:44,120
இந்த குறியீடுகள் உண்மையில் எவ்வளவு நேர்த்தியானவை என்பதை அந்த ஃப்ரேமிங் உண்மையில் குறைத்துவிடும்.

13
00:00:44,120 --> 00:00:47,620
சாத்தியமான அனைத்து பிழை இருப்பிடங்களையும் கண்காணிக்கும் ஒரு வழிமுறையை நீங்கள் எழுத

14
00:00:47,620 --> 00:00:52,320
வேண்டும் என்று நீங்கள் நினைக்கலாம் மற்றும் ஒவ்வொரு சரிபார்ப்பிலும் அந்த குழுவை

15
00:00:52,320 --> 00:00:54,160
பாதியாக குறைக்கலாம், ஆனால் அது உண்மையில் வழி, அதை விட எளிமையானது.

16
00:00:54,160 --> 00:00:58,720
கடந்த வீடியோவில் நாங்கள் செய்த நான்கு சமநிலை சரிபார்ப்புகளுக்கான பதில்களை, ஆம் மற்றும் இல்லை என்பதற்குப் பதிலாக

17
00:00:58,760 --> 00:01:04,800
1கள் மற்றும் 0கள் எனப் படித்தால், அது பைனரியில் உள்ள பிழையின் நிலையை உண்மையில் விவரிக்கிறது.

18
00:01:04,800 --> 00:01:10,160
எடுத்துக்காட்டாக, பைனரியில் உள்ள எண் 7 0111 போல் தெரிகிறது,

19
00:01:10,160 --> 00:01:12,640
இது 4 கூட்டல் 2 கூட்டல் 1 என்று கூறுகிறது.

20
00:01:12,640 --> 00:01:17,960
மற்றும் நிலை 7 எங்கு அமர்ந்திருக்கிறது என்பதைக் கவனியுங்கள், இது எங்கள் சமத்துவக்

21
00:01:17,960 --> 00:01:22,280
குழுக்களில் முதலாவது மற்றும் இரண்டாவது மற்றும் மூன்றாவது, ஆனால் கடைசியாக அல்ல.

22
00:01:22,280 --> 00:01:26,560
எனவே அந்த நான்கு காசோலைகளின் முடிவுகளை கீழிருந்து

23
00:01:26,560 --> 00:01:28,000
மேல் வரை படிப்பது பிழையின் நிலையை வெளிப்படுத்துகிறது.

24
00:01:28,520 --> 00:01:32,240
எடுத்துக்காட்டு 7 இல் சிறப்பு எதுவும் இல்லை, இது பொதுவாக வேலை செய்கிறது,

25
00:01:32,240 --> 00:01:37,440
மேலும் இது வன்பொருளில் முழு திட்டத்தையும் செயல்படுத்துவதற்கான தர்க்கத்தை அதிர்ச்சியூட்டும் வகையில் எளிதாக்குகிறது.

26
00:01:37,440 --> 00:01:43,380
இப்போது இந்த மேஜிக் ஏன் நடக்கிறது என்பதைப் பார்க்க விரும்பினால், இந்த 16 இன்டெக்ஸ்

27
00:01:43,380 --> 00:01:48,480
லேபிள்களை எங்கள் நிலைகளுக்கு எடுத்துக் கொள்ளுங்கள், ஆனால் அவற்றை அடிப்படை 10 இல்

28
00:01:48,480 --> 00:01:50,720
எழுதுவதற்குப் பதிலாக, 0000 முதல் 1111 வரை இயங்கும் பைனரியில் அனைத்தையும் எழுதுவோம்.

29
00:01:50,720 --> 00:01:55,880
இந்த பைனரி லேபிள்களை அவற்றின் பெட்டிகளில் மீண்டும் வைக்கும்போது,

30
00:01:56,080 --> 00:01:58,440
அவை உண்மையில் அனுப்பப்படும் தரவுகளிலிருந்து வேறுபட்டவை என்பதை வலியுறுத்துகிறேன்.

31
00:01:58,440 --> 00:02:02,200
நான்கு சமத்துவக் குழுக்கள் எங்கிருந்து வந்தன என்பதைப் புரிந்துகொள்ள உங்களுக்கும்

32
00:02:02,200 --> 00:02:04,200
எனக்கும் உதவும் ஒரு கருத்தியல் லேபிளைத் தவிர வேறொன்றுமில்லை.

33
00:02:04,200 --> 00:02:08,840
நாம் பார்க்கும் அனைத்தும் பைனரியில் விவரிக்கப்படுவதன் நேர்த்தியானது, நாம் பார்க்கும்

34
00:02:08,840 --> 00:02:13,160
அனைத்தும் பைனரியில் விவரிக்கப்பட வேண்டும் என்ற குழப்பத்தால் குறைக்கப்படலாம்.

35
00:02:13,160 --> 00:02:15,040
இருந்தாலும் அது மதிப்புக்குரியது.

36
00:02:15,040 --> 00:02:20,740
இந்த லேபிள்கள் அனைத்தின் கடைசி பிட்டில் மட்டும் உங்கள் கவனத்தை செலுத்தவும்,

37
00:02:20,740 --> 00:02:24,280
பின்னர் அந்த இறுதி பிட் 1 ஆக இருக்கும் நிலைகளை முன்னிலைப்படுத்தவும்.

38
00:02:24,280 --> 00:02:28,800
நாங்கள் பெறுவது எங்களின் நான்கு சமத்துவக் குழுக்களில் முதன்மையானது, அதாவது அந்த

39
00:02:28,800 --> 00:02:34,480
முதல் காசோலையைக் கேட்பது போல் நீங்கள் விளக்கலாம், ஏய், பிழை

40
00:02:34,480 --> 00:02:36,680
இருந்தால், அந்த பிழையின் நிலையில் இறுதி பிட் 1 உள்ளதா?

41
00:02:36,680 --> 00:02:42,600
இதேபோல், நீங்கள் இரண்டாவது முதல் கடைசி பிட் வரை கவனம் செலுத்தி, அது 1 ஆக

42
00:02:42,600 --> 00:02:47,040
இருக்கும் அனைத்து நிலைகளையும் முன்னிலைப்படுத்தினால், எங்கள் திட்டத்தில் இருந்து இரண்டாவது பாரிட்டி குழுவைப் பெறுவீர்கள்.

43
00:02:47,040 --> 00:02:51,960
வேறு வார்த்தைகளில் கூறுவதானால், அந்த இரண்டாவது காசோலை கேட்கிறது, ஏய், மீண்டும் என்னிடம்,

44
00:02:51,960 --> 00:02:56,160
பிழை இருந்தால், அந்த நிலையின் இரண்டாவது முதல் கடைசி பிட் 1 தானா?

45
00:02:56,160 --> 00:02:57,160
மற்றும் பல.

46
00:02:57,160 --> 00:03:03,320
மூன்றாவது பாரிட்டி காசோலையானது, மூன்றாவது முதல் கடைசி பிட் வரை இயக்கப்பட்ட ஒவ்வொரு நிலையையும் உள்ளடக்கியது,

47
00:03:03,320 --> 00:03:10,120
மேலும் கடைசியானது கடைசி எட்டு நிலைகளை உள்ளடக்கியது, அதிகபட்ச ஆர்டர் பிட் 1 ஆகும்.

48
00:03:10,120 --> 00:03:15,680
நாம் முன்பு செய்த அனைத்தும் இந்த நான்கு கேள்விகளுக்குப் பதிலளிப்பதைப்

49
00:03:15,680 --> 00:03:18,800
போன்றது, இது பைனரியில் ஒரு நிலையை உச்சரிப்பது போன்றது.

50
00:03:19,800 --> 00:03:22,080
இது இரண்டு விஷயங்களை தெளிவாக்குகிறது என்று நம்புகிறேன்.

51
00:03:22,080 --> 00:03:27,140
முதலாவதாக, இரண்டின் பெரிய சக்திகளைக் கொண்ட தொகுதி அளவுகளை முறையாகப் பொதுமைப்படுத்துவது எப்படி.

52
00:03:27,140 --> 00:03:33,180
64 புள்ளிகளை விவரிக்க ஆறு பிட்கள் போல, ஒவ்வொரு நிலையையும் விவரிக்க அதிக பிட்கள் தேவைப்பட்டால்,

53
00:03:33,180 --> 00:03:38,640
அந்த பிட்கள் ஒவ்வொன்றும் நாம் சரிபார்க்க வேண்டிய சமநிலைக் குழுக்களில் ஒன்றை உங்களுக்கு வழங்குகிறது.

54
00:03:38,640 --> 00:03:42,060
மேட் பார்க்கருடன் நான் செய்த சதுரங்கப் புதிரைப் பார்த்த

55
00:03:42,060 --> 00:03:43,400
உங்களில், இவை அனைத்தும் மிகவும் பரிச்சயமானதாக இருக்கலாம்.

56
00:03:43,400 --> 00:03:48,200
இது அதே முக்கிய தர்க்கம், ஆனால் வேறு ஒரு சிக்கலைத்

57
00:03:48,200 --> 00:03:49,880
தீர்க்கிறது, மேலும் 64-சதுர சதுரங்கப் பலகைக்கு இது பயன்படுத்தப்பட்டது.

58
00:03:49,880 --> 00:03:54,000
இது தெளிவுபடுத்தும் இரண்டாவது விஷயம் என்னவென்றால், 1, 2, 4, மற்றும் 8

59
00:03:54,000 --> 00:03:58,320
ஆகிய இரண்டு சக்திகளின் நிலைகளில் நமது சமநிலை பிட்கள் ஏன் அமர்ந்திருக்கின்றன என்பதுதான்.

60
00:03:58,320 --> 00:04:03,640
பைனரி பிரதிநிதித்துவம் ஒரு பிட் மட்டுமே இயக்கப்பட்டிருக்கும் நிலைகள் இவை.

61
00:04:03,640 --> 00:04:09,000
இதன் பொருள் என்னவென்றால், அந்த ஒவ்வொரு பாரிட்டி பிட்களும்

62
00:04:09,000 --> 00:04:12,640
ஒன்றுக்குள் அமர்ந்து நான்கு சமத்துவக் குழுக்களில் ஒன்று மட்டுமே.

63
00:04:12,640 --> 00:04:16,840
நீங்கள் இதைப் பெரிய எடுத்துக்காட்டுகளிலும் பார்க்கலாம், நீங்கள் எவ்வளவு பெரியதாக இருந்தாலும்,

64
00:04:16,840 --> 00:04:25,920
ஒவ்வொரு பாரிட்டி பிட்டும் வசதியாக குழுக்களில் ஒன்றை மட்டுமே தொடும்.

65
00:04:25,920 --> 00:04:29,680
நாம் அதிக நேரத்தைச் செலுத்திய இந்த சமநிலைச் சரிபார்ப்புகள் பைனரியில் உள்ள

66
00:04:29,680 --> 00:04:34,320
பிழையின் நிலையை உச்சரிப்பதற்கான ஒரு புத்திசாலித்தனமான வழியைத் தவிர வேறில்லை

67
00:04:34,320 --> 00:04:37,880
என்பதை நீங்கள் புரிந்துகொண்டவுடன், ஹேமிங்கைப் பற்றி சிந்திக்க வேறு வழியில் நாம்

68
00:04:37,880 --> 00:04:42,160
இணைப்பை உருவாக்கலாம். குறியீடுகள், இது மிகவும் எளிமையானது மற்றும் நேர்த்தியானது,

69
00:04:42,160 --> 00:04:43,880
மேலும் இது ஒரு ஒற்றை வரி குறியீட்டைக் கொண்டு எழுதப்படலாம்.

70
00:04:43,920 --> 00:04:46,200
இது XOR செயல்பாட்டை அடிப்படையாகக் கொண்டது.

71
00:04:46,200 --> 00:04:50,960
XOR, உங்களில் தெரியாதவர்களுக்கு, பிரத்தியேகமான அல்லது.

72
00:04:50,960 --> 00:04:55,440
நீங்கள் இரண்டு பிட்களின் XOR ஐ எடுக்கும்போது, அந்த பிட்களில் ஏதேனும் ஒன்று இயக்கப்பட்டிருந்தால்

73
00:04:55,440 --> 00:05:00,200
அது 1ஐத் தரும், ஆனால் இரண்டும் ஆன் அல்லது ஆஃப் செய்யப்பட்டிருந்தால் அல்ல.

74
00:05:00,200 --> 00:05:03,760
வித்தியாசமாக சொற்றொடர், இந்த இரண்டு பிட்களின் சமநிலை.

75
00:05:03,760 --> 00:05:07,840
ஒரு கணித நபராக, நான் அதை கூட்டல் மோட் 2 என நினைக்க விரும்புகிறேன்.

76
00:05:07,840 --> 00:05:12,000
நாங்கள் பொதுவாக இரண்டு வெவ்வேறு பிட் சரங்களின் XOR பற்றி

77
00:05:12,040 --> 00:05:14,040
பேசுகிறோம், இது அடிப்படையில் இந்த கூறுகளை கூறு மூலம் செய்கிறது.

78
00:05:14,040 --> 00:05:16,280
இது கூட்டல் போன்றது, ஆனால் நீங்கள் எடுத்துச் செல்லவே இல்லை.

79
00:05:16,280 --> 00:05:21,240
மீண்டும், கணித ரீதியாக அதிக விருப்பமுள்ளவர்கள் இதை இரண்டு திசையன்களைச்

80
00:05:21,240 --> 00:05:23,520
சேர்ப்பது மற்றும் மோட் 2 ஐக் குறைப்பது என்று நினைக்கலாம்.

81
00:05:23,520 --> 00:05:28,720
நீங்கள் இப்போது சில பைத்தானைத் திறந்து, இரண்டு முழு எண்களுக்கு இடையில் கேரட்

82
00:05:28,720 --> 00:05:35,400
செயல்பாட்டைப் பயன்படுத்தினால், இது பேட்டைக்குக் கீழே அந்த எண்களின் பிட் பிரதிநிதித்துவங்களைச் செய்யும்.

83
00:05:35,400 --> 00:05:40,920
உங்களுக்கும் எனக்கும் முக்கியமான விஷயம் என்னவென்றால், பல

84
00:05:40,960 --> 00:05:45,960
வேறுபட்ட பிட் சரங்களின் XORஐ எடுத்துக்கொள்வது, தனித்தனி

85
00:05:45,960 --> 00:05:51,320
குழுக்களின் கேலிக்கூத்துகளை கணக்கிடுவதற்கான ஒரு வழியாகும்.

86
00:05:51,320 --> 00:05:54,520
எங்கள் ஹேமிங் குறியீடு அல்காரிதத்தில் இருந்து பல சமநிலை சரிபார்ப்புகளைப் பற்றி சிந்திக்க இது

87
00:05:54,520 --> 00:05:59,680
எங்களுக்கு மிகவும் எளிமையான வழியை வழங்குகிறது, ஏனெனில் அனைத்தும் ஒன்றாக ஒரே செயல்பாட்டில் தொகுக்கப்படுகின்றன.

88
00:05:59,680 --> 00:06:02,800
முதல் பார்வையில் இது மிகவும் வித்தியாசமாகத் தெரிந்தாலும்.

89
00:06:02,800 --> 00:06:08,360
குறிப்பாக பைனரியில் 16 நிலைகளை எழுதவும், முன்பு இருந்தது போல், இப்போது

90
00:06:08,640 --> 00:06:14,800
செய்தி பிட் 1 க்கு இயக்கப்பட்ட நிலைகளை முன்னிலைப்படுத்தவும், பின்னர் இந்த

91
00:06:14,800 --> 00:06:19,400
நிலைகளை ஒரு பெரிய நெடுவரிசையில் சேகரித்து XOR ஐ எடுக்கவும்.

92
00:06:19,400 --> 00:06:23,480
இதன் விளைவாக கீழே அமர்ந்திருக்கும் 4 பிட்கள், நாங்கள் அறிந்த மற்றும் விரும்பி

93
00:06:23,480 --> 00:06:27,480
வைத்திருக்கும் 4 சமநிலை சரிபார்ப்புகளைப் போலவே இருக்கும் என்று நீங்கள் ஒருவேளை

94
00:06:27,480 --> 00:06:32,720
யூகிக்கலாம், ஆனால் ஏன் என்று சரியாகச் சிந்திக்க சிறிது நேரம் ஒதுக்குங்கள்.

95
00:06:32,720 --> 00:06:37,880
இந்த கடைசி நெடுவரிசை, எடுத்துக்காட்டாக, கடைசி பிட் 1 ஆக உள்ள அனைத்து நிலைகளையும்

96
00:06:38,400 --> 00:06:42,400
கணக்கிடுகிறது, ஆனால் நாங்கள் ஏற்கனவே ஹைலைட் செய்யப்பட்ட நிலைகளுக்கு மட்டுமே வரம்பிடப்பட்டுள்ளோம், எனவே இது

97
00:06:42,400 --> 00:06:45,960
முதல் சமநிலை குழுவிலிருந்து எத்தனை ஹைலைட் செய்யப்பட்ட நிலைகள் வந்தன என்பதை திறம்பட கணக்கிடுகிறது.

98
00:06:45,960 --> 00:06:48,520
அதில் ஏதாவது பொருளிருக்கிறதா? அதில் அர்த்தமிருக்கிறதா?

99
00:06:48,520 --> 00:06:53,600
அதேபோல, அடுத்த நெடுவரிசை, இரண்டாவது சமத்துவக் குழுவில் எத்தனை நிலைகள்

100
00:06:53,600 --> 00:06:59,640
உள்ளன, இரண்டாவது முதல் கடைசி பிட் வரையிலான நிலைகள்

101
00:06:59,640 --> 00:07:00,640
1, மற்றும் அவையும் தனிப்படுத்தப்பட்டவை மற்றும் பலவற்றைக் கணக்கிடுகிறது.

102
00:07:00,640 --> 00:07:06,640
இது உண்மையில் நாம் செய்துகொண்டிருக்கும் அதே விஷயத்தைப் பற்றிய கண்ணோட்டத்தில் ஒரு சிறிய மாற்றம்.

103
00:07:07,640 --> 00:07:10,000
அது இங்கிருந்து எங்கு செல்கிறது என்பது உங்களுக்குத் தெரியும்.

104
00:07:10,000 --> 00:07:14,400
தொகை 0000 ஆக இருக்கும் என்பதை உறுதிப்படுத்த, சில

105
00:07:14,400 --> 00:07:19,640
சிறப்பு சமநிலை பிட்களை மாற்றுவதற்கு அனுப்புநரின் பொறுப்பாகும்.

106
00:07:19,640 --> 00:07:23,600
இப்போது நாம் இதைப் பெற்றவுடன், கீழே உள்ள இந்த நான்கு பிட்கள் ஏன் பிழையின்

107
00:07:23,600 --> 00:07:28,720
நிலையை நேரடியாக உச்சரிக்கின்றன என்பதைப் பற்றி சிந்திக்க இது ஒரு நல்ல வழியை வழங்குகிறது.

108
00:07:28,720 --> 00:07:32,680
இந்த பிளாக்கில் சில பிட்கள் 0 இலிருந்து 1 ஆக மாறுகிறது என்று வைத்துக்கொள்வோம்.

109
00:07:32,720 --> 00:07:37,320
இதன் பொருள் என்னவென்றால், அந்த பிட்டின் நிலை இப்போது மொத்த

110
00:07:37,320 --> 00:07:42,960
XOR இல் சேர்க்கப்படும், இது கூட்டுத்தொகையை 0 என்பதிலிருந்து

111
00:07:42,960 --> 00:07:44,800
புதிதாக சேர்க்கப்பட்ட இந்த மதிப்பாக மாற்றுகிறது, பிழையின் நிலை.

112
00:07:44,800 --> 00:07:48,800
சற்று குறைவாக வெளிப்படையாக, 1 ஐ 0

113
00:07:48,800 --> 00:07:49,800
ஆக மாற்றும் பிழை இருந்தால் அதுவே உண்மை.

114
00:07:49,800 --> 00:07:54,720
நீங்கள் பார்க்கிறீர்கள், நீங்கள் ஒரு பிட் சரத்தை இரண்டு முறை ஒன்றாகச் சேர்த்தால், அது இல்லை

115
00:07:54,720 --> 00:07:59,000
என்பதற்கு சமம், அடிப்படையில் இந்த உலகில் 1 கூட்டல் 1 என்பது 0 ஆகும்.

116
00:07:59,000 --> 00:08:03,720
எனவே இந்த நிலையின் நகலை மொத்தத் தொகையில் சேர்ப்பது

117
00:08:03,720 --> 00:08:05,400
நாம் அதை நகர்த்தும்போது அதே விளைவை ஏற்படுத்தும்.

118
00:08:05,400 --> 00:08:10,080
அந்த விளைவு, மீண்டும், இங்கே கீழே உள்ள

119
00:08:10,080 --> 00:08:13,480
மொத்த முடிவு பிழையின் நிலையை உச்சரிக்கிறது.

120
00:08:13,480 --> 00:08:17,720
இது எவ்வளவு நேர்த்தியானது என்பதை விளக்குவதற்கு, நான் முன்பு குறிப்பிட்ட பைதான் குறியீட்டின்

121
00:08:17,720 --> 00:08:22,120
ஒரு வரியைக் காட்டுகிறேன், இது பெறுநரின் முடிவில் கிட்டத்தட்ட எல்லா தர்க்கங்களையும் கைப்பற்றும்.

122
00:08:22,120 --> 00:08:27,160
தரவுத் தொகுதியை உருவகப்படுத்த 16 1s மற்றும் 0s என்ற சீரற்ற வரிசையை

123
00:08:27,160 --> 00:08:31,160
உருவாக்குவதன் மூலம் தொடங்குவோம், நான் அதற்கு பெயர் பிட்களை தருகிறேன், ஆனால் நடைமுறையில்

124
00:08:31,160 --> 00:08:36,160
இது ஒரு அனுப்புநரிடமிருந்து நாம் பெறும் ஒன்று, அதற்கு பதிலாக சீரற்றதாக இருந்தால்,

125
00:08:36,160 --> 00:08:38,600
அது 11 டேட்டா பிட்களையும் 5 பேரிட்டி பிட்களையும் கொண்டு செல்லும்.

126
00:08:38,600 --> 00:08:43,160
நான் செயல்பாடு enumerateBits என்று அழைத்தால், அது 0 முதல் 15 வரை

127
00:08:43,160 --> 00:08:48,240
இயங்கும் இந்த விஷயத்தில், அந்த பிட்கள் ஒவ்வொன்றையும் தொடர்புடைய குறியீட்டுடன் இணைப்பதாகும்.

128
00:08:48,240 --> 00:08:53,200
எனவே, இந்த ஜோடிகள் அனைத்தின் மீதும் சுழலும் ஒரு பட்டியலை உருவாக்கினால், i போல

129
00:08:53,200 --> 00:08:59,160
தோற்றமளிக்கும் ஜோடிகள், பின்னர் i மதிப்பை, குறியீட்டை மட்டும் வெளியே இழுத்தால், அது அவ்வளவு

130
00:08:59,160 --> 00:09:01,920
உற்சாகமாக இல்லை, அந்த குறியீடுகளை 0 முதல் 15 வரை திரும்பப் பெறுவோம். .

131
00:09:01,920 --> 00:09:07,520
ஆனால் பிட் என்றால் மட்டுமே இதைச் செய்ய வேண்டும் என்ற நிபந்தனையைச் சேர்த்தால், அதாவது அந்த பிட்

132
00:09:07,520 --> 00:09:13,400
1 மற்றும் 0 அல்ல என்றால், அது தொடர்புடைய பிட் இயக்கப்பட்டிருக்கும் நிலைகளை மட்டும் இழுக்கிறது.

133
00:09:13,400 --> 00:09:20,320
இந்த வழக்கில், அந்த நிலைகள் 0, 4, 6, 9, போன்றவை போல் தெரிகிறது.

134
00:09:20,720 --> 00:09:24,640
நாம் விரும்புவது, அந்த நிலைகள் அனைத்தையும் ஒன்றாகச் சேகரிக்க வேண்டும், இயக்கப்பட்ட

135
00:09:24,640 --> 00:09:29,960
பிட்களின் நிலைகள், பின்னர் அவற்றை ஒன்றாக XOR செய்ய வேண்டும்.

136
00:09:29,960 --> 00:09:33,960
பைத்தானில் இதைச் செய்ய, முதலில் இரண்டு பயனுள்ள செயல்பாடுகளை இறக்குமதி செய்கிறேன்.

137
00:09:33,960 --> 00:09:39,140
அந்த வகையில் நாம் இந்த பட்டியலில் குறைக்க() என்று அழைக்கலாம் மற்றும் அதை குறைக்க XOR செயல்பாட்டைப் பயன்படுத்தலாம்.

138
00:09:39,140 --> 00:09:44,840
இது அடிப்படையில் பட்டியலில் அதன் வழியை உண்கிறது, வழியில் XOR களை எடுத்துக்கொள்கிறது.

139
00:09:44,840 --> 00:09:48,760
நீங்கள் விரும்பினால், XOR செயல்பாட்டை எங்கிருந்தும்

140
00:09:48,800 --> 00:09:52,200
இறக்குமதி செய்யாமல் வெளிப்படையாக எழுதலாம்.

141
00:09:52,200 --> 00:09:56,880
எனவே தற்போது 16 பிட்களின் சீரற்ற தொகுதியில் இதைச் செய்தால், அது

142
00:09:56,880 --> 00:10:02,080
9 ஐத் தருகிறது, இதில் பைனரி பிரதிநிதித்துவம் 1001 உள்ளது.

143
00:10:02,080 --> 00:10:05,960
நாங்கள் அதை இங்கே செய்ய மாட்டோம், ஆனால் அனுப்புநர் அந்த பைனரி பிரதிநிதித்துவத்தைப் பயன்படுத்தி நான்கு

144
00:10:05,960 --> 00:10:11,560
பேரிட்டி பிட்களை தேவைக்கேற்ப அமைக்கும் ஒரு செயல்பாட்டை நீங்கள் எழுதலாம், இறுதியில் இந்தத் தொகுதியை பிட்களின்

145
00:10:11,560 --> 00:10:16,200
முழுப் பட்டியலிலும் இந்த குறியீட்டு வரியை இயக்கும் நிலைக்கு கொண்டு செல்லலாம். ஒரு 0.

146
00:10:17,200 --> 00:10:20,200
இது நன்கு தயாரிக்கப்பட்ட தொகுதியாகக் கருதப்படும்.

147
00:10:20,200 --> 00:10:24,640
நல்ல விஷயம் என்னவென்றால், இந்த பட்டியலில் உள்ள பிட்களில் ஏதேனும் ஒன்றை நாம் மாற்றினால், இரைச்சலில் இருந்து

148
00:10:24,640 --> 00:10:30,600
ஒரு சீரற்ற பிழையை உருவகப்படுத்தினால், நீங்கள் இதே குறியீட்டை இயக்கினால், அது அந்த பிழையை அச்சிடுகிறது.

149
00:10:30,600 --> 00:10:31,920
அது சுத்தமாக இல்லையா?

150
00:10:31,920 --> 00:10:37,200
இந்தத் தொகுதியை நீங்கள் நீல நிறத்தில் இருந்து பெறலாம், இந்த ஒற்றை வரியை அதில் இயக்கலாம்,

151
00:10:37,200 --> 00:10:42,920
மேலும் அது பிழையின் நிலையை தானாகவே துப்பிவிடும், அல்லது எதுவும் இல்லை என்றால் 0.

152
00:10:42,920 --> 00:10:45,520
இங்கே அளவு 16 பற்றி சிறப்பு எதுவும் இல்லை.

153
00:10:45,520 --> 00:10:52,280
உங்களிடம் 256 பிட்களின் பட்டியல் இருந்தால் அதே வரி குறியீடு வேலை செய்யும்.

154
00:10:52,280 --> 00:10:56,280
2-பிட் பிழைகளைக் கண்டறிய மெட்டா பாரிட்டி செக் செய்வது போன்ற கூடுதல் குறியீடுகள்

155
00:10:56,280 --> 00:11:01,440
இங்கே எழுத வேண்டும் என்று சொல்லத் தேவையில்லை, ஆனால் எங்கள் திட்டத்தில் உள்ள

156
00:11:01,440 --> 00:11:05,080
அனைத்து முக்கிய தர்க்கங்களும் ஒரே XOR குறைப்புக்கு வரும் என்பது யோசனை.

157
00:11:05,080 --> 00:11:10,600
இப்போது, பைனரி மற்றும் XORகள் மற்றும் பொதுவாக மென்பொருளில் உள்ள உங்கள்

158
00:11:10,600 --> 00:11:15,880
வசதியைப் பொறுத்து, இந்த முன்னோக்கைக் கொஞ்சம் குழப்பமாகவோ அல்லது மிகவும் நேர்த்தியாகவும்

159
00:11:15,880 --> 00:11:19,320
எளிமையாகவும் நாம் ஏன் தொடங்கவில்லை என்று நீங்கள் ஆச்சரியப்படுகிறீர்கள். -போ.

160
00:11:19,320 --> 00:11:22,880
தளர்வாகச் சொன்னால், வன்பொருளில் ஹேமிங் குறியீடுகளை நேரடியாகச் செயல்படுத்தும் போது, மல்டிபிள்

161
00:11:22,880 --> 00:11:27,560
பேரிட்டி காசோலைக் கண்ணோட்டத்தைப் பற்றி சிந்திக்க எளிதானது, மேலும் XOR முன்னோக்கு

162
00:11:27,560 --> 00:11:31,380
மென்பொருளில், உயர் மட்டத்தில் இருந்து அதைச் செய்யும்போது சிந்திக்க எளிதானது.

163
00:11:31,380 --> 00:11:35,640
முதலாவது கையால் செய்வது மிகவும் எளிதானது, மேலும் இவை அனைத்திற்கும் அடிப்படையான உள்ளுணர்வை ஏற்படுத்துவதில்

164
00:11:35,640 --> 00:11:40,720
இது ஒரு சிறந்த வேலையைச் செய்யும் என்று நான் நினைக்கிறேன், அதாவது ஒரு பிழையைக்

165
00:11:40,720 --> 00:11:46,840
கண்டறிவதற்குத் தேவையான தகவல் தொகுதியின் அளவின் பதிவுடன் தொடர்புடையது. , அல்லது வேறு வார்த்தைகளில்

166
00:11:46,840 --> 00:11:51,020
கூறுவதானால், தொகுதி அளவு இரட்டிப்பாகும் போது அது ஒரு நேரத்தில் ஒரு பிட் வளரும்.

167
00:11:51,020 --> 00:11:55,440
இங்கே பொருத்தமான உண்மை என்னவென்றால், அந்த தகவல் நமக்கு

168
00:11:55,440 --> 00:11:56,440
எவ்வளவு பணிநீக்கம் தேவை என்பதை நேரடியாக ஒத்துள்ளது.

169
00:11:56,440 --> 00:12:00,320
ஒரு செய்தியை பிழைகளைத் தடுக்கும் வகையில் உருவாக்குவதைப் பற்றி முதலில்

170
00:12:00,320 --> 00:12:05,280
நினைக்கும் போது, பெரும்பாலானவர்களின் மொக்கை எதிர்வினைக்கு எதிராக அதுதான் இயங்குகிறது,

171
00:12:05,280 --> 00:12:07,520
பொதுவாக முழுச் செய்தியையும் நகலெடுப்பதுதான் மனதில் தோன்றும் முதல் உள்ளுணர்வு.

172
00:12:07,520 --> 00:12:11,120
பின்னர், இந்த முழு வேறு வழியும் உள்ளது, சில சமயங்களில் ஹேமிங்

173
00:12:11,120 --> 00:12:14,800
குறியீடுகள் வழங்கப்படுகின்றன, அங்கு நீங்கள் செய்தியை ஒரு பெரிய மேட்ரிக்ஸால் பெருக்குகிறீர்கள்.

174
00:12:14,800 --> 00:12:18,580
இது ஒருவகையில் நன்றாக இருக்கிறது, ஏனெனில் இது நேரியல் குறியீடுகளின் பரந்த குடும்பத்துடன் தொடர்புடையது, ஆனால்

175
00:12:18,580 --> 00:12:25,160
அது எங்கிருந்து வருகிறது அல்லது எப்படி அளவிடுகிறது என்பதற்கான உள்ளுணர்வைக் கொடுக்கவில்லை என்று நினைக்கிறேன்.

176
00:12:25,160 --> 00:12:29,340
மற்றும் அளவிடுதல் பற்றி பேசுகையில், தொகுதி அளவை அதிகரிக்கும்போது மட்டுமே

177
00:12:29,340 --> 00:12:32,200
இந்த திட்டத்தின் செயல்திறன் சிறப்பாக இருக்கும் என்பதை நீங்கள் கவனிக்கலாம்.

178
00:12:32,200 --> 00:12:40,560
எடுத்துக்காட்டாக, 256 பிட்கள் மூலம், நீங்கள் பணிநீக்கத்திற்கு அந்த இடத்தில் 3% மட்டுமே

179
00:12:40,560 --> 00:12:43,480
பயன்படுத்துகிறீர்கள் என்பதை நாங்கள் பார்த்தோம், மேலும் அது அங்கிருந்து சிறப்பாக வருகிறது.

180
00:12:43,480 --> 00:12:49,040
சமநிலை பிட்களின் எண்ணிக்கை ஒவ்வொன்றாக வளரும்போது, தொகுதி அளவு இரட்டிப்பாகிறது.

181
00:12:49,040 --> 00:12:53,840
நீங்கள் அதை ஒரு தீவிரத்திற்கு எடுத்துக் கொண்டால், நீங்கள் ஒரு மில்லியன் பிட்கள்

182
00:12:53,840 --> 00:12:58,800
கொண்ட ஒரு தொகுதியை வைத்திருக்கலாம், அங்கு நீங்கள் உண்மையில் உங்கள் சமநிலை சரிபார்ப்புகளுடன்

183
00:12:58,800 --> 00:13:00,800
20 கேள்விகளை விளையாடுவீர்கள், மேலும் அது 21 சமநிலை பிட்களை மட்டுமே பயன்படுத்துகிறது.

184
00:13:00,800 --> 00:13:05,760
ஒரு மில்லியன் பிட்களைப் பார்த்து ஒரு பிழையைக் கண்டறிவதைப் பற்றி

185
00:13:05,760 --> 00:13:08,640
சிந்திக்க நீங்கள் பின்வாங்கினால், அது உண்மையிலேயே பைத்தியமாக உணர்கிறது.

186
00:13:08,640 --> 00:13:12,680
பிரச்சனை, நிச்சயமாக, ஒரு பெரிய தொகுதியுடன், ஒன்று அல்லது இரண்டு பிட் பிழைகளை

187
00:13:12,680 --> 00:13:18,360
பார்க்கும் நிகழ்தகவு அதிகரிக்கிறது, மேலும் ஹேமிங் குறியீடுகள் அதைத் தாண்டி எதையும் கையாளாது.

188
00:13:18,360 --> 00:13:22,020
எனவே நடைமுறையில், நீங்கள் விரும்புவது சரியான அளவைக் கண்டுபிடிப்பதாகும், இதனால்

189
00:13:22,020 --> 00:13:25,520
பல பிட் ஃபிளிப்புகளின் நிகழ்தகவு மிக அதிகமாக இருக்காது.

190
00:13:26,520 --> 00:13:30,920
மேலும், நடைமுறையில், பிழைகள் சிறிய வெடிப்புகளில் வருகின்றன, இது ஒரு தொகுதியை முற்றிலுமாக அழித்துவிடும், எனவே

191
00:13:30,920 --> 00:13:35,680
பல்வேறு தொகுதிகளில் ஒரு வெடிப்பு பிழைகளை பரப்ப உதவும் ஒரு பொதுவான தந்திரம், அந்த தொகுதிகளை,

192
00:13:35,680 --> 00:13:41,720
இது போன்று, அவை உருவாகும் முன், பின்னிணைக்க வேண்டும். வெளியே அனுப்பப்பட்டது அல்லது சேமிக்கப்பட்டது.

193
00:13:45,480 --> 00:13:49,920
மீண்டும், இது மிகவும் நவீன குறியீடுகளால் முழுமையாக மாற்றப்படுகிறது, பொதுவாகப் பயன்படுத்தப்படும் ரீட்-சாலமன்

194
00:13:49,920 --> 00:13:55,060
அல்காரிதம் போன்றது, இது வெடிப்புப் பிழைகளை சிறப்பாகக் கையாளுகிறது, மேலும் இது

195
00:13:55,100 --> 00:13:59,580
ஒரு தொகுதிக்கு அதிக எண்ணிக்கையிலான பிழைகளை எதிர்க்கும் வகையில் மாற்றியமைக்கப்படலாம். .

196
00:13:59,580 --> 00:14:03,000
ஆனால் அது மற்றொரு நேரத்திற்கு ஒரு தலைப்பு.

197
00:14:03,000 --> 00:14:07,660
அவரது தி ஆர்ட் ஆஃப் டூயிங் சயின்ஸ் அண்ட் இன்ஜினியரிங் என்ற புத்தகத்தில், ஹாமிங்

198
00:14:07,660 --> 00:14:10,700
இந்த குறியீட்டின் கண்டுபிடிப்பு எவ்வளவு வளைந்திருந்தது என்பதைப் பற்றி அற்புதமாக நேர்மையாக கூறினார்.

199
00:14:10,700 --> 00:14:15,180
பிட்களை உயர் பரிமாண லட்டியின் பகுதிகளாக ஒழுங்கமைப்பது மற்றும் இது போன்ற விசித்திரமான

200
00:14:15,180 --> 00:14:18,420
விஷயங்களை உள்ளடக்கிய அனைத்து வகையான வெவ்வேறு திட்டங்களையும் அவர் முதலில் முயற்சித்தார்.

201
00:14:18,420 --> 00:14:22,520
ஒரு பிழையின் நிலையை வெளிப்படுத்தும் விதத்தில் சதி செய்ய சமநிலை

202
00:14:22,520 --> 00:14:26,360
காசோலைகளைப் பெறுவது சாத்தியம் என்ற எண்ணம் ஹேமிங்கிற்கு வந்தது, அவர்

203
00:14:26,360 --> 00:14:30,800
வேறு சில பகுப்பாய்வுகளுக்குப் பிறகு பின்வாங்கி, சரி, என்னால் முடிந்த

204
00:14:30,800 --> 00:14:32,860
திறமையானது எது என்று கேட்டபோதுதான். இதைப் பற்றி சிந்திக்க முடியுமா?

205
00:14:32,860 --> 00:14:36,760
1940 களில் இன்று இருப்பதை விட சமச்சீர் சோதனைகள் அவரது மனதில்

206
00:14:36,760 --> 00:14:42,040
ஏற்கனவே இருந்திருப்பது எவ்வளவு முக்கியம் என்பது குறித்தும் அவர் நேர்மையாக இருந்தார்.

207
00:14:42,040 --> 00:14:46,040
லூயிஸ் பாஸ்டர் மேற்கோள்களை அவர் குறிப்பிடும் இந்த புத்தகம் முழுவதும் அரை

208
00:14:46,040 --> 00:14:49,640
டஜன் முறைகள் உள்ளன, அதிர்ஷ்டம் தயாராக இருக்கும் மனதை ஆதரிக்கிறது.

209
00:14:49,640 --> 00:14:55,120
புத்திசாலித்தனமான யோசனைகள் பெரும்பாலும் பின்னோக்கிப் பார்க்கும்போது ஏமாற்றும் வகையில் எளிமையாகத் தோன்றுகின்றன, இது அவற்றைக் குறைத்து மதிப்பிடுவதை எளிதாக்குகிறது.

210
00:14:55,120 --> 00:14:59,680
இப்போது எனது நேர்மையான நம்பிக்கை என்னவென்றால், ஹேமிங் குறியீடுகள் அல்லது

211
00:14:59,680 --> 00:15:01,820
குறைந்தபட்சம் அத்தகைய குறியீடுகளின் சாத்தியக்கூறுகள் உங்களுக்குத் தெளிவாகத் தெரிகிறது.

212
00:15:01,820 --> 00:15:05,440
ஆனால் அவை உண்மையில் வெளிப்படையானவை என்று நினைத்து உங்களை

213
00:15:05,440 --> 00:15:08,000
நீங்களே ஏமாற்றிக் கொள்ளக்கூடாது, ஏனென்றால் அவை நிச்சயமாக இல்லை.

214
00:15:08,000 --> 00:15:12,080
புத்திசாலித்தனமான யோசனைகள் ஏமாற்றும் வகையில் எளிமையாக இருப்பதற்கான ஒரு காரணம் என்னவென்றால், நாம்

215
00:15:12,080 --> 00:15:17,360
எப்போதும் இறுதி முடிவை மட்டுமே பார்க்கிறோம், குழப்பமாக இருந்ததை சுத்தம் செய்வது,

216
00:15:17,360 --> 00:15:22,400
தவறான திருப்பங்கள் அனைத்தையும் குறிப்பிடாமல், ஒரு சிக்கலின் தொடக்கத்தில் ஆராயக்கூடிய சாத்தியக்கூறுகளின் இடம்

217
00:15:22,400 --> 00:15:23,980
எவ்வளவு பெரியது என்பதை குறைத்து விற்பனை செய்வது. தீர்க்கும் செயல்முறை, அனைத்து.

218
00:15:23,980 --> 00:15:25,280
ஆனால் இது பொதுவாக உண்மை.

219
00:15:25,280 --> 00:15:29,880
சில சிறப்புக் கண்டுபிடிப்புகளுக்கு, நாம் அவற்றைக் குறைத்து மதிப்பிடுவதற்கு

220
00:15:29,880 --> 00:15:31,040
இரண்டாவது, ஆழமான காரணம் இருப்பதாக நான் நினைக்கிறேன்.

221
00:15:31,040 --> 00:15:35,040
பிட்களின் அடிப்படையில் தகவல்களைச் சிந்திப்பது 1948 ஆம் ஆண்டளவில் ஒரு முழுமையான

222
00:15:35,040 --> 00:15:39,400
கோட்பாடாக ஒன்றிணைந்தது, தகவல் கோட்பாட்டில் கிளாட் ஷானனின் செமினல் பேப்பர்.

223
00:15:39,400 --> 00:15:43,400
ஹாமிங் தனது வழிமுறையை உருவாக்கியபோது இது அடிப்படையில் ஒத்துப்போனது.

224
00:15:43,440 --> 00:15:47,300
ஒரு குறிப்பிட்ட அர்த்தத்தில், பிட் ஃபிளிப்புகளின் நிகழ்தகவு எவ்வளவு அதிகமாக

225
00:15:47,300 --> 00:15:52,080
இருந்தாலும், குறைந்தபட்சம் கோட்பாட்டில், திறமையான பிழை திருத்தம் எப்போதும்

226
00:15:52,080 --> 00:15:53,920
சாத்தியமாகும் என்பதைக் காட்டிய அதே அடிப்படைக் கட்டுரை இதுவாகும்.

227
00:15:53,920 --> 00:15:58,120
ஷானனும் ஹாமிங்கும், பெல் லேப்ஸில் ஒரு அலுவலகத்தைப் பகிர்ந்து கொண்டனர், மிகவும்

228
00:15:58,120 --> 00:16:02,400
வித்தியாசமான விஷயங்களில் பணிபுரிந்த போதிலும், இது இங்கு தற்செயலாகத் தெரியவில்லை.

229
00:16:02,400 --> 00:16:06,960
பல தசாப்தங்களாக வேகமாக முன்னேறி, இந்த நாட்களில், நம்மில் பலர் பிட்கள் மற்றும் தகவல்களைப்

230
00:16:06,960 --> 00:16:13,080
பற்றி சிந்திப்பதில் மூழ்கிவிட்டோம், இந்த சிந்தனை முறை எவ்வளவு வித்தியாசமானது என்பதைக் கவனிப்பது எளிது.

231
00:16:13,080 --> 00:16:17,920
முரண்பாடாக, வருங்கால சந்ததியினர் நினைக்கும் வழிகளை மிக ஆழமாக வடிவமைக்கும் கருத்துக்கள்,

232
00:16:17,920 --> 00:16:22,640
அந்த எதிர்கால சந்ததியினருக்கு அவை உண்மையில் இருப்பதை விட எளிமையாக இருக்கும்.

