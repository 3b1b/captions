1
00:00:00,000 --> 00:00:03,120
இங்குள்ள அனைவரும் பாகம் 1ல் இருந்து வந்தவர்கள் என்று எண்ணுகிறேன்.

2
00:00:03,120 --> 00:00:07,657
நாங்கள் ஹேமிங் குறியீடுகளைப் பற்றி பேசிக் கொண்டிருந்தோம், பெரும்பாலான

3
00:00:07,657 --> 00:00:12,520
பிட்கள் அர்த்தமுள்ள செய்தியைக் கொண்டு செல்லும் தரவுத் தொகுதியை உருவாக்கும்

4
00:00:12,520 --> 00:00:17,122
ஒரு வழி பிட் அல்லது ஒரு பணிநீக்கம் பிட், இந்த பிளாக்கில் உள்ள எதையும்,

5
00:00:17,122 --> 00:00:21,920
ஒரு பெறுநரால் பிழை இருப்பதை அடையாளம் காண முடியும், அதை எவ்வாறு சரிசெய்வது.

6
00:00:21,920 --> 00:00:25,802
அங்கு வழங்கப்பட்ட அடிப்படை யோசனையானது, பிழைக்கான உங்கள் வழியை பைனரி

7
00:00:25,802 --> 00:00:29,800
தேடுவதற்கு பல சமநிலை சரிபார்ப்புகளை எவ்வாறு பயன்படுத்துவது என்பதுதான்.

8
00:00:29,800 --> 00:00:32,610
அந்த வீடியோவில், ஹேமிங் குறியீடுகளை முடிந்தவரை மீண்டும்

9
00:00:32,610 --> 00:00:35,420
கண்டுபிடிக்கக்கூடியதாக உணர வைப்பதே குறிக்கோளாக இருந்தது.

10
00:00:35,420 --> 00:00:38,392
ஆனால் மென்பொருளில் அல்லது வன்பொருளில் இதை நடைமுறைப்படுத்துவது பற்றி

11
00:00:38,392 --> 00:00:41,103
நீங்கள் சிந்திக்கத் தொடங்கும்போது, இந்த குறியீடுகள் உண்மையில்

12
00:00:41,103 --> 00:00:44,120
எவ்வளவு நேர்த்தியானவை என்பதை அந்த ஃப்ரேமிங் உண்மையில் குறைத்துவிடும்.

13
00:00:44,120 --> 00:00:47,569
சாத்தியமான அனைத்து பிழை இருப்பிடங்களையும் கண்காணிக்கும் ஒரு வழிமுறையை நீங்கள்

14
00:00:47,569 --> 00:00:50,975
எழுத வேண்டும் என்று நீங்கள் நினைக்கலாம் மற்றும் ஒவ்வொரு சரிபார்ப்பிலும் அந்த

15
00:00:50,975 --> 00:00:54,160
குழுவை பாதியாக குறைக்கலாம், ஆனால் அது உண்மையில் வழி, அதை விட எளிமையானது.

16
00:00:54,160 --> 00:00:57,550
கடந்த வீடியோவில் நாங்கள் செய்த நான்கு சமநிலை சரிபார்ப்புகளுக்கான

17
00:00:57,550 --> 00:01:01,201
பதில்களை, ஆம் மற்றும் இல்லை என்பதற்குப் பதிலாக 1கள் மற்றும் 0கள் எனப்

18
00:01:01,201 --> 00:01:04,800
படித்தால், அது பைனரியில் உள்ள பிழையின் நிலையை உண்மையில் விவரிக்கிறது.

19
00:01:04,800 --> 00:01:08,566
எடுத்துக்காட்டாக, பைனரியில் உள்ள எண் 7 0111 போல்

20
00:01:08,566 --> 00:01:12,640
தெரிகிறது, இது 4 கூட்டல் 2 கூட்டல் 1 என்று கூறுகிறது.

21
00:01:12,640 --> 00:01:17,580
மற்றும் நிலை 7 எங்கு அமர்ந்திருக்கிறது என்பதைக் கவனியுங்கள், இது எங்கள் சமத்துவக்

22
00:01:17,580 --> 00:01:22,280
குழுக்களில் முதலாவது மற்றும் இரண்டாவது மற்றும் மூன்றாவது, ஆனால் கடைசியாக அல்ல.

23
00:01:22,280 --> 00:01:25,309
எனவே அந்த நான்கு காசோலைகளின் முடிவுகளை கீழிருந்து

24
00:01:25,309 --> 00:01:28,520
மேல் வரை படிப்பது பிழையின் நிலையை வெளிப்படுத்துகிறது.

25
00:01:28,520 --> 00:01:31,477
எடுத்துக்காட்டு 7 இல் சிறப்பு எதுவும் இல்லை, இது பொதுவாக வேலை

26
00:01:31,477 --> 00:01:34,005
செய்கிறது, மேலும் இது வன்பொருளில் முழு திட்டத்தையும்

27
00:01:34,005 --> 00:01:37,440
செயல்படுத்துவதற்கான தர்க்கத்தை அதிர்ச்சியூட்டும் வகையில் எளிதாக்குகிறது.

28
00:01:37,440 --> 00:01:41,902
இப்போது இந்த மேஜிக் ஏன் நடக்கிறது என்பதைப் பார்க்க விரும்பினால், இந்த 16 இன்டெக்ஸ்

29
00:01:41,902 --> 00:01:46,257
லேபிள்களை எங்கள் நிலைகளுக்கு எடுத்துக் கொள்ளுங்கள், ஆனால் அவற்றை அடிப்படை 10 இல்

30
00:01:46,257 --> 00:01:50,720
எழுதுவதற்குப் பதிலாக, 0000 முதல் 1111 வரை இயங்கும் பைனரியில் அனைத்தையும் எழுதுவோம்.

31
00:01:50,720 --> 00:01:54,393
இந்த பைனரி லேபிள்களை அவற்றின் பெட்டிகளில் மீண்டும் வைக்கும்போது, அவை

32
00:01:54,393 --> 00:01:58,440
உண்மையில் அனுப்பப்படும் தரவுகளிலிருந்து வேறுபட்டவை என்பதை வலியுறுத்துகிறேன்.

33
00:01:58,440 --> 00:02:01,217
நான்கு சமத்துவக் குழுக்கள் எங்கிருந்து வந்தன என்பதைப் புரிந்துகொள்ள

34
00:02:01,217 --> 00:02:04,200
உங்களுக்கும் எனக்கும் உதவும் ஒரு கருத்தியல் லேபிளைத் தவிர வேறொன்றுமில்லை.

35
00:02:04,200 --> 00:02:08,930
நாம் பார்க்கும் அனைத்தும் பைனரியில் விவரிக்கப்படுவதன் நேர்த்தியானது, நாம் பார்க்கும்

36
00:02:08,930 --> 00:02:13,160
அனைத்தும் பைனரியில் விவரிக்கப்பட வேண்டும் என்ற குழப்பத்தால் குறைக்கப்படலாம்.

37
00:02:13,160 --> 00:02:15,040
இருந்தாலும் அது மதிப்புக்குரியது.

38
00:02:15,040 --> 00:02:19,916
இந்த லேபிள்கள் அனைத்தின் கடைசி பிட்டில் மட்டும் உங்கள் கவனத்தை செலுத்தவும்,

39
00:02:19,916 --> 00:02:24,280
பின்னர் அந்த இறுதி பிட் 1 ஆக இருக்கும் நிலைகளை முன்னிலைப்படுத்தவும்.

40
00:02:24,280 --> 00:02:28,626
நாங்கள் பெறுவது எங்களின் நான்கு சமத்துவக் குழுக்களில் முதன்மையானது,

41
00:02:28,626 --> 00:02:32,589
அதாவது அந்த முதல் காசோலையைக் கேட்பது போல் நீங்கள் விளக்கலாம்,

42
00:02:32,589 --> 00:02:36,680
ஏய், பிழை இருந்தால், அந்த பிழையின் நிலையில் இறுதி பிட் 1 உள்ளதா?

43
00:02:36,680 --> 00:02:40,115
இதேபோல், நீங்கள் இரண்டாவது முதல் கடைசி பிட் வரை கவனம் செலுத்தி,

44
00:02:40,115 --> 00:02:43,443
அது 1 ஆக இருக்கும் அனைத்து நிலைகளையும் முன்னிலைப்படுத்தினால்,

45
00:02:43,443 --> 00:02:47,040
எங்கள் திட்டத்தில் இருந்து இரண்டாவது பாரிட்டி குழுவைப் பெறுவீர்கள்.

46
00:02:47,040 --> 00:02:51,749
வேறு வார்த்தைகளில் கூறுவதானால், அந்த இரண்டாவது காசோலை கேட்கிறது, ஏய், மீண்டும்

47
00:02:51,749 --> 00:02:56,160
என்னிடம், பிழை இருந்தால், அந்த நிலையின் இரண்டாவது முதல் கடைசி பிட் 1 தானா?

48
00:02:56,160 --> 00:02:57,160
மற்றும் பல.

49
00:02:57,160 --> 00:03:01,480
மூன்றாவது பாரிட்டி காசோலையானது, மூன்றாவது முதல் கடைசி பிட் வரை

50
00:03:01,480 --> 00:03:05,800
இயக்கப்பட்ட ஒவ்வொரு நிலையையும் உள்ளடக்கியது, மேலும் கடைசியானது

51
00:03:05,800 --> 00:03:10,120
கடைசி எட்டு நிலைகளை உள்ளடக்கியது, அதிகபட்ச ஆர்டர் பிட் 1 ஆகும்.

52
00:03:10,120 --> 00:03:14,491
நாம் முன்பு செய்த அனைத்தும் இந்த நான்கு கேள்விகளுக்குப்

53
00:03:14,491 --> 00:03:19,800
பதிலளிப்பதைப் போன்றது, இது பைனரியில் ஒரு நிலையை உச்சரிப்பது போன்றது.

54
00:03:19,800 --> 00:03:22,080
இது இரண்டு விஷயங்களை தெளிவாக்குகிறது என்று நம்புகிறேன்.

55
00:03:22,080 --> 00:03:24,771
முதலாவதாக, இரண்டின் பெரிய சக்திகளைக் கொண்ட தொகுதி

56
00:03:24,771 --> 00:03:27,140
அளவுகளை முறையாகப் பொதுமைப்படுத்துவது எப்படி.

57
00:03:27,140 --> 00:03:31,111
64 புள்ளிகளை விவரிக்க ஆறு பிட்கள் போல, ஒவ்வொரு நிலையையும் விவரிக்க

58
00:03:31,111 --> 00:03:35,201
அதிக பிட்கள் தேவைப்பட்டால், அந்த பிட்கள் ஒவ்வொன்றும் நாம் சரிபார்க்க

59
00:03:35,201 --> 00:03:38,640
வேண்டிய சமநிலைக் குழுக்களில் ஒன்றை உங்களுக்கு வழங்குகிறது.

60
00:03:38,640 --> 00:03:40,998
மேட் பார்க்கருடன் நான் செய்த சதுரங்கப் புதிரைப் பார்த்த

61
00:03:40,998 --> 00:03:43,400
உங்களில், இவை அனைத்தும் மிகவும் பரிச்சயமானதாக இருக்கலாம்.

62
00:03:43,400 --> 00:03:46,827
இது அதே முக்கிய தர்க்கம், ஆனால் வேறு ஒரு சிக்கலைத் தீர்க்கிறது,

63
00:03:46,827 --> 00:03:49,880
மேலும் 64-சதுர சதுரங்கப் பலகைக்கு இது பயன்படுத்தப்பட்டது.

64
00:03:49,880 --> 00:03:53,911
இது தெளிவுபடுத்தும் இரண்டாவது விஷயம் என்னவென்றால், 1, 2, 4, மற்றும் 8 ஆகிய

65
00:03:53,911 --> 00:03:58,320
இரண்டு சக்திகளின் நிலைகளில் நமது சமநிலை பிட்கள் ஏன் அமர்ந்திருக்கின்றன என்பதுதான்.

66
00:03:58,320 --> 00:04:03,640
பைனரி பிரதிநிதித்துவம் ஒரு பிட் மட்டுமே இயக்கப்பட்டிருக்கும் நிலைகள் இவை.

67
00:04:03,640 --> 00:04:07,918
இதன் பொருள் என்னவென்றால், அந்த ஒவ்வொரு பாரிட்டி பிட்களும்

68
00:04:07,918 --> 00:04:12,640
ஒன்றுக்குள் அமர்ந்து நான்கு சமத்துவக் குழுக்களில் ஒன்று மட்டுமே.

69
00:04:12,640 --> 00:04:19,321
நீங்கள் இதைப் பெரிய எடுத்துக்காட்டுகளிலும் பார்க்கலாம், நீங்கள் எவ்வளவு பெரியதாக

70
00:04:19,321 --> 00:04:25,920
இருந்தாலும், ஒவ்வொரு பாரிட்டி பிட்டும் வசதியாக குழுக்களில் ஒன்றை மட்டுமே தொடும்.

71
00:04:25,920 --> 00:04:29,529
நாம் அதிக நேரத்தைச் செலுத்திய இந்த சமநிலைச் சரிபார்ப்புகள் பைனரியில் உள்ள

72
00:04:29,529 --> 00:04:33,237
பிழையின் நிலையை உச்சரிப்பதற்கான ஒரு புத்திசாலித்தனமான வழியைத் தவிர வேறில்லை

73
00:04:33,237 --> 00:04:36,895
என்பதை நீங்கள் புரிந்துகொண்டவுடன், ஹேமிங்கைப் பற்றி சிந்திக்க வேறு வழியில்

74
00:04:36,895 --> 00:04:40,359
நாம் இணைப்பை உருவாக்கலாம். குறியீடுகள், இது மிகவும் எளிமையானது மற்றும்

75
00:04:40,359 --> 00:04:43,920
நேர்த்தியானது, மேலும் இது ஒரு ஒற்றை வரி குறியீட்டைக் கொண்டு எழுதப்படலாம்.

76
00:04:43,920 --> 00:04:46,200
இது XOR செயல்பாட்டை அடிப்படையாகக் கொண்டது.

77
00:04:46,200 --> 00:04:50,960
XOR, உங்களில் தெரியாதவர்களுக்கு, பிரத்தியேகமான அல்லது.

78
00:04:50,960 --> 00:04:55,060
நீங்கள் இரண்டு பிட்களின் XOR ஐ எடுக்கும்போது, அந்த பிட்களில் ஏதேனும் ஒன்று

79
00:04:55,060 --> 00:04:59,926
இயக்கப்பட்டிருந்தால் அது 1ஐத் தரும், ஆனால் இரண்டும் ஆன் அல்லது ஆஃப் செய்யப்பட்டிருந்தால்

80
00:04:59,926 --> 00:05:00,200
அல்ல.

81
00:05:00,200 --> 00:05:03,760
வித்தியாசமாக சொற்றொடர், இந்த இரண்டு பிட்களின் சமநிலை.

82
00:05:03,760 --> 00:05:07,840
ஒரு கணித நபராக, நான் அதை கூட்டல் மோட் 2 என நினைக்க விரும்புகிறேன்.

83
00:05:07,840 --> 00:05:10,785
நாங்கள் பொதுவாக இரண்டு வெவ்வேறு பிட் சரங்களின் XOR பற்றி

84
00:05:10,785 --> 00:05:14,040
பேசுகிறோம், இது அடிப்படையில் இந்த கூறுகளை கூறு மூலம் செய்கிறது.

85
00:05:14,040 --> 00:05:16,280
இது கூட்டல் போன்றது, ஆனால் நீங்கள் எடுத்துச் செல்லவே இல்லை.

86
00:05:16,280 --> 00:05:19,560
மீண்டும், கணித ரீதியாக அதிக விருப்பமுள்ளவர்கள் இதை இரண்டு

87
00:05:19,560 --> 00:05:23,520
திசையன்களைச் சேர்ப்பது மற்றும் மோட் 2 ஐக் குறைப்பது என்று நினைக்கலாம்.

88
00:05:23,520 --> 00:05:28,602
நீங்கள் இப்போது சில பைத்தானைத் திறந்து, இரண்டு முழு எண்களுக்கு இடையில் கேரட்

89
00:05:28,602 --> 00:05:33,354
செயல்பாட்டைப் பயன்படுத்தினால், இது பேட்டைக்குக் கீழே அந்த எண்களின் பிட்

90
00:05:33,354 --> 00:05:35,400
பிரதிநிதித்துவங்களைச் செய்யும்.

91
00:05:35,400 --> 00:05:43,406
உங்களுக்கும் எனக்கும் முக்கியமான விஷயம் என்னவென்றால், பல வேறுபட்ட பிட் சரங்களின் XORஐ

92
00:05:43,406 --> 00:05:51,320
எடுத்துக்கொள்வது, தனித்தனி குழுக்களின் கேலிக்கூத்துகளை கணக்கிடுவதற்கான ஒரு வழியாகும்.

93
00:05:51,320 --> 00:05:54,341
எங்கள் ஹேமிங் குறியீடு அல்காரிதத்தில் இருந்து பல சமநிலை சரிபார்ப்புகளைப்

94
00:05:54,341 --> 00:05:57,114
பற்றி சிந்திக்க இது எங்களுக்கு மிகவும் எளிமையான வழியை வழங்குகிறது,

95
00:05:57,114 --> 00:05:59,680
ஏனெனில் அனைத்தும் ஒன்றாக ஒரே செயல்பாட்டில் தொகுக்கப்படுகின்றன.

96
00:05:59,680 --> 00:06:02,800
முதல் பார்வையில் இது மிகவும் வித்தியாசமாகத் தெரிந்தாலும்.

97
00:06:02,800 --> 00:06:08,577
குறிப்பாக பைனரியில் 16 நிலைகளை எழுதவும், முன்பு இருந்தது போல், இப்போது

98
00:06:08,577 --> 00:06:14,192
செய்தி பிட் 1 க்கு இயக்கப்பட்ட நிலைகளை முன்னிலைப்படுத்தவும், பின்னர்

99
00:06:14,192 --> 00:06:19,400
இந்த நிலைகளை ஒரு பெரிய நெடுவரிசையில் சேகரித்து XOR ஐ எடுக்கவும்.

100
00:06:19,400 --> 00:06:23,897
இதன் விளைவாக கீழே அமர்ந்திருக்கும் 4 பிட்கள், நாங்கள் அறிந்த மற்றும் விரும்பி

101
00:06:23,897 --> 00:06:28,452
வைத்திருக்கும் 4 சமநிலை சரிபார்ப்புகளைப் போலவே இருக்கும் என்று நீங்கள் ஒருவேளை

102
00:06:28,452 --> 00:06:32,720
யூகிக்கலாம், ஆனால் ஏன் என்று சரியாகச் சிந்திக்க சிறிது நேரம் ஒதுக்குங்கள்.

103
00:06:32,720 --> 00:06:35,925
இந்த கடைசி நெடுவரிசை, எடுத்துக்காட்டாக, கடைசி பிட் 1 ஆக உள்ள அனைத்து

104
00:06:35,925 --> 00:06:39,084
நிலைகளையும் கணக்கிடுகிறது, ஆனால் நாங்கள் ஏற்கனவே ஹைலைட் செய்யப்பட்ட

105
00:06:39,084 --> 00:06:42,057
நிலைகளுக்கு மட்டுமே வரம்பிடப்பட்டுள்ளோம், எனவே இது முதல் சமநிலை

106
00:06:42,057 --> 00:06:45,960
குழுவிலிருந்து எத்தனை ஹைலைட் செய்யப்பட்ட நிலைகள் வந்தன என்பதை திறம்பட கணக்கிடுகிறது.

107
00:06:45,960 --> 00:06:48,520
அதில் ஏதாவது பொருளிருக்கிறதா? அதில் அர்த்தமிருக்கிறதா?

108
00:06:48,520 --> 00:06:52,433
அதேபோல, அடுத்த நெடுவரிசை, இரண்டாவது சமத்துவக் குழுவில் எத்தனை

109
00:06:52,433 --> 00:06:56,347
நிலைகள் உள்ளன, இரண்டாவது முதல் கடைசி பிட் வரையிலான நிலைகள் 1,

110
00:06:56,347 --> 00:07:00,640
மற்றும் அவையும் தனிப்படுத்தப்பட்டவை மற்றும் பலவற்றைக் கணக்கிடுகிறது.

111
00:07:00,640 --> 00:07:04,692
இது உண்மையில் நாம் செய்துகொண்டிருக்கும் அதே விஷயத்தைப்

112
00:07:04,692 --> 00:07:07,640
பற்றிய கண்ணோட்டத்தில் ஒரு சிறிய மாற்றம்.

113
00:07:07,640 --> 00:07:10,000
அது இங்கிருந்து எங்கு செல்கிறது என்பது உங்களுக்குத் தெரியும்.

114
00:07:10,000 --> 00:07:14,950
தொகை 0000 ஆக இருக்கும் என்பதை உறுதிப்படுத்த, சில சிறப்பு

115
00:07:14,950 --> 00:07:19,640
சமநிலை பிட்களை மாற்றுவதற்கு அனுப்புநரின் பொறுப்பாகும்.

116
00:07:19,640 --> 00:07:24,208
இப்போது நாம் இதைப் பெற்றவுடன், கீழே உள்ள இந்த நான்கு பிட்கள் ஏன் பிழையின் நிலையை

117
00:07:24,208 --> 00:07:28,720
நேரடியாக உச்சரிக்கின்றன என்பதைப் பற்றி சிந்திக்க இது ஒரு நல்ல வழியை வழங்குகிறது.

118
00:07:28,720 --> 00:07:32,720
இந்த பிளாக்கில் சில பிட்கள் 0 இலிருந்து 1 ஆக மாறுகிறது என்று வைத்துக்கொள்வோம்.

119
00:07:32,720 --> 00:07:36,636
இதன் பொருள் என்னவென்றால், அந்த பிட்டின் நிலை இப்போது மொத்த

120
00:07:36,636 --> 00:07:40,618
XOR இல் சேர்க்கப்படும், இது கூட்டுத்தொகையை 0 என்பதிலிருந்து

121
00:07:40,618 --> 00:07:44,800
புதிதாக சேர்க்கப்பட்ட இந்த மதிப்பாக மாற்றுகிறது, பிழையின் நிலை.

122
00:07:44,800 --> 00:07:49,800
சற்று குறைவாக வெளிப்படையாக, 1 ஐ 0 ஆக மாற்றும் பிழை இருந்தால் அதுவே உண்மை.

123
00:07:49,800 --> 00:07:54,515
நீங்கள் பார்க்கிறீர்கள், நீங்கள் ஒரு பிட் சரத்தை இரண்டு முறை ஒன்றாகச் சேர்த்தால்,

124
00:07:54,515 --> 00:07:59,000
அது இல்லை என்பதற்கு சமம், அடிப்படையில் இந்த உலகில் 1 கூட்டல் 1 என்பது 0 ஆகும்.

125
00:07:59,000 --> 00:08:02,296
எனவே இந்த நிலையின் நகலை மொத்தத் தொகையில் சேர்ப்பது

126
00:08:02,296 --> 00:08:05,400
நாம் அதை நகர்த்தும்போது அதே விளைவை ஏற்படுத்தும்.

127
00:08:05,400 --> 00:08:13,480
அந்த விளைவு, மீண்டும், இங்கே கீழே உள்ள மொத்த முடிவு பிழையின் நிலையை உச்சரிக்கிறது.

128
00:08:13,480 --> 00:08:16,252
இது எவ்வளவு நேர்த்தியானது என்பதை விளக்குவதற்கு, நான் முன்பு

129
00:08:16,252 --> 00:08:19,116
குறிப்பிட்ட பைதான் குறியீட்டின் ஒரு வரியைக் காட்டுகிறேன், இது

130
00:08:19,116 --> 00:08:22,120
பெறுநரின் முடிவில் கிட்டத்தட்ட எல்லா தர்க்கங்களையும் கைப்பற்றும்.

131
00:08:22,120 --> 00:08:26,540
தரவுத் தொகுதியை உருவகப்படுத்த 16 1s மற்றும் 0s என்ற சீரற்ற வரிசையை உருவாக்குவதன்

132
00:08:26,540 --> 00:08:30,578
மூலம் தொடங்குவோம், நான் அதற்கு பெயர் பிட்களை தருகிறேன், ஆனால் நடைமுறையில்

133
00:08:30,578 --> 00:08:34,452
இது ஒரு அனுப்புநரிடமிருந்து நாம் பெறும் ஒன்று, அதற்கு பதிலாக சீரற்றதாக

134
00:08:34,452 --> 00:08:38,600
இருந்தால், அது 11 டேட்டா பிட்களையும் 5 பேரிட்டி பிட்களையும் கொண்டு செல்லும்.

135
00:08:38,600 --> 00:08:43,481
நான் செயல்பாடு enumerateBits என்று அழைத்தால், அது 0 முதல் 15 வரை இயங்கும் இந்த

136
00:08:43,481 --> 00:08:48,240
விஷயத்தில், அந்த பிட்கள் ஒவ்வொன்றையும் தொடர்புடைய குறியீட்டுடன் இணைப்பதாகும்.

137
00:08:48,240 --> 00:08:52,723
எனவே, இந்த ஜோடிகள் அனைத்தின் மீதும் சுழலும் ஒரு பட்டியலை உருவாக்கினால், i போல

138
00:08:52,723 --> 00:08:57,321
தோற்றமளிக்கும் ஜோடிகள், பின்னர் i மதிப்பை, குறியீட்டை மட்டும் வெளியே இழுத்தால்,

139
00:08:57,321 --> 00:09:01,920
அது அவ்வளவு உற்சாகமாக இல்லை, அந்த குறியீடுகளை 0 முதல் 15 வரை திரும்பப் பெறுவோம்.

140
00:09:01,920 --> 00:09:05,928
ஆனால் பிட் என்றால் மட்டுமே இதைச் செய்ய வேண்டும் என்ற நிபந்தனையைச்

141
00:09:05,928 --> 00:09:09,512
சேர்த்தால், அதாவது அந்த பிட் 1 மற்றும் 0 அல்ல என்றால், அது

142
00:09:09,512 --> 00:09:13,400
தொடர்புடைய பிட் இயக்கப்பட்டிருக்கும் நிலைகளை மட்டும் இழுக்கிறது.

143
00:09:13,400 --> 00:09:20,720
இந்த வழக்கில், அந்த நிலைகள் 0, 4, 6, 9, போன்றவை போல் தெரிகிறது.

144
00:09:20,720 --> 00:09:25,307
நாம் விரும்புவது, அந்த நிலைகள் அனைத்தையும் ஒன்றாகச் சேகரிக்க வேண்டும்,

145
00:09:25,307 --> 00:09:29,960
இயக்கப்பட்ட பிட்களின் நிலைகள், பின்னர் அவற்றை ஒன்றாக XOR செய்ய வேண்டும்.

146
00:09:29,960 --> 00:09:33,960
பைத்தானில் இதைச் செய்ய, முதலில் இரண்டு பயனுள்ள செயல்பாடுகளை இறக்குமதி செய்கிறேன்.

147
00:09:33,960 --> 00:09:36,731
அந்த வகையில் நாம் இந்த பட்டியலில் குறைக்க() என்று அழைக்கலாம்

148
00:09:36,731 --> 00:09:39,140
மற்றும் அதை குறைக்க XOR செயல்பாட்டைப் பயன்படுத்தலாம்.

149
00:09:39,140 --> 00:09:44,840
இது அடிப்படையில் பட்டியலில் அதன் வழியை உண்கிறது, வழியில் XOR களை எடுத்துக்கொள்கிறது.

150
00:09:44,840 --> 00:09:48,911
நீங்கள் விரும்பினால், XOR செயல்பாட்டை எங்கிருந்தும்

151
00:09:48,911 --> 00:09:52,200
இறக்குமதி செய்யாமல் வெளிப்படையாக எழுதலாம்.

152
00:09:52,200 --> 00:09:57,099
எனவே தற்போது 16 பிட்களின் சீரற்ற தொகுதியில் இதைச் செய்தால்,

153
00:09:57,099 --> 00:10:02,080
அது 9 ஐத் தருகிறது, இதில் பைனரி பிரதிநிதித்துவம் 1001 உள்ளது.

154
00:10:02,080 --> 00:10:06,334
நாங்கள் அதை இங்கே செய்ய மாட்டோம், ஆனால் அனுப்புநர் அந்த பைனரி பிரதிநிதித்துவத்தைப்

155
00:10:06,334 --> 00:10:10,126
பயன்படுத்தி நான்கு பேரிட்டி பிட்களை தேவைக்கேற்ப அமைக்கும் ஒரு செயல்பாட்டை

156
00:10:10,126 --> 00:10:13,919
நீங்கள் எழுதலாம், இறுதியில் இந்தத் தொகுதியை பிட்களின் முழுப் பட்டியலிலும்

157
00:10:13,919 --> 00:10:17,200
இந்த குறியீட்டு வரியை இயக்கும் நிலைக்கு கொண்டு செல்லலாம். ஒரு 0.

158
00:10:17,200 --> 00:10:20,200
இது நன்கு தயாரிக்கப்பட்ட தொகுதியாகக் கருதப்படும்.

159
00:10:20,200 --> 00:10:23,733
நல்ல விஷயம் என்னவென்றால், இந்த பட்டியலில் உள்ள பிட்களில் ஏதேனும் ஒன்றை

160
00:10:23,733 --> 00:10:27,415
நாம் மாற்றினால், இரைச்சலில் இருந்து ஒரு சீரற்ற பிழையை உருவகப்படுத்தினால்,

161
00:10:27,415 --> 00:10:30,600
நீங்கள் இதே குறியீட்டை இயக்கினால், அது அந்த பிழையை அச்சிடுகிறது.

162
00:10:30,600 --> 00:10:31,920
அது சுத்தமாக இல்லையா?

163
00:10:31,920 --> 00:10:37,712
இந்தத் தொகுதியை நீங்கள் நீல நிறத்தில் இருந்து பெறலாம், இந்த ஒற்றை வரியை அதில் இயக்கலாம்,

164
00:10:37,712 --> 00:10:42,920
மேலும் அது பிழையின் நிலையை தானாகவே துப்பிவிடும், அல்லது எதுவும் இல்லை என்றால் 0.

165
00:10:42,920 --> 00:10:45,520
இங்கே அளவு 16 பற்றி சிறப்பு எதுவும் இல்லை.

166
00:10:45,520 --> 00:10:52,280
உங்களிடம் 256 பிட்களின் பட்டியல் இருந்தால் அதே வரி குறியீடு வேலை செய்யும்.

167
00:10:52,280 --> 00:10:56,810
2-பிட் பிழைகளைக் கண்டறிய மெட்டா பாரிட்டி செக் செய்வது போன்ற கூடுதல் குறியீடுகள்

168
00:10:56,810 --> 00:11:01,115
இங்கே எழுத வேண்டும் என்று சொல்லத் தேவையில்லை, ஆனால் எங்கள் திட்டத்தில் உள்ள

169
00:11:01,115 --> 00:11:05,080
அனைத்து முக்கிய தர்க்கங்களும் ஒரே XOR குறைப்புக்கு வரும் என்பது யோசனை.

170
00:11:05,080 --> 00:11:09,907
இப்போது, பைனரி மற்றும் XORகள் மற்றும் பொதுவாக மென்பொருளில் உள்ள உங்கள் வசதியைப்

171
00:11:09,907 --> 00:11:14,673
பொறுத்து, இந்த முன்னோக்கைக் கொஞ்சம் குழப்பமாகவோ அல்லது மிகவும் நேர்த்தியாகவும்

172
00:11:14,673 --> 00:11:19,320
எளிமையாகவும் நாம் ஏன் தொடங்கவில்லை என்று நீங்கள் ஆச்சரியப்படுகிறீர்கள். -போ.

173
00:11:19,320 --> 00:11:23,323
தளர்வாகச் சொன்னால், வன்பொருளில் ஹேமிங் குறியீடுகளை நேரடியாகச் செயல்படுத்தும் போது,

174
00:11:23,323 --> 00:11:27,183
மல்டிபிள் பேரிட்டி காசோலைக் கண்ணோட்டத்தைப் பற்றி சிந்திக்க எளிதானது, மேலும் XOR

175
00:11:27,183 --> 00:11:31,380
முன்னோக்கு மென்பொருளில், உயர் மட்டத்தில் இருந்து அதைச் செய்யும்போது சிந்திக்க எளிதானது.

176
00:11:31,380 --> 00:11:35,025
முதலாவது கையால் செய்வது மிகவும் எளிதானது, மேலும் இவை அனைத்திற்கும்

177
00:11:35,025 --> 00:11:38,942
அடிப்படையான உள்ளுணர்வை ஏற்படுத்துவதில் இது ஒரு சிறந்த வேலையைச் செய்யும்

178
00:11:38,942 --> 00:11:42,968
என்று நான் நினைக்கிறேன், அதாவது ஒரு பிழையைக் கண்டறிவதற்குத் தேவையான தகவல்

179
00:11:42,968 --> 00:11:46,722
தொகுதியின் அளவின் பதிவுடன் தொடர்புடையது. , அல்லது வேறு வார்த்தைகளில்

180
00:11:46,722 --> 00:11:51,020
கூறுவதானால், தொகுதி அளவு இரட்டிப்பாகும் போது அது ஒரு நேரத்தில் ஒரு பிட் வளரும்.

181
00:11:51,020 --> 00:11:53,832
இங்கே பொருத்தமான உண்மை என்னவென்றால், அந்த தகவல் நமக்கு

182
00:11:53,832 --> 00:11:56,440
எவ்வளவு பணிநீக்கம் தேவை என்பதை நேரடியாக ஒத்துள்ளது.

183
00:11:56,440 --> 00:12:00,291
ஒரு செய்தியை பிழைகளைத் தடுக்கும் வகையில் உருவாக்குவதைப் பற்றி முதலில் நினைக்கும்

184
00:12:00,291 --> 00:12:03,858
போது, பெரும்பாலானவர்களின் மொக்கை எதிர்வினைக்கு எதிராக அதுதான் இயங்குகிறது,

185
00:12:03,858 --> 00:12:07,520
பொதுவாக முழுச் செய்தியையும் நகலெடுப்பதுதான் மனதில் தோன்றும் முதல் உள்ளுணர்வு.

186
00:12:07,520 --> 00:12:10,973
பின்னர், இந்த முழு வேறு வழியும் உள்ளது, சில சமயங்களில் ஹேமிங் குறியீடுகள்

187
00:12:10,973 --> 00:12:14,800
வழங்கப்படுகின்றன, அங்கு நீங்கள் செய்தியை ஒரு பெரிய மேட்ரிக்ஸால் பெருக்குகிறீர்கள்.

188
00:12:14,800 --> 00:12:18,332
இது ஒருவகையில் நன்றாக இருக்கிறது, ஏனெனில் இது நேரியல் குறியீடுகளின் பரந்த

189
00:12:18,332 --> 00:12:21,865
குடும்பத்துடன் தொடர்புடையது, ஆனால் அது எங்கிருந்து வருகிறது அல்லது எப்படி

190
00:12:21,865 --> 00:12:25,160
அளவிடுகிறது என்பதற்கான உள்ளுணர்வைக் கொடுக்கவில்லை என்று நினைக்கிறேன்.

191
00:12:25,160 --> 00:12:28,656
மற்றும் அளவிடுதல் பற்றி பேசுகையில், தொகுதி அளவை அதிகரிக்கும்போது மட்டுமே

192
00:12:28,656 --> 00:12:32,200
இந்த திட்டத்தின் செயல்திறன் சிறப்பாக இருக்கும் என்பதை நீங்கள் கவனிக்கலாம்.

193
00:12:32,200 --> 00:12:37,775
எடுத்துக்காட்டாக, 256 பிட்கள் மூலம், நீங்கள் பணிநீக்கத்திற்கு அந்த இடத்தில் 3% மட்டுமே

194
00:12:37,775 --> 00:12:43,480
பயன்படுத்துகிறீர்கள் என்பதை நாங்கள் பார்த்தோம், மேலும் அது அங்கிருந்து சிறப்பாக வருகிறது.

195
00:12:43,480 --> 00:12:49,040
சமநிலை பிட்களின் எண்ணிக்கை ஒவ்வொன்றாக வளரும்போது, தொகுதி அளவு இரட்டிப்பாகிறது.

196
00:12:49,040 --> 00:12:52,990
நீங்கள் அதை ஒரு தீவிரத்திற்கு எடுத்துக் கொண்டால், நீங்கள் ஒரு மில்லியன் பிட்கள் கொண்ட

197
00:12:52,990 --> 00:12:56,941
ஒரு தொகுதியை வைத்திருக்கலாம், அங்கு நீங்கள் உண்மையில் உங்கள் சமநிலை சரிபார்ப்புகளுடன்

198
00:12:56,941 --> 00:13:00,800
20 கேள்விகளை விளையாடுவீர்கள், மேலும் அது 21 சமநிலை பிட்களை மட்டுமே பயன்படுத்துகிறது.

199
00:13:00,800 --> 00:13:04,516
ஒரு மில்லியன் பிட்களைப் பார்த்து ஒரு பிழையைக் கண்டறிவதைப் பற்றி

200
00:13:04,516 --> 00:13:08,640
சிந்திக்க நீங்கள் பின்வாங்கினால், அது உண்மையிலேயே பைத்தியமாக உணர்கிறது.

201
00:13:08,640 --> 00:13:13,701
பிரச்சனை, நிச்சயமாக, ஒரு பெரிய தொகுதியுடன், ஒன்று அல்லது இரண்டு பிட் பிழைகளை பார்க்கும்

202
00:13:13,701 --> 00:13:18,360
நிகழ்தகவு அதிகரிக்கிறது, மேலும் ஹேமிங் குறியீடுகள் அதைத் தாண்டி எதையும் கையாளாது.

203
00:13:18,360 --> 00:13:22,744
எனவே நடைமுறையில், நீங்கள் விரும்புவது சரியான அளவைக் கண்டுபிடிப்பதாகும்,

204
00:13:22,744 --> 00:13:26,520
இதனால் பல பிட் ஃபிளிப்புகளின் நிகழ்தகவு மிக அதிகமாக இருக்காது.

205
00:13:26,520 --> 00:13:31,386
மேலும், நடைமுறையில், பிழைகள் சிறிய வெடிப்புகளில் வருகின்றன, இது ஒரு தொகுதியை

206
00:13:31,386 --> 00:13:36,000
முற்றிலுமாக அழித்துவிடும், எனவே பல்வேறு தொகுதிகளில் ஒரு வெடிப்பு பிழைகளை

207
00:13:36,000 --> 00:13:40,866
பரப்ப உதவும் ஒரு பொதுவான தந்திரம், அந்த தொகுதிகளை, இது போன்று, அவை உருவாகும்

208
00:13:40,866 --> 00:13:45,480
முன், பின்னிணைக்க வேண்டும். வெளியே அனுப்பப்பட்டது அல்லது சேமிக்கப்பட்டது.

209
00:13:45,480 --> 00:13:49,553
மீண்டும், இது மிகவும் நவீன குறியீடுகளால் முழுமையாக மாற்றப்படுகிறது, பொதுவாகப்

210
00:13:49,553 --> 00:13:53,940
பயன்படுத்தப்படும் ரீட்-சாலமன் அல்காரிதம் போன்றது, இது வெடிப்புப் பிழைகளை சிறப்பாகக்

211
00:13:53,940 --> 00:13:58,483
கையாளுகிறது, மேலும் இது ஒரு தொகுதிக்கு அதிக எண்ணிக்கையிலான பிழைகளை எதிர்க்கும் வகையில்

212
00:13:58,483 --> 00:13:59,580
மாற்றியமைக்கப்படலாம்.

213
00:13:59,580 --> 00:14:03,000
ஆனால் அது மற்றொரு நேரத்திற்கு ஒரு தலைப்பு.

214
00:14:03,000 --> 00:14:06,656
அவரது தி ஆர்ட் ஆஃப் டூயிங் சயின்ஸ் அண்ட் இன்ஜினியரிங் என்ற புத்தகத்தில், ஹாமிங் இந்த

215
00:14:06,656 --> 00:14:10,312
குறியீட்டின் கண்டுபிடிப்பு எவ்வளவு வளைந்திருந்தது என்பதைப் பற்றி அற்புதமாக நேர்மையாக

216
00:14:10,312 --> 00:14:10,700
கூறினார்.

217
00:14:10,700 --> 00:14:14,515
பிட்களை உயர் பரிமாண லட்டியின் பகுதிகளாக ஒழுங்கமைப்பது மற்றும் இது போன்ற விசித்திரமான

218
00:14:14,515 --> 00:14:18,420
விஷயங்களை உள்ளடக்கிய அனைத்து வகையான வெவ்வேறு திட்டங்களையும் அவர் முதலில் முயற்சித்தார்.

219
00:14:18,420 --> 00:14:22,908
ஒரு பிழையின் நிலையை வெளிப்படுத்தும் விதத்தில் சதி செய்ய சமநிலை காசோலைகளைப் பெறுவது

220
00:14:22,908 --> 00:14:27,451
சாத்தியம் என்ற எண்ணம் ஹேமிங்கிற்கு வந்தது, அவர் வேறு சில பகுப்பாய்வுகளுக்குப் பிறகு

221
00:14:27,451 --> 00:14:31,832
பின்வாங்கி, சரி, என்னால் முடிந்த திறமையானது எது என்று கேட்டபோதுதான். இதைப் பற்றி

222
00:14:31,832 --> 00:14:32,860
சிந்திக்க முடியுமா?

223
00:14:32,860 --> 00:14:37,228
1940 களில் இன்று இருப்பதை விட சமச்சீர் சோதனைகள் அவரது மனதில் ஏற்கனவே

224
00:14:37,228 --> 00:14:42,040
இருந்திருப்பது எவ்வளவு முக்கியம் என்பது குறித்தும் அவர் நேர்மையாக இருந்தார்.

225
00:14:42,040 --> 00:14:45,840
லூயிஸ் பாஸ்டர் மேற்கோள்களை அவர் குறிப்பிடும் இந்த புத்தகம் முழுவதும்

226
00:14:45,840 --> 00:14:49,640
அரை டஜன் முறைகள் உள்ளன, அதிர்ஷ்டம் தயாராக இருக்கும் மனதை ஆதரிக்கிறது.

227
00:14:49,640 --> 00:14:52,294
புத்திசாலித்தனமான யோசனைகள் பெரும்பாலும் பின்னோக்கிப் பார்க்கும்போது ஏமாற்றும்

228
00:14:52,294 --> 00:14:55,120
வகையில் எளிமையாகத் தோன்றுகின்றன, இது அவற்றைக் குறைத்து மதிப்பிடுவதை எளிதாக்குகிறது.

229
00:14:55,120 --> 00:14:58,196
இப்போது எனது நேர்மையான நம்பிக்கை என்னவென்றால், ஹேமிங் குறியீடுகள் அல்லது

230
00:14:58,196 --> 00:15:01,820
குறைந்தபட்சம் அத்தகைய குறியீடுகளின் சாத்தியக்கூறுகள் உங்களுக்குத் தெளிவாகத் தெரிகிறது.

231
00:15:01,820 --> 00:15:04,755
ஆனால் அவை உண்மையில் வெளிப்படையானவை என்று நினைத்து உங்களை

232
00:15:04,755 --> 00:15:08,000
நீங்களே ஏமாற்றிக் கொள்ளக்கூடாது, ஏனென்றால் அவை நிச்சயமாக இல்லை.

233
00:15:08,000 --> 00:15:11,099
புத்திசாலித்தனமான யோசனைகள் ஏமாற்றும் வகையில் எளிமையாக இருப்பதற்கான ஒரு

234
00:15:11,099 --> 00:15:14,199
காரணம் என்னவென்றால், நாம் எப்போதும் இறுதி முடிவை மட்டுமே பார்க்கிறோம்,

235
00:15:14,199 --> 00:15:17,125
குழப்பமாக இருந்ததை சுத்தம் செய்வது, தவறான திருப்பங்கள் அனைத்தையும்

236
00:15:17,125 --> 00:15:20,312
குறிப்பிடாமல், ஒரு சிக்கலின் தொடக்கத்தில் ஆராயக்கூடிய சாத்தியக்கூறுகளின்

237
00:15:20,312 --> 00:15:23,980
இடம் எவ்வளவு பெரியது என்பதை குறைத்து விற்பனை செய்வது. தீர்க்கும் செயல்முறை, அனைத்து.

238
00:15:23,980 --> 00:15:25,280
ஆனால் இது பொதுவாக உண்மை.

239
00:15:25,280 --> 00:15:27,955
சில சிறப்புக் கண்டுபிடிப்புகளுக்கு, நாம் அவற்றைக் குறைத்து

240
00:15:27,955 --> 00:15:31,040
மதிப்பிடுவதற்கு இரண்டாவது, ஆழமான காரணம் இருப்பதாக நான் நினைக்கிறேன்.

241
00:15:31,040 --> 00:15:35,356
பிட்களின் அடிப்படையில் தகவல்களைச் சிந்திப்பது 1948 ஆம் ஆண்டளவில் ஒரு முழுமையான

242
00:15:35,356 --> 00:15:39,400
கோட்பாடாக ஒன்றிணைந்தது, தகவல் கோட்பாட்டில் கிளாட் ஷானனின் செமினல் பேப்பர்.

243
00:15:39,400 --> 00:15:43,440
ஹாமிங் தனது வழிமுறையை உருவாக்கியபோது இது அடிப்படையில் ஒத்துப்போனது.

244
00:15:43,440 --> 00:15:46,754
ஒரு குறிப்பிட்ட அர்த்தத்தில், பிட் ஃபிளிப்புகளின் நிகழ்தகவு எவ்வளவு

245
00:15:46,754 --> 00:15:50,312
அதிகமாக இருந்தாலும், குறைந்தபட்சம் கோட்பாட்டில், திறமையான பிழை திருத்தம்

246
00:15:50,312 --> 00:15:53,920
எப்போதும் சாத்தியமாகும் என்பதைக் காட்டிய அதே அடிப்படைக் கட்டுரை இதுவாகும்.

247
00:15:53,920 --> 00:15:58,133
ஷானனும் ஹாமிங்கும், பெல் லேப்ஸில் ஒரு அலுவலகத்தைப் பகிர்ந்து கொண்டனர், மிகவும்

248
00:15:58,133 --> 00:16:02,400
வித்தியாசமான விஷயங்களில் பணிபுரிந்த போதிலும், இது இங்கு தற்செயலாகத் தெரியவில்லை.

249
00:16:02,400 --> 00:16:05,866
பல தசாப்தங்களாக வேகமாக முன்னேறி, இந்த நாட்களில், நம்மில் பலர்

250
00:16:05,866 --> 00:16:09,389
பிட்கள் மற்றும் தகவல்களைப் பற்றி சிந்திப்பதில் மூழ்கிவிட்டோம்,

251
00:16:09,389 --> 00:16:13,080
இந்த சிந்தனை முறை எவ்வளவு வித்தியாசமானது என்பதைக் கவனிப்பது எளிது.

252
00:16:13,080 --> 00:16:15,677
முரண்பாடாக, வருங்கால சந்ததியினர் நினைக்கும் வழிகளை மிக ஆழமாக வடிவமைக்கும் கருத்துக்கள்,

253
00:16:15,677 --> 00:16:17,920
அந்த எதிர்கால சந்ததியினருக்கு அவை உண்மையில் இருப்பதை விட எளிமையாக இருக்கும்.

