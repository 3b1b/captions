1
00:00:00,000 --> 00:00:02,560
मी असे गृहीत धरत आहे की येथे प्रत्येकजण भाग 1 पासून येत आहे.

2
00:00:03,060 --> 00:00:07,538
आम्ही हॅमिंग कोडबद्दल बोलत होतो, डेटाचा एक ब्लॉक तयार करण्याचा एक मार्ग जिथे बहुतेक 

3
00:00:07,538 --> 00:00:11,856
बिट एक अर्थपूर्ण संदेश देतात, तर काही इतर एक प्रकारचा रिडंडंसी म्हणून काम करतात, 

4
00:00:11,856 --> 00:00:15,908
अशा प्रकारे की जर काही बिट फ्लिप झाले तर एकतर संदेश बिट किंवा रिडंडंसी बिट, 

5
00:00:15,908 --> 00:00:20,280
या ब्लॉकमधील काहीही, एक प्राप्तकर्ता त्रुटी आहे हे ओळखण्यास सक्षम असेल आणि त्याचे 

6
00:00:20,280 --> 00:00:21,240
निराकरण कसे करावे.

7
00:00:21,880 --> 00:00:24,309
तेथे सादर केलेली मूलभूत कल्पना ही होती की त्रुटीकडे 

8
00:00:24,309 --> 00:00:27,160
जाण्यासाठी बायनरी शोधण्यासाठी एकाधिक पॅरिटी चेक कसे वापरायचे.

9
00:00:28,980 --> 00:00:31,997
त्या व्हिडिओमध्ये हॅमिंग कोड शक्य तितक्या हँड्स-ऑन 

10
00:00:31,997 --> 00:00:34,600
आणि पुन्हा शोधण्यायोग्य वाटणे हे ध्येय होते.

11
00:00:35,180 --> 00:00:39,400
परंतु जसे तुम्ही हे सॉफ्टवेअर किंवा हार्डवेअरमध्ये प्रत्यक्षात अंमलात आणण्याचा 

12
00:00:39,400 --> 00:00:43,460
विचार करू लागता, ते फ्रेमिंग हे कोड्स खरोखर किती सुंदर आहेत हे कमी करू शकते.

13
00:00:43,920 --> 00:00:46,992
तुम्हाला असे वाटेल की तुम्हाला एखादे अल्गोरिदम लिहावे लागेल जे 

14
00:00:46,992 --> 00:00:50,260
सर्व संभाव्य त्रुटी स्थानांचा मागोवा ठेवेल आणि प्रत्येक चेकसह त्या 

15
00:00:50,260 --> 00:00:53,480
गटाला अर्धा कापून टाकेल, परंतु प्रत्यक्षात ते त्यापेक्षा सोपे आहे.

16
00:00:53,940 --> 00:00:59,105
शेवटच्या व्हिडिओमध्ये आम्ही केलेल्या चार पॅरिटी चेकची उत्तरे तुम्ही होय आणि नाही 

17
00:00:59,105 --> 00:01:04,080
ऐवजी 1s आणि 0s अशी वाचली, तर ते बायनरीमधील त्रुटीचे स्थान अक्षरशः स्पष्ट करते.

18
00:01:04,780 --> 00:01:11,260
उदाहरणार्थ, बायनरी मधील 7 ही संख्या 0111 सारखी दिसते, मूलत: ते 4 अधिक 2 अधिक 1 असे म्हणते.

19
00:01:12,540 --> 00:01:17,627
आणि लक्षात घ्या की स्थान 7 कुठे बसते, ते आमच्या समता गटांपैकी पहिल्यावर, 

20
00:01:17,627 --> 00:01:21,740
आणि दुसऱ्या आणि तिसऱ्याला प्रभावित करते, परंतु शेवटचे नाही.

21
00:01:22,220 --> 00:01:27,540
त्यामुळे तळापासून वरपर्यंत त्या चार तपासण्यांचे निकाल वाचून त्रुटीची स्थिती स्पष्ट होते.

22
00:01:28,320 --> 00:01:32,070
उदाहरण 7 मध्ये विशेष काही नाही, हे सर्वसाधारणपणे कार्य करते आणि यामुळे 

23
00:01:32,070 --> 00:01:35,820
हार्डवेअरमध्ये संपूर्ण योजना लागू करण्याचे तर्क धक्कादायकपणे सोपे होते.

24
00:01:37,240 --> 00:01:40,383
आता ही जादू का घडते हे जर तुम्हाला पहायचे असेल, 

25
00:01:40,383 --> 00:01:43,592
तर आमच्या पोझिशन्ससाठी ही 16 इंडेक्स लेबले घ्या, 

26
00:01:43,592 --> 00:01:47,587
परंतु त्यांना बेस 10 मध्ये लिहिण्याऐवजी, 0000 ते 1111 पर्यंत 

27
00:01:47,587 --> 00:01:49,880
चालणारे ते सर्व बायनरीमध्ये लिहूया.

28
00:01:50,559 --> 00:01:53,892
जसे आम्ही ही बायनरी लेबले त्यांच्या बॉक्समध्ये परत ठेवतो, 

29
00:01:53,892 --> 00:01:57,800
मी यावर जोर देतो की ते प्रत्यक्षात पाठवलेल्या डेटापेक्षा वेगळे आहेत.

30
00:01:58,320 --> 00:02:00,887
ते चार समानता गट कुठून आले हे तुम्हाला आणि मला समजण्यास 

31
00:02:00,887 --> 00:02:03,500
मदत करण्यासाठी एक संकल्पनात्मक लेबलपेक्षा अधिक काही नाही.

32
00:02:04,140 --> 00:02:08,289
बायनरीमध्ये वर्णन केल्या जाणाऱ्या प्रत्येक गोष्टीचे 

33
00:02:08,289 --> 00:02:12,360
वर्णन आपण पाहत आहोत या संभ्रमामुळे कदाचित कमी होईल.

34
00:02:13,020 --> 00:02:14,120
तो वाचतो आहे, तरी.

35
00:02:14,800 --> 00:02:18,936
तुमचे लक्ष या सर्व लेबल्सच्या शेवटच्या बिट्सवर केंद्रित 

36
00:02:18,936 --> 00:02:23,220
करा आणि नंतर ते स्थान हायलाइट करा जिथे तो अंतिम बिट 1 आहे.

37
00:02:24,240 --> 00:02:27,608
आम्हाला जे मिळते ते आमच्या चार पॅरिटी गटांपैकी पहिले आहे, 

38
00:02:27,608 --> 00:02:31,383
याचा अर्थ तुम्ही त्या पहिल्या चेकचा विचार म्हणून अर्थ लावू शकता, 

39
00:02:31,383 --> 00:02:35,740
अरे, जर एखादी त्रुटी असेल, तर त्या त्रुटीच्या स्थितीतील अंतिम बिट 1 आहे का?

40
00:02:38,200 --> 00:02:42,130
त्याचप्रमाणे, जर तुम्ही सेकंड टू लास्ट बिटवर लक्ष केंद्रित केले आणि 1 असलेल्या 

41
00:02:42,130 --> 00:02:46,160
सर्व पोझिशन्स हायलाइट केल्यास तुम्हाला आमच्या स्कीममधून दुसरा पॅरिटी ग्रुप मिळेल.

42
00:02:46,740 --> 00:02:50,345
दुसऱ्या शब्दांत, तो दुसरा चेक विचारत आहे, अहो, मला पुन्हा, 

43
00:02:50,345 --> 00:02:54,500
जर एखादी त्रुटी असेल, तर त्या स्थितीचा दुसरा टू शेवटचा बिट 1 आहे का?

44
00:02:55,760 --> 00:02:56,900
वगैरे.

45
00:02:57,220 --> 00:03:03,054
तिसरा पॅरिटी चेक प्रत्येक पोझिशनचा कव्हर करतो ज्याचा तिसरा ते शेवटचा बिट चालू 

46
00:03:03,054 --> 00:03:08,740
आहे आणि शेवटच्या आठ पोझिशन्सला कव्हर करते, ज्यांची सर्वोच्च ऑर्डर बिट 1 आहे.

47
00:03:09,740 --> 00:03:14,434
आम्ही याआधी जे काही केले ते या चार प्रश्नांची उत्तरे देण्यासारखेच आहे, 

48
00:03:14,434 --> 00:03:17,740
जे यामधून बायनरीमधील स्थानाचे स्पेलिंग सारखेच आहे.

49
00:03:19,620 --> 00:03:21,480
मला आशा आहे की हे दोन गोष्टी स्पष्ट करेल.

50
00:03:22,040 --> 00:03:24,183
प्रथम म्हणजे दोन मोठ्या शक्ती असलेल्या आकारांना 

51
00:03:24,183 --> 00:03:26,460
ब्लॉक करण्यासाठी पद्धतशीरपणे सामान्यीकरण कसे करावे.

52
00:03:26,960 --> 00:03:29,804
प्रत्येक पोझिशनचे वर्णन करण्यासाठी अधिक बिट्स लागत असल्यास, 

53
00:03:29,804 --> 00:03:32,080
जसे की 64 स्पॉट्सचे वर्णन करण्यासाठी सहा बिट्स, 

54
00:03:32,080 --> 00:03:35,115
तर त्या प्रत्येक बिट्समुळे आपल्याला समानता गटांपैकी एक मिळेल जो 

55
00:03:35,115 --> 00:03:36,680
आपल्याला तपासण्याची आवश्यकता आहे.

56
00:03:38,400 --> 00:03:40,832
तुमच्यापैकी ज्यांनी मी मॅट पार्करसोबत केलेले बुद्धिबळाचे 

57
00:03:40,832 --> 00:03:43,180
कोडे पाहिले त्यांना कदाचित हे सर्व अत्यंत परिचित वाटेल.

58
00:03:43,660 --> 00:03:46,090
हे समान मुख्य तर्क आहे, परंतु वेगळ्या समस्येचे 

59
00:03:46,090 --> 00:03:48,780
निराकरण करते आणि 64-चौरस बुद्धिबळावर लागू केले जाते.

60
00:03:49,880 --> 00:03:53,656
दुसरी गोष्ट मला आशा आहे की हे स्पष्ट करते की आमचे पॅरिटी बिट्स दोन 

61
00:03:53,656 --> 00:03:57,320
पॉवर असलेल्या पोझिशनमध्ये का बसले आहेत, उदाहरणार्थ 1, 2, 4 आणि 8.

62
00:03:58,000 --> 00:04:03,000
ही अशी पोझिशन्स आहेत ज्यांचे बायनरी प्रतिनिधित्व फक्त एक बिट चालू आहे.

63
00:04:03,600 --> 00:04:09,460
याचा अर्थ असा आहे की त्या प्रत्येक पॅरिटी बिट्स चार पॅरिटी गटांपैकी फक्त एकामध्ये बसतात.

64
00:04:12,040 --> 00:04:16,196
आपण हे मोठ्या उदाहरणांमध्ये देखील पाहू शकता, जिथे आपण कितीही मोठे असले तरीही, 

65
00:04:16,196 --> 00:04:19,339
प्रत्येक पॅरिटी बिट सोयीस्करपणे फक्त एका गटाला स्पर्श करते.

66
00:04:25,600 --> 00:04:29,943
एकदा आपण समजून घेतले की या समता तपासण्या ज्यावर आम्ही आमचा बराच वेळ लक्ष केंद्रित 

67
00:04:29,943 --> 00:04:33,863
केला आहे ते बायनरीमधील त्रुटीची स्थिती स्पष्ट करण्याचा एक चतुर मार्ग आहे, 

68
00:04:33,863 --> 00:04:38,101
त्यानंतर आम्ही हॅमिंगबद्दल विचार करण्याच्या वेगळ्या मार्गाने कनेक्शन काढू शकतो. 

69
00:04:38,101 --> 00:04:42,551
कोड्स, जे वादातीतपणे बरेच सोपे आणि अधिक शोभिवंत आहेत आणि जे मुळात कोडच्या एका ओळीने 

70
00:04:42,551 --> 00:04:43,240
लिहिता येतात.

71
00:04:43,660 --> 00:04:45,500
हे XOR फंक्शनवर आधारित आहे.

72
00:04:46,940 --> 00:04:50,220
XOR, तुमच्यापैकी ज्यांना माहित नाही त्यांच्यासाठी, अनन्य किंवा.

73
00:04:50,780 --> 00:04:56,611
जेव्हा तुम्ही दोन बिट्सचा XOR घेता, तेव्हा त्यापैकी एक बिट चालू असल्यास ते 1 परत करेल, 

74
00:04:56,611 --> 00:04:59,360
परंतु दोन्ही चालू किंवा बंद असल्यास नाही.

75
00:05:00,100 --> 00:05:02,980
वेगळ्या पद्धतीने शब्दबद्ध केले तर ही या दोन बिट्सची समानता आहे.

76
00:05:03,540 --> 00:05:06,760
एक गणिती व्यक्ती म्हणून, मी त्याबद्दल अतिरिक्त मोड 2 म्हणून विचार करण्यास प्राधान्य देतो.

77
00:05:07,360 --> 00:05:11,413
आम्ही सामान्यतः दोन भिन्न बिट स्ट्रिंग्सच्या XOR बद्दल बोलतो, 

78
00:05:11,413 --> 00:05:13,440
जे मुळात हा घटक घटकानुसार करते.

79
00:05:13,680 --> 00:05:15,720
हे जोडण्यासारखे आहे, परंतु जिथे आपण कधीही वाहून नेत नाही.

80
00:05:16,500 --> 00:05:19,522
पुन्हा, अधिक गणिती कल हे दोन वेक्टर जोडणे आणि 

81
00:05:19,522 --> 00:05:22,480
मोड 2 कमी करणे असा विचार करणे पसंत करू शकतात.

82
00:05:23,500 --> 00:05:28,081
जर तुम्ही आत्ताच काही Python उघडले आणि दोन पूर्णांकांमध्ये कॅरेट ऑपरेशन लागू केले, 

83
00:05:28,081 --> 00:05:32,940
तर ते हेच करत आहे परंतु हुडच्या खाली असलेल्या त्या संख्यांच्या थोड्या प्रतिनिधित्वासाठी.

84
00:05:34,960 --> 00:05:38,982
तुमच्यासाठी आणि माझ्यासाठी महत्त्वाचा मुद्दा असा आहे की अनेक भिन्न बिट 

85
00:05:38,982 --> 00:05:43,061
स्ट्रिंग्सचे XOR घेणे हा वेगवेगळ्या गटांच्या विडंबनांची प्रभावीपणे गणना 

86
00:05:43,061 --> 00:05:47,140
करण्याचा एक मार्ग आहे, जसे की स्तंभांप्रमाणेच, सर्व काही एकाच वेळी होते.

87
00:05:51,260 --> 00:05:54,926
हे आम्हाला आमच्या हॅमिंग कोड अल्गोरिदममधील एकाधिक समानता तपासण्यांबद्दल विचार 

88
00:05:54,926 --> 00:05:58,780
करण्याचा एक अतिशय आकर्षक मार्ग देते कारण सर्व एकाच ऑपरेशनमध्ये एकत्रित केले जातात.

89
00:05:59,479 --> 00:06:02,180
जरी पहिल्या दृष्टीक्षेपात ते खूप वेगळे दिसते.

90
00:06:02,820 --> 00:06:07,555
विशेषत: बायनरीमध्ये 16 पोझिशन्स लिहा, जसे की आमच्याकडे आधी होती, 

91
00:06:07,555 --> 00:06:12,364
आणि आता ज्या पोझिशन्सवर मेसेज बिट ऑन केले आहे ते 1 वर हायलाइट करा 

92
00:06:12,364 --> 00:06:17,100
आणि नंतर या पोझिशन्स एका मोठ्या कॉलममध्ये एकत्र करा आणि XOR घ्या.

93
00:06:19,260 --> 00:06:24,286
आपण कदाचित अंदाज लावू शकता की परिणामी तळाशी बसलेले 4 बिट्स 4 पॅरिटी तपासण्यांसारखेच आहेत 

94
00:06:24,286 --> 00:06:29,200
ज्या आम्हाला माहित आहेत आणि आवडतात, परंतु नक्की का याचा विचार करण्यासाठी थोडा वेळ घ्या.

95
00:06:32,220 --> 00:06:36,637
हा शेवटचा स्तंभ, उदाहरणार्थ, सर्व पोझिशन्स मोजत आहे ज्याचा शेवटचा बिट 1 आहे, 

96
00:06:36,637 --> 00:06:40,539
परंतु आम्ही आधीच केवळ हायलाइट केलेल्या पोझिशन्सपुरते मर्यादित आहोत, 

97
00:06:40,539 --> 00:06:45,243
त्यामुळे पहिल्या पॅरिटी गटातून किती हायलाइट केलेल्या पोझिशन्स आल्या हे प्रभावीपणे 

98
00:06:45,243 --> 00:06:45,760
मोजत आहे.

99
00:06:46,240 --> 00:06:46,800
त्याला काही अर्थ आहे का?

100
00:06:49,080 --> 00:06:54,409
त्याचप्रमाणे, पुढील स्तंभ दुसऱ्या पॅरिटी गटात किती पोझिशन्स आहेत याची मोजणी करतो, 

101
00:06:54,409 --> 00:07:00,000
ज्या पोझिशन्सचा दुसरा ते शेवटचा बिट 1 आहे आणि ज्या हायलाइट केल्या आहेत, आणि असेच पुढे.

102
00:07:00,260 --> 00:07:03,960
आम्ही करत आहोत त्याच गोष्टीकडे दृष्टीकोनातील हा खरोखरच एक छोटासा बदल आहे.

103
00:07:07,760 --> 00:07:09,600
आणि म्हणून ते इथून कुठे जाते हे तुम्हाला माहिती आहे.

104
00:07:10,000 --> 00:07:12,974
बेरीज 0000 असल्याचे सुनिश्चित करण्यासाठी काही विशेष 

105
00:07:12,974 --> 00:07:15,720
पॅरिटी बिट्स टॉगल करण्यासाठी प्रेषक जबाबदार आहे.

106
00:07:15,720 --> 00:07:21,536
आता एकदा आमच्याकडे असे झाले की, हे आम्हाला तळाशी असलेले हे चार परिणामी बिट्स 

107
00:07:21,536 --> 00:07:27,580
थेट त्रुटीची स्थिती का स्पष्ट करतात याबद्दल विचार करण्याचा एक चांगला मार्ग देते.

108
00:07:28,460 --> 00:07:31,860
समजा या ब्लॉकमध्ये ० ते १ पर्यंत टॉगल केले आहे.

109
00:07:32,600 --> 00:07:38,384
याचा अर्थ असा आहे की त्या बिटची स्थिती आता एकूण XOR मध्ये समाविष्ट केली जाणार आहे, 

110
00:07:38,384 --> 00:07:43,820
जी बेरीज 0 वरून बदलते त्याऐवजी हे नवीन समाविष्ट केलेले मूल्य, त्रुटीची स्थिती.

111
00:07:44,460 --> 00:07:49,360
थोडेसे कमी स्पष्टपणे, 1 ते 0 बदलणारी त्रुटी असल्यास तेच खरे आहे.

112
00:07:50,180 --> 00:07:53,151
तुम्ही पहा, जर तुम्ही दोनदा थोडीशी स्ट्रिंग जोडली, 

113
00:07:53,151 --> 00:07:57,580
तर ती तिथे अजिबात नसल्यासारखीच आहे, मुळात कारण या जगात 1 अधिक 1 बरोबर 0 आहे.

114
00:07:57,580 --> 00:08:04,300
त्यामुळे एकूण बेरीजमध्ये या स्थितीची एक प्रत जोडल्याने आपण ती हलवत आहोत तसाच परिणाम होतो.

115
00:08:05,160 --> 00:08:10,700
आणि तो परिणाम, पुन्हा, येथे तळाशी एकूण परिणाम त्रुटीची स्थिती स्पष्ट करतो.

116
00:08:13,039 --> 00:08:17,268
हे किती शोभिवंत आहे हे स्पष्ट करण्यासाठी, मी आधी संदर्भित केलेल्या पायथन 

117
00:08:17,268 --> 00:08:21,440
कोडची एक ओळ दाखवते, जी रिसीव्हरच्या शेवटी जवळजवळ सर्व लॉजिक कॅप्चर करेल.

118
00:08:22,080 --> 00:08:25,875
आम्ही डेटा ब्लॉकचे नक्कल करण्यासाठी 16 1s आणि 0s चा यादृच्छिक अॅरे तयार 

119
00:08:25,875 --> 00:08:28,511
करून सुरुवात करू आणि मी त्याला नावाचे बिट्स देईन, 

120
00:08:28,511 --> 00:08:32,096
परंतु अर्थातच सराव मध्ये हे असे काहीतरी असेल जे आम्हाला प्रेषकाकडून 

121
00:08:32,096 --> 00:08:35,734
प्राप्त होत असेल आणि त्याऐवजी यादृच्छिक असल्याने ते 5 पॅरिटी बिट्ससह 

122
00:08:35,734 --> 00:08:37,000
11 डेटा बिट्स घेऊन जाईल.

123
00:08:37,000 --> 00:08:41,923
जर मी फंक्शनला enumerateBits म्हणतो, तर ते काय करते ते प्रत्येक 

124
00:08:41,923 --> 00:08:47,000
बिट्सला संबंधित इंडेक्ससह जोडते, या प्रकरणात 0 ते 15 पर्यंत चालते.

125
00:08:48,180 --> 00:08:52,522
मग जर आपण या सर्व जोड्या, i सारख्या दिसणार्‍या जोड्या लूप करणारी 

126
00:08:52,522 --> 00:08:56,663
यादी तयार केली आणि मग आपण फक्त i मूल्य, फक्त निर्देशांक काढू, 

127
00:08:56,663 --> 00:09:01,340
तर ते इतके रोमांचक नाही, तर आपल्याला ते निर्देशांक 0 ते 15 परत मिळतात.

128
00:09:01,680 --> 00:09:07,788
पण जर आपण हे फक्त बिट जर करण्याची अट जोडली, म्हणजे जर तो बिट 1 असेल तर 0 नसेल, 

129
00:09:07,788 --> 00:09:12,660
तर तो फक्त त्या पोझिशन्स बाहेर काढतो जिथे संबंधित बिट चालू आहे.

130
00:09:13,380 --> 00:09:20,360
या प्रकरणात असे दिसते की ती पोझिशन्स 0, 4, 6, 9, इ.

131
00:09:20,720 --> 00:09:24,517
त्या सर्व पोझिशन्स, चालू केलेल्या बिट्सच्या पोझिशन्स 

132
00:09:24,517 --> 00:09:27,240
आणि नंतर त्यांना एकत्र XOR करायचे आहे.

133
00:09:29,180 --> 00:09:33,220
पायथनमध्ये हे करण्यासाठी, मी प्रथम काही उपयुक्त कार्ये आयात करू.

134
00:09:33,900 --> 00:09:38,700
अशाप्रकारे आपण या यादीत reduce() कॉल करू शकतो आणि ते कमी करण्यासाठी XOR फंक्शन वापरू शकतो.

135
00:09:39,100 --> 00:09:42,680
हे मुळात XORs घेऊन, यादीतून मार्ग काढते.

136
00:09:44,800 --> 00:09:49,440
तुमची इच्छा असल्यास, तुम्ही ते XOR फंक्शन कोठूनही आयात न करता स्पष्टपणे लिहू शकता.

137
00:09:51,940 --> 00:09:56,503
तर याक्षणी असे दिसते की जर आपण हे आपल्या 16 बिट्सच्या यादृच्छिक 

138
00:09:56,503 --> 00:10:01,280
ब्लॉकवर केले तर ते 9 परत करेल, ज्याचे बायनरी प्रतिनिधित्व 1001 आहे.

139
00:10:01,980 --> 00:10:06,123
आम्ही ते येथे करणार नाही, परंतु तुम्ही एक फंक्शन लिहू शकता जिथे प्रेषक 

140
00:10:06,123 --> 00:10:10,441
आवश्यकतेनुसार चार पॅरिटी बिट्स सेट करण्यासाठी बायनरी प्रतिनिधित्व वापरतो, 

141
00:10:10,441 --> 00:10:15,460
शेवटी हा ब्लॉक अशा स्थितीत आणतो जिथे कोडची ही ओळ बिट्सच्या संपूर्ण यादीवर चालते. एक 0.

142
00:10:16,080 --> 00:10:20,100
हा एक उत्तम प्रकारे तयार केलेला ब्लॉक मानला जाईल.

143
00:10:20,100 --> 00:10:24,248
काय छान आहे की जर आपण या यादीतील कोणत्याही एका बिट्सला टॉगल केले, 

144
00:10:24,248 --> 00:10:29,465
नॉइजमधून यादृच्छिक त्रुटीचे नक्कल करून, जर तुम्ही कोडची हीच ओळ चालवली तर ती त्रुटी 

145
00:10:29,465 --> 00:10:30,220
प्रिंट करते.

146
00:10:30,960 --> 00:10:31,520
नीट आहे ना?

147
00:10:31,820 --> 00:10:36,185
तुम्ही हा ब्लॉक निळ्या रंगातून मिळवू शकता, त्यावर ही एकल ओळ 

148
00:10:36,185 --> 00:10:41,060
चालवा आणि ती आपोआप त्रुटीची स्थिती बाहेर टाकेल, किंवा जर नसेल तर 0.

149
00:10:42,500 --> 00:10:44,840
आणि येथे 16 आकाराबद्दल काही विशेष नाही.

150
00:10:44,840 --> 00:10:49,860
तुमच्याकडे २५६ बिट्सची यादी असेल तर कोडची समान ओळ काम करेल.

151
00:10:51,880 --> 00:10:55,203
2-बिट त्रुटी शोधण्यासाठी मेटा पॅरिटी चेक करण्यासारखे, 

152
00:10:55,203 --> 00:10:58,527
इथे लिहिण्यासाठी आणखी कोड आहे हे सांगण्याची गरज नाही, 

153
00:10:58,527 --> 00:11:03,760
परंतु कल्पना अशी आहे की आमच्या योजनेतील जवळजवळ सर्व मुख्य तर्क एका XOR कपातीवर येतात.

154
00:11:06,120 --> 00:11:09,783
आता, बायनरी आणि XORs आणि सर्वसाधारणपणे सॉफ्टवेअरसह तुमच्या सोयीनुसार, 

155
00:11:09,783 --> 00:11:13,866
तुम्हाला एकतर हा दृष्टीकोन थोडा गोंधळात टाकणारा किंवा इतका अधिक मोहक आणि सोपा 

156
00:11:13,866 --> 00:11:18,420
वाटू शकतो की, आम्ही सुरुवातीपासूनच याची सुरुवात का केली नाही याचा तुम्हाला प्रश्न पडतो.

157
00:11:19,140 --> 00:11:23,132
- जा हलक्या शब्दात सांगायचे तर, हार्डवेअरमध्ये हॅमिंग कोडची अंमलबजावणी 

158
00:11:23,132 --> 00:11:26,338
करताना मल्टीपल पॅरिटी चेक दृष्टीकोन विचार करणे सोपे आहे, 

159
00:11:26,338 --> 00:11:30,500
आणि XOR दृष्टीकोन हे सॉफ्टवेअरमध्ये करत असताना विचार करणे सर्वात सोपा आहे.

160
00:11:31,360 --> 00:11:36,110
पहिली गोष्ट हाताने करणे सर्वात सोपी आहे, आणि मला वाटते की या सर्व गोष्टींमध्ये 

161
00:11:36,110 --> 00:11:40,198
अंतर्भूत असलेली मूळ अंतर्ज्ञान स्थापित करणे अधिक चांगले कार्य करते, 

162
00:11:40,198 --> 00:11:45,550
म्हणजे एक त्रुटी शोधण्यासाठी आवश्यक असलेली माहिती ब्लॉकच्या आकाराच्या लॉगशी संबंधित आहे. 

163
00:11:45,550 --> 00:11:50,000
, किंवा दुसर्‍या शब्दात, ब्लॉकचा आकार दुप्पट होताना तो एकावेळी थोडा वाढतो.

164
00:11:51,020 --> 00:11:53,540
येथे संबंधित वस्तुस्थिती अशी आहे की ती माहिती आपल्याला 

165
00:11:53,540 --> 00:11:56,060
किती रिडंडन्सीची आवश्यकता आहे याच्याशी थेट संबंधित आहे.

166
00:11:56,660 --> 00:12:00,096
बहुतेक लोकांच्या गुडघेदुखीच्या प्रतिक्रियेच्या विरोधात हेच चालते जेव्हा 

167
00:12:00,096 --> 00:12:02,960
ते प्रथम एखादे संदेश त्रुटींना लवचिक बनवण्याचा विचार करतात, 

168
00:12:02,960 --> 00:12:06,540
जेथे सामान्यतः संपूर्ण संदेश कॉपी करणे ही मनात येणारी पहिली प्रवृत्ती असते.

169
00:12:07,500 --> 00:12:10,795
आणि मग, तसे, हा संपूर्ण दुसरा मार्ग आहे ज्यामध्ये आपण कधीकधी हॅमिंग कोड 

170
00:12:10,795 --> 00:12:14,000
सादर केलेले दिसतो, जिथे आपण संदेश एका मोठ्या मॅट्रिक्सने गुणाकार करतो.

171
00:12:14,670 --> 00:12:18,292
हे एक प्रकारचे छान आहे कारण ते रेखीय कोडच्या विस्तृत कुटुंबाशी संबंधित आहे, 

172
00:12:18,292 --> 00:12:22,106
परंतु मला वाटते की ते कोठून येते किंवा ते कसे मोजले जाते याबद्दल जवळजवळ कोणतीही 

173
00:12:22,106 --> 00:12:23,060
अंतर्ज्ञान देत नाही.

174
00:12:25,200 --> 00:12:28,062
आणि स्केलिंगबद्दल बोलताना, तुमच्या लक्षात येईल की या योजनेची 

175
00:12:28,062 --> 00:12:31,160
कार्यक्षमता केवळ आम्ही ब्लॉक आकार वाढवतो तेव्हाच अधिक चांगली होते.

176
00:12:35,000 --> 00:12:38,861
उदाहरणार्थ, आम्ही पाहिले की 256 बिट्ससह, तुम्ही त्यातील केवळ 

177
00:12:38,861 --> 00:12:42,660
3% जागा रिडंडंसीसाठी वापरत आहात आणि ते तिथून चांगले होत आहे.

178
00:12:43,300 --> 00:12:47,340
पॅरिटी बिट्सची संख्या एक एक करून वाढत असताना, ब्लॉकचा आकार दुप्पट होत जातो.

179
00:12:49,000 --> 00:12:54,076
आणि जर तुम्ही ते टोकापर्यंत नेले, तर तुमच्याकडे एक दशलक्ष बिट्सचा ब्लॉक असू शकतो, 

180
00:12:54,076 --> 00:12:59,586
जिथे तुम्ही तुमच्या पॅरिटी चेकसह अक्षरशः 20 प्रश्न खेळत असाल आणि ते फक्त 21 पॅरिटी बिट्स 

181
00:12:59,586 --> 00:13:00,020
वापरते.

182
00:13:00,740 --> 00:13:04,007
आणि जर तुम्ही दशलक्ष बिट्स पाहण्याचा आणि एक त्रुटी शोधण्याचा 

183
00:13:04,007 --> 00:13:07,060
विचार करण्यासाठी मागे पाऊल टाकले तर ते खरोखरच वेडे वाटते.

184
00:13:08,199 --> 00:13:12,898
अर्थातच, समस्या अशी आहे की मोठ्या ब्लॉकसह, एक किंवा दोन बिट त्रुटींपेक्षा 

185
00:13:12,898 --> 00:13:17,660
जास्त दिसण्याची शक्यता वाढते आणि हॅमिंग कोड त्यापलीकडे काहीही हाताळत नाहीत.

186
00:13:18,320 --> 00:13:21,199
त्यामुळे व्यवहारात, तुम्हाला योग्य आकार शोधायचा आहे 

187
00:13:21,199 --> 00:13:24,300
जेणेकरून खूप जास्त बिट फ्लिप होण्याची शक्यता जास्त नसेल.

188
00:13:26,600 --> 00:13:31,284
तसेच, व्यवहारात, त्रुटी थोड्या वेळाने येतात, ज्यामुळे एकाच ब्लॉकचा पूर्णपणे नाश होतो, 

189
00:13:31,284 --> 00:13:36,077
त्यामुळे अनेक वेगवेगळ्या ब्लॉक्समध्ये त्रुटी पसरवण्यास मदत करण्यासाठी एक सामान्य युक्ती 

190
00:13:36,077 --> 00:13:40,980
म्हणजे त्या ब्लॉक्सना एकमेकांशी जोडणे, जसे की, ते होण्यापूर्वी. बाहेर पाठवले किंवा साठवले.

191
00:13:45,580 --> 00:13:49,417
नंतर पुन्हा, यापैकी बरेच काही अधिक आधुनिक कोडद्वारे पूर्णपणे विवादित केले जाते, 

192
00:13:49,417 --> 00:13:52,200
जसे की सामान्यतः वापरल्या जाणार्‍या रीड-सोलोमन अल्गोरिदम, 

193
00:13:52,200 --> 00:13:55,701
जे बर्स्ट एरर्स विशेषतः चांगल्या प्रकारे हाताळते आणि प्रत्येक ब्लॉकमध्ये 

194
00:13:55,701 --> 00:13:58,820
मोठ्या संख्येने त्रुटींसाठी लवचिक होण्यासाठी ट्यून केले जाऊ शकते.

195
00:13:59,360 --> 00:14:01,340
पण तो दुसर्‍या वेळी विषय आहे.

196
00:14:02,500 --> 00:14:05,837
त्याच्या द आर्ट ऑफ डुइंग सायन्स अँड इंजिनीअरिंग या पुस्तकात, 

197
00:14:05,837 --> 00:14:09,940
हॅमिंगने या कोडचा शोध किती क्षुल्लक होता हे आश्चर्यकारकपणे स्पष्ट केले आहे.

198
00:14:10,620 --> 00:14:14,112
त्याने प्रथम सर्व प्रकारच्या विविध योजना वापरून पाहिल्या ज्यामध्ये बिट्सला उच्च 

199
00:14:14,112 --> 00:14:17,780
मितीय जाळीच्या भागांमध्ये व्यवस्थित करणे आणि यासारख्या विचित्र गोष्टींचा समावेश आहे.

200
00:14:18,300 --> 00:14:22,633
एररच्या स्थितीचे स्पेलिंग अशा प्रकारे कट रचण्यासाठी पॅरिटी चेक मिळवणे शक्य आहे 

201
00:14:22,633 --> 00:14:26,967
ही कल्पना हॅमिंगला तेव्हाच आली जेव्हा त्याने इतर विश्लेषणाच्या गुच्छानंतर मागे 

202
00:14:26,967 --> 00:14:31,520
पाऊल टाकले आणि विचारले, ठीक आहे, मी सर्वात कार्यक्षम काय आहे? कदाचित या बद्दल असेल?

203
00:14:32,620 --> 00:14:36,775
पॅरिटी चेक त्याच्या मनात आधीपासूनच होते हे किती महत्वाचे आहे याबद्दल ते 

204
00:14:36,775 --> 00:14:41,220
स्पष्टपणे सांगत होते, जे आजच्या पेक्षा 1940 च्या दशकात कमी सामान्य झाले असते.

205
00:14:41,920 --> 00:14:46,535
या पुस्तकात अर्धा डझन वेळा त्यांनी लुई पाश्चरच्या कोटाचा संदर्भ दिला आहे, 

206
00:14:46,535 --> 00:14:48,220
नशीब तयार मनाला अनुकूल आहे.

207
00:14:49,320 --> 00:14:54,300
हुशार कल्पना अनेकदा भ्रामकपणे सोप्या दिसतात, ज्यामुळे त्यांचे कमी कौतुक करणे सोपे होते.

208
00:14:54,960 --> 00:14:58,099
सध्या माझी प्रामाणिक आशा आहे की हॅमिंग कोड्स किंवा 

209
00:14:58,099 --> 00:15:01,300
किमान अशा कोडची शक्यता तुम्हाला जवळजवळ स्पष्ट वाटते.

210
00:15:01,660 --> 00:15:05,667
परंतु ते प्रत्यक्षात स्पष्ट आहेत असा विचार करून तुम्ही स्वत:ला फसवू नका, 

211
00:15:05,667 --> 00:15:06,820
कारण ते नक्कीच नाहीत.

212
00:15:07,880 --> 00:15:11,547
हुशार कल्पना भ्रामकपणे सोप्या दिसण्याच्या कारणाचा एक भाग हा आहे की आपण 

213
00:15:11,547 --> 00:15:14,440
फक्त अंतिम परिणाम पाहतो, जे गोंधळलेले होते ते साफ करणे, 

214
00:15:14,440 --> 00:15:18,211
सर्व चुकीच्या वळणांचा कधीही उल्लेख न करणे, एखाद्या समस्येच्या सुरुवातीला 

215
00:15:18,211 --> 00:15:22,860
शोधण्यायोग्य शक्यतांची जागा किती विस्तीर्ण आहे हे कमी करणे. सोडवण्याची प्रक्रिया, ते सर्व.

216
00:15:23,820 --> 00:15:24,900
पण हे सर्वसाधारणपणे खरे आहे.

217
00:15:24,900 --> 00:15:27,608
मला असे वाटते की काही विशेष शोधांसाठी, एक दुसरे, 

218
00:15:27,608 --> 00:15:30,040
सखोल कारण आहे की आपण त्यांचे कमी कौतुक करतो.

219
00:15:30,840 --> 00:15:34,636
माहितीच्या सिद्धांतावर क्लॉड शॅननच्या मुख्य पेपरसह 1948 पर्यंत बिट्सच्या 

220
00:15:34,636 --> 00:15:38,640
संदर्भात माहितीचा विचार करणे खरोखरच संपूर्ण सिद्धांतामध्ये एकत्रित झाले होते.

221
00:15:39,280 --> 00:15:42,540
जेव्हा हॅमिंगने त्याचे अल्गोरिदम विकसित केले तेव्हा हे मूलत: समांतर होते.

222
00:15:43,300 --> 00:15:48,181
हा तोच पायाभूत कागद होता ज्याने एका विशिष्ट अर्थाने दाखवून दिले की, किमान सिद्धांतानुसार, 

223
00:15:48,181 --> 00:15:52,900
बिट फ्लिपची संभाव्यता कितीही उच्च असली तरीही कार्यक्षम त्रुटी सुधारणे नेहमीच शक्य असते.

224
00:15:53,700 --> 00:15:59,722
शॅनन आणि हॅमिंग यांनी अगदी वेगळ्या गोष्टींवर काम करूनही बेल लॅबमध्ये एक ऑफिस शेअर केले, 

225
00:15:59,722 --> 00:16:01,160
जे इथे योगायोगच नाही.

226
00:16:02,380 --> 00:16:07,024
अनेक दशके फास्ट फॉरवर्ड, आणि आजकाल, आपल्यापैकी बरेच जण बिट्स आणि माहितीबद्दल विचार 

227
00:16:07,024 --> 00:16:11,836
करण्यात इतके मग्न आहेत की विचार करण्याची ही पद्धत किती वेगळी होती याकडे दुर्लक्ष करणे 

228
00:16:11,836 --> 00:16:12,340
सोपे आहे.

229
00:16:13,100 --> 00:16:17,454
गंमत म्हणजे, भावी पिढीच्या विचारसरणीला सर्वात गहनपणे आकार 

230
00:16:17,454 --> 00:16:22,260
देणार्‍या कल्पना त्या भावी पिढीला त्यांच्यापेक्षा सोप्या वाटतील.

