1
00:00:00,000 --> 00:00:03,120
मी असे गृहीत धरत आहे की येथे प्रत्येकजण भाग 1 पासून येत आहे.

2
00:00:03,120 --> 00:00:07,751
आम्ही हॅमिंग कोडबद्दल बोलत होतो, डेटाचा एक ब्लॉक तयार करण्याचा एक मार्ग जिथे बहुतेक

3
00:00:07,751 --> 00:00:12,437
बिट एक अर्थपूर्ण संदेश देतात, तर काही इतर एक प्रकारचा रिडंडंसी म्हणून काम करतात, अशा

4
00:00:12,437 --> 00:00:17,123
प्रकारे की जर काही बिट फ्लिप झाले तर एकतर संदेश बिट किंवा रिडंडंसी बिट, या ब्लॉकमधील

5
00:00:17,123 --> 00:00:21,920
काहीही, एक प्राप्तकर्ता त्रुटी आहे हे ओळखण्यास सक्षम असेल आणि त्याचे निराकरण कसे करावे.

6
00:00:21,920 --> 00:00:25,546
तेथे सादर केलेली मूलभूत कल्पना ही होती की त्रुटीकडे

7
00:00:25,546 --> 00:00:29,800
जाण्यासाठी बायनरी शोधण्यासाठी एकाधिक पॅरिटी चेक कसे वापरायचे.

8
00:00:29,800 --> 00:00:32,817
त्या व्हिडिओमध्ये हॅमिंग कोड शक्य तितक्या हँड्स-ऑन

9
00:00:32,817 --> 00:00:35,420
आणि पुन्हा शोधण्यायोग्य वाटणे हे ध्येय होते.

10
00:00:35,420 --> 00:00:39,854
परंतु जसे तुम्ही हे सॉफ्टवेअर किंवा हार्डवेअरमध्ये प्रत्यक्षात अंमलात आणण्याचा

11
00:00:39,854 --> 00:00:44,120
विचार करू लागता, ते फ्रेमिंग हे कोड्स खरोखर किती सुंदर आहेत हे कमी करू शकते.

12
00:00:44,120 --> 00:00:47,347
तुम्हाला असे वाटेल की तुम्हाला एखादे अल्गोरिदम लिहावे लागेल जे

13
00:00:47,347 --> 00:00:50,779
सर्व संभाव्य त्रुटी स्थानांचा मागोवा ठेवेल आणि प्रत्येक चेकसह त्या

14
00:00:50,779 --> 00:00:54,160
गटाला अर्धा कापून टाकेल, परंतु प्रत्यक्षात ते त्यापेक्षा सोपे आहे.

15
00:00:54,160 --> 00:00:59,580
शेवटच्या व्हिडिओमध्ये आम्ही केलेल्या चार पॅरिटी चेकची उत्तरे तुम्ही होय आणि नाही

16
00:00:59,580 --> 00:01:04,800
ऐवजी 1s आणि 0s अशी वाचली, तर ते बायनरीमधील त्रुटीचे स्थान अक्षरशः स्पष्ट करते.

17
00:01:04,800 --> 00:01:12,640
उदाहरणार्थ, बायनरी मधील 7 ही संख्या 0111 सारखी दिसते, मूलत: ते 4 अधिक 2 अधिक 1 असे म्हणते.

18
00:01:12,640 --> 00:01:17,167
आणि लक्षात घ्या की स्थान 7 कुठे बसते, ते आमच्या समता गटांपैकी

19
00:01:17,167 --> 00:01:22,280
पहिल्यावर, आणि दुसऱ्या आणि तिसऱ्याला प्रभावित करते, परंतु शेवटचे नाही.

20
00:01:22,280 --> 00:01:28,520
त्यामुळे तळापासून वरपर्यंत त्या चार तपासण्यांचे निकाल वाचून त्रुटीची स्थिती स्पष्ट होते.

21
00:01:28,520 --> 00:01:32,980
उदाहरण 7 मध्ये विशेष काही नाही, हे सर्वसाधारणपणे कार्य करते आणि यामुळे

22
00:01:32,980 --> 00:01:37,440
हार्डवेअरमध्ये संपूर्ण योजना लागू करण्याचे तर्क धक्कादायकपणे सोपे होते.

23
00:01:37,440 --> 00:01:41,430
आता ही जादू का घडते हे जर तुम्हाला पहायचे असेल, तर आमच्या

24
00:01:41,430 --> 00:01:45,972
पोझिशन्ससाठी ही 16 इंडेक्स लेबले घ्या, परंतु त्यांना बेस 10 मध्ये

25
00:01:45,972 --> 00:01:50,720
लिहिण्याऐवजी, 0000 ते 1111 पर्यंत चालणारे ते सर्व बायनरीमध्ये लिहूया.

26
00:01:50,720 --> 00:01:54,457
जसे आम्ही ही बायनरी लेबले त्यांच्या बॉक्समध्ये परत ठेवतो, मी

27
00:01:54,457 --> 00:01:58,440
यावर जोर देतो की ते प्रत्यक्षात पाठवलेल्या डेटापेक्षा वेगळे आहेत.

28
00:01:58,440 --> 00:02:01,294
ते चार समानता गट कुठून आले हे तुम्हाला आणि मला समजण्यास

29
00:02:01,294 --> 00:02:04,200
मदत करण्यासाठी एक संकल्पनात्मक लेबलपेक्षा अधिक काही नाही.

30
00:02:04,200 --> 00:02:08,723
बायनरीमध्ये वर्णन केल्या जाणाऱ्या प्रत्येक गोष्टीचे

31
00:02:08,723 --> 00:02:13,160
वर्णन आपण पाहत आहोत या संभ्रमामुळे कदाचित कमी होईल.

32
00:02:13,160 --> 00:02:15,040
तो वाचतो आहे, तरी.

33
00:02:15,040 --> 00:02:19,578
तुमचे लक्ष या सर्व लेबल्सच्या शेवटच्या बिट्सवर केंद्रित

34
00:02:19,578 --> 00:02:24,280
करा आणि नंतर ते स्थान हायलाइट करा जिथे तो अंतिम बिट 1 आहे.

35
00:02:24,280 --> 00:02:28,538
आम्हाला जे मिळते ते आमच्या चार पॅरिटी गटांपैकी पहिले आहे, याचा अर्थ

36
00:02:28,538 --> 00:02:32,484
तुम्ही त्या पहिल्या चेकचा विचार म्हणून अर्थ लावू शकता, अरे, जर

37
00:02:32,484 --> 00:02:36,680
एखादी त्रुटी असेल, तर त्या त्रुटीच्या स्थितीतील अंतिम बिट 1 आहे का?

38
00:02:36,680 --> 00:02:41,795
त्याचप्रमाणे, जर तुम्ही सेकंड टू लास्ट बिटवर लक्ष केंद्रित केले आणि 1 असलेल्या

39
00:02:41,795 --> 00:02:47,040
सर्व पोझिशन्स हायलाइट केल्यास तुम्हाला आमच्या स्कीममधून दुसरा पॅरिटी ग्रुप मिळेल.

40
00:02:47,040 --> 00:02:51,492
दुसऱ्या शब्दांत, तो दुसरा चेक विचारत आहे, अहो, मला पुन्हा, जर

41
00:02:51,492 --> 00:02:56,160
एखादी त्रुटी असेल, तर त्या स्थितीचा दुसरा टू शेवटचा बिट 1 आहे का?

42
00:02:56,160 --> 00:02:57,160
वगैरे.

43
00:02:57,160 --> 00:03:03,724
तिसरा पॅरिटी चेक प्रत्येक पोझिशनचा कव्हर करतो ज्याचा तिसरा ते शेवटचा बिट चालू

44
00:03:03,724 --> 00:03:10,120
आहे आणि शेवटच्या आठ पोझिशन्सला कव्हर करते, ज्यांची सर्वोच्च ऑर्डर बिट 1 आहे.

45
00:03:10,120 --> 00:03:15,400
आम्ही याआधी जे काही केले ते या चार प्रश्नांची उत्तरे देण्यासारखेच

46
00:03:15,400 --> 00:03:19,800
आहे, जे यामधून बायनरीमधील स्थानाचे स्पेलिंग सारखेच आहे.

47
00:03:19,800 --> 00:03:22,080
मला आशा आहे की हे दोन गोष्टी स्पष्ट करेल.

48
00:03:22,080 --> 00:03:24,533
प्रथम म्हणजे दोन मोठ्या शक्ती असलेल्या आकारांना

49
00:03:24,533 --> 00:03:27,140
ब्लॉक करण्यासाठी पद्धतशीरपणे सामान्यीकरण कसे करावे.

50
00:03:27,140 --> 00:03:30,898
प्रत्येक पोझिशनचे वर्णन करण्यासाठी अधिक बिट्स लागत असल्यास, जसे की

51
00:03:30,898 --> 00:03:34,713
64 स्पॉट्सचे वर्णन करण्यासाठी सहा बिट्स, तर त्या प्रत्येक बिट्समुळे

52
00:03:34,713 --> 00:03:38,640
आपल्याला समानता गटांपैकी एक मिळेल जो आपल्याला तपासण्याची आवश्यकता आहे.

53
00:03:38,640 --> 00:03:41,062
तुमच्यापैकी ज्यांनी मी मॅट पार्करसोबत केलेले बुद्धिबळाचे

54
00:03:41,062 --> 00:03:43,400
कोडे पाहिले त्यांना कदाचित हे सर्व अत्यंत परिचित वाटेल.

55
00:03:43,400 --> 00:03:46,476
हे समान मुख्य तर्क आहे, परंतु वेगळ्या समस्येचे

56
00:03:46,476 --> 00:03:49,880
निराकरण करते आणि 64-चौरस बुद्धिबळावर लागू केले जाते.

57
00:03:49,880 --> 00:03:54,163
दुसरी गोष्ट मला आशा आहे की हे स्पष्ट करते की आमचे पॅरिटी बिट्स दोन

58
00:03:54,163 --> 00:03:58,320
पॉवर असलेल्या पोझिशनमध्ये का बसले आहेत, उदाहरणार्थ 1, 2, 4 आणि 8.

59
00:03:58,320 --> 00:04:03,640
ही अशी पोझिशन्स आहेत ज्यांचे बायनरी प्रतिनिधित्व फक्त एक बिट चालू आहे.

60
00:04:03,640 --> 00:04:12,640
याचा अर्थ असा आहे की त्या प्रत्येक पॅरिटी बिट्स चार पॅरिटी गटांपैकी फक्त एकामध्ये बसतात.

61
00:04:12,640 --> 00:04:19,037
आपण हे मोठ्या उदाहरणांमध्ये देखील पाहू शकता, जिथे आपण कितीही मोठे

62
00:04:19,037 --> 00:04:25,920
असले तरीही, प्रत्येक पॅरिटी बिट सोयीस्करपणे फक्त एका गटाला स्पर्श करते.

63
00:04:25,920 --> 00:04:30,352
एकदा आपण समजून घेतले की या समता तपासण्या ज्यावर आम्ही आमचा बराच वेळ लक्ष केंद्रित

64
00:04:30,352 --> 00:04:34,838
केला आहे ते बायनरीमधील त्रुटीची स्थिती स्पष्ट करण्याचा एक चतुर मार्ग आहे, त्यानंतर

65
00:04:34,838 --> 00:04:39,217
आम्ही हॅमिंगबद्दल विचार करण्याच्या वेगळ्या मार्गाने कनेक्शन काढू शकतो. कोड्स, जे

66
00:04:39,217 --> 00:04:43,920
वादातीतपणे बरेच सोपे आणि अधिक शोभिवंत आहेत आणि जे मुळात कोडच्या एका ओळीने लिहिता येतात.

67
00:04:43,920 --> 00:04:46,200
हे XOR फंक्शनवर आधारित आहे.

68
00:04:46,200 --> 00:04:50,960
XOR, तुमच्यापैकी ज्यांना माहित नाही त्यांच्यासाठी, अनन्य किंवा.

69
00:04:50,960 --> 00:04:55,580
जेव्हा तुम्ही दोन बिट्सचा XOR घेता, तेव्हा त्यापैकी एक बिट चालू

70
00:04:55,580 --> 00:05:00,200
असल्यास ते 1 परत करेल, परंतु दोन्ही चालू किंवा बंद असल्यास नाही.

71
00:05:00,200 --> 00:05:03,760
वेगळ्या पद्धतीने शब्दबद्ध केले तर ही या दोन बिट्सची समानता आहे.

72
00:05:03,760 --> 00:05:07,840
एक गणिती व्यक्ती म्हणून, मी त्याबद्दल अतिरिक्त मोड 2 म्हणून विचार करण्यास प्राधान्य देतो.

73
00:05:07,840 --> 00:05:11,106
आम्ही सामान्यतः दोन भिन्न बिट स्ट्रिंग्सच्या XOR

74
00:05:11,106 --> 00:05:14,040
बद्दल बोलतो, जे मुळात हा घटक घटकानुसार करते.

75
00:05:14,040 --> 00:05:16,280
हे जोडण्यासारखे आहे, परंतु जिथे आपण कधीही वाहून नेत नाही.

76
00:05:16,280 --> 00:05:19,939
पुन्हा, अधिक गणिती कल हे दोन वेक्टर जोडणे आणि

77
00:05:19,939 --> 00:05:23,520
मोड 2 कमी करणे असा विचार करणे पसंत करू शकतात.

78
00:05:23,520 --> 00:05:29,494
जर तुम्ही आत्ताच काही Python उघडले आणि दोन पूर्णांकांमध्ये कॅरेट ऑपरेशन लागू केले, तर

79
00:05:29,494 --> 00:05:35,400
ते हेच करत आहे परंतु हुडच्या खाली असलेल्या त्या संख्यांच्या थोड्या प्रतिनिधित्वासाठी.

80
00:05:35,400 --> 00:05:40,657
तुमच्यासाठी आणि माझ्यासाठी महत्त्वाचा मुद्दा असा आहे की अनेक भिन्न बिट

81
00:05:40,657 --> 00:05:45,988
स्ट्रिंग्सचे XOR घेणे हा वेगवेगळ्या गटांच्या विडंबनांची प्रभावीपणे गणना

82
00:05:45,988 --> 00:05:51,320
करण्याचा एक मार्ग आहे, जसे की स्तंभांप्रमाणेच, सर्व काही एकाच वेळी होते.

83
00:05:51,320 --> 00:05:55,395
हे आम्हाला आमच्या हॅमिंग कोड अल्गोरिदममधील एकाधिक समानता तपासण्यांबद्दल विचार

84
00:05:55,395 --> 00:05:59,680
करण्याचा एक अतिशय आकर्षक मार्ग देते कारण सर्व एकाच ऑपरेशनमध्ये एकत्रित केले जातात.

85
00:05:59,680 --> 00:06:02,800
जरी पहिल्या दृष्टीक्षेपात ते खूप वेगळे दिसते.

86
00:06:02,800 --> 00:06:08,305
विशेषत: बायनरीमध्ये 16 पोझिशन्स लिहा, जसे की आमच्याकडे आधी होती,

87
00:06:08,305 --> 00:06:13,894
आणि आता ज्या पोझिशन्सवर मेसेज बिट ऑन केले आहे ते 1 वर हायलाइट करा

88
00:06:13,894 --> 00:06:19,400
आणि नंतर या पोझिशन्स एका मोठ्या कॉलममध्ये एकत्र करा आणि XOR घ्या.

89
00:06:19,400 --> 00:06:26,135
आपण कदाचित अंदाज लावू शकता की परिणामी तळाशी बसलेले 4 बिट्स 4 पॅरिटी तपासण्यांसारखेच आहेत

90
00:06:26,135 --> 00:06:32,720
ज्या आम्हाला माहित आहेत आणि आवडतात, परंतु नक्की का याचा विचार करण्यासाठी थोडा वेळ घ्या.

91
00:06:32,720 --> 00:06:37,039
हा शेवटचा स्तंभ, उदाहरणार्थ, सर्व पोझिशन्स मोजत आहे ज्याचा शेवटचा बिट 1 आहे,

92
00:06:37,039 --> 00:06:41,359
परंतु आम्ही आधीच केवळ हायलाइट केलेल्या पोझिशन्सपुरते मर्यादित आहोत, त्यामुळे

93
00:06:41,359 --> 00:06:45,960
पहिल्या पॅरिटी गटातून किती हायलाइट केलेल्या पोझिशन्स आल्या हे प्रभावीपणे मोजत आहे.

94
00:06:45,960 --> 00:06:48,520
त्याला काही अर्थ आहे का?

95
00:06:48,520 --> 00:06:54,435
त्याचप्रमाणे, पुढील स्तंभ दुसऱ्या पॅरिटी गटात किती पोझिशन्स आहेत याची मोजणी करतो,

96
00:06:54,435 --> 00:07:00,640
ज्या पोझिशन्सचा दुसरा ते शेवटचा बिट 1 आहे आणि ज्या हायलाइट केल्या आहेत, आणि असेच पुढे.

97
00:07:00,640 --> 00:07:07,640
आम्ही करत आहोत त्याच गोष्टीकडे दृष्टीकोनातील हा खरोखरच एक छोटासा बदल आहे.

98
00:07:07,640 --> 00:07:10,000
आणि म्हणून ते इथून कुठे जाते हे तुम्हाला माहिती आहे.

99
00:07:10,000 --> 00:07:15,012
बेरीज 0000 असल्याचे सुनिश्चित करण्यासाठी काही विशेष

100
00:07:15,012 --> 00:07:19,640
पॅरिटी बिट्स टॉगल करण्यासाठी प्रेषक जबाबदार आहे.

101
00:07:19,640 --> 00:07:24,093
आता एकदा आमच्याकडे असे झाले की, हे आम्हाला तळाशी असलेले हे चार परिणामी बिट्स

102
00:07:24,093 --> 00:07:28,720
थेट त्रुटीची स्थिती का स्पष्ट करतात याबद्दल विचार करण्याचा एक चांगला मार्ग देते.

103
00:07:28,720 --> 00:07:32,720
समजा या ब्लॉकमध्ये ० ते १ पर्यंत टॉगल केले आहे.

104
00:07:32,720 --> 00:07:38,572
याचा अर्थ असा आहे की त्या बिटची स्थिती आता एकूण XOR मध्ये समाविष्ट केली जाणार

105
00:07:38,572 --> 00:07:44,800
आहे, जी बेरीज 0 वरून बदलते त्याऐवजी हे नवीन समाविष्ट केलेले मूल्य, त्रुटीची स्थिती.

106
00:07:44,800 --> 00:07:49,800
थोडेसे कमी स्पष्टपणे, 1 ते 0 बदलणारी त्रुटी असल्यास तेच खरे आहे.

107
00:07:49,800 --> 00:07:54,291
तुम्ही पहा, जर तुम्ही दोनदा थोडीशी स्ट्रिंग जोडली, तर ती तिथे

108
00:07:54,291 --> 00:07:59,000
अजिबात नसल्यासारखीच आहे, मुळात कारण या जगात 1 अधिक 1 बरोबर 0 आहे.

109
00:07:59,000 --> 00:08:05,400
त्यामुळे एकूण बेरीजमध्ये या स्थितीची एक प्रत जोडल्याने आपण ती हलवत आहोत तसाच परिणाम होतो.

110
00:08:05,400 --> 00:08:13,480
आणि तो परिणाम, पुन्हा, येथे तळाशी एकूण परिणाम त्रुटीची स्थिती स्पष्ट करतो.

111
00:08:13,480 --> 00:08:17,829
हे किती शोभिवंत आहे हे स्पष्ट करण्यासाठी, मी आधी संदर्भित केलेल्या पायथन

112
00:08:17,829 --> 00:08:22,120
कोडची एक ओळ दाखवते, जी रिसीव्हरच्या शेवटी जवळजवळ सर्व लॉजिक कॅप्चर करेल.

113
00:08:22,120 --> 00:08:26,312
आम्ही डेटा ब्लॉकचे नक्कल करण्यासाठी 16 1s आणि 0s चा यादृच्छिक अॅरे तयार

114
00:08:26,312 --> 00:08:30,330
करून सुरुवात करू आणि मी त्याला नावाचे बिट्स देईन, परंतु अर्थातच सराव

115
00:08:30,330 --> 00:08:34,407
मध्ये हे असे काहीतरी असेल जे आम्हाला प्रेषकाकडून प्राप्त होत असेल आणि

116
00:08:34,407 --> 00:08:38,600
त्याऐवजी यादृच्छिक असल्याने ते 5 पॅरिटी बिट्ससह 11 डेटा बिट्स घेऊन जाईल.

117
00:08:38,600 --> 00:08:43,345
जर मी फंक्शनला enumerateBits म्हणतो, तर ते काय करते ते प्रत्येक

118
00:08:43,345 --> 00:08:48,240
बिट्सला संबंधित इंडेक्ससह जोडते, या प्रकरणात 0 ते 15 पर्यंत चालते.

119
00:08:48,240 --> 00:08:52,753
मग जर आपण या सर्व जोड्या, i सारख्या दिसणार्‍या जोड्या लूप करणारी

120
00:08:52,753 --> 00:08:57,267
यादी तयार केली आणि मग आपण फक्त i मूल्य, फक्त निर्देशांक काढू, तर

121
00:08:57,267 --> 00:09:01,920
ते इतके रोमांचक नाही, तर आपल्याला ते निर्देशांक 0 ते 15 परत मिळतात.

122
00:09:01,920 --> 00:09:07,660
पण जर आपण हे फक्त बिट जर करण्याची अट जोडली, म्हणजे जर तो बिट 1 असेल तर

123
00:09:07,660 --> 00:09:13,400
0 नसेल, तर तो फक्त त्या पोझिशन्स बाहेर काढतो जिथे संबंधित बिट चालू आहे.

124
00:09:13,400 --> 00:09:20,720
या प्रकरणात असे दिसते की ती पोझिशन्स 0, 4, 6, 9, इ.

125
00:09:20,720 --> 00:09:26,101
त्या सर्व पोझिशन्स, चालू केलेल्या बिट्सच्या पोझिशन्स

126
00:09:26,101 --> 00:09:29,960
आणि नंतर त्यांना एकत्र XOR करायचे आहे.

127
00:09:29,960 --> 00:09:33,960
पायथनमध्ये हे करण्यासाठी, मी प्रथम काही उपयुक्त कार्ये आयात करू.

128
00:09:33,960 --> 00:09:39,140
अशाप्रकारे आपण या यादीत reduce() कॉल करू शकतो आणि ते कमी करण्यासाठी XOR फंक्शन वापरू शकतो.

129
00:09:39,140 --> 00:09:44,840
हे मुळात XORs घेऊन, यादीतून मार्ग काढते.

130
00:09:44,840 --> 00:09:52,200
तुमची इच्छा असल्यास, तुम्ही ते XOR फंक्शन कोठूनही आयात न करता स्पष्टपणे लिहू शकता.

131
00:09:52,200 --> 00:09:57,026
तर याक्षणी असे दिसते की जर आपण हे आपल्या 16 बिट्सच्या यादृच्छिक

132
00:09:57,026 --> 00:10:02,080
ब्लॉकवर केले तर ते 9 परत करेल, ज्याचे बायनरी प्रतिनिधित्व 1001 आहे.

133
00:10:02,080 --> 00:10:06,727
आम्ही ते येथे करणार नाही, परंतु तुम्ही एक फंक्शन लिहू शकता जिथे प्रेषक

134
00:10:06,727 --> 00:10:11,570
आवश्यकतेनुसार चार पॅरिटी बिट्स सेट करण्यासाठी बायनरी प्रतिनिधित्व वापरतो,

135
00:10:11,570 --> 00:10:17,200
शेवटी हा ब्लॉक अशा स्थितीत आणतो जिथे कोडची ही ओळ बिट्सच्या संपूर्ण यादीवर चालते. एक 0.

136
00:10:17,200 --> 00:10:20,200
हा एक उत्तम प्रकारे तयार केलेला ब्लॉक मानला जाईल.

137
00:10:20,200 --> 00:10:25,044
काय छान आहे की जर आपण या यादीतील कोणत्याही एका बिट्सला टॉगल केले, नॉइजमधून

138
00:10:25,044 --> 00:10:30,600
यादृच्छिक त्रुटीचे नक्कल करून, जर तुम्ही कोडची हीच ओळ चालवली तर ती त्रुटी प्रिंट करते.

139
00:10:30,600 --> 00:10:31,920
नीट आहे ना?

140
00:10:31,920 --> 00:10:37,116
तुम्ही हा ब्लॉक निळ्या रंगातून मिळवू शकता, त्यावर ही एकल ओळ

141
00:10:37,116 --> 00:10:42,920
चालवा आणि ती आपोआप त्रुटीची स्थिती बाहेर टाकेल, किंवा जर नसेल तर 0.

142
00:10:42,920 --> 00:10:45,520
आणि येथे 16 आकाराबद्दल काही विशेष नाही.

143
00:10:45,520 --> 00:10:52,280
तुमच्याकडे २५६ बिट्सची यादी असेल तर कोडची समान ओळ काम करेल.

144
00:10:52,280 --> 00:10:56,126
2-बिट त्रुटी शोधण्यासाठी मेटा पॅरिटी चेक करण्यासारखे, इथे

145
00:10:56,126 --> 00:11:00,304
लिहिण्यासाठी आणखी कोड आहे हे सांगण्याची गरज नाही, परंतु कल्पना

146
00:11:00,304 --> 00:11:05,080
अशी आहे की आमच्या योजनेतील जवळजवळ सर्व मुख्य तर्क एका XOR कपातीवर येतात.

147
00:11:05,080 --> 00:11:09,867
आता, बायनरी आणि XORs आणि सर्वसाधारणपणे सॉफ्टवेअरसह तुमच्या सोयीनुसार, तुम्हाला

148
00:11:09,867 --> 00:11:14,654
एकतर हा दृष्टीकोन थोडा गोंधळात टाकणारा किंवा इतका अधिक मोहक आणि सोपा वाटू शकतो

149
00:11:14,654 --> 00:11:19,320
की, आम्ही सुरुवातीपासूनच याची सुरुवात का केली नाही याचा तुम्हाला प्रश्न पडतो.

150
00:11:19,320 --> 00:11:23,558
- जा हलक्या शब्दात सांगायचे तर, हार्डवेअरमध्ये हॅमिंग कोडची अंमलबजावणी

151
00:11:23,558 --> 00:11:27,439
करताना मल्टीपल पॅरिटी चेक दृष्टीकोन विचार करणे सोपे आहे, आणि XOR

152
00:11:27,439 --> 00:11:31,380
दृष्टीकोन हे सॉफ्टवेअरमध्ये करत असताना विचार करणे सर्वात सोपा आहे.

153
00:11:31,380 --> 00:11:36,385
पहिली गोष्ट हाताने करणे सर्वात सोपी आहे, आणि मला वाटते की या सर्व गोष्टींमध्ये

154
00:11:36,385 --> 00:11:41,326
अंतर्भूत असलेली मूळ अंतर्ज्ञान स्थापित करणे अधिक चांगले कार्य करते, म्हणजे एक

155
00:11:41,326 --> 00:11:46,331
त्रुटी शोधण्यासाठी आवश्यक असलेली माहिती ब्लॉकच्या आकाराच्या लॉगशी संबंधित आहे.

156
00:11:46,331 --> 00:11:51,020
, किंवा दुसर्‍या शब्दात, ब्लॉकचा आकार दुप्पट होताना तो एकावेळी थोडा वाढतो.

157
00:11:51,020 --> 00:11:53,730
येथे संबंधित वस्तुस्थिती अशी आहे की ती माहिती आपल्याला

158
00:11:53,730 --> 00:11:56,440
किती रिडंडन्सीची आवश्यकता आहे याच्याशी थेट संबंधित आहे.

159
00:11:56,440 --> 00:12:00,293
बहुतेक लोकांच्या गुडघेदुखीच्या प्रतिक्रियेच्या विरोधात हेच चालते जेव्हा

160
00:12:00,293 --> 00:12:03,773
ते प्रथम एखादे संदेश त्रुटींना लवचिक बनवण्याचा विचार करतात, जेथे

161
00:12:03,773 --> 00:12:07,520
सामान्यतः संपूर्ण संदेश कॉपी करणे ही मनात येणारी पहिली प्रवृत्ती असते.

162
00:12:07,520 --> 00:12:11,211
आणि मग, तसे, हा संपूर्ण दुसरा मार्ग आहे ज्यामध्ये आपण कधीकधी हॅमिंग कोड

163
00:12:11,211 --> 00:12:14,800
सादर केलेले दिसतो, जिथे आपण संदेश एका मोठ्या मॅट्रिक्सने गुणाकार करतो.

164
00:12:14,800 --> 00:12:19,862
हे एक प्रकारचे छान आहे कारण ते रेखीय कोडच्या विस्तृत कुटुंबाशी संबंधित आहे, परंतु मला

165
00:12:19,862 --> 00:12:25,160
वाटते की ते कोठून येते किंवा ते कसे मोजले जाते याबद्दल जवळजवळ कोणतीही अंतर्ज्ञान देत नाही.

166
00:12:25,160 --> 00:12:28,541
आणि स्केलिंगबद्दल बोलताना, तुमच्या लक्षात येईल की या योजनेची

167
00:12:28,541 --> 00:12:32,200
कार्यक्षमता केवळ आम्ही ब्लॉक आकार वाढवतो तेव्हाच अधिक चांगली होते.

168
00:12:32,200 --> 00:12:37,886
उदाहरणार्थ, आम्ही पाहिले की 256 बिट्ससह, तुम्ही त्यातील केवळ

169
00:12:37,886 --> 00:12:43,480
3% जागा रिडंडंसीसाठी वापरत आहात आणि ते तिथून चांगले होत आहे.

170
00:12:43,480 --> 00:12:49,040
पॅरिटी बिट्सची संख्या एक एक करून वाढत असताना, ब्लॉकचा आकार दुप्पट होत जातो.

171
00:12:49,040 --> 00:12:54,787
आणि जर तुम्ही ते टोकापर्यंत नेले, तर तुमच्याकडे एक दशलक्ष बिट्सचा ब्लॉक असू शकतो, जिथे

172
00:12:54,787 --> 00:13:00,337
तुम्ही तुमच्या पॅरिटी चेकसह अक्षरशः 20 प्रश्न खेळत असाल आणि ते फक्त 21 पॅरिटी बिट्स

173
00:13:00,337 --> 00:13:00,800
वापरते.

174
00:13:00,800 --> 00:13:04,852
आणि जर तुम्ही दशलक्ष बिट्स पाहण्याचा आणि एक त्रुटी शोधण्याचा

175
00:13:04,852 --> 00:13:08,640
विचार करण्यासाठी मागे पाऊल टाकले तर ते खरोखरच वेडे वाटते.

176
00:13:08,640 --> 00:13:13,467
अर्थातच, समस्या अशी आहे की मोठ्या ब्लॉकसह, एक किंवा दोन बिट त्रुटींपेक्षा

177
00:13:13,467 --> 00:13:18,360
जास्त दिसण्याची शक्यता वाढते आणि हॅमिंग कोड त्यापलीकडे काहीही हाताळत नाहीत.

178
00:13:18,360 --> 00:13:22,288
त्यामुळे व्यवहारात, तुम्हाला योग्य आकार शोधायचा आहे

179
00:13:22,288 --> 00:13:26,520
जेणेकरून खूप जास्त बिट फ्लिप होण्याची शक्यता जास्त नसेल.

180
00:13:26,520 --> 00:13:32,696
तसेच, व्यवहारात, त्रुटी थोड्या वेळाने येतात, ज्यामुळे एकाच ब्लॉकचा पूर्णपणे नाश होतो,

181
00:13:32,696 --> 00:13:39,016
त्यामुळे अनेक वेगवेगळ्या ब्लॉक्समध्ये त्रुटी पसरवण्यास मदत करण्यासाठी एक सामान्य युक्ती

182
00:13:39,016 --> 00:13:45,480
म्हणजे त्या ब्लॉक्सना एकमेकांशी जोडणे, जसे की, ते होण्यापूर्वी. बाहेर पाठवले किंवा साठवले.

183
00:13:45,480 --> 00:13:49,005
नंतर पुन्हा, यापैकी बरेच काही अधिक आधुनिक कोडद्वारे पूर्णपणे विवादित

184
00:13:49,005 --> 00:13:52,530
केले जाते, जसे की सामान्यतः वापरल्या जाणार्‍या रीड-सोलोमन अल्गोरिदम,

185
00:13:52,530 --> 00:13:56,259
जे बर्स्ट एरर्स विशेषतः चांगल्या प्रकारे हाताळते आणि प्रत्येक ब्लॉकमध्ये

186
00:13:56,259 --> 00:13:59,580
मोठ्या संख्येने त्रुटींसाठी लवचिक होण्यासाठी ट्यून केले जाऊ शकते.

187
00:13:59,580 --> 00:14:03,000
पण तो दुसर्‍या वेळी विषय आहे.

188
00:14:03,000 --> 00:14:06,963
त्याच्या द आर्ट ऑफ डुइंग सायन्स अँड इंजिनीअरिंग या पुस्तकात, हॅमिंगने

189
00:14:06,963 --> 00:14:10,700
या कोडचा शोध किती क्षुल्लक होता हे आश्चर्यकारकपणे स्पष्ट केले आहे.

190
00:14:10,700 --> 00:14:14,465
त्याने प्रथम सर्व प्रकारच्या विविध योजना वापरून पाहिल्या ज्यामध्ये बिट्सला उच्च

191
00:14:14,465 --> 00:14:18,420
मितीय जाळीच्या भागांमध्ये व्यवस्थित करणे आणि यासारख्या विचित्र गोष्टींचा समावेश आहे.

192
00:14:18,420 --> 00:14:23,153
एररच्या स्थितीचे स्पेलिंग अशा प्रकारे कट रचण्यासाठी पॅरिटी चेक मिळवणे शक्य आहे

193
00:14:23,153 --> 00:14:27,886
ही कल्पना हॅमिंगला तेव्हाच आली जेव्हा त्याने इतर विश्लेषणाच्या गुच्छानंतर मागे

194
00:14:27,886 --> 00:14:32,860
पाऊल टाकले आणि विचारले, ठीक आहे, मी सर्वात कार्यक्षम काय आहे? कदाचित या बद्दल असेल?

195
00:14:32,860 --> 00:14:37,295
पॅरिटी चेक त्याच्या मनात आधीपासूनच होते हे किती महत्वाचे आहे याबद्दल ते

196
00:14:37,295 --> 00:14:42,040
स्पष्टपणे सांगत होते, जे आजच्या पेक्षा 1940 च्या दशकात कमी सामान्य झाले असते.

197
00:14:42,040 --> 00:14:45,802
या पुस्तकात अर्धा डझन वेळा त्यांनी लुई पाश्चरच्या

198
00:14:45,802 --> 00:14:49,640
कोटाचा संदर्भ दिला आहे, नशीब तयार मनाला अनुकूल आहे.

199
00:14:49,640 --> 00:14:55,120
हुशार कल्पना अनेकदा भ्रामकपणे सोप्या दिसतात, ज्यामुळे त्यांचे कमी कौतुक करणे सोपे होते.

200
00:14:55,120 --> 00:14:58,437
सध्या माझी प्रामाणिक आशा आहे की हॅमिंग कोड्स किंवा

201
00:14:58,437 --> 00:15:01,820
किमान अशा कोडची शक्यता तुम्हाला जवळजवळ स्पष्ट वाटते.

202
00:15:01,820 --> 00:15:04,975
परंतु ते प्रत्यक्षात स्पष्ट आहेत असा विचार करून

203
00:15:04,975 --> 00:15:08,000
तुम्ही स्वत:ला फसवू नका, कारण ते नक्कीच नाहीत.

204
00:15:08,000 --> 00:15:11,912
हुशार कल्पना भ्रामकपणे सोप्या दिसण्याच्या कारणाचा एक भाग हा आहे की आपण

205
00:15:11,912 --> 00:15:15,769
फक्त अंतिम परिणाम पाहतो, जे गोंधळलेले होते ते साफ करणे, सर्व चुकीच्या

206
00:15:15,769 --> 00:15:19,737
वळणांचा कधीही उल्लेख न करणे, एखाद्या समस्येच्या सुरुवातीला शोधण्यायोग्य

207
00:15:19,737 --> 00:15:23,980
शक्यतांची जागा किती विस्तीर्ण आहे हे कमी करणे. सोडवण्याची प्रक्रिया, ते सर्व.

208
00:15:23,980 --> 00:15:25,280
पण हे सर्वसाधारणपणे खरे आहे.

209
00:15:25,280 --> 00:15:28,314
मला असे वाटते की काही विशेष शोधांसाठी, एक दुसरे,

210
00:15:28,314 --> 00:15:31,040
सखोल कारण आहे की आपण त्यांचे कमी कौतुक करतो.

211
00:15:31,040 --> 00:15:35,108
माहितीच्या सिद्धांतावर क्लॉड शॅननच्या मुख्य पेपरसह 1948 पर्यंत बिट्सच्या

212
00:15:35,108 --> 00:15:39,400
संदर्भात माहितीचा विचार करणे खरोखरच संपूर्ण सिद्धांतामध्ये एकत्रित झाले होते.

213
00:15:39,400 --> 00:15:43,440
जेव्हा हॅमिंगने त्याचे अल्गोरिदम विकसित केले तेव्हा हे मूलत: समांतर होते.

214
00:15:43,440 --> 00:15:48,768
हा तोच पायाभूत कागद होता ज्याने एका विशिष्ट अर्थाने दाखवून दिले की, किमान सिद्धांतानुसार,

215
00:15:48,768 --> 00:15:53,920
बिट फ्लिपची संभाव्यता कितीही उच्च असली तरीही कार्यक्षम त्रुटी सुधारणे नेहमीच शक्य असते.

216
00:15:53,920 --> 00:15:58,276
शॅनन आणि हॅमिंग यांनी अगदी वेगळ्या गोष्टींवर काम करूनही

217
00:15:58,276 --> 00:16:02,400
बेल लॅबमध्ये एक ऑफिस शेअर केले, जे इथे योगायोगच नाही.

218
00:16:02,400 --> 00:16:07,380
अनेक दशके फास्ट फॉरवर्ड, आणि आजकाल, आपल्यापैकी बरेच जण बिट्स आणि माहितीबद्दल विचार

219
00:16:07,380 --> 00:16:12,540
करण्यात इतके मग्न आहेत की विचार करण्याची ही पद्धत किती वेगळी होती याकडे दुर्लक्ष करणे

220
00:16:12,540 --> 00:16:13,080
सोपे आहे.

221
00:16:13,080 --> 00:16:15,380
गंमत म्हणजे, भावी पिढीच्या विचारसरणीला सर्वात गहनपणे आकार

222
00:16:15,380 --> 00:16:17,920
देणार्‍या कल्पना त्या भावी पिढीला त्यांच्यापेक्षा सोप्या वाटतील.

