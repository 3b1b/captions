1
00:00:00,000 --> 00:00:03,120
मी असे गृहीत धरत आहे की येथे प्रत्येकजण भाग 1 पासून येत आहे.

2
00:00:03,120 --> 00:00:07,751
आम्ही हॅमिंग कोडबद्दल बोलत होतो, डेटाचा एक ब्लॉक तयार करण्याचा एक मार्ग जिथे बहुतेक

3
00:00:07,751 --> 00:00:12,216
बिट एक अर्थपूर्ण संदेश देतात, तर काही इतर एक प्रकारचा रिडंडंसी म्हणून काम करतात,

4
00:00:12,216 --> 00:00:16,406
अशा प्रकारे की जर काही बिट फ्लिप झाले तर एकतर संदेश बिट किंवा रिडंडंसी बिट,

5
00:00:16,406 --> 00:00:20,927
या ब्लॉकमधील काहीही, एक प्राप्तकर्ता त्रुटी आहे हे ओळखण्यास सक्षम असेल आणि त्याचे

6
00:00:20,927 --> 00:00:21,920
निराकरण कसे करावे.

7
00:00:21,920 --> 00:00:25,546
तेथे सादर केलेली मूलभूत कल्पना ही होती की त्रुटीकडे

8
00:00:25,546 --> 00:00:29,800
जाण्यासाठी बायनरी शोधण्यासाठी एकाधिक पॅरिटी चेक कसे वापरायचे.

9
00:00:29,800 --> 00:00:32,817
त्या व्हिडिओमध्ये हॅमिंग कोड शक्य तितक्या हँड्स-ऑन

10
00:00:32,817 --> 00:00:35,420
आणि पुन्हा शोधण्यायोग्य वाटणे हे ध्येय होते.

11
00:00:35,420 --> 00:00:39,854
परंतु जसे तुम्ही हे सॉफ्टवेअर किंवा हार्डवेअरमध्ये प्रत्यक्षात अंमलात आणण्याचा

12
00:00:39,854 --> 00:00:44,120
विचार करू लागता, ते फ्रेमिंग हे कोड्स खरोखर किती सुंदर आहेत हे कमी करू शकते.

13
00:00:44,120 --> 00:00:47,347
तुम्हाला असे वाटेल की तुम्हाला एखादे अल्गोरिदम लिहावे लागेल जे

14
00:00:47,347 --> 00:00:50,779
सर्व संभाव्य त्रुटी स्थानांचा मागोवा ठेवेल आणि प्रत्येक चेकसह त्या

15
00:00:50,779 --> 00:00:54,160
गटाला अर्धा कापून टाकेल, परंतु प्रत्यक्षात ते त्यापेक्षा सोपे आहे.

16
00:00:54,160 --> 00:00:59,580
शेवटच्या व्हिडिओमध्ये आम्ही केलेल्या चार पॅरिटी चेकची उत्तरे तुम्ही होय आणि नाही

17
00:00:59,580 --> 00:01:04,800
ऐवजी 1s आणि 0s अशी वाचली, तर ते बायनरीमधील त्रुटीचे स्थान अक्षरशः स्पष्ट करते.

18
00:01:04,800 --> 00:01:12,640
उदाहरणार्थ, बायनरी मधील 7 ही संख्या 0111 सारखी दिसते, मूलत: ते 4 अधिक 2 अधिक 1 असे म्हणते.

19
00:01:12,640 --> 00:01:17,971
आणि लक्षात घ्या की स्थान 7 कुठे बसते, ते आमच्या समता गटांपैकी पहिल्यावर,

20
00:01:17,971 --> 00:01:22,280
आणि दुसऱ्या आणि तिसऱ्याला प्रभावित करते, परंतु शेवटचे नाही.

21
00:01:22,280 --> 00:01:28,520
त्यामुळे तळापासून वरपर्यंत त्या चार तपासण्यांचे निकाल वाचून त्रुटीची स्थिती स्पष्ट होते.

22
00:01:28,520 --> 00:01:32,980
उदाहरण 7 मध्ये विशेष काही नाही, हे सर्वसाधारणपणे कार्य करते आणि यामुळे

23
00:01:32,980 --> 00:01:37,440
हार्डवेअरमध्ये संपूर्ण योजना लागू करण्याचे तर्क धक्कादायकपणे सोपे होते.

24
00:01:37,440 --> 00:01:40,742
आता ही जादू का घडते हे जर तुम्हाला पहायचे असेल,

25
00:01:40,742 --> 00:01:44,114
तर आमच्या पोझिशन्ससाठी ही 16 इंडेक्स लेबले घ्या,

26
00:01:44,114 --> 00:01:48,311
परंतु त्यांना बेस 10 मध्ये लिहिण्याऐवजी, 0000 ते 1111 पर्यंत

27
00:01:48,311 --> 00:01:50,720
चालणारे ते सर्व बायनरीमध्ये लिहूया.

28
00:01:50,720 --> 00:01:54,273
जसे आम्ही ही बायनरी लेबले त्यांच्या बॉक्समध्ये परत ठेवतो,

29
00:01:54,273 --> 00:01:58,440
मी यावर जोर देतो की ते प्रत्यक्षात पाठवलेल्या डेटापेक्षा वेगळे आहेत.

30
00:01:58,440 --> 00:02:01,294
ते चार समानता गट कुठून आले हे तुम्हाला आणि मला समजण्यास

31
00:02:01,294 --> 00:02:04,200
मदत करण्यासाठी एक संकल्पनात्मक लेबलपेक्षा अधिक काही नाही.

32
00:02:04,200 --> 00:02:08,723
बायनरीमध्ये वर्णन केल्या जाणाऱ्या प्रत्येक गोष्टीचे

33
00:02:08,723 --> 00:02:13,160
वर्णन आपण पाहत आहोत या संभ्रमामुळे कदाचित कमी होईल.

34
00:02:13,160 --> 00:02:15,040
तो वाचतो आहे, तरी.

35
00:02:15,040 --> 00:02:19,578
तुमचे लक्ष या सर्व लेबल्सच्या शेवटच्या बिट्सवर केंद्रित

36
00:02:19,578 --> 00:02:24,280
करा आणि नंतर ते स्थान हायलाइट करा जिथे तो अंतिम बिट 1 आहे.

37
00:02:24,280 --> 00:02:27,912
आम्हाला जे मिळते ते आमच्या चार पॅरिटी गटांपैकी पहिले आहे,

38
00:02:27,912 --> 00:02:31,983
याचा अर्थ तुम्ही त्या पहिल्या चेकचा विचार म्हणून अर्थ लावू शकता,

39
00:02:31,983 --> 00:02:36,680
अरे, जर एखादी त्रुटी असेल, तर त्या त्रुटीच्या स्थितीतील अंतिम बिट 1 आहे का?

40
00:02:36,680 --> 00:02:41,795
त्याचप्रमाणे, जर तुम्ही सेकंड टू लास्ट बिटवर लक्ष केंद्रित केले आणि 1 असलेल्या

41
00:02:41,795 --> 00:02:47,040
सर्व पोझिशन्स हायलाइट केल्यास तुम्हाला आमच्या स्कीममधून दुसरा पॅरिटी ग्रुप मिळेल.

42
00:02:47,040 --> 00:02:51,276
दुसऱ्या शब्दांत, तो दुसरा चेक विचारत आहे, अहो, मला पुन्हा,

43
00:02:51,276 --> 00:02:56,160
जर एखादी त्रुटी असेल, तर त्या स्थितीचा दुसरा टू शेवटचा बिट 1 आहे का?

44
00:02:56,160 --> 00:02:57,160
वगैरे.

45
00:02:57,160 --> 00:03:03,724
तिसरा पॅरिटी चेक प्रत्येक पोझिशनचा कव्हर करतो ज्याचा तिसरा ते शेवटचा बिट चालू

46
00:03:03,724 --> 00:03:10,120
आहे आणि शेवटच्या आठ पोझिशन्सला कव्हर करते, ज्यांची सर्वोच्च ऑर्डर बिट 1 आहे.

47
00:03:10,120 --> 00:03:15,800
आम्ही याआधी जे काही केले ते या चार प्रश्नांची उत्तरे देण्यासारखेच आहे,

48
00:03:15,800 --> 00:03:19,800
जे यामधून बायनरीमधील स्थानाचे स्पेलिंग सारखेच आहे.

49
00:03:19,800 --> 00:03:22,080
मला आशा आहे की हे दोन गोष्टी स्पष्ट करेल.

50
00:03:22,080 --> 00:03:24,533
प्रथम म्हणजे दोन मोठ्या शक्ती असलेल्या आकारांना

51
00:03:24,533 --> 00:03:27,140
ब्लॉक करण्यासाठी पद्धतशीरपणे सामान्यीकरण कसे करावे.

52
00:03:27,140 --> 00:03:30,505
प्रत्येक पोझिशनचे वर्णन करण्यासाठी अधिक बिट्स लागत असल्यास,

53
00:03:30,505 --> 00:03:33,198
जसे की 64 स्पॉट्सचे वर्णन करण्यासाठी सहा बिट्स,

54
00:03:33,198 --> 00:03:36,788
तर त्या प्रत्येक बिट्समुळे आपल्याला समानता गटांपैकी एक मिळेल जो

55
00:03:36,788 --> 00:03:38,640
आपल्याला तपासण्याची आवश्यकता आहे.

56
00:03:38,640 --> 00:03:41,062
तुमच्यापैकी ज्यांनी मी मॅट पार्करसोबत केलेले बुद्धिबळाचे

57
00:03:41,062 --> 00:03:43,400
कोडे पाहिले त्यांना कदाचित हे सर्व अत्यंत परिचित वाटेल.

58
00:03:43,400 --> 00:03:46,476
हे समान मुख्य तर्क आहे, परंतु वेगळ्या समस्येचे

59
00:03:46,476 --> 00:03:49,880
निराकरण करते आणि 64-चौरस बुद्धिबळावर लागू केले जाते.

60
00:03:49,880 --> 00:03:54,163
दुसरी गोष्ट मला आशा आहे की हे स्पष्ट करते की आमचे पॅरिटी बिट्स दोन

61
00:03:54,163 --> 00:03:58,320
पॉवर असलेल्या पोझिशनमध्ये का बसले आहेत, उदाहरणार्थ 1, 2, 4 आणि 8.

62
00:03:58,320 --> 00:04:03,640
ही अशी पोझिशन्स आहेत ज्यांचे बायनरी प्रतिनिधित्व फक्त एक बिट चालू आहे.

63
00:04:03,640 --> 00:04:12,640
याचा अर्थ असा आहे की त्या प्रत्येक पॅरिटी बिट्स चार पॅरिटी गटांपैकी फक्त एकामध्ये बसतात.

64
00:04:12,640 --> 00:04:20,200
आपण हे मोठ्या उदाहरणांमध्ये देखील पाहू शकता, जिथे आपण कितीही मोठे असले तरीही,

65
00:04:20,200 --> 00:04:25,920
प्रत्येक पॅरिटी बिट सोयीस्करपणे फक्त एका गटाला स्पर्श करते.

66
00:04:25,920 --> 00:04:30,352
एकदा आपण समजून घेतले की या समता तपासण्या ज्यावर आम्ही आमचा बराच वेळ लक्ष केंद्रित

67
00:04:30,352 --> 00:04:34,352
केला आहे ते बायनरीमधील त्रुटीची स्थिती स्पष्ट करण्याचा एक चतुर मार्ग आहे,

68
00:04:34,352 --> 00:04:38,676
त्यानंतर आम्ही हॅमिंगबद्दल विचार करण्याच्या वेगळ्या मार्गाने कनेक्शन काढू शकतो.

69
00:04:38,676 --> 00:04:43,217
कोड्स, जे वादातीतपणे बरेच सोपे आणि अधिक शोभिवंत आहेत आणि जे मुळात कोडच्या एका ओळीने

70
00:04:43,217 --> 00:04:43,920
लिहिता येतात.

71
00:04:43,920 --> 00:04:46,200
हे XOR फंक्शनवर आधारित आहे.

72
00:04:46,200 --> 00:04:50,960
XOR, तुमच्यापैकी ज्यांना माहित नाही त्यांच्यासाठी, अनन्य किंवा.

73
00:04:50,960 --> 00:04:57,240
जेव्हा तुम्ही दोन बिट्सचा XOR घेता, तेव्हा त्यापैकी एक बिट चालू असल्यास ते 1 परत करेल,

74
00:04:57,240 --> 00:05:00,200
परंतु दोन्ही चालू किंवा बंद असल्यास नाही.

75
00:05:00,200 --> 00:05:03,760
वेगळ्या पद्धतीने शब्दबद्ध केले तर ही या दोन बिट्सची समानता आहे.

76
00:05:03,760 --> 00:05:07,840
एक गणिती व्यक्ती म्हणून, मी त्याबद्दल अतिरिक्त मोड 2 म्हणून विचार करण्यास प्राधान्य देतो.

77
00:05:07,840 --> 00:05:11,973
आम्ही सामान्यतः दोन भिन्न बिट स्ट्रिंग्सच्या XOR बद्दल बोलतो,

78
00:05:11,973 --> 00:05:14,040
जे मुळात हा घटक घटकानुसार करते.

79
00:05:14,040 --> 00:05:16,280
हे जोडण्यासारखे आहे, परंतु जिथे आपण कधीही वाहून नेत नाही.

80
00:05:16,280 --> 00:05:19,939
पुन्हा, अधिक गणिती कल हे दोन वेक्टर जोडणे आणि

81
00:05:19,939 --> 00:05:23,520
मोड 2 कमी करणे असा विचार करणे पसंत करू शकतात.

82
00:05:23,520 --> 00:05:29,286
जर तुम्ही आत्ताच काही Python उघडले आणि दोन पूर्णांकांमध्ये कॅरेट ऑपरेशन लागू केले,

83
00:05:29,286 --> 00:05:35,400
तर ते हेच करत आहे परंतु हुडच्या खाली असलेल्या त्या संख्यांच्या थोड्या प्रतिनिधित्वासाठी.

84
00:05:35,400 --> 00:05:40,657
तुमच्यासाठी आणि माझ्यासाठी महत्त्वाचा मुद्दा असा आहे की अनेक भिन्न बिट

85
00:05:40,657 --> 00:05:45,988
स्ट्रिंग्सचे XOR घेणे हा वेगवेगळ्या गटांच्या विडंबनांची प्रभावीपणे गणना

86
00:05:45,988 --> 00:05:51,320
करण्याचा एक मार्ग आहे, जसे की स्तंभांप्रमाणेच, सर्व काही एकाच वेळी होते.

87
00:05:51,320 --> 00:05:55,395
हे आम्हाला आमच्या हॅमिंग कोड अल्गोरिदममधील एकाधिक समानता तपासण्यांबद्दल विचार

88
00:05:55,395 --> 00:05:59,680
करण्याचा एक अतिशय आकर्षक मार्ग देते कारण सर्व एकाच ऑपरेशनमध्ये एकत्रित केले जातात.

89
00:05:59,680 --> 00:06:02,800
जरी पहिल्या दृष्टीक्षेपात ते खूप वेगळे दिसते.

90
00:06:02,800 --> 00:06:08,305
विशेषत: बायनरीमध्ये 16 पोझिशन्स लिहा, जसे की आमच्याकडे आधी होती,

91
00:06:08,305 --> 00:06:13,894
आणि आता ज्या पोझिशन्सवर मेसेज बिट ऑन केले आहे ते 1 वर हायलाइट करा

92
00:06:13,894 --> 00:06:19,400
आणि नंतर या पोझिशन्स एका मोठ्या कॉलममध्ये एकत्र करा आणि XOR घ्या.

93
00:06:19,400 --> 00:06:26,135
आपण कदाचित अंदाज लावू शकता की परिणामी तळाशी बसलेले 4 बिट्स 4 पॅरिटी तपासण्यांसारखेच आहेत

94
00:06:26,135 --> 00:06:32,720
ज्या आम्हाला माहित आहेत आणि आवडतात, परंतु नक्की का याचा विचार करण्यासाठी थोडा वेळ घ्या.

95
00:06:32,720 --> 00:06:37,039
हा शेवटचा स्तंभ, उदाहरणार्थ, सर्व पोझिशन्स मोजत आहे ज्याचा शेवटचा बिट 1 आहे,

96
00:06:37,039 --> 00:06:40,854
परंतु आम्ही आधीच केवळ हायलाइट केलेल्या पोझिशन्सपुरते मर्यादित आहोत,

97
00:06:40,854 --> 00:06:45,455
त्यामुळे पहिल्या पॅरिटी गटातून किती हायलाइट केलेल्या पोझिशन्स आल्या हे प्रभावीपणे

98
00:06:45,455 --> 00:06:45,960
मोजत आहे.

99
00:06:45,960 --> 00:06:48,520
त्याला काही अर्थ आहे का?

100
00:06:48,520 --> 00:06:54,435
त्याचप्रमाणे, पुढील स्तंभ दुसऱ्या पॅरिटी गटात किती पोझिशन्स आहेत याची मोजणी करतो,

101
00:06:54,435 --> 00:07:00,640
ज्या पोझिशन्सचा दुसरा ते शेवटचा बिट 1 आहे आणि ज्या हायलाइट केल्या आहेत, आणि असेच पुढे.

102
00:07:00,640 --> 00:07:07,640
आम्ही करत आहोत त्याच गोष्टीकडे दृष्टीकोनातील हा खरोखरच एक छोटासा बदल आहे.

103
00:07:07,640 --> 00:07:10,000
आणि म्हणून ते इथून कुठे जाते हे तुम्हाला माहिती आहे.

104
00:07:10,000 --> 00:07:15,012
बेरीज 0000 असल्याचे सुनिश्चित करण्यासाठी काही विशेष

105
00:07:15,012 --> 00:07:19,640
पॅरिटी बिट्स टॉगल करण्यासाठी प्रेषक जबाबदार आहे.

106
00:07:19,640 --> 00:07:24,093
आता एकदा आमच्याकडे असे झाले की, हे आम्हाला तळाशी असलेले हे चार परिणामी बिट्स

107
00:07:24,093 --> 00:07:28,720
थेट त्रुटीची स्थिती का स्पष्ट करतात याबद्दल विचार करण्याचा एक चांगला मार्ग देते.

108
00:07:28,720 --> 00:07:32,720
समजा या ब्लॉकमध्ये ० ते १ पर्यंत टॉगल केले आहे.

109
00:07:32,720 --> 00:07:38,947
याचा अर्थ असा आहे की त्या बिटची स्थिती आता एकूण XOR मध्ये समाविष्ट केली जाणार आहे,

110
00:07:38,947 --> 00:07:44,800
जी बेरीज 0 वरून बदलते त्याऐवजी हे नवीन समाविष्ट केलेले मूल्य, त्रुटीची स्थिती.

111
00:07:44,800 --> 00:07:49,800
थोडेसे कमी स्पष्टपणे, 1 ते 0 बदलणारी त्रुटी असल्यास तेच खरे आहे.

112
00:07:49,800 --> 00:07:53,494
तुम्ही पहा, जर तुम्ही दोनदा थोडीशी स्ट्रिंग जोडली,

113
00:07:53,494 --> 00:07:59,000
तर ती तिथे अजिबात नसल्यासारखीच आहे, मुळात कारण या जगात 1 अधिक 1 बरोबर 0 आहे.

114
00:07:59,000 --> 00:08:05,400
त्यामुळे एकूण बेरीजमध्ये या स्थितीची एक प्रत जोडल्याने आपण ती हलवत आहोत तसाच परिणाम होतो.

115
00:08:05,400 --> 00:08:13,480
आणि तो परिणाम, पुन्हा, येथे तळाशी एकूण परिणाम त्रुटीची स्थिती स्पष्ट करतो.

116
00:08:13,480 --> 00:08:17,829
हे किती शोभिवंत आहे हे स्पष्ट करण्यासाठी, मी आधी संदर्भित केलेल्या पायथन

117
00:08:17,829 --> 00:08:22,120
कोडची एक ओळ दाखवते, जी रिसीव्हरच्या शेवटी जवळजवळ सर्व लॉजिक कॅप्चर करेल.

118
00:08:22,120 --> 00:08:26,312
आम्ही डेटा ब्लॉकचे नक्कल करण्यासाठी 16 1s आणि 0s चा यादृच्छिक अॅरे तयार

119
00:08:26,312 --> 00:08:29,224
करून सुरुवात करू आणि मी त्याला नावाचे बिट्स देईन,

120
00:08:29,224 --> 00:08:33,184
परंतु अर्थातच सराव मध्ये हे असे काहीतरी असेल जे आम्हाला प्रेषकाकडून

121
00:08:33,184 --> 00:08:37,202
प्राप्त होत असेल आणि त्याऐवजी यादृच्छिक असल्याने ते 5 पॅरिटी बिट्ससह

122
00:08:37,202 --> 00:08:38,600
11 डेटा बिट्स घेऊन जाईल.

123
00:08:38,600 --> 00:08:43,345
जर मी फंक्शनला enumerateBits म्हणतो, तर ते काय करते ते प्रत्येक

124
00:08:43,345 --> 00:08:48,240
बिट्सला संबंधित इंडेक्ससह जोडते, या प्रकरणात 0 ते 15 पर्यंत चालते.

125
00:08:48,240 --> 00:08:52,753
मग जर आपण या सर्व जोड्या, i सारख्या दिसणार्‍या जोड्या लूप करणारी

126
00:08:52,753 --> 00:08:57,059
यादी तयार केली आणि मग आपण फक्त i मूल्य, फक्त निर्देशांक काढू,

127
00:08:57,059 --> 00:09:01,920
तर ते इतके रोमांचक नाही, तर आपल्याला ते निर्देशांक 0 ते 15 परत मिळतात.

128
00:09:01,920 --> 00:09:08,306
पण जर आपण हे फक्त बिट जर करण्याची अट जोडली, म्हणजे जर तो बिट 1 असेल तर 0 नसेल,

129
00:09:08,306 --> 00:09:13,400
तर तो फक्त त्या पोझिशन्स बाहेर काढतो जिथे संबंधित बिट चालू आहे.

130
00:09:13,400 --> 00:09:20,720
या प्रकरणात असे दिसते की ती पोझिशन्स 0, 4, 6, 9, इ.

131
00:09:20,720 --> 00:09:26,101
त्या सर्व पोझिशन्स, चालू केलेल्या बिट्सच्या पोझिशन्स

132
00:09:26,101 --> 00:09:29,960
आणि नंतर त्यांना एकत्र XOR करायचे आहे.

133
00:09:29,960 --> 00:09:33,960
पायथनमध्ये हे करण्यासाठी, मी प्रथम काही उपयुक्त कार्ये आयात करू.

134
00:09:33,960 --> 00:09:39,140
अशाप्रकारे आपण या यादीत reduce() कॉल करू शकतो आणि ते कमी करण्यासाठी XOR फंक्शन वापरू शकतो.

135
00:09:39,140 --> 00:09:44,840
हे मुळात XORs घेऊन, यादीतून मार्ग काढते.

136
00:09:44,840 --> 00:09:52,200
तुमची इच्छा असल्यास, तुम्ही ते XOR फंक्शन कोठूनही आयात न करता स्पष्टपणे लिहू शकता.

137
00:09:52,200 --> 00:09:57,026
तर याक्षणी असे दिसते की जर आपण हे आपल्या 16 बिट्सच्या यादृच्छिक

138
00:09:57,026 --> 00:10:02,080
ब्लॉकवर केले तर ते 9 परत करेल, ज्याचे बायनरी प्रतिनिधित्व 1001 आहे.

139
00:10:02,080 --> 00:10:06,727
आम्ही ते येथे करणार नाही, परंतु तुम्ही एक फंक्शन लिहू शकता जिथे प्रेषक

140
00:10:06,727 --> 00:10:11,570
आवश्यकतेनुसार चार पॅरिटी बिट्स सेट करण्यासाठी बायनरी प्रतिनिधित्व वापरतो,

141
00:10:11,570 --> 00:10:17,200
शेवटी हा ब्लॉक अशा स्थितीत आणतो जिथे कोडची ही ओळ बिट्सच्या संपूर्ण यादीवर चालते. एक 0.

142
00:10:17,200 --> 00:10:20,200
हा एक उत्तम प्रकारे तयार केलेला ब्लॉक मानला जाईल.

143
00:10:20,200 --> 00:10:24,463
काय छान आहे की जर आपण या यादीतील कोणत्याही एका बिट्सला टॉगल केले,

144
00:10:24,463 --> 00:10:29,824
नॉइजमधून यादृच्छिक त्रुटीचे नक्कल करून, जर तुम्ही कोडची हीच ओळ चालवली तर ती त्रुटी

145
00:10:29,824 --> 00:10:30,600
प्रिंट करते.

146
00:10:30,600 --> 00:10:31,920
नीट आहे ना?

147
00:10:31,920 --> 00:10:37,116
तुम्ही हा ब्लॉक निळ्या रंगातून मिळवू शकता, त्यावर ही एकल ओळ

148
00:10:37,116 --> 00:10:42,920
चालवा आणि ती आपोआप त्रुटीची स्थिती बाहेर टाकेल, किंवा जर नसेल तर 0.

149
00:10:42,920 --> 00:10:45,520
आणि येथे 16 आकाराबद्दल काही विशेष नाही.

150
00:10:45,520 --> 00:10:52,280
तुमच्याकडे २५६ बिट्सची यादी असेल तर कोडची समान ओळ काम करेल.

151
00:10:52,280 --> 00:10:55,861
2-बिट त्रुटी शोधण्यासाठी मेटा पॅरिटी चेक करण्यासारखे,

152
00:10:55,861 --> 00:10:59,442
इथे लिहिण्यासाठी आणखी कोड आहे हे सांगण्याची गरज नाही,

153
00:10:59,442 --> 00:11:05,080
परंतु कल्पना अशी आहे की आमच्या योजनेतील जवळजवळ सर्व मुख्य तर्क एका XOR कपातीवर येतात.

154
00:11:05,080 --> 00:11:09,321
आता, बायनरी आणि XORs आणि सर्वसाधारणपणे सॉफ्टवेअरसह तुमच्या सोयीनुसार,

155
00:11:09,321 --> 00:11:14,048
तुम्हाला एकतर हा दृष्टीकोन थोडा गोंधळात टाकणारा किंवा इतका अधिक मोहक आणि सोपा

156
00:11:14,048 --> 00:11:19,320
वाटू शकतो की, आम्ही सुरुवातीपासूनच याची सुरुवात का केली नाही याचा तुम्हाला प्रश्न पडतो.

157
00:11:19,320 --> 00:11:23,558
- जा हलक्या शब्दात सांगायचे तर, हार्डवेअरमध्ये हॅमिंग कोडची अंमलबजावणी

158
00:11:23,558 --> 00:11:26,961
करताना मल्टीपल पॅरिटी चेक दृष्टीकोन विचार करणे सोपे आहे,

159
00:11:26,961 --> 00:11:31,380
आणि XOR दृष्टीकोन हे सॉफ्टवेअरमध्ये करत असताना विचार करणे सर्वात सोपा आहे.

160
00:11:31,380 --> 00:11:36,385
पहिली गोष्ट हाताने करणे सर्वात सोपी आहे, आणि मला वाटते की या सर्व गोष्टींमध्ये

161
00:11:36,385 --> 00:11:40,693
अंतर्भूत असलेली मूळ अंतर्ज्ञान स्थापित करणे अधिक चांगले कार्य करते,

162
00:11:40,693 --> 00:11:46,331
म्हणजे एक त्रुटी शोधण्यासाठी आवश्यक असलेली माहिती ब्लॉकच्या आकाराच्या लॉगशी संबंधित आहे.

163
00:11:46,331 --> 00:11:51,020
, किंवा दुसर्‍या शब्दात, ब्लॉकचा आकार दुप्पट होताना तो एकावेळी थोडा वाढतो.

164
00:11:51,020 --> 00:11:53,730
येथे संबंधित वस्तुस्थिती अशी आहे की ती माहिती आपल्याला

165
00:11:53,730 --> 00:11:56,440
किती रिडंडन्सीची आवश्यकता आहे याच्याशी थेट संबंधित आहे.

166
00:11:56,440 --> 00:12:00,293
बहुतेक लोकांच्या गुडघेदुखीच्या प्रतिक्रियेच्या विरोधात हेच चालते जेव्हा

167
00:12:00,293 --> 00:12:03,505
ते प्रथम एखादे संदेश त्रुटींना लवचिक बनवण्याचा विचार करतात,

168
00:12:03,505 --> 00:12:07,520
जेथे सामान्यतः संपूर्ण संदेश कॉपी करणे ही मनात येणारी पहिली प्रवृत्ती असते.

169
00:12:07,520 --> 00:12:11,211
आणि मग, तसे, हा संपूर्ण दुसरा मार्ग आहे ज्यामध्ये आपण कधीकधी हॅमिंग कोड

170
00:12:11,211 --> 00:12:14,800
सादर केलेले दिसतो, जिथे आपण संदेश एका मोठ्या मॅट्रिक्सने गुणाकार करतो.

171
00:12:14,800 --> 00:12:19,273
हे एक प्रकारचे छान आहे कारण ते रेखीय कोडच्या विस्तृत कुटुंबाशी संबंधित आहे,

172
00:12:19,273 --> 00:12:23,982
परंतु मला वाटते की ते कोठून येते किंवा ते कसे मोजले जाते याबद्दल जवळजवळ कोणतीही

173
00:12:23,982 --> 00:12:25,160
अंतर्ज्ञान देत नाही.

174
00:12:25,160 --> 00:12:28,541
आणि स्केलिंगबद्दल बोलताना, तुमच्या लक्षात येईल की या योजनेची

175
00:12:28,541 --> 00:12:32,200
कार्यक्षमता केवळ आम्ही ब्लॉक आकार वाढवतो तेव्हाच अधिक चांगली होते.

176
00:12:32,200 --> 00:12:37,886
उदाहरणार्थ, आम्ही पाहिले की 256 बिट्ससह, तुम्ही त्यातील केवळ

177
00:12:37,886 --> 00:12:43,480
3% जागा रिडंडंसीसाठी वापरत आहात आणि ते तिथून चांगले होत आहे.

178
00:12:43,480 --> 00:12:49,040
पॅरिटी बिट्सची संख्या एक एक करून वाढत असताना, ब्लॉकचा आकार दुप्पट होत जातो.

179
00:12:49,040 --> 00:12:54,457
आणि जर तुम्ही ते टोकापर्यंत नेले, तर तुमच्याकडे एक दशलक्ष बिट्सचा ब्लॉक असू शकतो,

180
00:12:54,457 --> 00:13:00,337
जिथे तुम्ही तुमच्या पॅरिटी चेकसह अक्षरशः 20 प्रश्न खेळत असाल आणि ते फक्त 21 पॅरिटी बिट्स

181
00:13:00,337 --> 00:13:00,800
वापरते.

182
00:13:00,800 --> 00:13:04,852
आणि जर तुम्ही दशलक्ष बिट्स पाहण्याचा आणि एक त्रुटी शोधण्याचा

183
00:13:04,852 --> 00:13:08,640
विचार करण्यासाठी मागे पाऊल टाकले तर ते खरोखरच वेडे वाटते.

184
00:13:08,640 --> 00:13:13,467
अर्थातच, समस्या अशी आहे की मोठ्या ब्लॉकसह, एक किंवा दोन बिट त्रुटींपेक्षा

185
00:13:13,467 --> 00:13:18,360
जास्त दिसण्याची शक्यता वाढते आणि हॅमिंग कोड त्यापलीकडे काहीही हाताळत नाहीत.

186
00:13:18,360 --> 00:13:22,288
त्यामुळे व्यवहारात, तुम्हाला योग्य आकार शोधायचा आहे

187
00:13:22,288 --> 00:13:26,520
जेणेकरून खूप जास्त बिट फ्लिप होण्याची शक्यता जास्त नसेल.

188
00:13:26,520 --> 00:13:32,696
तसेच, व्यवहारात, त्रुटी थोड्या वेळाने येतात, ज्यामुळे एकाच ब्लॉकचा पूर्णपणे नाश होतो,

189
00:13:32,696 --> 00:13:39,016
त्यामुळे अनेक वेगवेगळ्या ब्लॉक्समध्ये त्रुटी पसरवण्यास मदत करण्यासाठी एक सामान्य युक्ती

190
00:13:39,016 --> 00:13:45,480
म्हणजे त्या ब्लॉक्सना एकमेकांशी जोडणे, जसे की, ते होण्यापूर्वी. बाहेर पाठवले किंवा साठवले.

191
00:13:45,480 --> 00:13:49,566
नंतर पुन्हा, यापैकी बरेच काही अधिक आधुनिक कोडद्वारे पूर्णपणे विवादित केले जाते,

192
00:13:49,566 --> 00:13:52,530
जसे की सामान्यतः वापरल्या जाणार्‍या रीड-सोलोमन अल्गोरिदम,

193
00:13:52,530 --> 00:13:56,259
जे बर्स्ट एरर्स विशेषतः चांगल्या प्रकारे हाताळते आणि प्रत्येक ब्लॉकमध्ये

194
00:13:56,259 --> 00:13:59,580
मोठ्या संख्येने त्रुटींसाठी लवचिक होण्यासाठी ट्यून केले जाऊ शकते.

195
00:13:59,580 --> 00:14:03,000
पण तो दुसर्‍या वेळी विषय आहे.

196
00:14:03,000 --> 00:14:06,453
त्याच्या द आर्ट ऑफ डुइंग सायन्स अँड इंजिनीअरिंग या पुस्तकात,

197
00:14:06,453 --> 00:14:10,700
हॅमिंगने या कोडचा शोध किती क्षुल्लक होता हे आश्चर्यकारकपणे स्पष्ट केले आहे.

198
00:14:10,700 --> 00:14:14,465
त्याने प्रथम सर्व प्रकारच्या विविध योजना वापरून पाहिल्या ज्यामध्ये बिट्सला उच्च

199
00:14:14,465 --> 00:14:18,420
मितीय जाळीच्या भागांमध्ये व्यवस्थित करणे आणि यासारख्या विचित्र गोष्टींचा समावेश आहे.

200
00:14:18,420 --> 00:14:23,153
एररच्या स्थितीचे स्पेलिंग अशा प्रकारे कट रचण्यासाठी पॅरिटी चेक मिळवणे शक्य आहे

201
00:14:23,153 --> 00:14:27,886
ही कल्पना हॅमिंगला तेव्हाच आली जेव्हा त्याने इतर विश्लेषणाच्या गुच्छानंतर मागे

202
00:14:27,886 --> 00:14:32,860
पाऊल टाकले आणि विचारले, ठीक आहे, मी सर्वात कार्यक्षम काय आहे? कदाचित या बद्दल असेल?

203
00:14:32,860 --> 00:14:37,295
पॅरिटी चेक त्याच्या मनात आधीपासूनच होते हे किती महत्वाचे आहे याबद्दल ते

204
00:14:37,295 --> 00:14:42,040
स्पष्टपणे सांगत होते, जे आजच्या पेक्षा 1940 च्या दशकात कमी सामान्य झाले असते.

205
00:14:42,040 --> 00:14:47,608
या पुस्तकात अर्धा डझन वेळा त्यांनी लुई पाश्चरच्या कोटाचा संदर्भ दिला आहे,

206
00:14:47,608 --> 00:14:49,640
नशीब तयार मनाला अनुकूल आहे.

207
00:14:49,640 --> 00:14:55,120
हुशार कल्पना अनेकदा भ्रामकपणे सोप्या दिसतात, ज्यामुळे त्यांचे कमी कौतुक करणे सोपे होते.

208
00:14:55,120 --> 00:14:58,437
सध्या माझी प्रामाणिक आशा आहे की हॅमिंग कोड्स किंवा

209
00:14:58,437 --> 00:15:01,820
किमान अशा कोडची शक्यता तुम्हाला जवळजवळ स्पष्ट वाटते.

210
00:15:01,820 --> 00:15:06,619
परंतु ते प्रत्यक्षात स्पष्ट आहेत असा विचार करून तुम्ही स्वत:ला फसवू नका,

211
00:15:06,619 --> 00:15:08,000
कारण ते नक्कीच नाहीत.

212
00:15:08,000 --> 00:15:11,912
हुशार कल्पना भ्रामकपणे सोप्या दिसण्याच्या कारणाचा एक भाग हा आहे की आपण

213
00:15:11,912 --> 00:15:14,998
फक्त अंतिम परिणाम पाहतो, जे गोंधळलेले होते ते साफ करणे,

214
00:15:14,998 --> 00:15:19,020
सर्व चुकीच्या वळणांचा कधीही उल्लेख न करणे, एखाद्या समस्येच्या सुरुवातीला

215
00:15:19,020 --> 00:15:23,980
शोधण्यायोग्य शक्यतांची जागा किती विस्तीर्ण आहे हे कमी करणे. सोडवण्याची प्रक्रिया, ते सर्व.

216
00:15:23,980 --> 00:15:25,280
पण हे सर्वसाधारणपणे खरे आहे.

217
00:15:25,280 --> 00:15:28,314
मला असे वाटते की काही विशेष शोधांसाठी, एक दुसरे,

218
00:15:28,314 --> 00:15:31,040
सखोल कारण आहे की आपण त्यांचे कमी कौतुक करतो.

219
00:15:31,040 --> 00:15:35,108
माहितीच्या सिद्धांतावर क्लॉड शॅननच्या मुख्य पेपरसह 1948 पर्यंत बिट्सच्या

220
00:15:35,108 --> 00:15:39,400
संदर्भात माहितीचा विचार करणे खरोखरच संपूर्ण सिद्धांतामध्ये एकत्रित झाले होते.

221
00:15:39,400 --> 00:15:43,440
जेव्हा हॅमिंगने त्याचे अल्गोरिदम विकसित केले तेव्हा हे मूलत: समांतर होते.

222
00:15:43,440 --> 00:15:48,768
हा तोच पायाभूत कागद होता ज्याने एका विशिष्ट अर्थाने दाखवून दिले की, किमान सिद्धांतानुसार,

223
00:15:48,768 --> 00:15:53,920
बिट फ्लिपची संभाव्यता कितीही उच्च असली तरीही कार्यक्षम त्रुटी सुधारणे नेहमीच शक्य असते.

224
00:15:53,920 --> 00:16:00,766
शॅनन आणि हॅमिंग यांनी अगदी वेगळ्या गोष्टींवर काम करूनही बेल लॅबमध्ये एक ऑफिस शेअर केले,

225
00:16:00,766 --> 00:16:02,400
जे इथे योगायोगच नाही.

226
00:16:02,400 --> 00:16:07,380
अनेक दशके फास्ट फॉरवर्ड, आणि आजकाल, आपल्यापैकी बरेच जण बिट्स आणि माहितीबद्दल विचार

227
00:16:07,380 --> 00:16:12,540
करण्यात इतके मग्न आहेत की विचार करण्याची ही पद्धत किती वेगळी होती याकडे दुर्लक्ष करणे

228
00:16:12,540 --> 00:16:13,080
सोपे आहे.

229
00:16:13,080 --> 00:16:15,380
गंमत म्हणजे, भावी पिढीच्या विचारसरणीला सर्वात गहनपणे आकार

230
00:16:15,380 --> 00:16:17,920
देणार्‍या कल्पना त्या भावी पिढीला त्यांच्यापेक्षा सोप्या वाटतील.

