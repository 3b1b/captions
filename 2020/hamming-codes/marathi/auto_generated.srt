1
00:00:03,620 --> 00:00:06,927
सीडी किंवा डीव्हीडी स्क्रॅच करणे कसे शक्य आहे आणि तरीही ते जे काही साठवले 

2
00:00:06,927 --> 00:00:10,100
आहे ते पुन्हा प्ले करणे कसे शक्य आहे याचा तुम्ही कधी विचार केला आहे का?

3
00:00:10,900 --> 00:00:13,891
स्क्रॅचचा खरोखरच डिस्कवरील 1s आणि 0s वर परिणाम होतो, 

4
00:00:13,891 --> 00:00:17,166
त्यामुळे तो संग्रहित केलेल्या डेटापासून भिन्न डेटा वाचतो, 

5
00:00:17,166 --> 00:00:20,327
परंतु जोपर्यंत तो खरोखर स्क्रॅच केला जात नाही तोपर्यंत, 

6
00:00:20,327 --> 00:00:25,012
ते वाचलेले बिट्स अगदी त्याच फाईलमध्ये डीकोड केले जातात जी त्यावर एन्कोड केली होती, 

7
00:00:25,012 --> 00:00:27,440
a त्या सर्व त्रुटी असूनही बिट कॉपीसाठी बिट.

8
00:00:27,440 --> 00:00:31,771
गणितीय हुशारीचा एक संपूर्ण ढिगारा आहे जो आपल्याला डेटा संग्रहित करण्यास परवानगी देतो आणि 

9
00:00:31,771 --> 00:00:34,545
त्याचप्रमाणे महत्त्वाचे म्हणजे डेटा प्रसारित करण्यासाठी, 

10
00:00:34,545 --> 00:00:36,200
त्रुटींना लवचिक असलेल्या मार्गाने.

11
00:00:36,200 --> 00:00:40,880
बरं, ठीक आहे, खरं तर हे करण्याचा मार्ग शोधण्यासाठी इतकी हुशारी लागत नाही.

12
00:00:40,880 --> 00:00:45,227
कोणतीही फाईल, मग ती व्हिडिओ असो वा ध्वनी किंवा मजकूर, 

13
00:00:45,227 --> 00:00:50,380
काही कोड, प्रतिमा, काहीही असो, शेवटी 1 आणि 0 चे काही क्रम असतात.

14
00:00:50,680 --> 00:00:53,389
आणि कोणताही बिट जो पलटला जातो तो दुरुस्त करण्यासाठी एक 

15
00:00:53,389 --> 00:00:56,000
साधी रणनीती म्हणजे प्रत्येक बिटच्या तीन प्रती साठवणे.

16
00:00:57,580 --> 00:01:00,713
मग ही फाइल वाचणारे मशीन या तीन प्रतींची तुलना करू शकते आणि 

17
00:01:00,713 --> 00:01:04,060
जेव्हाही विसंगती असेल तेव्हा नेहमी 3 पैकी सर्वोत्तम 2 घेऊ शकते.

18
00:01:07,160 --> 00:01:10,860
पण त्याचा अर्थ असा आहे की तुमच्या दोन तृतीयांश जागा रिडंडंसीसाठी वापरणे.

19
00:01:11,480 --> 00:01:14,417
आणि तरीही, त्या सर्व जागेसाठी, एकापेक्षा जास्त बिट 

20
00:01:14,417 --> 00:01:17,240
फ्लिप झाल्यास काय होईल याची कोणतीही ठोस हमी नाही.

21
00:01:17,980 --> 00:01:21,111
अधिक मनोरंजक प्रश्न म्हणजे ते कसे बनवायचे जेणेकरुन शक्य 

22
00:01:21,111 --> 00:01:24,020
तितक्या कमी जागा सोडताना त्रुटी सुधारल्या जाऊ शकतात.

23
00:01:24,520 --> 00:01:28,543
उदाहरणार्थ, तुम्ही या व्हिडिओबद्दल शिकणार असलेल्या पद्धतीचा वापर करून, 

24
00:01:28,543 --> 00:01:33,360
तुम्ही तुमचा डेटा २५६-बिट ब्लॉक्समध्ये संचयित करू शकता, जिथे प्रत्येक ब्लॉक ९ बिट, ९!

25
00:01:33,760 --> 00:01:37,231
एक प्रकारचा रिडंडंसी म्हणून काम करण्यासाठी, आणि इतर 247 बिट तुम्हाला 

26
00:01:37,231 --> 00:01:40,300
हवा तो अर्थपूर्ण संदेश किंवा डेटा घेऊन जाण्यासाठी मोकळे आहेत.

27
00:01:40,900 --> 00:01:44,031
आणि तरीही असेच असेल की इथे जर काही गडबड झाली तर, 

28
00:01:44,031 --> 00:01:47,866
फक्त हा ब्लॉक बघून आणि आणखी काही नाही, तर मशीन ओळखू शकेल की 

29
00:01:47,866 --> 00:01:52,660
त्रुटी होती आणि ती नेमकी कुठे होती, जेणेकरून ती कशी दुरुस्त करायची ते कळेल.

30
00:01:52,660 --> 00:01:54,620
आणि प्रामाणिकपणे, ते जादूसारखे वाटते.

31
00:01:55,440 --> 00:01:57,975
आणि या विशिष्ट योजनेसाठी, जर दोन बिट्स फ्लिप झाले तर, 

32
00:01:57,975 --> 00:02:00,511
मशीन कमीतकमी दोन त्रुटी असल्याचे शोधण्यास सक्षम असेल, 

33
00:02:00,511 --> 00:02:02,860
परंतु त्या कशा दुरुस्त करायच्या हे माहित नसले तरी.

34
00:02:03,520 --> 00:02:06,900
वेगवेगळ्या आकारांच्या ब्लॉक्ससाठी हे कसे मोजले जाते याबद्दल आम्ही थोड्या वेळाने बोलू.

35
00:02:07,860 --> 00:02:12,900
तुम्हाला यासारख्या चुका दुरुस्त करू देणार्‍या पद्धती एरर सुधारणा कोड म्हणून ओळखल्या जातात.

36
00:02:13,660 --> 00:02:17,774
गेल्या शतकाच्या चांगल्या भागासाठी, हे क्षेत्र आश्चर्यकारकपणे सखोल गणिताचे खरोखर 

37
00:02:17,774 --> 00:02:21,940
समृद्ध स्त्रोत आहे जे आम्ही दररोज वापरत असलेल्या उपकरणांमध्ये समाविष्ट केले जाते.

38
00:02:22,840 --> 00:02:25,509
हॅमिंग कोड म्हणून ओळखल्या जाणार्‍या सर्वात जुन्या 

39
00:02:25,509 --> 00:02:28,660
उदाहरणांपैकी एकाची अगदी सखोल माहिती देणे हे येथे ध्येय आहे.

40
00:02:29,520 --> 00:02:32,936
आणि तसे, या व्हिडिओच्या संरचनेबद्दल मी ज्या प्रकारे विचार करत आहे 

41
00:02:32,936 --> 00:02:37,025
ते शक्य तितके थेट स्पष्ट करणे कमी आहे आणि इकडे-तिकडे थोडे सौम्य मार्गदर्शनासह, 

42
00:02:37,025 --> 00:02:39,820
तुम्हाला स्वतःसाठी ते शोधण्यास प्रवृत्त करणे अधिक आहे.

43
00:02:40,120 --> 00:02:42,846
म्हणून जेव्हा तुम्हाला वाटत असेल की ते कुठे जात आहे ते एखाद्या वेळी, 

44
00:02:42,846 --> 00:02:46,285
तो क्षण थांबण्यासाठी घ्या, मी तुम्हाला सांगण्यापूर्वी ही योजना काय असेल याचा सक्रियपणे 

45
00:02:46,285 --> 00:02:46,720
अंदाज लावा.

46
00:02:47,240 --> 00:02:50,744
तसेच, जर तुम्हाला तुमची समज हार्डवेअरच्या पातळीवर उतरवायची असेल, 

47
00:02:50,744 --> 00:02:54,357
तर बेन ईटरने ब्रेडबोर्डवर हॅमिंग कोड प्रत्यक्षात कसे अंमलात आणायचे 

48
00:02:54,357 --> 00:02:58,240
हे दाखवत याच्या संयोगाने एक व्हिडिओ बनवला आहे, जो अत्यंत समाधानकारक आहे.

49
00:02:59,300 --> 00:03:03,617
तुम्हाला हे माहित असले पाहिजे, हॅमिंग कोड हे रीड-सोलोमन अल्गोरिदम सारख्या आधुनिक 

50
00:03:03,617 --> 00:03:07,989
कोड्सइतके मोठ्या प्रमाणावर वापरले जात नाहीत, परंतु हे कार्य सुरुवातीला किती अशक्य 

51
00:03:07,989 --> 00:03:11,720
वाटते आणि एकदा ते किती वाजवी वाटते यामधील फरकाची एक विशिष्ट जादू आहे. 

52
00:03:11,720 --> 00:03:13,000
तुम्ही हॅमिंगबद्दल शिका.

53
00:03:13,720 --> 00:03:19,501
त्रुटी सुधारण्याचे मूलभूत तत्त्व असे आहे की सर्व संभाव्य संदेशांच्या विशाल जागेत, 

54
00:03:19,501 --> 00:03:22,180
फक्त काही उपसंच वैध संदेश मानले जातील.

55
00:03:22,800 --> 00:03:26,940
एक साधर्म्य म्हणून, अचूक स्पेलिंग शब्द वि चुकीचे स्पेलिंग शब्द बद्दल विचार करा.

56
00:03:28,900 --> 00:03:33,301
जेव्हा जेव्हा एखादा वैध संदेश बदलला जातो, तेव्हा प्राप्तकर्ता जवळच्या वैध शेजाऱ्याला 

57
00:03:33,301 --> 00:03:37,340
जे दिसले ते दुरुस्त करण्यासाठी जबाबदार असतो, जसे तुम्ही टायपिंगमध्ये करू शकता.

58
00:03:38,220 --> 00:03:42,038
अशा संदेशांचे कार्यक्षमतेने वर्गीकरण करण्यासाठी ठोस अल्गोरिदम आणणे, 

59
00:03:42,038 --> 00:03:44,060
तथापि, एक विशिष्ट हुशारी आवश्यक आहे.

60
00:03:46,780 --> 00:03:51,309
कथा 1940 च्या दशकात सुरू होते, जेव्हा एक तरुण रिचर्ड हॅमिंग बेल लॅबसाठी काम करत होता, 

61
00:03:51,309 --> 00:03:54,891
आणि त्याच्या काही कामांमध्ये एक खूप मोठा महाग पंच कार्ड संगणक वापरत 

62
00:03:54,891 --> 00:03:57,420
होता ज्यामध्ये त्याला फक्त मर्यादित प्रवेश होता.

63
00:03:57,800 --> 00:04:00,472
आणि त्याद्वारे तो मांडत राहिलेले कार्यक्रम अयशस्वी होत गेले, 

64
00:04:00,472 --> 00:04:02,400
कारण वेळोवेळी थोडेफार चुकीचे वाचले जात होते.

65
00:04:03,120 --> 00:04:05,692
नैराश्य हे शोधाचे टोक असल्याने तो इतका कंटाळला की 

66
00:04:05,692 --> 00:04:08,420
त्याने जगातील पहिला त्रुटी सुधारणेचा कोड शोधून काढला.

67
00:04:09,060 --> 00:04:11,233
हॅमिंग कोड्स फ्रेम करण्याचे बरेच वेगवेगळे मार्ग आहेत, 

68
00:04:11,233 --> 00:04:14,333
परंतु प्रथम पास म्हणून आम्ही त्यामधून जाणार आहोत ज्या प्रकारे हॅमिंगने स्वतः 

69
00:04:14,333 --> 00:04:15,380
त्यांच्याबद्दल विचार केला.

70
00:04:16,519 --> 00:04:20,940
16 बिट्सच्या ब्लॉकचे एक उदाहरण वापरुया जे सोपे आहे, परंतु खूप सोपे नाही.

71
00:04:21,820 --> 00:04:24,740
आम्ही या बिट्सच्या स्थानांची संख्या 0 ते 15 पर्यंत करू.

72
00:04:25,620 --> 00:04:29,991
आम्‍हाला जो खरा डेटा संग्रहित करायचा आहे तो यापैकी फक्त 12 बिट्स बनवणार आहे, 

73
00:04:29,991 --> 00:04:33,000
तर 4 पोझिशन्स एक प्रकारची रिडंडंसी म्हणून राखीव आहेत.

74
00:04:33,900 --> 00:04:36,442
येथे रिडंडंट शब्दाचा अर्थ फक्त कॉपी असा नाही, शेवटी, 

75
00:04:36,442 --> 00:04:40,040
ते 4 बिट्स आम्हाला डेटाची आंधळेपणाने कॉपी करण्यासाठी पुरेशी जागा देत नाहीत.

76
00:04:40,720 --> 00:04:44,748
त्याऐवजी, त्यांना अधिक सूक्ष्म आणि हुशार प्रकारची अनावश्यकता असणे आवश्यक आहे, 

77
00:04:44,748 --> 00:04:47,280
कोणतीही नवीन माहिती न जोडता, परंतु लवचिकता जोडणे.

78
00:04:48,600 --> 00:04:52,569
तुम्हाला कदाचित हे 4 स्पेशल बिट्स नीटपणे एकत्रितपणे पॅक केले जातील अशी अपेक्षा असेल, 

79
00:04:52,569 --> 00:04:55,137
कदाचित शेवटी किंवा असे काहीतरी, परंतु जसे तुम्ही पहाल, 

80
00:04:55,137 --> 00:04:58,779
त्यांना 2 च्या पॉवर्स असलेल्या पोझिशन्सवर बसवल्याने शेवटपर्यंत खरोखर मोहक असे 

81
00:04:58,779 --> 00:04:59,620
काहीतरी मिळू शकते.

82
00:05:00,200 --> 00:05:03,540
हे तुम्हाला मोठ्या ब्लॉक्ससाठी कसे मोजते याबद्दल थोडीशी सूचना देखील देऊ शकते.

83
00:05:04,900 --> 00:05:07,509
तसेच तांत्रिकदृष्ट्या ते फक्त 11 बिट डेटाचे आहे, 

84
00:05:07,509 --> 00:05:11,343
तुम्हाला 0 च्या स्थानावर काय चालले आहे यासाठी एक सौम्य सूक्ष्मता आढळेल, 

85
00:05:11,343 --> 00:05:13,260
परंतु आत्ता त्याबद्दल काळजी करू नका.

86
00:05:14,140 --> 00:05:18,037
कोणत्याही त्रुटी सुधारण्याच्या अल्गोरिदमप्रमाणे, यात दोन खेळाडूंचा समावेश असेल, 

87
00:05:18,037 --> 00:05:21,691
एक प्रेषक जो या 4 विशेष बिट सेट करण्यासाठी जबाबदार आहे आणि एक प्राप्तकर्ता 

88
00:05:21,691 --> 00:05:25,200
जो काही प्रकारची तपासणी करण्यासाठी आणि त्रुटी सुधारण्यासाठी जबाबदार आहे.

89
00:05:25,200 --> 00:05:28,239
अर्थात, प्रेषक आणि प्राप्तकर्ता हे शब्द खरोखरच सर्व तपासण्या करत 

90
00:05:28,239 --> 00:05:31,326
असलेल्या मशीन्स किंवा सॉफ्टवेअरचा संदर्भ घेतात आणि मेसेजची कल्पना 

91
00:05:31,326 --> 00:05:34,740
म्हणजे स्टोरेजसारख्या गोष्टींचा समावेश करण्यासाठी खरोखरच व्यापक अर्थ आहे.

92
00:05:35,340 --> 00:05:38,310
शेवटी, डेटा संग्रहित करणे हे एका ठिकाणाहून दुसर्‍या 

93
00:05:38,310 --> 00:05:41,680
ठिकाणाऐवजी भूतकाळापासून भविष्यात संदेश पाठविण्यासारखेच आहे.

94
00:05:42,560 --> 00:05:45,754
तर हा सेटअप आहे, परंतु आपण आत जाण्यापूर्वी आपल्याला हॅमिंगच्या 

95
00:05:45,754 --> 00:05:50,165
शोधाच्या वेळी त्याच्या मनावर ताज्या असलेल्या एका संबंधित कल्पनेबद्दल बोलणे आवश्यक आहे, 

96
00:05:50,165 --> 00:05:52,852
एक पद्धत जी आपल्याला कोणत्याही एकल त्रुटी शोधू देते, 

97
00:05:52,852 --> 00:05:56,300
परंतु त्या सुधारू शकत नाही, ज्ञात आहे. समता तपासणी म्हणून व्यवसायात.

98
00:05:56,880 --> 00:06:00,182
समता तपासणीसाठी, आम्ही फक्त एकच बिट वेगळे करतो जो पाठवणारा 

99
00:06:00,182 --> 00:06:03,820
ट्युनिंगसाठी जबाबदार असतो आणि बाकीचे संदेश पाठवण्यास मोकळे असतात.

100
00:06:04,880 --> 00:06:11,280
या स्पेशल बिटचे एकमेव काम म्हणजे मेसेजमधील एकूण 1s ही सम संख्या असल्याची खात्री करणे.

101
00:06:12,080 --> 00:06:15,334
उदाहरणार्थ, आत्ता, 1s ची एकूण संख्या 7 आहे, ती विषम आहे, 

102
00:06:15,334 --> 00:06:19,960
म्हणून प्रेषकाला 1 असण्यासाठी तो विशेष बिट फ्लिप करणे आवश्यक आहे, गणना समान करते.

103
00:06:20,800 --> 00:06:24,184
परंतु जर ब्लॉक आधीच 1s च्या सम संख्येने सुरू झाला असता, 

104
00:06:24,184 --> 00:06:26,420
तर हा विशेष बिट 0 वर ठेवला गेला असता.

105
00:06:27,340 --> 00:06:32,146
हे खूपच सोपे आहे, भ्रामकपणे सोपे आहे, परंतु संदेशामध्ये कुठेही बदल करण्याची कल्पना 

106
00:06:32,146 --> 00:06:36,780
एका छोट्या माहितीमध्ये प्रतिबिंबित करण्याचा हा एक आश्चर्यकारकपणे मोहक मार्ग आहे.

107
00:06:37,500 --> 00:06:43,005
लक्षात घ्या की या संदेशाचा कोणताही भाग 0 ते 1 किंवा 1 ते 0 पर्यंत फ्लिप झाल्यास, 

108
00:06:43,005 --> 00:06:46,540
तो 1s ची एकूण संख्या सम असण्यापासून विषममध्ये बदलतो.

109
00:06:47,980 --> 00:06:50,889
म्हणून जर तुम्ही प्राप्तकर्ता असाल, तर तुम्ही हा संदेश पाहाल, 

110
00:06:50,889 --> 00:06:55,113
आणि तुम्हाला 1s ची विषम संख्या दिसली, तुम्ही निश्चितपणे समजू शकता की काही त्रुटी आली आहे, 

111
00:06:55,113 --> 00:06:57,460
जरी तुम्हाला कदाचित तो कुठे होता याची कल्पना नसेल.

112
00:06:58,500 --> 00:07:00,965
शब्दशैलीमध्ये, बिट्सच्या गटामध्ये 1s ची सम किंवा विषम 

113
00:07:00,965 --> 00:07:03,340
संख्या आहे की नाही हे त्याची समता म्हणून ओळखले जाते.

114
00:07:04,860 --> 00:07:07,688
तुम्ही संख्या देखील वापरू शकता आणि समता 0 किंवा 1 आहे असे म्हणू शकता, 

115
00:07:07,688 --> 00:07:10,720
जे एकदा तुम्ही कल्पनेसह गणित करणे सुरू केले की सामान्यत: अधिक उपयुक्त ठरते.

116
00:07:11,220 --> 00:07:15,520
आणि प्रेषक समता नियंत्रित करण्यासाठी वापरतो या विशेष बिटला पॅरिटी बिट म्हणतात.

117
00:07:17,560 --> 00:07:21,575
आणि प्रत्यक्षात, आपण हे स्पष्ट केले पाहिजे, जर प्राप्तकर्त्याला विषम समता दिसली, 

118
00:07:21,575 --> 00:07:24,698
तर याचा अर्थ फक्त एकच त्रुटी होती असे नाही, 3 त्रुटी, किंवा 5, 

119
00:07:24,698 --> 00:07:28,516
किंवा इतर कोणतीही विषम संख्या असू शकते, परंतु ते निश्चितपणे जाणून घेऊ शकतात. 

120
00:07:28,516 --> 00:07:29,260
की ते 0 नव्हते.

121
00:07:29,980 --> 00:07:34,106
दुसरीकडे, जर 2 चुका झाल्या असत्या, किंवा एररच्या संख्येची संख्या असती, 

122
00:07:34,106 --> 00:07:38,057
तर 1s ची अंतिम गणना अजूनही सम असेल, त्यामुळे प्राप्तकर्त्याला पूर्ण 

123
00:07:38,057 --> 00:07:42,300
विश्वास असू शकत नाही की सम गणनेचा अर्थ असा आहे की संदेश त्रुटी-मुक्त आहे.

124
00:07:42,840 --> 00:07:46,195
तुम्ही तक्रार करू शकता की फक्त 2 बिट फ्लिप्सने गोंधळलेला 

125
00:07:46,195 --> 00:07:49,080
संदेश खूपच कमकुवत आहे आणि तुम्ही अगदी बरोबर असाल.

126
00:07:49,700 --> 00:07:54,141
लक्षात ठेवा, तथापि, त्रुटी शोधण्यासाठी किंवा दुरुस्त करण्याची कोणतीही पद्धत नाही जी 

127
00:07:54,141 --> 00:07:58,900
तुम्हाला 100% आत्मविश्वास देऊ शकेल की तुम्हाला प्राप्त झालेला संदेश पाठवणाऱ्याचा हेतू आहे.

128
00:07:59,580 --> 00:08:02,701
शेवटी, पुरेसा यादृच्छिक आवाज नेहमीच एक वैध संदेश 

129
00:08:02,701 --> 00:08:05,440
दुसर्‍या वैध संदेशात बदलू शकतो केवळ संधीने.

130
00:08:06,240 --> 00:08:10,683
त्याऐवजी, विशिष्ट जास्तीत जास्त त्रुटींपर्यंत मजबुत असलेली योजना आणणे 

131
00:08:10,683 --> 00:08:15,380
किंवा यासारख्या चुकीच्या सकारात्मकतेची संभाव्यता कमी करणे हे उद्दिष्ट आहे.

132
00:08:16,260 --> 00:08:19,103
पॅरिटी चेक त्यांच्या स्वतःहून खूपच कमकुवत आहेत, 

133
00:08:19,103 --> 00:08:22,894
परंतु संपूर्ण संदेशामध्ये बदलाची कल्पना एका क्षणापर्यंत पसरवून, 

134
00:08:22,894 --> 00:08:27,160
ते आम्हाला अधिक अत्याधुनिक योजनांसाठी एक शक्तिशाली बिल्डिंग ब्लॉक देतात.

135
00:08:27,940 --> 00:08:32,652
उदाहरणार्थ, हॅमिंग एरर कुठे घडली हे ओळखण्याचा मार्ग शोधत होता, फक्त ती घडलीच नाही, 

136
00:08:32,652 --> 00:08:37,195
तर त्याची मुख्य माहिती अशी होती की जर तुम्ही काही पॅरिटी चेक पूर्ण मेसेजवर लागू 

137
00:08:37,195 --> 00:08:41,283
केले नाही तर काही काळजीपूर्वक निवडलेल्या उपसंचांना, तुम्ही विचारू शकता. 

138
00:08:41,283 --> 00:08:45,940
प्रश्नांची अधिक परिष्कृत मालिका जी कोणत्याही एका बिट त्रुटीचे स्थान पिन डाउन करते.

139
00:08:46,680 --> 00:08:49,448
एकंदरीत भावना 20 प्रश्नांचा गेम खेळण्यासारखी आहे, 

140
00:08:49,448 --> 00:08:53,380
होय किंवा नाही प्रश्न विचारणे ज्यामुळे शक्यतांची जागा अर्धी कापली जाते.

141
00:08:54,160 --> 00:08:57,677
उदाहरणार्थ, समजा की आम्ही फक्त या 8 बिट्सवर समता तपासणी करतो, 

142
00:08:57,677 --> 00:08:59,380
सर्व विषम क्रमांकित स्थानांवर.

143
00:09:00,100 --> 00:09:04,261
नंतर एखादी त्रुटी आढळल्यास, ती प्राप्तकर्त्याला विशेषतः त्रुटी कुठे 

144
00:09:04,261 --> 00:09:08,240
आहे याबद्दल थोडी अधिक माहिती देते, म्हणजे ती विचित्र स्थितीत आहे.

145
00:09:08,940 --> 00:09:11,884
जर त्या 8 बिट्समध्ये कोणतीही त्रुटी आढळली नाही, 

146
00:09:11,884 --> 00:09:16,240
तर याचा अर्थ एकतर कोणतीही त्रुटी नाही किंवा ती कुठेतरी सम स्थितीत बसते.

147
00:09:17,180 --> 00:09:20,646
तुम्हाला असे वाटेल की समता तपासणी अर्ध्या बिट्सपर्यंत मर्यादित ठेवल्याने 

148
00:09:20,646 --> 00:09:24,065
ते कमी प्रभावी होते, परंतु जेव्हा ते इतर योग्य-निवडलेल्या तपासण्यांच्या 

149
00:09:24,065 --> 00:09:27,200
संयोगाने केले जाते, तेव्हा ते आम्हाला अधिक शक्तिशाली काहीतरी देते.

150
00:09:29,240 --> 00:09:32,139
ती पॅरिटी चेक प्रत्यक्षात सेट करण्यासाठी, लक्षात ठेवा, 

151
00:09:32,139 --> 00:09:36,620
त्या पूर्ण गटाच्या समानतेसाठी नियंत्रण असलेले काही विशेष बिट निश्चित करणे आवश्यक आहे.

152
00:09:37,480 --> 00:09:39,180
येथे फक्त स्थान 1 निवडूया.

153
00:09:39,720 --> 00:09:42,831
दाखवलेल्या उदाहरणासाठी, या 8 बिट्सची पॅरिटी सध्या विषम आहे, 

154
00:09:42,831 --> 00:09:46,980
त्यामुळे प्रेषक त्या पॅरिटी बिटला टॉगल करण्यासाठी जबाबदार आहे आणि आता ते सम आहे.

155
00:09:47,940 --> 00:09:50,680
हे 4 पैकी फक्त 1 पॅरिटी चेक आहे जे आम्ही करू.

156
00:09:50,920 --> 00:09:54,595
दुसरा चेक ग्रिडच्या उजव्या अर्ध्या भागावर असलेल्या 8 बिट्समध्ये आहे, 

157
00:09:54,595 --> 00:09:56,300
कमीतकमी आम्ही तो येथे काढला आहे.

158
00:09:56,680 --> 00:09:59,505
यावेळी आपण पॅरिटी बिट म्हणून पोझिशन 2 वापरू शकतो, 

159
00:09:59,505 --> 00:10:03,969
त्यामुळे या 8 बिट्समध्ये आधीपासून सम पॅरिटी आहे आणि प्रेषकाला तो बिट क्रमांक 2 

160
00:10:03,969 --> 00:10:06,060
अपरिवर्तित ठेवल्यास चांगले वाटू शकते.

161
00:10:07,020 --> 00:10:11,352
मग दुसऱ्या टोकाला, जर प्राप्तकर्त्याने या गटाची समानता तपासली आणि त्यांना ते विचित्र 

162
00:10:11,352 --> 00:10:15,380
असल्याचे आढळले, तर त्यांना कळेल की उजवीकडील या 8 बिट्समध्ये कुठेतरी त्रुटी आहे.

163
00:10:15,820 --> 00:10:20,580
अन्यथा याचा अर्थ एकतर कोणतीही त्रुटी नाही किंवा त्रुटी डाव्या अर्ध्या भागात कुठेतरी आहे.

164
00:10:21,120 --> 00:10:23,727
किंवा मला वाटते की दोन त्रुटी असू शकतात, परंतु आत्ता आम्ही असे 

165
00:10:23,727 --> 00:10:26,500
गृहीत धरणार आहोत की संपूर्ण ब्लॉकमध्ये जास्तीत जास्त एक त्रुटी आहे.

166
00:10:26,940 --> 00:10:28,740
त्याहून अधिक गोष्टींसाठी गोष्टी पूर्णपणे खंडित होतात.

167
00:10:29,160 --> 00:10:32,112
येथे, आम्ही पुढील दोन तपासण्या पाहण्याआधी, जेव्हा तुम्ही त्यांचा एकत्रितपणे विचार 

168
00:10:32,112 --> 00:10:35,100
करता तेव्हा हे पहिले दोन आम्हाला काय करू देतात याचा विचार करण्यासाठी थोडा वेळ द्या.

169
00:10:35,800 --> 00:10:39,660
समजा तुम्हाला विषम स्तंभांमध्ये आणि उजव्या अर्ध्यामध्ये त्रुटी आढळली आहे.

170
00:10:40,200 --> 00:10:43,040
याचा अर्थ शेवटच्या स्तंभात कुठेतरी त्रुटी आहे.

171
00:10:43,820 --> 00:10:47,372
विषम स्तंभामध्ये कोणतीही त्रुटी नसल्यास, परंतु उजव्या अर्ध्या भागात एक त्रुटी असल्यास, 

172
00:10:47,372 --> 00:10:49,700
ते तुम्हाला सांगते की ते दुसऱ्या ते शेवटच्या स्तंभात आहे.

173
00:10:50,440 --> 00:10:53,995
त्याचप्रमाणे जर विषम स्तंभांमध्ये त्रुटी असेल परंतु उजव्या अर्ध्या भागात नसेल, 

174
00:10:53,995 --> 00:10:56,560
तर तुम्हाला माहिती आहे की ती दुसऱ्या स्तंभात कुठेतरी आहे.

175
00:10:56,560 --> 00:10:59,458
आणि जर या दोन्ही पॅरिटी तपासण्यांपैकी काहीही आढळले नाही, 

176
00:10:59,458 --> 00:11:03,120
तर याचा अर्थ एरर असू शकते अशी एकमेव जागा त्या सर्वात डाव्या स्तंभात आहे.

177
00:11:03,340 --> 00:11:06,120
परंतु याचा अर्थ असा असू शकतो की कोणतीही त्रुटी नाही.

178
00:11:06,300 --> 00:11:08,545
दोन पॅरिटी चेक आम्हाला कॉलम पिन डाउन करू द्या 

179
00:11:08,545 --> 00:11:10,840
असे म्हणण्याचा हा सर्व काही उलगडलेला मार्ग आहे.

180
00:11:11,480 --> 00:11:13,640
येथून, आपण कदाचित पुढील काय अंदाज लावू शकता.

181
00:11:13,800 --> 00:11:16,140
आम्ही मुळात तेच करतो पण पंक्तींसाठी.

182
00:11:16,440 --> 00:11:20,900
पॅरिटी बिट म्हणून पोझिशन 4 वापरून विषम पंक्तींवर समता तपासणी केली जाईल.

183
00:11:21,380 --> 00:11:25,820
तर या उदाहरणात त्या गटात आधीपासून सम समता आहे, त्यामुळे बिट 4 0 वर सेट केला जाईल.

184
00:11:26,560 --> 00:11:31,580
आणि शेवटी पॅरिटी बिट म्हणून स्थान 8 वापरून तळाच्या दोन ओळींवर पॅरिटी चेक आहे.

185
00:11:32,120 --> 00:11:36,820
या प्रकरणात, असे दिसते की प्रेषकाने गटाला समानता देण्यासाठी ते बिट 8 चालू करणे आवश्यक आहे.

186
00:11:37,700 --> 00:11:40,026
ज्याप्रमाणे पहिल्या दोन तपासण्या आपल्याला स्तंभ खाली पिन करू देतात, 

187
00:11:40,026 --> 00:11:41,840
त्याचप्रमाणे पुढील दोन आपल्याला पंक्ती पिन करू देतात.

188
00:11:42,880 --> 00:11:47,540
उदाहरण म्हणून, कल्पना करा की ट्रान्समिशन दरम्यान, स्थिती 3 वर एक त्रुटी आहे.

189
00:11:48,180 --> 00:11:52,160
बरं, हे पहिल्या पॅरिटी गटावर परिणाम करते, आणि ते दुसऱ्या पॅरिटी गटावर देखील परिणाम करते, 

190
00:11:52,160 --> 00:11:55,560
म्हणून प्राप्तकर्त्याला माहित आहे की त्या उजव्या स्तंभात कुठेतरी त्रुटी आहे.

191
00:11:56,100 --> 00:12:00,540
परंतु त्याचा तिसऱ्या गटावर परिणाम होत नाही आणि चौथ्या गटावर त्याचा परिणाम होत नाही.

192
00:12:01,240 --> 00:12:04,263
आणि ते प्राप्तकर्त्याला पहिल्या पंक्तीपर्यंत त्रुटी दर्शवू देते, 

193
00:12:04,263 --> 00:12:07,520
ज्याचा अर्थ स्थान 3 असणे आवश्यक आहे, जेणेकरून ते त्रुटी दूर करू शकतात.

194
00:12:08,580 --> 00:12:12,869
या चार प्रश्नांची उत्तरे तुम्हाला नेहमीच विशिष्ट स्थान पिन करू देतात हे 

195
00:12:12,869 --> 00:12:17,100
पटवून देण्यासाठी तुम्हाला थोडा वेळ आनंद वाटेल, मग ते कुठेही असले तरीही.

196
00:12:17,720 --> 00:12:20,844
किंबहुना, तुमच्यातील चतुर लोकांना कदाचित या प्रश्नांचा 

197
00:12:20,844 --> 00:12:23,060
आणि बायनरी मोजणीमधील संबंध लक्षात येईल.

198
00:12:23,500 --> 00:12:26,329
आणि जर तुम्ही असे केले तर, मी पुन्हा जोर देईन, विराम द्या, 

199
00:12:26,329 --> 00:12:28,920
मी ते खराब करण्यापूर्वी कनेक्शन काढण्याचा प्रयत्न करा.

200
00:12:30,500 --> 00:12:34,223
जर तुम्ही विचार करत असाल की पॅरिटी बिट स्वतःच प्रभावित झाल्यास काय होईल, 

201
00:12:34,223 --> 00:12:36,060
ठीक आहे, तुम्ही ते वापरून पाहू शकता.

202
00:12:36,440 --> 00:12:39,843
या चार विशेष बिट्समधील कोणतीही त्रुटी इतर कोणत्याही प्रमाणेच, 

203
00:12:39,843 --> 00:12:44,180
चार प्रश्नांच्या समान गटासह कशी शोधली जाईल याचा विचार करण्यासाठी थोडा वेळ घ्या.

204
00:12:47,060 --> 00:12:51,452
याने काही फरक पडत नाही, कारण दिवसाच्या शेवटी आपल्याला संदेश बिट्सचे संरक्षण करायचे आहे, 

205
00:12:51,452 --> 00:12:53,100
त्रुटी सुधारणे बिट्स सोबतच असतात.

206
00:12:53,600 --> 00:12:55,710
परंतु त्या बिट्सचे संरक्षण करणे ही अशी गोष्ट आहे जी 

207
00:12:55,710 --> 00:12:57,820
नैसर्गिकरित्या उपउत्पादन म्हणून योजनेतून बाहेर पडते.

208
00:12:59,200 --> 00:13:01,760
हे प्रमाण कसे वाढेल याचा अंदाज लावण्याचा तुम्हाला आनंदही वाटेल.

209
00:13:02,300 --> 00:13:07,510
जर आम्ही 256 बिट आकाराचा ब्लॉक वापरला असेल, उदाहरणार्थ, एखादे स्थान पिन डाउन करण्यासाठी, 

210
00:13:07,510 --> 00:13:12,780
तुम्हाला काही विशिष्ट ठिकाणी बायनरी शोधण्यासाठी फक्त आठ होय किंवा नाही प्रश्न आवश्यक आहेत.

211
00:13:15,640 --> 00:13:18,021
आणि लक्षात ठेवा, प्रत्येक प्रश्नासाठी योग्य समता 

212
00:13:18,021 --> 00:13:20,500
तपासणी सेट करण्यासाठी फक्त एक बिट सोडणे आवश्यक आहे.

213
00:13:23,160 --> 00:13:26,324
तुमच्यापैकी काहींनी ते आधीच पाहिले असेल, परंतु हे प्रश्न काय आहेत ते फक्त 

214
00:13:26,324 --> 00:13:29,360
एक किंवा दोन मिनिटांत शोधण्याच्या पद्धतशीर मार्गाबद्दल आम्ही नंतर बोलू.

215
00:13:29,880 --> 00:13:31,553
आशा आहे की आम्ही येथे जे विकसित करत आहोत त्याच्या 

216
00:13:31,553 --> 00:13:33,260
कार्यक्षमतेचे कौतुक करण्यासाठी हे स्केच पुरेसे आहे.

217
00:13:33,260 --> 00:13:37,913
पहिली गोष्ट, त्या आठ हायलाइट केलेले पॅरिटी बिट्स वगळता, 

218
00:13:37,913 --> 00:13:41,820
तुम्हाला हवे ते संदेश किंवा डेटा घेऊन जाऊ शकते.

219
00:13:41,820 --> 00:13:46,558
8 बिट या अर्थाने अनावश्यक आहेत की ते उर्वरित संदेशाद्वारे पूर्णपणे निर्धारित केले जातात, 

220
00:13:46,558 --> 00:13:50,020
परंतु संपूर्ण संदेश कॉपी करण्यापेक्षा ते अधिक हुशार मार्गाने आहे.

221
00:13:53,600 --> 00:13:55,904
आणि तरीही, इतक्या कमी सोडल्याबद्दल, तुम्ही कोणतीही एक 

222
00:13:55,904 --> 00:13:58,380
बिट त्रुटी ओळखण्यास आणि त्याचे निराकरण करण्यात सक्षम असाल.

223
00:13:59,200 --> 00:14:00,400
बरं, जवळजवळ.

224
00:14:00,960 --> 00:14:05,971
ठीक आहे, तर इथे एक अडचण अशी आहे की जर चार पॅरिटी तपासण्यांपैकी एकही त्रुटी आढळली नाही, 

225
00:14:05,971 --> 00:14:09,889
म्हणजे 8 बिट्सच्या विशेष निवडलेल्या उपसमूहांमध्ये समान समानता आहेत, 

226
00:14:09,889 --> 00:14:14,440
जसे की प्रेषकाने अभिप्रेत आहे, तर याचा अर्थ असा होतो की कोणतीही त्रुटी नव्हती. 

227
00:14:14,440 --> 00:14:16,860
, किंवा ते आम्हाला स्थान 0 मध्ये कमी करते.

228
00:14:17,740 --> 00:14:22,478
तुम्ही पहा, चार होय किंवा नाही प्रश्नांसह, आमच्या समता तपासणीसाठी आमच्याकडे 16 संभाव्य 

229
00:14:22,478 --> 00:14:27,216
परिणाम आहेत, आणि सुरुवातीला ब्लॉकमधील 16 पैकी 1 स्थान निश्चित करण्यासाठी योग्य वाटतात, 

230
00:14:27,216 --> 00:14:31,900
परंतु तुम्हाला 17 व्या निकालाशी संवाद साधण्याची आवश्यकता आहे, कोणतीही त्रुटी नाही. अट.

231
00:14:33,020 --> 00:14:37,300
येथे उपाय प्रत्यक्षात खूपच सोपे आहे, फक्त त्या 0व्या बिटबद्दल पूर्णपणे विसरून जा.

232
00:14:37,840 --> 00:14:41,571
म्हणून जेव्हा आम्ही आमच्या चार समानता तपासतो आणि आम्ही पाहतो की ते सर्व समान आहेत, 

233
00:14:41,571 --> 00:14:43,460
याचा अर्थ असा होतो की कोणतीही त्रुटी नाही.

234
00:14:44,240 --> 00:14:48,810
याचा अर्थ असा आहे की 16-बिट ब्लॉकसह काम करण्याऐवजी, आम्ही 15-बिट ब्लॉकसह कार्य करतो, 

235
00:14:48,810 --> 00:14:53,220
जिथे 11 बिट संदेश घेऊन जाण्यासाठी विनामूल्य आहेत आणि त्यापैकी 4 रिडंडंसीसाठी आहेत.

236
00:14:53,780 --> 00:15:00,200
आणि त्यासह, आमच्याकडे आता व्यवसायातील लोक 15-11 हॅमिंग कोड म्हणून संबोधतात.

237
00:15:00,460 --> 00:15:04,230
ते म्हणाले, 2 ची क्लीन पॉवर असणारा ब्लॉक आकार असणे खूप छान आहे आणि एक चतुर मार्ग 

238
00:15:04,230 --> 00:15:08,140
आहे ज्याने आपण तो 0 वा थोडा जवळ ठेवू शकतो आणि आपल्यासाठी थोडे अतिरिक्त काम करू शकतो.

239
00:15:08,700 --> 00:15:12,013
आम्ही संपूर्ण ब्लॉकमध्ये पॅरिटी बिट म्हणून याचा वापर केल्यास, 

240
00:15:12,013 --> 00:15:15,540
ते आम्हाला 2-बिट त्रुटी सुधारू शकत नसले तरी प्रत्यक्षात शोधू देते.

241
00:15:16,160 --> 00:15:16,820
ते कसे कार्य करते ते येथे आहे.

242
00:15:17,180 --> 00:15:19,975
ते चार विशेष एरर-करेक्टिंग बिट्स सेट केल्यानंतर, 

243
00:15:19,975 --> 00:15:24,940
आम्ही ते 0 वा सेट करतो जेणेकरून सामान्य पॅरिटी चेकप्रमाणे पूर्ण ब्लॉकची पॅरिटी सम असेल.

244
00:15:25,700 --> 00:15:30,041
आता, जर एक बिट एरर असेल, तर पूर्ण ब्लॉकची पॅरिटी विषम म्हणून टॉगल करते, 

245
00:15:30,041 --> 00:15:33,600
परंतु तरीही आम्ही चार त्रुटी-सुधारित तपासण्यांमुळे ते पकडू.

246
00:15:34,160 --> 00:15:38,425
तथापि, जर दोन त्रुटी असतील, तर एकूण समानता पुन्हा सम वर टॉगल होणार आहे, 

247
00:15:38,425 --> 00:15:42,158
परंतु प्राप्तकर्त्यास तरीही त्या चार पॅरिटी चेकमध्ये काय चालले 

248
00:15:42,158 --> 00:15:45,180
आहे त्यामुळे किमान काही त्रुटी असल्याचे दिसून येईल.

249
00:15:45,180 --> 00:15:49,041
त्यामुळे जर त्यांना एकंदरीत सम समानता दिसली, परंतु इतर तपासण्यांमध्ये शून्य 

250
00:15:49,041 --> 00:15:52,700
नसलेले काहीतरी घडत आहे, तर ते त्यांना सांगते की किमान दोन त्रुटी होत्या.

251
00:15:53,520 --> 00:15:54,000
हुशार नाही का?

252
00:15:54,300 --> 00:15:57,218
जरी आम्ही त्या 2-बिट चुका दुरुस्त करू शकत नसलो तरी, 

253
00:15:57,218 --> 00:16:01,260
फक्त एक थोडा त्रासदायक 0 वी बिट कामावर ठेवून, ते आम्हाला त्या शोधू देते.

254
00:16:02,260 --> 00:16:05,220
हे खूपच मानक आहे, हे विस्तारित हॅमिंग कोड म्हणून ओळखले जाते.

255
00:16:06,540 --> 00:16:11,090
तांत्रिकदृष्ट्या बोलायचे झाल्यास, हॅमिंग कोड काय करतो याचे संपूर्ण वर्णन तुमच्याकडे आहे, 

256
00:16:11,090 --> 00:16:12,880
किमान 16-बिट ब्लॉकच्या उदाहरणासाठी.

257
00:16:12,880 --> 00:16:17,075
परंतु मला वाटते की तुम्हाला तुमची समज तपासणे अधिक समाधानकारक वाटेल आणि सुरुवातीपासून 

258
00:16:17,075 --> 00:16:21,320
ते स्वतःला पूर्ण करण्यापर्यंत एक पूर्ण उदाहरण देऊन या टप्प्यापर्यंत सर्व काही दृढ करा.

259
00:16:22,080 --> 00:16:24,300
तरीही मी तुमच्याबरोबर यातून मार्ग काढेन जेणेकरून तुम्ही स्वतःला तपासू शकता.

260
00:16:25,120 --> 00:16:28,366
संदेश सेट करण्‍यासाठी, मग तो तुम्‍ही जागेवर भाषांतरित करत असलेला 

261
00:16:28,366 --> 00:16:32,412
शाब्दिक संदेश असो किंवा तुम्‍हाला कालांतराने संचयित करायचा असलेला काही डेटा असो, 

262
00:16:32,412 --> 00:16:34,660
पहिली पायरी म्हणजे 11-बिट भागांमध्ये विभागणे.

263
00:16:35,580 --> 00:16:39,760
प्रत्येक भाग त्रुटी-प्रतिरोधक 16-बिट ब्लॉकमध्ये पॅकेज केला जाईल.

264
00:16:39,760 --> 00:16:43,220
चला तर मग हे एक उदाहरण म्हणून घेऊ आणि ते प्रत्यक्षात आणू.

265
00:16:43,740 --> 00:16:44,740
पुढे जा, प्रत्यक्षात ते करा!

266
00:16:44,740 --> 00:16:47,020
चला थांबा आणि हा ब्लॉक एकत्र ठेवण्याचा प्रयत्न करूया.

267
00:16:52,720 --> 00:16:53,680
ठीक आहे, तुम्ही तयार आहात?

268
00:16:54,240 --> 00:16:59,162
लक्षात ठेवा, स्थान 0 सोबत 2 च्या इतर शक्ती देखील त्रुटी दुरुस्ती कर्तव्यासाठी राखीव आहेत, 

269
00:16:59,162 --> 00:17:03,320
म्हणून तुम्ही क्रमाने उर्वरित सर्व स्पॉट्समध्ये संदेश बिट ठेवून सुरुवात करा.

270
00:17:05,339 --> 00:17:09,268
तुम्‍हाला सम समता असण्‍यासाठी या गटाची आवश्‍यकता आहे, जी ते आधीपासून करत आहे, 

271
00:17:09,268 --> 00:17:12,339
त्यामुळे तुम्‍ही ते पॅरिटी बिट स्‍थिती 1 मध्‍ये 0 असायला हवे.

272
00:17:13,020 --> 00:17:17,880
पुढचा गट विषम समतेने सुरू होतो, त्यामुळे तुम्ही त्याचा पॅरिटी बिट 1 वर सेट केला असावा.

273
00:17:19,160 --> 00:17:21,574
त्यानंतरचा गट विषम पॅरिटीने सुरू होतो, त्यामुळे 

274
00:17:21,574 --> 00:17:24,240
तुम्ही पुन्हा त्याचे पॅरिटी बिट 1 वर सेट केले पाहिजे.

275
00:17:24,780 --> 00:17:27,420
आणि अंतिम गटामध्ये विषम समानता देखील आहे, म्हणजे 

276
00:17:27,420 --> 00:17:30,060
आम्ही ती बिट स्थान 8 मध्ये 1 म्हणून सेट केली आहे.

277
00:17:31,300 --> 00:17:35,509
आणि मग अंतिम पायरी म्हणून, आता पूर्ण ब्लॉकमध्ये सम समानता आहे, 

278
00:17:35,509 --> 00:17:40,320
म्हणजे तुम्ही तो बिट क्रमांक 0, ओव्हरचिंग पॅरिटी बिट, 0 वर सेट करू शकता.

279
00:17:41,340 --> 00:17:45,148
म्हणून हा ब्लॉक पाठवला जात असताना, चार विशेष उपसमूहांची 

280
00:17:45,148 --> 00:17:48,140
समता आणि संपूर्ण ब्लॉक सर्व सम किंवा 0 असेल.

281
00:17:48,820 --> 00:17:52,180
व्यायामाचा दुसरा भाग म्हणून, आपण प्राप्तकर्त्याची भूमिका बजावूया.

282
00:17:53,480 --> 00:17:56,588
अर्थात, याचा अर्थ असा आहे की हा संदेश काय आहे हे तुम्हाला आधीच माहित नाही, 

283
00:17:56,588 --> 00:17:59,780
कदाचित तुमच्यापैकी काहींनी तो लक्षात ठेवला असेल, परंतु समजू की तुम्हाला नाही.

284
00:18:00,020 --> 00:18:04,468
मी काय करणार आहे ते म्हणजे त्या ब्लॉकमधील ०, १, किंवा २ बिट्स बदला, 

285
00:18:04,468 --> 00:18:07,740
आणि मग मी काय केले ते शोधण्यासाठी तुम्हाला सांगेन.

286
00:18:08,260 --> 00:18:10,810
म्हणून पुन्हा, विराम द्या आणि प्रयत्न करा.

287
00:18:18,790 --> 00:18:23,323
ठीक आहे, म्हणून तुम्ही आता प्राप्तकर्ता म्हणून प्रथम पॅरिटी गट तपासा आणि तुम्ही ते सम 

288
00:18:23,323 --> 00:18:27,910
आहे हे पाहू शकता, त्यामुळे अस्तित्वात असलेली कोणतीही त्रुटी सम स्तंभात असणे आवश्यक आहे.

289
00:18:29,690 --> 00:18:33,392
पुढील चेक आम्हाला एक विषम संख्या देतो, कमीतकमी एक त्रुटी 

290
00:18:33,392 --> 00:18:37,030
असल्याचे सांगते आणि आम्हाला या विशिष्ट स्तंभात कमी करते.

291
00:18:38,550 --> 00:18:41,790
तिसरा चेक सम आहे, शक्यता कमी करून आणखी पुढे जाणे.

292
00:18:42,650 --> 00:18:46,336
आणि शेवटची पॅरिटी चेक विषम आहे, आम्हाला सांगते की तळाशी कुठेतरी एक त्रुटी आहे, 

293
00:18:46,336 --> 00:18:49,650
जी आत्तापर्यंत आपण पाहू शकतो की स्थान क्रमांक 10 मध्ये असणे आवश्यक आहे.

294
00:18:51,490 --> 00:18:54,538
इतकेच काय, संपूर्ण ब्लॉकची समानता विषम आहे, ज्यामुळे 

295
00:18:54,538 --> 00:18:57,530
आम्हाला विश्वास मिळतो की एक फ्लिप होता आणि दोन नाही.

296
00:18:58,070 --> 00:18:59,970
ते तीन किंवा अधिक असल्यास, सर्व बेट्स बंद आहेत.

297
00:19:01,310 --> 00:19:05,690
तो बिट क्रमांक 10 दुरुस्त केल्यानंतर, दुरुस्त्यासाठी न वापरलेले 11 बिट्स 

298
00:19:05,690 --> 00:19:09,170
बाहेर काढल्याने आम्हाला मूळ संदेशाचा संबंधित विभाग मिळतो, 

299
00:19:09,170 --> 00:19:14,390
जो तुम्ही रिवाइंड केला आणि तुलना केल्यास तेच खरे आहे ज्याने आम्ही उदाहरण सुरू केले आहे.

300
00:19:15,710 --> 00:19:18,334
आणि आता तुम्हाला हे सर्व हाताने कसे करायचे हे माहित आहे, 

301
00:19:18,334 --> 00:19:22,018
मी तुम्हाला दाखवू इच्छितो की तुम्ही या सर्व तर्काचा मुख्य भाग पायथन कोडच्या एका 

302
00:19:22,018 --> 00:19:23,170
ओळीने कसा पूर्ण करू शकता.

303
00:19:23,870 --> 00:19:29,025
तुम्ही पहा, हे अल्गोरिदम खरोखर किती मोहक आहे, एखादे मशीन मिळवणे किती सोपे आहे, 

304
00:19:29,025 --> 00:19:34,899
ते पद्धतशीरपणे कसे मोजायचे आणि आम्ही सर्व कसे फ्रेम करू शकतो हे मी तुम्हाला सांगितले नाही.

305
00:19:34,899 --> 00:19:38,750
 हे एकाधिक स्वतंत्र समानता तपासण्यांऐवजी एकच ऑपरेशन म्हणून.

306
00:19:39,430 --> 00:19:41,310
मला काय म्हणायचे आहे ते पाहण्यासाठी, माझ्यासोबत भाग २ मध्ये या.

