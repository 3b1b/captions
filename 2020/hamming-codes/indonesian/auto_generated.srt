1
00:00:00,000 --> 00:00:03,120
Saya berasumsi bahwa semua orang di sini berasal dari bagian 1.

2
00:00:03,120 --> 00:00:06,703
Kita berbicara tentang kode Hamming, suatu cara untuk membuat blok data yang

3
00:00:06,703 --> 00:00:09,076
sebagian besar bitnya membawa pesan yang bermakna,

4
00:00:09,076 --> 00:00:12,287
sementara beberapa bit lainnya bertindak sebagai semacam redundansi,

5
00:00:12,287 --> 00:00:15,823
sedemikian rupa sehingga jika ada bit yang dibalik, maka akan muncul pesan.

6
00:00:15,823 --> 00:00:19,686
bit atau bit redundansi, apa pun di blok ini, penerima akan dapat mengidentifikasi

7
00:00:19,686 --> 00:00:21,920
kesalahan yang terjadi, dan cara memperbaikinya.

8
00:00:21,920 --> 00:00:25,974
Ide dasar yang disajikan di sana adalah bagaimana menggunakan beberapa

9
00:00:25,974 --> 00:00:29,800
pemeriksaan paritas untuk mencari biner hingga menemukan kesalahan.

10
00:00:29,800 --> 00:00:32,583
Dalam video tersebut, tujuannya adalah untuk membuat

11
00:00:32,583 --> 00:00:35,420
kode Hamming terasa mudah dan mudah ditemukan kembali.

12
00:00:35,420 --> 00:00:38,304
Namun saat Anda mulai berpikir untuk mengimplementasikannya,

13
00:00:38,304 --> 00:00:40,715
baik dalam perangkat lunak maupun perangkat keras,

14
00:00:40,715 --> 00:00:44,120
pembingkaian tersebut mungkin meremehkan betapa elegannya kode-kode ini.

15
00:00:44,120 --> 00:00:47,343
Anda mungkin berpikir bahwa Anda perlu menulis algoritma yang melacak

16
00:00:47,343 --> 00:00:50,705
semua kemungkinan lokasi kesalahan dan memotong kelompok itu menjadi dua

17
00:00:50,705 --> 00:00:54,160
dengan setiap pemeriksaan, tetapi sebenarnya jauh lebih sederhana dari itu.

18
00:00:54,160 --> 00:00:57,673
Jika Anda membacakan jawaban atas empat pemeriksaan paritas yang kami

19
00:00:57,673 --> 00:01:01,537
lakukan di video terakhir, semuanya dalam angka 1 dan 0, bukan ya dan tidak,

20
00:01:01,537 --> 00:01:04,800
maka secara harfiah posisi kesalahan akan dijabarkan dalam biner.

21
00:01:04,800 --> 00:01:08,795
Misalnya, angka 7 dalam biner terlihat seperti 0111,

22
00:01:08,795 --> 00:01:12,640
yang pada dasarnya berarti 4 ditambah 2 ditambah 1.

23
00:01:12,640 --> 00:01:17,520
Dan perhatikan di mana posisi 7 berada, itu memang mempengaruhi kelompok paritas

24
00:01:17,520 --> 00:01:22,280
pertama kita, dan kelompok paritas kedua, dan ketiga, tapi bukan yang terakhir.

25
00:01:22,280 --> 00:01:25,400
Jadi membaca hasil keempat pemeriksaan tersebut dari

26
00:01:25,400 --> 00:01:28,520
bawah ke atas memang menunjukkan posisi kesalahannya.

27
00:01:28,520 --> 00:01:31,808
Tidak ada yang istimewa dari contoh 7, ini berfungsi secara umum,

28
00:01:31,808 --> 00:01:36,194
dan ini membuat logika untuk mengimplementasikan keseluruhan skema pada perangkat keras

29
00:01:36,194 --> 00:01:37,440
menjadi sangat sederhana.

30
00:01:37,440 --> 00:01:41,320
Sekarang jika Anda ingin melihat mengapa keajaiban ini terjadi,

31
00:01:41,320 --> 00:01:46,717
ambil 16 label indeks ini untuk posisi kita, tapi daripada menuliskannya dalam basis 10,

32
00:01:46,717 --> 00:01:50,720
mari kita tulis semuanya dalam biner, mulai dari 0000 hingga 1111.

33
00:01:50,720 --> 00:01:53,839
Saat kita mengembalikan label biner ini ke dalam kotaknya,

34
00:01:53,839 --> 00:01:58,440
izinkan saya menekankan bahwa label tersebut berbeda dari data yang sebenarnya dikirim.

35
00:01:58,440 --> 00:02:01,365
Itu tidak lebih dari sebuah label konseptual untuk membantu Anda

36
00:02:01,365 --> 00:02:04,200
dan saya memahami dari mana empat kelompok paritas itu berasal.

37
00:02:04,200 --> 00:02:08,550
Keanggunan dalam mendeskripsikan segala sesuatu yang kita lihat dalam biner mungkin

38
00:02:08,550 --> 00:02:13,160
dilemahkan oleh kebingungan karena segala sesuatu yang kita lihat dijelaskan dalam biner.

39
00:02:13,160 --> 00:02:15,040
Tapi itu sepadan.

40
00:02:15,040 --> 00:02:20,111
Fokuskan perhatian Anda hanya pada bagian terakhir dari semua label ini,

41
00:02:20,111 --> 00:02:24,280
lalu sorot posisi di mana bagian terakhir tersebut adalah 1.

42
00:02:24,280 --> 00:02:28,128
Apa yang kita dapatkan adalah yang pertama dari empat kelompok paritas,

43
00:02:28,128 --> 00:02:32,404
yang berarti Anda dapat menafsirkan pemeriksaan pertama itu sebagai pertanyaan,

44
00:02:32,404 --> 00:02:36,680
hei, jika ada kesalahan, apakah bit terakhir pada posisi kesalahan itu adalah 1?

45
00:02:36,680 --> 00:02:40,810
Demikian pula, jika Anda fokus pada bit kedua hingga terakhir,

46
00:02:40,810 --> 00:02:45,990
dan menyorot semua posisi yang bernilai 1, Anda mendapatkan grup paritas kedua

47
00:02:45,990 --> 00:02:47,040
dari skema kami.

48
00:02:47,040 --> 00:02:51,534
Dengan kata lain, pengecekan kedua itu menanyakan, hai, sekali lagi,

49
00:02:51,534 --> 00:02:56,160
jika ada kesalahan, apakah bit kedua dari posisi terakhir itu adalah 1?

50
00:02:56,160 --> 00:02:57,160
Dan seterusnya.

51
00:02:57,160 --> 00:03:01,436
Pemeriksaan paritas ketiga mencakup setiap posisi yang bit ketiga

52
00:03:01,436 --> 00:03:06,815
hingga terakhirnya diaktifkan, dan yang terakhir mencakup delapan posisi terakhir,

53
00:03:06,815 --> 00:03:10,120
yaitu posisi yang bit urutan tertingginya adalah 1.

54
00:03:10,120 --> 00:03:15,794
Semua yang kita lakukan sebelumnya sama dengan menjawab keempat pertanyaan tersebut,

55
00:03:15,794 --> 00:03:19,800
yang pada gilirannya sama dengan mengeja posisi dalam biner.

56
00:03:19,800 --> 00:03:22,080
Saya harap ini membuat dua hal menjadi lebih jelas.

57
00:03:22,080 --> 00:03:24,732
Yang pertama adalah bagaimana menggeneralisasi secara sistematis

58
00:03:24,732 --> 00:03:27,140
ke ukuran blok yang merupakan pangkat dua yang lebih besar.

59
00:03:27,140 --> 00:03:31,066
Jika diperlukan lebih banyak bit untuk mendeskripsikan setiap posisi,

60
00:03:31,066 --> 00:03:33,815
seperti enam bit untuk mendeskripsikan 64 titik,

61
00:03:33,815 --> 00:03:38,640
maka setiap bit tersebut memberi Anda salah satu grup paritas yang perlu kita periksa.

62
00:03:38,640 --> 00:03:40,944
Bagi Anda yang menonton teka-teki papan catur yang saya buat

63
00:03:40,944 --> 00:03:43,400
bersama Matt Parker mungkin menganggap semua ini sangat familiar.

64
00:03:43,400 --> 00:03:46,929
Logika intinya sama, tetapi memecahkan masalah yang berbeda,

65
00:03:46,929 --> 00:03:49,880
dan diterapkan pada papan catur berukuran 64 kotak.

66
00:03:49,880 --> 00:03:53,874
Hal kedua yang saya harap dapat dijelaskan adalah mengapa bit

67
00:03:53,874 --> 00:03:58,320
paritas kita berada pada posisi pangkat dua, misalnya 1, 2, 4, dan 8.

68
00:03:58,320 --> 00:04:03,640
Ini adalah posisi yang representasi binernya hanya diaktifkan satu bit.

69
00:04:03,640 --> 00:04:08,053
Artinya, masing-masing bit paritas tersebut berada

70
00:04:08,053 --> 00:04:12,640
di dalam satu dan hanya satu dari empat grup paritas.

71
00:04:12,640 --> 00:04:17,360
Anda juga dapat melihat ini dalam contoh yang lebih besar,

72
00:04:17,360 --> 00:04:21,840
di mana tidak peduli seberapa besar yang Anda dapatkan,

73
00:04:21,840 --> 00:04:25,920
setiap bit paritas hanya menyentuh salah satu grup.

74
00:04:25,920 --> 00:04:29,442
Setelah Anda memahami bahwa pemeriksaan paritas yang telah kita fokuskan

75
00:04:29,442 --> 00:04:32,965
sebagian besar waktu kita tidak lebih dari cara cerdas untuk menguraikan

76
00:04:32,965 --> 00:04:36,584
posisi kesalahan dalam biner, maka kita dapat menghubungkannya dengan cara

77
00:04:36,584 --> 00:04:40,204
berpikir yang berbeda tentang hamming. kode, yang bisa dibilang jauh lebih

78
00:04:40,204 --> 00:04:43,920
sederhana dan elegan, dan pada dasarnya dapat ditulis dengan satu baris kode.

79
00:04:43,920 --> 00:04:46,200
Ini didasarkan pada fungsi XOR.

80
00:04:46,200 --> 00:04:50,960
XOR bagi anda yang belum tahu, singkatan dari Exclusive or.

81
00:04:50,960 --> 00:04:55,635
Saat Anda mengambil XOR dari dua bit, itu akan mengembalikan 1 jika salah satu dari

82
00:04:55,635 --> 00:05:00,200
bit tersebut diaktifkan, tetapi tidak jika keduanya diaktifkan atau dinonaktifkan.

83
00:05:00,200 --> 00:05:03,760
Dengan kata lain, ini adalah paritas dari dua bit ini.

84
00:05:03,760 --> 00:05:07,840
Sebagai orang matematika, saya lebih suka menganggapnya sebagai mod penjumlahan 2.

85
00:05:07,840 --> 00:05:11,440
Kita juga biasa berbicara tentang XOR dari dua string bit yang berbeda,

86
00:05:11,440 --> 00:05:14,040
yang pada dasarnya melakukan komponen demi komponen.

87
00:05:14,040 --> 00:05:16,280
Ini seperti tambahan, tetapi Anda tidak pernah membawanya.

88
00:05:16,280 --> 00:05:19,952
Sekali lagi, mereka yang lebih cenderung matematis mungkin lebih suka

89
00:05:19,952 --> 00:05:23,520
menganggap ini sebagai penjumlahan dua vektor dan pengurangan mod 2.

90
00:05:23,520 --> 00:05:27,285
Jika Anda membuka beberapa Python sekarang dan menerapkan

91
00:05:27,285 --> 00:05:30,466
operasi tanda sisipan antara dua bilangan bulat,

92
00:05:30,466 --> 00:05:35,400
inilah yang dilakukannya kecuali representasi bit dari angka-angka tersebut.

93
00:05:35,400 --> 00:05:40,684
Poin kuncinya bagi Anda dan saya adalah bahwa mengambil XOR dari banyak string

94
00:05:40,684 --> 00:05:45,768
bit yang berbeda secara efektif merupakan cara untuk menghitung parodi dari

95
00:05:45,768 --> 00:05:51,320
sekelompok grup terpisah, seperti halnya dengan kolom, semuanya dalam satu gerakan.

96
00:05:51,320 --> 00:05:53,923
Ini memberi kita cara yang agak menarik untuk memikirkan

97
00:05:53,923 --> 00:05:56,527
tentang beberapa pemeriksaan paritas dari algoritma kode

98
00:05:56,527 --> 00:05:59,680
Hamming karena semuanya dikemas bersama menjadi satu operasi tunggal.

99
00:05:59,680 --> 00:06:02,800
Meski sekilas memang terlihat sangat berbeda.

100
00:06:02,800 --> 00:06:09,167
Secara khusus tuliskan 16 posisi dalam biner, seperti yang kita lakukan sebelumnya,

101
00:06:09,167 --> 00:06:13,866
dan sekarang sorot posisi di mana bit pesan diubah menjadi 1,

102
00:06:13,866 --> 00:06:19,400
lalu kumpulkan posisi-posisi ini ke dalam satu kolom besar dan ambil XOR.

103
00:06:19,400 --> 00:06:24,025
Anda mungkin dapat menebak bahwa 4 bit yang berada di bagian bawah sebagai

104
00:06:24,025 --> 00:06:28,711
hasilnya sama dengan 4 pemeriksaan paritas yang telah kita kenal dan sukai,

105
00:06:28,711 --> 00:06:32,720
tetapi luangkan waktu sejenak untuk memikirkan alasan sebenarnya.

106
00:06:32,720 --> 00:06:37,203
Kolom terakhir ini, misalnya, menghitung semua posisi yang bit terakhirnya adalah 1,

107
00:06:37,203 --> 00:06:40,263
namun kita sudah dibatasi hanya pada posisi yang disorot,

108
00:06:40,263 --> 00:06:44,588
sehingga secara efektif menghitung berapa banyak posisi yang disorot yang berasal

109
00:06:44,588 --> 00:06:45,960
dari grup paritas pertama.

110
00:06:45,960 --> 00:06:48,520
Apakah itu masuk akal?

111
00:06:48,520 --> 00:06:54,613
Demikian pula, kolom berikutnya menghitung berapa banyak posisi dalam grup paritas kedua,

112
00:06:54,613 --> 00:07:00,640
posisi yang bit kedua hingga terakhirnya adalah 1, dan yang juga disorot, dan seterusnya.

113
00:07:00,640 --> 00:07:04,102
Ini hanyalah perubahan kecil dalam perspektif

114
00:07:04,102 --> 00:07:07,640
terhadap hal yang sama yang telah kita lakukan.

115
00:07:07,640 --> 00:07:10,000
Jadi Anda tahu ke mana perginya setelah ini.

116
00:07:10,000 --> 00:07:14,820
Pengirim bertanggung jawab untuk mengubah beberapa bit

117
00:07:14,820 --> 00:07:19,640
paritas khusus untuk memastikan jumlahnya menjadi 0000.

118
00:07:19,640 --> 00:07:21,795
Sekarang setelah kita memilikinya seperti ini,

119
00:07:21,795 --> 00:07:24,776
ini memberi kita cara yang sangat bagus untuk memikirkan mengapa

120
00:07:24,776 --> 00:07:28,720
keempat bit yang dihasilkan di bawah ini secara langsung menguraikan posisi kesalahan.

121
00:07:28,720 --> 00:07:32,720
Katakanlah beberapa bit di blok ini diubah dari 0 menjadi 1.

122
00:07:32,720 --> 00:07:38,607
Artinya adalah posisi bit tersebut sekarang akan dimasukkan dalam total XOR,

123
00:07:38,607 --> 00:07:44,800
yang mengubah jumlah dari 0 menjadi nilai yang baru dimasukkan, posisi kesalahan.

124
00:07:44,800 --> 00:07:47,406
Sedikit kurang jelas, hal yang sama juga berlaku

125
00:07:47,406 --> 00:07:49,800
jika ada kesalahan yang mengubah 1 menjadi 0.

126
00:07:49,800 --> 00:07:52,885
Soalnya, jika Anda menambahkan sedikit string dua kali,

127
00:07:52,885 --> 00:07:55,749
itu sama saja dengan tidak memilikinya sama sekali,

128
00:07:55,749 --> 00:07:59,000
pada dasarnya karena di dunia ini 1 tambah 1 sama dengan 0.

129
00:07:59,000 --> 00:08:02,200
Jadi menambahkan salinan posisi ini ke jumlah total

130
00:08:02,200 --> 00:08:05,400
memiliki efek yang sama seperti kita memindahkannya.

131
00:08:05,400 --> 00:08:13,480
Dan efeknya, sekali lagi, adalah hasil total di bawah ini menjelaskan posisi kesalahannya.

132
00:08:13,480 --> 00:08:15,708
Untuk mengilustrasikan betapa elegannya hal ini,

133
00:08:15,708 --> 00:08:19,482
izinkan saya menunjukkan satu baris kode Python yang saya referensikan sebelumnya,

134
00:08:19,482 --> 00:08:22,120
yang akan menangkap hampir semua logika di pihak penerima.

135
00:08:22,120 --> 00:08:26,900
Kita akan mulai dengan membuat array acak 16 1 dan 0 untuk mensimulasikan blok data,

136
00:08:26,900 --> 00:08:30,950
dan saya akan memberinya nama bit, tapi tentu saja dalam praktiknya ini

137
00:08:30,950 --> 00:08:35,393
akan menjadi sesuatu yang kita terima dari pengirim, dan bukannya karena acak,

138
00:08:35,393 --> 00:08:38,600
ia akan membawa 11 bit data bersama dengan 5 bit paritas.

139
00:08:38,600 --> 00:08:43,002
Jika saya memanggil fungsi enumerateBits, yang dilakukannya adalah memasangkan

140
00:08:43,002 --> 00:08:46,011
masing-masing bit tersebut dengan indeks yang sesuai,

141
00:08:46,011 --> 00:08:48,240
dalam hal ini berjalan dari 0 hingga 15.

142
00:08:48,240 --> 00:08:52,178
Jadi jika kita kemudian membuat daftar yang mengulang semua pasangan ini,

143
00:08:52,178 --> 00:08:56,437
pasangan yang terlihat seperti i, dan kemudian kita hanya mengeluarkan nilai i,

144
00:08:56,437 --> 00:09:00,802
hanya indeksnya, itu tidak terlalu menarik, kita hanya mendapatkan kembali indeks

145
00:09:00,802 --> 00:09:01,920
tersebut 0 sampai 15.

146
00:09:01,920 --> 00:09:05,949
Tetapi jika kita menambahkan kondisi untuk hanya melakukan ini jika bit,

147
00:09:05,949 --> 00:09:08,874
yang berarti jika bit tersebut adalah 1 dan bukan 0,

148
00:09:08,874 --> 00:09:13,400
maka bit tersebut hanya akan menarik keluar posisi di mana bit terkait diaktifkan.

149
00:09:13,400 --> 00:09:20,720
Dalam hal ini sepertinya posisi tersebut adalah 0, 4, 6, 9, dst.

150
00:09:20,720 --> 00:09:25,139
Apa yang kita inginkan adalah mengumpulkan semua posisi tersebut,

151
00:09:25,139 --> 00:09:29,960
posisi bit-bit yang diaktifkan, dan kemudian melakukan XOR bersama-sama.

152
00:09:29,960 --> 00:09:31,860
Untuk melakukan ini dengan Python, izinkan saya

153
00:09:31,860 --> 00:09:33,960
mengimpor beberapa fungsi bermanfaat terlebih dahulu.

154
00:09:33,960 --> 00:09:36,966
Dengan begitu kita bisa memanggil pengurangan() pada daftar ini,

155
00:09:36,966 --> 00:09:39,140
dan menggunakan fungsi XOR untuk menguranginya.

156
00:09:39,140 --> 00:09:44,840
Ini pada dasarnya memakan seluruh daftar, mengambil XOR di sepanjang jalan.

157
00:09:44,840 --> 00:09:48,274
Jika mau, Anda dapat menulis fungsi XOR tersebut

158
00:09:48,274 --> 00:09:52,200
secara eksplisit tanpa harus mengimpornya dari mana pun.

159
00:09:52,200 --> 00:09:57,469
Jadi saat ini sepertinya jika kita melakukan ini pada blok acak 16 bit,

160
00:09:57,469 --> 00:10:02,080
ia akan mengembalikan 9, yang memiliki representasi biner 1001.

161
00:10:02,080 --> 00:10:05,724
Kami tidak akan melakukannya di sini, tetapi Anda dapat menulis fungsi di

162
00:10:05,724 --> 00:10:09,418
mana pengirim menggunakan representasi biner tersebut untuk mengatur empat

163
00:10:09,418 --> 00:10:13,210
bit paritas sesuai kebutuhan, yang pada akhirnya membuat blok ini ke keadaan

164
00:10:13,210 --> 00:10:17,200
di mana menjalankan baris kode ini pada daftar bit lengkap akan kembali sebuah 0.

165
00:10:17,200 --> 00:10:20,200
Ini akan dianggap sebagai blok yang dipersiapkan dengan baik.

166
00:10:20,200 --> 00:10:24,006
Yang keren adalah jika kita mengganti salah satu bit dalam daftar ini,

167
00:10:24,006 --> 00:10:27,705
menyimulasikan kesalahan acak dari noise, lalu jika Anda menjalankan

168
00:10:27,705 --> 00:10:30,600
baris kode yang sama, kesalahan tersebut akan dicetak.

169
00:10:30,600 --> 00:10:31,920
Bukankah itu rapi?

170
00:10:31,920 --> 00:10:37,786
Anda bisa mendapatkan blok ini secara tiba-tiba, menjalankan satu baris ini di atasnya,

171
00:10:37,786 --> 00:10:42,920
dan secara otomatis akan memunculkan posisi kesalahan, atau 0 jika tidak ada.

172
00:10:42,920 --> 00:10:45,520
Dan tidak ada yang istimewa dari ukuran 16 di sini.

173
00:10:45,520 --> 00:10:52,280
Baris kode yang sama akan berfungsi jika Anda memiliki daftar, katakanlah, 256 bit.

174
00:10:52,280 --> 00:10:55,756
Tak perlu dikatakan, ada lebih banyak kode untuk ditulis di sini,

175
00:10:55,756 --> 00:10:59,812
seperti melakukan pemeriksaan meta paritas untuk mendeteksi kesalahan 2-bit,

176
00:10:59,812 --> 00:11:03,815
namun idenya adalah bahwa hampir semua logika inti dari skema kita turun ke

177
00:11:03,815 --> 00:11:05,080
pengurangan XOR tunggal.

178
00:11:05,080 --> 00:11:08,665
Sekarang, tergantung pada kenyamanan Anda dengan biner dan XOR serta

179
00:11:08,665 --> 00:11:12,200
perangkat lunak secara umum, Anda mungkin menganggap perspektif ini

180
00:11:12,200 --> 00:11:15,785
sedikit membingungkan, atau jauh lebih elegan dan sederhana sehingga

181
00:11:15,785 --> 00:11:19,320
Anda bertanya-tanya mengapa kami tidak memulainya dari awal. -pergi.

182
00:11:19,320 --> 00:11:22,187
Secara longgar, perspektif pemeriksaan paritas berganda lebih mudah

183
00:11:22,187 --> 00:11:25,223
untuk dipikirkan ketika mengimplementasikan kode Hamming pada perangkat

184
00:11:25,223 --> 00:11:28,259
keras secara langsung, dan perspektif XOR paling mudah untuk dipikirkan

185
00:11:28,259 --> 00:11:31,380
ketika melakukannya dalam perangkat lunak, dari tingkat yang lebih tinggi.

186
00:11:31,380 --> 00:11:34,334
Yang pertama paling mudah dilakukan dengan tangan,

187
00:11:34,334 --> 00:11:39,432
dan menurut saya ini lebih baik dalam menanamkan intuisi inti yang mendasari semua ini,

188
00:11:39,432 --> 00:11:44,299
yaitu bahwa informasi yang diperlukan untuk menemukan satu kesalahan terkait dengan

189
00:11:44,299 --> 00:11:49,166
log ukuran blok. , atau dengan kata lain, ia bertambah sedikit demi sedikit seiring

190
00:11:49,166 --> 00:11:51,020
dengan bertambahnya ukuran blok.

191
00:11:51,020 --> 00:11:53,575
Fakta yang relevan di sini adalah bahwa informasi tersebut secara

192
00:11:53,575 --> 00:11:56,440
langsung berhubungan dengan seberapa banyak redundansi yang kita butuhkan.

193
00:11:56,440 --> 00:12:00,103
Hal itulah yang bertentangan dengan reaksi spontan kebanyakan orang ketika mereka

194
00:12:00,103 --> 00:12:03,454
pertama kali berpikir untuk membuat sebuah pesan tahan terhadap kesalahan,

195
00:12:03,454 --> 00:12:07,162
di mana biasanya menyalin seluruh pesan adalah naluri pertama yang terlintas dalam

196
00:12:07,162 --> 00:12:07,520
pikiran.

197
00:12:07,520 --> 00:12:11,851
Lalu, ada cara lain yang terkadang Anda lihat menampilkan kode Hamming,

198
00:12:11,851 --> 00:12:14,800
yaitu mengalikan pesan dengan satu matriks besar.

199
00:12:14,800 --> 00:12:19,208
Agak bagus karena menghubungkannya dengan kelompok kode linier yang lebih luas,

200
00:12:19,208 --> 00:12:22,404
tapi menurut saya hal itu hampir tidak memberikan intuisi

201
00:12:22,404 --> 00:12:25,160
tentang dari mana asalnya atau bagaimana skalanya.

202
00:12:25,160 --> 00:12:28,553
Dan berbicara tentang penskalaan, Anda mungkin memperhatikan bahwa

203
00:12:28,553 --> 00:12:32,200
efisiensi skema ini semakin baik seiring dengan peningkatan ukuran blok.

204
00:12:32,200 --> 00:12:37,945
Misalnya, kita melihat bahwa dengan 256 bit, Anda hanya menggunakan 3% dari ruang

205
00:12:37,945 --> 00:12:43,480
tersebut untuk redundansi, dan hal tersebut terus menjadi lebih baik dari sana.

206
00:12:43,480 --> 00:12:49,040
Ketika jumlah bit paritas bertambah satu per satu, ukuran blok terus berlipat ganda.

207
00:12:49,040 --> 00:12:53,110
Dan jika Anda menganggapnya ekstrem, Anda bisa memiliki blok dengan, katakanlah,

208
00:12:53,110 --> 00:12:56,930
satu juta bit, di mana Anda benar-benar akan memainkan 20 pertanyaan dengan

209
00:12:56,930 --> 00:13:00,800
pemeriksaan paritas Anda, dan blok tersebut hanya menggunakan 21 bit paritas.

210
00:13:00,800 --> 00:13:04,871
Dan jika Anda mundur sejenak untuk berpikir tentang melihat sejuta

211
00:13:04,871 --> 00:13:08,640
bit dan menemukan satu kesalahan, itu benar-benar terasa gila.

212
00:13:08,640 --> 00:13:11,446
Masalahnya, tentu saja, dengan blok yang lebih besar,

213
00:13:11,446 --> 00:13:15,345
kemungkinan melihat lebih dari satu atau dua kesalahan bit akan meningkat,

214
00:13:15,345 --> 00:13:18,360
dan kode Hamming tidak dapat menangani apa pun selain itu.

215
00:13:18,360 --> 00:13:22,413
Jadi dalam praktiknya, yang Anda inginkan adalah menemukan ukuran yang tepat

216
00:13:22,413 --> 00:13:26,520
sehingga kemungkinan terjadinya terlalu banyak bit flips tidak terlalu tinggi.

217
00:13:26,520 --> 00:13:31,245
Selain itu, dalam praktiknya, kesalahan cenderung terjadi dalam beberapa saat,

218
00:13:31,245 --> 00:13:35,910
yang akan merusak total satu blok, jadi salah satu taktik umum untuk membantu

219
00:13:35,910 --> 00:13:40,754
menyebarkan ledakan kesalahan ke banyak blok yang berbeda adalah dengan menjalin

220
00:13:40,754 --> 00:13:45,480
blok-blok tersebut, seperti ini, sebelum mereka terjadi. dikirim atau disimpan.

221
00:13:45,480 --> 00:13:49,100
Selain itu, banyak dari hal ini yang dianggap sepenuhnya diperdebatkan oleh

222
00:13:49,100 --> 00:13:52,720
kode-kode yang lebih modern, seperti algoritma Reed-Solomon yang jauh lebih

223
00:13:52,720 --> 00:13:55,721
umum digunakan, yang menangani error burst dengan sangat baik,

224
00:13:55,721 --> 00:13:59,580
dan dapat disesuaikan agar tahan terhadap jumlah error yang lebih besar per blok.

225
00:13:59,580 --> 00:14:03,000
Tapi itu topik untuk lain waktu.

226
00:14:03,000 --> 00:14:06,242
Dalam bukunya The Art of Doing Science and Engineering,

227
00:14:06,242 --> 00:14:10,700
Hamming sangat berterus terang tentang betapa berliku-liku penemuan kode ini.

228
00:14:10,700 --> 00:14:14,449
Dia pertama kali mencoba segala macam skema berbeda yang melibatkan pengorganisasian

229
00:14:14,449 --> 00:14:18,420
bit-bit menjadi bagian-bagian kisi dimensi yang lebih tinggi dan hal-hal aneh seperti ini.

230
00:14:18,420 --> 00:14:22,080
Gagasan bahwa mungkin saja pemeriksaan paritas berkonspirasi sedemikian

231
00:14:22,080 --> 00:14:25,792
rupa sehingga menjelaskan posisi kesalahan hanya muncul di benak Hamming

232
00:14:25,792 --> 00:14:29,402
ketika dia mundur setelah serangkaian analisis lain dan bertanya, oke,

233
00:14:29,402 --> 00:14:32,860
apa cara paling efisien yang bisa saya lakukan? mungkin tentang ini?

234
00:14:32,860 --> 00:14:35,903
Dia juga berterus terang tentang betapa pentingnya pemeriksaan

235
00:14:35,903 --> 00:14:38,996
paritas yang sudah ada dalam pikirannya, yang mana hal ini jauh

236
00:14:38,996 --> 00:14:42,040
lebih jarang dilakukan pada tahun 1940an dibandingkan saat ini.

237
00:14:42,040 --> 00:14:46,843
Ada setengah lusin kali dalam buku ini dia merujuk pada kutipan Louis Pasteur,

238
00:14:46,843 --> 00:14:49,640
keberuntungan berpihak pada pikiran yang siap.

239
00:14:49,640 --> 00:14:53,151
Ide-ide cerdas sering kali terlihat sederhana jika dipikir-pikir,

240
00:14:53,151 --> 00:14:55,120
sehingga mudah untuk kurang dihargai.

241
00:14:55,120 --> 00:14:57,998
Saat ini harapan jujur saya adalah bahwa kode Hamming,

242
00:14:57,998 --> 00:15:01,820
atau setidaknya kemungkinan kode tersebut, terasa hampir jelas bagi Anda.

243
00:15:01,820 --> 00:15:04,790
Namun Anda tidak boleh membodohi diri sendiri dengan berpikir

244
00:15:04,790 --> 00:15:08,000
bahwa hal tersebut sebenarnya sudah jelas, karena sebenarnya tidak.

245
00:15:08,000 --> 00:15:11,866
Salah satu alasan mengapa ide-ide cerdas terlihat mudah adalah karena kita

246
00:15:11,866 --> 00:15:15,113
hanya melihat hasil akhirnya, membereskan apa yang berantakan,

247
00:15:15,113 --> 00:15:17,536
tidak pernah menyebutkan semua hal yang salah,

248
00:15:17,536 --> 00:15:21,557
meremehkan betapa luasnya ruang kemungkinan yang dapat dieksplorasi pada awal

249
00:15:21,557 --> 00:15:23,980
sebuah masalah. proses penyelesaian, semua itu.

250
00:15:23,980 --> 00:15:25,280
Namun hal ini berlaku secara umum.

251
00:15:25,280 --> 00:15:28,057
Saya pikir untuk beberapa penemuan khusus, ada alasan

252
00:15:28,057 --> 00:15:31,040
kedua yang lebih dalam sehingga kita kurang menghargainya.

253
00:15:31,040 --> 00:15:35,077
Memikirkan informasi dalam bentuk potongan-potongan baru benar-benar menyatu menjadi

254
00:15:35,077 --> 00:15:38,925
teori penuh pada tahun 1948, dengan makalah penting Claude Shannon tentang teori

255
00:15:38,925 --> 00:15:39,400
informasi.

256
00:15:39,400 --> 00:15:43,440
Hal ini pada dasarnya bersamaan dengan ketika Hamming mengembangkan algoritmanya.

257
00:15:43,440 --> 00:15:46,997
Ini adalah makalah dasar yang sama yang menunjukkan, dalam arti tertentu,

258
00:15:46,997 --> 00:15:50,026
bahwa koreksi kesalahan yang efisien selalu mungkin dilakukan,

259
00:15:50,026 --> 00:15:53,920
tidak peduli seberapa tinggi kemungkinan pembalikan bit, setidaknya secara teori.

260
00:15:53,920 --> 00:15:57,247
Omong-omong, Shannon dan Hamming berbagi kantor di Bell Labs,

261
00:15:57,247 --> 00:15:59,931
meskipun mengerjakan hal-hal yang sangat berbeda,

262
00:15:59,931 --> 00:16:02,400
yang sepertinya bukan suatu kebetulan di sini.

263
00:16:02,400 --> 00:16:06,084
Beberapa dekade kemudian, dan saat ini, banyak dari kita yang begitu

264
00:16:06,084 --> 00:16:09,395
tenggelam dalam pemikiran tentang hal-hal kecil dan informasi

265
00:16:09,395 --> 00:16:13,080
sehingga mudah untuk mengabaikan betapa berbedanya cara berpikir ini.

266
00:16:13,080 --> 00:16:15,514
Ironisnya, ide-ide yang secara mendalam membentuk cara berpikir generasi masa depan

267
00:16:15,514 --> 00:16:17,920
akan membuat generasi masa depan terlihat lebih sederhana daripada yang sebenarnya.

