1
00:00:00,000 --> 00:00:03,120
Saya berasumsi bahwa semua orang di sini berasal dari bagian 1.

2
00:00:03,120 --> 00:00:06,703
Kita berbicara tentang kode Hamming, suatu cara untuk membuat blok data yang

3
00:00:06,703 --> 00:00:10,519
sebagian besar bitnya membawa pesan yang bermakna, sementara beberapa bit lainnya

4
00:00:10,519 --> 00:00:14,288
bertindak sebagai semacam redundansi, sedemikian rupa sehingga jika ada bit yang

5
00:00:14,288 --> 00:00:17,964
dibalik, maka akan muncul pesan. bit atau bit redundansi, apa pun di blok ini,

6
00:00:17,964 --> 00:00:21,920
penerima akan dapat mengidentifikasi kesalahan yang terjadi, dan cara memperbaikinya.

7
00:00:21,920 --> 00:00:25,974
Ide dasar yang disajikan di sana adalah bagaimana menggunakan beberapa

8
00:00:25,974 --> 00:00:29,800
pemeriksaan paritas untuk mencari biner hingga menemukan kesalahan.

9
00:00:29,800 --> 00:00:32,583
Dalam video tersebut, tujuannya adalah untuk membuat

10
00:00:32,583 --> 00:00:35,420
kode Hamming terasa mudah dan mudah ditemukan kembali.

11
00:00:35,420 --> 00:00:38,304
Namun saat Anda mulai berpikir untuk mengimplementasikannya,

12
00:00:38,304 --> 00:00:41,330
baik dalam perangkat lunak maupun perangkat keras, pembingkaian

13
00:00:41,330 --> 00:00:44,120
tersebut mungkin meremehkan betapa elegannya kode-kode ini.

14
00:00:44,120 --> 00:00:47,343
Anda mungkin berpikir bahwa Anda perlu menulis algoritma yang melacak

15
00:00:47,343 --> 00:00:50,705
semua kemungkinan lokasi kesalahan dan memotong kelompok itu menjadi dua

16
00:00:50,705 --> 00:00:54,160
dengan setiap pemeriksaan, tetapi sebenarnya jauh lebih sederhana dari itu.

17
00:00:54,160 --> 00:00:57,673
Jika Anda membacakan jawaban atas empat pemeriksaan paritas yang kami

18
00:00:57,673 --> 00:01:01,186
lakukan di video terakhir, semuanya dalam angka 1 dan 0, bukan ya dan

19
00:01:01,186 --> 00:01:04,800
tidak, maka secara harfiah posisi kesalahan akan dijabarkan dalam biner.

20
00:01:04,800 --> 00:01:08,795
Misalnya, angka 7 dalam biner terlihat seperti 0111,

21
00:01:08,795 --> 00:01:12,640
yang pada dasarnya berarti 4 ditambah 2 ditambah 1.

22
00:01:12,640 --> 00:01:17,520
Dan perhatikan di mana posisi 7 berada, itu memang mempengaruhi kelompok paritas

23
00:01:17,520 --> 00:01:22,280
pertama kita, dan kelompok paritas kedua, dan ketiga, tapi bukan yang terakhir.

24
00:01:22,280 --> 00:01:25,400
Jadi membaca hasil keempat pemeriksaan tersebut dari

25
00:01:25,400 --> 00:01:28,520
bawah ke atas memang menunjukkan posisi kesalahannya.

26
00:01:28,520 --> 00:01:32,955
Tidak ada yang istimewa dari contoh 7, ini berfungsi secara umum, dan ini membuat logika

27
00:01:32,955 --> 00:01:37,440
untuk mengimplementasikan keseluruhan skema pada perangkat keras menjadi sangat sederhana.

28
00:01:37,440 --> 00:01:41,866
Sekarang jika Anda ingin melihat mengapa keajaiban ini terjadi, ambil 16

29
00:01:41,866 --> 00:01:46,111
label indeks ini untuk posisi kita, tapi daripada menuliskannya dalam

30
00:01:46,111 --> 00:01:50,720
basis 10, mari kita tulis semuanya dalam biner, mulai dari 0000 hingga 1111.

31
00:01:50,720 --> 00:01:54,527
Saat kita mengembalikan label biner ini ke dalam kotaknya, izinkan saya

32
00:01:54,527 --> 00:01:58,440
menekankan bahwa label tersebut berbeda dari data yang sebenarnya dikirim.

33
00:01:58,440 --> 00:02:01,365
Itu tidak lebih dari sebuah label konseptual untuk membantu Anda

34
00:02:01,365 --> 00:02:04,200
dan saya memahami dari mana empat kelompok paritas itu berasal.

35
00:02:04,200 --> 00:02:08,550
Keanggunan dalam mendeskripsikan segala sesuatu yang kita lihat dalam biner mungkin

36
00:02:08,550 --> 00:02:13,160
dilemahkan oleh kebingungan karena segala sesuatu yang kita lihat dijelaskan dalam biner.

37
00:02:13,160 --> 00:02:15,040
Tapi itu sepadan.

38
00:02:15,040 --> 00:02:19,764
Fokuskan perhatian Anda hanya pada bagian terakhir dari semua label

39
00:02:19,764 --> 00:02:24,280
ini, lalu sorot posisi di mana bagian terakhir tersebut adalah 1.

40
00:02:24,280 --> 00:02:28,395
Apa yang kita dapatkan adalah yang pertama dari empat kelompok paritas, yang

41
00:02:28,395 --> 00:02:32,404
berarti Anda dapat menafsirkan pemeriksaan pertama itu sebagai pertanyaan,

42
00:02:32,404 --> 00:02:36,680
hei, jika ada kesalahan, apakah bit terakhir pada posisi kesalahan itu adalah 1?

43
00:02:36,680 --> 00:02:41,663
Demikian pula, jika Anda fokus pada bit kedua hingga terakhir, dan menyorot

44
00:02:41,663 --> 00:02:47,040
semua posisi yang bernilai 1, Anda mendapatkan grup paritas kedua dari skema kami.

45
00:02:47,040 --> 00:02:51,534
Dengan kata lain, pengecekan kedua itu menanyakan, hai, sekali lagi,

46
00:02:51,534 --> 00:02:56,160
jika ada kesalahan, apakah bit kedua dari posisi terakhir itu adalah 1?

47
00:02:56,160 --> 00:02:57,160
Dan seterusnya.

48
00:02:57,160 --> 00:03:01,436
Pemeriksaan paritas ketiga mencakup setiap posisi yang bit ketiga

49
00:03:01,436 --> 00:03:05,713
hingga terakhirnya diaktifkan, dan yang terakhir mencakup delapan

50
00:03:05,713 --> 00:03:10,120
posisi terakhir, yaitu posisi yang bit urutan tertingginya adalah 1.

51
00:03:10,120 --> 00:03:15,126
Semua yang kita lakukan sebelumnya sama dengan menjawab keempat pertanyaan

52
00:03:15,126 --> 00:03:19,800
tersebut, yang pada gilirannya sama dengan mengeja posisi dalam biner.

53
00:03:19,800 --> 00:03:22,080
Saya harap ini membuat dua hal menjadi lebih jelas.

54
00:03:22,080 --> 00:03:24,732
Yang pertama adalah bagaimana menggeneralisasi secara sistematis

55
00:03:24,732 --> 00:03:27,140
ke ukuran blok yang merupakan pangkat dua yang lebih besar.

56
00:03:27,140 --> 00:03:31,066
Jika diperlukan lebih banyak bit untuk mendeskripsikan setiap posisi,

57
00:03:31,066 --> 00:03:34,713
seperti enam bit untuk mendeskripsikan 64 titik, maka setiap bit

58
00:03:34,713 --> 00:03:38,640
tersebut memberi Anda salah satu grup paritas yang perlu kita periksa.

59
00:03:38,640 --> 00:03:40,944
Bagi Anda yang menonton teka-teki papan catur yang saya buat

60
00:03:40,944 --> 00:03:43,400
bersama Matt Parker mungkin menganggap semua ini sangat familiar.

61
00:03:43,400 --> 00:03:46,408
Logika intinya sama, tetapi memecahkan masalah yang

62
00:03:46,408 --> 00:03:49,880
berbeda, dan diterapkan pada papan catur berukuran 64 kotak.

63
00:03:49,880 --> 00:03:53,874
Hal kedua yang saya harap dapat dijelaskan adalah mengapa bit

64
00:03:53,874 --> 00:03:58,320
paritas kita berada pada posisi pangkat dua, misalnya 1, 2, 4, dan 8.

65
00:03:58,320 --> 00:04:03,640
Ini adalah posisi yang representasi binernya hanya diaktifkan satu bit.

66
00:04:03,640 --> 00:04:08,053
Artinya, masing-masing bit paritas tersebut berada

67
00:04:08,053 --> 00:04:12,640
di dalam satu dan hanya satu dari empat grup paritas.

68
00:04:12,640 --> 00:04:19,040
Anda juga dapat melihat ini dalam contoh yang lebih besar, di mana tidak peduli

69
00:04:19,040 --> 00:04:25,920
seberapa besar yang Anda dapatkan, setiap bit paritas hanya menyentuh salah satu grup.

70
00:04:25,920 --> 00:04:29,442
Setelah Anda memahami bahwa pemeriksaan paritas yang telah kita fokuskan

71
00:04:29,442 --> 00:04:32,965
sebagian besar waktu kita tidak lebih dari cara cerdas untuk menguraikan

72
00:04:32,965 --> 00:04:36,584
posisi kesalahan dalam biner, maka kita dapat menghubungkannya dengan cara

73
00:04:36,584 --> 00:04:40,204
berpikir yang berbeda tentang hamming. kode, yang bisa dibilang jauh lebih

74
00:04:40,204 --> 00:04:43,920
sederhana dan elegan, dan pada dasarnya dapat ditulis dengan satu baris kode.

75
00:04:43,920 --> 00:04:46,200
Ini didasarkan pada fungsi XOR.

76
00:04:46,200 --> 00:04:50,960
XOR bagi anda yang belum tahu, singkatan dari Exclusive or.

77
00:04:50,960 --> 00:04:55,635
Saat Anda mengambil XOR dari dua bit, itu akan mengembalikan 1 jika salah satu dari

78
00:04:55,635 --> 00:05:00,200
bit tersebut diaktifkan, tetapi tidak jika keduanya diaktifkan atau dinonaktifkan.

79
00:05:00,200 --> 00:05:03,760
Dengan kata lain, ini adalah paritas dari dua bit ini.

80
00:05:03,760 --> 00:05:07,840
Sebagai orang matematika, saya lebih suka menganggapnya sebagai mod penjumlahan 2.

81
00:05:07,840 --> 00:05:10,990
Kita juga biasa berbicara tentang XOR dari dua string bit yang

82
00:05:10,990 --> 00:05:14,040
berbeda, yang pada dasarnya melakukan komponen demi komponen.

83
00:05:14,040 --> 00:05:16,280
Ini seperti tambahan, tetapi Anda tidak pernah membawanya.

84
00:05:16,280 --> 00:05:19,952
Sekali lagi, mereka yang lebih cenderung matematis mungkin lebih suka

85
00:05:19,952 --> 00:05:23,520
menganggap ini sebagai penjumlahan dua vektor dan pengurangan mod 2.

86
00:05:23,520 --> 00:05:27,285
Jika Anda membuka beberapa Python sekarang dan menerapkan

87
00:05:27,285 --> 00:05:31,245
operasi tanda sisipan antara dua bilangan bulat, inilah yang

88
00:05:31,245 --> 00:05:35,400
dilakukannya kecuali representasi bit dari angka-angka tersebut.

89
00:05:35,400 --> 00:05:40,684
Poin kuncinya bagi Anda dan saya adalah bahwa mengambil XOR dari banyak string

90
00:05:40,684 --> 00:05:45,768
bit yang berbeda secara efektif merupakan cara untuk menghitung parodi dari

91
00:05:45,768 --> 00:05:51,320
sekelompok grup terpisah, seperti halnya dengan kolom, semuanya dalam satu gerakan.

92
00:05:51,320 --> 00:05:53,923
Ini memberi kita cara yang agak menarik untuk memikirkan

93
00:05:53,923 --> 00:05:56,527
tentang beberapa pemeriksaan paritas dari algoritma kode

94
00:05:56,527 --> 00:05:59,680
Hamming karena semuanya dikemas bersama menjadi satu operasi tunggal.

95
00:05:59,680 --> 00:06:02,800
Meski sekilas memang terlihat sangat berbeda.

96
00:06:02,800 --> 00:06:08,257
Secara khusus tuliskan 16 posisi dalam biner, seperti yang kita lakukan

97
00:06:08,257 --> 00:06:13,866
sebelumnya, dan sekarang sorot posisi di mana bit pesan diubah menjadi 1,

98
00:06:13,866 --> 00:06:19,400
lalu kumpulkan posisi-posisi ini ke dalam satu kolom besar dan ambil XOR.

99
00:06:19,400 --> 00:06:24,025
Anda mungkin dapat menebak bahwa 4 bit yang berada di bagian bawah sebagai

100
00:06:24,025 --> 00:06:28,280
hasilnya sama dengan 4 pemeriksaan paritas yang telah kita kenal dan

101
00:06:28,280 --> 00:06:32,720
sukai, tetapi luangkan waktu sejenak untuk memikirkan alasan sebenarnya.

102
00:06:32,720 --> 00:06:37,045
Kolom terakhir ini, misalnya, menghitung semua posisi yang bit terakhirnya adalah

103
00:06:37,045 --> 00:06:41,529
1, namun kita sudah dibatasi hanya pada posisi yang disorot, sehingga secara efektif

104
00:06:41,529 --> 00:06:45,960
menghitung berapa banyak posisi yang disorot yang berasal dari grup paritas pertama.

105
00:06:45,960 --> 00:06:48,520
Apakah itu masuk akal?

106
00:06:48,520 --> 00:06:54,613
Demikian pula, kolom berikutnya menghitung berapa banyak posisi dalam grup paritas kedua,

107
00:06:54,613 --> 00:07:00,640
posisi yang bit kedua hingga terakhirnya adalah 1, dan yang juga disorot, dan seterusnya.

108
00:07:00,640 --> 00:07:04,102
Ini hanyalah perubahan kecil dalam perspektif

109
00:07:04,102 --> 00:07:07,640
terhadap hal yang sama yang telah kita lakukan.

110
00:07:07,640 --> 00:07:10,000
Jadi Anda tahu ke mana perginya setelah ini.

111
00:07:10,000 --> 00:07:14,820
Pengirim bertanggung jawab untuk mengubah beberapa bit

112
00:07:14,820 --> 00:07:19,640
paritas khusus untuk memastikan jumlahnya menjadi 0000.

113
00:07:19,640 --> 00:07:22,574
Sekarang setelah kita memilikinya seperti ini, ini memberi kita

114
00:07:22,574 --> 00:07:25,555
cara yang sangat bagus untuk memikirkan mengapa keempat bit yang

115
00:07:25,555 --> 00:07:28,720
dihasilkan di bawah ini secara langsung menguraikan posisi kesalahan.

116
00:07:28,720 --> 00:07:32,720
Katakanlah beberapa bit di blok ini diubah dari 0 menjadi 1.

117
00:07:32,720 --> 00:07:38,607
Artinya adalah posisi bit tersebut sekarang akan dimasukkan dalam total XOR,

118
00:07:38,607 --> 00:07:44,800
yang mengubah jumlah dari 0 menjadi nilai yang baru dimasukkan, posisi kesalahan.

119
00:07:44,800 --> 00:07:47,406
Sedikit kurang jelas, hal yang sama juga berlaku

120
00:07:47,406 --> 00:07:49,800
jika ada kesalahan yang mengubah 1 menjadi 0.

121
00:07:49,800 --> 00:07:54,372
Soalnya, jika Anda menambahkan sedikit string dua kali, itu sama saja dengan tidak

122
00:07:54,372 --> 00:07:59,000
memilikinya sama sekali, pada dasarnya karena di dunia ini 1 tambah 1 sama dengan 0.

123
00:07:59,000 --> 00:08:02,200
Jadi menambahkan salinan posisi ini ke jumlah total

124
00:08:02,200 --> 00:08:05,400
memiliki efek yang sama seperti kita memindahkannya.

125
00:08:05,400 --> 00:08:13,480
Dan efeknya, sekali lagi, adalah hasil total di bawah ini menjelaskan posisi kesalahannya.

126
00:08:13,480 --> 00:08:16,299
Untuk mengilustrasikan betapa elegannya hal ini, izinkan saya

127
00:08:16,299 --> 00:08:18,936
menunjukkan satu baris kode Python yang saya referensikan

128
00:08:18,936 --> 00:08:22,120
sebelumnya, yang akan menangkap hampir semua logika di pihak penerima.

129
00:08:22,120 --> 00:08:26,282
Kita akan mulai dengan membuat array acak 16 1 dan 0 untuk mensimulasikan

130
00:08:26,282 --> 00:08:30,106
blok data, dan saya akan memberinya nama bit, tapi tentu saja dalam

131
00:08:30,106 --> 00:08:34,156
praktiknya ini akan menjadi sesuatu yang kita terima dari pengirim, dan

132
00:08:34,156 --> 00:08:38,600
bukannya karena acak, ia akan membawa 11 bit data bersama dengan 5 bit paritas.

133
00:08:38,600 --> 00:08:43,002
Jika saya memanggil fungsi enumerateBits, yang dilakukannya adalah memasangkan

134
00:08:43,002 --> 00:08:47,682
masing-masing bit tersebut dengan indeks yang sesuai, dalam hal ini berjalan dari 0

135
00:08:47,682 --> 00:08:48,240
hingga 15.

136
00:08:48,240 --> 00:08:52,658
Jadi jika kita kemudian membuat daftar yang mengulang semua pasangan ini, pasangan

137
00:08:52,658 --> 00:08:57,342
yang terlihat seperti i, dan kemudian kita hanya mengeluarkan nilai i, hanya indeksnya,

138
00:08:57,342 --> 00:09:01,920
itu tidak terlalu menarik, kita hanya mendapatkan kembali indeks tersebut 0 sampai 15.

139
00:09:01,920 --> 00:09:05,673
Tetapi jika kita menambahkan kondisi untuk hanya melakukan ini jika

140
00:09:05,673 --> 00:09:09,370
bit, yang berarti jika bit tersebut adalah 1 dan bukan 0, maka bit

141
00:09:09,370 --> 00:09:13,400
tersebut hanya akan menarik keluar posisi di mana bit terkait diaktifkan.

142
00:09:13,400 --> 00:09:20,720
Dalam hal ini sepertinya posisi tersebut adalah 0, 4, 6, 9, dst.

143
00:09:20,720 --> 00:09:25,139
Apa yang kita inginkan adalah mengumpulkan semua posisi tersebut,

144
00:09:25,139 --> 00:09:29,960
posisi bit-bit yang diaktifkan, dan kemudian melakukan XOR bersama-sama.

145
00:09:29,960 --> 00:09:31,860
Untuk melakukan ini dengan Python, izinkan saya

146
00:09:31,860 --> 00:09:33,960
mengimpor beberapa fungsi bermanfaat terlebih dahulu.

147
00:09:33,960 --> 00:09:36,411
Dengan begitu kita bisa memanggil pengurangan() pada

148
00:09:36,411 --> 00:09:39,140
daftar ini, dan menggunakan fungsi XOR untuk menguranginya.

149
00:09:39,140 --> 00:09:44,840
Ini pada dasarnya memakan seluruh daftar, mengambil XOR di sepanjang jalan.

150
00:09:44,840 --> 00:09:48,274
Jika mau, Anda dapat menulis fungsi XOR tersebut

151
00:09:48,274 --> 00:09:52,200
secara eksplisit tanpa harus mengimpornya dari mana pun.

152
00:09:52,200 --> 00:09:57,103
Jadi saat ini sepertinya jika kita melakukan ini pada blok acak 16

153
00:09:57,103 --> 00:10:02,080
bit, ia akan mengembalikan 9, yang memiliki representasi biner 1001.

154
00:10:02,080 --> 00:10:05,724
Kami tidak akan melakukannya di sini, tetapi Anda dapat menulis fungsi di

155
00:10:05,724 --> 00:10:09,418
mana pengirim menggunakan representasi biner tersebut untuk mengatur empat

156
00:10:09,418 --> 00:10:13,210
bit paritas sesuai kebutuhan, yang pada akhirnya membuat blok ini ke keadaan

157
00:10:13,210 --> 00:10:17,200
di mana menjalankan baris kode ini pada daftar bit lengkap akan kembali sebuah 0.

158
00:10:17,200 --> 00:10:20,200
Ini akan dianggap sebagai blok yang dipersiapkan dengan baik.

159
00:10:20,200 --> 00:10:23,738
Yang keren adalah jika kita mengganti salah satu bit dalam daftar

160
00:10:23,738 --> 00:10:27,061
ini, menyimulasikan kesalahan acak dari noise, lalu jika Anda

161
00:10:27,061 --> 00:10:30,600
menjalankan baris kode yang sama, kesalahan tersebut akan dicetak.

162
00:10:30,600 --> 00:10:31,920
Bukankah itu rapi?

163
00:10:31,920 --> 00:10:37,186
Anda bisa mendapatkan blok ini secara tiba-tiba, menjalankan satu baris ini di

164
00:10:37,186 --> 00:10:42,920
atasnya, dan secara otomatis akan memunculkan posisi kesalahan, atau 0 jika tidak ada.

165
00:10:42,920 --> 00:10:45,520
Dan tidak ada yang istimewa dari ukuran 16 di sini.

166
00:10:45,520 --> 00:10:52,280
Baris kode yang sama akan berfungsi jika Anda memiliki daftar, katakanlah, 256 bit.

167
00:10:52,280 --> 00:10:56,704
Tak perlu dikatakan, ada lebih banyak kode untuk ditulis di sini, seperti melakukan

168
00:10:56,704 --> 00:11:00,866
pemeriksaan meta paritas untuk mendeteksi kesalahan 2-bit, namun idenya adalah

169
00:11:00,866 --> 00:11:05,080
bahwa hampir semua logika inti dari skema kita turun ke pengurangan XOR tunggal.

170
00:11:05,080 --> 00:11:08,665
Sekarang, tergantung pada kenyamanan Anda dengan biner dan XOR serta

171
00:11:08,665 --> 00:11:12,200
perangkat lunak secara umum, Anda mungkin menganggap perspektif ini

172
00:11:12,200 --> 00:11:15,785
sedikit membingungkan, atau jauh lebih elegan dan sederhana sehingga

173
00:11:15,785 --> 00:11:19,320
Anda bertanya-tanya mengapa kami tidak memulainya dari awal. -pergi.

174
00:11:19,320 --> 00:11:22,187
Secara longgar, perspektif pemeriksaan paritas berganda lebih mudah

175
00:11:22,187 --> 00:11:25,223
untuk dipikirkan ketika mengimplementasikan kode Hamming pada perangkat

176
00:11:25,223 --> 00:11:28,259
keras secara langsung, dan perspektif XOR paling mudah untuk dipikirkan

177
00:11:28,259 --> 00:11:31,380
ketika melakukannya dalam perangkat lunak, dari tingkat yang lebih tinggi.

178
00:11:31,380 --> 00:11:36,188
Yang pertama paling mudah dilakukan dengan tangan, dan menurut saya ini lebih baik

179
00:11:36,188 --> 00:11:40,997
dalam menanamkan intuisi inti yang mendasari semua ini, yaitu bahwa informasi yang

180
00:11:40,997 --> 00:11:45,689
diperlukan untuk menemukan satu kesalahan terkait dengan log ukuran blok. , atau

181
00:11:45,689 --> 00:11:50,730
dengan kata lain, ia bertambah sedikit demi sedikit seiring dengan bertambahnya ukuran

182
00:11:50,730 --> 00:11:51,020
blok.

183
00:11:51,020 --> 00:11:53,575
Fakta yang relevan di sini adalah bahwa informasi tersebut secara

184
00:11:53,575 --> 00:11:56,440
langsung berhubungan dengan seberapa banyak redundansi yang kita butuhkan.

185
00:11:56,440 --> 00:12:00,103
Hal itulah yang bertentangan dengan reaksi spontan kebanyakan orang ketika mereka

186
00:12:00,103 --> 00:12:03,811
pertama kali berpikir untuk membuat sebuah pesan tahan terhadap kesalahan, di mana

187
00:12:03,811 --> 00:12:07,520
biasanya menyalin seluruh pesan adalah naluri pertama yang terlintas dalam pikiran.

188
00:12:07,520 --> 00:12:11,009
Lalu, ada cara lain yang terkadang Anda lihat menampilkan

189
00:12:11,009 --> 00:12:14,800
kode Hamming, yaitu mengalikan pesan dengan satu matriks besar.

190
00:12:14,800 --> 00:12:18,271
Agak bagus karena menghubungkannya dengan kelompok kode linier

191
00:12:18,271 --> 00:12:21,963
yang lebih luas, tapi menurut saya hal itu hampir tidak memberikan

192
00:12:21,963 --> 00:12:25,160
intuisi tentang dari mana asalnya atau bagaimana skalanya.

193
00:12:25,160 --> 00:12:28,553
Dan berbicara tentang penskalaan, Anda mungkin memperhatikan bahwa

194
00:12:28,553 --> 00:12:32,200
efisiensi skema ini semakin baik seiring dengan peningkatan ukuran blok.

195
00:12:32,200 --> 00:12:37,945
Misalnya, kita melihat bahwa dengan 256 bit, Anda hanya menggunakan 3% dari ruang

196
00:12:37,945 --> 00:12:43,480
tersebut untuk redundansi, dan hal tersebut terus menjadi lebih baik dari sana.

197
00:12:43,480 --> 00:12:49,040
Ketika jumlah bit paritas bertambah satu per satu, ukuran blok terus berlipat ganda.

198
00:12:49,040 --> 00:12:53,110
Dan jika Anda menganggapnya ekstrem, Anda bisa memiliki blok dengan, katakanlah,

199
00:12:53,110 --> 00:12:56,930
satu juta bit, di mana Anda benar-benar akan memainkan 20 pertanyaan dengan

200
00:12:56,930 --> 00:13:00,800
pemeriksaan paritas Anda, dan blok tersebut hanya menggunakan 21 bit paritas.

201
00:13:00,800 --> 00:13:04,871
Dan jika Anda mundur sejenak untuk berpikir tentang melihat sejuta

202
00:13:04,871 --> 00:13:08,640
bit dan menemukan satu kesalahan, itu benar-benar terasa gila.

203
00:13:08,640 --> 00:13:12,070
Masalahnya, tentu saja, dengan blok yang lebih besar, kemungkinan

204
00:13:12,070 --> 00:13:15,345
melihat lebih dari satu atau dua kesalahan bit akan meningkat,

205
00:13:15,345 --> 00:13:18,360
dan kode Hamming tidak dapat menangani apa pun selain itu.

206
00:13:18,360 --> 00:13:22,413
Jadi dalam praktiknya, yang Anda inginkan adalah menemukan ukuran yang tepat

207
00:13:22,413 --> 00:13:26,520
sehingga kemungkinan terjadinya terlalu banyak bit flips tidak terlalu tinggi.

208
00:13:26,520 --> 00:13:31,245
Selain itu, dalam praktiknya, kesalahan cenderung terjadi dalam beberapa saat,

209
00:13:31,245 --> 00:13:35,910
yang akan merusak total satu blok, jadi salah satu taktik umum untuk membantu

210
00:13:35,910 --> 00:13:40,754
menyebarkan ledakan kesalahan ke banyak blok yang berbeda adalah dengan menjalin

211
00:13:40,754 --> 00:13:45,480
blok-blok tersebut, seperti ini, sebelum mereka terjadi. dikirim atau disimpan.

212
00:13:45,480 --> 00:13:49,100
Selain itu, banyak dari hal ini yang dianggap sepenuhnya diperdebatkan oleh

213
00:13:49,100 --> 00:13:52,720
kode-kode yang lebih modern, seperti algoritma Reed-Solomon yang jauh lebih

214
00:13:52,720 --> 00:13:56,197
umum digunakan, yang menangani error burst dengan sangat baik, dan dapat

215
00:13:56,197 --> 00:13:59,580
disesuaikan agar tahan terhadap jumlah error yang lebih besar per blok.

216
00:13:59,580 --> 00:14:03,000
Tapi itu topik untuk lain waktu.

217
00:14:03,000 --> 00:14:06,705
Dalam bukunya The Art of Doing Science and Engineering, Hamming

218
00:14:06,705 --> 00:14:10,700
sangat berterus terang tentang betapa berliku-liku penemuan kode ini.

219
00:14:10,700 --> 00:14:14,449
Dia pertama kali mencoba segala macam skema berbeda yang melibatkan pengorganisasian

220
00:14:14,449 --> 00:14:18,420
bit-bit menjadi bagian-bagian kisi dimensi yang lebih tinggi dan hal-hal aneh seperti ini.

221
00:14:18,420 --> 00:14:22,080
Gagasan bahwa mungkin saja pemeriksaan paritas berkonspirasi sedemikian

222
00:14:22,080 --> 00:14:25,792
rupa sehingga menjelaskan posisi kesalahan hanya muncul di benak Hamming

223
00:14:25,792 --> 00:14:29,402
ketika dia mundur setelah serangkaian analisis lain dan bertanya, oke,

224
00:14:29,402 --> 00:14:32,860
apa cara paling efisien yang bisa saya lakukan? mungkin tentang ini?

225
00:14:32,860 --> 00:14:35,903
Dia juga berterus terang tentang betapa pentingnya pemeriksaan

226
00:14:35,903 --> 00:14:38,996
paritas yang sudah ada dalam pikirannya, yang mana hal ini jauh

227
00:14:38,996 --> 00:14:42,040
lebih jarang dilakukan pada tahun 1940an dibandingkan saat ini.

228
00:14:42,040 --> 00:14:45,931
Ada setengah lusin kali dalam buku ini dia merujuk pada kutipan

229
00:14:45,931 --> 00:14:49,640
Louis Pasteur, keberuntungan berpihak pada pikiran yang siap.

230
00:14:49,640 --> 00:14:52,353
Ide-ide cerdas sering kali terlihat sederhana jika

231
00:14:52,353 --> 00:14:55,120
dipikir-pikir, sehingga mudah untuk kurang dihargai.

232
00:14:55,120 --> 00:14:58,260
Saat ini harapan jujur saya adalah bahwa kode Hamming, atau

233
00:14:58,260 --> 00:15:01,820
setidaknya kemungkinan kode tersebut, terasa hampir jelas bagi Anda.

234
00:15:01,820 --> 00:15:04,790
Namun Anda tidak boleh membodohi diri sendiri dengan berpikir

235
00:15:04,790 --> 00:15:08,000
bahwa hal tersebut sebenarnya sudah jelas, karena sebenarnya tidak.

236
00:15:08,000 --> 00:15:11,866
Salah satu alasan mengapa ide-ide cerdas terlihat mudah adalah karena kita

237
00:15:11,866 --> 00:15:15,783
hanya melihat hasil akhirnya, membereskan apa yang berantakan, tidak pernah

238
00:15:15,783 --> 00:15:19,804
menyebutkan semua hal yang salah, meremehkan betapa luasnya ruang kemungkinan

239
00:15:19,804 --> 00:15:23,980
yang dapat dieksplorasi pada awal sebuah masalah. proses penyelesaian, semua itu.

240
00:15:23,980 --> 00:15:25,280
Namun hal ini berlaku secara umum.

241
00:15:25,280 --> 00:15:28,057
Saya pikir untuk beberapa penemuan khusus, ada alasan

242
00:15:28,057 --> 00:15:31,040
kedua yang lebih dalam sehingga kita kurang menghargainya.

243
00:15:31,040 --> 00:15:35,077
Memikirkan informasi dalam bentuk potongan-potongan baru benar-benar menyatu menjadi

244
00:15:35,077 --> 00:15:38,925
teori penuh pada tahun 1948, dengan makalah penting Claude Shannon tentang teori

245
00:15:38,925 --> 00:15:39,400
informasi.

246
00:15:39,400 --> 00:15:43,440
Hal ini pada dasarnya bersamaan dengan ketika Hamming mengembangkan algoritmanya.

247
00:15:43,440 --> 00:15:46,997
Ini adalah makalah dasar yang sama yang menunjukkan, dalam arti tertentu,

248
00:15:46,997 --> 00:15:50,314
bahwa koreksi kesalahan yang efisien selalu mungkin dilakukan, tidak

249
00:15:50,314 --> 00:15:53,920
peduli seberapa tinggi kemungkinan pembalikan bit, setidaknya secara teori.

250
00:15:53,920 --> 00:15:58,374
Omong-omong, Shannon dan Hamming berbagi kantor di Bell Labs, meskipun mengerjakan

251
00:15:58,374 --> 00:16:02,400
hal-hal yang sangat berbeda, yang sepertinya bukan suatu kebetulan di sini.

252
00:16:02,400 --> 00:16:06,084
Beberapa dekade kemudian, dan saat ini, banyak dari kita yang begitu

253
00:16:06,084 --> 00:16:09,395
tenggelam dalam pemikiran tentang hal-hal kecil dan informasi

254
00:16:09,395 --> 00:16:13,080
sehingga mudah untuk mengabaikan betapa berbedanya cara berpikir ini.

255
00:16:13,080 --> 00:16:15,514
Ironisnya, ide-ide yang secara mendalam membentuk cara berpikir generasi masa depan

256
00:16:15,514 --> 00:16:17,920
akan membuat generasi masa depan terlihat lebih sederhana daripada yang sebenarnya.

