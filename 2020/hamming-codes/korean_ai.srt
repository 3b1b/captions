1
00:00:00,000 --> 00:00:03,120
여기 계신 분들은 모두 1부에서 오신 분들인 것 같아요.

2
00:00:03,120 --> 00:00:06,920
우리는 대부분의 비트가 의미 있는 메시지를 전달하는 반면 다른

3
00:00:06,920 --> 00:00:11,640
비트는 일종의 중복 역할을 하는 데이터 블록을 생성하는 방법인

4
00:00:11,640 --> 00:00:15,800
해밍 코드에 대해 이야기하고 있었습니다. 비트 또는 중복 비트

5
00:00:15,800 --> 00:00:20,560
등 이 블록에 있는 모든 항목을 통해 수신자는 오류가

6
00:00:20,560 --> 00:00:21,920
있음을 식별하고 이를 수정하는 방법을 확인할 수 있습니다.

7
00:00:21,920 --> 00:00:25,900
거기에 제시된 기본 아이디어는 다중 패리티

8
00:00:25,900 --> 00:00:29,800
검사를 사용하여 오류까지 이진 검색하는 방법이었습니다.

9
00:00:29,800 --> 00:00:33,920
해당 비디오의 목표는 Hamming 코드를 가능한 한

10
00:00:33,920 --> 00:00:35,420
직접 사용하고 재발견할 수 있도록 만드는 것이었습니다.

11
00:00:35,420 --> 00:00:40,040
그러나 소프트웨어나 하드웨어에서 이를 실제로 구현하는 것에 대해 생각하기 시작하면 해당

12
00:00:40,040 --> 00:00:44,120
프레임은 실제로 이러한 코드가 실제로 얼마나 우아한지 과소평가할 수 있습니다.

13
00:00:44,120 --> 00:00:47,620
가능한 모든 오류 위치를 추적하고 검사할 때마다 해당

14
00:00:47,620 --> 00:00:52,320
그룹을 절반으로 줄이는 알고리즘을 작성해야 한다고 생각할

15
00:00:52,320 --> 00:00:54,160
수도 있지만 실제로는 그보다 훨씬 더 간단합니다.

16
00:00:54,160 --> 00:00:58,720
지난 비디오에서 우리가 했던 네 가지 패리티 검사에 대한 답을 모두 예와

17
00:00:58,760 --> 00:01:04,800
아니오 대신 1과 0으로 읽으면 문자 그대로 이진수로 오류 위치를 설명합니다.

18
00:01:04,800 --> 00:01:10,160
예를 들어, 이진수 7은 0111처럼 보입니다. 이는

19
00:01:10,160 --> 00:01:12,640
본질적으로 4 더하기 2 더하기 1을 의미합니다.

20
00:01:12,640 --> 00:01:17,960
그리고 위치 7이 어디에 있는지 확인하세요. 이는 패리티 그룹 중 첫

21
00:01:17,960 --> 00:01:22,280
번째, 두 번째, 세 번째에 영향을 주지만 마지막에는 영향을 미치지 않습니다.

22
00:01:22,280 --> 00:01:26,560
따라서 이 네 가지 검사 결과를 아래에서 위로

23
00:01:26,560 --> 00:01:28,000
읽으면 실제로 오류의 위치를 알 수 있습니다.

24
00:01:28,520 --> 00:01:32,240
예제 7에는 특별한 것이 없습니다. 이는 일반적으로 작동하며 하드웨어에서

25
00:01:32,240 --> 00:01:37,440
전체 구성표를 구현하는 논리를 놀라울 정도로 단순하게 만듭니다.

26
00:01:37,440 --> 00:01:43,380
이제 이 마법이 왜 일어나는지 알고 싶다면 위치에

27
00:01:43,380 --> 00:01:48,480
대한 16개의 인덱스 레이블을 사용하세요. 단, 10진수로 작성하는

28
00:01:48,480 --> 00:01:50,720
대신 0000부터 1111까지 실행되는 이진수로 모두 작성해 보겠습니다.

29
00:01:50,720 --> 00:01:55,880
이러한 바이너리 레이블을 상자에 다시 넣을 때

30
00:01:56,080 --> 00:01:58,440
실제로 전송되는 데이터와 구별된다는 점을 강조하겠습니다.

31
00:01:58,440 --> 00:02:02,200
이는 여러분과 제가 네 개의 패리티 그룹이 어디에서 왔는지

32
00:02:02,200 --> 00:02:04,200
이해하는 데 도움이 되는 개념적 레이블에 지나지 않습니다.

33
00:02:04,200 --> 00:02:08,840
우리가 보고 있는 모든 것을 이진법으로 기술하는 것의 우아함은 우리가 보고

34
00:02:08,840 --> 00:02:13,160
있는 모든 것을 이진법으로 기술하는 것의 혼란으로 인해 약화될 수도 있습니다.

35
00:02:13,160 --> 00:02:15,040
그래도 그만한 가치가 있습니다.

36
00:02:15,040 --> 00:02:20,740
모든 레이블의 마지막 비트에만 주의를 집중한 다음

37
00:02:20,740 --> 00:02:24,280
마지막 비트가 1인 위치를 강조 표시하세요.

38
00:02:24,280 --> 00:02:28,800
우리가 얻는 것은 네 개의 패리티 그룹 중 첫 번째입니다.

39
00:02:28,800 --> 00:02:34,480
즉, 첫 번째 검사를 다음과 같이 묻는 것으로 해석할 수

40
00:02:34,480 --> 00:02:36,680
있습니다. 오류가 있으면 해당 오류 위치의 마지막 비트가 1인가요?

41
00:02:36,680 --> 00:02:42,600
마찬가지로, 마지막 비트에서 두 번째 비트에 초점을 맞추고 해당 비트가 1인

42
00:02:42,600 --> 00:02:47,040
모든 위치를 강조 표시하면 구성표에서 두 번째 패리티 그룹을 얻게 됩니다.

43
00:02:47,040 --> 00:02:51,960
즉, 두 번째 확인은 &#39;안녕하세요, 다시 한 번 말씀드리지만, 오류가

44
00:02:51,960 --> 00:02:56,160
있는 경우 해당 위치의 마지막에서 두 번째 비트가 1인가요?&#39;라고 묻습니다.

45
00:02:56,160 --> 00:02:57,160
등등.

46
00:02:57,160 --> 00:03:03,320
세 번째 패리티 검사는 마지막에서 세 번째 비트가 켜져 있는 모든 위치를 다루고,

47
00:03:03,320 --> 00:03:10,120
마지막 패리티 검사는 가장 높은 순서 비트가 1인 마지막 8개 위치를 다룹니다.

48
00:03:10,120 --> 00:03:15,680
이전에 우리가 했던 모든 것은 이 네 가지 질문에 답하는

49
00:03:15,680 --> 00:03:18,800
것과 동일하며, 이는 다시 이진법으로 위치를 철자하는 것과 동일합니다.

50
00:03:19,800 --> 00:03:22,080
이것이 두 가지를 더 명확하게 해주기를 바랍니다.

51
00:03:22,080 --> 00:03:27,140
첫 번째는 2의 거듭제곱보다 큰 블록 크기를 체계적으로 일반화하는 방법입니다.

52
00:03:27,140 --> 00:03:33,180
64개 지점을 설명하는 데 6비트가 필요한 것처럼 각 위치를 설명하는 데 더 많은

53
00:03:33,180 --> 00:03:38,640
비트가 필요한 경우 각 비트는 확인해야 할 패리티 그룹 중 하나를 제공합니다.

54
00:03:38,640 --> 00:03:42,060
제가 Matt Parker와 함께 했던 체스판 퍼즐을 본

55
00:03:42,060 --> 00:03:43,400
분들이라면 이 모든 것이 매우 익숙할 것입니다.

56
00:03:43,400 --> 00:03:48,200
동일한 핵심 논리이지만 다른 문제를

57
00:03:48,200 --> 00:03:49,880
해결하고 64제곱 체스판에 적용됩니다.

58
00:03:49,880 --> 00:03:54,000
두 번째로 명확해지기를 바라는 것은 패리티 비트가 1, 2,

59
00:03:54,000 --> 00:03:58,320
4, 8과 같이 2의 거듭제곱 위치에 있는 이유입니다.

60
00:03:58,320 --> 00:04:03,640
이는 이진 표현이 단일 비트만 켜져 있는 위치입니다.

61
00:04:03,640 --> 00:04:09,000
이는 각 패리티 비트가 4개의 패리티

62
00:04:09,000 --> 00:04:12,640
그룹 중 하나에만 위치한다는 것을 의미합니다.

63
00:04:12,640 --> 00:04:16,840
얼마나 큰지 상관없이 각 패리티 비트가 그룹 중 하나에만

64
00:04:16,840 --> 00:04:25,920
편리하게 닿는 더 큰 예에서도 이를 볼 수 있습니다.

65
00:04:25,920 --> 00:04:29,680
우리가 많은 시간을 투자해 온 이러한 패리티 검사가

66
00:04:29,680 --> 00:04:34,320
오류의 위치를 바이너리로 설명하는 영리한 방법일 뿐이라는 점을

67
00:04:34,320 --> 00:04:37,880
이해하면 해밍에 대해 생각하는 다른 방식으로 연결을

68
00:04:37,880 --> 00:04:42,160
그릴 수 있습니다. 훨씬 더 간단하고 우아하며 기본적으로

69
00:04:42,160 --> 00:04:43,880
한 줄의 코드로 작성할 수 있는 코드입니다.

70
00:04:43,920 --> 00:04:46,200
XOR 함수를 기반으로 합니다.

71
00:04:46,200 --> 00:04:50,960
XOR은 모르시는 분들을 위해 설명하자면, Exclusive or의 약자입니다.

72
00:04:50,960 --> 00:04:55,440
두 비트의 XOR을 수행하면 해당 비트 중 하나가 켜져 있으면

73
00:04:55,440 --> 00:05:00,200
1이 반환되지만 둘 다 켜져 있거나 꺼져 있으면 반환되지 않습니다.

74
00:05:00,200 --> 00:05:03,760
다르게 말하면, 이 두 비트의 패리티입니다.

75
00:05:03,760 --> 00:05:07,840
수학적인 사람으로서 나는 그것을 추가 모드 2로 생각하는 것을 선호합니다.

76
00:05:07,840 --> 00:05:12,000
또한 기본적으로 이 구성 요소를 구성 요소별로 수행하는 두

77
00:05:12,040 --> 00:05:14,040
개의 서로 다른 비트 문자열의 XOR에 대해서도 일반적으로 이야기합니다.

78
00:05:14,040 --> 00:05:16,280
그것은 덧셈과 비슷하지만 결코 가지고 다니지 않습니다.

79
00:05:16,280 --> 00:05:21,240
다시 말하지만, 수학적으로 더 기울어진 사람은 이를 두 개의 벡터를

80
00:05:21,240 --> 00:05:23,520
추가하고 mod 2를 줄이는 것으로 생각하는 것을 선호할 수 있습니다.

81
00:05:23,520 --> 00:05:28,720
지금 당장 Python을 열고 두 정수 사이에 캐럿 연산을 적용하면

82
00:05:28,720 --> 00:05:35,400
이것이 수행되는 작업이지만 내부적으로 해당 숫자의 비트 표현이 수행됩니다.

83
00:05:35,400 --> 00:05:40,920
여러분과 저에게 중요한 점은 다양한 비트 문자열의 XOR을

84
00:05:40,960 --> 00:05:45,960
취하는 것이 열의 경우와 같이 여러 개별

85
00:05:45,960 --> 00:05:51,320
그룹의 패러디를 한꺼번에 계산하는 효과적인 방법이라는 것입니다.

86
00:05:51,320 --> 00:05:54,520
이는 해밍 코드 알고리즘의 다중 패리티 검사를 모두 하나의 단일

87
00:05:54,520 --> 00:05:59,680
작업으로 함께 패키지하는 것으로 생각하는 다소 멋진 방법을 제공합니다.

88
00:05:59,680 --> 00:06:02,800
언뜻 보면 매우 달라 보이지만.

89
00:06:02,800 --> 00:06:08,360
이전처럼 16개 위치를 이진수로 구체적으로 기록하고 이제 메시지

90
00:06:08,640 --> 00:06:14,800
비트가 1로 켜진 위치를 강조 표시한 다음 이러한

91
00:06:14,800 --> 00:06:19,400
위치를 하나의 큰 열로 수집하고 XOR을 수행합니다.

92
00:06:19,400 --> 00:06:23,480
결과적으로 맨 아래에 있는 4비트는 우리가 알고 사랑하게

93
00:06:23,480 --> 00:06:27,480
된 4개의 패리티 검사와 동일하다고 추측할 수 있지만

94
00:06:27,480 --> 00:06:32,720
실제로 그 이유가 무엇인지 잠시 생각해 보세요.

95
00:06:32,720 --> 00:06:37,880
예를 들어 이 마지막 열은 마지막 비트가 1인 모든

96
00:06:38,400 --> 00:06:42,400
위치를 계산하지만 이미 강조 표시된 위치로만 제한되어 있으므로 첫

97
00:06:42,400 --> 00:06:45,960
번째 패리티 그룹에서 강조 표시된 위치 수를 효과적으로 계산합니다.

98
00:06:45,960 --> 00:06:48,520
말이 돼?

99
00:06:48,520 --> 00:06:53,600
마찬가지로 다음 열에서는 두 번째 패리티 그룹에 위치가

100
00:06:53,600 --> 00:06:59,640
몇 개 있는지, 마지막 비트에서 두 번째 비트가

101
00:06:59,640 --> 00:07:00,640
1이고 역시 강조 표시된 위치 등을 계산합니다.

102
00:07:00,640 --> 00:07:06,640
이는 우리가 해왔던 동일한 일에 대한 관점의 작은 변화일 뿐입니다.

103
00:07:07,640 --> 00:07:10,000
그래서 여기서부터 어디로 가는지 알 수 있습니다.

104
00:07:10,000 --> 00:07:14,400
보낸 사람은 합계가 0000이 되도록 특수 패리티

105
00:07:14,400 --> 00:07:19,640
비트 중 일부를 전환할 책임이 있습니다.

106
00:07:19,640 --> 00:07:23,600
이제 이와 같은 결과가 나오면 하단에 있는 4개의 결과 비트가 오류

107
00:07:23,600 --> 00:07:28,720
위치를 직접적으로 설명하는 이유를 생각할 수 있는 정말 좋은 방법을 제공합니다.

108
00:07:28,720 --> 00:07:32,680
이 블록의 일부 비트가 0에서 1로 전환된다고 가정해 보겠습니다.

109
00:07:32,720 --> 00:07:37,320
이는 해당 비트의 위치가 이제 전체

110
00:07:37,320 --> 00:07:42,960
XOR에 포함되어 합계가 0에서 새로 포함된

111
00:07:42,960 --> 00:07:44,800
값인 오류 위치로 변경된다는 의미입니다.

112
00:07:44,800 --> 00:07:48,800
약간 덜 명확하게 말하면 1을 0으로

113
00:07:48,800 --> 00:07:49,800
변경하는 오류가 있는 경우에도 마찬가지입니다.

114
00:07:49,800 --> 00:07:54,720
알다시피, 비트 문자열을 두 번 더하면 거기에 전혀 없는 것과

115
00:07:54,720 --> 00:07:59,000
같습니다. 기본적으로 이 세상에서는 1 더하기 1이 0이기 때문입니다.

116
00:07:59,000 --> 00:08:03,720
따라서 이 위치의 복사본을 총 합계에

117
00:08:03,720 --> 00:08:05,400
추가하면 이동하는 것과 동일한 효과가 있습니다.

118
00:08:05,400 --> 00:08:10,080
그리고 그 효과는 여기 하단의 전체

119
00:08:10,080 --> 00:08:13,480
결과가 오류의 위치를 설명한다는 것입니다.

120
00:08:13,480 --> 00:08:17,720
이것이 얼마나 우아한지 설명하기 위해 이전에 참조한 Python 코드 한 줄을

121
00:08:17,720 --> 00:08:22,120
보여 드리겠습니다. 이 코드는 수신자 측의 거의 모든 논리를 캡처합니다.

122
00:08:22,120 --> 00:08:27,160
데이터 블록을 시뮬레이션하기 위해 16개의 1과 0으로

123
00:08:27,160 --> 00:08:31,160
구성된 임의의 배열을 생성하는 것부터 시작하고 여기에

124
00:08:31,160 --> 00:08:36,160
이름 비트를 부여할 것입니다. 무작위이므로 5개의 패리티

125
00:08:36,160 --> 00:08:38,600
비트와 함께 11개의 데이터 비트를 전달합니다.

126
00:08:38,600 --> 00:08:43,160
enumerateBits 함수를 호출하면 각 비트를 해당 인덱스와

127
00:08:43,160 --> 00:08:48,240
쌍으로 연결합니다. 이 경우에는 0에서 15까지 실행됩니다.

128
00:08:48,240 --> 00:08:53,200
그래서 우리가 이 모든 쌍, 즉 i처럼 보이는 쌍을

129
00:08:53,200 --> 00:08:59,160
반복하는 목록을 생성하고 i 값만 추출하고 인덱스만 추출하면 그다지

130
00:08:59,160 --> 00:09:01,920
흥미롭지는 않습니다. 0부터 15까지의 인덱스만 다시 가져옵니다. .

131
00:09:01,920 --> 00:09:07,520
하지만 만약 비트인 경우에만 이 작업을 수행한다는 조건을 추가하면, 즉 해당

132
00:09:07,520 --> 00:09:13,400
비트가 1이고 0이 아닌 경우 해당 비트가 켜져 있는 위치만 꺼냅니다.

133
00:09:13,400 --> 00:09:20,320
이 경우 해당 위치는 0, 4, 6, 9 등인 것처럼 보입니다.

134
00:09:20,720 --> 00:09:24,640
우리가 원하는 것은 모든 위치, 즉 켜져 있는

135
00:09:24,640 --> 00:09:29,960
비트의 위치를 함께 수집한 다음 함께 XOR하는 것입니다.

136
00:09:29,960 --> 00:09:33,960
Python에서 이 작업을 수행하려면 먼저 몇 가지 유용한 함수를 가져오겠습니다.

137
00:09:33,960 --> 00:09:39,140
그런 식으로 우리는 이 목록에서 Reduce()를 호출하고 XOR 함수를 사용하여 목록을 줄일 수 있습니다.

138
00:09:39,140 --> 00:09:44,840
이것은 기본적으로 목록을 통해 XOR을 수행합니다.

139
00:09:44,840 --> 00:09:48,760
원하는 경우 XOR 함수를 어디에서든 가져올

140
00:09:48,800 --> 00:09:52,200
필요 없이 명시적으로 작성할 수 있습니다.

141
00:09:52,200 --> 00:09:56,880
따라서 현재로서는 16비트의 무작위 블록에 대해 이 작업을 수행하면

142
00:09:56,880 --> 00:10:02,080
이진 표현 1001을 갖는 9가 반환되는 것처럼 보입니다.

143
00:10:02,080 --> 00:10:05,960
여기서는 수행하지 않겠지만 송신자가 이진 표현을 사용하여 필요에 따라 4개의 패리티

144
00:10:05,960 --> 00:10:11,560
비트를 설정하는 함수를 작성할 수 있습니다. 그러면 궁극적으로 이 블록을

145
00:10:11,560 --> 00:10:16,200
전체 비트 목록에서 이 코드 줄을 실행하는 상태가 반환됩니다. 0.

146
00:10:17,200 --> 00:10:20,200
이는 잘 준비된 블록으로 간주됩니다.

147
00:10:20,200 --> 00:10:24,640
멋진 점은 이 목록의 비트 중 하나를 전환하여 노이즈로 인한 임의

148
00:10:24,640 --> 00:10:30,600
오류를 시뮬레이션한 다음 동일한 코드 줄을 실행하면 해당 오류가 인쇄된다는 것입니다.

149
00:10:30,600 --> 00:10:31,920
깔끔하지 않나요?

150
00:10:31,920 --> 00:10:37,200
갑자기 이 블록을 가져와서 이 한 줄을 실행하면

151
00:10:37,200 --> 00:10:42,920
오류 위치가 자동으로 표시되고, 오류가 없으면 0이 표시됩니다.

152
00:10:42,920 --> 00:10:45,520
그리고 사이즈 16에는 특별한 것이 없습니다.

153
00:10:45,520 --> 00:10:52,280
예를 들어 256비트 목록이 있는 경우 동일한 코드 줄이 작동합니다.

154
00:10:52,280 --> 00:10:56,280
말할 필요도 없이 여기에 작성해야 할 코드가 더 있습니다. 예를 들어

155
00:10:56,280 --> 00:11:01,440
2비트 오류를 감지하기 위한 메타 패리티 검사를 수행하는 것입니다. 그러나 아이디어는

156
00:11:01,440 --> 00:11:05,080
우리 체계의 거의 모든 핵심 논리가 단일 XOR 감소로 귀결된다는 것입니다.

157
00:11:05,080 --> 00:11:10,600
이제 바이너리, XOR 및 일반적인 소프트웨어에 대한 편안함에 따라 이

158
00:11:10,600 --> 00:11:15,880
관점이 약간 혼란스러울 수도 있고 훨씬 더 우아하고 단순하여

159
00:11:15,880 --> 00:11:19,320
왜 우리가 처음부터 시작하지 않았는지 궁금해할 수도 있습니다. -가다.

160
00:11:19,320 --> 00:11:22,880
대략적으로 말하면 다중 패리티 검사 관점은 하드웨어에서 해밍 코드를

161
00:11:22,880 --> 00:11:27,560
직접 구현할 때 생각하기가 더 쉽고, XOR 관점은 소프트웨어에서

162
00:11:27,560 --> 00:11:31,380
수행할 때 더 높은 수준에서 생각하기 가장 쉽습니다.

163
00:11:31,380 --> 00:11:35,640
첫 번째는 실제로 손으로 하는 것이 가장 쉽고, 이 모든 것의 기초가

164
00:11:35,640 --> 00:11:40,720
되는 핵심 직관을 심어주는 것이 더 나은 일이라고 생각합니다. 즉, 단일

165
00:11:40,720 --> 00:11:46,840
오류를 찾는 데 필요한 정보는 블록 크기의 로그와 관련이 있다는 것입니다. 즉,

166
00:11:46,840 --> 00:11:51,020
블록 크기가 두 배로 증가함에 따라 한 번에 한 비트씩 증가합니다.

167
00:11:51,020 --> 00:11:55,440
여기서 관련 사실은 해당 정보가 필요한

168
00:11:55,440 --> 00:11:56,440
중복 정도와 직접적으로 일치한다는 것입니다.

169
00:11:56,440 --> 00:12:00,320
이는 오류에 대해 탄력적인 메시지를 만드는 것에 대해 처음

170
00:12:00,320 --> 00:12:05,280
생각할 때 대부분의 사람들이 무작정 반응하는 것과 반대되는 것입니다.

171
00:12:05,280 --> 00:12:07,520
일반적으로 전체 메시지를 복사하는 것이 가장 먼저 떠오르는 본능입니다.

172
00:12:07,520 --> 00:12:11,120
그런데 때로는 해밍 코드가 표시되는 완전히 다른 방식이

173
00:12:11,120 --> 00:12:14,800
있는데, 여기서 메시지에 하나의 큰 행렬을 곱합니다.

174
00:12:14,800 --> 00:12:18,580
더 넓은 범위의 선형 코드 제품군과 관련되어 있기 때문에 다소 좋지만, 그것이

175
00:12:18,580 --> 00:12:25,160
어디서 왔는지 또는 어떻게 확장되는지에 대한 직관을 거의 제공하지 않는다고 생각합니다.

176
00:12:25,160 --> 00:12:29,340
확장에 관해 말하자면, 블록 크기를 늘릴수록 이 체계의

177
00:12:29,340 --> 00:12:32,200
효율성이 더 좋아진다는 것을 알 수 있습니다.

178
00:12:32,200 --> 00:12:40,560
예를 들어, 256비트의 경우 중복성을 위해 해당 공간의 3%만

179
00:12:40,560 --> 00:12:43,480
사용하고 그 이후로 점점 더 좋아지는 것을 확인했습니다.

180
00:12:43,480 --> 00:12:49,040
패리티 비트 수가 하나씩 증가함에 따라 블록 크기는 계속 두 배로 늘어납니다.

181
00:12:49,040 --> 00:12:53,840
그리고 이를 극단적으로 받아들인다면, 예를 들어 백만 비트의 블록을

182
00:12:53,840 --> 00:12:58,800
가질 수 있습니다. 여기서 패리티 검사로 문자 그대로

183
00:12:58,800 --> 00:13:00,800
20개의 질문을 플레이하고 21개의 패리티 비트만 사용하게 됩니다.

184
00:13:00,800 --> 00:13:05,760
그리고 한 걸음 물러서서 백만 개의 비트를 살펴보고 단일 오류를

185
00:13:05,760 --> 00:13:08,640
찾는 것에 대해 생각한다면 그것은 정말로 미친 것처럼 느껴집니다.

186
00:13:08,640 --> 00:13:12,680
물론 문제는 블록이 클수록 비트 오류가 1~2개 이상 나올

187
00:13:12,680 --> 00:13:18,360
확률이 높아지고, 해밍 코드는 그 이상은 처리하지 못한다는 점이다.

188
00:13:18,360 --> 00:13:22,020
따라서 실제로 원하는 것은 비트 플립이 너무 많이 발생할

189
00:13:22,020 --> 00:13:25,520
확률이 너무 높지 않도록 올바른 크기를 찾는 것입니다.

190
00:13:26,520 --> 00:13:30,920
또한 실제로 오류는 작은 단위로 발생하는 경향이 있어 단일 블록을 완전히 망칠 수

191
00:13:30,920 --> 00:13:35,680
있습니다. 따라서 여러 블록에 걸쳐 오류를 분산시키는 데 도움이 되는 일반적인 전술 중

192
00:13:35,680 --> 00:13:41,720
하나는 해당 블록이 블록에 포함되기 전에 이와 같이 인터레이스하는 것입니다. 발송 또는 보관됩니다.

193
00:13:45,480 --> 00:13:49,920
그런 다음 다시 말하지만, 이 중 많은 부분은 버스트 오류를 특히 잘 처리하고

194
00:13:49,920 --> 00:13:55,060
블록당 더 많은 수의 오류에 탄력적으로 조정될 수 있는 훨씬 더 일반적으로

195
00:13:55,100 --> 00:13:59,580
사용되는 Reed-Solomon 알고리즘과 같은 최신 코드에 의해 완전히 논쟁의 여지가 있습니다. .

196
00:13:59,580 --> 00:14:03,000
그러나 그것은 다른 시간에 다룰 주제입니다.

197
00:14:03,000 --> 00:14:07,660
Hamming은 자신의 저서 The Art of Doing Science and Engineering에서

198
00:14:07,660 --> 00:14:10,700
자신이 발견한 이 코드가 얼마나 의미심장한 일이었는지 놀랍도록 솔직하게 밝혔습니다.

199
00:14:10,700 --> 00:14:15,180
그는 먼저 비트를 더 높은 차원의 격자 부분으로 구성하는 것과

200
00:14:15,180 --> 00:14:18,420
이와 같은 이상한 것들을 포함하는 모든 종류의 다양한 계획을 시도했습니다.

201
00:14:18,420 --> 00:14:22,520
오류의 위치를 명시하는 방식으로 패리티 검사를 공모하여 음모를 꾸미는 것이

202
00:14:22,520 --> 00:14:26,360
가능할 수도 있다는 생각은 Hamming이 여러 가지 다른 분석을 한

203
00:14:26,360 --> 00:14:30,800
후 한 걸음 물러나서 &quot;알겠습니다. 제가 할 수 있는 가장

204
00:14:30,800 --> 00:14:32,860
효율적인 방법은 무엇입니까?&quot;라고 물었을 때부터였습니다. 아마도 이것에 관한 것입니까?

205
00:14:32,860 --> 00:14:36,760
그는 또한 패리티 검사가 이미 그의 마음 속에 있다는 것이

206
00:14:36,760 --> 00:14:42,040
얼마나 중요한지 솔직하게 말했습니다. 1940년대에는 오늘날보다 훨씬 덜 일반적이었을 것입니다.

207
00:14:42,040 --> 00:14:46,040
이 책 전체에 걸쳐 그는 루이 파스퇴르의 명언을

208
00:14:46,040 --> 00:14:49,640
여섯 번이나 언급합니다. 행운은 준비된 마음을 선호합니다.

209
00:14:49,640 --> 00:14:55,120
영리한 아이디어는 돌이켜보면 믿을 수 없을 만큼 단순해 보이는 경우가 많아 과소평가되기 쉽습니다.

210
00:14:55,120 --> 00:14:59,680
지금 당장은 해밍 코드, 또는 적어도 그러한 코드의

211
00:14:59,680 --> 00:15:01,820
가능성이 여러분에게 거의 명백하게 느껴지기를 진심으로 바랍니다.

212
00:15:01,820 --> 00:15:05,440
하지만 그것들이 실제로 명백하다고 생각하도록 자신을 속여서는 안

213
00:15:05,440 --> 00:15:08,000
됩니다. 왜냐하면 그것들은 확실히 그렇지 않기 때문입니다.

214
00:15:08,000 --> 00:15:12,080
영리한 아이디어가 믿을 수 없을 정도로 쉬워 보이는 이유 중

215
00:15:12,080 --> 00:15:17,360
하나는 우리가 최종 결과만 보고 지저분한 것을 정리하고 모든 잘못된

216
00:15:17,360 --> 00:15:22,400
방향을 언급하지 않고 문제가 시작될 때 탐색 가능한 가능성의 공간이

217
00:15:22,400 --> 00:15:23,980
얼마나 광대한지 과소평가하기 때문입니다. 해결 과정, 그 모든 것.

218
00:15:23,980 --> 00:15:25,280
그러나 이것은 일반적으로 사실입니다.

219
00:15:25,280 --> 00:15:29,880
저는 몇몇 특별한 발명품에 대해 우리가 그것을 과소평가하는

220
00:15:29,880 --> 00:15:31,040
두 번째로 더 깊은 이유가 있다고 생각합니다.

221
00:15:31,040 --> 00:15:35,040
정보를 비트 단위로 생각하는 것은 정보 이론에 관한 Claude

222
00:15:35,040 --> 00:15:39,400
Shannon의 중요한 논문을 통해 1948년에 비로소 완전한 이론으로 통합되었습니다.

223
00:15:39,400 --> 00:15:43,400
이는 Hamming이 자신의 알고리즘을 개발했을 때와 본질적으로 동시에 발생했습니다.

224
00:15:43,440 --> 00:15:47,300
이것은 적어도 이론적으로는 비트 플립 확률이 아무리

225
00:15:47,300 --> 00:15:52,080
높더라도 어떤 의미에서는 효율적인 오류 수정이 항상

226
00:15:52,080 --> 00:15:53,920
가능하다는 것을 보여주는 동일한 기본 논문이었습니다.

227
00:15:53,920 --> 00:15:58,120
그런데 Shannon과 Hamming은 매우 다른 일을 하고 있음에도 불구하고

228
00:15:58,120 --> 00:16:02,400
Bell Labs에서 사무실을 공유했는데, 여기서는 우연이 아닌 것 같습니다.

229
00:16:02,400 --> 00:16:06,960
수십 년이 지난 지금, 우리 중 많은 사람들이 비트와 정보에 대한

230
00:16:06,960 --> 00:16:13,080
생각에 너무 몰두하여 이러한 사고 방식이 얼마나 뚜렷한지 간과하기 쉽습니다.

231
00:16:13,080 --> 00:16:17,920
아이러니하게도 미래 세대가 생각하는 방식을 가장 근본적으로 형성하는 아이디어는

232
00:16:17,920 --> 00:16:22,640
결국 미래 세대를 실제보다 더 단순하게 보게 될 것입니다.

