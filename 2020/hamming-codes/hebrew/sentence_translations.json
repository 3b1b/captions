[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing?",
  "model": "nmt",
  "translatedText": "האם אי פעם תהיתם איך אפשר לגרד תקליטור או DVD ועדיין להשמיע את כל מה שהוא מאחסן?",
  "time_range": [
   3.62,
   10.1
  ]
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors.",
  "model": "nmt",
  "translatedText": "השריטה באמת משפיעה על ה-1 וה-0 בדיסק, אז הוא קורא נתונים שונים ממה שנשמר, אבל אלא אם כן הוא ממש שרוט, הביטים שהוא קורא מפוענחים בדיוק לאותו קובץ שקודד בו, עותק ביט אחר סיבי, למרות כל השגיאות הללו.",
  "time_range": [
   10.9,
   27.44
  ]
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors.",
  "model": "nmt",
  "translatedText": "יש ערימה שלמה של פיקחות מתמטית שמאפשרת לנו לאחסן נתונים, ולא פחות חשוב להעביר נתונים, בצורה עמידה בפני שגיאות.",
  "time_range": [
   27.44,
   36.2
  ]
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this.",
  "model": "nmt",
  "translatedText": "ובכן, בסדר, למעשה לא צריך כל כך הרבה פיקחות כדי למצוא דרך לעשות את זה.",
  "time_range": [
   36.2,
   40.88
  ]
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s.",
  "model": "nmt",
  "translatedText": "כל קובץ, בין אם זה וידאו או צליל או טקסט, קוד כלשהו, תמונה, מה שלא יהיה, הוא בסופו של דבר איזה רצף של 1 ו-0.",
  "time_range": [
   40.88,
   50.38
  ]
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit.",
  "model": "nmt",
  "translatedText": "ואסטרטגיה פשוטה לתיקון כל סיביות שמתהפכת תהיה לאחסן שלושה עותקים של כל סיביות.",
  "time_range": [
   50.68,
   56.0
  ]
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy.",
  "model": "nmt",
  "translatedText": "לאחר מכן, המכונה שקוראת את הקובץ הזה תוכל להשוות את שלושת העותקים האלה ותמיד לקחת את ה-2 הטובים ביותר מתוך 3 בכל פעם שיש אי התאמה.",
  "time_range": [
   57.58,
   64.06
  ]
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy.",
  "model": "nmt",
  "translatedText": "אבל המשמעות היא שימוש בשני שלישים מהשטח שלך לעודפות.",
  "time_range": [
   67.16,
   70.86
  ]
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped.",
  "model": "nmt",
  "translatedText": "וגם אז, למרות כל השטח שמוותר עליו, אין ערובה חזקה לגבי מה יקרה אם יותר מסיבית אחת תתהפך.",
  "time_range": [
   71.48,
   77.24
  ]
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible.",
  "model": "nmt",
  "translatedText": "השאלה המעניינת הרבה יותר היא איך לעשות את זה כך שניתן יהיה לתקן שגיאות תוך ויתור על שטח קטן ככל האפשר.",
  "time_range": [
   77.98,
   84.02
  ]
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9!",
  "model": "nmt",
  "translatedText": "לדוגמה, באמצעות השיטה שתלמד על הסרטון הזה, תוכל לאחסן את הנתונים שלך בבלוקים של 256 סיביות, כאשר כל בלוק משתמש ב-9 סיביות, 9!",
  "time_range": [
   84.52000000000001,
   93.36
  ]
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want.",
  "model": "nmt",
  "translatedText": "לפעול כסוג של יתירות, ושאר 247 הסיביות חופשיות לשאת כל מסר או נתונים משמעותיים שתרצו.",
  "time_range": [
   93.76,
   100.3
  ]
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it.",
  "model": "nmt",
  "translatedText": "וזה עדיין יהיה כך שאם ביט כלשהו יתהפך כאן, רק על ידי הסתכלות על הבלוק הזה ותו לא, מכונה תוכל לזהות שהייתה שגיאה ובדיוק היכן היא הייתה כדי שהיא תדע לתקן אותה.",
  "time_range": [
   100.9,
   112.66
  ]
 },
 {
  "input": "And honestly, that feels like magic.",
  "model": "nmt",
  "translatedText": "ובכנות, זה מרגיש כמו קסם.",
  "time_range": [
   112.66,
   114.62
  ]
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them.",
  "model": "nmt",
  "translatedText": "ולסכמה הספציפית הזו, אם שני ביטים יתהפכו, המכונה לפחות תוכל לזהות שהיו שתי שגיאות, אם כי היא לא תדע כיצד לתקן אותן.",
  "time_range": [
   115.44,
   122.86
  ]
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes.",
  "model": "nmt",
  "translatedText": "נדבר קצת מאוחר יותר על איך זה קנה מידה עבור בלוקים בגדלים שונים.",
  "time_range": [
   123.52,
   126.9
  ]
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes.",
  "model": "nmt",
  "translatedText": "שיטות המאפשרות לך לתקן שגיאות כמו זו ידועות, באופן סביר, בתור קודי תיקון שגיאות.",
  "time_range": [
   127.86,
   132.9
  ]
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day.",
  "model": "nmt",
  "translatedText": "בחלקה הטוב יותר של המאה הקודמת, תחום זה היה מקור עשיר באמת למתמטיקה עמוקה להפתיע שמשולבת במכשירים שאנו משתמשים בהם מדי יום.",
  "time_range": [
   133.66,
   141.94
  ]
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code.",
  "model": "nmt",
  "translatedText": "המטרה כאן היא לתת לך הבנה מעמיקה מאוד של אחת הדוגמאות המוקדמות ביותר, המכונה קוד Hamming.",
  "time_range": [
   142.84,
   148.66
  ]
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there.",
  "model": "nmt",
  "translatedText": "ודרך אגב, איך שאני חושב על המבנה של הסרטון הזה הוא פחות עניין של הסבר ישיר ככל האפשר, ויותר עניין של לדרבן אותך להמציא את זה לעצמך, עם קצת הדרכה עדינה פה ושם.",
  "time_range": [
   149.52,
   159.82
  ]
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you.",
  "model": "nmt",
  "translatedText": "אז כשאתה מרגיש שאתה רואה לאן זה הולך בשלב מסוים, קח את הרגע הזה לעצור, חזה באופן פעיל מה התוכנית עומדת להיות לפני שאני אומר לך.",
  "time_range": [
   160.12,
   166.72
  ]
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying.",
  "model": "nmt",
  "translatedText": "כמו כן, אם אתה רוצה שההבנה שלך תרד לרמת החומרה, בן איטר הכין סרטון יחד עם הסרטון הזה שמראה לך איך ליישם בפועל קודי Hamming על לוחות לחם, וזה מספק ביותר.",
  "time_range": [
   167.24,
   178.24
  ]
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming.",
  "model": "nmt",
  "translatedText": "אתה צריך לדעת, קודי Hamming לא נמצאים בשימוש נרחב כמו קודים מודרניים יותר, כמו אלגוריתם ריד-סולומון, אבל יש קסם מסוים בניגוד בין כמה בלתי אפשרית המשימה הזו מרגישה בהתחלה, לבין כמה סבירה לחלוטין היא נראית פעם אחת. אתה לומד על האמינג.",
  "time_range": [
   179.3,
   193.0
  ]
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages.",
  "model": "nmt",
  "translatedText": "העיקרון הבסיסי של תיקון שגיאות הוא שבמרחב עצום של כל ההודעות האפשריות, רק תת-קבוצה מסוימת תיחשב להודעות חוקיות.",
  "time_range": [
   193.72,
   202.18
  ]
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words.",
  "model": "nmt",
  "translatedText": "כאנלוגיה, חשבו על מילים מאויתות נכון לעומת מילים מאויתות לא נכון.",
  "time_range": [
   202.8,
   206.94
  ]
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo.",
  "model": "nmt",
  "translatedText": "בכל פעם שהודעה חוקית משתנה, המקלט אחראי לתקן את מה שהם רואים בחזרה לשכן התקף הקרוב ביותר, כפי שאתה עשוי לעשות עם שגיאת הקלדה.",
  "time_range": [
   208.9,
   217.34
  ]
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness.",
  "model": "nmt",
  "translatedText": "עם זאת, להמציא אלגוריתם קונקרטי לסיווג יעיל של הודעות כמו זה, נדרשת פיקחות מסוימת.",
  "time_range": [
   218.22,
   224.06
  ]
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to.",
  "model": "nmt",
  "translatedText": "הסיפור מתחיל בשנות ה-40, כאשר ריצ&#39;רד האמינג צעיר עבד במעבדות בל, וחלק מעבודתו כללו שימוש במחשב כרטיס ניקוב יקר מאוד שהייתה לו רק גישה מוגבלת אליו.",
  "time_range": [
   226.78,
   237.42
  ]
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread.",
  "model": "nmt",
  "translatedText": "והתוכניות שהוא המשיך להעביר את זה לא הפסיקו להיכשל, כי מדי פעם קצת יקראו לא נכון.",
  "time_range": [
   237.8,
   242.4
  ]
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code.",
  "model": "nmt",
  "translatedText": "התסכול בהיותו כור ההמצאה, כל כך נמאס לו שהוא המציא את קוד תיקון השגיאות הראשון בעולם.",
  "time_range": [
   243.12,
   248.42
  ]
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them.",
  "model": "nmt",
  "translatedText": "ישנן דרכים רבות ושונות למסגר קודי האמינג, אבל כדרך ראשונה, אנחנו הולכים לעבור את זה כמו שהאמינג עצמו חשב עליהם.",
  "time_range": [
   249.06,
   255.38
  ]
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits.",
  "model": "nmt",
  "translatedText": "בואו נשתמש בדוגמה פשוטה, אבל לא פשוטה מדי, בלוק של 16 סיביות.",
  "time_range": [
   256.52,
   260.94
  ]
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15.",
  "model": "nmt",
  "translatedText": "נמספר את המיקומים של סיביות אלה מ-0 עד 15.",
  "time_range": [
   261.82,
   264.74
  ]
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy.",
  "model": "nmt",
  "translatedText": "הנתונים האמיתיים שאנו רוצים לאחסן יהוו רק 12 מהסיביות הללו, בעוד ש-4 מהמיקומים שמורים כסוג של יתירות.",
  "time_range": [
   265.62,
   273.0
  ]
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data.",
  "model": "nmt",
  "translatedText": "המילה מיותר כאן לא אומרת פשוט העתקה, אחרי הכל, 4 הביטים האלה לא נותנים לנו מספיק מקום להעתיק את הנתונים בצורה עיוורת.",
  "time_range": [
   273.9,
   280.04
  ]
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience.",
  "model": "nmt",
  "translatedText": "במקום זאת, הם יצטרכו להיות סוג הרבה יותר ניואנס וחכם של יתירות, לא להוסיף שום מידע חדש, אלא להוסיף חוסן.",
  "time_range": [
   280.72,
   287.28
  ]
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end.",
  "model": "nmt",
  "translatedText": "אולי אתה מצפה שארבעת החלקים המיוחדים האלה יבואו ארוזים יפה ביחד, אולי בסוף או משהו כזה, אבל כפי שתראה, כשהם יושבים בעמדות שהן עוצמה של 2 מאפשר משהו שהוא באמת אלגנטי עד הסוף.",
  "time_range": [
   288.6,
   299.62
  ]
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks.",
  "model": "nmt",
  "translatedText": "זה גם עשוי לתת לך רמז קטן לגבי איך זה מתאים לבלוקים גדולים יותר.",
  "time_range": [
   300.2,
   303.54
  ]
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now.",
  "model": "nmt",
  "translatedText": "גם מבחינה טכנית זה בסופו של דבר רק 11 סיביות של נתונים, תגלה שיש ניואנס מתון למה שמתרחש בעמדה 0, אבל אל תדאג בקשר לזה לעת עתה.",
  "time_range": [
   304.90000000000003,
   313.26
  ]
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors.",
  "model": "nmt",
  "translatedText": "כמו כל אלגוריתם לתיקון שגיאות, זה יכלול שני שחקנים, שולח שאחראי על הגדרת 4 הביטים המיוחדים הללו, ומקלט שאחראי על ביצוע איזושהי בדיקה ותיקון השגיאות.",
  "time_range": [
   314.14,
   325.2
  ]
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage.",
  "model": "nmt",
  "translatedText": "כמובן, המילים שולח ומקבל באמת מתייחסות למכונות או תוכנות שעושות את כל הבדיקות, והרעיון של הודעה נועד בצורה רחבה מאוד, לכלול דברים כמו אחסון.",
  "time_range": [
   325.2,
   334.74
  ]
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another.",
  "model": "nmt",
  "translatedText": "אחרי הכל, אחסון נתונים הוא אותו דבר כמו שליחת מסר רק מהעבר לעתיד במקום ממקום אחד לאחר.",
  "time_range": [
   335.34,
   341.68
  ]
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check.",
  "model": "nmt",
  "translatedText": "אז זה ההגדרה, אבל לפני שנוכל לצלול פנימה אנחנו צריכים לדבר על רעיון קשור שהיה טרי בראשו של האמינג בזמן גילויו, שיטה המאפשרת לך לזהות שגיאות סיביות בודדות, אך לא לתקן אותן, ידועה בעסק כמחאה זוגית.",
  "time_range": [
   342.56,
   356.3
  ]
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message.",
  "model": "nmt",
  "translatedText": "לבדיקת זוגיות, אנו מפרידים רק ביט בודד אחד שהשולח אחראי לכוונון, והשאר חופשיים לשאת הודעה.",
  "time_range": [
   356.88,
   363.82
  ]
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number.",
  "model": "nmt",
  "translatedText": "התפקיד היחיד של הביט המיוחד הזה הוא לוודא שהמספר הכולל של 1s בהודעה הוא מספר זוגי.",
  "time_range": [
   364.88,
   371.28
  ]
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even.",
  "model": "nmt",
  "translatedText": "אז לדוגמא כרגע, המספר הכולל של 1s הוא 7, זה מוזר, אז השולח צריך להפוך את הסיביות המיוחדת הזו כדי להיות 1, מה שהופך את הספירה לשקול.",
  "time_range": [
   372.08,
   379.96
  ]
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0.",
  "model": "nmt",
  "translatedText": "אבל אם הבלוק כבר התחיל עם מספר זוגי של 1, אז הביט המיוחד הזה היה נשמר ב-0.",
  "time_range": [
   380.8,
   386.42
  ]
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information.",
  "model": "nmt",
  "translatedText": "זה די פשוט, פשוט מטעה, אבל זו דרך אלגנטית להפליא לזקק את הרעיון של שינוי בכל מקום במסר שישתקף בפיסת מידע אחת.",
  "time_range": [
   387.34,
   396.78
  ]
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd.",
  "model": "nmt",
  "translatedText": "שימו לב שאם חלק כלשהו מההודעה הזו מתהפך, מ-0 ל-1 או מ-1 ל-0, זה משנה את הספירה הכוללת של 1 שניות מזוגיות לא-זוגית.",
  "time_range": [
   397.5,
   406.54
  ]
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was.",
  "model": "nmt",
  "translatedText": "אז אם אתה המקלט, אתה מסתכל על ההודעה הזו, ותראה מספר אי זוגי של 1, אתה יכול לדעת בוודאות שהתרחשה שגיאה כלשהי, למרות שאולי אין לך מושג היכן היא הייתה.",
  "time_range": [
   407.98,
   417.46
  ]
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity.",
  "model": "nmt",
  "translatedText": "בז&#39;רגון, האם לקבוצת ביטים יש מספר זוגי או אי-זוגי של 1, ידוע בתור הזוגיות שלה.",
  "time_range": [
   418.5,
   423.34
  ]
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea.",
  "model": "nmt",
  "translatedText": "אתה יכול גם להשתמש במספרים ולומר שהשוויון הוא 0 או 1, וזה בדרך כלל מועיל יותר ברגע שאתה מתחיל לעשות מתמטיקה עם הרעיון.",
  "time_range": [
   424.86,
   430.72
  ]
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit.",
  "model": "nmt",
  "translatedText": "והביט המיוחד הזה שהשולח משתמש בו כדי לשלוט בזוגיות נקרא סיבית הזוגיות.",
  "time_range": [
   431.22,
   435.52
  ]
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0.",
  "model": "nmt",
  "translatedText": "ולמעשה, עלינו להיות ברורים, אם המקלט רואה זוגיות אי זוגית, זה לא בהכרח אומר שהייתה רק שגיאה אחת, אולי היו 3 שגיאות, או 5, או כל מספר אי זוגי אחר, אבל הם יכולים לדעת בוודאות שזה לא היה 0.",
  "time_range": [
   437.56,
   449.26
  ]
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free.",
  "model": "nmt",
  "translatedText": "מצד שני, אם היו 2 שגיאות, או כל מספר זוגי של שגיאות, הספירה הסופית של 1s עדיין תהיה זוגית, כך שהמקבל לא יכול להיות בטוח שספירה זוגית אומרת בהכרח שההודעה נטולת שגיאות.",
  "time_range": [
   449.98,
   462.3
  ]
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right.",
  "model": "nmt",
  "translatedText": "אתה עלול להתלונן שהודעה שמתבלבלת רק על ידי סיבובים של 2 סיביות היא די חלשה, ואתה צודק לחלוטין.",
  "time_range": [
   462.84000000000003,
   469.08
  ]
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended.",
  "model": "nmt",
  "translatedText": "זכור, עם זאת, אין שיטה לזיהוי או תיקון שגיאות שיכולה לתת לך 100% ביטחון שההודעה שאתה מקבל היא זו שהשולח התכוון אליה.",
  "time_range": [
   469.7,
   478.9
  ]
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance.",
  "model": "nmt",
  "translatedText": "אחרי הכל, מספיק רעש אקראי תמיד יכול לשנות הודעה חוקית אחת להודעה חוקית אחרת רק במקרה.",
  "time_range": [
   479.58,
   485.44
  ]
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this.",
  "model": "nmt",
  "translatedText": "במקום זאת, המטרה היא להמציא סכמה שתהיה חזקה עד למספר מרבי מסוים של שגיאות, או אולי להפחית את ההסתברות לחיוב שגוי כמו זה.",
  "time_range": [
   486.24,
   495.38
  ]
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes.",
  "model": "nmt",
  "translatedText": "בדיקות זוגיות כשלעצמן הן די חלשות, אבל על ידי זיקוק רעיון השינוי על פני מסר מלא עד לחלק אחד, מה שהם נותנים לנו הוא אבן בניין רבת עוצמה לתוכניות מתוחכמות יותר.",
  "time_range": [
   496.26,
   507.16
  ]
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error.",
  "model": "nmt",
  "translatedText": "לדוגמה, מכיוון שהאמינג חיפש דרך לזהות היכן קרתה שגיאה, לא רק שהיא קרתה, התובנה העיקרית שלו הייתה שאם תחיל בדיקות זוגיות לא על ההודעה המלאה, אלא על תת-קבוצות מסוימות שנבחרו בקפידה, תוכל לשאול סדרה מעודנת יותר של שאלות המציינת את המיקום של כל שגיאת סיביות בודדת.",
  "time_range": [
   507.94,
   525.94
  ]
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half.",
  "model": "nmt",
  "translatedText": "התחושה הכללית היא קצת כמו לשחק במשחק של 20 שאלות, לשאול שאילתות כן או לא שחותכות את מרחב האפשרויות לשניים.",
  "time_range": [
   526.68,
   533.38
  ]
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions.",
  "model": "nmt",
  "translatedText": "לדוגמה, נניח שאנו עושים בדיקת זוגיות רק על 8 הסיביות הללו, כל המיקומים האי-זוגיים.",
  "time_range": [
   534.16,
   539.38
  ]
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position.",
  "model": "nmt",
  "translatedText": "לאחר מכן, אם מזוהה שגיאה, זה נותן למקלט קצת יותר מידע על היכן בדיוק נמצאת השגיאה, כלומר שהוא נמצא במיקום מוזר.",
  "time_range": [
   540.1,
   548.24
  ]
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions.",
  "model": "nmt",
  "translatedText": "אם לא מזוהה שגיאה בין 8 הסיביות האלה, זה אומר שאין שגיאה בכלל, או שהיא יושבת איפשהו במיקומים הזוגיים.",
  "time_range": [
   548.94,
   556.24
  ]
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful.",
  "model": "nmt",
  "translatedText": "אולי תחשוב שהגבלת בדיקת זוגיות לחצי מהביטים הופכת אותו לפחות יעיל, אבל כשהיא נעשית בשילוב עם בדיקות אחרות שנבחרו היטב, זה נותן לנו משהו הרבה יותר חזק.",
  "time_range": [
   557.18,
   567.2
  ]
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group.",
  "model": "nmt",
  "translatedText": "כדי להגדיר בפועל את בדיקת הזוגיות הזו, זכור, זה מצריך ייעוד של חלק מיוחד שיש לו שליטה על הזוגיות של אותה קבוצה מלאה.",
  "time_range": [
   569.24,
   576.62
  ]
 },
 {
  "input": "Here let's just choose position 1.",
  "model": "nmt",
  "translatedText": "כאן בואו פשוט נבחר בעמדה 1.",
  "time_range": [
   577.48,
   579.18
  ]
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even.",
  "model": "nmt",
  "translatedText": "עבור הדוגמה המוצגת, השוויון של 8 הסיביות הללו הוא אי-זוגי כרגע, כך שהשולח אחראי על החלפת סיביות השוויון, ועכשיו זה זוגי.",
  "time_range": [
   579.72,
   586.98
  ]
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do.",
  "model": "nmt",
  "translatedText": "זה רק 1 מתוך 4 בדיקות זוגיות שנבצע.",
  "time_range": [
   587.94,
   590.68
  ]
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here.",
  "model": "nmt",
  "translatedText": "הסימון השני הוא בין 8 הביטים בחצי הימני של הרשת, לפחות כפי שציירנו אותו כאן.",
  "time_range": [
   590.92,
   596.3
  ]
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged.",
  "model": "nmt",
  "translatedText": "הפעם אנו עשויים להשתמש במיקום 2 כסיביות זוגיות, כך של-8 הסיביות הללו כבר יש זוגיות זוגית, והשולח יכול להרגיש טוב ולהשאיר את הסיביות מספר 2 ללא שינוי.",
  "time_range": [
   596.68,
   606.06
  ]
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right.",
  "model": "nmt",
  "translatedText": "ואז בצד השני, אם המקלט יבדוק את השוויון של הקבוצה הזו והם יגלו שזה מוזר, הם יידעו שהשגיאה נמצאת איפשהו בין 8 הביטים האלה בצד ימין.",
  "time_range": [
   607.02,
   615.38
  ]
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half.",
  "model": "nmt",
  "translatedText": "אחרת זה אומר שאין שגיאה, או שהשגיאה נמצאת איפשהו בחצי השמאלי.",
  "time_range": [
   615.82,
   620.58
  ]
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block.",
  "model": "nmt",
  "translatedText": "או שאני מניח שיכולות להיות שתי שגיאות, אבל כרגע אנחנו הולכים להניח שיש לכל היותר שגיאה אחת בכל הבלוק.",
  "time_range": [
   621.12,
   626.5
  ]
 },
 {
  "input": "Things break down completely for more than that.",
  "model": "nmt",
  "translatedText": "דברים מתקלקלים לגמרי ליותר מזה.",
  "time_range": [
   626.94,
   628.74
  ]
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together.",
  "model": "nmt",
  "translatedText": "כאן, לפני שנסתכל על שני הבדיקות הבאות, קחו רגע לחשוב מה השניים הראשונים הללו מאפשרים לנו לעשות כאשר אתם מחשיבים אותם יחד.",
  "time_range": [
   629.16,
   635.1
  ]
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half.",
  "model": "nmt",
  "translatedText": "נניח שאתה מזהה שגיאה בין העמודות האי זוגיות, ובמחצית הימנית.",
  "time_range": [
   635.8,
   639.66
  ]
 },
 {
  "input": "It necessarily means the error is somewhere in the last column.",
  "model": "nmt",
  "translatedText": "זה בהכרח אומר שהשגיאה נמצאת איפשהו בעמודה האחרונה.",
  "time_range": [
   640.2,
   643.04
  ]
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column.",
  "model": "nmt",
  "translatedText": "אם לא הייתה שגיאה בעמודה האי זוגית אבל הייתה אחת בחצי הימני, זה אומר לך שהיא בעמודה השנייה עד האחרונה.",
  "time_range": [
   643.82,
   649.7
  ]
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column.",
  "model": "nmt",
  "translatedText": "כמו כן, אם יש שגיאה בעמודות האי זוגיות אבל לא בחצי הימני, אתה יודע שהיא איפשהו בעמודה השנייה.",
  "time_range": [
   650.44,
   656.56
  ]
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column.",
  "model": "nmt",
  "translatedText": "ואם אף אחת משתי בדיקות הזוגיות האלה לא מזהה משהו, זה אומר שהמקום היחיד שיכול להיות שגיאה הוא בעמודה השמאלית ביותר.",
  "time_range": [
   656.56,
   663.12
  ]
 },
 {
  "input": "But it also might simply mean there's no error at all.",
  "model": "nmt",
  "translatedText": "אבל זה יכול גם פשוט אומר שאין שגיאה בכלל.",
  "time_range": [
   663.34,
   666.12
  ]
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column.",
  "model": "nmt",
  "translatedText": "וזו דרך די מטופשת לומר ששתי בדיקות זוגיות מאפשרות לנו להצמיד את העמודה.",
  "time_range": [
   666.3,
   670.84
  ]
 },
 {
  "input": "From here, you can probably guess what follows.",
  "model": "nmt",
  "translatedText": "מכאן, אתם בוודאי יכולים לנחש מה בהמשך.",
  "time_range": [
   671.48,
   673.64
  ]
 },
 {
  "input": "We do basically the same thing but for the rows.",
  "model": "nmt",
  "translatedText": "אנחנו עושים את אותו הדבר חוץ מהשורות.",
  "time_range": [
   673.8,
   676.14
  ]
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit.",
  "model": "nmt",
  "translatedText": "תהיה בדיקת זוגיות בשורות האי זוגיות, תוך שימוש במיקום 4 בתור סיביות זוגיות.",
  "time_range": [
   676.44,
   680.9
  ]
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0.",
  "model": "nmt",
  "translatedText": "אז בדוגמה הזו לקבוצה כבר יש זוגיות זוגית, אז ביט 4 יוגדר ל-0.",
  "time_range": [
   681.38,
   685.82
  ]
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit.",
  "model": "nmt",
  "translatedText": "ולבסוף יש בדיקת זוגיות בשתי השורות התחתונות, תוך שימוש במיקום 8 בתור סיביות זוגיות.",
  "time_range": [
   686.56,
   691.58
  ]
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity.",
  "model": "nmt",
  "translatedText": "במקרה זה, נראה שהשולח צריך להפעיל את ה-bit 8 הזה כדי לתת לקבוצה זוגיות שווה.",
  "time_range": [
   692.12,
   696.82
  ]
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row.",
  "model": "nmt",
  "translatedText": "בדיוק כפי ששני הסימון הראשונים מאפשרים לנו להצמיד את העמודה, שני הסימון הבאים מאפשרים לך להצמיד את השורה.",
  "time_range": [
   697.7,
   701.84
  ]
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3.",
  "model": "nmt",
  "translatedText": "כדוגמה, דמיינו שבמהלך השידור יש שגיאה, למשל, בעמדה 3.",
  "time_range": [
   702.88,
   707.54
  ]
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column.",
  "model": "nmt",
  "translatedText": "ובכן זה משפיע על קבוצת השוויון הראשונה, וזה משפיע גם על קבוצת השוויון השנייה, כך שהמקלט יודע שיש שגיאה איפשהו בעמודה הימנית.",
  "time_range": [
   708.18,
   715.56
  ]
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group.",
  "model": "nmt",
  "translatedText": "אבל זה לא משפיע על הקבוצה השלישית, וזה לא משפיע על הקבוצה הרביעית.",
  "time_range": [
   716.1,
   720.54
  ]
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error.",
  "model": "nmt",
  "translatedText": "וזה מאפשר למקלט לאתר את השגיאה עד לשורה הראשונה, שמשמעותה בהכרח מיקום 3, כדי שיוכלו לתקן את השגיאה.",
  "time_range": [
   721.24,
   727.52
  ]
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be.",
  "model": "nmt",
  "translatedText": "אולי תיהנו להקדיש רגע לשכנע את עצמכם שהתשובות לארבע השאלות הללו באמת תמיד יאפשרו לכם לקבוע מיקום ספציפי, לא משנה היכן יתבררו.",
  "time_range": [
   728.58,
   737.1
  ]
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting.",
  "model": "nmt",
  "translatedText": "למעשה, הנבון שביניכם עשוי אפילו להבחין בקשר בין השאלות הללו לבין ספירה בינארית.",
  "time_range": [
   737.72,
   743.06
  ]
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it.",
  "model": "nmt",
  "translatedText": "ואם כן, שוב הרשו לי להדגיש, לעצור, לנסות בעצמכם לצייר את הקשר לפני שאקלקל אותו.",
  "time_range": [
   743.5,
   748.92
  ]
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it.",
  "model": "nmt",
  "translatedText": "אם אתה תוהה מה קורה אם סיבית זוגיות עצמה מושפעת, ובכן, אתה יכול פשוט לנסות את זה.",
  "time_range": [
   750.5,
   756.06
  ]
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions.",
  "model": "nmt",
  "translatedText": "קחו רגע לחשוב כיצד כל שגיאה בין ארבעת הסיביות המיוחדות הללו תתחקה בדיוק כמו כל אחר, עם אותה קבוצה של ארבע שאלות.",
  "time_range": [
   756.44,
   764.18
  ]
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along.",
  "model": "nmt",
  "translatedText": "זה לא באמת משנה, מכיוון שבסופו של יום מה שאנחנו רוצים זה להגן על סיביות ההודעה, סיביות תיקון השגיאות פשוט רוכבות.",
  "time_range": [
   767.0600000000001,
   773.1
  ]
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct.",
  "model": "nmt",
  "translatedText": "אבל הגנה גם על החלקים האלה היא משהו שנופל באופן טבעי מהתוכנית כתוצר לוואי.",
  "time_range": [
   773.6,
   777.82
  ]
 },
 {
  "input": "You might also enjoy anticipating how this scales.",
  "model": "nmt",
  "translatedText": "אולי תיהנו גם לצפות כיצד זה מתרחב.",
  "time_range": [
   779.2,
   781.76
  ]
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot.",
  "model": "nmt",
  "translatedText": "אם השתמשנו בבלוק בגודל 256 סיביות, למשל, כדי להצמיד מיקום, אתה צריך רק שמונה שאלות כן או לא כדי לחפש בינארי בדרך למטה למקום מסוים.",
  "time_range": [
   782.3,
   792.78
  ]
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check.",
  "model": "nmt",
  "translatedText": "וזכור, כל שאלה דורשת לוותר על ביט בודד בלבד כדי לקבוע את בדיקת השוויון המתאימה.",
  "time_range": [
   795.64,
   800.5
  ]
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two.",
  "model": "nmt",
  "translatedText": "חלק מכם אולי כבר רואים את זה, אבל נדבר מאוחר יותר על הדרך השיטתית למצוא מהן השאלות הללו תוך דקה או שתיים בלבד.",
  "time_range": [
   803.16,
   809.36
  ]
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here.",
  "model": "nmt",
  "translatedText": "אני מקווה שהסקיצה הזו מספיקה כדי להעריך את היעילות של מה שאנחנו מפתחים כאן.",
  "time_range": [
   809.88,
   813.26
  ]
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want.",
  "model": "nmt",
  "translatedText": "הדבר הראשון, למעט שמונה סיביות זוגיות מודגשת, יכול להיות מה שאתה רוצה שזה יהיה, לשאת כל מסר או נתונים שאתה רוצה.",
  "time_range": [
   813.26,
   821.82
  ]
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole.",
  "model": "nmt",
  "translatedText": "8 הביטים מיותרים במובן זה שהם נקבעים לחלוטין על ידי שאר ההודעה, אבל זה בצורה הרבה יותר חכמה מאשר להעתיק את ההודעה כולה.",
  "time_range": [
   821.82,
   830.02
  ]
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error.",
  "model": "nmt",
  "translatedText": "ועדיין, עבור כל כך מעט ויתור, תוכל לזהות ולתקן כל שגיאת סיביות בודדת.",
  "time_range": [
   833.6,
   838.38
  ]
 },
 {
  "input": "Well, almost.",
  "model": "nmt",
  "translatedText": "ובכן, כמעט.",
  "time_range": [
   839.2,
   840.4
  ]
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0.",
  "model": "nmt",
  "translatedText": "אוקיי, אז הבעיה האחת כאן היא שאם אף אחת מארבעת בדיקות השוויון לא מזהה שגיאה, כלומר שלתת-הקבוצות שנבחרו במיוחד של 8 סיביות יש לכולם זוגיות זוגיות, בדיוק כמו שהשולח התכוון, אז זה אומר שלא הייתה שגיאה בכלל , או שהוא מצמצם אותנו למצב 0.",
  "time_range": [
   840.96,
   856.86
  ]
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition.",
  "model": "nmt",
  "translatedText": "אתה מבין, עם ארבע שאלות כן או לא, יש לנו 16 תוצאות אפשריות עבור בדיקות השוויון שלנו, ובהתחלה זה מרגיש מושלם לאיתור 1 מתוך 16 מיקומים בבלוק, אבל אתה צריך גם לתקשר תוצאה 17, ללא שגיאה מַצָב.",
  "time_range": [
   857.74,
   871.9
  ]
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely.",
  "model": "nmt",
  "translatedText": "הפתרון כאן הוא למעשה די פשוט, פשוט תשכחו לגמרי מהביט ה-0 הזה.",
  "time_range": [
   873.02,
   877.3
  ]
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error.",
  "model": "nmt",
  "translatedText": "אז כשאנחנו עושים את ארבעת בדיקות השוויון שלנו ואנו רואים שכולם שווים, זה אומר חד משמעית שאין שגיאה.",
  "time_range": [
   877.84,
   883.46
  ]
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy.",
  "model": "nmt",
  "translatedText": "מה שזה אומר הוא במקום לעבוד עם בלוק של 16 סיביות, אנחנו עובדים עם בלוק של 15 סיביות, שבו 11 מהסיביות חופשיות לשאת הודעה ו-4 מהן נמצאות לשם יתירות.",
  "time_range": [
   884.24,
   893.22
  ]
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code.",
  "model": "nmt",
  "translatedText": "ועם זה, יש לנו עכשיו את מה שאנשים בעסק יתייחסו אליו כקוד 15-11 Hamming.",
  "time_range": [
   893.78,
   900.2
  ]
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us.",
  "model": "nmt",
  "translatedText": "עם זאת, זה נחמד שיש גודל בלוק שהוא כוח נקי של 2, ויש דרך חכמה שנוכל לשמור על הסיביות ה-0 הזו ולגרום לה לעשות קצת עבודה נוספת עבורנו.",
  "time_range": [
   900.46,
   908.14
  ]
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors.",
  "model": "nmt",
  "translatedText": "אם אנו משתמשים בו כסיביות זוגיות על פני כל הבלוק, הוא מאפשר לנו לזהות, למרות שאיננו יכולים לתקן, שגיאות של 2 סיביות.",
  "time_range": [
   908.7,
   915.54
  ]
 },
 {
  "input": "Here's how it works.",
  "model": "nmt",
  "translatedText": "ככה זה עובד.",
  "time_range": [
   916.16,
   916.82
  ]
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check.",
  "model": "nmt",
  "translatedText": "לאחר הגדרת ארבעת הביטים המיוחדים לתיקון שגיאות, אנו מגדירים את ה-0 כך שהשוויון של הבלוק המלא יהיה זוגי, בדיוק כמו בדיקת זוגיות רגילה.",
  "time_range": [
   917.18,
   924.94
  ]
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks.",
  "model": "nmt",
  "translatedText": "עכשיו, אם יש שגיאת סיביות בודדת, אז השוויון של הבלוק המלא משתנה להיות אי-זוגי, אבל היינו תופסים את זה בכל מקרה הודות לארבעת הבדיקות לתיקון השגיאות.",
  "time_range": [
   925.7,
   933.6
  ]
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks.",
  "model": "nmt",
  "translatedText": "עם זאת, אם יש שתי שגיאות, אז השוויון הכולל יחזור להיות זוגי, אבל המקלט עדיין יראה שהייתה לפחות שגיאה כלשהי בגלל מה שקורה עם ארבעת בדיקות השוויון האלה.",
  "time_range": [
   934.16,
   945.18
  ]
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors.",
  "model": "nmt",
  "translatedText": "אז אם הם מבחינים בשוויון שווה בסך הכל, אבל משהו לא אפס קורה עם הבדיקות האחרות, זה אומר להם שהיו לפחות שתי שגיאות.",
  "time_range": [
   945.18,
   952.7
  ]
 },
 {
  "input": "Isn't that clever?",
  "model": "nmt",
  "translatedText": "זה לא חכם?",
  "time_range": [
   953.52,
   954.0
  ]
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them.",
  "model": "nmt",
  "translatedText": "למרות שאיננו יכולים לתקן את השגיאות של 2 סיביות אלה, רק על ידי החזרת הסיבית ה-0 הקטנה והמטרידה הזו לעבודה, היא מאפשרת לנו לזהות אותן.",
  "time_range": [
   954.3,
   961.26
  ]
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code.",
  "model": "nmt",
  "translatedText": "זה די סטנדרטי, זה ידוע בתור קוד Hamming מורחב.",
  "time_range": [
   962.26,
   965.22
  ]
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block.",
  "model": "nmt",
  "translatedText": "מבחינה טכנית, יש לך כעת תיאור מלא של מה שקוד Hamming עושה, לפחות לדוגמא של בלוק של 16 סיביות.",
  "time_range": [
   966.54,
   972.88
  ]
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself.",
  "model": "nmt",
  "translatedText": "אבל אני חושב שתמצא את זה יותר מספק לבדוק את ההבנה שלך ולגבש הכל עד לנקודה זו על ידי ביצוע דוגמה אחת מלאה מההתחלה ועד הסוף בעצמך.",
  "time_range": [
   972.88,
   981.32
  ]
 },
 {
  "input": "I'll step through it with you though so you can check yourself.",
  "model": "nmt",
  "translatedText": "אבל אני אעבור איתך על זה כדי שתוכל לבדוק את עצמך.",
  "time_range": [
   982.08,
   984.3
  ]
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks.",
  "model": "nmt",
  "translatedText": "כדי להגדיר הודעה, בין אם זו הודעה מילולית שאתה מתרגם בחלל או נתונים שאתה רוצה לאחסן לאורך זמן, הצעד הראשון הוא לחלק אותו לנתחים של 11 סיביות.",
  "time_range": [
   985.12,
   994.66
  ]
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block.",
  "model": "nmt",
  "translatedText": "כל נתח הולך להיות ארוז לתוך בלוק 16 סיביות עמיד בפני שגיאות.",
  "time_range": [
   995.58,
   999.76
  ]
 },
 {
  "input": "So let's take this one as an example and actually work it out.",
  "model": "nmt",
  "translatedText": "אז בואו ניקח את זה כדוגמה ולמעשה נסתדר.",
  "time_range": [
   999.76,
   1003.22
  ]
 },
 {
  "input": "Go ahead, actually do it!",
  "model": "nmt",
  "translatedText": "קדימה, באמת תעשה את זה!",
  "time_range": [
   1003.74,
   1004.74
  ]
 },
 {
  "input": "Let's pause and try putting together this block.",
  "model": "nmt",
  "translatedText": "בואו נעצור וננסה להרכיב את הבלוק הזה.",
  "time_range": [
   1004.74,
   1007.02
  ]
 },
 {
  "input": "Okay, you ready?",
  "model": "nmt",
  "translatedText": "בסדר, אתה מוכן?",
  "time_range": [
   1012.72,
   1013.68
  ]
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order.",
  "model": "nmt",
  "translatedText": "זכור, מיקום 0 יחד עם שאר החזקות של 2 שמורות לחובה לתיקון שגיאות, אז אתה מתחיל בהצבת סיביות ההודעה בכל הנקודות הנותרות, לפי הסדר.",
  "time_range": [
   1014.24,
   1023.32
  ]
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0.",
  "model": "nmt",
  "translatedText": "אתה צריך שתהיה לקבוצה הזו זוגיות זוגית, מה שהיא כבר עושה, אז היית צריך להגדיר את סיביות הזוגיות הזו במיקום 1 להיות 0.",
  "time_range": [
   1025.34,
   1032.34
  ]
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1.",
  "model": "nmt",
  "translatedText": "הקבוצה הבאה מתחילה עם זוגיות אי זוגית, אז היית צריך להגדיר את סיביות הזוגיות שלה להיות 1.",
  "time_range": [
   1033.02,
   1037.88
  ]
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1.",
  "model": "nmt",
  "translatedText": "הקבוצה שאחריה מתחילה עם זוגיות אי זוגית, אז שוב היית צריך להגדיר את סיביות הזוגיות שלה ל-1.",
  "time_range": [
   1039.16,
   1044.24
  ]
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1.",
  "model": "nmt",
  "translatedText": "ולקבוצה הסופית יש גם זוגיות אי זוגית, כלומר הגדרנו את הביט הזה במיקום 8 להיות 1.",
  "time_range": [
   1044.78,
   1050.06
  ]
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0.",
  "model": "nmt",
  "translatedText": "ואז כשלב הסופי, לבלוק המלא כעת יש זוגיות זוגית, כלומר אתה יכול להגדיר את מספר הסיביות 0, סיבית הזוגיות הכוללת, להיות 0.",
  "time_range": [
   1051.3,
   1060.32
  ]
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0.",
  "model": "nmt",
  "translatedText": "אז כאשר הבלוק הזה נשלח, השוויון של ארבע תת-הקבוצות המיוחדות ושל הבלוק בכללותו יהיה זוגי או 0.",
  "time_range": [
   1061.34,
   1068.14
  ]
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver.",
  "model": "nmt",
  "translatedText": "כחלק השני של התרגיל, בואו נגיד לכם לשחק את תפקיד המקלט.",
  "time_range": [
   1068.82,
   1072.18
  ]
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't.",
  "model": "nmt",
  "translatedText": "כמובן, זה אומר שאתם כבר לא יודעים מהי ההודעה הזו, אולי חלקכם שיננו אותה בעל פה, אבל בואו נניח שלא.",
  "time_range": [
   1073.48,
   1079.78
  ]
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did.",
  "model": "nmt",
  "translatedText": "מה שאני הולך לעשות זה לשנות או 0, 1 או 2 מהסיביות בבלוק הזה, ואז לבקש ממך להבין מה זה שעשיתי.",
  "time_range": [
   1080.02,
   1087.74
  ]
 },
 {
  "input": "So again, pause and try working it out.",
  "model": "nmt",
  "translatedText": "אז שוב, עצור ונסה לפתור את זה.",
  "time_range": [
   1088.26,
   1090.81
  ]
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column.",
  "model": "nmt",
  "translatedText": "אוקיי, אז אתה כמקלט עכשיו בודק את קבוצת הזוגיות הראשונה ואתה יכול לראות שהיא זוגית, אז כל שגיאה שקיימת תצטרך להיות בעמודה זוגית.",
  "time_range": [
   1098.79,
   1107.91
  ]
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column.",
  "model": "nmt",
  "translatedText": "הסימון הבא נותן לנו מספר אי-זוגי, אומר לשנינו שיש לפחות שגיאה אחת, ומצמצם אותנו לעמודה הספציפית הזו.",
  "time_range": [
   1109.69,
   1117.03
  ]
 },
 {
  "input": "The third check is even, chopping down the possibilities even further.",
  "model": "nmt",
  "translatedText": "הבדיקה השלישית שווה, ומצמצמת את האפשרויות עוד יותר.",
  "time_range": [
   1118.55,
   1121.79
  ]
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10.",
  "model": "nmt",
  "translatedText": "ובדיקת השוויון האחרונה היא מוזרה, ואומרת לנו שיש שגיאה אי שם בתחתית, שעד עכשיו אנחנו יכולים לראות שהיא חייבת להיות בעמדה מספר 10.",
  "time_range": [
   1122.65,
   1129.65
  ]
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two.",
  "model": "nmt",
  "translatedText": "מה גם שהשוויון של כל הבלוק מוזר, נותן לנו ביטחון שהיה הפוך אחד ולא שניים.",
  "time_range": [
   1131.49,
   1137.53
  ]
 },
 {
  "input": "If it's three or more, all bets are off.",
  "model": "nmt",
  "translatedText": "אם זה שלושה או יותר, כל ההימורים מושבתים.",
  "time_range": [
   1138.07,
   1139.97
  ]
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with.",
  "model": "nmt",
  "translatedText": "לאחר תיקון אותו סיביות מספר 10, שליפת 11 הסיביות שלא שימשו לתיקון נותנת לנו את הקטע הרלוונטי של ההודעה המקורית, שאם תגלגל אחורה ותשווה הוא אכן בדיוק מה שהתחלנו איתו את הדוגמה.",
  "time_range": [
   1141.31,
   1154.39
  ]
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code.",
  "model": "nmt",
  "translatedText": "ועכשיו כשאתה יודע לעשות את כל זה ביד, אני רוצה להראות לך איך אתה יכול לבצע את החלק המרכזי של כל ההיגיון הזה עם שורה אחת של קוד Python.",
  "time_range": [
   1155.71,
   1163.17
  ]
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks.",
  "model": "nmt",
  "translatedText": "אתה מבין, מה שעדיין לא סיפרתי לך זה עד כמה האלגוריתם הזה באמת אלגנטי, כמה פשוט לגרום למכונה להצביע על המיקום של שגיאה, איך לשנות אותה באופן שיטתי ואיך אנחנו יכולים למסגר את כל זאת כפעולה אחת בודדת ולא כמספר בדיקות זוגיות נפרדות.",
  "time_range": [
   1163.87,
   1178.75
  ]
 },
 {
  "input": "To see what I mean, come join me in part 2.",
  "model": "nmt",
  "translatedText": "כדי להבין למה אני מתכוון, בוא הצטרף אליי בחלק 2.",
  "time_range": [
   1179.43,
   1181.31
  ]
 }
]