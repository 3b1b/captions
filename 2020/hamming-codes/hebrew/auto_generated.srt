1
00:00:00,000 --> 00:00:03,120
אני מניח שכולם כאן מגיעים מחלק 1.

2
00:00:03,120 --> 00:00:09,233
דיברנו על קודי Hamming, דרך ליצור גוש נתונים שבו רוב הביטים נושאים מסר משמעותי,

3
00:00:09,233 --> 00:00:15,271
בעוד שכמה אחרים פועלים כסוג של יתירות, באופן כזה שאם ביט כלשהו יתהפך, או הודעה

4
00:00:15,271 --> 00:00:21,920
סיביות או סיביות יתירות, כל דבר בבלוק הזה, מקלט יוכל לזהות שהייתה שגיאה ואיך לתקן אותה.

5
00:00:21,920 --> 00:00:25,738
הרעיון הבסיסי שהוצג שם היה כיצד להשתמש בבדיקות

6
00:00:25,738 --> 00:00:29,800
זוגיות מרובות כדי לחפש בינארי בדרך למטה אל השגיאה.

7
00:00:29,800 --> 00:00:35,420
בסרטון ההוא המטרה הייתה לגרום לקודי האמינג להרגיש מעשיים וניתנים לגילוי מחדש ככל האפשר.

8
00:00:35,420 --> 00:00:39,662
אבל כשאתה מתחיל לחשוב על יישום זה בפועל, בתוכנה או בחומרה,

9
00:00:39,662 --> 00:00:44,120
המסגור הזה עשוי למעשה להמחיש עד כמה הקודים האלה אלגנטיים באמת.

10
00:00:44,120 --> 00:00:49,275
אולי אתה חושב שאתה צריך לכתוב אלגוריתם שעוקב אחר כל מיקומי השגיאות האפשריים

11
00:00:49,275 --> 00:00:54,160
וחותך את הקבוצה הזו לשניים עם כל בדיקה, אבל זה למעשה הרבה יותר פשוט מזה.

12
00:00:54,160 --> 00:00:59,520
אם אתה קורא את התשובות לארבעת בדיקות השוויון שעשינו בסרטון האחרון,

13
00:00:59,520 --> 00:01:04,800
כולן בתור 1 ו-0 במקום כן ולא, זה ממש מפרט את מיקום השגיאה בבינארי.

14
00:01:04,800 --> 00:01:12,640
לדוגמה, המספר 7 בבינארי נראה כמו 0111, בעצם אומר שהוא 4 ועוד 2 ועוד 1.

15
00:01:12,640 --> 00:01:17,287
ושימו לב היכן יושבת עמדה 7, היא אכן משפיעה על הראשונה

16
00:01:17,287 --> 00:01:22,280
בקבוצות השוויוניות שלנו, והשנייה, והשלישית, אך לא האחרונה.

17
00:01:22,280 --> 00:01:28,520
אז קריאת התוצאות של ארבעת הבדיקות הללו מלמטה למעלה אכן מפרטת את מיקומו של השגיאה.

18
00:01:28,520 --> 00:01:32,895
אין שום דבר מיוחד בדוגמה 7, זה עובד באופן כללי, וזה

19
00:01:32,895 --> 00:01:37,440
הופך את ההיגיון ליישום כל הסכימה בחומרה לפשוטה להחריד.

20
00:01:37,440 --> 00:01:44,119
עכשיו אם אתה רוצה לראות למה הקסם הזה קורה, קח את 16 תוויות האינדקס האלה עבור העמדות

21
00:01:44,119 --> 00:01:50,720
שלנו, אבל במקום לכתוב אותן בבסיס 10, בוא נכתוב את כולם בבינארי, החל מ-0000 עד 1111.

22
00:01:50,720 --> 00:01:54,469
כשאנחנו מחזירים את התוויות הבינאריות האלה לקופסאות

23
00:01:54,469 --> 00:01:58,440
שלהן, הרשו לי להדגיש שהן שונות מהנתונים שנשלחים בפועל.

24
00:01:58,440 --> 00:02:04,200
הם לא יותר מאשר תווית מושגית כדי לעזור לך ולי להבין מאיפה הגיעו ארבע קבוצות השוויון.

25
00:02:04,200 --> 00:02:08,607
האלגנטיות של זה שכל מה שאנחנו מסתכלים עליו יתואר בבינארי הוא

26
00:02:08,607 --> 00:02:13,160
אולי תחת הבלבול של זה שכל מה שאנחנו מסתכלים עליו מתואר בבינארי.

27
00:02:13,160 --> 00:02:15,040
אבל זה שווה את זה.

28
00:02:15,040 --> 00:02:19,750
מקד את תשומת לבך רק לחלק האחרון של כל התוויות הללו,

29
00:02:19,750 --> 00:02:24,280
ולאחר מכן הדגש את המיקומים שבהם הקטע האחרון הוא 1.

30
00:02:24,280 --> 00:02:30,554
מה שאנחנו מקבלים היא הראשונה מבין ארבע קבוצות השוויון שלנו, מה שאומר שאתה יכול לפרש

31
00:02:30,554 --> 00:02:36,680
את הסימון הראשון הזה כשואל, היי, אם יש שגיאה, האם הביט האחרון במיקום השגיאה הוא 1?

32
00:02:36,680 --> 00:02:41,531
באופן דומה, אם אתה מתמקד בחלק השני עד האחרון, ומדגיש את כל

33
00:02:41,531 --> 00:02:47,040
המיקומים שבהם זה 1, אתה מקבל את קבוצת השוויון השנייה מהתוכנית שלנו.

34
00:02:47,040 --> 00:02:51,553
במילים אחרות, הבדיקה השנייה שואלת, היי, שוב אני,

35
00:02:51,553 --> 00:02:56,160
אם יש שגיאה, האם החלק השני אחרון במיקום הזה הוא 1?

36
00:02:56,160 --> 00:02:57,160
וכולי.

37
00:02:57,160 --> 00:03:03,284
בדיקת השוויון השלישית מכסה כל עמדה שהביט השלישי עד האחרון שלה מופעל,

38
00:03:03,284 --> 00:03:10,120
והאחרון מכסה את שמונת העמדות האחרונות, אלה שהביט הסדר הגבוה ביותר שלהן הוא 1.

39
00:03:10,120 --> 00:03:19,800
כל מה שעשינו קודם לכן זהה למענה על ארבע השאלות הללו, וזה בתורו זהה לאיית מיקום בבינארי.

40
00:03:19,800 --> 00:03:22,080
אני מקווה שזה מבהיר שני דברים יותר.

41
00:03:22,080 --> 00:03:27,140
הראשון הוא איך להכליל באופן שיטתי לגדלי בלוקים שהם עצמות גדולות יותר של שניים.

42
00:03:27,140 --> 00:03:32,556
אם צריך יותר ביטים כדי לתאר כל מיקום, כמו שישה ביטים כדי לתאר 64

43
00:03:32,556 --> 00:03:38,640
נקודות, אז כל אחד מהסיביות האלה נותן לך אחת מקבוצות הזוגיות שעלינו לבדוק.

44
00:03:38,640 --> 00:03:43,400
אלו מכם שצפו בפאזל לוח השחמט שעשיתי עם מאט פארקר עשויים למצוא את כל זה מוכר מאוד.

45
00:03:43,400 --> 00:03:49,880
זה אותו היגיון הליבה, אבל פתרון בעיה אחרת, מיושם על לוח שחמט של 64 ריבוע.

46
00:03:49,880 --> 00:03:54,061
הדבר השני שאני מקווה שזה מבהיר הוא מדוע סיביות השוויון

47
00:03:54,061 --> 00:03:58,320
שלנו יושבות בעמדות שהן חזקות של שתיים, למשל 1, 2, 4 ו-8.

48
00:03:58,320 --> 00:04:03,640
אלו הן העמדות שהייצוג הבינארי שלהן הופעל רק ביט בודד.

49
00:04:03,640 --> 00:04:12,640
המשמעות היא שכל אחד מאותם סיביות זוגיות יושב בתוך אחת ויחידה מארבע קבוצות הזוגיות.

50
00:04:12,640 --> 00:04:19,226
אתה יכול לראות זאת גם בדוגמאות גדולות יותר, שבהן לא משנה כמה

51
00:04:19,226 --> 00:04:25,920
גדול אתה מקבל, כל סיביות זוגיות נוגעת בנוחות רק באחת מהקבוצות.

52
00:04:25,920 --> 00:04:31,803
ברגע שתבינו שבדיקות השוויון האלה שהתמקדנו בהן כל כך הרבה מזמננו הן לא יותר מאשר דרך

53
00:04:31,803 --> 00:04:37,826
חכמה לאיית את מיקומה של שגיאה בבינארי, אז נוכל ליצור קשר עם דרך אחרת לחשוב על האמינג.

54
00:04:37,826 --> 00:04:43,920
קודים, אחד שהוא ללא ספק הרבה יותר פשוט ואלגנטי, ושאפשר לכתוב אותו בעצם עם שורת קוד אחת.

55
00:04:43,920 --> 00:04:46,200
זה מבוסס על פונקציית XOR.

56
00:04:46,200 --> 00:04:50,960
XOR, למי מכם שלא יודע, מייצג בלעדי או.

57
00:04:50,960 --> 00:04:55,621
כאשר אתה לוקח את ה-XOR של שני סיביות, זה יחזיר 1 אם אחד

58
00:04:55,621 --> 00:05:00,200
מהסיביות האלה מופעל, אבל לא אם שניהם מופעלים או כבויים.

59
00:05:00,200 --> 00:05:03,760
בניסוח שונה, זה השוויון של שני הביטים האלה.

60
00:05:03,760 --> 00:05:07,840
כאדם מתמטיקה, אני מעדיף לחשוב על זה כעל מוד 2 של תוספת.

61
00:05:07,840 --> 00:05:11,007
אנחנו גם מדברים בדרך כלל על XOR של שתי מחרוזות

62
00:05:11,007 --> 00:05:14,040
סיביות שונות, שבעצם עושה את זה רכיב אחר רכיב.

63
00:05:14,040 --> 00:05:16,280
זה כמו תוספת, אבל איפה שאתה אף פעם לא נושא.

64
00:05:16,280 --> 00:05:23,520
שוב, בעלי נטייה מתמטית יותר עשויים להעדיף לחשוב על זה כעל הוספת שני וקטורים והקטנת מוד 2.

65
00:05:23,520 --> 00:05:29,173
אם אתה פותח איזה Python עכשיו ומיישם את פעולת ה-caret בין שני מספרים

66
00:05:29,173 --> 00:05:35,400
שלמים, זה מה שהוא עושה מלבד ייצוגי הסיביות של המספרים האלה מתחת למכסה המנוע.

67
00:05:35,400 --> 00:05:43,412
נקודת המפתח עבורך ולי היא שלקיחת ה-XOR של מחרוזות סיביות שונות היא למעשה דרך

68
00:05:43,412 --> 00:05:51,320
לחשב את הפרודיות של חבורה של קבוצות נפרדות, כמו כך עם העמודות, הכל במכה אחת.

69
00:05:51,320 --> 00:05:55,610
זה נותן לנו דרך די מטופשת לחשוב על בדיקות השוויון המרובות

70
00:05:55,610 --> 00:05:59,680
מאלגוריתם קוד Hamming שלנו, כשהם ארוזים יחד לפעולה אחת.

71
00:05:59,680 --> 00:06:02,800
למרות שבמבט ראשון זה נראה שונה מאוד.

72
00:06:02,800 --> 00:06:11,302
רשום ספציפית את 16 המיקומים בבינארי, כמו שהיה לנו בעבר, ועכשיו סמן את המיקומים שבהם

73
00:06:11,302 --> 00:06:19,400
ביט ההודעה מופעל ל-1, ואז אסוף את המיקומים האלה לעמודה אחת גדולה ולקחת את ה-XOR.

74
00:06:19,400 --> 00:06:26,012
אתם בוודאי יכולים לנחש ש-4 הביטים שיושבים בתחתית כתוצאה מכך זהים ל-4

75
00:06:26,012 --> 00:06:32,720
בדיקות השוויון שלמדנו להכיר ואוהבים, אבל קחו רגע לחשוב באמת למה בדיוק.

76
00:06:32,720 --> 00:06:37,060
העמודה האחרונה הזו, למשל, סופרת את כל המיקומים שהחלק האחרון

77
00:06:37,060 --> 00:06:41,329
שלהם הוא 1, אבל אנחנו כבר מוגבלים רק למיקומים המודגשים, כך

78
00:06:41,329 --> 00:06:45,960
שהיא למעשה סופרת כמה עמדות מודגשות הגיעו מקבוצת השוויון הראשונה.

79
00:06:45,960 --> 00:06:48,520
האם זה הגיוני?

80
00:06:48,520 --> 00:06:54,345
כמו כן, העמודה הבאה סופרת כמה עמדות יש בקבוצת השוויון השנייה,

81
00:06:54,345 --> 00:07:00,640
המיקומים שהביט השני אחרון שלהם הוא 1, ואשר גם הם מודגשים, וכן הלאה.

82
00:07:00,640 --> 00:07:07,640
זה באמת רק שינוי קטן בפרספקטיבה על אותו הדבר שעשינו.

83
00:07:07,640 --> 00:07:10,000
וכך אתה יודע לאן זה הולך מכאן.

84
00:07:10,000 --> 00:07:19,640
השולח אחראי על החלפת חלק מהסיביות השוויוניות המיוחדות כדי לוודא שהסכום יגיע ל-0000.

85
00:07:19,640 --> 00:07:24,146
עכשיו ברגע שיש לנו את זה ככה, זה נותן לנו דרך ממש נחמדה לחשוב מדוע

86
00:07:24,146 --> 00:07:28,720
ארבעת הביטים המתקבלים האלה בתחתית מאייתים ישירות את המיקום של שגיאה.

87
00:07:28,720 --> 00:07:32,720
נניח שחלק מהגוש הזה עובר מ-0 ל-1.

88
00:07:32,720 --> 00:07:38,971
מה שזה אומר הוא שהמיקום של הביט הזה ייכלל כעת ב-XOR הכולל,

89
00:07:38,971 --> 00:07:44,800
מה שמשנה את הסכום מ-0 לערך זה החדש שנכלל, מיקום השגיאה.

90
00:07:44,800 --> 00:07:49,800
מעט פחות ברור, הדבר נכון אם יש שגיאה שמשנה 1 ל-0.

91
00:07:49,800 --> 00:07:54,360
אתה מבין, אם אתה מוסיף קצת מחרוזת יחד פעמיים, זה אותו דבר

92
00:07:54,360 --> 00:07:59,000
כמו לא להיות שם בכלל, בעיקרון כי בעולם הזה 1 ועוד 1 שווה 0.

93
00:07:59,000 --> 00:08:05,400
אז להוספת עותק של המיקום הזה לסכום הכולל יש את אותה השפעה כמו שאנחנו מעבירים אותו.

94
00:08:05,400 --> 00:08:13,480
והאפקט הזה, שוב, הוא שהתוצאה הכוללת בתחתית כאן מפרטת את מיקום השגיאה.

95
00:08:13,480 --> 00:08:17,800
כדי להמחיש עד כמה זה אלגנטי, הרשו לי להראות את השורה האחת של קוד

96
00:08:17,800 --> 00:08:22,120
Python שהתייחסתי אליה קודם, שתלכוד כמעט את כל ההיגיון בקצה המקלט.

97
00:08:22,120 --> 00:08:27,406
נתחיל ביצירת מערך אקראי של 16 1 ו-0 כדי לדמות את בלוק הנתונים, ואני

98
00:08:27,406 --> 00:08:32,536
אתן לו את סיביות השם, אבל כמובן שבפועל זה יהיה משהו שאנחנו מקבלים

99
00:08:32,536 --> 00:08:38,600
מהשולח, ובמקום בהיותו אקראי הוא יוביל 11 סיביות נתונים יחד עם 5 סיביות זוגיות.

100
00:08:38,600 --> 00:08:43,378
אם אני קורא לפונקציה enumerateBits, מה שהיא עושה זה לצמד

101
00:08:43,378 --> 00:08:48,240
כל אחד מהסיביות האלה עם אינדקס מתאים, במקרה הזה מ-0 עד 15.

102
00:08:48,240 --> 00:08:52,652
אז אם אנחנו יוצרים רשימה שמסתובבת בלולאה על כל הזוגות האלה,

103
00:08:52,652 --> 00:08:57,139
זוגות שנראים כמו i, ואז נוציא רק את ערך i, רק את המדד, ובכן,

104
00:08:57,139 --> 00:09:01,920
זה לא כל כך מרגש, אנחנו פשוט מקבלים בחזרה את המדדים האלה 0 עד 15.

105
00:09:01,920 --> 00:09:07,746
אבל אם נוסיף את התנאי לעשות את זה רק אם ביט, כלומר אם הביט הזה הוא

106
00:09:07,746 --> 00:09:13,400
1 ולא 0, ובכן, אז הוא שולף רק את המיקומים שבהם הביט המקביל מופעל.

107
00:09:13,400 --> 00:09:20,720
במקרה זה נראה שהמיקומים האלה הם 0, 4, 6, 9 וכו&#39;.

108
00:09:20,720 --> 00:09:25,194
מה שאנחנו רוצים זה לאסוף את כל המיקומים האלה,

109
00:09:25,194 --> 00:09:29,960
את המיקומים של הביטים המופעלים, ואז XOR אותם יחד.

110
00:09:29,960 --> 00:09:33,960
כדי לעשות זאת ב- Python, תחילה תן לי לייבא כמה פונקציות מועילות.

111
00:09:33,960 --> 00:09:39,140
כך נוכל לקרוא ל-reduce() ברשימה זו, ולהשתמש בפונקציה XOR כדי להקטין אותה.

112
00:09:39,140 --> 00:09:44,840
זה בעצם אוכל את הדרך ברשימה, ולוקח XORs לאורך הדרך.

113
00:09:44,840 --> 00:09:52,200
אם אתה מעדיף, אתה יכול לכתוב במפורש את פונקציית XOR מבלי לייבא אותה מכל מקום.

114
00:09:52,200 --> 00:09:56,996
אז כרגע נראה שאם נעשה זאת על הבלוק האקראי שלנו של

115
00:09:56,996 --> 00:10:02,080
16 סיביות, זה מחזיר 9, שיש לו את הייצוג הבינארי 1001.

116
00:10:02,080 --> 00:10:06,865
לא נעשה את זה כאן, אבל אתה יכול לכתוב פונקציה שבה השולח משתמש בייצוג

117
00:10:06,865 --> 00:10:11,859
הבינארי הזה כדי להגדיר את ארבעת סיביות הזוגיות לפי הצורך, ובסופו של דבר

118
00:10:11,859 --> 00:10:17,200
להביא את הבלוק הזה למצב שבו הפעלת שורת קוד זו ברשימת הביטים המלאה מחזירה א 0.

119
00:10:17,200 --> 00:10:20,200
זה ייחשב לבלוק מוכן היטב.

120
00:10:20,200 --> 00:10:25,130
מה שמגניב הוא שאם נחליף כל אחד מהסיביות ברשימה הזו, המדמה שגיאה

121
00:10:25,130 --> 00:10:30,600
אקראית מרעש, אז אם אתה מפעיל את אותה שורת קוד, הוא מדפיס את השגיאה הזו.

122
00:10:30,600 --> 00:10:31,920
זה לא מסודר?

123
00:10:31,920 --> 00:10:37,597
אתה יכול לקבל את הבלוק הזה ישר, להריץ עליו את השורה הבודדת הזו,

124
00:10:37,597 --> 00:10:42,920
והוא ינוק אוטומטית את המיקום של שגיאה, או 0 אם לא הייתה כזו.

125
00:10:42,920 --> 00:10:45,520
ואין כאן שום דבר מיוחד במידה 16.

126
00:10:45,520 --> 00:10:52,280
אותה שורת קוד תעבוד אם הייתה לך רשימה של, נניח, 256 סיביות.

127
00:10:52,280 --> 00:10:58,680
מיותר לציין שיש עוד קוד לכתוב כאן, כמו ביצוע בדיקת מטא זוגיות כדי לזהות שגיאות של

128
00:10:58,680 --> 00:11:05,080
2 סיביות, אבל הרעיון הוא שכמעט כל הלוגיקה הליבה מהסכמה שלנו מסתכמת בהפחתת XOR אחת.

129
00:11:05,080 --> 00:11:12,363
כעת, בהתאם לנוחות שלך עם רכיבי בינארי ו-XOR ותוכנה באופן כללי, ייתכן שתמצא את הפרספקטיבה

130
00:11:12,363 --> 00:11:19,320
הזו קצת מבלבלת, או הרבה יותר אלגנטי ופשוט שאתה תוהה למה לא התחלנו איתה מההתחלה -ללכת.

131
00:11:19,320 --> 00:11:23,254
באופן רופף, קל יותר לחשוב על פרספקטיבה של בדיקת זוגיות מרובה

132
00:11:23,254 --> 00:11:27,188
בעת יישום קודי Hamming בחומרה באופן ישיר מאוד, ואת פרספקטיבה

133
00:11:27,188 --> 00:11:31,380
של XOR קל יותר לחשוב עליה כאשר עושים זאת בתוכנה, מרמה גבוהה יותר.

134
00:11:31,380 --> 00:11:37,954
את הראשון הכי קל לעשות ביד, ולדעתי הוא עושה עבודה טובה יותר בהחדרת האינטואיציה

135
00:11:37,954 --> 00:11:44,279
הליבה העומדת בבסיס כל זה, והיא שהמידע הנדרש לאיתור שגיאה בודדת קשור ללוג של

136
00:11:44,279 --> 00:11:51,020
גודל הבלוק , או במילים אחרות, הוא גדל טיפה בכל פעם ככל שגודל הבלוק מכפיל את עצמו.

137
00:11:51,020 --> 00:11:56,440
העובדה הרלוונטית כאן היא שהמידע הזה מתאים ישירות לכמות היתירות שאנחנו צריכים.

138
00:11:56,440 --> 00:12:01,914
זה באמת מה שנוגד את התגובה המופרכת של רוב האנשים כשהם חושבים לראשונה על הפיכת הודעה

139
00:12:01,914 --> 00:12:07,520
לעמידה בפני שגיאות, כאשר בדרך כלל העתקה של כל ההודעה היא האינסטינקט הראשון שעולה בראש.

140
00:12:07,520 --> 00:12:11,192
ואז, אגב, יש את כל הדרך האחרת הזו שלפעמים רואים את קודי

141
00:12:11,192 --> 00:12:14,800
האמינג מוצגים, שבה אתה מכפיל את המסר במטריצה אחת גדולה.

142
00:12:14,800 --> 00:12:19,790
זה די נחמד כי זה מקשר את זה למשפחה הרחבה יותר של קודים ליניאריים,

143
00:12:19,790 --> 00:12:25,160
אבל אני חושב שזה כמעט לא נותן אינטואיציה מאיפה זה מגיע או איך זה מתרחב.

144
00:12:25,160 --> 00:12:28,577
ואם כבר מדברים על קנה מידה, אולי תשים לב שהיעילות

145
00:12:28,577 --> 00:12:32,200
של תכנית זו רק משתפרת ככל שאנו מגדילים את גודל הבלוק.

146
00:12:32,200 --> 00:12:37,960
לדוגמה, ראינו שעם 256 סיביות, אתה משתמש רק ב-3%

147
00:12:37,960 --> 00:12:43,480
מהשטח הזה עבור יתירות, ומשם זה רק הולך ומשתפר.

148
00:12:43,480 --> 00:12:49,040
ככל שמספר סיביות הזוגיות גדל בזה אחר זה, גודל הבלוק ממשיך להכפיל את עצמו.

149
00:12:49,040 --> 00:12:54,920
ואם אתה לוקח את זה לקיצוניות, אתה יכול לקבל בלוק עם, נגיד, מיליון ביטים, שבו

150
00:12:54,920 --> 00:13:00,800
אתה ממש משחק 20 שאלות עם בדיקות השוויון שלך, והוא משתמש רק ב-21 ביטים זוגיות.

151
00:13:00,800 --> 00:13:04,886
ואם אתה חוזר אחורה כדי לחשוב על להסתכל על מיליון

152
00:13:04,886 --> 00:13:08,640
ביטים ולאתר שגיאה בודדת, זה באמת מרגיש מטורף.

153
00:13:08,640 --> 00:13:13,390
הבעיה, כמובן, היא שעם בלוק גדול יותר, ההסתברות לראות יותר משגיאת

154
00:13:13,390 --> 00:13:18,360
סיביות אחת או שתיים עולה, וקודי Hamming לא מטפלים בשום דבר מעבר לזה.

155
00:13:18,360 --> 00:13:26,520
אז בפועל, מה שתרצו זה למצוא את הגודל הנכון כך שההסתברות של יותר מדי ביט לא תהיה גבוהה מדי.

156
00:13:26,520 --> 00:13:32,840
כמו כן, בפועל, שגיאות נוטות להגיע בהתפרצויות קטנות, מה שיהרוס לחלוטין

157
00:13:32,840 --> 00:13:38,979
בלוק בודד, אז טקטיקה נפוצה אחת כדי לעזור להפיץ פרץ של שגיאות על פני

158
00:13:38,979 --> 00:13:45,480
בלוקים רבים ושונים היא לשלב את הבלוקים האלה, ככה, לפני שהם נשלח או נשמר.

159
00:13:45,480 --> 00:13:50,411
אז שוב, הרבה מזה הופך ללא ספק על ידי קודים מודרניים יותר, כמו אלגוריתם

160
00:13:50,411 --> 00:13:54,995
ריד-סולומון הנפוץ הרבה יותר, המטפל בשגיאות פרץ בצורה טובה במיוחד,

161
00:13:54,995 --> 00:13:59,580
וניתן לכוון אותו כך שיהיה עמיד למספר גדול יותר של שגיאות בכל בלוק.

162
00:13:59,580 --> 00:14:03,000
אבל זה נושא לפעם אחרת.

163
00:14:03,000 --> 00:14:07,033
בספרו The Art of Doing Science and Engineering, האמינג

164
00:14:07,033 --> 00:14:10,700
הוא כנה להפליא לגבי מידת הפיתול של גילוי הקוד הזה.

165
00:14:10,700 --> 00:14:14,774
תחילה הוא ניסה כל מיני תוכניות שונות שכללו ארגון הסיביות

166
00:14:14,774 --> 00:14:18,420
לחלקים של סריג ממדי גבוה יותר ודברים מוזרים כמו זה.

167
00:14:18,420 --> 00:14:23,391
הרעיון שאולי אפשר לקבל בדיקות זוגיות כדי ליצור קשר בצורה שתפרט

168
00:14:23,391 --> 00:14:28,441
את המיקום של שגיאה, הגיע להאמינג רק כשהוא נסוג לאחר שלל ניתוחים

169
00:14:28,441 --> 00:14:32,860
אחרים ושאל, בסדר, מה הכי יעיל שיכולתי. אפשר לחשוב על זה?

170
00:14:32,860 --> 00:14:37,239
הוא גם היה כנה לגבי כמה חשוב שבדיקות זוגיות כבר היו

171
00:14:37,239 --> 00:14:42,040
בראש שלו, מה שהיה הרבה פחות נפוץ בשנות הארבעים מאשר היום.

172
00:14:42,040 --> 00:14:46,215
יש כמו חצי תריסר פעמים במהלך הספר הזה שהוא מתייחס

173
00:14:46,215 --> 00:14:49,640
לציטוט של לואי פסטר, המזל מעדיף מוח מוכן.

174
00:14:49,640 --> 00:14:52,410
רעיונות חכמים נראים לעתים קרובות פשוטים בצורה

175
00:14:52,410 --> 00:14:55,120
מטעה במבט לאחור, מה שמקל על הערכה נמוכה יותר.

176
00:14:55,120 --> 00:15:01,820
כרגע תקוותי הכנה היא שקודי האמינג, או לפחות האפשרות של קודים כאלה, מרגישים לך כמעט ברורים.

177
00:15:01,820 --> 00:15:08,000
אבל אתה לא צריך להטעות את עצמך לחשוב שהם בעצם ברורים, כי הם בהחלט לא.

178
00:15:08,000 --> 00:15:13,193
חלק מהסיבה שרעיונות חכמים נראים קלים בצורה מטעה היא שאנחנו רואים רק את התוצאה

179
00:15:13,193 --> 00:15:18,253
הסופית, מנקים את מה שהיה מבולגן, אף פעם לא מזכירים את כל הפניות הלא נכונות,

180
00:15:18,253 --> 00:15:23,980
ומדגישים עד כמה עצום המרחב של האפשרויות הניתנות לחקירה בתחילת בעיה תהליך פתרון, כל זה.

181
00:15:23,980 --> 00:15:25,280
אבל זה נכון באופן כללי.

182
00:15:25,280 --> 00:15:31,040
אני חושב שלכמה המצאות מיוחדות, יש סיבה שנייה, עמוקה יותר לכך שאנחנו פחות מעריכים אותן.

183
00:15:31,040 --> 00:15:35,102
חשיבה על מידע במונחים של ביטים התלכדה לתיאוריה מלאה

184
00:15:35,102 --> 00:15:39,400
רק ב-1948, עם המאמר המכונן של קלוד שאנון על תורת המידע.

185
00:15:39,400 --> 00:15:43,440
זה היה בעצם במקביל לזמן שבו האמינג פיתח את האלגוריתם שלו.

186
00:15:43,440 --> 00:15:48,760
זה היה אותו מאמר יסוד שהראה, במובן מסוים, שתיקון שגיאות יעיל תמיד

187
00:15:48,760 --> 00:15:53,920
אפשרי, לא משנה כמה גבוהה ההסתברות להיפוך סיביות, לפחות בתיאוריה.

188
00:15:53,920 --> 00:15:57,954
שאנון והאמינג, אגב, חלקו משרד ב-Bell Labs, למרות

189
00:15:57,954 --> 00:16:02,400
שעבדו על דברים שונים מאוד, מה שכמעט ולא נראה מקרי כאן.

190
00:16:02,400 --> 00:16:07,906
הרץ קדימה כמה עשורים, ובימים אלה, רבים מאיתנו שקועים כל כך בחשיבה

191
00:16:07,906 --> 00:16:13,080
על פיסות ומידע שקל להתעלם עד כמה הייתה צורת החשיבה הזו מובחנת.

192
00:16:13,080 --> 00:16:15,379
למרבה האירוניה, הרעיונות שמעצבים בצורה העמוקה ביותר את הדרכים שדור

193
00:16:15,379 --> 00:16:17,920
העתיד חושב יסתכלו בסופו של דבר על אותו דור העתיד פשוטות יותר ממה שהם באמת.

