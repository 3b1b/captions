1
00:00:00,000 --> 00:00:03,120
אני מניח שכולם כאן מגיעים מחלק 1.

2
00:00:03,120 --> 00:00:09,233
דיברנו על קודי Hamming, דרך ליצור גוש נתונים שבו רוב הביטים נושאים מסר משמעותי,

3
00:00:09,233 --> 00:00:14,583
בעוד שכמה אחרים פועלים כסוג של יתירות, באופן כזה שאם ביט כלשהו יתהפך,

4
00:00:14,583 --> 00:00:18,557
או הודעה סיביות או סיביות יתירות, כל דבר בבלוק הזה,

5
00:00:18,557 --> 00:00:21,920
מקלט יוכל לזהות שהייתה שגיאה ואיך לתקן אותה.

6
00:00:21,920 --> 00:00:25,738
הרעיון הבסיסי שהוצג שם היה כיצד להשתמש בבדיקות

7
00:00:25,738 --> 00:00:29,800
זוגיות מרובות כדי לחפש בינארי בדרך למטה אל השגיאה.

8
00:00:29,800 --> 00:00:35,420
בסרטון ההוא המטרה הייתה לגרום לקודי האמינג להרגיש מעשיים וניתנים לגילוי מחדש ככל האפשר.

9
00:00:35,420 --> 00:00:39,662
אבל כשאתה מתחיל לחשוב על יישום זה בפועל, בתוכנה או בחומרה,

10
00:00:39,662 --> 00:00:44,120
המסגור הזה עשוי למעשה להמחיש עד כמה הקודים האלה אלגנטיים באמת.

11
00:00:44,120 --> 00:00:49,275
אולי אתה חושב שאתה צריך לכתוב אלגוריתם שעוקב אחר כל מיקומי השגיאות האפשריים

12
00:00:49,275 --> 00:00:54,160
וחותך את הקבוצה הזו לשניים עם כל בדיקה, אבל זה למעשה הרבה יותר פשוט מזה.

13
00:00:54,160 --> 00:00:59,520
אם אתה קורא את התשובות לארבעת בדיקות השוויון שעשינו בסרטון האחרון,

14
00:00:59,520 --> 00:01:04,800
כולן בתור 1 ו-0 במקום כן ולא, זה ממש מפרט את מיקום השגיאה בבינארי.

15
00:01:04,800 --> 00:01:12,640
לדוגמה, המספר 7 בבינארי נראה כמו 0111, בעצם אומר שהוא 4 ועוד 2 ועוד 1.

16
00:01:12,640 --> 00:01:19,439
ושימו לב היכן יושבת עמדה 7, היא אכן משפיעה על הראשונה בקבוצות השוויוניות שלנו,

17
00:01:19,439 --> 00:01:22,280
והשנייה, והשלישית, אך לא האחרונה.

18
00:01:22,280 --> 00:01:28,520
אז קריאת התוצאות של ארבעת הבדיקות הללו מלמטה למעלה אכן מפרטת את מיקומו של השגיאה.

19
00:01:28,520 --> 00:01:32,559
אין שום דבר מיוחד בדוגמה 7, זה עובד באופן כללי,

20
00:01:32,559 --> 00:01:37,440
וזה הופך את ההיגיון ליישום כל הסכימה בחומרה לפשוטה להחריד.

21
00:01:37,440 --> 00:01:44,596
עכשיו אם אתה רוצה לראות למה הקסם הזה קורה, קח את 16 תוויות האינדקס האלה עבור העמדות שלנו,

22
00:01:44,596 --> 00:01:50,720
אבל במקום לכתוב אותן בבסיס 10, בוא נכתוב את כולם בבינארי, החל מ-0000 עד 1111.

23
00:01:50,720 --> 00:01:54,910
כשאנחנו מחזירים את התוויות הבינאריות האלה לקופסאות שלהן,

24
00:01:54,910 --> 00:01:58,440
הרשו לי להדגיש שהן שונות מהנתונים שנשלחים בפועל.

25
00:01:58,440 --> 00:02:04,200
הם לא יותר מאשר תווית מושגית כדי לעזור לך ולי להבין מאיפה הגיעו ארבע קבוצות השוויון.

26
00:02:04,200 --> 00:02:08,607
האלגנטיות של זה שכל מה שאנחנו מסתכלים עליו יתואר בבינארי הוא

27
00:02:08,607 --> 00:02:13,160
אולי תחת הבלבול של זה שכל מה שאנחנו מסתכלים עליו מתואר בבינארי.

28
00:02:13,160 --> 00:02:15,040
אבל זה שווה את זה.

29
00:02:15,040 --> 00:02:19,750
מקד את תשומת לבך רק לחלק האחרון של כל התוויות הללו,

30
00:02:19,750 --> 00:02:24,280
ולאחר מכן הדגש את המיקומים שבהם הקטע האחרון הוא 1.

31
00:02:24,280 --> 00:02:28,761
מה שאנחנו מקבלים היא הראשונה מבין ארבע קבוצות השוויון שלנו,

32
00:02:28,761 --> 00:02:33,990
מה שאומר שאתה יכול לפרש את הסימון הראשון הזה כשואל, היי, אם יש שגיאה,

33
00:02:33,990 --> 00:02:36,680
האם הביט האחרון במיקום השגיאה הוא 1?

34
00:02:36,680 --> 00:02:43,175
באופן דומה, אם אתה מתמקד בחלק השני עד האחרון, ומדגיש את כל המיקומים שבהם זה 1,

35
00:02:43,175 --> 00:02:47,040
אתה מקבל את קבוצת השוויון השנייה מהתוכנית שלנו.

36
00:02:47,040 --> 00:02:51,553
במילים אחרות, הבדיקה השנייה שואלת, היי, שוב אני,

37
00:02:51,553 --> 00:02:56,160
אם יש שגיאה, האם החלק השני אחרון במיקום הזה הוא 1?

38
00:02:56,160 --> 00:02:57,160
וכולי.

39
00:02:57,160 --> 00:03:03,284
בדיקת השוויון השלישית מכסה כל עמדה שהביט השלישי עד האחרון שלה מופעל,

40
00:03:03,284 --> 00:03:10,120
והאחרון מכסה את שמונת העמדות האחרונות, אלה שהביט הסדר הגבוה ביותר שלהן הוא 1.

41
00:03:10,120 --> 00:03:19,800
כל מה שעשינו קודם לכן זהה למענה על ארבע השאלות הללו, וזה בתורו זהה לאיית מיקום בבינארי.

42
00:03:19,800 --> 00:03:22,080
אני מקווה שזה מבהיר שני דברים יותר.

43
00:03:22,080 --> 00:03:27,140
הראשון הוא איך להכליל באופן שיטתי לגדלי בלוקים שהם עצמות גדולות יותר של שניים.

44
00:03:27,140 --> 00:03:33,223
אם צריך יותר ביטים כדי לתאר כל מיקום, כמו שישה ביטים כדי לתאר 64 נקודות,

45
00:03:33,223 --> 00:03:38,640
אז כל אחד מהסיביות האלה נותן לך אחת מקבוצות הזוגיות שעלינו לבדוק.

46
00:03:38,640 --> 00:03:43,400
אלו מכם שצפו בפאזל לוח השחמט שעשיתי עם מאט פארקר עשויים למצוא את כל זה מוכר מאוד.

47
00:03:43,400 --> 00:03:49,880
זה אותו היגיון הליבה, אבל פתרון בעיה אחרת, מיושם על לוח שחמט של 64 ריבוע.

48
00:03:49,880 --> 00:03:54,061
הדבר השני שאני מקווה שזה מבהיר הוא מדוע סיביות השוויון

49
00:03:54,061 --> 00:03:58,320
שלנו יושבות בעמדות שהן חזקות של שתיים, למשל 1, 2, 4 ו-8.

50
00:03:58,320 --> 00:04:03,640
אלו הן העמדות שהייצוג הבינארי שלהן הופעל רק ביט בודד.

51
00:04:03,640 --> 00:04:12,640
המשמעות היא שכל אחד מאותם סיביות זוגיות יושב בתוך אחת ויחידה מארבע קבוצות הזוגיות.

52
00:04:12,640 --> 00:04:20,845
אתה יכול לראות זאת גם בדוגמאות גדולות יותר, שבהן לא משנה כמה גדול אתה מקבל,

53
00:04:20,845 --> 00:04:25,920
כל סיביות זוגיות נוגעת בנוחות רק באחת מהקבוצות.

54
00:04:25,920 --> 00:04:31,803
ברגע שתבינו שבדיקות השוויון האלה שהתמקדנו בהן כל כך הרבה מזמננו הן לא יותר מאשר דרך

55
00:04:31,803 --> 00:04:37,826
חכמה לאיית את מיקומה של שגיאה בבינארי, אז נוכל ליצור קשר עם דרך אחרת לחשוב על האמינג.

56
00:04:37,826 --> 00:04:43,920
קודים, אחד שהוא ללא ספק הרבה יותר פשוט ואלגנטי, ושאפשר לכתוב אותו בעצם עם שורת קוד אחת.

57
00:04:43,920 --> 00:04:46,200
זה מבוסס על פונקציית XOR.

58
00:04:46,200 --> 00:04:50,960
XOR, למי מכם שלא יודע, מייצג בלעדי או.

59
00:04:50,960 --> 00:04:57,369
כאשר אתה לוקח את ה-XOR של שני סיביות, זה יחזיר 1 אם אחד מהסיביות האלה מופעל,

60
00:04:57,369 --> 00:05:00,200
אבל לא אם שניהם מופעלים או כבויים.

61
00:05:00,200 --> 00:05:03,760
בניסוח שונה, זה השוויון של שני הביטים האלה.

62
00:05:03,760 --> 00:05:07,840
כאדם מתמטיקה, אני מעדיף לחשוב על זה כעל מוד 2 של תוספת.

63
00:05:07,840 --> 00:05:11,950
אנחנו גם מדברים בדרך כלל על XOR של שתי מחרוזות סיביות שונות,

64
00:05:11,950 --> 00:05:14,040
שבעצם עושה את זה רכיב אחר רכיב.

65
00:05:14,040 --> 00:05:16,280
זה כמו תוספת, אבל איפה שאתה אף פעם לא נושא.

66
00:05:16,280 --> 00:05:23,520
שוב, בעלי נטייה מתמטית יותר עשויים להעדיף לחשוב על זה כעל הוספת שני וקטורים והקטנת מוד 2.

67
00:05:23,520 --> 00:05:29,746
אם אתה פותח איזה Python עכשיו ומיישם את פעולת ה-caret בין שני מספרים שלמים,

68
00:05:29,746 --> 00:05:35,400
זה מה שהוא עושה מלבד ייצוגי הסיביות של המספרים האלה מתחת למכסה המנוע.

69
00:05:35,400 --> 00:05:43,412
נקודת המפתח עבורך ולי היא שלקיחת ה-XOR של מחרוזות סיביות שונות היא למעשה דרך

70
00:05:43,412 --> 00:05:51,320
לחשב את הפרודיות של חבורה של קבוצות נפרדות, כמו כך עם העמודות, הכל במכה אחת.

71
00:05:51,320 --> 00:05:57,682
זה נותן לנו דרך די מטופשת לחשוב על בדיקות השוויון המרובות מאלגוריתם קוד Hamming שלנו,

72
00:05:57,682 --> 00:05:59,680
כשהם ארוזים יחד לפעולה אחת.

73
00:05:59,680 --> 00:06:02,800
למרות שבמבט ראשון זה נראה שונה מאוד.

74
00:06:02,800 --> 00:06:08,468
רשום ספציפית את 16 המיקומים בבינארי, כמו שהיה לנו בעבר,

75
00:06:08,468 --> 00:06:13,529
ועכשיו סמן את המיקומים שבהם ביט ההודעה מופעל ל-1,

76
00:06:13,529 --> 00:06:19,400
ואז אסוף את המיקומים האלה לעמודה אחת גדולה ולקחת את ה-XOR.

77
00:06:19,400 --> 00:06:26,012
אתם בוודאי יכולים לנחש ש-4 הביטים שיושבים בתחתית כתוצאה מכך זהים ל-4

78
00:06:26,012 --> 00:06:32,720
בדיקות השוויון שלמדנו להכיר ואוהבים, אבל קחו רגע לחשוב באמת למה בדיוק.

79
00:06:32,720 --> 00:06:37,929
העמודה האחרונה הזו, למשל, סופרת את כל המיקומים שהחלק האחרון שלהם הוא 1,

80
00:06:37,929 --> 00:06:42,125
אבל אנחנו כבר מוגבלים רק למיקומים המודגשים, כך שהיא למעשה

81
00:06:42,125 --> 00:06:45,960
סופרת כמה עמדות מודגשות הגיעו מקבוצת השוויון הראשונה.

82
00:06:45,960 --> 00:06:48,520
האם זה הגיוני?

83
00:06:48,520 --> 00:06:54,345
כמו כן, העמודה הבאה סופרת כמה עמדות יש בקבוצת השוויון השנייה,

84
00:06:54,345 --> 00:07:00,640
המיקומים שהביט השני אחרון שלהם הוא 1, ואשר גם הם מודגשים, וכן הלאה.

85
00:07:00,640 --> 00:07:07,640
זה באמת רק שינוי קטן בפרספקטיבה על אותו הדבר שעשינו.

86
00:07:07,640 --> 00:07:10,000
וכך אתה יודע לאן זה הולך מכאן.

87
00:07:10,000 --> 00:07:19,640
השולח אחראי על החלפת חלק מהסיביות השוויוניות המיוחדות כדי לוודא שהסכום יגיע ל-0000.

88
00:07:19,640 --> 00:07:24,146
עכשיו ברגע שיש לנו את זה ככה, זה נותן לנו דרך ממש נחמדה לחשוב מדוע

89
00:07:24,146 --> 00:07:28,720
ארבעת הביטים המתקבלים האלה בתחתית מאייתים ישירות את המיקום של שגיאה.

90
00:07:28,720 --> 00:07:32,720
נניח שחלק מהגוש הזה עובר מ-0 ל-1.

91
00:07:32,720 --> 00:07:38,971
מה שזה אומר הוא שהמיקום של הביט הזה ייכלל כעת ב-XOR הכולל,

92
00:07:38,971 --> 00:07:44,800
מה שמשנה את הסכום מ-0 לערך זה החדש שנכלל, מיקום השגיאה.

93
00:07:44,800 --> 00:07:49,800
מעט פחות ברור, הדבר נכון אם יש שגיאה שמשנה 1 ל-0.

94
00:07:49,800 --> 00:07:56,090
אתה מבין, אם אתה מוסיף קצת מחרוזת יחד פעמיים, זה אותו דבר כמו לא להיות שם בכלל,

95
00:07:56,090 --> 00:07:59,000
בעיקרון כי בעולם הזה 1 ועוד 1 שווה 0.

96
00:07:59,000 --> 00:08:05,400
אז להוספת עותק של המיקום הזה לסכום הכולל יש את אותה השפעה כמו שאנחנו מעבירים אותו.

97
00:08:05,400 --> 00:08:13,480
והאפקט הזה, שוב, הוא שהתוצאה הכוללת בתחתית כאן מפרטת את מיקום השגיאה.

98
00:08:13,480 --> 00:08:17,800
כדי להמחיש עד כמה זה אלגנטי, הרשו לי להראות את השורה האחת של קוד

99
00:08:17,800 --> 00:08:22,120
Python שהתייחסתי אליה קודם, שתלכוד כמעט את כל ההיגיון בקצה המקלט.

100
00:08:22,120 --> 00:08:27,017
נתחיל ביצירת מערך אקראי של 16 1 ו-0 כדי לדמות את בלוק הנתונים,

101
00:08:27,017 --> 00:08:33,158
ואני אתן לו את סיביות השם, אבל כמובן שבפועל זה יהיה משהו שאנחנו מקבלים מהשולח,

102
00:08:33,158 --> 00:08:38,600
ובמקום בהיותו אקראי הוא יוביל 11 סיביות נתונים יחד עם 5 סיביות זוגיות.

103
00:08:38,600 --> 00:08:43,378
אם אני קורא לפונקציה enumerateBits, מה שהיא עושה זה לצמד

104
00:08:43,378 --> 00:08:48,240
כל אחד מהסיביות האלה עם אינדקס מתאים, במקרה הזה מ-0 עד 15.

105
00:08:48,240 --> 00:08:52,652
אז אם אנחנו יוצרים רשימה שמסתובבת בלולאה על כל הזוגות האלה,

106
00:08:52,652 --> 00:08:57,139
זוגות שנראים כמו i, ואז נוציא רק את ערך i, רק את המדד, ובכן,

107
00:08:57,139 --> 00:09:01,920
זה לא כל כך מרגש, אנחנו פשוט מקבלים בחזרה את המדדים האלה 0 עד 15.

108
00:09:01,920 --> 00:09:08,529
אבל אם נוסיף את התנאי לעשות את זה רק אם ביט, כלומר אם הביט הזה הוא 1 ולא 0,

109
00:09:08,529 --> 00:09:13,400
ובכן, אז הוא שולף רק את המיקומים שבהם הביט המקביל מופעל.

110
00:09:13,400 --> 00:09:20,720
במקרה זה נראה שהמיקומים האלה הם 0, 4, 6, 9 וכו&#39;.

111
00:09:20,720 --> 00:09:28,306
מה שאנחנו רוצים זה לאסוף את כל המיקומים האלה, את המיקומים של הביטים המופעלים,

112
00:09:28,306 --> 00:09:29,960
ואז XOR אותם יחד.

113
00:09:29,960 --> 00:09:33,960
כדי לעשות זאת ב- Python, תחילה תן לי לייבא כמה פונקציות מועילות.

114
00:09:33,960 --> 00:09:39,140
כך נוכל לקרוא ל-reduce() ברשימה זו, ולהשתמש בפונקציה XOR כדי להקטין אותה.

115
00:09:39,140 --> 00:09:44,840
זה בעצם אוכל את הדרך ברשימה, ולוקח XORs לאורך הדרך.

116
00:09:44,840 --> 00:09:52,200
אם אתה מעדיף, אתה יכול לכתוב במפורש את פונקציית XOR מבלי לייבא אותה מכל מקום.

117
00:09:52,200 --> 00:09:58,051
אז כרגע נראה שאם נעשה זאת על הבלוק האקראי שלנו של 16 סיביות,

118
00:09:58,051 --> 00:10:02,080
זה מחזיר 9, שיש לו את הייצוג הבינארי 1001.

119
00:10:02,080 --> 00:10:06,865
לא נעשה את זה כאן, אבל אתה יכול לכתוב פונקציה שבה השולח משתמש בייצוג

120
00:10:06,865 --> 00:10:10,888
הבינארי הזה כדי להגדיר את ארבעת סיביות הזוגיות לפי הצורך,

121
00:10:10,888 --> 00:10:16,020
ובסופו של דבר להביא את הבלוק הזה למצב שבו הפעלת שורת קוד זו ברשימת הביטים

122
00:10:16,020 --> 00:10:17,200
המלאה מחזירה א 0.

123
00:10:17,200 --> 00:10:20,200
זה ייחשב לבלוק מוכן היטב.

124
00:10:20,200 --> 00:10:26,131
מה שמגניב הוא שאם נחליף כל אחד מהסיביות ברשימה הזו, המדמה שגיאה אקראית מרעש,

125
00:10:26,131 --> 00:10:30,600
אז אם אתה מפעיל את אותה שורת קוד, הוא מדפיס את השגיאה הזו.

126
00:10:30,600 --> 00:10:31,920
זה לא מסודר?

127
00:10:31,920 --> 00:10:37,597
אתה יכול לקבל את הבלוק הזה ישר, להריץ עליו את השורה הבודדת הזו,

128
00:10:37,597 --> 00:10:42,920
והוא ינוק אוטומטית את המיקום של שגיאה, או 0 אם לא הייתה כזו.

129
00:10:42,920 --> 00:10:45,520
ואין כאן שום דבר מיוחד במידה 16.

130
00:10:45,520 --> 00:10:52,280
אותה שורת קוד תעבוד אם הייתה לך רשימה של, נניח, 256 סיביות.

131
00:10:52,280 --> 00:10:58,680
מיותר לציין שיש עוד קוד לכתוב כאן, כמו ביצוע בדיקת מטא זוגיות כדי לזהות שגיאות של

132
00:10:58,680 --> 00:11:05,080
2 סיביות, אבל הרעיון הוא שכמעט כל הלוגיקה הליבה מהסכמה שלנו מסתכמת בהפחתת XOR אחת.

133
00:11:05,080 --> 00:11:10,235
כעת, בהתאם לנוחות שלך עם רכיבי בינארי ו-XOR ותוכנה באופן כללי,

134
00:11:10,235 --> 00:11:17,192
ייתכן שתמצא את הפרספקטיבה הזו קצת מבלבלת, או הרבה יותר אלגנטי ופשוט שאתה תוהה למה לא

135
00:11:17,192 --> 00:11:19,320
התחלנו איתה מההתחלה -ללכת.

136
00:11:19,320 --> 00:11:23,254
באופן רופף, קל יותר לחשוב על פרספקטיבה של בדיקת זוגיות מרובה

137
00:11:23,254 --> 00:11:26,285
בעת יישום קודי Hamming בחומרה באופן ישיר מאוד,

138
00:11:26,285 --> 00:11:31,380
ואת פרספקטיבה של XOR קל יותר לחשוב עליה כאשר עושים זאת בתוכנה, מרמה גבוהה יותר.

139
00:11:31,380 --> 00:11:37,954
את הראשון הכי קל לעשות ביד, ולדעתי הוא עושה עבודה טובה יותר בהחדרת האינטואיציה

140
00:11:37,954 --> 00:11:45,361
הליבה העומדת בבסיס כל זה, והיא שהמידע הנדרש לאיתור שגיאה בודדת קשור ללוג של גודל הבלוק ,

141
00:11:45,361 --> 00:11:51,020
או במילים אחרות, הוא גדל טיפה בכל פעם ככל שגודל הבלוק מכפיל את עצמו.

142
00:11:51,020 --> 00:11:56,440
העובדה הרלוונטית כאן היא שהמידע הזה מתאים ישירות לכמות היתירות שאנחנו צריכים.

143
00:11:56,440 --> 00:12:01,914
זה באמת מה שנוגד את התגובה המופרכת של רוב האנשים כשהם חושבים לראשונה על הפיכת הודעה

144
00:12:01,914 --> 00:12:07,520
לעמידה בפני שגיאות, כאשר בדרך כלל העתקה של כל ההודעה היא האינסטינקט הראשון שעולה בראש.

145
00:12:07,520 --> 00:12:12,176
ואז, אגב, יש את כל הדרך האחרת הזו שלפעמים רואים את קודי האמינג מוצגים,

146
00:12:12,176 --> 00:12:14,800
שבה אתה מכפיל את המסר במטריצה אחת גדולה.

147
00:12:14,800 --> 00:12:19,790
זה די נחמד כי זה מקשר את זה למשפחה הרחבה יותר של קודים ליניאריים,

148
00:12:19,790 --> 00:12:25,160
אבל אני חושב שזה כמעט לא נותן אינטואיציה מאיפה זה מגיע או איך זה מתרחב.

149
00:12:25,160 --> 00:12:28,577
ואם כבר מדברים על קנה מידה, אולי תשים לב שהיעילות

150
00:12:28,577 --> 00:12:32,200
של תכנית זו רק משתפרת ככל שאנו מגדילים את גודל הבלוק.

151
00:12:32,200 --> 00:12:40,720
לדוגמה, ראינו שעם 256 סיביות, אתה משתמש רק ב-3% מהשטח הזה עבור יתירות,

152
00:12:40,720 --> 00:12:43,480
ומשם זה רק הולך ומשתפר.

153
00:12:43,480 --> 00:12:49,040
ככל שמספר סיביות הזוגיות גדל בזה אחר זה, גודל הבלוק ממשיך להכפיל את עצמו.

154
00:12:49,040 --> 00:12:54,614
ואם אתה לוקח את זה לקיצוניות, אתה יכול לקבל בלוק עם, נגיד, מיליון ביטים,

155
00:12:54,614 --> 00:13:00,800
שבו אתה ממש משחק 20 שאלות עם בדיקות השוויון שלך, והוא משתמש רק ב-21 ביטים זוגיות.

156
00:13:00,800 --> 00:13:06,971
ואם אתה חוזר אחורה כדי לחשוב על להסתכל על מיליון ביטים ולאתר שגיאה בודדת,

157
00:13:06,971 --> 00:13:08,640
זה באמת מרגיש מטורף.

158
00:13:08,640 --> 00:13:13,390
הבעיה, כמובן, היא שעם בלוק גדול יותר, ההסתברות לראות יותר משגיאת

159
00:13:13,390 --> 00:13:18,360
סיביות אחת או שתיים עולה, וקודי Hamming לא מטפלים בשום דבר מעבר לזה.

160
00:13:18,360 --> 00:13:26,520
אז בפועל, מה שתרצו זה למצוא את הגודל הנכון כך שההסתברות של יותר מדי ביט לא תהיה גבוהה מדי.

161
00:13:26,520 --> 00:13:33,833
כמו כן, בפועל, שגיאות נוטות להגיע בהתפרצויות קטנות, מה שיהרוס לחלוטין בלוק בודד,

162
00:13:33,833 --> 00:13:40,062
אז טקטיקה נפוצה אחת כדי לעזור להפיץ פרץ של שגיאות על פני בלוקים רבים

163
00:13:40,062 --> 00:13:45,480
ושונים היא לשלב את הבלוקים האלה, ככה, לפני שהם נשלח או נשמר.

164
00:13:45,480 --> 00:13:49,508
אז שוב, הרבה מזה הופך ללא ספק על ידי קודים מודרניים יותר,

165
00:13:49,508 --> 00:13:54,995
כמו אלגוריתם ריד-סולומון הנפוץ הרבה יותר, המטפל בשגיאות פרץ בצורה טובה במיוחד,

166
00:13:54,995 --> 00:13:59,580
וניתן לכוון אותו כך שיהיה עמיד למספר גדול יותר של שגיאות בכל בלוק.

167
00:13:59,580 --> 00:14:03,000
אבל זה נושא לפעם אחרת.

168
00:14:03,000 --> 00:14:06,520
בספרו The Art of Doing Science and Engineering,

169
00:14:06,520 --> 00:14:10,700
האמינג הוא כנה להפליא לגבי מידת הפיתול של גילוי הקוד הזה.

170
00:14:10,700 --> 00:14:14,774
תחילה הוא ניסה כל מיני תוכניות שונות שכללו ארגון הסיביות

171
00:14:14,774 --> 00:14:18,420
לחלקים של סריג ממדי גבוה יותר ודברים מוזרים כמו זה.

172
00:14:18,420 --> 00:14:24,969
הרעיון שאולי אפשר לקבל בדיקות זוגיות כדי ליצור קשר בצורה שתפרט את המיקום של שגיאה,

173
00:14:24,969 --> 00:14:29,861
הגיע להאמינג רק כשהוא נסוג לאחר שלל ניתוחים אחרים ושאל, בסדר,

174
00:14:29,861 --> 00:14:32,860
מה הכי יעיל שיכולתי. אפשר לחשוב על זה?

175
00:14:32,860 --> 00:14:38,081
הוא גם היה כנה לגבי כמה חשוב שבדיקות זוגיות כבר היו בראש שלו,

176
00:14:38,081 --> 00:14:42,040
מה שהיה הרבה פחות נפוץ בשנות הארבעים מאשר היום.

177
00:14:42,040 --> 00:14:47,969
יש כמו חצי תריסר פעמים במהלך הספר הזה שהוא מתייחס לציטוט של לואי פסטר,

178
00:14:47,969 --> 00:14:49,640
המזל מעדיף מוח מוכן.

179
00:14:49,640 --> 00:14:53,433
רעיונות חכמים נראים לעתים קרובות פשוטים בצורה מטעה במבט לאחור,

180
00:14:53,433 --> 00:14:55,120
מה שמקל על הערכה נמוכה יותר.

181
00:14:55,120 --> 00:15:01,820
כרגע תקוותי הכנה היא שקודי האמינג, או לפחות האפשרות של קודים כאלה, מרגישים לך כמעט ברורים.

182
00:15:01,820 --> 00:15:08,000
אבל אתה לא צריך להטעות את עצמך לחשוב שהם בעצם ברורים, כי הם בהחלט לא.

183
00:15:08,000 --> 00:15:13,726
חלק מהסיבה שרעיונות חכמים נראים קלים בצורה מטעה היא שאנחנו רואים רק את התוצאה הסופית,

184
00:15:13,726 --> 00:15:18,253
מנקים את מה שהיה מבולגן, אף פעם לא מזכירים את כל הפניות הלא נכונות,

185
00:15:18,253 --> 00:15:23,980
ומדגישים עד כמה עצום המרחב של האפשרויות הניתנות לחקירה בתחילת בעיה תהליך פתרון, כל זה.

186
00:15:23,980 --> 00:15:25,280
אבל זה נכון באופן כללי.

187
00:15:25,280 --> 00:15:31,040
אני חושב שלכמה המצאות מיוחדות, יש סיבה שנייה, עמוקה יותר לכך שאנחנו פחות מעריכים אותן.

188
00:15:31,040 --> 00:15:35,962
חשיבה על מידע במונחים של ביטים התלכדה לתיאוריה מלאה רק ב-1948,

189
00:15:35,962 --> 00:15:39,400
עם המאמר המכונן של קלוד שאנון על תורת המידע.

190
00:15:39,400 --> 00:15:43,440
זה היה בעצם במקביל לזמן שבו האמינג פיתח את האלגוריתם שלו.

191
00:15:43,440 --> 00:15:49,324
זה היה אותו מאמר יסוד שהראה, במובן מסוים, שתיקון שגיאות יעיל תמיד אפשרי,

192
00:15:49,324 --> 00:15:53,920
לא משנה כמה גבוהה ההסתברות להיפוך סיביות, לפחות בתיאוריה.

193
00:15:53,920 --> 00:16:00,177
שאנון והאמינג, אגב, חלקו משרד ב-Bell Labs, למרות שעבדו על דברים שונים מאוד,

194
00:16:00,177 --> 00:16:02,400
מה שכמעט ולא נראה מקרי כאן.

195
00:16:02,400 --> 00:16:07,906
הרץ קדימה כמה עשורים, ובימים אלה, רבים מאיתנו שקועים כל כך בחשיבה

196
00:16:07,906 --> 00:16:13,080
על פיסות ומידע שקל להתעלם עד כמה הייתה צורת החשיבה הזו מובחנת.

197
00:16:13,080 --> 00:16:15,379
למרבה האירוניה, הרעיונות שמעצבים בצורה העמוקה ביותר את הדרכים שדור

198
00:16:15,379 --> 00:16:17,920
העתיד חושב יסתכלו בסופו של דבר על אותו דור העתיד פשוטות יותר ממה שהם באמת.

