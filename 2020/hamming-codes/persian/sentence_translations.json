[
 {
  "input": "Have you ever wondered how it's possible to scratch a CD or a DVD and still have it play back whatever it's storing? ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.62,
  "end": 10.1
 },
 {
  "input": "The scratch really does affect the 1s and 0s on the disk, so it reads off different data from what was stored, but unless it's really scratched up, the bits it reads off are decoded into precisely the same file that was encoded onto it, a bit for bit copy, despite all those errors. ",
  "translatedText": "آیا تا به حال به این فکر کرده اید که چگونه می توان یک سی دی یا دی وی دی را خراش داد و همچنان هر آنچه را که ذخیره می کند پخش کرد؟ خراش واقعاً روی 1s و 0s روی دیسک تأثیر می‌گذارد، بنابراین داده‌های متفاوتی را از آنچه که ذخیره شده است می‌خواند، اما اگر واقعاً خراشیده نشده باشد، بیت‌هایی که می‌خواند دقیقاً در همان فایلی رمزگشایی می‌شوند که روی آن کدگذاری شده است. با وجود تمام آن خطاها، کپی بیت به بیت. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 10.9,
  "end": 27.44
 },
 {
  "input": "There is a whole pile of mathematical cleverness that allows us to store data, and just as importantly to transmit data, in a way that's resilient to errors. ",
  "translatedText": "انبوهی از هوشمندی ریاضی وجود دارد که به ما امکان می‌دهد داده‌ها را ذخیره کنیم، و مهمتر از همه، داده‌ها را به روشی مقاوم در برابر خطاها منتقل کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 27.44,
  "end": 36.66
 },
 {
  "input": "Well, okay, actually it doesn't take that much cleverness to come up with a way to do this. ",
  "translatedText": "خوب، خوب، در واقع آنقدر هوشمندی لازم نیست تا راهی برای انجام این کار پیدا کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 37.52,
  "end": 41.6
 },
 {
  "input": "Any file, whether it's a video or sound or text, some code, an image, whatever, is ultimately some sequence of 1s and 0s. ",
  "translatedText": "هر فایلی، خواه ویدیو باشد یا صدا یا متن، کد، تصویر، هر چه باشد، در نهایت دنباله ای از 1 و 0 است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 42.06,
  "end": 50.38
 },
 {
  "input": "And a simple strategy to correct any bit that gets flipped would be to store three copies of each bit. ",
  "translatedText": "و یک استراتژی ساده برای تصحیح هر بیتی که برگردانده می شود، ذخیره سه نسخه از هر بیت است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 50.68,
  "end": 56.0
 },
 {
  "input": "Then the machine reading this file could compare these three copies and always take the best 2 out of 3 whenever there's a discrepancy. ",
  "translatedText": "سپس دستگاهی که این فایل را می‌خواند می‌تواند این سه نسخه را با هم مقایسه کند و هر زمان که مغایرتی وجود داشت، همیشه از 3 بهترین 2 را بگیرد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 57.58,
  "end": 64.06
 },
 {
  "input": "But what that means is using two thirds of your space for redundancy. ",
  "translatedText": "اما این به معنای استفاده از دو سوم فضای خود برای افزونگی است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 67.16,
  "end": 70.86
 },
 {
  "input": "And even then, for all of that space given up, there's no strong guarantee about what happens if more than one bit gets flipped. ",
  "translatedText": "و حتی پس از آن، با وجود تمام این فضای خالی، هیچ تضمین قوی در مورد اینکه اگر بیش از یک بیت ورق بخورد چه اتفاقی می افتد وجود ندارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 71.48,
  "end": 77.24
 },
 {
  "input": "The much more interesting question is how to make it so that errors can be corrected while giving up as little space as possible. ",
  "translatedText": "سوال بسیار جالب تر این است که چگونه آن را بسازیم تا بتوان خطاها را تصحیح کرد و در عین حال فضای کمتری را از دست داد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 77.98,
  "end": 84.02
 },
 {
  "input": "For example, using the method you'll learn about this video, you could store your data in 256-bit blocks, where each block uses 9 bits, 9! ",
  "translatedText": "به عنوان مثال، با استفاده از روشی که در مورد این ویدیو خواهید آموخت، می توانید داده های خود را در بلوک های 256 بیتی ذخیره کنید، جایی که هر بلوک از 9 بیت استفاده می کند، 9 بیت! ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 84.52,
  "end": 93.36
 },
 {
  "input": "to act as a kind of redundancy, and the other 247 bits are free to carry whatever meaningful message or data you want. ",
  "translatedText": "به عنوان نوعی افزونگی عمل می کند، و 247 بیت دیگر آزاد هستند تا هر پیام یا داده معناداری را که می خواهید حمل کنند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 93.76,
  "end": 100.3
 },
 {
  "input": "And it will still be the case that if any bit gets flipped here, just by looking at this block and nothing more, a machine will be able to identify that there was an error and precisely where it was so that it knows how to correct it. ",
  "translatedText": "و همچنان اینطور خواهد بود که اگر بیتی در اینجا برگردانده شود، فقط با نگاه کردن به این بلوک و هیچ چیز دیگر، یک ماشین می تواند تشخیص دهد که یک خطا وجود داشته است و دقیقاً کجا بوده است تا بداند چگونه آن را اصلاح کند. . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 100.9,
  "end": 112.66
 },
 {
  "input": "And honestly, that feels like magic. ",
  "translatedText": "و صادقانه بگویم، این یک جادو است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 112.66,
  "end": 114.62
 },
 {
  "input": "And for this particular scheme, if two bits get flipped, the machine will at least be able to detect that there were two errors, though it won't know how to fix them. ",
  "translatedText": "و برای این طرح خاص، اگر دو بیت برگردانده شوند، دستگاه حداقل می‌تواند تشخیص دهد که دو خطا وجود داشته است، اگرچه نمی‌داند چگونه آنها را برطرف کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 115.44,
  "end": 122.86
 },
 {
  "input": "We'll talk a little bit later about how this scales for blocks with different sizes. ",
  "translatedText": "ما کمی بعد در مورد اینکه چگونه این مقیاس برای بلوک های با اندازه های مختلف صحبت خواهیم کرد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 123.52,
  "end": 126.9
 },
 {
  "input": "Methods that let you correct errors like this are known, reasonably enough, as error correction codes. ",
  "translatedText": "روش هایی که به شما امکان می دهند چنین خطاهایی را تصحیح کنید، به اندازه کافی به عنوان کدهای تصحیح خطا شناخته می شوند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 127.86,
  "end": 132.9
 },
 {
  "input": "For the better part of the last century, this field has been a really rich source of surprisingly deep math that gets incorporated into devices we use every day. ",
  "translatedText": "در بخش بهتری از قرن گذشته، این رشته منبع واقعاً غنی از ریاضیات عمیق و شگفت‌آوری بوده است که در دستگاه‌هایی که ما هر روز استفاده می‌کنیم گنجانده می‌شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 133.66,
  "end": 141.94
 },
 {
  "input": "The goal here is to give you a very thorough understanding of one of the earliest examples, known as a Hamming code. ",
  "translatedText": "هدف در اینجا این است که به شما درک کاملی از یکی از اولین نمونه ها، معروف به کد همینگ، بدهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 142.84,
  "end": 148.66
 },
 {
  "input": "And by the way, the way I'm thinking about the structure of this video is less about explaining it as directly as possible, and more a matter of prompting you to invent it for yourself, with a little gentle guidance here and there. ",
  "translatedText": "و اتفاقاً، طرز فکر من در مورد ساختار این ویدیو، کمتر به توضیح مستقیم آن می‌پردازد، و بیشتر این است که شما را ترغیب کند تا آن را برای خودتان اختراع کنید، با کمی راهنمایی ملایم اینجا و آنجا. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 149.52,
  "end": 159.82
 },
 {
  "input": "So when you feel like you see where it's going at some point, take that moment to pause, actively predict what the scheme is going to be before I tell you. ",
  "translatedText": "بنابراین زمانی که احساس می‌کنید می‌بینید در نقطه‌ای به کجا می‌رود، آن لحظه را به مکث اختصاص دهید، قبل از اینکه به شما بگویم، به طور فعال پیش‌بینی کنید که طرح قرار است چگونه باشد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 160.12,
  "end": 166.72
 },
 {
  "input": "Also, if you want your understanding to get down to the hardware level, Ben Eater has made a video in conjunction with this one showing you how to actually implement Hamming codes on breadboards, which is extremely satisfying. ",
  "translatedText": "همچنین، اگر می‌خواهید درک شما به سطح سخت‌افزار برسد، Ben Eater ویدیویی را در ارتباط با این ویدیو تهیه کرده است که به شما نشان می‌دهد چگونه کدهای Hamming را روی تخته‌های پخت پیاده‌سازی کنید، که بسیار رضایت‌بخش است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 167.24,
  "end": 178.24
 },
 {
  "input": "You should know, Hamming codes are not as widely used as more modern codes, like the Reed-Solomon algorithm, but there is a certain magic to the contrast between just how impossible this task feels at the start, and how utterly reasonable it seems once you learn about Hamming. ",
  "translatedText": "باید بدانید، کدهای همینگ به اندازه کدهای مدرن تر مانند الگوریتم Reed-Solomon به طور گسترده مورد استفاده قرار نمی گیرند، اما یک جادوی خاصی در تضاد بین اینکه چقدر این کار در ابتدا غیرممکن به نظر می رسد و زمانی که یک بار کاملاً منطقی به نظر می رسد وجود دارد. شما در مورد Hamming یاد می گیرید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 179.3,
  "end": 193.0
 },
 {
  "input": "The basic principle of error correction is that in a vast space of all possible messages, only some subset are going to be considered valid messages. ",
  "translatedText": "اصل اساسی تصحیح خطا این است که در فضای وسیعی از همه پیام‌های ممکن، فقط برخی از زیر مجموعه‌ها پیام‌های معتبر در نظر گرفته می‌شوند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 193.72,
  "end": 202.18
 },
 {
  "input": "As an analogy, think about correctly spelled words vs incorrectly spelled words. ",
  "translatedText": "به عنوان یک قیاس، به کلماتی که املای صحیح دارند در مقابل کلماتی که املای نادرست دارند فکر کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.8,
  "end": 206.94
 },
 {
  "input": "Whenever a valid message gets altered, the receiver is responsible for correcting what they see back to the nearest valid neighbor, as you might do with a typo. ",
  "translatedText": "هر زمان که یک پیام معتبر تغییر می کند، گیرنده مسئول تصحیح آنچه می بیند به نزدیکترین همسایه معتبر برمی گردد، همانطور که ممکن است با یک اشتباه تایپی انجام دهید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 208.9,
  "end": 217.34
 },
 {
  "input": "Coming up with a concrete algorithm to efficiently categorize messages like this, though, takes a certain cleverness. ",
  "translatedText": "با این حال، ارائه یک الگوریتم مشخص برای دسته‌بندی مؤثر پیام‌هایی مانند این، هوشمندی خاصی را می‌طلبد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 218.22,
  "end": 224.06
 },
 {
  "input": "The story begins in the 1940s, when a young Richard Hamming was working for Bell Labs, and some of his work involved using a very big expensive punch card computer that he had only limited access to. ",
  "translatedText": "داستان در دهه 1940 آغاز می شود، زمانی که ریچارد همینگ جوان برای آزمایشگاه بل کار می کرد و برخی از کارهای او شامل استفاده از یک کامپیوتر کارت پانچ بسیار گران قیمت بود که دسترسی محدودی به آن داشت. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 226.78,
  "end": 237.42
 },
 {
  "input": "And the programs he kept putting through it kept failing, because every now and then a bit would get misread. ",
  "translatedText": "و برنامه‌هایی که او مدام اجرا می‌کرد با شکست مواجه می‌شد، زیرا هرازگاهی مقداری اشتباه خوانده می‌شد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 237.8,
  "end": 242.4
 },
 {
  "input": "Frustration being the crucible of invention, he got so fed up that he invented the world's first error correction code. ",
  "translatedText": "ناامیدی که بوته اختراع بود، آنقدر خسته شد که اولین کد تصحیح خطا در جهان را اختراع کرد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 243.12,
  "end": 248.42
 },
 {
  "input": "There are many different ways to frame Hamming codes, but as a first pass we're going to go through it the way Hamming himself thought about them. ",
  "translatedText": "راه‌های مختلفی برای قاب‌بندی کدهای همینگ وجود دارد، اما به عنوان اولین گذر، همان‌طور که خود همینگ درباره آن‌ها فکر می‌کرد، آن را مرور می‌کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 249.06,
  "end": 255.38
 },
 {
  "input": "Let's use an example that's simple, but not too simple, a block of 16 bits. ",
  "translatedText": "بیایید از یک مثال ساده، اما نه خیلی ساده، یک بلوک 16 بیتی استفاده کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 256.52,
  "end": 260.94
 },
 {
  "input": "We'll number the positions of these bits from 0 up to 15. ",
  "translatedText": "ما موقعیت های این بیت ها را از 0 تا 15 شماره گذاری می کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 261.82,
  "end": 264.74
 },
 {
  "input": "The actual data we want to store is only going to make up 12 of these bits, while 4 of the positions are reserved as a kind of redundancy. ",
  "translatedText": "داده‌های واقعی که می‌خواهیم ذخیره کنیم تنها 12 بیت از این بیت‌ها را تشکیل می‌دهند، در حالی که 4 مورد از موقعیت‌ها به عنوان نوعی افزونگی رزرو شده‌اند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 265.62,
  "end": 273.0
 },
 {
  "input": "The word redundant here doesn't simply mean copy, after all, those 4 bits don't give us enough room to blindly copy the data. ",
  "translatedText": "کلمه زاید در اینجا به سادگی به معنای کپی نیست، بالاخره آن 4 بیت فضای کافی برای کپی کورکورانه داده ها را به ما نمی دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 273.9,
  "end": 280.04
 },
 {
  "input": "Instead, they'll need to be a much more nuanced and clever kind of redundancy, not adding any new information, but adding resilience. ",
  "translatedText": "در عوض، آنها باید یک نوع افزونگی بسیار ظریف‌تر و هوشمندانه‌تر باشند، نه اطلاعات جدیدی، بلکه انعطاف‌پذیری را اضافه کنند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 280.72,
  "end": 287.28
 },
 {
  "input": "You might expect these 4 special bits to come nicely packaged together, maybe at the end or something like that, but as you'll see, having them sit in positions which are powers of 2 allows for something that's really elegant by the end. ",
  "translatedText": "ممکن است انتظار داشته باشید که این 4 بیت خاص به خوبی در کنار هم قرار گیرند، شاید در انتها یا چیزی شبیه به آن، اما همانطور که خواهید دید، نشستن آنها در موقعیت هایی که توان 2 هستند، امکان چیزی را فراهم می کند که در پایان واقعاً زیبا باشد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 288.6,
  "end": 299.62
 },
 {
  "input": "It also might give you a little hint about how this scales for larger blocks. ",
  "translatedText": "همچنین ممکن است به شما راهنمایی کوچکی در مورد اینکه چگونه این مقیاس برای بلوک‌های بزرگ‌تر انجام می‌شود، به شما بدهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 300.2,
  "end": 303.54
 },
 {
  "input": "Also technically it ends up being only 11 bits of data, you'll find there's a mild nuance for what goes on at position 0, but don't worry about that for now. ",
  "translatedText": "همچنین از نظر فنی تنها 11 بیت داده است، متوجه خواهید شد که تفاوت جزئی برای آنچه در موقعیت 0 می‌گذرد وجود دارد، اما فعلاً نگران آن نباشید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 304.9,
  "end": 313.26
 },
 {
  "input": "Like any error correction algorithm, this will involve two players, a sender who's responsible for setting these 4 special bits, and a receiver who's responsible for performing some kind of check and correcting the errors. ",
  "translatedText": "مانند هر الگوریتم تصحیح خطا، این شامل دو بازیکن است، یک فرستنده که مسئول تنظیم این 4 بیت ویژه است و یک گیرنده که مسئول انجام نوعی بررسی و تصحیح خطاها است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 314.14,
  "end": 325.54
 },
 {
  "input": "Of course, the words sender and receiver really refer to machines or software that's doing all the checks, and the idea of a message is meant really broadly, to include things like storage. ",
  "translatedText": "البته، واژه‌های فرستنده و گیرنده واقعاً به ماشین‌ها یا نرم‌افزارهایی اشاره می‌کنند که همه بررسی‌ها را انجام می‌دهند، و ایده یک پیام واقعاً به طور گسترده به معنای شامل مواردی مانند ذخیره‌سازی است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 326.3,
  "end": 334.74
 },
 {
  "input": "After all, storing data is the same thing as sending a message just from the past to the future instead of from one place to another. ",
  "translatedText": "پس از همه، ذخیره داده ها همان چیزی است که پیامی را فقط از گذشته به آینده به جای ارسال از یک مکان به مکان دیگر ارسال کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 335.34,
  "end": 341.68
 },
 {
  "input": "So that's the setup, but before we can dive in we need to talk about a related idea which was fresh on Hamming's mind in the time of his discovery, a method which lets you detect any single bit errors, but not to correct them, known in the business as a parity check. ",
  "translatedText": "بنابراین این تنظیمات است، اما قبل از اینکه بتوانیم وارد آن شویم، باید در مورد یک ایده مرتبط صحبت کنیم که در زمان کشف همینگ در ذهن او تازه بود، روشی که به شما امکان می‌دهد خطاهای تک بیتی را تشخیص دهید، اما آنها را اصلاح نکنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 342.56,
  "end": 356.3
 },
 {
  "input": "For a parity check, we separate out only one single bit that the sender is responsible for tuning, and the rest are free to carry a message. ",
  "translatedText": "در تجارت به عنوان چک برابری برای بررسی برابری، ما تنها یک بیت را که فرستنده مسئول تنظیم آن است، جدا می کنیم و بقیه برای حمل پیام آزاد هستند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 356.88,
  "end": 363.82
 },
 {
  "input": "The only job of this special bit is to make sure that the total number of 1s in the message is an even number. ",
  "translatedText": "تنها کار این بیت ویژه این است که مطمئن شود مجموع 1 های پیام یک عدد زوج است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 364.88,
  "end": 371.28
 },
 {
  "input": "So for example right now, that total number of 1s is 7, that's odd, so the sender needs to flip that special bit to be a 1, making the count even. ",
  "translatedText": "بنابراین برای مثال در حال حاضر، تعداد کل 1ها 7 است، که فرد است، بنابراین فرستنده باید آن بیت خاص را برگرداند تا عدد 1 باشد و تعداد را زوج کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 372.08,
  "end": 379.96
 },
 {
  "input": "But if the block had already started off with an even number of 1s, then this special bit would have been kept at a 0. ",
  "translatedText": "اما اگر بلوک قبلاً با عدد زوج 1 شروع شده بود، این بیت ویژه روی 0 نگه داشته می شد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 380.8,
  "end": 386.42
 },
 {
  "input": "This is pretty simple, deceptively simple, but it's an incredibly elegant way to distill the idea of change anywhere in a message to be reflected in a single bit of information. ",
  "translatedText": "این بسیار ساده، به طرز فریبنده ای ساده است، اما روشی فوق العاده زیبا برای تقطیر ایده تغییر در هر جایی از پیام است تا در یک بیت اطلاعات منعکس شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 387.34,
  "end": 396.78
 },
 {
  "input": "Notice if any bit of this message gets flipped, either from 0 to 1 or 1 to 0, it changes the total count of 1s from being even to being odd. ",
  "translatedText": "توجه کنید که اگر هر بیتی از این پیام از 0 به 1 یا 1 به 0 برگردانده شود، تعداد کل 1 ها را از زوج به فرد تغییر می دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 397.5,
  "end": 406.54
 },
 {
  "input": "So if you're the receiver, you look at this message, and you see an odd number of 1s, you can know for sure that some error has occurred, even though you might have no idea where it was. ",
  "translatedText": "بنابراین اگر شما گیرنده هستید، به این پیام نگاه می کنید و عدد فرد 1 را می بینید، می توانید مطمئن باشید که برخی از خطاها رخ داده است، حتی اگر نمی دانید کجا بوده است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 407.98,
  "end": 417.46
 },
 {
  "input": "In the jargon, whether a group of bits has an even or odd number of 1s is known as its parity. ",
  "translatedText": "در اصطلاح، اینکه گروهی از بیت ها دارای عدد زوج یا فرد 1 باشند، به عنوان برابری آن شناخته می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 418.5,
  "end": 423.34
 },
 {
  "input": "You could also use numbers and say the parity is 0 or 1, which is typically more helpful once you start doing math with the idea. ",
  "translatedText": "همچنین می توانید از اعداد استفاده کنید و بگویید که برابری 0 یا 1 است، که معمولاً زمانی که شروع به انجام ریاضیات با این ایده می کنید مفیدتر است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 424.86,
  "end": 430.72
 },
 {
  "input": "And this special bit that the sender uses to control the parity is called the parity bit. ",
  "translatedText": "و این بیت ویژه ای که فرستنده برای کنترل برابری استفاده می کند بیت برابری نامیده می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 431.22,
  "end": 435.52
 },
 {
  "input": "And actually, we should be clear, if the receiver sees an odd parity, it doesn't necessarily mean there was just one error, there might have been 3 errors, or 5, or any other odd number, but they can know for sure that it wasn't 0. ",
  "translatedText": "و در واقع، ما باید روشن باشیم، اگر گیرنده برابری فرد را ببیند، لزوماً به این معنی نیست که فقط یک خطا وجود داشته است، ممکن است 3 خطا، یا 5، یا هر عدد فرد دیگری وجود داشته باشد، اما آنها می توانند با اطمینان بدانند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 437.56,
  "end": 449.26
 },
 {
  "input": "On the other hand, if there had been 2 errors, or any even number of errors, that final count of 1s would still be even, so the receiver can't have full confidence that an even count necessarily means the message is error-free. ",
  "translatedText": "که 0 نبود از سوی دیگر، اگر 2 خطا یا هر تعداد زوج خطا وجود داشته باشد، آن شمارش نهایی 1 ها همچنان زوج خواهد بود، بنابراین گیرنده نمی تواند اطمینان کامل داشته باشد که شمارش زوج لزوماً به این معنی است که پیام بدون خطا است. . ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 449.98,
  "end": 462.3
 },
 {
  "input": "You might complain that a message which gets messed up by only 2 bit flips is pretty weak, and you would be absolutely right. ",
  "translatedText": "ممکن است شکایت کنید که پیامی که تنها با 2 بیت ورق می خورد بسیار ضعیف است و کاملاً درست می گویید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 462.84,
  "end": 469.08
 },
 {
  "input": "Keep in mind, though, there is no method for error detection or correction that could give you 100% confidence that the message you receive is the one the sender intended. ",
  "translatedText": "به خاطر داشته باشید، هرچند، هیچ روشی برای تشخیص یا تصحیح خطا وجود ندارد که به شما اطمینان 100٪ بدهد که پیامی که دریافت می‌کنید همان پیامی است که فرستنده در نظر گرفته است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 469.7,
  "end": 478.9
 },
 {
  "input": "After all, enough random noise could always change one valid message into another valid message just by pure chance. ",
  "translatedText": "به هر حال، نویز تصادفی کافی همیشه می تواند یک پیام معتبر را به یک پیام معتبر دیگر فقط به طور تصادفی تغییر دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 479.58,
  "end": 485.44
 },
 {
  "input": "Instead, the goal is to come up with a scheme that's robust up to a certain maximum number of errors, or maybe to reduce the probability of a false positive like this. ",
  "translatedText": "در عوض، هدف ارائه طرحی است که تا حداکثر تعداد معینی از خطاها قوی باشد، یا شاید کاهش احتمال مثبت کاذب مانند این. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 486.24,
  "end": 495.38
 },
 {
  "input": "Parity checks on their own are pretty weak, but by distilling the idea of change across a full message down to a single bit, what they give us is a powerful building block for more sophisticated schemes. ",
  "translatedText": "بررسی‌های برابری به خودی خود بسیار ضعیف هستند، اما با تقطیر ایده تغییر در یک پیام کامل تا یک بیت، چیزی که به ما می‌دهند یک بلوک ساختمانی قدرتمند برای طرح‌های پیچیده‌تر است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 496.26,
  "end": 507.16
 },
 {
  "input": "For example, as Hamming was searching for a way to identify where an error happened, not just that it happened, his key insight was that if you apply some parity checks not to the full message, but to certain carefully selected subsets, you can ask a more refined series of questions that pin down the location of any single bit error. ",
  "translatedText": "به عنوان مثال، وقتی همینگ به دنبال راهی برای شناسایی محل وقوع یک خطا بود، نه فقط اینکه خطا رخ داده است، دیدگاه کلیدی او این بود که اگر برخی از بررسی‌های برابری را نه برای پیام کامل، بلکه برای زیر مجموعه‌هایی که با دقت انتخاب شده‌اند اعمال کنید، می‌توانید بپرسید. مجموعه‌ای دقیق‌تر از سوالات که محل هر خطای بیتی را مشخص می‌کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 507.94,
  "end": 525.94
 },
 {
  "input": "The overall feeling is a bit like playing a game of 20 questions, asking yes or no queries that chop the space of possibilities in half. ",
  "translatedText": "احساس کلی کمی شبیه انجام یک بازی 20 سوالی است، پرسیدن سوالات بله یا خیر که فضای احتمالات را نصف می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 526.68,
  "end": 533.38
 },
 {
  "input": "For example, let's say we do a parity check just on these 8 bits, all of the odd numbered positions. ",
  "translatedText": "به عنوان مثال، فرض کنید ما فقط روی این 8 بیت، همه موقعیت‌های اعداد فرد، یک بررسی برابری انجام می‌دهیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 534.16,
  "end": 539.38
 },
 {
  "input": "Then if an error is detected, it gives the receiver a little more information about where specifically the error is, namely that it's in an odd position. ",
  "translatedText": "سپس اگر خطایی تشخیص داده شود، اطلاعات کمی بیشتر در مورد اینکه خطا دقیقاً کجاست، به گیرنده می دهد، یعنی اینکه در موقعیتی عجیب و غریب است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 540.1,
  "end": 548.24
 },
 {
  "input": "If no error is detected among those 8 bits, it either means there's no error at all, or it sits somewhere in the even positions. ",
  "translatedText": "اگر هیچ خطایی در بین آن 8 بیت تشخیص داده نشد، به این معنی است که اصلا خطایی وجود ندارد، یا جایی در موقعیت های زوج قرار می گیرد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 548.94,
  "end": 556.24
 },
 {
  "input": "You might think that limiting a parity check to half the bits makes it less effective, but when it's done in conjunction with other well-chosen checks, it counterintuitively gives us something a lot more powerful. ",
  "translatedText": "ممکن است فکر کنید که محدود کردن یک بررسی برابری به نیمی از بیت‌ها باعث می‌شود که کارایی آن کمتر شود، اما زمانی که آن را همراه با سایر چک‌های به‌خوبی انتخاب‌شده انجام می‌دهد، به طور غیرمستقیم چیزی بسیار قدرتمندتر به ما می‌دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 557.18,
  "end": 567.2
 },
 {
  "input": "To actually set up that parity check, remember, it requires earmarking some special bit that has control for the parity of that full group. ",
  "translatedText": "برای راه‌اندازی آن بررسی برابری، به یاد داشته باشید، نیاز به تخصیص بیت خاصی دارد که کنترل برابری آن گروه کامل را دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 569.24,
  "end": 576.62
 },
 {
  "input": "Here let's just choose position 1. ",
  "translatedText": "در اینجا بیایید فقط موقعیت 1 را انتخاب کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 577.48,
  "end": 579.18
 },
 {
  "input": "For the example shown, the parity of these 8 bits is currently odd, so the sender is responsible for toggling that parity bit, and now it's even. ",
  "translatedText": "برای مثال نشان داده شده، برابری این 8 بیت در حال حاضر فرد است، بنابراین فرستنده مسئول تغییر بیت برابری است، و اکنون آن زوج است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 579.72,
  "end": 586.98
 },
 {
  "input": "This is only 1 out of 4 parity checks that we'll do. ",
  "translatedText": "این تنها 1 مورد از 4 بررسی برابری است که ما انجام خواهیم داد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 587.94,
  "end": 590.68
 },
 {
  "input": "The second check is among the 8 bits on the right half of the grid, at least as we've drawn it here. ",
  "translatedText": "بررسی دوم در میان 8 بیت در نیمه سمت راست شبکه است، حداقل همانطور که ما آن را در اینجا ترسیم کردیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 590.92,
  "end": 596.3
 },
 {
  "input": "This time we might use position 2 as a parity bit, so these 8 bits already have an even parity, and the sender can feel good leaving that bit number 2 unchanged. ",
  "translatedText": "این بار ممکن است از موقعیت 2 به عنوان بیت برابری استفاده کنیم، بنابراین این 8 بیت از قبل دارای برابری زوج هستند و فرستنده می تواند احساس خوبی داشته باشد که بیت شماره 2 را بدون تغییر باقی بگذارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 596.68,
  "end": 606.06
 },
 {
  "input": "Then on the other end, if the receiver checks the parity of this group and they find that it's odd, they'll know that the error is somewhere among these 8 bits on the right. ",
  "translatedText": "سپس از طرف دیگر، اگر گیرنده برابری این گروه را بررسی کند و متوجه شود که عجیب و غریب است، می‌دانند که خطا جایی در بین این 8 بیت سمت راست است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 607.02,
  "end": 615.38
 },
 {
  "input": "Otherwise it means either there's no error, or the error is somewhere on the left half. ",
  "translatedText": "در غیر این صورت به این معنی است که یا خطایی وجود ندارد، یا خطا جایی در نیمه چپ است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 615.82,
  "end": 620.58
 },
 {
  "input": "Or I guess there could have been two errors, but for right now we're going to assume that there's at most one error in the entire block. ",
  "translatedText": "یا حدس می‌زنم ممکن است دو خطا وجود داشته باشد، اما فعلاً فرض می‌کنیم که حداکثر یک خطا در کل بلوک وجود دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 621.12,
  "end": 626.5
 },
 {
  "input": "Things break down completely for more than that. ",
  "translatedText": "همه چیز برای بیش از این به طور کامل خراب می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 626.94,
  "end": 628.74
 },
 {
  "input": "Here, before we look at the next two checks, take a moment to think about what these first two allow us to do when you consider them together. ",
  "translatedText": "در اینجا، قبل از اینکه به دو بررسی بعدی نگاه کنیم، لحظه ای به این فکر کنید که این دو مورد اول وقتی آنها را با هم در نظر می گیریم به ما اجازه می دهند چه کار کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 629.16,
  "end": 635.1
 },
 {
  "input": "Let's say you detect an error among the odd columns, and among the right half. ",
  "translatedText": "فرض کنید در بین ستون های فرد و در نیمه سمت راست خطایی را تشخیص داده اید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 635.8,
  "end": 639.66
 },
 {
  "input": "It necessarily means the error is somewhere in the last column. ",
  "translatedText": "لزوماً به این معنی است که خطا جایی در آخرین ستون است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 640.2,
  "end": 643.04
 },
 {
  "input": "If there was no error in the odd column but there was one in the right half, that tells you it's in the second to last column. ",
  "translatedText": "اگر در ستون فرد خطایی وجود نداشت اما در نیمه سمت راست خطایی وجود داشت، به شما می گوید که در ستون دوم تا آخر است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 643.82,
  "end": 649.7
 },
 {
  "input": "Likewise if there is an error in the odd columns but not in the right half, you know it's somewhere in the second column. ",
  "translatedText": "به همین ترتیب اگر خطایی در ستون های فرد وجود داشته باشد اما در نیمه سمت راست خطایی وجود نداشته باشد، می دانید که در جایی در ستون دوم است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 650.44,
  "end": 656.02
 },
 {
  "input": "And if neither of those two parity checks detects anything, it means the only place that an error could be is in that leftmost column. ",
  "translatedText": "و اگر هیچ یک از این دو بررسی برابری چیزی را شناسایی نکرد، به این معنی است که تنها جایی که ممکن است خطا باشد در همان ستون سمت چپ است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 656.02,
  "end": 663.12
 },
 {
  "input": "But it also might simply mean there's no error at all. ",
  "translatedText": "اما همچنین ممکن است به این معنی باشد که اصلا خطایی وجود ندارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 663.34,
  "end": 666.12
 },
 {
  "input": "Which is all a rather belabored way to say that two parity checks let us pin down the column. ",
  "translatedText": "که همگی روشی نسبتاً پیچیده برای گفتن این است که دو بررسی برابری به ما امکان می دهد ستون را مشخص کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.3,
  "end": 670.84
 },
 {
  "input": "From here, you can probably guess what follows. ",
  "translatedText": "از اینجا، احتمالاً می توانید حدس بزنید که چه چیزی در ادامه می آید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 671.48,
  "end": 673.64
 },
 {
  "input": "We do basically the same thing but for the rows. ",
  "translatedText": "ما اساساً همان کار را انجام می دهیم اما برای ردیف ها. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 673.8,
  "end": 676.14
 },
 {
  "input": "There's going to be a parity check on the odd rows, using position 4 as a parity bit. ",
  "translatedText": "با استفاده از موقعیت 4 به عنوان بیت برابری، یک بررسی برابری روی ردیف های فرد انجام می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 676.44,
  "end": 680.9
 },
 {
  "input": "So in this example that group already has an even parity, so bit 4 would be set to a 0. ",
  "translatedText": "بنابراین در این مثال آن گروه از قبل دارای برابری زوج است، بنابراین بیت 4 روی 0 تنظیم می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 681.38,
  "end": 685.82
 },
 {
  "input": "And finally there's a parity check on the bottom two rows, using position 8 as a parity bit. ",
  "translatedText": "و در نهایت یک بررسی برابری در دو ردیف پایین، با استفاده از موقعیت 8 به عنوان بیت برابری وجود دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 686.56,
  "end": 691.58
 },
 {
  "input": "In this case, it looks like the sender needs to turn that bit 8 on in order to give the group even parity. ",
  "translatedText": "در این حالت، به نظر می رسد که فرستنده باید آن بیت 8 را روشن کند تا به گروه برابری یکنواخت بدهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 692.12,
  "end": 696.82
 },
 {
  "input": "Just as the first two checks let us pin down the column, these next two let you pin down the row. ",
  "translatedText": "همانطور که دو چک اول به ما اجازه می دهد ستون را مشخص کنیم، این دو بررسی بعدی نیز به شما امکان می دهد ردیف را پین کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 697.7,
  "end": 701.84
 },
 {
  "input": "As an example, imagine that during the transmission there's an error at, say, position 3. ",
  "translatedText": "به عنوان مثال، تصور کنید که در حین انتقال، مثلاً در موقعیت 3 خطایی وجود دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 702.88,
  "end": 707.54
 },
 {
  "input": "Well this affects the first parity group, and it also affects the second parity group, so the receiver knows that there's an error somewhere in that right column. ",
  "translatedText": "خوب این روی گروه برابری اول تأثیر می گذارد، و همچنین روی گروه برابری دوم تأثیر می گذارد، بنابراین گیرنده می داند که در جایی در ستون سمت راست خطایی وجود دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 708.18,
  "end": 715.56
 },
 {
  "input": "But it doesn't affect the third group, and it doesn't affect the fourth group. ",
  "translatedText": "اما گروه سوم را تحت تاثیر قرار نمی دهد و گروه چهارم را تحت تاثیر قرار نمی دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 716.1,
  "end": 720.54
 },
 {
  "input": "And that lets the receiver pinpoint the error up to the first row, which necessarily means position 3, so they can fix the error. ",
  "translatedText": "و این به گیرنده اجازه می دهد تا خطا را تا ردیف اول مشخص کند، که لزوماً به معنای موقعیت 3 است، بنابراین آنها می توانند خطا را برطرف کنند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 721.24,
  "end": 727.52
 },
 {
  "input": "You might enjoy taking a moment to convince yourself that the answers to these four questions really will always let you pin down a specific location, no matter where they turn out to be. ",
  "translatedText": "ممکن است از صرف لحظه ای لذت ببرید و خود را متقاعد کنید که پاسخ به این چهار سوال واقعاً همیشه به شما امکان می دهد مکان خاصی را مشخص کنید، مهم نیست که کجا هستند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 728.58,
  "end": 737.1
 },
 {
  "input": "In fact, the astute among you might even notice a connection between these questions and binary counting. ",
  "translatedText": "در واقع، افراد زیرک در میان شما ممکن است حتی متوجه ارتباط بین این سوالات و شمارش دودویی شوند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 737.72,
  "end": 743.06
 },
 {
  "input": "And if you do, again let me emphasize, pause, try for yourself to draw the connection before I spoil it. ",
  "translatedText": "و اگر این کار را کردید، مجدداً اجازه دهید تأکید کنم، مکث کنید، خودتان سعی کنید قبل از اینکه من آن را خراب کنم، ارتباط را ترسیم کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 743.5,
  "end": 748.92
 },
 {
  "input": "If you're wondering what happens if a parity bit itself gets affected, well, you can just try it. ",
  "translatedText": "اگر از خود می‌پرسید که چه اتفاقی می‌افتد اگر خود بیت برابری تحت تأثیر قرار گیرد، خوب، می‌توانید آن را امتحان کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 750.5,
  "end": 756.06
 },
 {
  "input": "Take a moment to think about how any error among these four special bits is going to be tracked down just like any other, with the same group of four questions. ",
  "translatedText": "لحظه ای به این فکر کنید که چگونه هر خطایی در بین این چهار بیت خاص، دقیقاً با همان گروه چهار سؤالی، ردیابی می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 756.44,
  "end": 764.18
 },
 {
  "input": "It doesn't really matter, since at the end of the day what we want is to protect the message bits, the error correction bits are just riding along. ",
  "translatedText": "این واقعاً مهم نیست، زیرا در پایان روز چیزی که ما می‌خواهیم محافظت از بیت‌های پیام است، بیت‌های تصحیح خطا در حال حرکت هستند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 767.06,
  "end": 773.1
 },
 {
  "input": "But protecting those bits as well is something that naturally falls out of the scheme as a byproduct. ",
  "translatedText": "اما محافظت از آن بیت ها نیز چیزی است که به طور طبیعی به عنوان یک محصول جانبی از این طرح خارج می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 773.6,
  "end": 777.82
 },
 {
  "input": "You might also enjoy anticipating how this scales. ",
  "translatedText": "همچنین ممکن است از پیش بینی چگونگی این مقیاس لذت ببرید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 779.2,
  "end": 781.76
 },
 {
  "input": "If we used a block of size 256 bits, for example, in order to pin down a location, you need only eight yes or no questions to binary search your way down to some specific spot. ",
  "translatedText": "اگر از یک بلوک با اندازه 256 بیت استفاده کنیم، برای مثال، برای مشخص کردن یک مکان، شما فقط به هشت سوال بله یا خیر نیاز دارید تا مسیر خود را به صورت دودویی در یک نقطه خاص جستجو کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 782.3,
  "end": 792.78
 },
 {
  "input": "And remember, each question requires giving up only a single bit to set the appropriate parity check. ",
  "translatedText": "و به یاد داشته باشید، برای هر سوال فقط یک بیت برای تنظیم بررسی برابری مناسب لازم است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 795.64,
  "end": 800.5
 },
 {
  "input": "Some of you may already see it, but we'll talk later about the systematic way to find what these questions are in just a minute or two. ",
  "translatedText": "ممکن است برخی از شما قبلاً آن را دیده باشید، اما ما بعداً در مورد روش سیستماتیک برای یافتن این سؤالات تنها در یک یا دو دقیقه صحبت خواهیم کرد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 803.16,
  "end": 809.36
 },
 {
  "input": "Hopefully this sketch is enough to appreciate the efficiency of what we're developing here. ",
  "translatedText": "امیدواریم این طرح برای قدردانی از کارایی آنچه در اینجا در حال توسعه هستیم کافی باشد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 809.88,
  "end": 813.66
 },
 {
  "input": "The first thing, except for those eight highlighted parity bits, can be whatever you want it to be, carrying whatever message or data you want. ",
  "translatedText": "اولین چیز، به جز آن هشت بیت برابری برجسته، می‌تواند هر چیزی باشد که می‌خواهید باشد و هر پیام یا داده‌ای را که می‌خواهید حمل کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 813.66,
  "end": 821.0
 },
 {
  "input": "The 8 bits are redundant in the sense that they're completely determined by the rest of the message, but it's in a much smarter way than simply copying the message as a whole. ",
  "translatedText": "8 بیت زائد هستند به این معنا که به طور کامل توسط بقیه پیام تعیین می شوند، اما به روشی بسیار هوشمندانه تر از کپی کردن پیام به عنوان یک کل است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 821.72,
  "end": 830.02
 },
 {
  "input": "And still, for so little given up, you would be able to identify and fix any single bit error. ",
  "translatedText": "و با این حال، برای تسلیم شدن بسیار اندک، می‌توانید هر خطای تک بیتی را شناسایی و برطرف کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 833.6,
  "end": 838.38
 },
 {
  "input": "Well, almost. ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 839.2,
  "end": 840.4
 },
 {
  "input": "Okay, so the one problem here is that if none of the four parity checks detect an error, meaning that the specially selected subsets of 8 bits all have even parities, just like the sender intended, then it either means there was no error at all, or it narrows us down into position 0. ",
  "translatedText": "خب تقریبا بسیار خوب، بنابراین یک مشکل اینجاست که اگر هیچ یک از چهار بررسی برابری خطایی را شناسایی نکرد، به این معنی که زیرمجموعه های انتخاب شده ویژه 8 بیت، همگی دارای برابری زوج هستند، دقیقاً همانطور که فرستنده در نظر گرفته است، یا به این معنی است که اصلا خطایی وجود نداشته است. ، یا ما را به موقعیت 0 محدود می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 840.96,
  "end": 856.86
 },
 {
  "input": "You see, with four yes or no questions, we have 16 possible outcomes for our parity checks, and at first that feels perfect for pinpointing 1 out of 16 positions in the block, but you also need to communicate a 17th outcome, the no error condition. ",
  "translatedText": "ببینید، با چهار سوال بله یا خیر، ما 16 نتیجه ممکن برای بررسی برابری خود داریم، و در ابتدا برای مشخص کردن 1 از 16 موقعیت در بلوک عالی به نظر می رسد، اما شما همچنین باید یک نتیجه هفدهم، یعنی خطای بدون، را اعلام کنید. وضعیت. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 857.74,
  "end": 871.9
 },
 {
  "input": "The solution here is actually pretty simple, just forget about that 0th bit entirely. ",
  "translatedText": "راه حل در اینجا در واقع بسیار ساده است، فقط آن بیت 0 را به طور کامل فراموش کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 873.02,
  "end": 877.3
 },
 {
  "input": "So when we do our four parity checks and we see that they're all even, it unambiguously means that there is no error. ",
  "translatedText": "بنابراین وقتی ما چهار بررسی برابری خود را انجام می دهیم و می بینیم که همه آنها یکسان هستند، بدون ابهام به این معنی است که هیچ خطایی وجود ندارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 877.84,
  "end": 883.46
 },
 {
  "input": "What that means is rather than working with a 16-bit block, we work with a 15-bit block, where 11 of the bits are free to carry a message and 4 of them are there for redundancy. ",
  "translatedText": "این بدان معناست که به جای کار با یک بلوک 16 بیتی، ما با یک بلوک 15 بیتی کار می کنیم، که در آن 11 بیت برای حمل پیام آزاد هستند و 4 تا از آنها برای افزونگی وجود دارد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 884.24,
  "end": 893.22
 },
 {
  "input": "And with that, we now have what people in the business would refer to as a 15-11 Hamming code. ",
  "translatedText": "و با آن، ما اکنون چیزی را داریم که افراد در کسب و کار به عنوان کد 15-11 Hamming از آن یاد می کنند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 893.78,
  "end": 898.8
 },
 {
  "input": "That said, it's nice to have a block size that's a clean power of 2, and there's a clever way we can keep that 0th bit around and get it to do a little extra work for us. ",
  "translatedText": "با این اوصاف، داشتن اندازه بلوک با توان تمیز 2 خوب است، و یک راه هوشمندانه وجود دارد که بتوانیم آن بیت 0 را در اطراف نگه داریم و کاری کنیم که کمی کار اضافی برای ما انجام دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 899.86,
  "end": 908.14
 },
 {
  "input": "If we use it as a parity bit across the whole block, it lets us actually detect, even though we can't correct, 2-bit errors. ",
  "translatedText": "اگر از آن به‌عنوان بیت برابری در کل بلوک استفاده کنیم، به ما امکان می‌دهد در واقع خطاهای ۲ بیتی را تشخیص دهیم، حتی اگر نمی‌توانیم آن‌ها را اصلاح کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 908.7,
  "end": 915.54
 },
 {
  "input": "Here's how it works. ",
  "translatedText": "در اینجا نحوه عملکرد آن آمده است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 916.16,
  "end": 916.82
 },
 {
  "input": "After setting those four special error-correcting bits, we set that 0th one so that the parity of the full block is even, just like a normal parity check. ",
  "translatedText": "پس از تنظیم آن چهار بیت ویژه تصحیح خطا، آن 0 را طوری تنظیم می کنیم که برابری بلوک کامل برابر باشد، درست مانند یک بررسی برابری معمولی. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 917.18,
  "end": 924.94
 },
 {
  "input": "Now, if there's a single bit error, then the parity of the full block toggles to be odd, but we would catch that anyway thanks to the four error-correcting checks. ",
  "translatedText": "اکنون، اگر یک خطای تک بیتی وجود داشته باشد، برابری بلوک کامل به صورت عجیب و غریب تغییر می کند، اما به هر حال به لطف چهار بررسی تصحیح خطا، آن را دریافت می کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 925.7,
  "end": 933.6
 },
 {
  "input": "However, if there's two errors, then the overall parity is going to toggle back to being even, but the receiver would still see that there's been at least some error because of what's going on with those four parity checks. ",
  "translatedText": "با این حال، اگر دو خطا وجود داشته باشد، برابری کلی به یکنواخت شدن برمی‌گردد، اما گیرنده همچنان می‌بیند که حداقل مقداری خطا وجود داشته است، زیرا در آن چهار بررسی برابری اتفاق می‌افتد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 934.16,
  "end": 945.18
 },
 {
  "input": "So if they notice an even parity overall, but something non-zero happening with the other checks, it tells them there were at least two errors. ",
  "translatedText": "بنابراین اگر در کل متوجه برابری یکنواخت شوند، اما اتفاقی غیر صفر در بررسی‌های دیگر رخ دهد، به آنها می‌گوید حداقل دو خطا وجود داشته است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 945.18,
  "end": 952.7
 },
 {
  "input": "Isn't that clever? ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.52,
  "end": 954.0
 },
 {
  "input": "Even though we can't correct those 2-bit errors, just by putting that one little bothersome 0th bit back to work, it lets us detect them. ",
  "translatedText": "این هوشمندانه نیست؟ حتی اگر نمی‌توانیم آن خطاهای 2 بیتی را اصلاح کنیم، فقط با برگرداندن آن یک بیت 0 آزاردهنده کوچک، به ما امکان می‌دهد آنها را شناسایی کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 954.3,
  "end": 961.26
 },
 {
  "input": "This is pretty standard, it's known as an extended Hamming code. ",
  "translatedText": "این بسیار استاندارد است، آن را به عنوان یک کد Hamming توسعه یافته شناخته می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.26,
  "end": 965.22
 },
 {
  "input": "Technically speaking, you now have a full description of what a Hamming code does, at least for the example of a 16-bit block. ",
  "translatedText": "از نظر فنی، اکنون شرح کاملی از کاری که یک کد Hamming انجام می دهد، حداقل برای مثال یک بلوک 16 بیتی، دارید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 966.54,
  "end": 972.88
 },
 {
  "input": "But I think you'll find it more satisfying to check your understanding and solidify everything up to this point by doing one full example from start to finish yourself. ",
  "translatedText": "اما فکر می‌کنم با انجام یک مثال کامل از ابتدا تا انتها، بررسی درک خود و استحکام بخشیدن به همه چیز تا این مرحله، رضایت‌بخش‌تر خواهد بود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 972.88,
  "end": 981.32
 },
 {
  "input": "I'll step through it with you though so you can check yourself. ",
  "translatedText": "من آن را با شما انجام خواهم داد تا بتوانید خودتان را بررسی کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 982.08,
  "end": 984.3
 },
 {
  "input": "To set up a message, whether that's a literal message you're translating over space or some data you want to store over time, the first step is to divide it up into 11-bit chunks. ",
  "translatedText": "برای تنظیم یک پیام، خواه یک پیام تحت اللفظی باشد که در فضا ترجمه می‌کنید یا برخی از داده‌هایی که می‌خواهید در طول زمان ذخیره کنید، اولین قدم این است که آن را به تکه‌های 11 بیتی تقسیم کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 985.12,
  "end": 994.66
 },
 {
  "input": "Each chunk is going to get packaged into an error-resistant 16-bit block. ",
  "translatedText": "هر قطعه در یک بلوک 16 بیتی مقاوم در برابر خطا بسته بندی می شود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 995.58,
  "end": 999.76
 },
 {
  "input": "So let's take this one as an example and actually work it out. ",
  "translatedText": "بنابراین بیایید این مورد را به عنوان مثال در نظر بگیریم و در واقع آن را حل کنیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 999.76,
  "end": 1003.22
 },
 {
  "input": "Go ahead, actually do it! ",
  "translatedText": "برو، در واقع این کار را انجام بده! ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1003.74,
  "end": 1004.94
 },
 {
  "input": "Let's pause and try putting together this block. ",
  "translatedText": "بیایید مکث کنیم و سعی کنیم این بلوک را کنار هم قرار دهیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1005.22,
  "end": 1007.02
 },
 {
  "input": "Okay, you ready? ",
  "translatedText": "",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1012.72,
  "end": 1013.68
 },
 {
  "input": "Remember, position 0 along with the other powers of 2 are reserved for error correction duty, so you start by placing the message bits in all of the remaining spots, in order. ",
  "translatedText": "باشه، آماده ای؟ به یاد داشته باشید، موقعیت 0 به همراه سایر توان های 2 برای وظیفه تصحیح خطا محفوظ است، بنابراین شما با قرار دادن بیت های پیام در تمام نقاط باقی مانده به ترتیب شروع می کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1014.24,
  "end": 1023.32
 },
 {
  "input": "You need this group to have an even parity, which it already does, so you should have set that parity bit in position 1 to be a 0. ",
  "translatedText": "شما به این گروه نیاز دارید که یک برابری زوج داشته باشد، که قبلاً هم دارد، بنابراین باید آن بیت برابری را در موقعیت 1 روی 0 قرار دهید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1025.34,
  "end": 1032.34
 },
 {
  "input": "The next group starts off with an odd parity, so you should have set its parity bit to be 1. ",
  "translatedText": "گروه بعدی با یک برابری فرد شروع می شود، بنابراین شما باید بیت برابری آن را 1 تنظیم می کردید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1033.02,
  "end": 1037.88
 },
 {
  "input": "The group after that starts with an odd parity, so again you should have set its parity bit to 1. ",
  "translatedText": "گروه بعد از آن با یک برابری فرد شروع می شود، بنابراین دوباره باید بیت برابری آن را 1 تنظیم می کردید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1039.16,
  "end": 1044.24
 },
 {
  "input": "And the final group also has an odd parity, meaning we set that bit in position 8 to be a 1. ",
  "translatedText": "و گروه نهایی نیز دارای یک برابری فرد است، به این معنی که ما آن بیت را در موقعیت 8 برابر با 1 قرار می دهیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1044.78,
  "end": 1050.06
 },
 {
  "input": "And then as the final step, the full block now has an even parity, meaning you can set that bit number 0, the overarching parity bit, to be 0. ",
  "translatedText": "و سپس به عنوان مرحله آخر، بلوک کامل اکنون دارای یک برابری زوج است، به این معنی که می توانید آن بیت شماره 0، بیت برابری فراگیر، را 0 تنظیم کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1051.3,
  "end": 1060.32
 },
 {
  "input": "So as this block is sent off, the parity of the four special subsets and the block as a whole will all be even, or 0. ",
  "translatedText": "بنابراین با حذف این بلوک، برابری چهار زیرمجموعه ویژه و بلوک به عنوان یک کل زوج یا 0 خواهد بود. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1061.34,
  "end": 1068.14
 },
 {
  "input": "As the second part of the exercise, let's have you play the role of the receiver. ",
  "translatedText": "به عنوان قسمت دوم تمرین، اجازه دهید شما نقش گیرنده را بازی کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1068.82,
  "end": 1072.18
 },
 {
  "input": "Of course, that would mean you don't already know what this message is, maybe some of you memorized it, but let's assume that you haven't. ",
  "translatedText": "البته، این بدان معناست که شما از قبل نمی دانید این پیام چیست، شاید برخی از شما آن را حفظ کرده باشید، اما فرض کنیم که این پیام را ندانید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1073.48,
  "end": 1079.78
 },
 {
  "input": "What I'm going to do is change either 0, 1, or 2 of the bits in that block, and then ask you to figure out what it is that I did. ",
  "translatedText": "کاری که می‌خواهم انجام دهم این است که 0، 1 یا 2 بیت‌های آن بلوک را تغییر دهم و سپس از شما بخواهم بفهمید که چه کاری انجام دادم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1080.02,
  "end": 1087.74
 },
 {
  "input": "So again, pause and try working it out. ",
  "translatedText": "پس دوباره مکث کنید و سعی کنید آن را حل کنید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1088.26,
  "end": 1090.81
 },
 {
  "input": "Okay, so you as the receiver now check the first parity group and you can see that it's even, so any error that exists would have to be in an even column. ",
  "translatedText": "خوب، بنابراین شما به عنوان گیرنده اکنون اولین گروه برابری را بررسی کنید و می توانید ببینید که زوج است، بنابراین هر خطایی که وجود دارد باید در یک ستون زوج باشد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1098.79,
  "end": 1107.91
 },
 {
  "input": "The next check gives us an odd number, telling us both that there's at least one error, and narrowing us down into this specific column. ",
  "translatedText": "بررسی بعدی یک عدد فرد به ما می دهد و به هر دوی ما می گوید که حداقل یک خطا وجود دارد و ما را به این ستون خاص محدود می کند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1109.69,
  "end": 1117.03
 },
 {
  "input": "The third check is even, chopping down the possibilities even further. ",
  "translatedText": "سومین بررسی یکنواخت است و احتمالات را حتی بیشتر کاهش می دهد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1118.55,
  "end": 1121.79
 },
 {
  "input": "And the last parity check is odd, telling us there's an error somewhere in the bottom, which by now we can see must be in position number 10. ",
  "translatedText": "و آخرین بررسی برابری عجیب است، به ما می گوید خطایی در قسمت پایین وجود دارد، که تا به حال می توانیم ببینیم که باید در موقعیت شماره 10 باشد. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1122.65,
  "end": 1129.65
 },
 {
  "input": "What's more, the parity of the whole block is odd, giving us confidence that there was one flip and not two. ",
  "translatedText": "علاوه بر این، برابری کل بلوک عجیب است و به ما اطمینان می دهد که یک تلنگر وجود دارد و نه دو. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1131.49,
  "end": 1137.53
 },
 {
  "input": "If it's three or more, all bets are off. ",
  "translatedText": "اگر سه یا بیشتر باشد، همه شرط‌ها لغو می‌شوند. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1138.07,
  "end": 1139.97
 },
 {
  "input": "After correcting that bit number 10, pulling out the 11 bits that were not used for correction gives us the relevant segment of the original message, which if you rewind and compare is indeed exactly what we started the example with. ",
  "translatedText": "پس از تصحیح بیت شماره 10، بیرون کشیدن 11 بیتی که برای تصحیح استفاده نشده اند، بخش مربوطه از پیام اصلی را به ما می دهد، که اگر به عقب برگردانید و مقایسه کنید، در واقع دقیقاً همان چیزی است که مثال را با آن شروع کردیم. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1141.31,
  "end": 1154.39
 },
 {
  "input": "And now that you know how to do all this by hand, I'd like to show you how you can carry out the core part of all of this logic with a single line of Python code. ",
  "translatedText": "و اکنون که می دانید چگونه همه این کارها را با دست انجام دهید، می خواهم به شما نشان دهم که چگونه می توانید بخش اصلی همه این منطق را با یک خط کد پایتون انجام دهید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1155.71,
  "end": 1163.17
 },
 {
  "input": "You see, what I haven't told you yet is just how elegant this algorithm really is, how simple it is to get a machine to point to the position of an error, how to systematically scale it, and how we can frame all of this as one single operation rather than multiple separate parity checks. ",
  "translatedText": "می بینید، چیزی که من هنوز به شما نگفته ام این است که این الگوریتم واقعاً چقدر ظریف است، چقدر ساده است که یک ماشین را به موقعیت خطا نشان دهد، چگونه به طور سیستماتیک آن را مقیاس بندی کنیم، و چگونه می توانیم همه موارد را چارچوب بندی کنیم. این به عنوان یک عملیات واحد به جای چندین بررسی برابری جداگانه است. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1163.87,
  "end": 1178.75
 },
 {
  "input": "To see what I mean, come join me in part 2. ",
  "translatedText": "برای اینکه بفهمید منظورم چیست، در قسمت 2 با من همراه شوید. ",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1179.43,
  "end": 1181.31
 }
]