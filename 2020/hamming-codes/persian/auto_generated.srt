1
00:00:00,000 --> 00:00:03,120
من فرض می کنم که همه اینجا از قسمت 1 آمده اند.

2
00:00:03,120 --> 00:00:06,920
ما در مورد کدهای همینگ صحبت می‌کردیم، راهی برای ایجاد یک بلوک از داده‌ها

3
00:00:06,920 --> 00:00:11,640
که در آن بیشتر بیت‌ها پیامی معنادار دارند، در حالی که چند بیت دیگر

4
00:00:11,640 --> 00:00:15,800
به‌عنوان نوعی افزونگی عمل می‌کنند، به گونه‌ای که اگر بیتی برگردانده شد، یا

5
00:00:15,800 --> 00:00:20,560
یک پیام. بیت یا بیت افزونگی، هر چیزی در این بلوک، گیرنده می‌تواند تشخیص

6
00:00:20,560 --> 00:00:21,920
دهد که یک خطا وجود داشته است، و چگونه آن را برطرف کند.

7
00:00:21,920 --> 00:00:25,900
ایده اصلی ارائه شده در آنجا این بود که چگونه از چندین

8
00:00:25,900 --> 00:00:29,800
بررسی برابری برای جستجوی باینری برای رسیدن به خطا استفاده کنید.

9
00:00:29,800 --> 00:00:33,920
در آن ویدئو، هدف این بود که کدهای همینگ را تا

10
00:00:33,920 --> 00:00:35,420
حد امکان به صورت دستی و قابل کشف مجدد ایجاد کنیم.

11
00:00:35,420 --> 00:00:40,040
اما وقتی شروع به فکر کردن در مورد اجرای واقعی این کدها، چه در نرم‌افزار

12
00:00:40,040 --> 00:00:44,120
یا سخت‌افزار، می‌کنید، این قاب‌بندی ممکن است واقعاً از ظریف بودن این کدها کم‌فروش کند.

13
00:00:44,120 --> 00:00:47,620
ممکن است فکر کنید که باید الگوریتمی بنویسید که تمام مکان‌های خطای

14
00:00:47,620 --> 00:00:52,320
احتمالی را ردیابی کند و با هر بررسی آن گروه را به

15
00:00:52,320 --> 00:00:54,160
نصف کاهش دهد، اما در واقع بسیار ساده‌تر از این است.

16
00:00:54,160 --> 00:00:58,720
اگر پاسخ‌های چهار بررسی برابری را که در ویدیوی گذشته انجام دادیم، به‌جای بله و خیر به

17
00:00:58,760 --> 00:01:04,800
صورت 1 و 0 بخوانید، به معنای واقعی کلمه موقعیت خطا را در باینری مشخص می‌کند.

18
00:01:04,800 --> 00:01:10,160
به عنوان مثال، عدد 7 در باینری شبیه 0111 است، که در

19
00:01:10,160 --> 00:01:12,640
اصل می گوید که 4 به علاوه 2 به علاوه 1 است.

20
00:01:12,640 --> 00:01:17,960
و توجه کنید که موقعیت 7 در کجا قرار می گیرد، اولین گروه از گروه های

21
00:01:17,960 --> 00:01:22,280
برابری ما را تحت تاثیر قرار می دهد، و دوم، و سوم، اما نه آخرین.

22
00:01:22,280 --> 00:01:26,560
بنابراین خواندن نتایج آن چهار بررسی از پایین به

23
00:01:26,560 --> 00:01:28,000
بالا واقعاً موقعیت خطا را مشخص می کند.

24
00:01:28,520 --> 00:01:32,240
هیچ چیز خاصی در مورد مثال 7 وجود ندارد، این به طور کلی کار می کند، و

25
00:01:32,240 --> 00:01:37,440
این منطق اجرای کل طرح در سخت افزار را به طرز تکان دهنده ای ساده می کند.

26
00:01:37,440 --> 00:01:43,380
حالا اگر می‌خواهید ببینید چرا این جادو اتفاق می‌افتد، این 16 برچسب شاخص را

27
00:01:43,380 --> 00:01:48,480
برای موقعیت‌های ما انتخاب کنید، اما به جای نوشتن آنها در پایه 10، بیایید

28
00:01:48,480 --> 00:01:50,720
همه آنها را به صورت باینری بنویسیم، از 0000 تا 1111 اجرا شود.

29
00:01:50,720 --> 00:01:55,880
همانطور که این برچسب‌های باینری را دوباره در جعبه‌هایشان قرار می‌دهیم، اجازه دهید

30
00:01:56,080 --> 00:01:58,440
تأکید کنم که آنها از داده‌هایی که واقعاً ارسال می‌شوند متمایز هستند.

31
00:01:58,440 --> 00:02:02,200
آنها چیزی بیش از یک برچسب مفهومی برای کمک به من و

32
00:02:02,200 --> 00:02:04,200
شما نیستند که بفهمیم چهار گروه برابری از کجا آمده اند.

33
00:02:04,200 --> 00:02:08,840
ظرافت داشتن هر چیزی که ما به آن نگاه می کنیم به صورت باینری توصیف می شود، شاید به

34
00:02:08,840 --> 00:02:13,160
دلیل سردرگمی توصیف شدن هر چیزی که ما به آن نگاه می کنیم به صورت دودویی تضعیف شود.

35
00:02:13,160 --> 00:02:15,040
هرچند ارزشش را دارد.

36
00:02:15,040 --> 00:02:20,740
توجه خود را فقط روی آخرین بیت تمام این برچسب ها متمرکز کنید

37
00:02:20,740 --> 00:02:24,280
و سپس موقعیت هایی را که بیت نهایی 1 است، برجسته کنید.

38
00:02:24,280 --> 00:02:28,800
چیزی که دریافت می کنیم اولین گروه از چهار گروه برابری ما است، به

39
00:02:28,800 --> 00:02:34,480
این معنی که می توانید اولین بررسی را به این صورت تفسیر کنید که

40
00:02:34,480 --> 00:02:36,680
اگر خطایی وجود دارد، آیا بیت نهایی در موقعیت آن خطا 1 است؟

41
00:02:36,680 --> 00:02:42,600
به طور مشابه، اگر روی بیت دوم تا آخر تمرکز کنید و تمام موقعیت‌هایی را که

42
00:02:42,600 --> 00:02:47,040
در آن 1 است برجسته کنید، گروه برابری دوم را از طرح ما دریافت می‌کنید.

43
00:02:47,040 --> 00:02:51,960
به عبارت دیگر، آن چک دوم از شما می پرسد، دوباره سلام، اگر

44
00:02:51,960 --> 00:02:56,160
خطایی وجود دارد، آیا بیت دوم تا آخر آن موقعیت 1 است؟

45
00:02:56,160 --> 00:02:57,160
و غیره.

46
00:02:57,160 --> 00:03:03,320
بررسی برابری سوم هر موقعیتی را که بیت سوم تا آخرین بیت آن روشن است و آخرین

47
00:03:03,320 --> 00:03:10,120
مورد هشت موقعیت آخر را پوشش می دهد، آنهایی که بالاترین بیت مرتبه آنها 1 است.

48
00:03:10,120 --> 00:03:15,680
هر کاری که قبلا انجام دادیم مانند پاسخ دادن به این چهار سوال

49
00:03:15,680 --> 00:03:18,800
است، که به نوبه خود مانند املای یک موقعیت در باینری است.

50
00:03:19,800 --> 00:03:22,080
امیدوارم این دو چیز را واضح تر کند.

51
00:03:22,080 --> 00:03:27,140
اولین مورد این است که چگونه به طور سیستماتیک به اندازه های بلوکی که قدرت های دو بزرگتر هستند تعمیم دهیم.

52
00:03:27,140 --> 00:03:33,180
اگر برای توصیف هر موقعیت، بیت‌های بیشتری طول می‌کشد، مانند شش بیت برای توصیف 64 نقطه، هر

53
00:03:33,180 --> 00:03:38,640
کدام از آن بیت‌ها یکی از گروه‌های برابری را به شما می‌دهند که باید بررسی کنیم.

54
00:03:38,640 --> 00:03:42,060
کسانی از شما که پازل صفحه شطرنج را که من با مت پارکر

55
00:03:42,060 --> 00:03:43,400
انجام دادم تماشا کردند، ممکن است همه اینها را بسیار آشنا بیابند.

56
00:03:43,400 --> 00:03:48,200
این همان منطق اصلی است، اما حل یک مشکل متفاوت،

57
00:03:48,200 --> 00:03:49,880
و در یک صفحه شطرنج 64 مربع اعمال می شود.

58
00:03:49,880 --> 00:03:54,000
دومین چیزی که امیدوارم روشن شود این است که چرا بیت های برابری ما در موقعیت

59
00:03:54,000 --> 00:03:58,320
هایی قرار دارند که قدرت های دو هستند، برای مثال 1، 2، 4 و 8.

60
00:03:58,320 --> 00:04:03,640
اینها موقعیت هایی هستند که نمایش باینری آنها فقط یک بیت روشن است.

61
00:04:03,640 --> 00:04:09,000
این بدان معناست که هر یک از آن بیت های برابری در

62
00:04:09,000 --> 00:04:12,640
یک و تنها یکی از چهار گروه برابری قرار می گیرند.

63
00:04:12,640 --> 00:04:16,840
همچنین می‌توانید این را در نمونه‌های بزرگ‌تر ببینید، جایی که مهم نیست چقدر بزرگ

64
00:04:16,840 --> 00:04:25,920
می‌شوید، هر بیت برابری به راحتی تنها یکی از گروه‌ها را لمس می‌کند.

65
00:04:25,920 --> 00:04:29,680
هنگامی که متوجه شدید که این بررسی‌های برابری که ما بیشتر وقت خود

66
00:04:29,680 --> 00:04:34,320
را بر روی آنها متمرکز کرده‌ایم، چیزی جز روشی هوشمندانه برای مشخص کردن

67
00:04:34,320 --> 00:04:37,880
موقعیت یک خطا در باینری نیست، آنگاه می‌توانیم با روشی متفاوت برای

68
00:04:37,880 --> 00:04:42,160
تفکر در مورد همینگ ارتباط برقرار کنیم. کدهایی که مسلماً بسیار ساده‌تر و

69
00:04:42,160 --> 00:04:43,880
ظریف‌تر هستند و اساساً می‌توان آن‌ها را با یک خط کد نوشت.

70
00:04:43,920 --> 00:04:46,200
این بر اساس تابع XOR است.

71
00:04:46,200 --> 00:04:50,960
XOR، برای کسانی از شما که نمی دانند، مخفف منحصر به فرد یا.

72
00:04:50,960 --> 00:04:55,440
هنگامی که XOR دو بیت را می گیرید، اگر یکی از آن بیت ها

73
00:04:55,440 --> 00:05:00,200
روشن باشد، 1 برمی گردد، اما اگر هر دو روشن یا خاموش باشند، نه.

74
00:05:00,200 --> 00:05:03,760
با بیان متفاوت، برابری این دو بیت است.

75
00:05:03,760 --> 00:05:07,840
به عنوان یک فرد ریاضی، ترجیح می دهم در مورد آن به عنوان مد 2 فکر کنم.

76
00:05:07,840 --> 00:05:12,000
ما همچنین معمولاً در مورد XOR دو رشته بیت مختلف صحبت

77
00:05:12,040 --> 00:05:14,040
می کنیم که اساساً این جزء به جزء انجام می شود.

78
00:05:14,040 --> 00:05:16,280
این مانند اضافه است، اما جایی که هرگز حمل نمی کنید.

79
00:05:16,280 --> 00:05:21,240
باز هم، کسانی که تمایل بیشتری به ریاضی دارند ممکن است ترجیح دهند این

80
00:05:21,240 --> 00:05:23,520
را به عنوان افزودن دو بردار و کاهش mod 2 در نظر بگیرند.

81
00:05:23,520 --> 00:05:28,720
اگر همین الان پایتون را باز کنید و عملیات caret را بین دو عدد صحیح اعمال

82
00:05:28,720 --> 00:05:35,400
کنید، این همان کاری است که انجام می‌دهد به جز نمایش بیت‌های آن اعداد زیر سرپوش.

83
00:05:35,400 --> 00:05:40,920
نکته کلیدی برای من و شما این است که گرفتن XOR از

84
00:05:40,960 --> 00:05:45,960
بسیاری از رشته‌های بیتی مختلف، به طور موثر راهی برای محاسبه تقلید

85
00:05:45,960 --> 00:05:51,320
هجو دسته‌ای از گروه‌های جداگانه است، مانند ستون‌ها، همه در یک لحظه.

86
00:05:51,320 --> 00:05:54,520
این به ما یک روش نسبتاً جالب می دهد تا در مورد بررسی های برابری چندگانه از الگوریتم

87
00:05:54,520 --> 00:05:59,680
کد Hamming خود فکر کنیم زیرا همه با هم در یک عملیات واحد بسته بندی می شوند.

88
00:05:59,680 --> 00:06:02,800
اگرچه در نگاه اول بسیار متفاوت به نظر می رسد.

89
00:06:02,800 --> 00:06:08,360
به طور خاص 16 موقعیت را به صورت باینری بنویسید، همانطور که قبلاً داشتیم، و اکنون

90
00:06:08,640 --> 00:06:14,800
موقعیت هایی را که بیت پیام در آنها روشن است به 1 برجسته کنید، و

91
00:06:14,800 --> 00:06:19,400
سپس این موقعیت ها را در یک ستون بزرگ جمع کنید و XOR را بگیرید.

92
00:06:19,400 --> 00:06:23,480
احتمالاً می‌توانید حدس بزنید که 4 بیتی که در نتیجه پایین قرار می‌گیرند،

93
00:06:23,480 --> 00:06:27,480
همان 4 بررسی برابری هستند که ما می‌شناسیم و دوستش داریم، اما لحظه‌ای

94
00:06:27,480 --> 00:06:32,720
وقت بگذارید و واقعاً به این فکر کنید که چرا دقیقاً چرا.

95
00:06:32,720 --> 00:06:37,880
برای مثال، این آخرین ستون، تمام موقعیت‌هایی را که آخرین بیت آنها 1 است،

96
00:06:38,400 --> 00:06:42,400
می‌شمرد، اما ما در حال حاضر فقط به موقعیت‌های برجسته‌شده محدود شده‌ایم، بنابراین به

97
00:06:42,400 --> 00:06:45,960
طور موثر شمارش می‌کند که چند موقعیت برجسته از گروه برابری اول آمده است.

98
00:06:45,960 --> 00:06:48,520
فرقی میکنه؟

99
00:06:48,520 --> 00:06:53,600
به همین ترتیب، ستون بعدی تعداد موقعیت‌های گروه برابری

100
00:06:53,600 --> 00:06:59,640
دوم، موقعیت‌هایی که بیت دوم تا آخر آنها 1

101
00:06:59,640 --> 00:07:00,640
است و همچنین برجسته شده‌اند و غیره می‌شمارند.

102
00:07:00,640 --> 00:07:06,640
این واقعاً فقط یک تغییر کوچک در دیدگاه نسبت به همان کاری است که ما انجام می‌دادیم.

103
00:07:07,640 --> 00:07:10,000
و بنابراین می دانید که از اینجا به کجا می رود.

104
00:07:10,000 --> 00:07:14,400
فرستنده مسئول تغییر برخی از بیت های برابری ویژه

105
00:07:14,400 --> 00:07:19,640
است تا مطمئن شود که مجموع آنها 0000 است.

106
00:07:19,640 --> 00:07:23,600
حالا وقتی آن را به این شکل داشته باشیم، این روش واقعاً خوبی به ما می دهد تا فکر

107
00:07:23,600 --> 00:07:28,720
کنیم چرا این چهار بیت حاصل در پایین به طور مستقیم موقعیت یک خطا را مشخص می کنند.

108
00:07:28,720 --> 00:07:32,680
فرض کنید مقداری از بیت در این بلوک از 0 به 1 تغییر می کند.

109
00:07:32,720 --> 00:07:37,320
معنی آن این است که موقعیت آن بیت اکنون در XOR

110
00:07:37,320 --> 00:07:42,960
کل گنجانده می شود، که مجموع را از 0 به جای

111
00:07:42,960 --> 00:07:44,800
این مقدار جدید اضافه شده، یعنی موقعیت خطا، تغییر می دهد.

112
00:07:44,800 --> 00:07:48,800
واضح است که کمی کمتر، اگر خطایی وجود داشته باشد که

113
00:07:48,800 --> 00:07:49,800
1 را به 0 تغییر دهد، همین امر صادق است.

114
00:07:49,800 --> 00:07:54,720
ببینید، اگر یک رشته بیت را دو بار با هم اضافه کنید، مثل این است که اصلاً آن را

115
00:07:54,720 --> 00:07:59,000
نداشته باشید، اساساً به این دلیل که در این دنیا 1 به اضافه 1 برابر با 0 است.

116
00:07:59,000 --> 00:08:03,720
بنابراین افزودن یک کپی از این موقعیت به مجموع کل همان

117
00:08:03,720 --> 00:08:05,400
اثری را دارد که ما آن را جابجا می کنیم.

118
00:08:05,400 --> 00:08:10,080
و آن اثر، دوباره، این است که نتیجه کل

119
00:08:10,080 --> 00:08:13,480
در پایین اینجا موقعیت خطا را مشخص می کند.

120
00:08:13,480 --> 00:08:17,720
برای نشان دادن زیبایی این موضوع، اجازه دهید یک خط از کد پایتون را که قبلاً

121
00:08:17,720 --> 00:08:22,120
به آن ارجاع دادم نشان دهم، که تقریباً تمام منطق انتهای گیرنده را نشان می‌دهد.

122
00:08:22,120 --> 00:08:27,160
ما با ایجاد یک آرایه تصادفی از 16 1 و 0 برای شبیه سازی بلوک

123
00:08:27,160 --> 00:08:31,160
داده شروع می کنیم، و من بیت های نام را به آن می دهم، اما

124
00:08:31,160 --> 00:08:36,160
البته در عمل این چیزی است که ما از فرستنده دریافت می کنیم، و به

125
00:08:36,160 --> 00:08:38,600
جای تصادفی بودن، 11 بیت داده همراه با 5 بیت برابری را حمل می کند.

126
00:08:38,600 --> 00:08:43,160
اگر تابع enumerateBits را صدا بزنم، کاری که انجام می دهد این است که هر یک از آن بیت

127
00:08:43,160 --> 00:08:48,240
ها را با یک شاخص مربوطه جفت می کند، در این مورد از 0 تا 15 اجرا می شود.

128
00:08:48,240 --> 00:08:53,200
بنابراین، اگر لیستی ایجاد کنیم که روی همه این جفت‌ها حلقه بزند، جفت‌هایی که

129
00:08:53,200 --> 00:08:59,160
شبیه i هستند، و سپس فقط مقدار i، فقط شاخص را بیرون بیاوریم، خوب

130
00:08:59,160 --> 00:09:01,920
آنقدرها هم هیجان‌انگیز نیست، فقط آن شاخص‌ها را از 0 تا 15 برمی‌گردانیم. .

131
00:09:01,920 --> 00:09:07,520
اما اگر شرط را اضافه کنیم که فقط اگر بیت این کار را انجام دهد، به این معنی که اگر آن

132
00:09:07,520 --> 00:09:13,400
بیت 1 باشد و 0 نباشد، خوب آنگاه فقط موقعیت هایی را که بیت مربوطه روشن است بیرون می کشد.

133
00:09:13,400 --> 00:09:20,320
در این حالت به نظر می رسد که آن موقعیت ها 0، 4، 6، 9 و غیره هستند.

134
00:09:20,720 --> 00:09:24,640
چیزی که می‌خواهیم این است که همه آن موقعیت‌ها، موقعیت‌های بیت‌هایی که روشن

135
00:09:24,640 --> 00:09:29,960
شده‌اند را جمع‌آوری کنیم و سپس آنها را با هم XOR کنیم.

136
00:09:29,960 --> 00:09:33,960
برای انجام این کار در پایتون، اجازه دهید ابتدا چند تابع مفید را وارد کنم.

137
00:09:33,960 --> 00:09:39,140
به این ترتیب می‌توانیم ()reduce را در این لیست فراخوانی کنیم و از تابع XOR برای کاهش آن استفاده کنیم.

138
00:09:39,140 --> 00:09:44,840
این اساساً راه خود را از طریق لیست می خورد و XOR ها را در طول راه می برد.

139
00:09:44,840 --> 00:09:48,760
اگر ترجیح می دهید، می توانید به صراحت آن تابع XOR

140
00:09:48,800 --> 00:09:52,200
را بدون نیاز به وارد کردن آن از جایی بنویسید.

141
00:09:52,200 --> 00:09:56,880
بنابراین در حال حاضر به نظر می رسد که اگر این کار را روی بلوک

142
00:09:56,880 --> 00:10:02,080
تصادفی 16 بیتی خود انجام دهیم، 9 را برمی گرداند که نمایش باینری 1001 دارد.

143
00:10:02,080 --> 00:10:05,960
ما این کار را در اینجا انجام نمی دهیم، اما می توانید تابعی بنویسید که در آن فرستنده

144
00:10:05,960 --> 00:10:11,560
از آن نمایش باینری برای تنظیم چهار بیت برابری در صورت نیاز استفاده کند، در نهایت این بلوک

145
00:10:11,560 --> 00:10:16,200
به حالتی می رسد که اجرای این خط کد در لیست کامل بیت ها برمی گردد. یک 0.

146
00:10:17,200 --> 00:10:20,200
این یک بلوک به خوبی آماده شده در نظر گرفته می شود.

147
00:10:20,200 --> 00:10:24,640
نکته جالب این است که اگر هر یک از بیت‌های این لیست را تغییر دهیم، یک خطای تصادفی

148
00:10:24,640 --> 00:10:30,600
از نویز را شبیه‌سازی کنیم، سپس اگر همین خط کد را اجرا کنید، آن خطا را چاپ می‌کند.

149
00:10:30,600 --> 00:10:31,920
این تمیز نیست؟

150
00:10:31,920 --> 00:10:37,200
می‌توانید این بلوک را از حالت آبی دریافت کنید، این خط را روی آن اجرا کنید

151
00:10:37,200 --> 00:10:42,920
و به طور خودکار موقعیت یک خطا یا 0 را در صورت نبودن نشان می‌دهد.

152
00:10:42,920 --> 00:10:45,520
و هیچ چیز خاصی در مورد سایز 16 در اینجا وجود ندارد.

153
00:10:45,520 --> 00:10:52,280
اگر لیستی از مثلاً 256 بیت داشته باشید، همان خط کد کار می کند.

154
00:10:52,280 --> 00:10:56,280
نیازی به گفتن نیست، کدهای بیشتری برای نوشتن در اینجا وجود دارد، مانند انجام

155
00:10:56,280 --> 00:11:01,440
بررسی متا برابری برای تشخیص خطاهای 2 بیتی، اما ایده این است که

156
00:11:01,440 --> 00:11:05,080
تقریباً تمام منطق اصلی طرح ما به یک کاهش XOR منتهی می شود.

157
00:11:05,080 --> 00:11:10,600
اکنون، بسته به راحتی شما با باینری و XOR و به طور کلی نرم افزار،

158
00:11:10,600 --> 00:11:15,880
ممکن است این دیدگاه را کمی گیج کننده بیابید، یا آنقدر زیباتر و ساده

159
00:11:15,880 --> 00:11:19,320
تر که تعجب کنید که چرا ما از ابتدا با آن شروع نکردیم. -برو

160
00:11:19,320 --> 00:11:22,880
به زبان ساده، در هنگام پیاده‌سازی کدهای همینگ در سخت‌افزار به‌طور مستقیم

161
00:11:22,880 --> 00:11:27,560
می‌توان به دیدگاه بررسی برابری چندگانه فکر کرد، و در هنگام انجام

162
00:11:27,560 --> 00:11:31,380
آن در نرم‌افزار، از سطح بالاتر، راحت‌تر به دیدگاه XOR فکر می‌شود.

163
00:11:31,380 --> 00:11:35,640
اولین مورد ساده‌ترین کار است که واقعاً با دست انجام می‌شود، و من فکر می‌کنم

164
00:11:35,640 --> 00:11:40,720
با القای شهود اصلی زیربنای همه این‌ها کار بهتری انجام می‌دهد، یعنی اطلاعات مورد

165
00:11:40,720 --> 00:11:46,840
نیاز برای یافتن یک خطا مربوط به گزارش اندازه بلوک است. ، یا به عبارت

166
00:11:46,840 --> 00:11:51,020
دیگر، با دو برابر شدن اندازه بلوک، هر بار یک بیت رشد می کند.

167
00:11:51,020 --> 00:11:55,440
واقعیت مرتبط در اینجا این است که آن اطلاعات به

168
00:11:55,440 --> 00:11:56,440
طور مستقیم با میزان افزونگی مورد نیاز ما مطابقت دارد.

169
00:11:56,440 --> 00:12:00,320
این واقعاً چیزی است که در برابر واکنش تند و تیز اکثر افراد زمانی که برای

170
00:12:00,320 --> 00:12:05,280
اولین بار در مورد ایجاد یک پیام مقاوم در برابر خطاها فکر می کنند، مخالف است،

171
00:12:05,280 --> 00:12:07,520
جایی که معمولاً کپی کردن کل پیام اولین غریزی است که به ذهن می رسد.

172
00:12:07,520 --> 00:12:11,120
و بعد، اتفاقاً، این راه کاملاً وجود دارد که گاهی اوقات کدهای همینگ را مشاهده

173
00:12:11,120 --> 00:12:14,800
می کنید که در آن پیام را در یک ماتریس بزرگ ضرب می کنید.

174
00:12:14,800 --> 00:12:18,580
به نوعی خوب است زیرا آن را به خانواده گسترده‌تر کدهای خطی مرتبط می‌کند، اما من

175
00:12:18,580 --> 00:12:25,160
فکر می‌کنم که تقریباً هیچ شهودی برای اینکه از کجا آمده یا چگونه مقیاس می‌شود، نمی‌دهد.

176
00:12:25,160 --> 00:12:29,340
و در مورد مقیاس بندی، ممکن است متوجه شوید که

177
00:12:29,340 --> 00:12:32,200
با افزایش اندازه بلوک، کارایی این طرح بهتر می شود.

178
00:12:32,200 --> 00:12:40,560
به عنوان مثال، ما دیدیم که با 256 بیت، شما فقط از 3٪ از آن

179
00:12:40,560 --> 00:12:43,480
فضا برای افزونگی استفاده می کنید، و از آنجا به بعد بهتر می شود.

180
00:12:43,480 --> 00:12:49,040
همانطور که تعداد بیت های برابری یکی یکی افزایش می یابد، اندازه بلوک دو برابر می شود.

181
00:12:49,040 --> 00:12:53,840
و اگر آن را به حد افراط برسانید، می‌توانید بلوکی با مثلاً یک میلیون

182
00:12:53,840 --> 00:12:58,800
بیت داشته باشید، که در آن به معنای واقعی کلمه 20 سؤال را با

183
00:12:58,800 --> 00:13:00,800
بررسی‌های برابری خود بازی می‌کنید و فقط از 21 بیت برابری استفاده می‌کند.

184
00:13:00,800 --> 00:13:05,760
و اگر به عقب برگردید و به یک میلیون بیت نگاه

185
00:13:05,760 --> 00:13:08,640
کنید و یک خطا را پیدا کنید، واقعاً دیوانه کننده است.

186
00:13:08,640 --> 00:13:12,680
البته مشکل این است که با یک بلوک بزرگتر، احتمال مشاهده خطاهای بیش از یک یا

187
00:13:12,680 --> 00:13:18,360
دو بیت بالا می رود و کدهای همینگ چیزی فراتر از آن را کنترل نمی کنند.

188
00:13:18,360 --> 00:13:22,020
بنابراین در عمل، چیزی که می خواهید این است که اندازه مناسب را

189
00:13:22,020 --> 00:13:25,520
پیدا کنید تا احتمال تلنگرهای بیش از حد بیت خیلی زیاد نباشد.

190
00:13:26,520 --> 00:13:30,920
همچنین، در عمل، خطاها معمولاً به صورت پشت سر هم ظاهر می‌شوند، که یک بلوک را کاملاً

191
00:13:30,920 --> 00:13:35,680
خراب می‌کند، بنابراین یک تاکتیک رایج برای کمک به گسترش خطاها در بسیاری از بلوک‌های مختلف این

192
00:13:35,680 --> 00:13:41,720
است که آن بلوک‌ها، مانند این، قبل از اینکه به هم بریزند ارسال یا ذخیره می شود.

193
00:13:45,480 --> 00:13:49,920
سپس، بسیاری از این موارد به‌طور کامل توسط کدهای مدرن‌تر ارائه می‌شوند، مانند الگوریتم بسیار

194
00:13:49,920 --> 00:13:55,060
رایج‌تر Reed-Solomon، که به‌خوبی خطاهای انفجاری را مدیریت می‌کند، و می‌توان آن را به گونه‌ای

195
00:13:55,100 --> 00:13:59,580
تنظیم کرد که در برابر تعداد بیشتری از خطاها در هر بلوک انعطاف‌پذیر باشد. .

196
00:13:59,580 --> 00:14:03,000
اما این موضوع برای زمان دیگری است.

197
00:14:03,000 --> 00:14:07,660
هامینگ در کتاب خود به نام هنر انجام علم و مهندسی به طرز شگفت انگیزی

198
00:14:07,660 --> 00:14:10,700
در مورد اینکه کشف این رمز چقدر پر پیچ و خم بود، صریح است.

199
00:14:10,700 --> 00:14:15,180
او ابتدا انواع طرح‌های مختلف را امتحان کرد که شامل سازماندهی بیت‌ها در

200
00:14:15,180 --> 00:14:18,420
بخش‌هایی از شبکه‌ای با ابعاد بالاتر و چیزهای عجیبی مانند این بود.

201
00:14:18,420 --> 00:14:22,520
این ایده که ممکن است بررسی‌های برابری به گونه‌ای توطئه شود که موقعیت

202
00:14:22,520 --> 00:14:26,360
خطا را مشخص کند، تنها زمانی به ذهن همینگ رسید که او

203
00:14:26,360 --> 00:14:30,800
پس از یک سری تحلیل دیگر عقب‌نشینی کرد و پرسید، بسیار خوب،

204
00:14:30,800 --> 00:14:32,860
کارآمدترین کاری که می‌توانم داشتم چیست؟ ممکن است در مورد این باشد؟

205
00:14:32,860 --> 00:14:36,760
او همچنین در مورد اینکه چقدر مهم است که چک‌های برابری در ذهنش

206
00:14:36,760 --> 00:14:42,040
بود، که در دهه ۱۹۴۰ بسیار کمتر از امروز رایج بود، صادق بود.

207
00:14:42,040 --> 00:14:46,040
در سراسر این کتاب تقریباً دوازده بار است که او به نقل

208
00:14:46,040 --> 00:14:49,640
قول لویی پاستور اشاره می کند، شانس به نفع ذهن آماده است.

209
00:14:49,640 --> 00:14:55,120
ایده‌های هوشمندانه اغلب در آینده به طرز فریبنده‌ای ساده به نظر می‌رسند، که باعث می‌شود به راحتی از آنها قدردانی نشوند.

210
00:14:55,120 --> 00:14:59,680
در حال حاضر امید صادقانه من این است که کدهای Hamming

211
00:14:59,680 --> 00:15:01,820
یا حداقل امکان چنین کدهایی برای شما تقریباً واضح است.

212
00:15:01,820 --> 00:15:05,440
اما نباید خودتان را گول بزنید که فکر کنید

213
00:15:05,440 --> 00:15:08,000
آنها در واقع واضح هستند، زیرا قطعاً اینطور نیستند.

214
00:15:08,000 --> 00:15:12,080
بخشی از دلیل اینکه ایده‌های هوشمندانه به طرز فریبنده‌ای آسان به نظر می‌رسند این

215
00:15:12,080 --> 00:15:17,360
است که ما فقط نتیجه نهایی را می‌بینیم، تمیز کردن چیزهایی که به هم

216
00:15:17,360 --> 00:15:22,400
ریخته بود، هرگز به همه چرخش‌های اشتباه اشاره نمی‌کنیم، و کم‌فروش بودن فضای احتمالات

217
00:15:22,400 --> 00:15:23,980
قابل کشف در ابتدای یک مشکل را کم می‌کنیم. فرآیند حل، همه اینها

218
00:15:23,980 --> 00:15:25,280
اما این به طور کلی درست است.

219
00:15:25,280 --> 00:15:29,880
من فکر می کنم برای برخی اختراعات خاص، دلیل دوم و

220
00:15:29,880 --> 00:15:31,040
عمیق تری وجود دارد که ما از آنها قدردانی نمی کنیم.

221
00:15:31,040 --> 00:15:35,040
اندیشیدن به اطلاعات بر حسب بیت، تنها در سال 1948 با مقاله اصلی

222
00:15:35,040 --> 00:15:39,400
کلود شانون در مورد نظریه اطلاعات، در یک نظریه کامل ادغام شد.

223
00:15:39,400 --> 00:15:43,400
این اساساً با زمانی که هامینگ الگوریتم خود را توسعه داد همزمان بود.

224
00:15:43,440 --> 00:15:47,300
این همان مقاله بنیادی بود که نشان داد، به معنای

225
00:15:47,300 --> 00:15:52,080
خاصی، تصحیح خطای کارآمد همیشه امکان پذیر است، مهم نیست

226
00:15:52,080 --> 00:15:53,920
که احتمال تلنگر بیت چقدر بالا باشد، حداقل در تئوری.

227
00:15:53,920 --> 00:15:58,120
به هر حال، شانون و همینگ، علیرغم کار بر روی چیزهای بسیار متفاوت، دفتری در

228
00:15:58,120 --> 00:16:02,400
آزمایشگاه بل مشترک داشتند، که در اینجا به سختی تصادفی به نظر می رسد.

229
00:16:02,400 --> 00:16:06,960
چندین دهه به سرعت به جلو، و این روزها، بسیاری از ما چنان غرق در فکر کردن در مورد

230
00:16:06,960 --> 00:16:13,080
بیت ها و اطلاعات هستیم که به راحتی می توان از تفاوت این طرز تفکر چشم پوشی کرد.

231
00:16:13,080 --> 00:16:17,920
از قضا، ایده‌هایی که عمیق‌ترین روش‌هایی را که یک نسل آینده فکر می‌کند شکل

232
00:16:17,920 --> 00:16:22,640
می‌دهند، در نهایت به آن نسل آینده ساده‌تر از آنچه واقعا هستند نگاه می‌کنند.

