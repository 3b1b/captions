1
00:00:00,000 --> 00:00:03,120
Я припускаю, що всі тут походять із частини 1.

2
00:00:03,120 --> 00:00:06,920
Ми говорили про коди Хеммінга, спосіб створення блоку даних, де більшість

3
00:00:06,920 --> 00:00:11,640
бітів несуть значуще повідомлення, тоді як кілька інших діють як

4
00:00:11,640 --> 00:00:15,800
свого роду надлишковість, таким чином, що якщо будь-який біт перевертається,

5
00:00:15,800 --> 00:00:20,560
або повідомлення біт або біт надлишковості, будь-що в цьому блоці,

6
00:00:20,560 --> 00:00:21,920
приймач зможе визначити, що була помилка, і як її виправити.

7
00:00:21,920 --> 00:00:25,900
Основна ідея, представлена там, полягала в тому, як використовувати кілька

8
00:00:25,900 --> 00:00:29,800
перевірок на парність для бінарного пошуку на шляху до помилки.

9
00:00:29,800 --> 00:00:33,920
У цьому відео мета полягала в тому, щоб

10
00:00:33,920 --> 00:00:35,420
зробити коди Хеммінга максимально практичними та відкритими заново.

11
00:00:35,420 --> 00:00:40,040
Але коли ви починаєте думати про те, щоб реалізувати це в програмному

12
00:00:40,040 --> 00:00:44,120
чи апаратному забезпеченні, таке фреймування може фактично знизити вартість елегантного коду.

13
00:00:44,120 --> 00:00:47,620
Ви можете подумати, що вам потрібно написати алгоритм, який відстежує

14
00:00:47,620 --> 00:00:52,320
всі можливі місця помилок і скорочує цю групу навпіл під

15
00:00:52,320 --> 00:00:54,160
час кожної перевірки, але насправді це набагато, набагато простіше.

16
00:00:54,160 --> 00:00:58,720
Якщо ви зачитаєте відповіді на чотири перевірки парності, які ми робили в останньому відео, усі як

17
00:00:58,760 --> 00:01:04,800
1 і 0 замість «так» і «ні», це буквально вказує місце помилки в двійковому вигляді.

18
00:01:04,800 --> 00:01:10,160
Наприклад, число 7 у двійковій системі виглядає як 0111, по

19
00:01:10,160 --> 00:01:12,640
суті кажучи, що це 4 плюс 2 плюс 1.

20
00:01:12,640 --> 00:01:17,960
І зауважте, де знаходиться позиція 7, вона дійсно впливає на першу з наших

21
00:01:17,960 --> 00:01:22,280
груп парності, і на другу, і на третю, але не на останню.

22
00:01:22,280 --> 00:01:26,560
Отже, читання результатів цих чотирьох перевірок

23
00:01:26,560 --> 00:01:28,000
знизу вгору справді пояснює місце помилки.

24
00:01:28,520 --> 00:01:32,240
У прикладі 7 немає нічого особливого, загалом це працює, і це

25
00:01:32,240 --> 00:01:37,440
робить логіку реалізації всієї схеми на апаратному забезпеченні надзвичайно простою.

26
00:01:37,440 --> 00:01:43,380
Тепер, якщо ви хочете зрозуміти, чому відбувається ця магія, візьміть ці 16 індексних

27
00:01:43,380 --> 00:01:48,480
міток для наших позицій, але замість того, щоб записувати їх у базі

28
00:01:48,480 --> 00:01:50,720
10, давайте запишемо їх у двійковому вигляді, починаючи від 0000 до 1111.

29
00:01:50,720 --> 00:01:55,880
Коли ми повертаємо ці двійкові мітки назад у свої коробки, дозвольте

30
00:01:56,080 --> 00:01:58,440
мені підкреслити, що вони відрізняються від даних, які насправді надсилаються.

31
00:01:58,440 --> 00:02:02,200
Вони не що інше, як концептуальний ярлик, який допоможе

32
00:02:02,200 --> 00:02:04,200
вам і мені зрозуміти, звідки взялися чотири паритетні групи.

33
00:02:04,200 --> 00:02:08,840
Елегантність того, що все, на що ми дивимося, описується у двійковому форматі, можливо, підривається

34
00:02:08,840 --> 00:02:13,160
плутаниною, пов’язаною з тим, що все, на що ми дивимося, описується у двійковому форматі.

35
00:02:13,160 --> 00:02:15,040
Проте воно того варте.

36
00:02:15,040 --> 00:02:20,740
Зосередьте свою увагу лише на останньому фрагменті всіх цих міток,

37
00:02:20,740 --> 00:02:24,280
а потім виділіть позиції, де останній біт є 1.

38
00:02:24,280 --> 00:02:28,800
Що ми отримуємо, це перша з наших чотирьох груп парності, що

39
00:02:28,800 --> 00:02:34,480
означає, що ви можете інтерпретувати цю першу перевірку як запитання: якщо

40
00:02:34,480 --> 00:02:36,680
є помилка, чи є останній біт у позиції цієї помилки 1?

41
00:02:36,680 --> 00:02:42,600
Так само, якщо ви зосередитеся на передостанньому біті та виділите всі позиції,

42
00:02:42,600 --> 00:02:47,040
де це 1, ви отримаєте другу групу парності з нашої схеми.

43
00:02:47,040 --> 00:02:51,960
Іншими словами, ця друга перевірка запитує, привіт, я знову,

44
00:02:51,960 --> 00:02:56,160
якщо є помилка, передостанній біт цієї позиції є 1?

45
00:02:56,160 --> 00:02:57,160
І так далі.

46
00:02:57,160 --> 00:03:03,320
Третя перевірка парності охоплює кожну позицію, передостанній біт якої ввімкнено, а

47
00:03:03,320 --> 00:03:10,120
остання охоплює останні вісім позицій, у яких старший біт дорівнює 1.

48
00:03:10,120 --> 00:03:15,680
Усе, що ми робили раніше, те саме, що відповіді на ці чотири запитання,

49
00:03:15,680 --> 00:03:18,800
що, у свою чергу, те саме, що виклад позиції в двійковому коді.

50
00:03:19,800 --> 00:03:22,080
Сподіваюся, це зрозуміє дві речі.

51
00:03:22,080 --> 00:03:27,140
По-перше, як систематично узагальнювати розміри блоків, які є більшими степенями двійки.

52
00:03:27,140 --> 00:03:33,180
Якщо для опису кожної позиції потрібно більше бітів, наприклад, шість бітів для опису 64 плям,

53
00:03:33,180 --> 00:03:38,640
тоді кожен із цих бітів дає вам одну з груп парності, яку нам потрібно перевірити.

54
00:03:38,640 --> 00:03:42,060
Тим із вас, хто дивився головоломку на шахівниці, яку я

55
00:03:42,060 --> 00:03:43,400
розгадував із Метом Паркером, можливо, все це здасться надзвичайно знайомим.

56
00:03:43,400 --> 00:03:48,200
Це та сама основна логіка, але розв’язує іншу проблему

57
00:03:48,200 --> 00:03:49,880
та застосована до шахової дошки з 64 квадратами.

58
00:03:49,880 --> 00:03:54,000
Друге, що, я сподіваюся, це пояснює, чому наші біти парності сидять у

59
00:03:54,000 --> 00:03:58,320
позиціях, які є степенями двійки, наприклад, 1, 2, 4 і 8.

60
00:03:58,320 --> 00:04:03,640
Це позиції, двійкове представлення яких має лише один біт.

61
00:04:03,640 --> 00:04:09,000
Це означає, що кожен із цих бітів парності знаходиться

62
00:04:09,000 --> 00:04:12,640
в одній і лише одній із чотирьох груп парності.

63
00:04:12,640 --> 00:04:16,840
Ви також можете побачити це на більших прикладах, де незалежно від того, наскільки

64
00:04:16,840 --> 00:04:25,920
великим ви станете, кожен біт парності зручно стосується лише однієї з груп.

65
00:04:25,920 --> 00:04:29,680
Як тільки ви зрозумієте, що ці перевірки парності, на яких ми зосередили

66
00:04:29,680 --> 00:04:34,320
стільки нашого часу, є не що інше, як розумний спосіб виразити

67
00:04:34,320 --> 00:04:37,880
позицію помилки в двійковому форматі, тоді ми зможемо провести зв’язок з

68
00:04:37,880 --> 00:04:42,160
іншим способом уявлення про хемінг коди, який, мабуть, є набагато простішим

69
00:04:42,160 --> 00:04:43,880
і елегантнішим, і який можна записати за допомогою одного рядка коду.

70
00:04:43,920 --> 00:04:46,200
Він заснований на функції XOR.

71
00:04:46,200 --> 00:04:50,960
XOR, для тих із вас, хто не знає, означає ексклюзивне або.

72
00:04:50,960 --> 00:04:55,440
Коли ви використовуєте XOR двох бітів, він повертає 1, якщо один

73
00:04:55,440 --> 00:05:00,200
із цих бітів увімкнено, але не якщо обидва увімкнено чи вимкнено.

74
00:05:00,200 --> 00:05:03,760
Іншими словами, це парність цих двох бітів.

75
00:05:03,760 --> 00:05:07,840
Як математик я вважаю за краще думати про це як про додавання 2.

76
00:05:07,840 --> 00:05:12,000
Ми також зазвичай говоримо про XOR двох різних бітових

77
00:05:12,040 --> 00:05:14,040
рядків, що в основному виконує цей компонент за компонентом.

78
00:05:14,040 --> 00:05:16,280
Це як доповнення, але куди ніколи не понесеш.

79
00:05:16,280 --> 00:05:21,240
Знову ж таки, більш схильні до математики можуть вважати за краще думати

80
00:05:21,240 --> 00:05:23,520
про це як про додавання двох векторів і зменшення mod 2.

81
00:05:23,520 --> 00:05:28,720
Якщо ви прямо зараз відкриєте якийсь Python і застосуєте операцію каретки між двома цілими числами, це

82
00:05:28,720 --> 00:05:35,400
буде саме те, що він робить, але лише до розрядних представлень цих чисел під капотом.

83
00:05:35,400 --> 00:05:40,920
Ключовим моментом для нас із вами є те, що використання

84
00:05:40,960 --> 00:05:45,960
XOR багатьох різних бітових рядків є ефективним способом обчислення пародії

85
00:05:45,960 --> 00:05:51,320
на купу окремих груп, як і зі стовпцями, одним махом.

86
00:05:51,320 --> 00:05:54,520
Це дає нам досить хитрий спосіб уявити, що численні перевірки

87
00:05:54,520 --> 00:05:59,680
парності з нашого алгоритму коду Хеммінга об’єднані в одну операцію.

88
00:05:59,680 --> 00:06:02,800
Хоча на перший погляд виглядає зовсім інакше.

89
00:06:02,800 --> 00:06:08,360
Зокрема, запишіть 16 позицій у двійковому вигляді, як ми це робили раніше,

90
00:06:08,640 --> 00:06:14,800
а тепер виділіть позиції, де біт повідомлення ввімкнуто на 1, а

91
00:06:14,800 --> 00:06:19,400
потім зберіть ці позиції в один великий стовпець і виконайте XOR.

92
00:06:19,400 --> 00:06:23,480
Ви, напевно, можете здогадатися, що 4 біти, які лежать у нижній

93
00:06:23,480 --> 00:06:27,480
частині в результаті, такі ж, як і 4 перевірки парності, які

94
00:06:27,480 --> 00:06:32,720
ми знали і любимо, але знайдіть хвилинку, щоб подумати, чому саме.

95
00:06:32,720 --> 00:06:37,880
Цей останній стовпець, наприклад, підраховує всі позиції, останній біт яких

96
00:06:38,400 --> 00:06:42,400
дорівнює 1, але ми вже обмежені лише виділеними позиціями, тому

97
00:06:42,400 --> 00:06:45,960
фактично підраховується, скільки виділених позицій походить від першої групи парності.

98
00:06:45,960 --> 00:06:48,520
Чи має це сенс?

99
00:06:48,520 --> 00:06:53,600
Подібним чином у наступному стовпці підраховується кількість позицій

100
00:06:53,600 --> 00:06:59,640
у другій групі парності, позиції, передостанній біт

101
00:06:59,640 --> 00:07:00,640
яких дорівнює 1, які також виділені тощо.

102
00:07:00,640 --> 00:07:06,640
Насправді це лише невелика зміна погляду на те саме, що ми робили.

103
00:07:07,640 --> 00:07:10,000
І ви знаєте, куди це йде.

104
00:07:10,000 --> 00:07:14,400
Відправник відповідає за перемикання деяких спеціальних бітів

105
00:07:14,400 --> 00:07:19,640
парності, щоб переконатися, що сума дорівнює 0000.

106
00:07:19,640 --> 00:07:23,600
Тепер, коли ми маємо це таким чином, це дає нам дійсно гарний спосіб подумати

107
00:07:23,600 --> 00:07:28,720
про те, чому ці чотири результуючих біта внизу безпосередньо вказують на місце помилки.

108
00:07:28,720 --> 00:07:32,680
Припустимо, якийсь біт у цьому блоці перемикається з 0 на 1.

109
00:07:32,720 --> 00:07:37,320
Це означає, що позиція цього біта тепер буде

110
00:07:37,320 --> 00:07:42,960
включена в загальне XOR, яке змінює суму з

111
00:07:42,960 --> 00:07:44,800
0 на це нове включене значення, позицію помилки.

112
00:07:44,800 --> 00:07:48,800
Трохи менш очевидно, те ж саме вірно, якщо

113
00:07:48,800 --> 00:07:49,800
є помилка, яка змінює 1 на 0.

114
00:07:49,800 --> 00:07:54,720
Розумієте, якщо ви двічі додаєте бітовий рядок, це все одно, що його

115
00:07:54,720 --> 00:07:59,000
взагалі немає, тому що в цьому світі 1 плюс 1 дорівнює 0.

116
00:07:59,000 --> 00:08:03,720
Тож додавання копії цієї позиції до загальної суми

117
00:08:03,720 --> 00:08:05,400
має той самий ефект, що й її переміщення.

118
00:08:05,400 --> 00:08:10,080
І цей ефект, знову ж таки, полягає в тому,

119
00:08:10,080 --> 00:08:13,480
що загальний результат унизу тут вказує на місце помилки.

120
00:08:13,480 --> 00:08:17,720
Щоб проілюструвати, наскільки це елегантно, дозвольте мені показати той рядок коду Python, на

121
00:08:17,720 --> 00:08:22,120
який я посилався раніше, який захопить майже всю логіку на стороні приймача.

122
00:08:22,120 --> 00:08:27,160
Ми почнемо зі створення випадкового масиву з 16 1 і 0 для

123
00:08:27,160 --> 00:08:31,160
імітації блоку даних, і я дам йому біти назви, але, звичайно, на

124
00:08:31,160 --> 00:08:36,160
практиці це буде щось, що ми отримуємо від відправника, а замість будучи

125
00:08:36,160 --> 00:08:38,600
випадковим, він містив би 11 біт даних разом із 5 бітами парності.

126
00:08:38,600 --> 00:08:43,160
Якщо я викликаю функцію enumerateBits, вона об’єднає кожен із цих бітів

127
00:08:43,160 --> 00:08:48,240
із відповідним індексом, у цьому випадку від 0 до 15.

128
00:08:48,240 --> 00:08:53,200
Отже, якщо ми створимо список, який циклічно перебирає всі ці пари, пари, які

129
00:08:53,200 --> 00:08:59,160
виглядають як i, а потім витягуємо лише значення i, лише індекс, це не

130
00:08:59,160 --> 00:09:01,920
так цікаво, ми просто повертаємо ті індекси від 0 до 15. .

131
00:09:01,920 --> 00:09:07,520
Але якщо ми додамо умову робити це тільки якщо біт, тобто якщо цей біт є

132
00:09:07,520 --> 00:09:13,400
1, а не 0, добре, тоді він вилучає лише ті позиції, де відповідний біт увімкнено.

133
00:09:13,400 --> 00:09:20,320
У цьому випадку виглядає так, ніби ці позиції 0, 4, 6, 9 тощо.

134
00:09:20,720 --> 00:09:24,640
Те, що ми хочемо, це зібрати разом усі ці позиції,

135
00:09:24,640 --> 00:09:29,960
позиції бітів, які ввімкнено, а потім XOR їх разом.

136
00:09:29,960 --> 00:09:33,960
Щоб зробити це в Python, дозвольте мені спочатку імпортувати кілька корисних функцій.

137
00:09:33,960 --> 00:09:39,140
Таким чином ми можемо викликати reduce() у цьому списку та використовувати функцію XOR, щоб зменшити його.

138
00:09:39,140 --> 00:09:44,840
Це в основному з&#39;їдає собі шлях через список, використовуючи по дорозі XOR.

139
00:09:44,840 --> 00:09:48,760
Якщо ви бажаєте, ви можете явно написати цю функцію

140
00:09:48,800 --> 00:09:52,200
XOR без необхідності імпортувати її з будь-якого місця.

141
00:09:52,200 --> 00:09:56,880
Отже, на даний момент виглядає так, що якщо ми зробимо це на нашому

142
00:09:56,880 --> 00:10:02,080
випадковому блоці з 16 біт, він поверне 9, який має двійкове представлення 1001.

143
00:10:02,080 --> 00:10:05,960
Ми не будемо цього робити тут, але ви можете написати функцію, у якій відправник використовує

144
00:10:05,960 --> 00:10:11,560
це двійкове представлення, щоб за потреби встановити чотири біти парності, зрештою переводячи цей блок

145
00:10:11,560 --> 00:10:16,200
у стан, коли виконання цього рядка коду з повним списком бітів повертає а 0.

146
00:10:17,200 --> 00:10:20,200
Це буде вважатися добре підготовленим блоком.

147
00:10:20,200 --> 00:10:24,640
Цікаво те, що якщо ми перемикаємо будь-який із бітів у цьому списку, імітуючи випадкову помилку

148
00:10:24,640 --> 00:10:30,600
через шум, тоді, якщо ви запустите цей самий рядок коду, він виведе цю помилку.

149
00:10:30,600 --> 00:10:31,920
Хіба це не гарно?

150
00:10:31,920 --> 00:10:37,200
Ви можете отримати цей блок зненацька, запустити на ньому цей єдиний рядок,

151
00:10:37,200 --> 00:10:42,920
і він автоматично видасть позицію помилки або 0, якщо її не було.

152
00:10:42,920 --> 00:10:45,520
І нічого особливого в 16 розмірі тут немає.

153
00:10:45,520 --> 00:10:52,280
Той самий рядок коду спрацював би, якби у вас був список із, скажімо, 256 біт.

154
00:10:52,280 --> 00:10:56,280
Зайве говорити, що тут потрібно написати більше коду, як-от мета-перевірку парності

155
00:10:56,280 --> 00:11:01,440
для виявлення 2-бітових помилок, але ідея полягає в тому, що майже

156
00:11:01,440 --> 00:11:05,080
вся основна логіка нашої схеми зводиться до єдиного скорочення XOR.

157
00:11:05,080 --> 00:11:10,600
Тепер, залежно від вашого комфорту з двійковими кодами та XOR та програмним забезпеченням загалом,

158
00:11:10,600 --> 00:11:15,880
ви можете або вважати цю перспективу трохи заплутаною, або настільки більш елегантною та простою,

159
00:11:15,880 --> 00:11:19,320
що ви дивуєтеся, чому ми не почали з неї з самого початку -іди.

160
00:11:19,320 --> 00:11:22,880
Грубо кажучи, про перспективу множинної перевірки парності легше подумати, якщо реалізовувати

161
00:11:22,880 --> 00:11:27,560
коди Хеммінга в апаратному забезпеченні дуже безпосередньо, а про перспективу XOR

162
00:11:27,560 --> 00:11:31,380
найпростіше подумати, роблячи це в програмному забезпеченні, на більш високому рівні.

163
00:11:31,380 --> 00:11:35,640
Перший з них найлегше зробити вручну, і я думаю, що він краще справляється

164
00:11:35,640 --> 00:11:40,720
з прищепленням основної інтуїції, яка лежить в основі всього цього, а саме того,

165
00:11:40,720 --> 00:11:46,840
що інформація, необхідна для пошуку однієї помилки, пов’язана з журналом розміру блоку. ,

166
00:11:46,840 --> 00:11:51,020
або іншими словами, він зростає по одному біту, коли розмір блоку подвоюється.

167
00:11:51,020 --> 00:11:55,440
Релевантним фактом тут є те, що ця інформація

168
00:11:55,440 --> 00:11:56,440
безпосередньо відповідає тому, скільки резервування нам потрібно.

169
00:11:56,440 --> 00:12:00,320
Це насправді суперечить реагування більшості людей на колінах, коли вони вперше

170
00:12:00,320 --> 00:12:05,280
думають про те, щоб зробити повідомлення стійким до помилок, де зазвичай

171
00:12:05,280 --> 00:12:07,520
скопіювати все повідомлення є першим інстинктом, який спадає на думку.

172
00:12:07,520 --> 00:12:11,120
І, до речі, є цілий інший спосіб, у який ви іноді бачите

173
00:12:11,120 --> 00:12:14,800
представлені коди Хеммінга, коли ви множите повідомлення на одну велику матрицю.

174
00:12:14,800 --> 00:12:18,580
Це начебто добре, тому що це пов’язує його з більш широкою сім’єю лінійних кодів, але я

175
00:12:18,580 --> 00:12:25,160
думаю, що це майже не дає інтуїції щодо того, звідки він походить або як він масштабується.

176
00:12:25,160 --> 00:12:29,340
Говорячи про масштабування, ви можете помітити, що ефективність цієї

177
00:12:29,340 --> 00:12:32,200
схеми стає лише кращою, коли ми збільшуємо розмір блоку.

178
00:12:32,200 --> 00:12:40,560
Наприклад, ми бачили, що з 256 бітами ви використовуєте лише 3%

179
00:12:40,560 --> 00:12:43,480
цього простору для резервування, і з цього моменту все стає краще.

180
00:12:43,480 --> 00:12:49,040
Оскільки кількість бітів парності зростає один за одним, розмір блоку продовжує подвоюватися.

181
00:12:49,040 --> 00:12:53,840
І якщо ви доведете це до крайності, у вас може бути

182
00:12:53,840 --> 00:12:58,800
блок, скажімо, з мільйоном біт, де ви б буквально відтворювали 20

183
00:12:58,800 --> 00:13:00,800
запитань із перевіркою парності, і він використовує лише 21 біт парності.

184
00:13:00,800 --> 00:13:05,760
І якщо ви відступите назад, щоб подумати про перегляд мільйона

185
00:13:05,760 --> 00:13:08,640
бітів і пошук однієї помилки, це справді виглядає божевільним.

186
00:13:08,640 --> 00:13:12,680
Проблема, звісно, полягає в тому, що з більшим блоком зростає ймовірність побачити більше

187
00:13:12,680 --> 00:13:18,360
однієї або двох бітових помилок, а коди Хеммінга не обробляють нічого, крім цього.

188
00:13:18,360 --> 00:13:22,020
Тож на практиці вам потрібно знайти правильний розмір, щоб ймовірність

189
00:13:22,020 --> 00:13:25,520
занадто великої кількості перевертань бітів не була надто високою.

190
00:13:26,520 --> 00:13:30,920
Крім того, на практиці помилки, як правило, виникають невеликими пакетами, які повністю знищують один блок,

191
00:13:30,920 --> 00:13:35,680
тому одна з поширених тактик, щоб допомогти розподілити сплеск помилок між багатьма різними блоками, полягає

192
00:13:35,680 --> 00:13:41,720
в тому, щоб переплести ці блоки, як це, перш ніж вони будуть розіслано або збережено.

193
00:13:45,480 --> 00:13:49,920
Знову ж таки, багато чого з цього стає абсолютно спірним через більш сучасні коди,

194
00:13:49,920 --> 00:13:55,060
як-от набагато частіше використовуваний алгоритм Ріда-Соломона, який особливо добре обробляє пакетні помилки, і його

195
00:13:55,100 --> 00:13:59,580
можна налаштувати так, щоб бути стійким до більшої кількості помилок на блок. .

196
00:13:59,580 --> 00:14:03,000
Але це тема іншого разу.

197
00:14:03,000 --> 00:14:07,660
У своїй книзі «Мистецтво займатися наукою та технікою» Хеммінг надзвичайно відверто

198
00:14:07,660 --> 00:14:10,700
розповідає про те, наскільки звивистим було його відкриття цього коду.

199
00:14:10,700 --> 00:14:15,180
Спочатку він випробував усілякі різні схеми, що передбачають організацію бітів у

200
00:14:15,180 --> 00:14:18,420
частини решітки вищого виміру та такі дивні речі, як ця.

201
00:14:18,420 --> 00:14:22,520
Ідея про те, що можна змусити перевірку парності конспірувати таким

202
00:14:22,520 --> 00:14:26,360
чином, щоб визначити місце помилки, прийшла до Геммінга лише тоді,

203
00:14:26,360 --> 00:14:30,800
коли він відступив після купи інших аналізів і запитав: гаразд,

204
00:14:30,800 --> 00:14:32,860
що є найефективнішим, що я можу можливо бути про це?

205
00:14:32,860 --> 00:14:36,760
Він також був відвертим, наскільки важливо, щоб він уже думав про перевірку

206
00:14:36,760 --> 00:14:42,040
парності, яка була б набагато менш поширеною в 1940-х роках, ніж сьогодні.

207
00:14:42,040 --> 00:14:46,040
У цій книзі він півдюжини разів посилається на

208
00:14:46,040 --> 00:14:49,640
цитату Луї Пастера: удача сприяє підготовленому розуму.

209
00:14:49,640 --> 00:14:55,120
Розумні ідеї часто виглядають оманливо простими, тому їх легко недооцінити.

210
00:14:55,120 --> 00:14:59,680
Наразі я щиро сподіваюся, що коди Хеммінга або

211
00:14:59,680 --> 00:15:01,820
принаймні можливість таких кодів здаються вам майже очевидними.

212
00:15:01,820 --> 00:15:05,440
Але ви не повинні обманювати себе, думаючи, що вони

213
00:15:05,440 --> 00:15:08,000
насправді очевидні, тому що це точно не так.

214
00:15:08,000 --> 00:15:12,080
Однією з причин того, що розумні ідеї виглядають оманливо легко, є

215
00:15:12,080 --> 00:15:17,360
те, що ми завжди бачимо лише кінцевий результат, очищаємо те, що

216
00:15:17,360 --> 00:15:22,400
було брудним, ніколи не згадуємо всі неправильні повороти, недооцінюючи, наскільки величезним

217
00:15:22,400 --> 00:15:23,980
є простір досліджуваних можливостей на початку проблеми. процес вирішення, все це.

218
00:15:23,980 --> 00:15:25,280
Але в цілому це вірно.

219
00:15:25,280 --> 00:15:29,880
Я думаю, що для деяких особливих винаходів є

220
00:15:29,880 --> 00:15:31,040
друга, глибша причина, чому ми їх недооцінюємо.

221
00:15:31,040 --> 00:15:35,040
Розуміння інформації в термінах бітів справді об’єдналося в повну теорію лише до

222
00:15:35,040 --> 00:15:39,400
1948 року, коли Клод Шеннон опублікував фундаментальну статтю з теорії інформації.

223
00:15:39,400 --> 00:15:43,400
Це практично збігалося з тим, коли Хеммінг розробив свій алгоритм.

224
00:15:43,440 --> 00:15:47,300
Це був той самий основоположний документ, який показав, у певному

225
00:15:47,300 --> 00:15:52,080
сенсі, що ефективне виправлення помилок завжди можливе, незалежно від

226
00:15:52,080 --> 00:15:53,920
того, наскільки висока ймовірність перевертань бітів, принаймні в теорії.

227
00:15:53,920 --> 00:15:58,120
Шеннон і Хеммінг, до речі, ділилися офісом у Bell Labs, незважаючи на те,

228
00:15:58,120 --> 00:16:02,400
що працювали над дуже різними речами, що навряд чи здається тут випадковим.

229
00:16:02,400 --> 00:16:06,960
Перемотуємо вперед на кілька десятиліть, і сьогодні багато з нас настільки занурені в роздуми

230
00:16:06,960 --> 00:16:13,080
про біти та інформацію, що легко не помітити, наскільки відмінним був цей спосіб мислення.

231
00:16:13,080 --> 00:16:17,920
За іронією долі, ідеї, які найглибше формують уявлення майбутнього покоління,

232
00:16:17,920 --> 00:16:22,640
зрештою виглядатимуть це майбутнє покоління простішим, ніж воно є насправді.

