1
00:00:00,000 --> 00:00:03,120
আমি অনুমান করছি যে এখানে সবাই পার্ট 1 থেকে আসছে।

2
00:00:03,120 --> 00:00:06,920
আমরা হ্যামিং কোড সম্পর্কে কথা বলছিলাম, ডেটার একটি ব্লক তৈরি করার একটি উপায়

3
00:00:06,920 --> 00:00:11,640
যেখানে বেশিরভাগ বিট একটি অর্থপূর্ণ বার্তা বহন করে, যখন কয়েকটি অন্য এক ধরণের

4
00:00:11,640 --> 00:00:15,800
অপ্রয়োজনীয়তা হিসাবে কাজ করে, এমনভাবে যাতে কোনও বিট ফ্লিপ হয়ে যায়, হয় একটি

5
00:00:15,800 --> 00:00:20,560
বার্তা। বিট বা রিডানডেন্সি বিট, এই ব্লকের যেকোনো কিছু, একজন রিসিভার শনাক্ত করতে

6
00:00:20,560 --> 00:00:21,920
সক্ষম হবে যে একটি ত্রুটি ছিল এবং কীভাবে এটি ঠিক করা যায়।

7
00:00:21,920 --> 00:00:25,900
সেখানে উপস্থাপিত মূল ধারণাটি ছিল কিভাবে একাধিক প্যারিটি চেক ব্যবহার

8
00:00:25,900 --> 00:00:29,800
করে বাইনারি অনুসন্ধানের জন্য আপনার ত্রুটির দিকে যেতে হবে।

9
00:00:29,800 --> 00:00:33,920
সেই ভিডিওতে লক্ষ্য ছিল হ্যামিং কোডগুলিকে যতটা

10
00:00:33,920 --> 00:00:35,420
সম্ভব হ্যান্ড-অন এবং পুনরাবিষ্কারযোগ্য মনে করা।

11
00:00:35,420 --> 00:00:40,040
কিন্তু আপনি যখন সফ্টওয়্যার বা হার্ডওয়্যারে বাস্তবিকই এটি বাস্তবায়নের কথা ভাবতে শুরু

12
00:00:40,040 --> 00:00:44,120
করেন, সেই ফ্রেমিং আসলে এই কোডগুলি কতটা মার্জিত তা বোঝা যায়।

13
00:00:44,120 --> 00:00:47,620
আপনি ভাবতে পারেন যে আপনাকে এমন একটি অ্যালগরিদম লিখতে হবে যা

14
00:00:47,620 --> 00:00:52,320
সমস্ত সম্ভাব্য ত্রুটির অবস্থানের ট্র্যাক রাখে এবং প্রতিটি চেকের সাথে সেই

15
00:00:52,320 --> 00:00:54,160
গ্রুপটিকে অর্ধেক করে দেয়, তবে এটি আসলে তার চেয়ে সহজ উপায়।

16
00:00:54,160 --> 00:00:58,720
আপনি যদি শেষ ভিডিওতে আমরা যে চারটি প্যারিটি চেকের উত্তরগুলি পড়েছিলাম, হ্যাঁ এবং না-এর

17
00:00:58,760 --> 00:01:04,800
পরিবর্তে 1s এবং 0s হিসাবে, এটি আক্ষরিক অর্থে বাইনারিতে ত্রুটির অবস্থানটি বানান করে।

18
00:01:04,800 --> 00:01:10,160
উদাহরণস্বরূপ, বাইনারিতে 7 নম্বরটি 0111-এর মতো দেখায়, মূলত

19
00:01:10,160 --> 00:01:12,640
বলছে যে এটি 4 যোগ 2 যোগ 1।

20
00:01:12,640 --> 00:01:17,960
এবং লক্ষ্য করুন যেখানে অবস্থান 7 বসে, এটি আমাদের সমতা গোষ্ঠীর

21
00:01:17,960 --> 00:01:22,280
প্রথমটিকে প্রভাবিত করে, এবং দ্বিতীয়টি এবং তৃতীয়টি, কিন্তু শেষ নয়।

22
00:01:22,280 --> 00:01:26,560
সুতরাং নীচে থেকে উপরে এই চারটি চেকের

23
00:01:26,560 --> 00:01:28,000
ফলাফল পড়া প্রকৃতপক্ষে ত্রুটির অবস্থানটি বানান করে।

24
00:01:28,520 --> 00:01:32,240
উদাহরণ 7 সম্পর্কে বিশেষ কিছু নেই, এটি সাধারণভাবে কাজ করে, এবং

25
00:01:32,240 --> 00:01:37,440
এটি হার্ডওয়্যারে পুরো স্কিমটি বাস্তবায়নের যুক্তিকে চমকপ্রদভাবে সহজ করে তোলে।

26
00:01:37,440 --> 00:01:43,380
এখন আপনি যদি দেখতে চান কেন এই জাদুটি ঘটে, তাহলে আমাদের

27
00:01:43,380 --> 00:01:48,480
অবস্থানের জন্য এই 16টি সূচক লেবেল নিন, তবে সেগুলিকে বেস 10-এ

28
00:01:48,480 --> 00:01:50,720
না লিখে, আসুন সেগুলিকে 0000 থেকে 1111 পর্যন্ত বাইনারিতে লিখি।

29
00:01:50,720 --> 00:01:55,880
যেহেতু আমরা এই বাইনারি লেবেলগুলিকে তাদের বাক্সে আবার রাখি, আমাকে জোর দিয়ে

30
00:01:56,080 --> 00:01:58,440
বলতে দিন যে তারা আসলে যে ডেটা পাঠানো হচ্ছে তার থেকে আলাদা।

31
00:01:58,440 --> 00:02:02,200
এগুলি আপনাকে এবং আমাকে বুঝতে সাহায্য করার জন্য একটি ধারণাগত লেবেল

32
00:02:02,200 --> 00:02:04,200
ছাড়া আর কিছুই নয় যে চারটি সমতা গোষ্ঠী কোথা থেকে এসেছে।

33
00:02:04,200 --> 00:02:08,840
আমরা যা কিছু দেখছি তা বাইনারিতে বর্ণনা করার কমনীয়তা হয়তো বাইনারিতে বর্ণনা

34
00:02:08,840 --> 00:02:13,160
করা হচ্ছে এমন সব কিছু থাকার বিভ্রান্তির দ্বারা হ্রাস করা হয়েছে।

35
00:02:13,160 --> 00:02:15,040
এটা মূল্য, যদিও.

36
00:02:15,040 --> 00:02:20,740
এই সমস্ত লেবেলের শেষ বিটটিতে আপনার মনোযোগ কেন্দ্রীভূত করুন এবং

37
00:02:20,740 --> 00:02:24,280
তারপর সেই অবস্থানগুলিকে হাইলাইট করুন যেখানে সেই চূড়ান্ত বিটটি 1।

38
00:02:24,280 --> 00:02:28,800
আমরা কি পেতে আমাদের চার প্যারিটি গ্রুপের প্রথম, যার মানে আপনি

39
00:02:28,800 --> 00:02:34,480
যে প্রথম চেক ব্যাখ্যা করতে পারেন জিজ্ঞাসা হিসাবে, আরে, যদি

40
00:02:34,480 --> 00:02:36,680
একটি ত্রুটি আছে, যে ত্রুটির অবস্থানে চূড়ান্ত বিট একটি 1?

41
00:02:36,680 --> 00:02:42,600
একইভাবে, আপনি যদি সেকেন্ড টু লাস্ট বিটের উপর ফোকাস করেন এবং সমস্ত পজিশন

42
00:02:42,600 --> 00:02:47,040
হাইলাইট করেন যেখানে সেটি 1, আপনি আমাদের স্কিম থেকে দ্বিতীয় প্যারিটি গ্রুপ পাবেন।

43
00:02:47,040 --> 00:02:51,960
অন্য কথায়, যে দ্বিতীয় চেক জিজ্ঞাসা করা হয়, আরে, আমাকে আবার,

44
00:02:51,960 --> 00:02:56,160
যদি একটি ত্রুটি আছে, যে অবস্থানের শেষ বিট দ্বিতীয় একটি 1?

45
00:02:56,160 --> 00:02:57,160
ইত্যাদি।

46
00:02:57,160 --> 00:03:03,320
তৃতীয় প্যারিটি চেক প্রতিটি অবস্থানকে কভার করে যার তৃতীয় থেকে শেষ বিট চালু আছে

47
00:03:03,320 --> 00:03:10,120
এবং শেষটি শেষ আটটি অবস্থানকে কভার করে, যাদের সর্বোচ্চ ক্রম বিট হল 1।

48
00:03:10,120 --> 00:03:15,680
আমরা আগে যা করেছি তা এই চারটি প্রশ্নের উত্তর

49
00:03:15,680 --> 00:03:18,800
দেওয়ার মতোই, যা বাইনারিতে একটি অবস্থানের বানান করার মতোই।

50
00:03:19,800 --> 00:03:22,080
আমি আশা করি এটি দুটি জিনিস পরিষ্কার করে।

51
00:03:22,080 --> 00:03:27,140
প্রথমটি হল দুটির বড় শক্তির আকারগুলিকে ব্লক করার পদ্ধতিগতভাবে সাধারণীকরণ কিভাবে করা যায়।

52
00:03:27,140 --> 00:03:33,180
যদি প্রতিটি অবস্থান বর্ণনা করতে আরও বিট লাগে, যেমন 64টি দাগ বর্ণনা করতে ছয় বিট,

53
00:03:33,180 --> 00:03:38,640
তাহলে সেই বিটগুলির প্রতিটি আপনাকে প্যারিটি গ্রুপগুলির একটি দেয় যা আমাদের পরীক্ষা করতে হবে।

54
00:03:38,640 --> 00:03:42,060
আপনারা যারা ম্যাট পার্কারের সাথে দাবাবোর্ডের ধাঁধা দেখেছেন তারা

55
00:03:42,060 --> 00:03:43,400
হয়তো এই সব অতি পরিচিত মনে করতে পারেন।

56
00:03:43,400 --> 00:03:48,200
এটি একই মূল যুক্তি, কিন্তু একটি ভিন্ন সমস্যা সমাধান

57
00:03:48,200 --> 00:03:49,880
করে, এবং একটি 64-বর্গীয় দাবাবোর্ডে প্রয়োগ করা হয়।

58
00:03:49,880 --> 00:03:54,000
দ্বিতীয় জিনিসটি আমি আশা করি এটি পরিষ্কার করে দেয় যে কেন আমাদের প্যারিটি

59
00:03:54,000 --> 00:03:58,320
বিট দুটির শক্তি, উদাহরণস্বরূপ 1, 2, 4 এবং 8 অবস্থানে বসে আছে।

60
00:03:58,320 --> 00:04:03,640
এই হল সেই পজিশন যার বাইনারি রিপ্রেজেন্টেশন মাত্র একটি বিট চালু হয়েছে।

61
00:04:03,640 --> 00:04:09,000
এর মানে কি সেই প্যারিটি বিটগুলির প্রতিটি একটির ভিতরে

62
00:04:09,000 --> 00:04:12,640
বসে এবং চারটি প্যারিটি গ্রুপের মধ্যে একটি মাত্র।

63
00:04:12,640 --> 00:04:16,840
আপনি আরও বড় উদাহরণে এটি দেখতে পারেন, যেখানে আপনি যত বড়ই হোন

64
00:04:16,840 --> 00:04:25,920
না কেন, প্রতিটি প্যারিটি বিট সুবিধাজনকভাবে শুধুমাত্র একটি গ্রুপকে স্পর্শ করে।

65
00:04:25,920 --> 00:04:29,680
একবার আপনি বুঝতে পেরেছেন যে এই সমতা পরীক্ষাগুলি যেগুলির উপর আমরা আমাদের অনেক

66
00:04:29,680 --> 00:04:34,320
সময় ফোকাস করেছি তা বাইনারিতে একটি ত্রুটির অবস্থানটি বানান করার একটি চতুর

67
00:04:34,320 --> 00:04:37,880
উপায় ছাড়া আর কিছুই নয়, তাহলে আমরা হ্যামিং সম্পর্কে চিন্তা করার একটি

68
00:04:37,880 --> 00:04:42,160
ভিন্ন উপায়ের সাথে একটি সংযোগ আঁকতে পারি। কোড, যেটি তর্কাতীতভাবে অনেক সহজ

69
00:04:42,160 --> 00:04:43,880
এবং মার্জিত, এবং যা মূলত কোডের একটি লাইন দিয়ে লেখা যেতে পারে।

70
00:04:43,920 --> 00:04:46,200
এটি XOR ফাংশনের উপর ভিত্তি করে।

71
00:04:46,200 --> 00:04:50,960
XOR, আপনারা যারা জানেন না তাদের জন্য, একচেটিয়া বা।

72
00:04:50,960 --> 00:04:55,440
যখন আপনি দুটি বিটের XOR নেন, তখন এটি একটি 1 ফেরত দেয় যদি

73
00:04:55,440 --> 00:05:00,200
সেই বিটের যেকোনো একটি চালু থাকে, তবে উভয়টি চালু বা বন্ধ থাকলে নয়।

74
00:05:00,200 --> 00:05:03,760
ভিন্নভাবে বাক্যাংশ, এটি এই দুটি বিটের সমতা।

75
00:05:03,760 --> 00:05:07,840
একজন গণিত ব্যক্তি হিসাবে, আমি এটিকে সংযোজন মোড 2 হিসাবে ভাবতে পছন্দ করি।

76
00:05:07,840 --> 00:05:12,000
এছাড়াও আমরা সাধারণত দুটি ভিন্ন বিট স্ট্রিং এর XOR সম্পর্কে

77
00:05:12,040 --> 00:05:14,040
কথা বলি, যা মূলত এই উপাদানটি কম্পোনেন্ট দ্বারা করে।

78
00:05:14,040 --> 00:05:16,280
এটা যোগ মত, কিন্তু যেখানে আপনি বহন না.

79
00:05:16,280 --> 00:05:21,240
আবার, গাণিতিকভাবে আরো বেশি ঝোঁক এটিকে দুটি ভেক্টর যোগ করা

80
00:05:21,240 --> 00:05:23,520
এবং মোড 2 হ্রাস করার মত ভাবতে পছন্দ করতে পারে।

81
00:05:23,520 --> 00:05:28,720
আপনি যদি এখনই কিছু পাইথন খুলেন এবং দুটি পূর্ণসংখ্যার মধ্যে ক্যারেট অপারেশনটি

82
00:05:28,720 --> 00:05:35,400
প্রয়োগ করেন, তবে হুডের নীচে সেই সংখ্যাগুলির বিট উপস্থাপনা ছাড়া এটিই করছে।

83
00:05:35,400 --> 00:05:40,920
আপনার এবং আমার জন্য মূল বিষয় হল যে অনেকগুলি ভিন্ন

84
00:05:40,960 --> 00:05:45,960
বিট স্ট্রিংগুলির XOR নেওয়া কার্যকরভাবে একগুচ্ছ পৃথক গোষ্ঠীর প্যারোডিগুলি গণনা

85
00:05:45,960 --> 00:05:51,320
করার একটি উপায়, যেমন কলামগুলির সাথে, সমস্ত এককভাবে পড়ে যায়৷

86
00:05:51,320 --> 00:05:54,520
এটি আমাদের হ্যামিং কোড অ্যালগরিদম থেকে মাল্টিপল প্যারিটি চেক সম্পর্কে চিন্তা করার জন্য

87
00:05:54,520 --> 00:05:59,680
একটি সহজ উপায় দেয় কারণ সবগুলিকে এক একক অপারেশনে একসাথে প্যাকেজ করা হচ্ছে।

88
00:05:59,680 --> 00:06:02,800
যদিও প্রথম নজরে এটি খুব আলাদা দেখায়।

89
00:06:02,800 --> 00:06:08,360
বিশেষভাবে বাইনারিতে 16টি পজিশন লিখুন, যেমনটি আমাদের আগে ছিল, এবং এখন সেই

90
00:06:08,640 --> 00:06:14,800
পজিশনগুলিকে হাইলাইট করুন যেখানে মেসেজ বিটটি 1 এ চালু হয়েছে এবং

91
00:06:14,800 --> 00:06:19,400
তারপর এই পজিশনগুলিকে একটি বড় কলামে সংগ্রহ করুন এবং XOR নিন।

92
00:06:19,400 --> 00:06:23,480
আপনি সম্ভবত অনুমান করতে পারেন যে ফলস্বরূপ নীচে বসে থাকা 4টি

93
00:06:23,480 --> 00:06:27,480
বিটগুলি 4টি প্যারিটি চেকের মতো যা আমরা জেনেছি এবং পছন্দ

94
00:06:27,480 --> 00:06:32,720
করেছি, তবে ঠিক কেন তা নিয়ে ভাবতে একটু সময় নিন।

95
00:06:32,720 --> 00:06:37,880
উদাহরণস্বরূপ, এই শেষ কলামটি সেই সমস্ত অবস্থানগুলিকে গণনা করছে যার শেষ বিটটি হল

96
00:06:38,400 --> 00:06:42,400
1, কিন্তু আমরা ইতিমধ্যে শুধুমাত্র হাইলাইট করা অবস্থানগুলিতে সীমাবদ্ধ, তাই এটি কার্যকরভাবে

97
00:06:42,400 --> 00:06:45,960
গণনা করছে যে প্রথম প্যারিটি গ্রুপ থেকে কতগুলি হাইলাইট করা অবস্থান এসেছে।

98
00:06:45,960 --> 00:06:48,520
যে জানার জন্য?

99
00:06:48,520 --> 00:06:53,600
একইভাবে, পরবর্তী কলামটি দ্বিতীয় প্যারিটি গ্রুপে কতগুলি অবস্থান রয়েছে

100
00:06:53,600 --> 00:06:59,640
তা গণনা করে, যে অবস্থানগুলির দ্বিতীয় থেকে শেষ

101
00:06:59,640 --> 00:07:00,640
বিটটি 1, এবং যেগুলিকে হাইলাইট করা হয়েছে, ইত্যাদি।

102
00:07:00,640 --> 00:07:06,640
এটা সত্যিই দৃষ্টিকোণ একটি ছোট পরিবর্তন একই জিনিস আমরা করছি করছি.

103
00:07:07,640 --> 00:07:10,000
এবং তাই আপনি জানেন যে এটি এখান থেকে কোথায় যায়।

104
00:07:10,000 --> 00:07:14,400
যোগফল 0000 হবে তা নিশ্চিত করতে কিছু বিশেষ

105
00:07:14,400 --> 00:07:19,640
প্যারিটি বিট টগল করার জন্য প্রেরক দায়ী।

106
00:07:19,640 --> 00:07:23,600
এখন একবার আমাদের কাছে এটি এইরকম হয়ে গেলে, এটি আমাদেরকে চিন্তা করার একটি সত্যিই সুন্দর

107
00:07:23,600 --> 00:07:28,720
উপায় দেয় কেন নীচের এই চারটি ফলে বিটগুলি একটি ত্রুটির অবস্থানকে সরাসরি বানান করে।

108
00:07:28,720 --> 00:07:32,680
ধরা যাক এই ব্লকের কিছু অংশ 0 থেকে 1 থেকে টগল হয়ে গেছে।

109
00:07:32,720 --> 00:07:37,320
এর মানে হল যে সেই বিটের অবস্থানটি এখন মোট

110
00:07:37,320 --> 00:07:42,960
XOR-তে অন্তর্ভুক্ত হতে চলেছে, যা যোগফলকে 0 থেকে পরিবর্তন

111
00:07:42,960 --> 00:07:44,800
করে এই নতুন অন্তর্ভুক্ত মান, ত্রুটির অবস্থানের পরিবর্তে।

112
00:07:44,800 --> 00:07:48,800
সামান্য কম স্পষ্টতই, একই কথা সত্য যদি কোনো

113
00:07:48,800 --> 00:07:49,800
ত্রুটি থাকে যা 1 থেকে 0 পরিবর্তন করে।

114
00:07:49,800 --> 00:07:54,720
আপনি দেখতে পাচ্ছেন, আপনি যদি দুইবার একসাথে কিছুটা স্ট্রিং যোগ করেন, তবে এটি

115
00:07:54,720 --> 00:07:59,000
সেখানে না থাকার মতই, মূলত কারণ এই পৃথিবীতে 1 যোগ 1 সমান 0।

116
00:07:59,000 --> 00:08:03,720
সুতরাং মোট যোগফলের সাথে এই অবস্থানের একটি অনুলিপি যোগ

117
00:08:03,720 --> 00:08:05,400
করলে একই প্রভাব রয়েছে যেভাবে আমরা এটি স্থানান্তর করছি।

118
00:08:05,400 --> 00:08:10,080
এবং সেই প্রভাব, আবার, এখানে নীচের

119
00:08:10,080 --> 00:08:13,480
মোট ফলাফলটি ত্রুটির অবস্থানকে বানান করে।

120
00:08:13,480 --> 00:08:17,720
এটি কতটা মার্জিত তা বোঝাতে, আমি আগে উল্লেখ করেছি পাইথন কোডের

121
00:08:17,720 --> 00:08:22,120
একটি লাইন দেখাই, যা রিসিভারের প্রায় সমস্ত যুক্তি ক্যাপচার করবে।

122
00:08:22,120 --> 00:08:27,160
আমরা ডাটা ব্লকের অনুকরণের জন্য 16 1s এবং 0s এর একটি এলোমেলো অ্যারে

123
00:08:27,160 --> 00:08:31,160
তৈরি করে শুরু করব, এবং আমি এটির নাম বিট দেব, তবে অবশ্যই বাস্তবে

124
00:08:31,160 --> 00:08:36,160
এটি এমন কিছু হবে যা আমরা একজন প্রেরকের কাছ থেকে পাচ্ছি এবং পরিবর্তে

125
00:08:36,160 --> 00:08:38,600
এলোমেলো হওয়ায় এটি 5 প্যারিটি বিটের সাথে 11টি ডেটা বিট বহন করবে।

126
00:08:38,600 --> 00:08:43,160
যদি আমি ফাংশনটিকে গণনা বিট বলি, তবে এটি যা করে তা হল প্রতিটি বিটকে

127
00:08:43,160 --> 00:08:48,240
একটি সংশ্লিষ্ট সূচকের সাথে একত্রিত করে, এই ক্ষেত্রে 0 থেকে 15 পর্যন্ত চলছে।

128
00:08:48,240 --> 00:08:53,200
তাই যদি আমরা একটি তালিকা তৈরি করি যা এই সমস্ত জোড়ার উপর লুপ করে, যে

129
00:08:53,200 --> 00:08:59,160
জোড়াগুলি i এর মত দেখায়, এবং তারপরে আমরা শুধু i এর মান, শুধু সূচকটি বের

130
00:08:59,160 --> 00:09:01,920
করে ফেলি, ভাল এটি এত উত্তেজনাপূর্ণ নয়, আমরা 0 থেকে 15 সূচকগুলি ফিরে পাই। .

131
00:09:01,920 --> 00:09:07,520
কিন্তু যদি আমরা শর্ত যোগ করি যে এটি শুধুমাত্র যদি বিট করতে হয়, মানে সেই বিটটি যদি 1 হয়

132
00:09:07,520 --> 00:09:13,400
এবং 0 না হয়, তাহলে এটি শুধুমাত্র সেই অবস্থানগুলিকে বের করে দেয় যেখানে সংশ্লিষ্ট বিটটি চালু করা হয়েছে।

133
00:09:13,400 --> 00:09:20,320
এই ক্ষেত্রে মনে হচ্ছে সেই অবস্থানগুলি হল 0, 4, 6, 9, ইত্যাদি।

134
00:09:20,720 --> 00:09:24,640
আমরা যা চাই তা হল সেই সমস্ত পজিশন, বিটগুলির অবস্থানগুলি

135
00:09:24,640 --> 00:09:29,960
যেগুলি চালু করা হয়েছে, এবং তারপরে সেগুলিকে একসাথে সংগ্রহ করা।

136
00:09:29,960 --> 00:09:33,960
পাইথনে এটি করতে, আমাকে প্রথমে কয়েকটি সহায়ক ফাংশন আমদানি করতে দিন।

137
00:09:33,960 --> 00:09:39,140
এইভাবে আমরা এই তালিকায় reduce() কল করতে পারি এবং এটি কমাতে XOR ফাংশন ব্যবহার করতে পারি।

138
00:09:39,140 --> 00:09:44,840
এটি মূলত তালিকার মাধ্যমে তার পথ খায়, পথ ধরে XORs গ্রহণ করে।

139
00:09:44,840 --> 00:09:48,760
আপনি যদি চান, আপনি স্পষ্টভাবে XOR ফাংশনটি

140
00:09:48,800 --> 00:09:52,200
কোথাও থেকে আমদানি না করেই লিখতে পারেন।

141
00:09:52,200 --> 00:09:56,880
তাই এই মুহুর্তে এটা মনে হচ্ছে যদি আমরা আমাদের 16 বিটের এলোমেলো

142
00:09:56,880 --> 00:10:02,080
ব্লকে এটি করি, এটি 9 প্রদান করে, যার বাইনারি উপস্থাপনা 1001 আছে।

143
00:10:02,080 --> 00:10:05,960
আমরা এখানে এটি করব না, তবে আপনি একটি ফাংশন লিখতে পারেন যেখানে প্রেরক সেই বাইনারি

144
00:10:05,960 --> 00:10:11,560
উপস্থাপনা ব্যবহার করে প্রয়োজন অনুসারে চারটি প্যারিটি বিট সেট করে, শেষ পর্যন্ত এই ব্লকটিকে এমন

145
00:10:11,560 --> 00:10:16,200
একটি অবস্থায় নিয়ে আসে যেখানে বিটগুলির সম্পূর্ণ তালিকায় কোডের এই লাইনটি চালু হয়। একটি 0

146
00:10:17,200 --> 00:10:20,200
এটি একটি ভালভাবে প্রস্তুত ব্লক হিসাবে বিবেচিত হবে।

147
00:10:20,200 --> 00:10:24,640
কি চমৎকার যে আমরা যদি এই তালিকার যেকোনো একটি বিট টগল করি, গোলমাল থেকে একটি এলোমেলো

148
00:10:24,640 --> 00:10:30,600
ত্রুটি অনুকরণ করে, তারপর যদি আপনি কোডের এই একই লাইনটি চালান, এটি সেই ত্রুটিটি প্রিন্ট করে।

149
00:10:30,600 --> 00:10:31,920
ঝরঝরে তাই না?

150
00:10:31,920 --> 00:10:37,200
আপনি নীল থেকে এই ব্লকটি পেতে পারেন, এটিতে এই একক লাইনটি চালান,

151
00:10:37,200 --> 00:10:42,920
এবং এটি স্বয়ংক্রিয়ভাবে একটি ত্রুটির অবস্থান বা 0 না থাকলে থুতু দেবে।

152
00:10:42,920 --> 00:10:45,520
এবং এখানে 16 আকার সম্পর্কে বিশেষ কিছু নেই।

153
00:10:45,520 --> 00:10:52,280
কোডের একই লাইন কাজ করবে যদি আপনার কাছে 256 বিটের একটি তালিকা থাকে।

154
00:10:52,280 --> 00:10:56,280
বলা বাহুল্য, এখানে লেখার জন্য আরও কোড আছে, যেমন 2-বিট ত্রুটি সনাক্ত

155
00:10:56,280 --> 00:11:01,440
করতে মেটা প্যারিটি চেক করা, কিন্তু ধারণাটি হল যে আমাদের স্কিম

156
00:11:01,440 --> 00:11:05,080
থেকে প্রায় সমস্ত মূল যুক্তি একটি একক XOR হ্রাসে নেমে আসে।

157
00:11:05,080 --> 00:11:10,600
এখন, বাইনারি এবং XORs এবং সাধারণভাবে সফ্টওয়্যারগুলির সাথে আপনার স্বাচ্ছন্দ্যের উপর নির্ভর করে,

158
00:11:10,600 --> 00:11:15,880
আপনি হয় এই দৃষ্টিকোণটিকে কিছুটা বিভ্রান্তিকর মনে করতে পারেন, বা এত বেশি মার্জিত

159
00:11:15,880 --> 00:11:19,320
এবং সহজ যে আপনি ভাবছেন কেন আমরা এটি থেকে শুরু করিনি। -যাওয়া.

160
00:11:19,320 --> 00:11:22,880
ঢিলেঢালাভাবে বলতে গেলে, হার্ডওয়্যারে হ্যামিং কোডগুলিকে সরাসরি প্রয়োগ করার সময় মাল্টিপল

161
00:11:22,880 --> 00:11:27,560
প্যারিটি চেক দৃষ্টিকোণটি সম্পর্কে চিন্তা করা সহজ, এবং XOR দৃষ্টিকোণটি সফ্টওয়্যারে

162
00:11:27,560 --> 00:11:31,380
করার সময় চিন্তা করা সবচেয়ে সহজ, উচ্চ স্তরের ধরণের থেকে।

163
00:11:31,380 --> 00:11:35,640
প্রথমটি আসলে হাত দ্বারা করা সবচেয়ে সহজ, এবং আমি মনে করি এটি এই সমস্তটির

164
00:11:35,640 --> 00:11:40,720
অন্তর্নিহিত মূল অন্তর্জ্ঞান স্থাপনের জন্য একটি ভাল কাজ করে, যা হল যে একটি একক

165
00:11:40,720 --> 00:11:46,840
ত্রুটি সনাক্ত করার জন্য প্রয়োজনীয় তথ্য ব্লকের আকারের লগের সাথে সম্পর্কিত। , বা অন্য

166
00:11:46,840 --> 00:11:51,020
কথায়, ব্লকের আকার দ্বিগুণ হওয়ার সাথে সাথে এটি এক সময়ে এক বিট বৃদ্ধি পায়।

167
00:11:51,020 --> 00:11:55,440
এখানে প্রাসঙ্গিক সত্য হল যে তথ্যটি সরাসরি আমাদের

168
00:11:55,440 --> 00:11:56,440
কতটা অপ্রয়োজনীয়তার প্রয়োজন তার সাথে মিলে যায়।

169
00:11:56,440 --> 00:12:00,320
এটি আসলেই বেশিরভাগ লোকের হাঁটু-ঝাঁকুনির প্রতিক্রিয়ার বিরুদ্ধে চলে যখন তারা প্রথমে

170
00:12:00,320 --> 00:12:05,280
একটি বার্তাকে ত্রুটির প্রতি স্থিতিস্থাপক করার বিষয়ে চিন্তা করে, যেখানে

171
00:12:05,280 --> 00:12:07,520
সাধারণত পুরো বার্তাটি অনুলিপি করা প্রথম প্রবৃত্তি যা মনে আসে।

172
00:12:07,520 --> 00:12:11,120
এবং তারপরে, যাইহোক, এই সম্পূর্ণ অন্য উপায়ে আপনি মাঝে মাঝে হ্যামিং কোডগুলি

173
00:12:11,120 --> 00:12:14,800
উপস্থাপিত দেখতে পান, যেখানে আপনি একটি বড় ম্যাট্রিক্স দ্বারা বার্তাকে গুণ করেন।

174
00:12:14,800 --> 00:12:18,580
এটি একধরনের চমৎকার কারণ এটি রৈখিক কোডের বিস্তৃত পরিবারের সাথে সম্পর্কিত, তবে আমি মনে করি এটি

175
00:12:18,580 --> 00:12:25,160
কোথা থেকে আসে বা এটি কীভাবে স্কেল করে সে সম্পর্কে প্রায় কোনও অন্তর্দৃষ্টি দেয় না।

176
00:12:25,160 --> 00:12:29,340
এবং স্কেলিং এর কথা বলতে গেলে, আপনি লক্ষ্য করতে পারেন যে এই স্কিমের

177
00:12:29,340 --> 00:12:32,200
কার্যকারিতা কেবলমাত্র আমরা ব্লকের আকার বৃদ্ধি করার সাথে সাথে আরও ভাল হয়ে যায়।

178
00:12:32,200 --> 00:12:40,560
উদাহরণস্বরূপ, আমরা দেখেছি যে 256 বিটের সাথে, আপনি অপ্রয়োজনীয়তার জন্য সেই স্থানের

179
00:12:40,560 --> 00:12:43,480
মাত্র 3% ব্যবহার করছেন এবং এটি সেখান থেকে আরও ভাল হতে থাকে।

180
00:12:43,480 --> 00:12:49,040
একের পর এক প্যারিটি বিটের সংখ্যা বাড়ার সাথে সাথে ব্লকের আকার দ্বিগুণ হতে থাকে।

181
00:12:49,040 --> 00:12:53,840
এবং যদি আপনি এটিকে চরম পর্যায়ে নিয়ে যান, আপনার কাছে এক মিলিয়ন বিট

182
00:12:53,840 --> 00:12:58,800
সহ একটি ব্লক থাকতে পারে, যেখানে আপনি আক্ষরিক অর্থে আপনার প্যারিটি চেকের সাথে

183
00:12:58,800 --> 00:13:00,800
20টি প্রশ্ন খেলতে পারবেন এবং এটি শুধুমাত্র 21টি প্যারিটি বিট ব্যবহার করে।

184
00:13:00,800 --> 00:13:05,760
এবং যদি আপনি এক মিলিয়ন বিট দেখার এবং একটি একক ত্রুটি সনাক্ত করার

185
00:13:05,760 --> 00:13:08,640
বিষয়ে চিন্তা করার জন্য ফিরে যান, তবে এটি সত্যিকারের পাগল বোধ করে।

186
00:13:08,640 --> 00:13:12,680
সমস্যাটি, অবশ্যই, একটি বড় ব্লকের সাথে, এক বা দুটি বিটের বেশি ত্রুটি দেখার

187
00:13:12,680 --> 00:13:18,360
সম্ভাবনা বেড়ে যায় এবং হ্যামিং কোডগুলি এর বাইরে কিছু পরিচালনা করে না।

188
00:13:18,360 --> 00:13:22,020
তাই অনুশীলনে, আপনি যা চান তা হল সঠিক আকার খুঁজে বের

189
00:13:22,020 --> 00:13:25,520
করা যাতে অনেকগুলি বিট ফ্লিপ হওয়ার সম্ভাবনা খুব বেশি না হয়।

190
00:13:26,520 --> 00:13:30,920
এছাড়াও, অভ্যাসগতভাবে, ত্রুটিগুলি সামান্য বিস্ফোরণে আসে, যা একটি একক ব্লককে সম্পূর্ণরূপে ধ্বংস করে

191
00:13:30,920 --> 00:13:35,680
দেয়, তাই বিভিন্ন ব্লক জুড়ে ত্রুটিগুলি ছড়িয়ে দিতে সাহায্য করার জন্য একটি সাধারণ

192
00:13:35,680 --> 00:13:41,720
কৌশল হল ব্লকগুলিকে এইভাবে ইন্টারলেস করা, সেগুলি হওয়ার আগে পাঠানো বা সঞ্চিত।

193
00:13:45,480 --> 00:13:49,920
তারপরে আবার, এর অনেক কিছুকে আরও আধুনিক কোড দ্বারা সম্পূর্ণরূপে রেন্ডার করা হয়েছে, যেমন

194
00:13:49,920 --> 00:13:55,060
অনেক বেশি ব্যবহৃত রিড-সলোমন অ্যালগরিদম, যা বিস্ফোরিত ত্রুটিগুলি বিশেষভাবে ভালভাবে পরিচালনা করে এবং প্রতি

195
00:13:55,100 --> 00:13:59,580
ব্লকে আরও বেশি সংখ্যক ত্রুটির প্রতি স্থিতিস্থাপক হতে এটি টিউন করা যেতে পারে। .

196
00:13:59,580 --> 00:14:03,000
কিন্তু এটা অন্য সময়ের জন্য একটি বিষয়.

197
00:14:03,000 --> 00:14:07,660
তার দ্য আর্ট অফ ডুয়িং সায়েন্স অ্যান্ড ইঞ্জিনিয়ারিং বইয়ে, হ্যামিং এই

198
00:14:07,660 --> 00:14:10,700
কোডের তার আবিষ্কারটি কতটা অস্থির ছিল সে সম্পর্কে বিস্ময়করভাবে স্পষ্ট।

199
00:14:10,700 --> 00:14:15,180
তিনি প্রথমে একটি উচ্চমাত্রিক জালির অংশে বিটগুলিকে সংগঠিত করার সাথে জড়িত

200
00:14:15,180 --> 00:14:18,420
বিভিন্ন ধরণের স্কিম এবং এর মতো অদ্ভুত জিনিসগুলি চেষ্টা করেছিলেন।

201
00:14:18,420 --> 00:14:22,520
এই ধারণা যে প্যারিটি চেকগুলি এমনভাবে ষড়যন্ত্র করার জন্য সম্ভব হতে পারে

202
00:14:22,520 --> 00:14:26,360
যা একটি ত্রুটির অবস্থানকে বানান করে তখনই হ্যামিংয়ের কাছে এসেছিল যখন

203
00:14:26,360 --> 00:14:30,800
তিনি একগুচ্ছ অন্যান্য বিশ্লেষণের পরে পিছিয়ে পড়েছিলেন এবং জিজ্ঞাসা করেছিলেন, ঠিক আছে,

204
00:14:30,800 --> 00:14:32,860
আমি সবচেয়ে দক্ষ কোনটি করতে পারি? সম্ভবত এই সম্পর্কে হতে পারে?

205
00:14:32,860 --> 00:14:36,760
প্যারিটি চেকগুলি ইতিমধ্যেই তাঁর মাথায় ছিল কতটা গুরুত্বপূর্ণ সে সম্পর্কেও তিনি

206
00:14:36,760 --> 00:14:42,040
স্পষ্টবাদী ছিলেন, যা আজকের তুলনায় 1940 এর দশকে কম সাধারণ ছিল।

207
00:14:42,040 --> 00:14:46,040
এই বই জুড়ে প্রায় অর্ধ ডজন বার তিনি লুই পাস্তুরের

208
00:14:46,040 --> 00:14:49,640
উদ্ধৃতি উল্লেখ করেছেন, ভাগ্য একটি প্রস্তুত মনকে সমর্থন করে।

209
00:14:49,640 --> 00:14:55,120
চতুর ধারণাগুলি প্রায়শই পশ্চাৎদৃষ্টিতে প্রতারণামূলকভাবে সহজ দেখায়, যা তাদের কম মূল্যায়ন করা সহজ করে তোলে।

210
00:14:55,120 --> 00:14:59,680
এই মুহুর্তে আমার সৎ আশা হল হ্যামিং কোড, বা অন্তত

211
00:14:59,680 --> 00:15:01,820
এই ধরনের কোডগুলির সম্ভাবনা, আপনার কাছে প্রায় সুস্পষ্ট মনে হয়।

212
00:15:01,820 --> 00:15:05,440
কিন্তু আপনি নিজেকে বোকা বানানো উচিত নয় যে

213
00:15:05,440 --> 00:15:08,000
তারা আসলে সুস্পষ্ট, কারণ তারা অবশ্যই নয়।

214
00:15:08,000 --> 00:15:12,080
চতুর ধারণাগুলিকে প্রতারণামূলকভাবে সহজ দেখায় তার একটি কারণ হল যে আমরা কেবল

215
00:15:12,080 --> 00:15:17,360
চূড়ান্ত ফলাফলটি দেখতে পাই, যা অগোছালো ছিল তা পরিষ্কার করে, সমস্ত

216
00:15:17,360 --> 00:15:22,400
ভুল বাঁকগুলির কথা কখনও উল্লেখ করি না, একটি সমস্যার শুরুতে অন্বেষণযোগ্য

217
00:15:22,400 --> 00:15:23,980
সম্ভাবনার জায়গাটি কতটা বিস্তৃত তা আন্ডারসেলিং করি। সমাধান প্রক্রিয়া, যে সব.

218
00:15:23,980 --> 00:15:25,280
কিন্তু এটি সাধারণভাবে সত্য।

219
00:15:25,280 --> 00:15:29,880
আমি মনে করি কিছু বিশেষ উদ্ভাবনের জন্য, একটি দ্বিতীয়,

220
00:15:29,880 --> 00:15:31,040
গভীর কারণ রয়েছে যে আমরা তাদের কম মূল্যায়ন করি।

221
00:15:31,040 --> 00:15:35,040
তথ্য তত্ত্বের উপর ক্লদ শ্যাননের সেমিনাল পেপারের সাথে 1948 সালের মধ্যে

222
00:15:35,040 --> 00:15:39,400
বিটগুলির পরিপ্রেক্ষিতে তথ্যের চিন্তা সত্যিই একটি সম্পূর্ণ তত্ত্বে একত্রিত হয়েছিল।

223
00:15:39,400 --> 00:15:43,400
হ্যামিং যখন তার অ্যালগরিদম তৈরি করেছিলেন তখন এটি মূলত একই সাথে ছিল।

224
00:15:43,440 --> 00:15:47,300
এটি একই ভিত্তিগত কাগজ যা দেখিয়েছিল, একটি নির্দিষ্ট অর্থে,

225
00:15:47,300 --> 00:15:52,080
যে দক্ষ ত্রুটি সংশোধন সর্বদা সম্ভব, বিট ফ্লিপ হওয়ার

226
00:15:52,080 --> 00:15:53,920
সম্ভাবনা যতই উচ্চ হোক না কেন, অন্তত তত্ত্বে।

227
00:15:53,920 --> 00:15:58,120
শ্যানন এবং হ্যামিং, যাইহোক, বেল ল্যাবসে একটি অফিস ভাগ করেছেন, খুব ভিন্ন জিনিস

228
00:15:58,120 --> 00:16:02,400
নিয়ে কাজ করা সত্ত্বেও, যা এখানে খুব কমই কাকতালীয় বলে মনে হয়।

229
00:16:02,400 --> 00:16:06,960
বেশ কয়েক দশক ধরে দ্রুত এগিয়ে যাওয়া, এবং এই দিনগুলিতে, আমাদের মধ্যে অনেকেই বিট এবং

230
00:16:06,960 --> 00:16:13,080
তথ্য সম্পর্কে এতটাই নিমগ্ন যে চিন্তার এই পদ্ধতিটি কতটা স্বতন্ত্র ছিল তা উপেক্ষা করা সহজ।

231
00:16:13,080 --> 00:16:17,920
হাস্যকরভাবে, যে ধারণাগুলি ভবিষ্যত প্রজন্মের চিন্তাভাবনাগুলিকে সবচেয়ে গভীরভাবে আকার

232
00:16:17,920 --> 00:16:22,640
দেয় সেগুলি ভবিষ্যত প্রজন্মের কাছে সত্যিকারের চেয়ে সহজতর হবে।

