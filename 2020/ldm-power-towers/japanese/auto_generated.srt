1
00:00:00,000 --> 00:00:06,000
🎵音楽🎵 おそらくこれ

2
00:00:09,200 --> 00:00:11,200
が聞こえるでしょう。

3
00:00:11,200 --> 00:00:14,200
隣の家で工事が行われているんですが

4
00:00:14,200 --> 00:00:17,200
、ここ一時間か二時間くらいの間、

5
00:00:17,200 --> 00:00:21,700
ここが工事中の地面を砕く部分のよう

6
00:00:21,700 --> 00:00:24,200
で、家全体が揺れていました。続け

7
00:00:24,200 --> 00:00:27,200
れば聞こえるようになるでしょう。

8
00:00:27,200 --> 00:00:28,500
今も続いていると思います。

9
00:00:28,500 --> 00:00:31,500
興味があるなら、それがその音です。

10
00:00:31,500 --> 00:00:34,500
さて、あなたがたった今答えた導入の質問の 1 つで、実際に今

11
00:00:34,500 --> 00:00:39,500
日私たちが話そうとしていることについて考える準備が整います。

12
00:00:39,500 --> 00:00:43,000
この質問を書いて、よく考えてみると、とても笑ってしまいました。

13
00:00:43,000 --> 00:00:47,500
これは、x がこのボックスにほとんどの人が入力する数字で

14
00:00:47,500 --> 00:00:49,500
あるかどうか、x に 2 は何になるかを尋ねています。

15
00:00:49,500 --> 00:00:51,500
そして、それはとても混乱することです、なぜなら、多くの人が 1 に入

16
00:00:51,500 --> 00:00:54,500
力しているなら、私は 2 に入力すべきだ、でもみんながそれを考える

17
00:00:54,500 --> 00:00:56,500
だろうから、私は 4 に入力すべきかもしれない、でも誰もがそれについ

18
00:00:56,500 --> 00:00:59,500
て考える、ということを考えるからです。 4 に対して 2、あるいは

19
00:00:59,500 --> 00:01:02,500
それに対して 2、あるいはそれに対して 2 を行う必要があります。

20
00:01:02,500 --> 00:01:06,500
そして、もしそれが完璧な論理学者でいっぱいの部屋だったら、あなたは無限に吹き飛ばさ

21
00:01:06,500 --> 00:01:10,500
れてしまうだろうが、人間は論理学者ではない、そして客観的に正しい答えがいくつかある

22
00:01:10,500 --> 00:01:13,500
、そして私たちはこの文脈で客観的に正しい答えが何であるかを見てみることができる。

23
00:01:13,500 --> 00:01:18,500
そして、最も多くの人が 2 を入力したように見えます。つ

24
00:01:18,500 --> 00:01:22,500
まり、4 を入力した人が完全に正しいことを意味します。

25
00:01:22,500 --> 00:01:26,500
しかし、完璧な論理学者が考え抜くことを想像し、2 対

26
00:01:26,500 --> 00:01:29,500
2 対 2 対 2 で勝負するゲームでは、今日の

27
00:01:29,500 --> 00:01:31,500
ビデオのテーマである演算について考え始めることになり

28
00:01:31,500 --> 00:01:35,500
ます。これは通常、学校では教えられません。おそらく

29
00:01:35,500 --> 00:01:39,500
、他のものと同じレベルの応用力がないからでしょう。

30
00:01:39,500 --> 00:01:42,500
しかし、ご覧のとおり、それを使って始められるパズルがいくつかあります

31
00:01:42,500 --> 00:01:46,500
。これらは、用語が実際に何を意味するのか、そして自分の操作が正しいの

32
00:01:46,500 --> 00:01:50,500
かどうかを真剣に考えるという非常に重要な問題解決スキルとアイデアを確

33
00:01:50,500 --> 00:01:54,500
実に引き出します。象徴的にやっていると意味があるように見えますが、実

34
00:01:54,500 --> 00:01:58,500
際に何が起こっているのかをよく考えてみると、実際に意味があるのです。

35
00:01:58,500 --> 00:02:03,500
この演算はテトレーションと呼ばれます。これを考える方法として、私

36
00:02:03,500 --> 00:02:06,500
たちは皆、足し算について最初に学びます。2 つの数値を加算する方

37
00:02:06,500 --> 00:02:11,500
法と、最初に目にする乗算について学びます。追加を繰り返します。

38
00:02:11,500 --> 00:02:15,500
A 掛ける B は、A プラス A プラス A プラス A、B の異なる倍です。

39
00:02:15,500 --> 00:02:19,500
そして、掛け算を繰り返すとどうなるかというと、A

40
00:02:19,500 --> 00:02:23,500
回 A 回 A 回 A 回、B 回を繰り返し

41
00:02:23,500 --> 00:02:27,500
て、A の B 乗と書きます。これが累乗です。

42
00:02:27,500 --> 00:02:30,500
さて、このプロセスをさらに一歩進めて、累乗を繰り返

43
00:02:30,500 --> 00:02:33,500
すとどうなるかというと、これには名前があります。

44
00:02:33,500 --> 00:02:36,500
それをテトレーションと呼びます。Tetra はギリシャ語の 4 に由来します。これは

45
00:02:36,500 --> 00:02:43,500
、前の操作を繰り返し適用するこのプロセスの第 4 段階のようなものだからです。

46
00:02:43,500 --> 00:02:46,500
そしてもちろん、掛け算などの文脈では、単に数を数え

47
00:02:46,500 --> 00:02:49,500
るという枠を超えて、このアイデアを拡張しました。

48
00:02:49,500 --> 00:02:52,500
したがって、ここでは、これは B が計数数値である場合にのみ意味を持ち

49
00:02:52,500 --> 00:02:56,500
ますが、pi に E を掛けたり、2 に 1 を加えたものに i を加

50
00:02:56,500 --> 00:03:00,500
えた平方根を求めることができる複素数値を取得したりすることも行います。

51
00:03:00,500 --> 00:03:05,500
したがって、私たちはそれを繰り返し足し算を超えて拡張してきましたが、それがその

52
00:03:05,500 --> 00:03:07,500
起源のようなものであり、私たちがそれについて考え始めることがよくある方法です。

53
00:03:07,500 --> 00:03:11,500
同様に、非常に有名なことですが、このシリーズで私たちがよく話してきたこ

54
00:03:11,500 --> 00:03:16,500
との 1 つは、古典的なオイラーの公式の例でべき乗を拡張することです。

55
00:03:16,500 --> 00:03:22,500
しかし今のところ、このテトレーションを整数回繰り返すという観点から考えてみましょう。

56
00:03:22,500 --> 00:03:30,500
聞こえますか？誓います、私たちは小川のいずれかで地面を砕く日が来

57
00:03:30,500 --> 00:03:31,500
るという考えをとても恐れていましたが、ここに来ました。

58
00:03:31,500 --> 00:03:36,500
さて、用語をもう少し明確に定義しないと、これは実際にはあいま

59
00:03:36,500 --> 00:03:40,500
いになります。累乗は結合的ではないためです。つまり、これらの

60
00:03:40,500 --> 00:03:45,500
操作を実行して折りたたみを開始する順序が重要になるからです。

61
00:03:45,500 --> 00:03:49,500
なぜなら、左から右に向かっていく場合、これを 2 の 2 乗として書いたとします

62
00:03:49,500 --> 00:03:53,500
。そして、それを 2 乗して、その結果を 2 乗することを考えます。そうすると

63
00:03:53,500 --> 00:03:58,500
、次のように考える場合とは異なる数値が得られます。上から下へ向かっていきます。

64
00:03:58,500 --> 00:04:02,500
最初に評価するのがトップの 2 の 2 乗で、次に

65
00:04:02,500 --> 00:04:07,500
次の評価に進むと、その理由を考えることができます。

66
00:04:07,500 --> 00:04:12,500
ここで、下から折りたたむ場合、その下の部分は 4 なので、それを 2 乗し、それを 2 乗します。

67
00:04:12,500 --> 00:04:18,500
4 の 2 乗は 16 なので、それを 2 乗すると、最終的には 256 になります。

68
00:04:18,500 --> 00:04:23,500
しかし、一番下では、上の項を折りたたむことから始めると、4 になります。

69
00:04:23,500 --> 00:04:30,500
そして、現在のトップタームを崩壊させることを考えると、それは 2 対

70
00:04:30,500 --> 00:04:35,500
16 となり、これはさらに大きな数になります。つまり65,536です。

71
00:04:35,500 --> 00:04:41,500
そして一般に、上から下へ累乗を繰り返すこのプロセスは非常に急

72
00:04:41,500 --> 00:04:46,500
速に爆発し、テトレーションは一般に上から下の部分を指します。

73
00:04:46,500 --> 00:04:49,500
したがって、トップから評価を開始し、下に向かって評価していきます。

74
00:04:49,500 --> 00:04:54,500
それを明確にしたい場合は、それを電力塔として描く代わりに、

75
00:04:54,500 --> 00:04:59,500
反復プロセスを非常に正確に定義することができると思います。

76
00:04:59,500 --> 00:05:03,500
ある値があり、最初は 1 であり、その後、後続の値は

77
00:05:03,500 --> 00:05:08,500
それぞれ前の値の 2 乗になると言うかもしれません。

78
00:05:08,500 --> 00:05:11,500
したがって、サブ 1 は 2 になります。

79
00:05:11,500 --> 00:05:17,500
サブ 2 は、サブ 1 の 2 乗、この場合は 2 の 2 乗になります。

80
00:05:17,500 --> 00:05:25,500
サブ 3 は、サブ 2 の 2 乗になりますが、現在は 2 対 2 対 2 です。

81
00:05:25,500 --> 00:05:28,500
そして、操作の順序がどうあるべきかについてはもう曖昧さはありません。これは 2 つ

82
00:05:28,500 --> 00:05:33,500
の項から来ていることがわかるため、最初に上位にあるものを評価する必要があります。

83
00:05:33,500 --> 00:05:42,500
同様に、このように続けて、任意の値 n に対する sub n が前の項の 2、つまり s

84
00:05:42,500 --> 00:05:48,500
ub n から 1 を引いたものに等しい場合、この式を展開して再帰的定義に戻ると、次の

85
00:05:48,500 --> 00:05:54,500
ようになります。手に入れようとしているのは、n 回の異なる 2 つのパワータワーです。

86
00:05:54,500 --> 00:05:58,500
さて、このように書くことのもう一つの良い点は、実験的になれることです。

87
00:05:58,500 --> 00:06:03,500
そして、皆さんご存知のとおり、私はこのような新しい操作に出会ったときは、ぜひ遊び心を持ってもらい

88
00:06:03,500 --> 00:06:06,500
たいと思っています。このシリーズでは、そのための Python をいくつか取り上げてきました。

89
00:06:06,500 --> 00:06:11,500
それではここでそれをやってみましょう。この反復プロセスを取り上げて、実際にどのようになるかを見てみましょう。

90
00:06:11,500 --> 00:06:19,500
それで、ターミナルに行き、Python を開き、a の初期値を 1 に設定します。それ

91
00:06:19,500 --> 00:06:23,500
から、2 の累乗を調べます。 m はその値を a に再代入するので、この二重アスタリ

92
00:06:23,500 --> 00:06:29,500
スクは、Python でべき乗を取得する方法です。多くのプログラミング言語では、単一

93
00:06:29,500 --> 00:06:35,500
の等号です。これは質問ではなく、それらが等しいかどうかを尋ねるものではありません。それ

94
00:06:35,500 --> 00:06:40,500
は手術です。これは、右側にあるものをすべて取り出して、左側の値に押し込むと言っています。

95
00:06:40,500 --> 00:06:46,500
したがって、これを行うと、 a の値が 2 になるように、以前のものに再割り当てされます。

96
00:06:46,500 --> 00:06:52,500
これは、何かを解決する方程式があるように見えるため、プログラミングをしたことのない人にとっては奇妙に感じるかもしれません。

97
00:06:52,500 --> 00:06:56,500
しかしこの場合、左側が変更されており、それに対する操作です。

98
00:06:56,500 --> 00:07:03,500
それで、これをもう一度行うと、1 を 2 に前の値に変換する同じプロセスを実行し

99
00:07:03,500 --> 00:07:08,500
、それを同じ行に出力するだけです。そうすれば、4 になると言えます。は 16 に

100
00:07:08,500 --> 00:07:13,500
なります。ここで予測してみてください。16 の 2 になります。先ほど見たのは

101
00:07:13,500 --> 00:07:20,500
65,536 でした。もう一歩踏み出すと、高さ 5 のパワータワーにな

102
00:07:20,500 --> 00:07:24,500
ります。つまり、2 を 5 つ積み重ねるだけで、完全に爆発します。

103
00:07:24,500 --> 00:07:31,500
これはまさにこの途方もない数字ですが、その数字を見つける作業を私たちに代わって行うなんて、とても Python らしいと思います。

104
00:07:31,500 --> 00:07:37,500
とても感動しました。そして、必要に応じて、「その数値を文字列として考えてください。その文

105
00:07:37,500 --> 00:07:42,500
字列の長さはどれくらいで、その文字列に含まれる桁数がわかります」と言うことができます。

106
00:07:42,500 --> 00:07:47,500
したがって、ここで得られる数値は 19,000 桁の表現であり、非常に巨大です。

107
00:07:47,500 --> 00:07:54,500
そして、これをもう 1 回繰り返して、 を 2 の 19,000 桁の怪物の乗

108
00:07:54,500 --> 00:07:59,500
に変換しようとすると、その数値に必要な情報を保存することができなくなります。

109
00:07:59,500 --> 00:08:04,500
物質を使って、出てくるあらゆる数字をすべて符号化する方法はともか

110
00:08:04,500 --> 00:08:08,500
く、それが地球の半径のような範囲内であれば、その種の情報を保存

111
00:08:08,500 --> 00:08:13,500
しようとすると絶対にブラックホールが作成されてしまうでしょう。

112
00:08:13,500 --> 00:08:19,500
つまり、高さ 6 の電力塔だけで、文字通り物理的にあらゆる方法で伝えることができるものをはるかに超えています。

113
00:08:19,500 --> 00:08:26,500
では、2 つではない場合、他の番号ではどのくらいの速さで爆発するのかと疑問に思うかもしれません。

114
00:08:26,500 --> 00:08:31,500
そして、私が皆さんに尋ねたいことの 1 つは、実際にライブ投票で、先に進んで引き上げてみ

115
00:08:31,500 --> 00:08:36,500
ましょう。2 つではなく 1 つを扱った場合に、ここで何が起こるかを予測することです。1.

116
00:08:36,500 --> 00:08:42,500
したがって、説明内および画面上のリンクにアクセスして、私たちと一緒にライブの質問に答えていただくと

117
00:08:42,500 --> 00:08:47,500
、「B を 1 としますか」と尋ねられます。1、つまり 1 の少し上で、B から

118
00:08:47,500 --> 00:08:52,500
B へ、B から B へという形式の式を考えてみましょう。この電力塔の高

119
00:08:52,500 --> 00:08:56,500
さは N で、B の N 個の異なるコピーが表示されることを意味します。

120
00:08:56,500 --> 00:09:01,500
N はどのくらいの大きさでなければなりませんか?式の値が 10 桁を超えるまで

121
00:09:01,500 --> 00:09:05,500
に、この操作を何回繰り返す必要がありますか?

122
00:09:05,500 --> 00:09:09,500
したがって、2 つの場合、それが起こる前にサイズ 5 のタワーに到達する必要がありました。

123
00:09:09,500 --> 00:09:13,500
5 桁の番号から 19,000 桁の番号にジャンプしました。

124
00:09:13,500 --> 00:09:18,500
それでは、B の値が 1 になるには、何回実行する必要があるでしょうか。1?

125
00:09:18,500 --> 00:09:23,500
工事の速度が遅れているかもしれない心地よい音を聞きながら、少し時間をください。

126
00:09:28,500 --> 00:09:33,500
ここでこのプロセスを説明するために、Python に

127
00:09:33,500 --> 00:09:38,500
戻って、ターミナルに戻って、値 1 で A を開始し

128
00:09:38,500 --> 00:09:45,500
たとしましょう。これを for ループで実行して、for N を 50 などの範囲に設定しましょう。

129
00:09:45,500 --> 00:09:53,500
Aさんを再任させていただきます。累乗を繰り返す代わりに、単に 1 を掛けるだけだったらどうなるでしょうか。1?

130
00:09:53,500 --> 00:09:57,500
したがって、乗算を繰り返すだけですが、これはべき乗であるはずです。

131
00:09:57,500 --> 00:10:02,500
この値がどれだけ早く増加するかがわかります。ここで最初の 50 個の値を見てみると、1

132
00:10:02,500 --> 00:10:09,500
から始まります。1、1になります。21 であり、各段階で実際には少しずつ、ジャンプするたびに 10% ずつ増

133
00:10:09,500 --> 00:10:15,500
加しており、古典的な指数関数的な増加が得られます。つまり、50 ステップで 117 までかかりました。

134
00:10:15,500 --> 00:10:20,500
それは指数関数的な成長です。それで、テトレーション成長とは何だろうと疑問に思うかもしれません。

135
00:10:20,500 --> 00:10:23,500
このことを繰り返し累乗するとどうなるでしょうか?

136
00:10:23,500 --> 00:10:27,500
それに答える前に、あなたの考えを聞かせてください。

137
00:10:27,500 --> 00:10:33,500
これを繰り返し累乗するとどうなると思いますか?

138
00:10:33,500 --> 00:10:41,500
わかった。したがって、正しい答えは、実際にはそのようなものを超えて成長することは決してないということです。

139
00:10:41,500 --> 00:10:44,500
そして、ああ、興味深いことに、それが 3 位の答えです。

140
00:10:44,500 --> 00:10:50,500
したがって、ほとんどの人は、必要な高さは 10 ～ 100 の間であると考えていました。

141
00:10:50,500 --> 00:10:53,500
これを 10 ～ 100 回繰り返すと、10 桁を超えてしまいます。

142
00:10:53,500 --> 00:10:59,500
2 番目に多かった回答は、1 から 10 の間にあると考えているというもので、これは 2 がどのように成長するかに非常に似ています。

143
00:10:59,500 --> 00:11:04,500
3 番目に一般的なのですが、この 3 番目に一般的な人のうち何人がこのプロセスを以前に見たことがあるのでしょうか。

144
00:11:04,500 --> 00:11:10,500
なぜなら、それは非常に奇妙だからです。繰り返しそれ自体を掛け合わせると、望むだけ大きくなるという考えですが、どうい

145
00:11:10,500 --> 00:11:17,500
うわけか累乗を繰り返す、はるかに強力な操作のように感じられる操作を実行しますが、実際には制限されたままになります。

146
00:11:18,500 --> 00:11:26,500
そして、Python に戻ってみると、これが実際にうまくいくことがわかります。ここで、各反復で何を行っているかを確認しま

147
00:11:26,500 --> 00:11:32,500
す。a を再び 1 に設定する必要があると思います。これを繰り返し次のように変換します。 1 を自分自身で乗算します。

148
00:11:32,500 --> 00:11:39,500
そして、最初はわずかな増加が得られますが、すぐに速度が低下し、わずか 20 回の反復内で、実

149
00:11:39,500 --> 00:11:44,500
際にはこの値に固定されたままになります。この数字が変わっていないことがわかります。

150
00:11:44,500 --> 00:11:51,500
そこで何が起こっているのかをよく考えてみると、明らかに a がその値に等しい場合に 1 をとります。1 の値の乗なので 1

151
00:11:51,500 --> 00:12:01,500
。1 のこのものの乗は 1 です。1117、ああ、何度も入力しないでください。実際には修正されたままです。

152
00:12:01,500 --> 00:12:03,500
以前と同じ値が得られます。

153
00:12:03,500 --> 00:12:12,500
したがって、これを別の言い方で表現すると、方程式 1 と言えます。1 の x 乗は x

154
00:12:12,500 --> 00:12:16,500
に等しく、これを関数に接続すると、それ自体が得られ、これには解決策があります。

155
00:12:16,500 --> 00:12:24,500
2でやっていたときはこれが当てはまりませんでした。x の 2 が x に等しい場合、これに対するさまざまな答えを考えて

156
00:12:24,500 --> 00:12:29,500
みると、考えるのが難しい方程式になりますが、0 と 1、またはその間の値などのいくつかの値を試してみる

157
00:12:29,500 --> 00:12:34,500
と、次のことがわかります。実際にはここには答えはありませんが、この場合は明らかに答えが見えただけです。

158
00:12:34,500 --> 00:12:39,500
そして、ベースが 2 ではなく 1 だった場合、それが反復プロセスにとって何を意味するか。ベースが 1

159
00:12:39,500 --> 00:12:46,500
の場合、前の値を 1 上げる状況になります。1、それは固定されたままです。

160
00:12:46,500 --> 00:12:48,500
そして今、これは多くの興味深い疑問を引き起こし始めています。

161
00:12:48,500 --> 00:12:57,500
まず、スイッチはどこにありますか？有限な状態から爆発する点は 1 と 2 の間のどの数字ですか?

162
00:12:57,500 --> 00:13:04,500
信じられないほど早く爆発しましたが、2 ではコンピューターの処理能力を超えた

163
00:13:04,500 --> 00:13:06,500
ものを得るまでに 5 回の反復しかかからなかったことを思い出してください。

164
00:13:06,500 --> 00:13:15,500
これを少しいじってみることもできますが、これがまったく収束する可能性があるという事実のもう 1 つの興味深い成果は、非常に奇妙な

165
00:13:15,500 --> 00:13:22,500
質問のように見えるものに答え始めることができることです。つまり、「未知の値があると想像してください」と言うことができます。 x

166
00:13:22,500 --> 00:13:28,500
、そして私は有限のサイズのパワータワーではなく、無限のサイズのパワータワーを作ります。明らかに底が 1

167
00:13:28,500 --> 00:13:32,500
の場合と同じように、私は永遠に進み続けるつもりです。1.

168
00:13:32,500 --> 00:13:38,500
これが収束する x の値、たとえば 4 を見つけることはできますか?これはビデオのサムネイルで提起された質問です。

169
00:13:38,500 --> 00:13:45,500
そして、今見たのは、1 に収束する値を見つけることができたことです。111782 以降

170
00:13:45,500 --> 00:13:51,500
、これは明らかに収束できる値であり、解は 1 になります。1ですが、その逆はどうすればいいでしょうか？

171
00:13:51,500 --> 00:13:57,500
4 に等しい x の値を見つけることができるというアイデアを実際にどのように解決できるでしょうか?

172
00:13:57,500 --> 00:14:03,500
ここにはあなたも気づくかもしれない巧妙なトリックがあります。これは特定の問題解決の数学

173
00:14:03,500 --> 00:14:08,500
で出てきます。そこでは無限の式があり、うーん、活用できる自己相似性があると言うのです。

174
00:14:08,500 --> 00:14:14,500
内部には送電塔全体のコピーが入っています。それは無限であるため、それ自体の本物のコピーです。

175
00:14:14,500 --> 00:14:20,500
そうではありません。高さは無限大であるため、以前の高さを 1 から引いた高さはありません。

176
00:14:21,500 --> 00:14:30,500
そして、送電塔全体が 4 に等しいという仮定の下で、これを 4 に置き換えて、4 番目が 4 に等しい x を解くことができます。

177
00:14:30,500 --> 00:14:35,500
見てみましょう、それは何でしょうか？平方根を取ると、x の 2 乗が 2 に等しいと言うのと同じになります。

178
00:14:35,500 --> 00:14:44,500
興味深いことに、x は 2 の平方根に等しいので、4 に収束する電力塔が得られるようです。

179
00:14:44,500 --> 00:14:54,500
ちょっとファンキーな感じ。何かが収束するという考えはちょっと奇妙ですが、2 の平方根が整数のようなきれいな値になるという考えは、ある意味驚きです。

180
00:14:54,500 --> 00:15:04,500
実際に別の質問をさせてください。ここでは、先ほどと同じ戦術を適用して、その自己相似性を利用して、別の

181
00:15:04,500 --> 00:15:11,500
状況を解決してもらいます。未知の基数を調べ、それが事前に指定された値と等しいかどうかを確認します。

182
00:15:11,500 --> 00:15:17,500
それで、今回の質問は私たちに尋ねます、ここで車を止めるのに少しだけ時間を与えてください、まあ、少し時間が

183
00:15:17,500 --> 00:15:27,500
かかります、それは大丈夫です、ああ、素晴らしいです、質問は私たちに、今示した戦術を使用して、何を尋ねま

184
00:15:27,500 --> 00:15:33,500
すか？ 4 については、無限が 2 に等しくなるまで方程式 x を x から x まで解き続けました。

185
00:15:33,500 --> 00:15:36,500
そこで、少し考えてみましょう。

186
00:15:41,500 --> 00:15:59,500
グランドスマッシャーが帰ってきた。

187
00:15:59,500 --> 00:16:07,500
昨日、私たちがそれをやっていたとき、私たちは、あなたに見せられる映像があればよかったのですが、携帯電話か何かでそれを取り出

188
00:16:07,500 --> 00:16:16,500
してみることができるかもしれませんが、物事があまりにも揺れていたので、回路基板の山だけが壊れていました活発に揺れています。

189
00:16:16,500 --> 00:16:19,500
これを見つけたら見てみましょう、とても面白いです。

190
00:16:19,500 --> 00:16:30,500
そうですね、これは違うかもしれません。これはおそらく何かをストリーミングする最悪の方法です。携帯電話のオーバーヘッドカメラショットを撮ることですが、これがきちんと機能するかどうか見てみましょう。

191
00:16:30,500 --> 00:16:36,500
それで、私は建設現場の様子を見ようとしていたのですが、私たちはそこに移動しました、そしてただ積み上げられた回路基板だけがそのように震えていました。

192
00:16:36,500 --> 00:16:40,500
それが私たちが対処しなければならないことです。楽しんでいただければ幸いです。

193
00:16:40,500 --> 00:16:49,500
さて、クイズでは、ほぼ全員が同じ答えに集まっているように見えますが、あなたが正しい答えにたどり着いたと仮定します。実際

194
00:16:49,500 --> 00:16:59,500
、それは実際には 2 の平方根で、ちょっと面白いですね。なぜなら、4 を解くために行ったのとまったく同じロジックを実

195
00:16:59,500 --> 00:17:05,500
行すると、この無限のパワータワーがあり、それが 2 に等しいと仮定し、自己相似性を認識すると、これは、ああ、そうです

196
00:17:05,500 --> 00:17:13,500
、送電塔のコピーです。つまり、x の 2 乗が 2 に等しい、つまり x が 2 の平方根に等しいことを意味します。

197
00:17:13,500 --> 00:17:23,500
ちょっと待ってください。これは正しくありません。これは、一方では無限パワータワーがベースがルート 2 のときに 2 に収束することを

198
00:17:23,500 --> 00:17:26,500
示唆しているように見えますが、他方ではベースがルート 2 の場合には 4 に収束することを示唆しているように見えます。ルート2です。

199
00:17:26,500 --> 00:17:33,500
両方であることはできません。ここには、何が収束するかについて非常に決定的なプロセスがあるため、存在するとしても、どちらか一方でなければなりません。

200
00:17:33,500 --> 00:17:35,500
おそらく、この状況の論理全体が間違っているのかもしれません。

201
00:17:35,500 --> 00:17:41,500
それでは、経験的に見てみましょう。プログラミングに目を向けて、実際に最終的にどれになるのかを見てみましょう。

202
00:17:41,500 --> 00:17:51,500
それで、戻って、変数 a を 1 に再割り当てします。小さなループを作成します。ここでは平方根が必要になるため、実際に数学をインポートしましょう。

203
00:17:51,500 --> 00:17:56,500
それで私は、わかりませんが、一度に 20 個だけやろうと言います。

204
00:17:56,500 --> 00:18:03,500
a を取得して、2 の平方根、2 の平方根の a 乗に変換し、それがどのようにな

205
00:18:03,500 --> 00:18:06,500
るかを出力します。セミコロンは必要ないと思いますが、実際には問題ではありません。

206
00:18:06,500 --> 00:18:13,500
最初の 20 回の反復では、2 に近づくにつれて速度が若干遅くなっているように見えま

207
00:18:14,500 --> 00:18:19,500
す。さらに 20 回の反復を行うと、2 に近づくにつれて速度は確実に遅くなります。

208
00:18:19,500 --> 00:18:27,500
そして今度は、ちょうど 2 に着地したように見えて、その後 2 にジャンプするという、ある種奇妙なことを行います。00

209
00:18:27,500 --> 00:18:31,500
04、ここで何が起こっているのかよく考えてみると、ある時点で 2 に等しくなります。

210
00:18:31,500 --> 00:18:36,500
したがって、a が 2 に等しいと言って、2 の平方根の 2 乗を計

211
00:18:36,500 --> 00:18:40,500
算しますが、定義上、2 の 2 乗の平方根は 2 になるはずです。

212
00:18:40,500 --> 00:18:43,500
つまり、それは単なる数値誤差ということになります。

213
00:18:43,500 --> 00:18:48,500
ただし、数学の平方根ライブラリは平方根を実装していると思

214
00:18:48,500 --> 00:18:51,500
います。浮動小数点では常に多少の数値誤差が生じるため、

215
00:18:51,500 --> 00:18:54,500
2 乗しても正確に 2 が返されるわけではありません。

216
00:18:54,500 --> 00:18:55,500
それは問題ありません。

217
00:18:55,500 --> 00:19:03,500
しかし、根が 2 の送電塔がある場合に何が起こるかという私たちの質問に対する正しい答えは、それ

218
00:19:03,500 --> 00:19:09,500
が 2 に等しいか、これが表す数列が 2 に近づくことであることを示唆しているように思えます。

219
00:19:09,500 --> 00:19:11,500
他のロジックでは何が問題になっているのでしょうか?

220
00:19:11,500 --> 00:19:15,500
4 に等しいはずだと示唆しているように見えるロジックのどこが間違っているのでしょうか?

221
00:19:15,500 --> 00:19:18,500
答えとしては、2 つのことを行う必要があるということです。

222
00:19:18,500 --> 00:19:23,500
1 つ目は、これをもう少し視覚的に、少しグラフィックで表現して、この

223
00:19:23,500 --> 00:19:27,500
反復プロセスで何が起こっているのかを理解できるようにすることです。

224
00:19:27,500 --> 00:19:33,500
そして、そこからどの値が収束し、どの値が爆発するかを理解します。

225
00:19:33,500 --> 00:19:40,500
そして、これに答えることで、この問題を 4 に近づけることに関連するロジックの何が問題なのかという方向に戻ることができます。

226
00:19:40,500 --> 00:19:44,500
そのために、私たちの良き友人であるデスモスを見てみましょう。

227
00:19:44,500 --> 00:19:50,500
ここに来て、Chrome を開いてください。まだ見ないでください。4 後です。

228
00:19:50,500 --> 00:19:54,500
ここでグラフを見てみましょう。

229
00:19:54,500 --> 00:20:01,500
さて、私が持っているのは、直線 y が x に等しいということです。関数 b の x

230
00:20:01,500 --> 00:20:04,500
乗、b を 2 に設定しました。つまり、2 対 x のグラフを見ているだけです。

231
00:20:04,500 --> 00:20:11,500
そして、関数を繰り返し適用して出力を取得し、それを入力に戻すというアイデ

232
00:20:11,500 --> 00:20:15,500
アを考えると、一般にクモの巣図として知られるものを描くことができます。

233
00:20:15,500 --> 00:20:20,500
これがどのように機能するかというと、入力として初期値 1 を持ってい

234
00:20:20,500 --> 00:20:26,500
て、次の値は f が 1 であるものになり、1 を関数に接続します。

235
00:20:26,500 --> 00:20:32,500
これが意味するのは、グラフに到達するまで垂直に移動するということです。この場合、2

236
00:20:32,500 --> 00:20:35,500
対 1 はちょうど 2 なので、y の値 2 でグラフに到達することになります。

237
00:20:35,500 --> 00:20:40,500
しかし、そこから私が望むのは、取得したばかりの出力、つまり 2 を関数への入力にすることです。

238
00:20:40,500 --> 00:20:44,500
しかし、出力が y 軸上に表され、入力が x 軸上に表され

239
00:20:44,500 --> 00:20:49,500
る場合、必要なのは、y 値が x 値と同じである点です。

240
00:20:49,500 --> 00:20:53,500
したがって、y 値が x 値と同じになるまで水平方向に進むと、2 が x

241
00:20:53,500 --> 00:20:59,500
値である点に到達し、ここでその 2 が入力であると考えることができます。

242
00:20:59,500 --> 00:21:06,500
そのためには、y が x に等しい線に到達するまで歩きます。なぜなら、

243
00:21:06,500 --> 00:21:11,500
そこに到達すると、2,2 が表示されるため、グラフに到達するまで垂直

244
00:21:11,500 --> 00:21:15,500
に移動することで、その 2 を入力として扱うことができます。それがどの

245
00:21:15,500 --> 00:21:19,500
ように機能するか見てみましょう。つまり、反復プロセスの次の点は、先ほ

246
00:21:19,500 --> 00:21:23,500
どの値の 2 乗、つまり 2 の 2 乗、つまり 4 になります。その

247
00:21:23,500 --> 00:21:28,500
後、右に移動して、出力を入力して、平面上のどの点が x 値も 4 に

248
00:21:28,500 --> 00:21:32,500
等しいかを探します。そして、そこに到達したら、この線から跳ね返り、y

249
00:21:32,500 --> 00:21:35,500
が x に等しいと考えて、グラフに再度到達するまで垂直に移動します。

250
00:21:35,500 --> 00:21:41,500
そして今回は 16 になるまでグラフに到達しませんでした。そして、x も

251
00:21:42,500 --> 00:21:47,500
16 に等しくなるまで右に移動します。そこから、かなり長い時間、垂直方向に

252
00:21:47,500 --> 00:21:52,500
移動する必要がありますが、それはかなり起こります。しばらくすると、65,

253
00:21:52,500 --> 00:21:57,500
000 付近で再びグラフと交差し、それから同じく 65,000 の x 座

254
00:21:57,500 --> 00:22:01,500
標に到達するまで右に移動します。そこから、デスモスは次の垂直線を引くこと

255
00:22:01,500 --> 00:22:08,500
を完全に諦めます。なぜなら、これまで見てきたように、到達すべき高さはその高

256
00:22:08,500 --> 00:22:10,500
さを表す数字が 19,000 桁であるため、そこで諦めてしまうからです。

257
00:22:10,500 --> 00:22:16,500
しかし、これらのクモの巣の図に基づいて考えると、そのベース

258
00:22:16,500 --> 00:22:18,500
が何であるかを検討し始めると、何が起こるかがわかります。

259
00:22:18,500 --> 00:22:22,500
その基地とは何ですか？基本は地面を叩く活動です。

260
00:22:22,500 --> 00:22:26,500
ある時点で、グラフは実際に交差します。

261
00:22:26,500 --> 00:22:32,500
したがって、特に 1 に注目していました。1 より前、そしてそれは、ええ、絶対に交差しま

262
00:22:32,500 --> 00:22:37,500
すが、1 程度まででもです。41、これは 2 の平方根に相当します。こ

263
00:22:37,500 --> 00:22:42,500
のプロセスで何が起こっているかを見ると、出力を確認し、出力を入力

264
00:22:42,500 --> 00:22:45,500
に変換し、新しい出力を確認し、出力を入力に変換し、前後にバウンス

265
00:22:45,500 --> 00:22:50,500
します。 、これらのグラフが互いに交差する値、つまり、x の b

266
00:22:50,500 --> 00:22:56,500
(b の x 乗) が x に等しい値に向かって跳ね返ります。

267
00:22:56,500 --> 00:23:06,500
特に、その底が 2 の平方根であり、2 の平方根の x 乗 x に等しい解

268
00:23:06,500 --> 00:23:10,500
を求めたとします。これを体系的に解く方法を考えるのは簡単ではありません。特

269
00:23:10,500 --> 00:23:13,500
に、解は x が 2 に等しいと言ったら、あなたは信じてくれるでしょう。

270
00:23:13,500 --> 00:23:15,500
それを差し込むだけで解決できます。

271
00:23:15,500 --> 00:23:20,500
したがって、グラフを見て、b の場合、実際に先に進んで、単

272
00:23:20,500 --> 00:23:22,500
なる近似値ではなく、正確に 2 の平方根にしてみましょう。

273
00:23:22,500 --> 00:23:28,500
したがって、 b は平方根、2 の平方根、いいえ、2 の平方根になります。

274
00:23:28,500 --> 00:23:32,500
交点はちょうど 2 にあるので、反復プロセスがそれに近づいていることがわかります。

275
00:23:32,500 --> 00:23:34,500
なるほど、それは興味深いですね。

276
00:23:34,500 --> 00:23:39,500
これはまた、物事が収束するときと収束しないときの間の切り替えがどこで起こるかを理解したい場合

277
00:23:39,500 --> 00:23:45,500
、私たちがそうなりたいのであれば、それについてどのように考える必要があるかを示しています。

278
00:23:45,500 --> 00:23:52,500
なぜなら、私たちが知りたいのは、b のどの値を知ることなので、物が逃げられる場所、

279
00:23:52,500 --> 00:23:58,500
交差点がない場所、物が逃げられない場所、交差点がある場所に行く必要があるからです。

280
00:23:58,500 --> 00:24:02,500
ちなみに、この特定の Desmos グラフへのリンクを説明に残しまし

281
00:24:02,500 --> 00:24:06,500
たので、そこに飛び乗って一緒に遊んでみたいという方は、大歓迎です。

282
00:24:06,500 --> 00:24:11,500
1 つ明記しておく必要があるのは、それらが交差するという事実ですが、実際には、このク

283
00:24:11,500 --> 00:24:15,500
モの巣の反復プロセスが必ず収束することを保証するにはそれだけでは十分ではありません。

284
00:24:15,500 --> 00:24:22,500
関数のグラフ (この場合は b から x まで) が 1 未満の傾きで交差することが重要です。

285
00:24:22,500 --> 00:24:24,500
そして、なぜそれが真実なのかを考えることができます。

286
00:24:24,500 --> 00:24:31,500
見方を変えて、指数関数やそのような曲線を扱っておら

287
00:24:31,500 --> 00:24:34,500
ず、一般的な関数を扱っているだけだとしましょう。

288
00:24:34,500 --> 00:24:42,500
そこで、線 y が x に等しいことに注目してください。波線を描いて

289
00:24:42,500 --> 00:24:44,500
交差する関数があるとしますが、その傾きは 1 より大きいとします。

290
00:24:44,500 --> 00:24:48,500
次に、反復プロセスを実行すると、出力が得られるので、y が x に

291
00:24:48,500 --> 00:24:52,500
等しくなるまで水平に移動して、出力を入力に変えましょうとします。

292
00:24:52,500 --> 00:24:55,500
垂直方向に移動して、新しい出力を確認します。

293
00:24:55,500 --> 00:24:57,500
スマッシュ、スマッシュ、スマッシュ。

294
00:24:57,500 --> 00:25:05,500
新しい入力を確認するか、その出力に到達するまで水平に歩いてその出力を入力に変えます。

295
00:25:05,500 --> 00:25:07,500
そして、そのプロセスを繰り返します。

296
00:25:07,500 --> 00:25:11,500
1 より大きい勾配と交差しているため、これが起こっている

297
00:25:11,500 --> 00:25:14,500
ことがわかります。実際には交差点から離れて歩いています。

298
00:25:14,500 --> 00:25:19,500
したがって、それが単なる安定点ではないことを確認するために、グ

299
00:25:19,500 --> 00:25:22,500
ラフ間の共通点ではなく、このプロセスを繰り返すと安定します。

300
00:25:22,500 --> 00:25:24,500
この傾きは 1 未満である必要があります。

301
00:25:24,500 --> 00:25:27,500
そこで、この種のプロセスについて別の視点から考える方法について、ビデオ全体を提供しました。

302
00:25:27,500 --> 00:25:31,500
微積分では教えてくれないようなばかばかしいタイトルを付けたと思いますが、この例や楽

303
00:25:31,500 --> 00:25:38,500
しく無限に反復されるオブジェクトの例をもっと見たい場合は、そこを参照してください。

304
00:25:38,500 --> 00:25:44,500
ここで、私たちのケースでは、傾きが 1 未満であるため、これは機能します。

305
00:25:44,500 --> 00:25:47,500
ただし、2 番目の交点では、実際には 1 より大きい傾きになります。

306
00:25:47,500 --> 00:25:53,500
したがって、最初の値が 1 ではない反復プロ

307
00:25:53,500 --> 00:25:56,500
セスを変更した場合、この場合は値を 4 にす

308
00:25:56,500 --> 00:26:01,500
ると、ご覧のとおり、反復プロセスは実際に交点

309
00:26:01,500 --> 00:26:03,500
から逃げてしまい、実際に爆発します。無限に。

310
00:26:03,500 --> 00:26:05,500
だからいつも楽しいんです。

311
00:26:05,500 --> 00:26:07,500
これを 1 に戻します。

312
00:26:07,500 --> 00:26:14,500
Desmos 定義では 4 つの再帰ループを実行できないことにイライラした私の小さなメモを見てみましょう。

313
00:26:14,500 --> 00:26:18,500
そして、何を解決する必要があるかがわかります。

314
00:26:18,500 --> 00:26:25,500
ここでちょっと面白いのは 1 です。45 は、実際に交差する点のすぐ上にあるように見えます

315
00:26:25,500 --> 00:26:33,500
が、この跳ね返りがあり、最終的に爆発するまで非常に長い間ある程度安定した状態を保ちます。

316
00:26:33,500 --> 00:26:38,500
そして、これを図的に考えるのではなく、単に数値的に遊んでいる場合を想像してみてください。

317
00:26:38,500 --> 00:26:43,500
したがって、以前と同じプロセスを実行し、A が 1 から始まる場合は、累乗を

318
00:26:43,500 --> 00:26:49,500
何度も繰り返すことになりますが、それを 1 にすることになります。代わりに45。

319
00:26:49,500 --> 00:26:52,500
そして、これに 50 個の値を与えてみましょう。

320
00:26:52,500 --> 00:26:56,500
プロセスは最終的に爆発します。このオーバーフローエラーが発生します。

321
00:26:56,500 --> 00:27:02,500
しかし、何が起こっているかを視覚的に把握していなければ、プロセスは非常に混乱するでしょう。

322
00:27:02,500 --> 00:27:11,500
1から始まります。45は伸びますが、ちょっと安定しない感じですが、2ではあまり動かないようです。71828地域。

323
00:27:11,500 --> 00:27:15,500
何らかの理由で、そのあたりでは動きがひどく遅くなっているように見えます。

324
00:27:15,500 --> 00:27:19,500
しかし、それが 3 領域に少し大きくなり始めると、しばらくそこに留まります。

325
00:27:19,500 --> 00:27:27,500
4 領域には 2 つの値があります。それから6、9、39と続き、その後は200万にまで膨れ上がります。

326
00:27:27,500 --> 00:27:29,500
そしてそこから先は、コンピューターが処理できる範囲を超えたものになります。

327
00:27:29,500 --> 00:27:34,500
したがって、何が起こっているのかを十分に理解している場合を除いて、それは非常に混乱するでしょう。

328
00:27:34,500 --> 00:27:37,500
グラフはほぼ接触していますが、完全には接触していません。

329
00:27:37,500 --> 00:27:42,500
したがって、1の間のどこかにあります。44と1。私たちが探しているのは 45 です。

330
00:27:42,500 --> 00:27:45,500
そして、これを微積分の観点から考えるかもしれません。

331
00:27:45,500 --> 00:27:52,500
ここで私たちが知りたいのは、このグラフのタンジェントが線 y と x に等しいときを知ることです。

332
00:27:52,500 --> 00:27:57,500
x に対するグラフ b が y と x に等しい線に接するのはいつですか?

333
00:27:57,500 --> 00:28:02,500
そして、私がそれを解くために必要な方程式を立てるのではなく、あなたにも同じことをしてもらいます。

334
00:28:02,500 --> 00:28:07,500
この b の値を求める条件を見てもらいます。

335
00:28:07,500 --> 00:28:11,500
では、質問が具体的に何を尋ねているかを読んでみましょう。

336
00:28:11,500 --> 00:28:20,500
y のグラフが x に対して b に等しく、y が x に等しいグラフに接するような b の値が必要です。

337
00:28:20,500 --> 00:28:25,500
解く必要がある方程式のペアを表すものは次のうちどれですか?

338
00:28:25,500 --> 00:28:27,500
さて、ちょっと考えてみましょう。

339
00:28:27,500 --> 00:28:31,500
解く必要がある方程式のペアは次のうちどれですか?

340
00:28:32,500 --> 00:28:48,500
音楽 それについて考えている間に、聴衆

341
00:28:48,500 --> 00:28:52,500
からいくつか質問を受けてみましょう。

342
00:28:52,500 --> 00:28:54,500
我々は持っています。

343
00:28:54,500 --> 00:28:58,500
。。そこですぐに疑問に思ったのは、繰り返しの抑止は罰金であるということです。

344
00:28:58,500 --> 00:29:00,500
それともそれは有用なアイデアなのでしょうか？

345
00:29:00,500 --> 00:29:06,500
はい、これらのプロセスを繰り返すというアイデアについて説明する表記法があります。

346
00:29:06,500 --> 00:29:08,500
それはクヌース矢印記法と呼ばれます。

347
00:29:08,500 --> 00:29:10,500
そして、必要なだけ持つことができます。

348
00:29:10,500 --> 00:29:20,500
つまり、これがどのように機能するかというと、矢印 b のようなものを書くと、それは a の b 乗と同じことになります。

349
00:29:20,500 --> 00:29:26,500
しかし、2 つの矢印が付いた a はそのプロセスの繰り返しです。

350
00:29:26,500 --> 00:29:28,500
ご存知のように、b 回です。

351
00:29:30,500 --> 00:29:33,500
申し訳ありませんが、これは 2 つの矢印と b です。

352
00:29:33,500 --> 00:29:40,500
3 つの矢、3 つの矢、そして ab がある場合、私が繰り返しているのは、2 つの矢を実行するプロセスです。

353
00:29:40,500 --> 00:29:44,500
これは、数字で考え始めると本当に気が遠くなるほど大きなものです。

354
00:29:44,500 --> 00:29:46,500
2 や 3 などの偶数です。

355
00:29:46,500 --> 00:29:51,500
このプロセスを何度も繰り返すという考えは、まったくクレイジーです。

356
00:29:51,500 --> 00:29:54,500
そして、さらに多くの矢を放ち続けることもできます。

357
00:29:54,500 --> 00:30:01,500
グラム定数についてまだ学習していない人がいる場合は、今すぐその数値ファイルにアクセスして、グラム定数がどのように定義されているかを確認してください。

358
00:30:01,500 --> 00:30:05,500
なぜなら、このような矢の操作が含まれており、本当にクレイジーだからです。

359
00:30:05,500 --> 00:30:10,500
そして、グラム定数を初めて見たときは、数学生活の中で最も衝撃的な瞬間の 1 つです。

360
00:30:10,500 --> 00:30:12,500
そこでお勧めします。

361
00:30:12,500 --> 00:30:19,500
さて、次は 1 です。1のx乗はxに等しいため、Wolfram Alphaは2つの実数解を生成します。

362
00:30:19,500 --> 00:30:20,500
おお、素晴らしい質問ですね。

363
00:30:20,500 --> 00:30:22,500
そのうちの 1 つは、私たちが収束するものです。

364
00:30:22,500 --> 00:30:25,500
もう一人は38くらいです。29.

365
00:30:25,500 --> 00:30:27,500
素晴らしい。2 番目の解決策はどうなるのでしょうか?

366
00:30:27,500 --> 00:30:30,500
私たちが持っているグラフを正確に見ることができます。

367
00:30:30,500 --> 00:30:35,500
したがって、b を取得して 1 にするとします。1.

368
00:30:35,500 --> 00:30:36,500
わかった。

369
00:30:36,500 --> 00:30:41,500
1以上の勾配と交差する場所でどうなるかという話でした。

370
00:30:41,500 --> 00:30:45,500
はい、これは反復プロセスの固定点です。

371
00:30:45,500 --> 00:30:46,500
しかし、それは安定した固定点ではありません。

372
00:30:46,500 --> 00:30:49,500
ここまでが、先ほど参照した 38 の値です。

373
00:30:49,500 --> 00:30:58,500
また、1 よりも大きな傾きで交差するため、実際にそれに近い値をプロセスにシードしたとしても、プロセスはその値から逃げてしまいます。

374
00:30:58,500 --> 00:31:05,500
したがって、プロセスをシードしている場合、1 に等しい値から開始している場合、これが最終的に検出される交差点になります。

375
00:31:05,500 --> 00:31:07,500
それは未解決の質問です。

376
00:31:07,500 --> 00:31:12,500
そして 3 番目に、テトレーションなどの操作の実用的な使用例はあるのでしょうか?

377
00:31:12,500 --> 00:31:15,500
私は非常に科学的な分野を研究してきましたが、この演算子に出会ったことはありません。

378
00:31:15,500 --> 00:31:17,500
すごく興味がある。

379
00:31:17,500 --> 00:31:20,500
さて、それは的中の質問です。

380
00:31:20,500 --> 00:31:31,500
それで、最後にカオスとフラクタルの役割について少し話しますが、それ自体が役立つ他のものに関連していると言っているので、よく言っても希薄です。

381
00:31:31,500 --> 00:31:37,500
私個人としては、自然の中で科学を行っているときにドーンとテトレーションが現れるような場所は思いつきません。

382
00:31:37,500 --> 00:31:45,500
頭の体操のようなパズルのようなものを思い浮かべることができますが、この操作が登場するとはまったく考えられないかもしれませんが、実際にはそうなります。

383
00:31:45,500 --> 00:31:48,500
最後に時間があれば、お話しさせていただければと思います。

384
00:31:48,500 --> 00:31:58,500
私が今この種のことを学ぶ動機は、シーンが切り替わる混乱を許してください。目の前にあるパズルを実際に解き、繰り返される塔が 4 つに等しいということを理解す

385
00:31:58,500 --> 00:32:08,500
るためのプロセスです。 、そして私たちがこれから見つけようとしているもの、収束するものと収束しないものの間の切り替えポイントがどこにあるのかを理解します。

386
00:32:08,500 --> 00:32:14,500
これらは、より実践的な反復プロセスを伴う他の作業にも引き継がれる問題解決戦術です。

387
00:32:14,500 --> 00:32:19,500
そして、反復プロセスは科学のいたるところで必ず登場します。つまり、カオス理論はそこでの大きな理論のようなものです。

388
00:32:19,500 --> 00:32:30,500
人々の質問に答える側として、以上のことを踏まえて、私は Twitter を通じてさらに考え、おそらく最後にはさらに検討するつもりです。私たちの問題に対してあなたがどのように対処したかを見てみましょう。

389
00:32:30,500 --> 00:32:42,500
ここで連立方程式と正しい答えを探しています。1777 人が得たものです。これはフランス革命の領域ではないと思いますが、あなた方のアメリカ革

390
00:32:42,500 --> 00:32:51,500
命の領域では、x に対する b は x に等しいので、それらが交差する必要があり、さらに、交差する場所の傾きが同じであることが必要です。

391
00:32:51,500 --> 00:33:01,500
そして、b から x への導関数はそれ自体ですが、b の自然対数によってスケーリングされます。そして、その傾きが 1 に等しくなるようにしたいのです。なぜなら、それは今見ているグラフの傾きと同じでなければならないからです。

392
00:33:01,500 --> 00:33:09,500
そして、指数関数の導関数が何であるかを覚えていない場合でも、x に対する e はそれ自身の導関数であることを覚えている場合、つまり、x

393
00:33:09,500 --> 00:33:18,500
に対する e に関して微積分で覚えていることが 1 つあるとすれば、それはe から x へのそれ自体の導関数である必要があります。

394
00:33:18,500 --> 00:33:25,500
b を e として b の自然対数に書き込むことができるので、そのすべてを x に書き込むことができることに注意してください。

395
00:33:25,500 --> 00:33:31,500
つまり、これは e を b 倍 x の自然対数で表現するのと同じことです。これについては前回の講義でお話したと思います。

396
00:33:31,500 --> 00:33:50,500
したがって、これの導関数を取りたい場合は、その導関数を取得します。一方で、それはこれの導関数である必要があります。連鎖律により、指数に座っている定数、b 倍の自然対数、e は次のようになります。 ln b に x を掛けます。

397
00:33:50,500 --> 00:33:56,500
つまり、私たちが見ているのは、それ自体であるはずですが、何かによってスケールされ、その何かが b の自然対数であるということです。

398
00:33:56,500 --> 00:34:10,500
さて、グラフが y と x に等しいときに適切に接するようになるのはいつかを理解するためのパズルとして、この方程式、この連立方程式を実際に解いてみましょう。

399
00:34:10,500 --> 00:34:25,500
その解が得られる値 x を探しているので、x に対する曲線 b がその点で x に等しいことがわかり、その傾き (b 自体の自然対数) が 1 に等しいことがわかります。

400
00:34:25,500 --> 00:34:40,500
これを解決するために、最初に行うことは、b を x であるとして単純化できることに注意することです。したがって、それをここに適用すると、x が 1 に等しい b の自然対数を書くことができます。

401
00:34:40,500 --> 00:34:53,500
そして、それが私に与えるものは、b は x で割ったものと同じであるということです。すべて非常に良いことです。いやいや、それは私に与えません、それは、b の自然対数が x の 1 であるということを私に与えます。

402
00:34:53,500 --> 00:35:01,500
これは、x を超えるものに対して e は b に等しいと言うのと同じステートメントです。

403
00:35:02,500 --> 00:35:12,500
さて、その偏見とは何でしょうか？これにより、完全に x に関して b を表す式が得られるので、この上部に移動すると、x だけを含む方程式を得ることができます。

404
00:35:12,500 --> 00:35:22,500
それは e の x の 1 の x 乗になります。b を、我々が見つけた値に置き換えるだけです。これは x に等しいはずです。

405
00:35:22,500 --> 00:35:34,500
しかしその一方で、e の x の x 乗は単純化されて e になり、x は e に等しいことが分かりました。

406
00:35:34,500 --> 00:35:47,500
ところで、昨夜、私はこのレッスンの予行演習のようなことをしていました。そこでは、Twitter のストリームへのリンクを非公開リンクとして公開し、100 件もあればすぐに「いいね！」と言うのです。ツイートを削除し、予行演習を行うだけです。

407
00:35:47,500 --> 00:36:01,500
これを解いているとき、どういうわけか、ここまでたどり着くまでに 10 分ほど混乱していました。1 の間の値を探しているので、それは正しいはずがないと思いました。44と1。45 ということは、x を e にすることはできません。これは大きすぎます。2 のようなものです。718.

408
00:36:01,500 --> 00:36:06,500
そこで私は戻って、自分が何を間違ったのか、一体何が間違っていたのか、じっくり考えてみました。

409
00:36:06,500 --> 00:36:25,500
あまりにも時間がかかったので少し恥ずかしかったのですが、最終的には、いや、バカ、1 の間にある x の値を探しているわけではないことに気づきました。44と1。45、これは、私たちがここで遊んでいたときの指数関数の底の b の条件でした。

410
00:36:25,500 --> 00:36:43,500
x はそれらが交わる場所にあるだけなので、それが e の周囲にあっても問題ありません。実際、この接点が存在する場所の周囲が e であるという一貫性があるように見えます。これは y が x に等しい線で起こっているため、偶然にも出力でもあります。したがって、明らかに接点の座標は e カンマ e になります。

411
00:36:43,500 --> 00:37:01,500
そして、これを解くと、b 自体の値は何を意味するのでしょうか?x の正確な式があり、x に関する b の式もあります。したがって、これは、b は e の 1 乗を e で割ったものであることを意味しているように見えます。これはとても楽しい奇妙な答えです。 1 の累乗を e で割った値。

412
00:37:01,500 --> 00:37:13,500
そして、それがある程度意味があるかどうかを計算機で確認することができます。それでは、ここに飛び乗って、「おい、デスモス、e の 1 に e は何ですか?」と言うとします。1 オーバー 3 ではなく、1 オーバー e。

413
00:37:13,500 --> 00:37:23,500
はい、確認してください。1 の間です。44と1。45、これはまさに私たちが探していたもので、収束から爆発に移行するポイントです。

414
00:37:24,500 --> 00:37:37,500
e 対 e の 1 であるという解決策を見つけて、非常に満足していると思います。今日はちょっとした宿題が必要な場合は、挑戦的なパズルとして、これが収束する場所の下限を見つけてください。

415
00:37:37,500 --> 00:37:51,500
したがって、これを収束させる最高値を見つけましたが、1 未満の b の値を試し始めることもできます。そうすれば、ここでクモの巣を一種の方法で取り除くことができます。何らかの価値があるだろうということは、クモ

416
00:37:51,500 --> 00:38:01,500
の巣を張ったままにしておくべきだと思います。そこでは、特定の正確な値に焦点を合わせることはできなくなり、代わりに不安定な点になります。そしてあなたにとっての質問は、それはいつ起こるのかということです。

417
00:38:01,500 --> 00:38:09,500
2 つのグラフが交差する点に近づいてから、不安定なために近づかなくなるのはいつですか?

418
00:38:10,500 --> 00:38:24,500
ヒントが必要な場合は、傾きが 1 に等しいときの問題ではなく、マイナス 1 未満になるときの問題であるという事実を考えてください。別のヒントが必要な場合は、次のようにする必要があります。内側に 2 つの e が含まれる式。

419
00:38:24,500 --> 00:38:35,500
したがって、それに到達したい場合は、非常に楽しいパズルです。これにより、電力塔が実際に何かに収束するように、滴定のベースとしてどのような値を使用できるかについて、ある種の収束範囲が得られます。

420
00:38:35,500 --> 00:38:46,500
そして、ここで注目すべき点の 1 つは、値 e への収束から無限大までの爆発に至るまで、決して e と無限大の間の値には収束しないことです。

421
00:38:46,500 --> 00:39:00,500
これはおそらく直観に反するかもしれません。なぜなら、それがどういうわけか滑らかに爆発し、「ああ、1 に収束し、2 に収束し、e に収束し、そして無限に不連続にジャンプするのではなく」と考えるからです。行動。

422
00:39:00,500 --> 00:39:06,500
そして、それは単にグラフがかつて接していたために起こりますが、その後、そこからグラフが分離します。彼らはキスをしていて、そしてキスをやめます。

423
00:39:06,500 --> 00:39:10,500
これで、4 の送電塔の場合に何が起こっているかがわかります。

424
00:39:10,500 --> 00:39:15,500
では、ロジックを振り返ってみると、それはどこで得られたのでしょうか?

425
00:39:15,500 --> 00:39:30,500
素晴らしい。それで、私たちが送電塔を持っているとして、これが 4 に等しい値を解いてください、と言いましたが、これはそのような値が存在すること、そしてこのプロセスが必ず 4 に収束することを前提としています。

426
00:39:30,500 --> 00:39:33,500
しかし、それが e より大きいものに収束することは決してないことがわかりました。

427
00:39:33,500 --> 00:39:40,500
したがって、特に、置換を行う最初のステップでは、解決策が存在するという仮定を利用することになりますが、これは無効です。

428
00:39:41,500 --> 00:39:50,500
そして、それが 2 で機能した理由は、これが 2 に収束する値が存在するためです。そのため、最初の置換を行うとき、それは有効なことです。

429
00:39:50,500 --> 00:39:56,500
そして、それを解く前から、グラフを見れば 2 に収束する値が存在することがわかりました。

430
00:39:56,500 --> 00:40:07,500
たとえそれが 2 の平方根になるか分からなかったとしても、あなたが探すことになるのは、グラフ間のこの交点が y の値 2 になるのはいつなのかということです。

431
00:40:07,500 --> 00:40:13,500
y が x と等しい線上にあるので、x の値も 2 だと思いますが、ここで重要なのは y の値が 2 である必要があるということです。

432
00:40:13,500 --> 00:40:23,500
そして、経験的に、うーん、それが 1 の間のどこかにあることがわかり始めるでしょう。41と1。42 であれば、さらに少し下に向かって二分探索を行うこともできます。

433
00:40:23,500 --> 00:40:34,500
ですから、これは楽しいことだと思います。繰り返される送電塔のこのまったくクレイジーな歌唱プロセスを見てください。それがどの点でも収束しますが、これ

434
00:40:34,500 --> 00:40:40,500
は直観に反します。そして、いつそれが起こるかについて、実際に非常に実質的な発言ができるのです。このような反復プロセスを通じて思考し、収束します。

435
00:40:40,500 --> 00:40:49,500
今日はここまでです。短いレッスンになります。これで、電力塔のパズルについて私が言いたかったことは終わりです。そして、ちょっとした宿題が残ります。

436
00:40:49,500 --> 00:41:03,500
それで、ここでの最後に、Twitter からさらにいくつか質問を受け付けたいと思います。ロックダウンされた数学のハッシュタグを付けて質問すると、それらは私に転送されるかもしれません。テトレーションとこのプロセスに関するものは、まさに私たちが話すべき内容です。について。

437
00:41:03,500 --> 00:41:12,500
素晴らしいですね。指数の三角形がある場合、テトレーションの平方は存在しますか?テトレーションの逆関数にはどのような用途がありますか?

438
00:41:12,500 --> 00:41:22,500
どちらの場合でも、3 つの異なる変数を扱うことになります。何がベースで、何が高さで、そして何が出力になるのかという考えがあります。

439
00:41:23,500 --> 00:41:37,500
どちらの場合でも、3 つだけ存在することになります。テトレーションの 4 は、それを 4 にする理由と同様に、関連する数値が 3 つあるという事実ではありません。基数、指数、そして出力が何であれ、その後に新しい 4 番目のものがあります。

440
00:41:37,500 --> 00:41:44,500
この足し算、掛け算、べき乗のプロセスは、前のプロセスを繰り返す 4 番目のプロセスのようなものです。

441
00:41:44,500 --> 00:41:51,500
ML からの次の質問です。電力塔 x から x へ、x から x までが収束する複素数 x のフラクタル集合の一部を見せていただけますか?

442
00:41:51,500 --> 00:42:09,500
ML さん、ご質問いただきまして大変うれしく思います。はい、基数が 2 の代わりに、または基数が 2 の平方根、つまり 1 の代わりにどうなるか疑問に思われるかもしれません。4、または今調べたすべての値について、累乗する z のような複素数がある場合はどうなるでしょうか?

443
00:42:09,500 --> 00:42:19,500
ここで、複素数値を別の複素数値に上げることが正確に何を意味するかについては、少し微妙なニュアンスがあります。それについて話そうと思います。あまり気にしないでください。それについて話そうと思います。次の講義で。

444
00:42:19,500 --> 00:42:29,500
これは、実数値を e で再表現できる場合と非常によく似ています。複素数で e を考える方法を知っているので、それを行うことができます。

445
00:42:30,500 --> 00:42:40,500
しかし、累乗を複素数に拡張できる方法が存在するという事実を認めるのであれば、間違いなくそれを繰り返すことができます。

446
00:42:40,500 --> 00:42:54,500
それを繰り返すと、「これは収束するのか?」という疑問が湧いてきます。そして、それがいつ収束するのかを尋ね、収束するかどうかに基づいてプレーン上のすべてのピクセルに色を付けるシェーダまたはお気に入りの種類のプログラムを作成すると、これが得られます。

447
00:42:55,500 --> 00:43:09,500
つまり、今見ているものは、軸にラベルが付いていませんが、実際の軸はマイナス 4 あたりから画面の中央を横切っています。5 から 3 まで、そして私が考える負の 2i から 2i までの想像上の軸。

448
00:43:09,500 --> 00:43:21,500
したがって、この黒の水平部分は、先ほど見つけた収束するすべての値に対応します。上限は e から 1 上の e で、下限は、必要に応じて宿題で見つけることができるものです。

449
00:43:22,500 --> 00:43:34,500
ただし、それを超える他の値は発散しており、色分けによってどれだけ早く発散するかがわかります。つまり、黄色は非常に早く爆発することを意味し、青色は爆発がそれほど速くないことを意味します。

450
00:43:34,500 --> 00:43:47,500
そして、明らかに何が起こるかというと、複素数を許可すると、たとえその実数部が e より e の 1 の 1 より大きい場合でも、その虚数部がちょうどそれを収束させるような方法で共謀する可能性があり、これは完全に複雑な結果になり

451
00:43:47,500 --> 00:44:00,500
ます。マンデルブロ集合に非常に似たパターンで、これも特定の反復操作に関して定義されます。そして、これが示しているのは、実際には、これらの電力塔とこの滴定操作に関連して、あなたが予想するよりもはるかに複雑な仕組みがあるということです。

452
00:44:01,500 --> 00:44:18,500
何かを繰り返し適用するとカオスが生じる場合がよくありますが、そのカオスは、フラクタルが出現するという事実に絵的に反映されることが多く、画像の複雑さと出力の予測の難しさが並行しているようなものです。なる予定です。

453
00:44:19,500 --> 00:44:34,500
そして、出力の予測が難しいという事実を説明するために、あなたは未解決の問題が何であるかを知りたいと考えています。実際には世界中の誰も知りませんが、pi で送電塔に乗れるかどうかということです。 power pi から power pi へ、power pi へ、それを行います。

454
00:44:34,500 --> 00:44:47,500
どの時点でも、これが整数と等しくなることはありますか?ほぼ間違いなくそうではありません。これは無理数であり、ある種の確率論的に考えると、非常に可能性が低いように思えますが、確率論的ではなく、決定論的なプロセスです。

455
00:44:47,500 --> 00:45:01,500
実際、高さ 4 の電力塔の場合さえわかりません。ここに 4 円周率しかない場合、円周率の円周率、円周率の 1 乗、円周率の 1 乗を計算すると、最終的には次のようになります。私たちが正確に計算できるよりも大きい、途方もない数です。

456
00:45:01,500 --> 00:45:11,500
これが整数であるかどうかを証明する方法がありません。それを証明できれば、数学の最前線に貢献できることになります。

457
00:45:11,500 --> 00:45:16,500
それがこれらの送電塔について私たちが実際に知らないことのレベルであり、それは一種の興味深いことだと思います。

458
00:45:17,500 --> 00:45:24,500
矢印オペレーターが登場する頭の体操を共有できますか?うん、素晴らしい。させてください、描いてみましょう。

459
00:45:24,500 --> 00:45:40,500
これは IMO から来たものだと思います。これはポー・チェンローが私に話していたことです。きっと彼はどこかでそれについて私がその場で話すよりもわかりやすい話があると思います。ここ。

460
00:45:40,500 --> 00:45:48,500
しかし、これがどのように機能するかというと、6 つの異なるカップがあり、各カップには 1 枚のコインが入っている状態で開始されます。

461
00:45:48,500 --> 00:46:04,500
そして、2 つの異なる操作を利用できます。これらの操作の 1 つは、1 つのカップからコインを取り出すことができるため、1 つのカップからコインを取り除きますが、その後、さらに 2 枚のコインがその右側のカップに落ちます。

462
00:46:04,500 --> 00:46:15,500
したがって、これには一定の方向性があります。さらに 2 つがその右側の 1 つに落ちます。したがって、ここから 3 枚のコインをすべて削除すると、魔法のように 6 枚のコインが入ってくることが想像できます。

463
00:46:15,500 --> 00:46:29,500
5 つ、6 つ、魔法のようにその隣の次のカップに落ちます。そして、それがあなたが持っている唯一の能力である場合、あなたが持つことができるコインの最大数は最終的に63枚になることを理解するためのウォームアップティーザーのようなものです。

464
00:46:29,500 --> 00:46:36,500
コインを取り出して 2 倍にするこのプロセスを 1 つずらして繰り返すだけで、最大 63 枚を得ることができます。

465
00:46:36,500 --> 00:46:50,500
ここで 2 番目の魔法の操作を導入すると、カップの中のコインを 1 枚消して、魔法のように 2 枚を次のコインに落とす代わりに、その直後にある 2 枚を交換します。私は彼らの立場を交換します。

466
00:46:50,500 --> 00:46:57,500
これがあなたが持つ 2 番目の力ですが、エーテルからコインをもたらす必要がないため、それほど魔法ではないようです。

467
00:46:57,500 --> 00:47:11,500
これがもともと組み立てられた方法は、このプロセスを実行した後に手に入れることができる最大金額は、2010 の 2010 乗の 2010 乗より大きいか小さいか、ということだったと思います。

468
00:47:11,500 --> 00:47:26,500
それが質問でした。あなたがこれら 2 つの能力を持っていて、それぞれに 1 コインが入った 6 つのカップから始めたとき、それは大きいでしょうか、あなたが十分に賢ければ手に入れることができる最大のお金は、そのパワータワーより大きいでしょうか、それとも小さいでしょうか。高さ３？

469
00:47:26,500 --> 00:47:38,500
そして、もう一度言いますが、これは、つまり、非常に巨大なため、2回目の操作でそのレベルに近い数値が得られるというのは、ある意味ばかげています。それは物理学で見つけられるものよりもはるかに大きいです。

470
00:47:38,500 --> 00:47:44,500
統計力学などをやっているのでなければ。はい、素晴らしい質問です。

471
00:47:45,500 --> 00:47:56,500
ということで、これ以上皆さんが聞きたいことがなく、それが私に転送されない限り、この件については終わりにしたいと思います。

472
00:47:56,500 --> 00:48:08,500
そしてご参加いただきありがとうございます。このロックダウンシリーズは、最終的にはおそらく 10 話になるだろうと今考えています。したがって、次の 2 つに参加したい場合は、それらが最後の 2 つになります。

473
00:48:08,500 --> 00:48:12,500
それはいい。もう一つ質問があります。

474
00:48:12,500 --> 00:48:19,500
X を X から X まで繰り返し解いて 2 に等しいとき、X の 2 乗が 2 に等しいとき、2 の負の平方根を無視したことになります。素晴らしい。うん。

475
00:48:19,500 --> 00:48:24,500
うん。解の X の 2 乗は 2 に等しくなります。理由を説明できますか?ええ、それは本当に素晴らしいです。

476
00:48:24,500 --> 00:48:32,500
これをもう一度グラフで考えてみましょう。反復プロセスで何が起こっているかをもう少し具体的にするのに役立ちます。

477
00:48:32,500 --> 00:48:36,500
私が言ったとき、B は約 1 ポイント 4 1 に相当します。

478
00:48:36,500 --> 00:48:39,500
わかりました。

479
00:48:39,500 --> 00:48:43,500
2 の負の平方根付近では実際には何も起こっていないようです。

480
00:48:43,500 --> 00:48:49,500
では、なぜそれが起こっているのかを理解してみましょう。その地点に必ずしも交差点があるとは限りません。

481
00:48:49,500 --> 00:48:55,500
これが、送電塔の運用を検討するときに 2 の平方根を計算していた理由です。

482
00:48:55,500 --> 00:49:00,500
思い出してみれば。

483
00:49:00,500 --> 00:49:08,500
私たちは、答えが存在するという仮定を持っていました。この全体、いいえ、先頭に X があるのではなく、無限に等しい 2 まで上がります。

484
00:49:08,500 --> 00:49:13,500
私たちはそれ自体の反映を見ました。X の 2 乗は 2 に相当します。

485
00:49:13,500 --> 00:49:17,500
これが何を意味するのか考えてみましょう。ここで負の平方根があるとは何を意味するのでしょうか?

486
00:49:17,500 --> 00:49:23,500
まあ、あなたが想定しているのは、あなたがマイナスの力を受けているということでしょう。

487
00:49:23,500 --> 00:49:29,500
今考えてみると、X が 2 の負の平方根に等しいと言った場合です。

488
00:49:29,500 --> 00:49:33,500
そうすれば、次のプロセスでそれを引き上げることになります。2 の負の平方根を取得します。

489
00:49:33,500 --> 00:49:39,500
それを負の累乗に上げます。OK、負の累乗します。

490
00:49:39,500 --> 00:49:44,500
私たちはすでに、2 の負の平方根から 1 を超えるまでを考える領域に入っています。

491
00:49:44,500 --> 00:49:51,500
いいえ、マイナス 1 の 2 の平方根から 2 の平方根です。

492
00:49:51,500 --> 00:49:56,500
なぜそれが交差点などに現れないのでしょうか？

493
00:49:56,500 --> 00:50:03,500
実際、考えれば考えるほど、何が起こっているのかについて、私が見逃している非常に明白な答えがあるかもしれません。

494
00:50:03,500 --> 00:50:07,500
私が言いたいこと以外のことについても話すことができます。

495
00:50:07,500 --> 00:50:11,500
負の数は収束範囲に収まらないという事実について話すことができます。

496
00:50:11,500 --> 00:50:18,500
宿題の問題を解く場合と同様に、このように収束する負の X が存在するという仮定は誤りになります。

497
00:50:18,500 --> 00:50:24,500
なぜなら、行き詰まっていることがわかるからです。

498
00:50:24,500 --> 00:50:30,500
最終的にはEからマイナスEになると思います。したがって、失敗したのと同じように、4 つの場合でもロジックは失敗しました。

499
00:50:30,500 --> 00:50:36,500
負の 2 の平方根を代入するだけでは、ロジックは失敗します。それが数値的に内訳されるかどうかはちょっと興味があります。

500
00:50:36,500 --> 00:50:43,500
したがって、Python でこれをもう一度試す場合は、もう一度 1 に設定しましょう。

501
00:50:43,500 --> 00:50:50,500
for ループを見つけてみましょう。次に、2 の負の平方根を計算し、このプロセスを繰り返します。

502
00:50:50,500 --> 00:50:58,500
はい、何が得られるでしょうか？安定してポイントを獲得しています。面白い。

503
00:50:58,500 --> 00:51:06,500
2 の負の平方根。とても安定したポイントを持っているように見えます。決して2に等しい安定したポイントではありません。

504
00:51:06,500 --> 00:51:10,500
その数字は何ですか?そこで何が起こっているのでしょうか？

505
00:51:11,500 --> 00:51:19,500
あのね？私は完全に肯定的ではありません。今、私は決断を下さなければなりません。

506
00:51:19,500 --> 00:51:26,500
単にストリームに呼び込むのではなく、ライブ画面で何が起こっているのかを考えようとしているでしょうか?

507
00:51:26,500 --> 00:51:32,500
それとも、それについて考えて、最後にコメントに固定しますか?

508
00:51:32,500 --> 00:51:38,500
見てみましょう。私たちのロジックでは一体何が起こっているのでしょうか?

509
00:51:38,500 --> 00:51:45,500
2 に収束する値が存在すると仮定します。存在する場合、それはこの特性を満たすことになります。

510
00:51:45,500 --> 00:51:51,500
つまり、x は 2 のプラスまたはマイナスの平方根に等しいと言えると思います。

511
00:51:51,500 --> 00:51:55,500
両方試してみてください。そのうちの 1 つは等しいが、もう 1 つは等しくありません。物語の終わり。

512
00:51:55,500 --> 00:51:59,500
つまり、何か代数的な処理をしているときに、このようなことがよく起こります。このような操作があります。

513
00:51:59,500 --> 00:52:04,500
複数の可能性がありますが、それらをチェックに接続しただけで、そのうちの 1 つが機能しません。

514
00:52:04,500 --> 00:52:10,500
しかし、それは常に非常に満足のいくものではありません。なぜなら、あなたが望んでいるのは、うまくいきそうに見えたのにうまくいかなかった理由に対する何らかの答えだからです。

515
00:52:10,500 --> 00:52:14,500
したがって、4 つに等しい電力塔の場合、なぜそうしなかったのかが非常に明確にわかります。

516
00:52:14,500 --> 00:52:18,500
それが収束するという仮定すら誤りでした。

517
00:52:18,500 --> 00:52:31,500
そして、この場合、私たちの仮定は、負の根 2 がある場合、負の値がある場合、ここにあるものは依然として 2 に等しいということになると思います。

518
00:52:31,500 --> 00:52:40,500
わからない。そうではないことが分かりました。これを行うときは、両方を試して、どちらかがダメなら、それで終わりだと言えます。

519
00:52:40,500 --> 00:52:44,500
しかし、それだけでは私は満足できません。そこで、少し考えてみます。

520
00:52:44,500 --> 00:52:53,500
誰かがより深い考えを持っている場合は、もちろんコメントで共有してください。マイナス 2 の平方根で何が起こっているかのようなものとして、あなたの意見をぜひ聞きたいです。

521
00:52:53,500 --> 00:52:59,500
それは何に収束しますか?なぜこのプロセスと関係があるのでしょうか?

522
00:52:59,500 --> 00:53:08,500
すでに見たように、これは誤った推論であり、無限の電力塔の内部にあるものをすでに行った仮定に置き換えるだけでは少し不安定です。

523
00:53:08,500 --> 00:53:13,500
はい、それについて考えてみます。素晴らしい質問です。これで終わらせるのに最適だと思います。

524
00:53:13,500 --> 00:53:24,500
また、私はそれを尋ねている人の Twitter ハンドルに注目せずにはいられませんでした。なぜなら、この人はこれまでのすべてのロックダウン シリーズでこれらの非常に美しいメモを作成した人だからです。

525
00:53:24,500 --> 00:53:31,500
私がビデオの説明文にこのようなことを入れているのは、ただ単に「そうだ、これは、自分の手書きの文字があんな風に見えたらいいのに」という理由からだ。

526
00:53:31,500 --> 00:53:34,500
誰かがそれらをチェックしたいと思うなら、彼女は素晴らしい仕事をしました。

527
00:53:34,500 --> 00:53:42,500
これで今日のレッスンは終了とさせていただきます。金曜日の同じ時間に、ロックダウン数学シリーズの最後から 2 番目の回でお会いしましょう。

528
00:53:43,500 --> 00:53:49,500


