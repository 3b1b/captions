1
00:00:00,000 --> 00:00:06,000
🎵Music🎵 아마도 이 말을

2
00:00:09,200 --> 00:00:11,200
들을 수 있을 것입니다.

3
00:00:11,200 --> 00:00:14,200
옆집에서 공사가 진행되고 있는데 지난 한

4
00:00:14,200 --> 00:00:17,200
시간, 어쩌면 두 시간 정도는 그들이

5
00:00:17,200 --> 00:00:21,700
하고 있는 모든 공사 중 땅이

6
00:00:21,700 --> 00:00:24,200
무너지는 부분인 것 같고 집 전체가

7
00:00:24,200 --> 00:00:27,200
흔들리고 있습니다. 계속하면들을 수 있습니다.

8
00:00:27,200 --> 00:00:28,500
내 생각엔 지금도 계속되고 있는 것 같아.

9
00:00:28,500 --> 00:00:31,500
그래서 궁금하다면 바로 그 소리입니다.

10
00:00:31,500 --> 00:00:34,500
이제 여러분이 방금 대답한 소개 질문 중 하나를 통해 실제로

11
00:00:34,500 --> 00:00:39,500
오늘 우리가 이야기할 내용에 대해 생각하도록 마음을 준비하게 될 것입니다.

12
00:00:39,500 --> 00:00:43,000
이 질문은 저를 너무 웃겨서 글을 쓰고 곰곰이 생각해보게 만들었습니다.

13
00:00:43,000 --> 00:00:47,500
x가 대부분의 사람들이 이 상자에 입력할

14
00:00:47,500 --> 00:00:49,500
숫자인지 묻는 질문입니다. 2의 x는 무엇입니까?

15
00:00:49,500 --> 00:00:51,500
그리고 그것은 너무 혼란스럽습니다. 왜냐하면 많은 사람들이 1을

16
00:00:51,500 --> 00:00:54,500
입력한다면 나는 2를 입력해야 하지만 모두가 그것에 대해

17
00:00:54,500 --> 00:00:56,500
생각할 것이기 때문에 아마도 4를 입력해야 하지만 모두가

18
00:00:56,500 --> 00:00:59,500
그것에 대해 생각하기 때문입니다. 나는 4에 2개를 해야

19
00:00:59,500 --> 00:01:02,500
하고, 저것에 2개, 저것에 2개를 해야 합니다.

20
00:01:02,500 --> 00:01:06,500
그리고 완벽한 논리학자들이 가득한 방이었다면 무한대로 터지겠지만 사람은

21
00:01:06,500 --> 00:01:10,500
논리학자가 아니고 객관적으로 정답이 있는데, 이런 맥락에서

22
00:01:10,500 --> 00:01:13,500
객관적으로 정답이 무엇인지 살펴볼 수 있습니다. .

23
00:01:13,500 --> 00:01:18,500
그리고 그것은 가장 많은 사람이 2를 입력한 것처럼 보일

24
00:01:18,500 --> 00:01:22,500
것입니다. 이는 4를 입력한 사람이 절대적으로 옳다는 것을 의미합니다.

25
00:01:22,500 --> 00:01:26,500
하지만 완벽한 논리학자를 통해 생각하는 것을 상상하는 게임에서

26
00:01:26,500 --> 00:01:29,500
2 대 2 대 2 대 2를 하는

27
00:01:29,500 --> 00:01:31,500
게임에서 오늘 영상의 주제인 연산에 대해 생각하기 시작합니다.

28
00:01:31,500 --> 00:01:35,500
그것은 일반적으로 학교에서 가르치지 않습니다. 아마도 다른 특정

29
00:01:35,500 --> 00:01:39,500
것들과 동일한 수준의 응용 프로그램이 없기 때문일 것입니다.

30
00:01:39,500 --> 00:01:42,500
하지만 보시다시피, 용어가 실제로 의미하는 바가 무엇인지, 작업이 작동하는지

31
00:01:42,500 --> 00:01:46,500
여부를 실제로 생각하는 매우 중요한 문제 해결 기술과 아이디어를

32
00:01:46,500 --> 00:01:50,500
절대적으로 이끌어내는 몇 가지 퍼즐이 있습니다. 그렇게 하는 것은

33
00:01:50,500 --> 00:01:54,500
상징적으로 할 때 의미가 있는 것처럼 보이지만 실제로 무슨

34
00:01:54,500 --> 00:01:58,500
일이 일어나고 있는지 생각해 보면 실제로 의미가 있습니다.

35
00:01:58,500 --> 00:02:03,500
이 연산을 테트레이션이라고 하며, 여러분이 생각하는 방식은 우리 모두가 가장

36
00:02:03,500 --> 00:02:06,500
먼저 배우는 것 중 하나로 덧셈, 두 숫자를 더하는 방법,

37
00:02:06,500 --> 00:02:11,500
그리고 처음 보는 것처럼 곱셈에 대해 배우는 것입니다. 추가가 반복됩니다.

38
00:02:11,500 --> 00:02:15,500
A 곱하기 B는 A 더하기 A 더하기 A 더하기 A, B는 다른 시간입니다.

39
00:02:15,500 --> 00:02:19,500
그리고 곱셈을 반복하면 어떻게 됩니까? A 곱하기 A

40
00:02:19,500 --> 00:02:23,500
곱하기 A 곱하기 A, B를 여러 번

41
00:02:23,500 --> 00:02:27,500
취하여 A의 B 제곱으로 쓰는 것이 지수입니다.

42
00:02:27,500 --> 00:02:30,500
이제 이 과정에서 한 단계 더 나아가서 지수 계산을

43
00:02:30,500 --> 00:02:33,500
반복하면 어떤 일이 발생하는지 말하면 여기에 이름이 있습니다.

44
00:02:33,500 --> 00:02:36,500
우리는 그것을 테트라레이션이라고 부릅니다. 테트라(Tetra)는 4를 뜻하는 그리스어에서 유래했습니다. 이전

45
00:02:36,500 --> 00:02:43,500
연산을 반복적으로 적용하는 과정의 네 번째 단계이기 때문입니다.

46
00:02:43,500 --> 00:02:46,500
물론 곱셈과 같은 맥락에서 우리는 단순히

47
00:02:46,500 --> 00:02:49,500
숫자를 세는 것 이상으로 아이디어를 확장했습니다.

48
00:02:49,500 --> 00:02:52,500
따라서 이것은 B가 계산 숫자인 경우에만 의미가 있지만 파이 곱하기

49
00:02:52,500 --> 00:02:56,500
E 또는 심지어 2 곱하기 1 더하기 i의 제곱근을 구할

50
00:02:56,500 --> 00:03:00,500
수 있는 복소수 값을 취하는 것과 같은 작업을 수행합니다.

51
00:03:00,500 --> 00:03:05,500
그래서 우리는 그것을 반복적인 추가 이상으로 확장했지만 그것이 일종의

52
00:03:05,500 --> 00:03:07,500
기원이고 우리가 종종 그것에 대해 생각하기 시작하는 방식입니다.

53
00:03:07,500 --> 00:03:11,500
마찬가지로, 매우 유명하게도, 우리가 이 시리즈에서 공정하게 이야기해 온 것 중

54
00:03:11,500 --> 00:03:16,500
하나는 고전적인 오일러 공식 예를 사용하여 지수 계산을 확장하는 것입니다.

55
00:03:16,500 --> 00:03:22,500
하지만 지금 당장은 이 4회화를 정수 횟수 반복한다는 관점에서 생각해 보겠습니다.

56
00:03:22,500 --> 00:03:30,500
들리나요? 맹세코, 우리는 개울 중 하나에서 땅이 무너지는 날이

57
00:03:30,500 --> 00:03:31,500
올 것이라는 생각을 너무 두려워했지만 여기 있습니다.

58
00:03:31,500 --> 00:03:36,500
이제 용어를 조금 더 명확하게 정의하지 않으면 실제로

59
00:03:36,500 --> 00:03:40,500
모호해집니다. 왜냐하면 지수화는 연관적이지 않기 때문입니다. 즉, 이러한

60
00:03:40,500 --> 00:03:45,500
작업을 수행하고 축소하기 시작하는 순서가 중요하다는 의미입니다.

61
00:03:45,500 --> 00:03:49,500
왜냐하면 제가 왼쪽에서 오른쪽으로 간다면, 이것을 2의 제곱으로 쓴다고 가정해

62
00:03:49,500 --> 00:03:53,500
봅시다. 그런 다음 그것을 제곱하고 그 결과를 제곱하면 제가 생각하는

63
00:03:53,500 --> 00:03:58,500
것과는 다른 숫자가 나올 것입니다. 위에서 아래로 가는 것.

64
00:03:58,500 --> 00:04:02,500
내가 가장 먼저 평가하는 것이 맨 위에 있는 2의

65
00:04:02,500 --> 00:04:07,500
2승이고 다음으로 넘어가면 그 이유를 생각해 볼 수 있습니다.

66
00:04:07,500 --> 00:04:12,500
여기, 밑에서부터 접으면 그 밑 부분이 4가 되니까 제곱을 하고, 제곱을 할게요.

67
00:04:12,500 --> 00:04:18,500
4의 제곱은 16이므로 제곱하면 256이 됩니다.

68
00:04:18,500 --> 00:04:23,500
하지만 맨 아래에서 상위 항을 축소하여 시작하면 4가 됩니다.

69
00:04:23,500 --> 00:04:30,500
그리고 현재 상위 항을 축소한다고 생각하면 2의 16이 되고

70
00:04:30,500 --> 00:04:35,500
훨씬 더 큰 숫자가 됩니다. 그것은 65,536입니다.

71
00:04:35,500 --> 00:04:41,500
그리고 일반적으로 위에서 아래로 가면서 반복적으로 지수화하는 과정은 매우

72
00:04:41,500 --> 00:04:46,500
빠르게 폭발하는데, 일반적으로 4차화는 위에서 아래로 가는 부분을 말합니다.

73
00:04:46,500 --> 00:04:49,500
그래서 우리는 위에서부터 평가를 시작하고 아래로 작업합니다.

74
00:04:49,500 --> 00:04:54,500
이를 명확하게 만들고 싶다면 전력 타워로 그리는 대신

75
00:04:54,500 --> 00:04:59,500
반복 프로세스를 매우 정확하게 정의하는 것이 좋습니다.

76
00:04:59,500 --> 00:05:03,500
우리는 1에서 시작할 어떤 값을 가지고 있고, 연속되는 각

77
00:05:03,500 --> 00:05:08,500
값은 이전 값의 거듭제곱이 될 것이라고 말할 수 있습니다.

78
00:05:08,500 --> 00:05:11,500
따라서 하위 1은 2가 됩니다.

79
00:05:11,500 --> 00:05:17,500
서브 2는 서브 1이 무엇이든 간에 2의 거듭제곱이 될 것입니다. 이 경우에는 2의 제곱입니다.

80
00:05:17,500 --> 00:05:25,500
서브 3은 2의 서브 2의 거듭제곱이 될 것입니다. 이제 2의 2의 2가 됩니다.

81
00:05:25,500 --> 00:05:28,500
그리고 연산 순서가 무엇인지에 대해 더 이상 모호함이 없습니다. 왜냐하면 연산 순서가 2개의

82
00:05:28,500 --> 00:05:33,500
항에서 나온 것이므로 먼저 맨 위에 있는 것이 무엇인지 평가해야 하기 때문입니다.

83
00:05:33,500 --> 00:05:42,500
그리고 마찬가지로, 이렇게 계속하면 임의의 값 n에 대한 하위 n이 이전 항의

84
00:05:42,500 --> 00:05:48,500
2인 하위 n 빼기 1과 같습니다. 이 표현식을 펼치고 재귀적 정의로

85
00:05:48,500 --> 00:05:54,500
되돌아가면 무엇을 의미할까요? 얻게 될 것은 2개의 n개의 다른 시간의 전력탑이다.

86
00:05:54,500 --> 00:05:58,500
이렇게 작성하면 좋은 또 다른 점은 실험적이 될 수 있다는 것입니다.

87
00:05:58,500 --> 00:06:03,500
그리고 여러분 모두 아시다시피 저는 사람들이 이와 같은 새로운 작업을 접할 때 매우 즐겁게

88
00:06:03,500 --> 00:06:06,500
놀도록 격려하는 것을 좋아합니다. 이 시리즈의 많은 부분에서 우리는 이를 수행하기 위해 Python을 사용했습니다.

89
00:06:06,500 --> 00:06:11,500
그럼 여기서 해보겠습니다. 이 반복적인 프로세스를 통해 실제로 어떻게 보이는지 살펴보겠습니다.

90
00:06:11,500 --> 00:06:19,500
그래서 터미널로 가서 Python을 열고 a의 초기 값을 1로 설정한

91
00:06:19,500 --> 00:06:23,500
다음 2의 거듭제곱을 살펴보겠습니다. 그 값을 a에 재할당할 테니 이

92
00:06:23,500 --> 00:06:29,500
이중 별표는 우리가 Python에서 권한을 갖는 방식입니다. 그리고 많은 프로그래밍

93
00:06:29,500 --> 00:06:35,500
언어에서 단일 등호는 질문도 아니고 둘이 같은지 묻지도 않습니다. 그것은

94
00:06:35,500 --> 00:06:40,500
수술이다. 오른쪽에 있는 것을 가져와서 왼쪽 값에 밀어넣는다는 뜻입니다.

95
00:06:40,500 --> 00:06:46,500
따라서 우리가 이 작업을 수행하면 a의 값을 이전의 값에 2로 재할당합니다.

96
00:06:46,500 --> 00:06:52,500
프로그래밍을 해본 적이 없는 사람들에게는 이것이 이상할 수 있습니다. 왜냐하면 무언가를 풀고 있는 방정식이 있는 것처럼 보이기 때문입니다.

97
00:06:52,500 --> 00:06:56,500
하지만 이 경우에는 왼쪽이 변경되고 있으며 이는 그에 대한 작업입니다.

98
00:06:56,500 --> 00:07:03,500
따라서 다시 이 작업을 수행하면 a를 2로 거듭제곱하여 이전의 값으로 바꾸는

99
00:07:03,500 --> 00:07:08,500
동일한 과정을 거친 다음 같은 줄에 인쇄하면 4로 변한다고 말할

100
00:07:08,500 --> 00:07:13,500
수 있습니다. 여기서 예측을 해보면 2의 16이 될 것입니다. 방금 본

101
00:07:13,500 --> 00:07:20,500
값은 65,536입니다. 한 걸음만 더 내디디면 높이 5의 송전탑,

102
00:07:20,500 --> 00:07:24,500
즉 5개의 2가 겹겹이 쌓여 있으면 완전히 폭발합니다.

103
00:07:24,500 --> 00:07:31,500
그것은 단지 이 괴물 같은 숫자일 뿐입니다. 우리를 위해 숫자를 찾는 작업조차 수행하는 것은 정말 끔찍한 Python이라고 생각합니다.

104
00:07:31,500 --> 00:07:37,500
나는 그것에 깊은 인상을 받았습니다. 그리고 우리가 원한다면, 그 숫자를 문자열로 생각하고, 그 문자열의

105
00:07:37,500 --> 00:07:42,500
길이는 얼마이며, 그 안에 있는 자릿수를 말해 준다고 말할 수 있습니다.

106
00:07:42,500 --> 00:07:47,500
그래서 우리가 가지고 있는 숫자는 19,000자리 표현인데, 정말 엄청나게 큽니다.

107
00:07:47,500 --> 00:07:54,500
그리고 이것을 한 번 더 반복하여 a를 19,000자리 괴물의 거듭제곱으로

108
00:07:54,500 --> 00:07:59,500
2로 바꾸면 해당 숫자에 필요한 정보를 저장할 수 없습니다.

109
00:07:59,500 --> 00:08:04,500
어떤 방식으로든 나오는 모든 숫자를 인코딩하기 위해 물질을 사용하고

110
00:08:04,500 --> 00:08:08,500
있다면 그것이 지구의 반경과 같은 범위 내에 있다면 그러한

111
00:08:08,500 --> 00:08:13,500
종류의 정보를 저장하려는 시도에서 절대적으로 블랙홀을 생성하게 될 것입니다.

112
00:08:13,500 --> 00:08:19,500
따라서 높이가 6인 송전탑일 뿐이며 어떤 방식으로든 말 그대로 물리적으로 전달할 수 있는 것 이상입니다.

113
00:08:19,500 --> 00:08:26,500
그래서 여러분은 이것이 2가 아닌 경우 다른 숫자에 대해 얼마나 빨리 폭발하는지 물을 수 있습니다.

114
00:08:26,500 --> 00:08:31,500
그리고 제가 여러분께 묻고 싶은 한 가지 사실은 실시간 여론 조사를 통해 시작해

115
00:08:31,500 --> 00:08:36,500
보겠습니다. 2개가 아닌 1을 다룬다면 여기서 무슨 일이 일어날지 예측해 보는 것입니다. 1.

116
00:08:36,500 --> 00:08:42,500
따라서 설명과 화면 위에 있는 링크로 이동하여 실시간 질문에 답하면 B를

117
00:08:42,500 --> 00:08:47,500
1로 두라는 질문을 받게 됩니다. 1이므로 1보다 조금 위에 B, B,

118
00:08:47,500 --> 00:08:52,500
B, B라는 형태의 표현을 생각해 보세요. 이 전력 타워는 높이가 N입니다.

119
00:08:52,500 --> 00:08:56,500
즉, B의 N개의 서로 다른 복사본을 볼 수 있다는 의미입니다.

120
00:08:56,500 --> 00:09:01,500
N은 얼마나 커야 합니까? 표현식의 값이 10자리를 초과할 때까지

121
00:09:01,500 --> 00:09:05,500
이 작업을 몇 번 반복해야 합니까?

122
00:09:05,500 --> 00:09:09,500
그래서 두 명과 함께 우리는 그 일이 일어나기 전에 크기가 5인 타워에 도착해야 했습니다.

123
00:09:09,500 --> 00:09:13,500
5자리 숫자에서 19,000자리 숫자로 뛰어올랐습니다.

124
00:09:13,500 --> 00:09:18,500
그러면 B의 값이 1이 되려면 몇 번이나 이 작업을 수행해야 합니까? 1?

125
00:09:18,500 --> 00:09:23,500
그리고 우리가 차분한 건설 소리를 듣는 동안 속도가 느려질 수도 있다는 점에 대해 잠시 답변해 드리겠습니다.

126
00:09:28,500 --> 00:09:33,500
여기서 이 프로세스를 설명하기 위해 Python으로 돌아가서 여기로

127
00:09:33,500 --> 00:09:38,500
돌아가서 터미널로 돌아가서 A 값을 1로 시작했다고

128
00:09:38,500 --> 00:09:45,500
가정해 보겠습니다. for 루프에서 이 작업을 수행해 보겠습니다. N의 경우 50과 같은 범위에 있습니다.

129
00:09:45,500 --> 00:09:53,500
A를 다시 할당하겠습니다. 반복적인 지수 계산을 하는 대신 반복적으로 1을 곱하면 어떻게 될까요? 1?

130
00:09:53,500 --> 00:09:57,500
그러니까 그냥 반복된 곱셈, 즉 지수가 되어야 합니다.

131
00:09:57,500 --> 00:10:02,500
얼마나 빨리 증가하는지 알 수 있습니다. 여기서 처음 50개 값을 살펴보면 1부터 시작한다는 것을 알

132
00:10:02,500 --> 00:10:09,500
수 있습니다. 1, 1로 갑니다. 21이며, 각 단계에서 실제로는 조금씩, 점프할 때마다 10%씩

133
00:10:09,500 --> 00:10:15,500
증가하며 전형적인 기하급수적 성장을 얻습니다. 그래서 50걸음으로 최대 117걸음이 걸렸습니다.

134
00:10:15,500 --> 00:10:20,500
그것은 기하급수적인 성장이다. 그렇다면 4차 성장이 무엇인지 궁금할 것입니다.

135
00:10:20,500 --> 00:10:23,500
이것을 반복해서 지수화하면 어떻게 될까요?

136
00:10:23,500 --> 00:10:27,500
그리고 제가 대답하기 전에, 당신이 어떻게 생각하는지 살펴보겠습니다.

137
00:10:27,500 --> 00:10:33,500
이것을 반복적으로 지수화하면 여기서 무슨 일이 일어날 것이라고 생각하시나요?

138
00:10:33,500 --> 00:10:41,500
좋아요. 따라서 정답은 실제로 그런 것 이상으로 자라지 않는다는 것입니다.

139
00:10:41,500 --> 00:10:44,500
그리고 아, 흥미롭네요. 그게 세 번째 답변이군요.

140
00:10:44,500 --> 00:10:50,500
그래서 여러분 대부분은 필요한 키가 10에서 100 사이일 것이라고 생각했습니다.

141
00:10:50,500 --> 00:10:53,500
10~100번 하면 10자리가 넘습니다.

142
00:10:53,500 --> 00:10:59,500
두 번째로 가장 일반적인 대답은 1과 10 사이라고 생각하는 것이었습니다. 이는 2가 어떻게 성장하는지와 매우 유사합니다.

143
00:10:59,500 --> 00:11:04,500
세 번째로 가장 흔한 사람들이고, 세 번째로 가장 흔한 사람들 중 얼마나 많은 사람들이 이전에 이

144
00:11:04,500 --> 00:11:10,500
과정을 본 적이 있는지 궁금합니다. 매우 이상하기 때문입니다. 반복적으로 그 자체를 곱하는 아이디어는 원하는 만큼 성장할

145
00:11:10,500 --> 00:11:17,500
것이지만 어쨌든 훨씬 더 강력한 작업처럼 느껴지는 작업을 반복적으로 기하급수적으로 수행하지만 실제로는 제한된 상태를 유지합니다.

146
00:11:18,500 --> 00:11:26,500
그리고 Python으로 다시 돌아가면 이것이 실제로 적용되는 것을 볼 수 있습니다. 이제 각 반복에서

147
00:11:26,500 --> 00:11:32,500
수행 중인 작업은 a를 다시 1로 설정해야 할 것 같습니다. 1 그 자체의 힘.

148
00:11:32,500 --> 00:11:39,500
그리고 우리가 얻는 것은 약간의 초기 성장이지만 빠르게 느려지고 20번의 반복 이내에 실제로

149
00:11:39,500 --> 00:11:44,500
이 값으로 고정된 상태로 유지됩니다. 이 숫자는 변하지 않는 것을 볼 수 있습니다.

150
00:11:44,500 --> 00:11:51,500
그리고 거기에서 무슨 일이 일어나고 있는지 생각해 보면 분명히 a가 그 값과 같을 때 1을 취합니다. 1의 해당 값의 거듭제곱이므로 1입니다.

151
00:11:51,500 --> 00:12:01,500
1의 제곱은 1입니다. 1117, 아, 너무 많이 입력하지 마세요. 실제로는 고정되어 있습니다.

152
00:12:01,500 --> 00:12:03,500
이전과 동일한 값을 얻습니다.

153
00:12:03,500 --> 00:12:12,500
그래서 우리가 이것을 표현할 수 있는 또 다른 방법은 방정식 1이라고 말하는 것입니다. 1의 x제곱은 x와

154
00:12:12,500 --> 00:12:16,500
같습니다. 이를 함수에 연결하면 그 자체로 결과가 나옵니다.

155
00:12:16,500 --> 00:12:24,500
2로 할 때는 이런 현상이 발생하지 않았습니다. 2의 x가 x와 같다면 이에 대한 다른 답을 생각해 보면

156
00:12:24,500 --> 00:12:29,500
정말 이상한 방정식이 됩니다. 하지만 0과 1 또는 그 사이의 값과 같은 값을 시도해 보면

157
00:12:29,500 --> 00:12:34,500
다음을 알 수 있습니다. 실제로 여기에는 답이 없습니다. 반면에 이 경우에는 답을 본 것 같습니다.

158
00:12:34,500 --> 00:12:39,500
그리고 이것이 반복 프로세스에서 의미하는 바는 기본이 2가 아닌 1인 경우입니다. 1을 밑으로

159
00:12:39,500 --> 00:12:46,500
하면 이전 값이 1을 올리는 상황이 됩니다. 1. 그냥 고정된 상태로 유지됩니다.

160
00:12:46,500 --> 00:12:48,500
이제 이것은 많은 흥미로운 질문을 제기하기 시작합니다.

161
00:12:48,500 --> 00:12:57,500
우선, 스위치는 어디에 있나요? 1과 2 사이에서 유한한 상태에서 폭발하는 지점은 무엇입니까?

162
00:12:57,500 --> 00:13:04,500
그리고 믿을 수 없을 정도로 빠르게 폭발해버렸습니다. 기억하세요. 2에서는 컴퓨터가

163
00:13:04,500 --> 00:13:06,500
처리할 수 있는 수준을 넘어서는 것을 얻기까지 5번의 반복만 필요했습니다.

164
00:13:06,500 --> 00:13:15,500
그리고 우리는 이것을 조금 가지고 놀 수 있지만 이것이 수렴할 수 있다는 사실의 또 다른 흥미로운 결과는 매우

165
00:13:15,500 --> 00:13:22,500
기괴한 질문에 대답하기 시작할 수 있다는 것입니다. 여기서는 제가 알 수 없는 값이 있다고 가정할 수 있습니다. x,

166
00:13:22,500 --> 00:13:28,500
그리고 나는 유한한 크기의 전력 타워가 아니라 무한한 크기의 전력 타워입니다. 나는 1의 밑수로

167
00:13:28,500 --> 00:13:32,500
할 수 있는 것과 같은 방식으로 영원히 계속할 것입니다. 1.

168
00:13:32,500 --> 00:13:38,500
예를 들어 4로 수렴되는 x 값을 찾을 수 있나요? 영상 썸네일에 나온 질문입니다.

169
00:13:38,500 --> 00:13:45,500
방금 본 것은 1로 수렴하는 값을 찾을 수 있다는 것입니다. 111782는 계속해서 수렴할

170
00:13:45,500 --> 00:13:51,500
수 있는 값이며 솔루션은 1이 됩니다. 1. 그런데 어떻게 반대 방향으로 갈 수 있나요?

171
00:13:51,500 --> 00:13:57,500
4와 동일한 x 값을 찾을 수 있다는 아이디어를 실제로 어떻게 해결할 수 있습니까?

172
00:13:57,500 --> 00:14:03,500
그리고 여기 여러분이 발견할 수 있는 영리한 트릭이 있는데, 이것은 특정 문제 해결 종류의 수학에서

173
00:14:03,500 --> 00:14:08,500
나타나는데, 무한한 표현이 있고, 흠, 제가 활용할 수 있는 자기 유사성이 있다고 말할 수 있습니다.

174
00:14:08,500 --> 00:14:14,500
내부에는 전체 전력 타워의 복사본이 있습니다. 무한하기 때문에 그 자체의 진짜 복사본입니다.

175
00:14:14,500 --> 00:14:20,500
그렇지 않습니다. 높이는 1에서 이전 높이를 뺀 값이 아닙니다. 왜냐하면 높이는 무한대이기 때문입니다.

176
00:14:21,500 --> 00:14:30,500
그리고 전체 전력 타워가 4와 같다는 가정 하에서 나는 그것을 4로 대체하고 x의 4제곱을 풀면 4가 됩니다.

177
00:14:30,500 --> 00:14:35,500
어디 보자, 그게 뭘까? 제곱근을 취하면 x 제곱이 2라는 것과 같습니다.

178
00:14:35,500 --> 00:14:44,500
그래서 흥미롭게도 x는 2의 제곱근과 같으며 4로 수렴해야 하는 전력 타워를 제공합니다.

179
00:14:44,500 --> 00:14:54,500
좀 펑키해요. 어떤 것이든 수렴한다는 생각은 좀 이상하지만, 2의 제곱근이 정수처럼 깨끗한 값으로 변한다는 생각은 좀 놀랍습니다.

180
00:14:54,500 --> 00:15:04,500
그리고 실제로 또 다른 질문을 드리겠습니다. 방금 했던 것과 동일한 전술을 적용하여 자기 유사성을 활용하여 이러한

181
00:15:04,500 --> 00:15:11,500
상황 중 또 다른 상황을 해결하도록 하겠습니다. 알려지지 않은 염기, 미리 지정된 값과 같은지 확인합니다.

182
00:15:11,500 --> 00:15:17,500
그래서 이번에는 질문이 우리에게 묻습니다. 여기까지 오는 데 잠시 시간을 주면 잠시

183
00:15:17,500 --> 00:15:27,500
시간이 걸리겠지만 괜찮습니다. 아 좋아요. 질문은 방금 시연한 전술을 사용하여 우리에게 묻습니다.

184
00:15:27,500 --> 00:15:33,500
방금 4에 대해 해봤습니다. 방정식 x를 x로 x로 풀고 무한대까지 2가 됩니다.

185
00:15:33,500 --> 00:15:36,500
그래서 저는 여러분에게 그것에 대해 생각해 볼 시간을 드리겠습니다.

186
00:15:41,500 --> 00:15:59,500
그라운드 스매셔가 돌아왔습니다.

187
00:15:59,500 --> 00:16:07,500
야, 어제 우리가 그 일을 하고 있었을 때, 너한테 보여주고 싶은 영상이 있었으면 좋겠어, 어쩌면 내

188
00:16:07,500 --> 00:16:16,500
전화기로 끌어내려고 할 수도 있겠지만, 상황이 너무 많이 흔들리서 회로 기판 더미만 적극적으로 흔들리고 있습니다.

189
00:16:16,500 --> 00:16:19,500
이걸 찾을 수 있는지 한번 볼까요? 정말 재미있네요.

190
00:16:19,500 --> 00:16:30,500
좋아, 그렇지 않을 수도 있습니다. 이것은 아마도 무언가를 스트리밍하는 최악의 방법일 것입니다. 휴대폰의 머리 위 카메라 샷을 찍는 것이지만 이것이 제대로 작동하는지 확인해 보겠습니다.

191
00:16:30,500 --> 00:16:36,500
그래서 공사 현장을 보려고 하다가 옆으로 가보니 회로기판 더미가 그렇게 덜덜 떨리고 있었습니다.

192
00:16:36,500 --> 00:16:40,500
이것이 바로 우리가 처리해야 할 문제이므로 재미있게 즐기시기 바랍니다.

193
00:16:40,500 --> 00:16:49,500
이제 퀴즈를 보면 거의 모든 사람이 같은 답을 중심으로 모이는 것 같습니다. 그리고 저는 여러분이 정답에

194
00:16:49,500 --> 00:16:59,500
도달했다고 가정하겠습니다. 정답은 실제로 2의 제곱근입니다. 왜냐하면 우리가 무한한 전력 타워가 있는 4를 풀기 위해

195
00:16:59,500 --> 00:17:05,500
했던 것과 정확히 동일한 논리를 수행하고 그것이 2라고 가정하고 자기 유사성을 인식하기 때문입니다. 예, 송전탑

196
00:17:05,500 --> 00:17:13,500
자체를 복사한 것과 같습니다. 즉, x의 제곱이 2와 같다는 뜻이고, x가 2의 제곱근과 같다는 뜻입니다.

197
00:17:13,500 --> 00:17:23,500
잠깐만요, 이것은 옳을 수 없습니다. 왜냐하면 이것은 밑이 루트 2일 때 무한 전력 타워가 2로 수렴하지만 다른

198
00:17:23,500 --> 00:17:26,500
한편으로 밑이 루트 2일 때 무한 전력 타워가 4로 수렴한다는 것을 암시하는 것처럼 보이기 때문입니다. 루트 2입니다.

199
00:17:26,500 --> 00:17:33,500
둘 다일 수는 없습니다. 여기에는 수렴되는 매우 결정론적인 프로세스가 있으므로 둘 중 하나여야 합니다.

200
00:17:33,500 --> 00:17:35,500
어쩌면 상황의 전체 논리가 거짓일 수도 있습니다.

201
00:17:35,500 --> 00:17:41,500
그럼, 경험적으로 접근해보자. 프로그래밍을 통해 실제로 어떤 결과가 나오는지 살펴보겠습니다.

202
00:17:41,500 --> 00:17:51,500
다시 돌아가서 변수 a를 1로 재할당하고 작은 루프를 만들겠습니다. 실제로 수학을 가져오겠습니다. 여기에는 제곱근이 필요하기 때문입니다.

203
00:17:51,500 --> 00:17:56,500
그래서 저는 잘 모르겠습니다. 한 번에 20개씩만 할 것이라고 말씀드리고 싶습니다.

204
00:17:56,500 --> 00:18:03,500
나는 a를 취하고 이를 2의 제곱근, 2의 제곱의 a제곱으로 바꾸고, 어떻게 보이는지

205
00:18:03,500 --> 00:18:06,500
인쇄해 보겠습니다. 세미콜론은 필요하지 않을 것 같지만 실제로는 중요하지 않습니다. .

206
00:18:06,500 --> 00:18:13,500
처음 20번의 반복에서는 2에 가까워질수록 속도가 느려지는 것 같고, 또

207
00:18:14,500 --> 00:18:19,500
20번의 반복을 하면 2에 도달하면서 속도가 확실히 느려지는 것 같습니다.

208
00:18:19,500 --> 00:18:27,500
이제 정확히 2에 착지한 것처럼 보이다가 2로 점프하는 이상한 일이 발생합니다. 0004,

209
00:18:27,500 --> 00:18:31,500
여기서 무슨 일이 일어나고 있는지 생각해 보면 어느 시점에서는 2와 같습니다.

210
00:18:31,500 --> 00:18:36,500
그래서 우리는 a가 2와 같다고 말하고 2의 제곱근을 제곱합니다.

211
00:18:36,500 --> 00:18:40,500
하지만 정의에 따르면 2의 제곱근의 2제곱은 2가 되어야 합니다.

212
00:18:40,500 --> 00:18:43,500
그래서 그것은 단지 단순한 숫자 오류가 될 것입니다.

213
00:18:43,500 --> 00:18:48,500
하지만 수학 제곱근 라이브러리는 제곱근을 구현하고 있는 것

214
00:18:48,500 --> 00:18:51,500
같습니다. 부동 소수점에는 항상 약간의 수치 오류가 있을

215
00:18:51,500 --> 00:18:54,500
것이므로 이를 제곱해도 정확히 2를 얻지 못합니다.

216
00:18:54,500 --> 00:18:55,500
괜찮습니다. 문제 없습니다.

217
00:18:55,500 --> 00:19:03,500
그러나 루트 2를 갖는 전력 타워가 있을 때 어떤 일이 발생하는지에 대한 질문에

218
00:19:03,500 --> 00:19:09,500
대한 정답은 그것이 2와 같다거나 이것이 나타내는 일련의 숫자가 2에 접근한다는 것입니다.

219
00:19:09,500 --> 00:19:11,500
그런데 다른 논리에는 어떤 문제가 있습니까?

220
00:19:11,500 --> 00:19:15,500
4와 같아야 한다는 것을 암시하는 것처럼 보이는 논리에 어떤 문제가 있습니까?

221
00:19:15,500 --> 00:19:18,500
그렇다면 우리는 두 가지 일을 해야 한다고 대답하겠습니다.

222
00:19:18,500 --> 00:19:23,500
첫 번째는 이 일을 좀 더 시각적으로, 그래픽적으로 표현하는 것입니다. 이를 통해

223
00:19:23,500 --> 00:19:27,500
우리는 이 반복적인 프로세스에서 무슨 일이 일어나고 있는지 이해하려고 노력할 수 있습니다.

224
00:19:27,500 --> 00:19:33,500
그런 다음 거기에서 어떤 값이 수렴되고 어떤 값이 폭발할지 이해합니다.

225
00:19:33,500 --> 00:19:40,500
그리고 대답함으로써 우리는 이 접근 방식 4와 관련된 논리에 문제가 있는 방향으로 돌아갈 수 있습니다.

226
00:19:40,500 --> 00:19:44,500
그럼 우리의 좋은 친구 Desmos를 살펴보겠습니다.

227
00:19:44,500 --> 00:19:50,500
여기로 가서 Chrome을 열고 아직 보지 마세요. 4나중입니다.

228
00:19:50,500 --> 00:19:54,500
그리고 우리는 여기서 그래프를 살펴보겠습니다.

229
00:19:54,500 --> 00:20:01,500
좋아, 내가 가진 것은 y = x라는 선이고, x 거듭제곱에 대한 함수 b가

230
00:20:01,500 --> 00:20:04,500
있고 b를 2로 설정했기 때문에 우리는 x에 대한 2의 그래프를 보고 있습니다.

231
00:20:04,500 --> 00:20:11,500
그리고 함수를 반복적으로 적용하고 출력을 취한 다음 다시 입력에 연결하는 아이디어에

232
00:20:11,500 --> 00:20:15,500
대해 생각하기 위해 일반적으로 거미줄 다이어그램으로 알려진 것을 그릴 수 있습니다.

233
00:20:15,500 --> 00:20:20,500
이것이 작동하는 방식은 초기 값 1을 입력으로 갖고

234
00:20:20,500 --> 00:20:26,500
다음 값은 f/1이 되는 것입니다. 함수에 1을 연결하겠습니다.

235
00:20:26,500 --> 00:20:32,500
이것이 의미하는 바는 그래프에 도달할 때까지 수직으로 움직인다는 것입니다.

236
00:20:32,500 --> 00:20:35,500
이 경우 2의 1의 곱은 2이므로 2라는 값에 도달하겠습니다.

237
00:20:35,500 --> 00:20:40,500
하지만 거기에서 내가 원하는 것은 방금 얻은 출력, 즉 2가 함수의 입력이 되는 것입니다.

238
00:20:40,500 --> 00:20:44,500
그러나 출력이 y축에 표시되고 입력이 x축에 표시되는 경우

239
00:20:44,500 --> 00:20:49,500
필요한 것은 y 값이 x 값과 동일한 지점입니다.

240
00:20:49,500 --> 00:20:53,500
따라서 y 값이 x 값과 같아질 때까지 수평으로 걷는다면 2가 x

241
00:20:53,500 --> 00:20:59,500
값인 지점에 도달하게 되며 이제 2를 입력으로 생각할 수 있습니다.

242
00:20:59,500 --> 00:21:06,500
그러기 위해 저는 y가 x와 같은 선에 도달할 때까지 걷습니다.

243
00:21:06,500 --> 00:21:11,500
왜냐하면 선에 도달하면 2,2를 보게 되므로 그래프에 도달할 때까지

244
00:21:11,500 --> 00:21:15,500
수직으로 이동하여 2를 입력으로 처리할 수 있기 때문입니다. 이것이 어떻게

245
00:21:15,500 --> 00:21:19,500
작동하는지 알아보겠습니다. 즉, 반복 프로세스의 다음 지점은 2의 제곱,

246
00:21:19,500 --> 00:21:23,500
즉 2의 제곱, 즉 4가 될 것이라는 의미입니다. 그런 다음

247
00:21:23,500 --> 00:21:28,500
오른쪽으로 이동하여 출력을 입력을 통해 평면에서 x 값이 4인

248
00:21:28,500 --> 00:21:32,500
지점을 찾은 다음 해당 지점에 도달하면 이 선에서 튀어나와 y는

249
00:21:32,500 --> 00:21:35,500
x와 같고 그래프에 다시 도달할 때까지 수직으로 이동한다고 생각합니다.

250
00:21:35,500 --> 00:21:41,500
그리고 이번에는 16이 되어서야 그래프에 도달하고 x도 16이 될

251
00:21:42,500 --> 00:21:47,500
때까지 오른쪽으로 이동합니다. 그런 다음 거기에서 수직으로 이동하는

252
00:21:47,500 --> 00:21:52,500
데 꽤 오랜 시간이 걸립니다. 잠시 후 65,000

253
00:21:52,500 --> 00:21:57,500
부근에서 그래프와 다시 교차하고 오른쪽으로 이동하여 역시 65,000인 x

254
00:21:57,500 --> 00:22:01,500
좌표에 도달합니다. 거기에서 Desmos는 다음 수직선을 그리는 것을

255
00:22:01,500 --> 00:22:08,500
완전히 포기합니다. 우리가 본 것처럼, 높이를 나타내는 숫자가

256
00:22:08,500 --> 00:22:10,500
19,000자리 숫자인 높이에 도달해야 하므로 거기서는 우리를 포기합니다.

257
00:22:10,500 --> 00:22:16,500
하지만 이러한 거미줄 다이어그램의 관점에서 생각해 보면 이제 그 기반이

258
00:22:16,500 --> 00:22:18,500
무엇인지 가지고 놀기 시작하면 무슨 일이 일어날지 알 수 있습니다.

259
00:22:18,500 --> 00:22:22,500
그 베이스는 무엇인가요? 베이스는 땅을 부수는 활동입니다.

260
00:22:22,500 --> 00:22:26,500
어떤 시점에서는 그래프가 실제로 서로 교차합니다.

261
00:22:26,500 --> 00:22:32,500
그래서 특히 우리는 1을 보고 있었습니다. 1 이전에는 그렇습니다. 완전히 교차하지만

262
00:22:32,500 --> 00:22:37,500
최대 약 1까지입니다. 41, 이는 2의 제곱근에 해당합니다. 이

263
00:22:37,500 --> 00:22:42,500
프로세스에서 어떤 일이 일어나는지 살펴보면 출력을 보고, 출력을 입력으로 바꾸고,

264
00:22:42,500 --> 00:22:45,500
새로운 출력을 보고, 출력을 입력으로 바꾸고 앞뒤로 바운스합니다. ,

265
00:22:45,500 --> 00:22:50,500
우리는 이 그래프가 서로 교차하는 값을 향해, b의 x,

266
00:22:50,500 --> 00:22:56,500
b의 x제곱이 x와 같은 값을 향해 튕겨 나가고 있습니다.

267
00:22:56,500 --> 00:23:06,500
그리고 특히, 그 밑이 2의 제곱근이고, x = x 거듭제곱에 대한 2의 제곱근의

268
00:23:06,500 --> 00:23:10,500
해를 구한다면, 알다시피, 이것을 어떻게 체계적으로 풀 수 있을지 생각하기는 쉽지 않습니다.

269
00:23:10,500 --> 00:23:13,500
특별한 경우에, 해가 x = 2라고 말하면 여러분은 내 말을 믿을 것입니다.

270
00:23:13,500 --> 00:23:15,500
그냥 연결해서 해결하시면 됩니다.

271
00:23:15,500 --> 00:23:20,500
따라서 그래프를 보면, 만약 b라면 실제로 여기에서

272
00:23:20,500 --> 00:23:22,500
단지 근사치보다는 정확히 2의 제곱근으로 만들어 보겠습니다.

273
00:23:22,500 --> 00:23:28,500
그래서 b는 2의 제곱근, 아니 2의 제곱근이 될 것입니다.

274
00:23:28,500 --> 00:23:32,500
교차점은 정확히 2에 있으므로 반복 프로세스가 이에 접근하는 것을 볼 수 있습니다.

275
00:23:32,500 --> 00:23:34,500
좋아요, 그거 좀 흥미롭네요.

276
00:23:34,500 --> 00:23:39,500
이는 또한 우리가 원하는 경우, 사물이 수렴되는 시점과 수렴되지 않는 시점 사이에

277
00:23:39,500 --> 00:23:45,500
전환이 발생하는 위치를 이해하려는 경우 이에 대해 어떻게 생각해야 하는지 보여줍니다.

278
00:23:45,500 --> 00:23:52,500
우리가 원하는 것은 b의 값이 무엇인지 아는 것입니다. 사물이 탈출할 수 있는 곳,

279
00:23:52,500 --> 00:23:58,500
교차점이 없는 곳, 사물이 탈출할 수 없는 곳, 교차점이 있는 곳으로 가야 합니다.

280
00:23:58,500 --> 00:24:02,500
그건 그렇고, 설명에 이 특정 Desmos 그래프에 대한 링크를

281
00:24:02,500 --> 00:24:06,500
남겨두었으니, 거기로 내려가서 함께 플레이하고 싶다면 언제든지 환영입니다.

282
00:24:06,500 --> 00:24:11,500
제가 명시해야 할 한 가지 사실은 그들이 교차한다는 사실인데, 이는 실제로

283
00:24:11,500 --> 00:24:15,500
이 거미줄의 반복 프로세스가 반드시 수렴된다는 것을 보장하는 데 충분하지 않습니다.

284
00:24:15,500 --> 00:24:22,500
우리 함수의 그래프(이 경우 b 대 x)가 1보다 작은 기울기에서 교차하는 것이 중요합니다.

285
00:24:22,500 --> 00:24:24,500
그리고 우리는 그것이 왜 사실인지 생각해 볼 수 있습니다.

286
00:24:24,500 --> 00:24:31,500
다시 생각해 보면, 제가 지수 함수나 그런 곡선을 다루지

287
00:24:31,500 --> 00:24:34,500
않고 그냥 일반적인 함수를 다루고 있었다고 가정해 보겠습니다.

288
00:24:34,500 --> 00:24:42,500
y=x 선을 보세요. 구불구불한 선을 따라 교차하지만

289
00:24:42,500 --> 00:24:44,500
기울기가 1보다 큰 함수가 있다고 가정해 보겠습니다.

290
00:24:44,500 --> 00:24:48,500
그런 다음 반복 프로세스를 수행하면 일부 출력이 생기고 y가

291
00:24:48,500 --> 00:24:52,500
x와 같아질 때까지 수평으로 이동하여 이를 입력으로 바꾸자고 말합니다.

292
00:24:52,500 --> 00:24:55,500
수직으로 걸어가면서 새로운 출력을 살펴보세요.

293
00:24:55,500 --> 00:24:57,500
부수고, 부수고, 부수세요.

294
00:24:57,500 --> 00:25:05,500
새로운 입력을 보거나, 입력에 도달할 때까지 수평으로 걸어가면서 해당 출력을 입력으로 전환합니다.

295
00:25:05,500 --> 00:25:07,500
그리고 그 과정을 반복하세요.

296
00:25:07,500 --> 00:25:11,500
1보다 큰 경사로 교차했기 때문에 이런 일이 일어나고 있는

297
00:25:11,500 --> 00:25:14,500
것을 볼 수 있습니다. 우리는 실제로 교차점에서 멀어지고 있습니다.

298
00:25:14,500 --> 00:25:19,500
그래서 단순히 안정된 점이 아닌지 확인하기 위해 단순히 그래프

299
00:25:19,500 --> 00:25:22,500
간의 공통점이 아닌, 이 과정을 반복하면 안정적이게 됩니다.

300
00:25:22,500 --> 00:25:24,500
그 기울기는 1보다 작아야 합니다.

301
00:25:24,500 --> 00:25:27,500
그래서 저는 이런 종류의 과정을 어떻게 생각해야 하는지에 대한 또 다른 관점에 대한 전체 영상을 제공했습니다.

302
00:25:27,500 --> 00:25:31,500
미적분학에서 가르치지 않는 것과 같은 터무니없는 제목을 붙인 것 같습니다. 하지만 이것에 대한 더

303
00:25:31,500 --> 00:25:38,500
많은 예와 재미 있고 무한 반복되는 객체를 보고 싶다면 그곳을 방문할 수 있습니다.

304
00:25:38,500 --> 00:25:44,500
이제 우리의 경우 기울기가 1보다 작은 경우이므로 작동합니다.

305
00:25:44,500 --> 00:25:47,500
하지만 두 번째 교차점에서는 실제로 기울기가 1보다 큽니다.

306
00:25:47,500 --> 00:25:53,500
따라서 첫 번째 값이 1이 아닌

307
00:25:53,500 --> 00:25:56,500
반복 프로세스를 변경했지만 이 경우 4로

308
00:25:56,500 --> 00:26:01,500
설정하면 보시다시피 내 반복 프로세스가 실제로

309
00:26:01,500 --> 00:26:03,500
교차점에서 벗어나 실제로 폭발할 것입니다. 무한대.

310
00:26:03,500 --> 00:26:05,500
그래서 항상 재미있어요.

311
00:26:05,500 --> 00:26:07,500
다시 1로 바꾸겠습니다.

312
00:26:07,500 --> 00:26:14,500
Desmos 정의에서 4개의 재귀 루프를 수행할 수 없다는 사실에 짜증이 난 작은 메모를 살펴보겠습니다.

313
00:26:14,500 --> 00:26:18,500
그리고 우리가 해결해야 할 것이 무엇인지 알 수 있습니다.

314
00:26:18,500 --> 00:26:25,500
여기서 재미있는 점 중 하나는 1입니다. 45는 실제로 교차하는 지점 바로 위에 있는 것처럼 보이며,

315
00:26:25,500 --> 00:26:33,500
결국 폭발하기 전까지 오랜 시간 동안 어느 정도 안정적으로 유지되는 튀고 튀는 현상이 있습니다.

316
00:26:33,500 --> 00:26:38,500
그리고 이것을 그래픽적으로 생각하는 것이 아니라 수치적으로만 가지고 놀고 있다고 상상해보세요.

317
00:26:38,500 --> 00:26:43,500
따라서 A가 1에서 시작하는 이전과 동일한 프로세스를 수행했다면

318
00:26:43,500 --> 00:26:49,500
반복적으로 지수화를 수행하여 1로 만들 것입니다. 대신 45.

319
00:26:49,500 --> 00:26:52,500
그리고 이것에 대해 50개의 값을 부여해 봅시다.

320
00:26:52,500 --> 00:26:56,500
그 과정은 결국 폭발합니다. 이 오버플로 오류가 발생합니다.

321
00:26:56,500 --> 00:27:02,500
그러나 무슨 일이 일어나고 있는지 시각적으로 볼 수 없다면 프로세스는 매우 혼란스러울 것입니다.

322
00:27:02,500 --> 00:27:11,500
1시에 시작합니다. 45에서는 성장하고 불안정한 상태를 유지하지만 2에서는 그렇게 많이 움직이지 않는 것 같습니다. 71828 지역.

323
00:27:11,500 --> 00:27:15,500
어떤 이유에서인지 주변의 움직임은 끔찍할 정도로 느리게 보입니다.

324
00:27:15,500 --> 00:27:19,500
그러나 3영역으로 조금 더 커지기 시작하면 한동안 거기에 머물게 됩니다.

325
00:27:19,500 --> 00:27:27,500
4 지역에는 두 가지 값이 있습니다. 그다음 6개, 9개, 39개, 그리고 그 이후에는 200만 개까지 불어납니다.

326
00:27:27,500 --> 00:27:29,500
그리고 거기부터는 컴퓨터가 처리할 수 있는 것보다 더 큽니다.

327
00:27:29,500 --> 00:27:34,500
그래서 우리가 무슨 일이 일어나고 있는지 잘 이해하고 있다는 점을 제외하면 그것은 매우 혼란스러울 것입니다.

328
00:27:34,500 --> 00:27:37,500
그래프는 거의 닿지만 완전히 닿지는 않습니다.

329
00:27:37,500 --> 00:27:42,500
따라서 1 사이 어딘가에 있습니다. 44와 1. 45가 우리가 찾고 있는 것입니다.

330
00:27:42,500 --> 00:27:45,500
그리고 여러분은 이것을 미적분학의 관점에서 생각할 수도 있습니다.

331
00:27:45,500 --> 00:27:52,500
우리가 원하는 것은 이 그래프의 접선이 y=x 선과 같은 때를 아는 것입니다.

332
00:27:52,500 --> 00:27:57,500
x에 대한 그래프 b가 y와 x가 같은 선에 접하는 때는 언제입니까?

333
00:27:57,500 --> 00:28:02,500
그리고 우리가 그것을 해결하기 위해 필요한 방정식을 설정하는 것보다는 여러분도 똑같이 하도록 하겠습니다.

334
00:28:02,500 --> 00:28:07,500
b의 값을 구하는 이 조건을 살펴보도록 하겠습니다.

335
00:28:07,500 --> 00:28:11,500
그럼 질문이 우리에게 더 구체적으로 무엇을 묻는지 읽어보겠습니다.

336
00:28:11,500 --> 00:28:20,500
우리는 y의 그래프가 b와 x의 그래프가 y가 x와 같은 그래프에 접하도록 하는 b 값을 원합니다.

337
00:28:20,500 --> 00:28:25,500
다음 중 우리가 풀어야 할 방정식 쌍을 나타내는 것은 무엇입니까?

338
00:28:25,500 --> 00:28:27,500
좋습니다. 잠시 생각해 보세요.

339
00:28:27,500 --> 00:28:31,500
다음 중 우리가 풀어야 할 방정식 쌍은 무엇입니까?

340
00:28:32,500 --> 00:28:48,500
음악 당신이 그것에 대해 생각하고 있는 동안

341
00:28:48,500 --> 00:28:52,500
나는 청중으로부터 몇 가지 질문을 받겠습니다.

342
00:28:52,500 --> 00:28:54,500
우리는 가지고 있습니다.

343
00:28:54,500 --> 00:28:58,500
. . 그래서 즉시 나는 반복적인 거부감이 펜테이션이라는 생각이 들었습니다.

344
00:28:58,500 --> 00:29:00,500
아니면 그게 유용한 아이디어인가요?

345
00:29:00,500 --> 00:29:06,500
예, 이러한 프로세스를 반복한다는 아이디어에 대해 이야기하는 전체 표기법이 있습니다.

346
00:29:06,500 --> 00:29:08,500
Knuth 화살표 표기법이라고 합니다.

347
00:29:08,500 --> 00:29:10,500
그리고 원하는 만큼 많이 가질 수 있습니다.

348
00:29:10,500 --> 00:29:20,500
따라서 이것이 작동하는 방식은 제가 화살표 b와 같은 것을 쓴다면 그것은 a의 b제곱과 같습니다.

349
00:29:20,500 --> 00:29:26,500
그런데 두 개의 화살표가 있는 것은 그 과정의 반복입니다.

350
00:29:26,500 --> 00:29:28,500
알다시피, b 번.

351
00:29:30,500 --> 00:29:33,500
그리고 죄송합니다. 화살표 두 개와 b가 있습니다.

352
00:29:33,500 --> 00:29:40,500
화살표 세 개, 화살표 세 개, 그리고 ab가 있다면 내가 반복하는 것은 이중 화살표를 수행하는 과정입니다.

353
00:29:40,500 --> 00:29:44,500
숫자에 대해 생각하기 시작하면 정말 놀랍도록 큽니다.

354
00:29:44,500 --> 00:29:46,500
2, 3과 같은 짝수입니다.

355
00:29:46,500 --> 00:29:51,500
이 과정을 여러 번 반복한다는 생각은 정말 말도 안되는 일입니다.

356
00:29:51,500 --> 00:29:54,500
그리고 당신은 점점 더 많은 화살을 가지고 계속 나아갈 수 있습니다.

357
00:29:54,500 --> 00:30:01,500
그리고 여러분 중에 그램 상수에 대해 배우지 않은 사람이 있다면 지금 바로 해당 숫자 파일로 가서 그램 상수가 어떻게 정의되는지 확인하세요.

358
00:30:01,500 --> 00:30:05,500
왜냐하면 이런 종류의 화살표 작업이 포함되어 있고 정말 미친 일이기 때문입니다.

359
00:30:05,500 --> 00:30:10,500
그리고 그것은 수학 생활에서 그램 상수를 처음으로 보게 되는 가장 놀라운 순간 중 하나입니다.

360
00:30:10,500 --> 00:30:12,500
그래서 추천하고 싶습니다.

361
00:30:12,500 --> 00:30:19,500
좋습니다. 다음은 1입니다. 1의 x승은 x와 같으므로 Wolfram Alpha는 두 가지 실제 해를 산출합니다.

362
00:30:19,500 --> 00:30:20,500
아, 좋은 질문이네요.

363
00:30:20,500 --> 00:30:22,500
그 중 하나는 우리가 수렴하는 것입니다.

364
00:30:22,500 --> 00:30:25,500
다른 하나는 38 정도입니다. 29.

365
00:30:25,500 --> 00:30:27,500
엄청난. 두 번째 솔루션은 어떻게 되나요?

366
00:30:27,500 --> 00:30:30,500
우리가 가지고 있는 그래프를 통해 정확하게 살펴볼 수 있습니다.

367
00:30:30,500 --> 00:30:35,500
그래서 우리가 b를 취하고 그것을 1로 만든다면. 1.

368
00:30:35,500 --> 00:30:36,500
좋아요.

369
00:30:36,500 --> 00:30:41,500
1보다 큰 경사로 교차하는 곳에서 어떻게 되는지 얘기한 것입니다.

370
00:30:41,500 --> 00:30:45,500
네, 반복 프로세스의 고정 지점입니다.

371
00:30:45,500 --> 00:30:46,500
그러나 그것은 안정된 고정점이 아니다.

372
00:30:46,500 --> 00:30:49,500
여기 위에 방금 참조한 38개의 값이 있습니다.

373
00:30:49,500 --> 00:30:58,500
그리고 1보다 큰 기울기에서 교차하기 때문에 실제로 거기에 가까운 값을 프로세스에 시드하더라도 해당 값에서 벗어나게 됩니다.

374
00:30:58,500 --> 00:31:05,500
따라서 프로세스를 시드하는 경우, 1과 같은 값에서 시작하는 경우 이것이 결국 발견하게 될 교차점입니다.

375
00:31:05,500 --> 00:31:07,500
정말 좋은 질문이네요.

376
00:31:07,500 --> 00:31:12,500
셋째, 테트라화와 같은 작업에 대한 실제 사용 사례가 있습니까?

377
00:31:12,500 --> 00:31:15,500
나는 매우 과학적인 분야를 연구했지만 이 연산자를 본 적이 없습니다.

378
00:31:15,500 --> 00:31:17,500
난 정말 궁금해.

379
00:31:17,500 --> 00:31:20,500
좋아요, 그게 문제의 지점입니다.

380
00:31:20,500 --> 00:31:31,500
그래서 마지막에 혼돈과 프랙탈이 있는 역할에 대해 조금 이야기하겠습니다. 이는 그 자체로 유용한 다른 것들과 관련되어 있다고 말하기 때문에 기껏해야 미약한 것입니다.

381
00:31:31,500 --> 00:31:37,500
저는 개인적으로 야생에서 과학을 하면서 펑펑, 테트라레이션이 일어나는 곳을 생각할 수 없습니다.

382
00:31:37,500 --> 00:31:45,500
나는 이 작업이 일어날 것이라고 전혀 생각하지 않을 것 같은 일종의 수수께끼 유형의 퍼즐과 같은 퍼즐을 생각할 수 있지만 실제로는 발생합니다.

383
00:31:45,500 --> 00:31:48,500
마지막에 시간이 된다면 여러분과 공유해도 좋을 것 같습니다.

384
00:31:48,500 --> 00:31:58,500
지금 이런 것을 배우는 동기는 장면 전환이 혼란스러운 점을 용서해 주세요. 실제로 우리 앞에 놓인 퍼즐을 해결하는 과정, 즉 4와 같은 반복되는

385
00:31:58,500 --> 00:32:08,500
탑에 무슨 일이 있었는지 이해하는 것입니다. , 그리고 우리가 찾으려는 것이 무엇인지, 수렴하는 것과 수렴하지 않는 것 사이의 전환점이 어디에 있는지 이해합니다.

386
00:32:08,500 --> 00:32:14,500
이는 보다 실용적인 반복 프로세스를 포함하는 다른 작업에도 적용되는 문제 해결 전략입니다.

387
00:32:14,500 --> 00:32:19,500
그리고 반복적인 과정은 과학 전반에 걸쳐 분명히 나타납니다. 제 말은, 혼돈 이론이 거기에서 가장 큰 이론과 같다는 겁니다.

388
00:32:19,500 --> 00:32:30,500
그래서 그 모든 것을 사람들의 질문에 대답하는 측면으로 하고, 우리가 진행하면서 트위터를 통해 더 많이 생각하고 아마도 마지막에 더 많은 것을 할 것입니다. 우리 문제에 대해 당신이 어떻게 했는지 봅시다.

389
00:32:30,500 --> 00:32:42,500
그래서 우리는 여기서 연립방정식을 찾고 있으며 여러분 중 1777명이 얻은 정답을 찾고 있습니다. 제 생각엔 그것은 프랑스 혁명의 영역은 아니지만 여러분의 미국

390
00:32:42,500 --> 00:32:51,500
혁명의 영역은 b의 x = x이므로 우리는 그것들이 교차해야 하고, 더욱이 우리가 원하는 것은 그들이 교차하는 곳에서 기울기가 같아야 한다는 것입니다.

391
00:32:51,500 --> 00:33:01,500
그리고 x에 대한 b의 미분은 그 자체이지만 b의 자연 로그에 의해 스케일링됩니다. 그리고 우리는 그 기울기가 1이 되기를 원합니다. 왜냐하면 그것이 우리가 보고 있는 그래프의 기울기와 같아야 하기 때문입니다.

392
00:33:01,500 --> 00:33:09,500
그리고 지수 함수의 도함수가 무엇인지 기억하지 못한다면, e의 x에 대한 도함수는 그 자신의 도함수라는 것을 기억한다면,

393
00:33:09,500 --> 00:33:18,500
e에 대한 미적분학에서 기억나는 것이 하나 있다면 그것은 e의 x에 대한 자체 도함수가 되어야 합니다.

394
00:33:18,500 --> 00:33:25,500
b를 b의 자연 로그에 e로 쓸 수 있으므로 그 모든 것을 x에 쓸 수 있습니다.

395
00:33:25,500 --> 00:33:31,500
그래서 이것은 e를 b 곱하기 x의 자연로그로 표현하는 것과 같습니다. 지난 강의에서 이에 대해 이야기한 것 같습니다.

396
00:33:31,500 --> 00:33:50,500
따라서 만약 여러분이 이것의 도함수를 취하고 싶다면, 그것의 도함수를 취하세요. 한편으로는 이것은 이것의 도함수여야 합니다. 이것은 연쇄 법칙에 의해 지수에 상수가 있고, b 곱하기 그 자체의 자연 로그, e에 대한 것입니다. ln b 곱하기 x입니다.

397
00:33:50,500 --> 00:33:56,500
그래서 우리가 보고 있는 것은 그 자체여야 하지만 어떤 것에 의해 크기가 조정된 것이고 그 어떤 것은 b의 자연 로그였습니다.

398
00:33:56,500 --> 00:34:10,500
이제 우리의 그래프가 y=x에 접하게 접하는 시점이 언제인지 이해하기 위한 퍼즐을 위해 실제로 이 방정식, 즉 방정식 시스템을 풀어보겠습니다.

399
00:34:10,500 --> 00:34:25,500
우리는 해당 해가 발생하는 곳에서 x 값을 찾고 있기 때문에 x에 대한 곡선 b가 해당 지점에서 x와 같다는 것을 알고 있으며 b 곱하기 자체의 자연 로그인 기울기가 1과 같다는 것을 알고 있습니다.

400
00:34:25,500 --> 00:34:40,500
이제 이 문제를 해결하기 위해 제가 할 수 있는 첫 번째 일은 b를 x로 단순화하여 여기에 적용하고 b 곱하기 x가 1이 되는 자연 로그를 쓸 수 있다는 점입니다.

401
00:34:40,500 --> 00:34:53,500
그리고 그것이 나에게 주는 것은 b가 1을 x로 나눈 것과 같다는 것입니다. 모두 매우 훌륭합니다. 아니요, 아니요, 그것은 나에게 제공하지 않습니다. b의 자연 로그는 x 분의 1이라는 것입니다.

402
00:34:53,500 --> 00:35:01,500
이는 e에 x 분의 1이 b와 같다고 말하는 것과 같은 진술입니다.

403
00:35:02,500 --> 00:35:12,500
좋아요, 이제 그 편견은 무엇인가요? 글쎄요, 그것은 우리에게 x에 관한 b의 표현을 제공합니다. 그래서 이 윗 부분으로 가서 x만 포함하는 방정식을 얻을 수 있습니다.

404
00:35:12,500 --> 00:35:22,500
그것은 e의 x 나누기 1의 x제곱이 될 것입니다. 저는 단지 b를 우리가 찾은 것으로 대체할 뿐입니다. 그리고 그것은 x와 같아야 합니다.

405
00:35:22,500 --> 00:35:34,500
그러나 반면에 e의 x x 거듭제곱은 단순히 e로 단순화되며 우리가 발견한 것은 x가 e와 같다는 것입니다.

406
00:35:34,500 --> 00:35:47,500
그건 그렇고, 저는 어젯밤에 이 수업을 일종의 시험삼아 하고 있었습니다. 가끔은 비공개 링크인 트위터 스트림에 대한 링크를 게시하고 100만 개가 되자마자 다음과 같이 말하곤 했습니다. 여기로 올라오세요. 저는 트윗을 삭제하고 연습을 해보겠습니다.

407
00:35:47,500 --> 00:36:01,500
그리고 제가 이 문제를 해결하고 있을 때 어떤 이유에서인지 이 지점에 도달할 때까지 10분 정도 혼란스러워했고 그게 옳을 수 없다고 생각했습니다. 왜냐하면 우리는 1 사이의 값을 찾고 있기 때문입니다. 44와 1. 45이므로 x는 e가 될 수 없습니다. 너무 크네요. 2와 같습니다. 718.

408
00:36:01,500 --> 00:36:06,500
그래서 나는 돌아가서 내가 무엇을 잘못했는지, 도대체 여기서 무엇이 잘못되었는지 생각하려고 노력했습니다.

409
00:36:06,500 --> 00:36:25,500
시간이 너무 오래 걸려서 약간 당혹스러웠지만 결국에는 아니란 걸 깨달았습니다. 바보야. 우리가 1 사이의 x 값을 찾고 있는 게 아니구나. 44와 1. 45, 그것은 우리가 여기에서 놀 때 지수의 밑이 되는 b의 조건이었습니다.

410
00:36:25,500 --> 00:36:43,500
x는 그들이 교차하는 모든 곳이므로 e 주위에 있는 것은 괜찮습니다. 실제로 이 접선 지점이 있는 곳 주위에서 e라는 것이 일관되게 보입니다. 우연히도 이것은 선 y가 x와 같기 때문에 출력이기도 합니다. , 따라서 접선 지점은 분명히 e 쉼표 e 좌표를 갖습니다.

411
00:36:43,500 --> 00:37:01,500
그리고 우리가 풀면 b 자체의 값은 무엇을 의미합니까? x에 대한 정확한 표현이 있고, b에 대한 x 표현이 있습니다. 따라서 이는 b가 e의 1승을 e로 나눈다는 것을 의미하는 것처럼 보입니다. 이는 매우 기괴한 답입니다. 1의 거듭제곱을 e로 나눈 값입니다.

412
00:37:01,500 --> 00:37:13,500
그리고 우리는 그것이 어느 정도 의미가 있는지 계산기를 사용하여 확인할 수 있습니다. 따라서 여기로 가서 내가 &quot;안녕 Desmos, e의 1 나누기 e는 무엇입니까?&quot;라고 말하면, 1/3이 아니라 1/e가 아닙니다.

413
00:37:13,500 --> 00:37:23,500
네, 확인해보니 1시 사이네요. 44와 1. 45는 수렴에서 폭발로 전환되는 지점에 대해 정확히 우리가 찾고 있던 것입니다.

414
00:37:24,500 --> 00:37:37,500
제 생각에는 e의 1/e의 해를 찾는 것이 매우 만족스럽습니다. 여러분을 위한 도전 퍼즐로서, 오늘 약간의 숙제를 원한다면 이것이 수렴되는 하한선을 찾으시기 바랍니다.

415
00:37:37,500 --> 00:37:51,500
그래서 우리는 이것을 수렴하게 만드는 가장 높은 값을 찾았지만 1보다 작은 b 값으로 시작할 수도 있습니다. 그렇게 하면 여기서 거미줄을 제거할 수 있습니다. 어떤 값이 있을 것이라고 생각하면

416
00:37:51,500 --> 00:38:01,500
거미줄을 유지해야 할 것 같습니다. 여기서는 더 이상 정확한 값에 영점을 맞추지 않고 대신 불안정한 지점이 됩니다. 그리고 당신을 위한 질문은 언제 그런 일이 일어나는가 하는 것입니다.

417
00:38:01,500 --> 00:38:09,500
두 그래프가 교차하는 지점에 접근하다가 불안정하기 때문에 더 이상 접근하지 않게 되는 시점은 언제입니까?

418
00:38:10,500 --> 00:38:24,500
그리고 힌트를 원한다면 기울기가 언제 1이 되는가의 문제가 아니라 언제 -1보다 작은지가 문제이고 또 다른 힌트를 원한다면 다음과 같아야 한다는 사실을 생각해 보세요. 내부에 두 개의 e도 포함하는 표현입니다.

419
00:38:24,500 --> 00:38:35,500
그래서, 당신이 그것에 도달하고 싶다면 매우 재미있는 퍼즐입니다. 그리고 그것은 우리가 적정의 기초로 가질 수 있는 값에 대한 일종의 수렴 범위를 제공하여 전력 타워가 실제로 무언가로 수렴하도록 할 것입니다.

420
00:38:35,500 --> 00:38:46,500
여기서 주목할만한 점은 e 값으로 수렴하다가 무한대로 올라가지만 결코 e와 무한대 사이의 값으로 수렴하지 않는다는 것입니다.

421
00:38:46,500 --> 00:39:00,500
아마도 직관에 어긋날 수도 있는데, 왜냐하면 여러분은 그것이 어떻게든 원활하게 터진다고 생각하기 때문입니다. 가는 것보다 오, 그것은 1로 수렴하고, 2로 수렴하고, e로 수렴하고, 그리고 불연속적으로 무한대로 점프합니다. 행동.

422
00:39:00,500 --> 00:39:06,500
그리고 이는 그래프가 한때 접선이었다가 다시 분리되기 때문에 발생합니다. 그들은 키스를 하고 있다가 키스를 멈춥니다.

423
00:39:06,500 --> 00:39:10,500
그리고 이것은 4가 있는 전력 타워의 경우에 무슨 일이 일어나고 있는지에 대한 답을 제공합니다.

424
00:39:10,500 --> 00:39:15,500
그렇다면 논리를 다시 생각해 보면 우리는 그것을 어디에 가지고 있었습니까?

425
00:39:15,500 --> 00:39:30,500
엄청난. 따라서 전력 타워가 있고 이것이 4인 값을 구한다면 이는 그러한 값이 존재한다고 가정하고 이 과정은 4로 수렴할 것입니다.

426
00:39:30,500 --> 00:39:33,500
하지만 우리는 그것이 결코 e보다 큰 어떤 것으로 수렴되지 않는다는 것을 보았습니다.

427
00:39:33,500 --> 00:39:40,500
특히, 대체를 수행하는 첫 번째 단계는 솔루션이 존재한다는 가정을 활용하는 것입니다. 이는 유효하지 않습니다.

428
00:39:41,500 --> 00:39:50,500
2에 대해 효과가 있었던 이유는 이것이 2로 수렴되는 값이 존재하기 때문입니다. 따라서 초기 대체를 수행할 때 이는 유효한 작업입니다.

429
00:39:50,500 --> 00:39:56,500
그리고 풀기도 전에 그래프를 보면 2로 수렴하는 값이 존재한다는 것을 알 수 있습니다.

430
00:39:56,500 --> 00:40:07,500
당신이 찾을 것은, 그것이 2의 제곱근이 될 것이라는 것을 몰랐더라도, 당신이 찾을 것은 그래프 사이의 교차점이 2의 값에서 언제 발생하는가입니다.

431
00:40:07,500 --> 00:40:13,500
y와 x가 같은 선 위에 있기 때문에 x 값도 2라고 생각합니다. 하지만 우리가 관심을 갖는 것은 y 값이 2여야 한다는 것입니다.

432
00:40:13,500 --> 00:40:23,500
그리고 여러분은 경험적으로 1 사이 어딘가에 있다는 것을 알 수 있을 것입니다. 41과 1. 42, 그리고 조금 더 아래로 이진 검색을 할 수 있습니다.

433
00:40:23,500 --> 00:40:34,500
그래서 저는 그것이 반복되는 전력 타워의 완전히 말도 안되는 노래 과정을 살펴볼 수 있다는 점, 그것이 어떤 지점에서든 수렴한다는 점, 이는 반직관적이라는 점, 그리고

434
00:40:34,500 --> 00:40:40,500
우리가 실제로 그것이 언제 발생하는지에 대해 매우 실질적인 진술을 할 수 있다는 점은 매우 즐거운 일이라고 생각합니다. 이런 반복적인 과정을 통해 생각하면서 수렴합니다.

435
00:40:40,500 --> 00:40:49,500
사실 오늘은 여기까지입니다. 이번 강의는 더 짧을 것입니다. 이것이 전력 타워 퍼즐에 대해 내가 말하고 싶었던 내용의 끝이며, 여러분에게 약간의 숙제를 남깁니다.

436
00:40:49,500 --> 00:41:03,500
그래서 여기서 마지막으로 트위터에서 몇 가지 질문을 더 받고 싶습니다. 수학에 대한 해시태그를 달고 질문하면 제게 전달될 수 있으며 테트라레이션에 관한 모든 것이 바로 이 과정에 대해 이야기해야 합니다. 에 대한.

437
00:41:03,500 --> 00:41:12,500
좋아요, 그럼 지수의 삼각형이 있으면 4차의 제곱도 있다는 건가요? 테트라화의 역은 어떤 용도로 사용되나요?

438
00:41:12,500 --> 00:41:22,500
글쎄요, 두 경우 모두 우리는 세 가지 다른 변수를 다루게 될 것입니다. 베이스가 무엇인지, 높이는 무엇인지, 그리고 출력은 무엇인지에 대한 아이디어가 있습니다.

439
00:41:23,500 --> 00:41:37,500
따라서 두 경우 모두 우리는 그 중 세 개만 갖게 됩니다. 4를 만드는 것과 마찬가지로 4개의 4는 관련 숫자, 밑수, 지수, 출력이 무엇이든 간에, 그리고 새로운 4번째 숫자가 있다는 사실이 아닙니다.

440
00:41:37,500 --> 00:41:44,500
이 덧셈, 곱셈, 지수화 과정은 이전 과정을 반복하는 일종의 네 번째 과정입니다.

441
00:41:44,500 --> 00:41:51,500
ML의 다음 질문입니다. 전력 타워 x에서 x에서 x에서 x로 수렴하는 복소수 x의 프랙탈 집합의 일부를 보여 주시겠습니까?

442
00:41:51,500 --> 00:42:09,500
ML님, 물어봐주셔서 정말 기뻐요. 네, 밑이 2가 되는 대신에 밑이 2의 제곱근, 즉 1이 되는 대신에 무슨 일이 일어나는지 궁금할 것입니다. 4 또는 우리가 방금 보고 있던 모든 값에 z와 같이 반복 거듭제곱하는 복소수가 있다면 어떻게 될까요?

443
00:42:09,500 --> 00:42:19,500
이제 복잡한 값을 다른 복잡한 값으로 높이는 것이 정확히 무엇을 의미하는지에 대해 약간의 뉘앙스가 있습니다. 이에 대해 이야기할 것 같습니다. 다음 강의에서.

444
00:42:19,500 --> 00:42:29,500
e로 다시 표현할 수 있는 실제 값과 매우 유사합니다. e를 복소수로 생각하는 방법을 알고 있기 때문에 그렇게 할 수 있습니다.

445
00:42:30,500 --> 00:42:40,500
그러나 지수 계산을 복소수로 확장할 수 있는 방법이 존재한다는 사실을 기꺼이 인정한다면 확실히 이를 반복할 수 있습니다.

446
00:42:40,500 --> 00:42:54,500
그리고 이것을 반복하면, 이것이 수렴되는지에 대해 묻기 시작할 수 있습니다. 그리고 그것이 언제 수렴되는지 물어보고 수렴 여부에 따라 평면의 모든 픽셀을 색칠하는 셰이더나 가장 좋아하는 종류의 프로그램을 작성하면 이것이 얻을 수 있습니다.

447
00:42:55,500 --> 00:43:09,500
따라서 지금 보고 있는 것은 축에 라벨이 지정되어 있지 않지만 실제 축은 -4 부근에서 화면 중앙을 가로지르는 것입니다. 5에서 3까지라고 생각합니다. 그리고 가상의 축은 -2i에서 2i까지라고 생각합니다.

448
00:43:09,500 --> 00:43:21,500
따라서 이 검은색의 수평 부분은 우리가 방금 찾은 수렴하는 모든 값에 해당합니다. 여기서 상한은 e의 1 나누기 e이고 하한은 원할 경우 숙제로 찾을 수 있는 것입니다.

449
00:43:22,500 --> 00:43:34,500
그러나 그 위의 다른 값은 발산하며 색상을 통해 해당 값이 얼마나 빨리 발산하는지 알 수 있습니다. 따라서 노란색은 매우 빠르게 폭발한다는 의미이고, 파란색은 덜 빠르게 폭발한다는 의미입니다.

450
00:43:34,500 --> 00:43:47,500
그리고 분명히 일어나는 일은 복소수를 허용할 때 실수 부분이 e보다 1의 e 나누기보다 크다고 하더라도 허수 부분이 수렴하는 방식으로 공모할 수 있다는 것입니다. 그러면 완전히 복잡해집니다.

451
00:43:47,500 --> 00:44:00,500
특정 반복 연산의 관점에서 정의되는 Mandelbrot 집합과 매우 유사한 패턴입니다. 그리고 이것이 나타내는 것은 실제로 이러한 전력 타워 및 적정 작업과 관련하여 예상했던 것보다 훨씬 더 복잡하다는 것입니다.

452
00:44:01,500 --> 00:44:18,500
그리고 무언가를 반복적으로 적용하면 혼돈이 생길 수 있고, 그 혼돈은 종종 프랙탈이 나타난다는 사실에 그림으로 반영되며, 이미지의 복잡성이 출력을 예측하기 어려운 것과 유사합니다. 될 것입니다.

453
00:44:19,500 --> 00:44:34,500
그리고 출력을 예측하기 어려울 수 있다는 사실을 설명하기 위해 여러분은 해결되지 않은 문제가 무엇인지 알고 싶습니다. 세계 어느 누구도 실제로 알지 못하는 문제는 파이로 전력 타워를 가져갈 수 있는지입니다. 파워 파이에서 파워 파이로, 파워 파이로, 그렇게 하세요.

454
00:44:34,500 --> 00:44:47,500
어느 시점에서든 이것이 정수와 같습니까? 거의 확실히 그렇지 않습니다. 이는 비합리적인 숫자이기 때문에 가능성이 거의 없어 보일 것입니다. 확률적으로 생각한다면 확률적이지는 않지만 결정론적인 과정입니다.

455
00:44:47,500 --> 00:45:01,500
사실, 우리는 높이가 4인 전력 타워에 대해서도 모릅니다. 여기에 파이가 4개만 있으면 파이를 전력 파이로, 파이를 저것으로, 파이를 저것으로 제곱하면 결국 다음과 같이 됩니다. 우리가 정확하게 계산할 수 있는 것보다 더 큰 엄청난 숫자입니다.

456
00:45:01,500 --> 00:45:11,500
이것이 정수인지 아닌지를 증명할 방법이 없습니다. 그리고 만약 당신이 그것을 증명할 수 있다면, 당신은 수학의 최전선에 기여하게 될 것입니다.

457
00:45:11,500 --> 00:45:16,500
이것이 바로 우리가 전력 타워에 대해 실제로 알지 못하는 수준인데, 제 생각에는 꽤 흥미롭습니다.

458
00:45:17,500 --> 00:45:24,500
화살표 연산자가 나타나는 수수께끼를 공유할 수 있나요? 응, 환상적이야. 내가 그려드릴 수 있어요.

459
00:45:24,500 --> 00:45:40,500
나는 이것이 IMO에서 나온 것이라고 생각합니다. 이것은 Po Chen-Lo가 어느 시점에서 나와 공유했던 것입니다. 그리고 나는 그가 그것에 대해 어딘가에서 내가 즉석에서 이야기할 수 있는 것보다 더 설명이 될 것이라고 확신합니다. 여기.

460
00:45:40,500 --> 00:45:48,500
하지만 이것이 작동하는 방식은 6개의 서로 다른 컵이 있고 각 컵은 동전 한 개로 시작된다는 것입니다.

461
00:45:48,500 --> 00:46:04,500
그리고 두 가지 다른 작업을 사용할 수 있습니다. 이러한 작업 중 하나는 한 컵에서 동전을 제거할 수 있다는 것입니다. 따라서 한 컵에서 동전을 제거하겠습니다. 그러면 오른쪽 컵에 두 개의 동전이 더 떨어집니다.

462
00:46:04,500 --> 00:46:15,500
그래서 이것에는 특정한 방향성이 있습니다. 두 개가 더 오른쪽에 있는 항목으로 떨어집니다. 따라서 여기에서 세 개의 동전을 모두 제거하면 마술처럼 6개의 동전이 들어갈 수 있다고 상상할 수 있습니다.

463
00:46:15,500 --> 00:46:29,500
5, 6이 마법처럼 옆에 있는 다음 컵에 떨어집니다. 그리고 이것이 당신이 가진 유일한 능력이라면, 일종의 워밍업 티저는 당신이 가질 수 있는 최대 코인 수가 결국 63개가 된다는 것을 이해하는 것입니다.

464
00:46:29,500 --> 00:46:36,500
동전을 꺼내서 두 배로 늘리고 동전을 옮기는 과정을 계속하면 최대 63까지 얻을 수 있습니다.

465
00:46:36,500 --> 00:46:50,500
이제 두 번째 마법 연산을 소개하면, 컵에 있는 동전 중 하나를 제거하고 다음 동전에 두 개를 마법처럼 떨어뜨리는 대신 바로 뒤에 있는 두 개를 바꾸는 것입니다. 나는 그들의 위치를 바꾼다.

466
00:46:50,500 --> 00:46:57,500
그것은 당신이 가진 두 번째 힘이며, 에테르에서 동전을 가져올 필요가 없기 때문에 덜 마술적인 것처럼 보입니다.

467
00:46:57,500 --> 00:47:11,500
이 프레임이 원래 구성되어 있는 방식은 이 과정을 수행한 후 얻을 수 있는 최대 금액이 2010의 2010의 제곱보다 크거나 작습니까?라고 생각합니다.

468
00:47:11,500 --> 00:47:26,500
그것이 질문이었습니다. 당신이 이 두 가지 능력을 가지고 있고 각각 하나의 동전이 들어 있는 6개의 컵으로 시작할 때, 당신이 충분히 영리할 경우 얻을 수 있는 최대 돈의 양은 더 클까요, 아니면 그 전력탑보다 클까요, 작을까요? 키가 3개?

469
00:47:26,500 --> 00:47:38,500
그리고 두 번째 작업이 그 수준의 숫자에 가까운 곳으로 갈 수 있다는 것은 다소 터무니없는 일입니다. 왜냐하면 이것은 너무 거대하기 때문입니다. 물리학에서 찾을 수 있는 그 어떤 것보다 훨씬 더 큽니다.

470
00:47:38,500 --> 00:47:44,500
통계 역학이나 그와 유사한 작업을 수행하지 않는 한. 네, 훌륭한 질문입니다.

471
00:47:45,500 --> 00:47:56,500
그리고 사람들이 더 묻고 싶어하고 결국 나에게 전달되는 것이 없다면, 나는 이것으로 하루를 마감할 것이라고 생각합니다.

472
00:47:56,500 --> 00:48:08,500
그리고 참여해주셔서 감사합니다. 내 생각에 이 봉쇄 시리즈는 궁극적으로 아마도 10개의 에피소드를 갖게 될 것 같아요. 이것이 제가 현재 생각하고 있는 것입니다. 따라서 다음 두 개에 참여하고 싶다면 이것이 마지막 두 개가 될 것입니다.

473
00:48:08,500 --> 00:48:12,500
오 좋은. 또 다른 질문이 있습니다.

474
00:48:12,500 --> 00:48:19,500
X를 X와 X가 2가 되도록 풀고 X의 제곱이 2가 되었을 때, 2의 음수 제곱근을 무시했습니다. 엄청난. 응.

475
00:48:19,500 --> 00:48:24,500
응. 솔루션 X의 제곱은 2와 같습니다. 이유를 설명할 수 있나요? 네, 정말 훌륭해요.

476
00:48:24,500 --> 00:48:32,500
이것을 그래픽으로 다시 생각해 보면 반복 프로세스에서 무슨 일이 일어나고 있는지 좀 더 구체적으로 알 수 있습니다.

477
00:48:32,500 --> 00:48:36,500
내가 B가 약 1.41과 같다고 말했을 때.

478
00:48:36,500 --> 00:48:39,500
좋아요.

479
00:48:39,500 --> 00:48:43,500
2의 음의 제곱근 주변에는 실제로 아무 일도 일어나지 않는 것 같습니다.

480
00:48:43,500 --> 00:48:49,500
좋아요, 그럼 왜 그런 일이 일어나는지 이해해 봅시다. 그 지점에 반드시 교차로가 있을 필요도 없습니다.

481
00:48:49,500 --> 00:48:55,500
그래서 우리가 전력 타워 운영을 살펴볼 때 2의 제곱근을 취하는 이유입니다.

482
00:48:55,500 --> 00:49:00,500
우리 자신을 상기시킨다면.

483
00:49:00,500 --> 00:49:08,500
우리는 답이 존재한다고 가정했습니다. 이 모든 것은, 아니, 맨 위에 X가 있는 것이 아니라, 무한대로 올라가면 2가 됩니다.

484
00:49:08,500 --> 00:49:13,500
우리는 그 자체의 반성을 보았습니다. X 제곱은 2와 같습니다.

485
00:49:13,500 --> 00:49:17,500
이것이 무엇을 의미하는지 생각해 봅시다. 여기서 음의 제곱근이 있다는 것은 무엇을 의미합니까?

486
00:49:17,500 --> 00:49:23,500
글쎄, 내 생각엔 당신이 부정적인 힘을 갖고 있다고 가정할 것 같아요.

487
00:49:23,500 --> 00:49:29,500
이제 생각해보니 X가 음의 제곱근 2와 같다고 하면 말이죠.

488
00:49:29,500 --> 00:49:33,500
그러면 다음 프로세스에서 이를 올릴 수 있습니다. 2의 음의 제곱근을 취하게 됩니다.

489
00:49:33,500 --> 00:49:39,500
당신은 그것을 음의 거듭제곱으로 올릴 것입니다. 좋아요, 그럼 마이너스 거듭제곱으로 올려보겠습니다.

490
00:49:39,500 --> 00:49:44,500
우리는 이미 2의 1 나누기의 음의 제곱근에 대해 생각하는 영역에 있습니다.

491
00:49:44,500 --> 00:49:51,500
아니요, 마이너스 1 나누기 2의 제곱근 대 2의 제곱근입니다.

492
00:49:51,500 --> 00:49:56,500
왜 교차로나 그와 유사한 곳에서는 나타나지 않는 걸까요?

493
00:49:56,500 --> 00:50:03,500
사실, 생각하면 할수록 내가 놓치고 있는 무슨 일이 일어나고 있는지에 대한 매우 분명한 답이 있을 수도 있습니다.

494
00:50:03,500 --> 00:50:07,500
내 말은, 우리가 얘기할 수 있는 것 외에는.

495
00:50:07,500 --> 00:50:11,500
음수는 수렴 범위에 속하지 않는다는 사실을 이야기할 수 있습니다.

496
00:50:11,500 --> 00:50:18,500
숙제 문제를 풀면 이렇게 수렴하는 음의 X가 존재한다는 가정은 거짓이 될 것입니다.

497
00:50:18,500 --> 00:50:24,500
왜냐하면 당신은 경계가 끝난다는 것을 알게 될 것이기 때문입니다.

498
00:50:24,500 --> 00:50:30,500
내 생각엔 E 대 마이너스 E로 끝나는 것 같아요. 따라서 실패한 것과 마찬가지로 4의 경우에도 논리가 실패했습니다.

499
00:50:30,500 --> 00:50:36,500
음수 2의 제곱근만 대입하면 논리가 실패합니다. 수치상으로 구분이 되는지 궁금합니다.

500
00:50:36,500 --> 00:50:43,500
따라서 파이썬에서 이것을 다시 시도한다면 다시 1과 동일하게 설정해 보겠습니다.

501
00:50:43,500 --> 00:50:50,500
for 루프를 찾아봅시다. 이제 우리는 2의 음의 제곱근을 구하고 이 과정을 반복하겠습니다.

502
00:50:50,500 --> 00:50:58,500
응, 우리는 무엇을 얻나요? 우리는 안정적인 포인트를 얻습니다. 흥미로운.

503
00:50:58,500 --> 00:51:06,500
2의 음수 제곱근입니다. 당신은 매우 안정적인 지점인 것 같습니다. 당신은 전혀 2와 같은 안정적인 지점이 아닙니다.

504
00:51:06,500 --> 00:51:10,500
그 숫자는 무엇입니까? 거기 무슨 일 이죠?

505
00:51:11,500 --> 00:51:19,500
그거 알아? 나는 전적으로 긍정적이지는 않습니다. 이제 나는 결정을 내려야 합니다.

506
00:51:19,500 --> 00:51:26,500
단순히 스트림으로 호출하는 것보다 화면에서 정확히 무슨 일이 일어나고 있는지 실시간으로 생각하려고 노력합니까?

507
00:51:26,500 --> 00:51:32,500
아니면 그것에 대해 생각한 다음 마지막에 댓글에 고정합니까?

508
00:51:32,500 --> 00:51:38,500
어디 보자. 우리 논리에는 정확히 무슨 일이 벌어지고 있는 걸까요?

509
00:51:38,500 --> 00:51:45,500
우리는 2로 수렴하는 값이 있다고 가정합니다. 그렇다면 이 속성을 만족하게 될 것입니다.

510
00:51:45,500 --> 00:51:51,500
내 말은, 당신이 말할 수 있는 것은 x가 더하기 또는 빼기 2의 제곱근과 같다는 것입니다.

511
00:51:51,500 --> 00:51:55,500
둘 다 시도해 보세요. 그 중 하나는 같고, 하나는 같지 않습니다. 이야기의 끝.

512
00:51:55,500 --> 00:51:59,500
내 말은, 대수학적인 일을 할 때 이런 일이 많이 일어난다는 것입니다. 이런 조작이 있군요.

513
00:51:59,500 --> 00:52:04,500
여러 가지 가능성이 있지만 체크에 연결하면 그 중 하나가 작동하지 않습니다.

514
00:52:04,500 --> 00:52:10,500
그러나 그것은 항상 매우 불만족스럽습니다. 왜냐하면 당신이 원하는 것은 그것이 작동할 것처럼 보였지만 작동하지 않은 이유에 대한 일종의 대답이기 때문입니다.

515
00:52:10,500 --> 00:52:14,500
따라서 4에 해당하는 전력 타워의 경우 왜 그렇지 않은지 매우 명확하게 알 수 있습니다.

516
00:52:14,500 --> 00:52:18,500
심지어 수렴했다는 가정도 거짓이었습니다.

517
00:52:18,500 --> 00:52:31,500
그리고 이 경우 우리의 가정은 음수 루트 2가 있고 음수 값이 있다면 여기에 있는 것은 여전히 2와 같다고 가정할 것입니다.

518
00:52:31,500 --> 00:52:40,500
모르겠습니다. 우리는 그렇지 않다는 것을 보았습니다. 이 작업을 수행할 때 두 가지를 모두 시도해 보고 둘 중 하나가 그렇지 않으면 그게 전부라고 말할 수 있습니다.

519
00:52:40,500 --> 00:52:44,500
하지만 그것은 나에게 만족스럽지 않습니다. 그래서 그것에 대해 조금 생각해 보겠습니다.

520
00:52:44,500 --> 00:52:53,500
누구든지 더 깊은 생각을 가지고 있다면 댓글로 공유해 주세요. 나는 마이너스 2의 제곱근에 대해 무슨 일이 일어나고 있는지와 같은 당신의 말을 듣고 싶습니다.

521
00:52:53,500 --> 00:52:59,500
그것은 무엇으로 수렴되며 왜 이 과정과 어떤 관련이 있습니까?

522
00:52:59,500 --> 00:53:08,500
우리가 이미 보았듯이 이는 잘못된 추론 방식이며 무한한 전력 타워 내부에 있는 것을 이미 설정한 가정으로 대체하는 것이 약간 불안정한 것과 같습니다.

523
00:53:08,500 --> 00:53:13,500
응, 생각해 볼게. 훌륭한 질문이고 여기서 마무리하기에 좋은 곳이라고 생각합니다.

524
00:53:13,500 --> 00:53:24,500
또한, 나는 지금까지 모든 Lockdown 시리즈에 대해 매우 아름다운 노트를 만든 사람이기 때문에 누가 그것을 요청하는지에 대한 Twitter 핸들을 눈치채지 않을 수 없었습니다.

525
00:53:24,500 --> 00:53:31,500
제가 동영상 설명에 던진 것은 &#39;그래, 이거구나, 내 손글씨도 저렇게 생겼으면 좋겠어&#39;라고 생각했기 때문입니다.

526
00:53:31,500 --> 00:53:34,500
그러니 누구든지 확인하고 싶다면 그녀는 훌륭한 일을 한 것입니다.

527
00:53:34,500 --> 00:53:42,500
이것으로 오늘 수업을 마치겠습니다. Lockdown Math 시리즈의 마지막 두 번째 시간인 금요일 같은 시간에 뵙겠습니다.

528
00:53:43,500 --> 00:53:49,500


