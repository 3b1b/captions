[
 {
  "input": "Sometimes, math and physics conspire in ways that just feel too good to be true.",
  "translatedText": "",
  "from_community_srt": "수학과 물리학은 가끔씩 작당하고 너무 놀라워서 오히려 사실인지가 의심되는 결과를 만들기도 합니다.",
  "n_reviews": 0,
  "start": 4.0,
  "end": 8.0
 },
 {
  "input": "Let's play a strange sort of mathematical croquet.",
  "translatedText": "",
  "from_community_srt": "오늘은 좀 이상한 수학 크로켓을 해보도록 합시다.",
  "n_reviews": 0,
  "start": 8.64,
  "end": 10.78
 },
 {
  "input": "We're going to have two sliding blocks and a wall.",
  "translatedText": "",
  "from_community_srt": "미끄러지는 상자 두 개와 벽을 준비합시다.",
  "n_reviews": 0,
  "start": 11.28,
  "end": 13.54
 },
 {
  "input": "The first block starts by coming in at some velocity from the right, while the second one starts out stationary.",
  "translatedText": "",
  "from_community_srt": "첫 번째 상자는 오른쪽에서 정해진 속도로 미끄러져 오며, 두 번째 상자는 정지 상태입니다.",
  "n_reviews": 0,
  "start": 14.08,
  "end": 19.18
 },
 {
  "input": "Being overly idealistic physicists, let's assume there's no friction and all of the collisions are perfectly elastic, which means no energy is lost.",
  "translatedText": "",
  "from_community_srt": "지나치게 이상적인 상황을 좋아하는 물리학도로서, 모든 마찰과 공기저항을 무시하고 모든 충돌은 (완전) 탄성 충돌, 즉 에너지를 잃지 않는 충돌로 가정합시다.",
  "n_reviews": 0,
  "start": 19.92,
  "end": 27.78
 },
 {
  "input": "The astute among you might complain that such collisions would make no sound, but your goal here is to count how many collisions take place, so in slight conflict with that assumption I want to leave a little clack sound to better draw your attention to that count.",
  "translatedText": "",
  "from_community_srt": "물리 II를 배우신 분들은 탄성 충돌에서 왜 소리가 나냐고 하실지 모르겠는데, 어차피 우리의 목표는 충돌이 몇 번 일어나는지를 세는 거니까 처음에 했던 가정과는 살짝 모순되지만 충돌하는 숫자를 세기 좋게 저 작은 소리는 그냥 두도록 하겠습니다.",
  "n_reviews": 0,
  "start": 28.4,
  "end": 41.68
 },
 {
  "input": "The simplest case is when both blocks have the same mass.",
  "translatedText": "",
  "from_community_srt": "가장 단순한 경우는 두 상자의 질량이 같을 때입니다.",
  "n_reviews": 0,
  "start": 42.32,
  "end": 44.92
 },
 {
  "input": "The first block hits the second, transferring all of its momentum, then the second one bounces off the wall, and then transfers all of its momentum back to the first, which then sails off towards infinity.",
  "translatedText": "",
  "from_community_srt": "첫 번째 상자가 두 번째 상자와 충돌하면서 자신의 모든 운동량을 전달합니다. 두 번째 상자가 벽에 충돌한 다음, 자신의 운동량을 첫 번째 상자에 되돌려줍니다. 이제 이 상자는 영원히 미끄러지는 상태가 됩니다.",
  "n_reviews": 0,
  "start": 45.38,
  "end": 55.28
 },
 {
  "input": "Three total clacks.",
  "translatedText": "",
  "from_community_srt": "3번 부딪혔습니다.",
  "n_reviews": 0,
  "start": 55.86,
  "end": 56.8
 },
 {
  "input": "What about if the first block was 100 times the mass of the second one?",
  "translatedText": "",
  "n_reviews": 0,
  "start": 57.44,
  "end": 61.18
 },
 {
  "input": "I promise I will explain to you all the relevant physics in due course, it's not entirely obvious how you would predict the dynamics here, but in the spirit of getting to the punchline, let's watch what happens.",
  "translatedText": "",
  "from_community_srt": "첫 번째 상자(이하 A)의 질량이 두 번째 상자(이하 B)의 100배라면 어떻게 될까요? 여기 나오는 물리 현상은 나중에 설명해드리겠습니다. 이 두 물체가 어떻게 운동할지는 확실하지가 않지만, 일단은 어떤 신기한 게 나올지 기다려 봅시다.",
  "n_reviews": 0,
  "start": 61.84,
  "end": 71.28
 },
 {
  "input": "The second one will keep bouncing back and forth between the wall and the first block, 100 times its mass, like a satisfying game of Breakout, slowly and discreetly redirecting that first block's momentum to point in the opposite direction.",
  "translatedText": "",
  "from_community_srt": "B는 벽과 질량 100배짜리 A 사이에서 벽돌깨기를 하는 것마냥 왔다갔다 튕기면서, 자신의 운동량을 느린 속도로, 이산적으로 전달합니다.",
  "n_reviews": 0,
  "start": 71.9,
  "end": 83.84
 },
 {
  "input": "In total, there will be 31 collisions before each block is sliding off towards infinity, never to be touched again.",
  "translatedText": "",
  "from_community_srt": "두 상자가 다시 만나지 않으면서 영원히 미끄러질 때까지, 총 31번의 충돌이 발생합니다.",
  "n_reviews": 0,
  "start": 83.84,
  "end": 90.62
 },
 {
  "input": "What if the first block was 10,000 times the mass of the second one?",
  "translatedText": "",
  "n_reviews": 0,
  "start": 91.58,
  "end": 95.18
 },
 {
  "input": "In that case, there would be quite a few more clacks, all happening very rapidly at one point, adding up and all to 313 total collisions.",
  "translatedText": "",
  "from_community_srt": "A의 질량이 B의 10,000배라면? 이 경우에는 어떤 시점에서 엄청나게 빠른 속도로 계속 부딪쳐서... 결과적으로 313회 충돌이 일어나게 됩니다.",
  "n_reviews": 0,
  "start": 95.86,
  "end": 108.16
 },
 {
  "input": "Well, actually, hang on.",
  "translatedText": "",
  "from_community_srt": "결과적으로 313회 충돌이 일어나게 됩니다. 어 결과적으로 313회 충돌이 일어나게 됩니다. 어 아니야 결과적으로 313회 충돌이 일어나게 됩니다.",
  "n_reviews": 0,
  "start": 108.92,
  "end": 110.04
 },
 {
  "input": "Wait for it.",
  "translatedText": "",
  "n_reviews": 0,
  "start": 110.66,
  "end": 110.04
 },
 {
  "input": "Wait for it.",
  "translatedText": "",
  "from_community_srt": "어 아니야 잠깐만... 잠깐만 기다려봐요...",
  "n_reviews": 0,
  "start": 110.66,
  "end": 114.28
 },
 {
  "input": "Okay, 314 clacks.",
  "translatedText": "",
  "from_community_srt": "조금만 더... 됐다. 314번입니다.",
  "n_reviews": 0,
  "start": 116.98,
  "end": 118.48
 },
 {
  "input": "If the first block was 1,000,000 times the mass of the other, then again, with all of our crazy idealistic conditions, almost all of the clacks happen in one big burst, this time resulting in a total of 3,141 collisions.",
  "translatedText": "",
  "from_community_srt": "A의 질량이 B의 1,000,000배라면, 이번에도 그 미칠 듯하게 이상적인 가정 하에, 거의 모든 충돌이 한 번에 뽝!! 일어납니다. 이번에는 총 3,141회 충돌입니다.",
  "n_reviews": 0,
  "start": 119.3,
  "end": 132.68
 },
 {
  "input": "Perhaps you see the pattern here, though it's forgivable if you don't, since it defies all expectation.",
  "translatedText": "",
  "from_community_srt": "이쯤 되면 패턴이 보일지도 모르겠네요. 전혀 예상 밖의 결과니까, 눈치를 못 챘어도 괜찮습니다.",
  "n_reviews": 0,
  "start": 133.76,
  "end": 138.6
 },
 {
  "input": "When the mass of that first block is some power of 100 times the mass of the second, the total number of collisions have the same digits as pi.",
  "translatedText": "",
  "from_community_srt": "A의 질량이 B의 100의 거듭제곱 배일 경우, 총 충돌 횟수는 원주율의 처음 몇 자리와 일치합니다.",
  "n_reviews": 0,
  "start": 138.6,
  "end": 147.2
 },
 {
  "input": "This absolutely blew my mind when it was first shared with me.",
  "translatedText": "",
  "from_community_srt": "솔직히 저도 이걸 처음 봤을 때 엄청 신기하더라고요.",
  "n_reviews": 0,
  "start": 148.24,
  "end": 151.26
 },
 {
  "input": "Credit to the viewer Henry Cavill for introducing me to this fact, which was originally discovered by the mathematician Gregory Galperin in 1995 and published in 2003.",
  "translatedText": "",
  "from_community_srt": "제게 이 사실을 알려주신 시청자 Henry Kavle님께 감사드립니다. 수학자 Gregory Galperin이 1995년에 이를 처음 발견했고, 2003년에 발표했다고 합니다.",
  "n_reviews": 0,
  "start": 151.66,
  "end": 160.96
 },
 {
  "input": "Part of what I love about this is that if ever there were Olympic games for algorithms that compute pi, this one would have to win medals both for being the most elegant, and for being the most comically inefficient.",
  "translatedText": "",
  "from_community_srt": "제가 이걸 좋아하는 이유 중 하나가, 만약에 원주율을 계산하는 알고리즘으로 대회를 열면, 이 알고리즘이 가장 아름다운 알고리즘 부문, 끔찍하게 비효율적인 알고리즘 부문으로 2관왕을 탔을 겁니다.",
  "n_reviews": 0,
  "start": 161.92,
  "end": 173.36
 },
 {
  "input": "I mean, think about the actual algorithm here.",
  "translatedText": "",
  "from_community_srt": "이게 돌아가는 걸 한 번 상상해 보세요.",
  "n_reviews": 0,
  "start": 174.06,
  "end": 176.22
 },
 {
  "input": "Step 1, implement a physics engine.",
  "translatedText": "",
  "from_community_srt": "1. 물리엔진을 구현한다.",
  "n_reviews": 0,
  "start": 176.52,
  "end": 178.42
 },
 {
  "input": "Step 2, choose the number of digits d of pi you'd like to compute.",
  "translatedText": "",
  "from_community_srt": "2. 계산하려는 원주율의 자릿수 d를 입력한다.",
  "n_reviews": 0,
  "start": 178.88,
  "end": 183.0
 },
 {
  "input": "Step 3, set the mass of one of the blocks to be 100 to the power d-1, then send it travelling on a frictionless surface towards a block of mass 1.",
  "translatedText": "",
  "from_community_srt": "3. 상자 1개의 질량을 100^(d-1)로 놓고, 질량 1짜리 상자를 향해 마찰 없는 지면 위에 날린다.",
  "n_reviews": 0,
  "start": 183.68,
  "end": 192.28
 },
 {
  "input": "Step 4, count all of the collisions.",
  "translatedText": "",
  "from_community_srt": "4. 충돌하는 횟수를 센다.",
  "n_reviews": 0,
  "start": 192.82,
  "end": 194.98
 },
 {
  "input": "For example, to calculate only 20 digits of pi, which fits so cleanly on this screen, one block would have to have 100 billion billion billion billion times the mass of the other, which if that small block was 1 kilogram, means the big one has a mass about 10 times that of the supermassive black hole at the center of the Milky Way.",
  "translatedText": "",
  "from_community_srt": "예를 들어서 원주율을 20자리까지만 계산한다고 치면, (이거 화면에 꼭 맞네요) 상자 하나의 질량을 100간(10^38)으로 잡고 다른 하나를 1로 잡아야 되는데, 단위가 kg라고 한다면 이건 우리 은하 중심에 있는 초대질량 블랙홀 10개짜리인 겁니다.",
  "n_reviews": 0,
  "start": 196.42,
  "end": 214.98
 },
 {
  "input": "That means you would need to count 31 billion billion collisions.",
  "translatedText": "",
  "n_reviews": 0,
  "start": 215.64,
  "end": 218.92
 },
 {
  "input": "At one point in this virtual process, the frequency of clacks would be around 100 billion billion billion billion clacks per second.",
  "translatedText": "",
  "from_community_srt": "아무튼 이때 3141경에 육박하는 충돌을 일일이 세야 되고, 이걸 시뮬레이션하다 보면 분명 1초에 몇백 간 정도의 충돌을 할 거란 얘깁니다.",
  "n_reviews": 0,
  "start": 218.92,
  "end": 225.9
 },
 {
  "input": "So let's just say you would need very good numerical precision to get this working accurately, and it would take a very long time for the algorithm to complete.",
  "translatedText": "",
  "from_community_srt": "복잡하니까 그냥 이걸 정확하게 돌리려면 정밀도가 엄청 높아야 되고, 아무튼 엄청나게 오래 걸린다고만 알아둡시다.",
  "n_reviews": 0,
  "start": 226.38,
  "end": 233.48
 },
 {
  "input": "I'll emphasize again that this process is way over-idealized, quickly departing from anything that could possibly happen in real physics.",
  "translatedText": "",
  "from_community_srt": "이 과정은 지나치게 이상적인 환경을 가정하므로, 현실과는 저 멀리 동떨어진다는 걸 한 번 더 강조하겠습니다.",
  "n_reviews": 0,
  "start": 234.3,
  "end": 240.96
 },
 {
  "input": "But of course, you all know this is not interesting because of its potential as an actual pi computing algorithm or as a pragmatic physics demonstration.",
  "translatedText": "",
  "from_community_srt": "물론 여러분은 이게 원주율 알고리즘으로서의 가능성이나, 실용적인 물리 실험 같은 이유로 흥미로운 게 아니라는 건 알고 계시겠죠.",
  "n_reviews": 0,
  "start": 241.76,
  "end": 248.7
 },
 {
  "input": "It's mind-boggling because why on earth would pi show up here?",
  "translatedText": "",
  "from_community_srt": "그걸 다 떠나서, 그걸 다 떠나서, 원주율이 그걸 다 떠나서, 원주율이 왜 거기서 그걸 다 떠나서,",
  "n_reviews": 0,
  "start": 249.12,
  "end": 254.44
 },
 {
  "input": "And it's in such a weird way too.",
  "translatedText": "",
  "from_community_srt": "원주율이 왜 거기서 나오냐는 겁니다! 솔직히 말하자면 보통 원주율이라는 건 뭔가 '연속적인' 걸 나타내는데,",
  "n_reviews": 0,
  "start": 254.92,
  "end": 257.38
 },
 {
  "input": "Its decimal digits are counting something, but usually pi shows up when its precise value is describing something continuous.",
  "translatedText": "",
  "from_community_srt": "충돌 횟수를 '셌는데' 원주율이 나온다니 더 이상하죠.",
  "n_reviews": 0,
  "start": 257.46,
  "end": 263.94
 },
 {
  "input": "I will show you why this is true.",
  "translatedText": "",
  "from_community_srt": "왜 이렇게 되는지는 나중에 알려드리겠습니다.",
  "n_reviews": 0,
  "start": 264.8,
  "end": 266.2
 },
 {
  "input": "Where there is pi, there is a hidden circle, and in this case, that hidden circle comes from the conservation of energy.",
  "translatedText": "",
  "from_community_srt": "이미 얘기했지만 원주율이 나온다는 건 원이 숨어있다는 거고, 이 경우에는 에너지의 보존에 원이 숨어 있습니다.",
  "n_reviews": 0,
  "start": 266.58,
  "end": 271.62
 },
 {
  "input": "In fact, you're going to see two separate methods, which are each as stunning and surprising as the fact itself.",
  "translatedText": "",
  "from_community_srt": "두 가지 방법을 알려드릴 건데, 둘 모두 이 현상 자체만큼이나 신기합니다.",
  "n_reviews": 0,
  "start": 272.06,
  "end": 277.38
 },
 {
  "input": "Delaying gratification though, I will make you wait until the next video to see what's going on.",
  "translatedText": "",
  "from_community_srt": "하지만 궁금증을 증폭시키기 위해 이번에는 다음 동영상에 증명을 실을 겁니다.",
  "n_reviews": 0,
  "start": 278.16,
  "end": 282.24
 },
 {
  "input": "In the meantime, I highly encourage you to take a stab at it yourself, and be social about it.",
  "translatedText": "",
  "from_community_srt": "기다리는 동안에 직접 풀어보는 것을 강력히 권장합니다. 다른 데서도 얘기해봐요! 이건 어려운 퍼즐이니까,",
  "n_reviews": 0,
  "start": 282.52,
  "end": 287.64
 },
 {
  "input": "It's a hard puzzle, so it never hurts to recruit some other smart minds to the task.",
  "translatedText": "",
  "from_community_srt": "똑똑한 사람들을 몇 명 불러서 얘기하는 것도 괜찮습니다.",
  "n_reviews": 0,
  "start": 287.72,
  "end": 291.64
 },
 {
  "input": "Thank you.",
  "translatedText": "",
  "from_community_srt": "* 2019년 1월 20일에 해답이 공개됩니다. *",
  "n_reviews": 0,
  "start": 301.62,
  "end": 312.24
 }
]