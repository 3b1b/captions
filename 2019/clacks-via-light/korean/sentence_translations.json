[
 {
  "input": "You know that feeling you get when you have two mirrors facing each other, and it gives the illusion of there being an infinite tunnel of rooms.",
  "translatedText": "두 개의 거울이 서로 마주보게 했을 때 느끼는 그 느낌을 아실 겁니다. 그리고 그것은 무한한 방의 터널이 있는 것 같은 환상을 줍니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 0.0,
  "end": 6.34
 },
 {
  "input": "Or, if they're at an angle with each other, it makes you feel like you're a part of a strange kaleidoscopic world with many copies of yourself, all separated by angled pieces of glass.",
  "translatedText": "또는 서로 비스듬히 놓여 있으면 각진 유리 조각으로 분리된 자신의 복사본이 많이 있는 이상한 만화경 세계의 일부인 것처럼 느껴집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 6.84,
  "end": 16.26
 },
 {
  "input": "What many people may not realize is that the idea underlying these illusions can be surprisingly helpful for solving serious problems in math.",
  "translatedText": "많은 사람들이 깨닫지 못하는 것은 이러한 환상의 바탕이 되는 아이디어가 수학의 심각한 문제를 해결하는 데 놀랍게도 도움이 될 수 있다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 17.12,
  "end": 25.06
 },
 {
  "input": "We've already seen two videos describing the block-collision puzzle, with its wonderfully surprising answer.",
  "translatedText": "우리는 이미 블록 충돌 퍼즐에 대해 놀랍도록 놀라운 답변을 설명하는 두 개의 비디오를 보았습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 30.18,
  "end": 35.62
 },
 {
  "input": "Big block comes in from the bright, lots of clacks, the total number of clacks looks like pi, and we want to know why.",
  "translatedText": "밝고 많은 딸깍 소리에서 큰 블록이 들어오고 총 딸깍 소리의 수가 파이처럼 보이는데 그 이유를 알고 싶습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 36.16,
  "end": 41.96
 },
 {
  "input": "Here, we see one more perspective explaining what's going on, where if the connection to pi wasn't surprising enough, we add one more unexpected connection to optics.",
  "translatedText": "여기에서 무슨 일이 일어나고 있는지 설명하는 또 다른 관점을 볼 수 있습니다. 파이에 대한 연결이 충분히 놀라운 것이 아니라면 광학에 예상치 못한 연결을 하나 더 추가하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 42.64,
  "end": 51.3
 },
 {
  "input": "But we're doing more than just answering the same question twice.",
  "translatedText": "하지만 우리는 같은 질문에 두 번 답하는 것 이상의 일을 하고 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 51.6,
  "end": 54.34
 },
 {
  "input": "This alternate solution gives a much richer understanding of the whole setup, and it makes it easier to answer other questions.",
  "translatedText": "이 대체 솔루션을 사용하면 전체 설정을 더욱 풍부하게 이해할 수 있으며 다른 질문에 더 쉽게 답할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 54.5,
  "end": 60.06
 },
 {
  "input": "And fun side note, it happens to be core to how I coded the accurate simulations of these blocks without requiring absurdly small time steps and huge computation time.",
  "translatedText": "그리고 재미있는 측면은 터무니없이 작은 시간 단계와 막대한 계산 시간을 요구하지 않고 이러한 블록의 정확한 시뮬레이션을 코딩하는 방법의 핵심이라는 점입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 60.74,
  "end": 68.54
 },
 {
  "input": "The solution from the last video involved a coordinate plane, where each point encodes a pair of velocities.",
  "translatedText": "마지막 비디오의 솔루션에는 각 점이 한 쌍의 속도를 인코딩하는 좌표 평면이 포함되었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 69.3,
  "end": 74.82
 },
 {
  "input": "Here, we'll do something similar, but the points of our plane are going to encode the pair of positions of both blocks.",
  "translatedText": "여기서도 비슷한 작업을 수행하지만 평면의 점은 두 블록의 위치 쌍을 인코딩합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 76.06,
  "end": 81.2
 },
 {
  "input": "Again, the idea is that by representing the state of a changing system with individual points in some space, problems in dynamics turn into problems in geometry, which hopefully are more solvable.",
  "translatedText": "다시 말하지만, 변화하는 시스템의 상태를 일부 공간의 개별 점으로 표현함으로써 역학 문제가 기하학 문제로 바뀌고 희망적으로 더 해결 가능하다는 아이디어입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 81.78,
  "end": 92.82
 },
 {
  "input": "Specifically, let the x-coordinate of a 2D plane represent the distance from the wall to the left edge of the first block, what I'll call d1, and let the y-coordinate represent the distance from the wall to the right edge of the second block, what we'll call d2.",
  "translatedText": "구체적으로, 2D 평면의 x 좌표는 벽에서 첫 번째 블록의 왼쪽 가장자리까지의 거리(d1이라고 부르겠습니다)를 나타내고, y 좌표는 벽에서 첫 번째 블록의 오른쪽 가장자리까지의 거리를 나타냅니다. 두 번째 블록은 d2라고 부르겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 94.3,
  "end": 109.16
 },
 {
  "input": "That way, the line y equals x shows us where the two blocks clack into each other, since this happens whenever d1 is equal to d2.",
  "translatedText": "그런 식으로, y = x 선은 d1이 d2와 같을 때마다 발생하기 때문에 두 블록이 서로 부딪치는 위치를 보여줍니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 111.6,
  "end": 120.94
 },
 {
  "input": "Here's what it looks like for our scenario to play out.",
  "translatedText": "시나리오가 실행되는 모습은 다음과 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 122.54,
  "end": 125.32
 },
 {
  "input": "As the two distances of our blocks change, the two dimensional points of our configuration space move around, with positions that always fully encode the information of those two distances.",
  "translatedText": "블록의 두 거리가 변경됨에 따라 구성 공간의 2차원 점이 항상 두 거리의 정보를 완전히 인코딩하는 위치로 이동합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 125.78,
  "end": 135.76
 },
 {
  "input": "You may notice that at the bottom there, it's bounded by a line, where d2 is the same as the small block's width, which, if you think about it, is what it means for the small block to hit the wall.",
  "translatedText": "맨 아래에는 선으로 경계가 표시되어 있습니다. 여기서 d2는 작은 블록의 너비와 동일합니다. 생각해 보면 작은 블록이 벽에 부딪힌다는 의미입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 136.24,
  "end": 146.4
 },
 {
  "input": "You may be able to guess where we're going with this.",
  "translatedText": "이것으로 우리가 어디로 갈지 추측할 수 있을 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 147.56,
  "end": 149.44
 },
 {
  "input": "The way this point bounces between the two bounding lines is a bit like a beam of light bouncing between two mirrors.",
  "translatedText": "이 점이 두 경계선 사이에서 반사되는 방식은 두 개의 거울 사이에서 반사되는 빛의 광선과 약간 비슷합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 149.96,
  "end": 156.16
 },
 {
  "input": "The analogy doesn't quite work, though.",
  "translatedText": "그러나 비유는 제대로 작동하지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 159.48,
  "end": 161.96
 },
 {
  "input": "In the lingo of optics, the angle of incidence doesn't equal the angle of reflection.",
  "translatedText": "광학 용어에서 입사각은 반사각과 같지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 162.2,
  "end": 166.8
 },
 {
  "input": "Just think of the first collision.",
  "translatedText": "첫 번째 충돌을 생각해 보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 167.6,
  "end": 168.54
 },
 {
  "input": "A beam of light coming in from the right would bounce off of a 45 degree angled mirror, this x equals y line, in such a way that it ends up going straight down, which would mean that only the second block is moving.",
  "translatedText": "오른쪽에서 들어오는 빛의 광선은 45도 각도의 거울(이 x는 y 선과 동일)에서 반사되어 결국 똑바로 아래로 내려가며 이는 두 번째 블록만 움직인다는 것을 의미합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 169.02,
  "end": 180.4
 },
 {
  "input": "This does happen in the simplest case, where the second block has the same mass as the first, and picks up all of its momentum like a croquet ball.",
  "translatedText": "이것은 두 번째 블록이 첫 번째 블록과 동일한 질량을 갖고 크로케 공처럼 모든 운동량을 흡수하는 가장 간단한 경우에 발생합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 181.18,
  "end": 188.6
 },
 {
  "input": "But in the general case, for other mass ratios, that first block keeps much of its momentum, so the trajectory of our point in this configuration space won't be pointed straight down, it'll be down and to the left a bit.",
  "translatedText": "그러나 일반적인 경우, 다른 질량 비율의 경우 첫 번째 블록은 운동량의 대부분을 유지하므로 이 구성 공간에서 우리 지점의 궤적은 똑바로 아래를 향하지 않고 약간 왼쪽을 향하게 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 189.12,
  "end": 200.4
 },
 {
  "input": "And even if it's not immediately clear why this analogy with light would actually be helpful, and trust me, it will be helpful in many ways, run with me here and see if we can fix this for the general case.",
  "translatedText": "그리고 빛에 대한 비유가 실제로 도움이 되는 이유가 즉시 명확하지 않더라도 저를 믿으세요. 여러 면에서 도움이 될 것입니다. 여기서 저와 함께 실행하여 일반적인 경우에 대해 이 문제를 고칠 수 있는지 알아보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 201.14,
  "end": 211.14
 },
 {
  "input": "Seeking analogies in math is very often a good idea.",
  "translatedText": "수학에서 비유를 찾는 것은 종종 좋은 생각입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 211.66,
  "end": 214.7
 },
 {
  "input": "As with the last video, it's helpful to rescale the coordinates.",
  "translatedText": "지난 영상과 마찬가지로 좌표의 크기를 조정하는 것이 도움이 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 215.82,
  "end": 219.14
 },
 {
  "input": "In fact, motivated by precisely what we did then, you might think to rescale the coordinates so that x is not equal to d1, which is equal to the square root of the first mass, m1, times d1.",
  "translatedText": "사실 우리가 그때 했던 일에 동기를 부여받아 x가 d1과 같지 않도록 좌표의 크기를 다시 조정해야 한다고 생각할 수도 있습니다. d1은 첫 번째 질량의 제곱근 m1에 d1을 곱한 것과 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 219.8,
  "end": 230.98
 },
 {
  "input": "This has the effect of stretching our space horizontally, so changes in our big block's position now result in larger changes to the x-coordinate itself.",
  "translatedText": "이는 공간을 수평으로 확장하는 효과가 있으므로 큰 블록의 위치가 변경되면 이제 x 좌표 자체가 더 크게 변경됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 231.64,
  "end": 239.64
 },
 {
  "input": "And likewise, let's write the y-coordinate as square root of m2 times d2, even though in this particular case the second mass is 1, so it doesn't make a difference, but let's keep things symmetric.",
  "translatedText": "마찬가지로, y 좌표를 m2 곱하기 d2의 제곱근으로 쓰겠습니다. 이 특별한 경우에는 두 번째 질량이 1이므로 차이가 없지만 대칭을 유지하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 240.34,
  "end": 249.6
 },
 {
  "input": "Maybe this strikes you as making things uglier, and kind of a random thing to do, but as with last time, when we include square roots of masses like this, everything plays more nicely with the laws of conserving energy and momentum.",
  "translatedText": "어쩌면 이것이 일을 더 추악하고 임의적인 일로 만드는 것처럼 보일 수도 있지만 지난번과 마찬가지로 이와 같은 질량의 제곱근을 포함하면 모든 것이 에너지와 운동량 보존 법칙에 따라 더 잘 작동합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 250.48,
  "end": 263.1
 },
 {
  "input": "Specifically, the conservation of energy will translate into the fact that our little point in the space is always moving at the same speed, which in our analogy you might think of meaning there's a constant speed of light.",
  "translatedText": "특히, 에너지 보존은 공간에 있는 우리의 작은 지점이 항상 같은 속도로 움직인다는 사실로 해석될 것입니다. 이는 우리의 비유에서 빛의 속도가 일정하다는 의미로 생각할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 263.9,
  "end": 274.54
 },
 {
  "input": "And the conservation of momentum will translate to the fact that as our point bounces off of the mirrors of our setup, so to speak, the angle of incidence equals the angle of reflection.",
  "translatedText": "그리고 운동량 보존은 우리의 점이 거울에 반사되어 입사각이 반사각과 같다는 사실로 해석됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 274.9,
  "end": 285.0
 },
 {
  "input": "Doesn't that seem bizarre in kind of a delightful way, that the laws of kinematics should translate to laws of optics like this?",
  "translatedText": "운동학의 법칙이 이와 같은 광학의 법칙으로 해석되어야 한다는 것이 일종의 유쾌한 방식으로 이상해 보이지 않습니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 286.82,
  "end": 293.28
 },
 {
  "input": "To see why it's true, let's roll up our sleeves and work out the actual math.",
  "translatedText": "그것이 왜 사실인지 알아보기 위해 소매를 걷어붙이고 실제 수학을 계산해 봅시다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 294.02,
  "end": 297.44
 },
 {
  "input": "Focus on the velocity vector of our point in the diagram.",
  "translatedText": "다이어그램에서 우리 지점의 속도 벡터에 초점을 맞추세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 299.02,
  "end": 301.96
 },
 {
  "input": "It shows which direction it's moving and how quickly.",
  "translatedText": "움직이는 방향과 속도를 보여줍니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 302.46,
  "end": 304.64
 },
 {
  "input": "Now keep in mind, this is not a physical velocity, like the velocities of the moving blocks, instead it's a more abstract rate of change in the context of this configuration space, whose two dimensions worth of possible directions encode both velocities of the block.",
  "translatedText": "이제 이것은 움직이는 블록의 속도와 같은 물리적 속도가 아니라 이 구성 공간의 맥락에서 보다 추상적인 변화율이며, 가능한 방향의 2차원 가치가 블록의 두 속도를 모두 인코딩한다는 점을 명심하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 305.2,
  "end": 320.92
 },
 {
  "input": "The x-component of this little vector is the rate of change of x, and likewise its y-component is the rate of change of y.",
  "translatedText": "이 작은 벡터의 x 성분은 x의 변화율이고, 마찬가지로 y 성분은 y의 변화율입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 325.96,
  "end": 333.94
 },
 {
  "input": "But what is that rate of change for the x-coordinate?",
  "translatedText": "그런데 x좌표의 변화율은 얼마일까요?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 334.64,
  "end": 337.2
 },
 {
  "input": "Well, x is the square root of m1 times d1, and the mass doesn't change, so it depends only on how d1 changes.",
  "translatedText": "음, x는 m1 곱하기 d1의 제곱근이고 질량은 변하지 않으므로 d1이 어떻게 변하는지에만 의존합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 339.3,
  "end": 345.84
 },
 {
  "input": "And what's the rate at which d1 changes?",
  "translatedText": "그리고 d1이 변하는 속도는 얼마입니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 346.7,
  "end": 348.42
 },
 {
  "input": "Well that's the velocity of the big block, let's call that v1.",
  "translatedText": "이것이 큰 블록의 속도입니다. 이를 v1이라고 부르겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 349.08,
  "end": 352.7
 },
 {
  "input": "Likewise, the rate of change for y is going to be the square root of m2 times v2.",
  "translatedText": "마찬가지로, y의 변화율은 m2 곱하기 v2의 제곱근이 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 353.68,
  "end": 359.58
 },
 {
  "input": "Now, notice what the magnitude of our little configuration space changing vector is.",
  "translatedText": "이제 작은 구성 공간 변경 벡터의 크기가 얼마인지 확인하세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 360.14,
  "end": 365.24
 },
 {
  "input": "Using the Pythagorean theorem, it's the square root of the sum of each of these component rates of change squared, which is square root of m1 times v1 squared plus m2 times v2 squared.",
  "translatedText": "피타고라스 정리를 사용하면 각 구성 요소 변화율 제곱의 합의 제곱근이 됩니다. 이는 m1 곱하기 v1 제곱 더하기 m2 곱하기 v2 제곱의 제곱근입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 365.78,
  "end": 377.66
 },
 {
  "input": "This inner expression should look awfully familiar, it's exactly twice the kinetic energy of our system.",
  "translatedText": "이 내부 표현은 매우 친숙해 보일 것입니다. 이는 우리 시스템의 운동 에너지의 정확히 두 배입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 378.36,
  "end": 383.42
 },
 {
  "input": "So the speed of our point in the configuration space is some function of the total energy, and that stays constant throughout the whole process.",
  "translatedText": "따라서 구성 공간에서 우리 지점의 속도는 전체 에너지의 일부 기능이며 전체 프로세스에서 일정하게 유지됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 383.9,
  "end": 391.24
 },
 {
  "input": "Remember, a core over-idealizing assumption to this is that there's no energy lost to friction or to any of the collisions.",
  "translatedText": "이에 대한 지나치게 이상적인 가정의 핵심은 마찰이나 충돌로 인해 에너지가 손실되지 않는다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 391.92,
  "end": 398.1
 },
 {
  "input": "Alright, so that's pretty cool.",
  "translatedText": "좋아요, 꽤 괜찮네요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 400.16,
  "end": 401.52
 },
 {
  "input": "With these rescaled coordinates, our little point is always moving with a constant speed.",
  "translatedText": "이렇게 크기가 조정된 좌표를 사용하면 작은 점이 항상 일정한 속도로 움직입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 401.78,
  "end": 405.98
 },
 {
  "input": "And I know it's not obvious why you would care, but among other things, it's important for the next step, where the conservation of momentum implies that these two bounding lines act like mirrors.",
  "translatedText": "그리고 여러분이 관심을 갖는 이유가 명확하지 않다는 것을 압니다. 그러나 무엇보다도 다음 단계에서는 운동량 보존이 이 두 경계선이 거울처럼 작용한다는 것을 의미하는 것이 중요합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 406.6,
  "end": 415.76
 },
 {
  "input": "First, let's understand this line d1 equals d2 a little bit better.",
  "translatedText": "먼저, 이 선 d1이 d2와 같다는 것을 조금 더 잘 이해해 봅시다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 419.86,
  "end": 423.8
 },
 {
  "input": "In our new coordinates, it's no longer that nice 45 degree x equals y line.",
  "translatedText": "새로운 좌표에서는 더 이상 45도 x가 y선과 같지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 424.24,
  "end": 428.12
 },
 {
  "input": "Instead, if we do a little algebraic manipulation here, we can see that that line is x over square root m1 equals y over square root m2.",
  "translatedText": "대신, 여기서 약간의 대수적 조작을 하면 그 선이 제곱근 m1 분의 x와 제곱근 m2 분의 y와 같다는 것을 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 428.78,
  "end": 437.94
 },
 {
  "input": "Rearranging a little bit more, we see that's a line with a slope of square root m2 over m1.",
  "translatedText": "조금 더 재배열하면 m1에 대한 제곱근 m2의 기울기를 갖는 선이 보입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 438.56,
  "end": 443.48
 },
 {
  "input": "That's a nice expression to tuck away in the back of your mind.",
  "translatedText": "마음 한구석에 담아두기 딱 좋은 표현이네요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 443.78,
  "end": 446.54
 },
 {
  "input": "After the blocks collide, meaning our point hits this line, the way to figure out how they move is to use the conservation of momentum, which says that the value m1 times v1 plus m2 times v2 is the same both before and after the collision.",
  "translatedText": "블록이 충돌한 후, 즉 점이 이 선에 도달한 후 블록이 어떻게 움직이는지 알아내는 방법은 운동량 보존을 사용하는 것입니다. 즉, m1 곱하기 v1 더하기 m2 곱하기 v2 값은 충돌 전후 모두 동일합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 449.98,
  "end": 464.62
 },
 {
  "input": "Now notice, this looks like a dot product between two column vectors, m1m2 and v1v2.",
  "translatedText": "이제 이것은 두 열 벡터 m1m2와 v1v2 사이의 내적처럼 보입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 465.52,
  "end": 472.1
 },
 {
  "input": "Rewriting it slightly for our rescaled coordinates, the same thing could be written as a dot product between a column vector with the square roots of the masses, and one with the rates of change for x and y.",
  "translatedText": "재조정된 좌표에 대해 이를 약간 다시 작성하면 동일한 내용이 질량의 제곱근이 있는 열 벡터와 x 및 y의 변화율이 있는 열 벡터 사이의 내적으로 작성될 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 472.54,
  "end": 483.22
 },
 {
  "input": "I know this probably seems like a complicated way to talk about a comparatively simple momentum equation, but there is a good reason for shifting the language to one of dot products in our new coordinates.",
  "translatedText": "나는 이것이 비교적 간단한 운동량 방정식에 대해 말하는 복잡한 방법처럼 보일 수도 있다는 것을 알고 있지만, 새로운 좌표의 내적 중 하나로 언어를 전환하는 데는 타당한 이유가 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 484.18,
  "end": 494.0
 },
 {
  "input": "Notice that second vector is simply the rate of change vector for the point in our diagram that we've been looking at.",
  "translatedText": "두 번째 벡터는 단순히 우리가 보고 있는 다이어그램의 지점에 대한 변화율 벡터입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 495.56,
  "end": 501.12
 },
 {
  "input": "The key now is that the square root of the masses vector points in the same direction as our collision line, since the rise over run is square root m2 over square root of m1.",
  "translatedText": "이제 핵심은 질량 벡터의 제곱근이 충돌 선과 동일한 방향을 가리킨다는 것입니다. 왜냐하면 상승에 대한 상승은 m1의 제곱근에 대한 제곱근 m2이기 때문입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 501.12,
  "end": 512.24
 },
 {
  "input": "Now if you're unfamiliar with the dot product, there is another video on this channel describing it, but real quick let's go over what it means geometrically.",
  "translatedText": "이제 내적에 익숙하지 않다면 이 채널에 이를 설명하는 또 다른 비디오가 있지만 기하학적으로 무엇을 의미하는지 빠르게 살펴보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 513.3,
  "end": 520.04
 },
 {
  "input": "The dot product of two vectors equals the length of the first one multiplied by the length of the projection of the second one onto that first, where it's considered negative if they point in opposite directions.",
  "translatedText": "두 벡터의 내적은 첫 번째 벡터의 길이에 두 번째 벡터의 투영 길이를 곱한 것과 같습니다. 여기서 두 벡터가 반대 방향을 가리키면 음수로 간주됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 520.7,
  "end": 532.84
 },
 {
  "input": "You often see this written as the product of the lengths of the two vectors and the cosine of the angle between them.",
  "translatedText": "이는 두 벡터의 길이와 두 벡터 사이의 각도의 코사인의 곱으로 표시되는 경우가 많습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 533.5,
  "end": 539.88
 },
 {
  "input": "So look back at this conservation of momentum expression, telling us that the dot product between this square root of the masses vector and our little change vector has to be the same, both before and after the collision.",
  "translatedText": "따라서 이 운동량 보존 표현을 되돌아보면 질량 벡터의 제곱근 벡터와 작은 변화 벡터 사이의 내적은 충돌 전후 모두 동일해야 한다는 것을 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 544.34,
  "end": 556.46
 },
 {
  "input": "Since we just saw that this change vector has a constant magnitude, the only way for this dot product to stay the same is if the angle that it makes with the collision line stays the same.",
  "translatedText": "방금 이 변화 벡터의 크기가 일정한 것을 보았으므로 이 내적이 동일하게 유지되는 유일한 방법은 충돌 선과 이루는 각도가 동일하게 유지되는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 557.08,
  "end": 567.5
 },
 {
  "input": "In other words, again using the lingo of optics, the angle of incidence and the angle of reflection off this collision line must be equal.",
  "translatedText": "즉, 다시 광학 용어를 사용하면 입사각과 이 충돌선에서 반사되는 각도가 동일해야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 568.26,
  "end": 575.46
 },
 {
  "input": "Similarly, when the small block bounces off the wall, our little vector gets reflected about the x direction, since only its y coordinate changes.",
  "translatedText": "마찬가지로, 작은 블록이 벽에서 튕겨 나올 때, y 좌표만 변경되므로 작은 벡터가 x 방향에 대해 반사됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 576.14,
  "end": 583.68
 },
 {
  "input": "So our configuration point is bouncing off that horizontal line as if it was a mirror.",
  "translatedText": "따라서 우리의 구성 지점은 마치 거울인 것처럼 수평선에서 반사됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 584.26,
  "end": 588.76
 },
 {
  "input": "So step back a moment and think about what this means for our original question of counting block collisions and trying to understand why on Earth pi would show up.",
  "translatedText": "잠시 뒤로 물러나 블록 충돌 수를 계산하고 지구에서 파이가 나타나는 이유를 이해하려고 노력하는 원래 질문에서 이것이 무엇을 의미하는지 생각해 보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 590.1,
  "end": 597.68
 },
 {
  "input": "We can translate it to a completely different question.",
  "translatedText": "우리는 이것을 완전히 다른 질문으로 번역할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 598.08,
  "end": 600.48
 },
 {
  "input": "If you shine a beam of light at a pair of mirrors, meeting each other at some angle, let's say theta, how many times would that light bounce off of the mirrors as a function of that angle?",
  "translatedText": "한 쌍의 거울에 빛의 광선을 비추고 어떤 각도(세타)에서 서로 만난다면 그 빛은 그 각도의 함수로서 거울에서 몇 번이나 반사됩니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 601.34,
  "end": 611.78
 },
 {
  "input": "Remember, the mass ratio of our blocks completely determines this angle theta in the analogy.",
  "translatedText": "유추에서 블록의 질량 비율이 이 각도 세타를 완전히 결정한다는 것을 기억하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 612.92,
  "end": 617.98
 },
 {
  "input": "Now I can hear some of you complaining, haven't we just replaced one tricky setup with another?",
  "translatedText": "이제 여러분 중 일부가 불평하는 것을 들을 수 있습니다. 까다로운 설정을 다른 설정으로 교체하지 않았습니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 619.38,
  "end": 623.84
 },
 {
  "input": "This might make for a cute analogy, but how is it progress?",
  "translatedText": "이것은 귀여운 비유가 될 수 있지만 진행 상황은 어떻습니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 624.28,
  "end": 626.92
 },
 {
  "input": "It's true that counting the number of light bounces is hard, but now we have a helpful trick.",
  "translatedText": "빛이 반사되는 횟수를 세는 것이 어려운 것은 사실입니다. 하지만 이제 유용한 방법이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 627.64,
  "end": 633.22
 },
 {
  "input": "When the beam of light hits the mirror, instead of thinking of that beam as reflected about the mirror, think of the beam as going straight while the whole world gets flipped through the mirror.",
  "translatedText": "빛의 광선이 거울에 부딪힐 때, 그 광선이 거울에 반사되는 것으로 생각하는 대신, 온 세상이 거울을 통해 뒤집어지는 동안 그 광선이 직진한다고 생각하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 633.74,
  "end": 643.26
 },
 {
  "input": "It's as if the beam is passing through a piece of glass into an illusory looking glass universe.",
  "translatedText": "그것은 마치 광선이 유리 조각을 통과하여 환상적인 거울 우주로 들어가는 것과 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 643.92,
  "end": 648.62
 },
 {
  "input": "Think of actual mirrors here.",
  "translatedText": "여기서 실제 거울을 생각해 보십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 649.54,
  "end": 651.06
 },
 {
  "input": "This wire on the left will represent a laser beam coming into the mirror, and the one on the right will represent its reflection.",
  "translatedText": "왼쪽에 있는 와이어는 거울로 들어오는 레이저 빔을 나타내고, 오른쪽에 있는 와이어는 그 반사를 나타냅니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 651.5,
  "end": 657.52
 },
 {
  "input": "The illusion is that the beam goes straight through the mirror, as if passing through a window separating us from another room.",
  "translatedText": "환상은 마치 우리와 다른 방을 분리하는 창문을 통과하는 것처럼 광선이 거울을 똑바로 통과한다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 658.32,
  "end": 665.04
 },
 {
  "input": "But notice, crucially, for this illusion to work, the angle of incidence has to equal the angle of reflection, otherwise the flipped copy of the reflected beam won't line up with the first part.",
  "translatedText": "그러나 중요한 점은 이 환상이 작동하려면 입사각이 반사각과 같아야 한다는 점입니다. 그렇지 않으면 반사된 광선의 뒤집힌 복사본이 첫 번째 부분과 정렬되지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 665.72,
  "end": 678.24
 },
 {
  "input": "So all of that work we did, rescaling coordinates and futzing through the momentum equations, was certainly necessary.",
  "translatedText": "그래서 우리가 한 모든 작업, 즉 좌표의 크기를 재조정하고 운동량 방정식을 푸는 작업은 확실히 필요했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 679.0,
  "end": 684.52
 },
 {
  "input": "But now we get to enjoy the fruits of our labor.",
  "translatedText": "하지만 이제 우리는 노동의 결실을 누리게 되었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 685.0,
  "end": 687.52
 },
 {
  "input": "Watch how this helps us elegantly solve the question of how many mirror bounces there will be, which is also the question of how many block collisions there will be.",
  "translatedText": "이것이 미러 바운스 횟수와 블록 충돌 횟수에 대한 질문을 우아하게 해결하는 데 어떻게 도움이 되는지 살펴보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 688.14,
  "end": 695.78
 },
 {
  "input": "Every time the beam hits a mirror, don't think of the beam as getting reflected, let it continue straight while the world gets reflected.",
  "translatedText": "광선이 거울에 부딪힐 때마다 광선이 반사되는 것으로 생각하지 말고 세상이 반사되는 동안 계속해서 직선으로 놔두십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 699.0,
  "end": 706.28
 },
 {
  "input": "As this goes on, the illusion to the beam of light is that instead of getting bounced around between two angled mirrors many times, it's passing through a sequence of angled pieces of glass all the same angle apart.",
  "translatedText": "이것이 진행됨에 따라 빛의 광선에 대한 환상은 두 개의 각진 거울 사이를 여러 번 튕기는 대신 모두 같은 각도로 떨어져 있는 일련의 각진 유리 조각을 통과한다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 707.0,
  "end": 718.86
 },
 {
  "input": "Right now I'm showing you all of the reflected copies of the bouncing trajectory, which I think has a very striking beauty to it.",
  "translatedText": "지금 저는 튀는 궤적의 반사된 복사본을 모두 보여주고 있는데, 제 생각엔 매우 놀라운 아름다움을 갖고 있는 것 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 720.0,
  "end": 727.14
 },
 {
  "input": "But for a clear review, let's just focus on the original bouncing beam and the illusory straight one.",
  "translatedText": "그러나 명확한 검토를 위해 원래의 바운싱 빔과 환상의 직선 빔에만 초점을 맞추도록 하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 731.06,
  "end": 736.94
 },
 {
  "input": "The question of counting bounces turns into a question of how many pieces of glass this illusory beam crosses.",
  "translatedText": "바운스를 세는 문제는 이 환상적인 광선이 얼마나 많은 유리 조각을 통과하는지에 대한 문제로 바뀐다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 737.64,
  "end": 743.72
 },
 {
  "input": "How many reflected copies of the world does it pass into?",
  "translatedText": "얼마나 많은 반사된 세계 사본이 전달되나요?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 744.28,
  "end": 746.98
 },
 {
  "input": "Well, calling the angle between the mirrors theta, the answer here is however many times you can add theta to itself before you get more than halfway around a circle, which is to say, before you add up to more than pi total radians.",
  "translatedText": "음, 거울 사이의 각도를 세타라고 부르면, 여기서 답은 원 주위의 절반 이상이 되기 전에, 즉 총 파이 라디안보다 더 많이 더하기 전에 세타를 그 자체에 추가할 수 있는 횟수입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 754.98,
  "end": 769.38
 },
 {
  "input": "Written as a formula, the answer to this question is the floor of pi divided by theta.",
  "translatedText": "공식으로 작성하면 이 질문에 대한 답은 파이의 바닥을 세타로 나눈 값입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 771.78,
  "end": 776.62
 },
 {
  "input": "So let's review.",
  "translatedText": "그럼 검토해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 777.44,
  "end": 778.68
 },
 {
  "input": "We started by drawing a configuration space for our colliding blocks where the x and the y coordinates represented the two distances from the wall.",
  "translatedText": "우리는 x와 y 좌표가 벽으로부터의 두 거리를 나타내는 충돌 블록에 대한 구성 공간을 그리는 것부터 시작했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 779.08,
  "end": 786.64
 },
 {
  "input": "This kind of looked like light bouncing between two mirrors, but to make the analogy work properly we needed to rescale the coordinates by the square roots of the masses.",
  "translatedText": "이런 종류의 빛은 두 개의 거울 사이에서 반사되는 것처럼 보였지만 비유가 제대로 작동하려면 질량의 제곱근으로 좌표의 크기를 다시 조정해야 했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 787.78,
  "end": 796.06
 },
 {
  "input": "This made it so that the slope of one of our lines was square root of m2 divided by square root of m1, so the angle between those bounding lines will be the inverse tangent of that slope.",
  "translatedText": "이로 인해 선 중 하나의 기울기가 m2의 제곱근을 m1의 제곱근으로 나눈 값이 되므로 경계선 사이의 각도는 해당 기울기의 역탄젠트가 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 796.82,
  "end": 807.74
 },
 {
  "input": "To figure out how many bounces there are between two mirrors like this, think of the illusion of the beam going straight through a sequence of looking glass universes separated by a semi-circular fan of windows.",
  "translatedText": "이와 같은 두 개의 거울 사이에 얼마나 많은 반사가 있는지 파악하려면 반원형 창문 팬으로 분리된 일련의 거울 우주를 직선으로 통과하는 광선의 환상을 생각해 보십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 808.74,
  "end": 818.94
 },
 {
  "input": "The answer then comes down to how many times the value of this angle fits into 180 degrees, which is pi radians.",
  "translatedText": "그러면 답은 이 각도의 값이 180도(파이 라디안)에 몇 배나 맞는지에 달려 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 819.54,
  "end": 826.2
 },
 {
  "input": "From here, to understand why exactly the digits of pi show up when the mass ratio is a power of 100, it's exactly what we did in the last video, so I won't repeat myself here.",
  "translatedText": "여기서부터 질량비가 100의 거듭제곱일 때 파이의 숫자가 정확히 나타나는 이유를 이해하기 위해 지난 비디오에서 했던 것과 똑같으므로 여기서는 반복하지 않겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 827.1,
  "end": 836.7
 },
 {
  "input": "And finally, as we reflect now on how absurd the initial appearance of pi seemed, and on the two solutions we've now seen, and on how unexpectedly helpful it can be to represent the state of your system with points in some space, I leave you with this quote from the computer scientist Alan Kay.",
  "translatedText": "그리고 마지막으로, pi의 초기 모습이 얼마나 터무니없어 보였는지, 지금까지 본 두 가지 솔루션, 그리고 시스템의 상태를 어떤 공간의 점으로 표현하는 것이 얼마나 뜻밖에도 도움이 될 수 있는지 생각해 보면, 컴퓨터 과학자 Alan Kay의 명언을 남겨주세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 837.5,
  "end": 854.3
 },
 {
  "input": "A change in perspective is worth 80 IQ points.",
  "translatedText": "관점의 변화는 IQ 80점의 가치가 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 854.3,
  "end": 857.08
 }
]