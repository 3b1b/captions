[
 {
  "input": "Here, we look at the math behind an animation like this one, what's known as a complex Fourier series.",
  "translatedText": "여기서 우리는 이와 같은 애니메이션, 즉 복잡한 푸리에 급수라고 알려진 애니메이션 이면의 수학을 살펴봅니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 5.12,
  "end": 10.7
 },
 {
  "input": "Each little vector is rotating at some constant integer frequency, and when you add them together, tip to tail, the final tip draws out some shape over time.",
  "translatedText": "각각의 작은 벡터는 일정한 정수 주파수로 회전하며, 이를 끝에서 꼬리까지 함께 추가하면 시간이 지남에 따라 최종 끝이 모양을 그립니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 11.24,
  "end": 20.1
 },
 {
  "input": "By tweaking the initial size and angle of each vector, we can make it draw pretty much anything we want, and here you'll see how.",
  "translatedText": "각 벡터의 초기 크기와 각도를 조정함으로써 우리가 원하는 거의 모든 것을 그리도록 할 수 있으며 여기서는 그 방법을 살펴보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 21.22,
  "end": 28.62
 },
 {
  "input": "Before diving into it all, I want you to take a moment to just linger on how striking this is.",
  "translatedText": "모든 내용에 대해 자세히 알아보기 전에 잠시 시간을 내어 이것이 얼마나 놀라운지 잠시 생각해 보시기 바랍니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 31.12,
  "end": 36.12
 },
 {
  "input": "This particular animation has 300 rotating arrows in total.",
  "translatedText": "이 특정 애니메이션에는 총 300개의 회전 화살표가 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 37.2,
  "end": 40.9
 },
 {
  "input": "Go full screen for this if you can, the intricacy is worth it.",
  "translatedText": "가능하다면 전체 화면으로 이동하세요. 복잡함은 그만한 가치가 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 41.42,
  "end": 44.96
 },
 {
  "input": "Think about this, the action of each individual arrow is perhaps the simplest thing you could imagine, rotation at a steady rate.",
  "translatedText": "각 개별 화살표의 동작은 아마도 여러분이 상상할 수 있는 가장 간단한 것, 즉 일정한 속도로 회전하는 것일 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 50.44,
  "end": 57.96
 },
 {
  "input": "And yet the collection of all added together is anything but simple, and the mind-boggling complexity is put into an even sharper focus the farther we zoom in, revealing the contributions of the littlest, quickest, and downright frenetic arrows.",
  "translatedText": "그러나 모든 것을 합친 것의 집합은 결코 단순하지 않으며, 확대할 수록 놀라울 정도로 복잡한 복잡성은 더욱 선명하게 초점을 맞춰 가장 작고, 가장 빠르며, 완전히 열광적인 화살의 기여를 드러냅니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 58.6,
  "end": 71.48
 },
 {
  "input": "When you consider the chaotic frenzy you're looking at, and the clockwork rigidity underlying all the motions, it's bizarre how the swarm acts with a kind of coordination to trace out some very specific shape.",
  "translatedText": "당신이 보고 있는 혼란스러운 광란과 모든 움직임의 기초가 되는 시계 태엽의 경직성을 고려할 때, 떼가 매우 구체적인 형태를 추적하기 위해 일종의 조정을 통해 어떻게 행동하는지 기괴합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 72.3,
  "end": 83.4
 },
 {
  "input": "And unlike much of the emergent complexity you find elsewhere in nature, this is something we have the math to describe and control completely.",
  "translatedText": "그리고 자연의 다른 곳에서 발견되는 많은 새로운 복잡성과는 달리 이것은 우리가 완전히 설명하고 제어할 수 있는 수학을 가지고 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 83.84,
  "end": 91.08
 },
 {
  "input": "Just by tuning the starting conditions, nothing more, we can make this swarm conspire in all the right ways to draw anything you want, provided you have enough little arrows.",
  "translatedText": "시작 조건만 조정하면 이 떼가 올바른 방법으로 공모하여 원하는 것은 무엇이든 그릴 수 있습니다. 단, 작은 화살만 충분하면 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 91.66,
  "end": 101.56
 },
 {
  "input": "What's even crazier is that the ultimate formula for all of this is incredibly short.",
  "translatedText": "더 놀라운 점은 이 모든 것에 대한 궁극적인 공식이 믿을 수 없을 정도로 짧다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 102.18,
  "end": 106.52
 },
 {
  "input": "Often Fourier series are described in terms of something that looks a little different, functions of real numbers being broken down as a sum of sine waves.",
  "translatedText": "종종 푸리에 급수는 약간 다르게 보이는 것, 즉 실수의 함수가 사인파의 합으로 분해되는 것으로 설명됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 112.96,
  "end": 120.56
 },
 {
  "input": "That turns out to be a special case of this more general rotating vector phenomenon we'll build up to, but it's where Fourier himself started, and there's good reason for us to start the story there as well.",
  "translatedText": "이는 우리가 앞으로 구축할 보다 일반적인 회전 벡터 현상의 특별한 경우로 밝혀졌습니다. 그러나 푸리에 자신이 시작한 곳이 바로 여기이며 우리가 그곳에서 이야기를 시작해야 할 타당한 이유도 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 121.26,
  "end": 130.78
 },
 {
  "input": "Technically, this is the third video in a sequence about the heat equation, what Fourier was working on when he developed his big idea.",
  "translatedText": "기술적으로 이것은 푸리에가 자신의 큰 아이디어를 개발할 때 작업했던 열 방정식에 대한 세 번째 비디오입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 131.42,
  "end": 137.56
 },
 {
  "input": "I would like to teach you about Fourier series in a way that doesn't depend on you coming from those chapters, but if you have at least a high level idea for the problem from physics which originally motivated this piece of math, it gives some indication for just how unexpectedly far-reaching Fourier series are.",
  "translatedText": "나는 여러분이 해당 장에서 나오는 것에 의존하지 않는 방식으로 푸리에 급수에 대해 가르치고 싶습니다. 그러나 원래 이 수학 부분에 동기를 부여한 물리학 문제에 대해 최소한 높은 수준의 아이디어가 있다면 푸리에 급수가 예상치 못하게 얼마나 광범위한지에 대한 표시입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 138.2,
  "end": 152.34
 },
 {
  "input": "All you need to know is that we had a certain equation which tells us how the temperature distribution on a rod would evolve over time, and incidentally it also describes many other phenomena unrelated to heat.",
  "translatedText": "여러분이 알아야 할 것은 막대의 온도 분포가 시간이 지남에 따라 어떻게 변하는지 알려주는 특정 방정식이 있다는 것입니다. 또한 이는 열과 관련 없는 다른 많은 현상도 설명합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 152.82,
  "end": 164.82
 },
 {
  "input": "And while it's hard to directly use this equation to figure out what will happen to an arbitrary heat distribution, there's a simple solution if the initial function just happens to look like a cosine wave, with a frequency tuned so that it's flat at each end point.",
  "translatedText": "임의의 열 분포에 어떤 일이 일어날지 파악하기 위해 이 방정식을 직접 사용하는 것은 어렵지만, 초기 함수가 우연히 코사인파처럼 보이고 각 끝점에서 평탄하도록 주파수가 조정된 경우 간단한 해결책이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 164.82,
  "end": 178.12
 },
 {
  "input": "Specifically, as you graph what happens over time, these waves simply get scaled down exponentially, with higher frequency waves having a faster exponential decay.",
  "translatedText": "특히, 시간이 지남에 따라 발생하는 현상을 그래프로 표시하면 이러한 파동은 기하급수적으로 축소되고, 주파수가 높은 파동은 기하급수적으로 더 빠르게 감소합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 178.56,
  "end": 187.96
 },
 {
  "input": "The heat equation happens to be what's known in the business as a linear equation, meaning if you know two solutions and add them up, that sum is a new solution.",
  "translatedText": "열 방정식은 업계에서 선형 방정식으로 알려져 있습니다. 즉, 두 가지 해를 알고 이를 더하면 그 합이 새로운 해가 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 190.36,
  "end": 200.2
 },
 {
  "input": "You can even scale them each by some constant, which gives you some dials to turn to construct a custom function solving the equation.",
  "translatedText": "상수에 따라 각각의 크기를 조정할 수도 있으며, 이를 통해 방정식을 푸는 사용자 정의 함수를 구성하기 위해 다이얼을 돌릴 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 200.88,
  "end": 207.4
 },
 {
  "input": "This is a fairly straightforward property that you can verify for yourself, but it's incredibly important.",
  "translatedText": "이는 직접 확인할 수 있는 매우 간단한 속성이지만 매우 중요합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 209.24,
  "end": 214.08
 },
 {
  "input": "It means that we can take our infinite family of solutions, these exponentially decaying cosine waves, scale a few of them by some custom constants of our choosing, and combine them to get a solution for a new, tailor-made initial condition, which is some combination of cosine waves.",
  "translatedText": "이는 우리가 기하급수적으로 쇠퇴하는 코사인파와 같은 무한한 솔루션 계열을 선택하고 그 중 일부를 우리가 선택한 사용자 정의 상수로 확장하고 이를 결합하여 새로운 맞춤형 초기 조건에 대한 솔루션을 얻을 수 있음을 의미합니다. 코사인파의 조합.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 214.08,
  "end": 229.5
 },
 {
  "input": "One important thing I'd like you to notice is that when you combine these waves, because the higher frequency ones decay faster, the sum you construct will tend to smooth out over time as all the high frequency terms quickly go to zero, leaving only the low frequency terms dominating.",
  "translatedText": "제가 주목하고 싶은 한 가지 중요한 점은 이러한 파동을 결합할 때 더 높은 주파수의 파동이 더 빨리 감쇠되기 때문에 구성한 합은 모든 고주파수 항이 빠르게 0으로 가면서 시간이 지남에 따라 평활해지는 경향이 있다는 것입니다. 저주파 용어가 지배적입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 230.2,
  "end": 245.38
 },
 {
  "input": "So in a funny way, all of the complexity in the evolution of this heat distribution which the heat equation implies is captured by this difference in the decay rates for the different pure frequency components.",
  "translatedText": "그래서 재미있는 방법으로, 열 방정식이 의미하는 이 열 분포 진화의 모든 복잡성은 서로 다른 순수 주파수 구성요소에 대한 감쇠율의 차이에 의해 포착됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 246.1,
  "end": 256.02
 },
 {
  "input": "It's at this point that Fourier gains immortality.",
  "translatedText": "푸리에가 불멸성을 얻는 것은 바로 이 시점이다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 258.04,
  "end": 260.48
 },
 {
  "input": "I think most normal people at this stage would say, well, I can solve the heat equation when the initial distribution just happens to look like a wave, or a sum of waves, but what a shame it is that most real world distributions don't at all look like that.",
  "translatedText": "이 단계의 대부분의 일반 사람들은 초기 분포가 파동이나 파동의 합처럼 보이면 열 방정식을 풀 수 있다고 말할 것입니다. 그러나 대부분의 실제 분포는 그렇지 않다는 것이 얼마나 안타까운 일입니까? 전혀 그렇게 보이지 않네요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 261.28,
  "end": 274.24
 },
 {
  "input": "I mean, for example, let's say you brought together two rods which were each at some uniform temperature, and you wanted to know what happens immediately after they come into contact.",
  "translatedText": "예를 들어, 각각 균일한 온도를 유지하는 두 개의 막대를 모으고 두 막대가 접촉한 직후 어떤 일이 일어나는지 알고 싶다고 가정해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 274.8,
  "end": 283.3
 },
 {
  "input": "To make the numbers simple, let's say the temperature of the left rod is 1 degree, and the right rod is negative 1 degree, and that the total length, L, of the combined two rods is 1.",
  "translatedText": "숫자를 간단하게 하기 위해 왼쪽 막대의 온도가 1도, 오른쪽 막대의 온도가 -1도이고 결합된 두 막대의 전체 길이 L이 1이라고 가정해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 285.06,
  "end": 294.9
 },
 {
  "input": "What this means is that our initial temperature distribution is a step function, which is so obviously different from a sine wave, or the sum of sine waves, don't you think?",
  "translatedText": "이것이 의미하는 바는 초기 온도 분포가 계단 함수라는 것입니다. 이는 사인파 또는 사인파의 합과는 명백히 다릅니다. 그렇지 않나요?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 294.9,
  "end": 304.56
 },
 {
  "input": "I mean, it's almost entirely flat, not wavy, and for god's sake it's even discontinuous!",
  "translatedText": "내 말은, 그것은 물결 모양이 아닌 거의 완전히 평평하고, 심지어는 불연속적이라는 것입니다!",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 305.1,
  "end": 309.82
 },
 {
  "input": "And yet Fourier thought to ask a question which seems absurd.",
  "translatedText": "그런데 푸리에는 터무니없는 질문을 하려고 생각했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 310.6,
  "end": 313.7
 },
 {
  "input": "How do you express this as a sum of sine waves?",
  "translatedText": "이것을 사인파의 합으로 어떻게 표현하나요?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 314.3,
  "end": 316.66
 },
 {
  "input": "Even more boldly, how do you express any initial distribution as a sum of sine waves?",
  "translatedText": "더욱 대담하게, 초기 분포를 사인파의 합으로 어떻게 표현합니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 317.12,
  "end": 321.34
 },
 {
  "input": "And it's more constrained than just that.",
  "translatedText": "그리고 그것은 그보다 더 제한적입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 321.8,
  "end": 323.76
 },
 {
  "input": "You have to restrict yourself to adding waves which satisfy a certain boundary condition, and as we saw last video, that means working with these cosine functions whose frequencies are all some whole number multiple of a given base frequency.",
  "translatedText": "특정 경계 조건을 만족하는 파동을 추가하는 것으로 제한해야 하며, 지난 비디오에서 본 것처럼 이는 주파수가 모두 주어진 기본 주파수의 정수배인 코사인 함수로 작업하는 것을 의미합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 324.12,
  "end": 336.06
 },
 {
  "input": "And by the way, if you were working with some different boundary condition, say that the endpoints have to stay fixed, you'd have a different set of waves at your disposal to piece together, in this case replacing that cosine expression with a sine.",
  "translatedText": "그건 그렇고, 다른 경계 조건을 사용하여 작업하는 경우 끝점이 고정되어 있어야 한다고 가정하면 함께 결합할 수 있는 다른 파동 세트가 있을 것입니다. 이 경우 코사인 표현식을 사인으로 바꿉니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 336.92,
  "end": 348.54
 },
 {
  "input": "It's strange how often progress in math looks more like asking a new question rather than simply answering old ones.",
  "translatedText": "수학의 발전이 단순히 오래된 질문에 답하기보다는 새로운 질문을 묻는 것처럼 보이는 경우가 얼마나 자주 있는지 이상합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 349.56,
  "end": 355.56
 },
 {
  "input": "Fourier really does have a kind of immortality now, with his name essentially synonymous with the idea of breaking down functions and patterns as combinations of simple oscillations.",
  "translatedText": "푸리에는 이제 실제로 일종의 불멸성을 갖고 있습니다. 그의 이름은 기본적으로 기능과 패턴을 단순한 진동의 조합으로 분해한다는 개념과 동의어입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 356.24,
  "end": 365.0
 },
 {
  "input": "It's really hard to overstate just how important and far-reaching that idea turned out to be, well beyond anything Fourier himself could have imagined.",
  "translatedText": "그 아이디어가 푸리에 자신이 상상할 수 있었던 것 이상으로 얼마나 중요하고 광범위한 것으로 판명되었는지 과장하기는 정말 어렵습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 365.7,
  "end": 372.94
 },
 {
  "input": "And yet the origin of all this is a piece of physics which, at first glance, has nothing to do with frequencies and oscillations.",
  "translatedText": "그러나 이 모든 것의 기원은 언뜻 보기에 주파수 및 진동과 아무 관련이 없는 물리학의 일부입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 373.6,
  "end": 380.6
 },
 {
  "input": "If nothing else, this should give you a hint about the general applicability of Fourier series.",
  "translatedText": "다른 것이 없다면, 이것은 푸리에 급수의 일반적인 적용 가능성에 대한 힌트를 줄 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 381.28,
  "end": 385.3
 },
 {
  "input": "Now hang on, I hear some of you saying, none of these sums of sine waves you're showing are actually the step function, they're all just approximations.",
  "translatedText": "잠깐만요, 여러분 중 일부가 여러분이 보여주고 있는 사인파의 합은 실제로 계단 함수가 아니며 모두 근사치일 뿐이라고 말하는 것을 들었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 386.04,
  "end": 393.08
 },
 {
  "input": "And it's true, any finite sum of sine waves will never be perfectly flat, except for a constant function, nor will it be discontinuous.",
  "translatedText": "그리고 사인파의 유한합은 상수 함수를 제외하고는 결코 완벽하게 평평하지 않으며 불연속적이지도 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 393.54,
  "end": 401.5
 },
 {
  "input": "But Fourier thought more broadly, considering infinite sums.",
  "translatedText": "그러나 푸리에는 무한한 합을 고려하여 더 광범위하게 생각했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 402.02,
  "end": 405.46
 },
 {
  "input": "In the case of our step function, it turns out to be equal to this infinite sum, where the coefficients are 1, negative one third, plus one fifth, minus one seventh, and so on for all the odd frequencies, and all of it is rescaled by 4 divided by pi.",
  "translatedText": "계단 함수의 경우 모든 홀수 주파수에 대해 계수가 1, 음의 1/3, 더하기 1/5, 빼기 7분의 1 등인 무한 합과 같은 것으로 나타났습니다. 4를 pi로 나누어 크기가 조정됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 406.24,
  "end": 422.98
 },
 {
  "input": "I'll explain where those numbers come from in a moment.",
  "translatedText": "잠시 후 그 숫자가 어디서 나오는지 설명하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 423.8,
  "end": 425.96
 },
 {
  "input": "Before that, it's worth being clear about what we mean by a phrase like infinite sum, which runs the risk of being a little vague.",
  "translatedText": "그 전에, 약간 모호할 위험이 있는 무한 합과 같은 문구가 무엇을 의미하는지 명확히 할 필요가 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 426.4,
  "end": 432.66
 },
 {
  "input": "Consider the simpler context of numbers, where you could say, for example, that this infinite sum of fractions equals pi divided by 4.",
  "translatedText": "예를 들어 이 무한한 분수의 합은 파이를 4로 나눈 것과 같다고 말할 수 있는 더 간단한 숫자의 맥락을 생각해 보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 433.54,
  "end": 441.08
 },
 {
  "input": "As you keep adding the terms one by one, at all times what you have is rational, it never actually equals the irrational pi divided by 4.",
  "translatedText": "항을 하나씩 계속 추가하면 항상 합리적인 값을 얻을 수 있지만 실제로는 무리수 파이를 4로 나눈 값과 같지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 441.68,
  "end": 449.76
 },
 {
  "input": "But this sequence of partial sums approaches pi over 4, which is to say, the numbers you see while never equaling pi over 4 get arbitrarily close to that value, and they stay arbitrarily close to that value.",
  "translatedText": "그러나 이 부분합 시퀀스는 4분의 pi에 접근합니다. 즉, 4분의 pi와 결코 같지 않으면서 표시되는 숫자는 임의로 해당 값에 가까워지고 임의로 해당 값에 가깝게 유지됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 450.38,
  "end": 462.88
 },
 {
  "input": "That's all a mouthful to say, so instead we abbreviate and just say the infinite sum equals pi over 4.",
  "translatedText": "말하기엔 너무 많은 내용이므로 대신에 무한 합은 파이/4와 같다고 줄여서 표현하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 463.72,
  "end": 469.16
 },
 {
  "input": "With functions, you're doing the same thing, but with many different values in parallel.",
  "translatedText": "함수를 사용하면 동일한 작업을 수행하지만 동시에 여러 다른 값을 사용합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 470.62,
  "end": 474.7
 },
 {
  "input": "Consider a specific input, and the value of all of these scaled cosine functions for that input.",
  "translatedText": "특정 입력과 해당 입력에 대해 스케일링된 모든 코사인 함수의 값을 고려하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 475.92,
  "end": 481.52
 },
 {
  "input": "If that input is less than 0.5, as you add more and more terms, the sum will approach 1.",
  "translatedText": "해당 입력이 0보다 작은 경우.5, 더 많은 항을 추가할수록 합은 1에 가까워집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 482.12,
  "end": 487.74
 },
 {
  "input": "If that input is greater than 0.5, as you add more and more terms, it would approach negative 1.",
  "translatedText": "해당 입력이 0보다 큰 경우.5, 더 많은 항을 추가하면 마이너스 1에 가까워집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 490.0,
  "end": 495.46
 },
 {
  "input": "At the input 0.5 itself, all of the cosines are 0, so the limit of the partial sums is also 0.",
  "translatedText": "입력 0에서.5 자체에서는 코사인이 모두 0이므로 부분합의 극한도 0입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 497.26,
  "end": 503.84
 },
 {
  "input": "That means that, somewhat awkwardly, for this infinite sum to be strictly true, we have to prescribe the value of this set function at the point of discontinuity to be 0, sort of halfway along the jump.",
  "translatedText": "이는 다소 어색하게도 이 무한 합이 엄격하게 참이 되기 위해서는 불연속점에서 이 설정 함수의 값을 점프의 중간 정도인 0으로 규정해야 한다는 것을 의미합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 504.6,
  "end": 515.24
 },
 {
  "input": "Analogous to an infinite sum of rational numbers being irrational, the infinite sum of wavy continuous functions can equal a discontinuous flat function.",
  "translatedText": "유리수의 무한합이 무리수인 것과 유사하게, 물결 모양 연속 함수의 무한합은 불연속 평탄 함수와 같을 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 516.08,
  "end": 526.74
 },
 {
  "input": "Getting limits into the game allows for qualitative changes, which finite sums alone never could.",
  "translatedText": "게임에 한계를 두는 것은 유한한 합만으로는 결코 할 수 없는 질적인 변화를 허용합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 527.16,
  "end": 532.38
 },
 {
  "input": "There are multiple technical nuances that I'm sweeping under the rug here.",
  "translatedText": "여기서는 은밀히 다루어야 할 여러 기술적 뉘앙스가 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 533.28,
  "end": 536.66
 },
 {
  "input": "Does the fact that we're forced into a certain value for the step function at the point of discontinuity make any difference for the heat flow problem?",
  "translatedText": "불연속점에서 계단 함수의 특정 값을 강제로 받는다는 사실이 열 흐름 문제에 어떤 차이를 가져옵니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 536.66,
  "end": 543.3
 },
 {
  "input": "For that matter, what does it really mean to solve a PDE with a discontinuous initial condition?",
  "translatedText": "그렇다면, 불연속 초기 조건이 있는 PDE를 푼다는 것은 실제로 무엇을 의미합니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 543.82,
  "end": 548.02
 },
 {
  "input": "Can we be sure that the limit of solutions to the heat equation is also a solution?",
  "translatedText": "열 방정식의 해의 극한도 해라고 확신할 수 있습니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 549.28,
  "end": 553.02
 },
 {
  "input": "And can we be sure that all functions actually have a Fourier series like this?",
  "translatedText": "그리고 모든 함수가 실제로 이와 같은 푸리에 급수를 갖는다고 확신할 수 있습니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 553.58,
  "end": 556.88
 },
 {
  "input": "If not, when not?",
  "translatedText": "그렇지 않다면 언제 아닌가?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 557.18,
  "end": 558.4
 },
 {
  "input": "These are exactly the kind of questions which real analysis is built to answer, but it falls a bit deeper in the weeds than I'd like to go here, so I'll relegate that all to links in the video's description.",
  "translatedText": "이것들은 실제 분석이 답변하기 위해 만들어진 질문과 정확히 일치하지만 여기에서 다루고 싶은 것보다 잡초에 조금 더 깊이 빠지기 때문에 모든 내용을 비디오 설명의 링크로 이관하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 559.08,
  "end": 568.08
 },
 {
  "input": "The upshot is that when you take the heat equation solutions associated with these cosine waves and add them all up, all infinitely many of them, you do get an exact solution describing how the step function will evolve over time, and if you had done this in 1822, you would have become immortal for doing so.",
  "translatedText": "결과는 이러한 코사인 파동과 관련된 열 방정식 솔루션을 선택하고 이를 무한히 더하면 시간이 지남에 따라 계단 함수가 어떻게 전개되는지 설명하는 정확한 솔루션을 얻을 수 있다는 것입니다. 1822년에 그렇게 했다면 당신은 불멸의 존재가 되었을 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 568.72,
  "end": 586.48
 },
 {
  "input": "The key challenge in all of this, of course, is to find these coefficients.",
  "translatedText": "물론 이 모든 것의 핵심 과제는 이러한 계수를 찾는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 587.14,
  "end": 591.24
 },
 {
  "input": "So far we've been thinking about functions with real number outputs, but for the computations, I'd like to show you something more general than what Fourier originally did, applying to functions whose output can be any complex number in the 2d plane, which is where all these rotating vectors from the opening come back into play.",
  "translatedText": "지금까지 우리는 실수 출력을 갖는 함수에 대해 생각해 왔지만, 계산을 위해 푸리에가 원래 했던 것보다 더 일반적인 것을 보여주고 싶습니다. 출력이 2차원 평면에서 임의의 복소수일 수 있는 함수에 적용하는 것입니다. 오프닝에서 회전하는 모든 벡터가 다시 작동하는 곳입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 593.88,
  "end": 609.22
 },
 {
  "input": "Why the added complexity?",
  "translatedText": "복잡성이 추가된 이유는 무엇입니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 610.88,
  "end": 612.26
 },
 {
  "input": "Well aside from being more general, in my view the computations become cleaner, and it's easier to understand why they actually work.",
  "translatedText": "좀 더 일반적인 것 외에도 제 생각에는 계산이 더 깔끔해지고 실제로 작동하는 이유를 이해하기가 더 쉬워졌습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 612.26,
  "end": 619.58
 },
 {
  "input": "More importantly, it sets a good foundation for the ideas that will come up later on in the series, like the Laplace transform, and the importance of exponential functions.",
  "translatedText": "더 중요한 것은 라플라스 변환 및 지수 함수의 중요성과 같이 시리즈 후반부에 나올 아이디어에 대한 좋은 토대를 마련한다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 620.3,
  "end": 627.88
 },
 {
  "input": "We'll still think of functions whose input is some real number on a finite interval, say from 0 up to 1 for simplicity.",
  "translatedText": "우리는 입력이 유한한 간격(예: 단순화를 위해 0에서 1까지)의 실수인 함수를 계속 생각할 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 629.3,
  "end": 636.0
 },
 {
  "input": "But whereas something like a temperature function will have outputs on the real number line, this broader view will let the outputs wander anywhere in the 2d complex plane.",
  "translatedText": "그러나 온도 함수와 같은 것의 출력은 실수선에 있는 반면, 이 더 넓은 보기에서는 출력이 2D 복소 평면의 어느 곳이든 방황할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 636.56,
  "end": 644.54
 },
 {
  "input": "You might think of such a function as a drawing, with a pencil tip tracing out different points in the complex plane as the input ranges from 0 to 1.",
  "translatedText": "이러한 기능은 입력 범위가 0에서 1까지이므로 연필 끝으로 복잡한 평면의 여러 지점을 추적하는 그림으로 생각할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 645.12,
  "end": 652.74
 },
 {
  "input": "And instead of sine waves being the fundamental building block, as you saw at the start, we'll focus on breaking these functions down as a sum of little vectors, all rotating at some constant integer frequency.",
  "translatedText": "그리고 처음에 본 것처럼 사인파가 기본 구성 요소가 되는 대신 이러한 함수를 작은 벡터의 합으로 분해하는 데 중점을 둘 것이며 모두 일정한 정수 주파수로 회전합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 653.34,
  "end": 663.68
 },
 {
  "input": "Functions with real number outputs are essentially really boring drawings, a one-dimensional pencil sketch.",
  "translatedText": "실수 출력 기능은 본질적으로 정말 지루한 그림, 즉 1차원 연필 스케치입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 663.68,
  "end": 671.3
 },
 {
  "input": "You might not be used to thinking of them like this, since usually we visualize such a function with a graph, but right now the path being drawn is only in the output space.",
  "translatedText": "일반적으로 우리는 이러한 함수를 그래프로 시각화하기 때문에 이와 같이 생각하는 데 익숙하지 않을 수 있지만 현재 그려지는 경로는 출력 공간에만 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 671.98,
  "end": 680.82
 },
 {
  "input": "If you do one of these decompositions into rotating vectors for a boring drawing, what will happen is that the vectors with frequency 1 and negative 1 will have the same length, and they'll be horizontal reflections of each other.",
  "translatedText": "지루한 그림을 위해 이러한 분해 중 하나를 회전 벡터로 수행하면 주파수 1과 -1의 벡터가 동일한 길이를 가지며 서로 수평 반사가 되는 일이 발생합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 685.42,
  "end": 698.76
 },
 {
  "input": "When you just look at the sum of these two as they rotate, that sum stays fixed on the real number line, and it oscillates like a sine wave.",
  "translatedText": "이 둘이 회전하면서 그 합을 보면 그 합은 실수선에 고정되어 사인파처럼 진동합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 699.5,
  "end": 706.2
 },
 {
  "input": "If you haven't seen it before, this might be a really weird way to think about what a sine wave is, since we're used to looking at its graph rather than the output alone wandering on the real number line, but in the broader context of functions with complex number outputs, this oscillation on the horizontal line is what a sine wave looks like.",
  "translatedText": "이전에 본 적이 없다면 이것은 사인파가 무엇인지 생각하는 정말 이상한 방법일 수 있습니다. 왜냐하면 우리는 실수선에서 방황하는 출력보다는 그래프를 보는 데 익숙하기 때문입니다. 복소수 출력을 사용하는 함수의 더 넓은 맥락에서 수평선의 진동은 사인파처럼 보입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 706.92,
  "end": 723.32
 },
 {
  "input": "Similarly, the pair of rotating vectors with frequencies 2 and negative 2 will add another sine wave component, and so on, with the sine waves we were looking for earlier now corresponding to pairs of vectors rotating in opposite directions.",
  "translatedText": "마찬가지로, 주파수 2와 -2를 갖는 회전 벡터 쌍은 또 다른 사인파 구성요소를 추가하며, 앞서 우리가 찾고 있던 사인파는 이제 반대 방향으로 회전하는 벡터 쌍에 해당합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 724.92,
  "end": 738.76
 },
 {
  "input": "So the context that Fourier originally studied, breaking down real valued functions into sine waves, is a special case of the more general idea of 2D drawings and rotating vectors.",
  "translatedText": "따라서 실수 값 함수를 사인파로 분해하는 푸리에가 원래 연구한 내용은 2D 도면 및 회전 벡터에 대한 보다 일반적인 아이디어의 특별한 경우입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 739.64,
  "end": 749.2
 },
 {
  "input": "And at this point, maybe you don't trust me that widening our view to complex functions makes things easier to understand, but bear with me, it's really worth the added effort to see the fuller picture, and I think you'll be pleased with how clean the actual computation is in this broader context.",
  "translatedText": "그리고 이 시점에서는 복잡한 기능에 대한 관점을 넓히면 이해하기가 더 쉬워진다는 사실을 믿지 못할 수도 있지만, 양해해 주시기 바랍니다. 더 큰 그림을 보려면 추가로 노력할 가치가 있으며 여러분도 기뻐하실 것입니다. 이 더 넓은 맥락에서 실제 계산이 얼마나 깨끗한 지.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 754.58,
  "end": 768.44
 },
 {
  "input": "You may also wonder why, if we're going to bump things up into two dimensions, we don't just talk about 2D vectors, what does the square root of negative one have to do with anything?",
  "translatedText": "당신은 또한 왜 우리가 사물을 2차원으로 만들려면 2D 벡터에 대해서만 이야기하지 않고 음수 1의 제곱근이 어떤 것과 관련이 있는지 궁금할 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 769.1,
  "end": 777.24
 },
 {
  "input": "Well, the heart and soul of Fourier series is the complex exponential e to the i times t.",
  "translatedText": "음, 푸리에 급수의 핵심은 i 곱하기 t의 복소 지수 e입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 778.1,
  "end": 783.7
 },
 {
  "input": "As the input t ticks forward with time, this value walks around the unit circle at a rate of one unit per second.",
  "translatedText": "입력 t가 시간에 따라 앞으로 이동함에 따라 이 값은 초당 1단위의 속도로 단위원 주위를 이동합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 784.48,
  "end": 791.34
 },
 {
  "input": "In the next video you'll see a quick intuition for why exponentiating imaginary numbers walks around circles like this from the perspective of differential equations, and beyond that, as the series progresses, I hope to give you some sense for why complex exponentials like this are actually very important.",
  "translatedText": "다음 비디오에서는 왜 허수를 지수화하는 것이 미분 방정식의 관점에서 이렇게 원 주위를 도는 지에 대한 빠른 직관을 볼 수 있을 것입니다. 그리고 그 이상으로 시리즈가 진행됨에 따라 왜 이와 같은 복소 지수가 있는지에 대한 이해를 제공하고자 합니다. 실제로 매우 중요합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 792.28,
  "end": 807.06
 },
 {
  "input": "In theory, you could describe all of the Fourier series stuff purely in terms of vectors, and never breathe a word of i, the square root of negative one.",
  "translatedText": "이론적으로는 모든 푸리에 급수를 벡터로만 설명할 수 있으며 음수의 제곱근인 i라는 단어는 전혀 사용하지 않을 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 807.74,
  "end": 814.64
 },
 {
  "input": "The formulas would become more convoluted, but beyond that, leaving out the function e to the x would somehow no longer authentically reflect why this idea turns out to be so useful for solving differential equations.",
  "translatedText": "공식은 더욱 복잡해지겠지만, 그 이상으로 함수 e를 x에 빼면 이 아이디어가 미분 방정식을 푸는 데 왜 그렇게 유용한지 더 이상 확실하게 반영하지 못할 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 815.3,
  "end": 826.78
 },
 {
  "input": "For right now, if you want, you can think of e to the i t as a notational shorthand for describing rotating vectors, but just keep in the back of your mind that it is more significant than mere shorthand.",
  "translatedText": "지금은 원하는 경우 e를 회전 벡터를 설명하기 위한 표기법 약어로 생각할 수 있지만 단순한 약칭보다 더 중요하다는 점을 명심하세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 827.42,
  "end": 837.48
 },
 {
  "input": "You'll notice I'm being a little loose with language using the words vector and complex numbers somewhat interchangeably, in large part because thinking of complex numbers as little arrows makes the idea of adding a lot of them together easier to visualize.",
  "translatedText": "벡터와 복소수라는 단어를 어느 정도 서로 바꿔서 사용하는 언어가 약간 느슨하다는 것을 알 수 있을 것입니다. 복소수를 작은 화살표로 생각하면 많은 수를 함께 추가하는 아이디어가 더 쉽게 시각화되기 때문입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 838.54,
  "end": 850.34
 },
 {
  "input": "Alright, armed with the function e to the i times t, let's write down a formula for each of these rotating vectors we're working with.",
  "translatedText": "좋아요, i 곱하기 t의 함수 e로 무장하고, 우리가 작업 중인 회전 벡터 각각에 대한 공식을 작성해 봅시다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 851.34,
  "end": 857.72
 },
 {
  "input": "For right now, think of each of them as starting pointing one unit to the right at the number 1.",
  "translatedText": "지금은 각각이 숫자 1에서 오른쪽으로 한 단위를 가리키기 시작한다고 생각하세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 858.12,
  "end": 862.58
 },
 {
  "input": "The easiest vector to describe is the constant one, which stays at the number 1, never moving, or if you prefer, it's quote-unquote rotating just at a frequency of 0.",
  "translatedText": "설명하기 가장 쉬운 벡터는 숫자 1에 머무르고 절대 움직이지 않는 상수 벡터입니다. 또는 원하는 경우 0의 빈도로 인용-인용 해제 회전을 사용합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 863.08,
  "end": 872.26
 },
 {
  "input": "Then there will be the vector rotating one cycle every second, which we write as e to the 2 pi i times t.",
  "translatedText": "그런 다음 매초마다 한 사이클을 회전하는 벡터가 있을 것입니다. 이를 2pi i 곱하기 t에 e로 씁니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 873.1,
  "end": 879.22
 },
 {
  "input": "That 2 pi is there because as t goes from 0 to 1, it needs to cover a distance of 2 pi along the circle.",
  "translatedText": "2파이가 있는 이유는 t가 0에서 1로 변할 때 원을 따라 2파이의 거리를 커버해야 하기 때문입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 879.74,
  "end": 886.44
 },
 {
  "input": "Technically in what's being shown, it's actually one cycle every 10 seconds so things aren't too dizzying, I'm slowing everything down by a factor of 10.",
  "translatedText": "기술적으로 보여지는 것은 실제로 10초마다 한 사이클이므로 상황이 너무 어지러워지지 않고 모든 것을 10배로 늦추고 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 887.7,
  "end": 893.56
 },
 {
  "input": "We also have a vector rotating at one cycle per second in the other direction, e to the negative 2 pi i times t.",
  "translatedText": "또한 초당 한 사이클로 다른 방향으로 회전하는 벡터도 있습니다. 즉, e에서 -2pi i 곱하기 t입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 895.32,
  "end": 901.74
 },
 {
  "input": "Similarly, the one going two rotations per second is e to the 2 times 2 pi i times t, where that 2 times 2 pi in the exponent describes how much distance is covered in one second.",
  "translatedText": "마찬가지로, 초당 2회전하는 것은 e의 2 곱하기 2pi i 곱하기 t입니다. 여기서 지수의 2 곱하기 2pi는 1초에 얼마나 많은 거리를 이동하는지를 나타냅니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 904.3,
  "end": 916.74
 },
 {
  "input": "And we go on like this over all integers, both positive and negative, with a general formula of e to the n times 2 pi times i t.",
  "translatedText": "그리고 우리는 양수와 음수 모두의 모든 정수에 대해 e의 n 곱하기 2 파이 곱하기 i t의 일반 공식을 사용하여 이렇게 진행합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 920.6,
  "end": 928.8
 },
 {
  "input": "Notice this makes it more consistent to write that constant vector as e to the 0 times 2 pi times i t, which feels like an awfully complicated way to write the number 1, but at least it fits the pattern.",
  "translatedText": "이렇게 하면 상수 벡터를 e로 0 곱하기 2 파이 곱하기로 쓰는 것이 더 일관되게 됩니다. 숫자 1을 쓰는 것은 엄청나게 복잡한 방법처럼 느껴지지만 적어도 패턴에는 맞습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 929.34,
  "end": 939.62
 },
 {
  "input": "The control we have, the set of knobs and dials we get to turn, is the initial size and direction of each of these numbers.",
  "translatedText": "우리가 제어할 수 있는 노브와 다이얼 세트는 각 숫자의 초기 크기와 방향입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 940.5,
  "end": 946.9
 },
 {
  "input": "The way we control that is by multiplying each one by some complex constant, which I'll call c sub n.",
  "translatedText": "우리가 이를 제어하는 방법은 각각에 c sub n이라고 부르는 복잡한 상수를 곱하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 947.48,
  "end": 953.24
 },
 {
  "input": "For example, if we wanted the constant vector not to be at the number 1, but to have a length of 0.5, c sub 0 would be 0.5.",
  "translatedText": "예를 들어, 상수 벡터가 숫자 1이 아닌 길이가 0이 되기를 원한다고 가정해 보겠습니다.5, c sub 0은 0이 됩니다.5.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.88,
  "end": 961.86
 },
 {
  "input": "If we wanted the vector rotating at 1 cycle per second to start off at an angle of 45 degrees, we'd multiply it by a complex number which has the effect of rotating it by that much, which you can write as e to the pi fourths times i.",
  "translatedText": "초당 1주기로 회전하는 벡터가 45도 각도에서 시작하기를 원한다면, 그 만큼 회전하는 효과가 있는 복소수를 곱하면 됩니다. 이를 pi에 e로 쓸 수 있습니다. 네 번째 시간 i.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 962.54,
  "end": 975.0
 },
 {
  "input": "And if its initial length needed to be 0.3, then the coefficient c sub 1 would be 0.3 times that amount.",
  "translatedText": "그리고 초기 길이가 0이어야 하는 경우.3이면 계수 c sub 1은 0이 됩니다.그 금액의 3배.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 975.64,
  "end": 981.8
 },
 {
  "input": "Likewise, everyone in our infinite family of rotating vectors has some complex constant being multiplied into it, which determines its initial angle and its total magnitude.",
  "translatedText": "마찬가지로 무한한 회전 벡터 계열의 모든 구성원은 초기 각도와 전체 크기를 결정하는 복잡한 상수를 곱합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 982.76,
  "end": 991.9
 },
 {
  "input": "Our goal is to express any arbitrary function f of t, say this one that draws an eighth note as t goes from 0 to 1, as a sum of terms like this, so we need some way of picking out these constants one by one, given the data of the function itself.",
  "translatedText": "우리의 목표는 t의 임의의 함수 f(예를 들어 t가 0에서 1로 갈 때 8분 음표를 그리는 함수)를 다음과 같은 항의 합으로 표현하는 것입니다. 따라서 이러한 상수를 하나씩 선택하는 방법이 필요합니다. 함수 자체의 데이터가 주어졌습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 992.82,
  "end": 1009.44
 },
 {
  "input": "The easiest of these to find is the constant term.",
  "translatedText": "이들 중 가장 찾기 쉬운 것은 상수 항입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1011.84,
  "end": 1014.54
 },
 {
  "input": "This term represents a sort of center of mass for the full drawing.",
  "translatedText": "이 용어는 전체 도면에 대한 일종의 질량 중심을 나타냅니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1015.08,
  "end": 1018.48
 },
 {
  "input": "If you were to sample a bunch of evenly spaced values for the input t as it ranges from 0 to 1, the average of all the outputs of the function for those samples would be the constant term c0.",
  "translatedText": "0에서 1 사이의 범위에 있는 입력 t에 대해 균일한 간격의 값을 샘플링하는 경우 해당 샘플에 대한 함수의 모든 출력 평균은 상수항 c0이 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1019.0,
  "end": 1030.62
 },
 {
  "input": "Or more accurately, as you consider finer and finer samples, the average of the outputs for these samples approaches c0 in the limit.",
  "translatedText": "또는 더 정확하게 말하면, 점점 더 미세한 샘플을 고려할 때 이러한 샘플의 출력 평균은 한계에서 c0에 접근합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1031.36,
  "end": 1039.24
 },
 {
  "input": "What I'm describing, finer and finer sums of a function for samples of t from the input range, is an integral, an integral of f of t from 0 to 1.",
  "translatedText": "내가 설명하는 것은 입력 범위에서 t의 샘플에 대한 함수의 더 미세한 합은 적분, 즉 0에서 1까지의 t에 대한 f의 적분입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1040.0,
  "end": 1048.5
 },
 {
  "input": "Normally, since I'm framing this all in terms of averages, you would divide the integral by the length of the input range, but that length is 1, so in this case, taking an integral and taking an average are the same thing.",
  "translatedText": "일반적으로 이 모든 것을 평균으로 구성하기 때문에 적분을 입력 범위의 길이로 나누겠지만 그 길이는 1이므로 이 경우 적분을 취하는 것과 평균을 취하는 것은 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1050.82,
  "end": 1062.08
 },
 {
  "input": "There's a very nice way to think about why this integral would pull out c0.",
  "translatedText": "왜 이 적분이 c0를 끌어내는지에 대해 생각해 볼 수 있는 아주 좋은 방법이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1062.64,
  "end": 1066.58
 },
 {
  "input": "Remember, we want to think of this function as a sum of rotating vectors, so consider this integral, this continuous average, as being applied to that whole sum.",
  "translatedText": "기억하세요, 우리는 이 함수를 회전하는 벡터의 합으로 생각하고 싶기 때문에 이 적분, 이 연속 평균이 전체 합에 적용되는 것으로 생각하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1067.38,
  "end": 1076.6
 },
 {
  "input": "The average of a sum like this is the same as the sum over the averages of each part.",
  "translatedText": "이와 같은 합계의 평균은 각 부분의 평균에 대한 합계와 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1077.46,
  "end": 1082.58
 },
 {
  "input": "You can read this move as a sort of subtle shift in perspective.",
  "translatedText": "이 움직임은 일종의 관점의 미묘한 변화로 읽을 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1086.08,
  "end": 1089.24
 },
 {
  "input": "Rather than looking at the sum of all the vectors at each point in time and taking the average value they sweep out, look at the average of an individual vector as t goes from 0 to 1, and then add up all these averages.",
  "translatedText": "각 시점의 모든 벡터의 합을 보고 그 벡터가 쓸어내는 평균값을 취하는 대신 t가 0에서 1로 갈수록 개별 벡터의 평균을 보고 이 모든 평균을 합산하는 것이 좋습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1089.52,
  "end": 1101.54
 },
 {
  "input": "But each of these vectors just makes a whole number of rotations around 0, so its average value as t ranges from 0 to 1 will be 0.",
  "translatedText": "그러나 이들 벡터 각각은 0을 중심으로 전체 회전 수를 만들므로 t 범위가 0에서 1 사이일 때 평균 값은 0이 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1102.48,
  "end": 1110.8
 },
 {
  "input": "The only exception is the constant term.",
  "translatedText": "유일한 예외는 상수 항입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1111.34,
  "end": 1113.44
 },
 {
  "input": "Since it stays static and doesn't rotate, its average value is just whatever number it happened to start on, which is c0.",
  "translatedText": "정적으로 유지되고 회전하지 않기 때문에 평균값은 시작하는 숫자, 즉 c0입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1113.94,
  "end": 1120.84
 },
 {
  "input": "So doing this average over the whole function is a sort of clever way to kill all the terms that aren't c0.",
  "translatedText": "따라서 전체 함수에 대해 이 평균을 구하는 것은 c0이 아닌 모든 항을 죽이는 일종의 영리한 방법입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1121.6,
  "end": 1127.5
 },
 {
  "input": "But here's the clever part.",
  "translatedText": "하지만 여기에 영리한 부분이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1128.04,
  "end": 1129.56
 },
 {
  "input": "Let's say you wanted to compute a different term, like c2, sitting in front of the vector rotating two cycles per second.",
  "translatedText": "초당 2사이클을 회전하는 벡터 앞에 있는 c2와 같은 다른 항을 계산하고 싶다고 가정해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1129.86,
  "end": 1135.8
 },
 {
  "input": "The trick is to first multiply f of t by something that makes that vector hold still, sort of the mathematical equivalent of giving a smartphone to an overactive child.",
  "translatedText": "비결은 먼저 t의 f에 벡터를 고정시키는 무언가를 곱하는 것입니다. 이는 지나치게 활동적인 어린이에게 스마트폰을 주는 것과 같은 수학적 등가물입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1136.42,
  "end": 1145.44
 },
 {
  "input": "Specifically, if you multiply the whole function by e to the negative 2 times 2 pi i times t, think about what happens to each term.",
  "translatedText": "구체적으로, 전체 함수에 e를 -2 곱하기 2pi i 곱하기 t로 곱하면 각 항에 어떤 일이 일어나는지 생각해 보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1146.26,
  "end": 1154.5
 },
 {
  "input": "Since multiplying exponentials results in adding what's in the exponent, the frequency term in each of our exponents gets shifted down by 2.",
  "translatedText": "지수를 곱하면 지수의 내용이 더해지기 때문에 각 지수의 주파수 항은 2만큼 아래로 이동합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1156.64,
  "end": 1165.32
 },
 {
  "input": "So now, as we do our averages of each term, that c-1 vector spins around negative 3 times with an average of 0.",
  "translatedText": "이제 각 항의 평균을 계산할 때 c-1 벡터는 평균 0에서 마이너스 3번 회전합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1169.66,
  "end": 1176.72
 },
 {
  "input": "The c0 vector, previously constant, now rotates twice as t ranges from 0 to 1, so its average is also 0.",
  "translatedText": "이전에는 상수였던 c0 벡터는 이제 t 범위가 0에서 1까지 두 번 회전하므로 평균도 0입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1177.56,
  "end": 1184.98
 },
 {
  "input": "Likewise, all vectors other than the c2 term make some whole number of rotations, meaning they average out to be 0.",
  "translatedText": "마찬가지로, c2 항 이외의 모든 벡터는 정수 회전을 수행합니다. 즉, 평균이 0이 된다는 의미입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1186.52,
  "end": 1193.74
 },
 {
  "input": "So taking the average of this modified function is a clever way to kill all the terms other than c2.",
  "translatedText": "따라서 이 수정된 함수의 평균을 취하는 것은 c2 이외의 모든 항을 없애는 영리한 방법입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1195.28,
  "end": 1201.68
 },
 {
  "input": "And of course, there's nothing special about the number 2 here, you could replace it with any other n, and you have a general formula for cn, which is what we're looking for.",
  "translatedText": "그리고 물론, 여기서 숫자 2에는 특별한 것이 없습니다. 이를 다른 n으로 대체할 수 있으며, 우리가 찾고 있는 cn에 대한 일반 공식이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1202.36,
  "end": 1210.1
 },
 {
  "input": "Out of context, this expression might look complicated, but remember, you can read it as first modifying our function, our 2d drawing, so as to make the nth little vector hold still, and then performing an average which kills all the moving vectors and leaves you only with the still part.",
  "translatedText": "문맥상 이 표현식은 복잡해 보일 수 있지만 먼저 n번째 작은 벡터를 고정하기 위해 함수인 2D 드로잉을 수정한 다음 모든 움직이는 벡터를 죽이는 평균을 수행하는 것으로 읽을 수 있습니다. 정지된 부분만 남깁니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1210.66,
  "end": 1225.78
 },
 {
  "input": "Isn't that crazy?",
  "translatedText": "그거 미친거 아니야?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1226.46,
  "end": 1227.08
 },
 {
  "input": "All of the complexity in these decompositions you're seeing of drawings into sums of many rotating vectors is entirely captured in this little expression.",
  "translatedText": "도면을 많은 회전 벡터의 합으로 분해하는 과정에서 나타나는 모든 복잡성이 이 작은 표현에 완전히 담겨 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1227.5,
  "end": 1235.88
 },
 {
  "input": "So when I'm rendering these animations, that's exactly what I'm having the computer do.",
  "translatedText": "그래서 제가 이러한 애니메이션을 렌더링할 때 컴퓨터가 하는 일이 바로 이것이었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1236.54,
  "end": 1240.82
 },
 {
  "input": "It computes the path like a complex function, and for a certain range of values n, it computes this integral to find the coefficient c of n.",
  "translatedText": "이는 복잡한 함수처럼 경로를 계산하고 n 값의 특정 범위에 대해 이 적분을 계산하여 n의 계수 c를 찾습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1241.28,
  "end": 1249.06
 },
 {
  "input": "For those of you curious about where the data for a path itself comes from, I'm going the easy route and just having the program read in an SVG, which is a file format that defines the image in terms of mathematical curves rather than with pixel values.",
  "translatedText": "경로 자체의 데이터가 어디서 나오는지 궁금하신 분들을 위해 저는 쉬운 길을 택하여 SVG에서 프로그램을 읽도록 하겠습니다. SVG는 SVG가 아닌 수학적 곡선으로 이미지를 정의하는 파일 형식입니다. 픽셀 값.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1251.08,
  "end": 1262.82
 },
 {
  "input": "So the mapping f of t from a time parameter to points in space basically comes predefined.",
  "translatedText": "따라서 시간 매개변수에서 공간의 지점으로의 t 매핑 f는 기본적으로 미리 정의되어 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1263.28,
  "end": 1268.96
 },
 {
  "input": "In what's shown right now, I'm using 101 rotating vectors, computing the values of n from negative 50 up to 50.",
  "translatedText": "지금 표시된 것은 101개의 회전 벡터를 사용하여 -50에서 50까지 n 값을 계산하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1270.54,
  "end": 1277.48
 },
 {
  "input": "In practice, each of these integrals is computed numerically, basically meaning it chops up the unit interval into many small pieces of size delta t, and then adds up this value, f of t times e to the negative n 2 pi i t times delta t, for each one of them.",
  "translatedText": "실제로, 이러한 적분 각각은 수치적으로 계산됩니다. 즉, 기본적으로 단위 간격을 델타 t 크기의 여러 작은 조각으로 나눈 다음 이 값을 더합니다(f의 t 곱하기 e를 음의 n 2 pi에 델타 t를 곱함). , 그들 각각에 대해.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1278.12,
  "end": 1292.74
 },
 {
  "input": "There are fancier methods for more efficient numerical integration, but this gives the basic idea.",
  "translatedText": "보다 효율적인 수치 적분을 위한 더 멋진 방법이 있지만 이것이 기본 아이디어를 제공합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1293.28,
  "end": 1297.98
 },
 {
  "input": "And after you compute these 101 constants, each one determines an initial angle and magnitude for the little vectors, and then you just set them all rotating, adding them tip to tail as they go, and the path drawn out by the final tip is some approximation of the original path you fed in.",
  "translatedText": "그리고 이 101개의 상수를 계산한 후 각각은 작은 벡터의 초기 각도와 크기를 결정합니다. 그런 다음 모두 회전하도록 설정하고 끝에서 꼬리까지 이동하면서 추가합니다. 최종 끝이 그리는 경로는 다음과 같습니다. 공급한 원래 경로의 근사치입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1298.82,
  "end": 1314.4
 },
 {
  "input": "As the number of vectors used approaches infinity, the approximation path gets more and more accurate.",
  "translatedText": "사용된 벡터의 수가 무한대에 가까워질수록 근사 경로는 점점 더 정확해집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1315.1,
  "end": 1320.78
 },
 {
  "input": "To bring this all back down to Earth, consider the example we were looking at earlier, of a step function, which remember was useful for modeling the heat dissipation between two rods at different temperatures after they come into contact.",
  "translatedText": "이 모든 것을 다시 지구로 가져오려면 이전에 보았던 계단 함수의 예를 고려하십시오. 이 예는 두 막대가 접촉한 후 서로 다른 온도에서 사이의 열 방출을 모델링하는 데 유용했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1334.14,
  "end": 1345.5
 },
 {
  "input": "Like any real number valued function, the step function is like a boring drawing confined to one dimension.",
  "translatedText": "모든 실수 값 함수와 마찬가지로 계단 함수는 한 차원에 국한된 지루한 그림과 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1346.62,
  "end": 1352.5
 },
 {
  "input": "But this one is an especially dull drawing, since for inputs between 0 and 0.5, the output just stays static at the number 1, and then it discontinuously jumps to negative 1 for inputs between 0.5 and 1.",
  "translatedText": "그러나 이것은 0과 0 사이의 입력에 대한 것이기 때문에 특히 지루한 그림입니다.5에서 출력은 숫자 1에서 정적으로 유지된 다음 0 사이의 입력에 대해 불연속적으로 -1로 점프합니다.5와 1.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1353.24,
  "end": 1365.82
 },
 {
  "input": "So in the Fourier series approximation, the vector sum stays really close to 1 for the first half of the cycle, then quickly jumps to negative 1 and stays close to that for the second half of the cycle.",
  "translatedText": "따라서 푸리에 급수 근사법에서 벡터 합은 주기의 전반부 동안 1에 가깝게 유지되었다가 빠르게 -1로 점프하여 주기의 후반부 동안 그 값에 가깝게 유지됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1366.44,
  "end": 1376.68
 },
 {
  "input": "And remember, each pair of vectors rotating in opposite directions corresponds to one of the cosine waves we were looking at earlier.",
  "translatedText": "그리고 반대 방향으로 회전하는 각 벡터 쌍은 앞서 살펴본 코사인 파동 중 하나에 해당한다는 것을 기억하십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1377.5,
  "end": 1384.68
 },
 {
  "input": "To find the coefficients, you would need to compute this integral, and for the ambitious viewers among you itching to work out some integrals by hand, this is one where you can actually do the calculus to get an exact answer, rather than just having a computer do it numerically for you.",
  "translatedText": "계수를 찾으려면 이 적분을 계산해야 하며, 일부 적분을 손으로 풀고 싶어하는 야심 찬 시청자를 위해 이것은 단순히 계산하는 것이 아니라 실제로 미적분을 수행하여 정확한 답을 얻을 수 있는 곳입니다. 컴퓨터가 당신을 위해 숫자로 작업을 수행합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1386.08,
  "end": 1399.94
 },
 {
  "input": "I'll leave it as an exercise to work this out, and to relate it back to the idea of cosine waves by pairing off the vectors that rotate in opposite directions.",
  "translatedText": "이 문제를 해결하고 반대 방향으로 회전하는 벡터를 쌍으로 연결하여 코사인 파동의 개념과 다시 연관시키기 위한 연습으로 남겨두겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1399.94,
  "end": 1407.88
 },
 {
  "input": "And for the even more ambitious, I'll leave another exercise up on the screen for how to relate this more general computation with what you might see in a textbook describing Fourier series only in terms of real-valued functions with sines and cosines.",
  "translatedText": "그리고 훨씬 더 야심 찬 사람들을 위해 이 보다 일반적인 계산을 사인과 코사인이 있는 실수 값 함수 측면에서만 푸리에 급수를 설명하는 교과서에서 볼 수 있는 것과 연관시키는 방법에 대한 또 다른 연습을 화면에 남겨 두겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1408.78,
  "end": 1420.94
 },
 {
  "input": "By the way, if you're looking for more Fourier series content, I highly recommend the videos by Mathologer and The Coding Train, and I'd also recommend this blog post, links of course in the description.",
  "translatedText": "그건 그렇고, 더 많은 Fourier 시리즈 콘텐츠를 찾고 있다면 Mathologer와 The Coding Train의 비디오를 강력히 추천하며, 설명에 있는 링크인 이 블로그 게시물도 추천합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1421.84,
  "end": 1431.68
 },
 {
  "input": "So on the one hand, this concludes our discussion of the heat equation, which was a little window into the study of partial differential equations.",
  "translatedText": "따라서 한편으로 이것은 편미분 방정식 연구에 대한 작은 창이었던 열 방정식에 대한 논의를 마무리합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1433.62,
  "end": 1440.72
 },
 {
  "input": "But on the other hand, this Fourier into Fourier series is a first glimpse at a deeper idea.",
  "translatedText": "그러나 다른 한편으로, 이 푸리에 대 푸리에 시리즈는 더 깊은 아이디어를 처음으로 엿볼 수 있는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1441.24,
  "end": 1445.92
 },
 {
  "input": "Exponential functions, including their generalization into complex numbers and even matrices, play a very important role for differential equations, especially when it comes to linear equations.",
  "translatedText": "복소수 및 행렬로의 일반화를 포함한 지수 함수는 미분 방정식, 특히 선형 방정식의 경우 매우 중요한 역할을 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1446.5,
  "end": 1456.24
 },
 {
  "input": "What you just saw, breaking down a function as a combination of these exponentials and using that to solve a differential equation, comes up again and again in different shapes and forms.",
  "translatedText": "방금 본 것, 이러한 지수의 조합으로 함수를 분해하고 이를 사용하여 미분 방정식을 푸는 것은 다양한 모양과 형태로 계속해서 나타납니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1456.92,
  "end": 1485.9
 }
]