1
00:00:04,220 --> 00:00:05,700
リーマンのゼータ関数。

2
00:00:06,400 --> 00:00:08,080
これは、多くの人が聞いたことがあるかもしれ

3
00:00:08,080 --> 00:00:09,440
ない現代数学のオブジェクトの 1 

4
00:00:09,440 --> 00:00:11,440
つですが、理解するのが非常に難しい場合があります。

5
00:00:12,280 --> 00:00:13,692
心配しないでください。 先ほど見たアニ

6
00:00:13,692 --> 00:00:15,180
メーションについては数分後に説明します。

7
00:00:15,980 --> 00:00:18,225
この関数については多くの人が知っています。

8
00:00:18,225 --> 00:00:21,218
 リーマン予想として知られる未解決の問題、いつゼロに等し

9
00:00:21,218 --> 00:00:23,142
くなるかを理解できた人には 100 

10
00:00:23,142 --> 00:00:24,960
万ドルの賞金が与えられるからです。

11
00:00:25,600 --> 00:00:28,000
1 プラス 2 プラス 3 プラス 4 

12
00:00:28,000 --> 00:00:31,480
が無限に続く発散和の文脈でこのことを聞いたことがある人もい

13
00:00:31,480 --> 00:00:32,560
るかもしれません。

14
00:00:33,300 --> 00:00:35,593
この合計がマイナス 1/12 に等しいという

15
00:00:35,593 --> 00:00:37,886
感覚がありますが、これは明らかに間違っている

16
00:00:37,886 --> 00:00:40,180
わけではないにしても、ナンセンスに思えます。

17
00:00:40,700 --> 00:00:43,260
しかし、この方程式が実際に何を言っているかを定義する

18
00:00:43,260 --> 00:00:45,920
一般的な方法では、リーマン ゼータ関数が使用されます。

19
00:00:46,760 --> 00:00:50,214
しかし、これを読み始めたカジュアルな数学愛好家なら誰で

20
00:00:50,214 --> 00:00:53,669
も知っているように、その定義は、複素数値関数に関係する

21
00:00:53,669 --> 00:00:57,380
解析継続と呼ばれるこの 1 つのアイデアを参照しています。

22
00:00:57,860 --> 00:00:59,190
そして、このアイデアはイライラするほど

23
00:00:59,190 --> 00:01:00,520
不透明で直感的ではない場合があります。

24
00:01:01,400 --> 00:01:04,812
ここで私がやりたいことは、このゼータ関数が実際にどのよう

25
00:01:04,812 --> 00:01:08,224
なものかを皆さんにお見せし、この解析的継続の考え方がどの

26
00:01:08,224 --> 00:01:11,880
ようなものかを視覚的かつより直観的な方法で説明することです。

27
00:01:13,979 --> 00:01:15,990
複素数についての知識があり、複素数を扱う

28
00:01:15,990 --> 00:01:18,000
ことに慣れていることを前提としています。

29
00:01:18,440 --> 00:01:20,895
解析の継続はすべて導関数に関するものなので、微

30
00:01:20,895 --> 00:01:23,350
積分を知っておくべきだと言いたくなりますが、私

31
00:01:23,350 --> 00:01:25,805
が計画しているものを提示する方法を考えると、実

32
00:01:25,805 --> 00:01:28,260
際には微積分を知らなくても大丈夫だと思います。

33
00:01:29,140 --> 00:01:30,920
それでは早速本題に入るために、このゼ

34
00:01:30,920 --> 00:01:32,800
ータ関数が何であるかを定義しましょう。

35
00:01:32,800 --> 00:01:35,832
一般に変数 s を使用する特定の入力の場合、関数は 

36
00:01:35,832 --> 00:01:38,748
s に対して 1 に対して 1 (常に 1)、s 

37
00:01:38,748 --> 00:01:41,898
に対して 2 に対して 1 を加え、s に対して 3 

38
00:01:41,898 --> 00:01:45,047
に対して 1 を加え、s に対して 4 に対して 1 

39
00:01:45,047 --> 00:01:48,196
を加えます。 s を何度も繰り返し、すべての自然数を合

40
00:01:48,196 --> 00:01:48,780
計します。

41
00:01:50,960 --> 00:01:54,080
たとえば、s = 2 のような値を入力するとします。

42
00:01:54,720 --> 00:01:58,390
1 プラス 1 オーバー 4 プラス 1 オーバー 

43
00:01:58,390 --> 00:02:00,649
9 プラス 1 16 分の 1 

44
00:02:00,649 --> 00:02:04,885
が得られ、平方の逆数をどんどん足し続けると、これはたまたま 

45
00:02:04,885 --> 00:02:08,979
6 の円周率 2 乗、つまり約 1 に近づきます。645。

46
00:02:09,979 --> 00:02:12,516
ここに pi が表示される理由には非常に美しい理

47
00:02:12,516 --> 00:02:15,052
由があり、後日ビデオを作成するかもしれませんが、

48
00:02:15,052 --> 00:02:17,800
それはこの関数が美しい理由の氷山の一角にすぎません。

49
00:02:18,380 --> 00:02:20,332
他の入力 (3 や 4 など) 

50
00:02:20,332 --> 00:02:23,382
に対しても同じことを行うと、他の興味深い値が得られ

51
00:02:23,382 --> 00:02:24,480
る場合があります。

52
00:02:25,240 --> 00:02:26,210
そして、これまでのところ、すべて

53
00:02:26,210 --> 00:02:27,180
がかなり合理的だと感じています。

54
00:02:27,720 --> 00:02:29,620
どんどん小さな金額を合計していき

55
00:02:29,620 --> 00:02:31,640
、その合計はある数値に近づきます。

56
00:02:32,180 --> 00:02:33,800
素晴らしい、ここには狂気はありません。

57
00:02:34,660 --> 00:02:36,606
しかし、これについて読んでみると、マイナス 

58
00:02:36,606 --> 00:02:38,553
1 のゼータはマイナス 1 の 12 分の 

59
00:02:38,553 --> 00:02:40,500
1 に等しい、と言う人もいるかもしれません。

60
00:02:41,520 --> 00:02:44,400
しかし、この無限和を見ると、それは何の意味もありません。

61
00:02:44,400 --> 00:02:47,986
各項をマイナスの 1 に上げ、各分数を反転する

62
00:02:47,986 --> 00:02:51,573
と、すべての自然数にわたって 1 プラス 2 

63
00:02:51,573 --> 00:02:55,160
プラス 3 プラス 4 が繰り返し得られます。

64
00:02:55,720 --> 00:02:57,740
そして明らかに、それは何にも近づきません、

65
00:02:57,740 --> 00:02:59,760
確かにマイナス1/12ではありませんよね？

66
00:03:00,940 --> 00:03:04,880
そして、リーマン予想を研究している傭兵なら誰でも知っているよ

67
00:03:04,880 --> 00:03:08,820
うに、この関数は負の偶数に自明なゼロを持つと言われています。

68
00:03:09,400 --> 00:03:10,950
したがって、たとえば、マイナス 2 

69
00:03:10,950 --> 00:03:12,760
のゼータは 0 に等しいことを意味します。

70
00:03:12,760 --> 00:03:16,106
しかし、マイナス 2 を代入すると、1 プラス 4 

71
00:03:16,106 --> 00:03:18,937
プラス 9 プラス 16 が延々と続きます。

72
00:03:18,937 --> 00:03:21,254
 これも明らかに何にも近づきません。

73
00:03:21,254 --> 00:03:23,700
 ましてや 0 には近づきませんよね。

74
00:03:24,860 --> 00:03:27,683
そうですね、数分以内に負の値になりますが、今のとこ

75
00:03:27,683 --> 00:03:30,620
ろ、合理的だと思われることだけを言っておきましょう。

76
00:03:31,240 --> 00:03:33,674
この関数は、s が 1 より大きい場合、つま

77
00:03:33,674 --> 00:03:36,220
りこの合計が収束する場合にのみ意味を持ちます。

78
00:03:36,740 --> 00:03:39,760
これまでのところ、他の値については定義されていません。

79
00:03:40,840 --> 00:03:45,329
さて、そうは言っても、バーナード・リーマンは、入力と出力とし

80
00:03:45,329 --> 00:03:49,820
て複素数を持つ関数の研究である複素解析の父のようなものです。

81
00:03:50,720 --> 00:03:53,681
したがって、この合計が実数直線上の数値 s 

82
00:03:53,681 --> 00:03:57,047
を実数直線上の別の数値にどのように変換するかを考 

83
00:03:57,047 --> 00:03:59,470
えることよりも、彼の主な焦点は、s 

84
00:03:59,470 --> 00:04:03,240
に複素数値を代入すると何が起こるかを理解することでした。

85
00:04:04,040 --> 00:04:06,372
たとえば、2 を接続する代わりに、2 

86
00:04:06,372 --> 00:04:08,460
と i を接続するとよいでしょう。

87
00:04:10,280 --> 00:04:13,354
さて、数値を複素数値で累乗するという考え方を見たこと

88
00:04:13,354 --> 00:04:16,192
がなければ、最初は奇妙に感 じるかもしれません。

89
00:04:16,192 --> 00:04:19,740
 なぜなら、それは繰り返しの乗算とは何の関係もないからです。

90
00:04:20,660 --> 00:04:24,086
しかし数学者たちは、指数の定義を実数という馴染みの

91
00:04:24,086 --> 00:04:27,513
ある領域を超えて複素数値 の領域に拡張する、非常に

92
00:04:27,513 --> 00:04:30,940
優れた、非常に自然な方法があることを発見しました。

93
00:04:32,919 --> 00:04:35,573
このビデオの目的において、複雑な指数を理解す

94
00:04:35,573 --> 00:04:38,226
ることはそれほど重要で はありませんが、ここ

95
00:04:38,226 --> 00:04:40,880
では要点だけを要約しておくと良いと思います。

96
00:04:41,500 --> 00:04:44,766
基本的な考え方は、1/2 の複素数乗のようなも

97
00:04:44,766 --> 00:04:47,607
のを書くとき、それを実 数部の 1/2 

98
00:04:47,607 --> 00:04:51,300
と純粋な虚数部の 1/2 に分割するということです。

99
00:04:52,080 --> 00:04:55,260
本番までの半分は順調に進んでおり、問題はありません。

100
00:04:55,560 --> 00:04:58,600
しかし、何かを純粋な虚数に引き上げる場合はどうでしょうか?

101
00:05:02,659 --> 00:05:08,460
そうですね、結果は複素平面の単位円上の複素数になります。

102
00:05:09,480 --> 00:05:13,461
純粋な想像上の入力を想像上の線の上を上下に移動させると 

103
00:05:13,461 --> 00:05:17,300
、結果として得られる出力はその単位円の周りを歩きます。

104
00:05:21,280 --> 00:05:23,530
1/2 のようなベースの場合、出力は単

105
00:05:23,530 --> 00:05:25,900
位円の周囲をややゆっくりと歩き回ります。

106
00:05:26,840 --> 00:05:30,773
しかし、1 9 分の 1 など、1 から離れた基数の場 

107
00:05:30,773 --> 00:05:34,567
合、この入力を虚数軸上で上下に移動させると、対応する 

108
00:05:34,567 --> 00:05:38,220
出力は単位円の周囲をより速く移動することになります。

109
00:05:39,300 --> 00:05:41,036
これを見たことがなく、一体なぜこのようなことが

110
00:05:41,036 --> 00:05:42,772
起こるのか疑問に思ってい る方のために、説明の

111
00:05:42,772 --> 00:05:44,660
中に優れたリソースへのリンクをいくつか残しました。

112
00:05:45,320 --> 00:05:46,669
ここでは、「Why」を使わずに「

113
00:05:46,669 --> 00:05:48,020
What」だけを進めていきます。

114
00:05:49,180 --> 00:05:52,975
主なポイントは、1 の半分の 2 乗に i を加えたも 

115
00:05:52,975 --> 00:05:56,635
の (1 の 2 乗の 1 の 2 乗に i の 1 

116
00:05:56,635 --> 00:06:00,160
の半分を乗じたもの) の場合、その i の 1 の 

117
00:06:00,160 --> 00:06:03,820
半分が単位円上にあることです。 の絶対値は 1 です。

118
00:06:05,680 --> 00:06:08,343
したがって、乗算しても数値のサイズは変わりません。

119
00:06:08,343 --> 00:06:10,900
 4 分の 1 を取り、多少回転させるだけです。

120
00:06:10,900 --> 00:06:14,382
したがって、2 プラス i をゼータ関数に接続する場

121
00:06:14,382 --> 00:06:17,865
合、それが何をするか を考える 1 つの方法は、1 

122
00:06:17,865 --> 00:06:20,678
の半分を i の部分に取り込み、それが何 

123
00:06:20,678 --> 00:06:24,161
をするかを考えることです。 それは、提起されたすべて

124
00:06:24,161 --> 00:06:27,644
の項から始めることです。 これは、長さが数値の 2 

125
00:06:27,644 --> 00:06:30,591
乗の逆数である線をつなぎ合わせたものと考え 

126
00:06:30,591 --> 00:06:33,940
ることができ、前に述べたように、6 の pi の 

127
00:06:33,940 --> 00:06:35,280
2 乗に収束します。

128
00:06:35,280 --> 00:06:38,363
次に、その入力を 2 から 2 プラス i に変 

129
00:06:38,363 --> 00:06:41,200
更すると、これらの各線はある程度回転されます。

130
00:06:41,200 --> 00:06:43,504
しかし重要なのは、これらの線の長さは変わ 

131
00:06:43,504 --> 00:06:45,700
らないため、合計は依然として収束します。

132
00:06:46,060 --> 00:06:47,820
それは、複素平面上の特定の点に向

133
00:06:47,820 --> 00:06:49,580
かって螺旋状に行われるだけです。

134
00:06:50,880 --> 00:06:54,148
ここで、複素平面上のこの黄色の点で表される、入力 

135
00:06:54,148 --> 00:06:57,417
s を変化させたときにどのようになるかを示します。

136
00:06:57,417 --> 00:07:01,340
 この スパイラル和は常に s のゼータの収束値を示します。

137
00:07:12,820 --> 00:07:16,478
これが意味するのは、この無限和として定義される s 

138
00:07:16,478 --> 00:07:18,730
のゼータは、入力の実 部が 1 

139
00:07:18,730 --> 00:07:22,952
より大きい限り、完全に合理的な複素関数であるということです。

140
00:07:22,952 --> 00:07:26,752
 つ まり、入力 s が複素平面の右半分のどこかに位置

141
00:07:26,752 --> 00:07:28,300
することを意味します。

142
00:07:29,140 --> 00:07:32,799
繰り返しますが、これは、各数値のサイズを決定するのは s 

143
00:07:32,799 --> 00:07:36,460
の実数部であり、虚数部は回転を指示するだけであるためです。

144
00:07:39,159 --> 00:07:42,360
ここで私がやりたいのは、この関数を視覚化することです。

145
00:07:42,540 --> 00:07:45,950
複素平面の右半分で入力を受け取り、複素 

146
00:07:45,950 --> 00:07:49,020
平面の別の場所に出力を吐き出します。

147
00:07:49,760 --> 00:07:53,523
複雑な関数を理解する非常に優れた方法は、関数を変 

148
00:07:53,523 --> 00:07:57,437
換として視覚化することです。 つまり、関数へのあら 

149
00:07:57,437 --> 00:08:00,900
ゆる入力を調べて、対応する出力に移すだけです。

150
00:08:01,940 --> 00:08:04,171
たとえば、少し時間をとって、ゼータ関数よりももう

151
00:08:04,171 --> 00:08:06,030
少し簡単なものを視覚化し てみましょう。

152
00:08:06,030 --> 00:08:08,820
 たとえば、s の f が s の 2 乗に等しいとします。

153
00:08:09,400 --> 00:08:12,926
s = 2 を代入すると 4 が得られるため、 

154
00:08:12,926 --> 00:08:16,160
最終的に 2 の点を 4 の点に移動します。

155
00:08:16,880 --> 00:08:20,560
マイナス 1 を入力すると 1 が得られるため、マ 

156
00:08:20,560 --> 00:08:24,100
イナス 1 の点は最終的に 1 の点に移動します。

157
00:08:24,980 --> 00:08:28,245
i を入力すると、定義上、その 2 乗はマイナス 

158
00:08:28,245 --> 00:08:31,380
1 なので、ここではマイナス 1 に移動します。

159
00:08:32,179 --> 00:08:34,532
ここで、さらにカラフルなグリッドを追加します。

160
00:08:34,532 --> 00:08:37,191
 これは 、ちょうど物事が動き始めているためであり、

161
00:08:37,191 --> 00:08:40,260
その動き の中でグリッド線を区別できる何かがあると便利です。

162
00:08:40,860 --> 00:08:43,551
ここから、s が s の 2 乗に等しい関数 

163
00:08:43,551 --> 00:08:46,360
f に基づいて、このグリッド 上のすべての点を対

164
00:08:46,360 --> 00:08:49,520
応する出力に移動するようにコンピューターに指示します。

165
00:08:50,140 --> 00:08:51,340
外観は次のとおりです。

166
00:08:55,420 --> 00:08:56,806
それは理解することがたくさんあるかもしれな

167
00:08:56,806 --> 00:08:58,260
いので、先に進んでもう一度プレイしてみます。

168
00:08:58,260 --> 00:09:00,181
そして今回は、マークされた点の 1 

169
00:09:00,181 --> 00:09:02,317
つに焦点を当て、それがその 正方形に対応

170
00:09:02,317 --> 00:09:04,880
する点にどのように移動するかに注目してください。

171
00:09:07,240 --> 00:09:09,892
すべての点が一度に移動するのを見るのは少し複雑か

172
00:09:09,892 --> 00:09:12,544
もしれませんが、こ れにより、複雑な関数が実際に

173
00:09:12,544 --> 00:09:14,643
何を行っているかについて非常に豊富な 

174
00:09:14,643 --> 00:09:17,295
図が得られ、すべてが 2 次元内で行われるという

175
00:09:17,295 --> 00:09:18,180
利点があります。

176
00:09:20,340 --> 00:09:21,800
ゼータ関数に戻りましょう。

177
00:09:22,120 --> 00:09:26,333
複素数 s の関数であるこの無限和があり、実部が 1 

178
00:09:26,333 --> 00:09:30,702
より大きい s の値を代入し、収束するスパイラル和を介 

179
00:09:30,702 --> 00:09:34,760
して意味のある出力を得ることができて満足しています。

180
00:09:35,600 --> 00:09:38,845
この関数を視覚化するために、ここで複素平面の右側にあ 

181
00:09:38,845 --> 00:09:42,090
るグリッドの部分 (数値の実部が 1 より大きい部分 

182
00:09:42,090 --> 00:09:45,335
) を取得し、コンピューターに移動するよう指示します。

183
00:09:45,335 --> 00:09:48,460
 このグリッドの各ポイントを適切な出力に接続します。

184
00:09:49,220 --> 00:09:52,068
実際には、数字の 1 の周りにさらにグリッド線を追加する 

185
00:09:52,068 --> 00:09:54,720
と、その領域がかなり引き伸ばされるため、役に立ちます。

186
00:09:59,520 --> 00:10:01,550
さて、それではまず、それがどれほど

187
00:10:01,550 --> 00:10:03,580
美しいかをみんなで鑑賞しましょう。

188
00:10:04,000 --> 00:10:06,480
つまり、くそー、複雑な関数についてもっと学びたいと

189
00:10:06,480 --> 00:10:08,960
思わないのなら、あなたには心がないということです。

190
00:10:10,880 --> 00:10:13,290
しかしまた、この変換されたグリッドは

191
00:10:13,290 --> 00:10:15,700
、少し拡張されることを望んでいます。

192
00:10:16,880 --> 00:10:20,810
たとえば、ここでは虚数部 i または負の i を持つす 

193
00:10:20,810 --> 00:10:24,600
べての複素数を表すこれらの行を強調表示してみましょう。

194
00:10:26,940 --> 00:10:29,523
変身後はこの線がとても綺麗な弧

195
00:10:29,523 --> 00:10:32,280
を描きながらピタッと止まります。

196
00:10:33,000 --> 00:10:35,760
このままこの弧を続けたくないですか?

197
00:10:36,800 --> 00:10:40,378
実際、平面の左半分にまで拡張された定義を備えた関数の変 

198
00:10:40,378 --> 00:10:43,957
更バージョンを使用すると、この図を非常に美しいもので完 

199
00:10:43,957 --> 00:10:47,280
成させることができるかもしれないことが想像できます。

200
00:10:48,260 --> 00:10:50,243
そうですね、これはまさに複雑な

201
00:10:50,243 --> 00:10:52,360
関数を扱う数学者が行うことです。

202
00:10:52,360 --> 00:10:57,280
これらは、定義された元のドメインを超えて機能を継続します。

203
00:10:58,000 --> 00:11:02,569
ここで、実数部が 1 未満の入力に分岐するとすぐに、最初に関

204
00:11:02,569 --> 00:11:07,140
 数を定義するために使用したこの無限の合計は意味を失います。

205
00:11:07,420 --> 00:11:09,145
1 プラス 2 プラス 3 プラス 4 

206
00:11:09,145 --> 00:11:11,560
を無限大まで加算するようなナンセンスな結果が得られます。

207
00:11:12,260 --> 00:11:15,340
しかし、この平面の右半分の変換されたバージョンを見る

208
00:11:15,340 --> 00:11:18,421
と、合計が意味 を成しており、たとえそれが何らかの拡

209
00:11:18,421 --> 00:11:21,502
張関数を定義することを意味す るとしても、入力として

210
00:11:21,502 --> 00:11:24,109
考慮している点のセットを拡張するよう求めら 

211
00:11:24,109 --> 00:11:27,190
れているだけです。 必ずしもその合計を使用するわけで

212
00:11:27,190 --> 00:11:28,020
はありません。

213
00:11:29,220 --> 00:11:31,346
もちろん、飛行機の残りの部分でその機能をど 

214
00:11:31,346 --> 00:11:33,280
のように定義するかという疑問が残ります。

215
00:11:34,840 --> 00:11:37,680
いくらでも拡張できると思うかもしれません。

216
00:11:38,260 --> 00:11:41,214
おそらく、s がマイナス 1 に等しい点が 12 

217
00:11:41,214 --> 00:11:44,760
番目のマイナス 1 に移動するように拡張を定義するとします。

218
00:11:47,620 --> 00:11:49,390
ただし、拡張子を波線にして、他

219
00:11:49,390 --> 00:11:51,280
の値に到達する可能性があります。

220
00:11:51,280 --> 00:11:55,095
つまり、収束領域外の値、つまり無限和に基づいていない 

221
00:11:55,095 --> 00:11:58,911
値に対して関数を別の方法で定義するというアイデアに心 

222
00:11:58,911 --> 00:12:02,726
を開くとすぐに、世界はあなたの好みに合わせて拡張でき 

223
00:12:02,726 --> 00:12:06,260
、拡張はいくらでもできるようになります。 、 右？

224
00:12:07,319 --> 00:12:08,940
そうですね、正確にはそうではありません。

225
00:12:09,420 --> 00:12:13,020
つまり、はい、どの子にもマーカーを与えて、これらの線をどの

226
00:12:13,020 --> 00:12:16,620
方向にでも拡張させ ることができますが、この新しい拡張関数

227
00:12:16,620 --> 00:12:19,102
がどこにでも導関数を持たなければならな 

228
00:12:19,102 --> 00:12:21,709
いという制限を追加すると、可能なのは 1 

229
00:12:21,709 --> 00:12:23,820
つだけになってしまいます。 拡大。

230
00:12:25,340 --> 00:12:27,507
わかっています、わかっています、このビデオでは導

231
00:12:27,507 --> 00:12:29,765
関数について知る必要はないと言いましたが、たとえ 

232
00:12:29,765 --> 00:12:31,932
微積分を知っていたとしても、複素関数の導関数を解

233
00:12:31,932 --> 00:12:34,100
釈する方法をまだ学習していない可能性があります。

234
00:12:34,880 --> 00:12:37,301
しかし、私たちにとって幸運なことに、私が次のような

235
00:12:37,301 --> 00:12:39,722
フレーズを言うときに覚えて おくことができる非常に

236
00:12:39,722 --> 00:12:42,240
優れた幾何学的直観があり、どこにでも派生があります。

237
00:12:43,260 --> 00:12:45,240
ここで、私が言いたいことを示すために、s の f が 

238
00:12:45,240 --> 00:12:47,220
s の 2 乗に等しいという例を振り返ってみましょう。

239
00:12:47,859 --> 00:12:51,273
繰り返しますが、この関数は、複素平面のすべての点 

240
00:12:51,273 --> 00:12:54,960
s を点 s の二乗に移動する変換として考えられます。

241
00:12:56,080 --> 00:13:00,017
微積分を知っている人は、任意の入力でこの関数の導関数を取得 

242
00:13:00,017 --> 00:13:03,824
できることを知っていますが、その変換には、その事実に関連 

243
00:13:03,824 --> 00:13:07,500
し、ほぼ同等であることが判明する興味深い特性があります。

244
00:13:08,760 --> 00:13:12,427
入力空間内で何らかの角度で交差する 2 本の線に注 

245
00:13:12,427 --> 00:13:16,094
目し、変換後にそれらがどのようになるかを考慮すると 

246
00:13:16,094 --> 00:13:19,480
、それらの線は同じ角度で交差したままになります。

247
00:13:21,020 --> 00:13:24,462
線が曲がるかもしれませんが、それは問題ありませんが、重 

248
00:13:24,462 --> 00:13:27,660
要なのは、線が交わる角度は変わらないということです。

249
00:13:27,900 --> 00:13:31,080
これは、選択したどのペアのラインにも当てはまります。

250
00:13:34,780 --> 00:13:37,739
したがって、関数にはどこにでも導関数があると言う

251
00:13:37,739 --> 00:13:41,314
とき、この角度保 持の特性について考えてもらいたいのです。

252
00:13:41,314 --> 00:13:44,274
 つまり、2 本の線が交 差するときはいつでも、

253
00:13:44,274 --> 00:13:46,740
それらの間の角度は変換後も変化しません。

254
00:13:47,860 --> 00:13:51,988
これは、グリッド線が変化するすべての曲線が互いに直角に交差 

255
00:13:51,988 --> 00:13:55,980
していることに注目すると、一目で理解するのが最も簡単です。

256
00:13:58,580 --> 00:14:00,915
随所に導関数がある複雑な関数は解析的関数

257
00:14:00,915 --> 00:14:03,250
と呼ばれるため、この解 析的という用語は

258
00:14:03,250 --> 00:14:05,820
角度の保持を意味すると考えることができます。

259
00:14:06,680 --> 00:14:09,980
確かに、ここでは少し嘘をついていますが、ほんの少しだけです。

260
00:14:10,400 --> 00:14:13,492
完全な詳細が必要な方への若干の注意点は、関数の 

261
00:14:13,492 --> 00:14:16,585
導関数がゼロである入力では、角度が保持されるの 

262
00:14:16,585 --> 00:14:19,420
ではなく、何らかの整数が乗算されることです。

263
00:14:20,600 --> 00:14:23,753
しかし、それらの点は圧倒的に少数であり、分析関数 

264
00:14:23,753 --> 00:14:26,780
へのほとんどすべての入力では角度が保持されます。

265
00:14:29,520 --> 00:14:31,929
したがって、私が分析的と言うときに角度の保存を考

266
00:14:31,929 --> 00:14:34,440
えるのであれば、それは素晴らしい直観だと思います。

267
00:14:39,000 --> 00:14:41,002
ここで、少し考えてみてください。

268
00:14:41,002 --> 00:14:44,382
 これは本当に理解して いただきたい点ですが、これは非

269
00:14:44,382 --> 00:14:45,760
常に制限的な特性です。

270
00:14:46,420 --> 00:14:50,680
交差する線のペア間の角度は変更されない必要があります。

271
00:14:51,560 --> 00:14:53,615
それでも、名前が付いているほとんどすべ

272
00:14:53,615 --> 00:14:55,780
ての関数は分析的であることがわかります。

273
00:14:58,420 --> 00:15:02,554
リーマンが現代的な形で確立するのに貢献した複素解析の分野 

274
00:15:02,554 --> 00:15:06,688
は、ほぼ完全に解析関数の特性を活用して、数学や科学の他の 

275
00:15:06,688 --> 00:15:10,680
分野の結果やパターンを理解することに重点を置いています。

276
00:15:12,900 --> 00:15:15,634
ゼータ関数は、平面の右半分の無限

277
00:15:15,634 --> 00:15:18,540
和によって定義され、解析関数です。

278
00:15:19,340 --> 00:15:21,926
グリッド線が変化するこれらすべての曲線が依然とし

279
00:15:21,926 --> 00:15:24,620
て互いに直角に交差していることに注目してください。

280
00:15:28,100 --> 00:15:32,243
したがって、複素関数に関する驚くべき事実は、解析関数 

281
00:15:32,243 --> 00:15:36,386
を最初に定義された領域を超えて拡張する場合、たとえば 

282
00:15:36,386 --> 00:15:40,530
、このゼータ関数を平面の左半分に拡張する場合、新しい 

283
00:15:40,530 --> 00:15:43,752
拡張関数が必要な場合であるということです。

284
00:15:43,752 --> 00:15:47,895
 まだ分析的 です。 つまり、どこでも角度を保持してお

285
00:15:47,895 --> 00:15:51,578
り、拡張が存在 するとしても、可能な拡張は 1 

286
00:15:51,578 --> 00:15:52,960
つだけになります。

287
00:15:53,500 --> 00:15:56,566
これは、無限に連続するジグソーパズルのようなもの

288
00:15:56,566 --> 00:15:59,633
で、角度を維持するという 要件によって、角度を拡

289
00:15:59,633 --> 00:16:02,700
張する方法が 1 つだけの選択肢に固定されます。

290
00:16:04,400 --> 00:16:08,650
ご想像のとおり、分析関数を分析可能な唯一の方法で 

291
00:16:08,650 --> 00:16:12,560
拡張するこのプロセスは、分析継続と呼ばれます。

292
00:16:14,920 --> 00:16:17,720
これが完全なリーマン ゼータ関数の定義方法です。

293
00:16:18,240 --> 00:16:20,642
実数部が 1 より大きい、平面の右半分の 

294
00:16:20,642 --> 00:16:22,931
s の値については 、それらをこの合計に

295
00:16:22,931 --> 00:16:25,220
代入して、どこに収束するかを確認します。

296
00:16:25,680 --> 00:16:27,996
そして、これらの各項を複素累乗すると、各項

297
00:16:27,996 --> 00:16:30,313
が回転する効果があるた め、その収束はある

298
00:16:30,313 --> 00:16:32,740
種のスパイラルのように見えるかもしれません。

299
00:16:33,520 --> 00:16:37,151
次に、平面の残りの部分については、関数が依然として解析的で

300
00:16:37,151 --> 00:16:39,155
あるように、つまりすべての単一 

301
00:16:39,155 --> 00:16:42,786
点での角度が保持されるように、この定義を拡張する唯一の方法

302
00:16:42,786 --> 00:16:44,540
が存在することがわかります。

303
00:16:45,300 --> 00:16:48,782
したがって、定義上、平面の左半分のゼータ関数はその拡張 

304
00:16:48,782 --> 00:16:52,140
が何であれ、それが何であるかだけであるとだけ言えます。

305
00:16:52,960 --> 00:16:55,048
そして、可能な分析継続は 1 つだ

306
00:16:55,048 --> 00:16:57,260
けであるため、これは有効な定義です。

307
00:16:58,600 --> 00:17:00,900
これは非常に暗黙的な定義であることに注意してください。

308
00:17:01,420 --> 00:17:03,719
より抽象的な導出を通じて、このジグソーパズルが存在す

309
00:17:03,719 --> 00:17:06,108
るはずであることがわかっている、このジグソーパズルの 

310
00:17:06,108 --> 00:17:08,408
解決策を使用してくださいとだけ書かれていますが、それ

311
00:17:08,408 --> 00:17:10,619
を解く方法を正確に指定しているわけではありません。

312
00:17:11,160 --> 00:17:14,041
数学者はこの拡張機能がどのようなものかをかなりよく理解 

313
00:17:14,041 --> 00:17:16,819
していますが、その重要な部分は依然として謎のままです。

314
00:17:17,339 --> 00:17:18,940
実際、100万ドルの謎。

315
00:17:19,640 --> 00:17:21,750
実際に少し時間をとって、リーマン予想、

316
00:17:21,750 --> 00:17:23,859
100万ドル問題について話しましょう。

317
00:17:24,980 --> 00:17:26,586
この関数がゼロに等しい場所は非

318
00:17:26,586 --> 00:17:28,300
常に重要であることがわかります。

319
00:17:28,940 --> 00:17:31,110
つまり、変換後にどの点が原点にマ

320
00:17:31,110 --> 00:17:33,280
ッピングされるかということです。

321
00:17:34,480 --> 00:17:36,717
この拡張機能についてわかっていることの 1 

322
00:17:36,717 --> 00:17:39,260
つは、負の偶数はゼロにマップされるということです。

323
00:17:41,160 --> 00:17:43,560
これらは一般に自明ゼロと呼ばれます。

324
00:17:44,300 --> 00:17:47,428
ここでの命名は、最初からまったく明らかではない事 

325
00:17:47,428 --> 00:17:50,556
実であっても、よく理解している場合には物事を自明 

326
00:17:50,556 --> 00:17:53,560
と呼ぶという数学者の長年の伝統に由来しています。

327
00:17:54,560 --> 00:17:57,356
また、ゼロにマッピングされる残りの点は、クリティカル 

328
00:17:57,356 --> 00:17:59,635
ストリップと 呼ばれるこの垂直ストリップのど

329
00:17:59,635 --> 00:18:01,500
こかに位置することもわかっています。

330
00:18:01,760 --> 00:18:04,879
そして、これらの自明ではないゼロの特定の配置

331
00:18:04,879 --> 00:18:08,140
は、素数に関する驚くべき情報をコード化します。

332
00:18:09,120 --> 00:18:11,444
実際、この関数がなぜ素数についてこれほど多くの

333
00:18:11,444 --> 00:18:13,970
情報を伝えるのかは非常に興味深いので、それについ 

334
00:18:13,970 --> 00:18:16,294
ては後で必ずビデオにしようと思っていますが、現

335
00:18:16,294 --> 00:18:18,720
時点では十分に長いので、説明しないままにします。

336
00:18:19,780 --> 00:18:23,197
リーマンは、これらの自明ではないゼロはすべて、実部が 

337
00:18:23,197 --> 00:18:25,222
2 分の 1 で ある数値 s 

338
00:18:25,222 --> 00:18:28,640
の線上のストリップの中央に位置すると仮説を立てました。

339
00:18:29,460 --> 00:18:30,880
これをクリティカルラインといいます。

340
00:18:31,780 --> 00:18:34,261
それが本当であれば、素数のパターンだけでな

341
00:18:34,261 --> 00:18:36,742
く、そこから派生する数 学の他の多くのパタ

342
00:18:36,742 --> 00:18:39,460
ーンを驚くほど厳密に把握できるようになります。

343
00:18:40,340 --> 00:18:42,654
さて、これまでゼータ関数がどのようなものである

344
00:18:42,654 --> 00:18:44,969
かを示してきた とき、画面上のグリッドの部分に

345
00:18:44,969 --> 00:18:46,580
対してゼータ関数が何を行うかを 

346
00:18:46,580 --> 00:18:49,600
示しただけであり、そのためその複雑さが過小評価されています。

347
00:18:50,320 --> 00:18:53,535
したがって、この重要な線を強調表示して変換を適用した場合 

348
00:18:53,535 --> 00:18:56,640
、原点をまったく越えていないように見えるかもしれません。

349
00:18:57,200 --> 00:18:59,580
ただし、そのラインのさらに多くの変

350
00:18:59,580 --> 00:19:01,960
形バージョンが次のようになります。

351
00:19:06,440 --> 00:19:09,820
数値のゼロを何度も通過していることに注目してください。

352
00:19:10,500 --> 00:19:13,448
すべての非自明なゼロがこの線上のどこかにあることを

353
00:19:13,448 --> 00:19:16,514
証明できれば 、クレイ数学研究所はあなたに 100 

354
00:19:16,514 --> 00:19:19,463
万ドルを与え、また、す でに示されている現代数学の

355
00:19:19,463 --> 00:19:21,703
結果を数千とは言わないまでも、数百も 

356
00:19:21,703 --> 00:19:24,652
証明することになります。 この仮説が真実であること

357
00:19:24,652 --> 00:19:25,360
が条件です。

358
00:19:26,520 --> 00:19:28,480
この拡張関数についてわかっているもう 1 

359
00:19:28,480 --> 00:19:30,906
つのことは、点のマイナス 1 をマイナス 1 12 

360
00:19:30,906 --> 00:19:32,120
にマップしていることです。

361
00:19:34,160 --> 00:19:36,605
これを元の合計に当てはめると、1 プラス 2 

362
00:19:36,605 --> 00:19:39,794
プラス 3 プラス 4 を無限 大まで繰り返すと、マイナス 

363
00:19:39,794 --> 00:19:42,240
1 12 に等しいと言っているように見えます。

364
00:19:42,240 --> 00:19:45,108
さて、平面の左半分のゼータ関数の定義はこの

365
00:19:45,108 --> 00:19:47,977
合計から直接定義されな いため、これをまだ

366
00:19:47,977 --> 00:19:51,120
合計と呼ぶのは不誠実に思われるかもしれません。

367
00:19:51,740 --> 00:19:54,125
代わりに、それは、合計が収束する領域を超えて

368
00:19:54,125 --> 00:19:56,620
合計を分析的に継続することによって得られます。

369
00:19:57,120 --> 00:20:00,732
つまり、行の最初の行から始まったジグソーパズルを解くこと 

370
00:20:00,732 --> 00:20:04,220
、平面の右半分から始まったジグソーパズルを解くことです。

371
00:20:04,220 --> 00:20:07,145
そうは言っても、この分析継続の独自性、ジグソーパズルの解が 

372
00:20:07,145 --> 00:20:09,679
1 つし かないという事実は、これらの拡張された値と

373
00:20:09,679 --> 00:20:12,215
元の合計の間に何らかの本質 的な関係があることを非常

374
00:20:12,215 --> 00:20:14,360
に示唆していることを認めなければなりません。

