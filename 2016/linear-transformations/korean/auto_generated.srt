1
00:00:12,040 --> 00:00:12,920
안녕 모두들!

2
00:00:13,320 --> 00:00:15,489
선형 대수학의 다른 모든 주제를 클릭하게 

3
00:00:15,489 --> 00:00:17,658
만들고 학생이 선형 대수학을 처음 수강할 

4
00:00:17,658 --> 00:00:19,733
때 너무 자주 배우지 않게 되는 주제를 

5
00:00:19,733 --> 00:00:22,280
하나만 선택해야 한다면 바로 이 주제일 것입니다.

6
00:00:22,700 --> 00:00:26,200
선형 변환의 아이디어와 행렬과의 관계.

7
00:00:26,950 --> 00:00:29,549
이 비디오에서는 2차원의 경우 이러한 변환이 

8
00:00:29,549 --> 00:00:32,044
어떻게 나타나는지, 그리고 행렬 벡터 곱셈 

9
00:00:32,044 --> 00:00:35,060
아이디어와 어떤 관련이 있는지에 중점을 둘 것입니다.

10
00:00:35,880 --> 00:00:38,721
특히, 암기에 의존하지 않는 행렬 벡터 

11
00:00:38,721 --> 00:00:42,080
곱셈에 대해 생각하는 방법을 보여주고 싶습니다.

12
00:00:43,160 --> 00:00:46,580
시작하려면 선형 변환이라는 용어를 분석해 보겠습니다.

13
00:00:47,420 --> 00:00:49,880
변환은 본질적으로 기능에 대한 멋진 단어입니다.

14
00:00:50,260 --> 00:00:52,173
그것은 입력을 받아들이고 각각에 

15
00:00:52,173 --> 00:00:53,980
대한 출력을 뱉어내는 것입니다.

16
00:00:53,980 --> 00:00:56,454
특히 선형 대수학의 맥락에서 우리는 일부 

17
00:00:56,454 --> 00:00:58,820
벡터를 받아들이고 다른 벡터를 뱉어내는 

18
00:00:58,820 --> 00:01:01,080
변환에 대해 생각하는 것을 좋아합니다.

19
00:01:02,500 --> 00:01:04,316
그렇다면 동일한 의미인 경우 함수 대신 

20
00:01:04,316 --> 00:01:06,380
변환이라는 단어를 사용하는 이유는 무엇입니까?

21
00:01:07,120 --> 00:01:09,082
글쎄요, 이는 이러한 입출력 관계를 

22
00:01:09,082 --> 00:01:11,340
시각화하는 특정 방법을 암시하는 것입니다.

23
00:01:11,860 --> 00:01:13,830
벡터의 기능을 이해하는 가장 좋은 

24
00:01:13,830 --> 00:01:15,800
방법은 움직임을 이용하는 것입니다.

25
00:01:16,780 --> 00:01:20,820
변환이 일부 입력 벡터를 일부 출력 벡터로 가져오는 

26
00:01:20,820 --> 00:01:24,860
경우 입력 벡터가 출력 벡터로 이동한다고 상상합니다.

27
00:01:25,680 --> 00:01:28,601
그런 다음 변환을 전체적으로 이해하기 위해 

28
00:01:28,601 --> 00:01:31,523
가능한 모든 입력 벡터가 해당 출력 벡터로 

29
00:01:31,523 --> 00:01:34,080
이동하는 것을 상상해 볼 수 있습니다.

30
00:01:34,980 --> 00:01:37,257
모든 벡터를 한꺼번에, 각각을 화살표로 

31
00:01:37,257 --> 00:01:39,120
생각하는 것은 정말 복잡해집니다.

32
00:01:39,500 --> 00:01:41,995
그래서 제가 지난 비디오에서 언급했듯이, 

33
00:01:41,995 --> 00:01:44,924
좋은 비결은 각 벡터를 화살표가 아닌 단일 점, 

34
00:01:44,924 --> 00:01:47,420
즉 끝이 있는 점으로 개념화하는 것입니다.

35
00:01:48,030 --> 00:01:50,800
그런 식으로 가능한 모든 입력 벡터를 일부 출력 

36
00:01:50,800 --> 00:01:53,672
벡터로 변환하는 변환을 생각하기 위해 공간의 모든 

37
00:01:53,672 --> 00:01:56,340
지점이 다른 지점으로 이동하는 것을 관찰합니다.

38
00:01:57,220 --> 00:01:59,928
2차원 변환의 경우 변환의 전체 모양에 대한 

39
00:01:59,928 --> 00:02:02,746
더 나은 느낌을 얻기 위해 무한 그리드의 모든 

40
00:02:02,746 --> 00:02:05,780
점을 사용하여 이 작업을 수행하는 것을 좋아합니다.

41
00:02:06,560 --> 00:02:08,704
또한 나는 때때로 시작 위치와 관련하여 모든 것이 

42
00:02:08,704 --> 00:02:11,001
끝나는 위치를 추적하는 데 도움이 되도록 백그라운드에 

43
00:02:11,001 --> 00:02:12,840
그리드의 복사본을 유지하는 것을 좋아합니다.

44
00:02:14,460 --> 00:02:17,770
공간의 모든 지점 주위를 이동하는 

45
00:02:17,770 --> 00:02:21,080
다양한 변형의 효과는 아름답습니다.

46
00:02:21,880 --> 00:02:24,640
공간 자체가 찌그러지고 변형되는 느낌을 줍니다.

47
00:02:25,600 --> 00:02:27,887
상상할 수 있듯이 임의의 변환은 

48
00:02:27,887 --> 00:02:29,920
꽤 복잡해 보일 수 있습니다.

49
00:02:30,380 --> 00:02:33,983
그러나 다행히도 선형 대수학은 선형 변환이라고 

50
00:02:33,983 --> 00:02:37,448
불리는 이해하기 쉬운 특수한 유형의 변환으로 

51
00:02:37,448 --> 00:02:38,280
제한됩니다.

52
00:02:39,120 --> 00:02:41,459
시각적으로 말하면 두 가지 속성이 

53
00:02:41,459 --> 00:02:43,060
있는 변환은 선형입니다.

54
00:02:43,700 --> 00:02:46,895
모든 선은 휘어지지 않고 선을 유지해야 하며, 

55
00:02:46,895 --> 00:02:49,600
원점은 제자리에 고정되어 있어야 합니다.

56
00:02:50,620 --> 00:02:52,845
예를 들어, 여기 있는 선은 모두 

57
00:02:52,845 --> 00:02:55,540
곡선이 되기 때문에 선형 변환이 아닙니다.

58
00:02:56,100 --> 00:02:59,185
그리고 바로 여기 있는 것은 선을 직선으로 유지하지만 

59
00:02:59,185 --> 00:03:01,860
원점을 이동시키기 때문에 선형 변환이 아닙니다.

60
00:03:02,680 --> 00:03:04,835
여기 이건 원점을 수정해서 선을 직선으로 

61
00:03:04,835 --> 00:03:06,709
유지하는 것처럼 보일 수도 있지만, 

62
00:03:06,709 --> 00:03:09,240
가로 및 세로 격자선만 표시하고 있기 때문입니다.

63
00:03:09,540 --> 00:03:11,665
이것이 대각선에 어떤 영향을 미치는지 보면, 

64
00:03:11,665 --> 00:03:13,450
그 선이 모두 곡선으로 변하기 때문에 

65
00:03:13,450 --> 00:03:15,320
전혀 선형이 아니라는 것이 분명해집니다.

66
00:03:16,760 --> 00:03:19,394
일반적으로 선형 변환은 그리드 선을 평행하고 

67
00:03:19,394 --> 00:03:22,240
일정한 간격으로 유지하는 것으로 생각해야 합니다.

68
00:03:23,400 --> 00:03:25,470
일부 선형 변환은 원점에 대한 

69
00:03:25,470 --> 00:03:27,540
회전과 같이 생각하기 쉽습니다.

70
00:03:28,120 --> 00:03:30,600
다른 것들은 말로 설명하기가 조금 더 까다롭습니다.

71
00:03:32,040 --> 00:03:33,673
그렇다면 이러한 변환을 수치적으로 

72
00:03:33,673 --> 00:03:35,480
어떻게 설명할 수 있다고 생각하시나요?

73
00:03:35,480 --> 00:03:38,227
예를 들어, 주제를 가르치는 비디오를 만들기 

74
00:03:38,227 --> 00:03:40,975
위해 애니메이션을 프로그래밍하는 경우 벡터의 

75
00:03:40,975 --> 00:03:43,722
좌표를 제공하면 해당 벡터가 도달하는 위치의 

76
00:03:43,722 --> 00:03:46,580
좌표를 제공할 수 있도록 컴퓨터에 어떤 공식을 

77
00:03:46,580 --> 00:03:47,240
제공합니까?

78
00:03:48,480 --> 00:03:51,831
두 개의 기본 벡터인 i-hat과 j-hat, 

79
00:03:51,831 --> 00:03:54,666
각 랜드와 그 밖의 모든 것이 어디에서 

80
00:03:54,666 --> 00:03:56,600
따라오는지 기록하면 됩니다.

81
00:03:57,500 --> 00:03:59,463
예를 들어, 좌표가 음수 1, 

82
00:03:59,463 --> 00:04:01,888
2인 벡터 v를 생각해 보세요. 즉, 

83
00:04:01,888 --> 00:04:04,314
음수 1 x i-hat 더하기 2 x 

84
00:04:04,314 --> 00:04:05,700
j-hat과 같습니다.

85
00:04:08,680 --> 00:04:11,565
변환을 수행하고 이 세 벡터가 모두 어디로 

86
00:04:11,565 --> 00:04:14,572
가는지 따라가면 그리드 선이 평행하고 균일한 

87
00:04:14,572 --> 00:04:17,578
간격을 유지한다는 속성이 정말 중요한 결과를 

88
00:04:17,578 --> 00:04:18,300
가져옵니다.

89
00:04:19,100 --> 00:04:21,000
v가 착지하는 장소는 i-hat이 

90
00:04:21,000 --> 00:04:23,200
착지한 벡터의 음수 1배에 j-hat이 

91
00:04:23,200 --> 00:04:25,400
착지한 벡터의 2배를 더한 값이 됩니다.

92
00:04:25,980 --> 00:04:29,993
즉, i-hat과 j-hat의 특정 선형 조합으로 

93
00:04:29,993 --> 00:04:33,863
시작하여 두 벡터가 도달한 동일한 선형 조합으로 

94
00:04:33,863 --> 00:04:34,580
끝납니다.

95
00:04:35,620 --> 00:04:37,276
이는 i-hat과 j-hat이 각각 

96
00:04:37,276 --> 00:04:39,015
착륙한 위치만을 기반으로 v가 어디로 

97
00:04:39,015 --> 00:04:40,920
가야 하는지 추론할 수 있음을 의미합니다.

98
00:04:41,580 --> 00:04:42,887
이것이 내가 배경에 원본 그리드의 

99
00:04:42,887 --> 00:04:44,540
복사본을 유지하는 것을 좋아하는 이유입니다.

100
00:04:45,080 --> 00:04:49,140
여기에 표시된 변환의 경우 i-hat은 좌표 1, 

101
00:04:49,140 --> 00:04:52,474
-2에 있고 j-hat은 x축 좌표 3, 

102
00:04:52,474 --> 00:04:54,940
0에 있음을 읽을 수 있습니다.

103
00:04:55,540 --> 00:04:59,073
이는 -1 i-hat + 2 곱하기 j-hat으로 

104
00:04:59,073 --> 00:05:01,975
표현되는 벡터가 벡터 1의 -1 곱하기, 

105
00:05:01,975 --> 00:05:05,382
-2 더하기 벡터 3, 0의 2배로 끝나는 것을 

106
00:05:05,382 --> 00:05:06,140
의미합니다.

107
00:05:07,100 --> 00:05:09,171
이를 모두 합치면 벡터 5, 2에 

108
00:05:09,171 --> 00:05:11,680
도달해야 한다는 것을 추론할 수 있습니다.

109
00:05:14,260 --> 00:05:15,709
이것은 꽤 중요하기 때문에 잠시 

110
00:05:15,709 --> 00:05:17,240
멈춰서 생각해 보는 것이 좋습니다.

111
00:05:18,520 --> 00:05:21,764
이제 실제로 전체 변환을 보여주고 있으므로 

112
00:05:21,764 --> 00:05:25,280
v의 좌표가 5, 2라는 것을 볼 수 있습니다.

113
00:05:25,760 --> 00:05:28,664
그러나 여기서 멋진 부분은 변환 자체를 볼 필요 

114
00:05:28,664 --> 00:05:31,247
없이 i-hat과 j-hat이 각각 어디에 

115
00:05:31,247 --> 00:05:34,152
착지하는지에 대한 기록이 있는 한 벡터가 어디에 

116
00:05:34,152 --> 00:05:37,380
착지하는지 추론할 수 있는 기술을 제공한다는 것입니다.

117
00:05:38,600 --> 00:05:41,536
보다 일반적인 좌표인 x와 y를 사용하여 

118
00:05:41,536 --> 00:05:44,217
벡터를 작성하면 i-hat이 착지하는 

119
00:05:44,217 --> 00:05:47,025
벡터의 x배(1, -2)에 j-hat이 

120
00:05:47,025 --> 00:05:50,600
착지하는 벡터의 y배(3, 0)에 착지하게 됩니다.

121
00:05:51,860 --> 00:05:54,515
그 합계를 계산하면 1x + 3y, 

122
00:05:54,515 --> 00:05:58,100
-2x + 0y에 도달하는 것을 알 수 있습니다.

123
00:05:58,740 --> 00:06:00,353
제가 여러분에게 임의의 벡터를 제공하고 

124
00:06:00,353 --> 00:06:01,966
여러분은 이 공식을 사용하여 그 벡터가 

125
00:06:01,966 --> 00:06:03,580
어디에 도달하는지 말해 줄 수 있습니다.

126
00:06:04,860 --> 00:06:07,770
이 모든 것이 말하는 것은 2차원 선형 변환이 

127
00:06:07,770 --> 00:06:10,568
단지 4개의 숫자, 즉 i-hat이 착지하는 

128
00:06:10,568 --> 00:06:13,366
위치에 대한 두 좌표와 j-hat이 착지하는 

129
00:06:13,366 --> 00:06:16,500
위치에 대한 두 좌표로 완전히 설명된다는 것입니다.

130
00:06:17,080 --> 00:06:17,640
멋지지 않나요?

131
00:06:18,380 --> 00:06:21,139
이러한 좌표를 2x2 행렬이라고 하는 숫자의 

132
00:06:21,139 --> 00:06:23,899
2x2 격자로 패키징하는 것이 일반적입니다. 

133
00:06:23,899 --> 00:06:26,549
여기서 열을 i-hat과 j-hat이 각각 

134
00:06:26,549 --> 00:06:29,640
배치되는 두 개의 특수 벡터로 해석할 수 있습니다.

135
00:06:30,380 --> 00:06:34,317
선형 변환과 일부 특정 벡터를 설명하는 2x2 

136
00:06:34,317 --> 00:06:38,254
행렬이 주어졌고 해당 선형 변환이 해당 벡터를 

137
00:06:38,254 --> 00:06:42,494
사용하는 위치를 알고 싶다면 벡터의 좌표를 가져와 

138
00:06:42,494 --> 00:06:46,431
행렬의 해당 열을 곱한 다음 당신이 얻는 것을 

139
00:06:46,431 --> 00:06:47,340
합치십시오.

140
00:06:48,180 --> 00:06:50,223
이는 새로운 기본 벡터의 확장된 

141
00:06:50,223 --> 00:06:52,720
버전을 추가한다는 아이디어와 일치합니다.

142
00:06:54,720 --> 00:06:57,365
행렬에 항목 A, B, C, D가 있는 가장 

143
00:06:57,365 --> 00:07:00,540
일반적인 경우에 이것이 어떻게 보이는지 살펴보겠습니다.

144
00:07:01,100 --> 00:07:03,860
그리고 기억하세요. 이 행렬은 선형 변환을 설명하는 

145
00:07:03,860 --> 00:07:06,240
데 필요한 정보를 패키징하는 방법일 뿐입니다.

146
00:07:06,240 --> 00:07:09,678
항상 첫 번째 열인 AC를 첫 번째 기저 벡터가 있는 

147
00:07:09,678 --> 00:07:13,116
위치로 해석하고, 두 번째 열인 BD를 두 번째 기저 

148
00:07:13,116 --> 00:07:16,440
벡터가 있는 위치로 해석해야 한다는 점을 기억하세요.

149
00:07:17,500 --> 00:07:19,250
이 변환을 일부 벡터 xy에 

150
00:07:19,250 --> 00:07:21,000
적용하면 무엇을 얻게 됩니까?

151
00:07:22,060 --> 00:07:24,445
음, x 곱하기 AC 더하기 

152
00:07:24,445 --> 00:07:26,980
y 곱하기 BD가 될 것입니다.

153
00:07:28,060 --> 00:07:31,034
이것을 종합하면 벡터 Ax + By, 

154
00:07:31,034 --> 00:07:33,300
Cx + Dy를 얻게 됩니다.

155
00:07:33,980 --> 00:07:37,605
행렬을 함수처럼 벡터의 왼쪽에 배치하면 이를 

156
00:07:37,605 --> 00:07:40,940
행렬 벡터 곱셈으로 정의할 수도 있습니다.

157
00:07:41,660 --> 00:07:43,100
그러면 고등학생들에게 직관적으로 

158
00:07:43,100 --> 00:07:44,780
느껴지게 하는 중요한 부분을 보여주지 

159
00:07:44,780 --> 00:07:46,620
않고도 이것을 암기하게 만들 수 있습니다.

160
00:07:48,300 --> 00:07:51,777
하지만 이러한 열을 기저 벡터의 변환된 버전으로 

161
00:07:51,777 --> 00:07:54,740
생각하고 결과를 해당 벡터의 적절한 선형 

162
00:07:54,740 --> 00:07:57,960
조합으로 생각하는 것이 더 재미있지 않습니까?

163
00:08:00,720 --> 00:08:02,088
행렬을 사용하여 몇 가지 선형 

164
00:08:02,088 --> 00:08:03,780
변환을 설명하는 연습을 해 보겠습니다.

165
00:08:04,580 --> 00:08:08,546
예를 들어, 모든 공간을 시계 반대 방향으로 90도 

166
00:08:08,546 --> 00:08:12,240
회전하면 i-hat은 좌표 0, 1에 착지합니다.

167
00:08:13,980 --> 00:08:17,180
그리고 j-hat은 음수 1, 0 좌표에 도달합니다.

168
00:08:17,980 --> 00:08:20,225
따라서 우리가 끝나는 행렬에는 열 0, 

169
00:08:20,225 --> 00:08:21,960
1, 음수 1, 0이 있습니다.

170
00:08:22,880 --> 00:08:26,120
90도 회전 후 벡터에 어떤 일이 발생하는지 

171
00:08:26,120 --> 00:08:29,620
파악하려면 해당 좌표에 이 행렬을 곱하면 됩니다.

172
00:08:31,560 --> 00:08:32,861
여기 shear라고 불리는 특별한 

173
00:08:32,861 --> 00:08:34,299
이름을 가진 재미있는 변형이 있습니다.

174
00:08:35,000 --> 00:08:36,858
그 안에서 i-hat은 고정된 상태로 

175
00:08:36,858 --> 00:08:39,159
유지되므로 행렬의 첫 번째 열은 1, 0입니다.

176
00:08:39,600 --> 00:08:42,380
그러나 j-hat은 행렬의 두 번째 

177
00:08:42,380 --> 00:08:45,300
열이 되는 좌표 1, 1로 이동합니다.

178
00:08:45,300 --> 00:08:48,266
여기서 중복될 위험이 있으므로 전단이 주어진 

179
00:08:48,266 --> 00:08:51,113
벡터를 어떻게 변환하는지 알아내는 것은 이 

180
00:08:51,113 --> 00:08:54,080
행렬에 해당 벡터를 곱하는 것으로 귀결됩니다.

181
00:08:55,760 --> 00:08:58,590
행렬에서 시작하여 열 1, 2, 3, 

182
00:08:58,590 --> 00:09:01,285
1로 시작하여 행렬의 변환이 어떻게 

183
00:09:01,285 --> 00:09:04,520
생겼는지 추론하고 싶다고 가정해 보겠습니다.

184
00:09:04,960 --> 00:09:07,440
잠시 멈춰서 상상할 수 있는지 살펴보세요.

185
00:09:08,420 --> 00:09:11,600
이를 수행하는 한 가지 방법은 먼저 i-hat을 1, 

186
00:09:11,600 --> 00:09:13,721
2로 이동한 다음 j-hat을 3, 

187
00:09:13,721 --> 00:09:15,100
1로 이동하는 것입니다.

188
00:09:15,100 --> 00:09:17,294
눈금선이 평행하고 일정한 간격을 

189
00:09:17,294 --> 00:09:20,220
유지하도록 항상 나머지 공간을 이동하십시오.

190
00:09:21,680 --> 00:09:25,559
i-hat과 j-hat이 착지하는 벡터가 선형 

191
00:09:25,559 --> 00:09:29,438
종속적이라면(지난 비디오를 떠올려 보면 하나가 

192
00:09:29,438 --> 00:09:33,616
다른 하나의 크기가 조정된 버전이라는 의미) 이는 

193
00:09:33,616 --> 00:09:37,794
선형 변환이 모든 2D 공간을 두 벡터가 위치하는 

194
00:09:37,794 --> 00:09:41,823
선으로, 두 선형 종속 벡터의 1차원 범위라고도 

195
00:09:41,823 --> 00:09:42,420
합니다.

196
00:09:44,420 --> 00:09:47,684
요약하자면, 선형 변환은 격자선이 평행하고 

197
00:09:47,684 --> 00:09:50,540
균일한 간격을 유지하며 원점이 고정된 

198
00:09:50,540 --> 00:09:53,940
상태로 유지되도록 공간을 이동하는 방법입니다.

199
00:09:54,540 --> 00:09:58,096
다행스럽게도 이러한 변환은 각 기본 벡터가 도달하는 

200
00:09:58,096 --> 00:10:01,530
좌표인 소수의 숫자만 사용하여 설명할 수 있습니다.

201
00:10:02,760 --> 00:10:06,125
행렬은 이러한 변환을 설명하는 언어를 제공합니다. 

202
00:10:06,125 --> 00:10:08,529
여기서 열은 해당 좌표를 나타내며, 

203
00:10:08,529 --> 00:10:11,534
행렬-벡터 곱셈은 해당 변환이 주어진 벡터에 

204
00:10:11,534 --> 00:10:14,660
대해 수행하는 작업을 계산하는 방법일 뿐입니다.

205
00:10:15,360 --> 00:10:18,428
여기서 중요한 점은 행렬을 볼 때마다 이를 

206
00:10:18,428 --> 00:10:21,880
공간의 특정 변형으로 해석할 수 있다는 것입니다.

207
00:10:22,580 --> 00:10:24,903
이 아이디어를 실제로 소화하면 선형 대수학을 

208
00:10:24,903 --> 00:10:27,320
깊이 이해할 수 있는 좋은 위치에 있게 됩니다.

209
00:10:27,660 --> 00:10:30,625
행렬 곱셈부터 행렬식, 기저 변화, 

210
00:10:30,625 --> 00:10:34,777
고유값에 이르기까지 앞으로 나올 거의 모든 주제는 

211
00:10:34,777 --> 00:10:38,928
행렬을 공간 변환으로 생각하기 시작하면 이해하기가 

212
00:10:38,928 --> 00:10:40,560
더 쉬워질 것입니다.

213
00:10:41,300 --> 00:10:43,503
가장 즉시 다음 비디오에서는 두 

214
00:10:43,503 --> 00:10:46,320
행렬을 곱하는 것에 대해 이야기하겠습니다.

