1
00:00:12,040 --> 00:00:12,920
こんにちは、みなさん！

2
00:00:13,320 --> 00:00:15,763
線形代数の他のすべてのトピックがピンとくるトピックを 

3
00:00:15,763 --> 00:00:17,935
1 つだけ選 択しなければならないとしたら、学生

4
00:00:17,935 --> 00:00:19,383
が初めて線形代数を学ぶときにあ 

5
00:00:19,383 --> 00:00:21,555
まりにも頻繁に学習されなくなるトピックは、このト

6
00:00:21,555 --> 00:00:22,280
ピックでしょう。

7
00:00:22,700 --> 00:00:26,200
線形変換の考え方と行列との関係。

8
00:00:26,950 --> 00:00:28,922
このビデオでは、これらの変換が 2 

9
00:00:28,922 --> 00:00:31,114
次元の場合にどのように見えるか、および 

10
00:00:31,114 --> 00:00:33,744
それらが行列ベクトルの乗算の概念にどのように関連

11
00:00:33,744 --> 00:00:35,060
するかに焦点を当てます。

12
00:00:35,880 --> 00:00:39,152
特に、暗記に頼らない行列ベクトルの乗 

13
00:00:39,152 --> 00:00:42,080
算の考え方を紹介したいと思います。

14
00:00:43,160 --> 00:00:46,580
まず、線形変換という用語を解析してみましょう。

15
00:00:47,420 --> 00:00:48,614
トランスフォーメーションとは、本質

16
00:00:48,614 --> 00:00:49,880
的には機能を意味する派手な言葉です。

17
00:00:50,260 --> 00:00:53,980
入力を受け取り、それぞれに対して出力を吐き出すものです。

18
00:00:53,980 --> 00:00:57,530
具体的には、線形代数のコンテキストでは、あるベクトルを取り込

19
00:00:57,530 --> 00:01:01,080
 んで別のベクトルを吐き出す変換について考えるのが好きです。

20
00:01:02,500 --> 00:01:04,390
では、同じ意味であるのに、なぜ関数では

21
00:01:04,390 --> 00:01:06,380
なく変換という言葉を使うのでしょうか? 

22
00:01:07,120 --> 00:01:09,172
そうですね、この入出力関係を視覚化す

23
00:01:09,172 --> 00:01:11,340
るための特定の方法を示唆するためです。

24
00:01:11,860 --> 00:01:13,830
ベクトルの機能を理解するための優れ

25
00:01:13,830 --> 00:01:15,800
た方法は、動きを利用することです。

26
00:01:16,780 --> 00:01:20,959
変換によって入力ベクトルが出力ベクトルに変換される場合、そ 

27
00:01:20,959 --> 00:01:24,860
の入力ベクトルが出力ベクトルに移動することを想像します。

28
00:01:25,680 --> 00:01:28,480
次に、変換を全体として理解するために、考えられる

29
00:01:28,480 --> 00:01:31,280
すべての入力ベクトルが対 応する出力ベクトルに移

30
00:01:31,280 --> 00:01:34,080
動するのを観察することを想像するかもしれません。

31
00:01:34,980 --> 00:01:37,105
すべてのベクトルを一度に、それぞれを 

32
00:01:37,105 --> 00:01:39,120
矢印として考えるのは非常に面倒です。

33
00:01:39,500 --> 00:01:42,100
前回のビデオで述べたように、優れたトリックは

34
00:01:42,100 --> 00:01:44,701
、各ベクトルを矢印では なく単一の点、つまり

35
00:01:44,701 --> 00:01:47,420
その先端が位置する点として概念化することです。

36
00:01:48,030 --> 00:01:50,763
このようにして、考えられるすべての入力ベクトルを何

37
00:01:50,763 --> 00:01:53,497
らかの出力ベクトルに変換す ることを考えるために、

38
00:01:53,497 --> 00:01:56,340
空間内のすべての点が他の点に移動するのを観察します。

39
00:01:57,220 --> 00:02:00,026
2 次元での変換の場合、変換の全体的な形

40
00:02:00,026 --> 00:02:02,833
状をよりよく理解する ために、無限グリッ

41
00:02:02,833 --> 00:02:05,780
ド上のすべての点でこれを行うのが好きです。

42
00:02:06,560 --> 00:02:08,622
また、開始位置に対するすべての終了位置を追跡

43
00:02:08,622 --> 00:02:10,684
しやすくするために、グ リッドのコピーをバッ

44
00:02:10,684 --> 00:02:12,840
クグラウンドに保存しておきたい場合もあります。

45
00:02:14,460 --> 00:02:17,927
空間内のすべての点を移動するさまざまな変換 

46
00:02:17,927 --> 00:02:21,080
の効果は、認められるとおり、美しいです。

47
00:02:21,880 --> 00:02:24,640
空間自体を押しつぶして変形させるような感覚を与えます。

48
00:02:25,600 --> 00:02:27,698
ただし、ご想像のとおり、任意の変換

49
00:02:27,698 --> 00:02:29,920
は非常に複雑に見える場合があります。

50
00:02:30,380 --> 00:02:34,404
しかし幸いなことに、線形代数は、線形変換と呼ばれる、 

51
00:02:34,404 --> 00:02:38,280
より理解しやすい特殊な種類の変換に限定されています。

52
00:02:39,120 --> 00:02:41,033
視覚的に言えば、変換に 2 つのプ

53
00:02:41,033 --> 00:02:43,060
ロパティがある場合、変換は線形です。

54
00:02:43,700 --> 00:02:46,589
すべての線は曲がらずに線のままでなければならず、

55
00:02:46,589 --> 00:02:49,600
原点は所定の位置に固定されていなければなりません。

56
00:02:50,620 --> 00:02:53,209
たとえば、ここでは線がすべて曲線になっ 

57
00:02:53,209 --> 00:02:55,540
ているため、線形変換ではありません。

58
00:02:56,100 --> 00:02:59,038
そして、ここにあるものは、線を真っ直ぐに保ちます 

59
00:02:59,038 --> 00:03:01,860
が、原点を移動するため、線形変換ではありません。

60
00:03:02,680 --> 00:03:04,866
これは原点を固定しており、線がまっすぐに保たれてい

61
00:03:04,866 --> 00:03:07,053
るように見えるかもしれま せんが、それは水平と垂直

62
00:03:07,053 --> 00:03:09,240
のグリッド線だけを表示しているだけであるためです。

63
00:03:09,540 --> 00:03:12,488
対角線がどうなるかを見ると、その線がすべて曲線に 

64
00:03:12,488 --> 00:03:15,320
なるため、まったく直線ではないことがわかります。

65
00:03:16,760 --> 00:03:19,637
一般に、線形変換はグリッド線を平行かつ等 

66
00:03:19,637 --> 00:03:22,240
間隔に保つことと考える必要があります。

67
00:03:23,400 --> 00:03:25,403
原点を中心とした回転など、一部

68
00:03:25,403 --> 00:03:27,540
の線形変換は考えるのが簡単です。

69
00:03:28,120 --> 00:03:30,600
言葉で説明するのが少し難しいものもあります。

70
00:03:32,040 --> 00:03:33,760
では、これらの変化を数値的に説明す

71
00:03:33,760 --> 00:03:35,480
るにはどうすればよいでしょうか? 

72
00:03:35,480 --> 00:03:38,368
たとえば、トピックを教えるビデオを作成するためにアニメー

73
00:03:38,368 --> 00:03:41,256
ションをプログラミ ングしている場合、コンピュータにベク

74
00:03:41,256 --> 00:03:43,320
トルの座標を与えると、そのベクトルが到 

75
00:03:43,320 --> 00:03:46,208
達する位置の座標が得られるように、どのような式をコンピュ

76
00:03:46,208 --> 00:03:47,240
ータに与えますか? 

77
00:03:48,480 --> 00:03:50,593
2 つの基底ベクトル、i-hat と 

78
00:03:50,593 --> 00:03:52,595
j-hat、それぞれの着地がどこに 

79
00:03:52,595 --> 00:03:55,265
あるかを記録するだけでよく、その他すべてはそこか

80
00:03:55,265 --> 00:03:56,600
ら続くことがわかります。

81
00:03:57,500 --> 00:04:00,083
たとえば、座標が負の 1、2 であるベクトル 

82
00:04:00,083 --> 00:04:02,891
v を考えます。これは、負の 1 倍 i-hat 

83
00:04:02,891 --> 00:04:05,700
と 2 倍 j-hat に等しいことを意味します。

84
00:04:08,680 --> 00:04:10,766
何らかの変換を実行して、これら 3 

85
00:04:10,766 --> 00:04:13,547
つのベクトルすべてがどこに行くのかを追跡すると 

86
00:04:13,547 --> 00:04:16,677
、グリッド線が平行かつ等間隔に保たれるという特性が非常

87
00:04:16,677 --> 00:04:18,300
に重要な結果をもたらします。

88
00:04:19,100 --> 00:04:20,698
v が着地する場所は、i-hat 

89
00:04:20,698 --> 00:04:22,861
が着地したベクトルの 1 倍に、 j-hat 

90
00:04:22,861 --> 00:04:25,400
が着地したベクトルの 2 倍を加えた負の値になります。

91
00:04:25,980 --> 00:04:28,846
言い換えれば、それは i-hat と j-hat 

92
00:04:28,846 --> 00:04:31,713
の特定の線形結合として始 まり、最終的にはこれら 

93
00:04:31,713 --> 00:04:34,580
2 つのベクトルが着地した同じ線形結合になります。

94
00:04:35,620 --> 00:04:37,134
これは、i-hat と j-hat 

95
00:04:37,134 --> 00:04:38,900
がそれぞれ着地する場所のみに基づいて v 

96
00:04:38,900 --> 00:04:40,920
がどこに行くべきかを推測できることを意味します。

97
00:04:41,580 --> 00:04:43,060
これが、私が元のグリッドのコピーをバックグ

98
00:04:43,060 --> 00:04:44,540
ラウンドに保持しておくのが好きな理由です。

99
00:04:45,080 --> 00:04:48,023
ここに示す変換では、i-hat が座標 

100
00:04:48,023 --> 00:04:51,408
1、負の 2 に着地し、j -hat が座標 

101
00:04:51,408 --> 00:04:54,940
3、0 の x 軸に着地することが読み取れます。

102
00:04:55,539 --> 00:04:58,133
これは、負の 1 i-hat と j-hat 

103
00:04:58,133 --> 00:05:00,952
の 2 倍で表されるベクトルは、最終的にベクトル 

104
00:05:00,952 --> 00:05:03,659
1 の負の 1 倍、負の 2 プラス ベクトル 

105
00:05:03,659 --> 00:05:06,140
3 の 2 倍、0 になることを意味します。

106
00:05:07,100 --> 00:05:09,161
これらをすべて合計すると、ベクトル 

107
00:05:09,161 --> 00:05:11,680
5、2 に着地する必要があると推測できます。

108
00:05:14,260 --> 00:05:15,750
これは非常に重要なことなので、立ち止

109
00:05:15,750 --> 00:05:17,240
まって熟考するのに良いポイントです。

110
00:05:18,520 --> 00:05:22,030
ここで、実際に完全な変換を示していることを考えると、 

111
00:05:22,030 --> 00:05:25,280
v の座標が 5、2 であることがわかるはずです。

112
00:05:25,760 --> 00:05:28,548
しかし、ここでの素晴らしい点は、i-hat と 

113
00:05:28,548 --> 00:05:31,453
j-hat がそれ ぞれどこに着地するか記録があれ

114
00:05:31,453 --> 00:05:33,661
ば、変換自体を観察する必要がなく、ベ 

115
00:05:33,661 --> 00:05:36,566
クトルがどこに着地するかを推定するテクニックが得ら

116
00:05:36,566 --> 00:05:37,380
れることです。

117
00:05:38,600 --> 00:05:41,505
より一般的な座標 x と y を使用してベクト

118
00:05:41,505 --> 00:05:44,663
ルを記述すると、i-hat が着地するベクトルの 

119
00:05:44,663 --> 00:05:47,315
x 倍、1、負の 2、および j-hat 

120
00:05:47,315 --> 00:05:50,600
が着地するベクトルの y 倍、3、0 に着地します。

121
00:05:51,860 --> 00:05:55,240
この合計を実行すると、1x プラス 3y、マイナス 

122
00:05:55,240 --> 00:05:58,100
2x プラス 0y になることがわかります。

123
00:05:58,740 --> 00:06:01,108
任意のベクトルを与えると、この公式を使用してそ

124
00:06:01,108 --> 00:06:03,580
のベクトルがどこに着地するかを教えてもらえます。

125
00:06:04,860 --> 00:06:06,965
これらすべてが言っているのは、2 

126
00:06:06,965 --> 00:06:09,813
次元の線形変換は、i-hat が着地する 2 

127
00:06:09,813 --> 00:06:12,661
つの座標と j-hat が着地する 2 つの 

128
00:06:12,661 --> 00:06:15,509
座標という 4 つの数値だけで完全に記述できる

129
00:06:15,509 --> 00:06:16,500
ということです。

130
00:06:17,080 --> 00:06:17,640
それはクールじゃないですか？

131
00:06:18,380 --> 00:06:20,919
これらの座標を 2x2 行列と呼ばれる数値の 

132
00:06:20,919 --> 00:06:23,789
2x2 グリッドにパッ ケージ化するのが一般的です。

133
00:06:23,789 --> 00:06:26,217
ここで、列を i-hat と j-ha t 

134
00:06:26,217 --> 00:06:28,977
がそれぞれ着地する 2 つの特別なベクトルとして解

135
00:06:28,977 --> 00:06:29,640
釈できます。

136
00:06:30,380 --> 00:06:34,700
線形変換を記述する 2x2 行列と特定のベクトルが与 

137
00:06:34,700 --> 00:06:39,020
えられ、その線形変換がそのベクトルをどこに取るかを知 

138
00:06:39,020 --> 00:06:43,340
りたい場合は、ベクトルの座標を取得し、それらを行列の 

139
00:06:43,340 --> 00:06:47,340
対応する列で乗算します。得られたものを合計します。

140
00:06:48,180 --> 00:06:50,399
これは、新しい基底ベクトルのスケーリングされ

141
00:06:50,399 --> 00:06:52,720
たバージョンを追加するという考えに対応します。

142
00:06:54,720 --> 00:06:57,746
行列にエントリ A、B、C、D がある最も一般的な 

143
00:06:57,746 --> 00:07:00,540
ケースでこれがどのようになるかを見てみましょう。

144
00:07:01,100 --> 00:07:03,716
この行列は、線形変換を記述するために必要な情報をパッケ 

145
00:07:03,716 --> 00:07:06,240
ージ化する単なる方法であることを覚えておいてください。

146
00:07:06,240 --> 00:07:09,640
最初の列 AC を最初の基底ベクトルが到着する場所として

147
00:07:09,640 --> 00:07:11,825
解釈し、2 番目の列 BD を 2 

148
00:07:11,825 --> 00:07:15,225
番目の基底ベクトルが到着する場所として解釈することを常に

149
00:07:15,225 --> 00:07:16,440
忘れないでください。

150
00:07:17,500 --> 00:07:19,250
この変換をベクトル x、y に適用

151
00:07:19,250 --> 00:07:21,000
すると、何が得られるでしょうか? 

152
00:07:22,060 --> 00:07:26,980
そうですね、AC の x 倍と BD の y 倍になります。

153
00:07:28,060 --> 00:07:30,467
これをまとめると、ベクトル Ax 

154
00:07:30,467 --> 00:07:33,300
と By、Cx と Dy が得られます。

155
00:07:33,980 --> 00:07:37,599
行列を関数のようにベクトルの左側に置くと、これを行 

156
00:07:37,599 --> 00:07:40,940
列とベクトルの乗算として定義することもできます。

157
00:07:41,660 --> 00:07:44,192
そうすれば、直感的に感じられる重要な部分を見せ 

158
00:07:44,192 --> 00:07:46,620
ずに、高校生にこれを暗記させることができます。

159
00:07:48,300 --> 00:07:51,608
しかし、これらの列を基底ベクトルの変換バージョン 

160
00:07:51,608 --> 00:07:54,784
として考え、その結果をそれらのベクトルの適切な 

161
00:07:54,784 --> 00:07:57,960
線形結合として考える方が楽しいと思いませんか? 

162
00:08:00,720 --> 00:08:02,250
行列を使用していくつかの線形変換

163
00:08:02,250 --> 00:08:03,780
を記述する練習をしてみましょう。

164
00:08:04,580 --> 00:08:08,180
たとえば、空間全体を反時計回りに 90 

165
00:08:08,180 --> 00:08:11,780
度回転すると、I ハットは座標 0、1 

166
00:08:11,780 --> 00:08:17,180
に着地し、J ハットは座標のマイナス 1、0 に着地します。

167
00:08:17,980 --> 00:08:20,131
したがって、最終的に得られる行列の列は 

168
00:08:20,131 --> 00:08:21,960
0、1、負の 1、0 になります。

169
00:08:22,880 --> 00:08:26,396
90 度回転したベクトルに何が起こるかを調べる 

170
00:08:26,396 --> 00:08:29,620
には、その座標にこの行列を乗算するだけです。

171
00:08:31,560 --> 00:08:32,929
ここでは、ハサミと呼ばれる特別な名

172
00:08:32,929 --> 00:08:34,299
前が付いた楽しい変身を紹介します。

173
00:08:35,000 --> 00:08:38,389
ここでは、I ハットは固定されたままであるため、行列

174
00:08:38,389 --> 00:08:42,170
の最初の列は 1, 0 で すが、J ハットは座標 1, 

175
00:08:42,170 --> 00:08:45,300
1 に移動し、それが行列の 2 列目になります。

176
00:08:45,300 --> 00:08:48,190
そして、ここで冗長になる危険がありますが、せん断が与え

177
00:08:48,190 --> 00:08:51,081
られたベクトルをどのように変 換するかを理解することは

178
00:08:51,081 --> 00:08:54,080
、結局、この行列とそのベクトルを乗算することになります。

179
00:08:55,760 --> 00:09:00,225
逆に、列 1、2、および 3、1 の行列から始めて 

180
00:09:00,225 --> 00:09:04,520
、その変換がどのようになるかを推定したいとします。

181
00:09:04,960 --> 00:09:07,440
少し立ち止まって、想像できるかどうかを確認してください。

182
00:09:08,420 --> 00:09:12,174
これを行う 1 つの方法は、まず I ハットを 1、2 

183
00:09:12,174 --> 00:09:14,856
に移動し、次に J ハットを 3 、1 

184
00:09:14,856 --> 00:09:18,745
に移動し、常にグリッド線が平行かつ等間隔になるように残りの

185
00:09:18,745 --> 00:09:20,220
スペースを移動します。

186
00:09:21,680 --> 00:09:24,626
I ハットと J ハットが着地するベクトルが線形依存

187
00:09:24,626 --> 00:09:26,893
している場合、これは、前回のビデオを思 

188
00:09:26,893 --> 00:09:29,839
い出していただけると、一方が他方のスケーリングされた

189
00:09:29,839 --> 00:09:32,673
バージョンであることを意味し、線形変換 によって 

190
00:09:32,673 --> 00:09:35,620
2D 空間全体が 2D 空間に押しつぶされることを意

191
00:09:35,620 --> 00:09:38,680
味します。これら 2 つのベ クトルが位置するライン。

192
00:09:38,680 --> 00:09:40,946
これら 2 つの線形依存ベクトルの 1 

193
00:09:40,946 --> 00:09:42,420
次元スパンとも呼ばれます。

194
00:09:44,420 --> 00:09:49,180
要約すると、線形変換は、グリッド線が平行かつ等間隔に保たれ、

195
00:09:49,180 --> 00:09:53,940
 原点が固定されたままになるように空間内を移動する方法です。

196
00:09:54,540 --> 00:09:58,106
これらの変換は、少数の数値、つまり各基底ベクトル 

197
00:09:58,106 --> 00:10:01,530
が着地する座標のみを使用して簡単に記述できます。

198
00:10:02,760 --> 00:10:06,453
行列は、これらの変換を記述するための言語を提供します。

199
00:10:06,453 --> 00:10:10,419
列は それらの座標を表し、行列とベクトルの乗算は、その変換

200
00:10:10,419 --> 00:10:14,386
が特 定のベクトルに対して何を行うかを計算する単なる方法で

201
00:10:14,386 --> 00:10:14,660
す。

202
00:10:15,360 --> 00:10:18,750
ここで重要なのは、マトリックスを見るたびに、それを 

203
00:10:18,750 --> 00:10:21,880
空間の特定の変換として解釈できるということです。

204
00:10:22,580 --> 00:10:25,014
この考え方をしっかり理解すると、線形 

205
00:10:25,014 --> 00:10:27,320
代数を深く理解できるようになります。

206
00:10:27,660 --> 00:10:32,064
行列の乗算から行列式、基底の変更、固有値に至るまで、今 

207
00:10:32,064 --> 00:10:36,469
後出てくるほぼすべてのトピックは、行列を空間の変換とし 

208
00:10:36,469 --> 00:10:40,560
て考え始めると、より簡単に理解できるようになります。

209
00:10:41,300 --> 00:10:43,550
すぐに、次のビデオで 2 つの 

210
00:10:43,550 --> 00:10:45,220
行列の乗算について説明します。

211
00:10:45,220 --> 00:10:45,660
それではまた！

212
00:10:46,120 --> 00:10:46,320
ご清覧ありがとうございました！

