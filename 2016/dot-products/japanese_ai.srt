1
00:00:00,000 --> 00:00:20,800
[ベートーベンの「歓喜の歌」がピアノの最後まで演奏されます。 ]

2
00:00:20,800 --> 00:00:25,120
伝統的に、ドット積は線形代数コースの非常に早い段階で、通常は開始直後に導入されるものです。

3
00:00:25,120 --> 00:00:26,640


4
00:00:26,640 --> 00:00:29,960
したがって、私がシリーズでここまで押し戻したのは奇妙に思われるかもしれません。

5
00:00:30,120 --> 00:00:32,920
私がこのようにしたのは、このトピックを紹介する標準的な方法があり、それにはベクトルの基本的な理解だけが必要ですが、数学において内積が果たす役割をより完全に理解するには、実際には線形変換を考慮する必要があります。

6
00:00:32,920 --> 00:00:36,120


7
00:00:36,120 --> 00:00:39,480


8
00:00:39,480 --> 00:00:42,760


9
00:00:43,320 --> 00:00:47,560
ただし、その前に、点積が導入される標準的な方法について簡単に説明しておきます。これは、多くの視聴者にとって少なくとも部分的には復習されていると思います。

10
00:00:47,560 --> 00:00:50,840


11
00:00:51,240 --> 00:00:54,840
数値的には、同じ次元の 2

12
00:00:54,840 --> 00:00:57,320
つのベクトル、つまり同じ長さの数値の

13
00:00:57,320 --> 00:01:01,000
2

14
00:01:01,640 --> 00:01:04,920
つのリストがある場合、それらの内積を求めることは、すべての座標をペアにし、それらのペアを掛け合わせて、その結果を加算することを意味します。

15
00:01:06,680 --> 00:01:13,080
したがって、3、4 が点在するベクトル 1、2 は、1 掛ける 3 と 2 掛ける 4 になります。

16
00:01:14,520 --> 00:01:21,240
1、8、5、3 が点在するベクトル 6、2、8、3 は、6 掛ける 1 プラス 2 掛ける 8

17
00:01:21,240 --> 00:01:23,640
プラス 8 掛ける 5 プラス 3 掛ける 3 になります。

18
00:01:24,520 --> 00:01:28,840
幸いなことに、この計算には非常に優れた幾何学的解釈が得られます。

19
00:01:28,840 --> 00:01:32,520
2 つのベクトル v と w

20
00:01:32,520 --> 00:01:37,800
の間の内積について考えるには、v の原点と先端を通る直線に w を投影すると想像します。

21
00:01:38,280 --> 00:01:44,360
この投影の長さに v の長さを乗算すると、内積 v dot w が得られます。

22
00:01:46,040 --> 00:01:49,880
この w の射影が

23
00:01:49,880 --> 00:01:52,120
v と反対の方向を向いている場合を除き、その内積は実際には負になります。

24
00:01:53,800 --> 00:01:57,800
したがって、2 つのベクトルが通常同じ方向を向いている場合、それらの内積は正になります。

25
00:01:59,400 --> 00:02:04,040
それらが垂直である場合、つまり一方のもう一方への投影がゼロ

26
00:02:04,040 --> 00:02:05,880
ベクトルである場合、それらの内積はゼロになります。

27
00:02:05,880 --> 00:02:09,560
そして、それらがほぼ逆の方向を向いている場合、それらの内積は負になります。

28
00:02:11,640 --> 00:02:14,680
さて、この解釈は奇妙なことに非対称です。

29
00:02:14,680 --> 00:02:16,760
2 つのベクトルをまったく異なる方法で扱います。

30
00:02:16,760 --> 00:02:19,880
なので、初めてこのことを知ったとき、順番は関係ないことに驚きました。

31
00:02:20,280 --> 00:02:23,000
代わりに、v を w に投影し、投影された

32
00:02:23,000 --> 00:02:27,400
v の長さに w の長さを乗算すると、同じ結果が得られます。

33
00:02:29,400 --> 00:02:32,120
つまり、それはまったく異なるプロセスのように感じませんか?

34
00:02:34,600 --> 00:02:36,840
順序が重要ではない理由についての直感は次のとおりです。

35
00:02:37,640 --> 00:02:41,400
v と w がたまたま同じ長さであれば、対称性を活用することができます。

36
00:02:42,200 --> 00:02:47,560
w を v に投影し、その投影の長さに

37
00:02:48,440 --> 00:02:52,040
v の長さを掛けることは、v を w

38
00:02:52,040 --> 00:02:55,080
に投影し、その投影の長さに w の長さを掛けることの完全な鏡像となるためです。

39
00:02:57,160 --> 00:03:01,080
ここで、そのうちの 1 つ (たとえば

40
00:03:01,080 --> 00:03:04,840
v) を 2 などの定数でスケールして、長さが等しくなるようにすると、対称性が崩れます。

41
00:03:04,840 --> 00:03:07,240
しかし、この新しいベクトル、v の 2

42
00:03:07,240 --> 00:03:09,960
倍と w の間の内積を解釈する方法をよく考えてみましょう。

43
00:03:10,840 --> 00:03:13,480
w を v に投影すると考えると、内積 2v dot w

44
00:03:13,480 --> 00:03:19,720
は内積 v dot w のちょうど 2 倍になります。

45
00:03:20,280 --> 00:03:26,120
これは、v を 2 倍にスケールすると、w

46
00:03:26,120 --> 00:03:29,560
の投影の長さは変わりませんが、投影先のベクトルの長さが 2 倍になるためです。

47
00:03:30,200 --> 00:03:34,120
しかし一方で、v が w に投影されることを考えていたとしましょう。

48
00:03:34,760 --> 00:03:39,960
その場合、v を

49
00:03:39,960 --> 00:03:43,320
2 で乗算すると投影の長さがスケーリングされますが、投影しているベクトルの長さは一定のままです。

50
00:03:43,320 --> 00:03:47,000
したがって、全体的な効果は依然として内積を 2 倍にするだけです。

51
00:03:47,000 --> 00:03:49,400
したがって、この場合は対称性が崩れていますが、このスケーリングが内積の値に与える影響はどちらの解釈でも同じです。

52
00:03:49,400 --> 00:03:52,920


53
00:03:52,920 --> 00:03:54,920


54
00:03:56,760 --> 00:04:00,120
私がこのことを初めて学んだとき、私を混乱させたもう 1 つの大きな疑問があります。

55
00:04:00,760 --> 00:04:04,280
一体なぜ、座標を一致させ、ペアを掛け合わせ、それらを加算するという数値処理が投影と関係があるのでしょうか?

56
00:04:04,280 --> 00:04:08,760


57
00:04:08,760 --> 00:04:16,280
そうですね、満足のいく答えを与えるために、また内積の重要性を完全に正当に評価するには、ここで起こっていることをもう少し深く掘り起こす必要があります。これはしばしば二重性と呼ばれます。

58
00:04:16,280 --> 00:04:19,160


59
00:04:19,160 --> 00:04:21,320


60
00:04:21,880 --> 00:04:26,280
しかし、本題に入る前に、複数の次元から 1 つの次元

61
00:04:26,280 --> 00:04:29,880
(単なる数直線) への線形変換について説明する必要があります。

62
00:04:32,520 --> 00:04:35,960
これらは 2D

63
00:04:35,960 --> 00:04:38,840
ベクトルを受け取り、何らかの数値を吐き出す関数ですが、線形変換は、当然のことながら、2D 入力と

64
00:04:38,840 --> 00:04:42,200
1D 出力を使用するありふれた関数よりもはるかに制限されています。

65
00:04:42,760 --> 00:04:47,080
第

66
00:04:47,080 --> 00:04:50,040
3

67
00:04:50,040 --> 00:04:53,960
章で説明したような高次元での変換と同様、これらの関数を線形にする形式的特性がいくつかありますが、最終目標から逸れないように、ここでは意図的にそれらを無視します。すべての形式的なものと同等の特定の視覚的特性に焦点を当てます。

68
00:04:53,960 --> 00:04:58,040


69
00:04:58,920 --> 00:05:03,320
等間隔のドットの線を取得して変換を適用すると、線形変換により、これらのドットが出力空間

70
00:05:04,280 --> 00:05:08,120
(数直線)

71
00:05:08,120 --> 00:05:11,000
に到達すると、それらのドットは等間隔に保たれます。

72
00:05:12,200 --> 00:05:15,320
それ以外の場合、不均等な間隔の点の線がある場合、変換は線形ではありません。

73
00:05:15,320 --> 00:05:17,080


74
00:05:19,160 --> 00:05:23,000
これまでに見たケースと同様に、これらの線形変換の 1

75
00:05:23,000 --> 00:05:26,760
つは、i-hat と

76
00:05:26,760 --> 00:05:30,440
j-hat

77
00:05:30,440 --> 00:05:34,120
がどこにかかるかによって完全に決定されますが、今回は、これらの基底ベクトルのそれぞれが数値に到達するだけなので、どこにあるかを記録するときそれらは行列の列として配置され、それらの各列には 1

78
00:05:34,120 --> 00:05:36,680
つの数値だけが含まれます。

79
00:05:38,280 --> 00:05:39,720
これは 1x2 の行列です。

80
00:05:41,640 --> 00:05:45,640
これらの変換の 1 つをベクトルに適用することが何を意味するのか、例を見てみましょう。

81
00:05:46,200 --> 00:05:51,560
i-hat を 1 に、j-hat をマイナス 2 にする線形変換があるとします。

82
00:05:52,280 --> 00:05:56,600
たとえば 4, 3 などの座標を持つベクトルがどこに終わるかを追跡するには、このベクトルを i-hat の

83
00:05:56,600 --> 00:06:00,920
4 倍と j-hat の 3 倍として分割することを考えてください。

84
00:06:01,640 --> 00:06:05,160
線形性の結果、変換後のベクトルは、i-hat が着地する場所の 4

85
00:06:05,160 --> 00:06:09,000
倍 1、さらに j-hat

86
00:06:09,000 --> 00:06:12,680
が着地する場所の 3 倍、マイナス

87
00:06:12,680 --> 00:06:15,320
2 になります。これは、この場合、負の位置に着地することを意味します。 2.

88
00:06:17,960 --> 00:06:22,360
この計算を純粋に数値的に行う場合、それは行列ベクトルの乗算になります。

89
00:06:23,240 --> 00:06:30,440
さて、1x2 行列にベクトルを乗算するこの数値演算は、2

90
00:06:30,440 --> 00:06:33,160
つのベクトルの内積を取るのと同じように感じられます。

91
00:06:33,160 --> 00:06:36,760
その 1x2 行列は、単にベクトルを横に傾けたように見えませんか?

92
00:06:37,880 --> 00:06:43,160
実際、今のところ、1x2 行列と

93
00:06:43,160 --> 00:06:47,640
2D ベクトルの間には適切な関連性があると言えます。これは、ベクトルの数値表現を横に傾けて関連する行列を取得するか、行列を傾けて元の位置に戻して関連するベクトルを取得することによって定義されます。

94
00:06:47,640 --> 00:06:52,520
。

95
00:06:53,400 --> 00:06:56,040
今は数値式を見ているだけなので、ベクトルと 1x2

96
00:06:56,040 --> 00:07:00,600
行列の間を行ったり来たりするのは愚かなことのように感じるかもしれません。

97
00:07:01,560 --> 00:07:05,480
しかし、これは幾何学的な観点から見ると本当に素晴らしいことを示唆しています。

98
00:07:05,480 --> 00:07:08,440
ベクトルを数値に変換する線形変換とベクトル自体の間には、ある種のつながりがあります。

99
00:07:08,440 --> 00:07:11,640


100
00:07:12,520 --> 00:07:17,880
重要性を明確にする例を示しますが、これは偶然にも、先ほどの内積パズルの答えにもなります。

101
00:07:17,880 --> 00:07:21,320


102
00:07:21,960 --> 00:07:23,320
これまで学んだことを忘れて、内積が投影に関連していることをまだ知らないと想像してください。

103
00:07:23,320 --> 00:07:27,160


104
00:07:28,920 --> 00:07:33,480
ここでやろうとしていることは、数直線のコピーを取り、それを何らかの形で空間に斜めに配置し、数字の 0

105
00:07:33,480 --> 00:07:39,000
を原点に置くことです。 ここで、数直線上の数字 1 の位置に先端がある

106
00:07:39,000 --> 00:07:44,520
2 次元の単位ベクトルについて考えてみましょう。 あの男に名前を付けたい、ユーハット。

107
00:07:45,560 --> 00:07:48,280
この小さな男はこれから起こることにおいて重要な役割を果たしているので、頭の片隅に置いておいてください。

108
00:07:48,280 --> 00:07:49,960


109
00:07:50,920 --> 00:07:54,840
2D ベクトルをこの対角の数直線上に真っ直ぐ投影すると、事実上、2D

110
00:07:54,840 --> 00:07:58,920
ベクトルを数値に変換する関数を定義したことになります。

111
00:07:59,480 --> 00:08:03,720
さらに、この関数は実際には線形であり、等間隔の点の行が数直線上に到達すると等間隔のままであるという視覚テストに合格するためです。

112
00:08:03,720 --> 00:08:08,840


113
00:08:09,080 --> 00:08:16,280
念のために言っておきますが、このように数直線を 2D 空間に埋め込んだとしても、関数の出力は

114
00:08:16,280 --> 00:08:19,720
2D ベクトルではなく数値です。

115
00:08:19,720 --> 00:08:23,640
2 つの座標を受け取り、1 つの座標を出力する関数を考える必要があります。

116
00:08:24,920 --> 00:08:29,240
しかし、そのベクトル U ハットは入力空間に存在する 2 次元ベクトルです。

117
00:08:29,240 --> 00:08:33,160
数直線の埋め込みと重なるように配置されているだけです。

118
00:08:33,160 --> 00:08:39,960
この投影では、2D ベクトルから数値への線形変換を定義しただけなので、その変換を記述するある種の

119
00:08:39,960 --> 00:08:44,600
1x2 行列を見つけることができるようになります。

120
00:08:45,320 --> 00:08:49,960
1x2 行列を見つけるために、この対角線の数直線設定を拡大して、I

121
00:08:49,960 --> 00:08:53,240
ハットと J

122
00:08:53,240 --> 00:08:56,360
ハットがそれぞれどこに着地するかを考えてみましょう。それらの着地スポットは行列の列になるからです。

123
00:08:58,360 --> 00:09:02,840
この部分は超クールです。 非常にエレガントな対称性の作品によって、それを推論することができます。

124
00:09:02,920 --> 00:09:05,800
I ハットと U ハットはどちらも単位ベクトルであるため、I

125
00:09:05,800 --> 00:09:09,160
ハットを U ハットを通る線上に投影すると、U

126
00:09:09,160 --> 00:09:13,560
ハットを X 軸上に投影するのと完全に対称に見えます。

127
00:09:13,560 --> 00:09:17,240
したがって、I ハットが投影されたときに着地する番号は何なのかと尋ねると、答えは、U ハットが

128
00:09:17,240 --> 00:09:22,680
X 軸に投影されたときに着地するものと同じになります。

129
00:09:22,680 --> 00:09:28,920
ただし、U ハットを X 軸に投影するということは、U ハットの X 座標を取得することを意味します。

130
00:09:28,920 --> 00:09:34,280
したがって、対称性により、I ハットが対角の数直線に投影されたときに着地する数値が U ハットの

131
00:09:34,280 --> 00:09:37,560
x 座標になります。 それはクールじゃないですか？

132
00:09:39,080 --> 00:09:43,000
推論は J-hat 事件でもほぼ同じです。 少し考えてみましょう。

133
00:09:49,240 --> 00:09:52,280
同じ理由で、U ハットの y

134
00:09:52,280 --> 00:09:56,520
座標は、J ハットが数直線のコピーに投影されたときに着地する番号を示します。

135
00:09:57,400 --> 00:10:00,040
立ち止まって、少し考えてみましょう。 それは本当に素晴らしいことだと思います。

136
00:10:00,920 --> 00:10:05,000
したがって、射影変換を記述する 1x2

137
00:10:05,000 --> 00:10:07,160
行列のエントリは、U ハットの座標になります。

138
00:10:07,800 --> 00:10:11,720
そして、空間内の任意のベクトルに対するこの射影変換を計算することは、その行列にそれらのベクトルを乗算する必要があり、計算的には

139
00:10:11,720 --> 00:10:15,080
U

140
00:10:15,080 --> 00:10:18,840
ハットで内積を求めることと同じです。

141
00:10:21,800 --> 00:10:24,760
このため、単位ベクトルとの内積を求めることは、その単位ベクトルのスパンにベクトルを投影し、長さを求めることと解釈できます。

142
00:10:24,840 --> 00:10:30,520


143
00:10:34,120 --> 00:10:36,200
では、単位でないベクトルはどうなるでしょうか?

144
00:10:36,200 --> 00:10:40,600
たとえば、単位ベクトル U ハットを 3 倍に拡大するとします。

145
00:10:41,240 --> 00:10:44,760
数値的には、その各コンポーネントは 3 倍されます。

146
00:10:44,760 --> 00:10:47,880
したがって、そのベクトルに関連付けられた行列を見ると、I ハットと J

147
00:10:47,880 --> 00:10:52,360
ハットは以前に到達した値の 3 倍かかります。

148
00:10:55,400 --> 00:11:00,280
これはすべて線形であるため、より一般的には、新しい行列は任意のベクトルを数直線のコピーに投影し、その到達点で 3

149
00:11:00,280 --> 00:11:04,600
を乗じるものとして解釈できることを意味します。

150
00:11:05,320 --> 00:11:10,360
これが、非単位ベクトルとの内積が、最初にそのベクトルに投影され、次にその投影の長さをベクトルの長さだけスケールアップすると解釈できる理由です。

151
00:11:10,360 --> 00:11:14,920


152
00:11:17,720 --> 00:11:19,800
ここで何が起こったのか少し考えてみましょう。

153
00:11:19,800 --> 00:11:23,000
2D

154
00:11:23,000 --> 00:11:26,920
空間から数直線への線形変換がありましたが、これは数値ベクトルや数値内積によって定義されず、空間を数直線の対角コピーに投影することによって定義されました。

155
00:11:26,920 --> 00:11:30,760


156
00:11:31,400 --> 00:11:37,080
しかし、変換は線形であるため、必然的に何らかの 1x2 行列で記述されます。

157
00:11:37,080 --> 00:11:42,360
そして、1x2 行列に 2D

158
00:11:42,360 --> 00:11:47,880
ベクトルを乗算することは、その行列をひっくり返して内積を求めることと同じであるため、この変換は必然的に何らかの 2D ベクトルに関連することになります。

159
00:11:48,680 --> 00:11:52,600
ここでの教訓は、出力空間が数直線であるこれらの線形変換の 1

160
00:11:52,600 --> 00:11:56,280
つがあるときは常に、それがどのように定義されたかに関係なく、変換を適用するという意味で、その変換に対応する何らかの一意のベクトル

161
00:11:56,280 --> 00:12:00,440
v

162
00:12:00,440 --> 00:12:05,400
が存在することになるということです。そのベクトルの内積を取るのと同じことです。

163
00:12:08,840 --> 00:12:11,160
私にとって、これはまったく美しいことです。

164
00:12:11,800 --> 00:12:14,360
これは数学における双対性と呼ばれるものの一例です。

165
00:12:14,360 --> 00:12:18,040
双対性は数学全体でさまざまな方法や形で現れますが、実際に定義するのは非常に困難です。

166
00:12:18,040 --> 00:12:20,360


167
00:12:20,360 --> 00:12:26,040
大まかに言えば、これは 2

168
00:12:26,040 --> 00:12:28,440
種類の数学的なものの間に自然だが驚くべき対応関係がある状況を指します。

169
00:12:29,000 --> 00:12:31,400
先ほど学んだ線形代数の場合、ベクトルの双対はそれがエンコードする線形変換であり、ある空間から

170
00:12:31,400 --> 00:12:35,880
1

171
00:12:36,760 --> 00:12:40,600
次元への線形変換の双対はその空間内の特定のベクトルであると言えます。

172
00:12:40,600 --> 00:12:43,000


173
00:12:43,240 --> 00:12:47,800
要約すると、表面的には、内積は投影を理解し、ベクトルが同じ方向を向く傾向があるかどうかをテストするための非常に便利な幾何学的ツールです。

174
00:12:47,800 --> 00:12:52,920


175
00:12:52,920 --> 00:12:57,240
そしてそれはおそらく、ドット積について覚えておくべき最も重要なことです。

176
00:12:57,240 --> 00:13:02,120
しかし、より深いレベルでは、2 つのベクトルを点在させることは、そのうちの

177
00:13:02,120 --> 00:13:04,440
1 つを変換の世界に変換する方法です。

178
00:13:04,440 --> 00:13:08,040
繰り返しになりますが、数値的には、これを強調するのは愚かな点のように感じるかもしれません。

179
00:13:08,040 --> 00:13:09,960
それはあまりにも計算的です。

180
00:13:10,040 --> 00:13:13,240
しかし、私がこれが非常に重要であると考える理由は、数学全体を通して、ベクトルを扱うとき、その性質を実際に理解すると、それを空間の矢印としてではなく、ベクトルとして理解する方が簡単であることに気づくことがあるためです。線形変換の物理的な具体化。

181
00:13:13,240 --> 00:13:17,320


182
00:13:17,320 --> 00:13:21,720


183
00:13:21,720 --> 00:13:25,640


184
00:13:25,640 --> 00:13:30,440
空間全体を動かすよりも空間内の矢印について考えるほうが簡単なので、ベクトルが実際には特定の変換の単なる概念的な省略表現であるかのようです。

185
00:13:30,440 --> 00:13:35,640


186
00:13:35,880 --> 00:13:40,440
次のビデオでは、外積について説明しながら、この二重性が実際に動作している別の本当に素晴らしい例をご覧いただけます。

187
00:13:40,440 --> 00:13:42,440


