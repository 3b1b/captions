1
00:00:00,000 --> 00:00:11,240
오늘 저는 다른 숫자 체계로 숫자를 세는 것만으로 하노이 탑 퍼즐을 푸는 깔끔한 방법을 여러분과 공유하고 싶습니다.

2
00:00:11,240 --> 00:00:16,720
그리고 놀랍게도 이 내용은 시에르핀스키의 삼각형을 채우는 곡선을 찾는 것과 관련이 있습니다.

3
00:00:16,720 --> 00:00:24,840
저는 전 CS 강사였던 Keith Schwartz로부터 이에 대해 배웠습니다. 이 사람은 제가 만난 최고의 교육자 중 한 명입니다.

4
00:00:24,840 --> 00:00:42,520
나는 실제로 그가 나에게 이 물건을 보여준 대화를 조금 녹음했습니다. 그래서 여러분은 그가 직접 설명한 내용 중 일부를 들을 수 있습니다.

5
00:00:42,520 --> 00:00:54,440
익숙하지 않은 경우 하노이 타워 퍼즐이 실제로 무엇인지 간단히 설명하겠습니다.

6
00:00:54,440 --> 00:00:59,260
이 디스크는 중앙에 구멍이 있어서 못에 끼울 수 있다고 생각합니다.

7
00:00:59,260 --> 00:01:24,120
여기에 표시된 설정에는 5개의 디스크가 있습니다. 여기에 0, 1, 2, 3, 4라는 라벨을 붙이지만 원칙적으로는 원하는 만큼 디스크를 가질 수 있습니다.

8
00:01:24,120 --> 00:01:33,320
예를 들어, 첫 번째 이동에는 디스크 0을 이동해야 합니다. 왜냐하면 다른 디스크에는 이동하기 전에 방해가 되지 않는 항목이 그 위에 있기 때문입니다.

9
00:01:33,320 --> 00:01:39,239
그 후에는 디스크 1을 이동할 수 있지만 현재 디스크 0이 없는 페그에 이동해야 합니다.

10
00:01:39,239 --> 00:01:45,040
그렇지 않으면 더 작은 디스크에 더 큰 디스크를 배치하게 되므로 이는 허용되지 않습니다.

11
00:01:45,040 --> 00:02:00,320
이전에 이것을 본 적이 없다면 잠시 멈추고 다양한 크기의 책을 꺼내 직접 시험해 보시기를 적극 권장합니다.

12
00:02:00,320 --> 00:02:06,510
이제 Keith는 이 퍼즐에 대해 정말로 놀라운 것을 보여주었습니다. 그것은 이진법으로 숫자를 세고

13
00:02:06,510 --> 00:02:12,480
그 숫자의 리듬을 디스크 움직임의 특정 리듬과 연관시키는 것만으로 문제를 풀 수 있다는 것입니다.

14
00:02:12,480 --> 00:02:17,420
바이너리에 익숙하지 않은 분들을 위해 먼저 여기서 간략한 개요를 살펴보겠습니다.

15
00:02:17,420 --> 00:02:26,560
사실 이진법에 익숙하시더라도 이전에는 생각하지 못했을 수도 있고 생각하지 못했을 수도 있는 계산의 리듬을 중심으로 설명하고 싶습니다.

16
00:02:26,560 --> 00:02:32,291
이진법에 대한 모든 설명은 일반적으로 숫자를 표현하는 일반적인 방법, 즉 10진법이라고 부르는 방식에 대한 성찰로

17
00:02:32,291 --> 00:02:38,560
시작됩니다. 왜냐하면 우리는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9라는 10개의 개별 숫자를 사용하기 때문입니다.

18
00:02:38,560 --> 00:02:45,220
숫자 세기의 리듬은 이 10개의 숫자를 모두 거치면서 시작됩니다.

19
00:02:45,220 --> 00:02:52,320
그런 다음 새 숫자가 부족해지면 다음 숫자인 10을 두 자리 숫자 1, 0으로 표현합니다.

20
00:02:52,320 --> 00:03:02,540
1은 10의 자리에 있다고 했는데, 이는 이미 지금까지 계산한 10개의 그룹을 캡슐화하고 1의 자리를 0으로 재설정할 수 있도록 하기 위한 것이기 때문입니다.

21
00:03:02,540 --> 00:03:13,000
숫자를 세는 리듬은 9를 세고, 10의 자리로, 9를 더 세고, 10의 자리로 넘기는 식으로 반복됩니다.

22
00:03:13,000 --> 00:03:30,040
글쎄요, 이 과정을 9번 반복한 후에는 백 자리로 롤오버합니다. 이 숫자는 100의 그룹 수를 추적하는 숫자이며 나머지 두 자리는 0으로 재설정됩니다.

23
00:03:30,040 --> 00:03:34,060
이런 식으로 계산의 리듬은 일종의 자기 유사성입니다.

24
00:03:34,060 --> 00:03:49,960
더 큰 규모로 축소하더라도 프로세스는 더 큰 롤오버 전에 무언가를 하고, 롤오버하고, 같은 일을 하고, 롤오버하고, 9번 반복하는 것처럼 보입니다.

25
00:03:49,960 --> 00:03:59,700
2진수라고도 알려진 이진법에서는 일반적으로 비트라고 불리는 두 자리 숫자(0과 1)로 제한됩니다. 이는 이진수의 약자입니다.

26
00:03:59,700 --> 00:04:03,960
결과적으로 계산할 때 항상 뒤집어야 합니다.

27
00:04:03,960 --> 00:04:12,304
0, 1을 센 후에는 이미 비트가 부족하므로 2의 자리로 돌아가서 1-0을 쓰고 이를 10으로 읽으려는 10진수

28
00:04:12,304 --> 00:04:20,120
훈련 두뇌의 모든 충동에 저항해야 합니다. 대신 2에 0을 더한 1개의 그룹을 의미하는 것으로 이해하세요.

29
00:04:20,120 --> 00:04:28,815
그런 다음 3을 나타내는 1-1까지 증가하고 이미 다시 롤오버해야 하며, 그 2의 자리에 1이 있기 때문에

30
00:04:28,815 --> 00:04:37,800
그것도 롤오버해야 하므로 1을 나타내는 1-0-0이 됩니다. 4개 더하기 0개의 그룹 2개 더하기 0개의 그룹.

31
00:04:37,800 --> 00:04:46,380
10진수의 숫자가 10의 거듭제곱을 나타내는 것과 마찬가지로, 2진수의 비트는 2의 다양한 거듭제곱을 나타냅니다.

32
00:04:46,380 --> 00:04:55,800
따라서 10의 자리, 100의 자리, 1000의 자리 등을 말하는 대신 2의 자리, 4의 자리, 8의 자리에 대해 이야기합니다.

33
00:04:55,800 --> 00:05:01,080
이제 계산의 리듬이 훨씬 빨라졌지만 거의 눈에 띄게 되었습니다.

34
00:05:01,080 --> 00:05:02,940
마지막을 뒤집고 한 번 뒤집습니다.

35
00:05:02,940 --> 00:05:04,680
마지막을 뒤집고 두 번 뒤집습니다.

36
00:05:04,680 --> 00:05:06,380
마지막을 뒤집고 한 번 뒤집습니다.

37
00:05:06,380 --> 00:05:09,100
마지막을 뒤집고 세 번 뒤집습니다.

38
00:05:09,100 --> 00:05:13,980
다시 말하지만, 이 패턴에는 특정한 자기 유사성이 있습니다.

39
00:05:13,980 --> 00:05:22,480
모든 규모에서 프로세스는 무언가를 수행하고, 롤오버한 다음, 동일한 작업을 다시 수행하는 것입니다.

40
00:05:22,480 --> 00:05:33,320
작은 규모에서 이진수로 1-1인 3까지 세는 것은 마지막 비트를 뒤집고 2의 비트로 롤오버한 다음 마지막 비트를 뒤집는 것을 의미합니다.

41
00:05:33,320 --> 00:05:47,260
1-1-1-1인 15까지 세는 것과 같이 더 큰 규모에서 프로세스는 마지막 3을 7까지 세고 8의 자리로 롤오버한 다음 마지막 3비트를 다시 세는 것입니다.

42
00:05:47,260 --> 00:06:01,080
8개의 연속된 1인 255까지 계산하면 마지막 7비트가 가득 찰 때까지 계산하고 128의 자리로 롤오버한 다음 마지막 7비트를 다시 계산하는 것처럼 보입니다.

43
00:06:01,080 --> 00:06:10,440
자, 그 짧은 소개를 통해 Keith가 나에게 보여준 놀라운 사실은 우리가 이 리듬을 사용하여 하노이의 탑을 해결할 수 있다는 것입니다.

44
00:06:10,440 --> 00:06:12,720
0부터 세기 시작합니다.

45
00:06:12,720 --> 00:06:22,420
마지막 비트만 0에서 1로 뒤집을 때마다 디스크 0을 오른쪽으로 한 페그 이동합니다.

46
00:06:22,420 --> 00:06:29,200
이미 가장 오른쪽 말뚝에 있었다면 첫 번째 말뚝에 다시 고리를 걸면 됩니다.

47
00:06:29,200 --> 00:06:37,740
두 자리로 한 번 롤오버하면, 즉 마지막 두 비트를 뒤집으면 디스크 1이 이동됩니다.

48
00:06:37,740 --> 00:06:39,740
그것을 어디로 옮기느냐고 물어볼 수도 있습니다.

49
00:06:39,740 --> 00:06:47,100
선택의 여지가 없고 디스크 0 위에 놓을 수 없으며 다른 페그가 하나뿐이므로 강제로 이동해야 하는 위치로 이동합니다.

50
00:06:47,100 --> 00:06:52,900
그런 다음 1-1까지 계산하면 마지막 비트만 뒤집어서 디스크 0을 다시 이동합니다.

51
00:06:52,900 --> 00:07:01,440
그런 다음 이진수 계산이 4의 자리로 두 번 롤오버되면 디스크 2를 이동하면 패턴이 이와 같이 계속됩니다.

52
00:07:01,440 --> 00:07:03,460
마지막을 뒤집고 디스크 0을 이동합니다.

53
00:07:03,460 --> 00:07:05,900
마지막 두 개를 뒤집고 디스크 1을 이동합니다.

54
00:07:05,900 --> 00:07:08,080
마지막을 뒤집고 디스크 0을 이동합니다.

55
00:07:08,080 --> 00:07:14,100
그리고 여기서 우리는 8의 자리까지 세 번 롤오버해야 하며 이는 디스크 3의 이동에 해당합니다.

56
00:07:14,100 --> 00:07:19,180
뭔가 마법같은 느낌이 있어요. 처음 봤을 때 이건 안 되겠다는 생각이 들었어요.

57
00:07:19,180 --> 00:07:27,868
이것이 어떻게 작동하는지, 왜 작동하는지 모르겠습니다. 이제 알지만, 보면 정말 마법같습니다. 제가 이것을 가르칠 때 애니메이션을 함께 만든 기억이 나네요.

58
00:07:27,868 --> 00:07:36,260
알다시피, 나는 이것이 어떻게 작동하는지 알고, 그 안에 있는 모든 것을 알고 있습니다. 그냥 앉아서 진행되는 것을 지켜보는 것은 여전히 재미 있습니다.

59
00:07:36,260 --> 00:07:37,260
오 예.

60
00:07:37,260 --> 00:07:41,800
내 말은, 이것이 항상 법적 조치를 취할 것인지가 처음에는 명확하지 않다는 것입니다.

61
00:07:41,800 --> 00:07:49,820
예를 들어, 8의 자리로 롤오버할 때마다 해당 디스크 3이 반드시 이동을 위해 비워질 것이라는 것을 어떻게 알 수 있습니까?

62
00:07:49,820 --> 00:08:00,560
동시에 솔루션은 다음과 같은 질문을 즉시 제기합니다. 이것이 어디서 왔는지, 왜 작동하는지, 2의 n-1 단계를 수행하는 것보다 더 나은 방법이 있습니까?

63
00:08:00,560 --> 00:08:07,180
이는 하노이 타워를 해결할 뿐만 아니라 가능한 가장 효율적인 방법으로 해결된다는 것이 밝혀졌습니다.

64
00:08:07,180 --> 00:08:11,940
이것이 왜 작동하는지, 어떻게 작동하는지, 도대체 무슨 일이 일어나고 있는지 이해하는

65
00:08:11,940 --> 00:08:16,900
것은 CS 담당자가 재귀적 관점이라고 부를 수 있는 퍼즐에 대한 특정 관점으로 귀결됩니다.

66
00:08:16,900 --> 00:08:20,917
디스크 3은 2, 1, 0을 생각하고 있습니다. 마치 당신이 나에게서 떨어져야 하는

67
00:08:20,917 --> 00:08:25,020
것처럼, 이 정도의 무게와 압력으로 인해 제가 실제로 기능할 수 없는 것처럼 말입니다.

68
00:08:25,020 --> 00:08:29,653
따라서 디스크 3의 관점에서 볼 때 디스크 3이 어떻게 여기에 도달하는지 알고 싶다면

69
00:08:29,653 --> 00:08:33,900
디스크 2, 1, 0이 스핀들 B에 어떻게 도달해야 하는지는 상관하지 않습니다.

70
00:08:33,900 --> 00:08:36,020
그래야만 움직일 수 있습니다.

71
00:08:36,020 --> 00:08:38,060
이 디스크 중 하나라도 3개 위에 있으면 이동할 수 없습니다.

72
00:08:38,060 --> 00:08:41,000
이들 중 하나라도 스핀들 C에 있으면 그곳으로 이동할 수 없습니다.

73
00:08:41,000 --> 00:08:43,980
그래서 어떻게든 우리는 2, 1, 0을 빼내야 합니다.

74
00:08:43,980 --> 00:08:48,180
그런 다음 디스크 3을 저기로 이동할 수 있습니다.

75
00:08:48,180 --> 00:08:50,020
그리고 디스크 3에서는 &#39;설정되었습니다&#39;라고 말합니다.

76
00:08:50,020 --> 00:08:51,940
다시는 나를 움직일 필요가 없습니다.

77
00:08:51,940 --> 00:08:54,340
다른 사람들은 여기까지 가는 방법만 알아내면 됩니다.

78
00:08:54,340 --> 00:08:57,540
그리고 어떤 의미에서는 이제 동일한 문제의 더 작은 버전이 있습니다.

79
00:08:57,540 --> 00:09:01,981
이제 디스크 0, 1, 2가 스핀들 B에 있으므로 이를 C로 가져와야 합니다.

80
00:09:01,981 --> 00:09:06,330
그래서 아이디어는 하나의 디스크에만 집중하고 이 디스크가 작동하도록 하려면 무엇을

81
00:09:06,330 --> 00:09:10,680
해야 하는지 생각하면 더 큰 문제를 약간 더 작은 문제로 바꿀 수 있다는 것입니다.

82
00:09:10,680 --> 00:09:12,020
그러면 어떻게 해결하나요?

83
00:09:12,020 --> 00:09:13,600
글쎄, 그것은 똑같은 것입니다.

84
00:09:13,600 --> 00:09:17,160
디스크 2가 디스크 1과 디스크 0이라고 말하면 그것은 당신이 아니라 나입니다.

85
00:09:17,160 --> 00:09:18,160
단지 공간이 좀 필요할 뿐이에요.

86
00:09:18,160 --> 00:09:19,160
내리세요.

87
00:09:19,160 --> 00:09:20,520
그들은 어딘가로 이동해야 합니다.

88
00:09:20,520 --> 00:09:23,040
그러면 디스크 2가 필요한 곳으로 이동할 수 있습니다.

89
00:09:23,040 --> 00:09:25,120
그러면 디스크 1과 0이 이 작업을 수행할 수 있습니다.

90
00:09:25,120 --> 00:09:31,040
그러나 흥미로운 점은 모든 단일 디스크가 거의 동일한 전략을 가지고 있다는 것입니다.

91
00:09:31,040 --> 00:09:33,220
다들 나보다 위에 있는 사람들은 내리라고 하더군요.

92
00:09:33,220 --> 00:09:34,220
그럼 나는 움직일 것이다.

93
00:09:34,220 --> 00:09:36,560
좋아, 모두 다시 모여라.

94
00:09:36,560 --> 00:09:43,926
그러한 통찰력을 알면 하노이의 탑을 해결할 수 있는 코드를 작성할 수 있습니다. 예를

95
00:09:43,926 --> 00:09:50,680
들어 5~6줄의 코드처럼 코드 줄에 대한 지적 투자 비율이 가장 높을 것입니다.

96
00:09:50,680 --> 00:09:56,800
그리고 조금만 생각해 보면 이것이 가장 효율적인 솔루션임이 분명해집니다.

97
00:09:56,800 --> 00:10:00,060
모든 단계에서 당신은 당신에게 강요된 일을 하고 있을 뿐입니다.

98
00:10:00,060 --> 00:10:04,440
디스크 3을 이동하려면 먼저 디스크 0부터 2까지를 꺼야 합니다.

99
00:10:04,440 --> 00:10:06,520
그리고 디스크 3을 옮겨야 합니다.

100
00:10:06,520 --> 00:10:09,760
그런 다음 디스크 0부터 2까지 다시 디스크로 옮겨야 합니다.

101
00:10:09,760 --> 00:10:15,400
이러한 관점에서는 비효율적일 여지가 전혀 없습니다.

102
00:10:15,400 --> 00:10:18,920
그렇다면 이진수 계산이 이 알고리즘을 포착하는 이유는 무엇입니까?

103
00:10:18,920 --> 00:10:30,160
음, 여기서 일어나는 일은 하위 문제를 해결하고 큰 디스크를 이동한 다음 다시 하위 문제를 해결하는 패턴이 이진수 계산 패턴과 완벽하게 유사하다는 것입니다.

104
00:10:30,160 --> 00:10:35,360
일정 금액을 세고, 뒤집어서 같은 금액까지 다시 세어보세요.

105
00:10:35,360 --> 00:10:42,140
그리고 이 하노이 타워 알고리즘과 이진수 계산은 둘 다 자체 유사 프로세스입니다. 즉, 축소하여 더 큰 2의

106
00:10:42,140 --> 00:10:48,920
거듭제곱으로 계산하거나 더 많은 디스크로 하노이 타워를 풀면 둘 다 여전히 동일한 구조를 갖는다는 의미입니다.

107
00:10:48,920 --> 00:10:52,700
하위 문제, 어떤 일을 하세요, 하위 문제.

108
00:10:52,700 --> 00:10:58,210
예를 들어, 꽤 작은 규모에서 하노이 타워를 두 개의 디스크로 해결하면 디스크 0

109
00:10:58,210 --> 00:11:03,840
이동, 디스크 1 이동, 디스크 0 이동은 이진수로 최대 3까지 계산하여 반영됩니다.

110
00:11:03,840 --> 00:11:07,560
마지막 비트를 뒤집고 한 번 뒤집은 다음 마지막 비트를 뒤집습니다.

111
00:11:07,560 --> 00:11:13,155
약간 더 큰 규모에서 디스크 3개로 하노이 타워를 해결하는 것은 디스크 2개를 풀고 디스크

112
00:11:13,155 --> 00:11:19,080
2번을 이동한 다음 다시 디스크 2개를 해결하는 데 필요한 모든 작업을 수행하는 것처럼 보입니다.

113
00:11:19,080 --> 00:11:28,000
마찬가지로, 이진수로 최대 111을 세는 것은 최대 3을 세고 세 비트를 모두 롤오버한 다음 세 개를 더 세는 것을 포함합니다.

114
00:11:28,000 --> 00:11:32,100
모든 규모에서 두 프로세스 모두 이와 동일한 분석을 갖습니다.

115
00:11:32,100 --> 00:11:41,795
따라서 어떤 의미에서 이 이진법이 작동하는 이유 또는 적어도 설명은 설명이 없는 것 같지만 가장 자연스러운 것은 이러한 이진수를 생성하는 데

116
00:11:41,795 --> 00:11:51,860
사용하는 패턴이 정확히 동일하다는 것입니다. 구조는 하노이 타워에 사용할 패턴이므로 비트 뒤집기를 보면 이 프로세스가 효과적으로 역전되는 것입니다.

117
00:11:51,860 --> 00:11:54,200
어떤 프로세스에서 이러한 현상이 발생했다는 말씀이신가요?

118
00:11:54,200 --> 00:12:00,827
마치 제가 이 비트를 뒤집어서 이것을 제공하는 방법을 이해하려고 노력하는 것처럼 하노이

119
00:12:00,827 --> 00:12:07,860
타워에 대한 재귀 알고리즘을 효과적으로 역전시키는 것입니다. 이것이 바로 작동하는 이유입니다.

120
00:12:07,860 --> 00:12:09,620
정말 멋지죠?

121
00:12:09,620 --> 00:12:10,940
하지만 실제로는 더 시원해집니다.

122
00:12:10,940 --> 00:12:14,460
나는 이것이 시에르핀스키의 삼각형과 어떤 관련이 있는지조차 알지 못했습니다.

123
00:12:14,460 --> 00:12:19,140
이것이 바로 제가 후속 비디오 파트 2에서 하려고 하는 작업입니다.

124
00:12:19,140 --> 00:12:22,620
Patreon에서 이 동영상을 후원해 주시는 모든 분들께 진심으로 감사드립니다.

125
00:12:22,620 --> 00:12:28,700
방금 Essence of Calculus의 첫 번째 장을 마쳤고 지금 두 번째 장을 작업 중입니다. 몇

126
00:12:28,700 --> 00:12:34,780
달 후에 전체 시리즈를 게시하기 전에 Patreon 지지자들이 이 동영상을 먼저 접할 수 있을 것입니다.

127
00:12:34,780 --> 00:12:39,730
이 영상과 다음 영상도 부분적으로 Desmos의 지원을 받고 있습니다. 다음 영상을 보기

128
00:12:39,730 --> 00:12:44,780
전에 잠시 시간을 내어 Desmos가 누구인지, 채용 중인지에 대해 조금 공유하고 싶습니다.

129
00:12:44,780 --> 00:12:47,020
그래서 Desmos는 실제로 정말 멋집니다.

130
00:12:47,020 --> 00:12:51,680
그들은 교실을 위한 대화형 수학 활동과 교사를 위한 도구를 많이 만듭니다.

131
00:12:51,680 --> 00:12:56,060
그들이 제공하는 것의 진정한 핵심은 교실 활동에 있습니다.

132
00:12:56,060 --> 00:13:02,540
저는 이러한 활동이 교육학적 관점에서 얼마나 세심하게 계획되어 있는지에 깊은 인상을 받았습니다.

133
00:13:02,540 --> 00:13:08,180
팀은 자신의 업무를 명확하게 알고 있으며 학생과 교사의 삶에 변화를 가져올 수 있는 위치를 알고 있습니다.

134
00:13:08,180 --> 00:13:10,140
그리고 내가 말했듯이, 그들은 채용 중입니다.

135
00:13:10,140 --> 00:13:19,600
그들은 엔지니어링 인재, 디자이너, 교사 또는 자신이 원하는 일과 일치하는 기타 기술 세트 등 더 좋은 인재를 영입하기 위해 항상 노력하고 있습니다.

136
00:13:19,600 --> 00:13:27,720
여러분 중 누군가가 여기에 참여하여 교사와 학생을 위한 훌륭한 도구를 만드는 데 도움을 주고 싶다면 설명에 링크된 채용 페이지를 확인하세요.

137
00:13:27,720 --> 00:13:30,480
개인적으로는 정말 의미있는 일을 하고 있다고 생각합니다.

138
00:13:30,480 --> 00:13:35,413
나는 그들의 활동이 학생들을 위한 진정으로 좋은 수학 직관을 구축하고 있다고 생각하며, 세상은 그들이

139
00:13:35,413 --> 00:13:40,520
하는 방식으로 교육을 향한 노력을 가리키는 몇몇 재능 있는 사람들을 더 많이 사용할 수 있다고 생각합니다.

140
00:13:40,520 --> 00:13:44,640
좋아요, 그럼 다음 영상에서 뵙겠습니다. 여러분은 이 내용이 정말 마음에 드실 거라고 생각합니다.

