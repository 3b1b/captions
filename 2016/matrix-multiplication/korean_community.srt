1
00:00:10,920 --> 00:00:11,960
안녕하세요 여러분?

2
00:00:11,960 --> 00:00:14,920
지난 시간에는 선형변환이 어떤 것인지 설명해드렸고

3
00:00:14,920 --> 00:00:17,900
선형변환을 행렬을 이용해 표현하는 방법도 소개해드렸습니다.

4
00:00:18,260 --> 00:00:21,320
지난 번에 다룬 내용을 다시 요약해드리겠습니다. 왜냐하면 이건 정말 중요한 것이거든요.

5
00:00:21,320 --> 00:00:25,640
물론,  요약만으로 부족하다고 느낀다면 다시 이전 동영상 전체를 시청하는 것도 좋은 방법입니다.

6
00:00:25,760 --> 00:00:30,140
기술적으로 말하자면,  선형변환은 한마디로 함수입니다. 벡터를 집어넣으면[벡터가 정의역]

7
00:00:30,140 --> 00:00:31,620
벡터가 나오는 것이지요.[벡터가 치역]

8
00:00:31,620 --> 00:00:34,060
지난번에 제가 이것을 시각적으로 보여드렸습니다. 어떻게  선형변환을 생각할 수 있는 지를요.

9
00:00:34,060 --> 00:00:39,100
공간을 이리저리 비틀면서 말이죠.
물론 격자선들은 여전히 평행하고 균등간격을 유지한 채로요.

10
00:00:39,100 --> 00:00:41,560
그리고 원점은 고정되어 있습니다.

11
00:00:41,560 --> 00:00:43,040
여기서 중요한 점은,

12
00:00:43,040 --> 00:00:48,600
기저벡터가 선형변환에 의해 어떻게 옮겨졌는지를 알면, 그 선형 변환이 무엇인지 파악할 수 있다는 것입니다.

13
00:00:48,600 --> 00:00:52,040
예를 들어, 2차원 공간에서는 i-hat 벡터와 j-hat 벡터로요.

14
00:00:52,040 --> 00:00:57,500
왜냐하면 모든 벡터들은 이 i-hat 벡터와 j-hat 벡터의 선형 결합으로 모두 표현이 가능하기 때문이죠.

15
00:00:57,660 --> 00:00:59,800
좌표값이 (x,y) 인 벡터는

16
00:00:59,800 --> 00:01:03,040
i-hat 벡터의 x 배 + j-hat 벡터의 y 배로 표현됩니다.

17
00:01:03,280 --> 00:01:05,280
선형변환을 하고 나서도,

18
00:01:05,280 --> 00:01:08,720
격자선들이 여전히 평행을 유지하고 균등간격을 유지한다는

19
00:01:08,720 --> 00:01:10,540
멋진 결론을 얻었죠.

20
00:01:10,540 --> 00:01:18,120
변환된 벡터는 변환된 i-hat 의 x배 + 변환된 j-hat 의 y 배로 표현된다는 것도요.

21
00:01:18,120 --> 00:01:21,880
이 말의 뜻은 만약 우리가 변환된 i-hat 의 좌표값과

22
00:01:21,880 --> 00:01:24,080
변환된 j-hat의 좌표값을 안다면,

23
00:01:24,080 --> 00:01:27,140
초기값 (x, y) 에서 시작한 벡터가 변환
 후 어디로 갈지 계산해낼 수 있다는 것입니다.

24
00:01:27,140 --> 00:01:30,440
바로 변환된 i-hat 좌표값의 x 배와

25
00:01:30,440 --> 00:01:33,040
변환된 j-hat 좌표값의 y 배를 이용해서 말이죠.

26
00:01:33,560 --> 00:01:37,240
관례적으로 i-hat 과 j-hat 의 변형후 좌표값을

27
00:01:37,240 --> 00:01:39,360
행렬로 표현합니다.

28
00:01:39,360 --> 00:01:43,420
그리고 이 열들(벡터) 각각을 x, y로 스케일링한 것을

29
00:01:43,420 --> 00:01:45,960
행렬-벡터 곱셈으로 정의합니다.

30
00:01:45,960 --> 00:01:47,140
이 방법으로 보면,

31
00:01:47,140 --> 00:01:50,000
한 행렬은 하나의 선형변환을 나타냅니다.

32
00:01:50,000 --> 00:01:58,400
그리고 벡터에 행렬을 곱하는 것은 수식적으로 그 벡터를 선형변환하는 것과 같습니다.

33
00:01:58,620 --> 00:02:01,420
됐습니다. 요약 끝. 새 주제로 넘어갑시다.

34
00:02:01,420 --> 00:02:07,500
아마도 선형변환을 하고 나서 거기에 다시 선형변환을 하는 것도 설명하고 싶어하는 사람도 있을 것입니다.

35
00:02:07,600 --> 00:02:08,540
예를 들면,

36
00:02:08,540 --> 00:02:13,160
시계방향으로 90도 회전시키고,

37
00:02:13,160 --> 00:02:15,160
그리고 나서 옆으로 밀면(shearing) 어떻게 되는 지를요.

38
00:02:15,160 --> 00:02:17,680
전체 효과는

39
00:02:17,680 --> 00:02:19,800
또 다른 하나의 선형변환이라는 것입니다.

40
00:02:19,800 --> 00:02:22,300
회전과 밂과는 구별되는 무언가라는 것이죠.

41
00:02:22,300 --> 00:02:28,860
이렇게 새로 생겨난 선형변환을 흔히 두 개의 선형변환의 합성이라고 일컫습니다.

42
00:02:28,860 --> 00:02:30,700
다른 선형변환과 마찬가지로,

43
00:02:30,700 --> 00:02:36,180
이 선형변환도 행렬로 표현이 가능합니다. 
위와 같이 i-hat, j-hat을 이용해서요.

44
00:02:36,180 --> 00:02:39,260
여기서 i-hat 의 최종도착지는

45
00:02:39,260 --> 00:02:42,280
(1,1)입니다.

46
00:02:42,280 --> 00:02:44,820
그럼 이것을 행렬의 첫번째 열로 적으면 됩니다.

47
00:02:44,820 --> 00:02:49,580
마찬가지로, j-hat 의 최종도착지는 (-1, 0)입니다.

48
00:02:49,580 --> 00:02:52,520
그럼 이걸 행렬의 두번째 열로 적으면 됩니다.

49
00:02:52,520 --> 00:02:58,100
이 새 행렬이 바로 회전하고 미는 변환의 최종 효과을 나타냅니다.

50
00:02:58,100 --> 00:03:03,140
하지만 연속되는 변환이 아니라, 
단지 하나의 변환으로서만 표현하고 있죠.

51
00:03:03,260 --> 00:03:05,300
새 행렬을 생각해보는 방법이 있습니다.

52
00:03:05,300 --> 00:03:09,600
어떤 벡터를 가져다가 회전시키고 미는 변환을 시키면,

53
00:03:09,600 --> 00:03:11,600
결과가 무엇인기 계산해야되는 이 긴 과정은 다음과 같습니다.

54
00:03:11,600 --> 00:03:15,400
우선 회전을 나타내는 행렬에 벡터를 곱합니다.

55
00:03:15,400 --> 00:03:20,200
그리고 그 결과를 미는 것을 나타내는 행렬 오른쪽에다 놓고 곱하면

56
00:03:20,200 --> 00:03:26,100
이것이 수치적으로 표현된,  어떤 벡터에다가 회전 시키고 민 것을 적용한 뒤의 결과입니다.

57
00:03:26,700 --> 00:03:32,900
하지만 우리가 방금 구한 행렬을 곱해도  같은 결과값을 얻습니다.

58
00:03:32,900 --> 00:03:34,800
어떤 벡터를 고르던지 말이죠.

59
00:03:34,800 --> 00:03:42,340
우리가 구한 새 행렬은 회전하고 미는 것과 같은 효과를 나타내기 때문입니다.

60
00:03:42,340 --> 00:03:44,300
지금까지 설명한 것들을 기반으로 해서,

61
00:03:44,300 --> 00:03:48,840
이 새 행렬을, 두 원본 행렬의 곱(product)이라고 불러도 될 것 같습니다.

62
00:03:48,840 --> 00:03:50,400
그렇지 않나요?

63
00:03:50,400 --> 00:03:53,960
그럼 잠시,  행렬의 곱을 좀 더 일반적으로 계산하는 방법에 대해 생각해보겠습니다.

64
00:03:53,960 --> 00:03:56,980
근데 숫자들 사이에서 헤매기 쉬우므로
조심하십시오.

65
00:03:56,980 --> 00:04:00,220
항상 여러분들이 기억해야 할 것은, 두 행렬의 곱셈은

66
00:04:00,220 --> 00:04:06,100
기하학적으로 한 변환을 적용하고나서 다른 변환을 적용한 것과 같다는 것입니다.

67
00:04:06,100 --> 00:04:10,040
근데 이상한 점이 있는데, 
읽을 때 오른쪽에서 왼쪽방향으로 봐야합니다.

68
00:04:10,040 --> 00:04:13,600
우측의 행렬이 첫번째 변환을 의미하고,

69
00:04:13,600 --> 00:04:17,220
좌측의 행렬로 그 다음 변환 적용을 나타내죠.

70
00:04:17,220 --> 00:04:19,500
이것은 함수 표기법에서 유래한 것입니다.

71
00:04:19,500 --> 00:04:21,660
함수를 변수의 왼쪽에다 적기 때문이죠.

72
00:04:21,660 --> 00:04:25,900
그래서 두 함수를 합성할 때마다, 
오른쪽에서 왼쪽으로 읽어야 합니다.

73
00:04:25,900 --> 00:04:29,680
히브리어 독자들에게 좋은 소식일 테지만, 우리에게는 나쁜 소식입니다.

74
00:04:29,680 --> 00:04:31,620
다른 예를 살펴 보죠.

75
00:04:31,620 --> 00:04:35,360
행렬 (1, 1), (-2, 0) 이 있을때,

76
00:04:35,360 --> 00:04:37,860
이 변환은 이렇게 보일텐데,

77
00:04:37,860 --> 00:04:39,860
이 변환을 M1 이라고 합시다.

78
00:04:39,860 --> 00:04:43,920
그 다음 행렬 (0, 1), (2, 0) 을  있을때,

79
00:04:43,920 --> 00:04:47,520
이 변환은 이렇게 보일텐데,

80
00:04:47,520 --> 00:04:49,740
이번엔 M2 라고 합시다.

81
00:04:49,740 --> 00:04:52,900
M1을 적용하고 나서 M2를 적용한 결과는

82
00:04:52,900 --> 00:04:54,640
우리에게 새로운 변환을 나타내죠.

83
00:04:54,640 --> 00:04:56,120
자, 이 행렬을 찾아봅시다.

84
00:04:56,120 --> 00:05:00,140
하지만 이번엔, 애니메이션을 보지 않고 찾아내봅시다.

85
00:05:00,140 --> 00:05:04,460
대신에 각 행렬을 나타내는 수치만 가지고 찾아내봅시다.

86
00:05:04,460 --> 00:05:07,860
우선 i-hat 벡터가 어떻게 되는지 부터 봅시다.

87
00:05:07,860 --> 00:05:11,000
M1 변환 적용 후 나타나는 새로운 i-hat 좌표는

88
00:05:11,000 --> 00:05:14,780
정의에 의해, M1의 첫 번째 열에 나타나죠.

89
00:05:14,780 --> 00:05:16,640
즉, (1, 1)

90
00:05:16,640 --> 00:05:19,400
M2를 적용한 후를 살펴보려면,

91
00:05:19,400 --> 00:05:25,180
M2 행렬에 이 벡터 (1,1)를 곱하면 됩니다.

92
00:05:25,180 --> 00:05:28,100
지난번에 설명한 방법으로 계산하면,

93
00:05:28,100 --> 00:05:30,500
벡터 (2, 1) 라는 값을 얻을 수 있습니다.

94
00:05:30,500 --> 00:05:34,280
이 벡터가 합성행렬의 첫 번째 열입니다.

95
00:05:34,280 --> 00:05:36,060
마찬가지로,  j-hat 에도 적용해보면,

96
00:05:36,060 --> 00:05:42,660
M1의 두 번째 열이 첫번째 변환 후인 좌표 (-2, 0)가 되고

97
00:05:42,660 --> 00:05:47,800
다음, M2 행렬을 이 벡터에다 곱하면,

98
00:05:47,800 --> 00:05:52,440
행렬-벡터 곱으로 계산해서 (0, -2)이라는 값을 얻을 수 있습니다.

99
00:05:52,440 --> 00:05:56,640
이것이 합성행렬의 두번재 열입니다.

100
00:05:56,640 --> 00:05:59,520
다시 한 번 설명드리겠습니다. 하지만 이번에는

101
00:05:59,520 --> 00:06:01,940
각 행렬 안에 숫자를 변수로 대체해서 보여드리겠습니다.

102
00:06:01,940 --> 00:06:05,420
아까 전과 같이 진행할 것이라서,

103
00:06:05,420 --> 00:06:08,160
기호가 더 많고, 쓸 공간도 더 많이 필요하겠죠.

104
00:06:08,160 --> 00:06:14,320
하지만 이전에 행렬 곱셈을 요령으로 배웠던 사람이라면 꽤 만족할 것입니다.

105
00:06:14,320 --> 00:06:15,960
i-hat 벡터가 어떻게 되는 지부터 봅시다.

106
00:06:15,960 --> 00:06:18,980
오른쪽 행렬의 첫째 열부터 보죠.

107
00:06:18,980 --> 00:06:21,640
이것은 첫번째 변환 후의 i-hat의 위치입니다.

108
00:06:21,640 --> 00:06:24,820
이 열을 왼쪽 행렬에다가 곱하면,

109
00:06:24,820 --> 00:06:31,480
한 번 변환을 거친 i-hat이 최종적으로 어디에 도달하는지 알 수 있습니다.

110
00:06:31,480 --> 00:06:33,940
그래서 합성행렬의 첫번째 열은

111
00:06:33,940 --> 00:06:39,560
항상 왼쪽 행렬과 오른쪽 행렬의 첫째열의 곱셈과 같습니다.

112
00:06:42,040 --> 00:06:48,540
마찬가지로, j-hat 은 오른쪽 행렬의 두번째 열의 값을 거쳐

113
00:06:48,540 --> 00:06:53,820
왼쪽 행렬을 곱하여서 최종 위치가 나옵니다.

114
00:06:53,820 --> 00:06:58,280
따라서,  이 값이 합성 행렬의 두번째 열입니다.

115
00:07:00,400 --> 00:07:02,440
주의할 점은, 기호가 너무 많기 때문에

116
00:07:02,440 --> 00:07:05,240
이것을 기억하기 위해서 어떤 요령으로 많이들 가르치죠.

117
00:07:05,240 --> 00:07:09,060
특정 알고리즘 순서로서 기억하기 쉽게 말이요.

118
00:07:09,060 --> 00:07:12,100
하지만 그렇게 암기하기 전에 꼭,

119
00:07:12,100 --> 00:07:16,640
행렬 곱셈이 무엇을 나타낸는지 생각해보는 습관을 가졌으면 좋겠습니다.

120
00:07:16,640 --> 00:07:19,420
그것은 한 변환을 적용한 후, 다른 변환을 적용한다는 것.

121
00:07:19,420 --> 00:07:26,880
방금 제가 설명드린 것들은 여러분들이  행렬의 곱셈에 대해 더 쉽게 이해할 수 있도록 어떤 틀을 제공해 줄것입니다.

122
00:07:26,880 --> 00:07:28,720
예를들어, 다음과 같은 질문이 있습니다.

123
00:07:28,720 --> 00:07:33,760
우리가 두 행렬을 곱할 때 그 두 행렬을 곱하는 순서가 상관있을까요?

124
00:07:33,760 --> 00:07:35,920
간단한 예제를 통해 알아봅시다.

125
00:07:35,920 --> 00:07:37,500
앞에서 했었던 방법으로 말이죠.

126
00:07:37,500 --> 00:07:41,808
i-hat 은 고정이고 j-hat 만 오른쪽으로 밀어지는 미는 (shear) 변환과

127
00:07:41,808 --> 00:07:43,400
90 ° 회전 변환을 이용해서요.

128
00:07:43,400 --> 00:07:46,200
만약 먼저 민 후 회전시키면,

129
00:07:46,200 --> 00:07:48,920
i-hat 의 결과는 (0, 1)이고

130
00:07:48,920 --> 00:07:51,140
j-hat 의 결과는 (-1, 1) 가 된다는 것을 알 수 있습니다.

131
00:07:51,140 --> 00:07:53,440
두 벡터가 서로 가까이 위치하고 있네요.

132
00:07:53,440 --> 00:07:56,980
이번엔 먼저 회전을 하고 나서 밀면,

133
00:07:57,700 --> 00:07:59,940
i-hat 은 (1, 1)

134
00:07:59,940 --> 00:08:03,600
j-hat 은 (-1, 0) 위치가 된다는 것을 알 수 있습니다.

135
00:08:03,600 --> 00:08:06,100
이 둘은 보시다시피 서로 멀리 떨어져 있네요.

136
00:08:06,100 --> 00:08:11,940
곱하는 순서에 따라 결과가 달라지기 때문에 결론은 곱하는 순서가 중요합니다.

137
00:08:11,940 --> 00:08:14,640
주목할 점은 변환에 대해서 떠올릴 때

138
00:08:14,640 --> 00:08:18,040
변환은 시각화함으로써 머릿속으로 떠올릴 수 있는 것들이라는 것이죠.

139
00:08:18,040 --> 00:08:20,280
행렬 곱셈하는 것 그 자체는 중요하지 않아요.

140
00:08:21,520 --> 00:08:23,880
제가 선형대수학을 처음 접했을 때가 기억나는 데,

141
00:08:23,880 --> 00:08:29,420
행렬 곱셈의 결합법칙(Asoociativity)에 대해 증명하라는 숙제가 있었습니다.

142
00:08:29,420 --> 00:08:32,620
결합법칙은 행렬 A, B, C가 있어서

143
00:08:32,620 --> 00:08:34,380
이것을 모두 곱할 때,

144
00:08:34,380 --> 00:08:39,440
AB 먼저 곱하고 나서 오른쪽에 C를 곱하거나

145
00:08:39,440 --> 00:08:44,760
BC 먼저 곱하고나서 왼쪽에  A를 곱하거나 그 순서는 상관이 없다는 것을 의미합니다.

146
00:08:44,760 --> 00:08:48,100
다시 말해서, 괄호를 어디다 집어넣든 크게 상관이 없다는 거죠

147
00:08:48,100 --> 00:08:52,200
여러분들이 결합법칙을 수치적으로 제가 방금 아까 했던 것처럼 증명하려 한다면

148
00:08:52,240 --> 00:08:56,040
그 방법은 아주 끔찍하고 결합법칙이 무엇인지 깨우치는 데 좋지 못합니다.

149
00:08:56,040 --> 00:09:01,100
하지만 행렬의 곱셈을 한 변환을 적용하고 나서 다시 다른 변환을 적용하는 것이라고 생각한다면,

150
00:09:01,100 --> 00:09:02,795
이 문제는 정말 간단합니다.

151
00:09:02,795 --> 00:09:04,620
왜 그런지 이해가 되나요?

152
00:09:04,620 --> 00:09:09,180
결합법칙이 나타내는 것은 CB, A 순서로 적용하는 것이

153
00:09:09,300 --> 00:09:12,880
C, BA 순서로 적용하는 것과 같다는 겁니다.

154
00:09:12,880 --> 00:09:14,460
더이상 증명할 게 없어요.

155
00:09:14,460 --> 00:09:19,300
그냥 동일한 세 변환을 같은 순서대로 적용하는 것에 불과합니다.

156
00:09:19,300 --> 00:09:21,800
꼼수처럼 느껴질 지도 모르지만 전혀 그렇지 않아요.

157
00:09:21,800 --> 00:09:26,060
이 방법은 행렬 곱셈이 결합법칙이 성립된다는 것을 증명하는 아주 좋은 방법입니다.

158
00:09:26,060 --> 00:09:31,580
게다가 이렇게 하면 왜 결합법칙이 참인지 아주 잘 설명해주죠.

159
00:09:31,580 --> 00:09:34,560
저는 여러분들이 이 아이디어를 잘 활용하시기를 바랍니다.

160
00:09:34,560 --> 00:09:36,780
서로 다른 두 개의 변환을 떠올려서 한 변환을 적용한 후 다른 변환을 적용하는 것과

161
00:09:36,780 --> 00:09:42,560
행렬 곱셈을 수치적으로 하는 것에 대해 한 번 궁구해보십시오.

162
00:09:42,560 --> 00:09:47,100
이렇게 함으로써 행렬 곱셈에 대해 정말로 깊게 이해할 수 있게 될 것입니다.

163
00:09:47,100 --> 00:09:51,860
다음 동영상에서는 이 아이디어를 2차원 이상으로 확장해보겠습니다.

164
00:09:51,860 --> 00:09:53,360
그 때 봅시다!

