1
00:00:00,000 --> 00:00:15,240
皆さん、前回の続きで、線形変換がどのようなものなのか、そして行列を使用して線形変換を表現する方法を説明しました。

2
00:00:15,240 --> 00:00:18,360


3
00:00:18,360 --> 00:00:22,320
これは本当に重要なことなので、簡単に要約する価値がありますが、もちろん、これが単なる要約以上のものだと感じた場合は、戻ってビデオ全体を見てください。

4
00:00:22,320 --> 00:00:26,280


5
00:00:26,280 --> 00:00:30,700
一般的に、線形変換は入力としてベクトル、出力としてベクトルを持つ関数ですが、前回、グリッド線が平行で等間隔に保たれ、原点が固定されたままです。

6
00:00:30,700 --> 00:00:34,760


7
00:00:34,760 --> 00:00:39,760


8
00:00:39,760 --> 00:00:41,840


9
00:00:41,840 --> 00:00:46,860
重要な点は、線形変換は空間の基底ベクトル (2 次元の場合は i-hat

10
00:00:46,860 --> 00:00:52,260
と j-hat を意味します) をどこに取るかによって完全に決定されるということです。

11
00:00:52,260 --> 00:00:56,500
これは、他のベクトルはそれらの基底ベクトルの線形結合として記述できるためです。

12
00:00:56,500 --> 00:00:57,820


13
00:00:57,820 --> 00:01:03,460
座標 x、y を持つベクトルは、x に i-hat を掛けたものに、y に j-hat を掛けたものです。

14
00:01:03,460 --> 00:01:07,540
変換を経た後、グリッド線が平行かつ等間隔に保たれるというこの特性は、素晴らしい結果をもたらします。

15
00:01:07,540 --> 00:01:10,600


16
00:01:10,600 --> 00:01:15,180
ベクトルが着地する場所は、i-hat の変換バージョンの x 倍に、j-hat

17
00:01:15,180 --> 00:01:18,440
の変換バージョンの y 倍を加えた場所になります。

18
00:01:18,440 --> 00:01:22,960
これは、i-hat が着地する座標と j-hat が着地する座標を記録しておくと、x、y

19
00:01:22,960 --> 00:01:28,940
で始まるベクトルは、i-hat に y を加えた新しい座標の

20
00:01:28,940 --> 00:01:33,600
x 倍の位置に着地する必要があることを計算できます。 j-hat の新しい座標を倍します。

21
00:01:33,600 --> 00:01:38,000
規則では、i-hat と j-hat

22
00:01:38,000 --> 00:01:42,820
が配置される場所の座標を行列の列として記録し、これらの列を x と

23
00:01:42,820 --> 00:01:46,280
y でスケーリングしたものの合計を行列とベクトルの乗算として定義します。

24
00:01:46,280 --> 00:01:51,320
このように、行列は特定の線形変換を表し、行列にベクトルを乗算することは、その変換をそのベクトルに適用することを計算的に意味します。

25
00:01:51,320 --> 00:01:58,040


26
00:01:58,040 --> 00:02:01,760
さて、おさらいして新しい内容に移りましょう。

27
00:02:01,760 --> 00:02:06,160
ある変換を適用してから別の変換を適用した場合の効果を説明したい場合がよくあります。

28
00:02:06,160 --> 00:02:07,680


29
00:02:07,680 --> 00:02:11,760
たとえば、最初に平面を反時計回りに 90

30
00:02:11,760 --> 00:02:15,440
度回転し、次にシアーを適用すると何が起こるかを説明したいとします。

31
00:02:15,440 --> 00:02:20,360
ここでの全体的な効果は、最初から最後まで、回転やせん断とは異なる別の線形変換です。

32
00:02:20,360 --> 00:02:22,540


33
00:02:22,540 --> 00:02:26,920
この新しい線形変換は、一般に、適用した 2

34
00:02:26,920 --> 00:02:29,040
つの別々の変換の合成と呼ばれます。

35
00:02:29,040 --> 00:02:33,480
そして、他の線形変換と同様に、i-hat と

36
00:02:33,480 --> 00:02:36,280
j-hat に従って、それ自体の行列で記述することができます。

37
00:02:36,280 --> 00:02:42,360
この例では、両方の変換後の i-hat の最終的な着地点は

38
00:02:42,360 --> 00:02:44,800
1,1 なので、これを行列の最初の列にします。

39
00:02:44,840 --> 00:02:50,320
同様に、j-hat は最終的にマイナス 1,0

40
00:02:50,320 --> 00:02:52,800
の位置に到達するため、それを行列の 2 列目にします。

41
00:02:52,800 --> 00:02:58,300
この新しいマトリックスは、回転とせん断を適用した場合の全体的な効果を、連続した 2 つのアクションではなく

42
00:02:58,300 --> 00:03:03,400
1 つのアクションとして捉えています。

43
00:03:03,400 --> 00:03:05,480
この新しいマトリックスについて考える 1 つの方法を次に示します。

44
00:03:05,480 --> 00:03:09,760
ベクトルを取得し、それを回転、次にせん断を通してポンプする場合、最終的にどこに到達するかを計算する長い方法は、まず左側で回転行列を乗算することです。

45
00:03:09,760 --> 00:03:14,360


46
00:03:14,400 --> 00:03:15,400


47
00:03:15,400 --> 00:03:20,520
次に、得られたものをすべて取り、左側にせん断行列を掛けます。

48
00:03:20,520 --> 00:03:26,000
これは、数値的に言えば、特定のベクトルに回転を加えてからせん断を適用することを意味します。

49
00:03:26,000 --> 00:03:27,000


50
00:03:27,000 --> 00:03:30,720
しかし、得られるものは何であれ、選択したベクトルに関係なく、同じベクトルで見つけたこの新しい合成行列を適用したのと同じであるはずです。この新しい行列は、回転とせん断アクションと同じ全体的な効果をキャプチャすることになっているためです。

51
00:03:30,720 --> 00:03:35,560


52
00:03:35,560 --> 00:03:42,720


53
00:03:42,720 --> 00:03:45,940
ここでの書き方からすると、この新しい行列を元の 2

54
00:03:45,940 --> 00:03:50,640
つの行列の積と呼ぶのが妥当だと思いますね。

55
00:03:50,640 --> 00:03:54,460
その積をより一般的に計算する方法についてはすぐに考えることができますが、あまりにも簡単に数値の森の中で迷子になってしまいます。

56
00:03:54,460 --> 00:03:57,440


57
00:03:57,440 --> 00:04:02,280
このように 2

58
00:04:02,280 --> 00:04:06,340
つの行列を乗算することには、ある変換を適用してから別の変換を適用するという幾何学的な意味があることを常に覚えておいてください。

59
00:04:06,340 --> 00:04:10,080
ここで少し奇妙なのは、右から左に読むことになることです。

60
00:04:10,080 --> 00:04:14,160
まず右側の行列で表される変換を適用し、次に左側の行列で表される変換を適用します。

61
00:04:14,160 --> 00:04:17,600


62
00:04:17,600 --> 00:04:21,940
これは関数の表記法に由来しています。変数の左側に関数を記述するため、2

63
00:04:21,940 --> 00:04:26,160
つの関数を構成するたびに、常に右から左に読む必要があります。

64
00:04:26,160 --> 00:04:30,080
ヘブライ語の読者にとっては良いニュースですが、それ以外の私たちにとっては悪いニュースです。

65
00:04:30,080 --> 00:04:31,880
別の例を見てみましょう。

66
00:04:31,880 --> 00:04:38,160
列 1,1 と負の 2,0 を持つ行列を考えます。その変換は次のようになります。

67
00:04:38,240 --> 00:04:40,000
それを m1 と呼びます。

68
00:04:40,000 --> 00:04:46,000
次に、列 0,1 および 2,0 を持つ行列を取得します。その変換は次のようになります。

69
00:04:47,840 --> 00:04:50,040
その男を m2 と呼びましょう。

70
00:04:50,040 --> 00:04:55,560
m1 を適用してから

71
00:04:55,560 --> 00:04:56,560
m2 を適用する合計の効果により、新しい変換が得られるので、その行列を見つけてみましょう。

72
00:04:56,560 --> 00:05:00,940
ただし今回は、アニメーションを見ずに、各行列の数値入力だけを使用してそれができるかどうかを見てみましょう。

73
00:05:00,940 --> 00:05:04,480


74
00:05:04,480 --> 00:05:08,040
まず、i-hat がどこに行くのかを把握する必要があります。

75
00:05:08,280 --> 00:05:13,560
m1 を適用した後、i-hat の新しい座標は、定義により、m1

76
00:05:13,560 --> 00:05:16,960
の最初の列、つまり 1,1 によって与えられます。

77
00:05:16,960 --> 00:05:23,960
m2 を適用した後に何が起こるかを確認するには、m2 の行列にそのベクトル 1,1 を乗算します。

78
00:05:25,720 --> 00:05:30,860
前回のビデオで説明した方法で計算すると、ベクトル 2,1 が得られます。

79
00:05:30,860 --> 00:05:33,960
これは、構成マトリックスの最初の列になります。

80
00:05:34,160 --> 00:05:40,000
同様に、j-hat に従うと、m1 の 2

81
00:05:40,000 --> 00:05:42,000
番目の列は、最初に負の 2,0 に到達することを示しています。

82
00:05:42,000 --> 00:05:50,000
次に、そのベクトルに m2 を適用すると、行列ベクトルの積を計算して 0、負の

83
00:05:50,240 --> 00:05:57,040
2 を得ることができ、これが合成行列の 2 列目になります。

84
00:05:57,040 --> 00:06:01,060
同じプロセスをもう一度説明しますが、今回は、同じ推論がどの行列でも機能することを示すために、各行列の変数エントリを示します。

85
00:06:01,060 --> 00:06:05,620


86
00:06:05,620 --> 00:06:09,560
これはシンボルが多くなり、もう少しスペースが必要になりますが、以前に行列の乗算をより暗記的な方法で教えられた人にとっては、かなり満足できるはずです。

87
00:06:09,560 --> 00:06:14,580


88
00:06:14,580 --> 00:06:19,180
i-hat がどこへ行くのかを追跡するには、まず右側の行列の最初の列を調べます。これは、i-hat

89
00:06:19,180 --> 00:06:22,440
が最初に着地する場所だからです。

90
00:06:22,440 --> 00:06:26,860
その列に左側の行列を乗算すると、2 番目の変換を適用した後に

91
00:06:26,860 --> 00:06:31,780
i-hat の中間バージョンがどこに到達するかがわかります。

92
00:06:31,780 --> 00:06:36,380
したがって、合成行列の最初の列は常に、左行列と右行列の最初の列の積に等しくなります。

93
00:06:36,380 --> 00:06:39,380


94
00:06:39,380 --> 00:06:46,380
同様に、j-hat は常に最初は右行列の 2 列目に配置されます。

95
00:06:48,960 --> 00:06:54,540
したがって、左の行列にこの 2 番目の列を乗算すると、その最終的な位置が得られるため、それが合成行列の

96
00:06:54,740 --> 00:07:00,740
2 番目の列になります。

97
00:07:00,740 --> 00:07:04,460
ここにはたくさんの記号があることに注意してください。この公式は暗記するものとして教えられるのが一般的であり、それを覚えるのに役立つ特定のアルゴリズムのプロセスも一緒に教えられます。

98
00:07:04,460 --> 00:07:09,320


99
00:07:09,320 --> 00:07:13,100
しかし、そのプロセスを暗記する前に、行列の乗算が実際に何を表し、変換を次々と適用するかを考える習慣を身につけるべきだと私は心から思います。

100
00:07:13,100 --> 00:07:18,140


101
00:07:18,140 --> 00:07:19,660


102
00:07:19,660 --> 00:07:23,600
信じてください。これにより、行列の乗算の特性をはるかに理解しやすくする、より優れた概念フレームワークが得られます。

103
00:07:23,640 --> 00:07:27,160


104
00:07:27,160 --> 00:07:29,080
たとえば、こんな質問があります。

105
00:07:29,080 --> 00:07:33,480
2 つの行列を乗算するときにそれらをどの順序で置くかは重要ですか?

106
00:07:33,480 --> 00:07:37,760
さて、先ほどのような簡単な例で考えてみましょう。

107
00:07:37,760 --> 00:07:43,700
i-hat を固定し、j-hat を右に押しつぶすハサミを 90 度回転させます。

108
00:07:43,700 --> 00:07:49,560
最初にせん断を行ってから回転すると、i-hat は 0,1 になり、j-hat

109
00:07:49,600 --> 00:07:51,480
は負の 1,1 になることがわかります。

110
00:07:51,480 --> 00:07:54,000
両方は通常、近くを指しています。

111
00:07:54,000 --> 00:08:01,000
最初に回転してからせん断を行うと、i-hat は 1,1 で終了し、j-hat

112
00:08:01,420 --> 00:08:06,440
は負の 1,0 で別の方向にずれて、さらに離れた方向を指します。

113
00:08:06,440 --> 00:08:12,480
ここでの全体的な効果は明らかに異なるため、明らかに順序が完全に重要です。

114
00:08:12,480 --> 00:08:16,520
変換という観点から考えると、視覚化することで頭の中でできるようなことです。

115
00:08:16,520 --> 00:08:18,360


116
00:08:18,360 --> 00:08:21,800
行列の乗算は必要ありません。

117
00:08:21,800 --> 00:08:26,020
私が初めて線形代数を履修したとき、行列の乗算が結合的であることを証明するという宿題が 1

118
00:08:26,020 --> 00:08:29,780
つありました。

119
00:08:29,780 --> 00:08:34,660
これは、A、B、C という 3 つの行列があり、それらをすべて乗算する場合、最初に A と

120
00:08:34,660 --> 00:08:39,840
B を掛けてからその結果を C で乗算するか、最初に B

121
00:08:39,840 --> 00:08:45,060
を乗算するかは問題ではないことを意味します。 C を計算し、その結果に左側の A を掛けます。

122
00:08:45,060 --> 00:08:48,100
つまり、括弧をどこに入れても問題ありません。

123
00:08:48,100 --> 00:08:53,340
さて、当時の私のようにこれを数値的に解明しようとすると、それは恐ろしい、まったく恐ろしく、その点においては啓発的ではありません。

124
00:08:53,340 --> 00:08:56,420


125
00:08:56,420 --> 00:09:01,380
しかし、行列の乗算を 1

126
00:09:01,380 --> 00:09:03,460
つの変換を次々に適用するものと考えると、この性質は単なる些細なものです。

127
00:09:03,460 --> 00:09:05,060
理由がわかりますか?

128
00:09:05,060 --> 00:09:10,700
何を言っているのかというと、最初に C を適用し、次に B、次に A

129
00:09:10,700 --> 00:09:13,060
を適用した場合、それは C、次に B、次に A を適用したのと同じであるということです。

130
00:09:13,060 --> 00:09:16,940
つまり、証明するものは何もなく、同じ 3

131
00:09:16,940 --> 00:09:19,680
つのことをすべて同じ順序で順番に適用しているだけです。

132
00:09:19,680 --> 00:09:22,080
これは不正行為のように感じるかもしれませんが、そうではありません。

133
00:09:22,080 --> 00:09:26,360
これは、行列の乗算が結合的であるという正直な証明です。

134
00:09:26,360 --> 00:09:31,820
そしてそれ以上に、それはその特性が真である理由をうまく説明しています。

135
00:09:31,820 --> 00:09:37,020
このアイデアをもっと試してみることをお勧めします。2

136
00:09:37,020 --> 00:09:40,560
つの異なる変換を想像し、交互に適用すると何が起こるかを考え、行列の積を数値的に計算します。

137
00:09:40,560 --> 00:09:42,700


138
00:09:42,700 --> 00:09:47,460
信じてください、これはアイデアを本当に浸透させる一種の遊びです。

139
00:09:47,460 --> 00:09:52,060
次のビデオでは、これらのアイデアを単なる 2 次元を超えて拡張することについて話し始めます。

140
00:09:52,060 --> 00:09:52,340
それではまた！

