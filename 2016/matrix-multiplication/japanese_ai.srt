1
00:00:00,000 --> 00:00:15,240
皆さん、前回の続きで、線形変換がどのようなものなのか、そ

2
00:00:15,240 --> 00:00:18,360
して行列を使用して線形変換を表現する方法を説明しました。

3
00:00:18,360 --> 00:00:22,320
これは本当に重要なことなので、簡単に要約する価値がありますが、もちろん、こ

4
00:00:22,320 --> 00:00:26,280
れが単なる要約以上のものだと感じた場合は、戻ってビデオ全体を見てください。

5
00:00:26,280 --> 00:00:30,700
一般的に、線形変換は入力としてベクト

6
00:00:30,700 --> 00:00:34,760
ル、出力としてベクトルを持つ関数です

7
00:00:34,760 --> 00:00:39,760
が、前回、グリッド線が平行で等間隔に

8
00:00:39,760 --> 00:00:41,840
保たれ、原点が固定されたままです。

9
00:00:41,840 --> 00:00:46,860
重要な点は、線形変換は空間の基底ベクトル (2 次元の場合は i-hat と j

10
00:00:46,860 --> 00:00:52,260
-hat を意味します) をどこに取るかによって完全に決定されるということです。

11
00:00:52,260 --> 00:00:56,500
これは、他のベクトルはそれらの基底ベクト

12
00:00:56,500 --> 00:00:57,820
ルの線形結合として記述できるためです。

13
00:00:57,820 --> 00:01:03,460
座標 x、y を持つベクトルは、x に i-hat を掛けたものに、y に j-hat を掛けたものです。

14
00:01:03,460 --> 00:01:07,540
変換を経た後、グリッド線が平行かつ等間隔に保たれる

15
00:01:07,540 --> 00:01:10,600
というこの特性は、素晴らしい結果をもたらします。

16
00:01:10,600 --> 00:01:15,180
ベクトルが着地する場所は、i-hat の変換バージョンの x 倍に

17
00:01:15,180 --> 00:01:18,440
、j-hat の変換バージョンの y 倍を加えた場所になります。

18
00:01:18,440 --> 00:01:22,960
これは、i-hat が着地する座標と j-hat が着地する座標を記録しておくと、

19
00:01:22,960 --> 00:01:28,940
x、y で始まるベクトルは、i-hat に y を加えた新しい座標の x 倍の位

20
00:01:28,940 --> 00:01:33,600
置に着地する必要があることを計算できます。 j-hat の新しい座標を倍します。

21
00:01:33,600 --> 00:01:38,000
慣例では、i ハットと j ハットが配置される場所の座標を

22
00:01:38,000 --> 00:01:42,820
行列の列として記録し、これらの列を x と y でスケーリ

23
00:01:42,820 --> 00:01:46,280
ングしたものの合計を行列とベクトルの乗算として定義します。

24
00:01:46,280 --> 00:01:51,320
このように、行列は特定の線形変換を表し、行列にベクトルを乗算するこ

25
00:01:51,320 --> 00:01:58,040
とは、その変換をそのベクトルに適用することを計算的に意味します。

26
00:01:58,040 --> 00:02:01,760
さて、おさらいして新しい内容に移りましょう。

27
00:02:01,760 --> 00:02:06,160
ある変換を適用してから別の変換を適用した場

28
00:02:06,160 --> 00:02:07,680
合の効果を説明したい場合がよくあります。

29
00:02:07,680 --> 00:02:11,760
たとえば、最初に平面を反時計回りに 90 度回転し、次

30
00:02:11,760 --> 00:02:15,440
にシアーを適用すると何が起こるかを説明したいとします。

31
00:02:15,440 --> 00:02:20,360
ここでの全体的な効果は、最初から最後まで、

32
00:02:20,360 --> 00:02:22,540
回転やせん断とは異なる別の線形変換です。

33
00:02:22,540 --> 00:02:26,920
この新しい線形変換は、一般に、適用した

34
00:02:26,920 --> 00:02:29,040
2 つの別々の変換の合成と呼ばれます。

35
00:02:29,040 --> 00:02:33,480
そして、他の線形変換と同様に、i-hat と j-ha

36
00:02:33,480 --> 00:02:36,280
t に従って、それ自体の行列で記述することができます。

37
00:02:36,280 --> 00:02:42,360
この例では、両方の変換後の i-hat の最終的な着地

38
00:02:42,360 --> 00:02:44,800
点は 1,1 なので、これを行列の最初の列にします。

39
00:02:44,840 --> 00:02:50,320
同様に、j-hat は最終的にマイナス 1,0 の位

40
00:02:50,320 --> 00:02:52,800
置に到達するため、それを行列の 2 列目にします。

41
00:02:52,800 --> 00:02:58,300
この新しいマトリックスは、回転とせん断を適用した場合の全体的な効果を、連続

42
00:02:58,300 --> 00:03:03,400
した 2 つのアクションではなく 1 つのアクションとして捉えています。

43
00:03:03,400 --> 00:03:05,480
この新しいマトリックスについて考える 1 つの方法を次に示します。

44
00:03:05,480 --> 00:03:09,760
ベクトルを取得し、それを回転、次にせん断を通してポ

45
00:03:09,760 --> 00:03:14,360
ンプする場合、最終的にどこに到達するかを計算する長

46
00:03:14,400 --> 00:03:15,400
い方法は、まず左側で回転行列を乗算することです。

47
00:03:15,400 --> 00:03:20,520
次に、得られたものをすべて取り、左側にせん断行列を掛けます。

48
00:03:20,520 --> 00:03:26,000
これは、数値的に言えば、特定のベクトルに回転を

49
00:03:26,000 --> 00:03:27,000
加えてからせん断を適用することを意味します。

50
00:03:27,000 --> 00:03:30,720
しかし、得られるものは何であれ、選択したベクトルに関係なく、同じベクトルで見つ

51
00:03:30,720 --> 00:03:35,560
けたこの新しい合成行列を適用したのと同じであるはずです。この新しい行列は、回転

52
00:03:35,560 --> 00:03:42,720
とせん断アクションと同じ全体的な効果をキャプチャすることになっているためです。

53
00:03:42,720 --> 00:03:45,940
ここでの書き方からすると、この新しい行列を元の

54
00:03:45,940 --> 00:03:50,640
2 つの行列の積と呼ぶのが妥当だと思いますね。

55
00:03:50,640 --> 00:03:54,460
その積をより一般的に計算する方法についてはすぐに考えることができ

56
00:03:54,460 --> 00:03:57,440
ますが、あまりにも簡単に数値の森の中で迷子になってしまいます。

57
00:03:57,440 --> 00:04:02,280
このように 2 つの行列を乗算することには、ある変換を適用してから別の変

58
00:04:02,280 --> 00:04:06,340
換を適用するという幾何学的な意味があることを常に覚えておいてください。

59
00:04:06,340 --> 00:04:10,080
ここで少し奇妙なのは、右から左に読むことになることです。

60
00:04:10,080 --> 00:04:14,160
まず右側の行列で表される変換を適用し、次

61
00:04:14,160 --> 00:04:17,600
に左側の行列で表される変換を適用します。

62
00:04:17,600 --> 00:04:21,940
これは関数の表記法に由来しています。変数の左側に関数を記述するため

63
00:04:21,940 --> 00:04:26,160
、2 つの関数を構成するたびに、常に右から左に読む必要があります。

64
00:04:26,160 --> 00:04:30,080
ヘブライ語の読者にとっては良いニュースですが、それ以外の私たちにとっては悪いニュースです。

65
00:04:30,080 --> 00:04:31,880
別の例を見てみましょう。

66
00:04:31,880 --> 00:04:38,160
列 1,1 と負の 2,0 を持つ行列を考えます。その変換は次のようになります。

67
00:04:38,240 --> 00:04:40,000
それを m1 と呼びます。

68
00:04:40,000 --> 00:04:46,000
次に、列 0,1 および 2,0 を持つ行列を取得します。その変換は次のようになります。

69
00:04:47,840 --> 00:04:50,040
その男を m2 と呼びましょう。

70
00:04:50,040 --> 00:04:55,560
m1 を適用してから m2 を適用する合計の効果により、

71
00:04:55,560 --> 00:04:56,560
新しい変換が得られるので、その行列を見つけてみましょう。

72
00:04:56,560 --> 00:05:00,940
ただし今回は、アニメーションを見ずに、各行列の数値入力

73
00:05:00,940 --> 00:05:04,480
だけを使用してそれができるかどうかを見てみましょう。

74
00:05:04,480 --> 00:05:08,040
まず、i-hat がどこに行くのかを把握する必要があります。

75
00:05:08,280 --> 00:05:13,560
m1 を適用した後、i-hat の新しい座標は、定義により

76
00:05:13,560 --> 00:05:16,960
、m1 の最初の列、つまり 1,1 によって与えられます。

77
00:05:16,960 --> 00:05:23,960
m2 を適用した後に何が起こるかを確認するには、m2 の行列にそのベクトル 1,1 を乗算します。

78
00:05:25,720 --> 00:05:30,860
前回のビデオで説明した方法で計算すると、ベクトル 2,1 が得られます。

79
00:05:30,860 --> 00:05:33,960
これは、構成マトリックスの最初の列になります。

80
00:05:34,160 --> 00:05:40,000
同様に、j-hat に従うと、m1 の 2 番目の列は

81
00:05:40,000 --> 00:05:42,000
、最初に負の 2,0 に到達することを示しています。

82
00:05:42,000 --> 00:05:50,000
次に、そのベクトルに m2 を適用すると、行列ベクトルの積を計算して

83
00:05:50,240 --> 00:05:57,040
0、負の 2 を得ることができ、これが合成行列の 2 列目になります。

84
00:05:57,040 --> 00:06:01,060
同じプロセスをもう一度説明しますが、今回は、同じ推論がどの行列

85
00:06:01,060 --> 00:06:05,620
でも機能することを示すために、各行列の変数エントリを示します。

86
00:06:05,620 --> 00:06:09,560
これはシンボルが多くなり、もう少しスペースが必要になりますが、以前に行列の

87
00:06:09,560 --> 00:06:14,580
乗算をより暗記的な方法で教えられた人にとっては、かなり満足できるはずです。

88
00:06:14,580 --> 00:06:19,180
i-hat がどこへ行くのかを追跡するには、まず右側の行列の最初の

89
00:06:19,180 --> 00:06:22,440
列を調べます。これは、i-hat が最初に着地する場所だからです。

90
00:06:22,440 --> 00:06:26,860
その列に左側の行列を乗算すると、2 番目の変換を適用した後に

91
00:06:26,860 --> 00:06:31,780
i-hat の中間バージョンがどこに到達するかがわかります。

92
00:06:31,780 --> 00:06:36,380
したがって、合成行列の最初の列は常に、左行

93
00:06:36,380 --> 00:06:39,380
列と右行列の最初の列の積に等しくなります。

94
00:06:39,380 --> 00:06:46,380
同様に、j-hat は常に最初は右行列の 2 列目に配置されます。

95
00:06:48,960 --> 00:06:54,540
したがって、左の行列にこの 2 番目の列を乗算すると、その最終的

96
00:06:54,740 --> 00:07:00,740
な位置が得られるため、それが合成行列の 2 番目の列になります。

97
00:07:00,740 --> 00:07:04,460
ここにはたくさんの記号があることに注意してください。この公式は暗記するものとして教えられる

98
00:07:04,460 --> 00:07:09,320
のが一般的であり、それを覚えるのに役立つ特定のアルゴリズムのプロセスも一緒に教えられます。

99
00:07:09,320 --> 00:07:13,100
しかし、そのプロセスを暗記する前に、行列の乗算

100
00:07:13,100 --> 00:07:18,140
が実際に何を表し、変換を次々と適用するかを考え

101
00:07:18,140 --> 00:07:19,660
る習慣を身につけるべきだと私は心から思います。

102
00:07:19,660 --> 00:07:23,600
信じてください。これにより、行列の乗算の特性をはるかに理解

103
00:07:23,640 --> 00:07:27,160
しやすくする、より優れた概念フレームワークが得られます。

104
00:07:27,160 --> 00:07:29,080
たとえば、こんな質問があります。

105
00:07:29,080 --> 00:07:33,480
2 つの行列を乗算するときにそれらをどの順序で置くかは重要ですか?

106
00:07:33,480 --> 00:07:37,760
さて、先ほどのような簡単な例で考えてみましょう。

107
00:07:37,760 --> 00:07:43,700
i-hat を固定し、j-hat を右に押しつぶすハサミを 90 度回転させます。

108
00:07:43,700 --> 00:07:49,560
最初にせん断を行ってから回転すると、i-hat が 0,1

109
00:07:49,600 --> 00:07:51,480
になり、j-hat が負の 1,1 になることがわかります。

110
00:07:51,480 --> 00:07:54,000
両方は通常、近くを指しています。

111
00:07:54,000 --> 00:08:01,000
最初に回転してからせん断を行うと、i-hat は 1,1 で終了し、j-

112
00:08:01,420 --> 00:08:06,440
hat は負の 1,0 で別の方向にずれて、さらに離れた方向を指します。

113
00:08:06,440 --> 00:08:12,480
ここでの全体的な効果は明らかに異なるため、明らかに順序が完全に重要です。

114
00:08:12,480 --> 00:08:16,520
変換という観点から考えると、視覚化する

115
00:08:16,520 --> 00:08:18,360
ことで頭の中でできるようなことです。

116
00:08:18,360 --> 00:08:21,800
行列の乗算は必要ありません。

117
00:08:21,800 --> 00:08:26,020
私が初めて線形代数を履修したとき、行列の乗算が結合的

118
00:08:26,020 --> 00:08:29,780
であることを証明するという宿題が 1 つありました。

119
00:08:29,780 --> 00:08:34,660
これは、A、B、C という 3 つの行列があり、それらをすべて乗算する場合、最初に

120
00:08:34,660 --> 00:08:39,840
A と B を掛けてからその結果を C で乗算するか、最初に B を乗算するかは

121
00:08:39,840 --> 00:08:45,060
問題ではないことを意味します。 C を計算し、その結果に左側の A を掛けます。

122
00:08:45,060 --> 00:08:48,100
つまり、括弧をどこに入れても問題ありません。

123
00:08:48,100 --> 00:08:53,340
さて、当時の私のようにこれを数値的に解明しようとすると、それは恐

124
00:08:53,340 --> 00:08:56,420
ろしい、まったく恐ろしく、その点においては啓発的ではありません。

125
00:08:56,420 --> 00:09:01,380
しかし、行列の乗算を 1 つの変換を次々に適用する

126
00:09:01,380 --> 00:09:03,460
ものと考えると、この性質は単なる些細なものです。

127
00:09:03,460 --> 00:09:05,060
理由がわかりますか?

128
00:09:05,060 --> 00:09:10,700
何を言っているのかというと、最初に C を適用し、次に B、次に A を適用した

129
00:09:10,700 --> 00:09:13,060
場合、それは C、次に B、次に A を適用したのと同じであるということです。

130
00:09:13,060 --> 00:09:16,940
つまり、証明するものは何もなく、同じ 3 つのこ

131
00:09:16,940 --> 00:09:19,680
とをすべて同じ順序で順番に適用しているだけです。

132
00:09:19,680 --> 00:09:22,080
これは不正行為のように感じるかもしれませんが、そうではありません。

133
00:09:22,080 --> 00:09:26,360
これは、行列の乗算が結合的であるという正直な証明です。

134
00:09:26,360 --> 00:09:31,820
そしてそれ以上に、それはその特性が真である理由をうまく説明しています。

135
00:09:31,820 --> 00:09:37,020
このアイデアをもっと試してみることをお勧めします

136
00:09:37,020 --> 00:09:40,560
。2 つの異なる変換を想像し、交互に適用すると何

137
00:09:40,560 --> 00:09:42,700
が起こるかを考え、行列の積を数値的に計算します。

138
00:09:42,700 --> 00:09:47,460
信じてください、これはアイデアを本当に浸透させる一種の遊びです。

139
00:09:47,460 --> 00:09:52,060
次のビデオでは、これらのアイデアを単なる 2 次元を超えて拡張することについて話し始めます。

140
00:09:52,060 --> 00:09:52,340
それではまた！

