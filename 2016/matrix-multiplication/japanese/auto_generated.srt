1
00:00:10,940 --> 00:00:13,962
皆さん、前回の続きで、線形変換がどのようなものなのか、そ 

2
00:00:13,962 --> 00:00:16,880
して行列を使用して線形変換を表現する方法を説明しました。

3
00:00:18,320 --> 00:00:20,593
これは本当に重要なことなので、簡単に要約する価値が

4
00:00:20,593 --> 00:00:22,866
ありますが、もちろん、こ れが単なる要約以上のもの

5
00:00:22,866 --> 00:00:25,140
だと感じた場合は、戻ってビデオ全体を見てください。

6
00:00:25,779 --> 00:00:29,734
一般的に、線形変換は入力としてベクト 

7
00:00:29,734 --> 00:00:33,688
ル、出力としてベクトルを持つ関数です 

8
00:00:33,688 --> 00:00:37,642
が、前回、グリッド線が平行で等間隔に 

9
00:00:37,642 --> 00:00:41,180
保たれ、原点が固定されたままです。

10
00:00:41,820 --> 00:00:44,640
重要な点は、線形変換は空間の基底ベクトル (2 

11
00:00:44,640 --> 00:00:48,166
次元の場合は i-hat と j -hat を意味します) 

12
00:00:48,166 --> 00:00:51,340
をどこに取るかによって完全に決定されるということです。

13
00:00:51,340 --> 00:00:54,490
これは、他のベクトルはそれらの基底ベクト 

14
00:00:54,490 --> 00:00:57,340
ルの線形結合として記述できるためです。

15
00:00:57,940 --> 00:01:00,098
座標 x、y を持つベクトルは、x に i-hat 

16
00:01:00,098 --> 00:01:02,340
を掛けたものに、y に j-hat を掛けたものです。

17
00:01:03,460 --> 00:01:06,788
変換を経た後、グリッド線が平行かつ等間隔に保たれる 

18
00:01:06,788 --> 00:01:09,860
というこの特性は、素晴らしい結果をもたらします。

19
00:01:10,500 --> 00:01:12,532
ベクトルが着地する場所は、i-hat 

20
00:01:12,532 --> 00:01:14,885
の変換バージョンの x 倍に 、j-hat 

21
00:01:14,885 --> 00:01:17,560
の変換バージョンの y 倍を加えた場所になります。

22
00:01:18,240 --> 00:01:21,207
これは、i-hat が着地する座標と j-hat 

23
00:01:21,207 --> 00:01:23,699
が着地する座標を記録しておくと、 x、y 

24
00:01:23,699 --> 00:01:26,073
で始まるベクトルは、i-hat に y 

25
00:01:26,073 --> 00:01:28,091
を加えた新しい座標の x 倍の位 

26
00:01:28,091 --> 00:01:30,583
置に着地する必要があることを計算できます。

27
00:01:30,583 --> 00:01:32,720
j-hat の新しい座標を倍します。

28
00:01:33,560 --> 00:01:37,537
慣例では、i ハットと j ハットが配置される場所の座標を 

29
00:01:37,537 --> 00:01:41,515
行列の列として記録し、これらの列を x と y でスケーリ 

30
00:01:41,515 --> 00:01:45,360
ングしたものの合計を行列とベクトルの乗算として定義します。

31
00:01:46,050 --> 00:01:49,726
このように、行列は特定の線形変換を表し、行列

32
00:01:49,726 --> 00:01:53,403
にベクトルを乗算するこ とは、その変換をその

33
00:01:53,403 --> 00:01:57,080
ベクトルに適用することを計算的に意味します。

34
00:01:58,800 --> 00:02:00,880
さて、おさらいして新しい内容に移りましょう。

35
00:02:01,600 --> 00:02:04,428
ある変換を適用してから別の変換を適用した場 

36
00:02:04,428 --> 00:02:07,000
合の効果を説明したい場合がよくあります。

37
00:02:07,620 --> 00:02:11,112
たとえば、最初に平面を反時計回りに 90 度回転し、次 

38
00:02:11,112 --> 00:02:14,480
にシアーを適用すると何が起こるかを説明したいとします。

39
00:02:15,260 --> 00:02:18,685
ここでの全体的な効果は、最初から最後まで、 

40
00:02:18,685 --> 00:02:21,800
回転やせん断とは異なる別の線形変換です。

41
00:02:22,280 --> 00:02:25,326
この新しい線形変換は、一般に、適用した 

42
00:02:25,326 --> 00:02:28,220
2 つの別々の変換の合成と呼ばれます。

43
00:02:28,920 --> 00:02:32,239
そして、他の線形変換と同様に、i-hat と j-ha 

44
00:02:32,239 --> 00:02:35,440
t に従って、それ自体の行列で記述することができます。

45
00:02:36,020 --> 00:02:40,220
この例では、両方の変換後の i-hat の最終的な着地 

46
00:02:40,220 --> 00:02:44,120
点は 1,1 なので、これを行列の最初の列にします。

47
00:02:44,960 --> 00:02:48,542
同様に、j-hat は最終的にマイナス 1,0 の位 

48
00:02:48,542 --> 00:02:51,860
置に到達するため、それを行列の 2 列目にします。

49
00:02:52,680 --> 00:02:55,488
この新しいマトリックスは、回転とせん断を適用した

50
00:02:55,488 --> 00:02:57,712
場合の全体的な効果を、連続 した 2 

51
00:02:57,712 --> 00:03:00,520
つのアクションではなく 1 つのアクションとして

52
00:03:00,520 --> 00:03:01,340
捉えています。

53
00:03:03,040 --> 00:03:04,099
この新しいマトリックスについて考える 

54
00:03:04,099 --> 00:03:04,880
1 つの方法を次に示します。

55
00:03:05,420 --> 00:03:08,635
ベクトルを取得し、それを回転、次にせん断を通してポ 

56
00:03:08,635 --> 00:03:11,851
ンプする場合、最終的にどこに到達するかを計算する長 

57
00:03:11,851 --> 00:03:14,820
い方法は、まず左側で回転行列を乗算することです。

58
00:03:15,320 --> 00:03:19,800
次に、得られたものをすべて取り、左側にせん断行列を掛けます。

59
00:03:20,460 --> 00:03:23,381
これは、数値的に言えば、特定のベクトルに回転を 

60
00:03:23,381 --> 00:03:26,060
加えてからせん断を適用することを意味します。

61
00:03:26,800 --> 00:03:30,255
しかし、得られるものは何であれ、選択したベクトルに関係なく

62
00:03:30,255 --> 00:03:33,711
、同じベクトルで見つ けたこの新しい合成行列を適用したのと

63
00:03:33,711 --> 00:03:36,332
同じであるはずです。この新しい行列は、回転 

64
00:03:36,332 --> 00:03:39,788
とせん断アクションと同じ全体的な効果をキャプチャすることに

65
00:03:39,788 --> 00:03:40,980
なっているためです。

66
00:03:42,480 --> 00:03:46,003
ここでの書き方からすると、この新しい行列を元の 

67
00:03:46,003 --> 00:03:49,380
2 つの行列の積と呼ぶのが妥当だと思いますね。

68
00:03:50,420 --> 00:03:52,447
その積をより一般的に計算する方法については

69
00:03:52,447 --> 00:03:54,475
すぐに考えることができ ますが、あまりにも

70
00:03:54,475 --> 00:03:56,600
簡単に数値の森の中で迷子になってしまいます。

71
00:03:56,600 --> 00:03:59,160
このように 2 つの行列を乗算することには、ある

72
00:03:59,160 --> 00:04:01,720
変換を適用してから別の変 換を適用するという幾何

73
00:04:01,720 --> 00:04:04,280
学的な意味があることを常に覚えておいてください。

74
00:04:05,860 --> 00:04:09,660
ここで少し奇妙なのは、右から左に読むことになることです。

75
00:04:10,040 --> 00:04:13,461
まず右側の行列で表される変換を適用し、次 

76
00:04:13,461 --> 00:04:16,720
に左側の行列で表される変換を適用します。

77
00:04:17,399 --> 00:04:19,565
これは関数の表記法に由来しています。

78
00:04:19,565 --> 00:04:21,851
変数の左側に関数を記述するため 、2 

79
00:04:21,851 --> 00:04:25,460
つの関数を構成するたびに、常に右から左に読む必要があります。

80
00:04:25,920 --> 00:04:27,416
ヘブライ語の読者にとっては良いニュースですが

81
00:04:27,416 --> 00:04:28,980
、それ以外の私たちにとっては悪いニュースです。

82
00:04:29,880 --> 00:04:31,100
別の例を見てみましょう。

83
00:04:31,760 --> 00:04:34,947
列 1,1 と負の 2,0 を持つ行列を考えます。

84
00:04:34,947 --> 00:04:36,860
その変換は次のようになります。

85
00:04:37,980 --> 00:04:39,060
それを m1 と呼びます。

86
00:04:40,100 --> 00:04:43,790
次に、列 0,1 および 2,0 を持つ行列を取得します。

87
00:04:43,790 --> 00:04:45,700
その変換は次のようになります。

88
00:04:47,520 --> 00:04:49,240
その男を m2 と呼びましょう。

89
00:04:49,920 --> 00:04:52,850
m1 を適用してから m2 を適用する合計の効果により、 

90
00:04:52,850 --> 00:04:55,680
新しい変換が得られるので、その行列を見つけてみましょう。

91
00:04:56,280 --> 00:05:00,210
ただし今回は、アニメーションを見ずに、各行列の数値入力 

92
00:05:00,210 --> 00:05:03,860
だけを使用してそれができるかどうかを見てみましょう。

93
00:05:04,740 --> 00:05:07,140
まず、i-hat がどこに行くのかを把握する必要があります。

94
00:05:08,040 --> 00:05:12,077
m1 を適用した後、i-hat の新しい座標は、定義により 

95
00:05:12,077 --> 00:05:15,980
、m1 の最初の列、つまり 1,1 によって与えられます。

96
00:05:16,780 --> 00:05:20,482
m2 を適用した後に何が起こるかを確認するには、m2 

97
00:05:20,482 --> 00:05:23,500
の行列にそのベクトル 1,1 を乗算します。

98
00:05:25,300 --> 00:05:28,480
前回のビデオで説明した方法で計算すると、ベクトル 

99
00:05:28,480 --> 00:05:29,880
2,1 が得られます。

100
00:05:30,700 --> 00:05:33,100
これは、構成マトリックスの最初の列になります。

101
00:05:34,520 --> 00:05:37,641
同様に、j-hat に従うと、m1 の 2 番目の列は 

102
00:05:37,641 --> 00:05:40,540
、最初に負の 2,0 に到達することを示しています。

103
00:05:42,700 --> 00:05:46,807
次に、そのベクトルに m2 を適用すると、行列

104
00:05:46,807 --> 00:05:50,200
ベクトルの積を計算して 0、負の 2 

105
00:05:50,200 --> 00:05:55,200
を得ることができ、これが合成行列の 2 列目になります。

106
00:05:56,640 --> 00:05:59,400
同じプロセスをもう一度説明しますが、今回は

107
00:05:59,400 --> 00:06:02,160
、同じ推論がどの行列 でも機能することを示

108
00:06:02,160 --> 00:06:04,920
すために、各行列の変数エントリを示します。

109
00:06:05,540 --> 00:06:08,246
これはシンボルが多くなり、もう少しスペースが必要に

110
00:06:08,246 --> 00:06:10,953
なりますが、以前に行列の 乗算をより暗記的な方法で

111
00:06:10,953 --> 00:06:13,660
教えられた人にとっては、かなり満足できるはずです。

112
00:06:14,460 --> 00:06:16,627
i-hat がどこへ行くのかを追跡するには、

113
00:06:16,627 --> 00:06:18,498
まず右側の行列の最初の 列を調べます。

114
00:06:18,498 --> 00:06:21,060
これは、i-hat が最初に着地する場所だからです。

115
00:06:22,000 --> 00:06:24,449
その列に左側の行列を乗算すると、2 

116
00:06:24,449 --> 00:06:27,034
番目の変換を適用した後に i-hat 

117
00:06:27,034 --> 00:06:30,300
の中間バージョンがどこに到達するかがわかります。

118
00:06:31,620 --> 00:06:34,935
したがって、合成行列の最初の列は常に、左行 

119
00:06:34,935 --> 00:06:38,100
列と右行列の最初の列の積に等しくなります。

120
00:06:42,160 --> 00:06:45,329
同様に、j-hat は常に最初は右行列の 

121
00:06:45,329 --> 00:06:47,140
2 列目に配置されます。

122
00:06:48,940 --> 00:06:50,796
したがって、左の行列にこの 2 

123
00:06:50,796 --> 00:06:52,768
番目の列を乗算すると、その最終的 

124
00:06:52,768 --> 00:06:55,088
な位置が得られるため、それが合成行列の 

125
00:06:55,088 --> 00:06:56,480
2 番目の列になります。

126
00:06:56,480 --> 00:07:00,068
ここにはたくさんの記号があることに注意してください。

127
00:07:00,068 --> 00:07:02,829
この公式は暗記するものとして教えられる 

128
00:07:02,829 --> 00:07:05,865
のが一般的であり、それを覚えるのに役立つ特定

129
00:07:05,865 --> 00:07:09,040
のアルゴリズムのプロセスも一緒に教えられます。

130
00:07:09,160 --> 00:07:12,452
しかし、そのプロセスを暗記する前に、行列の乗算 

131
00:07:12,452 --> 00:07:15,744
が実際に何を表し、変換を次々と適用するかを考え 

132
00:07:15,744 --> 00:07:18,900
る習慣を身につけるべきだと私は心から思います。

133
00:07:19,620 --> 00:07:23,075
信じてください。これにより、行列の乗算の特性をはるかに理解 

134
00:07:23,075 --> 00:07:26,300
しやすくする、より優れた概念フレームワークが得られます。

135
00:07:27,060 --> 00:07:28,360
たとえば、こんな質問があります。

136
00:07:28,880 --> 00:07:30,860
2 つの行列を乗算するときにそれら

137
00:07:30,860 --> 00:07:32,840
をどの順序で置くかは重要ですか? 

138
00:07:33,620 --> 00:07:37,000
さて、先ほどのような簡単な例で考えてみましょう。

139
00:07:37,640 --> 00:07:39,787
i-hat を固定し、j-hat 

140
00:07:39,787 --> 00:07:42,820
を右に押しつぶすハサミを 90 度回転させます。

141
00:07:43,600 --> 00:07:47,280
最初にせん断を行ってから回転すると、i-hat が 0,1 

142
00:07:47,280 --> 00:07:50,960
になり、j-hat が負の 1,1 になることがわかります。

143
00:07:51,320 --> 00:07:53,060
両方は通常、近くを指しています。

144
00:07:53,860 --> 00:07:57,533
最初に回転してからせん断を行うと、i-hat 

145
00:07:57,533 --> 00:08:01,047
は 1,1 で終了し、j- hat は負の 

146
00:08:01,047 --> 00:08:05,520
1,0 で別の方向にずれて、さらに離れた方向を指します。

147
00:08:06,380 --> 00:08:09,409
ここでの全体的な効果は明らかに異なる

148
00:08:09,409 --> 00:08:12,440
ため、明らかに順序が完全に重要です。

149
00:08:12,700 --> 00:08:15,405
変換という観点から考えると、視覚化する 

150
00:08:15,405 --> 00:08:17,840
ことで頭の中でできるようなことです。

151
00:08:18,220 --> 00:08:19,900
行列の乗算は必要ありません。

152
00:08:21,480 --> 00:08:25,372
私が初めて線形代数を履修したとき、行列の乗算が結合的 

153
00:08:25,372 --> 00:08:29,120
であることを証明するという宿題が 1 つありました。

154
00:08:29,560 --> 00:08:31,500
これは、A、B、C という 3 

155
00:08:31,500 --> 00:08:34,655
つの行列があり、それらをすべて乗算する場合、最初に 

156
00:08:34,655 --> 00:08:37,081
A と B を掛けてからその結果を C 

157
00:08:37,081 --> 00:08:39,628
で乗算するか、最初に B を乗算するかは 

158
00:08:39,628 --> 00:08:41,691
問題ではないことを意味します。C 

159
00:08:41,691 --> 00:08:44,360
を計算し、その結果に左側の A を掛けます。

160
00:08:44,940 --> 00:08:47,400
つまり、括弧をどこに入れても問題ありません。

161
00:08:48,380 --> 00:08:50,764
さて、当時の私のようにこれを数値的に解明し

162
00:08:50,764 --> 00:08:53,148
ようとすると、それは恐 ろしい、まったく恐

163
00:08:53,148 --> 00:08:55,760
ろしく、その点においては啓発的ではありません。

164
00:08:55,760 --> 00:08:59,410
しかし、行列の乗算を 1 つの変換を次々に適用する 

165
00:08:59,410 --> 00:09:02,780
ものと考えると、この性質は単なる些細なものです。

166
00:09:03,300 --> 00:09:04,000
理由がわかりますか? 

167
00:09:04,860 --> 00:09:07,492
何を言っているのかというと、最初に C を適用し、次に 

168
00:09:07,492 --> 00:09:09,842
B、次に A を適用した 場合、それは C、次に 

169
00:09:09,842 --> 00:09:12,380
B、次に A を適用したのと同じであるということです。

170
00:09:12,820 --> 00:09:15,799
つまり、証明するものは何もなく、同じ 3 つのこ 

171
00:09:15,799 --> 00:09:18,660
とをすべて同じ順序で順番に適用しているだけです。

172
00:09:19,460 --> 00:09:20,468
これは不正行為のように感じるかも

173
00:09:20,468 --> 00:09:21,540
しれませんが、そうではありません。

174
00:09:21,540 --> 00:09:25,900
これは、行列の乗算が結合的であるという正直な証明です。

175
00:09:25,900 --> 00:09:28,221
そしてそれ以上に、それはその特性が

176
00:09:28,221 --> 00:09:30,680
真である理由をうまく説明しています。

177
00:09:31,560 --> 00:09:35,277
このアイデアをもっと試してみることをお勧めします 。

178
00:09:35,277 --> 00:09:38,708
2 つの異なる変換を想像し、交互に適用すると何 

179
00:09:38,708 --> 00:09:42,140
が起こるかを考え、行列の積を数値的に計算します。

180
00:09:42,600 --> 00:09:44,520
信じてください、これはアイデアを

181
00:09:44,520 --> 00:09:46,440
本当に浸透させる一種の遊びです。

182
00:09:47,200 --> 00:09:49,310
次のビデオでは、これらのアイデアを単なる 2 

183
00:09:49,310 --> 00:09:51,420
次元を超えて拡張することについて話し始めます。

184
00:09:52,020 --> 00:09:52,180
それではまた！

