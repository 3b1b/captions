1
00:00:11,109 --> 00:00:14,798
皆さん、前回の続きで、線形変換がどのようなものなのか、そ

2
00:00:14,798 --> 00:00:18,360
して行列を使用して線形変換を表現する方法を説明しました。

3
00:00:18,360 --> 00:00:21,000
これは本当に重要なことなので、簡単に要約する価値が

4
00:00:21,000 --> 00:00:23,640
ありますが、もちろん、こ れが単なる要約以上のもの

5
00:00:23,640 --> 00:00:26,280
だと感じた場合は、戻ってビデオ全体を見てください。

6
00:00:26,280 --> 00:00:30,275
一般的に、線形変換は入力としてベクト

7
00:00:30,275 --> 00:00:34,270
ル、出力としてベクトルを持つ関数です

8
00:00:34,270 --> 00:00:38,265
が、前回、グリッド線が平行で等間隔に

9
00:00:38,265 --> 00:00:41,840
保たれ、原点が固定されたままです。

10
00:00:41,840 --> 00:00:44,927
重要な点は、線形変換は空間の基底ベクトル (2

11
00:00:44,927 --> 00:00:48,786
次元の場合は i-hat と j -hat を意味します)

12
00:00:48,786 --> 00:00:52,260
をどこに取るかによって完全に決定されるということです。

13
00:00:52,260 --> 00:00:55,179
これは、他のベクトルはそれらの基底ベクト

14
00:00:55,179 --> 00:00:57,820
ルの線形結合として記述できるためです。

15
00:00:57,820 --> 00:01:00,586
座標 x、y を持つベクトルは、x に i-hat

16
00:01:00,586 --> 00:01:03,460
を掛けたものに、y に j-hat を掛けたものです。

17
00:01:03,460 --> 00:01:07,172
変換を経た後、グリッド線が平行かつ等間隔に保たれる

18
00:01:07,172 --> 00:01:10,600
というこの特性は、素晴らしい結果をもたらします。

19
00:01:10,600 --> 00:01:12,856
ベクトルが着地する場所は、i-hat

20
00:01:12,856 --> 00:01:15,470
の変換バージョンの x 倍に 、j-hat

21
00:01:15,470 --> 00:01:18,440
の変換バージョンの y 倍を加えた場所になります。

22
00:01:18,440 --> 00:01:21,546
これは、i-hat が着地する座標と j-hat

23
00:01:21,546 --> 00:01:24,156
が着地する座標を記録しておくと、 x、y

24
00:01:24,156 --> 00:01:26,641
で始まるベクトルは、i-hat に y

25
00:01:26,641 --> 00:01:28,753
を加えた新しい座標の x 倍の位

26
00:01:28,753 --> 00:01:31,363
置に着地する必要があることを計算できます。

27
00:01:31,363 --> 00:01:33,600
j-hat の新しい座標を倍します。

28
00:01:33,600 --> 00:01:37,874
慣例では、i ハットと j ハットが配置される場所の座標を

29
00:01:37,874 --> 00:01:42,148
行列の列として記録し、これらの列を x と y でスケーリ

30
00:01:42,148 --> 00:01:46,280
ングしたものの合計を行列とベクトルの乗算として定義します。

31
00:01:46,280 --> 00:01:50,200
このように、行列は特定の線形変換を表し、行列

32
00:01:50,200 --> 00:01:54,120
にベクトルを乗算するこ とは、その変換をその

33
00:01:54,120 --> 00:01:58,040
ベクトルに適用することを計算的に意味します。

34
00:01:58,040 --> 00:02:01,760
さて、おさらいして新しい内容に移りましょう。

35
00:02:01,760 --> 00:02:04,860
ある変換を適用してから別の変換を適用した場

36
00:02:04,860 --> 00:02:07,680
合の効果を説明したい場合がよくあります。

37
00:02:07,680 --> 00:02:11,630
たとえば、最初に平面を反時計回りに 90 度回転し、次

38
00:02:11,630 --> 00:02:15,440
にシアーを適用すると何が起こるかを説明したいとします。

39
00:02:15,440 --> 00:02:19,159
ここでの全体的な効果は、最初から最後まで、

40
00:02:19,159 --> 00:02:22,540
回転やせん断とは異なる別の線形変換です。

41
00:02:22,540 --> 00:02:25,873
この新しい線形変換は、一般に、適用した

42
00:02:25,873 --> 00:02:29,040
2 つの別々の変換の合成と呼ばれます。

43
00:02:29,040 --> 00:02:32,725
そして、他の線形変換と同様に、i-hat と j-ha

44
00:02:32,725 --> 00:02:36,280
t に従って、それ自体の行列で記述することができます。

45
00:02:36,280 --> 00:02:40,697
この例では、両方の変換後の i-hat の最終的な着地

46
00:02:40,697 --> 00:02:44,800
点は 1,1 なので、これを行列の最初の列にします。

47
00:02:44,800 --> 00:02:48,953
同様に、j-hat は最終的にマイナス 1,0 の位

48
00:02:48,953 --> 00:02:52,800
置に到達するため、それを行列の 2 列目にします。

49
00:02:52,800 --> 00:02:56,237
この新しいマトリックスは、回転とせん断を適用した

50
00:02:56,237 --> 00:02:58,959
場合の全体的な効果を、連続 した 2

51
00:02:58,959 --> 00:03:02,397
つのアクションではなく 1 つのアクションとして

52
00:03:02,397 --> 00:03:03,400
捉えています。

53
00:03:03,400 --> 00:03:04,597
この新しいマトリックスについて考える

54
00:03:04,597 --> 00:03:05,480
1 つの方法を次に示します。

55
00:03:05,480 --> 00:03:08,873
ベクトルを取得し、それを回転、次にせん断を通してポ

56
00:03:08,873 --> 00:03:12,267
ンプする場合、最終的にどこに到達するかを計算する長

57
00:03:12,267 --> 00:03:15,400
い方法は、まず左側で回転行列を乗算することです。

58
00:03:15,400 --> 00:03:20,520
次に、得られたものをすべて取り、左側にせん断行列を掛けます。

59
00:03:20,520 --> 00:03:23,900
これは、数値的に言えば、特定のベクトルに回転を

60
00:03:23,900 --> 00:03:27,000
加えてからせん断を適用することを意味します。

61
00:03:27,000 --> 00:03:30,830
しかし、得られるものは何であれ、選択したベクトルに関係なく

62
00:03:30,830 --> 00:03:34,661
、同じベクトルで見つ けたこの新しい合成行列を適用したのと

63
00:03:34,661 --> 00:03:37,568
同じであるはずです。この新しい行列は、回転

64
00:03:37,568 --> 00:03:41,398
とせん断アクションと同じ全体的な効果をキャプチャすることに

65
00:03:41,398 --> 00:03:42,720
なっているためです。

66
00:03:42,720 --> 00:03:46,764
ここでの書き方からすると、この新しい行列を元の

67
00:03:46,764 --> 00:03:50,640
2 つの行列の積と呼ぶのが妥当だと思いますね。

68
00:03:50,640 --> 00:03:52,871
その積をより一般的に計算する方法については

69
00:03:52,871 --> 00:03:55,102
すぐに考えることができ ますが、あまりにも

70
00:03:55,102 --> 00:03:57,440
簡単に数値の森の中で迷子になってしまいます。

71
00:03:57,440 --> 00:04:00,406
このように 2 つの行列を乗算することには、ある

72
00:04:00,406 --> 00:04:03,373
変換を適用してから別の変 換を適用するという幾何

73
00:04:03,373 --> 00:04:06,340
学的な意味があることを常に覚えておいてください。

74
00:04:06,340 --> 00:04:10,080
ここで少し奇妙なのは、右から左に読むことになることです。

75
00:04:10,080 --> 00:04:13,931
まず右側の行列で表される変換を適用し、次

76
00:04:13,931 --> 00:04:17,600
に左側の行列で表される変換を適用します。

77
00:04:17,600 --> 00:04:19,899
これは関数の表記法に由来しています。

78
00:04:19,899 --> 00:04:22,327
変数の左側に関数を記述するため 、2

79
00:04:22,327 --> 00:04:26,160
つの関数を構成するたびに、常に右から左に読む必要があります。

80
00:04:26,160 --> 00:04:28,076
ヘブライ語の読者にとっては良いニュースですが

81
00:04:28,076 --> 00:04:30,080
、それ以外の私たちにとっては悪いニュースです。

82
00:04:30,080 --> 00:04:31,880
別の例を見てみましょう。

83
00:04:31,880 --> 00:04:35,805
列 1,1 と負の 2,0 を持つ行列を考えます。

84
00:04:35,805 --> 00:04:38,160
その変換は次のようになります。

85
00:04:38,160 --> 00:04:40,000
それを m1 と呼びます。

86
00:04:40,000 --> 00:04:43,954
次に、列 0,1 および 2,0 を持つ行列を取得します。

87
00:04:43,954 --> 00:04:46,000
その変換は次のようになります。

88
00:04:46,000 --> 00:04:50,040
その男を m2 と呼びましょう。

89
00:04:50,040 --> 00:04:53,357
m1 を適用してから m2 を適用する合計の効果により、

90
00:04:53,357 --> 00:04:56,560
新しい変換が得られるので、その行列を見つけてみましょう。

91
00:04:56,560 --> 00:05:00,666
ただし今回は、アニメーションを見ずに、各行列の数値入力

92
00:05:00,666 --> 00:05:04,480
だけを使用してそれができるかどうかを見てみましょう。

93
00:05:04,480 --> 00:05:08,040
まず、i-hat がどこに行くのかを把握する必要があります。

94
00:05:08,040 --> 00:05:12,575
m1 を適用した後、i-hat の新しい座標は、定義により

95
00:05:12,575 --> 00:05:16,960
、m1 の最初の列、つまり 1,1 によって与えられます。

96
00:05:16,960 --> 00:05:20,817
m2 を適用した後に何が起こるかを確認するには、m2

97
00:05:20,817 --> 00:05:23,960
の行列にそのベクトル 1,1 を乗算します。

98
00:05:23,960 --> 00:05:28,751
前回のビデオで説明した方法で計算すると、ベクトル

99
00:05:28,751 --> 00:05:30,860
2,1 が得られます。

100
00:05:30,860 --> 00:05:33,960
これは、構成マトリックスの最初の列になります。

101
00:05:33,960 --> 00:05:38,128
同様に、j-hat に従うと、m1 の 2 番目の列は

102
00:05:38,128 --> 00:05:42,000
、最初に負の 2,0 に到達することを示しています。

103
00:05:42,000 --> 00:05:46,941
次に、そのベクトルに m2 を適用すると、行列

104
00:05:46,941 --> 00:05:51,024
ベクトルの積を計算して 0、負の 2

105
00:05:51,024 --> 00:05:57,040
を得ることができ、これが合成行列の 2 列目になります。

106
00:05:57,040 --> 00:05:59,900
同じプロセスをもう一度説明しますが、今回は

107
00:05:59,900 --> 00:06:02,760
、同じ推論がどの行列 でも機能することを示

108
00:06:02,760 --> 00:06:05,620
すために、各行列の変数エントリを示します。

109
00:06:05,620 --> 00:06:08,606
これはシンボルが多くなり、もう少しスペースが必要に

110
00:06:08,606 --> 00:06:11,593
なりますが、以前に行列の 乗算をより暗記的な方法で

111
00:06:11,593 --> 00:06:14,580
教えられた人にとっては、かなり満足できるはずです。

112
00:06:14,580 --> 00:06:17,160
i-hat がどこへ行くのかを追跡するには、

113
00:06:17,160 --> 00:06:19,389
まず右側の行列の最初の 列を調べます。

114
00:06:19,389 --> 00:06:22,440
これは、i-hat が最初に着地する場所だからです。

115
00:06:22,440 --> 00:06:25,196
その列に左側の行列を乗算すると、2

116
00:06:25,196 --> 00:06:28,105
番目の変換を適用した後に i-hat

117
00:06:28,105 --> 00:06:31,780
の中間バージョンがどこに到達するかがわかります。

118
00:06:31,780 --> 00:06:35,668
したがって、合成行列の最初の列は常に、左行

119
00:06:35,668 --> 00:06:39,380
列と右行列の最初の列の積に等しくなります。

120
00:06:39,380 --> 00:06:43,834
同様に、j-hat は常に最初は右行列の

121
00:06:43,834 --> 00:06:46,380
2 列目に配置されます。

122
00:06:46,380 --> 00:06:49,914
したがって、左の行列にこの 2

123
00:06:49,914 --> 00:06:53,670
番目の列を乗算すると、その最終的

124
00:06:53,670 --> 00:06:58,088
な位置が得られるため、それが合成行列の

125
00:06:58,088 --> 00:07:00,740
2 番目の列になります。

126
00:07:00,740 --> 00:07:03,191
ここにはたくさんの記号があることに注意してください。

127
00:07:03,191 --> 00:07:05,077
この公式は暗記するものとして教えられる

128
00:07:05,077 --> 00:07:07,151
のが一般的であり、それを覚えるのに役立つ特定

129
00:07:07,151 --> 00:07:09,320
のアルゴリズムのプロセスも一緒に教えられます。

130
00:07:09,320 --> 00:07:12,815
しかし、そのプロセスを暗記する前に、行列の乗算

131
00:07:12,815 --> 00:07:16,310
が実際に何を表し、変換を次々と適用するかを考え

132
00:07:16,310 --> 00:07:19,660
る習慣を身につけるべきだと私は心から思います。

133
00:07:19,660 --> 00:07:23,539
信じてください。これにより、行列の乗算の特性をはるかに理解

134
00:07:23,539 --> 00:07:27,160
しやすくする、より優れた概念フレームワークが得られます。

135
00:07:27,160 --> 00:07:29,080
たとえば、こんな質問があります。

136
00:07:29,080 --> 00:07:31,280
2 つの行列を乗算するときにそれら

137
00:07:31,280 --> 00:07:33,480
をどの順序で置くかは重要ですか?

138
00:07:33,480 --> 00:07:37,760
さて、先ほどのような簡単な例で考えてみましょう。

139
00:07:37,760 --> 00:07:40,222
i-hat を固定し、j-hat

140
00:07:40,222 --> 00:07:43,700
を右に押しつぶすハサミを 90 度回転させます。

141
00:07:43,700 --> 00:07:47,590
最初にせん断を行ってから回転すると、i-hat が 0,1

142
00:07:47,590 --> 00:07:51,480
になり、j-hat が負の 1,1 になることがわかります。

143
00:07:51,480 --> 00:07:54,000
両方は通常、近くを指しています。

144
00:07:54,000 --> 00:07:57,919
最初に回転してからせん断を行うと、i-hat

145
00:07:57,919 --> 00:08:01,668
は 1,1 で終了し、j- hat は負の

146
00:08:01,668 --> 00:08:06,440
1,0 で別の方向にずれて、さらに離れた方向を指します。

147
00:08:06,440 --> 00:08:09,460
ここでの全体的な効果は明らかに異なる

148
00:08:09,460 --> 00:08:12,480
ため、明らかに順序が完全に重要です。

149
00:08:12,480 --> 00:08:15,574
変換という観点から考えると、視覚化する

150
00:08:15,574 --> 00:08:18,360
ことで頭の中でできるようなことです。

151
00:08:18,360 --> 00:08:21,800
行列の乗算は必要ありません。

152
00:08:21,800 --> 00:08:25,865
私が初めて線形代数を履修したとき、行列の乗算が結合的

153
00:08:25,865 --> 00:08:29,780
であることを証明するという宿題が 1 つありました。

154
00:08:29,780 --> 00:08:31,783
これは、A、B、C という 3

155
00:08:31,783 --> 00:08:35,040
つの行列があり、それらをすべて乗算する場合、最初に

156
00:08:35,040 --> 00:08:37,545
A と B を掛けてからその結果を C

157
00:08:37,545 --> 00:08:40,175
で乗算するか、最初に B を乗算するかは

158
00:08:40,175 --> 00:08:42,304
問題ではないことを意味します。C

159
00:08:42,304 --> 00:08:45,060
を計算し、その結果に左側の A を掛けます。

160
00:08:45,060 --> 00:08:48,100
つまり、括弧をどこに入れても問題ありません。

161
00:08:48,100 --> 00:08:50,788
さて、当時の私のようにこれを数値的に解明し

162
00:08:50,788 --> 00:08:53,476
ようとすると、それは恐 ろしい、まったく恐

163
00:08:53,476 --> 00:08:56,420
ろしく、その点においては啓発的ではありません。

164
00:08:56,420 --> 00:09:00,080
しかし、行列の乗算を 1 つの変換を次々に適用する

165
00:09:00,080 --> 00:09:03,460
ものと考えると、この性質は単なる些細なものです。

166
00:09:03,460 --> 00:09:05,060
理由がわかりますか?

167
00:09:05,060 --> 00:09:07,860
何を言っているのかというと、最初に C を適用し、次に

168
00:09:07,860 --> 00:09:10,360
B、次に A を適用した 場合、それは C、次に

169
00:09:10,360 --> 00:09:13,060
B、次に A を適用したのと同じであるということです。

170
00:09:13,060 --> 00:09:16,437
つまり、証明するものは何もなく、同じ 3 つのこ

171
00:09:16,437 --> 00:09:19,680
とをすべて同じ順序で順番に適用しているだけです。

172
00:09:19,680 --> 00:09:20,843
これは不正行為のように感じるかも

173
00:09:20,843 --> 00:09:22,080
しれませんが、そうではありません。

174
00:09:22,080 --> 00:09:26,360
これは、行列の乗算が結合的であるという正直な証明です。

175
00:09:26,360 --> 00:09:29,012
そしてそれ以上に、それはその特性が

176
00:09:29,012 --> 00:09:31,820
真である理由をうまく説明しています。

177
00:09:31,820 --> 00:09:35,642
このアイデアをもっと試してみることをお勧めします 。

178
00:09:35,642 --> 00:09:39,171
2 つの異なる変換を想像し、交互に適用すると何

179
00:09:39,171 --> 00:09:42,700
が起こるかを考え、行列の積を数値的に計算します。

180
00:09:42,700 --> 00:09:45,080
信じてください、これはアイデアを

181
00:09:45,080 --> 00:09:47,460
本当に浸透させる一種の遊びです。

182
00:09:47,460 --> 00:09:49,760
次のビデオでは、これらのアイデアを単なる 2

183
00:09:49,760 --> 00:09:52,060
次元を超えて拡張することについて話し始めます。

184
00:09:52,060 --> 00:09:52,560
それではまた！

