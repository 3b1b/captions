1
00:00:10,940 --> 00:00:13,982
大家好，在我们上次停下的地方，我展示了线 

2
00:00:13,982 --> 00:00:16,880
性变换的样子以及如何使用矩阵来表示它们。

3
00:00:18,320 --> 00:00:21,802
这值得快速回顾一下，因为它非常重要，但当然，如 

4
00:00:21,802 --> 00:00:25,140
果这感觉不仅仅是回顾，请返回并观看完整的视频。

5
00:00:25,779 --> 00:00:29,813
一般来说，线性变换是以向量作为输入、以向量 

6
00:00:29,813 --> 00:00:33,663
作为输出的函数，但我上次展示了如何在视觉 

7
00:00:33,663 --> 00:00:37,513
上将它们视为在空间中平滑移动，从而使网格 

8
00:00:37,513 --> 00:00:41,180
线保持平行且均匀间隔，并且原点保持固定。

9
00:00:41,820 --> 00:00:46,770
关键要点是线性变换完全取决于它采用空间基向量的位置 

10
00:00:46,770 --> 00:00:51,340
，这对于二维意味着 i-hat 和 j-hat。

11
00:00:51,340 --> 00:00:57,340
这是因为任何其他向量都可以描 述为这些基向量的线性组合。

12
00:00:57,940 --> 00:01:00,083
坐标为 x、y 的向量等于 x 乘以 

13
00:01:00,083 --> 00:01:02,340
i-hat 加上 y 乘以 j-hat。

14
00:01:03,460 --> 00:01:06,763
经过变换后，网格线保持平行且间 

15
00:01:06,763 --> 00:01:09,860
隔均匀的特性产生了奇妙的结果。

16
00:01:10,500 --> 00:01:14,030
矢量降落的位置将是 i-hat 变换版本的 

17
00:01:14,030 --> 00:01:17,560
x 倍加上 j-hat 变换版本的 y 倍。

18
00:01:18,240 --> 00:01:21,898
这意味着，如果您记录 i-hat 落在的坐标和 

19
00:01:21,898 --> 00:01:25,556
j-hat 落 在的坐标，您可以计算出从 x, 

20
00:01:25,556 --> 00:01:29,214
y 开始的向量必须落在 x 乘 以 i-hat 

21
00:01:29,214 --> 00:01:32,720
的新坐标加 y 上乘以 j-hat 的新坐标。

22
00:01:33,560 --> 00:01:37,176
约定是将 i-hat 和 j-hat 

23
00:01:37,176 --> 00:01:41,172
落地 的坐标记录为矩阵的列，并将这些列按 

24
00:01:41,172 --> 00:01:45,360
x 和 y 缩放后的总和定义为矩阵向量乘法。

25
00:01:46,050 --> 00:01:51,699
这样，矩阵表示特定的线性变换，将矩阵乘以 

26
00:01:51,699 --> 00:01:57,080
向量就是将该变换应用于该向量的计算意义。

27
00:01:58,800 --> 00:02:00,880
好了，回顾一下，开始新内容。

28
00:02:01,600 --> 00:02:04,381
通常，您会发现自己想要描述应用一 

29
00:02:04,381 --> 00:02:07,000
种转换然后应用另一种转换的效果。

30
00:02:07,620 --> 00:02:11,213
例如，也许您想要描述当您首先将平面逆时针旋 

31
00:02:11,213 --> 00:02:14,480
转 90 度，然后应用剪切时会发生什么。

32
00:02:15,260 --> 00:02:18,722
这里的整体效果，从开始到结束，是另 

33
00:02:18,722 --> 00:02:21,800
一种线性变换，与旋转和剪切不同。

34
00:02:22,280 --> 00:02:28,220
这种新的线性变换通常称为我们 应用的两个单独变换的组合。

35
00:02:28,920 --> 00:02:32,255
与任何线性变换一样，它可以通过遵循 i-h 

36
00:02:32,255 --> 00:02:35,440
at 和 j-hat 用自己的矩阵来描述。

37
00:02:36,020 --> 00:02:40,246
在此示例中，两次转换后 i-hat 的最终着陆 

38
00:02:40,246 --> 00:02:44,120
点是 1,1，因此我们将其作为矩阵的第一列。

39
00:02:44,960 --> 00:02:48,503
同样，j-hat 最终位于负 1,0 

40
00:02:48,503 --> 00:02:51,860
位置，因此我们将其作为矩阵的第二列。

41
00:02:52,680 --> 00:02:57,206
这个新矩阵捕捉了应用旋转然后剪切的整体效果， 

42
00:02:57,206 --> 00:03:01,340
但作为一个单一动作，而不是两个连续的动作。

43
00:03:03,040 --> 00:03:04,880
这是思考新矩阵的一种方法。

44
00:03:05,420 --> 00:03:08,612
如果你要获取一些向量并通过旋转泵送 

45
00:03:08,612 --> 00:03:11,804
它，那么剪切，计算它最终的位置的长 

46
00:03:11,804 --> 00:03:14,820
方法是首先将它在左侧乘以旋转矩阵。

47
00:03:15,320 --> 00:03:19,800
然后，将得到的值乘以左侧的剪切矩阵。

48
00:03:20,460 --> 00:03:26,060
从数字上来说，这就是对给定向 量应用旋转然后剪切的含义。

49
00:03:26,800 --> 00:03:31,588
但是无论您得到什么，都应该与应用我们刚刚通过同一向 

50
00:03:31,588 --> 00:03:36,376
量找到的新合成矩阵相同，无论您选择什么向量，因为这 

51
00:03:36,376 --> 00:03:40,980
个新矩阵应该捕获与旋转然后剪切动作相同的整体效果。

52
00:03:42,480 --> 00:03:46,111
根据这里的写法，我认为将这个新矩阵称为 

53
00:03:46,111 --> 00:03:49,380
原始两个矩阵的乘积是合理的，不是吗？

54
00:03:50,420 --> 00:03:53,598
我们可以立即考虑如何更普遍地计算该 

55
00:03:53,598 --> 00:03:56,600
乘积，但很容易迷失在数字的森林中。

56
00:03:56,600 --> 00:04:00,538
永远记住，像这样的两个矩阵相乘具有先应 

57
00:04:00,538 --> 00:04:04,280
用一种变换再应用另一种变换的几何意义。

58
00:04:05,860 --> 00:04:09,660
这里有点奇怪的一件事是我们从右向左阅读。

59
00:04:10,040 --> 00:04:16,720
首先应用右侧矩阵表示的变换， 然后应用左侧矩阵表示的变换。

60
00:04:17,399 --> 00:04:21,591
这源于函数表示法，因为我们将函数写在变量的左侧，所 

61
00:04:21,591 --> 00:04:25,460
以每次组合两个函数时，您总是必须从右到左读取它。

62
00:04:25,920 --> 00:04:27,400
对于希伯来语读者来说是个好消息

63
00:04:27,400 --> 00:04:28,980
，对于我们其他人来说则是坏消息。

64
00:04:29,880 --> 00:04:31,100
让我们看另一个例子。

65
00:04:31,760 --> 00:04:36,860
取第 1,1 列和第 2,0 列为负的矩阵，其变换如下所示。

66
00:04:37,980 --> 00:04:39,060
我们称之为 m1。

67
00:04:40,100 --> 00:04:43,425
接下来，采用具有 0,1 和 2,0 

68
00:04:43,425 --> 00:04:45,700
列的矩阵，其变换如下所示。

69
00:04:47,520 --> 00:04:49,240
我们称那个人为m2。

70
00:04:49,920 --> 00:04:52,937
应用 m1 然后 m2 的总效果为我们提供 

71
00:04:52,937 --> 00:04:55,680
了一个新的变换，所以让我们找到它的矩阵。

72
00:04:56,280 --> 00:05:00,234
但这一次，让我们看看是否可以在不观看动画的情况 

73
00:05:00,234 --> 00:05:03,860
下做到这一点，而只使用每个矩阵中的数字条目。

74
00:05:04,740 --> 00:05:07,140
首先，我们需要弄清楚 i-hat 的去向。

75
00:05:08,040 --> 00:05:12,102
应用 m1 后，根据定义，i-hat 的新 

76
00:05:12,102 --> 00:05:15,980
坐标由 m1 的第一列（即 1,1）给出。

77
00:05:16,780 --> 00:05:20,428
要查看应用 m2 后会发生什么，请将 

78
00:05:20,428 --> 00:05:23,500
m2 的矩阵乘以该向量 1,1。

79
00:05:25,300 --> 00:05:29,880
按照我上一个视频描述的方式进行计算，您将得到向量 2,1。

80
00:05:30,700 --> 00:05:33,100
这将是组成矩阵的第一列。

81
00:05:34,520 --> 00:05:37,611
同样，遵循 j-hat，m1 的第二 

82
00:05:37,611 --> 00:05:40,540
列告诉我们它首先落在负 2,0 上。

83
00:05:42,700 --> 00:05:49,059
然后，当我们将 m2 应用于该向量时，您可以计算出矩阵向 

84
00:05:49,059 --> 00:05:55,200
量乘积，得到 0，负 2，这成为我们的复合矩阵的第二列。

85
00:05:56,640 --> 00:06:00,939
让我再次讨论相同的过程，但这次我将显示每个矩阵中的变 

86
00:06:00,939 --> 00:06:04,920
量条目，只是为了表明相同的推理过程适用于任何矩阵。

87
00:06:05,540 --> 00:06:09,668
这需要更多的符号，并且需要更多的空间，但是对于以前以更死记 

88
00:06:09,668 --> 00:06:13,660
硬背的方式学习过矩阵乘法的人来说，它应该是非常令人满意的。

89
00:06:14,460 --> 00:06:17,897
要跟踪 i-hat 的去向，请首先查看右侧矩阵的 

90
00:06:17,897 --> 00:06:21,060
第一列，因为这是 i-hat 最初落地的位置。

91
00:06:22,000 --> 00:06:26,330
将该列乘以左侧的矩阵，您就可以知道应用第二次转 

92
00:06:26,330 --> 00:06:30,300
换后 i-hat 的中间版本最终出现在哪里。

93
00:06:31,620 --> 00:06:38,100
因此，合成矩阵的第一列始终等 于左矩阵乘以右矩阵的第一列。

94
00:06:42,160 --> 00:06:47,140
同样，j-hat 最初总是落在右侧矩阵的第二列上。

95
00:06:48,940 --> 00:06:52,919
因此，将左侧矩阵乘以第二列将给出其最 

96
00:06:52,919 --> 00:06:56,480
终位置，因此这是合成矩阵的第二列。

97
00:06:56,480 --> 00:07:03,033
请注意，这里有很多符号，通常会教授这个公式作为 

98
00:07:03,033 --> 00:07:09,040
要记住的东西，以及某种帮助记住它的算法过程。

99
00:07:09,160 --> 00:07:12,539
但我确实认为，在记住该过程之前， 

100
00:07:12,539 --> 00:07:15,918
您应该养成思考矩阵乘法真正代表什 

101
00:07:15,918 --> 00:07:18,900
么的习惯，应用一个又一个变换。

102
00:07:19,620 --> 00:07:23,055
相信我，这将为您提供一个更好的概念 

103
00:07:23,055 --> 00:07:26,300
框架，使矩阵乘法的属性更容易理解。

104
00:07:27,060 --> 00:07:28,360
例如，这是一个问题。

105
00:07:28,880 --> 00:07:32,840
当我们将两个矩阵相乘时，它们的顺序重要吗？

106
00:07:33,620 --> 00:07:37,000
好吧，让我们考虑一个简单的例子，就像前面的例子一样。

107
00:07:37,640 --> 00:07:40,230
拿一把剪刀，它可以固定 i-hat 并将 

108
00:07:40,230 --> 00:07:42,820
j-hat 压到右侧，然后旋转 90 度。

109
00:07:43,600 --> 00:07:47,352
如果你先进行剪切，然后旋转，我们可以看到 i-ha 

110
00:07:47,352 --> 00:07:50,960
t 最终为 0,1，j-hat 最终为负 1,1。

111
00:07:51,320 --> 00:07:53,060
两者通常都指向一起。

112
00:07:53,860 --> 00:07:58,084
如果你先旋转，然后进行剪切，i-hat 最终会在 

113
00:07:58,084 --> 00:08:01,971
1,1 处结束，而 j-hat 在负 1,0 

114
00:08:01,971 --> 00:08:05,520
处朝不同方向偏离，并且它们指向的距离更远。

115
00:08:06,380 --> 00:08:12,440
这里的整体效果明显不同，所以显然顺序很重要。

116
00:08:12,700 --> 00:08:15,412
请注意，通过从转换的角度思考，这就是 

117
00:08:15,412 --> 00:08:17,840
你可以通过想象在头脑中完成的事情。

118
00:08:18,220 --> 00:08:19,900
不需要矩阵乘法。

119
00:08:21,480 --> 00:08:25,491
我记得当我第一次学习线性代数时，有一个作 

120
00:08:25,491 --> 00:08:29,120
业问题要求我们证明矩阵乘法是结合律的。

121
00:08:29,560 --> 00:08:32,812
这意味着，如果您有三个矩阵 A、B 和 

122
00:08:32,812 --> 00:08:36,228
C，并且将它们全部相 乘，则无论您先计算 

123
00:08:36,228 --> 00:08:39,643
A 乘以 B，然后将结果乘以 C，还是先 

124
00:08:39,643 --> 00:08:44,360
将 B 乘以，都没有关系。C，然后将该结果乘以左边的 A。

125
00:08:44,940 --> 00:08:47,400
换句话说，括号放在哪里并不重要。

126
00:08:48,380 --> 00:08:52,142
现在，如果你尝试用数字来解决这个问题，就像我当时所 

127
00:08:52,142 --> 00:08:55,760
做的那样，那就太可怕了，太可怕了，而且毫无启发性。

128
00:08:55,760 --> 00:08:59,364
但是，当您将矩阵乘法视为应用一个又一 

129
00:08:59,364 --> 00:09:02,780
个变换时，这个属性就显得微不足道了。

130
00:09:03,300 --> 00:09:04,000
你能明白为什么吗？

131
00:09:04,860 --> 00:09:08,764
它的意思是，如果您先应用 C，然后应用 B，然后应用 

132
00:09:08,764 --> 00:09:12,380
A，则与应用 C、然后 B、然后 A 的效果相同。

133
00:09:12,820 --> 00:09:15,893
我的意思是，没有什么可以证明的，你只是 

134
00:09:15,893 --> 00:09:18,660
按照相同的顺序依次应用相同的三件事。

135
00:09:19,460 --> 00:09:21,540
这可能感觉像是作弊，但事实并非如此。

136
00:09:21,540 --> 00:09:25,900
这是矩阵乘法具有结合性的诚实证明。

137
00:09:25,900 --> 00:09:30,680
甚至更好的是，它很好地解释了为什么该属性应该是正确的。

138
00:09:31,560 --> 00:09:35,262
我真的鼓励你更多地尝试这个想法，想象两种 

139
00:09:35,262 --> 00:09:38,789
不同的变换，思考当你一个接一个地应用时 

140
00:09:38,789 --> 00:09:42,140
会发生什么，然后用数字计算出矩阵乘积。

141
00:09:42,600 --> 00:09:46,440
相信我，这样的游戏时间才能真正让这个想法深入人心。

142
00:09:47,200 --> 00:09:51,420
在下一个视频中，我将开始讨论将这些想法扩展到二维之外。

143
00:09:52,020 --> 00:09:52,180
回头见！

