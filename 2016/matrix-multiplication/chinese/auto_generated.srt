1
00:00:10,940 --> 00:00:13,982
大家好，在我们上次停下的地方，我展示了线 

2
00:00:13,982 --> 00:00:16,880
性变换的样子以及如何使用矩阵来表示它们。

3
00:00:18,320 --> 00:00:21,512
这值得快速回顾一下，因为它非常重要，但当然，

4
00:00:21,512 --> 00:00:25,140
如 果这感觉不仅仅是回顾，请返回并观看完整的视频。

5
00:00:25,779 --> 00:00:31,279
一般来说，线性变换是以向量作为输入、以向量 作为输出的函数，

6
00:00:31,279 --> 00:00:36,413
但我上次展示了如何在视觉 上将它们视为在空间中平滑移动，

7
00:00:36,413 --> 00:00:41,180
从而使网格 线保持平行且均匀间隔，并且原点保持固定。

8
00:00:41,820 --> 00:00:46,960
关键要点是线性变换完全取决于它采用空间基向量的位置 ，

9
00:00:46,960 --> 00:00:51,340
这对于二维意味着 i-hat 和 j-hat。

10
00:00:51,340 --> 00:00:57,340
这是因为任何其他向量都可以描 述为这些基向量的线性组合。

11
00:00:57,940 --> 00:01:00,083
坐标为 x、y 的向量等于 x 乘以 

12
00:01:00,083 --> 00:01:02,340
i-hat 加上 y 乘以 j-hat。

13
00:01:03,460 --> 00:01:06,763
经过变换后，网格线保持平行且间 

14
00:01:06,763 --> 00:01:09,860
隔均匀的特性产生了奇妙的结果。

15
00:01:10,500 --> 00:01:14,030
矢量降落的位置将是 i-hat 变换版本的 

16
00:01:14,030 --> 00:01:17,560
x 倍加上 j-hat 变换版本的 y 倍。

17
00:01:18,240 --> 00:01:21,898
这意味着，如果您记录 i-hat 落在的坐标和 

18
00:01:21,898 --> 00:01:25,556
j-hat 落 在的坐标，您可以计算出从 x, 

19
00:01:25,556 --> 00:01:29,214
y 开始的向量必须落在 x 乘 以 i-hat 

20
00:01:29,214 --> 00:01:32,720
的新坐标加 y 上乘以 j-hat 的新坐标。

21
00:01:33,560 --> 00:01:37,176
约定是将 i-hat 和 j-hat 

22
00:01:37,176 --> 00:01:41,172
落地 的坐标记录为矩阵的列，并将这些列按 

23
00:01:41,172 --> 00:01:45,360
x 和 y 缩放后的总和定义为矩阵向量乘法。

24
00:01:46,050 --> 00:01:51,699
这样，矩阵表示特定的线性变换，将矩阵乘以 

25
00:01:51,699 --> 00:01:57,080
向量就是将该变换应用于该向量的计算意义。

26
00:01:58,800 --> 00:02:00,880
好了，回顾一下，开始新内容。

27
00:02:01,600 --> 00:02:04,381
通常，您会发现自己想要描述应用一 

28
00:02:04,381 --> 00:02:07,000
种转换然后应用另一种转换的效果。

29
00:02:07,620 --> 00:02:12,356
例如，也许您想要描述当您首先将平面逆时针旋 转 90 度，

30
00:02:12,356 --> 00:02:14,480
然后应用剪切时会发生什么。

31
00:02:15,260 --> 00:02:20,068
这里的整体效果，从开始到结束，是另 一种线性变换，

32
00:02:20,068 --> 00:02:21,800
与旋转和剪切不同。

33
00:02:22,280 --> 00:02:28,220
这种新的线性变换通常称为我们 应用的两个单独变换的组合。

34
00:02:28,920 --> 00:02:32,255
与任何线性变换一样，它可以通过遵循 i-h 

35
00:02:32,255 --> 00:02:35,440
at 和 j-hat 用自己的矩阵来描述。

36
00:02:36,020 --> 00:02:40,246
在此示例中，两次转换后 i-hat 的最终着陆 

37
00:02:40,246 --> 00:02:44,120
点是 1,1，因此我们将其作为矩阵的第一列。

38
00:02:44,960 --> 00:02:49,062
同样，j-hat 最终位于负 1,0 位置，

39
00:02:49,062 --> 00:02:51,860
因此我们将其作为矩阵的第二列。

40
00:02:52,680 --> 00:02:57,010
这个新矩阵捕捉了应用旋转然后剪切的整体效果，

41
00:02:57,010 --> 00:03:01,340
 但作为一个单一动作，而不是两个连续的动作。

42
00:03:03,040 --> 00:03:04,880
这是思考新矩阵的一种方法。

43
00:03:05,420 --> 00:03:09,853
如果你要获取一些向量并通过旋转泵送 它，那么剪切，

44
00:03:09,853 --> 00:03:14,820
计算它最终的位置的长 方法是首先将它在左侧乘以旋转矩阵。

45
00:03:15,320 --> 00:03:19,800
然后，将得到的值乘以左侧的剪切矩阵。

46
00:03:20,460 --> 00:03:26,060
从数字上来说，这就是对给定向 量应用旋转然后剪切的含义。

47
00:03:26,800 --> 00:03:31,588
但是无论您得到什么，都应该与应用我们刚刚通过同一向 

48
00:03:31,588 --> 00:03:35,639
量找到的新合成矩阵相同，无论您选择什么向量，

49
00:03:35,639 --> 00:03:40,980
因为这 个新矩阵应该捕获与旋转然后剪切动作相同的整体效果。

50
00:03:42,480 --> 00:03:46,111
根据这里的写法，我认为将这个新矩阵称为 

51
00:03:46,111 --> 00:03:49,380
原始两个矩阵的乘积是合理的，不是吗？

52
00:03:50,420 --> 00:03:54,128
我们可以立即考虑如何更普遍地计算该 乘积，

53
00:03:54,128 --> 00:03:56,600
但很容易迷失在数字的森林中。

54
00:03:56,600 --> 00:04:00,538
永远记住，像这样的两个矩阵相乘具有先应 

55
00:04:00,538 --> 00:04:04,280
用一种变换再应用另一种变换的几何意义。

56
00:04:05,860 --> 00:04:09,660
这里有点奇怪的一件事是我们从右向左阅读。

57
00:04:10,040 --> 00:04:16,720
首先应用右侧矩阵表示的变换， 然后应用左侧矩阵表示的变换。

58
00:04:17,399 --> 00:04:21,268
这源于函数表示法，因为我们将函数写在变量的左侧，

59
00:04:21,268 --> 00:04:25,460
所 以每次组合两个函数时，您总是必须从右到左读取它。

60
00:04:25,920 --> 00:04:27,499
对于希伯来语读者来说是个好消息，

61
00:04:27,499 --> 00:04:28,980
对于我们其他人来说则是坏消息。

62
00:04:29,880 --> 00:04:31,100
让我们看另一个例子。

63
00:04:31,760 --> 00:04:36,860
取第 1,1 列和第 2,0 列为负的矩阵，其变换如下所示。

64
00:04:37,980 --> 00:04:39,060
我们称之为 m1。

65
00:04:40,100 --> 00:04:44,299
接下来，采用具有 0,1 和 2,0 列的矩阵，

66
00:04:44,299 --> 00:04:45,700
其变换如下所示。

67
00:04:47,520 --> 00:04:49,240
我们称那个人为m2。

68
00:04:49,920 --> 00:04:54,034
应用 m1 然后 m2 的总效果为我们提供 了一个新的变换，

69
00:04:54,034 --> 00:04:55,680
所以让我们找到它的矩阵。

70
00:04:56,280 --> 00:05:00,234
但这一次，让我们看看是否可以在不观看动画的情况 

71
00:05:00,234 --> 00:05:03,860
下做到这一点，而只使用每个矩阵中的数字条目。

72
00:05:04,740 --> 00:05:07,140
首先，我们需要弄清楚 i-hat 的去向。

73
00:05:08,040 --> 00:05:12,102
应用 m1 后，根据定义，i-hat 的新 

74
00:05:12,102 --> 00:05:15,980
坐标由 m1 的第一列（即 1,1）给出。

75
00:05:16,780 --> 00:05:19,852
要查看应用 m2 后会发生什么，

76
00:05:19,852 --> 00:05:23,500
请将 m2 的矩阵乘以该向量 1,1。

77
00:05:25,300 --> 00:05:29,880
按照我上一个视频描述的方式进行计算，您将得到向量 2,1。

78
00:05:30,700 --> 00:05:33,100
这将是组成矩阵的第一列。

79
00:05:34,520 --> 00:05:37,611
同样，遵循 j-hat，m1 的第二 

80
00:05:37,611 --> 00:05:40,540
列告诉我们它首先落在负 2,0 上。

81
00:05:42,700 --> 00:05:46,866
然后，当我们将 m2 应用于该向量时，

82
00:05:46,866 --> 00:05:51,910
您可以计算出矩阵向 量乘积，得到 0，负 2，

83
00:05:51,910 --> 00:05:55,200
这成为我们的复合矩阵的第二列。

84
00:05:56,640 --> 00:06:00,939
让我再次讨论相同的过程，但这次我将显示每个矩阵中的变 

85
00:06:00,939 --> 00:06:04,920
量条目，只是为了表明相同的推理过程适用于任何矩阵。

86
00:06:05,540 --> 00:06:08,154
这需要更多的符号，并且需要更多的空间，

87
00:06:08,154 --> 00:06:12,008
但是对于以前以更死记 硬背的方式学习过矩阵乘法的人来说，

88
00:06:12,008 --> 00:06:13,660
它应该是非常令人满意的。

89
00:06:14,460 --> 00:06:18,447
要跟踪 i-hat 的去向，请首先查看右侧矩阵的 第一列，

90
00:06:18,447 --> 00:06:21,060
因为这是 i-hat 最初落地的位置。

91
00:06:22,000 --> 00:06:26,330
将该列乘以左侧的矩阵，您就可以知道应用第二次转 

92
00:06:26,330 --> 00:06:30,300
换后 i-hat 的中间版本最终出现在哪里。

93
00:06:31,620 --> 00:06:38,100
因此，合成矩阵的第一列始终等 于左矩阵乘以右矩阵的第一列。

94
00:06:42,160 --> 00:06:47,140
同样，j-hat 最初总是落在右侧矩阵的第二列上。

95
00:06:48,940 --> 00:06:53,757
因此，将左侧矩阵乘以第二列将给出其最 终位置，

96
00:06:53,757 --> 00:06:56,480
因此这是合成矩阵的第二列。

97
00:06:56,480 --> 00:07:03,033
请注意，这里有很多符号，通常会教授这个公式作为 

98
00:07:03,033 --> 00:07:09,040
要记住的东西，以及某种帮助记住它的算法过程。

99
00:07:09,160 --> 00:07:12,340
但我确实认为，在记住该过程之前，

100
00:07:12,340 --> 00:07:16,912
 您应该养成思考矩阵乘法真正代表什 么的习惯，

101
00:07:16,912 --> 00:07:18,900
应用一个又一个变换。

102
00:07:19,620 --> 00:07:23,628
相信我，这将为您提供一个更好的概念 框架，

103
00:07:23,628 --> 00:07:26,300
使矩阵乘法的属性更容易理解。

104
00:07:27,060 --> 00:07:28,360
例如，这是一个问题。

105
00:07:28,880 --> 00:07:32,840
当我们将两个矩阵相乘时，它们的顺序重要吗？

106
00:07:33,620 --> 00:07:37,000
好吧，让我们考虑一个简单的例子，就像前面的例子一样。

107
00:07:37,640 --> 00:07:40,230
拿一把剪刀，它可以固定 i-hat 并将 

108
00:07:40,230 --> 00:07:42,820
j-hat 压到右侧，然后旋转 90 度。

109
00:07:43,600 --> 00:07:47,352
如果你先进行剪切，然后旋转，我们可以看到 i-ha 

110
00:07:47,352 --> 00:07:50,960
t 最终为 0,1，j-hat 最终为负 1,1。

111
00:07:51,320 --> 00:07:53,060
两者通常都指向一起。

112
00:07:53,860 --> 00:07:58,084
如果你先旋转，然后进行剪切，i-hat 最终会在 

113
00:07:58,084 --> 00:08:01,971
1,1 处结束，而 j-hat 在负 1,0 

114
00:08:01,971 --> 00:08:05,520
处朝不同方向偏离，并且它们指向的距离更远。

115
00:08:06,380 --> 00:08:12,440
这里的整体效果明显不同，所以显然顺序很重要。

116
00:08:12,700 --> 00:08:15,412
请注意，通过从转换的角度思考，这就是 

117
00:08:15,412 --> 00:08:17,840
你可以通过想象在头脑中完成的事情。

118
00:08:18,220 --> 00:08:19,900
不需要矩阵乘法。

119
00:08:21,480 --> 00:08:24,536
我记得当我第一次学习线性代数时，

120
00:08:24,536 --> 00:08:29,120
有一个作 业问题要求我们证明矩阵乘法是结合律的。

121
00:08:29,560 --> 00:08:33,138
这意味着，如果您有三个矩阵 A、B 和 C，

122
00:08:33,138 --> 00:08:37,366
并且将它们全部相 乘，则无论您先计算 A 乘以 B，

123
00:08:37,366 --> 00:08:40,781
然后将结果乘以 C，还是先 将 B 乘以，

124
00:08:40,781 --> 00:08:44,360
都没有关系。C，然后将该结果乘以左边的 A。

125
00:08:44,940 --> 00:08:47,400
换句话说，括号放在哪里并不重要。

126
00:08:48,380 --> 00:08:51,129
现在，如果你尝试用数字来解决这个问题，

127
00:08:51,129 --> 00:08:54,602
就像我当时所 做的那样，那就太可怕了，太可怕了，

128
00:08:54,602 --> 00:08:55,760
而且毫无启发性。

129
00:08:55,760 --> 00:09:00,313
但是，当您将矩阵乘法视为应用一个又一 个变换时，

130
00:09:00,313 --> 00:09:02,780
这个属性就显得微不足道了。

131
00:09:03,300 --> 00:09:04,000
你能明白为什么吗？

132
00:09:04,860 --> 00:09:09,053
它的意思是，如果您先应用 C，然后应用 B，然后应用 A，

133
00:09:09,053 --> 00:09:12,380
则与应用 C、然后 B、然后 A 的效果相同。

134
00:09:12,820 --> 00:09:15,278
我的意思是，没有什么可以证明的，

135
00:09:15,278 --> 00:09:18,660
你只是 按照相同的顺序依次应用相同的三件事。

136
00:09:19,460 --> 00:09:21,540
这可能感觉像是作弊，但事实并非如此。

137
00:09:21,540 --> 00:09:25,900
这是矩阵乘法具有结合性的诚实证明。

138
00:09:25,900 --> 00:09:30,680
甚至更好的是，它很好地解释了为什么该属性应该是正确的。

139
00:09:31,560 --> 00:09:36,321
我真的鼓励你更多地尝试这个想法，想象两种 不同的变换，

140
00:09:36,321 --> 00:09:39,847
思考当你一个接一个地应用时 会发生什么，

141
00:09:39,847 --> 00:09:42,140
然后用数字计算出矩阵乘积。

142
00:09:42,600 --> 00:09:46,440
相信我，这样的游戏时间才能真正让这个想法深入人心。

143
00:09:47,200 --> 00:09:51,420
在下一个视频中，我将开始讨论将这些想法扩展到二维之外。

144
00:09:52,020 --> 00:09:52,180
回头见！

