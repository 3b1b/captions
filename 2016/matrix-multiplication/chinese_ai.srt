1
00:00:00,000 --> 00:00:15,240
大家好，在我们上次停下的地方，我展示了线

2
00:00:15,240 --> 00:00:18,360
性变换的样子以及如何使用矩阵来表示它们。

3
00:00:18,360 --> 00:00:22,320
这值得快速回顾一下，因为它非常重要，但当然，如

4
00:00:22,320 --> 00:00:26,280
果这感觉不仅仅是回顾，请返回并观看完整的视频。

5
00:00:26,280 --> 00:00:30,700
一般来说，线性变换是以向量作为输入、以向量

6
00:00:30,700 --> 00:00:34,760
作为输出的函数，但我上次展示了如何在视觉

7
00:00:34,760 --> 00:00:39,760
上将它们视为在空间中平滑移动，从而使网格

8
00:00:39,760 --> 00:00:41,840
线保持平行且均匀间隔，并且原点保持固定。

9
00:00:41,840 --> 00:00:46,860
关键要点是线性变换完全取决于它采用空间基向量的位置

10
00:00:46,860 --> 00:00:52,260
，这对于二维意味着 i-hat 和 j-hat。

11
00:00:52,260 --> 00:00:56,500
这是因为任何其他向量都可以描

12
00:00:56,500 --> 00:00:57,820
述为这些基向量的线性组合。

13
00:00:57,820 --> 00:01:03,460
坐标为 x、y 的向量等于 x 乘以 i-hat 加上 y 乘以 j-hat。

14
00:01:03,460 --> 00:01:07,540
经过变换后，网格线保持平行且间

15
00:01:07,540 --> 00:01:10,600
隔均匀的特性产生了奇妙的结果。

16
00:01:10,600 --> 00:01:15,180
矢量降落的位置将是 i-hat 变换版本的

17
00:01:15,180 --> 00:01:18,440
x 倍加上 j-hat 变换版本的 y 倍。

18
00:01:18,440 --> 00:01:22,960
这意味着，如果您记录 i-hat 落在的坐标和 j-hat 落

19
00:01:22,960 --> 00:01:28,940
在的坐标，您可以计算出从 x, y 开始的向量必须落在 x 乘

20
00:01:28,940 --> 00:01:33,600
以 i-hat 的新坐标加 y 上乘以 j-hat 的新坐标。

21
00:01:33,600 --> 00:01:38,000
约定是将 i-hat 和 j-hat 落地

22
00:01:38,000 --> 00:01:42,820
的坐标记录为矩阵的列，并将这些列按 x

23
00:01:42,820 --> 00:01:46,280
和 y 缩放后的总和定义为矩阵向量乘法。

24
00:01:46,280 --> 00:01:51,320
这样，矩阵表示特定的线性变换，将矩阵乘以

25
00:01:51,320 --> 00:01:58,040
向量就是将该变换应用于该向量的计算意义。

26
00:01:58,040 --> 00:02:01,760
好了，回顾一下，开始新内容。

27
00:02:01,760 --> 00:02:06,160
通常，您会发现自己想要描述应用一

28
00:02:06,160 --> 00:02:07,680
种转换然后应用另一种转换的效果。

29
00:02:07,680 --> 00:02:11,760
例如，也许您想要描述当您首先将平面逆时针旋

30
00:02:11,760 --> 00:02:15,440
转 90 度，然后应用剪切时会发生什么。

31
00:02:15,440 --> 00:02:20,360
这里的整体效果，从开始到结束，是另

32
00:02:20,360 --> 00:02:22,540
一种线性变换，与旋转和剪切不同。

33
00:02:22,540 --> 00:02:26,920
这种新的线性变换通常称为我们

34
00:02:26,920 --> 00:02:29,040
应用的两个单独变换的组合。

35
00:02:29,040 --> 00:02:33,480
与任何线性变换一样，它可以通过遵循 i-h

36
00:02:33,480 --> 00:02:36,280
at 和 j-hat 用自己的矩阵来描述。

37
00:02:36,280 --> 00:02:42,360
在此示例中，两次转换后 i-hat 的最终着陆

38
00:02:42,360 --> 00:02:44,800
点是 1,1，因此我们将其作为矩阵的第一列。

39
00:02:44,840 --> 00:02:50,320
同样，j-hat 最终位于负 1,0

40
00:02:50,320 --> 00:02:52,800
位置，因此我们将其作为矩阵的第二列。

41
00:02:52,800 --> 00:02:58,300
这个新矩阵捕捉了应用旋转然后剪切的整体效果，

42
00:02:58,300 --> 00:03:03,400
但作为一个单一动作，而不是两个连续的动作。

43
00:03:03,400 --> 00:03:05,480
这是思考新矩阵的一种方法。

44
00:03:05,480 --> 00:03:09,760
如果你要获取一些向量并通过旋转泵送

45
00:03:09,760 --> 00:03:14,360
它，那么剪切，计算它最终的位置的长

46
00:03:14,400 --> 00:03:15,400
方法是首先将它在左侧乘以旋转矩阵。

47
00:03:15,400 --> 00:03:20,520
然后，将得到的值乘以左侧的剪切矩阵。

48
00:03:20,520 --> 00:03:26,000
从数字上来说，这就是对给定向

49
00:03:26,000 --> 00:03:27,000
量应用旋转然后剪切的含义。

50
00:03:27,000 --> 00:03:30,720
但是无论您得到什么，都应该与应用我们刚刚通过同一向

51
00:03:30,720 --> 00:03:35,560
量找到的新合成矩阵相同，无论您选择什么向量，因为这

52
00:03:35,560 --> 00:03:42,720
个新矩阵应该捕获与旋转然后剪切动作相同的整体效果。

53
00:03:42,720 --> 00:03:45,940
根据这里的写法，我认为将这个新矩阵称为

54
00:03:45,940 --> 00:03:50,640
原始两个矩阵的乘积是合理的，不是吗？

55
00:03:50,640 --> 00:03:54,460
我们可以立即考虑如何更普遍地计算该

56
00:03:54,460 --> 00:03:57,440
乘积，但很容易迷失在数字的森林中。

57
00:03:57,440 --> 00:04:02,280
永远记住，像这样的两个矩阵相乘具有先应

58
00:04:02,280 --> 00:04:06,340
用一种变换再应用另一种变换的几何意义。

59
00:04:06,340 --> 00:04:10,080
这里有点奇怪的一件事是我们从右向左阅读。

60
00:04:10,080 --> 00:04:14,160
首先应用右侧矩阵表示的变换，

61
00:04:14,160 --> 00:04:17,600
然后应用左侧矩阵表示的变换。

62
00:04:17,600 --> 00:04:21,940
这源于函数表示法，因为我们将函数写在变量的左侧，所

63
00:04:21,940 --> 00:04:26,160
以每次组合两个函数时，您总是必须从右到左读取它。

64
00:04:26,160 --> 00:04:30,080
对于希伯来语读者来说是个好消息，对于我们其他人来说则是坏消息。

65
00:04:30,080 --> 00:04:31,880
让我们看另一个例子。

66
00:04:31,880 --> 00:04:38,160
取第 1,1 列和第 2,0 列为负的矩阵，其变换如下所示。

67
00:04:38,240 --> 00:04:40,000
我们称之为 m1。

68
00:04:40,000 --> 00:04:46,000
接下来，采用具有 0,1 和 2,0 列的矩阵，其变换如下所示。

69
00:04:47,840 --> 00:04:50,040
我们称那个人为m2。

70
00:04:50,040 --> 00:04:55,560
应用 m1 然后 m2 的总效果为我们提供

71
00:04:55,560 --> 00:04:56,560
了一个新的变换，所以让我们找到它的矩阵。

72
00:04:56,560 --> 00:05:00,940
但这一次，让我们看看是否可以在不观看动画的情况

73
00:05:00,940 --> 00:05:04,480
下做到这一点，而只使用每个矩阵中的数字条目。

74
00:05:04,480 --> 00:05:08,040
首先，我们需要弄清楚 i-hat 的去向。

75
00:05:08,280 --> 00:05:13,560
应用 m1 后，根据定义，i-hat 的新

76
00:05:13,560 --> 00:05:16,960
坐标由 m1 的第一列（即 1,1）给出。

77
00:05:16,960 --> 00:05:23,960
要查看应用 m2 后会发生什么，请将 m2 的矩阵乘以该向量 1,1。

78
00:05:25,720 --> 00:05:30,860
按照我上一个视频描述的方式进行计算，您将得到向量 2,1。

79
00:05:30,860 --> 00:05:33,960
这将是组成矩阵的第一列。

80
00:05:34,160 --> 00:05:40,000
同样，遵循 j-hat，m1 的第二

81
00:05:40,000 --> 00:05:42,000
列告诉我们它首先落在负 2,0 上。

82
00:05:42,000 --> 00:05:50,000
然后，当我们将 m2 应用于该向量时，您可以计算出矩阵向

83
00:05:50,240 --> 00:05:57,040
量乘积，得到 0，负 2，这成为我们的复合矩阵的第二列。

84
00:05:57,040 --> 00:06:01,060
让我再次讨论相同的过程，但这次我将显示每个矩阵中的变

85
00:06:01,060 --> 00:06:05,620
量条目，只是为了表明相同的推理过程适用于任何矩阵。

86
00:06:05,620 --> 00:06:09,560
这需要更多的符号，并且需要更多的空间，但是对于以前以更死记

87
00:06:09,560 --> 00:06:14,580
硬背的方式学习过矩阵乘法的人来说，它应该是非常令人满意的。

88
00:06:14,580 --> 00:06:19,180
要跟踪 i-hat 的去向，请首先查看右侧矩阵的

89
00:06:19,180 --> 00:06:22,440
第一列，因为这是 i-hat 最初落地的位置。

90
00:06:22,440 --> 00:06:26,860
将该列乘以左侧的矩阵，您就可以知道应用第二次转

91
00:06:26,860 --> 00:06:31,780
换后 i-hat 的中间版本最终出现在哪里。

92
00:06:31,780 --> 00:06:36,380
因此，合成矩阵的第一列始终等

93
00:06:36,380 --> 00:06:39,380
于左矩阵乘以右矩阵的第一列。

94
00:06:39,380 --> 00:06:46,380
同样，j-hat 最初总是落在右侧矩阵的第二列上。

95
00:06:48,960 --> 00:06:54,540
因此，将左侧矩阵乘以第二列将给出其最

96
00:06:54,740 --> 00:07:00,740
终位置，因此这是合成矩阵的第二列。

97
00:07:00,740 --> 00:07:04,460
请注意，这里有很多符号，通常会教授这个公式作为

98
00:07:04,460 --> 00:07:09,320
要记住的东西，以及某种帮助记住它的算法过程。

99
00:07:09,320 --> 00:07:13,100
但我确实认为，在记住该过程之前，

100
00:07:13,100 --> 00:07:18,140
您应该养成思考矩阵乘法真正代表什

101
00:07:18,140 --> 00:07:19,660
么的习惯，应用一个又一个变换。

102
00:07:19,660 --> 00:07:23,600
相信我，这将为您提供一个更好的概念

103
00:07:23,640 --> 00:07:27,160
框架，使矩阵乘法的属性更容易理解。

104
00:07:27,160 --> 00:07:29,080
例如，这是一个问题。

105
00:07:29,080 --> 00:07:33,480
当我们将两个矩阵相乘时，它们的顺序重要吗？

106
00:07:33,480 --> 00:07:37,760
好吧，让我们考虑一个简单的例子，就像前面的例子一样。

107
00:07:37,760 --> 00:07:43,700
拿一把剪刀，它可以固定 i-hat 并将 j-hat 压到右侧，然后旋转 90 度。

108
00:07:43,700 --> 00:07:49,560
如果你先进行剪切，然后旋转，我们可以看到 i-ha

109
00:07:49,600 --> 00:07:51,480
t 最终为 0,1，j-hat 最终为负 1,1。

110
00:07:51,480 --> 00:07:54,000
两者通常都指向一起。

111
00:07:54,000 --> 00:08:01,000
如果你先旋转，然后进行剪切，i-hat 最终会在 1,1 处结束，而

112
00:08:01,420 --> 00:08:06,440
j-hat 在负 1,0 处朝不同方向偏离，并且它们指向的距离更远。

113
00:08:06,440 --> 00:08:12,480
这里的整体效果明显不同，所以显然顺序很重要。

114
00:08:12,480 --> 00:08:16,520
请注意，通过从转换的角度思考，这就是

115
00:08:16,520 --> 00:08:18,360
你可以通过想象在头脑中完成的事情。

116
00:08:18,360 --> 00:08:21,800
不需要矩阵乘法。

117
00:08:21,800 --> 00:08:26,020
我记得当我第一次学习线性代数时，有一个作

118
00:08:26,020 --> 00:08:29,780
业问题要求我们证明矩阵乘法是结合律的。

119
00:08:29,780 --> 00:08:34,660
这意味着，如果您有三个矩阵 A、B 和 C，并且将它们全部相

120
00:08:34,660 --> 00:08:39,840
乘，则无论您先计算 A 乘以 B，然后将结果乘以 C，还是先

121
00:08:39,840 --> 00:08:45,060
将 B 乘以，都没有关系。 C，然后将该结果乘以左边的 A。

122
00:08:45,060 --> 00:08:48,100
换句话说，括号放在哪里并不重要。

123
00:08:48,100 --> 00:08:53,340
现在，如果你尝试用数字来解决这个问题，就像我当时所

124
00:08:53,340 --> 00:08:56,420
做的那样，那就太可怕了，太可怕了，而且毫无启发性。

125
00:08:56,420 --> 00:09:01,380
但是，当您将矩阵乘法视为应用一个又一

126
00:09:01,380 --> 00:09:03,460
个变换时，这个属性就显得微不足道了。

127
00:09:03,460 --> 00:09:05,060
你能明白为什么吗？

128
00:09:05,060 --> 00:09:10,700
它的意思是，如果您先应用 C，然后应用 B，然后应用

129
00:09:10,700 --> 00:09:13,060
A，则与应用 C、然后 B、然后 A 的效果相同。

130
00:09:13,060 --> 00:09:16,940
我的意思是，没有什么可以证明的，你只是

131
00:09:16,940 --> 00:09:19,680
按照相同的顺序依次应用相同的三件事。

132
00:09:19,680 --> 00:09:22,080
这可能感觉像是作弊，但事实并非如此。

133
00:09:22,080 --> 00:09:26,360
这是矩阵乘法具有结合性的诚实证明。

134
00:09:26,360 --> 00:09:31,820
甚至更好的是，它很好地解释了为什么该属性应该是正确的。

135
00:09:31,820 --> 00:09:37,020
我真的鼓励你更多地尝试这个想法，想象两种

136
00:09:37,020 --> 00:09:40,560
不同的变换，思考当你一个接一个地应用时

137
00:09:40,560 --> 00:09:42,700
会发生什么，然后用数字计算出矩阵乘积。

138
00:09:42,700 --> 00:09:47,460
相信我，这样的游戏时间才能真正让这个想法深入人心。

139
00:09:47,460 --> 00:09:52,060
在下一个视频中，我将开始讨论将这些想法扩展到二维之外。

140
00:09:52,060 --> 00:09:52,340
回头见！

