1
00:00:00,000 --> 00:00:20,040
前回のビデオでは、単純な関数の導関数について説明しましたが、その目標は、これら

2
00:00:20,040 --> 00:00:25,280
の公式がどこから来たのかを実際に説明する明確なイメージや直感を頭の中に持つこと

3
00:00:25,280 --> 00:00:31,200
でした。しかし、世界をモデル化する際に扱う関数のほとんどは、これらの単純な関数を

4
00:00:31,200 --> 00:00:36,400
別の方法で混合、組み合わせ、または微調整することを伴うため、次のステップは、より複

5
00:00:36,400 --> 00:00:42,280
雑な組み合わせの導関数をどのように取得するかを理解することです。繰り返しに

6
00:00:42,280 --> 00:00:45,680
なりますが、これらを暗記するものではなく、それぞれがどこ

7
00:00:45,680 --> 00:00:50,500
から来たのかを明確に頭の中に持っておいてほしいのです。

8
00:00:50,500 --> 00:00:55,380
これは、関数を組み合わせる 3 つの基本的な方法に要約されます。それらを加算したり、乗算

9
00:00:55,380 --> 00:01:00,260
したり、一方をもう一方の中に入れることもできます (これを「合成」といいます)。

10
00:01:00,260 --> 00:01:04,920
確かに、減算すると言うこともできますが、実際には、2 番目の値にマイナスの 1

11
00:01:04,920 --> 00:01:10,280
を掛けて、それらを加算するだけです。同様に、関数を除算しても実際に

12
00:01:10,280 --> 00:01:15,220
は何も加算されません。これは、関数内の 1 を x に

13
00:01:15,220 --> 00:01:17,660
1 に接続して、2 つを乗算するのと同じだからです。

14
00:01:17,660 --> 00:01:21,900
つまり、実際のところ、遭遇するほとんどの関数には、これら 3 つの異なるタイプの組み合わせを

15
00:01:21,900 --> 00:01:26,060
重ね合わせることが含まれていますが、どの程度巨大なものになるかについては実際には制限がありま

16
00:01:26,060 --> 00:01:31,140
せん。しかし、これら 3 つの組み合わせタイプだけでデリバティブ

17
00:01:31,140 --> 00:01:35,640
がどのように機能するかを知っていれば、いつでも段階的に実行して

18
00:01:35,640 --> 00:01:39,460
、あらゆる種類の巨大な表現のレイヤーを剥がすことができます。

19
00:01:39,460 --> 00:01:44,220
問題は、2 つの関数の導関数がわかっている場合、それらの和

20
00:01:44,220 --> 00:01:50,520
、積、およびそれらの間の関数合成の導関数は何でしょうか?

21
00:01:50,520 --> 00:01:56,140
声を大にして言うのは少々ややこしいですが、合計ルールが最も簡単です。2 つの関数の合計の導

22
00:01:56,140 --> 00:02:01,840
関数は、それらの導関数の合計です。ただし、積と関数合成の導関数パ

23
00:02:01,840 --> 00:02:07,860
ターンはそれほど単純ではなく、この種の関数が必要になるため、2

24
00:02:07,860 --> 00:02:13,460
つの関数の和の導関数を取ることが何を意味するのかをよく考え

25
00:02:13,700 --> 00:02:16,740
て、この例でウォームアップする価値があります。より深い思考。

26
00:02:16,740 --> 00:02:22,300
たとえば、x の関数 f が x の正弦に x の 2 乗を加えたものに等しいという関数について考えてみましょう。これは

27
00:02:22,300 --> 00:02:27,220
、入力ごとに、x の正弦値とその時点での x の 2 乗の値を加算する

28
00:02:27,220 --> 00:02:35,220
関数です。たとえば、x が 0 に等しいとします。図５において、正弦グラフの高

29
00:02:35,220 --> 00:02:41,060
さはこの縦棒によって与えられ、ｘ二乗放物線の高さはこの小さな縦棒によっ

30
00:02:41,460 --> 00:02:48,460
て与えられる。そして、それらの合計は、それらを積み重ねるだけで得られる長さになります。

31
00:02:48,820 --> 00:02:53,940
導関数の場合、その入力をわずかに微調整すると、おそらく 0 まで増加すると何が起こるかを尋ねる必要が

32
00:02:53,940 --> 00:03:00,940
あります。5プラスDX。これら 2 つの場所の f の値の差を df と呼び

33
00:03:01,780 --> 00:03:08,080
ます。そして、このようにイメージすると、高さの合計の変化は、正弦グラフの変

34
00:03:08,080 --> 00:03:13,600
化が何であれ、x の d サインと呼ぶものに、x の 2 乗に対する変化を加

35
00:03:13,600 --> 00:03:20,600
えたもの、つまり dx であることに同意していただけると思います。四角い。

36
00:03:22,840 --> 00:03:28,240
ここで、サインの導関数がコサインであることがわかり、それが何を意味するかを思い出しました。これは、この小

37
00:03:28,240 --> 00:03:35,040
さな変化、つまり x の d サインが、x のコサインに dx を掛けたものであることを意味します。これは最初のナ

38
00:03:35,080 --> 00:03:40,800
ッジ dx のサイズに比例し、比例定数は開始した入力のコサイン

39
00:03:40,800 --> 00:03:47,800
に等しくなります。同様に、x の 2 乗の導関数は 2x であるため、

40
00:03:48,160 --> 00:03:55,160
x の 2 乗グラフの高さの変化は、dx が何であれ 2 倍になります。

41
00:03:55,760 --> 00:04:02,360
したがって、df を dx で割って並べ替えると、この合計関数に対する小さな変化と、それを引き起

42
00:04:02,360 --> 00:04:09,320
こした x の小さな変化の比は、確かに x のコサインに 2x を加えたもの、つまり各部分の導関

43
00:04:09,320 --> 00:04:13,720
数の合計になります。しかし、先ほども言いましたが、製品の場合は少し事情が異なりま

44
00:04:13,720 --> 00:04:20,720
す。その理由を小さなナッジの観点からもう一度考えてみましょう。この場合、グラ

45
00:04:20,760 --> 00:04:25,120
フは物事を視覚化するのに最善の策ではないと思います。数学ではよくあることで

46
00:04:25,120 --> 00:04:30,320
すが、多くのレベルの数学では、2 つのものの積を扱う場合、それをある種の領

47
00:04:30,360 --> 00:04:34,720
域として理解するのに役立ちます。この場合、辺の長さが x の正弦および x の

48
00:04:34,720 --> 00:04:40,520
2 乗であるボックスの精神的な設定を構成しようとすると考えられます。しかし、それは何を意味する

49
00:04:40,520 --> 00:04:46,640
のでしょうか？これらは関数であるため、x の値に応じてこれらの側面を調整できる

50
00:04:46,640 --> 00:04:51,180
と考えるかもしれません。x は単に上下に自由に調整できる数値であると考

51
00:04:51,180 --> 00:04:57,160
えるかもしれません。これが何を意味するのかを理解するには、x の関数正弦として

52
00:04:57,800 --> 00:05:04,800
変化する上側に注目してください。この x の値を 0 から変更すると、x の正弦

53
00:05:05,240 --> 00:05:10,840
がピークに向かって上昇するにつれて長さ 1 まで増加し、その後、x の正弦が 1

54
00:05:10,840 --> 00:05:16,920
から下降するにつれて減少し始めます。そして同じように、その高さは常に x

55
00:05:16,920 --> 00:05:22,520
の 2 乗として変化します。したがって、これら 2 つの関数の積として定義される x

56
00:05:22,520 --> 00:05:29,060
の f は、このボックスの面積になります。そして導関数については、dx による x への小さな変更が

57
00:05:29,060 --> 00:05:36,060
その領域にどのような影響を与えるかを考えてみましょう。その結果、DFエリアにどのような変化が生じたのでしょうか？

58
00:05:39,960 --> 00:05:45,580
dx を微調整すると、その幅が x の小さな d サインだけ変化し、高さが

59
00:05:45,620 --> 00:05:52,620
dx の 2 乗だけ変化します。これにより、新しい領域の 3 つの小さなスニペッ

60
00:05:53,100 --> 00:05:58,920
トが得られます。下部の薄い長方形の面積は、幅と x の正弦に、薄い高さの dx の 2

61
00:05:58,920 --> 00:06:05,920
乗を掛けたものです。右側の薄い長方形の面積は、高さの x の 2 乗です。その細い

62
00:06:06,620 --> 00:06:13,000
幅に x の d サインを掛けます。隅にこれも少しありますが、それは無視

63
00:06:13,000 --> 00:06:19,160
して構いません。その面積は最終的には dx の 2 乗に比例し、これ

64
00:06:19,160 --> 00:06:24,320
までに見たように、dx が 0 に近づくと無視できるほどになります。

65
00:06:24,320 --> 00:06:29,440
このセットアップ全体は、前回のビデオで示した x の 2 乗図と非常によく似ています。

66
00:06:29,440 --> 00:06:33,560
そして、その時と同じように、ここでも実際に見えるように描画するために多少大胆な変更を使用し

67
00:06:33,560 --> 00:06:40,000
ていることに注意してください。しかし、原則として、dx は非常に非常に小さいものであり、

68
00:06:40,000 --> 00:06:46,480
つまり、x の dx 2 乗と d サインも非常に小さいことを意味します。非常に少ない。

69
00:06:46,480 --> 00:06:52,000
したがって、サインと x の 2 乗の微分について私たちが知っていることを適用すると、その小

70
00:06:52,000 --> 00:06:59,000
さな変化 dx の 2 乗は dx の約 2x 倍になり、x の小さな変化 d サインは

71
00:06:59,040 --> 00:07:06,040
dx の x 倍のコサインになります。いつものように、dx で割って、必要な比率 (df

72
00:07:06,280 --> 00:07:13,280
を dx で割った値) が、x の 2 乗微分の正弦と、sine の微分の x 2

73
00:07:13,400 --> 00:07:19,760
乗を加えたものであることを確認します。ここで行ったことは、サインまたは x の 2 乗に

74
00:07:19,760 --> 00:07:24,660
固有のものではありません。これと同じ推論が、任意の 2 つの関数 g と h に対しても機

75
00:07:24,660 --> 00:07:28,520
能します。そして時々、このパターンを頭の中で「左、右、

76
00:07:28,520 --> 00:07:33,140
右、左」と歌うような記憶術で覚えようとする人がいま

77
00:07:33,180 --> 00:07:36,940
す。この例では、x の正弦に x の 2 乗を乗じた値があり、left d rig

78
00:07:36,940 --> 00:07:42,700
ht ということは、左の関数である x の正弦に右の導関数を掛けたもの (この場合は 2

79
00:07:42,700 --> 00:07:48,700
x) を取ることを意味します。次に、右 d 左に、その右の関数 x の 2

80
00:07:48,700 --> 00:07:52,780
乗を加算し、左の関数の導関数 (x のコサイン) を掛けます。

81
00:07:52,780 --> 00:07:59,780
文脈を無視して、覚えておくべきルールとして提示されると、かなり奇妙に感じられると思いますね

82
00:07:59,780 --> 00:08:05,340
。しかし、実際にこの調整可能なボックスについて考えると、これらの各用語が何を表しているのかがわ

83
00:08:05,340 --> 00:08:12,340
かります。左 d 右はその小さな底の長方形の面積であり、右 d 左は

84
00:08:13,100 --> 00:08:20,100
その長方形の側面の面積です。ところで、定数を掛けると、たとえば x の正弦を

85
00:08:22,120 --> 00:08:28,300
2 倍すると、物事はずっと単純になることを言っておきます。微分値は、定数に関数

86
00:08:28,300 --> 00:08:33,400
の微分値を乗算したものとまったく同じです。この場合、x のコサインの

87
00:08:33,400 --> 00:08:39,300
2 倍です。立ち止まって熟考し、それが理にかなっているかどうかを検証するのはあなたにお任せ

88
00:08:39,300 --> 00:08:44,540
します。加算と乗算のほかに、関数を組み合わせるもう 1 つの一般的

89
00:08:44,540 --> 00:08:49,260
な方法は、信じてください、これは常に登場しますが、一方をもう一

90
00:08:49,260 --> 00:08:54,340
方の中に押し込む、つまり関数の合成です。たとえば、関数 x の 2 乗を取

91
00:08:54,660 --> 00:08:59,660
得し、それを x の正弦の内側に押し込み、この新しい関数 x の 2 乗の正弦を取得するか

92
00:08:59,660 --> 00:09:05,540
もしれません。その新しい関数の派生関数は何だと思いますか?

93
00:09:05,540 --> 00:09:09,980
これをじっくり考えるために、創造的な数学にはたくさんの選択肢があることを強調するために、

94
00:09:09,980 --> 00:09:15,700
物事を視覚化するさらに別の方法を選択します。3 つの異なる数直線を用意します。一番上の

95
00:09:15,700 --> 00:09:22,120
直線は x の値を保持し、2 番目の直線は x の 2 乗の値を保持し、3 番目の直線は

96
00:09:22,120 --> 00:09:27,460
x の 2 乗の正弦の値、つまり関数を保持します。 x 2 乗を使用すると 1 行目

97
00:09:27,460 --> 00:09:32,680
から 2 行目まで移動でき、関数 sine を使用すると 2 行目から 3 行目まで移動

98
00:09:32,680 --> 00:09:37,300
できます。この x の値を中心にシフトし、おそらく値 3 まで移動すると

99
00:09:37,300 --> 00:09:44,040
、2 番目の値は x の 2 乗に固定されたままになり、この場合は 9

100
00:09:44,040 --> 00:09:49,560
まで移動し、その下の値は x の 2 乗の正弦になります。 9 の正弦

101
00:09:49,560 --> 00:09:57,680
がたまたまあるものに移動します。したがって、導関数については、その x 値を少し

102
00:09:57,680 --> 00:10:03,280
dx だけ微調整することから再び始めましょう。私はいつも、x が実際の具体的な数値 (おそ

103
00:10:03,280 --> 00:10:09,720
らく 1) から始まると考えると役立つと思います。この場合は5です。結果として生じる 2 番

104
00:10:09,720 --> 00:10:16,720
目の値へのナッジ、つまり dx によって引き起こされる x の 2 乗の変化は、dx の 2 乗です。

105
00:10:17,240 --> 00:10:24,240
これを 2x x dx として拡張できます。これは、特定の入力では 2 x 1 になります。d

106
00:10:25,040 --> 00:10:31,160
x の 5 倍ですが、少なくとも現時点では、物事を dx の 2 乗として記述するのに役立ちます。

107
00:10:31,160 --> 00:10:37,520
実際、さらに一歩進んで、この x の 2 乗に新しい名前 (おそらく h)

108
00:10:37,520 --> 00:10:42,760
を付けて、このナッジに対して dx 二乗と書く代わりに dh と書きます。

109
00:10:42,760 --> 00:10:48,120
これにより、h の正弦に固定される 3 番目の値について考えることが容易になります。

110
00:10:48,120 --> 00:10:55,120
その変化は h の d サイン、つまり dh のナッジによって引き起こされる小さな変化です。

111
00:10:55,160 --> 00:10:59,200
ちなみに、dh バンプが右に移動しているのに左に移動しているという事

112
00:10:59,200 --> 00:11:04,860
実は、この変化、h の d サインが何らかの負の数になることを意味

113
00:11:04,860 --> 00:11:08,360
します。もう一度、サインの導関数に関する知識を活用する

114
00:11:08,400 --> 00:11:13,140
ことができます。この h の d サインは、h のコサインに dh を掛

115
00:11:13,140 --> 00:11:16,760
けたものになります。これが、サインの導関数がコサインになるこ

116
00:11:16,760 --> 00:11:21,840
とを意味します。物事を展開すると、h を x の 2 乗に再度置き換えることが

117
00:11:21,840 --> 00:11:26,880
できるため、一番下のナッジのコサインのサイズが x の 2 乗に dx の 2 乗を掛

118
00:11:26,880 --> 00:11:33,080
けたものになることがわかります。実際、物事をさらに展開してみましょう。

119
00:11:33,080 --> 00:11:39,680
その中間ナッジ dx の 2 乗は、dx の約 2 倍になります。

120
00:11:39,680 --> 00:11:44,440
このような表現が実際に何を意味するのかを思い出すことは常に良い習慣です。

121
00:11:44,440 --> 00:11:50,240
この場合、x から開始した場所は 1 に等しくなります。上の 5 では、この式全体が、3 行

122
00:11:50,240 --> 00:11:57,240
目のナッジのサイズが約 1 のコサインになることを示しています。5の2

123
00:11:57,280 --> 00:12:02,320
乗×2×1。dx のサイズに関係なく 5 倍。

124
00:12:02,320 --> 00:12:07,360
これは dx のサイズに比例し、この導関数によりその比例定数が得

125
00:12:07,360 --> 00:12:13,080
られます。ここで何が判明したかに注目してください。

126
00:12:13,080 --> 00:12:18,580
外側の関数の導関数があり、それは依然として変更されていない内側

127
00:12:18,580 --> 00:12:25,580
の関数を取り込み、それをその内側の関数の導関数で乗算します。

128
00:12:26,580 --> 00:12:31,500
x の正弦または x の 2 乗については特別なことは何もありません。x の g と x の h と

129
00:12:31,500 --> 00:12:38,500
いう 2 つの関数がある場合、それらの合成の導関数、g of h of x

130
00:12:38,500 --> 00:12:45,500
は、h で評価された g の導関数に h の導関数を乗算したものになります。

131
00:12:47,600 --> 00:12:52,660
このパターンは、通常、連鎖規則と呼ばれるものです。

132
00:12:52,660 --> 00:12:59,300
gの導関数については、dg dxではなくdg dhと書いています。記号レベルでは

133
00:12:59,300 --> 00:13:04,020
、これは導関数に接続するものは依然として中間関数 h であるこ

134
00:13:04,020 --> 00:13:09,200
とを思い出させます。しかしそれ以上に、これは外部関数の導

135
00:13:09,200 --> 00:13:13,100
関数が実際に何を表しているのかを反映する重要な点です。

136
00:13:13,100 --> 00:13:18,820
3 つのラインの設定で、その底部のサインの導関数を取得したときに、そのナッジのサイズ d sine を

137
00:13:18,820 --> 00:13:25,580
h と dh の掛け合わせのコサインとして拡張したことを思い出してください。これは、その下部ナ

138
00:13:25,580 --> 00:13:33,300
ッジのサイズが x にどのように依存するのかがすぐには分からなかったためです。

139
00:13:33,300 --> 00:13:38,820
しかし、中間変数 h に関して導関数を求めることはできます。つまり、

140
00:13:38,820 --> 00:13:43,380
3 行目のナッジのサイズを、2 行目のナッジのサイズである dh の倍数

141
00:13:43,380 --> 00:13:48,620
として表現する方法を考え出します。その後、dh が何である

142
00:13:48,620 --> 00:13:53,820
かを理解することでさらに展開が始まりました。

143
00:13:53,820 --> 00:13:58,100
この連鎖ルール式では、最終出力である g の小さな変化と、それを引き起こした h の

144
00:13:58,100 --> 00:14:03,860
小さな変化との比率を調べてください (h は g に代入する値です) と言っていま

145
00:14:03,860 --> 00:14:10,440
す。次に、それに h の小さな変化を掛け、それを引き起こした x の小さな変化で割

146
00:14:10,440 --> 00:14:16,800
ります。これらの dh が相殺され、最終的な出力の変化と

147
00:14:16,800 --> 00:14:21,860
、特定の一連のイベントによってそれがもたらされた入力

148
00:14:21,860 --> 00:14:24,160
の変化との間の比率が得られることに注意してください。

149
00:14:24,160 --> 00:14:29,640
dh の取り消しは単なる表記上のトリックではなく、私たちがデリバティブで行う

150
00:14:29,640 --> 00:14:37,240
すべてのことを支える小さなナッジで何が起こっているかを純粋に反映しています。

151
00:14:37,240 --> 00:14:41,280
これらは、多くの小さなものを組み合わせた関数の派生関数を処理するために備えてお

152
00:14:41,280 --> 00:14:46,700
くべき 3 つの基本ツールです。合計ルール、積ルー

153
00:14:46,700 --> 00:14:48,720
ル、連鎖ルールがあります。

154
00:14:48,720 --> 00:14:52,200
正直に言うと、連鎖ルールと積ルールが何であるかを知っていることと

155
00:14:52,200 --> 00:14:56,860
、実際にそれらを最も困難な状況にさえ流暢に適用できることの間に

156
00:14:56,860 --> 00:15:02,800
は大きな違いがあります。微積分の仕組みに関するビデオを視聴するこ

157
00:15:02,800 --> 00:15:07,900
とは、微積分の仕組みを自分で練習し、計算を行うための筋肉を鍛える

158
00:15:07,900 --> 00:15:13,200
ことに代わるものではありません。あなたの代わりにそうすることを提案できれば

159
00:15:13,200 --> 00:15:18,240
本当によかったのですが、残念ながらボールはあなたのコートにあり、練習を求めているのです。

160
00:15:18,240 --> 00:15:23,080
私が提供できること、そして提供できればと願っていることは、これらのルールが実際にどこから来たのかを示す

161
00:15:23,080 --> 00:15:27,580
ことです。これらは単に暗記して叩き込むべきものではなく、自然

162
00:15:27,580 --> 00:15:32,520
なパターンであり、派生語が実際に何を意味するのかを辛抱強

163
00:15:32,520 --> 00:15:35,160
く考え抜くだけで発見できるものであることを示すためです。

