1
00:00:00,000 --> 00:00:20,040
前回のビデオでは、単純な関数の導関数について説明しましたが、その目標は、これらの式がどこから来たのかを実際に説明する明確なイメージや直観を頭の中に持つことでした。

2
00:00:20,040 --> 00:00:25,280


3
00:00:25,280 --> 00:00:31,200
しかし、世界をモデル化する際に扱う関数のほとんどは、これらの単純な関数を別の方法で混合、組み合わせ、または微調整することを伴うため、次のステップは、より複雑な組み合わせの導関数をどのように取得するかを理解することです。

4
00:00:31,200 --> 00:00:36,400


5
00:00:36,400 --> 00:00:42,280
繰り返しになりますが、これらを暗記するものではなく、それぞれがどこから来たのかを明確に頭の中に持っておいてほしいのです。

6
00:00:42,280 --> 00:00:45,680


7
00:00:45,680 --> 00:00:50,500


8
00:00:50,500 --> 00:00:55,380
これは、関数を組み合わせる 3 つの基本的な方法に要約されます。 それらを加算したり、乗算したり、一方をもう一方の中に入れることもできます

9
00:00:55,380 --> 00:01:00,260
(これを「合成」といいます)。

10
00:01:00,260 --> 00:01:04,920
確かに、減算すると言うこともできますが、実際には、2 番目の値にマイナスの 1

11
00:01:04,920 --> 00:01:10,280
を掛けて、それらを加算するだけです。 同様に、関数を除算しても実際には何も加算されません。これは、関数内の 1

12
00:01:10,280 --> 00:01:15,220
を x に

13
00:01:15,220 --> 00:01:17,660
1 に接続して、2 つを乗算するのと同じだからです。

14
00:01:17,660 --> 00:01:21,900
つまり、実際のところ、遭遇するほとんどの関数には、これら 3

15
00:01:21,900 --> 00:01:26,060
つの異なるタイプの組み合わせを重ね合わせることが含まれていますが、どの程度巨大なものになるかについては実際には制限がありません。

16
00:01:26,060 --> 00:01:31,140
しかし、これら

17
00:01:31,140 --> 00:01:35,640
3

18
00:01:35,640 --> 00:01:39,460
つの組み合わせタイプだけでデリバティブがどのように機能するかを知っていれば、いつでも段階的に実行して、あらゆる種類の巨大な表現のレイヤーを剥がすことができます。

19
00:01:39,460 --> 00:01:44,220
問題は、2

20
00:01:44,220 --> 00:01:50,520
つの関数の導関数がわかっている場合、それらの和、積、およびそれらの間の関数合成の導関数は何でしょうか?

21
00:01:50,520 --> 00:01:56,140
声を大にして言うのは少々ややこしいですが、合計ルールが最も簡単です。 2

22
00:01:56,140 --> 00:02:01,840
つの関数の合計の導関数は、それらの導関数の合計です。 ただし、積と関数合成の導関数パターンはそれほど単純ではなく、この種の関数が必要になるため、2

23
00:02:01,840 --> 00:02:07,860


24
00:02:07,860 --> 00:02:13,460
つの関数の和の導関数を取ることが何を意味するのかをよく考えて、この例でウォームアップする価値があります。より深い思考。

25
00:02:13,700 --> 00:02:16,740


26
00:02:16,740 --> 00:02:22,300
たとえば、x の関数 f が x の正弦に x の 2 乗を加えたものに等しいという関数について考えてみましょう。 これは、入力ごとに、x

27
00:02:22,300 --> 00:02:27,220
の正弦値とその時点での x の 2 乗の値を加算する関数です。

28
00:02:27,220 --> 00:02:35,220
たとえば、x が 0 に等しいとします。 図５において、正弦グラフの高さはこの縦棒によって与えられ、ｘ二乗放物線の高さはこの小さな縦棒によって与えられる。

29
00:02:35,220 --> 00:02:41,060


30
00:02:41,460 --> 00:02:48,460
そして、それらの合計は、それらを積み重ねるだけで得られる長さになります。

31
00:02:48,820 --> 00:02:53,940
導関数の場合、その入力をわずかに微調整すると、おそらく 0 まで増加すると何が起こるかを尋ねる必要があります。

32
00:02:53,940 --> 00:03:00,940
5プラスDX。 これら 2 つの場所の f の値の差を df と呼びます。

33
00:03:01,780 --> 00:03:08,080
そして、このようにイメージすると、高さの合計の変化は、正弦グラフの変化が何であれ、x の d

34
00:03:08,080 --> 00:03:13,600
サインと呼ぶものに、x の 2

35
00:03:13,600 --> 00:03:20,600
乗に対する変化を加えたもの、つまり dx であることに同意していただけると思います。四角い。

36
00:03:22,840 --> 00:03:28,240
ここで、サインの導関数がコサインであることがわかり、それが何を意味するかを思い出しました。 これは、この小さな変化、つまり

37
00:03:28,240 --> 00:03:35,040
x の d サインが、x のコサインに dx を掛けたものであることを意味します。 これは最初のナッジ

38
00:03:35,080 --> 00:03:40,800
dx のサイズに比例し、比例定数は開始した入力のコサインに等しくなります。

39
00:03:40,800 --> 00:03:47,800
同様に、x の 2 乗の導関数は 2x

40
00:03:48,160 --> 00:03:55,160
であるため、x の 2 乗グラフの高さの変化は、dx が何であれ 2 倍になります。

41
00:03:55,760 --> 00:04:02,360
したがって、df を dx で割って並べ替えると、この合計関数に対する小さな変化と、それを引き起こした x

42
00:04:02,360 --> 00:04:09,320
の小さな変化の比は、確かに x のコサインに 2x を加えたもの、つまり各部分の導関数の合計になります。

43
00:04:09,320 --> 00:04:13,720
しかし、先ほども言いましたが、製品の場合は少し事情が異なります。その理由を小さなナッジの観点からもう一度考えてみましょう。

44
00:04:13,720 --> 00:04:20,720
この場合、グラフは物事を視覚化するのに最善の策ではないと思います。

45
00:04:20,760 --> 00:04:25,120
数学ではよくあることですが、多くのレベルの数学では、2

46
00:04:25,120 --> 00:04:30,320
つのものの積を扱う場合、それをある種の領域として理解するのに役立ちます。

47
00:04:30,360 --> 00:04:34,720
この場合、辺の長さが x の正弦および

48
00:04:34,720 --> 00:04:40,520
x の 2 乗であるボックスの精神的な設定を構成しようとすると考えられます。 しかし、それは何を意味するのでしょうか？

49
00:04:40,520 --> 00:04:46,640
これらは関数であるため、これらの辺は x

50
00:04:46,640 --> 00:04:51,180
の値に応じて調整可能であると考えるかもしれません。x は単に上下に自由に調整できる数値であると考えるかもしれません。

51
00:04:51,180 --> 00:04:57,160
これが何を意味するのかを理解するには、x の関数正弦として変化する上側に注目してください。

52
00:04:57,800 --> 00:05:04,800
この x の値を 0

53
00:05:05,240 --> 00:05:10,840
から変更すると、x の正弦がピークに向かって上昇するにつれて長さ 1 まで増加し、その後、x の正弦が

54
00:05:10,840 --> 00:05:16,920
1 から下降するにつれて減少し始めます。 そして同じように、その高さは常に x の

55
00:05:16,920 --> 00:05:22,520
2 乗として変化します。 したがって、これら 2 つの関数の積として定義される x の

56
00:05:22,520 --> 00:05:29,060
f は、このボックスの面積になります。 そして導関数については、dx による x

57
00:05:29,060 --> 00:05:36,060
への小さな変更がその領域にどのような影響を与えるかを考えてみましょう。 その結果、DFエリアにどのような変化が生じたのでしょうか？

58
00:05:39,960 --> 00:05:45,580
dx を微調整すると、その幅が x の小さな d サインだけ変化し、高さが dx

59
00:05:45,620 --> 00:05:52,620
の 2 乗だけ変化します。 これにより、新しい領域の 3 つの小さなスニペットが得られます。下部の薄い長方形の面積は、幅と x

60
00:05:53,100 --> 00:05:58,920
の正弦に、薄い高さの dx の 2 乗を掛けたものです。右側の薄い長方形の面積は、高さの

61
00:05:58,920 --> 00:06:05,920
x の 2 乗です。その細い幅に x の

62
00:06:06,620 --> 00:06:13,000
d サインを掛けます。 隅にこれも少しありますが、それは無視して構いません。

63
00:06:13,000 --> 00:06:19,160
その面積は最終的には dx の 2

64
00:06:19,160 --> 00:06:24,320
乗に比例し、これまでに見たように、dx が 0 に近づくと無視できるほどになります。

65
00:06:24,320 --> 00:06:29,440
このセットアップ全体は、前回のビデオで示した x の 2 乗図と非常によく似ています。

66
00:06:29,440 --> 00:06:33,560
そして、その時と同じように、ここでも実際に見えるように描画するために多少大胆な変更を使用していることに注意してください。しかし、原則として、dx は非常に非常に小さいものであり、つまり、x の

67
00:06:33,560 --> 00:06:40,000
dx 2 乗と

68
00:06:40,000 --> 00:06:46,480
d サインも非常に小さいことを意味します。非常に少ない。

69
00:06:46,480 --> 00:06:52,000
したがって、サインと x の 2 乗の微分について私たちが知っていることを適用すると、その小さな変化 dx の 2 乗は

70
00:06:52,000 --> 00:06:59,000
dx の約 2x 倍になり、x の小さな変化 d サインは dx

71
00:06:59,040 --> 00:07:06,040
の x 倍のコサインになります。 いつものように、dx で割って、必要な比率 (df を

72
00:07:06,280 --> 00:07:13,280
dx で割った値) が、x の 2 乗微分の正弦と、sine の微分の

73
00:07:13,400 --> 00:07:19,760
x 2 乗を加えたものであることを確認します。 ここで行ったことは、サインまたは x の 2

74
00:07:19,760 --> 00:07:24,660
乗に固有のものではありません。 これと同じ推論が、任意の 2 つの関数 g と h

75
00:07:24,660 --> 00:07:28,520
に対しても機能します。 そして時々、このパターンを頭の中で「左、右、右、左」と歌うような記憶術で覚えようとする人がいます。

76
00:07:28,520 --> 00:07:33,140


77
00:07:33,180 --> 00:07:36,940
この例では、x の正弦に x の 2 乗を乗じた値があり、left

78
00:07:36,940 --> 00:07:42,700
d right ということは、左の関数である x の正弦に右の導関数を掛けたもの (この場合は

79
00:07:42,700 --> 00:07:48,700
2x) を取ることを意味します。 次に、右 d 左に、その右の関数 x

80
00:07:48,700 --> 00:07:52,780
の 2 乗を加算し、左の関数の導関数 (x のコサイン) を掛けます。

81
00:07:52,780 --> 00:07:59,780
文脈を無視して、覚えておくべきルールとして提示されると、かなり奇妙に感じられると思いますね。

82
00:07:59,780 --> 00:08:05,340
しかし、実際にこの調整可能なボックスについて考えてみると、これらの各用語が何を表しているのかがわかります。

83
00:08:05,340 --> 00:08:12,340
左 d 右はその小さな底の長方形の面積であり、右 d

84
00:08:13,100 --> 00:08:20,100
左はその長方形の側面の面積です。 ところで、定数を掛けると、たとえば x の正弦を

85
00:08:22,120 --> 00:08:28,300
2 倍すると、物事はずっと単純になることを言っておきます。 微分値は、定数に関数の微分値を乗算したものとまったく同じです。この場合、x

86
00:08:28,300 --> 00:08:33,400
のコサインの 2 倍です。

87
00:08:33,400 --> 00:08:39,300
立ち止まって熟考し、それが理にかなっているかどうかを検証するのはあなたにお任せします。

88
00:08:39,300 --> 00:08:44,540
加算と乗算のほかに、関数を組み合わせるもう 1

89
00:08:44,540 --> 00:08:49,260
つの一般的な方法は、信じてください、これは常に登場しますが、一方をもう一方の中に押し込む、つまり関数の合成です。

90
00:08:49,260 --> 00:08:54,340
たとえば、関数 x の

91
00:08:54,660 --> 00:08:59,660
2 乗を取得し、それを x の正弦の内側に押し込み、この新しい関数 x の 2

92
00:08:59,660 --> 00:09:05,540
乗の正弦を取得するかもしれません。 その新しい関数の派生関数は何だと思いますか?

93
00:09:05,540 --> 00:09:09,980
これをじっくり考えるために、創造的な数学にはたくさんの選択肢があることを強調するために、物事を視覚化するさらに別の方法を選択します。

94
00:09:09,980 --> 00:09:15,700
3 つの異なる数直線を用意します。一番上の直線は x の値を保持し、2

95
00:09:15,700 --> 00:09:22,120
番目の直線は x の 2 乗の値を保持し、3 番目の直線は x の

96
00:09:22,120 --> 00:09:27,460
2 乗の正弦の値、つまり関数を保持します。 x 2 乗を使用すると 1 行目から

97
00:09:27,460 --> 00:09:32,680
2 行目まで移動でき、関数 sine を使用すると 2 行目から 3 行目まで移動できます。

98
00:09:32,680 --> 00:09:37,300
この x の値を中心にシフトし、おそらく値 3 まで移動すると、2

99
00:09:37,300 --> 00:09:44,040
番目の値は x の 2 乗に固定されたままになり、この場合は 9

100
00:09:44,040 --> 00:09:49,560
まで移動し、その下の値は x の 2 乗の正弦になります。

101
00:09:49,560 --> 00:09:57,680
9 の正弦がたまたまあるものに移動します。 したがって、導関数については、その x 値を少し

102
00:09:57,680 --> 00:10:03,280
dx だけ微調整することから再び始めましょう。 私はいつも、x が実際の具体的な数値 (おそらく

103
00:10:03,280 --> 00:10:09,720
1) から始まると考えると役立つと思います。 この場合は5です。 結果として生じる 2 番目の値へのナッジ、つまり

104
00:10:09,720 --> 00:10:16,720
dx によって引き起こされる x の 2 乗の変化は、dx の 2 乗です。

105
00:10:17,240 --> 00:10:24,240
これを 2x x dx として拡張できます。これは、特定の入力では 2 x 1 になります。 dx

106
00:10:25,040 --> 00:10:31,160
の 5 倍ですが、少なくとも現時点では、物事を dx の 2 乗として記述するのに役立ちます。

107
00:10:31,160 --> 00:10:37,520
実際、さらに一歩進んで、この x の 2 乗に新しい名前 (おそらく

108
00:10:37,520 --> 00:10:42,760
h) を付けて、このナッジに対して dx 二乗と書く代わりに dh と書きます。

109
00:10:42,760 --> 00:10:48,120
これにより、h の正弦に固定される 3 番目の値について考えることが容易になります。

110
00:10:48,120 --> 00:10:55,120
その変化は h の d サイン、つまり dh のナッジによって引き起こされる小さな変化です。

111
00:10:55,160 --> 00:10:59,200
ちなみに、dh バンプが右に移動しているのに左に移動しているという事実は、この変化、h の

112
00:10:59,200 --> 00:11:04,860
d サインが何らかの負の数になることを意味します。

113
00:11:04,860 --> 00:11:08,360
もう一度、サインの導関数に関する知識を活用することができます。

114
00:11:08,400 --> 00:11:13,140
この h の d サインは、h のコサインに

115
00:11:13,140 --> 00:11:16,760
dh を掛けたものになります。 これが、サインの導関数がコサインになることを意味します。

116
00:11:16,760 --> 00:11:21,840
物事を展開すると、h を x の 2

117
00:11:21,840 --> 00:11:26,880
乗に再度置き換えることができるため、一番下のナッジのコサインのサイズが x の 2 乗に dx の

118
00:11:26,880 --> 00:11:33,080
2 乗を掛けたものになることがわかります。 実際、物事をさらに展開してみましょう。

119
00:11:33,080 --> 00:11:39,680
その中間ナッジ dx の 2 乗は、dx の約 2 倍になります。

120
00:11:39,680 --> 00:11:44,440
このような表現が実際に何を意味するのかを思い出すことは常に良い習慣です。

121
00:11:44,440 --> 00:11:50,240
この場合、x から開始した場所は 1 に等しくなります。 上の 5 では、この式全体が、3

122
00:11:50,240 --> 00:11:57,240
行目のナッジのサイズが約 1 のコサインになることを示しています。 5の2乗×2×1。

123
00:11:57,280 --> 00:12:02,320
dx のサイズに関係なく 5 倍。

124
00:12:02,320 --> 00:12:07,360
これは dx のサイズに比例し、この導関数によりその比例定数が得られます。

125
00:12:07,360 --> 00:12:13,080
ここで何が判明したかに注目してください。

126
00:12:13,080 --> 00:12:18,580
外側の関数の導関数があり、それは依然として変更されていない内側の関数を取り込み、それをその内側の関数の導関数で乗算します。

127
00:12:18,580 --> 00:12:25,580


128
00:12:26,580 --> 00:12:31,500
x の正弦または x の 2 乗については特別なことは何もありません。 x の g と

129
00:12:31,500 --> 00:12:38,500
x の h という 2 つの関数がある場合、それらの合成の導関数、g of h

130
00:12:38,500 --> 00:12:45,500
of x は、h で評価された g の導関数に h の導関数を乗算したものになります。

131
00:12:47,600 --> 00:12:52,660
このパターンは、通常、連鎖規則と呼ばれるものです。

132
00:12:52,660 --> 00:12:59,300
gの導関数については、dg dxではなくdg dhと書いています。 記号レベルでは、これは導関数に接続するものは依然として中間関数

133
00:12:59,300 --> 00:13:04,020
h であることを思い出させます。

134
00:13:04,020 --> 00:13:09,200
しかしそれ以上に、これは外部関数の導関数が実際に何を表しているのかを反映する重要な点です。

135
00:13:09,200 --> 00:13:13,100


136
00:13:13,100 --> 00:13:18,820
3 つのラインの設定で、その底部のサインの導関数を取得したときに、そのナッジのサイズ d sine を h

137
00:13:18,820 --> 00:13:25,580
と dh の掛け合わせのコサインとして拡張したことを思い出してください。 これは、その下部ナッジのサイズが

138
00:13:25,580 --> 00:13:33,300
x にどのように依存するのかがすぐには分からなかったためです。

139
00:13:33,300 --> 00:13:38,820
しかし、中間変数 h に関して導関数を求めることはできます。 つまり、3

140
00:13:38,820 --> 00:13:43,380
行目のナッジのサイズを、2 行目のナッジのサイズである dh

141
00:13:43,380 --> 00:13:48,620
の倍数として表現する方法を考え出します。 その後、dh

142
00:13:48,620 --> 00:13:53,820
が何であるかを理解することでさらに展開が始まりました。

143
00:13:53,820 --> 00:13:58,100
この連鎖ルール式では、最終出力である g の小さな変化と、それを引き起こした h の小さな変化との比率を調べてください

144
00:13:58,100 --> 00:14:03,860
(h は g に代入する値です) と言っています。

145
00:14:03,860 --> 00:14:10,440
次に、それに h の小さな変化を掛け、それを引き起こした x の小さな変化で割ります。

146
00:14:10,440 --> 00:14:16,800
これらの

147
00:14:16,800 --> 00:14:21,860
dh

148
00:14:21,860 --> 00:14:24,160
が相殺され、最終的な出力の変化と、特定の一連のイベントによってそれがもたらされた入力の変化との間の比率が得られることに注意してください。

149
00:14:24,160 --> 00:14:29,640
dh

150
00:14:29,640 --> 00:14:37,240
の取り消しは単なる表記上のトリックではなく、私たちがデリバティブで行うすべてのことを支える小さなナッジで何が起こっているかを純粋に反映しています。

151
00:14:37,240 --> 00:14:41,280
これらは、多くの小さなものを組み合わせた関数の派生関数を処理するために備えておくべき 3 つの基本ツールです。

152
00:14:41,280 --> 00:14:46,700
合計ルール、積ルール、連鎖ルールがあります。

153
00:14:46,700 --> 00:14:48,720


154
00:14:48,720 --> 00:14:52,200
正直に言うと、連鎖ルールと積ルールが何であるかを知っていることと、実際にそれらを最も困難な状況にさえ流暢に適用できることの間には大きな違いがあります。

155
00:14:52,200 --> 00:14:56,860


156
00:14:56,860 --> 00:15:02,800
微積分の仕組みに関するビデオを視聴することは、微積分の仕組みを自分で練習し、計算を行うための筋肉を鍛えることに代わるものではありません。

157
00:15:02,800 --> 00:15:07,900


158
00:15:07,900 --> 00:15:13,200
あなたの代わりにそうすることを提案できれば本当によかったのですが、残念ながらボールはあなたのコートにあり、練習を求めているのです。

159
00:15:13,200 --> 00:15:18,240


160
00:15:18,240 --> 00:15:23,080
私が提供できること、そして提供できればと願っていることは、これらのルールが実際にどこから来たのかを示すことです。

161
00:15:23,080 --> 00:15:27,580
これらは単に暗記して叩き込むものではなく、自然なパターンであり、派生語が実際に何を意味するのかを辛抱強く考え抜くだけで発見できるものであることを示すためです。

162
00:15:27,580 --> 00:15:32,520


163
00:15:32,520 --> 00:15:35,160


