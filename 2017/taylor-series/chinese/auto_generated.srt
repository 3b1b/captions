1
00:00:14,912 --> 00:00:18,600
当我第一次了解泰勒级数时，我绝

2
00:00:18,600 --> 00:00:20,180
对没有意识到它们有多么重要。

3
00:00:20,180 --> 00:00:24,800
但它们一次又一次地出现在数学、物理和许多工程领域，

4
00:00:24,800 --> 00:00:30,080
因为它们是数学为逼近函数提供的最强大的工具之一。

5
00:00:30,080 --> 00:00:34,000
我想，作为一名学生，我第一次意识到这一

6
00:00:34,000 --> 00:00:35,960
点并不是在微积分课上，而是在物理课上。

7
00:00:35,960 --> 00:00:40,560
我们正在研究一个与钟摆势能有关的问题，为

8
00:00:40,560 --> 00:00:45,000
此你需要一个表达式来表达钟摆的重量高于其

9
00:00:45,000 --> 00:00:49,720
最低点的高度，当你计算出来时，结果是与

10
00:00:49,720 --> 00:00:54,080
1 减去摆锤与垂线夹角的余弦值成正比。

11
00:00:54,080 --> 00:00:57,840
我们试图解决的问题的细节超出了这里的重点，但我要

12
00:00:57,840 --> 00:01:03,360
说的是，这个余弦函数使问题变得尴尬和难以处理，

13
00:01:03,360 --> 00:01:07,680
并且使摆与其他振荡现象之间的关系变得不太清楚。

14
00:01:07,680 --> 00:01:14,440
但如果你将 θ 的余弦近似为 1 减去 2

15
00:01:14,440 --> 00:01:17,080
的 θ 平方，那么一切就更容易实现了。

16
00:01:17,080 --> 00:01:21,360
如果你以前从未见过这样的东西，那么这样的

17
00:01:21,360 --> 00:01:23,900
近似可能看起来完全超出了你的想象范围。

18
00:01:23,900 --> 00:01:29,440
如果你将 theta 的余弦与这个函数（1 减去 2 的 2 的平方）一

19
00:01:29,440 --> 00:01:34,720
起绘制出来，它们看起来确实非常接近，至少对于接近 0 的小角度来说是这样

20
00:01:34,720 --> 00:01:41,360
，但是你会如何考虑进行这种近似，以及你会如何做找到那个特定的二次方程？

21
00:01:41,360 --> 00:01:46,220
泰勒级数的研究主要是采用非多项式函数并

22
00:01:46,220 --> 00:01:49,660
找到在某些输入附近逼近它们的多项式。

23
00:01:49,820 --> 00:01:53,940
这里的动机是多项式往往比其他函数更容易处理。

24
00:01:53,940 --> 00:01:58,420
它们更容易计算，更容易求导

25
00:01:58,420 --> 00:02:00,700
，更容易集成，而且更友好。

26
00:02:00,700 --> 00:02:05,400
因此，让我们看一下 x 的余弦函数，并真正花点时间

27
00:02:05,400 --> 00:02:11,220
思考一下如何构造 x 等于 0 附近的二次近似值。

28
00:02:11,220 --> 00:02:18,340
也就是说，在看起来像 c0 加 c1 乘以 x 加 c2

29
00:02:18,340 --> 00:02:24,860
乘以 x 平方的所有可能多项式中，对于这些常数 c0、c1

30
00:02:24,860 --> 00:02:30,940
和 c2 的某些选择，找到最接近 x 接近 x 等于 0

31
00:02:30,940 --> 00:02:33,500
的 x 余弦的多项式，其图形与该点的余弦 x 图形类似。

32
00:02:33,500 --> 00:02:40,020
好吧，首先，在输入 0 处，x 的余弦值为 1，因此如果我们的近

33
00:02:40,020 --> 00:02:45,860
似值有任何好处，那么在输入 x 等于 0 处它也应该等于 1。

34
00:02:45,860 --> 00:02:53,260
代入 0 只会得到 c0 的结果，因此我们可以将其设置为 1。

35
00:02:53,260 --> 00:02:57,580
这让我们可以自由选择常数 c1 和 c2 来使近

36
00:02:57,580 --> 00:03:01,860
似值尽可能好，但我们对它们所做的任何事情都不会改

37
00:03:01,860 --> 00:03:05,580
变多项式在 x 等于 0 时等于 1 的事实。

38
00:03:05,580 --> 00:03:10,220
如果我们的近似值与该感兴趣点的余弦

39
00:03:10,220 --> 00:03:11,700
x 具有相同的切线斜率，那就太好了。

40
00:03:11,740 --> 00:03:16,740
否则，近似值偏离余弦图的速度会比需要的快得多。

41
00:03:18,300 --> 00:03:24,100
余弦的导数是负正弦，在 x 等于 0

42
00:03:24,100 --> 00:03:27,500
时，即等于 0，意味着切线完全平坦。

43
00:03:27,500 --> 00:03:33,260
另一方面，当你计算二次方程的导数时，你会得

44
00:03:33,260 --> 00:03:35,240
到 c1 加 2 乘以 c2 乘以 x。

45
00:03:35,240 --> 00:03:40,280
当 x 等于 0 时，这恰好等于我们为 c1 选择的值。

46
00:03:40,280 --> 00:03:45,440
所以这个常数 c1 完全控制了

47
00:03:45,440 --> 00:03:47,200
x 等于 0 的近似值的导数。

48
00:03:47,200 --> 00:03:53,480
将其设置为 0 可确保我们的近似值在该点也具有平坦的切线。

49
00:03:53,480 --> 00:03:58,760
这让我们可以自由地更改 c2，但 x 等于 0

50
00:03:58,760 --> 00:04:04,360
处的多项式的值和斜率被锁定以匹配余弦的值和斜率。

51
00:04:04,360 --> 00:04:08,940
最后要利用的是余弦图在 x 等于 0

52
00:04:08,980 --> 00:04:13,460
上方向下弯曲的事实，它具有负二阶导数。

53
00:04:13,460 --> 00:04:17,820
或者换句话说，即使该点的变化率为 0

54
00:04:17,820 --> 00:04:21,300
，但在该点附近变化率本身正在减小。

55
00:04:21,300 --> 00:04:26,980
具体来说，由于它的导数是x的负正弦，所以它的二阶

56
00:04:26,980 --> 00:04:33,140
导数是x的负余弦，并且当x等于0时，它等于负1。

57
00:04:33,140 --> 00:04:37,020
现在，以同样的方式，我们希望近似值的导数与

58
00:04:37,100 --> 00:04:41,980
余弦的导数相匹配，以便它们的值不会不必要地

59
00:04:41,980 --> 00:04:47,260
快速漂移，确保它们的二阶导数匹配将确保它们

60
00:04:47,260 --> 00:04:52,260
以相同的速率弯曲，即我们的多项式的斜率偏离

61
00:04:52,260 --> 00:04:54,500
余弦 x 的斜率的速度不会比需要的更快。

62
00:04:54,500 --> 00:04:59,280
提取我们之前得到的相同导数，然后求其导数，我们发

63
00:04:59,280 --> 00:05:05,020
现该多项式的二阶导数恰好是 c2 的 2 倍。

64
00:05:05,020 --> 00:05:10,620
因此，为了确保 x 等于 0 时二阶导数也等于负 1，2 乘以

65
00:05:10,620 --> 00:05:16,820
c2 必须为负 1，这意味着 c2 本身应该为负 1 一半。

66
00:05:16,820 --> 00:05:23,180
这给出了近似值 1 加 0x 减 1 x 平方的一半。

67
00:05:23,180 --> 00:05:29,460
如果您估计余弦为 0，则可以感受一下它有多好。1 使用这

68
00:05:29,460 --> 00:05:32,860
个多项式，你会估计它是 0。995.

69
00:05:32,860 --> 00:05:36,020
这就是 0 余弦的真实值。1.

70
00:05:36,020 --> 00:05:40,420
这是一个非常好的近似！

71
00:05:40,420 --> 00:05:43,000
花点时间反思一下刚刚发生的事情。

72
00:05:43,000 --> 00:05:49,540
这个二次近似有 3 个自由度，即常数 c0、c1 和 c2。

73
00:05:49,540 --> 00:05:54,520
c0 负责确保近似值的输出与 x 等

74
00:05:54,520 --> 00:05:57,180
于 0 处的余弦 x 的输出相匹配。

75
00:05:57,180 --> 00:06:05,100
c1 负责确保此时的导数匹配，

76
00:06:05,100 --> 00:06:09,420
c2 负责确保二阶导数匹配。

77
00:06:09,420 --> 00:06:14,820
这确保了当您远离 x 等于 0 时近似值的变

78
00:06:14,820 --> 00:06:19,620
化方式以及变化率本身变化的方式与余弦 x

79
00:06:19,620 --> 00:06:24,340
的行为尽可能相似（考虑到您拥有的控制量）。

80
00:06:24,340 --> 00:06:28,860
您可以通过在多项式中允许更多项并匹配

81
00:06:28,860 --> 00:06:30,860
更高阶的导数来给自己更多的控制权。

82
00:06:30,860 --> 00:06:36,580
例如，假设您添加了项 c3 乘以 x3 以获得某个常数 c3。

83
00:06:36,580 --> 00:06:42,860
在这种情况下，如果对三次多项式求三阶导

84
00:06:42,860 --> 00:06:45,700
数，任何二次或更小的值都会变为 0。

85
00:06:45,700 --> 00:06:52,420
至于最后一项，在幂律迭代 3 次之后，它看起

86
00:06:52,420 --> 00:06:56,700
来像 1 乘以 2 乘以 3 乘以 c3。

87
00:06:56,700 --> 00:07:01,860
另一方面，余弦 x 的三阶导数得出正弦

88
00:07:01,860 --> 00:07:04,020
x，在 x 等于 0 时它等于 0。

89
00:07:04,020 --> 00:07:09,920
因此，为了确保三阶导数匹配，常数 c3 应为 0。

90
00:07:09,920 --> 00:07:15,940
或者换句话说，1 minus 1 half x2 不仅

91
00:07:15,940 --> 00:07:21,580
是余弦的最佳二次近似值，而且也是最佳可能的三次近似值。

92
00:07:21,580 --> 00:07:28,060
您可以通过添加四阶项（c4 乘以 x 到四项）来进行改进。

93
00:07:28,060 --> 00:07:34,340
余弦的四阶导数是它本身，在 x 等于 0 时等于 1。

94
00:07:34,340 --> 00:07:38,260
这个新项的多项式的四阶导数是多少？

95
00:07:38,260 --> 00:07:43,160
好吧，当你一遍又一遍地应用幂法则时，那些指数都在

96
00:07:43,160 --> 00:07:50,240
前面向下跳跃，你最终会得到 1 乘以 2 乘以

97
00:07:50,240 --> 00:07:51,700
3 乘以 4 乘以 c4，即 24 乘以 c4。

98
00:07:51,700 --> 00:07:58,280
因此，如果我们希望它与余弦 x 的四阶导数（即

99
00:07:58,280 --> 00:07:59,280
1）相匹配，则 c4 必须为 24 分之 1。

100
00:07:59,280 --> 00:08:06,660
事实上，多项式 1 减 1 半 x2 加 1 24 乘以 x 的四次方

101
00:08:06,660 --> 00:08:13,820
，看起来像这样，是关于 x 等于 0 的余弦 x 的非常接近的近似值。

102
00:08:13,820 --> 00:08:18,540
例如，在任何涉及小角度余弦的物理问

103
00:08:18,540 --> 00:08:23,520
题中，如果用这个多项式代替 x 的

104
00:08:23,520 --> 00:08:26,220
余弦，预测结果几乎不会明显不同。

105
00:08:26,220 --> 00:08:30,620
现在退一步，注意这个过程中发生的一些事情。

106
00:08:30,620 --> 00:08:35,060
首先，阶乘项在这个过程中很自然地出现。

107
00:08:35,060 --> 00:08:39,500
当你对函数 x 求 n 个连续的导数到 n

108
00:08:39,500 --> 00:08:46,580
时，让幂律继续向下级联，你剩下的就是 1

109
00:08:46,580 --> 00:08:49,460
乘以 2 乘以 3，一直到 n 的值。

110
00:08:49,460 --> 00:08:53,780
因此，您不能简单地将多项式的系

111
00:08:53,780 --> 00:08:54,780
数设置为等于您想要的任何导数。

112
00:08:54,780 --> 00:08:59,500
您必须除以适当的阶乘才能抵消这种影响。

113
00:08:59,500 --> 00:09:05,260
例如，第四个系数的 x 是余弦的四阶

114
00:09:05,260 --> 00:09:09,540
导数 1，但除以 4 阶乘 24。

115
00:09:09,540 --> 00:09:14,500
第二件需要注意的事情是，添加新术语，例如 c4 乘以

116
00:09:14,500 --> 00:09:20,140
x 到第四个，不会弄乱旧术语应该是什么，这非常重要。

117
00:09:20,140 --> 00:09:25,740
例如，该多项式在 x 等于 0 处的二阶导数仍然等于第

118
00:09:25,740 --> 00:09:31,060
二个系数的 2 倍，即使在引入更高阶项之后也是如此。

119
00:09:31,060 --> 00:09:35,860
这是因为我们代入的 x 等于 0，因此任何

120
00:09:35,860 --> 00:09:40,820
包含 x 的高阶项的二阶导数都会被冲走。

121
00:09:40,820 --> 00:09:45,780
对于任何其他导数也是如此，这就是为什么多项式在 x

122
00:09:45,780 --> 00:09:52,680
等于 0 处的每个导数都由一个且仅一个系数控制。

123
00:09:52,680 --> 00:09:58,220
相反，如果您近似于 0 以外的输入，例如 x 等于

124
00:09:58,220 --> 00:10:02,320
pi，为了获得相同的效果，您必须根据 x 减去

125
00:10:02,320 --> 00:10:06,480
pi 的幂或您正在查看的任何输入来编写多项式。

126
00:10:06,480 --> 00:10:10,760
这使得它看起来明显更复杂，但我们所做的就是确保点

127
00:10:10,760 --> 00:10:17,140
pi 看起来和行为都像 0，这样插入 x 等于

128
00:10:17,140 --> 00:10:22,700
pi 将导致很多很好的取消，只留下一个常量。

129
00:10:22,700 --> 00:10:27,320
最后，在更哲学的层面上，请注意我们在这里所做

130
00:10:27,320 --> 00:10:33,740
的基本上是获取有关函数在单个点的高阶导数的信

131
00:10:33,740 --> 00:10:41,420
息，并将其转换为有关该点附近函数值的信息。

132
00:10:41,420 --> 00:10:44,580
您可以根据需要获取任意数量的余弦导数。

133
00:10:44,580 --> 00:10:49,460
它遵循这个很好的循环模式，x 的余弦，

134
00:10:49,460 --> 00:10:52,380
x 的负正弦，负余弦，正弦，然后重复。

135
00:10:52,380 --> 00:10:56,900
在 x 等于 0 时，每一个的值都很容易计算，它给出

136
00:10:56,900 --> 00:11:02,060
了这个循环模式 1, 0，负 1, 0，然后重复。

137
00:11:02,060 --> 00:11:06,660
了解所有这些高阶导数的值就可以获得有关 x 余弦的

138
00:11:06,660 --> 00:11:14,540
大量信息，即使它只涉及插入一个数字，x 等于 0。

139
00:11:14,540 --> 00:11:19,260
因此，我们正在做的是利用这些信息来获得该输入的近似值，您可以通

140
00:11:19,260 --> 00:11:24,740
过创建一个多项式来实现这一点，该多项式的高阶导数被设计为与余弦

141
00:11:24,740 --> 00:11:31,660
的导数匹配，遵循相同的 1, 0, 负 1, 0、循环模式。

142
00:11:31,660 --> 00:11:36,900
为此，您只需使多项式的每个系数遵循相同的

143
00:11:36,900 --> 00:11:40,140
模式，但必须将每个系数除以适当的阶乘。

144
00:11:40,180 --> 00:11:44,660
正如我之前提到的，这可以抵消

145
00:11:44,660 --> 00:11:47,340
许多幂律应用程序的级联效应。

146
00:11:47,340 --> 00:11:52,100
通过在任意点停止此过程得到的多项

147
00:11:52,100 --> 00:11:53,860
式称为 x 余弦的泰勒多项式。

148
00:11:53,860 --> 00:11:58,440
更一般地，因此更抽象地，如果我们处理除余弦之外的其他

149
00:11:58,440 --> 00:12:03,860
函数，您将计算它的导数、二阶导数等等，获得您想要的尽

150
00:12:03,860 --> 00:12:09,780
可能多的项，并且您将评估每一项其中 x 等于 0。

151
00:12:09,820 --> 00:12:16,660
对于多项式近似，每个 x 到 n 项的系数应为在 0

152
00:12:16,660 --> 00:12:23,900
处计算的函数的 n 次导数的值，但除以 n 阶乘。

153
00:12:23,900 --> 00:12:29,400
您可能会在任何涉及泰勒多项式的文本或

154
00:12:29,400 --> 00:12:31,940
课程中看到这个整个相当抽象的公式。

155
00:12:31,940 --> 00:12:36,420
当你看到它时，想想常数项确保

156
00:12:36,420 --> 00:12:39,200
多项式的值与 f 的值匹配。

157
00:12:39,280 --> 00:12:44,600
下一项确保多项式的斜率与 x 等

158
00:12:44,600 --> 00:12:46,360
于 0 处的函数的斜率相匹配。

159
00:12:46,360 --> 00:12:51,280
下一项确保斜率变化的速率在该点相同，

160
00:12:51,280 --> 00:12:54,680
依此类推，具体取决于您想要的项数。

161
00:12:54,680 --> 00:12:58,400
您选择的项越多，近似值就越接近，

162
00:12:58,400 --> 00:13:02,720
但代价是您得到的多项式会更复杂。

163
00:13:02,720 --> 00:13:07,040
为了让事情变得更一般化，如果你想近似接近 0 以外的某个

164
00:13:07,080 --> 00:13:13,080
输入（我们称之为 a），你可以用 x 减 a 的幂来写这

165
00:13:13,080 --> 00:13:19,320
个多项式，然后你可以计算 f 的所有导数在该输入处，a。

166
00:13:19,320 --> 00:13:24,280
这就是泰勒多项式最普遍的样子。

167
00:13:24,280 --> 00:13:29,600
更改 a 的值会导致该近似值接近原始函数

168
00:13:29,600 --> 00:13:36,000
，其高阶导数将等于原始函数的高阶导数。

169
00:13:36,040 --> 00:13:40,560
最简单、有意义的例子之一是函数 e

170
00:13:40,560 --> 00:13:43,280
与输入 x 周围的 x 等于 0。

171
00:13:43,280 --> 00:13:47,520
计算导数非常好，尽可能好，因为 e 对 x

172
00:13:47,520 --> 00:13:53,180
的导数是它本身，所以二阶导数也是 e 对

173
00:13:53,180 --> 00:13:54,460
x 的导数，三阶导数也是如此，依此类推。

174
00:13:54,460 --> 00:13:59,240
所以当 x 等于 0 时，所有这些都等于 1。

175
00:13:59,240 --> 00:14:09,000
这意味着我们的多项式近似应该看起来像 1 加 1 乘以 x

176
00:14:09,000 --> 00:14:17,480
加 1 除以 2 乘以 x 的平方加上 1 除以 3

177
00:14:17,480 --> 00:14:19,840
阶乘乘以 x 的立方，依此类推，具体取决于您想要的项数。

178
00:14:19,840 --> 00:14:22,800
这些是 e 到 x 的泰勒多项式。

179
00:14:22,800 --> 00:14:31,360
好的，以此为基础，本着向您展示微积分的所有主题之间

180
00:14:31,360 --> 00:14:36,280
的相互联系的精神，让我转向一些有趣的东西，一种完全

181
00:14:36,280 --> 00:14:41,420
不同的方式来理解泰勒多项式的二阶项，但是几何上。

182
00:14:41,420 --> 00:14:45,160
它与微积分的基本定理有关，如果您需要快速回顾一

183
00:14:45,160 --> 00:14:48,200
下，我在第 1 章和第 8 章中讨论过该定理。

184
00:14:48,200 --> 00:14:53,340
就像我们在这些视频中所做的那样，考虑一个函数，它

185
00:14:53,340 --> 00:14:56,280
给出了固定左点和可变右点之间的某个图形下的面积。

186
00:14:56,280 --> 00:15:01,480
我们在这里要做的是考虑如何近似这个面积函数，而

187
00:15:01,480 --> 00:15:05,120
不是像我们之前所做的那样计算图形本身的函数。

188
00:15:05,120 --> 00:15:09,920
专注于该区域将使二阶项弹出。

189
00:15:09,920 --> 00:15:16,460
请记住，微积分的基本定理是，该图本身表示面积函数的

190
00:15:16,460 --> 00:15:21,780
导数，这是因为将 dx 稍微推到面积的右边界会给

191
00:15:21,780 --> 00:15:30,480
出一个新的面积位，大约等于图的高度乘以 dx 。

192
00:15:30,480 --> 00:15:36,060
对于越来越小的 dx 选择，该近似值越来越准确。

193
00:15:36,060 --> 00:15:39,700
但是，如果您想更准确地了解面积的变化，考虑

194
00:15:39,700 --> 00:15:44,900
到 x 的一些变化并不意味着接近 0，您就

195
00:15:44,900 --> 00:15:48,860
必须考虑这里的这部分，它大约是一个三角形。

196
00:15:48,860 --> 00:15:56,460
我们将起始输入命名为 a，将其上方的微

197
00:15:56,460 --> 00:15:58,620
移输入命名为 x，因此更改为 xa。

198
00:15:58,620 --> 00:16:06,140
该小三角形的底边是变化 xa，

199
00:16:06,140 --> 00:16:08,540
其高度是图形的斜率乘以 xa。

200
00:16:08,540 --> 00:16:14,140
由于该图是面积函数的导数，因此其斜率是面

201
00:16:14,180 --> 00:16:18,580
积函数的二阶导数，在输入 a 处计算。

202
00:16:18,580 --> 00:16:24,140
因此，该三角形的面积（底边的 1 倍乘以高度）是该面积函数

203
00:16:24,140 --> 00:16:31,300
的二阶导数的 1 倍（以 a 计算）乘以 xa 的平方。

204
00:16:31,300 --> 00:16:35,180
这正是泰勒多项式所看到的。

205
00:16:35,180 --> 00:16:40,920
如果您知道该面积函数在 a 点的各种导

206
00:16:40,920 --> 00:16:46,040
数信息，您将如何近似 x 点的面积？

207
00:16:46,040 --> 00:16:52,480
你必须包括a的所有面积，a的f，加上这里矩形的

208
00:16:52,480 --> 00:16:58,240
面积，即一阶导数，乘以xa，加上那个小三角形

209
00:16:58,240 --> 00:17:02,880
的面积，即二阶导数的1倍，乘以xa 的平方。

210
00:17:02,880 --> 00:17:07,220
我真的很喜欢这个，因为尽管写起来有点乱，但每个

211
00:17:07,220 --> 00:17:13,700
术语都有非常明确的含义，你可以在图表上指出。

212
00:17:13,700 --> 00:17:17,720
如果您愿意，我们可以到此结束，您将拥有一个非

213
00:17:17,720 --> 00:17:21,700
常有用的工具来使用这些泰勒多项式进行近似。

214
00:17:21,700 --> 00:17:26,460
但如果您像数学家一样思考，您可能会问的一个问

215
00:17:26,460 --> 00:17:31,740
题是，永不停歇地添加无限多个项是否有意义。

216
00:17:31,740 --> 00:17:37,040
在数学中，无限和称为级数，因此即使这些具有

217
00:17:37,040 --> 00:17:42,880
有限多项项的近似之一称为泰勒多项式，将所

218
00:17:42,880 --> 00:17:45,720
有无限多项项相加即可得到所谓的泰勒级数。

219
00:17:45,720 --> 00:17:49,760
你必须非常小心无限级数的想法，因为

220
00:17:49,760 --> 00:17:54,400
添加无限多的东西实际上没有意义，你

221
00:17:54,400 --> 00:17:57,840
只能多次点击计算器上的加号按钮。

222
00:17:57,840 --> 00:18:01,800
但是，如果您有一个级数，其中添加越来越多的

223
00:18:01,800 --> 00:18:08,000
项（这在每一步都有意义），使您越来越接近

224
00:18:08,000 --> 00:18:10,800
某个特定值，则您可以说该级数收敛于该值。

225
00:18:10,800 --> 00:18:15,440
或者，如果您愿意扩展等式的定义以包括

226
00:18:15,440 --> 00:18:21,240
这种级数收敛，您会说级数作为一个整体

227
00:18:21,240 --> 00:18:23,880
，即这个无限和，等于它收敛到的值。

228
00:18:23,880 --> 00:18:29,320
例如，查看 e 到 x 的泰勒多项式，

229
00:18:29,320 --> 00:18:31,280
然后插入一些输入，例如 x 等于 1。

230
00:18:31,280 --> 00:18:37,060
当你添加越来越多的多项式项时，总和越来越接

231
00:18:37,060 --> 00:18:44,000
近值 e，因此你可以说这个无穷级数收敛到数

232
00:18:44,000 --> 00:18:48,080
字 e，或者说同样的事情，它等于数字 e。

233
00:18:48,080 --> 00:18:53,800
事实上，事实证明，如果你代入 x 的任何其他值，

234
00:18:53,800 --> 00:18:59,200
例如 x 等于 2，并查看该值处的更高阶泰勒多项

235
00:18:59,200 --> 00:19:05,320
式的值，它们将向 e 收敛到 x，即e 平方。

236
00:19:05,320 --> 00:19:11,340
对于任何输入都是如此，无论它距离 0 有多远，即使这些

237
00:19:11,340 --> 00:19:18,540
泰勒多项式仅根据输入 0 处收集的导数信息构造而成。

238
00:19:18,540 --> 00:19:24,320
在这种情况下，我们说 x 的 e 等于所有输

239
00:19:24,320 --> 00:19:29,000
入 x 处的泰勒级数，这是一件神奇的事情。

240
00:19:29,000 --> 00:19:34,280
尽管这对于其他几个重要函数（例如正弦和余

241
00:19:34,280 --> 00:19:39,320
弦）也是如此，但有时这些级数仅在您正在使

242
00:19:39,320 --> 00:19:41,640
用其导数信息的输入周围的一定范围内收敛。

243
00:19:41,640 --> 00:19:46,640
如果您计算出输入 x 等于 1 附近 x 的自然对数

244
00:19:46,640 --> 00:19:52,380
的泰勒级数（这是通过评估 x 等于 1 处 x 的自

245
00:19:52,380 --> 00:19:56,340
然对数的高阶导数而构建的），那么它看起来就是这样的。

246
00:19:56,340 --> 00:20:01,500
当您插入 0 到 2 之间的输入时，添加越来越多

247
00:20:01,500 --> 00:20:06,460
的该级数项确实会让您越来越接近该输入的自然对数。

248
00:20:06,460 --> 00:20:12,580
但超出这个范围，即使只有一点点，该系列也无法达到任何目标。

249
00:20:12,580 --> 00:20:18,260
当你添加越来越多的条款时，总和会剧烈地来回波动。

250
00:20:18,260 --> 00:20:23,620
正如您可能期望的那样，它不会接近该值的自然对数，即使

251
00:20:23,620 --> 00:20:28,640
x 的自然对数对于 2 以上的输入来说是完美定义的。

252
00:20:28,640 --> 00:20:34,520
从某种意义上说，x 等于 1 时 x

253
00:20:34,520 --> 00:20:36,740
的 ln 的导数信息不会传播那么远。

254
00:20:36,740 --> 00:20:41,240
在这样的情况下，添加更多级数项并不

255
00:20:41,240 --> 00:20:44,280
能解决任何问题，您可以说级数发散。

256
00:20:44,280 --> 00:20:48,640
您近似的输入与这些多项式的输

257
00:20:48,640 --> 00:20:54,380
出实际收敛的点之间的最大距

258
00:20:54,380 --> 00:20:57,040
离称为泰勒级数的收敛半径。

259
00:20:57,040 --> 00:20:59,620
关于泰勒级数还有更多需要了解。

260
00:20:59,620 --> 00:21:04,740
有许多用例、对这些近似值的误差设置界限的

261
00:21:04,740 --> 00:21:09,540
策略、用于理解级数何时收敛和不收敛的测

262
00:21:09,540 --> 00:21:13,760
试，就这一点而言，还有更多关于微积分的整

263
00:21:13,760 --> 00:21:15,620
体知识和无数未触及的主题通过这个系列。

264
00:21:15,620 --> 00:21:19,960
这些视频的目标是为您提供基本的直觉，

265
00:21:19,960 --> 00:21:25,440
让您在自己学习更多内容时感到自信和高

266
00:21:25,440 --> 00:21:28,200
效，甚至有可能自己重新发现更多主题。

267
00:21:28,200 --> 00:21:33,080
就泰勒级数而言，当您探索更多内容时

268
00:21:33,080 --> 00:21:39,260
要记住的基本直觉是，它们将单个点的

269
00:21:39,260 --> 00:21:44,320
导数信息转换为该点周围的近似信息。

270
00:21:44,320 --> 00:21:47,320
再次感谢所有支持这个系列的人。

271
00:21:47,320 --> 00:21:51,540
下一个类似的系列将是关于概率的，如果您想在

272
00:21:51,540 --> 00:21:53,000
这些视频制作时尽早访问，您知道该去哪里。

