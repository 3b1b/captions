1
00:00:04,020 --> 00:00:06,860
“拥有”一枚比特币究竟意味着什么？

2
00:00:07,160 --> 00:00:09,480
很多人都听说过比特币

3
00:00:09,480 --> 00:00:12,680
它是一种数字货币，并不需要特定政府发行

4
00:00:12,680 --> 00:00:15,900
也不依赖银行来管理账户及验证交易

5
00:00:16,045 --> 00:00:18,875
甚至都没有人真正知晓其发明者

6
00:00:19,135 --> 00:00:22,175
很多人都不知道片头提及的那个问题的答案

7
00:00:22,180 --> 00:00:23,480
至少不全了解

8
00:00:24,140 --> 00:00:26,140
要想搞明白，同时也为了让

9
00:00:26,140 --> 00:00:29,880
比特币背后的技术细节显得直观

10
00:00:29,880 --> 00:00:35,280
我们将从你会如何建立比特币的过程中一步一步地说明

11
00:00:35,840 --> 00:00:40,040
首先我们从你用于记录你与好友们交易的公共账本开始

12
00:00:40,280 --> 00:00:44,780
然而你与好友及世界上的其他人的互信开始逐渐降低

13
00:00:44,900 --> 00:00:49,980
但聪明的你引入了密码学中的某些概念来解决信任危机

14
00:00:50,200 --> 00:00:53,240
你就创造了一种新事物，叫做“加密货币”

15
00:00:53,440 --> 00:00:58,080
比特币只是第一个被广泛应用的加密货币的例子

16
00:00:58,260 --> 00:01:02,700
而如今有了更多其他的加密货币并与传统货币发生交易

17
00:01:02,980 --> 00:01:05,060
从你发明你自己的加密货币入手

18
00:01:05,060 --> 00:01:09,140
能帮助我们理解如今几大主流加密货币的理论基础

19
00:01:09,180 --> 00:01:13,480
了解其背后在不同方面存在着不同的设计空间

20
00:01:13,940 --> 00:01:17,200
事实上我选这个选题是因为在过去一年中针对加密货币

21
00:01:17,200 --> 00:01:23,820
有大量的关注、资本投入甚至老实讲还有媒体过分渲染

22
00:01:24,260 --> 00:01:28,000
我并不会对当前及未来的汇率发表评论及预测

23
00:01:28,000 --> 00:01:31,880
但我想任何想要购买加密货币的人都应

24
00:01:31,880 --> 00:01:33,580
搞明白加密货币究竟是怎么一回事

25
00:01:33,940 --> 00:01:37,940
我不会含糊地将其与挖矿作类比

26
00:01:38,040 --> 00:01:45,880
我会直接描述当我们发送、接受、创造加密货币时
计算机内部所发生的事情

27
00:01:46,520 --> 00:01:53,720
我还要强调一点：
虽然我们将花一些时间稍深入地了解背后的原理

28
00:01:54,140 --> 00:01:58,780
仅仅日常使用的话，我们并不需要了解其详细技术原理

29
00:01:58,880 --> 00:02:03,220
就像你不需要了解你刷信用卡背后所发生的一切一样

30
00:02:03,580 --> 00:02:07,540
与电子支付一样，加密货币也有很多方便易用的应用

31
00:02:07,660 --> 00:02:11,240
用于发送和接受货币而不需要知道是怎么实现的

32
00:02:11,600 --> 00:02:17,220
区别在于加密货币的背后并不是某家银行来验证交易

33
00:02:17,220 --> 00:02:24,580
而是一套基于密码学中某些数学方法的
去中心化的、互不信任的交易验证体系

34
00:02:25,620 --> 00:02:30,500
在开始讲之前，你暂时把加密货币放在一边

35
00:02:30,820 --> 00:02:35,720
我们先从更基本的概念入手：账本和电子签名。

36
00:02:36,240 --> 00:02:38,860
如果你和你的朋友们有很频繁的金钱来往

37
00:02:38,865 --> 00:02:41,415
比如AA支付晚餐的账单等等

38
00:02:41,415 --> 00:02:44,325
用现金总是不方便的

39
00:02:44,360 --> 00:02:46,480
所以可能会用到一个公共账本

40
00:02:46,480 --> 00:02:50,440
它记录了某些未来将会发生的交易信息

41
00:02:50,440 --> 00:02:54,900
如Alice支付Bob 20元，Bob支付Charlie 40元等等

42
00:02:55,340 --> 00:02:58,780
这个账本必须是公开的，每个人都能查阅

43
00:02:58,900 --> 00:03:01,960
就像一个网站一样，每个人都能查阅并添加新的记录

44
00:03:02,440 --> 00:03:07,880
而到了每个月底大家对交易记录都无异议就会一起合计

45
00:03:08,260 --> 00:03:11,420
如果你入不敷出，就要向公家交钱

46
00:03:11,420 --> 00:03:14,560
如果仍有结余，就可以从中取钱

47
00:03:15,080 --> 00:03:19,380
所以这个简单体系的设计大概会是如下所述

48
00:03:19,840 --> 00:03:25,380
每个人都能向账本添加交易信息，到月底再统一结算

49
00:03:25,940 --> 00:03:30,780
但公共账本存在一个问题，正因为每个人都能添加记录

50
00:03:30,780 --> 00:03:37,300
应该怎样避免Bob在没有Alice核准的情况下偷偷记下：Alice给Bob 100元

51
00:03:37,660 --> 00:03:43,340
我们又凭什么相信账本中的记录都准确无误呢

52
00:03:44,500 --> 00:03:48,980
这里就需要密码学中的电子签名技术

53
00:03:49,200 --> 00:03:55,540
就像手写签名一样，Alice需能在交易信息边上留下记录

54
00:03:55,540 --> 00:03:58,900
以证明她了解并且允许这笔交易发生

55
00:03:59,080 --> 00:04:03,460
而且这个签名不能被他人获取并伪造

56
00:04:04,140 --> 00:04:08,780
乍一思索电子签名似乎不太可能实现

57
00:04:08,780 --> 00:04:14,120
无论电子签名是如何存储的，计算机读取并复制即可

58
00:04:14,120 --> 00:04:16,600
那究竟该如何防止伪造呢

59
00:04:17,120 --> 00:04:21,920
要实现电子签名，每个人都需要生成
一对公共密钥及私人密钥

60
00:04:22,120 --> 00:04:24,100
每一个密钥都是一串比特

61
00:04:24,500 --> 00:04:29,160
私人密钥有时也被叫做“秘密”钥匙以便能够缩写成sk

62
00:04:29,300 --> 00:04:31,500
公共密钥则缩写成pk

63
00:04:32,100 --> 00:04:36,400
正如其名，私人密钥是由你自己保存的

64
00:04:37,020 --> 00:04:42,200
现实生活中，你所签署的所有文件中的签名都是一致的

65
00:04:42,200 --> 00:04:47,220
电子签名则更进一步，它会随着签署的内容变化而变化

66
00:04:47,580 --> 00:04:53,180
它看上去就是一串10代码，通常长度是256位

67
00:04:53,340 --> 00:04:59,760
而内容的轻微变动都会让这串代码看上去几乎完全不同

68
00:05:00,640 --> 00:05:05,480
正式一点地讲，产生这样的签名需要一个函数

69
00:05:05,560 --> 00:05:08,600
它同时要求所签署的内容以及你的私人密钥

70
00:05:09,060 --> 00:05:12,480
私人密钥确保了只有你本人能产生这个电子签名

71
00:05:12,625 --> 00:05:15,265
这个签名还取决于签署的内容

72
00:05:15,265 --> 00:05:19,920
就意味着其他人不能简单地复制这个签名
并在其他内容上伪造另一个签名

73
00:05:20,820 --> 00:05:25,640
与此同时还有一个验证函数用于验证签名是否真实

74
00:05:25,960 --> 00:05:28,200
而这个函数还需要公共密钥

75
00:05:28,860 --> 00:05:37,980
它的作用是告诉我们这个签名是否是由一个私钥加密
并有一个与之配对的公钥用于验证

76
00:05:38,400 --> 00:05:41,960
这里并不会具体讨论这些函数具体如何实现

77
00:05:41,960 --> 00:05:49,260
它保证了如果你不知道私钥，
你几乎不可能找到一个正确的签名

78
00:05:49,740 --> 00:05:54,600
准确地讲，并不会有比穷举并反复验证更好的办法了

79
00:05:54,900 --> 00:05:58,180
然后用大家都知道的公钥进行验证

80
00:05:58,760 --> 00:06:03,360
现在想想256位比特到底有多少可能的签名

81
00:06:03,760 --> 00:06:06,580
总共有2的256次方个可能的签名

82
00:06:07,160 --> 00:06:09,600
这是一个天文数字

83
00:06:09,820 --> 00:06:13,980
称其为天文数字实际上又远远高估了天文学的范畴

84
00:06:13,980 --> 00:06:19,780
我还做了另一个补充视频来演示这个数字究竟有多大

85
00:06:20,280 --> 00:06:25,460
现在如果一旦你验证了一个签名是真的

86
00:06:26,020 --> 00:06:28,320
你就能相当有把握地认为

87
00:06:28,320 --> 00:06:32,080
这个签名只能由他本人持有的私钥加密产生

88
00:06:32,200 --> 00:06:35,300
以及与这个私钥配对的公钥验证

89
00:06:36,720 --> 00:06:40,620
现在确保了每个人都会在交易信息后面签名

90
00:06:40,620 --> 00:06:42,755
仍然会存在另一个问题

91
00:06:42,760 --> 00:06:46,540
比如Alice签署了一条Alice支付Bob 100元的交易记录

92
00:06:46,540 --> 00:06:50,540
即便Bob不能在Alice的新交易记录上伪造签名

93
00:06:50,640 --> 00:06:54,180
他还可以把这条记录随心所欲地复制好几遍

94
00:06:54,180 --> 00:06:57,180
这些记录以及它对应的签名都是正确的

95
00:06:57,680 --> 00:07:01,640
要解决这个问题，你在签署新的交易信息时

96
00:07:01,760 --> 00:07:07,240
交易信息还必须包含一个唯一的编号与之对应

97
00:07:07,660 --> 00:07:11,500
那样如果Alice多次支付Bob 100元的话

98
00:07:11,680 --> 00:07:15,880
账本上的每条记录都会要求一个新的签名

99
00:07:16,740 --> 00:07:22,060
有了电子签名就完美地解决了原本体系中的信任危机

100
00:07:22,300 --> 00:07:27,420
但要真正实现，仍然需要依赖一个类似的信用机构

101
00:07:27,540 --> 00:07:32,900
也就是说你信任每个人到了月底都会出现并用现金结算

102
00:07:33,300 --> 00:07:39,400
万一Charlie欠了很多钱但就是不出来还钱该怎么办

103
00:07:39,940 --> 00:07:47,160
而再次使用现金的唯一原因是其中有人欠了钱

104
00:07:47,720 --> 00:07:52,220
聪明的你想到了一个方法就不需要真正再用现金结算

105
00:07:52,300 --> 00:07:56,580
只要能够避免其中有些人的所得不足以支付其支出

106
00:07:57,240 --> 00:08:01,320
所有人开始就往账上支付100元，

107
00:08:01,500 --> 00:08:03,940
账本上最先记录几条：

108
00:08:04,080 --> 00:08:08,300
Alice获得100元，Bob获得100元，Charlie等等

109
00:08:08,980 --> 00:08:16,040
现在只需要拒绝在账本上记录某些人入不敷出的交易

110
00:08:16,900 --> 00:08:20,095
举个例子，如果前两条交易记录是

111
00:08:20,100 --> 00:08:22,140
Charlie支付Alice 50元，

112
00:08:22,140 --> 00:08:24,420
Charlie支付Bob 50元

113
00:08:24,420 --> 00:08:28,120
如果他想记录Charlie支付你20元，

114
00:08:28,280 --> 00:08:32,260
那将是不合法的，和他没有签名一样不合法

115
00:08:32,840 --> 00:08:35,700
因此这就意味着验证一条交易

116
00:08:35,700 --> 00:08:39,460
就需要了解截至当前所有的历史交易信息

117
00:08:40,040 --> 00:08:46,500
这在加密货币中同样如此，并且仍有待优化

118
00:08:48,440 --> 00:08:55,480
有趣的是，这个设计真正去掉了账本和真实货币的联系

119
00:08:56,260 --> 00:08:59,360
理论上如果世界上所有人都是用这个账本

120
00:08:59,580 --> 00:09:03,640
你整个一生都可以在这个账本上支付并获得钱财中度过

121
00:09:03,640 --> 00:09:06,600
根本不需要真实的货币

122
00:09:07,320 --> 00:09:14,160
为了强调这一点，我们把账本上的货币单位称之为账元，并简称为LD

123
00:09:14,740 --> 00:09:18,780
你也可以将账元自由地兑换成真的美元

124
00:09:18,780 --> 00:09:22,600
举个例子，Alice在现实中给了Bob 100元

125
00:09:22,600 --> 00:09:29,740
同时Bob在公共账本上记上Bob支付Alice 100元

126
00:09:30,660 --> 00:09:34,440
但这样的兑换并不在这套系统的设计初衷之内

127
00:09:34,760 --> 00:09:40,580
这样的兑换与美元和欧元或市场上其他的货币兑换类似

128
00:09:41,160 --> 00:09:43,940
那是另外一个事情了

129
00:09:44,460 --> 00:09:50,020
这是理解比特币和其他加密货币的最重要的信息了

130
00:09:50,540 --> 00:09:52,840
它实际上就是一个账本

131
00:09:53,080 --> 00:09:56,260
所有的历史交易总和就是当下(current)的货币(currency)

132
00:09:57,000 --> 00:09:58,420
当然就比特币而言

133
00:09:58,420 --> 00:10:01,800
人们只有用现金购买和使用比特币才会在账本上记录

134
00:10:01,800 --> 00:10:05,120
但新的比特币如何产生我一会儿再细说

135
00:10:05,440 --> 00:10:12,480
但此之前，我们的LD体系和当前加密货币还有一大不同

136
00:10:12,860 --> 00:10:15,860
我刚提到这个公共账本存在于某个公共地点

137
00:10:15,940 --> 00:10:18,640
比如一个网站，所有人都能登陆并添加记录

138
00:10:19,180 --> 00:10:21,975
那样的话我们就必须信任这一中心机构

139
00:10:21,980 --> 00:10:26,800
那究竟谁来管理这个网站，谁来控制添加记录的规则呢

140
00:10:27,540 --> 00:10:32,220
让所有人都能获取这份账本也就不需要信任中心机构了

141
00:10:32,760 --> 00:10:36,960
当你需要发生交易，如Alice支付Bob 100元

142
00:10:37,060 --> 00:10:40,900
你需要将这个信息广播给网络中所有的其他人

143
00:10:40,900 --> 00:10:43,680
他人收到了这个信息都在自己那份账本上记下这条交易

144
00:10:44,700 --> 00:10:49,440
想法虽然简单，但这样的设计相当糟糕

145
00:10:49,680 --> 00:10:52,860
如何确保所有人手里都是正确的那份账本呢

146
00:10:53,300 --> 00:10:57,180
当Bob收到了如Alice支付Bob10账元的交易，

147
00:10:57,560 --> 00:11:01,840
他如何确保并相信其他所有人也同样收到了这一信息

148
00:11:02,220 --> 00:11:07,460
能让他在今后可以用这10账元支付给Charlie做交易？

149
00:11:08,300 --> 00:11:12,300
试着想想是你自己收听着来自外界的交易信息广播

150
00:11:12,860 --> 00:11:18,380
该如何确保其他人和你一样以相同的顺序接受交易信息

151
00:11:19,320 --> 00:11:23,060
这才是关键所在，也是一个有趣的难题

152
00:11:23,460 --> 00:11:27,640
你能想出一个方法来决定接受或拒绝收到的交易信息

153
00:11:27,660 --> 00:11:30,900
而且你确信其他所有人在这个方法下

154
00:11:30,900 --> 00:11:34,300
能以同样的顺序接受交易信息

155
00:11:34,860 --> 00:11:37,780
最终形成同样的一份账单

156
00:11:38,480 --> 00:11:41,640
这也是比特币原始论文中详述的部分

157
00:11:44,220 --> 00:11:47,315
简单地讲，比特币的解决办法是

158
00:11:47,320 --> 00:11:51,960
选择信任消耗最多计算资源的那份账本

159
00:11:52,480 --> 00:11:54,980
我会花一些时间详细讲是什么意思

160
00:11:55,120 --> 00:11:58,200
它涉及到“加密散列函数”这个概念

161
00:11:58,460 --> 00:12:00,260
基本的思路如下：

162
00:12:00,460 --> 00:12:04,600
如果你将计算资源的消耗作为你的信任之基，

163
00:12:05,000 --> 00:12:08,440
那么伪造交易记录

164
00:12:08,620 --> 00:12:12,220
将会需要不可能达到的计算能力才有可能。

165
00:12:12,780 --> 00:12:15,915
在提醒大家一次，这里我们将会继续深入讨论

166
00:12:15,920 --> 00:12:19,920
对大多数仅仅只是使用比特币的用户并不需了解

167
00:12:19,920 --> 00:12:21,355
但这个想法实在是太酷了！

168
00:12:21,480 --> 00:12:27,040
如果你懂了，你就会理解比特币和其他加密货币的核心

169
00:12:27,680 --> 00:12:30,680
那么首先，什么是散列函数？

170
00:12:30,680 --> 00:12:35,320
这些函数的输入可以是任何信息或文件

171
00:12:35,740 --> 00:12:40,440
它们会输出一个固定长度的比特字符串，如256位

172
00:12:41,420 --> 00:12:44,820
这个输出值叫做这个信息的散列值，或者称其为“指纹”

173
00:12:45,160 --> 00:12:48,100
它故意设计成会输出看似相当随机的内容

174
00:12:48,200 --> 00:12:51,760
但并不是随机的，对给定的信息总是输出相同的内容

175
00:12:52,200 --> 00:12:55,100
但如果你将输入稍作修改，

176
00:12:55,440 --> 00:12:57,640
也许仅仅只是修改了其中一个字母，

177
00:12:57,640 --> 00:13:00,580
最终的散列值会变得面目全非

178
00:13:01,080 --> 00:13:05,500
事实上，我这里做演示的散列函数叫做“SHA256”

179
00:13:05,860 --> 00:13:11,940
输入的轻微修改，输出就会完全不同，毫无规律可言

180
00:13:12,260 --> 00:13:15,060
明白了吧，这不是普通的散列函数，

181
00:13:15,060 --> 00:13:17,200
这是加密散列函数

182
00:13:17,360 --> 00:13:20,900
这就意味着逆向计算是不可能的

183
00:13:21,180 --> 00:13:24,400
如果告诉你一串1,0的字符串然后问你

184
00:13:24,400 --> 00:13:31,100
哪一个输入经过SHA256函数计算后会得到同样的结果

185
00:13:31,580 --> 00:13:34,700
没有比一个一个尝试更好的办法了

186
00:13:35,480 --> 00:13:42,100
如果你想感受一下2的256次方个尝试究竟需要计算多久

187
00:13:42,340 --> 00:13:44,755
可以看看这个补充视频

188
00:13:44,755 --> 00:13:46,785
 

189
00:13:48,640 --> 00:13:53,540
你会想如果知道了这个函数的运作细节

190
00:13:53,840 --> 00:13:57,780
是不是就可以不用瞎猜而是可以倒过来推断这个输入呢

191
00:13:57,980 --> 00:14:00,960
但目前没有人可以做到

192
00:14:01,240 --> 00:14:07,100
有趣的是，目前还没有严格的证明逆向计算是困难的

193
00:14:07,420 --> 00:14:10,600
目前大量的安全行业和加密需求都取决于

194
00:14:10,600 --> 00:14:14,360
加密散列函数以及它的这个性质

195
00:14:14,740 --> 00:14:17,820
如果你细看浏览器和youtube建立的加密连接

196
00:14:17,820 --> 00:14:20,580
背后的加密算法

197
00:14:20,580 --> 00:14:22,500
或浏览器连接银行网站时

198
00:14:22,500 --> 00:14:26,060
你很可能会看到SHA256算法

199
00:14:27,100 --> 00:14:29,560
但现在，我们的关注点会是

200
00:14:29,560 --> 00:14:33,460
这样的函数如何证明一个账单

201
00:14:33,480 --> 00:14:36,760
它所需要的计算力

202
00:14:37,720 --> 00:14:40,735
想想如果有人给你一份交易记录并说

203
00:14:40,740 --> 00:14:43,240
“嘿！我发现了一个特殊的数字

204
00:14:43,240 --> 00:14:46,600
你把这个数字放在这份交易记录后面

205
00:14:46,700 --> 00:14:49,800
整体信息进行SHA256函数计算后

206
00:14:49,805 --> 00:14:53,195
前面30个数字都会是0！”

207
00:14:53,760 --> 00:14:57,020
你想想找到这样的一个数字有多难？

208
00:14:58,060 --> 00:14:59,200
对于一个随机的信息，

209
00:14:59,360 --> 00:15:05,580
其散列值前30位都是0的概率是2的30次方分之一

210
00:15:05,580 --> 00:15:07,420
差不多是十亿分之一

211
00:15:07,860 --> 00:15:11,740
而且因为SHA256是一个加密散列函数

212
00:15:11,960 --> 00:15:16,080
找到这个特殊数字的唯一方法只能是穷举验证

213
00:15:16,640 --> 00:15:20,880
所以刚才那个人基本上已经尝试了十亿次

214
00:15:20,880 --> 00:15:22,520
才找到了这个特别数字

215
00:15:23,040 --> 00:15:24,800
而你知道了这个数字，

216
00:15:24,800 --> 00:15:28,820
很快计算一下散列值发现开头确实是30个0

217
00:15:29,500 --> 00:15:33,620
换言之，你能很快地验证他们确实经过了大量的计算

218
00:15:33,880 --> 00:15:36,520
而你不需要亲自付出这么多重复劳动。

219
00:15:37,040 --> 00:15:39,320
这叫做“工作量证明”

220
00:15:39,320 --> 00:15:44,320
重要的是，这个工作量证明和这份交易记录紧密相关

221
00:15:44,880 --> 00:15:47,740
如果你更改了其中一条交易信息，即便是轻微的改动

222
00:15:48,080 --> 00:15:49,860
也会完全改变最终的散列值

223
00:15:49,860 --> 00:15:54,000
所以就又需要经过十亿次尝试才能找到新的工作量证明

224
00:15:54,180 --> 00:15:55,180
即找到那个特别数字

225
00:15:55,180 --> 00:16:00,520
和它对应的交易记录的散列值会以30个0开头

226
00:16:01,240 --> 00:16:04,300
现在回过头来考虑我们的分布式账本的情形：

227
00:16:04,380 --> 00:16:07,100
每个人都在广播交易信息，

228
00:16:07,100 --> 00:16:10,820
我们想找到一个方法能让所有人都确认一份正确的账单

229
00:16:11,340 --> 00:16:14,700
我前面说过比特币原始论文的核心点就是

230
00:16:14,700 --> 00:16:18,780
每个人都信任需要最多计算能力的那份账单

231
00:16:19,100 --> 00:16:22,780
要实现这个想法首先需要将账单整理成区块

232
00:16:22,800 --> 00:16:27,240
这些区块包含了一系列交易信息以及其工作量证明

233
00:16:27,760 --> 00:16:32,280
也即有一个特别数字满足其散列值以一系列0开头

234
00:16:32,920 --> 00:16:37,020
我们暂时先定60个0开头吧，

235
00:16:37,020 --> 00:16:41,100
一会儿我们会回头来看如何系统地确定这些0的个数

236
00:16:41,560 --> 00:16:46,560
类比于交易信息要经过发送方签名才被认定为有效

237
00:16:46,760 --> 00:16:50,000
一个区块只有当它有工作量证明时才被认定为有效

238
00:16:50,720 --> 00:16:54,380
而且为了确保这些区块有一定的顺序

239
00:16:54,380 --> 00:16:59,540
我们规定前一区块的散列值必须加入到当前区块的头部信息中

240
00:17:00,040 --> 00:17:03,200
这样的话，如果你回头想改变其中某个区块的内容

241
00:17:03,200 --> 00:17:05,580
或交换两个区块的顺序

242
00:17:05,580 --> 00:17:08,140
你就会改变它后一个区块的内容

243
00:17:08,140 --> 00:17:09,900
也就改变了那个区块的散列值

244
00:17:09,900 --> 00:17:12,940
然后又影响到再下一个区块

245
00:17:13,740 --> 00:17:16,320
那将会需要重新计算所有这些区块的散列值，

246
00:17:16,320 --> 00:17:21,500
重新寻找每个特别数字使得区块的散列值以60个0开头

247
00:17:22,100 --> 00:17:24,940
因为区块以这种方式相互链接

248
00:17:24,940 --> 00:17:28,840
与其称其为账本，不如称其为“区块链”

249
00:17:29,740 --> 00:17:31,820
在这个新的体系之下，

250
00:17:31,820 --> 00:17:34,680
我们现在允许世界上的每个人都能成为区块的建立者

251
00:17:35,100 --> 00:17:38,680
意思是说他们都将收听网络中的交易信息，

252
00:17:38,680 --> 00:17:40,335
整理这些信息生成区块，

253
00:17:40,340 --> 00:17:42,900
然后花大量的计算能力

254
00:17:42,900 --> 00:17:46,480
寻找特别数字使得区块的散列值以60个0开头

255
00:17:46,920 --> 00:17:49,840
一旦找到了这个数字，他们就将这个区块广播出去

256
00:17:50,700 --> 00:17:53,380
为了奖励这个区块建立者的工作付出，

257
00:17:53,380 --> 00:17:55,140
当她建立了一个区块，

258
00:17:55,140 --> 00:17:59,100
我们规定她可以把一笔特别的交易信息放在账单开头，

259
00:17:59,100 --> 00:18:01,740
即：她获得10账元。

260
00:18:03,320 --> 00:18:04,920
这叫做“区块奖励”，

261
00:18:04,920 --> 00:18:09,620
这是我们接受或拒绝交易信息规则的一个例外情况

262
00:18:09,780 --> 00:18:12,940
它并不来自于其他人，所以也并不需要签名。

263
00:18:12,940 --> 00:18:13,555
 

264
00:18:13,560 --> 00:18:19,860
也意味着整个网络中的账元会随着新区块的产生而增加

265
00:18:20,600 --> 00:18:23,240
建立区块通常叫做“挖矿”，

266
00:18:23,240 --> 00:18:25,200
因为它会需要大量的计算力

267
00:18:25,200 --> 00:18:28,480
挖矿会为整个经济中引入新的货币量

268
00:18:28,780 --> 00:18:31,360
所以当你听到或看到矿工时

269
00:18:31,360 --> 00:18:33,700
你现在明白他们所做的其实就是

270
00:18:33,700 --> 00:18:40,580
收听交易信息，建立区块，广播区块
并获得新货币的奖励

271
00:18:40,580 --> 00:18:41,080
 

272
00:18:41,720 --> 00:18:45,900
而在矿工眼中，每个区块就像是一个小型的彩票，

273
00:18:45,900 --> 00:18:48,880
每个人都想尽可能快得猜数字

274
00:18:48,940 --> 00:18:52,580
直到其中有一个幸运儿找到了那个特别数字

275
00:18:52,580 --> 00:18:56,240
能让区块的散列值以很多0开头，然后他们就得到奖励

276
00:18:56,600 --> 00:18:57,100
 

277
00:18:57,760 --> 00:19:00,980
而对于其他只是想利用这个系统做交易的人而言，

278
00:19:00,980 --> 00:19:03,460
并不需要收听交易记录，

279
00:19:03,460 --> 00:19:06,760
他们只需要收听被矿工广播的区块即可，

280
00:19:06,920 --> 00:19:09,920
然后更新自己的那一份区块链

281
00:19:10,200 --> 00:19:13,000
现在我们新体系的关键点来了

282
00:19:13,000 --> 00:19:17,760
如果我们收到了两份完全不同的区块链，

283
00:19:18,200 --> 00:19:22,300
我们倾向于选择最长的那一个，也就是需要最多的工作量的那一份。

284
00:19:22,600 --> 00:19:26,220
如果暂时难分上下，等待下一个区块的广播，

285
00:19:26,220 --> 00:19:28,120
总有一个会形成更长的区块链

286
00:19:28,420 --> 00:19:30,760
所以即便没有中心机构，

287
00:19:31,000 --> 00:19:33,980
所有人也都自己维护自己的那份区块链

288
00:19:34,220 --> 00:19:39,300
但如果每个人都信任最多工作量的那个区块链，

289
00:19:39,300 --> 00:19:42,900
我们就达到了一个去中心化的共识

290
00:19:43,560 --> 00:19:45,780
为什么这样能够建立一个可信的系统，

291
00:19:45,780 --> 00:19:49,080
并理解这个系统里的交易到底有多可信，

292
00:19:49,420 --> 00:19:54,780
我们尝试在这个系统中伪造信息欺骗他人到底有多难

293
00:19:55,420 --> 00:19:58,760
也许Alice想要用一个伪造的区块欺骗Bob

294
00:19:58,760 --> 00:20:04,020
也即她给Bob一个区块里包含里她支付Bob 100账元的信息

295
00:20:04,240 --> 00:20:07,020
但她没有把这个区块广播给网络中的其他人

296
00:20:07,320 --> 00:20:11,320
那样的话，其他人还会人会她仍然持有那100账元

297
00:20:12,000 --> 00:20:17,100
她要比其他所有矿工先找到工作量证明才能欺骗所有人

298
00:20:17,100 --> 00:20:18,780
他们都在独立计算区块

299
00:20:19,100 --> 00:20:20,740
而这确实是有可能发生的！

300
00:20:21,000 --> 00:20:25,040
有可能Alice刚好比其他所有人都先找到了这个证明

301
00:20:25,380 --> 00:20:29,480
但Bob也还会收到来自其他矿工的区块广播

302
00:20:30,060 --> 00:20:32,400
所以为了让他相信她那份伪造的区块，

303
00:20:32,400 --> 00:20:35,340
Alice后面都要重新计算

304
00:20:35,340 --> 00:20:38,980
她那份伪造给Bob的区块后面的所有区块

305
00:20:39,240 --> 00:20:42,400
这些区块和Bob收到了来自其他矿工的区块都不同

306
00:20:42,400 --> 00:20:48,320
但系统规定Bob总是信任他所指的最长的那一个区块链

307
00:20:48,940 --> 00:20:52,020
Alice在前几个区块还有可能保持领先

308
00:20:52,020 --> 00:20:57,780
如果刚好碰巧她比其他所有矿工都先找到那个区块

309
00:20:57,780 --> 00:20:58,280
 

310
00:20:58,280 --> 00:21:03,600
但除非她拥有接近所有矿工的计算资源的50%

311
00:21:03,980 --> 00:21:06,240
所以更可能发生的是

312
00:21:06,240 --> 00:21:09,420
所以其他矿工计算的区块

313
00:21:09,600 --> 00:21:13,640
会比Alice伪造给Bob的区块形成的区块链更长更快

314
00:21:14,000 --> 00:21:14,500
 

315
00:21:14,900 --> 00:21:19,580
所以经过足够长的时间，Bob会放弃他收到的来自Alice的区块链

316
00:21:19,660 --> 00:21:22,900
而选择其他所有人都在计算的那一份区块链

317
00:21:23,700 --> 00:21:29,320
所以你一开始并不会立即信任收听到的新的区块

318
00:21:29,320 --> 00:21:33,500
而要等到后面有新的区块添加后

319
00:21:33,500 --> 00:21:36,400
如果你还没收听到更长的区块链，

320
00:21:36,400 --> 00:21:41,020
你就能信任这个区块和其他人的区块链中是一致的

321
00:21:42,040 --> 00:21:45,420
到此，我们讲解了所有主要内容

322
00:21:45,800 --> 00:21:48,680
这个基于工作量证明的分布式账本系统

323
00:21:49,040 --> 00:21:53,920
多多少少和比特币还有其他加密货币一样

324
00:21:54,240 --> 00:21:56,020
再讲讲更多的细节

325
00:21:56,020 --> 00:21:59,520
刚我讲到工作量证明是寻找那一个特别数字

326
00:21:59,520 --> 00:22:02,900
满足其区块的散列值以60个0开头

327
00:22:03,100 --> 00:22:08,160
而现实的比特币体系中这些0的数字规律的变化

328
00:22:08,160 --> 00:22:12,100
以保证平均每10分钟产生一个新的区块

329
00:22:12,460 --> 00:22:15,715
当有越来越多的矿工加入其中

330
00:22:15,720 --> 00:22:22,840
为了赢得每10分钟开奖的彩票，计算也变得越来越难

331
00:22:22,960 --> 00:22:23,460
 

332
00:22:23,640 --> 00:22:27,500
很多新的加密货币有更短的区块时间

333
00:22:27,500 --> 00:22:28,000
 

334
00:22:28,360 --> 00:22:32,720
比特币体系中所有的比特币都来自于生成新区块的奖励

335
00:22:32,720 --> 00:22:35,780
在一开始，是每区块50个比特币

336
00:22:35,980 --> 00:22:39,160
还有一个叫做“Block Explorer”的网站你可以去看看

337
00:22:39,160 --> 00:22:41,800
上面能轻松地看到比特币区块链中的信息

338
00:22:41,800 --> 00:22:44,800
如果你看区块链最初识的那几个区块

339
00:22:44,800 --> 00:22:49,460
它们除了奖励给矿工的50个比特币之外并没有其他交易

340
00:22:49,840 --> 00:22:54,220
但每过210000个区块，差不多每4年，

341
00:22:54,580 --> 00:22:56,780
区块奖励就会减半

342
00:22:56,780 --> 00:23:00,260
现在，每个区块的奖励是12.5个比特币

343
00:23:00,520 --> 00:23:04,420
也因为这个奖励随着时间等比减少

344
00:23:04,420 --> 00:23:09,520
也就意味着最终可获取的比特币不会超过21000000

345
00:23:10,180 --> 00:23:13,380
但这并不是说矿工最终赚不到钱

346
00:23:13,640 --> 00:23:18,160
除了区块奖励外，矿工还可以获得交易费

347
00:23:18,160 --> 00:23:24,540
每当你支付时，你可选择一小笔交易费一起支付

348
00:23:24,540 --> 00:23:25,040
 

349
00:23:25,040 --> 00:23:28,600
这笔交易费最终会给包含这笔记录的区块建立者

350
00:23:29,000 --> 00:23:31,985
你这么做能够激励矿工们

351
00:23:31,985 --> 00:23:35,960
将包含你这笔交易信息的区块广播给网络中的其他人

352
00:23:35,960 --> 00:23:41,660
在比特币中，每个区块包含约2400笔交易记录

353
00:23:41,660 --> 00:23:45,420
很多批判家认为这个限制过于严格

354
00:23:45,820 --> 00:23:51,360
与VISA比较，VISA每秒平均处理约1700笔交易

355
00:23:51,360 --> 00:23:55,460
而它每秒能够处理多达24000笔交易

356
00:23:56,220 --> 00:24:01,200
相比而言比特币较慢的交易速度使得它的交易费用更高

357
00:24:01,320 --> 00:24:06,360
正是交易费用让矿工更倾向将其交易收入到新的区块中

358
00:24:07,900 --> 00:24:11,880
除了以上这些加密货币的基础知识

359
00:24:12,160 --> 00:24:16,200
还有其他许多不同的加密货币的系统设计尚未涉及

360
00:24:16,420 --> 00:24:21,360
我希望这个视频能够让大家在今后遇到新概念时

361
00:24:21,360 --> 00:24:24,500
能有一个理性的思考

362
00:24:25,080 --> 00:24:26,100
正如我开头所说，

363
00:24:26,100 --> 00:24:30,960
我做此视频的初衷是目前有大量的资金涌入加密货币中

364
00:24:31,260 --> 00:24:34,960
是好是坏我并不过多评价

365
00:24:35,140 --> 00:24:38,140
但我认为想要进入这一领域的人

366
00:24:38,140 --> 00:24:40,700
如果懂一些基本内容是有所裨益的

367
00:24:41,520 --> 00:24:45,600
最后，我衷心感谢在Patreon支持这个频道的你们

368
00:24:46,120 --> 00:24:49,255
我理解并不是每个人都能支持到这个地步

369
00:24:49,260 --> 00:24:51,220
但你如果仍想支持我，

370
00:24:51,300 --> 00:24:53,540
最好的方式之一就是

371
00:24:53,540 --> 00:24:56,600
将这个视频分享给你认为对其有益的人们

