1
00:00:00,300 --> 00:00:02,000
 

2
00:00:02,700 --> 00:00:04,000
한글 자막 by
homo.efficio@gmail.com

3
00:00:04,400 --> 00:00:07,440
비트코인을 *소유*하고 있다는 건 어떤 의미일까?

4
00:00:07,440 --> 00:00:09,410
비트코인은 순전히 디지털로만 만들어진 화폐라는
이야기를 들어본 적이 있을거야.

5
00:00:09,410 --> 00:00:12,570
비트코인은 발행하는 정부 주체도 없고,

6
00:00:12,690 --> 00:00:16,300
계좌를 관리해주고 거래 내역을 확인해 주는 
은행조차도 필요 없다고 하지.

7
00:00:16,500 --> 00:00:19,080
사토시 나카모토라는 사람이 만들었다고 되어 있지만,
그가 누구인지는 정확히 알려져 있지 않아.

8
00:00:19,100 --> 00:00:24,300
비트코인을 *소유*하는 것이 어떤 의미인지,
일부라도 아는 사람들은 많지 않아.

9
00:00:24,340 --> 00:00:25,120
그 의미를 이해하고,

10
00:00:25,120 --> 00:00:29,780
그 안에 담긴 기술적인 세부 사항을 
확인해보는 것은 쉽지 않은 일이지만,

11
00:00:29,780 --> 00:00:32,340
차례차례 한 번 알아보자구!!

12
00:00:32,340 --> 00:00:35,600
여러분이 직접 비트코인을 만들었다면 
어떻게 만들었을까?

13
00:00:36,120 --> 00:00:40,050
먼저 친구들과의 금전 거래 내역을
공동의 장부에 기록해야겠지.

14
00:00:40,370 --> 00:00:44,690
이제부턴 장부를 믿으면 되니까, 친구들과
세상에 대한 신뢰의 필요성은 점점 줄어들거야.

15
00:00:44,910 --> 00:00:48,130
암호학에서 몇 가지 아이디어를 가져와서

16
00:00:48,130 --> 00:00:50,260
그런 신뢰가 없어도 장부로 거래를 운영할 수 있다면,

17
00:00:50,260 --> 00:00:53,310
그 거래에 사용된 화폐를
"암호화 화폐"라고 부르게 되지 않을까?

18
00:00:53,700 --> 00:00:58,040
비트코인은 가장 먼저 만들어진 암호화 화폐야.

19
00:00:58,340 --> 00:01:02,830
지금은 거래소에서 수 천가지의 암호화 화폐를
기존의 통화로 사고 팔 수 있어.

20
00:01:03,280 --> 00:01:06,410
앞에서 여러분의 암호화 화폐를 만든 과정을 되짚어보면

21
00:01:06,410 --> 00:01:09,440
최근에 만들어진 암호화 화폐를 이해할 수 있고

22
00:01:09,440 --> 00:01:13,600
언제, 그리고 왜 새로운 암호화 화폐들이
저마다의 독특한 설계로 만들어지는지 알 수 있어.

23
00:01:14,050 --> 00:01:16,300
사실 내가 이 주제를 다루게 된 이유는,

24
00:01:16,300 --> 00:01:20,060
작년(2016년)에 암호화 화폐에 대한 
관심과 투자가 폭증했기 때문이야.

25
00:01:20,060 --> 00:01:23,600
암호화 화폐에 대한 이 정도의 관심은, 
솔직히 말해 좀 과장된 면도 있을거라고 봐.

26
00:01:24,320 --> 00:01:28,060
나는 거래소에서 거래되는 암호화 화폐의
가격에 대한 얘기나 예측을 하려는 건 아니야.

27
00:01:28,060 --> 00:01:29,350
하지만 암호화 화폐를 살 생각이 있다면,

28
00:01:29,350 --> 00:01:33,640
먼저 암호화 화폐에 대해 알아야 한다고 생각해.

29
00:01:33,920 --> 00:01:38,080
그렇다고해서 금광 채굴에 비유하면서
모호하게 용어를 설명하려는 것은 아니고,

30
00:01:38,080 --> 00:01:42,510
디지털로 만들어진 암호화 화폐의 이면에서
컴퓨터가 실제로 어떤 일을 하는지
구체적으로 설명하려고 해.

31
00:01:42,510 --> 00:01:45,660
우리가 암호화 화폐를 주고 받고 만들 때
어떤 일이 벌어지는지에 대한 얘기 말이야.

32
00:01:46,800 --> 00:01:48,870
먼저 한 가지 강조하고 싶은 것은

33
00:01:48,870 --> 00:01:51,930
이제부터 세부적인 내용을 심도있게 알아볼 것이고,

34
00:01:52,120 --> 00:01:53,830
알아보는 데 시간도 꽤 걸리겠지만,

35
00:01:54,110 --> 00:01:58,770
그런 것을 모두 알아야만 암호화 화폐를 
사용할 수 있는 것은 아니라는 점이야.

36
00:01:59,070 --> 00:02:03,290
카드를 긁을 때 그 안에서 무슨 일이 벌어지는지
몰라도 쓸 수 있는 것처럼 말이지.

37
00:02:03,680 --> 00:02:07,190
다른 디지털 결제수단과 마찬가지로
속에서 무슨 일이 벌어지는지 알지 못해도,

38
00:02:07,190 --> 00:02:11,260
쉽고 편리하게 돈을 주고 받을 수 있게 해주는
사용자 친화적인 애플리케이션이 많이 있어.

39
00:02:11,780 --> 00:02:14,940
차이점이 뭐냐하면, 그런 결제 처리의 중심에

40
00:02:14,940 --> 00:02:17,300
거래 내역을 확인해 주는 은행이 없다는 거지.

41
00:02:17,620 --> 00:02:21,970
은행 대신에, 암호학에서 탄생된
몇 가지 수학 원리를 이용해서

42
00:02:22,180 --> 00:02:24,850
거래 주체들 사이에 신뢰가 필요하지 않은
똘똘한 분산 확인 시스템이 있다고.

43
00:02:25,910 --> 00:02:26,460
하지만 시작하기 전에,

44
00:02:26,460 --> 00:02:30,730
암호화 화폐에 대한 생각은
앞으로 몇 분 동안만 잠시 접어두자고.

45
00:02:31,040 --> 00:02:35,810
암호화 화폐에 앞서, 훨씬 실질적이고 현실적인 '장부'와
'디지털 서명'으로 이야기를 풀어나가려고 해.

46
00:02:36,400 --> 00:02:38,980
여러분이 친구들과 돈을 주고 받는 일이
자주 일어난다면,

47
00:02:38,980 --> 00:02:41,660
예를 들어, 저녁 값을 더치페이로 하는데,

48
00:02:41,660 --> 00:02:44,250
그럴때마다 항상 현금으로 주고 받는 것은 불편하지.

49
00:02:44,700 --> 00:02:46,300
그래서 그냥 공동 장부를 만들어서

50
00:02:46,300 --> 00:02:50,190
더치 페이 내역을 모두 기록해두고,
나중에 한 번에 정산하는 것이 편할거야.

51
00:02:50,500 --> 00:02:52,470
앨리스가 밥에게 20달러를 주고,

52
00:02:52,470 --> 00:02:54,940
팝은 찰리에게 40달러를 주고.. 
이런 걸 모두 장부에 기록하는거지.

53
00:02:55,580 --> 00:02:58,920
이 공동 장부는 누구나 볼 수 있어.

54
00:02:58,920 --> 00:03:01,980
아무나 접속해서 글을 추가할 수 있는
웹사이트라고 생각해도 돼.

55
00:03:02,530 --> 00:03:04,320
매달 말일에

56
00:03:04,320 --> 00:03:07,930
모두 모여서 거래 내역을 보고 정산을 하는거지.

57
00:03:08,290 --> 00:03:11,450
여러분이 받은 돈보다 쓴 돈이 더 많다면,
정산할 때 돈을 내야돼.

58
00:03:11,450 --> 00:03:14,560
쓴 돈보다 받은 돈이 더 많다면,
정산할 때 돈을 받으면 되겠지.

59
00:03:15,390 --> 00:03:19,530
이 단순한 시스템을 규약으로 정하면 이렇게 될 거야.

60
00:03:19,950 --> 00:03:22,000
누구든 장부에 기록할 수 있다.

61
00:03:22,000 --> 00:03:25,340
매월 말일에 모여서 정산한다.

62
00:03:26,240 --> 00:03:31,010
이런 공동 장부의 문제점은
아무나 기록할 수 있다는 점이야.

63
00:03:31,010 --> 00:03:37,240
예를 들어 밥이 앨리스의 확인도 없이 자기 멋대로
"앨리스가 밥에게 100달러 지불"이라고 기록한다면?

64
00:03:37,750 --> 00:03:41,260
공동 장부에 기록된 내용들이
돈을 보내는 사람의 의도대로

65
00:03:41,260 --> 00:03:43,400
진실되게 기록되어 있다는 것을
어떻게 믿을 수 있을까?

66
00:03:44,810 --> 00:03:48,850
자, 딱 이 지점에서 암호학이 우리를 도와주러 오는거야.
인사해. '디지털 서명' 이라는 친구야.

67
00:03:49,460 --> 00:03:50,960
손으로 서명하는 것처럼,

68
00:03:50,960 --> 00:03:55,830
앨리스는 자기가 돈을 보낸다는 거래 기록에,
서명같은 효과를 가지는 무언가를 추가할 수 있어야 해.

69
00:03:55,830 --> 00:03:58,720
그 무언가는 앨리스가 그 거래 기록을 직접 보고
승인을 했다는 증표가 되겠지.

70
00:03:59,220 --> 00:04:03,490
그리고 그 증표는 위조가 불가능해야돼.

71
00:04:04,360 --> 00:04:08,790
처음에는 말이야, 디지털 서명이라는 것 자체가
전혀 가능할 것 같지가 않았어.

72
00:04:09,130 --> 00:04:14,160
무슨 말이냐면, 그 디지털 서명을 구성하는 데이터는
컴퓨터로 쉽게 읽고 복사할 수 있을테니
증표로 쓸 수 없을 거라는 얘기지.

73
00:04:14,390 --> 00:04:17,000
쉽게 읽어서 복사할 수 있는데,
위조를 어떻게 막을 수 있겠어?

74
00:04:17,300 --> 00:04:22,200
그런데 '공개키(열쇠)-비공개키(열쇠)'라는 걸 만들면
위조를 막을 수 있어.

75
00:04:22,200 --> 00:04:24,410
공개키와 비공개키는
모두 여러 자리수의 0과 1로 되어 있어.

76
00:04:24,810 --> 00:04:27,280
비공개키는 비밀키라고 부르기도 해.

77
00:04:27,280 --> 00:04:31,670
비밀키를 줄여서 sk라고 하고,
공개키를 줄여서 pk라고 하지.

78
00:04:32,400 --> 00:04:36,480
이름에서 알 수 있는 것처럼,
비밀키는 여러분만 비밀로 가지고 있는 키야.

79
00:04:37,080 --> 00:04:41,950
현실 세계에서 여러분이 직접 손으로 쓴 서명은
어느 문서에 쓰든 똑같아 보이지.

80
00:04:42,480 --> 00:04:45,080
하지만 디지털 서명은 훨씬 더 강력해.

81
00:04:45,080 --> 00:04:47,320
서명하는 문서의 내용에 따라
디지털 서명이 달라진다고.

82
00:04:47,880 --> 00:04:52,900
디지털 서명은 보통 256개의 0과 1의
조합으로 만들어진 하나의 값이야.

83
00:04:53,310 --> 00:04:55,840
문서의 내용 중 단 한 글자만 바뀌어도

84
00:04:55,840 --> 00:04:59,760
256개의 0과 1로 구성된
디지털 서명값은 완전히 달라져.

85
00:05:00,910 --> 00:05:02,720
조금 더 공식적으로 얘기하면,

86
00:05:02,720 --> 00:05:08,720
디지털 서명값은 문서의 내용과 여러분의 비밀키를
조합하는 함수에 의해 만들어져.

87
00:05:09,260 --> 00:05:12,590
비밀키는 오직 여러분만이 알고 있으므로,
여러분의 디지털 서명값은 여러분만 만들 수 있지.

88
00:05:12,900 --> 00:05:15,180
그리고 디지털 서명값을 만들 때
비밀키와 함께 문서의 내용이 포함된다는 것은

89
00:05:15,180 --> 00:05:19,870
누군가가 여러분의 디지털 서명값을 훔쳐도,
그 훔친 디지털 서명값은 다른 문서에 대한 증표로는
사용할 수 없다는 것을 의미하지.

90
00:05:21,120 --> 00:05:25,850
디지털 서명과 관련된 두 번째 함수는
디지털 서명값이 유효한지 확인하는데 사용돼.

91
00:05:26,280 --> 00:05:28,900
그리고 디지털 서명값의 유효성을 확인할 때
비밀키의 짝꿍인 공개키가 사용되지.

92
00:05:29,170 --> 00:05:31,470
두 번째 함수는 단순하게 참 또는 거짓 만을
결과값으로 반환하는데,

93
00:05:31,470 --> 00:05:34,740
디지털 서명값이 공개키와 짝꿍인 비밀키를 이용해서
만들어져 있으면 참을,

94
00:05:34,740 --> 00:05:38,080
그렇지 않으면 거짓을 반환해.

95
00:05:38,610 --> 00:05:41,000
디지털 서명값이 비밀키로 만들어져있다는 사실을,
어떻게 공개키를 이용해서 확인할 수 있는지

96
00:05:41,000 --> 00:05:42,240
그 깊은 상세 내용을 여기에서 정확하게 
다룰 필요까지는 없겠지만,

97
00:05:42,240 --> 00:05:47,590
비밀키를 모른다면 유효한 디지털 서명값을
찾아낼 수 없다는 것만은

98
00:05:47,590 --> 00:05:49,390
알고 넘어가자고.

99
00:05:50,040 --> 00:05:54,970
구체적으로 얘기하면, 비밀키를 모르면
그냥 아무 값이나 디지털 서명값으로 정하고,

100
00:05:54,970 --> 00:05:58,080
공개키와 함께 계산해서 디지털 서명값이 유효한지
확인하는 것을 반복 하는 것 외에 다른 방법이 없어.

101
00:05:59,020 --> 00:06:03,370
256비트 길이의 디지털 서명값을
찍을 수 있는 경우의 수가 몇 개냐 하면

102
00:06:03,790 --> 00:06:06,810
무려 2의 256승 개야.

103
00:06:07,350 --> 00:06:09,880
말도 안 되게 큰 숫자라고.

104
00:06:09,880 --> 00:06:13,900
천문학적인 숫자라고 할 수도 없을만큼 큰 숫자야.

105
00:06:14,290 --> 00:06:19,880
이게 얼마나 큰 숫자인지 보여줄 수 있는 비디오를
내가 따로 만들었단다.(https://youtu.be/S9JGmA5_unY)

106
00:06:20,360 --> 00:06:21,860
어쨌든 경우의 수가 그렇게 많다면,

107
00:06:21,860 --> 00:06:25,470
어떤 디지털 서명값이 유효하다고 확인이 되었다는 것은,

108
00:06:25,830 --> 00:06:30,420
그 디지털 서명값은 찍어서 맞춘 것이 아니라,

109
00:06:30,420 --> 00:06:35,360
유효함을 확인할 때 사용한 공개키와 짝꿍인 비밀키로
만든 진짜 디지털 서명값이라고 충분히 확신해도 될거야.

110
00:06:37,040 --> 00:06:40,960
거래 내역을 장부에 기록하는 것은
꽤 괜찮은 생각 같아.

111
00:06:40,960 --> 00:06:42,410
하지만 거기에도 가벼운 헛점은 있지.

112
00:06:42,850 --> 00:06:46,880
앨리스가 "앨리스가 밥에게 100달러 지불"이라는
거래에 디지털 서명했다면,

113
00:06:46,880 --> 00:06:50,740
밥이 그 메시지에 대한
디지털 서명값을 위조할 수는 없지만

114
00:06:50,740 --> 00:06:53,890
동일한 거래 내역 자체는 여러 번 복사할 수 있지.

115
00:06:54,190 --> 00:06:57,400
유효한 메시지-서명 조합을 복사하면,
복사한 메시지-서명 조합도 유효하다고 받아들여진다고.

116
00:06:57,970 --> 00:07:01,970
이런 문제가 발생하지 않게 하려면,
메시지에 거래별로 유일한 식별자인 ID값을 포함해야 돼.

117
00:07:01,970 --> 00:07:07,310
그렇게 하면 메시지 내용이 서로 다르므로,
디지털 서명값도 모두 달라지게 되어,
메시지-서명 조합을 복사해도 다른 곳에 쓸 수 없게 되지.

118
00:07:07,880 --> 00:07:11,710
이 방법을 쓰면 앨리스가 밥에게 100달러를
여러번 지불하더라도,

119
00:07:11,710 --> 00:07:15,740
각 거래는 서로 다른 새로운 거래로 인식되고,
새로운 디지털 서명값을 가지게 돼.

120
00:07:16,960 --> 00:07:17,880
오! 아주 훌륭한데!

121
00:07:18,160 --> 00:07:22,380
처음에 만든 두 가지 규약에
디지털 서명된 거래만 유효하다는 조항을 추가해서
거래 내용 확인 및 신뢰 확보에 드는 비용을
제거할 수 있게 되었어.

122
00:07:22,380 --> 00:07:24,910
하지만 여전히

123
00:07:24,910 --> 00:07:27,460
거래 참여자에 대한 신뢰에 의지하지 않을 수는 없어.

124
00:07:27,720 --> 00:07:30,460
왜냐하면, 거래 참여자가 모두 규약을 잘 따르고

125
00:07:30,470 --> 00:07:33,010
매월 말일에 현금으로 정산할 거라고 믿고 있는데,

126
00:07:33,620 --> 00:07:37,590
찰리가 수천 달러를 지불한다는
거래 기록을 장부에 남기고

127
00:07:37,590 --> 00:07:39,900
나중에 실제로 정산할 때 나타나지 않고
먹튀할 수도 있기 때문이지.

128
00:07:40,240 --> 00:07:43,270
월 1회 장부기록-사후정산 방식 대신
그때그때 현금으로 주고 받는 방식으로 되돌아가야 하는

129
00:07:43,270 --> 00:07:47,300
유일한 경우는 바로 이렇게 누군가 먹튀할 때야.
(찰리 너 걸리면 뒈진다..)

130
00:07:48,010 --> 00:07:52,440
먹튀를 막을 수 있는 좋은 방법은

131
00:07:52,440 --> 00:07:56,740
바로 사람들이 자기들이 미리 적립해둔 금액 이상으로는
지출할 수 없게 하는 거지.

132
00:07:57,390 --> 00:08:01,280
미리 100달러씩 선납해서 적립해두고

133
00:08:01,580 --> 00:08:04,080
장부에는 적립 내역을 기록하는 거야.

134
00:08:04,080 --> 00:08:08,460
앨리스 100달러 적립, 밥 100달러 적립,
찰리 100달러 적립 등

135
00:08:09,170 --> 00:08:12,560
이제 참여자들이 적립해둔 금액 이상으로는
지출할 수 없게 하면,

136
00:08:12,560 --> 00:08:16,210
이제 참여자들이 적립해둔 금액 이상으로는
지출할 수 없게 하면,

137
00:08:16,850 --> 00:08:20,030
예를 들면, 처음 두 거래가

138
00:08:20,030 --> 00:08:24,240
"찰리가 앨리스에게 50달러 지불"과 
"찰리가 밥에게 50달러 지불"인 상태에서,

139
00:08:24,480 --> 00:08:29,690
"찰리가 네게 20달러 지불"이라는 거래를 기록하려할 때 ,
적립한 100달러를 모두 소진한 빈털터리 찰리가
또 20달러를 지불하려는 거래는 무효가 되는거지.

140
00:08:29,690 --> 00:08:32,100
마치 디지털 서명을 하지 않은 거래가
유효하지 않은 것처럼 말이야.

141
00:08:33,010 --> 00:08:35,940
이게 가능하려면 어떤 거래가 발생할 때마다

142
00:08:35,940 --> 00:08:39,600
그 시점까지의 거래 내역 전부를 알아야만 한다는
제약 사항이 생겨.

143
00:08:40,140 --> 00:08:43,970
이는 암호화 화폐에서도 마찬가지야.

144
00:08:43,970 --> 00:08:46,260
다만 암호화 화폐에는 좀더 최적화 할 여지가 있지.

145
00:08:48,750 --> 00:08:50,120
재미있는 것은

146
00:08:50,120 --> 00:08:55,900
이 과정에서 장부와 실제 물리적인 US 달러와의
연결 고리가 끊어진다는 점이야.

147
00:08:56,310 --> 00:08:59,680
이론적으로 세상의 모든 사람들이
이 장부를 사용한다면

148
00:08:59,680 --> 00:09:03,640
여러분은 이 장부 상에서 수입을 올리고
지출하는 것만으로도 살아갈 수 있어.

149
00:09:03,640 --> 00:09:06,960
장부상의 돈을 US 달러로 환전하지 않고도
살아갈 수 있다는 얘기야.

150
00:09:07,430 --> 00:09:08,920
자 이 부분을 더 강조하기 위해,

151
00:09:08,920 --> 00:09:14,310
장부상의 금액을 "장부달러", 줄여서 "LD"라고 하자.

152
00:09:14,790 --> 00:09:18,900
여러분은 장부달러를 실물 US 달러로
자유롭게 환전할 수 있어.

153
00:09:19,070 --> 00:09:22,750
예를 들어, 앨리스가 실제로 밥에게 10 US 달러를 줬다면

154
00:09:22,750 --> 00:09:26,000
장부에 다음과 같이 기록하고 디지털 서명할 수 있지.

155
00:09:26,000 --> 00:09:29,830
"밥이 앨리스에게 10 장부달러 지불"

156
00:09:30,820 --> 00:09:34,490
하지만 10 US 달러와 10 장부달러의 환전은
장부의 규약에 의해 보증되지는 않아.

157
00:09:34,840 --> 00:09:38,510
이 부분을 이해하기 위해
달러를 유로나 다른 통화로 환전하는 것을 떠올려보자.

158
00:09:38,510 --> 00:09:40,830
이 부분을 이해하기 위해
달러를 유로나 다른 통화로 환전하는 것을 떠올려보자.

159
00:09:41,160 --> 00:09:44,080
환전 자체는 그저 독립적인 사건이잖아.

160
00:09:44,690 --> 00:09:50,380
바로 그게 비트코인이나 다른 암호화 화폐를 이해하는데
가장 중요한 점이기도 해.

161
00:09:50,850 --> 00:09:56,320
뭐냐하면 장부는 해당 통화의
모든 거래 이력만을 가지고 있을뿐,
환전을 기록하지는 않는다는거야.

162
00:09:57,110 --> 00:09:58,440
비트코인에서도,

163
00:09:58,440 --> 00:10:01,970
사람들이 현금으로 비트코인을 사더라도,
장부에 실질적인 돈이 들어오는 것은 아니라고.

164
00:10:01,970 --> 00:10:05,040
장부에 새로운 돈이 어떻게 들어오는지는
몇 분 후에 설명해줄게.

165
00:10:05,530 --> 00:10:08,710
일단 지금은, 현재의 장부달러 체계와
암호화 화폐가 작동하는 체계는

166
00:10:08,710 --> 00:10:12,590
큰 차이가 있다는 점이 중요해.

167
00:10:13,000 --> 00:10:16,080
지금까지, 장부는 일종의 공용 장소라고 얘기했잖아?

168
00:10:16,080 --> 00:10:18,720
아무나 새로운 내용을 추가할 수 있는 
웹사이트 같다고 얘기했지.

169
00:10:19,220 --> 00:10:22,080
하지만 웹사이트는 어떤 중앙의 통제소를 필요로 해.

170
00:10:22,080 --> 00:10:24,240
즉, 그 웹사이트를 "(중앙의)누군가"가
호스팅하고 있다는거지.

171
00:10:24,240 --> 00:10:27,060
그럼 장부에 새로운 내용을 추가하는 것도
중앙의 누군가가 통제하는 걸까?

172
00:10:27,550 --> 00:10:32,260
중앙의 누군가에 의존하지 않으려면,
모든 사람들이 장부의 복사본을 가지고 있어야 돼.

173
00:10:32,760 --> 00:10:37,100
그리고 "앨리스가 밥에게 100 장부달러 지불"이라는
거래를 기록하려면

174
00:10:37,400 --> 00:10:39,960
장부를 가지고 있는 모든 사람들에게
이 거래를 알려야 하지.

175
00:10:39,960 --> 00:10:43,740
그래야 사람들이 그 거래 정보를 듣고
자기들이 각자 보유한 장부에 기록할 수 있을테니까.

176
00:10:44,850 --> 00:10:49,460
하지만 여기에 추가적인 조치를 하지 않는다면,
각자 복사본을 보유하는 이런 체계는 매우 안 좋아.

177
00:10:49,800 --> 00:10:53,040
수많은 장부 중에서 어떤 장부가 올바른 장부인지
어떻게 알 수 있겠어?

178
00:10:53,400 --> 00:10:57,620
밥이 "앨리스가 밥에게 10 장부달러 지불"이라는
거래 정보를 수신받았다면,

179
00:10:57,620 --> 00:11:01,960
다른 모든 사람들도 똑같은 거래 정보를 수신 받고
그 거래 정보를 신뢰해서,

180
00:11:02,290 --> 00:11:07,550
밥이 앨리스에게 받은 그 10 장부달러를 찰리에게
지불할 수 있다는 것을 밥은 어떻게 확신할 수 있을까?

181
00:11:08,300 --> 00:11:12,480
자 실제로 여러분이 브로드캐스팅 되는 거래 정보를
수신하고 있다고 상상해보자.

182
00:11:12,950 --> 00:11:19,000
여러분뿐아니라 다른 모든 사람들도
똑같은 거래를 똑같은 순서로 그들의 장부에 기록해서
모든 사람들의 장부 내용이 언제나 완전히 똑같다는 것을
확신할 수 있을까?

183
00:11:19,460 --> 00:11:21,540
이게 바로 문제의 핵심이야!!

184
00:11:21,540 --> 00:11:23,000
이건 진짜 재미있는 퍼즐이라고.

185
00:11:23,450 --> 00:11:27,910
거래 내용을 접수하거나 거절하는 기준이 되고,

186
00:11:27,910 --> 00:11:31,160
거래 내용 기록의 순서를 정하는
기준이 될 수 있는 규약을 만들 수 있을까?

187
00:11:31,160 --> 00:11:34,860
그래서 모든 사람이 그 규약을 따르기만 하면

188
00:11:34,860 --> 00:11:38,000
모든 사람들의 장부가 여러분의 장부와
완전히 똑같다는 것을 확신할 수 있게 해주는
규약이 있을까?

189
00:11:38,510 --> 00:11:41,800
비트코인 논문에는
바로 그 문제에 대한 해답이 담겨 있어.

190
00:11:44,530 --> 00:11:47,640
좀 추상적인 수준에서 살펴보면,
비트코인이 제시한 해법이라는 것은

191
00:11:47,640 --> 00:11:52,040
가장 많은 계산 작업을 포함하고 있는 장부가
신뢰할 만한 올바른 장부라는 것이야.

192
00:11:52,600 --> 00:11:55,240
이게 무슨 뜻인지 더 자세히 설명해줄게.

193
00:11:55,240 --> 00:11:58,290
그건 "암호화 해쉬 함수"라는 것과 관련이 있어.

194
00:11:58,510 --> 00:12:00,540
이제부터 알아볼 아이디어는

195
00:12:00,540 --> 00:12:04,910
무엇을 신뢰할 것인가를 판단하는 기준을
계산 작업에 둔다면,

196
00:12:05,310 --> 00:12:08,810
거래 내역을 속이거나 장부의 충돌을 유발하기 위해서는

197
00:12:08,810 --> 00:12:12,400
정해진 시간 내에 처리가 불가능할만큼
엄청난 양의 계산이 필요하게 만들수 있다는 거야.

198
00:12:12,990 --> 00:12:15,930
다시 말하지만, 그저 화폐를 사용하기만 하는 입장에서는

199
00:12:15,930 --> 00:12:19,750
이런 내용까지 알아야 할 필요는 없어.

200
00:12:20,130 --> 00:12:21,600
하지만 이건 완전 기발한 아이디어라고.

201
00:12:21,600 --> 00:12:26,950
그리고 이 부분을 이해한다면,
비트코인과 다른 모든 암호화 화폐의
핵심을 이해할 수 있어.

202
00:12:27,990 --> 00:12:30,230
자 차례차례 알아보자.
해쉬 함수가 뭘까?

203
00:12:30,750 --> 00:12:34,300
어떤 종류의 메시지나 파일도
해쉬 함수의 입력값이 될 수 있어.

204
00:12:34,300 --> 00:12:35,540
입력값의 종류는 중요하지 않아.

205
00:12:35,730 --> 00:12:40,820
해쉬 함수의 결과값은 256비트처럼,
고정된 길이의 연속된 비트값이야.

206
00:12:41,420 --> 00:12:45,040
결과값을 그 입력값의 "해쉬"
또는 "다이제스트"라고 해.

207
00:12:45,380 --> 00:12:47,980
기본적인 의도는 난수처럼 보이게 해서
쉽게 알아볼 수 없게 하는 거지만,

208
00:12:48,220 --> 00:12:51,850
실제로는 그냥 난수가 아니야.
입력값이 같다면 결과 해쉬값은 언제나 똑같아.

209
00:12:52,290 --> 00:12:53,120
 

210
00:12:53,120 --> 00:12:57,640
그리고 입력값 중에서 단 한 글자만 바꾸더라도

211
00:12:57,950 --> 00:13:00,800
결과 해쉬값은 약간만 달라지는게 아니라 
전체적으로 완전히 다른 값이 나와.

212
00:13:01,030 --> 00:13:05,680
내가 여기에서 보여주는 해쉬 함수는
SHA256이라는 해쉬 함수인데,

213
00:13:05,980 --> 00:13:12,010
입력값에 따라 결과 해쉬값이 어떻게 달라지는지
예측하는 것이 불가능해.

214
00:13:12,490 --> 00:13:15,080
그래서 이 SHA256 함수는 그냥 해쉬 함수가 아니라,

215
00:13:15,080 --> 00:13:17,360
암호화 해쉬 함수라고 부르지.

216
00:13:17,360 --> 00:13:20,830
암호화 해쉬 함수는 결과값에서 역산을 통해
입력값을 알아내는 것이 현실적으로 불가능하다고.

217
00:13:21,320 --> 00:13:23,620
내가 0과 1로된 숫자를 여러분에게 보여주고,

218
00:13:23,620 --> 00:13:25,860
"SHA256함수로 계산해서 이런 해쉬값이 나오려면

219
00:13:25,860 --> 00:13:31,320
입력값은 무엇일까요?" 하고 묻는다면,

220
00:13:31,640 --> 00:13:34,910
답을 찾는 방법은 그저 찍어서 맞추는 수 밖에 없어.

221
00:13:35,770 --> 00:13:42,260
그리고 그 찍을 수 있는 가지수가 2의 256승이나 돼.
2의 256승 개 중에서 여러분이 찍어서 맞출 수 있겠어?

222
00:13:42,260 --> 00:13:44,060
2의 256이 얼마나 큰 수인지는(https://youtu.be/S9JGmA5_unY)를 보면 알 수 있을거야.

223
00:13:44,320 --> 00:13:46,880
그 비디오를 만들때 개인적으로 엄청 재미있었어.

224
00:13:48,960 --> 00:13:54,040
SHA256 함수가 어떻게 동작하는지
깊게 파들어가서 연구하면

225
00:13:54,040 --> 00:13:57,680
그냥 찍기가 아니라 역산을 통해서
입력값을 맞출 수 있을거라고 생각할 수도 있을 거야.

226
00:13:58,270 --> 00:14:00,870
하지만 지금까지 아무도,
그 방법을 알아내지 못했지.

227
00:14:01,550 --> 00:14:07,270
재미있는 사실은, 역산으로 입력값을 계산해 낼 수 없다는
확실한 증명도 없다는 거야.

228
00:14:07,600 --> 00:14:10,300
현대 보안의 많은 부분은

229
00:14:10,300 --> 00:14:14,500
이처럼 역산이 실질적으로 불가능하다는
암호화 해쉬 함수의 특성에 기반을 두고 있어.

230
00:14:15,040 --> 00:14:18,140
지금 여러분의 브라우저와 유튜브 사이에 맺어져 있는
보안 연결이 어떤 알고리듬으로 되어 있는지

231
00:14:18,140 --> 00:14:20,580
지금 여러분의 브라우저와 유튜브 사이에 맺어져 있는
보안 연결이 어떤 알고리듬으로 되어 있는지

232
00:14:20,580 --> 00:14:22,210
또는 여러분과 은행 사이트 사이의 보안 연결이
어떤 알고리듬으로 되어 있는지 알아보다 보면

233
00:14:22,580 --> 00:14:25,990
아마도 SHA256 함수와 반드시 마주치게 될 거야.

234
00:14:27,390 --> 00:14:29,360
일단 지금은

235
00:14:29,360 --> 00:14:33,810
그런 암호화 해쉬 함수가 어떤 방식으로,
일정한 수의 거래들이

236
00:14:33,810 --> 00:14:37,070
상당히 많은 양의 계산 작업과 연결되어 있다는 것을
증명할 수 있는가에 집중해보자고.

237
00:14:38,030 --> 00:14:41,240
누군가 여러분에게 일정한 갯수의 거래 내역을 보여주고,

238
00:14:41,240 --> 00:14:43,220
"이봐!! 내가 매직넘버를 찾아냈어!!"

239
00:14:43,220 --> 00:14:47,010
"이 매직 넘버를 거래 내역 목록의
마지막에 추가한 다음에"

240
00:14:47,010 --> 00:14:50,090
"그 값을 입력값으로 해서 SHA256 함수로 계산하면,"

241
00:14:50,090 --> 00:14:53,570
"결과 해쉬값의 첫 30비트는 모두 0이야!!"
라고 말했다고 해보자.

242
00:14:54,080 --> 00:14:57,110
그 매직 넘버를 알아내는데
도대체 얼마나 많은 계산을 한 걸까?

243
00:14:58,060 --> 00:14:59,520
그냥 난수로 만들어진 메시지에서

244
00:14:59,520 --> 00:15:05,830
이처럼 처음 30자리가 모두 0일 확률은
2의 30승 분의 1 이야.

245
00:15:05,830 --> 00:15:07,650
대략 10억 분의 1 이지.

246
00:15:08,150 --> 00:15:12,110
SHA256 해쉬 함수는 암호화 해쉬 함수이므로

247
00:15:12,110 --> 00:15:16,170
매직 넘버를 찾아낼 수 있는 유일한 방법은
아무 값이나 넣고 계산해서
결과를 비교하는 수밖에 없어.

248
00:15:16,640 --> 00:15:20,880
그러니 그 사람은 답을 찾아내기 위해
아무값이나 넣고 계산하는 일을 
대략 10억번 반복했다는 얘기지.

249
00:15:20,880 --> 00:15:22,670
그러니 그 사람은 답을 찾아내기 위해
아무값이나 넣고 계산하는 일을
대략 10억번 반복했다는 얘기지.

250
00:15:23,000 --> 00:15:24,830
하지만 그 매직 넘버가 정말 맞는 답인지 확인해 볼 때는

251
00:15:24,830 --> 00:15:29,110
단 한 번만 계산해보고 그 결과값이 정말로
30개의 0으로 시작하는지 쉽게 알 수 있지.

252
00:15:29,800 --> 00:15:33,900
정리하면, 매직 넘버를 찾아내는 데는
엄청난 양의 계산이 필요하지만

253
00:15:33,900 --> 00:15:36,720
그 매직 넘버가 맞는 값인지 확인해 보는 일에는
별로 많은 양의 계산이 필요하지 않다는 거야.

254
00:15:37,330 --> 00:15:39,040
이를 "작업 증명"이라고 해.

255
00:15:39,430 --> 00:15:44,610
중요한 것은 이런 "작업"에는
내부적으로 일정한 수의 거래 내역이 포함되기 때문에

256
00:15:44,930 --> 00:15:48,080
그 거래 정보를 아주 조금만 변경하더라도

257
00:15:48,080 --> 00:15:49,890
결과 해쉬값은 완전히 달라질 것이고,

258
00:15:50,150 --> 00:15:54,200
새로운 매직 넘버를 찾아내는 작업 증명을 완수하기 위해
10억번의 계산을 다시 해야돼.

259
00:15:54,200 --> 00:15:55,670
새로운 매직 넘버를 찾아내는 작업 증명을 완수하기 위해
10억번의 계산을 다시 해야돼.

260
00:15:55,670 --> 00:16:00,880
그렇게 새로 찾아낸 매직 넘버와 변경된 거래 내역을 통해
계산한 해쉬값은 30개의 0으로 시작하게 되지.

261
00:16:01,530 --> 00:16:04,400
자 이제 앞에서 살펴봤던 분산 장부로 다시 돌아가보자.

262
00:16:04,690 --> 00:16:07,240
모두가 거래 정보를 브로드캐스팅 하고 있어.

263
00:16:07,240 --> 00:16:11,080
장부를 가진 다른 사람들이
어느 장부가 올바른 장부인지 모두 동의하려면,

264
00:16:11,490 --> 00:16:14,920
다시 말해, 비트코인 논문에 담겨 있던
그 핵심 아이디어는

265
00:16:14,920 --> 00:16:18,700
"장부를 가진 모든 사람들은
가장 많은 계산 작업이 포함된 장부를 믿으면 된다."
라는 거야.

266
00:16:19,370 --> 00:16:23,200
장부는 블록 단위로 나누어서 구성되어 있고,

267
00:16:23,200 --> 00:16:27,410
블록에는 일정한 수의 거래 내역이
작업 증명(매직 넘버)과 함께 담겨 있으며,

268
00:16:27,840 --> 00:16:32,600
그 블록의 해쉬값은 정해진 만큼의
여러 자리수의 0으로 시작하겠지.

269
00:16:33,190 --> 00:16:37,280
먼저 블록의 해쉬값이 60자리의 0으로
시작해야 한다고 해보자.

270
00:16:37,280 --> 00:16:41,040
나중에는 이 60이라는 값을 결정하는데도
어떤 체계가 있다는 것을 알게될 거야.

271
00:16:41,840 --> 00:16:46,800
거래는 지불하는 송금자의 디지털 서명이 있어야만
유효한 거래로 인식되는 것처럼

272
00:16:46,800 --> 00:16:50,220
블록도 마찬가지로 작업 증명이 있어야만
유효한 블록으로 인식될 수 있어.

273
00:16:51,040 --> 00:16:54,700
더 나아가서 블록들의 순서까지 보장하려면

274
00:16:54,700 --> 00:16:59,760
각 블록이 자기보다 앞에 있는 이전 블록의
해쉬값을 포함하게 하면 돼.

275
00:17:00,150 --> 00:17:03,550
이렇게 하면 과거로 돌아가서
어떤 블록의 내용을 변경하거나

276
00:17:03,550 --> 00:17:05,550
어떤 두 블록의 순서를 바꾼다면,

277
00:17:05,890 --> 00:17:08,230
변경한 블록에 대한 해쉬값이 바뀌므로,
그 다음에 이어져 있는 블록들의 내용도 바뀌고

278
00:17:08,230 --> 00:17:10,010
결과적으로 다음에 이어지는
블록들의 해쉬값도 바뀌게 되지.

279
00:17:10,010 --> 00:17:13,070
그 변경은 그 이후의 모든 블록에서
연쇄적으로 발생하게 돼.

280
00:17:14,040 --> 00:17:16,370
결국 이후의 모든 블록마다 해쉬값이
60 자리의 0으로 시작하게 하는

281
00:17:16,370 --> 00:17:21,660
작업 증명을 다시 해야만
변경이 발생한 이후의 모든 블록들이
유효한 블록이 될 수 있겠지.

282
00:17:22,410 --> 00:17:25,040
블록은 이렇게 앞의 블록의 해쉬값을 통해
앞뒤가 연쇄적으로 연결되어 있기 때문에

283
00:17:25,040 --> 00:17:28,800
그냥 장부라고 부르지 않고 "블록체인"이라고 부르지.

284
00:17:30,050 --> 00:17:31,920
체인을 이루도록 변경된 규약에 의해,

285
00:17:31,920 --> 00:17:34,780
이제는 누구든지 블록을 생성할 수 있게 되었어.

286
00:17:35,230 --> 00:17:38,950
무슨 얘기냐 하면 누구든지 브로드캐스팅 되는
거래 정보를 접수하고

287
00:17:38,950 --> 00:17:40,620
접수한 거래 정보를 모아서 블록을 만들고

288
00:17:40,620 --> 00:17:42,110
그 블록의 해쉬값이 60개의 0으로 시작하게 하는

289
00:17:42,110 --> 00:17:46,400
매직 넘버를 찾기 위해 엄청난 양의
계산 작업을 수행하고

290
00:17:46,900 --> 00:17:50,210
마침내 그 매직 넘버를 찾아내서
그 블록을 브로드캐스팅하면 블록의 생성자가 되는거야.

291
00:17:50,970 --> 00:17:53,490
이 모든 작업을 수행한 블록 생성자에게
보상을 주기 위해서는

292
00:17:53,490 --> 00:17:55,270
거래 정보를 모아서 블록을 구성할 때

293
00:17:55,270 --> 00:17:59,070
블록 생성자에게 예를 들어 10 장부달러를 지급한다는
아주 특별한 거래를

294
00:17:59,070 --> 00:18:02,780
블록의 맨 처음 거래로 포함하게 하면 돼.

295
00:18:03,470 --> 00:18:05,230
이 특별한 거래를 "블록 보상"이라고 불러.

296
00:18:05,230 --> 00:18:09,800
이 특별한 블록 보상에는
일반적으로 거래를 받아들이거나 거절하는데 적용되는 기준이 예외적으로 적용되지 않아.

297
00:18:10,010 --> 00:18:13,190
그리고 보상액을 지급하는 주체가 없으므로
디지털 서명이 필요하지 않지.

298
00:18:13,600 --> 00:18:19,720
이는 블록이 새로 생성될 때마다 보상에 의해
장부달러의 총액이 증가한다는 얘기야.

299
00:18:20,880 --> 00:18:23,200
블록을 생성하고 보상을 받는 것을
"채굴"이라고 부르기도 하지.

300
00:18:23,200 --> 00:18:25,220
블록을 생성할 때 많은 작업을 해야하고

301
00:18:25,220 --> 00:18:28,460
실물 경제에 새로운 화폐를 도입하게 하므로
채굴이라고 부르는 것도 나쁘지 않은 것 같아.

302
00:18:29,070 --> 00:18:31,470
하지만 이제부터 비트코인 채굴자에 대한
얘기를 듣거나 읽을 때는

303
00:18:31,470 --> 00:18:33,730
채굴자들이 실제로 하는 일은

304
00:18:33,730 --> 00:18:36,630
브로드캐스팅 되는 거래 정보를 수집하고,
블록을 새로 생성해서,

305
00:18:36,630 --> 00:18:40,900
생성한 새 블록을 다시 브로드캐스팅하고
보상을 받는 일이라는 것을 잊지 말자고.

306
00:18:41,940 --> 00:18:46,230
채굴자의 입장에서는 각 블록이 미니 로또나 마찬가지야.

307
00:18:46,230 --> 00:18:49,140
모든 채굴자들이 서로 먼저 매직 넘버를 찾기 위해
경쟁하고

308
00:18:49,140 --> 00:18:52,460
결국 매직 넘버를 가장 먼저 찾아내는 단 한 채굴자가

309
00:18:52,460 --> 00:18:55,310
결국 매직 넘버를 가장 먼저 찾아내는 단 한 채굴자가

310
00:18:55,310 --> 00:18:56,370
보상을 받게 되거든.

311
00:18:58,040 --> 00:19:01,200
채굴자가 아닌, 그러니까 비트코인을
결제 수단으로만 사용하는 사람들은

312
00:19:01,200 --> 00:19:03,430
브로드캐스팅 되는 모든 거래 정보를 수집하는 대신에

313
00:19:03,430 --> 00:19:07,080
채굴자가 브로드캐스팅하는 블록 정보만 수집해서

314
00:19:07,080 --> 00:19:10,010
각자의 블록체인 복사본을 업데이트 하면 돼.

315
00:19:10,510 --> 00:19:13,320
이제 규약에 핵심적인 내용이 추가되는데,

316
00:19:13,320 --> 00:19:17,930
여러분에게 서로 충돌되는 이력을 가진
두 개의 서로 다른 블록체인 정보가 들어왔다면

317
00:19:18,310 --> 00:19:22,350
여러분은 둘 중에서 더 많은 계산 작업이 포함된
더 긴 블록체인만을
유효한 블록체인으로 받아들여야 한다는 거야.

318
00:19:22,900 --> 00:19:27,930
두 개의 블록체인의 길이가 같다면,
더 긴 블록체인 정보가 들어올 때까지
어느 한 쪽을 선택하지 말고 기다려야 돼.

319
00:19:28,720 --> 00:19:33,910
따라서 모두가 각자의 블록체인 복사본을
각자 따로 가지고 있더라도

320
00:19:34,180 --> 00:19:39,260
가장 많은 계산 작업을 포함하고 있는 가장 긴 블록체인만
유효한 블록체인으로 인정하는데 동의한다면,

321
00:19:39,660 --> 00:19:42,980
우리는 중앙의 통제 기관에 의지하지 않고도
분산된 합의에 도달할 수 있어.

322
00:19:43,640 --> 00:19:45,840
이런 방식이 어떻게 신뢰할 수 있는 체계를 만들어내는지
알아보려면

323
00:19:45,840 --> 00:19:49,450
그리고 어떤 지불이 유효하다는 것을
어느 시점에 신뢰해도 되는 건지 이해하려면,

324
00:19:49,450 --> 00:19:55,070
이 체계를 이용하는 누군가가 다른 누군가를
속이는 사례를 검토해보는 것이 효과적이야.

325
00:19:55,650 --> 00:19:58,690
앨리스가 거짓 블록으로 밥을 속이려 한다고 해보자.

326
00:19:59,030 --> 00:20:04,080
앨리스는 밥에게 100 장부달러를 지불한다는
거짓 거래가 포함된 블록을 밥에게 보내고

327
00:20:04,420 --> 00:20:07,260
그 블록을 블록체인 네트워크 상의 다른 사람들에게는
브로드캐스팅하지 않는다고 해보자.

328
00:20:07,620 --> 00:20:11,440
이러면 밥을 제외한 다른 사람들은
앨리스가 여전히 100 장부달러를 가지고 있는 걸로 알지.

329
00:20:12,150 --> 00:20:17,250
이게 가능하려면, 앨리스는 각자의 블록을 채굴하고 있는
다른 모든 채굴자들보다 먼저

330
00:20:17,250 --> 00:20:18,860
그 거짓 블록의 매직 넘버를 찾아내야 돼.

331
00:20:19,410 --> 00:20:20,990
실제로 앨리스가 먼저 찾아낼 수도 있지!!

332
00:20:20,990 --> 00:20:24,980
앨리스가 운좋게 다른 사람들보다 먼저
이 미니 로또를 맞출 수도 있는 거니까.

333
00:20:25,680 --> 00:20:29,770
하지만 밥은 앨리스 뿐아니라 다른 채굴자들이
브로드캐스팅하는 블록 정보도 수집하고 있어.

334
00:20:30,080 --> 00:20:32,640
따라서 그 거짓 블록을 밥이 계속 신뢰하게 하려면

335
00:20:32,640 --> 00:20:35,440
앨리스는 그 거짓 블록이 포함된 밥의 블록체인에
블록을 추가하는 일을 혼자서 계속 해야 돼.

336
00:20:35,440 --> 00:20:39,440
앨리스는 그 거짓 블록이 포함된 밥의 블록체인에
블록을 추가하는 일을 혼자서 계속 해야 돼.

337
00:20:39,440 --> 00:20:42,330
그 블록체인은 밥이 다른 채굴자들로부터 수집하고 있는
블록체인과는 내용이 다른 블록체인이겠지.

338
00:20:42,720 --> 00:20:48,400
다시 떠올려보자. 규약에 따르면,
밥은 항상 가장 긴 블록체인을
유효한 것으로 인정해야돼.

339
00:20:49,230 --> 00:20:51,960
앨리스의 거짓 블록이 포함된 블록체인이
밥이 가진 가장 긴 블록체인으로 계속 남을 수도 있어.

340
00:20:51,960 --> 00:20:55,140
앨리스가 운좋게도 네트워크에 있는
다른 모든 채굴자들이 생성해내는 블록보다

341
00:20:55,140 --> 00:20:58,050
더 많은 블록을 생성할 수 있다면 말이지.

342
00:20:58,560 --> 00:21:03,710
하지만 앨리스가 모든 채굴자들의 컴퓨팅 자원의
50%에 근접하는 자원을 보유하지 못하면

343
00:21:04,080 --> 00:21:06,570
그런 일이 실제로 발생할 가능성은 매우 낮아.

344
00:21:06,570 --> 00:21:09,650
다른 모든 채굴자들이 생성해내는 블록들로
구성되는 블록체인이 결국에는

345
00:21:09,650 --> 00:21:14,190
앨리스가 밥을 속이기 위해 혼자 만들어가고 있는
블록체인보다 더 빨리 길어질 것이기 때문이지.

346
00:21:15,200 --> 00:21:19,820
그래서 결국 충분한 시간이 지나면,
밥은 앨리스에게 받는 블록체인 정보를 기각하게 돼.

347
00:21:19,820 --> 00:21:23,100
앨리스에게 받는 블록체인보다
다른 사람들로부터 받는 블록체인이 더 길기 때문이지.

348
00:21:24,020 --> 00:21:29,250
새로 생성되어 브로드캐스팅 된 블록을
접수하자마자 신뢰할 필요는 없다는 점에 유의하라고.

349
00:21:29,620 --> 00:21:33,420
대신에 새 블록 몇 개가 더 추가될 때까지
기다린 후에 신뢰해야돼.

350
00:21:33,890 --> 00:21:36,610
기다린 후에도 더 긴 블록체인 정보를 접수하지 못했다면

351
00:21:36,610 --> 00:21:41,800
그때서야 여러분은 그 블록이
다른 사람들이 모두 신뢰하고 사용하고 있는 블록체인에 있는 유효한 블록이라고 신뢰할 수 있게 되는거야.

352
00:21:42,250 --> 00:21:45,520
이제 핵심 아이디어는 모두 알아봤어.

353
00:21:45,850 --> 00:21:49,190
"작업 증명"에 기반한 이 분산 장부 시스템은

354
00:21:49,190 --> 00:21:53,810
비트코인 규약이 동작하는 방식과
다른 많은 암호화 화폐가 동작하는 방식의 근간이야.

355
00:21:54,260 --> 00:21:56,280
정확하게 정리하고 넘어가야 할
세부 내용들도 몇 가지 있어.

356
00:21:56,280 --> 00:21:59,480
아까 작업 증명이란 블록의 해쉬값이
60개의 0으로 시작하게 하는
매직 넘버를 찾는 일이라고 얘기했는데,

357
00:21:59,480 --> 00:22:02,830
아까 작업 증명이란 블록의 해쉬값이
60개의 0으로 시작하게 하는
매직 넘버를 찾는 일이라고 얘기했는데,

358
00:22:03,210 --> 00:22:08,400
정확하게는 비트코인은 그 0의 갯수를
주기적으로 조절하는 규약을 가지고 있어.

359
00:22:08,400 --> 00:22:12,080
그래서 새 블록을 생성하는데 드는 시간이 평균적으로
10분이 되도록 주기적으로 0의 갯수를 조절해.

360
00:22:12,800 --> 00:22:15,730
그래서 더 많은 채굴자가 비트코인의
블록체인 네트워크에 참여하면

361
00:22:16,010 --> 00:22:18,230
0의 갯수를 늘려서 매직 넘버를 찾아내기
더 어렵게 만들지.

362
00:22:18,230 --> 00:22:23,170
이 방식을 통해 미니 로또 당첨자는
대략 10분 마다 탄생되는거야.

363
00:22:23,950 --> 00:22:28,080
많은 새로운 암호화 화폐들은 대개 10분보다
훨씬 더 짧은 블록 생성 시간을 갖고 있어.

364
00:22:28,660 --> 00:22:32,770
비트코인에서의 모든 코인은
이 블록 보상에서 만들어지는거야.

365
00:22:33,030 --> 00:22:35,890
처음에는 블록 하나 당 
50 비트코인이 보상으로 주어졌어.

366
00:22:36,190 --> 00:22:39,380
"Block Explorer"라는 웹사이트에 가면

367
00:22:39,380 --> 00:22:41,760
비트코인 블록체인 정보를 쉽게 살펴볼 수 있어.

368
00:22:41,990 --> 00:22:45,030
맨 처음 몇 블록을 살펴보면

369
00:22:45,030 --> 00:22:49,520
채굴자에게 50 비트코인을 보상으로 주었다는
블록 보상 거래만 보일거야.

370
00:22:49,970 --> 00:22:54,800
21만 블록마다, 시간적으로는 약 4년 마다

371
00:22:54,800 --> 00:22:56,890
보상액은 절반으로 줄어들어.

372
00:22:56,890 --> 00:23:00,390
그래서 지금(2017년 7월)은
블록 당 12.5 비트코인이 보상으로 지급되고 있어.

373
00:23:00,740 --> 00:23:04,340
보상액이 시간이 지남에 따라
기하급수적으로 줄어들게 되므로

374
00:23:04,710 --> 00:23:09,750
비트코인의 총 개수가 2,100만개가 되면
보상액은 0이 되고 코인 수는 더 이상 늘어나지 않아.

375
00:23:10,450 --> 00:23:13,520
하지만 보상액이 0이 된다고 해서
채굴자들이 채굴을 멈추지는 않아.

376
00:23:13,950 --> 00:23:18,230
왜냐하면 채굴자들은 블록 보상 외에도
일정량의 거래 수수료를 챙길 수 있기 때문이지.

377
00:23:18,500 --> 00:23:20,970
여러분이 비트코인으로 지불할 때

378
00:23:20,970 --> 00:23:24,700
옵션으로 소액의 거래 수수료를 포함할 수 있어.

379
00:23:24,700 --> 00:23:28,620
그럼 그 지불이 포함된 블록의 생성자가
그 거래 수수료를 가져가게 돼.

380
00:23:29,280 --> 00:23:32,100
거래 수수료를 포함하면
채굴자들이 수수료가 포함된 그 거래를

381
00:23:32,100 --> 00:23:36,080
다른 거래보다 먼저 블록에 포함시키도록
동기부여가 되겠지.

382
00:23:36,430 --> 00:23:42,080
비트코인에서는 약 2,400개까지의 거래만
하나의 블록에 포함될 수 있도록 제한하고 있어.

383
00:23:42,080 --> 00:23:45,380
이 부분은 사실 불필요한 제약이라며
많은 비판을 받고 있기도 해.

384
00:23:45,970 --> 00:23:51,740
다른 것과 비교를 해보자면, VISA 카드사는
초당 평균 1,700개의 거래를 처리한다고 해.

385
00:23:51,740 --> 00:23:55,510
초당 최대 24,000개의 거래도 처리할 수 있다고 하네.

386
00:23:56,240 --> 00:24:01,390
이처럼 상대적으로 느린 비트코인 처리 시간은
놓은 수수료를 지불하게 되는 원인이 되기도 하지.

387
00:24:01,390 --> 00:24:06,410
왜냐면 채굴자가 어떤 거래를 선택해서 블록에 포함할지
결정하는 기준이 바로 거래 수수료이기 때문이야.

388
00:24:08,160 --> 00:24:12,140
지금까지 다뤘던 주제들이
암호화 화폐의 전부는 결코 아니야.

389
00:24:12,140 --> 00:24:16,400
암호화 화폐에는 더 다양한 주제 및 뉘앙스와
설계 대안들도 많이 있어.

390
00:24:16,720 --> 00:24:21,550
하지만 지금까지 다룬 주제들이 "잠깐만 근데 왜.." 같은
생각의 뿌리가 될 수 있기를 진심으로 바라는 마음이야.

391
00:24:21,550 --> 00:24:24,710
그래서 다른 자료들을 읽으면서
더 많은 생각의 가지로 자라나기를 바라고.

392
00:24:25,250 --> 00:24:26,280
처음에 얘기했던 것처럼,

393
00:24:26,280 --> 00:24:31,170
이걸 만든 이유는, 많은 돈이 암호화 화폐 분야로
흘러들어가고 있기 때문이야.

394
00:24:31,370 --> 00:24:35,090
그게 좋은 투자인지 나쁜 투자인지를
내가 평가할 일은 아니지만,

395
00:24:35,330 --> 00:24:38,210
사람들이 어떤 게임에 참가하려면,

396
00:24:38,210 --> 00:24:40,720
그 기술의 기초에 대해서는 알고 참가하는 것이
건전한 방식이라고 생각해.

397
00:24:41,550 --> 00:24:45,750
언제나처럼, 이 채널을 만들어가는
Patreon과 그 멤버들에게
진심으로 감사 말씀 전하고 싶어.

398
00:24:46,170 --> 00:24:49,180
모든 사람들이 공헌할 수는 없다는 것은
나도 알고 있어.

399
00:24:49,180 --> 00:24:51,280
하지만 여러분이 여전히 어떻게든
도와주고 싶다면

400
00:24:51,280 --> 00:24:52,700
가장 좋은 방법은

401
00:24:52,700 --> 00:24:57,200
여러분이 재미있다고 생각하거나
다른 사람들에게 도움이 될 것 같은 비디오를
여러 곳에 공유해 주는 거야.

