1
00:00:00,000 --> 00:00:04,226
拥有比特币意味着什么？

2
00:00:04,226 --> 00:00:07,929
很多人都听说过比特币，它是一种

3
00:00:07,929 --> 00:00:13,947
完全数字化的货币，没有政府发行，没有银行需要管理账

4
00:00:13,947 --> 00:00:19,271
户和验证交易，而且没有人真正知道是谁发明了它。

5
00:00:19,271 --> 00:00:24,421
然而许 多人并不知道这个问题的答案，至少不完全知道。

6
00:00:24,421 --> 00:00:30,094
为了实现 这一目标，并确保答案背后的技术细节确实让人感到

7
00:00:30,094 --> 00:00:35,180
有动力，我们将逐步介绍您如何发明自己版本的比特 币。

8
00:00:35,180 --> 00:00:39,421
我们将从您使用公共分类账记录与朋友的付款开始

9
00:00:39,421 --> 00:00:44,216
，然后当您开始越来越不信任您的朋友和周围的世界时，

10
00:00:44,216 --> 00:00:49,010
如果您足够聪明，可以从以下地方引入一些想法密码学可

11
00:00:49,010 --> 00:00:53,620
以帮助规避信任需求，最终得到的就是所谓的加密货币。

12
00:00:53,620 --> 00:00:59,798
比特币只是加密货币的第一个实施示例，现在还有数千种加密

13
00:00:59,798 --> 00:01:02,666
货币在与传统货币进行交易。

14
00:01:02,666 --> 00:01:08,262
走上自己发明的道路有助 于为了解游戏中的一些较新的玩家

15
00:01:08,262 --> 00:01:13,858
奠定基础，并认识 到何时以及为何有不同设计选择的空间。

16
00:01:13,858 --> 00:01:20,122
事实上， 我选择这个主题的原因之一是，去年这些货币受

17
00:01:20,122 --> 00:01:23,370
到了大量的关注、投资和炒作。

18
00:01:23,370 --> 00:01:28,208
我不会评论或推测 当前或未来的汇率，但我认为我们都同

19
00:01:28,208 --> 00:01:33,232
意，任何想要购买 加密货币的人都应该真正知道它是什么。

20
00:01:33,232 --> 00:01:37,720
我的意思不仅仅是 与黄金开采的模糊联系的

21
00:01:37,720 --> 00:01:41,310
类比，我的意思是对我们发送、接

22
00:01:41,310 --> 00:01:46,920
收和创建加密货币时计算机正在做什么的实际直接描述。

23
00:01:46,920 --> 00:01:51,554
值得强调的一件事是，即使你和我要深入研究这里的细节，并

24
00:01:51,554 --> 00:01:56,189
且这需要花费有意义的时间，但如果你只是想使用加密货币，

25
00:01:56,189 --> 00:02:00,823
你实际上不需要知道这些细节，就像你不知道一样当您刷信用

26
00:02:00,823 --> 00:02:03,637
卡时，无需了解幕后发生的详细情况。

27
00:02:03,637 --> 00:02:07,619
与任何数字支付一样， 有许多用户友好的应用程序可

28
00:02:07,619 --> 00:02:11,600
让您只需发送和接收货币，而无 需考虑发生了什么。

29
00:02:11,600 --> 00:02:17,229
不同之处在于，其背后的骨干不是 验证交易的银行。

30
00:02:17,229 --> 00:02:20,913
相反，它是一个基于密码学中的一

31
00:02:20,913 --> 00:02:25,980
些数学原理的去中心化、去信任验证的聪明系统。

32
00:02:25,980 --> 00:02:30,460
但首先，我希望你能真正把加密货币之类的想法放在一 边几分钟。

33
00:02:30,460 --> 00:02:35,636
我们将从更实际的东西开始这个故事，账 本和数字签名。

34
00:02:35,636 --> 00:02:38,815
如果您和您的朋友经常兑换货币，支

35
00:02:38,815 --> 00:02:44,051
付您应得的晚餐费用等，那么一直兑换现金可能会很不 方便。

36
00:02:44,051 --> 00:02:48,018
因此，您可能会保留一个公共分类账，记录您打

37
00:02:48,018 --> 00:02:50,904
算在未来某个时刻支付的所有付款。

38
00:02:50,904 --> 00:02:52,732
Alice 付给 Bob 20 美元，Bob

39
00:02:52,732 --> 00:02:54,480
付给 Charlie 40 美元，诸如此类。

40
00:02:54,480 --> 00:02:57,940
这个分类账将是公开的，每个人都可

41
00:02:57,940 --> 00:03:02,620
以访问，就像一个任何人都可以去添加新行的网站。

42
00:03:02,620 --> 00:03:07,557
假设每个月末你们都聚在一起，查看交易清单 ，然后结算。

43
00:03:07,557 --> 00:03:10,978
如果你花的钱多于收到的钱，你就把钱放

44
00:03:10,978 --> 00:03:15,480
进锅里，如果你收到的钱多于花的钱，你就把钱拿出来。

45
00:03:15,480 --> 00:03:19,884
因此，作为这个非常简单的系统一部分的协议可能如下所示。

46
00:03:19,884 --> 00:03:22,386
任何人 都可以在账本上添加行数

47
00:03:22,386 --> 00:03:25,054
，每个月底你们都会聚在一起结算。

48
00:03:25,054 --> 00:03:30,471
现在像这样的公共分类账的一个问题是任何人 都可以添加一行。

49
00:03:30,471 --> 00:03:34,131
那么，怎样才能阻止鲍勃在未经爱丽丝批准的情况下写下“

50
00:03:34,131 --> 00:03:36,571
爱丽丝向鲍勃支付 100 美元”呢？

51
00:03:36,571 --> 00:03:45,020
我们如何才能相信所 有这些交易都是发送者所希望的？

52
00:03:45,020 --> 00:03:49,582
这就是密码学的第一个部分——数字签名。

53
00:03:49,582 --> 00:03:54,080
就像手写签 名一样，这里的想法是，爱丽丝应该

54
00:03:54,080 --> 00:03:58,578
能够在该交易旁边添加 一些东西，证明她已经看

55
00:03:58,578 --> 00:04:03,485
到并批准了它，并且其他任何人 都无法伪造该签名。

56
00:04:03,485 --> 00:04:08,910
乍一看，数字签名似乎根 本不可能。

57
00:04:08,910 --> 00:04:14,694
我的意思是，构成该签名的任何数据都可以 由计算机读取和复制。

58
00:04:14,694 --> 00:04:17,460
那么如何防止伪造呢？

59
00:04:17,460 --> 00:04:22,093
其工作原理是，每个人都会生成所谓的公钥-私钥对，每个

60
00:04:22,093 --> 00:04:24,324
密钥对看起来都像一些位串。

61
00:04:24,324 --> 00:04:29,539
私钥有时也称为秘密密钥，因 此我们可以将其缩写为

62
00:04:29,539 --> 00:04:32,460
SK，而将公钥缩写为 PK。

63
00:04:32,460 --> 00:04:37,140
顾名思义，这个秘密密钥是您想要保守秘密的东西。

64
00:04:37,140 --> 00:04:39,647
在现实世界中，无论您签署什么文档

65
00:04:39,647 --> 00:04:42,312
，您的手写签名看起来都是一样 的。

66
00:04:42,312 --> 00:04:47,427
但数字签名实际上要强大得多，因为它会根据不同的消息而变 化。

67
00:04:47,427 --> 00:04:52,754
它看起来像一些由 1 和 0 组成的字符串，通常类

68
00:04:52,754 --> 00:04:58,491
似于 256 位，即使稍微改变消息也会完全改变该消息上

69
00:04:58,491 --> 00:04:59,925
的签名的外观。

70
00:04:59,925 --> 00:05:03,792
更正式地说，生成签名涉及一个既

71
00:05:03,792 --> 00:05:08,384
取决于消息本身又取决于您的私钥的函数。

72
00:05:08,384 --> 00:05:13,392
私钥确保只有您可以生成该签名，并且它取决于消息这

73
00:05:13,392 --> 00:05:18,600
一事实意味着没有人可以复制您的签名之一并将其伪造到

74
00:05:18,600 --> 00:05:20,003
另一条消息上。

75
00:05:20,003 --> 00:05:23,498
与此相关的是第二个函数，用于验

76
00:05:23,498 --> 00:05:28,085
证签名是否有效，这就是公钥发挥作用的地方。

77
00:05:28,085 --> 00:05:33,068
它所做的只是输出 true 或 false，以指示

78
00:05:33,068 --> 00:05:37,860
这是否是由与您用于验证的公钥关联的私钥生成的签名。

79
00:05:37,860 --> 00:05:43,258
我不会详细介绍这两个函数到底如何工作，但其想法

80
00:05:43,258 --> 00:05:49,106
是，如果您不知道密钥，则完全不可能找到有效的 签名。

81
00:05:49,106 --> 00:05:53,866
具体来说，没有比猜测和检查随机签名更好的

82
00:05:53,866 --> 00:05:59,080
策略了，您可以使用每个人都知道的公钥进行检查。

83
00:05:59,080 --> 00:06:03,890
现在想想长度为256位的签名有多少个。

84
00:06:03,890 --> 00:06:05,998
这是 2 的 256 次方！

85
00:06:05,998 --> 00:06:08,522
这是一个大得愚蠢的数字。

86
00:06:08,522 --> 00:06:14,088
称其为天文巨星，未免 太过于相信天文学了。

87
00:06:14,088 --> 00:06:20,480
事实上，我制作了一个 补充视频，专门用来说明这个数字有多大。

88
00:06:20,480 --> 00:06:26,260
但在这里，我们只能说，当您验证给定消息的签名是否

89
00:06:26,260 --> 00:06:32,041
有效时，您可以非常有信心地认为，某人生成签名的唯

90
00:06:32,041 --> 00:06:37,360
一方法是他们知道与您用于验证的公钥关联的密钥。

91
00:06:37,360 --> 00:06:42,478
确保人们在账本上签署交易固然很好，但有一个小漏 洞。

92
00:06:42,478 --> 00:06:46,527
如果爱丽丝签署了一笔交易，例如爱丽丝向鲍勃支付

93
00:06:46,527 --> 00:06:50,408
100 美 元，即使鲍勃无法在新消息上伪造爱丽

94
00:06:50,408 --> 00:06:54,120
丝的签名，他也可以根据需要多 次复制同一行。

95
00:06:54,120 --> 00:06:58,040
该消息签名组合仍然有效。

96
00:06:58,040 --> 00:07:03,690
为了解决这个问题，我们在您签署交易时，消息还必须

97
00:07:03,690 --> 00:07:07,532
包含某种与该交易关联的唯一 ID。

98
00:07:07,532 --> 00:07:12,433
这样，如果 Alice 多次向 Bob 支付

99
00:07:12,433 --> 00:07:18,400
100 美 元，则分类账上的每一行都需要一个全新的签名。

100
00:07:18,400 --> 00:07:22,665
数字签名消除了对该初始协议的很大程度的信任。

101
00:07:22,665 --> 00:07:27,486
但即便如此 ，如果你真的这样做，你就会依赖某种荣誉制度。

102
00:07:27,486 --> 00:07:32,263
也就是 说，您相信每个人都会真正遵守并在每个月底以现

103
00:07:32,263 --> 00:07:32,971
金结算。

104
00:07:32,971 --> 00:07:39,241
例如，如果查理欠下了数千美元的债务并且拒绝 露面怎么办？

105
00:07:39,241 --> 00:07:45,946
恢复现金结算的唯一真正原因是，如果有 人欠了很多钱。

106
00:07:45,946 --> 00:07:49,949
因此，也许你有一个聪明的想法，只要

107
00:07:49,949 --> 00:07:55,509
你有办法防止人们支出超出他们的收入，你实际上就不

108
00:07:55,509 --> 00:07:57,065
必用现金结算。

109
00:07:57,065 --> 00:08:00,322
也许你首先让每个人向彩池中支付 100

110
00:08:00,322 --> 00:08:04,231
美元，然后让账本的前几行显示爱丽丝获得 100

111
00:08:04,231 --> 00:08:08,302
美元， 鲍勃获得 100 美元，查理获得 100

112
00:08:08,302 --> 00:08:09,280
美元，等等。

113
00:08:09,280 --> 00:08:15,061
现在，只要有人花费的金额超过了账本上的金额，就不要接受

114
00:08:15,061 --> 00:08:16,094
任何交易。

115
00:08:16,094 --> 00:08:21,853
例如，如果前两笔交易是查理向爱丽丝支付 50 美元，查理

116
00:08:21,853 --> 00:08:27,017
向鲍勃支付 50 美元，如果他尝试添加查理向您支付

117
00:08:27,017 --> 00:08:32,380
20 美元，则该交 易将无效，就像他从未签名一样无效。

118
00:08:32,380 --> 00:08:36,296
请注意，这意味着验证交易需 要

119
00:08:36,296 --> 00:08:40,474
了解截至该点的完整交易历史记录。

120
00:08:40,474 --> 00:08:47,200
加密货币也 是如此，尽管还有一点优化的空间。

121
00:08:47,200 --> 00:08:55,517
这里有趣的是，这一步消除了账本和实际实物美 元之间的联系。

122
00:08:55,517 --> 00:08:59,004
理论上，如果世界上每个人都在使用这个

123
00:08:59,004 --> 00:09:04,326
分类账，那么你可以一辈子只在这个分类账上发送和接收资金，

124
00:09:04,326 --> 00:09:06,528
而无需转换为真正的美元。

125
00:09:06,528 --> 00:09:10,698
事实上，为了强调这一点，我们 开始将

126
00:09:10,698 --> 00:09:15,100
账本上的数量称为账本美元，简称 LD。

127
00:09:15,100 --> 00:09:19,143
您可以 自由地将账本美元兑换成真实的美元。

128
00:09:19,143 --> 00:09:22,682
例如，Alice 在现实世界中给 Bob 一张

129
00:09:22,682 --> 00:09:26,369
10 美元的钞票，以换取他添加并签署交易，Bob

130
00:09:26,369 --> 00:09:30,203
向 Ali ce 支付 10 美元到这个公共分类账。

131
00:09:30,203 --> 00:09:34,370
但协议并不能保证这样的 交换。

132
00:09:34,370 --> 00:09:39,096
现在，它更类似于您在公开市场上将美元兑换成

133
00:09:39,096 --> 00:09:41,889
欧元或任何其他货币的方式。

134
00:09:41,889 --> 00:09:44,940
它只是它自己独立的东西。

135
00:09:44,940 --> 00:09:50,980
这是了解比特币或任何其他加密货币的第一件重要的事情。

136
00:09:50,980 --> 00:09:52,672
它是一个分类账。

137
00:09:52,672 --> 00:09:56,056
交易的历史就是货币。

138
00:09:56,056 --> 00:10:01,680
当然，对于比特币 ，人们使用现金购买时，钱不会进入分类账。

139
00:10:01,680 --> 00:10:04,922
几分钟后我将了 解新资金如何进入分类账。

140
00:10:04,922 --> 00:10:08,621
但在此之前，我们当前的账本美 元系统和加密

141
00:10:08,621 --> 00:10:12,496
货币的运作方式之间实际上存在更显着的差 异。

142
00:10:12,496 --> 00:10:16,010
到目前为止，我已经说过这个分类帐位于某个公共场

143
00:10:16,010 --> 00:10:18,645
所，例如任何人都可以添加新行的网站。

144
00:10:18,645 --> 00:10:22,499
但这需要信任一 个中心位置，即谁托

145
00:10:22,499 --> 00:10:26,579
管该网站，谁控制添加新线路的规 则。

146
00:10:26,579 --> 00:10:32,255
为了消除这种信任，我们将让每个人保留自己的账本副本。

147
00:10:32,255 --> 00:10:36,532
然后，当您想要进行交易时，例如 Alice 向 Bob

148
00:10:36,532 --> 00:10:40,810
支付 100 Ledger Dollars，您可以向全世

149
00:10:40,810 --> 00:10:45,240
界广播该交易，以便人们可以听到并记录在自己的私人分类账上。

150
00:10:45,240 --> 00:10:49,038
但除非你做更多的事情，否则这个系统就糟糕得离谱。

151
00:10:49,038 --> 00:10:52,913
如何让每个人都同 意什么是正确的账本？

152
00:10:52,913 --> 00:10:55,800
当 Bob 收到一笔交易时，比如 Alice

153
00:10:55,800 --> 00:10:58,185
向 Bob 支付 10 Ledger

154
00:10:58,185 --> 00:11:01,700
Dollars，他如何确定其他人收到并相 信同一笔交易？

155
00:11:01,700 --> 00:11:04,715
他稍后可以去找 Charlie 并使用这 10

156
00:11:04,715 --> 00:11:07,731
个 Ledg er Dollars 进行交易吗？

157
00:11:07,731 --> 00:11:12,286
真的，想象一下您自己正在收听 正在广播的交易。

158
00:11:12,286 --> 00:11:18,618
您如何确定其他人都以相同的顺 序记录相同的交易？

159
00:11:18,618 --> 00:11:21,306
这确实是问题的核心。

160
00:11:21,306 --> 00:11:23,111
这是 一个有趣的谜题。

161
00:11:23,111 --> 00:11:26,927
您能否提出一个关于如何接受或拒绝交易以

162
00:11:26,927 --> 00:11:32,079
及按什么顺序接受或拒绝交易的协议，以便您可以确信世界

163
00:11:32,079 --> 00:11:37,803
上遵循相同协议的其他人都拥有与您的个人账本相同的个人 账本？

164
00:11:37,803 --> 00:11:44,620
这是原始比特币论文中解决的问题。

165
00:11:44,620 --> 00:11:49,589
从较高的层面来看，比特币提供的解决方案是信任投入

166
00:11:49,589 --> 00:11:51,577
最多计算工作的账本。

167
00:11:51,577 --> 00:11:55,042
我将花点时间解释一下这到底意味着什么。

168
00:11:55,042 --> 00:11:57,919
它涉及加密哈希函数。

169
00:11:57,919 --> 00:12:02,622
我们将构建的总体想法是 ，如果您使用计算

170
00:12:02,622 --> 00:12:07,325
工作作为信任的基础，则可以实 现欺诈性交

171
00:12:07,325 --> 00:12:12,263
易和冲突账本需要不可行的计算量才能 实现。

172
00:12:12,263 --> 00:12:16,251
我再次提醒您，这已经超出了任何

173
00:12:16,251 --> 00:12:20,240
人使用这样的货币所需了解的范围。

174
00:12:20,240 --> 00:12:25,633
但这是一个非常酷的想法，如果你理解它，你就理解了比特币和其

175
00:12:25,633 --> 00:12:27,251
他加密货币的核心。

176
00:12:27,251 --> 00:12:30,880
首先，什么是哈希函数？

177
00:12:30,880 --> 00:12:35,348
这些函数之一的输入可以是任何类型的消息或文件，这并 不重要。

178
00:12:35,348 --> 00:12:39,878
输出是一串具有某种固定长度的位，例如 256 位。

179
00:12:39,878 --> 00:12:44,713
该输出称为消息的哈希值或摘要。

180
00:12:44,713 --> 00:12:47,656
其目的是让它 看起来随机。

181
00:12:47,656 --> 00:12:52,400
它不是随机的，对于给定的输入它总是给出相同的输出。

182
00:12:52,400 --> 00:12:58,080
但其想法是，如果您稍微更改输入，也许只编辑其中一个字符，则

183
00:12:58,080 --> 00:13:00,352
生成的哈希值会完全改变。

184
00:13:00,352 --> 00:13:05,043
事实上，对于我在这里展示的称为 SH A256

185
00:13:05,043 --> 00:13:10,711
的哈希函数，当您稍微更改输入时，输出的变化方式是完全不可

186
00:13:10,711 --> 00:13:11,492
预测的。

187
00:13:11,492 --> 00:13:17,480
你看，这不仅仅是一个哈希函数，它是一个加密哈希函数。

188
00:13:17,480 --> 00:13:21,031
这意味着反向计算是不可行的。

189
00:13:21,031 --> 00:13:24,121
如果我向您展示一些 由 1 和 0

190
00:13:24,121 --> 00:13:28,413
组成的字符串，并要求您找到一个输入，以便该输入的

191
00:13:28,413 --> 00:13:33,048
SHA 256 哈希值给出这个精确的位字符串，您将没有

192
00:13:33,048 --> 00:13:35,280
比猜测和检查更好的方法了。

193
00:13:35,280 --> 00:13:39,496
再说一遍，如果您想了解进行 2 到 256

194
00:13:39,496 --> 00:13:43,905
次猜测 需要多少计算量，只需观看补充视频即可。

195
00:13:43,905 --> 00:13:47,573
事实上，我 写那件事太有趣了。

196
00:13:47,573 --> 00:13:50,867
您可能会认为，如果您真正深入了

197
00:13:50,867 --> 00:13:56,218
解该函数的工作原理，就可以对适当的输入进行逆向工程

198
00:13:56,218 --> 00:13:58,277
，而无需猜测和检查。

199
00:13:58,277 --> 00:14:01,440
但没有人找到一种方法来做到这一点。

200
00:14:01,440 --> 00:14:07,001
有趣的是，没有冷酷严格的证据表明反向计算是困难 的。

201
00:14:07,001 --> 00:14:12,085
然而，现代安全性在很大程度上取决于加密哈希函数以

202
00:14:12,085 --> 00:14:14,525
及它们具有此属性的想法。

203
00:14:14,525 --> 00:14:18,964
如果您要查看浏览器现在与 Y ouTube

204
00:14:18,964 --> 00:14:22,597
或银行建立的安全连接背后的算法是什

205
00:14:22,597 --> 00:14:27,440
么，您可能会看到 SHA256 名称出现在其中。

206
00:14:27,440 --> 00:14:33,187
目前，我们的重点只是这样的函数如何证明

207
00:14:33,187 --> 00:14:38,360
特定的交易列表与大量的计算工作相关。

208
00:14:38,360 --> 00:14:43,398
想象一下，有人向您展示了一个交易列表，他们说，嘿，我发现了一

209
00:14:43,398 --> 00:14:48,268
个特 殊的数字，这样当您将该数字放在该交易列表的末尾并将

210
00:14:48,268 --> 00:14:52,635
SHA25 6 应用于整个事物时，该输出的前 30

211
00:14:52,635 --> 00:14:53,474
位都是零。

212
00:14:53,474 --> 00:14:57,441
您认为他们 找到这个号码有多难？

213
00:14:57,441 --> 00:15:01,498
对于随机消息，散列恰好以 3 0

214
00:15:01,498 --> 00:15:08,181
个连续零开头的概率为 230 分之一，约为十亿分之 一。

215
00:15:08,181 --> 00:15:13,540
由于 SHA256 是一种加密哈希函数，因此找到此类特殊

216
00:15:13,540 --> 00:15:16,312
数字的唯一方法就是猜测和检查。

217
00:15:16,312 --> 00:15:19,603
因此，这个人几乎肯定必须检 查大约十

218
00:15:19,603 --> 00:15:23,077
亿个不同的数字才能找到这个特殊的数字。

219
00:15:23,077 --> 00:15:26,019
一旦你知 道了这个数字，验证起来就非常快了，

220
00:15:26,019 --> 00:15:28,961
你只需运行哈希值就可以看到 有 30 个零。

221
00:15:28,961 --> 00:15:32,745
换句话说，您可以验证他们是否进行

222
00:15:32,745 --> 00:15:37,420
了大量的工作，而无需您自己进行同样的努力。

223
00:15:37,420 --> 00:15:39,213
这称为工作量证明。

224
00:15:39,213 --> 00:15:44,223
重要的是，所有这些工作本质上都与交 易列表相关。

225
00:15:44,223 --> 00:15:48,083
如果你改变其中一笔交易，即使是轻微的改变，也

226
00:15:48,083 --> 00:15:49,594
会完全改变哈希值。

227
00:15:49,594 --> 00:15:53,698
因此，你必须进行另外十亿次猜测才能找到

228
00:15:53,698 --> 00:15:59,033
新的工作证明，一个新的数字，使列表的哈希值以 30

229
00:15:59,033 --> 00:16:00,264
个 零开头。

230
00:16:00,264 --> 00:16:04,000
现在回想一下我们的分布式账本情况。

231
00:16:04,000 --> 00:16:08,783
每个人都在那里广播交易，我们希望有一种方式让他们就

232
00:16:08,783 --> 00:16:10,622
正确的账本达成一致。

233
00:16:10,622 --> 00:16:14,240
正如我所说，原始比特币论文背后

234
00:16:14,240 --> 00:16:19,440
的核心思想是让每个人都信任投入最多工作的账本。

235
00:16:19,440 --> 00:16:24,467
其工作原理是首先将给定的分类帐组织成块，其中每个

236
00:16:24,467 --> 00:16:29,293
块由交易列表和工作证明（即一个特殊的数字）组成

237
00:16:29,293 --> 00:16:32,711
，以便整个块的哈希值以一堆零开头。

238
00:16:32,711 --> 00:16:37,069
目前，假设它必 须以 60 个零开始，但稍后我

239
00:16:37,069 --> 00:16:41,427
们将回到您可能想要选择 该数字的更系统的方式。

240
00:16:41,427 --> 00:16:45,813
就像交易仅在由发送者签名时 才被视为有效一样

241
00:16:45,813 --> 00:16:50,200
，区块也只有在具有工作证明时 才被视为有效。

242
00:16:50,200 --> 00:16:53,674
另外，为了确保这些块有一个标准

243
00:16:53,674 --> 00:16:59,537
顺序，我们将确保块必须在其标头包含前一个块的 哈希值。

244
00:16:59,537 --> 00:17:03,741
这样，如果您要返回并更改任何一个块，

245
00:17:03,741 --> 00:17:09,051
或者交换两个块的顺序，它将更改其后面的块，这会

246
00:17:09,051 --> 00:17:14,140
更改该块的哈希值，从而更改其后面的块， 等等。

247
00:17:14,140 --> 00:17:19,103
这需要重做所有工作，为每个块找到一个新的特殊数字，使

248
00:17:19,103 --> 00:17:21,677
其哈希值以 60 个零开头。

249
00:17:21,677 --> 00:17:25,797
因为区块是这样链接在一 起的，所以

250
00:17:25,797 --> 00:17:30,160
通常不称其为账本，而是称其为区块链。

251
00:17:30,160 --> 00:17:32,676
作为我们更新协议的一部分，我们现在

252
00:17:32,676 --> 00:17:35,340
将允许世界上的任何人成为区块创建者。

253
00:17:35,340 --> 00:17:39,866
这意味着他们将监听正在广播的交易，将它们收集到某个区

254
00:17:39,866 --> 00:17:44,225
块中，然后做大量工作来找到一个特殊的数字，使该区块

255
00:17:44,225 --> 00:17:46,573
的哈希值以 60 个零开头。

256
00:17:46,573 --> 00:17:50,289
一旦他们找到它，他们就会广播 出他们找到的区块。

257
00:17:50,289 --> 00:17:53,967
为了奖励区块创建者所做的所有这些工作，当她

258
00:17:53,967 --> 00:17:58,817
组装一个区块时，我们将允许她在其顶部包含一项非常特殊的交

259
00:17:58,817 --> 00:18:03,164
易，在该交易中，她会凭空获得 10 美元的账本美元。

260
00:18:03,164 --> 00:18:08,588
这称为 区块奖励，它是我们关于是否接受交易的通常规

261
00:18:08,588 --> 00:18:09,632
则的例外。

262
00:18:09,632 --> 00:18:13,780
它不是来自任何人，因此不必签名。

263
00:18:13,780 --> 00:18:19,197
这也意味着我们经济中的账本美元总数随着每个新区块的增加而增

264
00:18:19,197 --> 00:18:19,558
加。

265
00:18:19,558 --> 00:18:24,265
创建区块通常被称为挖矿，因为它需要做

266
00:18:24,265 --> 00:18:29,220
大量的工作，并且它将新的货币引入经济中。

267
00:18:29,220 --> 00:18:34,313
但是，当您听到或读到有关矿工的信息时，请记住，他们

268
00:18:34,313 --> 00:18:39,406
真正做的是监听交易、创建区块、广播这些区块，并因此

269
00:18:39,406 --> 00:18:41,169
获得新的资金奖励。

270
00:18:41,169 --> 00:18:44,474
从矿工的角度来看，每个区块都有点像

271
00:18:44,474 --> 00:18:49,432
一个微型彩票，每个人都在尽可能快地猜测数字，直到一个

272
00:18:49,432 --> 00:18:54,573
幸运的人找到一个特殊的数字，使该区块的哈希值以许多零开

273
00:18:54,573 --> 00:18:56,777
头，并且他们得到了报酬。

274
00:18:56,777 --> 00:19:01,127
对于其他只想使用该系统 进行支付的人来说

275
00:19:01,127 --> 00:19:05,478
，他们不再监听交易，而是开 始监听矿工广

276
00:19:05,478 --> 00:19:10,046
播的区块并更新他们自己的区块链个 人副本。

277
00:19:10,046 --> 00:19:14,096
现在，我们协议的关键补充是，如果您听到两

278
00:19:14,096 --> 00:19:19,304
个不同的区块链具有相互冲突的交易历史，那么您会遵循最

279
00:19:19,304 --> 00:19:22,775
长的一个，也就是投入最多工作的那个。

280
00:19:22,775 --> 00:19:28,800
如果有平局，只 需等待，直到听到额外的块，使其中一个更长。

281
00:19:28,800 --> 00:19:33,975
因此，即使没有中央权威，并且每个人都维护自己的

282
00:19:33,975 --> 00:19:38,935
区块链副本，如果每个人都同意优先考虑投入最多

283
00:19:38,935 --> 00:19:43,680
工作的区块链，我们就有办法达成去中心化共识。

284
00:19:43,680 --> 00:19:48,321
要了解为什么这会成为一个值得信赖的系统，并了解在什

285
00:19:48,321 --> 00:19:52,963
么时候您应该相信付款是合法的，了解如何欺骗使用该系

286
00:19:52,963 --> 00:19:54,748
统的人确实很有帮助。

287
00:19:54,748 --> 00:19:58,204
也许爱丽丝试图用一个欺诈性的区块来愚弄鲍

288
00:19:58,204 --> 00:20:02,482
勃，即她试图向他发送一个包含她向他支付 100 个

289
00:20:02,482 --> 00:20:06,760
Ledger 美元的区块，但没有将该区块广播到网络的

290
00:20:06,760 --> 00:20:07,583
其他部分。

291
00:20:07,583 --> 00:20:10,022
这样其他人仍然认为她拥 有那 100

292
00:20:10,022 --> 00:20:11,563
个 Ledger 美元。

293
00:20:11,563 --> 00:20:15,310
为此，她必须先于所有其他矿工 （每个人都

294
00:20:15,310 --> 00:20:19,058
在自己的区块上工作）找到有效的工作证明。

295
00:20:19,058 --> 00:20:24,317
这肯定 会发生，也许爱丽丝碰巧先于其他人赢得了这张微型

296
00:20:24,317 --> 00:20:24,880
彩票。

297
00:20:24,880 --> 00:20:29,548
但是鲍勃仍然会听到其他矿工发出的广播，因此为

298
00:20:29,548 --> 00:20:35,027
了让他相信这个欺诈性区块，爱丽丝必须自己完成所有工作

299
00:20:35,027 --> 00:20:40,303
，以继续在鲍勃区块链的这个特殊分叉上添加区块，这与

300
00:20:40,303 --> 00:20:42,942
他听到的不同来自其他矿工。

301
00:20:42,942 --> 00:20:48,216
请记住，根据协议，鲍勃始终 信任他所知道的最长的链。

302
00:20:48,216 --> 00:20:52,990
如果爱丽丝碰巧比网络上其他 矿工加起来更快地

303
00:20:52,990 --> 00:20:57,981
找到区块，她也许能够将这种情况保 持几个区块。

304
00:20:57,981 --> 00:21:02,014
但除非她拥有所有矿工中接近 50% 的

305
00:21:02,014 --> 00:21:07,458
计算资源，否则所有其他矿工正在处理的区块链的增长速度

306
00:21:07,458 --> 00:21:12,903
将超过 Alice 向 Bob 提供的单个欺诈性区块

307
00:21:12,903 --> 00:21:14,315
链的增长速度。

308
00:21:14,315 --> 00:21:17,842
因此，经过足够的时间后，鲍勃将拒绝他从

309
00:21:17,842 --> 00:21:22,955
爱丽丝那里听到的消息，转而支持其他人正在研究的更长的 链。

310
00:21:22,955 --> 00:21:29,061
请注意，这意味着您不必立即信任您立即听到的新块

311
00:21:29,061 --> 00:21:33,640
，而是应该等待在其之上添加几个新块。

312
00:21:33,640 --> 00:21:37,626
如果您还没有听 说过任何更长的区块链，您可以相

313
00:21:37,626 --> 00:21:41,785
信这个区块是其他人都在使用 的同一条链的一部分。

314
00:21:41,785 --> 00:21:46,040
至此，我们已经实现了所有主要想法。

315
00:21:46,040 --> 00:21:51,045
这种基于工作量证明的分布式账本系统或多或少是比特币协议

316
00:21:51,045 --> 00:21:53,906
以及许多其他加密货币的工作原理。

317
00:21:53,906 --> 00:21:55,896
只有一些细节需要澄清。

318
00:21:55,896 --> 00:22:00,242
之前我说过，工作量证明可能是找到一个特殊的数字，使得该块

319
00:22:00,242 --> 00:22:02,340
的哈希值以 60 个零开头。

320
00:22:02,340 --> 00:22:07,227
嗯，实际的比特币协议的工作 方式是定期更改零的数

321
00:22:07,227 --> 00:22:12,115
量，这样平均需要 10 分钟才 能找到新的区块。

322
00:22:12,115 --> 00:22:16,015
因此，随着越来越多的矿工加入网络，挑

323
00:22:16,015 --> 00:22:21,353
战变得越来越难，以至于这种微型彩票每 10 分钟大

324
00:22:21,353 --> 00:22:23,200
约只有一名中奖者。

325
00:22:23,200 --> 00:22:27,889
许多较新的加密货币的出块时间比这 短得多。

326
00:22:27,889 --> 00:22:32,468
比特币中的所有资金最终都来自于一些 区块奖励。

327
00:22:32,468 --> 00:22:35,923
最初，这些奖励是每个区块 50 比特币。

328
00:22:35,923 --> 00:22:38,844
实际上 有一个很棒的网站，名为 Block

329
00:22:38,844 --> 00:22:41,897
Explorer，可以轻 松浏览比特币区块链。

330
00:22:41,897 --> 00:22:46,051
如果你看一下链上的前几个区块，除了给矿 工的

331
00:22:46,051 --> 00:22:49,844
50 比特币奖励之外，它们不包含任何交易。

332
00:22:49,844 --> 00:22:53,799
但每 21 0,000 个区块（大约每

333
00:22:53,799 --> 00:22:56,568
4 年），奖励就会减少一半。

334
00:22:56,568 --> 00:23:00,115
所以现在的 奖励是12。每个区块 5 比特币。

335
00:23:00,115 --> 00:23:03,841
而且由于这种奖励随着时间的推移呈几何

336
00:23:03,841 --> 00:23:08,351
级数减少，这意味着比特币的存在量永远不会超过

337
00:23:08,351 --> 00:23:09,920
2100 万个。

338
00:23:09,920 --> 00:23:13,497
然而，这并不意味着矿工将停止赚钱。

339
00:23:13,497 --> 00:23:17,694
除了区块奖励之 外，矿工还可以获得交易费。

340
00:23:17,694 --> 00:23:23,107
其工作原理是，每当您进 行付款时，您完全可以选择包

341
00:23:23,107 --> 00:23:28,736
含交易费，该交易费将 支付给包含该付款的区块的矿工。

342
00:23:28,736 --> 00:23:32,328
您这样做的原因是 为了激励矿工将您

343
00:23:32,328 --> 00:23:36,132
广播的交易实际包含到下一个区块 中。

344
00:23:36,132 --> 00:23:41,307
你看，在比特币中，每个区块仅限于约 2400

345
00:23:41,307 --> 00:23:45,807
笔交易，许多批评者认为这是不必要的限制。

346
00:23:45,807 --> 00:23:50,209
相比之下，V isa 平均每秒处理约 1700

347
00:23:50,209 --> 00:23:55,162
笔交易，并且每秒能够处理超过 2 4,000 笔交易。

348
00:23:55,162 --> 00:23:59,503
比特币的处理速度相对较慢，导致交易

349
00:23:59,503 --> 00:24:06,497
费用更高，因为这决定了矿工选择将哪些交易包含在 新区块中。

350
00:24:06,497 --> 00:24:11,784
所有这些还远未全面覆盖加密 货币。

351
00:24:11,784 --> 00:24:16,325
还有许多我什至没有触及的细微差别和替代 设计选择。

352
00:24:16,325 --> 00:24:20,282
但我希望这能为那些希望通过进一步阅读添加更

353
00:24:20,282 --> 00:24:25,320
多分支的人提供一个稳定的、“等待但为什么”式的理解树干。

354
00:24:25,320 --> 00:24:29,312
正如我一开始所说，这背后的动机之一是大量资金开

355
00:24:29,312 --> 00:24:30,643
始流向加密货币。

356
00:24:30,643 --> 00:24:33,436
尽管我不想对这是一项好还是坏的

357
00:24:33,436 --> 00:24:37,625
投资做出任何断言，但我确实认为，对于进入游戏的

358
00:24:37,625 --> 00:24:41,640
人们来说，至少了解这项技术的基础知识是健康的。

359
00:24:41,640 --> 00:24:44,242
一如既往，我衷心感谢你们让这个频道在

360
00:24:44,242 --> 00:24:46,160
Patreon 上成为可能。

361
00:24:46,160 --> 00:24:50,672
我知道并不是每个人都有能力做出贡献，但如果您仍然有兴

362
00:24:50,672 --> 00:24:55,016
趣提供帮助，最好的方法之一就是分享您认为对其他人可

363
00:24:55,016 --> 00:24:56,855
能有趣或有帮助的视频。

364
00:24:56,855 --> 00:24:54,480
我知道你知道这一点，但这确实有帮助。

