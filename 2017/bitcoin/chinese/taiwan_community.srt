1
00:00:04,019 --> 00:00:06,860
「擁有」一枚比特幣究竟意味著什麼？

2
00:00:07,160 --> 00:00:09,480
很多人都聽說過比特幣

3
00:00:09,480 --> 00:00:12,680
它是一種數字貨幣，並不需要特定政府發行

4
00:00:12,680 --> 00:00:15,900
也不依賴銀行來管理帳戶及驗證交易

5
00:00:16,045 --> 00:00:18,875
甚至都沒有人真正知道其發明者

6
00:00:19,135 --> 00:00:22,175
很多人都不知道片頭提及的那個問題的答案

7
00:00:22,180 --> 00:00:23,480
至少不全然瞭解

8
00:00:24,140 --> 00:00:26,140
想要搞清楚，同時也為了讓

9
00:00:26,140 --> 00:00:29,880
比特幣背後的技術細節顯得直觀

10
00:00:29,880 --> 00:00:35,280
我們將從你會如何發明自己的比特幣來一步一步地說明

11
00:00:35,840 --> 00:00:40,040
首先我們從你用於記錄你與好友們交易的公共帳本開始

12
00:00:40,280 --> 00:00:44,780
然而你與好友及世界上的其他人的互信開始逐漸降低

13
00:00:44,900 --> 00:00:49,980
但聰明的你引入了密碼學中的某些概念來解決信任危機

14
00:00:50,200 --> 00:00:53,240
你就創造了一種新事物，叫做「加密貨幣」

15
00:00:53,440 --> 00:00:58,080
比特幣只是第一個被廣泛應用的加密貨幣的例子

16
00:00:58,260 --> 00:01:02,700
而如今已多了上千種加密貨幣在與傳統貨幣交易中

17
00:01:02,980 --> 00:01:05,060
從發明你自己的加密貨幣入手

18
00:01:05,060 --> 00:01:09,140
能幫助我們理解如今幾大主流加密貨幣的理論基礎

19
00:01:09,180 --> 00:01:13,480
瞭解其背後在不同方面設計上的取捨

20
00:01:13,940 --> 00:01:17,200
事實上我選這個主題是因為在過去一年中針對加密貨幣

21
00:01:17,200 --> 00:01:23,820
有大量的關注、資本投入甚至老實講還有媒體過分渲染

22
00:01:24,260 --> 00:01:28,000
我並不會對當前及未來的匯率發表評論及預測

23
00:01:28,000 --> 00:01:31,880
但我想任何想要購買加密貨幣的人都應

24
00:01:31,880 --> 00:01:33,580
搞清楚加密貨幣究竟是怎麼一回事

25
00:01:33,940 --> 00:01:37,940
我不會含糊地將其與挖礦作類比

26
00:01:38,040 --> 00:01:45,880
我會直接描述當我們發送、接受、創造加密貨幣時
電腦內部所發生的事情

27
00:01:46,520 --> 00:01:53,720
我還要強調一點：
雖然我們將花一些時間稍深入地瞭解背後的原理

28
00:01:54,140 --> 00:01:58,780
僅僅日常使用的話，我們並不需要瞭解其詳細技術原理

29
00:01:58,880 --> 00:02:03,220
就像你不需要瞭解刷信用卡時背後所發生的事一樣

30
00:02:03,580 --> 00:02:07,540
與電子支付一樣，加密貨幣也有很多方便易用的應用

31
00:02:07,660 --> 00:02:11,240
用於發送和接受貨幣而不需要知道背後是怎麼運作的

32
00:02:11,600 --> 00:02:17,220
差別在於加密貨幣的背後並不是某家銀行來驗證交易

33
00:02:17,220 --> 00:02:24,580
而是一套基於密碼學中某些數學方法、
去中心化、互不信任的交易驗證體系

34
00:02:25,620 --> 00:02:30,500
在開始講之前，你暫時把加密貨幣放在一邊

35
00:02:30,820 --> 00:02:35,720
我們先從更基本的概念入手：帳本和電子簽名。

36
00:02:36,240 --> 00:02:38,860
如果你和你的朋友們有很頻繁的金錢來往

37
00:02:38,865 --> 00:02:41,415
比如AA支付晚餐的帳單等等

38
00:02:41,415 --> 00:02:44,325
總是用現金很不方便

39
00:02:44,360 --> 00:02:46,480
所以可能你們可能會寫一個公共帳本

40
00:02:46,480 --> 00:02:50,440
來記錄某些未來將會發生的交易資訊

41
00:02:50,440 --> 00:02:54,900
如Alice支付Bob 20元，Bob支付Charlie 40元等等

42
00:02:55,340 --> 00:02:58,780
這個帳本必須是公開的，每個人都能查閱

43
00:02:58,900 --> 00:03:01,960
就像一個網站一樣，每個人都能查閱並添加新記錄

44
00:03:02,440 --> 00:03:07,880
而到了每個月底大家對交易記錄都無異議就會一起合計

45
00:03:08,260 --> 00:03:11,420
如果你花的比收到的多，就要向公家交錢

46
00:03:11,420 --> 00:03:14,560
如果你收到的比花的多，就可以從中取錢

47
00:03:15,080 --> 00:03:19,380
所以這個簡單體系的設計大概會是如下所述

48
00:03:19,840 --> 00:03:25,380
每個人都能向帳本添加交易資訊，到月底再統一結算

49
00:03:25,940 --> 00:03:30,780
但公共帳本存在一個問題，正因為每個人都能添加記錄

50
00:03:30,780 --> 00:03:37,300
應該怎樣避免Bob在沒有Alice核准的情況下偷偷記下：Alice給Bob 100元

51
00:03:37,660 --> 00:03:43,340
我們又憑什麼相信帳本中的記錄都準確無誤呢

52
00:03:44,500 --> 00:03:48,980
這裡就需要密碼學中的電子簽名技術

53
00:03:49,200 --> 00:03:55,540
就像手寫簽名一樣，Alice需能在交易資訊邊上留下記錄

54
00:03:55,540 --> 00:03:58,900
以證明她瞭解並且允許這筆交易發生

55
00:03:59,080 --> 00:04:03,460
而且這個簽名不能被他人獲取並偽造

56
00:04:04,140 --> 00:04:08,780
乍看之下電子簽名似乎不太可能實現

57
00:04:08,780 --> 00:04:14,120
無論電子簽名是如何儲存的，電腦讀取並複製即可

58
00:04:14,120 --> 00:04:16,600
那究竟該如何防止偽造呢

59
00:04:17,120 --> 00:04:21,920
要實現電子簽名，每個人都需要生成
一對公共密鑰及私人密鑰

60
00:04:22,120 --> 00:04:24,100
每一個密鑰都是一串位元

61
00:04:24,500 --> 00:04:29,160
私人密鑰有時也被叫做「秘密」鑰匙以便能夠縮寫成sk

62
00:04:29,300 --> 00:04:31,500
公共密鑰則縮寫成pk

63
00:04:32,100 --> 00:04:36,400
正如其名，私人密鑰是由你自己保存的

64
00:04:37,020 --> 00:04:42,200
現實生活中，你所簽署的所有文件中的簽名都是一致的

65
00:04:42,200 --> 00:04:47,220
電子簽名則更強一些，它會隨著簽署的內容而變化

66
00:04:47,580 --> 00:04:53,180
它看上去就是一串1和0，通常長度是256位

67
00:04:53,340 --> 00:04:59,760
而內容的輕微變動都會讓這串數字看上去完全不同

68
00:05:00,640 --> 00:05:05,480
正式一點地講，產生這樣的簽名需要一個函數

69
00:05:05,560 --> 00:05:08,600
以簽署的內容以及你的私人密鑰作爲參數

70
00:05:09,060 --> 00:05:12,480
私人密鑰確保了只有你本人能產生這個電子簽名

71
00:05:12,625 --> 00:05:15,265
這個簽名還取決於簽署的內容

72
00:05:15,265 --> 00:05:19,920
就意味著其他人不能簡單地複製這個簽名
並在其他內容上偽造另一個簽名

73
00:05:20,820 --> 00:05:25,640
與此同時還有一個驗證函數用於驗證簽名是否真實

74
00:05:25,960 --> 00:05:28,200
而這個函數還需要公共密鑰

75
00:05:28,860 --> 00:05:37,980
它的作用是告訴我們這個簽名是否是由一個私鑰加密
並有一個與之配對的公鑰用於驗證

76
00:05:38,400 --> 00:05:41,960
這裡並不會具體討論這些函數具體如何實現

77
00:05:41,960 --> 00:05:49,260
它保證了如果你不知道私鑰，
你幾乎不可能找到一個正確的簽名

78
00:05:49,740 --> 00:05:54,600
更準確地講，並不會有比隨機猜測簽名

79
00:05:54,900 --> 00:05:58,180
然後用大家都知道的公鑰反覆驗證更好的方法了

80
00:05:58,760 --> 00:06:03,360
現在想想256位元到底有多少可能的簽名

81
00:06:03,760 --> 00:06:06,580
總共有2的256次方個可能的簽名

82
00:06:07,160 --> 00:06:09,600
這是一個天文數字

83
00:06:09,820 --> 00:06:13,980
稱其為天文數字實際上又遠遠高估了天文學的範疇

84
00:06:13,980 --> 00:06:19,780
我還做了另一個補充影片來演示這個數字究竟有多大

85
00:06:20,280 --> 00:06:25,460
現在假設你驗證了一個簽名是真的

86
00:06:26,020 --> 00:06:28,320
你就能相當有把握地認為

87
00:06:28,320 --> 00:06:32,080
這個簽名只能由他本人持有的私鑰加密產生

88
00:06:32,200 --> 00:06:35,300
以及與這個私鑰配對的公鑰驗證

89
00:06:36,720 --> 00:06:40,620
現在確保了每個人都會在交易資訊後面簽名

90
00:06:40,620 --> 00:06:42,755
但仍然存在另一個問題

91
00:06:42,760 --> 00:06:46,540
比如Alice簽署了一條Alice支付Bob 100元的交易記錄

92
00:06:46,540 --> 00:06:50,540
即便Bob不能在Alice的新交易記錄上偽造簽名

93
00:06:50,640 --> 00:06:54,180
他可以乾脆把這整條記錄隨心所欲地複製好幾遍

94
00:06:54,180 --> 00:06:57,180
因爲這些記錄以及它對應的簽名都是正確的

95
00:06:57,680 --> 00:07:01,640
要解決這個問題，你在簽署新的交易資訊時

96
00:07:01,760 --> 00:07:07,240
交易資訊還必須包含一個唯一的編號與之對應

97
00:07:07,660 --> 00:07:11,500
那樣如果Alice多次支付Bob 100元的話

98
00:07:11,680 --> 00:07:15,880
帳本上的每條記錄都會要求一個新的簽名

99
00:07:16,740 --> 00:07:22,060
有了電子簽名就完美地解決了原本體系中的信任危機

100
00:07:22,300 --> 00:07:27,420
但要真正實現，仍然需要依賴一個類似的信用機構

101
00:07:27,540 --> 00:07:32,900
也就是說你信任每個人到了月底都會出現並用現金結算

102
00:07:33,300 --> 00:07:39,400
萬一Charlie欠了很多錢但就是不出來還錢該怎麼辦

103
00:07:39,940 --> 00:07:47,160
而再次使用現金的唯一原因就是有人欠了錢不還

104
00:07:47,720 --> 00:07:52,220
聰明的你想到了一個方法就不需要真正再用現金結算

105
00:07:52,300 --> 00:07:56,580
只要能夠避免其中有些人的所得不足以支付其支出

106
00:07:57,240 --> 00:08:01,320
所有人開始就往帳上支付100元，

107
00:08:01,500 --> 00:08:03,940
帳本上最先記錄幾條：

108
00:08:04,080 --> 00:08:08,300
Alice獲得100元，Bob獲得100元，Charlie等等

109
00:08:08,980 --> 00:08:16,040
現在只需要拒絕在帳本上記錄某些人入不敷出的交易

110
00:08:16,900 --> 00:08:20,095
舉個例子，如果前兩條交易記錄是

111
00:08:20,100 --> 00:08:22,140
Charlie支付Alice 50元，

112
00:08:22,140 --> 00:08:24,420
Charlie支付Bob 50元

113
00:08:24,420 --> 00:08:28,120
如果他想記錄Charlie支付你20元，

114
00:08:28,280 --> 00:08:32,260
那將是無效的，和他沒有簽名一樣

115
00:08:32,840 --> 00:08:35,700
因此這就意味著驗證一條交易

116
00:08:35,700 --> 00:08:39,460
就需要瞭解截至當前所有的歷史交易資訊

117
00:08:40,039 --> 00:08:46,500
這在加密貨幣中同樣如此，雖然仍有待優化

118
00:08:48,440 --> 00:08:55,480
有趣的是，這個設計真正去掉了帳本和真實貨幣的連結

119
00:08:56,260 --> 00:08:59,360
理論上如果世界上所有人都是用這個帳本

120
00:08:59,580 --> 00:09:03,640
你可以終其一生都在這個帳本上收付款

121
00:09:03,640 --> 00:09:06,600
根本不需用到真實的貨幣

122
00:09:07,320 --> 00:09:14,160
為了強調這一點，我們把帳本上的貨幣單位稱之為帳元，並簡稱為LD

123
00:09:14,740 --> 00:09:18,780
你當然也可以將帳元自由地兌換成真的美元

124
00:09:18,780 --> 00:09:22,600
舉個例子，Alice在現實中給了Bob 100元

125
00:09:22,600 --> 00:09:29,740
同時Bob在公共帳本上記上Bob支付Alice 100元

126
00:09:30,660 --> 00:09:34,440
但這樣的兌換並不在這套系統的設計初衷之內

127
00:09:34,760 --> 00:09:40,580
這樣的兌換與美元和歐元或市場上其他的貨幣兌換類似

128
00:09:41,160 --> 00:09:43,940
但那就是題外話了

129
00:09:44,460 --> 00:09:50,020
這是理解比特幣和其他加密貨幣的最重要的資訊了

130
00:09:50,540 --> 00:09:52,840
它實際上就是一個帳本

131
00:09:53,080 --> 00:09:56,260
所有的歷史交易總和就是當下的貨幣

132
00:09:57,000 --> 00:09:58,420
當然就比特幣而言

133
00:09:58,420 --> 00:10:01,800
用現金購買比特幣不會在帳本上記錄

134
00:10:01,800 --> 00:10:05,120
新的比特幣如何產生我待會再細說

135
00:10:05,440 --> 00:10:12,480
但在此之前，我們的LD體系和當前加密貨幣還有一大不同

136
00:10:12,860 --> 00:10:15,860
我剛提到這個公共帳本存在於某個公共地點

137
00:10:15,940 --> 00:10:18,640
比如一個網站，所有人都能登入並添加記錄

138
00:10:19,180 --> 00:10:21,975
那樣的話我們就必須信任這一中心機構

139
00:10:21,980 --> 00:10:26,800
那究竟誰來管理這個網站，誰來控制添加記錄的規則呢

140
00:10:27,540 --> 00:10:32,220
讓所有人都能獲取這份帳本也就不需要信任中心機構了

141
00:10:32,760 --> 00:10:36,960
當產生交易，如「Alice支付Bob 100元」

142
00:10:37,060 --> 00:10:40,900
你就將這個訊息廣播給網絡中所有的人

143
00:10:40,900 --> 00:10:43,680
他人收到了這個訊息都在自己那份帳本上記下這條交易

144
00:10:44,700 --> 00:10:49,440
但是除非有更多相應的措施，這樣的設計相當糟糕

145
00:10:49,680 --> 00:10:52,860
你要如何確保所有人手裡都是正確的那份帳本呢

146
00:10:53,300 --> 00:10:57,180
當Bob收到了如「Alice支付Bob10帳元」的交易，

147
00:10:57,560 --> 00:11:01,840
他如何確保其他人也都同樣收到並且相信這個訊息

148
00:11:02,220 --> 00:11:07,460
讓他在今後可以用這10帳元支付給Charlie做交易？

149
00:11:08,300 --> 00:11:12,300
試著想想是你自己收聽著來自外界的交易資訊廣播

150
00:11:12,860 --> 00:11:18,380
你怎麼確定其他人和你一樣以相同的順序記錄著相同的交易資訊

151
00:11:19,320 --> 00:11:23,060
這才是關鍵所在，也是一個有趣的難題

152
00:11:23,460 --> 00:11:27,640
你能想出一個規則來決定接受或拒絕收到的交易資訊

153
00:11:27,660 --> 00:11:30,900
同時確信其他人在這個規則下

154
00:11:30,900 --> 00:11:34,300
都能以同樣的順序接受交易資訊

155
00:11:34,860 --> 00:11:37,780
並最終形成同樣的一份個人帳本嗎？

156
00:11:38,480 --> 00:11:41,640
這就是比特幣原始論文處理的問題

157
00:11:44,220 --> 00:11:47,315
簡單地講，比特幣的解決辦法是

158
00:11:47,320 --> 00:11:51,960
選擇信任消耗最多計算資源的那份帳本

159
00:11:52,480 --> 00:11:54,980
我會花一些時間解釋這到底代表什麼意思

160
00:11:55,120 --> 00:11:58,200
它涉及「加密雜湊函數」這個概念

161
00:11:58,460 --> 00:12:00,260
基本的思路如下：

162
00:12:00,460 --> 00:12:04,600
如果你要將計算資源的消耗作為你信任的基礎，

163
00:12:05,000 --> 00:12:08,440
那麼偽造交易記錄

164
00:12:08,620 --> 00:12:12,220
將需要不可能達到的計算能力才可行。

165
00:12:12,780 --> 00:12:15,915
再提醒大家一次，這裡我們將會繼續深入討論

166
00:12:15,920 --> 00:12:19,920
大多數僅僅只是使用比特幣的用戶並不需瞭解

167
00:12:19,920 --> 00:12:21,355
但這個想法實在是太酷了！

168
00:12:21,480 --> 00:12:27,040
如果你懂了，你就會理解比特幣和其他加密貨幣的核心

169
00:12:27,680 --> 00:12:30,680
那麼首先，什麼是雜湊函數？

170
00:12:30,680 --> 00:12:35,320
這些函數的輸入可以是任何資訊或文件

171
00:12:35,740 --> 00:12:40,440
它們會輸出一個固定長度的比特字符串，如256位

172
00:12:41,420 --> 00:12:44,820
這個輸出值叫做這個資訊的雜湊值，或者稱其為「指紋」

173
00:12:45,160 --> 00:12:48,100
它被設計成看似隨機的亂數

174
00:12:48,200 --> 00:12:51,760
但它並非隨機的，對給定的資訊總是輸出相同的數

175
00:12:52,200 --> 00:12:55,100
但如果你將輸入稍作修改，

176
00:12:55,440 --> 00:12:57,640
也許僅僅只是修改了其中一個字母，

177
00:12:57,640 --> 00:13:00,580
最終的雜湊值會變得完全不一樣

178
00:13:01,080 --> 00:13:05,500
事實上，我這裡做演示的雜湊函數叫做「SHA256」

179
00:13:05,860 --> 00:13:11,940
輸入的輕微修改，輸出就會完全不同，毫無規律可言

180
00:13:12,260 --> 00:13:15,060
明白了吧，這不是普通的雜湊函數，

181
00:13:15,060 --> 00:13:17,200
這是加密雜湊函數

182
00:13:17,360 --> 00:13:20,900
這就意味著逆向計算是不可能的

183
00:13:21,180 --> 00:13:24,400
如果告訴你一個1和0的字符串然後問你

184
00:13:24,400 --> 00:13:31,100
什麼輸入經過SHA256函數計算後會得到同樣的字符串

185
00:13:31,580 --> 00:13:34,700
沒有比一個一個嘗試更好的辦法了

186
00:13:35,480 --> 00:13:42,100
如果你想感受一下2的256次方個嘗試究竟需要計算多久

187
00:13:42,340 --> 00:13:43,760
可以看看這個補充影片

188
00:13:44,160 --> 00:13:46,600
我其實做那部影片做的很開心

189
00:13:48,640 --> 00:13:53,540
你可能會想如果知道了這個函數的運作細節

190
00:13:53,840 --> 00:13:57,780
是不是就可以不用瞎猜而可以倒過來推算出這個輸入呢

191
00:13:57,980 --> 00:14:00,960
但目前沒有人可以做到

192
00:14:01,240 --> 00:14:07,100
有趣的是，目前還沒有嚴格的證明逆向計算是困難的

193
00:14:07,420 --> 00:14:10,600
目前大量的安全行業和加密需求都取決於

194
00:14:10,600 --> 00:14:14,360
加密雜湊函數以及它的這個性質

195
00:14:14,740 --> 00:14:17,820
如果你看瀏覽器和YouTube建立的加密連接

196
00:14:17,820 --> 00:14:20,580
或連上銀行網站時

197
00:14:20,580 --> 00:14:22,500
它背後的加密演算法

198
00:14:22,500 --> 00:14:26,060
你很可能會看到「SHA256演算法」

199
00:14:27,100 --> 00:14:29,560
但現在，我們的關注點會是

200
00:14:29,560 --> 00:14:33,460
如何證明這樣的函數代表一個帳單

201
00:14:33,480 --> 00:14:36,760
需要非常大量的計算資源

202
00:14:37,720 --> 00:14:40,735
想想如果有人給你一份交易記錄並說

203
00:14:40,740 --> 00:14:43,240
「嘿！我發現了一個特殊的數字

204
00:14:43,240 --> 00:14:46,600
你把這個數字放在這份交易記錄後面

205
00:14:46,700 --> 00:14:49,800
整體資訊進行SHA256函數計算後

206
00:14:49,805 --> 00:14:53,195
前面30個數字都會是0！」

207
00:14:53,760 --> 00:14:57,020
你想想找到這樣的一個數字有多難？

208
00:14:58,060 --> 00:14:59,200
對於一個隨機的訊息，

209
00:14:59,360 --> 00:15:05,580
其雜湊值前30位都是0的機率是2的30次方分之一

210
00:15:05,580 --> 00:15:07,420
差不多是十億分之一

211
00:15:07,860 --> 00:15:11,740
而且因為SHA256是一個加密雜湊函數

212
00:15:11,960 --> 00:15:16,080
找到這個特殊數字的唯一方法只能是窮舉驗證

213
00:15:16,640 --> 00:15:20,880
所以剛才那個人基本上已經嘗試了十億次

214
00:15:20,880 --> 00:15:22,520
才找到了這個特別數字

215
00:15:23,040 --> 00:15:24,800
而你知道了這個數字，

216
00:15:24,800 --> 00:15:28,820
很快計算一下雜湊值發現開頭確實是30個0

217
00:15:29,500 --> 00:15:33,620
換言之，你能很快地驗證他們確實經過了大量的計算

218
00:15:33,880 --> 00:15:36,520
而你不需要親自付出這麼多重複勞動。

219
00:15:37,040 --> 00:15:39,320
這叫做「工作量證明」

220
00:15:39,320 --> 00:15:44,320
重要的是，這個工作量證明和這份交易記錄緊密相關

221
00:15:44,880 --> 00:15:47,740
如果你更改了其中一條交易資訊，即便是輕微的改動

222
00:15:48,080 --> 00:15:49,860
也會完全改變最終的雜湊值

223
00:15:49,860 --> 00:15:54,000
所以就又需要經過十億次嘗試才能找到新的工作量證明

224
00:15:54,180 --> 00:15:55,180
找到一個新的那個特別數字

225
00:15:55,180 --> 00:16:00,520
讓和它對應的交易記錄的雜湊值會以30個0開頭

226
00:16:01,240 --> 00:16:04,300
現在回過頭來考慮我們的分散式帳本的情形：

227
00:16:04,380 --> 00:16:07,100
每個人都在廣播交易資訊，

228
00:16:07,100 --> 00:16:10,820
我們想找到一個方法能讓所有人都確認一份正確的帳單

229
00:16:11,340 --> 00:16:14,700
我前面說過比特幣原始論文的核心點就是

230
00:16:14,700 --> 00:16:18,780
每個人都信任需要最多計算能力的那份帳單

231
00:16:19,100 --> 00:16:22,780
要實現這個想法首先需要將帳單整理成區塊

232
00:16:22,800 --> 00:16:27,240
這些區塊包含了一系列交易資訊以及其工作量證明

233
00:16:27,760 --> 00:16:32,280
也就是說有一個特別的數字滿足其雜湊值以一系列0開頭

234
00:16:32,920 --> 00:16:37,020
我們暫時先定60個0開頭吧，

235
00:16:37,020 --> 00:16:41,100
待會我們再來看如何系統地決定這些0的個數

236
00:16:41,560 --> 00:16:46,560
就像交易資訊要經過發送方簽名才被認定為有效

237
00:16:46,760 --> 00:16:50,000
一個區塊只有當它有工作量證明時才被認定為有效

238
00:16:50,720 --> 00:16:54,380
而且為了確保這些區塊有一定的順序

239
00:16:54,380 --> 00:16:59,540
我們規定前一區塊的雜湊值必須加到當前區塊的頭部資訊中

240
00:17:00,040 --> 00:17:03,200
這樣的話，如果你回頭想改變其中某個區塊的內容

241
00:17:03,200 --> 00:17:05,579
或交換兩個區塊的順序

242
00:17:05,579 --> 00:17:08,139
你就會改變它後一個區塊的內容

243
00:17:08,140 --> 00:17:09,900
也就改變了那個區塊的雜湊值

244
00:17:09,900 --> 00:17:12,940
然後又影響到再下一個區塊

245
00:17:13,740 --> 00:17:16,319
那將會需要重新計算所有這些區塊的雜湊值，

246
00:17:16,319 --> 00:17:21,499
重新尋找每個特別數字使得區塊的雜湊值以60個0開頭

247
00:17:22,099 --> 00:17:24,939
因為區塊以這種方式相互鏈接

248
00:17:24,940 --> 00:17:28,840
與其稱其為帳本，不如稱其為「區塊鏈」

249
00:17:29,740 --> 00:17:31,820
在這個新的體系之下，

250
00:17:31,820 --> 00:17:34,680
我們現在允許世界上的每個人都能成為區塊的建立者

251
00:17:35,100 --> 00:17:38,680
意思是說他們都將收聽網絡中的交易資訊，

252
00:17:38,680 --> 00:17:40,335
整理這些資訊生成區塊，

253
00:17:40,340 --> 00:17:42,900
然後花大量的計算能力

254
00:17:42,900 --> 00:17:46,480
尋找特別數字使得區塊的雜湊值以60個0開頭

255
00:17:46,920 --> 00:17:49,840
一旦找到了這個數字，他們就將這個區塊廣播出去

256
00:17:50,700 --> 00:17:53,380
為了獎勵這個區塊建立者的工作付出，

257
00:17:53,380 --> 00:17:55,140
當她建立了一個區塊，

258
00:17:55,140 --> 00:17:59,100
我們規定她可以把一筆特別的交易資訊放在帳單開頭，

259
00:17:59,100 --> 00:18:01,740
例如：她獲得10帳元。

260
00:18:03,320 --> 00:18:04,920
這叫做「區塊獎勵」，

261
00:18:04,920 --> 00:18:09,620
這是我們接受或拒絕交易資訊規則的一個例外情況

262
00:18:09,780 --> 00:18:12,940
它並不來自於其他人，所以也並不需要簽名。

263
00:18:13,560 --> 00:18:19,860
也意味著整個網絡中的帳元會隨著新區塊的產生而增加

264
00:18:20,600 --> 00:18:23,240
建立區塊通常叫做「挖礦」，

265
00:18:23,240 --> 00:18:25,200
因為它會需要大量的計算力

266
00:18:25,200 --> 00:18:28,480
挖礦會為整個經濟中引入新的貨幣量

267
00:18:28,780 --> 00:18:31,360
所以當你聽到或看到礦工時

268
00:18:31,360 --> 00:18:33,700
你現在明白他們所做的其實就是

269
00:18:33,700 --> 00:18:40,580
收聽交易資訊，建立區塊，廣播區塊
並獲得新貨幣的獎勵

270
00:18:41,720 --> 00:18:45,900
而在礦工眼中，每個區塊就像是一個小型的彩票，

271
00:18:45,900 --> 00:18:48,880
每個人都想盡可能快得猜數字

272
00:18:48,940 --> 00:18:52,580
直到其中有一個幸運兒找到了那個特別數字

273
00:18:52,580 --> 00:18:56,240
能讓區塊的雜湊值以很多0開頭，然後他們就得到獎勵

274
00:18:57,760 --> 00:19:00,980
而對於其他只是想利用這個系統做交易的人而言，

275
00:19:00,980 --> 00:19:03,460
並不需要收聽交易記錄，

276
00:19:03,460 --> 00:19:06,760
他們只需要收聽被礦工廣播的區塊即可，

277
00:19:06,920 --> 00:19:09,920
然後更新自己的那一份區塊鏈

278
00:19:10,200 --> 00:19:13,000
現在我們新體系的關鍵點來了

279
00:19:13,000 --> 00:19:17,760
如果我們收到了兩份完全不同的區塊鏈，

280
00:19:18,200 --> 00:19:22,300
我們傾向於選擇最長的那一個，也就是需要最多的工作量的那一份。

281
00:19:22,600 --> 00:19:26,220
如果暫時難分上下，等待下一個區塊的廣播，

282
00:19:26,220 --> 00:19:28,120
總有一個會形成更長的區塊鏈

283
00:19:28,420 --> 00:19:30,760
所以即便沒有中心機構，

284
00:19:31,000 --> 00:19:33,980
所有人也都自己維護自己的那份區塊鏈

285
00:19:34,220 --> 00:19:39,300
但如果每個人都信任最多工作量的那個區塊鏈，

286
00:19:39,300 --> 00:19:42,900
我們就達到了一個去中心化的共識。

287
00:19:43,560 --> 00:19:45,780
爲了理解爲什麼這樣能夠建立一個可信的系統

288
00:19:45,780 --> 00:19:49,080
和這個系統裡的交易到底有多可信，

289
00:19:49,420 --> 00:19:54,780
我們嘗試看看在這個系統中偽造資訊欺騙他人到底有多難

290
00:19:55,420 --> 00:19:58,760
也許Alice想要用一個偽造的區塊欺騙Bob

291
00:19:58,760 --> 00:20:04,020
也就是說她給Bob一個區塊包含她支付Bob 100帳元的資訊

292
00:20:04,240 --> 00:20:07,020
但她沒有把這個區塊廣播給網絡中的其他人

293
00:20:07,320 --> 00:20:11,320
那樣的話，其他人會認爲她仍然持有那100帳元

294
00:20:12,000 --> 00:20:17,100
她要比其他所有礦工先找到工作量證明才能欺騙所有人

295
00:20:17,100 --> 00:20:18,780
他們都在獨立計算區塊

296
00:20:19,100 --> 00:20:20,740
而這確實是有可能發生的！

297
00:20:21,000 --> 00:20:25,040
有可能Alice剛好比其他所有人都先找到了這個證明

298
00:20:25,380 --> 00:20:29,480
但Bob也還會收到來自其他礦工的區塊廣播

299
00:20:30,060 --> 00:20:32,400
所以為了讓他相信她那份偽造的區塊，

300
00:20:32,400 --> 00:20:35,340
Alice後面都要重新計算

301
00:20:35,340 --> 00:20:38,980
她那份偽造給Bob的區塊後面的所有區塊

302
00:20:39,240 --> 00:20:42,400
這些區塊和Bob收到了來自其他礦工的區塊都不同

303
00:20:42,400 --> 00:20:48,320
但系統規定Bob總是信任他所指的最長的那一個區塊鏈

304
00:20:48,940 --> 00:20:52,020
Alice在前幾個區塊還有可能保持領先

305
00:20:52,020 --> 00:20:57,780
如果剛好碰巧她比其他所有礦工都先找到那個區塊

306
00:20:58,280 --> 00:21:03,600
但除非她擁有接近所有礦工的計算資源的50%

307
00:21:03,980 --> 00:21:06,240
不然更可能發生的是

308
00:21:06,240 --> 00:21:09,420
所以其他礦工計算的區塊

309
00:21:09,600 --> 00:21:13,640
會比Alice偽造給Bob的區塊形成的區塊鏈更長更快

310
00:21:14,900 --> 00:21:19,580
所以經過足夠長的時間，Bob會放棄他收到的來自Alice的區塊鏈

311
00:21:19,660 --> 00:21:22,900
而選擇其他所有人都在計算的那一份區塊鏈

312
00:21:23,700 --> 00:21:29,320
所以你一開始並不會立即信任收聽到的新區塊

313
00:21:29,320 --> 00:21:33,500
而要等到後面有新的區塊添加

314
00:21:33,500 --> 00:21:36,400
如果沒收聽到更長的區塊鏈，

315
00:21:36,400 --> 00:21:41,020
你就能信任這個區塊和其他人的區塊鏈是一致的

316
00:21:42,040 --> 00:21:45,420
到此，我們講解了所有主要內容

317
00:21:45,800 --> 00:21:48,680
這個基於工作量證明的分散式帳本系統

318
00:21:49,040 --> 00:21:53,920
多多少少和比特幣還有其他加密貨幣運作原理一樣

319
00:21:54,240 --> 00:21:56,020
只剩一些細節要解釋

320
00:21:56,020 --> 00:21:59,520
剛剛我講到工作量證明是尋找那一個特別數字

321
00:21:59,520 --> 00:22:02,900
滿足其區塊的雜湊值以60個0開頭

322
00:22:03,100 --> 00:22:08,160
而現實的比特幣體系中這些0的長度規律地變化

323
00:22:08,160 --> 00:22:12,100
以保證平均每10分鐘產生一個新的區塊

324
00:22:12,460 --> 00:22:15,715
所以當有越來越多的礦工加入其中

325
00:22:15,720 --> 00:22:22,840
計算也變得越來越難，來維持這個「樂透」大約每10分鐘只有一個人中獎

326
00:22:23,640 --> 00:22:27,500
很多新的加密貨幣有更短的區塊時間

327
00:22:28,360 --> 00:22:32,720
比特幣體系中所有的比特幣最初都來自於生成新區塊的獎勵

328
00:22:32,720 --> 00:22:35,780
在一開始，是每區塊50個比特幣

329
00:22:35,980 --> 00:22:39,160
還有一個叫做「Block Explorer」的網站你可以去看看

330
00:22:39,160 --> 00:22:41,800
上面能輕鬆地看到比特幣區塊鏈中的資訊

331
00:22:41,800 --> 00:22:44,800
如果你看區塊鏈最開始的那幾個區塊

332
00:22:44,800 --> 00:22:49,460
它們除了獎勵給礦工的50個比特幣之外並沒有其他交易

333
00:22:49,840 --> 00:22:54,220
但每過210000個區塊，差不多每4年，

334
00:22:54,580 --> 00:22:56,780
區塊獎勵就會減半

335
00:22:56,780 --> 00:23:00,260
現在，每個區塊的獎勵是12.5個比特幣

336
00:23:00,520 --> 00:23:04,420
也因為這個獎勵隨著時間等比減少

337
00:23:04,420 --> 00:23:09,520
也就意味著最終可獲取的比特幣不會超過21000000

338
00:23:10,180 --> 00:23:13,380
但這並不是說礦工最終不能再賺錢

339
00:23:13,640 --> 00:23:18,160
除了區塊獎勵外，礦工還可以獲得交易費

340
00:23:18,160 --> 00:23:24,540
每當你支付時，你可選擇一小筆交易費一起支付

341
00:23:25,040 --> 00:23:28,600
這筆交易費最終會給包含這筆記錄的區塊建立者

342
00:23:29,000 --> 00:23:31,985
你這麼做能夠激勵礦工們

343
00:23:31,985 --> 00:23:35,960
在下個區塊中包含你這筆交易資訊

344
00:23:35,960 --> 00:23:41,660
在比特幣中，每個區塊包含約2400筆交易記錄

345
00:23:41,660 --> 00:23:45,420
很多批判家認為這個限制過於嚴格

346
00:23:45,820 --> 00:23:51,360
與VISA比較，VISA每秒平均處理約1700筆交易

347
00:23:51,360 --> 00:23:55,460
每秒最多能處理24000筆交易

348
00:23:56,220 --> 00:24:01,200
相比而言比特幣較慢的交易速度使得它的交易費用更高

349
00:24:01,320 --> 00:24:06,360
因爲正是交易費用讓礦工更傾向將其交易記錄在新的區塊中

350
00:24:07,900 --> 00:24:11,880
以上這些絕非完整的加密貨幣知識

351
00:24:12,160 --> 00:24:16,200
還有其他許多細微差異和加密貨幣的系統設計尚未涉及

352
00:24:16,420 --> 00:24:21,360
我希望這個影片能夠讓大家有個紮實的基礎知識

353
00:24:21,360 --> 00:24:24,500
之後能自行閱讀再學習新觀念

354
00:24:25,080 --> 00:24:26,100
正如我開頭所說，

355
00:24:26,100 --> 00:24:30,960
我做此影片的初衷是目前有大量的資金湧入加密貨幣中

356
00:24:31,260 --> 00:24:34,960
是好是壞我並不過多評價

357
00:24:35,140 --> 00:24:38,140
但我認為想要進入這一領域的人

358
00:24:38,140 --> 00:24:40,700
如果能至少懂一些基本技術背景是有所裨益的

359
00:24:41,520 --> 00:24:45,600
最後，我衷心感謝在Patreon支持這個頻道的你們

360
00:24:46,120 --> 00:24:49,255
我理解並不是每個人都能支持到這個地步

361
00:24:49,260 --> 00:24:51,220
但你如果仍想支持我

362
00:24:51,300 --> 00:24:53,540
最好的方式之一就是

363
00:24:53,540 --> 00:24:56,600
將這個影片分享給你認為對此感興趣或對其有益的人

