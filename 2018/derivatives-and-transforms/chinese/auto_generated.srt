1
00:00:07,739 --> 00:00:11,763
未来的几个月里，你将面临大量的艰苦工作，一些简洁的 

2
00:00:11,763 --> 00:00:15,632
例子，一些不太简洁的例子，与物理的美妙联系，需要 

3
00:00:15,632 --> 00:00:19,656
记住的一堆不那么漂亮的公式，大量的卡住和敲打的时刻 

4
00:00:19,656 --> 00:00:23,525
当你把头撞到墙上时，也会有一些美好的顿悟时刻，还 

5
00:00:23,525 --> 00:00:27,240
有一些真正可爱的图形直觉来帮助指导你完成这一切。

6
00:00:27,630 --> 00:00:31,606
但是，如果您面前的课程类似于我的第一门微积分入门 

7
00:00:31,606 --> 00:00:35,582
课程，或者是我多年来见过的第一门课程，那么有一个 

8
00:00:35,582 --> 00:00:39,400
主题您不会看到，但我相信它会极大地加速您的学习。

9
00:00:40,280 --> 00:00:44,620
你看，第一年几乎所有的视觉直觉都是基于图表的。

10
00:00:45,080 --> 00:00:49,660
导数是图的斜率，积分是该图下方的某个区域。

11
00:00:50,200 --> 00:00:54,266
但是，当您将微积分推广到输入和输出只是数字的函数之 

12
00:00:54,266 --> 00:00:58,020
外时，并不总是能够绘制出您正在分析的函数的图表。

13
00:01:00,680 --> 00:01:04,991
因此，如果你对基本思想（如导数）的所有直觉都过于 

14
00:01:04,991 --> 00:01:09,302
严格地植根于图表，那么它可能会在你和更多引用不引 

15
00:01:09,302 --> 00:01:13,613
用的高级主题（如多变量微积分和复杂分析）之间造成 

16
00:01:13,613 --> 00:01:17,580
一个非常高且基本上不必要的概念障碍，微分几何。

17
00:01:18,840 --> 00:01:22,504
我想与您分享的是一种思考导数的方法， 

18
00:01:22,504 --> 00:01:26,168
我将其称为转换视图，它可以更无缝地推 

19
00:01:26,168 --> 00:01:29,640
广到微积分出现的一些更一般的环境中。

20
00:01:29,880 --> 00:01:34,860
然后我们将使用这个替代视图来分析一个关于重复分数的有趣谜题。

21
00:01:35,460 --> 00:01:39,660
但首先，我只是想确保我们对于 标准视觉效果的看法是一致的。

22
00:01:40,060 --> 00:01:44,802
如果你要绘制一个函数，它只是将实数作为输入和输 

23
00:01:44,802 --> 00:01:49,347
出，你在微积分课程中学到的第一件事就是导数给 

24
00:01:49,347 --> 00:01:53,892
出了这个图的斜率，我们的意思是该函数的导数是 

25
00:01:53,892 --> 00:01:58,240
一个新函数，它对于每个输入 x 返回该斜率。

26
00:01:59,520 --> 00:02:02,054
现在，我鼓励您不要将这种导数视为 

27
00:02:02,054 --> 00:02:04,440
斜率概念，而将其视为导数的定义。

28
00:02:05,000 --> 00:02:10,419
相反，从根本上将其视为函数对 输入周围微小推动的敏感程度。

29
00:02:11,020 --> 00:02:14,143
斜率只是考虑仅与这种特定的观察功 

30
00:02:14,143 --> 00:02:16,900
能方式相关的敏感性的一种方式。

31
00:02:17,340 --> 00:02:19,798
如果您想了解更多信息，我不仅有另一 

32
00:02:19,798 --> 00:02:22,120
个视频，还有关于该主题的完整系列。

33
00:02:22,600 --> 00:02:26,145
现在导数的替代视觉背后的基本思想 

34
00:02:26,145 --> 00:02:29,691
是将此函数视为将数轴上的所有输入 

35
00:02:29,691 --> 00:02:32,820
点映射到不同数轴上的相应输出。

36
00:02:33,400 --> 00:02:36,897
在这种情况下，导数为您提供的是输入空间 

37
00:02:36,897 --> 00:02:40,220
在各个区域中被拉伸或压缩的程度的度量。

38
00:02:41,859 --> 00:02:47,018
也就是说，如果您要放大特定输入并查看其周 

39
00:02:47,018 --> 00:02:51,932
围一些均匀分布的点，则该输入函数的导数 

40
00:02:51,932 --> 00:02:56,600
将告诉您这些点在映射后如何展开或收缩。

41
00:02:57,940 --> 00:02:59,400
在这里，一个具体的例子会有所帮助。

42
00:02:59,740 --> 00:03:02,535
以函数 x2 为例，它将 1 映射到 

43
00:03:02,535 --> 00:03:05,920
1、2 映射到 4、3 映射到 9，依此类推。

44
00:03:06,480 --> 00:03:13,260
您还可以看到它如何作用于中间的所有点。

45
00:03:13,260 --> 00:03:18,311
如果放大输入 1 周围的一小群点，并查看它们落在 

46
00:03:18,311 --> 00:03:23,160
相关输出周围的位置，您会注意到它们往往会被拉伸。

47
00:03:23,160 --> 00:03:27,820
事实上，它看起来大致相当于拉伸了 2 倍。

48
00:03:27,820 --> 00:03:35,000
放大得越近，这种局部行为看 起来就越像乘以 2 倍。

49
00:03:35,000 --> 00:03:41,820
这就是输入 x 等于 1 时 x2 的导数为 2 的含义。

50
00:03:42,340 --> 00:03:45,400
这就是这个事实在转型背景下的样子。

51
00:03:46,460 --> 00:03:52,160
如果您查看输入 3 周围的点 邻域，它们将被拉伸 6 倍。

52
00:03:52,740 --> 00:03:57,440
这就是该函数在输入 3 处的导数等于 6 的含义。

53
00:03:58,980 --> 00:04:04,013
在输入 1/4 附近，一个小区域往往会收缩 

54
00:04:04,013 --> 00:04:08,360
1/2，这就是导数小于 1 时的情况。

55
00:04:10,720 --> 00:04:12,600
输入 0 很有趣。

56
00:04:13,120 --> 00:04:17,959
放大 10 倍，它看起来 并不像持续拉伸或挤压。

57
00:04:18,380 --> 00:04:21,360
一方面，所有的输出最终都朝着积极的方向发展。

58
00:04:21,360 --> 00:04:31,332
当你放大得越来越近时，100 倍或 1000 倍，它看起来 

59
00:04:31,332 --> 00:04:40,640
越来越像 0 周围的点的一个小邻域刚刚折叠成 0 本身。

60
00:04:40,640 --> 00:04:43,300
这就是导数为 0 时的样子。

61
00:04:43,300 --> 00:04:47,040
局部行为看起来越来越像将整个数轴乘以 0。

62
00:04:47,040 --> 00:04:51,644
它不必将所有内容完全折叠到特定缩放级别的某个点， 

63
00:04:51,644 --> 00:04:55,880
而是当您放大得越来越近时限制行为是什么的问题。

64
00:04:55,880 --> 00:04:58,960
查看这里的负面输入也很有启发性。

65
00:05:00,700 --> 00:05:04,915
事情开始感觉有点局促，因为它们与所有正输入值的 

66
00:05:04,915 --> 00:05:08,780
去向发生冲突，这是将函数视为转换的缺点之一。

67
00:05:09,400 --> 00:05:12,502
但对于导数，我们只关心局部行为，即 

68
00:05:12,502 --> 00:05:15,260
给定输入周围小范围内发生的情况。

69
00:05:15,260 --> 00:05:19,782
在这里，请注意，在负数 2 附近的一个小邻 

70
00:05:19,782 --> 00:05:24,100
域中的输入，它们不仅会被拉伸，还会被翻转。

71
00:05:24,680 --> 00:05:28,460
具体来说，放大得越近，对这样一个邻 

72
00:05:28,460 --> 00:05:31,820
域的操作看起来就越像乘以负 4。

73
00:05:32,320 --> 00:05:38,900
这就是函数导数为负时的样子。

74
00:05:38,900 --> 00:05:41,352
我想你明白了，这一切都很好，但让 

75
00:05:41,352 --> 00:05:43,660
我们看看这在解决问题时有何用处。

76
00:05:44,260 --> 00:05:48,405
我的一个朋友最近问了我一个非常有趣的问题，关于无限分 

77
00:05:48,405 --> 00:05:52,397
数 1 加 1 除以 1 加 1 除以 1 加 1 

78
00:05:52,397 --> 00:05:56,389
除以 1，显然你在网上观看数学视频，所以也许你以前 

79
00:05:56,389 --> 00:06:00,381
看过这个，但是我朋友的问题实际上切入了你以前可能没 

80
00:06:00,381 --> 00:06:04,220
有想到的问题，与我们在这里讨论的衍生品的观点相关。

81
00:06:05,020 --> 00:06:09,535
计算这样的表达式的典型方法是将其设置为等于 

82
00:06:09,535 --> 00:06:13,640
x，然后注意到其内部存在完整分数的副本。

83
00:06:14,700 --> 00:06:18,780
因此，您可以用另一个 x 替换该副本，然后求解 x。

84
00:06:19,440 --> 00:06:22,258
也就是说，你想要的是找到函数 1 

85
00:06:22,258 --> 00:06:24,580
加 1 除以 x 的不动点。

86
00:06:27,160 --> 00:06:31,864
但问题是，x 实际上有两个解决方案，两个特殊数字 

87
00:06:31,864 --> 00:06:36,380
，其中 1 加 1 除以该数字会得到相同的结果。

88
00:06:36,940 --> 00:06:42,659
一是黄金比例，phi，大约为 1。618，另一个为负0。

89
00:06:42,659 --> 00:06:46,540
618， 恰好是负 1 除以 phi。

90
00:06:46,960 --> 00:06:50,059
我喜欢将另一个数字称为 phi 的弟弟，因为几 

91
00:06:50,059 --> 00:06:52,900
乎 phi 具有的任何属性，这个数字也具有。

92
00:06:53,560 --> 00:06:58,580
这就提出了一个问题，我们看到的无限分数在某种程度 

93
00:06:58,580 --> 00:07:03,600
上也等于 phi 的弟弟负 0 是否有效。618？

94
00:07:04,520 --> 00:07:08,058
也许你一开始会说，显然不是，左边的所有内 

95
00:07:08,058 --> 00:07:11,260
容都是正数，那么它怎么可能等于负数呢？

96
00:07:12,500 --> 00:07:17,100
好吧，首先我们应该清楚这样的表达方式的实际含义。

97
00:07:17,780 --> 00:07:23,180
你可以考虑的一种方法是，这不是唯一的方法，这里有选择的自由 

98
00:07:23,180 --> 00:07:28,039
，就是想象从一些常数开始，比如 1，然后重复应用函数 

99
00:07:28,039 --> 00:07:33,260
1 加 1 除以 x，然后问，什么你会继续采用这种方法吗？

100
00:07:36,040 --> 00:07:38,576
我的意思是，当然象征性地，你得到的看起来越 

101
00:07:38,576 --> 00:07:41,113
来越像我们的无限分数，所以也许如果你想等于 

102
00:07:41,113 --> 00:07:43,420
一个数字，你应该问这一系列数字接近什么。

103
00:07:45,120 --> 00:07:48,344
如果这就是你对事物的看法，也许你从一个负数开始 

104
00:07:48,344 --> 00:07:51,300
，所以整个表达式最终变成负数并不是那么疯狂。

105
00:07:52,740 --> 00:07:55,434
毕竟，如果你从负 1 除以 phi 

106
00:07:55,434 --> 00:07:58,577
开始，然后应用这个函数，1 加 1 除以 

107
00:07:58,577 --> 00:08:02,020
x，你会得到相同的数字，负 1 除以 phi。

108
00:08:02,200 --> 00:08:05,040
因此，无论您应用多少次，您都会保持固定在该值。

109
00:08:05,040 --> 00:08:09,450
但即便如此，您仍然应该将 phi 视为 

110
00:08:09,450 --> 00:08:13,420
这一对中最喜欢的兄弟，原因是有一个。

111
00:08:14,020 --> 00:08:18,756
在这里，尝试一下，拉出某种计算器，然后从任意随机 

112
00:08:18,756 --> 00:08:23,492
数开始，将其插入到这个函数中，1加1除以x，然后 

113
00:08:23,492 --> 00:08:28,040
将该数字插入1加1除以x，如此反复，一次又一次。

114
00:08:28,480 --> 00:08:33,159
无论你从什么常数开始，最终都会得到 1。618. 

115
00:08:33,799 --> 00:08:38,599
即使你从一个负数开始，即使是一个非常接近 phi 

116
00:08:38,599 --> 00:08:43,400
的小兄弟的数字，最终它也会避开该值并跳回 phi。

117
00:08:50,819 --> 00:08:52,460
那么，这是怎么回事？

118
00:08:52,800 --> 00:08:55,920
为什么这些固定点之一比另一个更受青睐？

119
00:08:56,720 --> 00:09:00,229
也许您已经可以看到对导数的转换理解如何有 

120
00:09:00,229 --> 00:09:03,738
助于理解这种设置，但为了进行对比，我想向 

121
00:09:03,738 --> 00:09:07,080
您展示如何经常使用图表来教授这样的问题。

122
00:09:07,920 --> 00:09:12,013
如果您要向此函数插入一些随机输入，则 

123
00:09:12,013 --> 00:09:15,460
y 值会告诉您相应的输出，对吧？

124
00:09:15,460 --> 00:09:19,897
因此，要将输出插回到函数中，您可能首先水平移动， 

125
00:09:19,897 --> 00:09:24,157
直到到达 y 等于 x 的线，这将为您提供一个 

126
00:09:24,157 --> 00:09:28,240
位置，其中 x 值对应于之前的 y 值，对吧？

127
00:09:28,920 --> 00:09:33,241
然后从那里开始，您可以垂直移动以查看这个新的 

128
00:09:33,241 --> 00:09:37,376
x 值有什么输出，然后重复，水平移动到 y 

129
00:09:37,376 --> 00:09:41,885
等于 x 的线，找到一个 x 值与您刚刚获得的 

130
00:09:41,885 --> 00:09:46,020
输出相同的点，然后垂直移动以再次应用该功能。

131
00:09:46,020 --> 00:09:48,548
就我个人而言，我认为这是重复应用 

132
00:09:48,548 --> 00:09:50,780
函数的一种尴尬的方式，不是吗？

133
00:09:51,300 --> 00:09:53,990
我的意思是，这是有道理的，但你必须停 

134
00:09:53,990 --> 00:09:56,540
下来思考一下，以记住以哪种方式划线。

135
00:09:57,120 --> 00:10:01,394
如果你愿意，你可以思考什么条件使这个蜘蛛网 

136
00:10:01,394 --> 00:10:05,280
过程缩小到一个固定点，而不是远离它传播。

137
00:10:05,860 --> 00:10:08,900
事实上，继续吧，现在就停下来，尝试把它当作一个练习来思考。

138
00:10:09,240 --> 00:10:10,460
跟坡度有关系。

139
00:10:12,020 --> 00:10:17,473
或者，如果您想跳过练习来获得我认为可以提供更令 

140
00:10:17,473 --> 00:10:22,700
人满意的理解的内容，请考虑该函数如何充当转换。

141
00:10:22,700 --> 00:10:25,301
因此，我将从这里开始绘制一堆箭 

142
00:10:25,301 --> 00:10:27,740
头来指示各种采样输入点的去向。

143
00:10:28,320 --> 00:10:31,440
顺便说一句，您不认为这给出了一个简洁的涌现模式吗？

144
00:10:31,820 --> 00:10:35,740
我没想到会这样，但在制作动画时看到它弹出真是太酷了。

145
00:10:35,740 --> 00:10:38,648
1 除以 x 的作用给出了这个很好的紧急 

146
00:10:38,648 --> 00:10:41,280
循环，然后我们只需将其移动 1 即可。

147
00:10:42,040 --> 00:10:45,519
不管怎样，我想让你思考一下在这种情况下重复应用某 

148
00:10:45,519 --> 00:10:48,720
个函数意味着什么，比如 1 加 1 除以 x。

149
00:10:50,240 --> 00:10:54,179
好吧，在让它将所有输入映射到输出之后，您可 

150
00:10:54,179 --> 00:10:57,939
以将它们视为新输入，然后再次应用相同的过 

151
00:10:57,939 --> 00:11:01,520
程，然后再一次，并执行您想要的任意次数。

152
00:11:02,580 --> 00:11:07,133
请注意，在使用代表样本点的几个点进行动画处理时，在所有这 

153
00:11:07,133 --> 00:11:11,843
些点都聚集在 1 左右之前，根本不需要进行多次迭代。618.

154
00:11:11,843 --> 00:11:12,000
 

155
00:11:14,620 --> 00:11:19,055
现在记住，我们知道 1。618和它的弟弟，负0。

156
00:11:19,055 --> 00:11:23,860
618 不断 ，在此过程的每次迭代期间保持固定到位。

157
00:11:24,860 --> 00:11:27,480
但放大 phi 周围的邻域。

158
00:11:27,480 --> 00:11:34,184
在映射期间，该区域中的点围绕 phi 收缩，这意味着函数 

159
00:11:34,184 --> 00:11:41,120
1 加 1 在 x 上的导数在此输入处具有小于 1 的幅度。

160
00:11:41,880 --> 00:11:45,200
事实上，该导数的结果约为负 0。38. 

161
00:11:46,120 --> 00:11:50,432
所以这意味着每次重复的应用都会将这个数字周围的邻 

162
00:11:50,432 --> 00:11:54,400
域压缩得越来越小，就像对 phi 的引力一样。

163
00:11:54,959 --> 00:11:58,620
现在，告诉我你认为在 phi 的弟弟附近会发生什么。

164
00:12:01,320 --> 00:12:08,920
在那里，导数的大小大于 1， 因此固定点附近的点会被排斥。

165
00:12:09,520 --> 00:12:11,724
当你计算出来时，你会发现它们在每 

166
00:12:11,724 --> 00:12:13,800
次迭代中都被拉伸了 2 倍以上。

167
00:12:14,420 --> 00:12:17,798
它们也会被翻转，因为这里的导数是负的， 

168
00:12:17,798 --> 00:12:20,840
但为了稳定性，最重要的事实就是大小。

169
00:12:23,440 --> 00:12:29,360
数学家将这个右值称为稳定不动 点，而左值称为不稳定不动点。

170
00:12:30,000 --> 00:12:33,632
如果当你稍微扰动它时，一切都会回到原来的位 

171
00:12:33,632 --> 00:12:37,100
置，而不是远离它，那么它就被认为是稳定的。

172
00:12:38,180 --> 00:12:41,284
所以我们看到的是一个非常有用的 

173
00:12:41,284 --> 00:12:46,911
小事实，即定点的稳定性取决于其 导数的大小是否大于或小于 

174
00:12:46,911 --> 00:12:47,300
1。

175
00:12:47,300 --> 00:12:50,349
这解释了为什么 phi 总是出现在数字游戏

176
00:12:50,349 --> 00:12:53,109
中，您只需一遍又一遍地 在计算器上按 

177
00:12:53,109 --> 00:12:56,740
Enter 键，但 phi 的弟弟却从来不这样做。

178
00:12:56,740 --> 00:13:02,880
您是否想将 phi 的弟弟视 为无限分数的有效值取决于您。

179
00:13:03,260 --> 00:13:06,987
我们刚刚展示的所有内容都表明，如果您认为这个表达式 

180
00:13:06,987 --> 00:13:10,715
代表一个极限过程，那么因为除了 phi 的弟弟之外 

181
00:13:10,715 --> 00:13:14,299
的每个可能的种子值都会为您提供一个收敛于 phi 

182
00:13:14,299 --> 00:13:17,740
的级数，因此将它们置于平等的地位确实感觉很愚蠢。

183
00:13:18,260 --> 00:13:21,975
但也许您不认为它是一个限制，也许您正在 

184
00:13:21,975 --> 00:13:25,690
做的数学运算适合将其视为纯粹的代数对象 

185
00:13:25,690 --> 00:13:29,220
，就像多项式的解一样，它只具有多个值。

186
00:13:30,340 --> 00:13:34,710
无论如何，这不是重点，我在这里的观点并不是认为观察导数， 

187
00:13:34,710 --> 00:13:38,780
因为密度的这种变化在某种程度上比整体上的图形直觉更好。

188
00:13:39,600 --> 00:13:42,331
事实上，与图表相比，以这种方式描绘 

189
00:13:42,331 --> 00:13:44,760
整个函数可能有点笨拙且不切实际。

190
00:13:45,339 --> 00:13:49,727
我的观点是，在大多数微积分入门课程中，它值得更多 

191
00:13:49,727 --> 00:13:53,940
地提及，因为它可以帮助学生对导数的理解更加灵活。

192
00:13:54,900 --> 00:13:58,419
就像我提到的，我建议您在学习新主题时随身携带 

193
00:13:58,419 --> 00:14:01,786
这种观点的真正原因并不是因为它对您对单变量 

194
00:14:01,786 --> 00:14:05,000
微积分的理解有何帮助，而是为了之后的内容。

