1
00:00:00,000 --> 00:00:05,744
未来的几个月里，你将面临大量的艰苦工作，一些简洁的

2
00:00:05,744 --> 00:00:11,268
例子，一些不太简洁的例子，与物理的美妙联系，需要

3
00:00:11,268 --> 00:00:17,013
记住的一堆不那么漂亮的公式，大量的卡住和敲打的时刻

4
00:00:17,013 --> 00:00:22,537
当你把头撞到墙上时，也会有一些美好的顿悟时刻，还

5
00:00:22,537 --> 00:00:27,840
有一些真正可爱的图形直觉来帮助指导你完成这一切。

6
00:00:27,840 --> 00:00:32,049
但是，如果您面前的课程类似于我的第一门微积分入门

7
00:00:32,049 --> 00:00:36,258
课程，或者是我多年来见过的第一门课程，那么有一个

8
00:00:36,258 --> 00:00:40,300
主题您不会看到，但我相信它会极大地加速您的学习。

9
00:00:40,300 --> 00:00:45,080
你看，第一年几乎所有的视觉直觉都是基于图表的。

10
00:00:45,080 --> 00:00:50,320
导数是图的斜率，积分是该图下方的某个区域。

11
00:00:50,320 --> 00:00:56,175
但是，当您将微积分推广到输入和输出只是数字的函数之

12
00:00:56,175 --> 00:01:01,580
外时，并不总是能够绘制出您正在分析的函数的图表。

13
00:01:01,580 --> 00:01:06,034
因此，如果你对基本思想（如导数）的所有直觉都过于

14
00:01:06,034 --> 00:01:10,488
严格地植根于图表，那么它可能会在你和更多引用不引

15
00:01:10,488 --> 00:01:14,942
用的高级主题（如多变量微积分和复杂分析）之间造成

16
00:01:14,942 --> 00:01:19,040
一个非常高且基本上不必要的概念障碍，微分几何。

17
00:01:19,040 --> 00:01:22,765
我想与您分享的是一种思考导数的方法，

18
00:01:22,765 --> 00:01:26,490
我将其称为转换视图，它可以更无缝地推

19
00:01:26,490 --> 00:01:30,020
广到微积分出现的一些更一般的环境中。

20
00:01:30,020 --> 00:01:35,600
然后我们将使用这个替代视图来分析一个关于重复分数的有趣谜题。

21
00:01:35,600 --> 00:01:40,160
但首先，我只是想确保我们对于 标准视觉效果的看法是一致的。

22
00:01:40,160 --> 00:01:45,215
如果你要绘制一个函数，它只是将实数作为输入和输

23
00:01:45,215 --> 00:01:50,060
出，你在微积分课程中学到的第一件事就是导数给

24
00:01:50,060 --> 00:01:54,905
出了这个图的斜率，我们的意思是该函数的导数是

25
00:01:54,905 --> 00:01:59,540
一个新函数，它对于每个输入 x 返回该斜率。

26
00:01:59,540 --> 00:02:02,476
现在，我鼓励您不要将这种导数视为

27
00:02:02,476 --> 00:02:05,240
斜率概念，而将其视为导数的定义。

28
00:02:05,240 --> 00:02:11,060
相反，从根本上将其视为函数对 输入周围微小推动的敏感程度。

29
00:02:11,060 --> 00:02:14,470
斜率只是考虑仅与这种特定的观察功

30
00:02:14,470 --> 00:02:17,480
能方式相关的敏感性的一种方式。

31
00:02:17,480 --> 00:02:19,856
如果您想了解更多信息，我不仅有另一

32
00:02:19,856 --> 00:02:22,100
个视频，还有关于该主题的完整系列。

33
00:02:22,100 --> 00:02:25,888
现在导数的替代视觉背后的基本思想

34
00:02:25,888 --> 00:02:29,677
是将此函数视为将数轴上的所有输入

35
00:02:29,677 --> 00:02:33,020
点映射到不同数轴上的相应输出。

36
00:02:33,020 --> 00:02:37,820
在这种情况下，导数为您提供的是输入空间

37
00:02:37,820 --> 00:02:42,380
在各个区域中被拉伸或压缩的程度的度量。

38
00:02:42,380 --> 00:02:47,567
也就是说，如果您要放大特定输入并查看其周

39
00:02:47,567 --> 00:02:52,507
围一些均匀分布的点，则该输入函数的导数

40
00:02:52,507 --> 00:02:57,200
将告诉您这些点在映射后如何展开或收缩。

41
00:02:57,200 --> 00:02:59,840
在这里，一个具体的例子会有所帮助。

42
00:02:59,840 --> 00:03:02,952
以函数 x2 为例，它将 1 映射到

43
00:03:02,952 --> 00:03:06,720
1、2 映射到 4、3 映射到 9，依此类推。

44
00:03:06,720 --> 00:03:12,960
您还可以看到它如何作用于中间的所有点。

45
00:03:12,960 --> 00:03:19,255
如果放大输入 1 周围的一小群点，并查看它们落在

46
00:03:19,255 --> 00:03:25,300
相关输出周围的位置，您会注意到它们往往会被拉伸。

47
00:03:25,300 --> 00:03:29,700
事实上，它看起来大致相当于拉伸了 2 倍。

48
00:03:29,700 --> 00:03:36,500
放大得越近，这种局部行为看 起来就越像乘以 2 倍。

49
00:03:36,500 --> 00:03:41,900
这就是输入 x 等于 1 时 x2 的导数为 2 的含义。

50
00:03:41,900 --> 00:03:46,480
这就是这个事实在转型背景下的样子。

51
00:03:46,480 --> 00:03:52,800
如果您查看输入 3 周围的点 邻域，它们将被拉伸 6 倍。

52
00:03:52,800 --> 00:03:59,240
这就是该函数在输入 3 处的导数等于 6 的含义。

53
00:03:59,240 --> 00:04:05,614
在输入 1/4 附近，一个小区域往往会收缩

54
00:04:05,614 --> 00:04:11,120
1/2，这就是导数小于 1 时的情况。

55
00:04:11,120 --> 00:04:13,300
输入 0 很有趣。

56
00:04:13,300 --> 00:04:18,580
放大 10 倍，它看起来 并不像持续拉伸或挤压。

57
00:04:18,580 --> 00:04:23,380
一方面，所有的输出最终都朝着积极的方向发展。

58
00:04:23,380 --> 00:04:29,214
当你放大得越来越近时，100 倍或 1000 倍，它看起来

59
00:04:29,214 --> 00:04:34,660
越来越像 0 周围的点的一个小邻域刚刚折叠成 0 本身。

60
00:04:34,660 --> 00:04:40,500
这就是导数为 0 时的样子。

61
00:04:40,500 --> 00:04:45,720
局部行为看起来越来越像将整个数轴乘以 0。

62
00:04:45,720 --> 00:04:50,324
它不必将所有内容完全折叠到特定缩放级别的某个点，

63
00:04:50,324 --> 00:04:54,560
而是当您放大得越来越近时限制行为是什么的问题。

64
00:04:54,560 --> 00:05:01,120
查看这里的负面输入也很有启发性。

65
00:05:01,120 --> 00:05:05,440
事情开始感觉有点局促，因为它们与所有正输入值的

66
00:05:05,440 --> 00:05:09,400
去向发生冲突，这是将函数视为转换的缺点之一。

67
00:05:09,400 --> 00:05:13,031
但对于导数，我们只关心局部行为，即

68
00:05:13,031 --> 00:05:16,260
给定输入周围小范围内发生的情况。

69
00:05:16,260 --> 00:05:20,516
在这里，请注意，在负数 2 附近的一个小邻

70
00:05:20,516 --> 00:05:24,580
域中的输入，它们不仅会被拉伸，还会被翻转。

71
00:05:24,580 --> 00:05:28,645
具体来说，放大得越近，对这样一个邻

72
00:05:28,645 --> 00:05:32,260
域的操作看起来就越像乘以负 4。

73
00:05:32,260 --> 00:05:36,140
这就是函数导数为负时的样子。

74
00:05:36,140 --> 00:05:40,312
我想你明白了，这一切都很好，但让

75
00:05:40,312 --> 00:05:44,240
我们看看这在解决问题时有何用处。

76
00:05:44,240 --> 00:05:48,560
我的一个朋友最近问了我一个非常有趣的问题，关于无限分

77
00:05:48,560 --> 00:05:52,720
数 1 加 1 除以 1 加 1 除以 1 加 1

78
00:05:52,720 --> 00:05:56,880
除以 1，显然你在网上观看数学视频，所以也许你以前

79
00:05:56,880 --> 00:06:01,040
看过这个，但是我朋友的问题实际上切入了你以前可能没

80
00:06:01,040 --> 00:06:05,040
有想到的问题，与我们在这里讨论的衍生品的观点相关。

81
00:06:05,040 --> 00:06:10,340
计算这样的表达式的典型方法是将其设置为等于

82
00:06:10,340 --> 00:06:15,160
x，然后注意到其内部存在完整分数的副本。

83
00:06:15,160 --> 00:06:19,300
因此，您可以用另一个 x 替换该副本，然后求解 x。

84
00:06:19,300 --> 00:06:23,862
也就是说，你想要的是找到函数 1

85
00:06:23,862 --> 00:06:27,620
加 1 除以 x 的不动点。

86
00:06:27,620 --> 00:06:32,507
但问题是，x 实际上有两个解决方案，两个特殊数字

87
00:06:32,507 --> 00:06:37,200
，其中 1 加 1 除以该数字会得到相同的结果。

88
00:06:37,200 --> 00:06:43,002
一是黄金比例，phi，大约为 1。618，另一个为负0。

89
00:06:43,002 --> 00:06:46,940
618， 恰好是负 1 除以 phi。

90
00:06:46,940 --> 00:06:50,487
我喜欢将另一个数字称为 phi 的弟弟，因为几

91
00:06:50,487 --> 00:06:53,740
乎 phi 具有的任何属性，这个数字也具有。

92
00:06:53,740 --> 00:06:59,290
这就提出了一个问题，我们看到的无限分数在某种程度

93
00:06:59,290 --> 00:07:04,840
上也等于 phi 的弟弟负 0 是否有效。618？

94
00:07:04,840 --> 00:07:08,662
也许你一开始会说，显然不是，左边的所有内

95
00:07:08,662 --> 00:07:12,120
容都是正数，那么它怎么可能等于负数呢？

96
00:07:12,120 --> 00:07:17,980
好吧，首先我们应该清楚这样的表达方式的实际含义。

97
00:07:17,980 --> 00:07:23,603
你可以考虑的一种方法是，这不是唯一的方法，这里有选择的自由

98
00:07:23,603 --> 00:07:28,664
，就是想象从一些常数开始，比如 1，然后重复应用函数

99
00:07:28,664 --> 00:07:34,100
1 加 1 除以 x，然后问，什么你会继续采用这种方法吗？

100
00:07:34,100 --> 00:07:37,963
我的意思是，当然象征性地，你得到的看起来越

101
00:07:37,963 --> 00:07:41,827
来越像我们的无限分数，所以也许如果你想等于

102
00:07:41,827 --> 00:07:45,340
一个数字，你应该问这一系列数字接近什么。

103
00:07:45,340 --> 00:07:49,451
如果这就是你对事物的看法，也许你从一个负数开始

104
00:07:49,451 --> 00:07:53,220
，所以整个表达式最终变成负数并不是那么疯狂。

105
00:07:53,220 --> 00:07:55,885
毕竟，如果你从负 1 除以 phi

106
00:07:55,885 --> 00:07:58,994
开始，然后应用这个函数，1 加 1 除以

107
00:07:58,994 --> 00:08:02,400
x，你会得到相同的数字，负 1 除以 phi。

108
00:08:02,400 --> 00:08:07,980
因此，无论您应用多少次，您都会保持固定在该值。

109
00:08:07,980 --> 00:08:10,948
但即便如此，您仍然应该将 phi 视为

110
00:08:10,948 --> 00:08:13,620
这一对中最喜欢的兄弟，原因是有一个。

111
00:08:13,620 --> 00:08:18,768
在这里，尝试一下，拉出某种计算器，然后从任意随机

112
00:08:18,768 --> 00:08:23,917
数开始，将其插入到这个函数中，1加1除以x，然后

113
00:08:23,917 --> 00:08:28,860
将该数字插入1加1除以x，如此反复，一次又一次。

114
00:08:28,860 --> 00:08:34,080
无论你从什么常数开始，最终都会得到 1。618.

115
00:08:34,080 --> 00:08:38,690
即使你从一个负数开始，即使是一个非常接近 phi

116
00:08:38,690 --> 00:08:43,300
的小兄弟的数字，最终它也会避开该值并跳回 phi。

117
00:08:43,300 --> 00:08:52,840
那么，这是怎么回事？

118
00:08:52,840 --> 00:08:56,740
为什么这些固定点之一比另一个更受青睐？

119
00:08:56,740 --> 00:09:00,526
也许您已经可以看到对导数的转换理解如何有

120
00:09:00,526 --> 00:09:04,313
助于理解这种设置，但为了进行对比，我想向

121
00:09:04,313 --> 00:09:07,920
您展示如何经常使用图表来教授这样的问题。

122
00:09:07,920 --> 00:09:11,752
如果您要向此函数插入一些随机输入，则

123
00:09:11,752 --> 00:09:14,980
y 值会告诉您相应的输出，对吧？

124
00:09:14,980 --> 00:09:19,841
因此，要将输出插回到函数中，您可能首先水平移动，

125
00:09:19,841 --> 00:09:24,507
直到到达 y 等于 x 的线，这将为您提供一个

126
00:09:24,507 --> 00:09:28,980
位置，其中 x 值对应于之前的 y 值，对吧？

127
00:09:28,980 --> 00:09:33,114
然后从那里开始，您可以垂直移动以查看这个新的

128
00:09:33,114 --> 00:09:37,070
x 值有什么输出，然后重复，水平移动到 y

129
00:09:37,070 --> 00:09:41,384
等于 x 的线，找到一个 x 值与您刚刚获得的

130
00:09:41,384 --> 00:09:45,340
输出相同的点，然后垂直移动以再次应用该功能。

131
00:09:45,340 --> 00:09:48,548
就我个人而言，我认为这是重复应用

132
00:09:48,548 --> 00:09:51,380
函数的一种尴尬的方式，不是吗？

133
00:09:51,380 --> 00:09:54,152
我的意思是，这是有道理的，但你必须停

134
00:09:54,152 --> 00:09:56,780
下来思考一下，以记住以哪种方式划线。

135
00:09:56,780 --> 00:10:01,326
如果你愿意，你可以思考什么条件使这个蜘蛛网

136
00:10:01,326 --> 00:10:05,460
过程缩小到一个固定点，而不是远离它传播。

137
00:10:05,460 --> 00:10:09,460
事实上，继续吧，现在就停下来，尝试把它当作一个练习来思考。

138
00:10:09,460 --> 00:10:12,380
跟坡度有关系。

139
00:10:12,380 --> 00:10:16,281
或者，如果您想跳过练习来获得我认为可以提供更令

140
00:10:16,281 --> 00:10:20,020
人满意的理解的内容，请考虑该函数如何充当转换。

141
00:10:20,020 --> 00:10:24,272
因此，我将从这里开始绘制一堆箭

142
00:10:24,272 --> 00:10:28,260
头来指示各种采样输入点的去向。

143
00:10:28,260 --> 00:10:31,860
顺便说一句，您不认为这给出了一个简洁的涌现模式吗？

144
00:10:31,860 --> 00:10:35,820
我没想到会这样，但在制作动画时看到它弹出真是太酷了。

145
00:10:35,820 --> 00:10:38,802
1 除以 x 的作用给出了这个很好的紧急

146
00:10:38,802 --> 00:10:41,500
循环，然后我们只需将其移动 1 即可。

147
00:10:41,500 --> 00:10:45,500
不管怎样，我想让你思考一下在这种情况下重复应用某

148
00:10:45,500 --> 00:10:49,180
个函数意味着什么，比如 1 加 1 除以 x。

149
00:10:49,180 --> 00:10:54,054
好吧，在让它将所有输入映射到输出之后，您可

150
00:10:54,054 --> 00:10:58,708
以将它们视为新输入，然后再次应用相同的过

151
00:10:58,708 --> 00:11:03,140
程，然后再一次，并执行您想要的任意次数。

152
00:11:03,140 --> 00:11:08,708
请注意，在使用代表样本点的几个点进行动画处理时，在所有这

153
00:11:08,708 --> 00:11:14,468
些点都聚集在 1 左右之前，根本不需要进行多次迭代。618.

154
00:11:14,468 --> 00:11:14,660


155
00:11:14,660 --> 00:11:19,594
现在记住，我们知道 1。618和它的弟弟，负0。

156
00:11:19,594 --> 00:11:24,940
618 不断 ，在此过程的每次迭代期间保持固定到位。

157
00:11:24,940 --> 00:11:28,500
但放大 phi 周围的邻域。

158
00:11:28,500 --> 00:11:35,106
在映射期间，该区域中的点围绕 phi 收缩，这意味着函数

159
00:11:35,106 --> 00:11:41,940
1 加 1 在 x 上的导数在此输入处具有小于 1 的幅度。

160
00:11:41,940 --> 00:11:46,180
事实上，该导数的结果约为负 0。38.

161
00:11:46,180 --> 00:11:50,950
所以这意味着每次重复的应用都会将这个数字周围的邻

162
00:11:50,950 --> 00:11:55,340
域压缩得越来越小，就像对 phi 的引力一样。

163
00:11:55,340 --> 00:12:01,420
现在，告诉我你认为在 phi 的弟弟附近会发生什么。

164
00:12:01,420 --> 00:12:09,660
在那里，导数的大小大于 1， 因此固定点附近的点会被排斥。

165
00:12:09,660 --> 00:12:12,132
当你计算出来时，你会发现它们在每

166
00:12:12,132 --> 00:12:14,460
次迭代中都被拉伸了 2 倍以上。

167
00:12:14,460 --> 00:12:19,175
它们也会被翻转，因为这里的导数是负的，

168
00:12:19,175 --> 00:12:23,420
但为了稳定性，最重要的事实就是大小。

169
00:12:23,420 --> 00:12:30,180
数学家将这个右值称为稳定不动 点，而左值称为不稳定不动点。

170
00:12:30,180 --> 00:12:34,293
如果当你稍微扰动它时，一切都会回到原来的位

171
00:12:34,293 --> 00:12:38,220
置，而不是远离它，那么它就被认为是稳定的。

172
00:12:38,220 --> 00:12:41,624
所以我们看到的是一个非常有用的

173
00:12:41,624 --> 00:12:47,794
小事实，即定点的稳定性取决于其 导数的大小是否大于或小于

174
00:12:47,794 --> 00:12:48,220
1。

175
00:12:48,220 --> 00:12:50,920
这解释了为什么 phi 总是出现在数字游戏

176
00:12:50,920 --> 00:12:53,364
中，您只需一遍又一遍地 在计算器上按

177
00:12:53,364 --> 00:12:56,580
Enter 键，但 phi 的弟弟却从来不这样做。

178
00:12:56,580 --> 00:13:03,520
您是否想将 phi 的弟弟视 为无限分数的有效值取决于您。

179
00:13:03,520 --> 00:13:07,355
我们刚刚展示的所有内容都表明，如果您认为这个表达式

180
00:13:07,355 --> 00:13:11,191
代表一个极限过程，那么因为除了 phi 的弟弟之外

181
00:13:11,191 --> 00:13:14,879
的每个可能的种子值都会为您提供一个收敛于 phi

182
00:13:14,879 --> 00:13:18,420
的级数，因此将它们置于平等的地位确实感觉很愚蠢。

183
00:13:18,420 --> 00:13:22,243
但也许您不认为它是一个限制，也许您正在

184
00:13:22,243 --> 00:13:26,067
做的数学运算适合将其视为纯粹的代数对象

185
00:13:26,067 --> 00:13:29,700
，就像多项式的解一样，它只具有多个值。

186
00:13:29,700 --> 00:13:34,837
无论如何，这不是重点，我在这里的观点并不是认为观察导数，

187
00:13:34,837 --> 00:13:39,620
因为密度的这种变化在某种程度上比整体上的图形直觉更好。

188
00:13:39,620 --> 00:13:42,722
事实上，与图表相比，以这种方式描绘

189
00:13:42,722 --> 00:13:45,480
整个函数可能有点笨拙且不切实际。

190
00:13:45,480 --> 00:13:50,337
我的观点是，在大多数微积分入门课程中，它值得更多

191
00:13:50,337 --> 00:13:55,000
地提及，因为它可以帮助学生对导数的理解更加灵活。

192
00:13:55,000 --> 00:13:58,666
就像我提到的，我建议您在学习新主题时随身携带

193
00:13:58,666 --> 00:14:02,172
这种观点的真正原因并不是因为它对您对单变量

194
00:14:02,172 --> 00:14:05,520
微积分的理解有何帮助，而是为了之后的内容。

