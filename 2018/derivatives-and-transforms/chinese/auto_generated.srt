1
00:00:07,739 --> 00:00:12,228
未来的几个月里，你将面临大量的艰苦工作，一些简洁的 例子，

2
00:00:12,228 --> 00:00:15,168
一些不太简洁的例子，与物理的美妙联系，

3
00:00:15,168 --> 00:00:17,799
需要 记住的一堆不那么漂亮的公式，

4
00:00:17,799 --> 00:00:21,204
大量的卡住和敲打的时刻 当你把头撞到墙上时，

5
00:00:21,204 --> 00:00:25,073
也会有一些美好的顿悟时刻，还 有一些真正可爱的图形

6
00:00:25,073 --> 00:00:27,240
直觉来帮助指导你完成这一切。

7
00:00:27,630 --> 00:00:32,083
但是，如果您面前的课程类似于我的第一门微积分入门 课程，

8
00:00:32,083 --> 00:00:36,855
或者是我多年来见过的第一门课程，那么有一个 主题您不会看到，

9
00:00:36,855 --> 00:00:39,400
但我相信它会极大地加速您的学习。

10
00:00:40,280 --> 00:00:44,620
你看，第一年几乎所有的视觉直觉都是基于图表的。

11
00:00:45,080 --> 00:00:49,660
导数是图的斜率，积分是该图下方的某个区域。

12
00:00:50,200 --> 00:00:54,735
但是，当您将微积分推广到输入和输出只是数字的函数之 外时，

13
00:00:54,735 --> 00:00:58,020
并不总是能够绘制出您正在分析的函数的图表。

14
00:01:00,680 --> 00:01:04,991
因此，如果你对基本思想（如导数）的所有直觉都过于 

15
00:01:04,991 --> 00:01:09,302
严格地植根于图表，那么它可能会在你和更多引用不引 

16
00:01:09,302 --> 00:01:13,613
用的高级主题（如多变量微积分和复杂分析）之间造成 

17
00:01:13,613 --> 00:01:17,580
一个非常高且基本上不必要的概念障碍，微分几何。

18
00:01:18,840 --> 00:01:24,432
我想与您分享的是一种思考导数的方法， 我将其称为转换视图，

19
00:01:24,432 --> 00:01:29,640
它可以更无缝地推 广到微积分出现的一些更一般的环境中。

20
00:01:29,880 --> 00:01:34,860
然后我们将使用这个替代视图来分析一个关于重复分数的有趣谜题。

21
00:01:35,460 --> 00:01:39,660
但首先，我只是想确保我们对于 标准视觉效果的看法是一致的。

22
00:01:40,060 --> 00:01:45,197
如果你要绘制一个函数，它只是将实数作为输入和输 出，

23
00:01:45,197 --> 00:01:51,126
你在微积分课程中学到的第一件事就是导数给 出了这个图的斜率，

24
00:01:51,126 --> 00:01:55,078
我们的意思是该函数的导数是 一个新函数，

25
00:01:55,078 --> 00:01:58,240
它对于每个输入 x 返回该斜率。

26
00:01:59,520 --> 00:02:02,800
现在，我鼓励您不要将这种导数视为 斜率概念，

27
00:02:02,800 --> 00:02:04,440
而将其视为导数的定义。

28
00:02:05,000 --> 00:02:10,419
相反，从根本上将其视为函数对 输入周围微小推动的敏感程度。

29
00:02:11,020 --> 00:02:14,143
斜率只是考虑仅与这种特定的观察功 

30
00:02:14,143 --> 00:02:16,900
能方式相关的敏感性的一种方式。

31
00:02:17,340 --> 00:02:20,344
如果您想了解更多信息，我不仅有另一 个视频，

32
00:02:20,344 --> 00:02:22,120
还有关于该主题的完整系列。

33
00:02:22,600 --> 00:02:26,145
现在导数的替代视觉背后的基本思想 

34
00:02:26,145 --> 00:02:29,691
是将此函数视为将数轴上的所有输入 

35
00:02:29,691 --> 00:02:32,820
点映射到不同数轴上的相应输出。

36
00:02:33,400 --> 00:02:36,897
在这种情况下，导数为您提供的是输入空间 

37
00:02:36,897 --> 00:02:40,220
在各个区域中被拉伸或压缩的程度的度量。

38
00:02:41,859 --> 00:02:47,018
也就是说，如果您要放大特定输入并查看其周 

39
00:02:47,018 --> 00:02:51,932
围一些均匀分布的点，则该输入函数的导数 

40
00:02:51,932 --> 00:02:56,600
将告诉您这些点在映射后如何展开或收缩。

41
00:02:57,940 --> 00:02:59,400
在这里，一个具体的例子会有所帮助。

42
00:02:59,740 --> 00:03:02,535
以函数 x2 为例，它将 1 映射到 

43
00:03:02,535 --> 00:03:05,920
1、2 映射到 4、3 映射到 9，依此类推。

44
00:03:06,480 --> 00:03:13,260
您还可以看到它如何作用于中间的所有点。

45
00:03:13,260 --> 00:03:16,694
如果放大输入 1 周围的一小群点，

46
00:03:16,694 --> 00:03:20,331
并查看它们落在 相关输出周围的位置，

47
00:03:20,331 --> 00:03:23,160
您会注意到它们往往会被拉伸。

48
00:03:23,160 --> 00:03:27,820
事实上，它看起来大致相当于拉伸了 2 倍。

49
00:03:27,820 --> 00:03:35,000
放大得越近，这种局部行为看 起来就越像乘以 2 倍。

50
00:03:35,000 --> 00:03:41,820
这就是输入 x 等于 1 时 x2 的导数为 2 的含义。

51
00:03:42,340 --> 00:03:45,400
这就是这个事实在转型背景下的样子。

52
00:03:46,460 --> 00:03:52,160
如果您查看输入 3 周围的点 邻域，它们将被拉伸 6 倍。

53
00:03:52,740 --> 00:03:57,440
这就是该函数在输入 3 处的导数等于 6 的含义。

54
00:03:58,980 --> 00:04:04,928
在输入 1/4 附近，一个小区域往往会收缩 1/2，

55
00:04:04,928 --> 00:04:08,360
这就是导数小于 1 时的情况。

56
00:04:10,720 --> 00:04:12,600
输入 0 很有趣。

57
00:04:13,120 --> 00:04:17,959
放大 10 倍，它看起来 并不像持续拉伸或挤压。

58
00:04:18,380 --> 00:04:21,360
一方面，所有的输出最终都朝着积极的方向发展。

59
00:04:21,360 --> 00:04:29,670
当你放大得越来越近时，100 倍或 1000 倍，

60
00:04:29,670 --> 00:04:38,977
它看起来 越来越像 0 周围的点的一个小邻域刚刚折叠成 

61
00:04:38,977 --> 00:04:40,640
0 本身。

62
00:04:40,640 --> 00:04:43,300
这就是导数为 0 时的样子。

63
00:04:43,300 --> 00:04:47,040
局部行为看起来越来越像将整个数轴乘以 0。

64
00:04:47,040 --> 00:04:51,460
它不必将所有内容完全折叠到特定缩放级别的某个点，

65
00:04:51,460 --> 00:04:55,880
 而是当您放大得越来越近时限制行为是什么的问题。

66
00:04:55,880 --> 00:04:58,960
查看这里的负面输入也很有启发性。

67
00:05:00,700 --> 00:05:04,915
事情开始感觉有点局促，因为它们与所有正输入值的 

68
00:05:04,915 --> 00:05:08,780
去向发生冲突，这是将函数视为转换的缺点之一。

69
00:05:09,400 --> 00:05:12,157
但对于导数，我们只关心局部行为，

70
00:05:12,157 --> 00:05:15,260
即 给定输入周围小范围内发生的情况。

71
00:05:15,260 --> 00:05:21,016
在这里，请注意，在负数 2 附近的一个小邻 域中的输入，

72
00:05:21,016 --> 00:05:24,100
它们不仅会被拉伸，还会被翻转。

73
00:05:24,680 --> 00:05:28,460
具体来说，放大得越近，对这样一个邻 

74
00:05:28,460 --> 00:05:31,820
域的操作看起来就越像乘以负 4。

75
00:05:32,320 --> 00:05:38,900
这就是函数导数为负时的样子。

76
00:05:38,900 --> 00:05:41,352
我想你明白了，这一切都很好，但让 

77
00:05:41,352 --> 00:05:43,660
我们看看这在解决问题时有何用处。

78
00:05:44,260 --> 00:05:47,484
我的一个朋友最近问了我一个非常有趣的问题，

79
00:05:47,484 --> 00:05:51,476
关于无限分 数 1 加 1 除以 1 加 1 除以 

80
00:05:51,476 --> 00:05:55,161
1 加 1 除以 1，显然你在网上观看数学视频，

81
00:05:55,161 --> 00:05:59,153
所以也许你以前 看过这个，但是我朋友的问题实际上切入

82
00:05:59,153 --> 00:06:03,145
了你以前可能没 有想到的问题，与我们在这里讨论的衍生

83
00:06:03,145 --> 00:06:04,220
品的观点相关。

84
00:06:05,020 --> 00:06:09,945
计算这样的表达式的典型方法是将其设置为等于 x，

85
00:06:09,945 --> 00:06:13,640
然后注意到其内部存在完整分数的副本。

86
00:06:14,700 --> 00:06:18,780
因此，您可以用另一个 x 替换该副本，然后求解 x。

87
00:06:19,440 --> 00:06:22,258
也就是说，你想要的是找到函数 1 

88
00:06:22,258 --> 00:06:24,580
加 1 除以 x 的不动点。

89
00:06:27,160 --> 00:06:32,052
但问题是，x 实际上有两个解决方案，两个特殊数字 ，

90
00:06:32,052 --> 00:06:36,380
其中 1 加 1 除以该数字会得到相同的结果。

91
00:06:36,940 --> 00:06:41,229
一是黄金比例，phi，大约为 1。618，

92
00:06:41,229 --> 00:06:46,540
另一个为负0。618， 恰好是负 1 除以 phi。

93
00:06:46,960 --> 00:06:49,542
我喜欢将另一个数字称为 phi 的弟弟，

94
00:06:49,542 --> 00:06:52,900
因为几 乎 phi 具有的任何属性，这个数字也具有。

95
00:06:53,560 --> 00:06:58,580
这就提出了一个问题，我们看到的无限分数在某种程度 

96
00:06:58,580 --> 00:07:03,600
上也等于 phi 的弟弟负 0 是否有效。618？

97
00:07:04,520 --> 00:07:09,069
也许你一开始会说，显然不是，左边的所有内 容都是正数，

98
00:07:09,069 --> 00:07:11,260
那么它怎么可能等于负数呢？

99
00:07:12,500 --> 00:07:17,100
好吧，首先我们应该清楚这样的表达方式的实际含义。

100
00:07:17,780 --> 00:07:21,560
你可以考虑的一种方法是，这不是唯一的方法，

101
00:07:21,560 --> 00:07:26,419
这里有选择的自由 ，就是想象从一些常数开始，比如 1，

102
00:07:26,419 --> 00:07:30,739
然后重复应用函数 1 加 1 除以 x，然后问，

103
00:07:30,739 --> 00:07:33,260
什么你会继续采用这种方法吗？

104
00:07:36,040 --> 00:07:38,576
我的意思是，当然象征性地，你得到的看起来越 

105
00:07:38,576 --> 00:07:41,690
来越像我们的无限分数，所以也许如果你想等于 一个数字，

106
00:07:41,690 --> 00:07:43,420
你应该问这一系列数字接近什么。

107
00:07:45,120 --> 00:07:48,478
如果这就是你对事物的看法，也许你从一个负数开始 ，

108
00:07:48,478 --> 00:07:51,300
所以整个表达式最终变成负数并不是那么疯狂。

109
00:07:52,740 --> 00:07:55,883
毕竟，如果你从负 1 除以 phi 开始，

110
00:07:55,883 --> 00:07:58,876
然后应用这个函数，1 加 1 除以 x，

111
00:07:58,876 --> 00:08:02,020
你会得到相同的数字，负 1 除以 phi。

112
00:08:02,200 --> 00:08:05,040
因此，无论您应用多少次，您都会保持固定在该值。

113
00:08:05,040 --> 00:08:09,450
但即便如此，您仍然应该将 phi 视为 

114
00:08:09,450 --> 00:08:13,420
这一对中最喜欢的兄弟，原因是有一个。

115
00:08:14,020 --> 00:08:19,514
在这里，尝试一下，拉出某种计算器，然后从任意随机 数开始，

116
00:08:19,514 --> 00:08:22,924
将其插入到这个函数中，1加1除以x，

117
00:08:22,924 --> 00:08:28,040
然后 将该数字插入1加1除以x，如此反复，一次又一次。

118
00:08:28,480 --> 00:08:33,159
无论你从什么常数开始，最终都会得到 1。618. 

119
00:08:33,799 --> 00:08:38,599
即使你从一个负数开始，即使是一个非常接近 phi 

120
00:08:38,599 --> 00:08:43,400
的小兄弟的数字，最终它也会避开该值并跳回 phi。

121
00:08:50,819 --> 00:08:52,460
那么，这是怎么回事？

122
00:08:52,800 --> 00:08:55,920
为什么这些固定点之一比另一个更受青睐？

123
00:08:56,720 --> 00:09:01,732
也许您已经可以看到对导数的转换理解如何有 助于理解这种设置，

124
00:09:01,732 --> 00:09:05,074
但为了进行对比，我想向 您展示如何经常使

125
00:09:05,074 --> 00:09:07,080
用图表来教授这样的问题。

126
00:09:07,920 --> 00:09:11,582
如果您要向此函数插入一些随机输入，

127
00:09:11,582 --> 00:09:15,460
则 y 值会告诉您相应的输出，对吧？

128
00:09:15,460 --> 00:09:19,720
因此，要将输出插回到函数中，您可能首先水平移动，

129
00:09:19,720 --> 00:09:24,690
 直到到达 y 等于 x 的线，这将为您提供一个 位置，

130
00:09:24,690 --> 00:09:28,240
其中 x 值对应于之前的 y 值，对吧？

131
00:09:28,920 --> 00:09:33,241
然后从那里开始，您可以垂直移动以查看这个新的 

132
00:09:33,241 --> 00:09:38,879
x 值有什么输出，然后重复，水平移动到 y 等于 x 的线，

133
00:09:38,879 --> 00:09:43,201
找到一个 x 值与您刚刚获得的 输出相同的点，

134
00:09:43,201 --> 00:09:46,020
然后垂直移动以再次应用该功能。

135
00:09:46,020 --> 00:09:50,185
就我个人而言，我认为这是重复应用 函数的一种尴尬的方式，

136
00:09:50,185 --> 00:09:50,780
不是吗？

137
00:09:51,300 --> 00:09:54,982
我的意思是，这是有道理的，但你必须停 下来思考一下，

138
00:09:54,982 --> 00:09:56,540
以记住以哪种方式划线。

139
00:09:57,120 --> 00:10:01,394
如果你愿意，你可以思考什么条件使这个蜘蛛网 

140
00:10:01,394 --> 00:10:05,280
过程缩小到一个固定点，而不是远离它传播。

141
00:10:05,860 --> 00:10:08,900
事实上，继续吧，现在就停下来，尝试把它当作一个练习来思考。

142
00:10:09,240 --> 00:10:10,460
跟坡度有关系。

143
00:10:12,020 --> 00:10:17,473
或者，如果您想跳过练习来获得我认为可以提供更令 

144
00:10:17,473 --> 00:10:22,700
人满意的理解的内容，请考虑该函数如何充当转换。

145
00:10:22,700 --> 00:10:25,301
因此，我将从这里开始绘制一堆箭 

146
00:10:25,301 --> 00:10:27,740
头来指示各种采样输入点的去向。

147
00:10:28,320 --> 00:10:31,440
顺便说一句，您不认为这给出了一个简洁的涌现模式吗？

148
00:10:31,820 --> 00:10:35,740
我没想到会这样，但在制作动画时看到它弹出真是太酷了。

149
00:10:35,740 --> 00:10:39,064
1 除以 x 的作用给出了这个很好的紧急 循环，

150
00:10:39,064 --> 00:10:41,280
然后我们只需将其移动 1 即可。

151
00:10:42,040 --> 00:10:45,519
不管怎样，我想让你思考一下在这种情况下重复应用某 

152
00:10:45,519 --> 00:10:48,720
个函数意味着什么，比如 1 加 1 除以 x。

153
00:10:50,240 --> 00:10:53,641
好吧，在让它将所有输入映射到输出之后，

154
00:10:53,641 --> 00:10:58,297
您可 以将它们视为新输入，然后再次应用相同的过 程，

155
00:10:58,297 --> 00:11:01,520
然后再一次，并执行您想要的任意次数。

156
00:11:02,580 --> 00:11:06,348
请注意，在使用代表样本点的几个点进行动画处理时，

157
00:11:06,348 --> 00:11:09,331
在所有这 些点都聚集在 1 左右之前，

158
00:11:09,331 --> 00:11:12,000
根本不需要进行多次迭代。618. 

159
00:11:14,620 --> 00:11:19,055
现在记住，我们知道 1。618和它的弟弟，负0。

160
00:11:19,055 --> 00:11:23,860
618 不断 ，在此过程的每次迭代期间保持固定到位。

161
00:11:24,860 --> 00:11:27,480
但放大 phi 周围的邻域。

162
00:11:27,480 --> 00:11:32,566
在映射期间，该区域中的点围绕 phi 收缩，

163
00:11:32,566 --> 00:11:36,496
这意味着函数 1 加 1 在 x 

164
00:11:36,496 --> 00:11:41,120
上的导数在此输入处具有小于 1 的幅度。

165
00:11:41,880 --> 00:11:45,200
事实上，该导数的结果约为负 0。38. 

166
00:11:46,120 --> 00:11:50,432
所以这意味着每次重复的应用都会将这个数字周围的邻 

167
00:11:50,432 --> 00:11:54,400
域压缩得越来越小，就像对 phi 的引力一样。

168
00:11:54,959 --> 00:11:58,620
现在，告诉我你认为在 phi 的弟弟附近会发生什么。

169
00:12:01,320 --> 00:12:08,920
在那里，导数的大小大于 1， 因此固定点附近的点会被排斥。

170
00:12:09,520 --> 00:12:11,724
当你计算出来时，你会发现它们在每 

171
00:12:11,724 --> 00:12:13,800
次迭代中都被拉伸了 2 倍以上。

172
00:12:14,420 --> 00:12:17,630
它们也会被翻转，因为这里的导数是负的，

173
00:12:17,630 --> 00:12:20,840
 但为了稳定性，最重要的事实就是大小。

174
00:12:23,440 --> 00:12:29,360
数学家将这个右值称为稳定不动 点，而左值称为不稳定不动点。

175
00:12:30,000 --> 00:12:33,962
如果当你稍微扰动它时，一切都会回到原来的位 置，

176
00:12:33,962 --> 00:12:37,100
而不是远离它，那么它就被认为是稳定的。

177
00:12:38,180 --> 00:12:42,060
所以我们看到的是一个非常有用的 小事实，

178
00:12:42,060 --> 00:12:47,300
即定点的稳定性取决于其 导数的大小是否大于或小于 1。

179
00:12:47,300 --> 00:12:50,640
这解释了为什么 phi 总是出现在数字游戏中，

180
00:12:50,640 --> 00:12:54,271
您只需一遍又一遍地 在计算器上按 Enter 键，

181
00:12:54,271 --> 00:12:56,740
但 phi 的弟弟却从来不这样做。

182
00:12:56,740 --> 00:13:02,880
您是否想将 phi 的弟弟视 为无限分数的有效值取决于您。

183
00:13:03,260 --> 00:13:06,987
我们刚刚展示的所有内容都表明，如果您认为这个表达式 

184
00:13:06,987 --> 00:13:10,715
代表一个极限过程，那么因为除了 phi 的弟弟之外 

185
00:13:10,715 --> 00:13:14,872
的每个可能的种子值都会为您提供一个收敛于 phi 的级数，

186
00:13:14,872 --> 00:13:17,740
因此将它们置于平等的地位确实感觉很愚蠢。

187
00:13:18,260 --> 00:13:21,975
但也许您不认为它是一个限制，也许您正在 

188
00:13:21,975 --> 00:13:25,876
做的数学运算适合将其视为纯粹的代数对象 ，

189
00:13:25,876 --> 00:13:29,220
就像多项式的解一样，它只具有多个值。

190
00:13:30,340 --> 00:13:34,560
无论如何，这不是重点，我在这里的观点并不是认为观察导数，

191
00:13:34,560 --> 00:13:38,780
 因为密度的这种变化在某种程度上比整体上的图形直觉更好。

192
00:13:39,600 --> 00:13:42,331
事实上，与图表相比，以这种方式描绘 

193
00:13:42,331 --> 00:13:44,760
整个函数可能有点笨拙且不切实际。

194
00:13:45,339 --> 00:13:48,674
我的观点是，在大多数微积分入门课程中，

195
00:13:48,674 --> 00:13:53,940
它值得更多 地提及，因为它可以帮助学生对导数的理解更加灵活。

196
00:13:54,900 --> 00:13:58,419
就像我提到的，我建议您在学习新主题时随身携带 

197
00:13:58,419 --> 00:14:01,786
这种观点的真正原因并不是因为它对您对单变量 

198
00:14:01,786 --> 00:14:05,000
微积分的理解有何帮助，而是为了之后的内容。

