1
00:00:00,000 --> 00:00:11,880
これから数か月は、たくさんの大変な作業、いくつかのきちんとした例、いくつかのあ

2
00:00:11,880 --> 00:00:16,160
まりきちんとしていない例、物理学との美しいつながり、それほど美しくはない数式の

3
00:00:16,160 --> 00:00:20,440
暗記の山、行き詰まったりバタンキューしたりする瞬間がたくさんあるでしょう。壁

4
00:00:20,440 --> 00:00:25,580
に頭を打ち付けたり、いくつかの素敵な「なるほど」の瞬間も散りばめられており、す

5
00:00:25,580 --> 00:00:27,840
べてを乗り越えるのに役立つ本当に美しいグラフィックの直感がいくつかあります。

6
00:00:27,840 --> 00:00:31,880
しかし、これからあなたが受けるコースが、私の最初の微積分入門のようなものである場合、ま

7
00:00:31,880 --> 00:00:36,060
たはそれ以来数年間に私が受講した最初のコースのいずれかである場合、あなたには見られない

8
00:00:36,060 --> 00:00:40,300
トピックが 1 つありますが、これはあなたの学習を大幅に加速すると私は信じています。

9
00:00:40,300 --> 00:00:45,080
ご存知のとおり、最初の 1 年間の視覚的直観のほとんどはグラフに基づいています。

10
00:00:45,080 --> 00:00:50,320
微分値はグラフの傾きであり、積分値はそのグラフの下の特定の領域です。

11
00:00:50,320 --> 00:00:54,800
しかし、入力と出力が単なる数値である関数を超えて微積分を一般

12
00:00:54,800 --> 00:01:01,580
化すると、分析している関数をグラフ化できるとは限りません。

13
00:01:01,580 --> 00:01:06,220
したがって、導関数などの基本的なアイデアに対するすべての直観があ

14
00:01:06,220 --> 00:01:11,100
まりにも厳密にグラフに根ざしている場合、多変数微積分や複雑な解析

15
00:01:11,100 --> 00:01:16,620
などの、引用と引用のない高度なトピックとの間に非常に高く、ほとん

16
00:01:16,620 --> 00:01:19,040
ど不必要な概念的ハードルが生じる可能性があります。微分幾何学。

17
00:01:19,040 --> 00:01:22,260
私が皆さんと共有したいのは、微分積分について考える方法です

18
00:01:22,260 --> 00:01:27,480
。これを、微分積分が登場するより一般的なコンテキストのいく

19
00:01:27,480 --> 00:01:30,020
つかに、よりシームレスに一般化する変換ビューと呼びます。

20
00:01:30,020 --> 00:01:35,600
次に、この代替ビューを使用して、分数の繰り返しに関する楽しいパズルを分析します。

21
00:01:35,600 --> 00:01:38,900
ただし、最初に、標準のビジュアルとは何かについて、全

22
00:01:38,900 --> 00:01:40,160
員が同じ認識を持っていることを確認したいと思います。

23
00:01:40,160 --> 00:01:44,840
単純に実数を入力と出力として受け取る関数のグラフを作成する場合、微

24
00:01:44,840 --> 00:01:48,640
積分のコースで最初に学ぶことの 1 つは、導関数によってこのグラ

25
00:01:48,640 --> 00:01:54,140
フの傾きが得られるということです。これが意味するところは、関数の導

26
00:01:54,140 --> 00:01:59,540
関数は、すべての入力 x に対してその傾きを返す新しい関数です。

27
00:01:59,540 --> 00:02:03,740
ここで、この導関数を勾配のアイデアとして導関

28
00:02:03,740 --> 00:02:05,240
数の定義として考えないことをお勧めします。

29
00:02:05,240 --> 00:02:09,100
むしろ、入力の周りの小さな微調整に対して関数がどの程度敏感で

30
00:02:09,100 --> 00:02:11,060
あるかについての、より根本的なものであると考えてください。

31
00:02:11,060 --> 00:02:15,740
そして、傾きは、関数のこの特定の見方にのみ関連する感

32
00:02:15,740 --> 00:02:17,480
度について考えるための 1 つの方法にすぎません。

33
00:02:17,480 --> 00:02:20,900
さらに詳しく知りたい場合は、別のビデオではなく、この

34
00:02:20,900 --> 00:02:22,100
トピックに関する完全なシリーズをご用意しています。

35
00:02:22,100 --> 00:02:27,060
ここで、導関数の代替ビジュアルの背後にある基本的な考

36
00:02:27,060 --> 00:02:31,580
え方は、この関数を数直線上のすべての入力点を別の数直

37
00:02:31,580 --> 00:02:33,020
線上の対応する出力にマッピングすると考えることです。

38
00:02:33,020 --> 00:02:37,340
このコンテキストでは、導関数によって得られるのは、入力空間がさまざまな

39
00:02:37,340 --> 00:02:42,380
領域でどの程度引き伸ばされたり押しつぶされたりするかを示す尺度です。

40
00:02:42,380 --> 00:02:47,220
つまり、特定の入力の周囲をズームインし、その周囲に等間隔に配置された

41
00:02:47,240 --> 00:02:53,560
点をいくつか確認すると、その入力の関数の導関数によって、マッピング

42
00:02:53,560 --> 00:02:57,200
後にそれらの点がどのように広がるか、または縮小するかがわかります。

43
00:02:57,200 --> 00:02:59,840
ここで、具体的な例を見てみましょう。

44
00:02:59,840 --> 00:03:06,720
関数 x2 を例に挙げると、1 から 1、2 から 4、3 から 9 などにマッピングされます。

45
00:03:06,720 --> 00:03:12,960
また、その間のすべてのポイントにどのように作用するかも確認できます。

46
00:03:12,980 --> 00:03:18,540
入力 1 の周りの小さな点のクラスターを拡大して、それらが関連する出力の周りでど

47
00:03:18,540 --> 00:03:25,300
こに到達するかを確認すると、それらが引き伸ばされる傾向があることがわかります。

48
00:03:25,300 --> 00:03:29,700
実際には、おおよそ 2 倍に引き伸ばされたように見えます。

49
00:03:29,700 --> 00:03:34,860
ズームインすると、このローカルな動作が

50
00:03:34,860 --> 00:03:36,500
2 倍になっているように見えます。

51
00:03:36,500 --> 00:03:41,900
これは、入力 x が 1 に等しい場合の x2 の導関数が 2 になることを意味します。

52
00:03:41,920 --> 00:03:46,480
それは、変革の文脈においてその事実がどのように見えるかです。

53
00:03:46,480 --> 00:03:50,780
入力 3 の周囲の点の近傍を見ると、

54
00:03:50,780 --> 00:03:52,800
それらは 6 倍に引き伸ばされます。

55
00:03:52,800 --> 00:03:59,240
これは、入力 3 でのこの関数の導関数が 6 に等しいことを意味します。

56
00:03:59,240 --> 00:04:05,720
入力の 1/4 付近では、小さな領域が 1/2 に縮小される傾

57
00:04:05,720 --> 00:04:11,120
向があり、導関数が 1 より小さくなるのはこのようになります。

58
00:04:11,140 --> 00:04:13,300
入力 0 は興味深いものです。

59
00:04:13,300 --> 00:04:17,580
10 倍に拡大すると、継続的に伸びたり押し

60
00:04:17,580 --> 00:04:18,580
つぶされたりしているようには見えません。

61
00:04:18,580 --> 00:04:23,380
まず、すべての出力が最終的に物事の正しいプラス面に反映されます。

62
00:04:23,380 --> 00:04:29,060
100 倍、または 1000 倍とどんどんズームインしていくと、0 の

63
00:04:29,060 --> 00:04:34,660
周囲の小さな点の近傍が 0 自体に折りたたまれているように見えます。

64
00:04:37,780 --> 00:04:40,500
導関数が 0 になると次のようになります。

65
00:04:40,520 --> 00:04:45,720
ローカルの動作は、整数直線に 0 を乗算するように見えてきます。

66
00:04:45,720 --> 00:04:50,040
特定のズーム レベルですべてをある点まで完全に折りたたむ必要はありません。代わりに、

67
00:04:50,040 --> 00:04:54,560
ズームインをどんどん近づけていくと、どのような動作が制限されるかが問題になります。

68
00:04:54,560 --> 00:05:01,120
ここでネガティブなインプットに注目することも有益です。

69
00:05:01,120 --> 00:05:04,360
すべての正の入力値が入る場所と衝突するため、物事は少し窮屈に感じられ

70
00:05:04,360 --> 00:05:09,400
始めます。これは、関数を変換として考えることの欠点の 1 つです。

71
00:05:09,420 --> 00:05:13,540
しかし、導関数の場合、私たちが実際に気にするのはとにかくローカル

72
00:05:13,540 --> 00:05:16,260
な動作、つまり特定の入力の周囲の狭い範囲で何が起こるかだけです。

73
00:05:16,260 --> 00:05:21,460
ここで、たとえばマイナス 2 付近の小さな入力が引き伸

74
00:05:21,460 --> 00:05:24,580
ばされるだけでなく、反転されることに注目してください。

75
00:05:24,580 --> 00:05:29,900
具体的には、ズームインすると、そのような近傍に対するアクシ

76
00:05:29,900 --> 00:05:32,260
ョンは、ますますマイナス 4 を乗算するように見えます。

77
00:05:32,260 --> 00:05:36,140
関数の導関数が負になる場合は次のようになります。

78
00:05:36,140 --> 00:05:42,720
これで要点は理解できたと思いますが、これが問

79
00:05:42,720 --> 00:05:44,240
題解決にどのように役立つかを見てみましょう。

80
00:05:44,240 --> 00:05:48,520
最近、私の友人が、無限分数 1 プラス 1 割る 1 プラス 1 割る 1 プ

81
00:05:48,520 --> 00:05:54,960
ラス 1 割る 1 についてのとても楽しい質問をしてくれました。オンラインで数

82
00:05:54,960 --> 00:05:58,860
学のビデオを見ているのは明らかなので、おそらくこれを以前に見たことがあるかもし

83
00:05:58,860 --> 00:06:03,120
れませんが、私の友人の質問は、実際には、ここで見ているデリバティブの見方に関連

84
00:06:03,120 --> 00:06:05,040
する、あなたがこれまで考えたこともなかったかもしれないことに切り込んでいます。

85
00:06:05,040 --> 00:06:10,100
このような式を評価する一般的な方法は、それを x と等しく設

86
00:06:10,100 --> 00:06:15,160
定し、その中に完全な分数のコピーがあることに気づくことです。

87
00:06:15,160 --> 00:06:19,300
したがって、そのコピーを別の x に置き換えて、x を求めるだけです。

88
00:06:19,300 --> 00:06:24,080
つまり、関数 1 プラス 1 を x で

89
00:06:24,080 --> 00:06:27,620
割った不動点を見つけることが必要です。

90
00:06:27,620 --> 00:06:32,920
しかし、問題はここにあります。x には実際には 2 つの解があり、1 プ

91
00:06:32,920 --> 00:06:37,200
ラス 1 をその数値で割ると同じ結果が得られる 2 つの特別な数値です。

92
00:06:37,200 --> 00:06:44,740
1 つは黄金比、ファイ、約 1 です。618、もう 1 つはマイナスの 0 です。618、これ

93
00:06:44,740 --> 00:06:46,940
はたまたま負の 1 をファイで割った値になります。

94
00:06:46,940 --> 00:06:51,000
私はこのもう 1 つの番号をファイの弟と呼びたいと思います

95
00:06:51,000 --> 00:06:53,740
。ファイが持つほぼすべての特性がこの番号にもあるからです。

96
00:06:53,740 --> 00:06:57,820
そして、これは、私たちが見た無限の分数がどういうわけかファイの弟であるマイ

97
00:06:57,820 --> 00:07:04,840
ナスの 0 にも等しいと言うのは妥当なのかという疑問を引き起こします。618?

98
00:07:04,840 --> 00:07:09,460
おそらく最初は、明らかにそうではありませんが、左側にあるものは

99
00:07:09,460 --> 00:07:12,120
すべて正であるのに、どうして負の数に等しくなるのでしょうか?

100
00:07:12,120 --> 00:07:17,980
まず、このような表現が実際に何を意味するのかを明確にする必要があります。

101
00:07:17,980 --> 00:07:21,040
これについて考える方法の 1 つは、これが唯一の方法ではありませんが、ここでは選択の自由が

102
00:07:21,040 --> 00:07:26,680
あります。まず、1 などの定数から始めて、関数 1 プラス 1 を x で割った関数を繰り

103
00:07:26,680 --> 00:07:34,100
返し適用し、次に何を尋ねるかを考えることです。このアプローチは今後も継続していきますか？

104
00:07:34,100 --> 00:07:39,900
つまり、確かに象徴的に、得られるものは無限の分数にますます

105
00:07:39,900 --> 00:07:42,940
似てきます。そのため、数値を等しくしたい場合は、この一連の

106
00:07:42,940 --> 00:07:45,340
数値がどのように近づくかを尋ねる必要があるかもしれません。

107
00:07:45,340 --> 00:07:48,820
そして、それがあなたの見方であるなら、負の数から始めるかもしれないの

108
00:07:48,820 --> 00:07:53,220
で、式全体が負の値になることはそれほどおかしなことではありません。

109
00:07:53,220 --> 00:07:58,240
結局のところ、負の 1 をファイで割った値から始めて、この関数 (1 プラス 1

110
00:07:58,240 --> 00:08:02,400
を x に加える) を適用すると、負の 1 をファイで割った同じ数値が返されます。

111
00:08:02,400 --> 00:08:07,980
したがって、何度適用しても、この値は固定されたままになります。

112
00:08:07,980 --> 00:08:12,620
しかしそれでも、おそらくファイをこのペアのお気

113
00:08:12,620 --> 00:08:13,620
に入りの兄弟とみなすべき理由が1つあります。

114
00:08:13,620 --> 00:08:18,960
これを試してみてください。何らかの計算機を起動して、任意の乱数から始

115
00:08:18,960 --> 00:08:24,380
めて、この関数に代入します。1 プラス 1 を x で割って、その数

116
00:08:24,380 --> 00:08:28,860
値を 1 プラス 1 に x を掛けて代入します。 、何度も何度も。

117
00:08:28,860 --> 00:08:34,080
どのような定数から始めても、最終的には 1 になります。618.

118
00:08:34,080 --> 00:08:38,060
負の数から始めたとしても、それがファイの弟に非常に近い値

119
00:08:38,060 --> 00:08:43,300
であっても、最終的にはその値を避けてファイに戻ります。

120
00:08:48,960 --> 00:08:52,840
それで、ここで何が起こっているのでしょうか？

121
00:08:52,840 --> 00:08:56,740
なぜこれらの固定点の 1 つが他の固定点よりも優先されるのでしょうか?

122
00:08:56,740 --> 00:09:00,700
おそらく、導関数の変換的理解がこの設定を理解するのにどのように役立つかはすで

123
00:09:00,700 --> 00:09:04,360
にお分かりいただけたかと思いますが、対照的な点を持たせるために、このような問

124
00:09:04,360 --> 00:09:07,920
題がグラフを使用してどのように教えられることが多いかを示したいと思います。

125
00:09:07,920 --> 00:09:13,040
この関数にランダムな入力を接続すると、y

126
00:09:13,040 --> 00:09:14,980
値によって対応する出力がわかります。

127
00:09:14,980 --> 00:09:21,060
その出力を関数に戻すには、まず y が x に等し

128
00:09:21,060 --> 00:09:26,480
い行に達するまで水平に移動します。そうすると、x

129
00:09:26,480 --> 00:09:28,980
の値が前の y の値に対応する位置が得られます。

130
00:09:28,980 --> 00:09:35,260
そこで、そこから垂直方向に移動して、この新しい x 値がどのよう

131
00:09:35,260 --> 00:09:39,560
な出力になるかを確認します。それから繰り返し、y が x に等

132
00:09:39,560 --> 00:09:43,860
しい線まで水平方向に移動して、x 値が先ほど取得した出力と同じで

133
00:09:43,860 --> 00:09:45,340
ある点を見つけます。次に、垂直に移動して機能を再度適用します。

134
00:09:45,340 --> 00:09:50,380
個人的には、関数を繰り返し適用する

135
00:09:50,380 --> 00:09:51,380
という考え方は厄介だと思います。

136
00:09:51,380 --> 00:09:55,780
つまり、それは理にかなっていますが、線を引く方法を

137
00:09:55,780 --> 00:09:56,780
思い出すには、立ち止まって考える必要があります。

138
00:09:56,780 --> 00:10:02,100
そして、必要に応じて、どのような条件によってこのクモの巣のプロセスが

139
00:10:02,100 --> 00:10:05,460
固定点に狭まり、固定点から遠ざかっていくのかを考えることができます。

140
00:10:05,460 --> 00:10:09,460
実際、さあ、今すぐ立ち止まって、練習としてじっくり考えてみてください。

141
00:10:09,460 --> 00:10:12,380
それは斜面と関係があります。

142
00:10:12,380 --> 00:10:16,020
または、より満足のいく理解が得られると思われる演習をスキップしたい

143
00:10:16,020 --> 00:10:20,020
場合は、この関数が変換としてどのように機能するかを考えてください。

144
00:10:20,020 --> 00:10:26,140
そこで、ここでは、さまざまなサンプリングされた入力ポイントが

145
00:10:26,140 --> 00:10:28,260
どこに行くのかを示すために、矢印の束を描くことから始めます。

146
00:10:28,260 --> 00:10:31,860
余談ですが、これはきちんとした出現パターンを示していると思いませんか?

147
00:10:31,860 --> 00:10:35,820
これは期待していませんでしたが、アニメーション中にポップアップするのを見るのはクールでした。

148
00:10:35,820 --> 00:10:40,220
1 を x で割ったアクションにより、この素晴らしい創発的

149
00:10:40,220 --> 00:10:41,500
な円が得られます。その後、物事を 1 つずらすだけです。

150
00:10:41,620 --> 00:10:46,220
とにかく、この文脈で、x に対して 1 プラス 1 などの関数

151
00:10:46,220 --> 00:10:49,180
を繰り返し適用することが何を意味するのかを考えてほしいのです。

152
00:10:49,180 --> 00:10:54,940
すべての入力を出力にマッピングさせた後、そ

153
00:10:54,940 --> 00:11:00,620
れらを新しい入力とみなして、同じプロセス

154
00:11:00,620 --> 00:11:03,140
を何度も繰り返し適用することができます。

155
00:11:03,140 --> 00:11:07,540
サンプル ポイントを表すいくつかのドットを使用してこれをアニメーション化すると、これらのドット

156
00:11:07,580 --> 00:11:14,660
がすべて 1 程度に固まるまで、それほど多くの反復を必要としないことに注目してください。618.

157
00:11:14,660 --> 00:11:21,580
ここで、1 を知っていることを思い出してください。618 とその弟分、マイナス 0。618 以降、この

158
00:11:21,580 --> 00:11:24,940
プロセスの各反復中、所定の位置に固定されたままになります。

159
00:11:24,940 --> 00:11:28,500
しかし、ファイの周囲を拡大してみましょう。

160
00:11:28,500 --> 00:11:34,900
マップ中に、その領域内の点はファイの周りで収縮します。これは、x に対する関数 1

161
00:11:34,900 --> 00:11:41,940
プラス 1 が、この入力で 1 より小さい大きさの導関数を持つことを意味します。

162
00:11:41,940 --> 00:11:46,180
実際、この導関数はマイナス 0 付近になることがわかります。38.

163
00:11:46,180 --> 00:11:50,900
これが意味するのは、アプリケーションを繰り返すたびに、ファイに向かう重力の

164
00:11:50,900 --> 00:11:55,340
ように、この数値の周囲の近傍がどんどん小さくなってしまうということです。

165
00:11:55,340 --> 00:12:01,420
それで今、ファイの弟の近所で何が起こっていると思うかを教えてください。

166
00:12:01,420 --> 00:12:07,300
そこでは導関数の大きさが 1 より大きいため

167
00:12:07,300 --> 00:12:09,660
、固定点に近い点は固定点から遠ざけられます。

168
00:12:09,660 --> 00:12:12,500
計算してみると、反復ごとに 2 倍以上

169
00:12:12,500 --> 00:12:14,460
引き伸ばされていることがわかります。

170
00:12:14,460 --> 00:12:18,740
ここでは導関数が負であるため、それらも反転します

171
00:12:18,740 --> 00:12:23,420
が、安定性のための重要な事実は大きさだけです。

172
00:12:23,420 --> 00:12:27,940
数学者はこの右側の値を安定した不動点、

173
00:12:27,940 --> 00:12:30,180
左側の値を不安定な不動点と呼びます。

174
00:12:30,180 --> 00:12:33,660
すべてを少しだけ混乱させたときに、そこから離れるのではなく、最初

175
00:12:33,660 --> 00:12:38,220
の場所に戻る傾向がある場合、すべては安定していると見なされます。

176
00:12:38,220 --> 00:12:42,540
つまり、私たちが見ているのは、固定点の安定性はそ

177
00:12:42,540 --> 00:12:47,220
の導関数の大きさが 1 より大きいか小さいかによ

178
00:12:47,220 --> 00:12:48,220
って決まるという、非常に有益な小さな事実です。

179
00:12:48,220 --> 00:12:51,800
これは、計算機で Enter キーを何度も押すだけの数値遊びでファイが

180
00:12:51,800 --> 00:12:56,580
常に登場するのに、ファイの弟は決して登場しない理由を説明しています。

181
00:12:56,580 --> 00:12:59,780
ファイの弟を無限分数の有効な値と

182
00:12:59,780 --> 00:13:03,520
みなすかどうかはあなた次第です。

183
00:13:03,520 --> 00:13:07,280
これまで示したすべてのことから、この式が限界プロセスを表

184
00:13:07,280 --> 00:13:12,340
すものと考えると、ファイの弟以外の考えられるすべてのシー

185
00:13:12,340 --> 00:13:17,080
ド値がファイに収束する系列を与えるため、それらを互いに同

186
00:13:17,080 --> 00:13:18,420
等の立場に置くのは愚かに感じられることがわかります。 。

187
00:13:18,420 --> 00:13:22,340
しかし、おそらくあなたはそれを限界とは考えておらず、おそらくあなた

188
00:13:22,340 --> 00:13:27,380
が行っている数学の種類は、これを単に複数の値を持つ多項式の解のよう

189
00:13:27,380 --> 00:13:29,700
な純粋な代数オブジェクトとして扱うのに適しているのかもしれません。

190
00:13:29,700 --> 00:13:34,400
とにかく、それは重要ではありません。そして、ここで私が言いたいのは、この密度の変化として導関数を観察

191
00:13:34,400 --> 00:13:39,620
することの方が、全体としてグラフィカルな直観よりも何らかの形で優れているということではありません。

192
00:13:39,620 --> 00:13:43,680
実際、この方法で関数全体を描くのは、グラフに比べ

193
00:13:43,680 --> 00:13:45,480
てやや不格好で非現実的になる可能性があります。

194
00:13:45,480 --> 00:13:50,160
私が言いたいのは、これは微積分の入門コースのほとんどでもっと言及される価値があるという

195
00:13:50,160 --> 00:13:55,000
ことです。なぜなら、微積分についての学生の理解をもう少し柔軟にするのに役立つからです。

196
00:13:55,000 --> 00:13:59,040
先ほども述べたように、新しいトピックを学ぶときにこの視

197
00:13:59,040 --> 00:14:03,320
点を持ち歩くことをお勧めする本当の理由は、単一変数微積

198
00:14:03,320 --> 00:14:05,520
分の理解に役立つというよりも、その後のことのためです。

