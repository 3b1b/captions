1
00:00:04,300 --> 00:00:07,680
我觉得你们会喜欢这个的 我想展示一个美妙的结果

2
00:00:07,720 --> 00:00:12,440
其揭示了一系列简单的分数与圆的几何之间出人意料的联系

3
00:00:12,880 --> 00:00:16,200
但是与你们之前看到的其他结论不同

4
00:00:18,140 --> 00:00:20,500
这次把它们乘起来

5
00:00:20,560 --> 00:00:22,180
而不是把它们加起来

6
00:00:22,180 --> 00:00:26,580
你将要看的视频对于我们3B1B是很激动人心的

7
00:00:26,580 --> 00:00:29,940
因为其起因与之前的大多数视频有一点不同

8
00:00:29,980 --> 00:00:31,660
如果你退一步思考一下

9
00:00:31,660 --> 00:00:34,440
任何数学展示的价值

10
00:00:34,440 --> 00:00:40,420
来自其数学原理和有助于交流的一些选择

11
00:00:40,600 --> 00:00:43,080
这个频道的几乎所有内容

12
00:00:43,100 --> 00:00:45,820
其数学原理在圈内都是众所周知的

13
00:00:45,820 --> 00:00:49,300
基于普遍理论或一些专门的论文

14
00:00:49,300 --> 00:00:52,560
我希望这些视频能在交流的部分带来一些新的东西

15
00:00:53,060 --> 00:00:55,800
在这个视频中，我们讨论的

16
00:00:55,800 --> 00:00:58,540
一个非常著名的pi的无穷乘积表示，称为Wallis公式

17
00:00:58,640 --> 00:01:00,320
确实是广为人知

18
00:01:00,640 --> 00:01:03,800
但是我们要展示的，据我们所知，

19
00:01:03,805 --> 00:01:05,975
是这个结论的更原创性的证明

20
00:01:06,545 --> 00:01:09,455
交代一下，Sweeter在看了我们关于Basil问题的视频之后

21
00:01:09,455 --> 00:01:11,795
（Sweeter是我们的新成员）

22
00:01:11,800 --> 00:01:15,200
（你们如果看过色彩和卷绕数视频，可能还记得他）

23
00:01:15,540 --> 00:01:18,960
他花了一点时间思考那个视频所用的方法

24
00:01:18,960 --> 00:01:23,160
以及Basil问题和Wallis公式的联系

25
00:01:23,500 --> 00:01:27,720
结果他偶然就得到了一个关于Wallis公式和Pi的联系的证明

26
00:01:28,500 --> 00:01:34,520
我不排除证明方法可能隐藏在我们搜索不到的文献中

27
00:01:34,860 --> 00:01:37,560
但我至少能说这是独立发现的

28
00:01:37,560 --> 00:01:42,880
如果这个方法真的在文献中存在，我只能说藏的够深的

29
00:01:43,500 --> 00:01:46,220
话不多说，跳入数学

30
00:01:48,880 --> 00:01:54,760
考虑2/1 * 4/3 * 6/5 * ... 不停下去

31
00:01:55,100 --> 00:01:58,120
我们做的是把所有的偶数作为分子

32
00:01:58,120 --> 00:02:00,140
所有奇数作为分母

33
00:02:00,600 --> 00:02:03,280
当然了，这里每一项都大于1

34
00:02:03,280 --> 00:02:07,280
当你一项一项地乘下去

35
00:02:07,500 --> 00:02:09,740
乘积就会越来越大

36
00:02:09,980 --> 00:02:14,120
实际上，这个乘积会最终大于任何有限的数字

37
00:02:14,540 --> 00:02:18,000
在这个意义上，这并不是很有趣，它只是膨胀到无穷而已

38
00:02:18,500 --> 00:02:21,240
另一方面，如果你把数字整体移动一下

39
00:02:21,240 --> 00:02:26,460
观察2/3 * 4/5 * 6/7 * ...

40
00:02:26,800 --> 00:02:31,140
这里每一项都小于1，因此乘积变得越来越小

41
00:02:31,340 --> 00:02:33,800
而且实际上这次乘积是趋向0的

42
00:02:34,260 --> 00:02:36,340
但是，如果把这两个乘积混合一下

43
00:02:36,700 --> 00:02:43,600
观察2/1 * 2/3 * 4/3 * 4/5 * ...

44
00:02:43,600 --> 00:02:48,940
现在部分积不停地增加，减少，增加，减少

45
00:02:48,940 --> 00:02:51,300
增加一点点，减少更小一点点

46
00:02:51,300 --> 00:02:54,920
直到这些涨落几乎看不出来

47
00:02:55,340 --> 00:02:59,280
因此这个乘积应该是收敛到一个有限值的

48
00:02:59,620 --> 00:03:01,300
但这个值是多少？

49
00:03:01,900 --> 00:03:06,200
信不信由你，我们会发现它等于pi/2

50
00:03:06,700 --> 00:03:11,520
为了理解这个显然与圆无关的乘积与pi的联系

51
00:03:11,640 --> 00:03:16,280
我们要稍稍的绕个弯路，使用一些几何工具，但这是很有用的

52
00:03:16,460 --> 00:03:20,940
对于各种数学问题，这些想法都是有力的解题工具

53
00:03:25,980 --> 00:03:31,040
这里的布置是一个圆（译注：半径为1），以及圆周上等距分布的许多点

54
00:03:31,200 --> 00:03:33,060
圆周上还有另外一个特殊点

55
00:03:33,060 --> 00:03:35,800
这跟Basil问题的视频差不多

56
00:03:35,800 --> 00:03:41,480
那个视频里我们把等距分布的点当作灯塔，把特殊点当作观察者

57
00:03:41,900 --> 00:03:47,880
那时我们关注的是每个灯塔到观察者的距离

58
00:03:48,220 --> 00:03:52,760
取这些距离的倒数平方，再加起来

59
00:03:52,920 --> 00:03:56,120
之所以一开始要把它们当成灯塔

60
00:03:56,120 --> 00:04:01,340
是因为物理中的平方反比定律很好地解释了这个量：

61
00:04:01,340 --> 00:04:04,860
即观察者接收到的光的总量

62
00:04:05,860 --> 00:04:08,300
尽管有这个很好的物理解释

63
00:04:08,300 --> 00:04:11,420
把距离的倒数平方相加并没有什么神奇

64
00:04:11,420 --> 00:04:14,700
这只是刚好对这个特定问题（Basil问题）有帮助而已

65
00:04:14,880 --> 00:04:17,705
现在要处理新的问题

66
00:04:17,705 --> 00:04:21,420
2/1 * 2/3 * 4/3 * 4/5 * ...

67
00:04:21,580 --> 00:04:24,240
我们要用类似但细节上不同的方法

68
00:04:24,600 --> 00:04:27,260
不需要把距离平方取倒数

69
00:04:27,260 --> 00:04:29,720
现在只看距离本身

70
00:04:30,200 --> 00:04:33,500
而且我们要把它们乘起来而不是加起来

71
00:04:33,640 --> 00:04:39,280
得到一个量，我们称为观察者的距离乘积，后面会很重要

72
00:04:39,700 --> 00:04:43,820
尽管这个距离乘积不再有很好的物理类比

73
00:04:43,900 --> 00:04:47,180
我还是想用灯塔和观察者来描绘

74
00:04:47,180 --> 00:04:52,660
可能是因为比较好看吧，而且比抽象的几何点更有意思

75
00:04:53,160 --> 00:04:55,240
为了证明Wallis公式

76
00:04:55,240 --> 00:04:58,000
我们需要这个距离乘积的两个关键性质

77
00:04:58,000 --> 00:04:59,160
两个小引理

78
00:04:59,300 --> 00:05:04,260
第一，如果观察者在两个相邻灯塔的正中间

79
00:05:04,440 --> 00:05:06,000
此时的距离乘积

80
00:05:06,000 --> 00:05:09,740
也就是这些线段长度的乘积

81
00:05:10,125 --> 00:05:12,465
算出来刚好等于2

82
00:05:13,600 --> 00:05:15,420
不管有多少灯塔都成立

83
00:05:20,180 --> 00:05:25,140
第二，如果你去掉一个灯塔然后把观察者放在那个空位上

84
00:05:25,260 --> 00:05:28,500
此时，剩下的灯塔的距离乘积

85
00:05:28,840 --> 00:05:32,780
刚好等于一开始的灯塔数量

86
00:05:34,540 --> 00:05:36,740
同样，不管有多少灯塔都成立

87
00:05:43,320 --> 00:05:46,120
如果你觉得这两个性质很不可思议，我也同意

88
00:05:46,120 --> 00:05:51,280
这两种情况下距离乘积都是整数，光这一点也是不太明显的

89
00:05:51,480 --> 00:05:58,200
而且把所有的距离计算出来再乘起来，似乎也是非常麻烦的

90
00:05:58,480 --> 00:06:04,040
但实际上有一种巧妙的方法使这个复杂的计算变得相当简单

91
00:06:04,280 --> 00:06:09,120
大致的想法是，圆周上等距分布的点的几何性质

92
00:06:09,460 --> 00:06:12,780
对应于一个非常好的代数性质

93
00:06:12,785 --> 00:06:15,760
只要我们把它当作复平面上的单位圆

94
00:06:15,760 --> 00:06:20,060
并且这些灯塔现在就位于某些特定的复数上

95
00:06:20,555 --> 00:06:23,555
有些人可能知道这些就是单位根

96
00:06:23,555 --> 00:06:27,005
可能也有人没听过，还是让我带你们快速了解一下

97
00:06:27,260 --> 00:06:29,960
考虑把其中一个数取平方

98
00:06:30,080 --> 00:06:33,580
其模长肯定是1，所以平方之后不变

99
00:06:33,715 --> 00:06:36,835
但是它和水平线的夹角会变成两倍

100
00:06:37,000 --> 00:06:39,200
复数的平方就是这样执行的

101
00:06:39,460 --> 00:06:44,360
类似地，把这个数取立方，它和水平线的夹角会变成三倍

102
00:06:44,640 --> 00:06:49,080
普遍来讲，取其n次方，会使其与水平线夹角变为n倍

103
00:06:49,500 --> 00:06:54,460
举个例子，现在屏幕上的单位圆上有七个等距分布的点

104
00:06:54,700 --> 00:06:58,060
我把它们称为L0，L1，L2，等等

105
00:06:58,200 --> 00:07:03,680
并且把它们整体旋转使得L0处在右边的数字1上

106
00:07:04,340 --> 00:07:11,340
因为任何一点（与原点连线）与水平线的夹角都是1/7圈的整数倍

107
00:07:11,500 --> 00:07:14,300
把任何一点对应的复数取7次方

108
00:07:14,300 --> 00:07:17,340
最终都会旋转到数字1上

109
00:07:18,640 --> 00:07:25,880
换句话说，这些都是多项式方程x^7 - 1 = 0的解

110
00:07:29,520 --> 00:07:32,515
但另一方面，我们可以用完全不同的方式构造一个多项式

111
00:07:32,520 --> 00:07:35,180
并且这些数也都是它的根

112
00:07:35,180 --> 00:07:41,860
就是(x - L0) * (x - L1) * ... * (x - L6)

113
00:07:41,940 --> 00:07:46,020
你把L0~L6的任何一个数代入，这个乘积一定等于0

114
00:07:46,400 --> 00:07:51,740
因为这两个7次多项式有7个同样的不同根

115
00:07:51,740 --> 00:07:56,020
并且最高次项也相同，两边都是x^7

116
00:07:56,020 --> 00:07:58,080
它们其实是同一个东西

117
00:07:58,500 --> 00:08:01,845
稍微停下来欣赏一下，这是多么不同寻常

118
00:08:01,845 --> 00:08:05,720
看起来等号右边如果要展开的话，简直是噩梦

119
00:08:06,140 --> 00:08:08,280
不仅有一大堆项要相乘

120
00:08:08,280 --> 00:08:15,020
光是要把这些复数写出来，就得使我们淹没在一大堆sin和cos当中

121
00:08:15,420 --> 00:08:17,540
但因为这个布局的对称性

122
00:08:17,540 --> 00:08:20,620
我们知道当所有的代数的尘埃落地之后

123
00:08:20,620 --> 00:08:26,320
就会简化成x^7 - 1，所有的其他项都会抵消

124
00:08:26,960 --> 00:08:29,480
当然，7这个数字在这里并没有什么特别

125
00:08:29,480 --> 00:08:32,760
如果在圆上有N个等距分布的点

126
00:08:32,760 --> 00:08:36,720
它们都是x^N - 1 = 0的根

127
00:08:37,420 --> 00:08:44,120
你现在可能看出来了，为什么这些有助于简化计算我们之前定义的距离乘积

128
00:08:44,360 --> 00:08:49,180
考虑任何一个复数作为观察者，并不一定要在圆周上

129
00:08:49,360 --> 00:08:52,020
然后把那个数代入x

130
00:08:52,280 --> 00:08:56,540
等号右边会得到一个新的复数

131
00:08:56,540 --> 00:09:02,300
其模长等于观察者到每一个灯塔的距离乘积

132
00:09:02,940 --> 00:09:04,660
但是看看等号左边

133
00:09:04,660 --> 00:09:10,200
你马上就明白右边的乘积最终会简化成什么

134
00:09:10,700 --> 00:09:15,720
神奇的是，如果把观察者和灯塔一起放置在圆周上

135
00:09:16,020 --> 00:09:19,480
灯塔的确切个数就不重要了

136
00:09:19,560 --> 00:09:25,500
确定了相邻灯塔之间观察者位置的比值（弧L0O/弧L0L1）才是我们关心的

137
00:09:28,100 --> 00:09:30,080
设这个比值为f

138
00:09:30,080 --> 00:09:35,860
则观察者的N次方与L0之间的圆弧与整个圆周的比值将会是f

139
00:09:35,940 --> 00:09:40,615
因此复数O^N - 1的模长

140
00:09:40,620 --> 00:09:46,320
等于数字1和f倍单位圆周的点之间的距离

141
00:09:46,920 --> 00:09:50,495
例如，现在屏幕上有七个灯塔

142
00:09:50,500 --> 00:09:55,080
而观察者位于第一灯塔和第二灯塔之间1/3处

143
00:09:55,500 --> 00:10:00,480
如果你取观察者对应复数的7次方

144
00:10:00,760 --> 00:10:04,340
就会跑到整个圆周的1/3处

145
00:10:04,560 --> 00:10:12,700
因此O^N - 1的模长就是这条1/3圆周的弦的长度

146
00:10:12,760 --> 00:10:15,280
碰巧差不多是1.73 （哪里碰巧...）

147
00:10:15,280 --> 00:10:22,000
注意，这个值就是我们关心的完整的距离乘积

148
00:10:22,240 --> 00:10:25,300
我们可以增加或减少灯塔的数量

149
00:10:25,300 --> 00:10:30,200
只要观察者位于相邻灯塔的1/3处

150
00:10:30,200 --> 00:10:34,720
我们想求的距离乘积总是这同一条弦的长度

151
00:10:36,760 --> 00:10:40,860
为了普（简）遍（洁）性，我们定义一个特殊函数Chord(f)

152
00:10:40,860 --> 00:10:47,800
表示f倍单位圆周对应的弦长

153
00:10:48,280 --> 00:10:51,920
例如，我们刚才看到的1/3圆周对应的弦长

154
00:10:52,520 --> 00:11:00,460
其实不难看出Chord(f)就等于2 * sin(f/2 * 2pi)

155
00:11:01,840 --> 00:11:04,820
也就是2 * sin(f * pi)

156
00:11:04,820 --> 00:11:08,020
但是有时把它就当成Chord(f)更简单

157
00:11:09,120 --> 00:11:10,680
总结一下刚才的结论

158
00:11:10,680 --> 00:11:14,100
如果观察者在相邻灯塔之间比值为f的地方

159
00:11:14,100 --> 00:11:17,760
总的距离乘积看起来好像很复杂

160
00:11:17,765 --> 00:11:20,535
实际上就等于Chord(f)

161
00:11:20,535 --> 00:11:22,715
不管有多少灯塔都成立

162
00:11:23,145 --> 00:11:26,245
特别地，考虑Chord(1/2)

163
00:11:26,340 --> 00:11:30,300
这就是单位圆上相对两点之间的距离

164
00:11:30,300 --> 00:11:31,540
也就是2

165
00:11:31,720 --> 00:11:36,300
现在我们明白了，不管单位圆上有多少个等距分布的灯塔

166
00:11:36,300 --> 00:11:40,420
把观察者放在相邻灯塔的圆弧中间

167
00:11:40,620 --> 00:11:43,580
得到的距离乘积就刚好是2

168
00:11:44,260 --> 00:11:46,980
这就是第一个关键性质，可以把它放一边了

169
00:11:46,980 --> 00:11:51,400
下一个关键性质，把观察者放在某一个灯塔上

170
00:11:52,080 --> 00:11:55,040
当然此时的距离乘积等于0

171
00:11:55,405 --> 00:11:58,705
等于0的这个距离把其他因数全部掩盖了

172
00:11:59,055 --> 00:12:01,775
但如果我们把这个麻烦的灯塔拿掉

173
00:12:01,775 --> 00:12:05,055
只考虑其他灯塔的贡献

174
00:12:05,500 --> 00:12:08,100
这样距离乘积是多少？

175
00:12:08,860 --> 00:12:13,020
现在不考虑多项式O^N - 1

176
00:12:13,020 --> 00:12:15,920
因为N个单位根都是它的解

177
00:12:15,920 --> 00:12:21,640
我们要看多项式(O^N - 1)/(O - 1)

178
00:12:21,640 --> 00:12:26,140
除了1之外，其他N - 1个单位根都是它的解

179
00:12:26,620 --> 00:12:30,120
稍稍运用代数可以得出这个分式等于

180
00:12:30,120 --> 00:12:36,820
1 + O + O^2 + ... + O^(N - 1)

181
00:12:37,280 --> 00:12:41,940
因此如果你代入观察者=1，因为这就是他所处的位置

182
00:12:41,940 --> 00:12:43,280
你得到多少？

183
00:12:43,720 --> 00:12:47,880
这里所有项都变成1，算出来就是N

184
00:12:48,120 --> 00:12:51,060
也就是说这种情形下的距离乘积

185
00:12:51,060 --> 00:12:53,800
就等于一开始的灯塔数量

186
00:12:54,180 --> 00:12:57,220
现在确实与灯塔数量有关

187
00:12:57,240 --> 00:12:58,740
但只是非常简单的关系

188
00:12:58,860 --> 00:13:00,580
想想看，真的难以置信

189
00:13:00,580 --> 00:13:06,080
把观察者放在一个灯塔上时，与其它灯塔的距离乘积

190
00:13:06,080 --> 00:13:11,480
刚好就等于灯塔总数N（包含忽略的那个）

191
00:13:11,720 --> 00:13:13,700
这就是第二个关键性质

192
00:13:14,180 --> 00:13:17,920
顺便说一下，像这样用复数多项式来证明几何性质

193
00:13:17,920 --> 00:13:19,480
在数学上是相当标准的操作

194
00:13:19,540 --> 00:13:22,265
如果你跑到当地的数学家那里，

195
00:13:22,265 --> 00:13:25,295
把这两个结论，或是其他结论展示给他/她看的话

196
00:13:25,400 --> 00:13:28,200
他们马上就会意识到这些都是正确的

197
00:13:28,200 --> 00:13:30,900
以及如何用类似的方法证明

198
00:13:31,060 --> 00:13:32,680
现在你也行了

199
00:13:32,760 --> 00:13:35,120
有这两个性质在手

200
00:13:35,120 --> 00:13:38,940
接着来看我们如何利用它们来理解我们感兴趣的乘积

201
00:13:38,940 --> 00:13:40,600
以及它到底如何与pi产生联系

202
00:13:45,480 --> 00:13:46,500
布置如下：

203
00:13:46,500 --> 00:13:49,980
N个灯塔等距放置在单位圆周上

204
00:13:49,980 --> 00:13:54,380
并设想有两个分开的观察者，我称为管理员和水手

205
00:13:54,500 --> 00:13:57,300
把管理员直接放在一个灯塔上

206
00:13:57,300 --> 00:14:00,860
然后把水手放在那个灯塔和相邻灯塔之间圆弧的中间

207
00:14:01,160 --> 00:14:07,540
大致思路是观察管理员的距离乘积与水手的距离乘积的比值

208
00:14:07,540 --> 00:14:10,840
并且我们要用两种方式来计算这个比值

209
00:14:11,340 --> 00:14:16,440
根据第一条性质，我们知道水手的距离乘积是2

210
00:14:17,600 --> 00:14:19,720
而管理员的距离乘积

211
00:14:19,780 --> 00:14:23,140
好吧，是0，因为他正处在一个灯塔之上

212
00:14:23,140 --> 00:14:24,820
但如果忽略那个灯塔的话

213
00:14:24,820 --> 00:14:29,600
根据第二条性质，剩下的距离乘积应该是N

214
00:14:30,940 --> 00:14:33,040
当然，由于忽略了那个灯塔

215
00:14:33,040 --> 00:14:36,320
对于水手的距离乘积，我们也要忽略掉那个灯塔的贡献

216
00:14:36,720 --> 00:14:41,220
所以现在分母应该再除以两个观察者之间的距离

217
00:14:41,640 --> 00:14:43,620
稍微简化一下，就得到

218
00:14:43,620 --> 00:14:48,100
管理员和水手的距离乘积之比等于

219
00:14:48,100 --> 00:14:52,480
(N * 观察者之间距离)/2

220
00:14:53,060 --> 00:14:59,460
但是我们也可以通过单独考虑每一个灯塔来计算

221
00:14:59,780 --> 00:15:03,900
对每一个灯塔，考虑它对管理员的距离乘积的贡献

222
00:15:03,960 --> 00:15:06,280
也就是它到管理员的距离

223
00:15:06,480 --> 00:15:10,140
除以它对水手的距离乘积的贡献

224
00:15:10,140 --> 00:15:12,235
也就是它到水手的距离

225
00:15:12,240 --> 00:15:15,780
当我们把所有灯塔贡献的因子乘起来

226
00:15:15,920 --> 00:15:18,435
必定得到同样的比值

227
00:15:18,435 --> 00:15:21,755
也就是(N * 观察者之间距离)/2

228
00:15:22,140 --> 00:15:24,980
现在这个计算看起来非常混乱

229
00:15:24,980 --> 00:15:29,720
但是当N越来越大，每一个灯塔的计算都会变得更简单

230
00:15:30,180 --> 00:15:35,960
例如，考虑在逆时针方向上管理员之后的第一个灯塔

231
00:15:36,540 --> 00:15:39,220
它距离水手更近一些

232
00:15:39,440 --> 00:15:42,615
说得更具体的话，从这个灯塔到管理员的圆心角

233
00:15:42,620 --> 00:15:46,260
正好是从这个灯塔到水手的圆心角的两倍

234
00:15:46,960 --> 00:15:50,980
尽管圆心角与直线距离并不成正比

235
00:15:51,100 --> 00:15:55,320
但是当N越来越大，这个比值会越来越接近

236
00:15:55,440 --> 00:15:59,360
当N非常大时，这个灯塔到管理员的距离

237
00:15:59,360 --> 00:16:03,240
几乎就是它到水手距离的两倍

238
00:16:05,060 --> 00:16:09,000
同样地，观察管理员之后的第二个灯塔

239
00:16:09,080 --> 00:16:14,020
它到管理员的圆心角与它到水手的圆心角之比正好是4/3

240
00:16:14,060 --> 00:16:20,580
当N很大时，这与距离之比是几乎相同的

241
00:16:21,180 --> 00:16:29,140
第三个灯塔L3贡献的比值，当N趋向无穷时，会越来越接近6/5

242
00:16:32,200 --> 00:16:36,820
为了完成这个证明，我们对待下半部分的灯塔的方式稍有不同

243
00:16:36,820 --> 00:16:40,560
所以我给它们标号成-1, -2, -3, 等等

244
00:16:41,500 --> 00:16:44,440
观察管理员之前的第一个灯塔

245
00:16:44,440 --> 00:16:47,900
它到管理员与它到水手的距离之比

246
00:16:47,900 --> 00:16:51,700
当N趋向无穷，是趋近于2/3的

247
00:16:51,700 --> 00:16:58,840
第二个灯塔L_(-2)贡献的比值趋近于4/5

248
00:16:59,100 --> 00:17:04,600
第三个灯塔L_(-3)贡献的比值趋近于6/7

249
00:17:04,820 --> 00:17:06,080
等等

250
00:17:07,365 --> 00:17:10,315
对所有的灯塔，把这些组合在一起

251
00:17:10,320 --> 00:17:19,780
我们得到2/1 * 2/3 * 4/3 * 4/5 * 6/5 * 6/7 * ...

252
00:17:20,100 --> 00:17:23,260
这就是我们要研究的乘积

253
00:17:23,260 --> 00:17:30,720
并且在当前语境下，当N趋向无穷，乘积中每一项就反映了一个特定灯塔的贡献值

254
00:17:31,660 --> 00:17:37,660
这个贡献值指的是对管理员与水手的距离乘积比值的贡献

255
00:17:37,720 --> 00:17:41,020
而我们知道这个比值在每一步都等于

256
00:17:41,020 --> 00:17:43,920
(N * 观察者之间距离)/2

257
00:17:44,120 --> 00:17:47,980
当N趋向无穷时，这个比值又趋向多少？

258
00:17:48,660 --> 00:17:54,780
两个观察者之间的距离是（约等于）整个圆周的1/N的一半

259
00:17:55,200 --> 00:17:58,960
而且因为这是单位圆，其周长是2 * pi

260
00:17:59,340 --> 00:18:03,580
所以观察者之间的距离趋向于pi/N

261
00:18:04,080 --> 00:18:10,080
因此(N * 这个距离)/2趋向于pi/2

262
00:18:10,700 --> 00:18:12,440
你已经得到了答案

263
00:18:12,460 --> 00:18:17,460
这个乘积2/1 * 2/3 * 4/3 * 4/5 * ...

264
00:18:17,460 --> 00:18:20,180
一定是趋向于pi/2

265
00:18:20,800 --> 00:18:23,000
这真的是一个令人称奇的结果

266
00:18:23,000 --> 00:18:27,580
它以17世纪数学家John Wallis被命名为Wallis公式

267
00:18:27,700 --> 00:18:31,140
他是第一个发现这个结果的人，只是当时的方法要复杂得多

268
00:18:31,140 --> 00:18:37,880
顺带一提，他也是发现了，或者说发明了无穷大符号的人

269
00:18:42,440 --> 00:18:45,360
如果你回头看看这个论证的话

270
00:18:45,360 --> 00:18:48,860
我们确实在正式过程上耍了一点花招

271
00:18:48,860 --> 00:18:53,220
你如果对数学理解特别深刻，可能已经发现了

272
00:18:53,220 --> 00:18:55,400
这里有许多因子

273
00:18:55,400 --> 00:19:00,220
我们知道把它们乘起来等于(N * 观察者之间距离)/2

274
00:19:00,380 --> 00:19:05,440
然后我们分别考察了当N趋向无穷时每一个因子的极限

275
00:19:05,620 --> 00:19:08,700
于是就下结论说所有因子极限的乘积

276
00:19:08,700 --> 00:19:14,240
等于(N * 观察者之间距离)/2的极限，不管这个极限是多少

277
00:19:14,420 --> 00:19:19,360
但是这就假设了极限的乘积等于乘积的极限

278
00:19:19,440 --> 00:19:21,580
这一论断在无穷个因子相乘时仍然成立

279
00:19:22,000 --> 00:19:25,940
这种极限的交换在无穷算术领域中

280
00:19:26,340 --> 00:19:28,340
其实并不总是成立

281
00:19:28,480 --> 00:19:31,040
这经常是有效的，但有时会失效

282
00:19:31,480 --> 00:19:36,700
我来展示一个简单的极限交换会失效的例子

283
00:19:37,040 --> 00:19:38,280
这里有一个方阵

284
00:19:38,280 --> 00:19:42,180
每一行都有一个7和一大堆1

285
00:19:42,520 --> 00:19:47,080
对每一行求无穷乘积得到的都是7

286
00:19:47,080 --> 00:19:49,820
因为所有的乘积都是7

287
00:19:49,820 --> 00:19:52,560
这些乘积的极限也是7

288
00:19:52,800 --> 00:19:55,280
但如果先取极限会发生什么？

289
00:19:55,280 --> 00:19:59,580
观察任何指定的一列，其极限是1，

290
00:19:59,580 --> 00:20:01,680
因为向下到某一点，下面的数字全部都是1了

291
00:20:02,080 --> 00:20:05,200
但接着你把这些极限乘起来

292
00:20:05,200 --> 00:20:07,340
你只是把一大堆1乘起来

293
00:20:07,340 --> 00:20:10,080
就得到一个不同的结果，也就是1

294
00:20:12,600 --> 00:20:16,840
幸运的是，数学家们花了很多时间思考这种现象

295
00:20:16,940 --> 00:20:22,780
并且发明了一些工具，用来快速判断允许极限交换的条件是否成立

296
00:20:23,200 --> 00:20:27,160
在这个场合中，有一个特定的权威结论，称为“控制收敛”

297
00:20:27,160 --> 00:20:31,860
可以很快让我们确信我们的论证能通过严格的检查

298
00:20:32,100 --> 00:20:36,980
你如果有兴趣，Sweeter给这个视频写了一篇补充博客

299
00:20:36,980 --> 00:20:39,920
包含了这些细节，还有很多其他内容

300
00:20:40,420 --> 00:20:41,560
还有一点我要提醒

301
00:20:41,560 --> 00:20:44,980
对于如何解释这样的乘积，我们需要略加留心

302
00:20:45,100 --> 00:20:49,600
还记得我们有从管理员开始逆时针数过来的灯塔的贡献

303
00:20:49,600 --> 00:20:52,265
同样也有顺时针数过来的

304
00:20:52,265 --> 00:20:55,640
我们把这些交替地乘起来，得到我们要的乘积

305
00:20:56,000 --> 00:21:02,980
逆时针数过来的灯塔贡献了2/1, 4/3, 6/5等等

306
00:21:03,160 --> 00:21:08,660
顺时针数过来的灯塔贡献了2/3, 4/5, 6/7

307
00:21:08,860 --> 00:21:12,975
我之前说过，如果只是捣鼓一半的数列

308
00:21:12,980 --> 00:21:16,600
第一个乘积只会越来越大，趋向无穷

309
00:21:16,600 --> 00:21:20,060
而第二个只会越来越小，趋近于0

310
00:21:20,600 --> 00:21:28,980
如果把这两部分分别算出来再乘起来的话，要使这个总的乘积有意义是很微妙的

311
00:21:29,040 --> 00:21:32,940
甚至，如果用不同的方式把它们混合在一起

312
00:21:32,940 --> 00:21:37,360
例如，每次从一边取的因子个数是另一边的两倍

313
00:21:37,440 --> 00:21:40,520
总体的乘积会算出不同的结果

314
00:21:40,640 --> 00:21:47,120
只有用这种一个一个轮流交替的方式你才能使乘积收敛到pi/2

315
00:21:47,380 --> 00:21:53,060
（这句不好翻译）

316
00:21:53,300 --> 00:21:56,080
要了解更多细节，查看补充博客

317
00:21:56,860 --> 00:21:58,980
不管怎样，这些只是技术性细节

318
00:21:58,980 --> 00:22:02,740
我们已经展示了证明的要点

319
00:22:07,765 --> 00:22:10,245
在完成了这些之后

320
00:22:10,245 --> 00:22:15,220
有一个美妙的推论值得我们快速讨论一下

321
00:22:15,240 --> 00:22:17,980
可能这才是整个证明中最酷的部分

322
00:22:17,980 --> 00:22:20,480
我们可以讨论一般的情形

323
00:22:20,900 --> 00:22:23,980
回想一下，在证明第一个关键性质的时候

324
00:22:23,980 --> 00:22:29,140
观察者并不一定要位于两个相邻灯塔的中间

325
00:22:29,140 --> 00:22:33,360
它可以位于两个灯塔之间的任何比例，f

326
00:22:33,500 --> 00:22:34,900
在这种更一般的情形下

327
00:22:34,900 --> 00:22:38,720
水手的距离乘积并不一定是2

328
00:22:38,720 --> 00:22:43,180
而是Chord(f)，f是弧L0O/弧L0L1

329
00:22:44,060 --> 00:22:46,460
我们接着用同样的论证方法

330
00:22:46,460 --> 00:22:50,140
只是把水手移动到f处，其他都不变

331
00:22:50,300 --> 00:22:56,440
我们发现管理员与水手的距离乘积的比值会变成

332
00:22:56,520 --> 00:23:00,560
(N * 观察者之间距离)/Chord(f)

333
00:23:00,780 --> 00:23:05,820
当N越来越大，它趋向于(f * 2 * pi)/Chord(f)

334
00:23:08,960 --> 00:23:12,240
跟之前一样，你也可以换一种计算方式

335
00:23:12,240 --> 00:23:15,680
把每一个灯塔的距离比值乘起来

336
00:23:15,940 --> 00:23:17,860
如果你花点时间把它算出来

337
00:23:17,860 --> 00:23:21,860
管理员之后（上半圆周）第k个灯塔贡献的因子是

338
00:23:22,040 --> 00:23:25,580
k/(k - f)

339
00:23:26,160 --> 00:23:29,315
并且管理员之前（下半圆周）的灯塔贡献的因子是一样的

340
00:23:29,315 --> 00:23:32,225
只是k是负整数

341
00:23:32,500 --> 00:23:36,740
如果对所有非零整数k，把这些因子乘起来

342
00:23:36,740 --> 00:23:42,060
跟之前一样，把k为正和k为负的项组合起来的时候要小心

343
00:23:42,320 --> 00:23:48,660
你会得到：对所有非零整数k，把k/(k - f)相乘

344
00:23:48,780 --> 00:23:52,900
等于(f * 2 * pi)/Chord(f)

345
00:23:53,220 --> 00:23:57,420
换种写法，因为Chord(f) = 2 * sin(f * pi)

346
00:24:00,700 --> 00:24:06,860
这个乘积等于(f * 2 * pi)/(2 * sin(f * pi))

347
00:24:06,860 --> 00:24:09,700
也就是(f * pi)/sin(f * pi)

348
00:24:10,100 --> 00:24:12,640
然后再稍微改写一下

349
00:24:12,640 --> 00:24:14,620
你现在就得到很有趣的结论

350
00:24:15,020 --> 00:24:20,480
sin(f * pi) = f * pi * 这个很长的乘积

351
00:24:20,540 --> 00:24:25,380
这个乘积就是对所有非零整数k，(1 - f/k)的乘积

352
00:24:25,620 --> 00:24:30,960
我们发现了一种方法把sin(x)表示成无穷乘积

353
00:24:31,220 --> 00:24:33,540
你想想看，这真的很不得了

354
00:24:33,985 --> 00:24:37,265
这个证明不仅给了我们Wallis公式

355
00:24:37,265 --> 00:24:39,380
当然它本身就是非凡的

356
00:24:39,380 --> 00:24:42,960
它还能一般化，给出一个sin的乘积公式

357
00:24:42,960 --> 00:24:47,860
了不起的是，当时这个公式帮助了欧拉解决Basel问题

358
00:24:47,860 --> 00:24:50,000
也就是之前的视频展示的和式

359
00:24:50,000 --> 00:24:53,040
他当时就研究了这个sin的无穷乘积表示

360
00:24:53,400 --> 00:24:56,900
我想说的是，把这两个pi的公式与圆联系起来是一回事

361
00:24:56,900 --> 00:24:59,960
但是直接把它们联系起来是另一回事

362
00:25:00,300 --> 00:25:05,020
有关此事的细节，详见补充博客

