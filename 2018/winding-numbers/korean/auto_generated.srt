1
00:00:00,000 --> 00:00:06,720
여기에는 기본 주제와 메타 주제라는 두 가지가 있습니다.

2
00:00:06,720 --> 00:00:10,440
주요 주제는 2차원 방정식, 두 개의 알려지지 않은

3
00:00:10,440 --> 00:00:14,900
실수 또는 복소수인 단일 미지수와 관련된 문제를

4
00:00:14,900 --> 00:00:17,420
해결하기 위한 정말 깔끔한 알고리즘이 될 것입니다.

5
00:00:17,420 --> 00:00:21,840
예를 들어, 다항식의 복소수 근을 찾고 싶거나 리만

6
00:00:21,840 --> 00:00:25,960
제타 함수의 백만 달러짜리 0 중 일부를

7
00:00:25,960 --> 00:00:26,960
찾고 싶다면 이 알고리즘이 대신해 줄 것입니다.

8
00:00:27,000 --> 00:00:30,520
그리고 이 방법은 정말 예쁜데, 많은 색상이 들어가거든요.

9
00:00:30,520 --> 00:00:34,960
그리고 더 중요한 것은 핵심 기본 아이디어가 나중에

10
00:00:34,960 --> 00:00:39,600
이야기할 약간의 위상수학을 포함하여 방정식을 풀기 위한 이

11
00:00:39,600 --> 00:00:40,600
알고리즘을 훨씬 넘어서는 모든 종류의 수학에 적용된다는 것입니다.

12
00:00:40,600 --> 00:00:44,880
하지만 이 시간을 실제로 20분 정도의 가치로 만드는 것은

13
00:00:44,880 --> 00:00:50,000
수학 전반에 걸쳐 훨씬 더 일반적으로 유용한 교훈,

14
00:00:50,000 --> 00:00:52,120
즉 서로 잘 구성되는 구성을 정의하려고 시도한다는 점입니다.

15
00:00:52,120 --> 00:00:55,460
이야기가 진행되면서 이것이 무슨 뜻인지 알게 될 것입니다.

16
00:00:55,460 --> 00:00:59,460
2D 입력과 2D 출력이 있는 함수로 사례를 동기를 부여하기 위해

17
00:00:59,460 --> 00:01:05,100
실수를 받아들이고 실수를 뱉어내는 함수로 더 간단하게 시작해 보겠습니다.

18
00:01:05,100 --> 00:01:10,060
x의 함수 f가 x의 다른 함수 g와 언제 같은지 알고 싶다면,

19
00:01:10,060 --> 00:01:14,260
이를 해당 함수의 그래프가 교차하는 때를 검색하는 것으로 생각할 수 있습니다.

20
00:01:14,260 --> 00:01:19,340
즉, 두 함수 모두 동일한 출력을 갖는 입력을 제공한다는 뜻입니다.

21
00:01:19,340 --> 00:01:24,520
매우 간단한 예를 들어, f(x)가 x 제곱이고

22
00:01:24,520 --> 00:01:25,520
g(x)가 상수 함수 2라고 상상해 보세요.

23
00:01:25,520 --> 00:01:29,620
즉, 2의 제곱근을 구하려는 것입니다.

24
00:01:29,620 --> 00:01:33,620
제곱근을 찾는 것에 대해 거의 아무것도 모르더라도 1의 제곱은 2보다 작고

25
00:01:33,620 --> 00:01:39,260
2의 제곱은 2보다 크다는 것을 알 수 있으므로 아, 이 두

26
00:01:39,260 --> 00:01:42,640
값 사이에 어떤 해결책이 있을 것이라는 것을 깨닫게 될 것입니다.

27
00:01:42,640 --> 00:01:46,740
그런 다음 범위를 더 좁히고 싶다면 중간점인

28
00:01:46,740 --> 00:01:47,740
1을 제곱해 보세요. 5.

29
00:01:47,740 --> 00:01:53,060
이는 2로 나옵니다. 25는 약간 높으므로 1과 1 사이의

30
00:01:53,060 --> 00:01:54,940
영역에 집중하게 됩니다. 5.

31
00:01:54,940 --> 00:01:58,560
계속해서 이것이 어떻게 계속 진행되는지 알 수 있습니다. 중간

32
00:01:58,560 --> 00:02:05,540
지점에서 계속 계산한 다음 검색 공간을 절반으로 줄입니다.

33
00:02:05,540 --> 00:02:08,340
이에 대해 생각하는 또 다른 방법은 더 높은 차원에

34
00:02:08,340 --> 00:02:13,560
도달하면 더 쉽게 만들 수 있으며 대신 이 두

35
00:02:13,560 --> 00:02:16,300
함수의 차이가 0일 때의 동등한 질문에 집중하는 것입니다.

36
00:02:16,380 --> 00:02:20,700
이러한 관점에서 우리는 그 차이가 한쪽 끝에서는 음수이고

37
00:02:20,700 --> 00:02:24,020
다른 쪽 끝에서는 양수인 입력 영역을 발견했습니다.

38
00:02:24,020 --> 00:02:28,660
우리는 그것을 두 개로 나누고, 우리가 주의를 좁힌

39
00:02:28,660 --> 00:02:31,600
절반은 가장 바깥쪽 지점에 다양한 부호가 있는 부분이었습니다.

40
00:02:31,600 --> 00:02:36,020
이렇게 우리는 국경에 다양한 표지판이 있는 각 지역을 선택하고 절반

41
00:02:36,020 --> 00:02:41,320
중에서 더 작은 지역을 찾아 영원히 계속할 수 있었습니다. 궁극적으로

42
00:02:41,320 --> 00:02:46,260
우리는 정확히 0이 될 지점으로 좁아져야 한다는 것을 알고 있었습니다.

43
00:02:46,260 --> 00:02:50,480
간단히 말해서, 방정식을 푸는 것은 항상 특정 함수가 0과 같을 때를 찾는

44
00:02:50,480 --> 00:02:55,780
것으로 구성될 수 있으며, 그렇게 하기 위해 우리는 이 경험적 방법을 사용합니다.

45
00:02:55,780 --> 00:03:00,420
f가 한 지점에서 양수이고 다른 지점에서 음수인 경우, 그 사이의 어딘가를 찾을

46
00:03:00,420 --> 00:03:03,980
수 있습니다. 적어도 갑작스러운 점프 없이 모든 것이 순조롭게 변한다면 그것은 0입니다.

47
00:03:03,980 --> 00:03:08,060
제가 여러분께 보여드리고 싶은 놀라운 점은 이런 종류의

48
00:03:08,060 --> 00:03:13,220
사고를 2차원 방정식, 즉 입력과 출력이 모두 2차원인

49
00:03:13,220 --> 00:03:14,940
함수 간의 방정식으로 확장할 수 있다는 것입니다.

50
00:03:14,940 --> 00:03:19,540
예를 들어 복소수는 2차원이며 우리가 개발 중인 이

51
00:03:19,540 --> 00:03:21,780
도구는 복잡한 방정식의 해를 찾는 데 적합합니다.

52
00:03:21,780 --> 00:03:25,700
이제 이러한 2D 기능에 대해 많이 이야기할 것이므로

53
00:03:25,700 --> 00:03:29,380
잠시 옆으로 가서 이를 설명하는 방법을 고려해 보겠습니다.

54
00:03:29,380 --> 00:03:34,700
2D 입력 및 2D 출력을 사용하여 함수를 그래프로

55
00:03:34,700 --> 00:03:39,220
표시하려면 4차원이 필요하며 2D 화면의 3D 세계에서는 잘

56
00:03:39,220 --> 00:03:41,140
작동하지 않지만 여전히 몇 가지 좋은 옵션이 있습니다.

57
00:03:41,140 --> 00:03:46,020
하나는 입력 공간과 출력 공간을 나란히 보는 것입니다.

58
00:03:46,020 --> 00:03:51,540
입력 공간의 각 지점은 출력 공간의 특정 지점으로 이동하며 해당 입력 지점

59
00:03:51,540 --> 00:03:57,060
주위의 이동이 출력 공간의 특정 이동에 어떻게 대응되는지 보여줄 수 있습니다.

60
00:03:57,060 --> 00:04:01,460
우리가 고려하는 모든 기능은 입력의 작은

61
00:04:01,460 --> 00:04:05,820
변화가 출력의 작은 변화에만 해당하고

62
00:04:05,820 --> 00:04:07,460
갑작스러운 점프가 없다는 점에서 연속적입니다.

63
00:04:07,460 --> 00:04:12,020
또 다른 옵션은 출력 공간의 원점에서 해당 출력 지점까지의

64
00:04:12,020 --> 00:04:17,380
화살표를 상상하고 해당 화살표의 축소판을 입력 지점에 연결하는 것입니다.

65
00:04:17,380 --> 00:04:22,340
이를 통해 주어진 입력 지점이 어디로 가는지 또는 전체 벡터 필드를

66
00:04:22,340 --> 00:04:27,580
그려 다양한 입력 지점이 어디로 가는지 한눈에 알 수 있습니다.

67
00:04:27,580 --> 00:04:30,740
불행하게도 많은 지점에서 이 작업을 수행하면 상당히 복잡해질 수

68
00:04:30,740 --> 00:04:34,340
있으므로 여기에서는 모든 화살표를 동일한 크기로 만들겠습니다. 이것이 의미하는

69
00:04:34,340 --> 00:04:37,900
바는 각 출력 지점의 방향을 파악할 수 있다는 것입니다.

70
00:04:37,900 --> 00:04:41,660
그러나 아마도 2차원 함수를 설명하는 가장 멋진 방법이자 이 비디오에서 가장

71
00:04:41,660 --> 00:04:47,400
많이 사용할 방법은 해당 출력 공간의 각 점을 색상과 연관시키는 것입니다.

72
00:04:47,400 --> 00:04:52,180
여기서 우리는 원점에서 멀어지는 방향에 대응하기 위해

73
00:04:52,180 --> 00:04:57,020
색상(색상이 무지개나 색상환을 따라 떨어지는 위치)을 사용했고,

74
00:04:57,020 --> 00:05:00,060
원점으로부터의 거리에 대응하기 위해 어두움이나 밝기를 사용했습니다.

75
00:05:00,060 --> 00:05:05,720
예를 들어, 이 출력 배열에 초점을 맞추면 이러한 점은 모두 빨간색이지만 원점에

76
00:05:05,720 --> 00:05:10,340
가까운 점은 조금 더 어둡고 멀리 있는 점은 조금 더 밝습니다.

77
00:05:10,340 --> 00:05:15,360
이 출력 배열에 초점을 맞추면 모든 점이

78
00:05:15,360 --> 00:05:18,980
녹색이고 원점에 가까울수록 어두워지고 멀어질수록 밝아집니다.

79
00:05:18,980 --> 00:05:24,300
그리고 여기서 우리가 하는 일은 각 방향에 특정

80
00:05:24,300 --> 00:05:25,300
색상을 할당하는 것뿐입니다. 모든 방향은 계속해서 변합니다.

81
00:05:25,300 --> 00:05:29,100
여기서는 어두움과 밝기의 차이가 매우 미묘하다는 것을 알

82
00:05:29,140 --> 00:05:33,940
수 있지만, 이 비디오에서 우리가 관심을 갖는

83
00:05:33,940 --> 00:05:35,300
것은 출력의 방향이지 크기나 색상, 밝기가 아닙니다.

84
00:05:35,300 --> 00:05:39,160
밝기에 대해 주목해야 할 한 가지 중요한 점은 특정

85
00:05:39,160 --> 00:05:44,440
방향이 없는 원점 근처에서는 모든 색상이 검은색으로 희미해진다는 것입니다.

86
00:05:44,440 --> 00:05:48,820
함수에 대해 생각해 보면 이제 각 출력의 색상을 결정했으므로

87
00:05:48,820 --> 00:05:54,020
출력 공간에 있는 지점의 색상을 기반으로 입력 공간의 각

88
00:05:54,020 --> 00:05:57,860
지점에 색상을 지정하여 2D 기능을 시각화할 수 있습니다.

89
00:05:57,860 --> 00:06:02,340
나는 입력 공간의 다양한 지점이 출력 공간의 해당 출력으로

90
00:06:02,340 --> 00:06:06,340
이동한 다음 착륙 지점의 색상을 기반으로 칠해진 다음 입력

91
00:06:06,340 --> 00:06:11,820
공간에서 원래 위치로 다시 이동하는 것을 상상하고 싶습니다.

92
00:06:11,820 --> 00:06:15,700
입력 공간의 모든 점에 대해 이 작업을 수행하면 해당 입력 공간을

93
00:06:15,700 --> 00:06:19,140
살펴보면 함수가 각 점을 대략적으로 취하는 위치를 알 수 있습니다.

94
00:06:19,140 --> 00:06:23,880
예를 들어, 왼쪽에 있는 분홍색 점 줄무늬는 모든 점이 출력

95
00:06:23,920 --> 00:06:30,000
공간의 왼쪽 아래인 분홍색 방향 어딘가에 매핑된다는 것을 나타냅니다.

96
00:06:30,000 --> 00:06:34,120
또한 주위에 많은 색상이 있고 검은색인

97
00:06:34,120 --> 00:06:37,120
세 점은 0이 되는 점입니다.

98
00:06:37,120 --> 00:06:46,120
좋습니다. 1D의 경우와 마찬가지로 2D 함수의 방정식을 푸는 것도

99
00:06:46,120 --> 00:06:49,780
특정 함수가 언제 0인지 묻는 방식으로 재구성할 수 있습니다.

100
00:06:49,780 --> 00:06:54,820
이것이 바로 지금 우리의 과제입니다. 주어진 2D 함수의 어느

101
00:06:54,820 --> 00:07:00,900
입력 포인트가 0이 되는지 찾는 알고리즘을 만드는 것입니다.

102
00:07:00,900 --> 00:07:04,560
검은색 점을 보고 이와 같은 색상 지도를 보고 있다면 함수의

103
00:07:04,560 --> 00:07:08,700
0이 어디에 있는지 이미 알고 있다는 점을 지적할 수 있습니다.

104
00:07:08,700 --> 00:07:11,460
그럼 그게 중요해?

105
00:07:11,460 --> 00:07:15,100
이와 같은 다이어그램을 만들기 위해 컴퓨터가 평면의 모든 픽셀에서

106
00:07:15,100 --> 00:07:21,020
함수를 계산하도록 했지만 우리의 목표는 가능한 한 적은 수의

107
00:07:21,020 --> 00:07:25,380
지점에서만 함수를 계산해야 하는 보다 효율적인 알고리즘을 찾는 것입니다.

108
00:07:25,380 --> 00:07:29,600
, 말하자면 색상에 대한 제한된 시각만 가지고 있는 것입니다.

109
00:07:29,600 --> 00:07:33,940
또한 좀 더 이론적인 관점에서 볼 때, 주어진 영역 내에 0이

110
00:07:33,940 --> 00:07:38,300
존재하는지 여부에 대한 조건을 알려주는 일반적인 구조를 갖는 것이 좋을 것입니다.

111
00:07:38,300 --> 00:07:43,700
한 차원에서 주요 통찰력은 연속 함수가 한 지점에서는 양수이고

112
00:07:43,700 --> 00:07:48,920
다른 지점에서는 음수이면 그 사이의 어딘가는 0이어야 한다는 것입니다.

113
00:07:48,920 --> 00:07:50,960
그러면 어떻게 이를 2차원으로 확장할 수 있을까요?

114
00:07:50,960 --> 00:07:55,180
우리는 표지판에 대해 이야기하는 일종의 아날로그가 필요합니다.

115
00:07:55,180 --> 00:07:59,140
표지판이 무엇인지 생각하는 한 가지 방법은 방향입니다.

116
00:07:59,140 --> 00:08:02,620
양수는 수직선을 따라 오른쪽을 가리키고 있다는

117
00:08:02,620 --> 00:08:04,240
뜻이고, 음수는 왼쪽을 가리킨다는 뜻입니다.

118
00:08:04,240 --> 00:08:08,800
2차원 수량에도 방향이 있지만 옵션이 훨씬 더 넓어서 가능성의

119
00:08:08,800 --> 00:08:12,780
전체 범위를 따라 어느 곳이든 가리킬 수 있습니다.

120
00:08:12,780 --> 00:08:16,860
따라서 1차원에서 우리는 주어진 함수가 단지 2개의 점인 범위의

121
00:08:16,860 --> 00:08:22,860
경계에서 양수인지 음수인지 묻는 것과 같은 방식으로 2차원

122
00:08:22,860 --> 00:08:28,200
함수에 대해 우리는 영역의 경계를 살펴볼 것입니다. 루프이며

123
00:08:28,200 --> 00:08:33,760
해당 경계를 따라 함수 출력의 방향에 대해 물어보십시오.

124
00:08:33,760 --> 00:08:39,220
예를 들어, 이 0을 중심으로 하는 이 루프를 따라 출력은

125
00:08:39,220 --> 00:08:43,460
가능한 모든 방향, 무지개의 모든 색상, 빨간색, 노란색, 녹색,

126
00:08:43,460 --> 00:08:45,820
파란색, 다시 빨간색으로, 그리고 그 사이의 모든 색상을 통과합니다.

127
00:08:45,820 --> 00:08:50,640
하지만 여기에 있는 이 루프를 따라 0이 없으면 출력이 모든 색상을

128
00:08:50,640 --> 00:08:55,420
통과하지 않고 일부 주황색 색상을 통과하지만 결코 녹색이나 파란색은 통과하지 않습니다.

129
00:08:55,420 --> 00:08:59,320
그리고 이것은 유망합니다. 일이 한 차원에서 작동하는 방식과 매우 비슷해 보입니다.

130
00:08:59,320 --> 00:09:03,540
아마도 1d 함수가 1d 영역의 경계에서 가능한 두 부호를 모두 취하면

131
00:09:03,540 --> 00:09:09,700
내부 어딘가에 0이 있는 것과 같은 방식으로, 2d 함수가 영역을 따라

132
00:09:09,700 --> 00:09:15,140
가능한 모든 방향, 가능한 모든 색상의 출력에 도달한다고 가정할 수 있습니다.

133
00:09:15,140 --> 00:09:20,980
2D 영역의 경계가 있으면 해당 영역 내부 어딘가에 0이 되어야 합니다.

134
00:09:20,980 --> 00:09:25,100
이것이 우리의 추측입니다. 이것이 사실이어야 하는지,

135
00:09:25,100 --> 00:09:27,660
그렇다면 왜 그런지 잠시 생각해 보십시오.

136
00:09:27,660 --> 00:09:32,020
어떤 입력 지점 주변의 작은 루프에 대해 생각하기 시작하면 모든 것이 연속적이므로

137
00:09:32,020 --> 00:09:36,660
함수가 해당 출력 근처의 작은 루프로 이동한다는 것을 알 수 있습니다.

138
00:09:36,660 --> 00:09:41,140
하지만 대부분의 작은 루프의 경우 출력 색상이 다양합니다.

139
00:09:41,140 --> 00:09:46,300
0이 아닌 출력 지점을 선택하고 그 근처에 충분히 촘촘한 루프를

140
00:09:46,300 --> 00:09:49,860
그리면 루프의 색상은 모두 해당 지점과 거의 같은 색상이 됩니다.

141
00:09:49,860 --> 00:09:55,980
여기의 촘촘한 고리는 모두 푸르스름하고, 여기의 촘촘한 고리는 모두

142
00:09:55,980 --> 00:09:58,440
노란색입니다. 확실히 무지개의 모든 색상을 얻을 수는 없습니다.

143
00:09:58,440 --> 00:10:03,580
모든 색상을 얻으면서 주변의 루프를 조일 수

144
00:10:03,580 --> 00:10:07,120
있는 유일한 지점은 무색 원점인 0 자체입니다.

145
00:10:07,120 --> 00:10:11,680
따라서 무지개의 모든 색상을 통과하고 조이고

146
00:10:11,680 --> 00:10:15,960
조이고 한 지점에서 좁아지는 루프가 있는

147
00:10:15,960 --> 00:10:17,360
경우 해당 지점은 실제로 0이어야 합니다.

148
00:10:17,360 --> 00:10:22,360
이제 1차원 방정식 솔버와 마찬가지로 2D 방정식 솔버를 설정해 보겠습니다.

149
00:10:22,360 --> 00:10:27,200
경계가 모든 색상을 통과하는 큰 영역을 찾으면 이를 두

150
00:10:27,200 --> 00:10:30,640
개로 분할한 다음 각 절반의 경계에 있는 색상을 살펴봅니다.

151
00:10:30,640 --> 00:10:34,920
여기에 표시된 예에서는 왼쪽 절반의 테두리가 모든 색상을 통과하지 않습니다.

152
00:10:34,920 --> 00:10:39,080
예를 들어 주황색을 띤 노란색 방향으로 매핑되는 점이 없습니다.

153
00:10:39,080 --> 00:10:43,480
따라서 더 이상 검색하고 싶지 않다는 의미로 이 영역을 회색으로 표시하겠습니다.

154
00:10:43,480 --> 00:10:47,840
오른쪽 절반은 모든 색상을 통과하고 녹색 방향에서 많은 시간을

155
00:10:47,840 --> 00:10:51,120
보낸 다음 노란색 주황색 빨간색과 파란색 보라색 분홍색을 통과합니다.

156
00:10:51,120 --> 00:10:56,060
이제 이것이 의미하는 바는 이 경계의 지점이

157
00:10:56,060 --> 00:10:57,800
가능한 모든 방향의 출력에 매핑된다는 것입니다.

158
00:10:57,800 --> 00:11:02,900
그래서 좀 더 자세히 살펴보고, 다시 세분화하여 각 지역의 경계를 확인하겠습니다.

159
00:11:02,900 --> 00:11:07,000
상단의 경계는 모두 녹색이므로 거기서 검색을 중지하겠습니다.

160
00:11:07,000 --> 00:11:10,500
하지만 바닥은 세분화할 가치가 있을 만큼 컬러풀합니다.

161
00:11:10,500 --> 00:11:12,420
그리고 이대로 계속하세요.

162
00:11:12,420 --> 00:11:16,860
가능한 모든 색상을 포함하는 경계가 있는 하위 영역을 확인합니다.

163
00:11:16,860 --> 00:11:21,280
즉, 해당 경계의 지점이 가능한 모든 방향에 매핑된다는 의미입니다.

164
00:11:21,280 --> 00:11:25,400
그리고 1차원 경우에서 했던 것처럼 해당 영역을 계속 반으로

165
00:11:25,400 --> 00:11:29,320
자르고 결국 기능에 대한 0이 됩니다. 아, 잠깐만요.

166
00:11:29,320 --> 00:11:30,320
여기 뭔 일 있었 니?

167
00:11:30,320 --> 00:11:34,520
오른쪽 하단에 있는 마지막 하위 구분 중 어느 것도

168
00:11:34,520 --> 00:11:38,160
모든 색상을 통과하지 못했기 때문에 우리 알고리즘은 둘 중

169
00:11:38,160 --> 00:11:41,160
하나를 검색하고 싶지 않았기 때문에 중지되었지만 0도 찾지 못했습니다.

170
00:11:41,160 --> 00:11:43,720
좋아요, 분명히 뭔가 문제가 있는 것 같습니다.

171
00:11:43,720 --> 00:11:46,680
그리고 괜찮아요. 틀린다는 것은 수학을 하는 데 있어 일반적인 부분입니다.

172
00:11:46,680 --> 00:11:51,400
돌이켜보면 우리는 이런 가설을 세웠고, 그것이 제안한

173
00:11:51,400 --> 00:11:53,680
알고리즘으로 이어졌기 때문에 어딘가에서 착각하고 있었던 것입니다.

174
00:11:53,680 --> 00:11:56,860
그리고 수학을 잘한다는 것은 처음부터 옳다는 것이

175
00:11:56,860 --> 00:12:00,920
아니라, 주의 깊게 되돌아보고 실수를 이해하고 이를

176
00:12:00,920 --> 00:12:02,520
고치는 방법을 이해하는 회복력을 갖는 것입니다.

177
00:12:02,520 --> 00:12:06,760
이제 여기서 문제는 경계가 모든 색상을 통과하는 지역이 있다는 것입니다. 하지만

178
00:12:06,760 --> 00:12:11,260
중간에 분할했을 때 하위 지역의 경계가 모든 색상을 통과하지 않았고 다음에

179
00:12:11,260 --> 00:12:14,880
계속 검색할 위치에 대한 옵션이 없었으며 이로 인해 0이 깨졌습니다. 파인더.

180
00:12:15,280 --> 00:12:18,120
이제 한 차원에서는 이런 종류의 일이 결코 일어나지 않았습니다.

181
00:12:18,120 --> 00:12:22,960
끝점에 다른 부호가 있는 간격이 있을 때마다

182
00:12:22,960 --> 00:12:28,200
이를 분할하면 끝점에도 다른 부호가 있는 일부

183
00:12:28,200 --> 00:12:29,200
하위 간격이 보장된다는 것을 알 수 있습니다.

184
00:12:29,200 --> 00:12:34,120
또는 달리 말하면, 끝점이 부호를 변경하지 않는 두

185
00:12:34,120 --> 00:12:38,280
개의 간격이 있을 때마다 이를 결합하면 끝점도 부호가

186
00:12:38,280 --> 00:12:39,280
변경되지 않는 더 큰 간격을 얻게 됩니다.

187
00:12:39,280 --> 00:12:43,140
그러나 2차원에서는 경계가 모든 색상을 통과하지는 않지만

188
00:12:43,140 --> 00:12:48,040
경계가 결합되어 모든 색상을 통과하는 영역을

189
00:12:48,040 --> 00:12:49,940
제공하는 두 영역을 찾는 것이 가능합니다.

190
00:12:49,940 --> 00:12:53,740
그리고 이런 방식으로 우리가 제안한 영점 찾기 알고리즘이 깨졌습니다.

191
00:12:53,740 --> 00:12:58,680
사실, 생각해 보면 내부에 0이 없이 테두리가 가능한

192
00:12:58,680 --> 00:13:03,120
모든 색상을 통과하는 큰 루프를 찾을 수 있습니다.

193
00:13:03,120 --> 00:13:07,100
모든 색상을 통과하는 영원히 좁아지는 루프는 0에서 좁아져야 한다고 우리가 말했을

194
00:13:07,100 --> 00:13:13,040
때 작은 루프에 대한 우리의 주장이 틀렸다고 말하는 것은 아닙니다.

195
00:13:13,040 --> 00:13:17,120
그러나 우리를 혼란스럽게 만든 것은 이 속성이 모든 색상을 통과하는지 여부에

196
00:13:17,120 --> 00:13:23,040
관계없이 지역을 결합할 때 훌륭하고 예측 가능한 방식으로 결합되지 않는다는 것입니다.

197
00:13:23,040 --> 00:13:28,100
하지만 걱정하지 마세요. 우리가 원하는 것을 제공하기 위해 결합하는 좀

198
00:13:28,100 --> 00:13:38,560
더 정교한 속성으로 이것을 약간 수정할 수 있다는 것이 밝혀졌습니다.

199
00:13:38,560 --> 00:13:42,540
단순히 루프의 특정 지점에서 색상을 찾을 수

200
00:13:42,540 --> 00:13:47,100
있는지 묻는 대신 루프를 돌면서 이러한 색상이

201
00:13:47,100 --> 00:13:48,100
어떻게 변하는지 더 주의 깊게 추적하자는 아이디어입니다.

202
00:13:48,100 --> 00:13:50,060
예를 들어 내가 의미하는 바를 보여 드리겠습니다.

203
00:13:50,060 --> 00:13:54,120
추적하는 데 도움이 되도록 여기 구석에 작은 색상환을 올려 놓겠습니다.

204
00:13:54,120 --> 00:13:58,540
입력 경로를 따라 색상이 무지개를 통해 빨간색에서

205
00:13:58,540 --> 00:14:04,380
노란색, 노란색에서 녹색, 녹색에서 파란색, 파란색에서 빨간색으로

206
00:14:04,380 --> 00:14:05,720
특정 방향으로 이동하면 출력이 시계 방향으로 회전합니다.

207
00:14:05,720 --> 00:14:09,980
그러나 반면에 색상이 무지개를 통해 파란색에서 녹색, 녹색에서 노란색, 노란색에서 빨간색,

208
00:14:09,980 --> 00:14:17,160
빨간색에서 파란색으로 반대 방향으로 이동하면 출력이 시계 반대 방향으로 흔들리는 것입니다.

209
00:14:17,160 --> 00:14:22,940
따라서 여기 이 짧은 경로를 따라 걸으면 색상은 색상환을 통해 시계

210
00:14:22,940 --> 00:14:28,340
방향으로 5분의 1 방향으로 휘어집니다. 그리고 여기 이 경로를 따라 걷는

211
00:14:28,340 --> 00:14:30,620
경우 색상은 색상환을 통해 시계 방향으로 5분의 1 방향으로 휘어집니다.

212
00:14:30,620 --> 00:14:35,400
물론, 이는 두 경로를 차례로 통과하면 색상이 시계

213
00:14:35,400 --> 00:14:39,380
방향으로 전체 회전의 2/5만큼 감겨진다는 것을 의미합니다.

214
00:14:39,380 --> 00:14:43,740
와인딩의 총량은 합산되며 이것이 핵심이 될 것입니다.

215
00:14:43,740 --> 00:14:47,140
이것은 우리에게 유용할 일종의 간단한 결합입니다.

216
00:14:47,140 --> 00:14:51,980
총 권선량을 말할 때 화살표가 시계 방향으로 회전하면 앞으로 움직이고 화살표가 시계

217
00:14:51,980 --> 00:14:58,700
반대 방향으로 회전하면 뒤로 움직이는 구식 주행 거리계를 상상해 보시기 바랍니다.

218
00:14:58,700 --> 00:15:03,020
따라서 시계 반대 방향 권선은 음의 시계 방향 권선으로 간주됩니다.

219
00:15:03,020 --> 00:15:07,460
출력이 많이 회전할 수 있지만 회전

220
00:15:07,460 --> 00:15:08,940
중 일부가 반대 방향이면 상쇄됩니다.

221
00:15:08,940 --> 00:15:13,220
예를 들어, 이 경로를 따라 앞으로 이동한 다음 동일한

222
00:15:13,220 --> 00:15:18,100
경로를 따라 뒤로 이동하면 총 감기 양은 0이 되고,

223
00:15:18,100 --> 00:15:23,440
뒤로 이동은 말 그대로 이전에 본 색상을 통해 되감기하여

224
00:15:23,440 --> 00:15:26,300
모든 이전 감기를 반전하고 주행 거리계가 시작된 곳으로 돌아갑니다.

225
00:15:26,300 --> 00:15:30,480
우리의 목적을 위해 우리는 루프를 따라 감기는 것을 보는 데 가장 관심을 가질 것입니다.

226
00:15:30,480 --> 00:15:34,280
예를 들어, 이 전체 루프를 시계 방향으로 돌고 있다고 가정해 보겠습니다.

227
00:15:34,280 --> 00:15:39,680
우리가 접하게 되는 출력은 시계 방향으로 총 3바퀴를 돌며, 색상은

228
00:15:39,680 --> 00:15:47,120
빨간색에서 다시 빨간색으로, 그리고 다시 빨간색으로 순서대로 무지개를 통해 회전합니다.

229
00:15:47,120 --> 00:15:52,260
수학자들이 사용하는 전문 용어에서는 이 루프를

230
00:15:52,260 --> 00:15:54,100
따라 총 와인딩 수는 3이라고 말합니다.

231
00:15:54,100 --> 00:15:58,440
다른 루프의 경우 다른 정수일 수 있으며, 입력이 단일 루프 주위를 이동할

232
00:15:58,440 --> 00:16:03,680
때 출력이 여러 번 회전하는 경우 더 큰 숫자가 될 수 있고,

233
00:16:03,720 --> 00:16:07,060
출력이 한두 번만 회전하는 경우 더 작은 숫자가 될 수 있습니다.

234
00:16:07,060 --> 00:16:12,260
또는 루프를 시계 방향으로 돌 때 출력이 시계 반대 방향으로

235
00:16:12,260 --> 00:16:15,200
흔들리는 경우 해당 굴곡 숫자는 음의 정수일 수도 있습니다.

236
00:16:15,200 --> 00:16:19,720
그러나 어떤 루프에서든 이 총 권선 양은 정수여야 합니다.

237
00:16:19,720 --> 00:16:23,980
내 말은, 시작한 곳으로 돌아올 때쯤에는 시작한

238
00:16:23,980 --> 00:16:25,840
것과 동일한 결과를 얻게 될 것이라는 뜻입니다.

239
00:16:25,840 --> 00:16:31,520
덧붙여서, 경로에 실제로 출력이 정확히 0인 지점이 포함되어

240
00:16:31,560 --> 00:16:35,640
있는 경우 출력에 특정 방향이 없기 때문에 기술적으로

241
00:16:35,640 --> 00:16:37,600
이를 따라 굴곡 수를 정의할 수 없습니다.

242
00:16:37,600 --> 00:16:41,740
이것은 우리에게 문제가 되지 않을 것입니다. 왜냐하면 우리의 전체 목표는 0을 찾는

243
00:16:41,740 --> 00:16:45,200
것이기 때문입니다. 따라서 이런 일이 발생하더라도 우리는 일찍 운이 좋았을 뿐입니다.

244
00:16:45,200 --> 00:16:48,720
이러한 구불구불한 숫자에 대해 주목해야 할 가장 중요한 점은 경로를

245
00:16:48,720 --> 00:16:55,040
더 큰 경로로 결합할 때 그 숫자가 멋지게 합산된다는 것입니다.

246
00:16:55,040 --> 00:16:59,440
그러나 우리가 정말로 원하는 것은 지역을 결합하여 더 큰 지역을

247
00:16:59,440 --> 00:17:03,120
만들 때 지역 경계를 따라 구불구불한 숫자가 멋지게 합산되는 것입니다.

248
00:17:03,120 --> 00:17:06,320
그럼 우리는 그 재산을 갖고 있나요?

249
00:17:06,320 --> 00:17:09,600
글쎄, 한번보세요.

250
00:17:09,600 --> 00:17:14,760
왼쪽에 있는 이 지역을 시계 방향으로 돌면서 구불구불한

251
00:17:14,760 --> 00:17:17,920
숫자는 이 네 경로의 구불구불한 숫자의 합입니다.

252
00:17:17,920 --> 00:17:21,960
그리고 오른쪽에 있는 이 지역을 시계 방향으로 회전하는

253
00:17:21,960 --> 00:17:25,480
구불구불한 부분은 이 네 경로의 구불구불한 숫자의 합입니다.

254
00:17:25,480 --> 00:17:29,840
그리고 이 두 지역을 더 큰 지역으로 결합하면 대부분의

255
00:17:29,840 --> 00:17:33,760
경로가 더 큰 지역의 시계 방향 경계의 일부가 됩니다.

256
00:17:33,760 --> 00:17:36,040
그렇지 않은 두 경로는 무엇입니까?

257
00:17:36,040 --> 00:17:40,520
그것들은 완벽하게 상쇄됩니다. 그 중 하나는 우리가

258
00:17:40,520 --> 00:17:42,660
전에 본 것처럼 다른 하나의 역방향입니다.

259
00:17:42,660 --> 00:17:48,840
따라서 지역 경계를 따라 구불구불한 숫자는 우리가 원하는 방식으로 합산됩니다.

260
00:17:48,840 --> 00:17:53,560
또한 참고로, 이렇게 멋지게 합산되는 지향성 경계에 대한 추론은

261
00:17:53,560 --> 00:17:57,320
수학에서 많이 나타나며 종종 스톡스의 정리라는 이름으로 사용됩니다.

262
00:17:57,320 --> 00:18:02,880
다변수 미적분학을 공부해본 분들이라면 그 맥락에서 이를 인식하실 수도 있습니다.

263
00:18:02,880 --> 00:18:08,040
이제 마침내 구불구불한 숫자를 손에 쥐고 방정식 풀이 목표로 돌아갈 수 있습니다.

264
00:18:08,040 --> 00:18:12,400
앞서 본 영역의 문제점은 경계선이 가능한 모든 색상을

265
00:18:12,400 --> 00:18:16,620
통과했음에도 불구하고 권선 수가 실제로 0이라는 것입니다.

266
00:18:16,620 --> 00:18:22,360
출력은 노란색을 거쳐 빨간색으로 반쯤 감겨진 다음 시계 반대

267
00:18:22,360 --> 00:18:26,000
방향으로 다른 방향으로 돌아가기 시작한 다음 계속해서 파란색을 통과하고

268
00:18:26,000 --> 00:18:32,040
반대쪽에서 빨간색에 도달하여 전체 권선이 0이 되는 방식으로 이루어졌습니다.

269
00:18:32,040 --> 00:18:36,000
그러나 모든 색상에 해당할 뿐만 아니라 0이 아닌 구불구불한 숫자라는

270
00:18:36,000 --> 00:18:41,200
더 강력한 조건을 갖는 루프를 찾은 경우 이를 반으로 분할하면

271
00:18:41,200 --> 00:18:46,400
해당 반쪽 중 적어도 하나는 0이 아닌 굴곡 숫자도 마찬가지입니다.

272
00:18:46,400 --> 00:18:48,600
왜냐하면 모든 것이 우리가 원하는 방식으로 멋지게 추가되기 때문입니다.

273
00:18:48,600 --> 00:18:54,280
따라서 이런 방식으로 계속 진행하면서 한 지점으로 점점 더 범위를 좁힐 수 있습니다.

274
00:18:54,280 --> 00:18:58,440
그리고 한 지점으로 범위를 좁히면 0이 아닌 구불구불한 숫자가 있는

275
00:18:58,440 --> 00:19:02,840
작은 루프를 사용하게 됩니다. 이는 가능한 모든 색상을 통과한다는 것을

276
00:19:02,840 --> 00:19:07,680
의미합니다. 따라서 앞서 말했듯이 지점이 좁아지고 있습니다. on은 0이어야 합니다.

277
00:19:07,680 --> 00:19:08,760
그리고 그게 다야!

278
00:19:08,760 --> 00:19:13,280
이제 우리는 2차원 방정식 솔버를 만들었습니다.

279
00:19:13,280 --> 00:19:14,760
이번에는 버그가 없을 것이라고 약속합니다.

280
00:19:14,760 --> 00:19:18,200
권선 번호는 정확하게 이 작업을 수행하는 데 필요한 도구입니다.

281
00:19:18,200 --> 00:19:23,040
이제 f와 g 사이의 차이가 어떻게 돌아가는지 고려함으로써 2차원에서

282
00:19:23,040 --> 00:19:27,660
f(x)가 g(x)와 어디가 같은지 방정식을 풀 수 있습니다.

283
00:19:27,660 --> 00:19:31,800
굴곡 수가 0이 아닌 루프가 있을 때마다 우리는 이 알고리즘을

284
00:19:31,800 --> 00:19:35,160
루프에서 실행할 수 있으며 루프 내의 어딘가에서 솔루션을 찾도록 보장됩니다.

285
00:19:35,160 --> 00:19:40,300
게다가 한 차원에서와 마찬가지로 이 알고리즘은 놀라울 정도로 효율적입니다.

286
00:19:40,300 --> 00:19:44,880
우리는 매 라운드마다 영역 크기를 절반으로 좁혀서 0으로 빠르게

287
00:19:44,880 --> 00:19:49,840
좁혀지고 그 동안 많은 루프에서 확인하는 대신 이러한 루프의

288
00:19:49,840 --> 00:19:55,240
지점을 따라 함수 값만 확인하면 됩니다. 인테리어 포인트.

289
00:19:55,240 --> 00:20:00,400
따라서 어떤 의미에서 수행된 전체 작업은 전체 영역이

290
00:20:00,400 --> 00:20:04,960
아닌 검색 공간의 둘레에만 비례합니다. 이는 놀라운 일입니다.

291
00:20:04,960 --> 00:20:09,360
이제 무슨 일이 일어나고 있는지 이해하고 나면 이것이 작동하는 모습을

292
00:20:09,360 --> 00:20:13,800
지켜보면서 기능을 제공하고 0을 검색하게 하는 것은 이상하게도 매혹적입니다.

293
00:20:13,800 --> 00:20:18,600
앞서 말한 것처럼 복소수는 2차원이므로

294
00:20:18,600 --> 00:20:20,340
복소수가 있는 방정식에 적용해 보겠습니다.

295
00:20:20,340 --> 00:20:25,240
예를 들어, 복소 평면에서 5번째 빼기 x 빼기

296
00:20:25,240 --> 00:20:28,920
1까지의 함수 x의 영점을 찾는 알고리즘은 다음과 같습니다.

297
00:20:28,920 --> 00:20:33,160
원점 주변의 매우 넓은 영역을 고려하여

298
00:20:33,160 --> 00:20:35,440
시작하여 권선 수는 5가 되었습니다.

299
00:20:35,440 --> 00:20:39,640
0이 아닌 굴곡 번호가 있는 루프를 찾을 때마다 이를

300
00:20:39,640 --> 00:20:42,840
반으로 나누고 두 개의 작은 루프의 굴곡 번호를 알아냅니다.

301
00:20:42,880 --> 00:20:46,880
둘 중 하나 또는 둘 다 0이 아닌 굴곡 숫자를 갖는

302
00:20:46,880 --> 00:20:51,440
것이 보장되며, 이를 보면 작은 루프 내부 어딘가에 0이 있다는 것을

303
00:20:51,440 --> 00:20:54,300
알 수 있으므로 계속해서 동일한 방식으로 더 작은 공간을 검색합니다.

304
00:20:54,300 --> 00:20:58,920
또한 우리가 계산하고 있는 경로가 0을 우연히 발견하면 영역 탐색을

305
00:20:58,920 --> 00:21:03,420
중단합니다. 실제로 여기 오른쪽 절반의 예에서 한 번 발생했습니다.

306
00:21:03,420 --> 00:21:07,600
이러한 드문 현상은 권선 수를

307
00:21:07,600 --> 00:21:09,320
계산하는 능력을 방해하지만 0을 얻었습니다.

308
00:21:09,320 --> 00:21:13,320
그리고 굴곡 수가 0인 루프의 경우 더 이상 탐색하지 않습니다.

309
00:21:13,320 --> 00:21:18,520
내부에 해결책이 있을 수도 있고 없을 수도 있습니다. 우리는 보장할 수 없습니다.

310
00:21:18,520 --> 00:21:22,240
그리고 방정식 솔버가 이와 동일한 방식으로 계속되도록 하면

311
00:21:22,240 --> 00:21:26,020
결국 이 다항식에 대해 많은 0으로 수렴됩니다.

312
00:21:26,020 --> 00:21:30,400
그런데 이 예에서 총 권선

313
00:21:30,400 --> 00:21:31,660
수가 5인 것은 우연이 아닙니다.

314
00:21:31,660 --> 00:21:37,280
복소수의 경우 x에서 n까지의 연산은 입력 원점을 한 번

315
00:21:37,280 --> 00:21:45,000
돌아다니면서 출력 원점을 n번 돌아다니는 것과 직접적으로 일치합니다.

316
00:21:45,000 --> 00:21:50,500
따라서 다항식을 사용하면 입력이 충분히 큰 경우 주요

317
00:21:50,500 --> 00:21:52,700
항을 제외한 모든 항이 비교에서 중요하지 않게 됩니다.

318
00:21:52,700 --> 00:21:58,780
따라서 선행항이 x에서 n까지인 모든 복소 다항식은 충분히

319
00:21:58,780 --> 00:22:00,700
큰 루프 주위에 n의 굴곡 수를 갖습니다.

320
00:22:00,700 --> 00:22:06,240
그런 식으로 우리의 굴곡수 기술은 실제로

321
00:22:06,240 --> 00:22:07,620
모든 복소 다항식에 0이 있음을 보장합니다.

322
00:22:07,620 --> 00:22:13,880
이는 수학자들이 대수학의 기본 정리라고 부를 만큼 중요한 사실입니다.

323
00:22:13,880 --> 00:22:18,040
이와 같은 방정식에 대한 수치적 해를 찾는 알고리즘을 갖는

324
00:22:18,040 --> 00:22:22,420
것은 매우 실용적이지만 대수학의 기본 정리는 이러한 구불구불한 숫자가

325
00:22:22,420 --> 00:22:27,780
이론적 수준에서도 매우 유용하여 광범위한 클래스에 대한 해의

326
00:22:27,780 --> 00:22:32,280
존재를 보장하는 방법을 보여주는 좋은 예입니다. 적합한 조건에 대한

327
00:22:32,280 --> 00:22:34,060
방정식은 수학자들이 생각하고 싶어하는 종류에 훨씬 더 가깝습니다.

328
00:22:34,400 --> 00:22:39,360
후속 비디오에서 토폴로지 맥락에서 이에 대한 몇 가지 놀라운 응용

329
00:22:39,360 --> 00:22:44,080
프로그램을 보여 드리겠습니다. 여기에는 오래된 3blue1brown 비디오의 실수 수정이 포함됩니다.

330
00:22:44,080 --> 00:22:45,080
어느 것?

331
00:22:45,080 --> 00:22:48,740
이 채널의 모든 동영상과 모든 내용을 시청하고

332
00:22:48,740 --> 00:22:51,640
먼저 오류를 발견할 수 있는지 확인하세요.

333
00:22:51,640 --> 00:22:55,960
이 비디오의 주요 작성자는 3blue1brown의 최신

334
00:22:55,960 --> 00:22:56,460
팀원 중 한 명인 Sridhar Ramesh입니다.

