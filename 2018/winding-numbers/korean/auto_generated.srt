1
00:00:03,060 --> 00:00:05,047
여기에는 기본 주제와 메타 주제라는 

2
00:00:05,047 --> 00:00:06,140
두 가지가 있습니다.

3
00:00:06,640 --> 00:00:10,161
주요 주제는 2차원 방정식, 두 개의 알려지지 않은 

4
00:00:10,161 --> 00:00:13,440
실수 또는 복소수인 단일 미지수와 관련된 문제를 

5
00:00:13,440 --> 00:00:16,840
해결하기 위한 정말 깔끔한 알고리즘이 될 것입니다.

6
00:00:17,440 --> 00:00:20,460
예를 들어, 다항식의 복소수 근을 찾고 싶거나 

7
00:00:20,460 --> 00:00:23,479
리만 제타 함수의 백만 달러짜리 0 중 일부를 

8
00:00:23,479 --> 00:00:26,500
찾고 싶다면 이 알고리즘이 대신해 줄 것입니다.

9
00:00:26,800 --> 00:00:28,633
그리고 이 방법은 정말 예쁜데, 

10
00:00:28,633 --> 00:00:30,060
많은 색상이 들어가거든요.

11
00:00:30,540 --> 00:00:32,968
그리고 더 중요한 것은 핵심 기본 아이디어가 

12
00:00:32,968 --> 00:00:35,300
나중에 이야기할 약간의 위상수학을 포함하여 

13
00:00:35,300 --> 00:00:37,437
방정식을 풀기 위한 이 알고리즘을 훨씬 

14
00:00:37,437 --> 00:00:40,060
넘어서는 모든 종류의 수학에 적용된다는 것입니다.

15
00:00:40,740 --> 00:00:43,342
하지만 이 시간을 실제로 20분 정도의 

16
00:00:43,342 --> 00:00:46,182
가치로 만드는 것은 수학 전반에 걸쳐 훨씬 

17
00:00:46,182 --> 00:00:48,903
더 일반적으로 유용한 교훈, 즉 서로 잘 

18
00:00:48,903 --> 00:00:51,980
구성되는 구성을 정의하려고 시도한다는 점입니다.

19
00:00:52,400 --> 00:00:53,570
이야기가 진행되면서 이것이 무슨 

20
00:00:53,570 --> 00:00:54,480
뜻인지 알게 될 것입니다.

21
00:00:55,060 --> 00:00:57,904
2D 입력과 2D 출력이 있는 함수로 사례를 

22
00:00:57,904 --> 00:01:00,862
동기를 부여하기 위해 실수를 받아들이고 실수를 

23
00:01:00,862 --> 00:01:03,820
뱉어내는 함수로 더 간단하게 시작해 보겠습니다.

24
00:01:05,080 --> 00:01:07,947
x의 함수 f가 x의 다른 함수 g와 언제 

25
00:01:07,947 --> 00:01:11,174
같은지 알고 싶다면, 이를 해당 함수의 그래프가 

26
00:01:11,174 --> 00:01:14,520
교차하는 때를 검색하는 것으로 생각할 수 있습니다.

27
00:01:15,020 --> 00:01:16,817
즉, 두 함수 모두 동일한 출력을 

28
00:01:16,817 --> 00:01:18,520
갖는 입력을 제공한다는 뜻입니다.

29
00:01:18,520 --> 00:01:22,109
매우 간단한 예를 들어, f(x)가 x 제곱이고 

30
00:01:22,109 --> 00:01:25,300
g(x)가 상수 함수 2라고 상상해 보세요.

31
00:01:25,960 --> 00:01:28,640
즉, 2의 제곱근을 구하려는 것입니다.

32
00:01:29,460 --> 00:01:32,560
제곱근을 찾는 것에 대해 거의 아무것도 모르더라도 

33
00:01:32,560 --> 00:01:35,770
1의 제곱은 2보다 작고 2의 제곱은 2보다 크다는 

34
00:01:35,770 --> 00:01:38,870
것을 알 수 있으므로 아, 이 두 값 사이에 어떤 

35
00:01:38,870 --> 00:01:41,860
해결책이 있을 것이라는 것을 깨닫게 될 것입니다.

36
00:01:42,580 --> 00:01:44,979
그런 다음 범위를 더 좁히고 싶다면 

37
00:01:44,979 --> 00:01:47,140
중간점인 1을 제곱해 보세요.5.

38
00:01:47,720 --> 00:01:50,675
이는 2로 나옵니다.25는 약간 높으므로 

39
00:01:50,675 --> 00:01:53,760
1과 1 사이의 영역에 집중하게 됩니다.5.

40
00:01:54,760 --> 00:01:56,782
계속해서 이것이 어떻게 계속 진행되는지 

41
00:01:56,782 --> 00:01:58,713
알 수 있습니다. 중간 지점에서 계속 

42
00:01:58,713 --> 00:02:00,920
계산한 다음 검색 공간을 절반으로 줄입니다.

43
00:02:05,100 --> 00:02:08,573
이에 대해 생각하는 또 다른 방법은 더 높은 차원에 

44
00:02:08,573 --> 00:02:12,166
도달하면 더 쉽게 만들 수 있으며 대신 이 두 함수의 

45
00:02:12,166 --> 00:02:15,520
차이가 0일 때의 동등한 질문에 집중하는 것입니다.

46
00:02:16,100 --> 00:02:19,736
이러한 관점에서 우리는 그 차이가 한쪽 끝에서는 

47
00:02:19,736 --> 00:02:23,237
음수이고 다른 쪽 끝에서는 양수인 입력 영역을 

48
00:02:23,237 --> 00:02:24,180
발견했습니다.

49
00:02:24,180 --> 00:02:26,271
우리는 그것을 두 개로 나누고, 

50
00:02:26,271 --> 00:02:28,827
우리가 주의를 좁힌 절반은 가장 바깥쪽 

51
00:02:28,827 --> 00:02:31,500
지점에 다양한 부호가 있는 부분이었습니다.

52
00:02:31,500 --> 00:02:34,784
이렇게 우리는 국경에 다양한 표지판이 있는 각 지역을 

53
00:02:34,784 --> 00:02:37,850
선택하고 절반 중에서 더 작은 지역을 찾아 영원히 

54
00:02:37,850 --> 00:02:41,134
계속할 수 있었습니다. 궁극적으로 우리는 정확히 0이 

55
00:02:41,134 --> 00:02:44,200
될 지점으로 좁아져야 한다는 것을 알고 있었습니다.

56
00:02:45,760 --> 00:02:48,351
간단히 말해서, 방정식을 푸는 것은 항상 특정 

57
00:02:48,351 --> 00:02:50,942
함수가 0과 같을 때를 찾는 것으로 구성될 수 

58
00:02:50,942 --> 00:02:53,434
있으며, 그렇게 하기 위해 우리는 이 경험적 

59
00:02:53,434 --> 00:02:56,026
방법을 사용합니다. f가 한 지점에서 양수이고 

60
00:02:56,026 --> 00:02:58,717
다른 지점에서 음수인 경우, 그 사이의 어딘가를 

61
00:02:58,717 --> 00:03:01,408
찾을 수 있습니다. 적어도 갑작스러운 점프 없이 

62
00:03:01,408 --> 00:03:03,900
모든 것이 순조롭게 변한다면 그것은 0입니다.

63
00:03:03,900 --> 00:03:06,988
제가 여러분께 보여드리고 싶은 놀라운 점은 이런 

64
00:03:06,988 --> 00:03:08,932
종류의 사고를 2차원 방정식, 

65
00:03:08,932 --> 00:03:12,364
즉 입력과 출력이 모두 2차원인 함수 간의 방정식으로 

66
00:03:12,364 --> 00:03:14,080
확장할 수 있다는 것입니다.

67
00:03:14,739 --> 00:03:17,951
예를 들어 복소수는 2차원이며 우리가 개발 중인 

68
00:03:17,951 --> 00:03:21,400
이 도구는 복잡한 방정식의 해를 찾는 데 적합합니다.

69
00:03:22,360 --> 00:03:24,289
이제 이러한 2D 기능에 대해 많이 

70
00:03:24,289 --> 00:03:26,218
이야기할 것이므로 잠시 옆으로 가서 

71
00:03:26,218 --> 00:03:28,340
이를 설명하는 방법을 고려해 보겠습니다.

72
00:03:29,060 --> 00:03:31,940
2D 입력 및 2D 출력을 사용하여 함수를 

73
00:03:31,940 --> 00:03:34,820
그래프로 표시하려면 4차원이 필요하며 2D 

74
00:03:34,820 --> 00:03:37,700
화면의 3D 세계에서는 잘 작동하지 않지만 

75
00:03:37,700 --> 00:03:40,220
여전히 몇 가지 좋은 옵션이 있습니다.

76
00:03:40,859 --> 00:03:45,440
하나는 입력 공간과 출력 공간을 나란히 보는 것입니다.

77
00:03:45,540 --> 00:03:49,071
입력 공간의 각 지점은 출력 공간의 특정 지점으로 

78
00:03:49,071 --> 00:03:52,728
이동하며 해당 입력 지점 주위의 이동이 출력 공간의 

79
00:03:52,728 --> 00:03:56,260
특정 이동에 어떻게 대응되는지 보여줄 수 있습니다.

80
00:03:56,940 --> 00:04:00,060
우리가 고려하는 모든 기능은 입력의 작은 

81
00:04:00,060 --> 00:04:02,908
변화가 출력의 작은 변화에만 해당하고 

82
00:04:02,908 --> 00:04:06,300
갑작스러운 점프가 없다는 점에서 연속적입니다.

83
00:04:06,940 --> 00:04:10,109
또 다른 옵션은 출력 공간의 원점에서 해당 

84
00:04:10,109 --> 00:04:13,014
출력 지점까지의 화살표를 상상하고 해당 

85
00:04:13,014 --> 00:04:16,579
화살표의 축소판을 입력 지점에 연결하는 것입니다.

86
00:04:17,360 --> 00:04:20,264
이를 통해 주어진 입력 지점이 어디로 가는지 

87
00:04:20,264 --> 00:04:22,935
또는 전체 벡터 필드를 그려 다양한 입력 

88
00:04:22,935 --> 00:04:25,840
지점이 어디로 가는지 한눈에 알 수 있습니다.

89
00:04:27,600 --> 00:04:29,739
불행하게도 많은 지점에서 이 작업을 수행하면 

90
00:04:29,739 --> 00:04:31,879
상당히 복잡해질 수 있으므로 여기에서는 모든 

91
00:04:31,879 --> 00:04:33,676
화살표를 동일한 크기로 만들겠습니다. 

92
00:04:33,676 --> 00:04:35,816
이것이 의미하는 바는 각 출력 지점의 방향을 

93
00:04:35,816 --> 00:04:37,100
파악할 수 있다는 것입니다.

94
00:04:37,780 --> 00:04:40,544
그러나 아마도 2차원 함수를 설명하는 가장 멋진 

95
00:04:40,544 --> 00:04:43,308
방법이자 이 비디오에서 가장 많이 사용할 방법은 

96
00:04:43,308 --> 00:04:46,380
해당 출력 공간의 각 점을 색상과 연관시키는 것입니다.

97
00:04:47,220 --> 00:04:50,376
여기서 우리는 원점에서 멀어지는 방향에 대응하기 

98
00:04:50,376 --> 00:04:53,064
위해 색상(색상이 무지개나 색상환을 따라 

99
00:04:53,064 --> 00:04:55,870
떨어지는 위치)을 사용했고, 원점으로부터의 

100
00:04:55,870 --> 00:04:59,260
거리에 대응하기 위해 어두움이나 밝기를 사용했습니다.

101
00:04:59,260 --> 00:05:02,367
예를 들어, 이 출력 배열에 초점을 맞추면 

102
00:05:02,367 --> 00:05:05,605
이러한 점은 모두 빨간색이지만 원점에 가까운 

103
00:05:05,605 --> 00:05:08,972
점은 조금 더 어둡고 멀리 있는 점은 조금 더 

104
00:05:08,972 --> 00:05:09,620
밝습니다.

105
00:05:10,360 --> 00:05:14,170
이 출력 배열에 초점을 맞추면 모든 점이 녹색이고 

106
00:05:14,170 --> 00:05:17,980
원점에 가까울수록 어두워지고 멀어질수록 밝아집니다.

107
00:05:18,780 --> 00:05:21,507
그리고 여기서 우리가 하는 일은 각 방향에 특정 

108
00:05:21,507 --> 00:05:24,335
색상을 할당하는 것뿐입니다. 모든 방향은 계속해서 

109
00:05:24,335 --> 00:05:24,840
변합니다.

110
00:05:25,359 --> 00:05:28,532
여기서는 어두움과 밝기의 차이가 매우 미묘하다는 것을 

111
00:05:28,532 --> 00:05:31,493
알 수 있지만, 이 비디오에서 우리가 관심을 갖는 

112
00:05:31,493 --> 00:05:34,560
것은 출력의 방향이지 크기나 색상, 밝기가 아닙니다.

113
00:05:35,300 --> 00:05:37,869
밝기에 대해 주목해야 할 한 가지 중요한 

114
00:05:37,869 --> 00:05:40,327
점은 특정 방향이 없는 원점 근처에서는 

115
00:05:40,327 --> 00:05:43,120
모든 색상이 검은색으로 희미해진다는 것입니다.

116
00:05:44,440 --> 00:05:47,411
함수에 대해 생각해 보면 이제 각 출력의 

117
00:05:47,411 --> 00:05:50,640
색상을 결정했으므로 출력 공간에 있는 지점의 

118
00:05:50,640 --> 00:05:53,482
색상을 기반으로 입력 공간의 각 지점에 

119
00:05:53,482 --> 00:05:57,100
색상을 지정하여 2D 기능을 시각화할 수 있습니다.

120
00:05:57,840 --> 00:06:01,001
나는 입력 공간의 다양한 지점이 출력 공간의 

121
00:06:01,001 --> 00:06:03,783
해당 출력으로 이동한 다음 착륙 지점의 

122
00:06:03,783 --> 00:06:06,818
색상을 기반으로 칠해진 다음 입력 공간에서 

123
00:06:06,818 --> 00:06:10,360
원래 위치로 다시 이동하는 것을 상상하고 싶습니다.

124
00:06:11,640 --> 00:06:13,572
입력 공간의 모든 점에 대해 이 작업을 

125
00:06:13,572 --> 00:06:15,680
수행하면 해당 입력 공간을 살펴보면 함수가 

126
00:06:15,680 --> 00:06:18,140
각 점을 대략적으로 취하는 위치를 알 수 있습니다.

127
00:06:18,140 --> 00:06:21,660
예를 들어, 왼쪽에 있는 분홍색 점 줄무늬는 

128
00:06:21,660 --> 00:06:25,040
모든 점이 출력 공간의 왼쪽 아래인 분홍색 

129
00:06:25,040 --> 00:06:28,280
방향 어딘가에 매핑된다는 것을 나타냅니다.

130
00:06:29,780 --> 00:06:32,070
또한 주위에 많은 색상이 있고 

131
00:06:32,070 --> 00:06:34,900
검은색인 세 점은 0이 되는 점입니다.

132
00:06:39,340 --> 00:06:42,387
좋습니다. 1D의 경우와 마찬가지로 2D 

133
00:06:42,387 --> 00:06:45,700
함수의 방정식을 푸는 것도 특정 함수가 언제 

134
00:06:45,700 --> 00:06:48,880
0인지 묻는 방식으로 재구성할 수 있습니다.

135
00:06:49,580 --> 00:06:53,075
이것이 바로 지금 우리의 과제입니다. 

136
00:06:53,075 --> 00:06:56,738
주어진 2D 함수의 어느 입력 포인트가 

137
00:06:56,738 --> 00:07:00,900
0이 되는지 찾는 알고리즘을 만드는 것입니다.

138
00:07:00,900 --> 00:07:03,366
검은색 점을 보고 이와 같은 색상 지도를 

139
00:07:03,366 --> 00:07:05,726
보고 있다면 함수의 0이 어디에 있는지 

140
00:07:05,726 --> 00:07:08,300
이미 알고 있다는 점을 지적할 수 있습니다.

141
00:07:08,620 --> 00:07:11,080
그럼 그게 중요해?

142
00:07:11,080 --> 00:07:14,413
이와 같은 다이어그램을 만들기 위해 컴퓨터가 평면의 

143
00:07:14,413 --> 00:07:17,860
모든 픽셀에서 함수를 계산하도록 했지만 우리의 목표는 

144
00:07:17,860 --> 00:07:21,308
가능한 한 적은 수의 지점에서만 함수를 계산해야 하는 

145
00:07:21,308 --> 00:07:24,182
보다 효율적인 알고리즘을 찾는 것입니다. , 

146
00:07:24,182 --> 00:07:27,285
말하자면 색상에 대한 제한된 시각만 가지고 있는 

147
00:07:27,285 --> 00:07:27,860
것입니다.

148
00:07:29,360 --> 00:07:32,033
또한 좀 더 이론적인 관점에서 볼 때, 

149
00:07:32,033 --> 00:07:35,192
주어진 영역 내에 0이 존재하는지 여부에 대한 

150
00:07:35,192 --> 00:07:38,472
조건을 알려주는 일반적인 구조를 갖는 것이 좋을 

151
00:07:38,472 --> 00:07:39,080
것입니다.

152
00:07:39,080 --> 00:07:41,947
한 차원에서 주요 통찰력은 연속 함수가 한 

153
00:07:41,947 --> 00:07:44,933
지점에서는 양수이고 다른 지점에서는 음수이면 

154
00:07:44,933 --> 00:07:47,920
그 사이의 어딘가는 0이어야 한다는 것입니다.

155
00:07:48,840 --> 00:07:50,580
그러면 어떻게 이를 2차원으로 확장할 수 있을까요?

156
00:07:50,940 --> 00:07:52,337
우리는 표지판에 대해 이야기하는 

157
00:07:52,337 --> 00:07:53,580
일종의 아날로그가 필요합니다.

158
00:07:54,700 --> 00:07:58,140
표지판이 무엇인지 생각하는 한 가지 방법은 방향입니다.

159
00:07:58,800 --> 00:08:01,244
양수는 수직선을 따라 오른쪽을 가리키고 있다는 

160
00:08:01,244 --> 00:08:03,500
뜻이고, 음수는 왼쪽을 가리킨다는 뜻입니다.

161
00:08:04,200 --> 00:08:06,733
2차원 수량에도 방향이 있지만 옵션이 

162
00:08:06,733 --> 00:08:09,266
훨씬 더 넓어서 가능성의 전체 범위를 

163
00:08:09,266 --> 00:08:11,800
따라 어느 곳이든 가리킬 수 있습니다.

164
00:08:12,530 --> 00:08:15,949
따라서 1차원에서 우리는 주어진 함수가 단지 

165
00:08:15,949 --> 00:08:19,506
2개의 점인 범위의 경계에서 양수인지 음수인지 

166
00:08:19,506 --> 00:08:22,926
묻는 것과 같은 방식으로 2차원 함수에 대해 

167
00:08:22,926 --> 00:08:25,935
우리는 영역의 경계를 살펴볼 것입니다. 

168
00:08:25,935 --> 00:08:29,492
루프이며 해당 경계를 따라 함수 출력의 방향에 

169
00:08:29,492 --> 00:08:30,860
대해 물어보십시오.

170
00:08:33,640 --> 00:08:36,389
예를 들어, 이 0을 중심으로 하는 이 루프를 

171
00:08:36,389 --> 00:08:39,561
따라 출력은 가능한 모든 방향, 무지개의 모든 색상, 

172
00:08:39,561 --> 00:08:42,627
빨간색, 노란색, 녹색, 파란색, 다시 빨간색으로, 

173
00:08:42,627 --> 00:08:45,060
그리고 그 사이의 모든 색상을 통과합니다.

174
00:08:45,700 --> 00:08:48,506
하지만 여기에 있는 이 루프를 따라 0이 없으면 

175
00:08:48,506 --> 00:08:51,209
출력이 모든 색상을 통과하지 않고 일부 주황색 

176
00:08:51,209 --> 00:08:54,120
색상을 통과하지만 결코 녹색이나 파란색은 통과하지 

177
00:08:54,120 --> 00:08:54,640
않습니다.

178
00:08:55,300 --> 00:08:57,017
그리고 이것은 유망합니다. 일이 한 차원에서 

179
00:08:57,017 --> 00:08:58,460
작동하는 방식과 매우 비슷해 보입니다.

180
00:08:59,340 --> 00:09:02,718
아마도 1d 함수가 1d 영역의 경계에서 가능한 

181
00:09:02,718 --> 00:09:06,096
두 부호를 모두 취하면 내부 어딘가에 0이 있는 

182
00:09:06,096 --> 00:09:09,349
것과 같은 방식으로, 2d 함수가 영역을 따라 

183
00:09:09,349 --> 00:09:12,602
가능한 모든 방향, 가능한 모든 색상의 출력에 

184
00:09:12,602 --> 00:09:14,855
도달한다고 가정할 수 있습니다. 

185
00:09:14,855 --> 00:09:18,483
2D 영역의 경계가 있으면 해당 영역 내부 어딘가에 

186
00:09:18,483 --> 00:09:19,860
0이 되어야 합니다.

187
00:09:20,960 --> 00:09:23,880
이것이 우리의 추측입니다. 이것이 사실이어야 하는지, 

188
00:09:23,880 --> 00:09:26,120
그렇다면 왜 그런지 잠시 생각해 보십시오.

189
00:09:27,420 --> 00:09:30,338
어떤 입력 지점 주변의 작은 루프에 대해 생각하기 

190
00:09:30,338 --> 00:09:33,257
시작하면 모든 것이 연속적이므로 함수가 해당 출력 

191
00:09:33,257 --> 00:09:36,280
근처의 작은 루프로 이동한다는 것을 알 수 있습니다.

192
00:09:37,140 --> 00:09:38,829
하지만 대부분의 작은 루프의 

193
00:09:38,829 --> 00:09:40,520
경우 출력 색상이 다양합니다.

194
00:09:40,980 --> 00:09:43,793
0이 아닌 출력 지점을 선택하고 그 근처에 

195
00:09:43,793 --> 00:09:46,606
충분히 촘촘한 루프를 그리면 루프의 색상은 

196
00:09:46,606 --> 00:09:49,420
모두 해당 지점과 거의 같은 색상이 됩니다.

197
00:09:49,840 --> 00:09:52,310
여기의 촘촘한 고리는 모두 푸르스름하고, 

198
00:09:52,310 --> 00:09:54,780
여기의 촘촘한 고리는 모두 노란색입니다. 

199
00:09:54,780 --> 00:09:57,680
확실히 무지개의 모든 색상을 얻을 수는 없습니다.

200
00:09:58,220 --> 00:10:02,190
모든 색상을 얻으면서 주변의 루프를 조일 수 

201
00:10:02,190 --> 00:10:06,320
있는 유일한 지점은 무색 원점인 0 자체입니다.

202
00:10:07,100 --> 00:10:09,844
따라서 무지개의 모든 색상을 통과하고 

203
00:10:09,844 --> 00:10:12,981
조이고 조이고 한 지점에서 좁아지는 루프가 

204
00:10:12,981 --> 00:10:16,380
있는 경우 해당 지점은 실제로 0이어야 합니다.

205
00:10:17,320 --> 00:10:19,590
이제 1차원 방정식 솔버와 마찬가지로 

206
00:10:19,590 --> 00:10:21,860
2D 방정식 솔버를 설정해 보겠습니다.

207
00:10:22,260 --> 00:10:24,886
경계가 모든 색상을 통과하는 큰 영역을 

208
00:10:24,886 --> 00:10:27,393
찾으면 이를 두 개로 분할한 다음 각 

209
00:10:27,393 --> 00:10:29,900
절반의 경계에 있는 색상을 살펴봅니다.

210
00:10:30,540 --> 00:10:33,123
여기에 표시된 예에서는 왼쪽 절반의 테두리가 

211
00:10:33,123 --> 00:10:34,983
모든 색상을 통과하지 않습니다. 

212
00:10:34,983 --> 00:10:37,773
예를 들어 주황색을 띤 노란색 방향으로 매핑되는 

213
00:10:37,773 --> 00:10:38,600
점이 없습니다.

214
00:10:39,060 --> 00:10:40,759
따라서 더 이상 검색하고 싶지 않다는 

215
00:10:40,759 --> 00:10:42,620
의미로 이 영역을 회색으로 표시하겠습니다.

216
00:10:43,380 --> 00:10:45,686
오른쪽 절반은 모든 색상을 통과하고 녹색 

217
00:10:45,686 --> 00:10:47,892
방향에서 많은 시간을 보낸 다음 노란색 

218
00:10:47,892 --> 00:10:50,700
주황색 빨간색과 파란색 보라색 분홍색을 통과합니다.

219
00:10:51,560 --> 00:10:54,403
이제 이것이 의미하는 바는 이 경계의 지점이 

220
00:10:54,403 --> 00:10:57,360
가능한 모든 방향의 출력에 매핑된다는 것입니다.

221
00:10:57,840 --> 00:10:59,448
그래서 좀 더 자세히 살펴보고, 

222
00:10:59,448 --> 00:11:01,860
다시 세분화하여 각 지역의 경계를 확인하겠습니다.

223
00:11:02,880 --> 00:11:04,775
상단의 경계는 모두 녹색이므로 

224
00:11:04,775 --> 00:11:06,560
거기서 검색을 중지하겠습니다.

225
00:11:06,860 --> 00:11:09,520
하지만 바닥은 세분화할 가치가 있을 만큼 컬러풀합니다.

226
00:11:10,340 --> 00:11:12,020
그리고 이대로 계속하세요.

227
00:11:12,360 --> 00:11:15,188
가능한 모든 색상을 포함하는 경계가 있는 하위 

228
00:11:15,188 --> 00:11:17,907
영역을 확인합니다. 즉, 해당 경계의 지점이 

229
00:11:17,907 --> 00:11:20,518
가능한 모든 방향에 매핑된다는 의미입니다. 

230
00:11:20,518 --> 00:11:23,455
그리고 1차원 경우에서 했던 것처럼 해당 영역을 

231
00:11:23,455 --> 00:11:26,609
계속 반으로 자르고 결국 기능에 대한 0이 됩니다. 

232
00:11:26,609 --> 00:11:27,480
아, 잠깐만요.

233
00:11:28,880 --> 00:11:29,920
여기 뭔 일 있었 니?

234
00:11:30,380 --> 00:11:32,835
오른쪽 하단에 있는 마지막 하위 구분 중 어느 

235
00:11:32,835 --> 00:11:35,291
것도 모든 색상을 통과하지 못했기 때문에 우리 

236
00:11:35,291 --> 00:11:37,747
알고리즘은 둘 중 하나를 검색하고 싶지 않았기 

237
00:11:37,747 --> 00:11:39,920
때문에 중지되었지만 0도 찾지 못했습니다.

238
00:11:41,060 --> 00:11:43,300
좋아요, 분명히 뭔가 문제가 있는 것 같습니다.

239
00:11:43,540 --> 00:11:44,848
그리고 괜찮아요. 틀린다는 것은 

240
00:11:44,848 --> 00:11:46,520
수학을 하는 데 있어 일반적인 부분입니다.

241
00:11:46,520 --> 00:11:48,673
돌이켜보면 우리는 이런 가설을 세웠고, 

242
00:11:48,673 --> 00:11:50,630
그것이 제안한 알고리즘으로 이어졌기 

243
00:11:50,630 --> 00:11:52,980
때문에 어딘가에서 착각하고 있었던 것입니다.

244
00:11:53,660 --> 00:11:56,406
그리고 수학을 잘한다는 것은 처음부터 옳다는 것이 

245
00:11:56,406 --> 00:11:58,955
아니라, 주의 깊게 되돌아보고 실수를 이해하고 

246
00:11:58,955 --> 00:12:01,800
이를 고치는 방법을 이해하는 회복력을 갖는 것입니다.

247
00:12:02,480 --> 00:12:05,026
이제 여기서 문제는 경계가 모든 색상을 통과하는 

248
00:12:05,026 --> 00:12:07,572
지역이 있다는 것입니다. 하지만 중간에 분할했을 

249
00:12:07,572 --> 00:12:09,930
때 하위 지역의 경계가 모든 색상을 통과하지 

250
00:12:09,930 --> 00:12:12,382
않았고 다음에 계속 검색할 위치에 대한 옵션이 

251
00:12:12,382 --> 00:12:14,740
없었으며 이로 인해 0이 깨졌습니다. 파인더.

252
00:12:14,740 --> 00:12:16,190
이제 한 차원에서는 이런 종류의 

253
00:12:16,190 --> 00:12:17,560
일이 결코 일어나지 않았습니다.

254
00:12:17,980 --> 00:12:21,427
끝점에 다른 부호가 있는 간격이 있을 때마다 

255
00:12:21,427 --> 00:12:25,012
이를 분할하면 끝점에도 다른 부호가 있는 일부 

256
00:12:25,012 --> 00:12:28,460
하위 간격이 보장된다는 것을 알 수 있습니다.

257
00:12:29,020 --> 00:12:32,101
또는 달리 말하면, 끝점이 부호를 변경하지 않는 

258
00:12:32,101 --> 00:12:35,298
두 개의 간격이 있을 때마다 이를 결합하면 끝점도 

259
00:12:35,298 --> 00:12:38,380
부호가 변경되지 않는 더 큰 간격을 얻게 됩니다.

260
00:12:39,080 --> 00:12:42,587
그러나 2차원에서는 경계가 모든 색상을 통과하지는 

261
00:12:42,587 --> 00:12:45,718
않지만 경계가 결합되어 모든 색상을 통과하는 

262
00:12:45,718 --> 00:12:49,100
영역을 제공하는 두 영역을 찾는 것이 가능합니다.

263
00:12:49,840 --> 00:12:51,766
그리고 이런 방식으로 우리가 제안한 

264
00:12:51,766 --> 00:12:53,500
영점 찾기 알고리즘이 깨졌습니다.

265
00:12:54,380 --> 00:12:58,517
사실, 생각해 보면 내부에 0이 없이 테두리가 가능한 

266
00:12:58,517 --> 00:13:02,380
모든 색상을 통과하는 큰 루프를 찾을 수 있습니다.

267
00:13:03,080 --> 00:13:05,814
모든 색상을 통과하는 영원히 좁아지는 루프는 

268
00:13:05,814 --> 00:13:08,659
0에서 좁아져야 한다고 우리가 말했을 때 작은 

269
00:13:08,659 --> 00:13:11,613
루프에 대한 우리의 주장이 틀렸다고 말하는 것은 

270
00:13:11,613 --> 00:13:12,160
아닙니다.

271
00:13:12,800 --> 00:13:15,809
그러나 우리를 혼란스럽게 만든 것은 이 속성이 모든 

272
00:13:15,809 --> 00:13:18,819
색상을 통과하는지 여부에 관계없이 지역을 결합할 때 

273
00:13:18,819 --> 00:13:21,621
훌륭하고 예측 가능한 방식으로 결합되지 않는다는 

274
00:13:21,621 --> 00:13:22,140
것입니다.

275
00:13:23,000 --> 00:13:25,480
하지만 걱정하지 마세요. 우리가 원하는 것을 

276
00:13:25,480 --> 00:13:28,060
제공하기 위해 결합하는 좀 더 정교한 속성으로 

277
00:13:28,060 --> 00:13:30,740
이것을 약간 수정할 수 있다는 것이 밝혀졌습니다.

278
00:13:38,180 --> 00:13:41,131
단순히 루프의 특정 지점에서 색상을 찾을 수 

279
00:13:41,131 --> 00:13:44,200
있는지 묻는 대신 루프를 돌면서 이러한 색상이 

280
00:13:44,200 --> 00:13:46,915
어떻게 변하는지 더 주의 깊게 추적하자는 

281
00:13:46,915 --> 00:13:47,860
아이디어입니다.

282
00:13:48,580 --> 00:13:49,960
예를 들어 내가 의미하는 바를 보여 드리겠습니다.

283
00:13:50,400 --> 00:13:51,720
추적하는 데 도움이 되도록 여기 

284
00:13:51,720 --> 00:13:53,260
구석에 작은 색상환을 올려 놓겠습니다.

285
00:13:53,940 --> 00:13:56,465
입력 경로를 따라 색상이 무지개를 통해 

286
00:13:56,465 --> 00:13:58,876
빨간색에서 노란색, 노란색에서 녹색, 

287
00:13:58,876 --> 00:14:01,745
녹색에서 파란색, 파란색에서 빨간색으로 특정 

288
00:14:01,745 --> 00:14:04,960
방향으로 이동하면 출력이 시계 방향으로 회전합니다.

289
00:14:05,700 --> 00:14:08,854
그러나 반면에 색상이 무지개를 통해 파란색에서 녹색, 

290
00:14:08,854 --> 00:14:11,062
녹색에서 노란색, 노란색에서 빨간색, 

291
00:14:11,062 --> 00:14:13,691
빨간색에서 파란색으로 반대 방향으로 이동하면 

292
00:14:13,691 --> 00:14:16,320
출력이 시계 반대 방향으로 흔들리는 것입니다.

293
00:14:17,160 --> 00:14:20,341
따라서 여기 이 짧은 경로를 따라 걸으면 색상은 

294
00:14:20,341 --> 00:14:23,523
색상환을 통해 시계 방향으로 5분의 1 방향으로 

295
00:14:23,523 --> 00:14:26,940
휘어집니다. 그리고 여기 이 경로를 따라 걷는 경우 

296
00:14:26,940 --> 00:14:30,003
색상은 색상환을 통해 시계 방향으로 5분의 1 

297
00:14:30,003 --> 00:14:31,300
방향으로 휘어집니다.

298
00:14:31,300 --> 00:14:33,904
물론, 이는 두 경로를 차례로 통과하면 

299
00:14:33,904 --> 00:14:36,153
색상이 시계 방향으로 전체 회전의 

300
00:14:36,153 --> 00:14:38,640
2/5만큼 감겨진다는 것을 의미합니다.

301
00:14:39,280 --> 00:14:43,395
와인딩의 총량은 합산되며 이것이 핵심이 될 것입니다. 

302
00:14:43,395 --> 00:14:47,100
이것은 우리에게 유용할 일종의 간단한 결합입니다.

303
00:14:47,100 --> 00:14:50,034
총 권선량을 말할 때 화살표가 시계 방향으로 

304
00:14:50,034 --> 00:14:52,617
회전하면 앞으로 움직이고 화살표가 시계 

305
00:14:52,617 --> 00:14:55,434
반대 방향으로 회전하면 뒤로 움직이는 구식 

306
00:14:55,434 --> 00:14:57,900
주행 거리계를 상상해 보시기 바랍니다.

307
00:14:58,740 --> 00:15:00,449
따라서 시계 반대 방향 권선은 

308
00:15:00,449 --> 00:15:02,460
음의 시계 방향 권선으로 간주됩니다.

309
00:15:03,000 --> 00:15:05,630
출력이 많이 회전할 수 있지만 회전 

310
00:15:05,630 --> 00:15:08,260
중 일부가 반대 방향이면 상쇄됩니다.

311
00:15:08,920 --> 00:15:12,276
예를 들어, 이 경로를 따라 앞으로 이동한 다음 

312
00:15:12,276 --> 00:15:15,632
동일한 경로를 따라 뒤로 이동하면 총 감기 양은 

313
00:15:15,632 --> 00:15:18,864
0이 되고, 뒤로 이동은 말 그대로 이전에 본 

314
00:15:18,864 --> 00:15:22,345
색상을 통해 되감기하여 모든 이전 감기를 반전하고 

315
00:15:22,345 --> 00:15:25,080
주행 거리계가 시작된 곳으로 돌아갑니다.

316
00:15:26,280 --> 00:15:27,905
우리의 목적을 위해 우리는 루프를 따라 

317
00:15:27,905 --> 00:15:29,900
감기는 것을 보는 데 가장 관심을 가질 것입니다.

318
00:15:30,440 --> 00:15:32,451
예를 들어, 이 전체 루프를 시계 

319
00:15:32,451 --> 00:15:34,780
방향으로 돌고 있다고 가정해 보겠습니다.

320
00:15:34,780 --> 00:15:38,756
우리가 접하게 되는 출력은 시계 방향으로 총 3바퀴를 

321
00:15:38,756 --> 00:15:41,938
돌며, 색상은 빨간색에서 다시 빨간색으로, 

322
00:15:41,938 --> 00:15:45,384
그리고 다시 빨간색으로 순서대로 무지개를 통해 

323
00:15:45,384 --> 00:15:46,180
회전합니다.

324
00:15:46,920 --> 00:15:50,174
수학자들이 사용하는 전문 용어에서는 이 

325
00:15:50,174 --> 00:15:54,020
루프를 따라 총 와인딩 수는 3이라고 말합니다.

326
00:15:54,020 --> 00:15:56,560
다른 루프의 경우 다른 정수일 수 있으며, 

327
00:15:56,560 --> 00:15:59,417
입력이 단일 루프 주위를 이동할 때 출력이 여러 

328
00:15:59,417 --> 00:16:02,169
번 회전하는 경우 더 큰 숫자가 될 수 있고, 

329
00:16:02,169 --> 00:16:05,027
출력이 한두 번만 회전하는 경우 더 작은 숫자가 

330
00:16:05,027 --> 00:16:05,980
될 수 있습니다.

331
00:16:06,320 --> 00:16:09,066
또는 루프를 시계 방향으로 돌 때 출력이 

332
00:16:09,066 --> 00:16:11,693
시계 반대 방향으로 흔들리는 경우 해당 

333
00:16:11,693 --> 00:16:14,320
굴곡 숫자는 음의 정수일 수도 있습니다.

334
00:16:15,180 --> 00:16:17,135
그러나 어떤 루프에서든 이 총 

335
00:16:17,135 --> 00:16:18,860
권선 양은 정수여야 합니다.

336
00:16:20,880 --> 00:16:22,978
내 말은, 시작한 곳으로 돌아올 때쯤에는 시작한 

337
00:16:22,978 --> 00:16:25,000
것과 동일한 결과를 얻게 될 것이라는 뜻입니다.

338
00:16:26,180 --> 00:16:29,966
덧붙여서, 경로에 실제로 출력이 정확히 0인 지점이 

339
00:16:29,966 --> 00:16:33,753
포함되어 있는 경우 출력에 특정 방향이 없기 때문에 

340
00:16:33,753 --> 00:16:37,540
기술적으로 이를 따라 굴곡 수를 정의할 수 없습니다.

341
00:16:37,540 --> 00:16:39,566
이것은 우리에게 문제가 되지 않을 것입니다. 

342
00:16:39,566 --> 00:16:41,349
왜냐하면 우리의 전체 목표는 0을 찾는 

343
00:16:41,349 --> 00:16:43,052
것이기 때문입니다. 따라서 이런 일이 

344
00:16:43,052 --> 00:16:45,160
발생하더라도 우리는 일찍 운이 좋았을 뿐입니다.

345
00:16:45,160 --> 00:16:46,974
이러한 구불구불한 숫자에 대해 주목해야 할 

346
00:16:46,974 --> 00:16:48,638
가장 중요한 점은 경로를 더 큰 경로로 

347
00:16:48,638 --> 00:16:50,680
결합할 때 그 숫자가 멋지게 합산된다는 것입니다.

348
00:16:54,800 --> 00:16:57,142
그러나 우리가 정말로 원하는 것은 지역을 

349
00:16:57,142 --> 00:16:59,689
결합하여 더 큰 지역을 만들 때 지역 경계를 

350
00:16:59,689 --> 00:17:02,440
따라 구불구불한 숫자가 멋지게 합산되는 것입니다.

351
00:17:02,980 --> 00:17:04,520
그럼 우리는 그 재산을 갖고 있나요?

352
00:17:07,760 --> 00:17:09,060
글쎄, 한번보세요.

353
00:17:09,540 --> 00:17:12,729
왼쪽에 있는 이 지역을 시계 방향으로 돌면서 

354
00:17:12,729 --> 00:17:16,302
구불구불한 숫자는 이 네 경로의 구불구불한 숫자의 

355
00:17:16,302 --> 00:17:16,940
합입니다.

356
00:17:17,500 --> 00:17:19,750
그리고 오른쪽에 있는 이 지역을 시계 

357
00:17:19,750 --> 00:17:21,894
방향으로 회전하는 구불구불한 부분은 

358
00:17:21,894 --> 00:17:24,359
이 네 경로의 구불구불한 숫자의 합입니다.

359
00:17:25,339 --> 00:17:27,804
그리고 이 두 지역을 더 큰 지역으로 

360
00:17:27,804 --> 00:17:29,917
결합하면 대부분의 경로가 더 큰 

361
00:17:29,917 --> 00:17:32,500
지역의 시계 방향 경계의 일부가 됩니다.

362
00:17:33,260 --> 00:17:35,800
그렇지 않은 두 경로는 무엇입니까?

363
00:17:36,020 --> 00:17:37,896
그것들은 완벽하게 상쇄됩니다. 

364
00:17:37,896 --> 00:17:40,545
그 중 하나는 우리가 전에 본 것처럼 다른 

365
00:17:40,545 --> 00:17:41,760
하나의 역방향입니다.

366
00:17:42,560 --> 00:17:45,043
따라서 지역 경계를 따라 구불구불한 

367
00:17:45,043 --> 00:17:47,900
숫자는 우리가 원하는 방식으로 합산됩니다.

368
00:17:48,640 --> 00:17:51,393
또한 참고로, 이렇게 멋지게 합산되는 지향성 

369
00:17:51,393 --> 00:17:54,036
경계에 대한 추론은 수학에서 많이 나타나며 

370
00:17:54,036 --> 00:17:56,680
종종 스톡스의 정리라는 이름으로 사용됩니다.

371
00:17:57,060 --> 00:17:58,950
다변수 미적분학을 공부해본 분들이라면 

372
00:17:58,950 --> 00:18:01,020
그 맥락에서 이를 인식하실 수도 있습니다.

373
00:18:02,360 --> 00:18:04,956
이제 마침내 구불구불한 숫자를 손에 쥐고 

374
00:18:04,956 --> 00:18:07,440
방정식 풀이 목표로 돌아갈 수 있습니다.

375
00:18:08,000 --> 00:18:10,433
앞서 본 영역의 문제점은 경계선이 

376
00:18:10,433 --> 00:18:12,738
가능한 모든 색상을 통과했음에도 

377
00:18:12,738 --> 00:18:15,940
불구하고 권선 수가 실제로 0이라는 것입니다.

378
00:18:16,500 --> 00:18:19,966
출력은 노란색을 거쳐 빨간색으로 반쯤 감겨진 다음 

379
00:18:19,966 --> 00:18:23,432
시계 반대 방향으로 다른 방향으로 돌아가기 시작한 

380
00:18:23,432 --> 00:18:27,022
다음 계속해서 파란색을 통과하고 반대쪽에서 빨간색에 

381
00:18:27,022 --> 00:18:29,869
도달하여 전체 권선이 0이 되는 방식으로 

382
00:18:29,869 --> 00:18:30,860
이루어졌습니다.

383
00:18:31,840 --> 00:18:34,522
그러나 모든 색상에 해당할 뿐만 아니라 0이 

384
00:18:34,522 --> 00:18:37,096
아닌 구불구불한 숫자라는 더 강력한 조건을 

385
00:18:37,096 --> 00:18:39,779
갖는 루프를 찾은 경우 이를 반으로 분할하면 

386
00:18:39,779 --> 00:18:42,461
해당 반쪽 중 적어도 하나는 0이 아닌 굴곡 

387
00:18:42,461 --> 00:18:45,036
숫자도 마찬가지입니다. 왜냐하면 모든 것이 

388
00:18:45,036 --> 00:18:48,040
우리가 원하는 방식으로 멋지게 추가되기 때문입니다.

389
00:18:48,440 --> 00:18:50,916
따라서 이런 방식으로 계속 진행하면서 한 

390
00:18:50,916 --> 00:18:53,500
지점으로 점점 더 범위를 좁힐 수 있습니다.

391
00:18:54,050 --> 00:18:56,520
그리고 한 지점으로 범위를 좁히면 0이 아닌 

392
00:18:56,520 --> 00:18:59,484
구불구불한 숫자가 있는 작은 루프를 사용하게 됩니다. 

393
00:18:59,484 --> 00:19:02,448
이는 가능한 모든 색상을 통과한다는 것을 의미합니다. 

394
00:19:02,448 --> 00:19:05,115
따라서 앞서 말했듯이 지점이 좁아지고 있습니다. 

395
00:19:05,115 --> 00:19:06,400
on은 0이어야 합니다.

396
00:19:07,420 --> 00:19:08,360
그리고 그게 다야!

397
00:19:08,600 --> 00:19:11,440
이제 우리는 2차원 방정식 솔버를 만들었습니다. 

398
00:19:11,440 --> 00:19:13,860
이번에는 버그가 없을 것이라고 약속합니다.

399
00:19:14,560 --> 00:19:16,092
권선 번호는 정확하게 이 작업을 

400
00:19:16,092 --> 00:19:17,540
수행하는 데 필요한 도구입니다.

401
00:19:18,100 --> 00:19:21,205
이제 f와 g 사이의 차이가 어떻게 돌아가는지 

402
00:19:21,205 --> 00:19:24,192
고려함으로써 2차원에서 f(x)가 g(x)와 

403
00:19:24,192 --> 00:19:26,820
어디가 같은지 방정식을 풀 수 있습니다.

404
00:19:27,600 --> 00:19:29,840
굴곡 수가 0이 아닌 루프가 있을 때마다 

405
00:19:29,840 --> 00:19:32,080
우리는 이 알고리즘을 루프에서 실행할 수 

406
00:19:32,080 --> 00:19:34,515
있으며 루프 내의 어딘가에서 솔루션을 찾도록 

407
00:19:34,515 --> 00:19:35,100
보장됩니다.

408
00:19:35,660 --> 00:19:37,699
게다가 한 차원에서와 마찬가지로 이 

409
00:19:37,699 --> 00:19:39,840
알고리즘은 놀라울 정도로 효율적입니다.

410
00:19:40,240 --> 00:19:43,571
우리는 매 라운드마다 영역 크기를 절반으로 

411
00:19:43,571 --> 00:19:47,042
좁혀서 0으로 빠르게 좁혀지고 그 동안 많은 

412
00:19:47,042 --> 00:19:50,512
루프에서 확인하는 대신 이러한 루프의 지점을 

413
00:19:50,512 --> 00:19:54,400
따라 함수 값만 확인하면 됩니다. 인테리어 포인트.

414
00:19:55,160 --> 00:19:57,707
따라서 어떤 의미에서 수행된 전체 

415
00:19:57,707 --> 00:20:00,522
작업은 전체 영역이 아닌 검색 공간의 

416
00:20:00,522 --> 00:20:03,740
둘레에만 비례합니다. 이는 놀라운 일입니다.

417
00:20:04,920 --> 00:20:07,500
이제 무슨 일이 일어나고 있는지 이해하고 나면 

418
00:20:07,500 --> 00:20:10,280
이것이 작동하는 모습을 지켜보면서 기능을 제공하고 

419
00:20:10,280 --> 00:20:12,960
0을 검색하게 하는 것은 이상하게도 매혹적입니다.

420
00:20:13,620 --> 00:20:16,524
앞서 말한 것처럼 복소수는 2차원이므로 

421
00:20:16,524 --> 00:20:19,560
복소수가 있는 방정식에 적용해 보겠습니다.

422
00:20:20,300 --> 00:20:23,810
예를 들어, 복소 평면에서 5번째 빼기 x 빼기 

423
00:20:23,810 --> 00:20:27,449
1까지의 함수 x의 영점을 찾는 알고리즘은 다음과 

424
00:20:27,449 --> 00:20:28,100
같습니다.

425
00:20:28,900 --> 00:20:31,822
원점 주변의 매우 넓은 영역을 고려하여 

426
00:20:31,822 --> 00:20:34,480
시작하여 권선 수는 5가 되었습니다.

427
00:20:35,280 --> 00:20:37,451
0이 아닌 굴곡 번호가 있는 루프를 

428
00:20:37,451 --> 00:20:39,622
찾을 때마다 이를 반으로 나누고 두 

429
00:20:39,622 --> 00:20:42,120
개의 작은 루프의 굴곡 번호를 알아냅니다.

430
00:20:42,700 --> 00:20:45,400
둘 중 하나 또는 둘 다 0이 아닌 굴곡 숫자를 

431
00:20:45,400 --> 00:20:48,100
갖는 것이 보장되며, 이를 보면 작은 루프 내부 

432
00:20:48,100 --> 00:20:50,500
어딘가에 0이 있다는 것을 알 수 있으므로 

433
00:20:50,500 --> 00:20:53,400
계속해서 동일한 방식으로 더 작은 공간을 검색합니다.

434
00:20:54,180 --> 00:20:57,202
또한 우리가 계산하고 있는 경로가 0을 우연히 

435
00:20:57,202 --> 00:20:59,412
발견하면 영역 탐색을 중단합니다. 

436
00:20:59,412 --> 00:21:02,900
실제로 여기 오른쪽 절반의 예에서 한 번 발생했습니다.

437
00:21:03,280 --> 00:21:05,887
이러한 드문 현상은 권선 수를 계산하는 

438
00:21:05,887 --> 00:21:08,140
능력을 방해하지만 0을 얻었습니다.

439
00:21:09,220 --> 00:21:11,017
그리고 굴곡 수가 0인 루프의 

440
00:21:11,017 --> 00:21:12,920
경우 더 이상 탐색하지 않습니다.

441
00:21:12,920 --> 00:21:15,106
내부에 해결책이 있을 수도 있고 없을 수도 있습니다. 

442
00:21:15,106 --> 00:21:16,200
우리는 보장할 수 없습니다.

443
00:21:18,400 --> 00:21:21,257
그리고 방정식 솔버가 이와 동일한 방식으로 계속되도록 

444
00:21:21,257 --> 00:21:24,020
하면 결국 이 다항식에 대해 많은 0으로 수렴됩니다.

445
00:21:25,840 --> 00:21:28,654
그런데 이 예에서 총 권선 수가 

446
00:21:28,654 --> 00:21:31,000
5인 것은 우연이 아닙니다.

447
00:21:31,580 --> 00:21:35,234
복소수의 경우 x에서 n까지의 연산은 입력 

448
00:21:35,234 --> 00:21:38,585
원점을 한 번 돌아다니면서 출력 원점을 

449
00:21:38,585 --> 00:21:42,240
n번 돌아다니는 것과 직접적으로 일치합니다.

450
00:21:44,680 --> 00:21:48,330
따라서 다항식을 사용하면 입력이 충분히 큰 경우 주요 

451
00:21:48,330 --> 00:21:51,980
항을 제외한 모든 항이 비교에서 중요하지 않게 됩니다.

452
00:21:52,480 --> 00:21:56,260
따라서 선행항이 x에서 n까지인 모든 복소 다항식은 

453
00:21:56,260 --> 00:21:59,780
충분히 큰 루프 주위에 n의 굴곡 수를 갖습니다.

454
00:22:00,540 --> 00:22:03,613
그런 식으로 우리의 굴곡수 기술은 실제로 

455
00:22:03,613 --> 00:22:06,820
모든 복소 다항식에 0이 있음을 보장합니다.

456
00:22:07,480 --> 00:22:09,502
이는 수학자들이 대수학의 기본 

457
00:22:09,502 --> 00:22:12,000
정리라고 부를 만큼 중요한 사실입니다.

458
00:22:13,800 --> 00:22:17,156
이와 같은 방정식에 대한 수치적 해를 찾는 알고리즘을 

459
00:22:17,156 --> 00:22:20,289
갖는 것은 매우 실용적이지만 대수학의 기본 정리는 

460
00:22:20,289 --> 00:22:23,310
이러한 구불구불한 숫자가 이론적 수준에서도 매우 

461
00:22:23,310 --> 00:22:26,667
유용하여 광범위한 클래스에 대한 해의 존재를 보장하는 

462
00:22:26,667 --> 00:22:28,681
방법을 보여주는 좋은 예입니다. 

463
00:22:28,681 --> 00:22:31,702
적합한 조건에 대한 방정식은 수학자들이 생각하고 

464
00:22:31,702 --> 00:22:33,940
싶어하는 종류에 훨씬 더 가깝습니다.

465
00:22:33,940 --> 00:22:36,187
후속 비디오에서 토폴로지 맥락에서 이에 

466
00:22:36,187 --> 00:22:38,638
대한 몇 가지 놀라운 응용 프로그램을 보여 

467
00:22:38,638 --> 00:22:40,375
드리겠습니다. 여기에는 오래된 

468
00:22:40,375 --> 00:22:43,440
3blue1brown 비디오의 실수 수정이 포함됩니다.

469
00:22:44,060 --> 00:22:44,440
어느 것?

470
00:22:44,940 --> 00:22:47,412
이 채널의 모든 동영상과 모든 내용을 시청하고 

471
00:22:47,412 --> 00:22:49,600
먼저 오류를 발견할 수 있는지 확인하세요.

472
00:22:51,300 --> 00:23:00,203
이 비디오의 주요 작성자는 3blue1brown의 

473
00:23:00,203 --> 00:23:06,880
최신 팀원 중 한 명인 Sridhar 

474
00:23:06,880 --> 00:23:10,060
Ramesh입니다.

