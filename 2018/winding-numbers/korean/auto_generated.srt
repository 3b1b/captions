1
00:00:03,060 --> 00:00:06,140
여기에는 기본 주제와 메타 주제라는 두 가지가 있습니다.

2
00:00:06,640 --> 00:00:16,840
주요 주제는 2차원 방정식, 두 개의 알려지지 않은 실수 또는 복소수인 단일 미지수와 관련된 문제를 해결하기 위한 정말 깔끔한 알고리즘이 될 것입니다.

3
00:00:17,440 --> 00:00:26,500
예를 들어, 다항식의 복소수 근을 찾고 싶거나 리만 제타 함수의 백만 달러짜리 0 중 일부를 찾고 싶다면 이 알고리즘이 대신해 줄 것입니다.

4
00:00:26,800 --> 00:00:30,060
그리고 이 방법은 정말 예쁜데, 많은 색상이 들어가거든요.

5
00:00:30,540 --> 00:00:35,300
그리고 더 중요한 것은 핵심 기본 아이디어가 나중에 이야기할 약간의 위상수학을 포함하여 

6
00:00:35,300 --> 00:00:40,060
방정식을 풀기 위한 이 알고리즘을 훨씬 넘어서는 모든 종류의 수학에 적용된다는 것입니다.

7
00:00:40,740 --> 00:00:48,075
하지만 이 시간을 실제로 20분 정도의 가치로 만드는 것은 수학 전반에 걸쳐 훨씬 더 일반적으로 유용한 교훈, 

8
00:00:48,075 --> 00:00:51,980
즉 서로 잘 구성되는 구성을 정의하려고 시도한다는 점입니다.

9
00:00:52,400 --> 00:00:54,480
이야기가 진행되면서 이것이 무슨 뜻인지 알게 될 것입니다.

10
00:00:55,060 --> 00:01:03,820
2D 입력과 2D 출력이 있는 함수로 사례를 동기를 부여하기 위해 실수를 받아들이고 실수를 뱉어내는 함수로 더 간단하게 시작해 보겠습니다.

11
00:01:05,080 --> 00:01:14,520
x의 함수 f가 x의 다른 함수 g와 언제 같은지 알고 싶다면, 이를 해당 함수의 그래프가 교차하는 때를 검색하는 것으로 생각할 수 있습니다.

12
00:01:15,020 --> 00:01:18,520
즉, 두 함수 모두 동일한 출력을 갖는 입력을 제공한다는 뜻입니다.

13
00:01:18,520 --> 00:01:25,300
매우 간단한 예를 들어, f(x)가 x 제곱이고 g(x)가 상수 함수 2라고 상상해 보세요.

14
00:01:25,960 --> 00:01:28,640
즉, 2의 제곱근을 구하려는 것입니다.

15
00:01:29,460 --> 00:01:37,431
제곱근을 찾는 것에 대해 거의 아무것도 모르더라도 1의 제곱은 2보다 작고 2의 제곱은 2보다 크다는 것을 알 수 있으므로 아, 

16
00:01:37,431 --> 00:01:41,860
이 두 값 사이에 어떤 해결책이 있을 것이라는 것을 깨닫게 될 것입니다.

17
00:01:42,580 --> 00:01:47,140
그런 다음 범위를 더 좁히고 싶다면 중간점인 1을 제곱해 보세요.5.

18
00:01:47,720 --> 00:01:53,760
이는 2로 나옵니다.25는 약간 높으므로 1과 1 사이의 영역에 집중하게 됩니다.5.

19
00:01:54,760 --> 00:02:00,920
계속해서 이것이 어떻게 계속 진행되는지 알 수 있습니다. 중간 지점에서 계속 계산한 다음 검색 공간을 절반으로 줄입니다.

20
00:02:05,100 --> 00:02:15,520
이에 대해 생각하는 또 다른 방법은 더 높은 차원에 도달하면 더 쉽게 만들 수 있으며 대신 이 두 함수의 차이가 0일 때의 동등한 질문에 집중하는 것입니다.

21
00:02:16,100 --> 00:02:24,180
이러한 관점에서 우리는 그 차이가 한쪽 끝에서는 음수이고 다른 쪽 끝에서는 양수인 입력 영역을 발견했습니다.

22
00:02:24,180 --> 00:02:31,500
우리는 그것을 두 개로 나누고, 우리가 주의를 좁힌 절반은 가장 바깥쪽 지점에 다양한 부호가 있는 부분이었습니다.

23
00:02:31,500 --> 00:02:39,273
이렇게 우리는 국경에 다양한 표지판이 있는 각 지역을 선택하고 절반 중에서 더 작은 지역을 찾아 영원히 계속할 수 있었습니다. 

24
00:02:39,273 --> 00:02:44,200
궁극적으로 우리는 정확히 0이 될 지점으로 좁아져야 한다는 것을 알고 있었습니다.

25
00:02:45,760 --> 00:02:51,441
간단히 말해서, 방정식을 푸는 것은 항상 특정 함수가 0과 같을 때를 찾는 것으로 구성될 수 있으며, 

26
00:02:51,441 --> 00:02:57,620
그렇게 하기 위해 우리는 이 경험적 방법을 사용합니다. f가 한 지점에서 양수이고 다른 지점에서 음수인 경우, 

27
00:02:57,620 --> 00:03:03,900
그 사이의 어딘가를 찾을 수 있습니다. 적어도 갑작스러운 점프 없이 모든 것이 순조롭게 변한다면 그것은 0입니다.

28
00:03:03,900 --> 00:03:14,080
제가 여러분께 보여드리고 싶은 놀라운 점은 이런 종류의 사고를 2차원 방정식, 즉 입력과 출력이 모두 2차원인 함수 간의 방정식으로 확장할 수 있다는 것입니다.

29
00:03:14,739 --> 00:03:21,400
예를 들어 복소수는 2차원이며 우리가 개발 중인 이 도구는 복잡한 방정식의 해를 찾는 데 적합합니다.

30
00:03:22,360 --> 00:03:28,340
이제 이러한 2D 기능에 대해 많이 이야기할 것이므로 잠시 옆으로 가서 이를 설명하는 방법을 고려해 보겠습니다.

31
00:03:29,060 --> 00:03:34,820
2D 입력 및 2D 출력을 사용하여 함수를 그래프로 표시하려면 4차원이 필요하며 2D 

32
00:03:34,820 --> 00:03:40,220
화면의 3D 세계에서는 잘 작동하지 않지만 여전히 몇 가지 좋은 옵션이 있습니다.

33
00:03:40,859 --> 00:03:45,440
하나는 입력 공간과 출력 공간을 나란히 보는 것입니다.

34
00:03:45,540 --> 00:03:56,260
입력 공간의 각 지점은 출력 공간의 특정 지점으로 이동하며 해당 입력 지점 주위의 이동이 출력 공간의 특정 이동에 어떻게 대응되는지 보여줄 수 있습니다.

35
00:03:56,940 --> 00:04:06,300
우리가 고려하는 모든 기능은 입력의 작은 변화가 출력의 작은 변화에만 해당하고 갑작스러운 점프가 없다는 점에서 연속적입니다.

36
00:04:06,940 --> 00:04:16,579
또 다른 옵션은 출력 공간의 원점에서 해당 출력 지점까지의 화살표를 상상하고 해당 화살표의 축소판을 입력 지점에 연결하는 것입니다.

37
00:04:17,360 --> 00:04:25,840
이를 통해 주어진 입력 지점이 어디로 가는지 또는 전체 벡터 필드를 그려 다양한 입력 지점이 어디로 가는지 한눈에 알 수 있습니다.

38
00:04:27,600 --> 00:04:33,676
불행하게도 많은 지점에서 이 작업을 수행하면 상당히 복잡해질 수 있으므로 여기에서는 모든 화살표를 동일한 크기로 만들겠습니다. 

39
00:04:33,676 --> 00:04:37,100
이것이 의미하는 바는 각 출력 지점의 방향을 파악할 수 있다는 것입니다.

40
00:04:37,780 --> 00:04:46,380
그러나 아마도 2차원 함수를 설명하는 가장 멋진 방법이자 이 비디오에서 가장 많이 사용할 방법은 해당 출력 공간의 각 점을 색상과 연관시키는 것입니다.

41
00:04:47,220 --> 00:04:54,934
여기서 우리는 원점에서 멀어지는 방향에 대응하기 위해 색상(색상이 무지개나 색상환을 따라 떨어지는 위치)을 사용했고, 

42
00:04:54,934 --> 00:04:59,260
원점으로부터의 거리에 대응하기 위해 어두움이나 밝기를 사용했습니다.

43
00:04:59,260 --> 00:05:09,620
예를 들어, 이 출력 배열에 초점을 맞추면 이러한 점은 모두 빨간색이지만 원점에 가까운 점은 조금 더 어둡고 멀리 있는 점은 조금 더 밝습니다.

44
00:05:10,360 --> 00:05:17,980
이 출력 배열에 초점을 맞추면 모든 점이 녹색이고 원점에 가까울수록 어두워지고 멀어질수록 밝아집니다.

45
00:05:18,780 --> 00:05:24,840
그리고 여기서 우리가 하는 일은 각 방향에 특정 색상을 할당하는 것뿐입니다. 모든 방향은 계속해서 변합니다.

46
00:05:25,359 --> 00:05:34,560
여기서는 어두움과 밝기의 차이가 매우 미묘하다는 것을 알 수 있지만, 이 비디오에서 우리가 관심을 갖는 것은 출력의 방향이지 크기나 색상, 밝기가 아닙니다.

47
00:05:35,300 --> 00:05:43,120
밝기에 대해 주목해야 할 한 가지 중요한 점은 특정 방향이 없는 원점 근처에서는 모든 색상이 검은색으로 희미해진다는 것입니다.

48
00:05:44,440 --> 00:05:50,640
함수에 대해 생각해 보면 이제 각 출력의 색상을 결정했으므로 출력 공간에 있는 지점의 

49
00:05:50,640 --> 00:05:57,100
색상을 기반으로 입력 공간의 각 지점에 색상을 지정하여 2D 기능을 시각화할 수 있습니다.

50
00:05:57,840 --> 00:06:03,783
나는 입력 공간의 다양한 지점이 출력 공간의 해당 출력으로 이동한 다음 착륙 지점의 

51
00:06:03,783 --> 00:06:10,360
색상을 기반으로 칠해진 다음 입력 공간에서 원래 위치로 다시 이동하는 것을 상상하고 싶습니다.

52
00:06:11,640 --> 00:06:18,140
입력 공간의 모든 점에 대해 이 작업을 수행하면 해당 입력 공간을 살펴보면 함수가 각 점을 대략적으로 취하는 위치를 알 수 있습니다.

53
00:06:18,140 --> 00:06:28,280
예를 들어, 왼쪽에 있는 분홍색 점 줄무늬는 모든 점이 출력 공간의 왼쪽 아래인 분홍색 방향 어딘가에 매핑된다는 것을 나타냅니다.

54
00:06:29,780 --> 00:06:34,900
또한 주위에 많은 색상이 있고 검은색인 세 점은 0이 되는 점입니다.

55
00:06:39,340 --> 00:06:48,880
좋습니다. 1D의 경우와 마찬가지로 2D 함수의 방정식을 푸는 것도 특정 함수가 언제 0인지 묻는 방식으로 재구성할 수 있습니다.

56
00:06:49,580 --> 00:07:00,900
이것이 바로 지금 우리의 과제입니다. 주어진 2D 함수의 어느 입력 포인트가 0이 되는지 찾는 알고리즘을 만드는 것입니다.

57
00:07:00,900 --> 00:07:08,300
검은색 점을 보고 이와 같은 색상 지도를 보고 있다면 함수의 0이 어디에 있는지 이미 알고 있다는 점을 지적할 수 있습니다.

58
00:07:08,620 --> 00:07:11,080
그럼 그게 중요해?

59
00:07:11,080 --> 00:07:19,240
이와 같은 다이어그램을 만들기 위해 컴퓨터가 평면의 모든 픽셀에서 함수를 계산하도록 했지만 우리의 목표는 가능한 한 적은 수의 

60
00:07:19,240 --> 00:07:27,860
지점에서만 함수를 계산해야 하는 보다 효율적인 알고리즘을 찾는 것입니다. , 말하자면 색상에 대한 제한된 시각만 가지고 있는 것입니다.

61
00:07:29,360 --> 00:07:39,080
또한 좀 더 이론적인 관점에서 볼 때, 주어진 영역 내에 0이 존재하는지 여부에 대한 조건을 알려주는 일반적인 구조를 갖는 것이 좋을 것입니다.

62
00:07:39,080 --> 00:07:47,920
한 차원에서 주요 통찰력은 연속 함수가 한 지점에서는 양수이고 다른 지점에서는 음수이면 그 사이의 어딘가는 0이어야 한다는 것입니다.

63
00:07:48,840 --> 00:07:50,580
그러면 어떻게 이를 2차원으로 확장할 수 있을까요?

64
00:07:50,940 --> 00:07:53,580
우리는 표지판에 대해 이야기하는 일종의 아날로그가 필요합니다.

65
00:07:54,700 --> 00:07:58,140
표지판이 무엇인지 생각하는 한 가지 방법은 방향입니다.

66
00:07:58,800 --> 00:08:03,500
양수는 수직선을 따라 오른쪽을 가리키고 있다는 뜻이고, 음수는 왼쪽을 가리킨다는 뜻입니다.

67
00:08:04,200 --> 00:08:11,800
2차원 수량에도 방향이 있지만 옵션이 훨씬 더 넓어서 가능성의 전체 범위를 따라 어느 곳이든 가리킬 수 있습니다.

68
00:08:12,530 --> 00:08:21,421
따라서 1차원에서 우리는 주어진 함수가 단지 2개의 점인 범위의 경계에서 양수인지 음수인지 묻는 것과 같은 방식으로 

69
00:08:21,421 --> 00:08:30,860
2차원 함수에 대해 우리는 영역의 경계를 살펴볼 것입니다. 루프이며 해당 경계를 따라 함수 출력의 방향에 대해 물어보십시오.

70
00:08:33,640 --> 00:08:39,561
예를 들어, 이 0을 중심으로 하는 이 루프를 따라 출력은 가능한 모든 방향, 무지개의 모든 색상, 

71
00:08:39,561 --> 00:08:45,060
빨간색, 노란색, 녹색, 파란색, 다시 빨간색으로, 그리고 그 사이의 모든 색상을 통과합니다.

72
00:08:45,700 --> 00:08:54,640
하지만 여기에 있는 이 루프를 따라 0이 없으면 출력이 모든 색상을 통과하지 않고 일부 주황색 색상을 통과하지만 결코 녹색이나 파란색은 통과하지 않습니다.

73
00:08:55,300 --> 00:08:58,460
그리고 이것은 유망합니다. 일이 한 차원에서 작동하는 방식과 매우 비슷해 보입니다.

74
00:08:59,340 --> 00:09:07,598
아마도 1d 함수가 1d 영역의 경계에서 가능한 두 부호를 모두 취하면 내부 어딘가에 0이 있는 것과 같은 방식으로, 

75
00:09:07,598 --> 00:09:14,855
2d 함수가 영역을 따라 가능한 모든 방향, 가능한 모든 색상의 출력에 도달한다고 가정할 수 있습니다. 

76
00:09:14,855 --> 00:09:19,860
2D 영역의 경계가 있으면 해당 영역 내부 어딘가에 0이 되어야 합니다.

77
00:09:20,960 --> 00:09:26,120
이것이 우리의 추측입니다. 이것이 사실이어야 하는지, 그렇다면 왜 그런지 잠시 생각해 보십시오.

78
00:09:27,420 --> 00:09:36,280
어떤 입력 지점 주변의 작은 루프에 대해 생각하기 시작하면 모든 것이 연속적이므로 함수가 해당 출력 근처의 작은 루프로 이동한다는 것을 알 수 있습니다.

79
00:09:37,140 --> 00:09:40,520
하지만 대부분의 작은 루프의 경우 출력 색상이 다양합니다.

80
00:09:40,980 --> 00:09:49,420
0이 아닌 출력 지점을 선택하고 그 근처에 충분히 촘촘한 루프를 그리면 루프의 색상은 모두 해당 지점과 거의 같은 색상이 됩니다.

81
00:09:49,840 --> 00:09:57,680
여기의 촘촘한 고리는 모두 푸르스름하고, 여기의 촘촘한 고리는 모두 노란색입니다. 확실히 무지개의 모든 색상을 얻을 수는 없습니다.

82
00:09:58,220 --> 00:10:06,320
모든 색상을 얻으면서 주변의 루프를 조일 수 있는 유일한 지점은 무색 원점인 0 자체입니다.

83
00:10:07,100 --> 00:10:16,380
따라서 무지개의 모든 색상을 통과하고 조이고 조이고 한 지점에서 좁아지는 루프가 있는 경우 해당 지점은 실제로 0이어야 합니다.

84
00:10:17,320 --> 00:10:21,860
이제 1차원 방정식 솔버와 마찬가지로 2D 방정식 솔버를 설정해 보겠습니다.

85
00:10:22,260 --> 00:10:29,900
경계가 모든 색상을 통과하는 큰 영역을 찾으면 이를 두 개로 분할한 다음 각 절반의 경계에 있는 색상을 살펴봅니다.

86
00:10:30,540 --> 00:10:38,600
여기에 표시된 예에서는 왼쪽 절반의 테두리가 모든 색상을 통과하지 않습니다. 예를 들어 주황색을 띤 노란색 방향으로 매핑되는 점이 없습니다.

87
00:10:39,060 --> 00:10:42,620
따라서 더 이상 검색하고 싶지 않다는 의미로 이 영역을 회색으로 표시하겠습니다.

88
00:10:43,380 --> 00:10:50,700
오른쪽 절반은 모든 색상을 통과하고 녹색 방향에서 많은 시간을 보낸 다음 노란색 주황색 빨간색과 파란색 보라색 분홍색을 통과합니다.

89
00:10:51,560 --> 00:10:57,360
이제 이것이 의미하는 바는 이 경계의 지점이 가능한 모든 방향의 출력에 매핑된다는 것입니다.

90
00:10:57,840 --> 00:11:01,860
그래서 좀 더 자세히 살펴보고, 다시 세분화하여 각 지역의 경계를 확인하겠습니다.

91
00:11:02,880 --> 00:11:06,560
상단의 경계는 모두 녹색이므로 거기서 검색을 중지하겠습니다.

92
00:11:06,860 --> 00:11:09,520
하지만 바닥은 세분화할 가치가 있을 만큼 컬러풀합니다.

93
00:11:10,340 --> 00:11:12,020
그리고 이대로 계속하세요.

94
00:11:12,360 --> 00:11:20,518
가능한 모든 색상을 포함하는 경계가 있는 하위 영역을 확인합니다. 즉, 해당 경계의 지점이 가능한 모든 방향에 매핑된다는 의미입니다. 

95
00:11:20,518 --> 00:11:27,480
그리고 1차원 경우에서 했던 것처럼 해당 영역을 계속 반으로 자르고 결국 기능에 대한 0이 됩니다. 아, 잠깐만요.

96
00:11:28,880 --> 00:11:29,920
여기 뭔 일 있었 니?

97
00:11:30,380 --> 00:11:35,008
오른쪽 하단에 있는 마지막 하위 구분 중 어느 것도 모든 색상을 통과하지 못했기 때문에 

98
00:11:35,008 --> 00:11:39,920
우리 알고리즘은 둘 중 하나를 검색하고 싶지 않았기 때문에 중지되었지만 0도 찾지 못했습니다.

99
00:11:41,060 --> 00:11:43,300
좋아요, 분명히 뭔가 문제가 있는 것 같습니다.

100
00:11:43,540 --> 00:11:46,520
그리고 괜찮아요. 틀린다는 것은 수학을 하는 데 있어 일반적인 부분입니다.

101
00:11:46,520 --> 00:11:52,980
돌이켜보면 우리는 이런 가설을 세웠고, 그것이 제안한 알고리즘으로 이어졌기 때문에 어딘가에서 착각하고 있었던 것입니다.

102
00:11:53,660 --> 00:12:01,800
그리고 수학을 잘한다는 것은 처음부터 옳다는 것이 아니라, 주의 깊게 되돌아보고 실수를 이해하고 이를 고치는 방법을 이해하는 회복력을 갖는 것입니다.

103
00:12:02,480 --> 00:12:08,421
이제 여기서 문제는 경계가 모든 색상을 통과하는 지역이 있다는 것입니다. 하지만 중간에 분할했을 때 하위 지역의 

104
00:12:08,421 --> 00:12:14,740
경계가 모든 색상을 통과하지 않았고 다음에 계속 검색할 위치에 대한 옵션이 없었으며 이로 인해 0이 깨졌습니다. 파인더.

105
00:12:14,740 --> 00:12:17,560
이제 한 차원에서는 이런 종류의 일이 결코 일어나지 않았습니다.

106
00:12:17,980 --> 00:12:28,460
끝점에 다른 부호가 있는 간격이 있을 때마다 이를 분할하면 끝점에도 다른 부호가 있는 일부 하위 간격이 보장된다는 것을 알 수 있습니다.

107
00:12:29,020 --> 00:12:38,380
또는 달리 말하면, 끝점이 부호를 변경하지 않는 두 개의 간격이 있을 때마다 이를 결합하면 끝점도 부호가 변경되지 않는 더 큰 간격을 얻게 됩니다.

108
00:12:39,080 --> 00:12:49,100
그러나 2차원에서는 경계가 모든 색상을 통과하지는 않지만 경계가 결합되어 모든 색상을 통과하는 영역을 제공하는 두 영역을 찾는 것이 가능합니다.

109
00:12:49,840 --> 00:12:53,500
그리고 이런 방식으로 우리가 제안한 영점 찾기 알고리즘이 깨졌습니다.

110
00:12:54,380 --> 00:13:02,380
사실, 생각해 보면 내부에 0이 없이 테두리가 가능한 모든 색상을 통과하는 큰 루프를 찾을 수 있습니다.

111
00:13:03,080 --> 00:13:12,160
모든 색상을 통과하는 영원히 좁아지는 루프는 0에서 좁아져야 한다고 우리가 말했을 때 작은 루프에 대한 우리의 주장이 틀렸다고 말하는 것은 아닙니다.

112
00:13:12,800 --> 00:13:22,140
그러나 우리를 혼란스럽게 만든 것은 이 속성이 모든 색상을 통과하는지 여부에 관계없이 지역을 결합할 때 훌륭하고 예측 가능한 방식으로 결합되지 않는다는 것입니다.

113
00:13:23,000 --> 00:13:30,740
하지만 걱정하지 마세요. 우리가 원하는 것을 제공하기 위해 결합하는 좀 더 정교한 속성으로 이것을 약간 수정할 수 있다는 것이 밝혀졌습니다.

114
00:13:38,180 --> 00:13:47,860
단순히 루프의 특정 지점에서 색상을 찾을 수 있는지 묻는 대신 루프를 돌면서 이러한 색상이 어떻게 변하는지 더 주의 깊게 추적하자는 아이디어입니다.

115
00:13:48,580 --> 00:13:49,960
예를 들어 내가 의미하는 바를 보여 드리겠습니다.

116
00:13:50,400 --> 00:13:53,260
추적하는 데 도움이 되도록 여기 구석에 작은 색상환을 올려 놓겠습니다.

117
00:13:53,940 --> 00:14:00,023
입력 경로를 따라 색상이 무지개를 통해 빨간색에서 노란색, 노란색에서 녹색, 녹색에서 파란색, 

118
00:14:00,023 --> 00:14:04,960
파란색에서 빨간색으로 특정 방향으로 이동하면 출력이 시계 방향으로 회전합니다.

119
00:14:05,700 --> 00:14:11,062
그러나 반면에 색상이 무지개를 통해 파란색에서 녹색, 녹색에서 노란색, 노란색에서 빨간색, 

120
00:14:11,062 --> 00:14:16,320
빨간색에서 파란색으로 반대 방향으로 이동하면 출력이 시계 반대 방향으로 흔들리는 것입니다.

121
00:14:17,160 --> 00:14:24,347
따라서 여기 이 짧은 경로를 따라 걸으면 색상은 색상환을 통해 시계 방향으로 5분의 1 방향으로 휘어집니다. 

122
00:14:24,347 --> 00:14:31,300
그리고 여기 이 경로를 따라 걷는 경우 색상은 색상환을 통해 시계 방향으로 5분의 1 방향으로 휘어집니다.

123
00:14:31,300 --> 00:14:38,640
물론, 이는 두 경로를 차례로 통과하면 색상이 시계 방향으로 전체 회전의 2/5만큼 감겨진다는 것을 의미합니다.

124
00:14:39,280 --> 00:14:47,100
와인딩의 총량은 합산되며 이것이 핵심이 될 것입니다. 이것은 우리에게 유용할 일종의 간단한 결합입니다.

125
00:14:47,100 --> 00:14:52,617
총 권선량을 말할 때 화살표가 시계 방향으로 회전하면 앞으로 움직이고 화살표가 시계 

126
00:14:52,617 --> 00:14:57,900
반대 방향으로 회전하면 뒤로 움직이는 구식 주행 거리계를 상상해 보시기 바랍니다.

127
00:14:58,740 --> 00:15:02,460
따라서 시계 반대 방향 권선은 음의 시계 방향 권선으로 간주됩니다.

128
00:15:03,000 --> 00:15:08,260
출력이 많이 회전할 수 있지만 회전 중 일부가 반대 방향이면 상쇄됩니다.

129
00:15:08,920 --> 00:15:16,502
예를 들어, 이 경로를 따라 앞으로 이동한 다음 동일한 경로를 따라 뒤로 이동하면 총 감기 양은 0이 되고, 

130
00:15:16,502 --> 00:15:25,080
뒤로 이동은 말 그대로 이전에 본 색상을 통해 되감기하여 모든 이전 감기를 반전하고 주행 거리계가 시작된 곳으로 돌아갑니다.

131
00:15:26,280 --> 00:15:29,900
우리의 목적을 위해 우리는 루프를 따라 감기는 것을 보는 데 가장 관심을 가질 것입니다.

132
00:15:30,440 --> 00:15:34,780
예를 들어, 이 전체 루프를 시계 방향으로 돌고 있다고 가정해 보겠습니다.

133
00:15:34,780 --> 00:15:46,180
우리가 접하게 되는 출력은 시계 방향으로 총 3바퀴를 돌며, 색상은 빨간색에서 다시 빨간색으로, 그리고 다시 빨간색으로 순서대로 무지개를 통해 회전합니다.

134
00:15:46,920 --> 00:15:54,020
수학자들이 사용하는 전문 용어에서는 이 루프를 따라 총 와인딩 수는 3이라고 말합니다.

135
00:15:54,020 --> 00:16:02,169
다른 루프의 경우 다른 정수일 수 있으며, 입력이 단일 루프 주위를 이동할 때 출력이 여러 번 회전하는 경우 더 큰 숫자가 될 수 있고, 

136
00:16:02,169 --> 00:16:05,980
출력이 한두 번만 회전하는 경우 더 작은 숫자가 될 수 있습니다.

137
00:16:06,320 --> 00:16:14,320
또는 루프를 시계 방향으로 돌 때 출력이 시계 반대 방향으로 흔들리는 경우 해당 굴곡 숫자는 음의 정수일 수도 있습니다.

138
00:16:15,180 --> 00:16:18,860
그러나 어떤 루프에서든 이 총 권선 양은 정수여야 합니다.

139
00:16:20,880 --> 00:16:25,000
내 말은, 시작한 곳으로 돌아올 때쯤에는 시작한 것과 동일한 결과를 얻게 될 것이라는 뜻입니다.

140
00:16:26,180 --> 00:16:37,540
덧붙여서, 경로에 실제로 출력이 정확히 0인 지점이 포함되어 있는 경우 출력에 특정 방향이 없기 때문에 기술적으로 이를 따라 굴곡 수를 정의할 수 없습니다.

141
00:16:37,540 --> 00:16:42,241
이것은 우리에게 문제가 되지 않을 것입니다. 왜냐하면 우리의 전체 목표는 0을 찾는 것이기 때문입니다. 

142
00:16:42,241 --> 00:16:45,160
따라서 이런 일이 발생하더라도 우리는 일찍 운이 좋았을 뿐입니다.

143
00:16:45,160 --> 00:16:50,680
이러한 구불구불한 숫자에 대해 주목해야 할 가장 중요한 점은 경로를 더 큰 경로로 결합할 때 그 숫자가 멋지게 합산된다는 것입니다.

144
00:16:54,800 --> 00:17:02,440
그러나 우리가 정말로 원하는 것은 지역을 결합하여 더 큰 지역을 만들 때 지역 경계를 따라 구불구불한 숫자가 멋지게 합산되는 것입니다.

145
00:17:02,980 --> 00:17:04,520
그럼 우리는 그 재산을 갖고 있나요?

146
00:17:07,760 --> 00:17:09,060
글쎄, 한번보세요.

147
00:17:09,540 --> 00:17:16,940
왼쪽에 있는 이 지역을 시계 방향으로 돌면서 구불구불한 숫자는 이 네 경로의 구불구불한 숫자의 합입니다.

148
00:17:17,500 --> 00:17:24,359
그리고 오른쪽에 있는 이 지역을 시계 방향으로 회전하는 구불구불한 부분은 이 네 경로의 구불구불한 숫자의 합입니다.

149
00:17:25,339 --> 00:17:32,500
그리고 이 두 지역을 더 큰 지역으로 결합하면 대부분의 경로가 더 큰 지역의 시계 방향 경계의 일부가 됩니다.

150
00:17:33,260 --> 00:17:35,800
그렇지 않은 두 경로는 무엇입니까?

151
00:17:36,020 --> 00:17:41,760
그것들은 완벽하게 상쇄됩니다. 그 중 하나는 우리가 전에 본 것처럼 다른 하나의 역방향입니다.

152
00:17:42,560 --> 00:17:47,900
따라서 지역 경계를 따라 구불구불한 숫자는 우리가 원하는 방식으로 합산됩니다.

153
00:17:48,640 --> 00:17:56,680
또한 참고로, 이렇게 멋지게 합산되는 지향성 경계에 대한 추론은 수학에서 많이 나타나며 종종 스톡스의 정리라는 이름으로 사용됩니다.

154
00:17:57,060 --> 00:18:01,020
다변수 미적분학을 공부해본 분들이라면 그 맥락에서 이를 인식하실 수도 있습니다.

155
00:18:02,360 --> 00:18:07,440
이제 마침내 구불구불한 숫자를 손에 쥐고 방정식 풀이 목표로 돌아갈 수 있습니다.

156
00:18:08,000 --> 00:18:15,940
앞서 본 영역의 문제점은 경계선이 가능한 모든 색상을 통과했음에도 불구하고 권선 수가 실제로 0이라는 것입니다.

157
00:18:16,500 --> 00:18:23,803
출력은 노란색을 거쳐 빨간색으로 반쯤 감겨진 다음 시계 반대 방향으로 다른 방향으로 돌아가기 시작한 다음 

158
00:18:23,803 --> 00:18:30,860
계속해서 파란색을 통과하고 반대쪽에서 빨간색에 도달하여 전체 권선이 0이 되는 방식으로 이루어졌습니다.

159
00:18:31,840 --> 00:18:39,779
그러나 모든 색상에 해당할 뿐만 아니라 0이 아닌 구불구불한 숫자라는 더 강력한 조건을 갖는 루프를 찾은 경우 이를 반으로 분할하면 

160
00:18:39,779 --> 00:18:48,040
해당 반쪽 중 적어도 하나는 0이 아닌 굴곡 숫자도 마찬가지입니다. 왜냐하면 모든 것이 우리가 원하는 방식으로 멋지게 추가되기 때문입니다.

161
00:18:48,440 --> 00:18:53,500
따라서 이런 방식으로 계속 진행하면서 한 지점으로 점점 더 범위를 좁힐 수 있습니다.

162
00:18:54,050 --> 00:18:59,484
그리고 한 지점으로 범위를 좁히면 0이 아닌 구불구불한 숫자가 있는 작은 루프를 사용하게 됩니다. 

163
00:18:59,484 --> 00:19:06,400
이는 가능한 모든 색상을 통과한다는 것을 의미합니다. 따라서 앞서 말했듯이 지점이 좁아지고 있습니다. on은 0이어야 합니다.

164
00:19:07,420 --> 00:19:08,360
그리고 그게 다야!

165
00:19:08,600 --> 00:19:13,860
이제 우리는 2차원 방정식 솔버를 만들었습니다. 이번에는 버그가 없을 것이라고 약속합니다.

166
00:19:14,560 --> 00:19:17,540
권선 번호는 정확하게 이 작업을 수행하는 데 필요한 도구입니다.

167
00:19:18,100 --> 00:19:26,820
이제 f와 g 사이의 차이가 어떻게 돌아가는지 고려함으로써 2차원에서 f(x)가 g(x)와 어디가 같은지 방정식을 풀 수 있습니다.

168
00:19:27,600 --> 00:19:35,100
굴곡 수가 0이 아닌 루프가 있을 때마다 우리는 이 알고리즘을 루프에서 실행할 수 있으며 루프 내의 어딘가에서 솔루션을 찾도록 보장됩니다.

169
00:19:35,660 --> 00:19:39,840
게다가 한 차원에서와 마찬가지로 이 알고리즘은 놀라울 정도로 효율적입니다.

170
00:19:40,240 --> 00:19:47,042
우리는 매 라운드마다 영역 크기를 절반으로 좁혀서 0으로 빠르게 좁혀지고 그 동안 많은 

171
00:19:47,042 --> 00:19:54,400
루프에서 확인하는 대신 이러한 루프의 지점을 따라 함수 값만 확인하면 됩니다. 인테리어 포인트.

172
00:19:55,160 --> 00:20:03,740
따라서 어떤 의미에서 수행된 전체 작업은 전체 영역이 아닌 검색 공간의 둘레에만 비례합니다. 이는 놀라운 일입니다.

173
00:20:04,920 --> 00:20:12,960
이제 무슨 일이 일어나고 있는지 이해하고 나면 이것이 작동하는 모습을 지켜보면서 기능을 제공하고 0을 검색하게 하는 것은 이상하게도 매혹적입니다.

174
00:20:13,620 --> 00:20:19,560
앞서 말한 것처럼 복소수는 2차원이므로 복소수가 있는 방정식에 적용해 보겠습니다.

175
00:20:20,300 --> 00:20:28,100
예를 들어, 복소 평면에서 5번째 빼기 x 빼기 1까지의 함수 x의 영점을 찾는 알고리즘은 다음과 같습니다.

176
00:20:28,900 --> 00:20:34,480
원점 주변의 매우 넓은 영역을 고려하여 시작하여 권선 수는 5가 되었습니다.

177
00:20:35,280 --> 00:20:42,120
0이 아닌 굴곡 번호가 있는 루프를 찾을 때마다 이를 반으로 나누고 두 개의 작은 루프의 굴곡 번호를 알아냅니다.

178
00:20:42,700 --> 00:20:48,100
둘 중 하나 또는 둘 다 0이 아닌 굴곡 숫자를 갖는 것이 보장되며, 이를 보면 작은 루프 내부 

179
00:20:48,100 --> 00:20:53,400
어딘가에 0이 있다는 것을 알 수 있으므로 계속해서 동일한 방식으로 더 작은 공간을 검색합니다.

180
00:20:54,180 --> 00:21:02,900
또한 우리가 계산하고 있는 경로가 0을 우연히 발견하면 영역 탐색을 중단합니다. 실제로 여기 오른쪽 절반의 예에서 한 번 발생했습니다.

181
00:21:03,280 --> 00:21:08,140
이러한 드문 현상은 권선 수를 계산하는 능력을 방해하지만 0을 얻었습니다.

182
00:21:09,220 --> 00:21:12,920
그리고 굴곡 수가 0인 루프의 경우 더 이상 탐색하지 않습니다.

183
00:21:12,920 --> 00:21:16,200
내부에 해결책이 있을 수도 있고 없을 수도 있습니다. 우리는 보장할 수 없습니다.

184
00:21:18,400 --> 00:21:24,020
그리고 방정식 솔버가 이와 동일한 방식으로 계속되도록 하면 결국 이 다항식에 대해 많은 0으로 수렴됩니다.

185
00:21:25,840 --> 00:21:31,000
그런데 이 예에서 총 권선 수가 5인 것은 우연이 아닙니다.

186
00:21:31,580 --> 00:21:42,240
복소수의 경우 x에서 n까지의 연산은 입력 원점을 한 번 돌아다니면서 출력 원점을 n번 돌아다니는 것과 직접적으로 일치합니다.

187
00:21:44,680 --> 00:21:51,980
따라서 다항식을 사용하면 입력이 충분히 큰 경우 주요 항을 제외한 모든 항이 비교에서 중요하지 않게 됩니다.

188
00:21:52,480 --> 00:21:59,780
따라서 선행항이 x에서 n까지인 모든 복소 다항식은 충분히 큰 루프 주위에 n의 굴곡 수를 갖습니다.

189
00:22:00,540 --> 00:22:06,820
그런 식으로 우리의 굴곡수 기술은 실제로 모든 복소 다항식에 0이 있음을 보장합니다.

190
00:22:07,480 --> 00:22:12,000
이는 수학자들이 대수학의 기본 정리라고 부를 만큼 중요한 사실입니다.

191
00:22:13,800 --> 00:22:23,870
이와 같은 방정식에 대한 수치적 해를 찾는 알고리즘을 갖는 것은 매우 실용적이지만 대수학의 기본 정리는 이러한 구불구불한 숫자가 이론적 수준에서도 매우 유용하여 

192
00:22:23,870 --> 00:22:33,940
광범위한 클래스에 대한 해의 존재를 보장하는 방법을 보여주는 좋은 예입니다. 적합한 조건에 대한 방정식은 수학자들이 생각하고 싶어하는 종류에 훨씬 더 가깝습니다.

193
00:22:33,940 --> 00:22:39,456
후속 비디오에서 토폴로지 맥락에서 이에 대한 몇 가지 놀라운 응용 프로그램을 보여 드리겠습니다. 

194
00:22:39,456 --> 00:22:43,440
여기에는 오래된 3blue1brown 비디오의 실수 수정이 포함됩니다.

195
00:22:44,060 --> 00:22:44,440
어느 것?

196
00:22:44,940 --> 00:22:49,600
이 채널의 모든 동영상과 모든 내용을 시청하고 먼저 오류를 발견할 수 있는지 확인하세요.

197
00:22:51,300 --> 00:23:10,060
이 비디오의 주요 작성자는 3blue1brown의 최신 팀원 중 한 명인 Sridhar Ramesh입니다.

