[
 {
  "input": "There's two things here, the main topic and the meta topic.",
  "translatedText": "여기에는 기본 주제와 메타 주제라는 두 가지가 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.06,
  "end": 6.14
 },
 {
  "input": "The main topic is going to be this really neat algorithm for solving two-dimensional equations, things that have two unknown real numbers, or also those involving a single unknown which is a complex number.",
  "translatedText": "주요 주제는 2차원 방정식, 두 개의 알려지지 않은 실수 또는 복소수인 단일 미지수와 관련된 문제를 해결하기 위한 정말 깔끔한 알고리즘이 될 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 6.64,
  "end": 16.84
 },
 {
  "input": "So for example, if you wanted to find the complex roots of a polynomial, or maybe some of those million dollar zeros of the Riemann zeta function, this algorithm would do it for you.",
  "translatedText": "예를 들어, 다항식의 복소수 근을 찾고 싶거나 리만 제타 함수의 백만 달러짜리 0 중 일부를 찾고 싶다면 이 알고리즘이 대신해 줄 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 17.44,
  "end": 26.5
 },
 {
  "input": "And this method is super pretty, since a lot of colors are involved.",
  "translatedText": "그리고 이 방법은 정말 예쁜데, 많은 색상이 들어가거든요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 26.8,
  "end": 30.06
 },
 {
  "input": "And more importantly, the core underlying idea applies to all sorts of math well beyond this algorithm for solving equations, including a bit of topology, which I'll talk about afterwards.",
  "translatedText": "그리고 더 중요한 것은 핵심 기본 아이디어가 나중에 이야기할 약간의 위상수학을 포함하여 방정식을 풀기 위한 이 알고리즘을 훨씬 넘어서는 모든 종류의 수학에 적용된다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 30.54,
  "end": 40.06
 },
 {
  "input": "But what really makes this worth 20 minutes or so of your time is that it illustrates a lesson much more generally useful throughout math, which is try to define constructs that compose nicely with each other.",
  "translatedText": "하지만 이 시간을 실제로 20분 정도의 가치로 만드는 것은 수학 전반에 걸쳐 훨씬 더 일반적으로 유용한 교훈, 즉 서로 잘 구성되는 구성을 정의하려고 시도한다는 점입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 40.74,
  "end": 51.98
 },
 {
  "input": "You'll see what I mean by that as the story progresses.",
  "translatedText": "이야기가 진행되면서 이것이 무슨 뜻인지 알게 될 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 52.4,
  "end": 54.48
 },
 {
  "input": "To motivate the case with functions that have 2d inputs and 2d outputs, let's start off simpler, with functions that just take in a real number and spit out a real number.",
  "translatedText": "2D 입력과 2D 출력이 있는 함수로 사례를 동기를 부여하기 위해 실수를 받아들이고 실수를 뱉어내는 함수로 더 간단하게 시작해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 55.06,
  "end": 63.82
 },
 {
  "input": "If you want to know when a function f of x equals some other function g of x, you might think of this as searching for when the graphs of those functions intersect, right?",
  "translatedText": "x의 함수 f가 x의 다른 함수 g와 언제 같은지 알고 싶다면, 이를 해당 함수의 그래프가 교차하는 때를 검색하는 것으로 생각할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 65.08,
  "end": 74.52
 },
 {
  "input": "I mean, that gives you an input where both functions have the same output.",
  "translatedText": "즉, 두 함수 모두 동일한 출력을 갖는 입력을 제공한다는 뜻입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 75.02,
  "end": 78.52
 },
 {
  "input": "To take a very simple example, imagine f of x is x squared, and g of x is the constant function 2.",
  "translatedText": "매우 간단한 예를 들어, f(x)가 x 제곱이고 g(x)가 상수 함수 2라고 상상해 보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 78.52,
  "end": 85.3
 },
 {
  "input": "In other words, you want to find the square root of 2.",
  "translatedText": "즉, 2의 제곱근을 구하려는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 85.96,
  "end": 88.64
 },
 {
  "input": "Even if you know almost nothing about finding square roots, you can probably see that 1 squared is less than 2, and 2 squared is bigger than 2, so you realize, ah, there's going to be some solution in between those two values.",
  "translatedText": "제곱근을 찾는 것에 대해 거의 아무것도 모르더라도 1의 제곱은 2보다 작고 2의 제곱은 2보다 크다는 것을 알 수 있으므로 아, 이 두 값 사이에 어떤 해결책이 있을 것이라는 것을 깨닫게 될 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 89.46,
  "end": 101.86
 },
 {
  "input": "And then if you wanted to narrow it down further, maybe you try squaring the halfway point, 1.5.",
  "translatedText": "그런 다음 범위를 더 좁히고 싶다면 중간점인 1을 제곱해 보세요.5.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 102.58,
  "end": 107.14
 },
 {
  "input": "This comes out to be 2.25, a little too high, so you'd focus on the region between 1 and 1.5.",
  "translatedText": "이는 2로 나옵니다.25는 약간 높으므로 1과 1 사이의 영역에 집중하게 됩니다.5.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 107.72,
  "end": 113.76
 },
 {
  "input": "And so on, you can probably see how this would keep going, you'd keep computing at the midpoint and then chopping your search space in half.",
  "translatedText": "계속해서 이것이 어떻게 계속 진행되는지 알 수 있습니다. 중간 지점에서 계속 계산한 다음 검색 공간을 절반으로 줄입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 114.76,
  "end": 120.92
 },
 {
  "input": "Another way to think about this, which is going to make it easier for us once we get up to higher dimensions, is to instead focus on the equivalent question for when the difference between these two functions is zero.",
  "translatedText": "이에 대해 생각하는 또 다른 방법은 더 높은 차원에 도달하면 더 쉽게 만들 수 있으며 대신 이 두 함수의 차이가 0일 때의 동등한 질문에 집중하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 125.1,
  "end": 135.52
 },
 {
  "input": "In those terms, we found a region of inputs where that difference was negative on one end, and it was positive on another end.",
  "translatedText": "이러한 관점에서 우리는 그 차이가 한쪽 끝에서는 음수이고 다른 쪽 끝에서는 양수인 입력 영역을 발견했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 136.1,
  "end": 143.34
 },
 {
  "input": "We split it into two, and the half we narrowed our attention to was the one where the outermost points had varying signs.",
  "translatedText": "우리는 그것을 두 개로 나누고, 우리가 주의를 좁힌 절반은 가장 바깥쪽 지점에 다양한 부호가 있는 부분이었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 143.84,
  "end": 150.56
 },
 {
  "input": "Like this, we were able to keep going forever, taking each region with varying signs on the border, finding a smaller such region among its halves, knowing that ultimately we have to be narrowing in on a point which is going to be exactly zero.",
  "translatedText": "이렇게 우리는 국경에 다양한 표지판이 있는 각 지역을 선택하고 절반 중에서 더 작은 지역을 찾아 영원히 계속할 수 있었습니다. 궁극적으로 우리는 정확히 0이 될 지점으로 좁아져야 한다는 것을 알고 있었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 151.36,
  "end": 164.2
 },
 {
  "input": "In short, solving equations can always be framed as finding when a certain function is equal to zero, and to do that, we have this heuristic, if f is positive at one point and negative at another point, you can find someplace in between where it's zero, at least if everything changes smoothly with no sudden jumps.",
  "translatedText": "간단히 말해서, 방정식을 푸는 것은 항상 특정 함수가 0과 같을 때를 찾는 것으로 구성될 수 있으며, 그렇게 하기 위해 우리는 이 경험적 방법을 사용합니다. f가 한 지점에서 양수이고 다른 지점에서 음수인 경우, 그 사이의 어딘가를 찾을 수 있습니다. 적어도 갑작스러운 점프 없이 모든 것이 순조롭게 변한다면 그것은 0입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 165.76,
  "end": 183.02
 },
 {
  "input": "The amazing thing I want to show you is that you can extend this kind of thinking into two-dimensional equations, equations between functions whose inputs and outputs are both two-dimensional.",
  "translatedText": "제가 여러분께 보여드리고 싶은 놀라운 점은 이런 종류의 사고를 2차원 방정식, 즉 입력과 출력이 모두 2차원인 함수 간의 방정식으로 확장할 수 있다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 183.88,
  "end": 194.08
 },
 {
  "input": "For example, complex numbers are 2D, and this tool we're developing is perfect for finding solutions to complex equations.",
  "translatedText": "예를 들어 복소수는 2차원이며 우리가 개발 중인 이 도구는 복잡한 방정식의 해를 찾는 데 적합합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 194.74,
  "end": 201.4
 },
 {
  "input": "Now, since we're going to be talking about these 2D functions so much, let's take a brief side step and consider how we illustrate these.",
  "translatedText": "이제 이러한 2D 기능에 대해 많이 이야기할 것이므로 잠시 옆으로 가서 이를 설명하는 방법을 고려해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.36,
  "end": 208.34
 },
 {
  "input": "Graphing a function with a 2D input and 2D output would require four dimensions, and that's not going to work so well in our 3D world on our 2D screens, but we still have a couple good options.",
  "translatedText": "2D 입력 및 2D 출력을 사용하여 함수를 그래프로 표시하려면 4차원이 필요하며 2D 화면의 3D 세계에서는 잘 작동하지 않지만 여전히 몇 가지 좋은 옵션이 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 209.06,
  "end": 220.22
 },
 {
  "input": "One is to just look at both the input space and output space side by side.",
  "translatedText": "하나는 입력 공간과 출력 공간을 나란히 보는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 220.86,
  "end": 225.44
 },
 {
  "input": "Each point in the input space moves to a particular point in the output space, and I can show how moving around that input point corresponds to certain movements in the output space.",
  "translatedText": "입력 공간의 각 지점은 출력 공간의 특정 지점으로 이동하며 해당 입력 지점 주위의 이동이 출력 공간의 특정 이동에 어떻게 대응되는지 보여줄 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 225.54,
  "end": 236.26
 },
 {
  "input": "All of the functions we consider will be continuous, in the sense that small little changes to the input only correspond to small little changes in the output, there's no sudden jumps.",
  "translatedText": "우리가 고려하는 모든 기능은 입력의 작은 변화가 출력의 작은 변화에만 해당하고 갑작스러운 점프가 없다는 점에서 연속적입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 236.94,
  "end": 246.3
 },
 {
  "input": "Another option we have is to imagine the arrow from the origin of the output space to that output point, and to attach a miniature version of that arrow to the input point.",
  "translatedText": "또 다른 옵션은 출력 공간의 원점에서 해당 출력 지점까지의 화살표를 상상하고 해당 화살표의 축소판을 입력 지점에 연결하는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 246.94,
  "end": 256.58
 },
 {
  "input": "This can give us a sense, at a glance, for where a given input point goes, or where many different input points go by drawing the full vector field.",
  "translatedText": "이를 통해 주어진 입력 지점이 어디로 가는지 또는 전체 벡터 필드를 그려 다양한 입력 지점이 어디로 가는지 한눈에 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 257.36,
  "end": 265.84
 },
 {
  "input": "And unfortunately when you do this at a lot of points it can get pretty cluttered, so here let me make all of the arrows the same size, and what this means is we can get a sense of the direction of each output point.",
  "translatedText": "불행하게도 많은 지점에서 이 작업을 수행하면 상당히 복잡해질 수 있으므로 여기에서는 모든 화살표를 동일한 크기로 만들겠습니다. 이것이 의미하는 바는 각 출력 지점의 방향을 파악할 수 있다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 267.6,
  "end": 277.1
 },
 {
  "input": "But perhaps the prettiest way to illustrate two-dimensional functions, and the one we'll be using most this video, is to associate each point in that output space with a color.",
  "translatedText": "그러나 아마도 2차원 함수를 설명하는 가장 멋진 방법이자 이 비디오에서 가장 많이 사용할 방법은 해당 출력 공간의 각 점을 색상과 연관시키는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 277.78,
  "end": 286.38
 },
 {
  "input": "Here we've used hues, that is where the color falls along a rainbow or a color wheel, to correspond to the direction away from the origin, and we're using darkness or brightness to correspond to the distance from the origin.",
  "translatedText": "여기서 우리는 원점에서 멀어지는 방향에 대응하기 위해 색상(색상이 무지개나 색상환을 따라 떨어지는 위치)을 사용했고, 원점으로부터의 거리에 대응하기 위해 어두움이나 밝기를 사용했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 287.22,
  "end": 299.26
 },
 {
  "input": "For example, focusing on this array of outputs, all of these points are red, but the ones closer to the origin are a little darker, and the ones farther away are a little brighter.",
  "translatedText": "예를 들어, 이 출력 배열에 초점을 맞추면 이러한 점은 모두 빨간색이지만 원점에 가까운 점은 조금 더 어둡고 멀리 있는 점은 조금 더 밝습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 299.26,
  "end": 309.62
 },
 {
  "input": "And focusing on this array of outputs, all of the points are green, and again, closer to the origin means darker, farther away means lighter.",
  "translatedText": "이 출력 배열에 초점을 맞추면 모든 점이 녹색이고 원점에 가까울수록 어두워지고 멀어질수록 밝아집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 310.36,
  "end": 317.98
 },
 {
  "input": "And so on, all we're doing here is assigning a specific color to each direction, all changing continuously.",
  "translatedText": "그리고 여기서 우리가 하는 일은 각 방향에 특정 색상을 할당하는 것뿐입니다. 모든 방향은 계속해서 변합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 318.78,
  "end": 324.84
 },
 {
  "input": "You might notice the darkness and brightness differences here are pretty subtle, but for this video, all we care about is the direction of outputs, not the magnitudes, the hues, not the brightness.",
  "translatedText": "여기서는 어두움과 밝기의 차이가 매우 미묘하다는 것을 알 수 있지만, 이 비디오에서 우리가 관심을 갖는 것은 출력의 방향이지 크기나 색상, 밝기가 아닙니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 325.36,
  "end": 334.56
 },
 {
  "input": "The one important thing about brightness for you to notice is that near the origin, which has no particular direction, all of the colors fade to black.",
  "translatedText": "밝기에 대해 주목해야 할 한 가지 중요한 점은 특정 방향이 없는 원점 근처에서는 모든 색상이 검은색으로 희미해진다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 335.3,
  "end": 343.12
 },
 {
  "input": "So for thinking about functions, now that we've decided on a color for each output, we can visualize 2D functions by coloring each point in the input space based on the color of the point where it lands in the output space.",
  "translatedText": "함수에 대해 생각해 보면 이제 각 출력의 색상을 결정했으므로 출력 공간에 있는 지점의 색상을 기반으로 입력 공간의 각 지점에 색상을 지정하여 2D 기능을 시각화할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 344.44,
  "end": 357.1
 },
 {
  "input": "I like to imagine many different points from that input space hopping over to their corresponding outputs in the output space, then getting painted based on the color of the point where they land, and then hopping back to where they came from in the input space.",
  "translatedText": "나는 입력 공간의 다양한 지점이 출력 공간의 해당 출력으로 이동한 다음 착륙 지점의 색상을 기반으로 칠해진 다음 입력 공간에서 원래 위치로 다시 이동하는 것을 상상하고 싶습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 357.84,
  "end": 370.36
 },
 {
  "input": "Doing this for every point in the input space, you can get a sense just by looking at that input space for roughly where the function takes each point.",
  "translatedText": "입력 공간의 모든 점에 대해 이 작업을 수행하면 해당 입력 공간을 살펴보면 함수가 각 점을 대략적으로 취하는 위치를 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 371.64,
  "end": 378.42
 },
 {
  "input": "For example, this stripe of pink points on the left tells us that all of those points get mapped somewhere in the pink direction, that lower left of the output space.",
  "translatedText": "예를 들어, 왼쪽에 있는 분홍색 점 줄무늬는 모든 점이 출력 공간의 왼쪽 아래인 분홍색 방향 어딘가에 매핑된다는 것을 나타냅니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 379.12,
  "end": 388.28
 },
 {
  "input": "Also those three points which are black with lots of colors around them are the ones that go to zero.",
  "translatedText": "또한 주위에 많은 색상이 있고 검은색인 세 점은 0이 되는 점입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 389.78,
  "end": 394.9
 },
 {
  "input": "Alright, so just like the 1D case, solving equations of 2D functions can always be reframed by asking when a certain function is equal to zero.",
  "translatedText": "좋습니다. 1D의 경우와 마찬가지로 2D 함수의 방정식을 푸는 것도 특정 함수가 언제 0인지 묻는 방식으로 재구성할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 399.34,
  "end": 408.88
 },
 {
  "input": "So that's our challenge right now, create an algorithm that finds which input points of a given 2D function go to zero.",
  "translatedText": "이것이 바로 지금 우리의 과제입니다. 주어진 2D 함수의 어느 입력 포인트가 0이 되는지 찾는 알고리즘을 만드는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 409.58,
  "end": 417.06
 },
 {
  "input": "You might point out that if you're looking at a color map like this by seeing those black dots, you already know where the zeros of the function are.",
  "translatedText": "검은색 점을 보고 이와 같은 색상 지도를 보고 있다면 함수의 0이 어디에 있는지 이미 알고 있다는 점을 지적할 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 420.86,
  "end": 428.3
 },
 {
  "input": "So does that count?",
  "translatedText": "그럼 그게 중요해?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 428.62,
  "end": 430.0
 },
 {
  "input": "Keep in mind that to create a diagram like this, we've had the computer compute the function at all the pixels on the plane, but our goal is to find a more efficient algorithm that only requires computing the function at as few points as possible, only having a limited view of the colors, so to speak.",
  "translatedText": "이와 같은 다이어그램을 만들기 위해 컴퓨터가 평면의 모든 픽셀에서 함수를 계산하도록 했지만 우리의 목표는 가능한 한 적은 수의 지점에서만 함수를 계산해야 하는 보다 효율적인 알고리즘을 찾는 것입니다. , 말하자면 색상에 대한 제한된 시각만 가지고 있는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 430.92,
  "end": 447.86
 },
 {
  "input": "And also from a more theoretical standpoint, it'd be nice to have a general construct that tells us the conditions for whether or not a zero exists inside a given region.",
  "translatedText": "또한 좀 더 이론적인 관점에서 볼 때, 주어진 영역 내에 0이 존재하는지 여부에 대한 조건을 알려주는 일반적인 구조를 갖는 것이 좋을 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 449.36,
  "end": 457.64
 },
 {
  "input": "Remember, in one dimension the main insight was that if a continuous function is positive at one point and negative at another, somewhere in between it must be zero.",
  "translatedText": "한 차원에서 주요 통찰력은 연속 함수가 한 지점에서는 양수이고 다른 지점에서는 음수이면 그 사이의 어딘가는 0이어야 한다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 459.0,
  "end": 467.92
 },
 {
  "input": "So how do we extend that into two dimensions?",
  "translatedText": "그러면 어떻게 이를 2차원으로 확장할 수 있을까요?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 468.84,
  "end": 470.58
 },
 {
  "input": "We need some sort of analog of talking about signs.",
  "translatedText": "우리는 표지판에 대해 이야기하는 일종의 아날로그가 필요합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 470.94,
  "end": 473.58
 },
 {
  "input": "One way to think about what signs even are is directions.",
  "translatedText": "표지판이 무엇인지 생각하는 한 가지 방법은 방향입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 474.7,
  "end": 478.14
 },
 {
  "input": "Positive means you're pointing to the right along the number line, and negative means you're pointing to the left.",
  "translatedText": "양수는 수직선을 따라 오른쪽을 가리키고 있다는 뜻이고, 음수는 왼쪽을 가리킨다는 뜻입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 478.8,
  "end": 483.5
 },
 {
  "input": "Two-dimensional quantities also have direction, but for them the options are much wider, they can point anywhere along a whole circle of possibilities.",
  "translatedText": "2차원 수량에도 방향이 있지만 옵션이 훨씬 더 넓어서 가능성의 전체 범위를 따라 어느 곳이든 가리킬 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 484.2,
  "end": 491.8
 },
 {
  "input": "So the same way that in one dimension we were asking whether a given function is positive or negative on the boundary of a range, which is just two points, for 2d functions we're going to be looking at the boundary of a region, which is a loop, and ask about the direction of the function's output along that boundary.",
  "translatedText": "따라서 1차원에서 우리는 주어진 함수가 단지 2개의 점인 범위의 경계에서 양수인지 음수인지 묻는 것과 같은 방식으로 2차원 함수에 대해 우리는 영역의 경계를 살펴볼 것입니다. 루프이며 해당 경계를 따라 함수 출력의 방향에 대해 물어보십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 492.53,
  "end": 510.86
 },
 {
  "input": "For example, we see that along this loop around this zero, the output goes through every possible direction, all the colors of the rainbow, red, yellow, green, blue, back to red, and everything in between along the way.",
  "translatedText": "예를 들어, 이 0을 중심으로 하는 이 루프를 따라 출력은 가능한 모든 방향, 무지개의 모든 색상, 빨간색, 노란색, 녹색, 파란색, 다시 빨간색으로, 그리고 그 사이의 모든 색상을 통과합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 513.64,
  "end": 525.06
 },
 {
  "input": "But along this loop over here, with no zeros inside of it, the output doesn't go through every color, it goes through some of the orangish ones, but never, say, green or blue.",
  "translatedText": "하지만 여기에 있는 이 루프를 따라 0이 없으면 출력이 모든 색상을 통과하지 않고 일부 주황색 색상을 통과하지만 결코 녹색이나 파란색은 통과하지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 525.7,
  "end": 534.64
 },
 {
  "input": "And this is promising, it looks a lot like how things worked in one dimension.",
  "translatedText": "그리고 이것은 유망합니다. 일이 한 차원에서 작동하는 방식과 매우 비슷해 보입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 535.3,
  "end": 538.46
 },
 {
  "input": "Maybe in the same way that if a 1d function takes both possible signs on the boundary of a 1d region, there was a zero somewhere inside, we might hypothesize that if a 2d function hits outputs of all possible directions, all possible colors, along the boundary of a 2d region, then somewhere inside that region it must go to zero.",
  "translatedText": "아마도 1d 함수가 1d 영역의 경계에서 가능한 두 부호를 모두 취하면 내부 어딘가에 0이 있는 것과 같은 방식으로, 2d 함수가 영역을 따라 가능한 모든 방향, 가능한 모든 색상의 출력에 도달한다고 가정할 수 있습니다. 2D 영역의 경계가 있으면 해당 영역 내부 어딘가에 0이 되어야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 539.34,
  "end": 559.86
 },
 {
  "input": "So that's our guess, and take a moment to think about if this should be true, and if so why.",
  "translatedText": "이것이 우리의 추측입니다. 이것이 사실이어야 하는지, 그렇다면 왜 그런지 잠시 생각해 보십시오.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 560.96,
  "end": 566.12
 },
 {
  "input": "If we start thinking about a tiny loop around some input point, we know that since everything is continuous, our function takes it to some tiny loop near the corresponding output.",
  "translatedText": "어떤 입력 지점 주변의 작은 루프에 대해 생각하기 시작하면 모든 것이 연속적이므로 함수가 해당 출력 근처의 작은 루프로 이동한다는 것을 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 567.42,
  "end": 576.28
 },
 {
  "input": "But look, for most tiny loops, the output varies in color.",
  "translatedText": "하지만 대부분의 작은 루프의 경우 출력 색상이 다양합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 577.14,
  "end": 580.52
 },
 {
  "input": "If you pick any output point other than zero, and draw a sufficiently tight loop near it, the loop's colors are all going to be about the same color as that point.",
  "translatedText": "0이 아닌 출력 지점을 선택하고 그 근처에 충분히 촘촘한 루프를 그리면 루프의 색상은 모두 해당 지점과 거의 같은 색상이 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 580.98,
  "end": 589.42
 },
 {
  "input": "A tight loop over here is all bluish, a tight loop over here is all yellowish, you certainly aren't going to get every color of the rainbow.",
  "translatedText": "여기의 촘촘한 고리는 모두 푸르스름하고, 여기의 촘촘한 고리는 모두 노란색입니다. 확실히 무지개의 모든 색상을 얻을 수는 없습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 589.84,
  "end": 597.68
 },
 {
  "input": "The only point where you can tighten loops around it while still getting all the colors is the colorless origin, zero itself.",
  "translatedText": "모든 색상을 얻으면서 주변의 루프를 조일 수 있는 유일한 지점은 무색 원점인 0 자체입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 598.22,
  "end": 606.32
 },
 {
  "input": "So it is indeed the case that if you have loops going through every color of the rainbow, tightening and tightening, narrowing in on a point, then that point must in fact be a zero.",
  "translatedText": "따라서 무지개의 모든 색상을 통과하고 조이고 조이고 한 지점에서 좁아지는 루프가 있는 경우 해당 지점은 실제로 0이어야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 607.1,
  "end": 616.38
 },
 {
  "input": "And so let's set up a 2d equation solver just like our one-dimensional equation solver.",
  "translatedText": "이제 1차원 방정식 솔버와 마찬가지로 2D 방정식 솔버를 설정해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 617.32,
  "end": 621.86
 },
 {
  "input": "When we find a large region whose border goes through every color, split it into two, and then look at the colors on the boundary of each half.",
  "translatedText": "경계가 모든 색상을 통과하는 큰 영역을 찾으면 이를 두 개로 분할한 다음 각 절반의 경계에 있는 색상을 살펴봅니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 622.26,
  "end": 629.9
 },
 {
  "input": "In the example shown here, the border on the left half doesn't go through all colors, there are no points that map to the orangeish yellowish directions, for example.",
  "translatedText": "여기에 표시된 예에서는 왼쪽 절반의 테두리가 모든 색상을 통과하지 않습니다. 예를 들어 주황색을 띤 노란색 방향으로 매핑되는 점이 없습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 630.54,
  "end": 638.6
 },
 {
  "input": "So I'll grey out this area as a way of saying we don't want to search it any further.",
  "translatedText": "따라서 더 이상 검색하고 싶지 않다는 의미로 이 영역을 회색으로 표시하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 639.06,
  "end": 642.62
 },
 {
  "input": "The right half does go through all the colors, spends a lot of time in the green direction, then passes through yellow orange red, as well as blue violet pink.",
  "translatedText": "오른쪽 절반은 모든 색상을 통과하고 녹색 방향에서 많은 시간을 보낸 다음 노란색 주황색 빨간색과 파란색 보라색 분홍색을 통과합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 643.38,
  "end": 650.7
 },
 {
  "input": "Now remember, what that means is that points of this boundary get mapped to outputs of all possible directions.",
  "translatedText": "이제 이것이 의미하는 바는 이 경계의 지점이 가능한 모든 방향의 출력에 매핑된다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 651.56,
  "end": 657.36
 },
 {
  "input": "So we'll explore it further, subdividing again and checking the boundary for each region.",
  "translatedText": "그래서 좀 더 자세히 살펴보고, 다시 세분화하여 각 지역의 경계를 확인하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 657.84,
  "end": 661.86
 },
 {
  "input": "The boundary of the top is all green, so we'll stop searching there.",
  "translatedText": "상단의 경계는 모두 녹색이므로 거기서 검색을 중지하겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 662.88,
  "end": 666.56
 },
 {
  "input": "But the bottom is colorful enough to deserve a subdivision.",
  "translatedText": "하지만 바닥은 세분화할 가치가 있을 만큼 컬러풀합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.86,
  "end": 669.52
 },
 {
  "input": "And just continue like this.",
  "translatedText": "그리고 이대로 계속하세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 670.34,
  "end": 672.02
 },
 {
  "input": "Check which subregion has a boundary covering all possible colors, meaning points of that boundary get mapped to all possible directions, and keep chopping those regions in half like we did for the one-dimensional case, eventually leading us to a zero over the func- Oh, hang on a second.",
  "translatedText": "가능한 모든 색상을 포함하는 경계가 있는 하위 영역을 확인합니다. 즉, 해당 경계의 지점이 가능한 모든 방향에 매핑된다는 의미입니다. 그리고 1차원 경우에서 했던 것처럼 해당 영역을 계속 반으로 자르고 결국 기능에 대한 0이 됩니다. 아, 잠깐만요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 672.36,
  "end": 687.48
 },
 {
  "input": "What happened here?",
  "translatedText": "여기 뭔 일 있었 니?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 688.88,
  "end": 689.92
 },
 {
  "input": "Neither of those last subdivisions on the bottom right passed through all the colors, so our algorithm stopped because it didn't want to search through either of those, but it also didn't find a zero.",
  "translatedText": "오른쪽 하단에 있는 마지막 하위 구분 중 어느 것도 모든 색상을 통과하지 못했기 때문에 우리 알고리즘은 둘 중 하나를 검색하고 싶지 않았기 때문에 중지되었지만 0도 찾지 못했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 690.38,
  "end": 699.92
 },
 {
  "input": "Okay, clearly something's wrong here.",
  "translatedText": "좋아요, 분명히 뭔가 문제가 있는 것 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 701.06,
  "end": 703.3
 },
 {
  "input": "And that's okay, being wrong is a regular part of doing math.",
  "translatedText": "그리고 괜찮아요. 틀린다는 것은 수학을 하는 데 있어 일반적인 부분입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 703.54,
  "end": 706.52
 },
 {
  "input": "If we look back, we had this hypothesis, and it led us to this proposed algorithm, so we were mistaken somewhere.",
  "translatedText": "돌이켜보면 우리는 이런 가설을 세웠고, 그것이 제안한 알고리즘으로 이어졌기 때문에 어딘가에서 착각하고 있었던 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 706.52,
  "end": 712.98
 },
 {
  "input": "And being good at math is not about being right the first time, it's about having the resilience to carefully look back and understand the mistakes, and understand how to fix them.",
  "translatedText": "그리고 수학을 잘한다는 것은 처음부터 옳다는 것이 아니라, 주의 깊게 되돌아보고 실수를 이해하고 이를 고치는 방법을 이해하는 회복력을 갖는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 713.66,
  "end": 721.8
 },
 {
  "input": "Now the problem here is that we had a region whose border went through every color, but when we split it in the middle, neither subregion's border went through every color, we had no options for where to keep searching next, and that broke the zero finder.",
  "translatedText": "이제 여기서 문제는 경계가 모든 색상을 통과하는 지역이 있다는 것입니다. 하지만 중간에 분할했을 때 하위 지역의 경계가 모든 색상을 통과하지 않았고 다음에 계속 검색할 위치에 대한 옵션이 없었으며 이로 인해 0이 깨졌습니다. 파인더.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 722.48,
  "end": 734.74
 },
 {
  "input": "Now in one dimension, this sort of thing never happened.",
  "translatedText": "이제 한 차원에서는 이런 종류의 일이 결코 일어나지 않았습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 734.74,
  "end": 737.56
 },
 {
  "input": "Any time you had an interval whose endpoints have different signs, if you split it up, you know that you're guaranteed to get some subinterval whose endpoints also have different signs.",
  "translatedText": "끝점에 다른 부호가 있는 간격이 있을 때마다 이를 분할하면 끝점에도 다른 부호가 있는 일부 하위 간격이 보장된다는 것을 알 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 737.98,
  "end": 748.46
 },
 {
  "input": "Or put another way, any time you have two intervals whose endpoints don't change signs, if you combine them, you'll get a bigger interval whose endpoints also don't change sign.",
  "translatedText": "또는 달리 말하면, 끝점이 부호를 변경하지 않는 두 개의 간격이 있을 때마다 이를 결합하면 끝점도 부호가 변경되지 않는 더 큰 간격을 얻게 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 749.02,
  "end": 758.38
 },
 {
  "input": "But in two dimensions, it's possible to find two regions whose borders don't go through every color, but whose boundaries combine to give a region whose border does go through every color.",
  "translatedText": "그러나 2차원에서는 경계가 모든 색상을 통과하지는 않지만 경계가 결합되어 모든 색상을 통과하는 영역을 제공하는 두 영역을 찾는 것이 가능합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 759.08,
  "end": 769.1
 },
 {
  "input": "And in just this way, our proposed zero-finding algorithm broke.",
  "translatedText": "그리고 이런 방식으로 우리가 제안한 영점 찾기 알고리즘이 깨졌습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 769.84,
  "end": 773.5
 },
 {
  "input": "In fact, if you think about it, you can find a big loop whose border goes through every possible color without there being a zero inside of it.",
  "translatedText": "사실, 생각해 보면 내부에 0이 없이 테두리가 가능한 모든 색상을 통과하는 큰 루프를 찾을 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 774.38,
  "end": 782.38
 },
 {
  "input": "Now that's not to say that we were wrong in our claims about tiny loops when we said that a forever narrowing loop going through every color has to be narrowing in on a zero.",
  "translatedText": "모든 색상을 통과하는 영원히 좁아지는 루프는 0에서 좁아져야 한다고 우리가 말했을 때 작은 루프에 대한 우리의 주장이 틀렸다고 말하는 것은 아닙니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 783.08,
  "end": 792.16
 },
 {
  "input": "But what made a mess of things for us is that this does-my-border-go-through-every-color-or-not property doesn't combine in a nice, predictable way when you combine regions.",
  "translatedText": "그러나 우리를 혼란스럽게 만든 것은 이 속성이 모든 색상을 통과하는지 여부에 관계없이 지역을 결합할 때 훌륭하고 예측 가능한 방식으로 결합되지 않는다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 792.8,
  "end": 802.14
 },
 {
  "input": "But don't worry, it turns out we can modify this slightly to a more sophisticated property that does combine to give us what we want.",
  "translatedText": "하지만 걱정하지 마세요. 우리가 원하는 것을 제공하기 위해 결합하는 좀 더 정교한 속성으로 이것을 약간 수정할 수 있다는 것이 밝혀졌습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 803.0,
  "end": 810.74
 },
 {
  "input": "The idea is that instead of simply asking whether we can find a color at some point along the loop, let's keep more careful track of how these colors change as we walk around that loop.",
  "translatedText": "단순히 루프의 특정 지점에서 색상을 찾을 수 있는지 묻는 대신 루프를 돌면서 이러한 색상이 어떻게 변하는지 더 주의 깊게 추적하자는 아이디어입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 818.18,
  "end": 827.86
 },
 {
  "input": "Let me show you what I mean with an example.",
  "translatedText": "예를 들어 내가 의미하는 바를 보여 드리겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 828.58,
  "end": 829.96
 },
 {
  "input": "I'll keep a little color wheel up here in the corner to help us keep track.",
  "translatedText": "추적하는 데 도움이 되도록 여기 구석에 작은 색상환을 올려 놓겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 830.4,
  "end": 833.26
 },
 {
  "input": "When the colors along a path of inputs move through the rainbow in a specific direction, from red to yellow, yellow to green, green to blue, or blue to red, the output is swinging clockwise.",
  "translatedText": "입력 경로를 따라 색상이 무지개를 통해 빨간색에서 노란색, 노란색에서 녹색, 녹색에서 파란색, 파란색에서 빨간색으로 특정 방향으로 이동하면 출력이 시계 방향으로 회전합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 833.94,
  "end": 844.96
 },
 {
  "input": "But on the other hand, if the colors move the other way through the rainbow, from blue to green, green to yellow, yellow to red, or red to blue, the output is swinging counterclockwise.",
  "translatedText": "그러나 반면에 색상이 무지개를 통해 파란색에서 녹색, 녹색에서 노란색, 노란색에서 빨간색, 빨간색에서 파란색으로 반대 방향으로 이동하면 출력이 시계 반대 방향으로 흔들리는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 845.7,
  "end": 856.32
 },
 {
  "input": "So walking along this short path here, the colors wind a fifth of the way clockwise through the color wheel, and walking along this path here, the colors wind another fifth of the way clockwise through the color wheel.",
  "translatedText": "따라서 여기 이 짧은 경로를 따라 걸으면 색상은 색상환을 통해 시계 방향으로 5분의 1 방향으로 휘어집니다. 그리고 여기 이 경로를 따라 걷는 경우 색상은 색상환을 통해 시계 방향으로 5분의 1 방향으로 휘어집니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 857.16,
  "end": 870.36
 },
 {
  "input": "Of course, that means that if you go through both paths, one after the other, the colors wind a total of two-fifths of a full turn clockwise.",
  "translatedText": "물론, 이는 두 경로를 차례로 통과하면 색상이 시계 방향으로 전체 회전의 2/5만큼 감겨진다는 것을 의미합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 871.16,
  "end": 878.64
 },
 {
  "input": "The total amount of winding just adds up, and this is going to be key, this is the kind of straightforward combining that will be useful to us.",
  "translatedText": "와인딩의 총량은 합산되며 이것이 핵심이 될 것입니다. 이것은 우리에게 유용할 일종의 간단한 결합입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 879.28,
  "end": 886.3
 },
 {
  "input": "When I say total amount of winding, I want you to imagine an old fashioned odometer that ticks forward as the arrow spins clockwise, but backwards as the arrow spins counterclockwise.",
  "translatedText": "총 권선량을 말할 때 화살표가 시계 방향으로 회전하면 앞으로 움직이고 화살표가 시계 반대 방향으로 회전하면 뒤로 움직이는 구식 주행 거리계를 상상해 보시기 바랍니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 886.98,
  "end": 897.9
 },
 {
  "input": "So counterclockwise winding counts as negative clockwise winding.",
  "translatedText": "따라서 시계 반대 방향 권선은 음의 시계 방향 권선으로 간주됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 898.74,
  "end": 902.46
 },
 {
  "input": "The outputs may turn a lot, but if some of that turning is in the opposite direction, it cancels out.",
  "translatedText": "출력이 많이 회전할 수 있지만 회전 중 일부가 반대 방향이면 상쇄됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 903.0,
  "end": 908.26
 },
 {
  "input": "For example, if you move forward along this path, and then move backwards along that same path, the total amount of winding ends up being zero, the backwards movement literally rewinds through the previously seen colors, reversing all the previous winding, and returning the odometer back to where it started.",
  "translatedText": "예를 들어, 이 경로를 따라 앞으로 이동한 다음 동일한 경로를 따라 뒤로 이동하면 총 감기 양은 0이 되고, 뒤로 이동은 말 그대로 이전에 본 색상을 통해 되감기하여 모든 이전 감기를 반전하고 주행 거리계가 시작된 곳으로 돌아갑니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 908.92,
  "end": 925.08
 },
 {
  "input": "For our purposes, we'll care most about looking at the winding along loops.",
  "translatedText": "우리의 목적을 위해 우리는 루프를 따라 감기는 것을 보는 데 가장 관심을 가질 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 926.28,
  "end": 929.9
 },
 {
  "input": "For example, let's say we walk around this entire loop clockwise.",
  "translatedText": "예를 들어, 이 전체 루프를 시계 방향으로 돌고 있다고 가정해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 930.44,
  "end": 933.68
 },
 {
  "input": "The outputs we come across wind around a total of three full clockwise turns, the colors swung through the rainbow, in order, from red to red again, and then again, and again.",
  "translatedText": "우리가 접하게 되는 출력은 시계 방향으로 총 3바퀴를 돌며, 색상은 빨간색에서 다시 빨간색으로, 그리고 다시 빨간색으로 순서대로 무지개를 통해 회전합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 934.24,
  "end": 946.18
 },
 {
  "input": "In the jargon mathematicians use, we say that along this loop, the total winding number is 3.",
  "translatedText": "수학자들이 사용하는 전문 용어에서는 이 루프를 따라 총 와인딩 수는 3이라고 말합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 946.92,
  "end": 952.72
 },
 {
  "input": "For other loops, it could be any other whole number, maybe a larger one if the output swings around many times as the input walks around a single loop, or it could be a smaller number if the output only swings around once or twice.",
  "translatedText": "다른 루프의 경우 다른 정수일 수 있으며, 입력이 단일 루프 주위를 이동할 때 출력이 여러 번 회전하는 경우 더 큰 숫자가 될 수 있고, 출력이 한두 번만 회전하는 경우 더 작은 숫자가 될 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.82,
  "end": 965.98
 },
 {
  "input": "Or that winding number could even be a negative integer, if the output was swinging counterclockwise as we walk clockwise around the loop.",
  "translatedText": "또는 루프를 시계 방향으로 돌 때 출력이 시계 반대 방향으로 흔들리는 경우 해당 굴곡 숫자는 음의 정수일 수도 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 966.32,
  "end": 974.32
 },
 {
  "input": "But along any loop, this total amount of winding has to be a whole number.",
  "translatedText": "그러나 어떤 루프에서든 이 총 권선 양은 정수여야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 975.18,
  "end": 978.86
 },
 {
  "input": "I mean, by the time you get back to where you started, you'll have the same output that you started with.",
  "translatedText": "내 말은, 시작한 곳으로 돌아올 때쯤에는 시작한 것과 동일한 결과를 얻게 될 것이라는 뜻입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 980.88,
  "end": 985.0
 },
 {
  "input": "Incidentally, if a path actually contains a point where the output is precisely zero, then technically you can't define a winding number along that, since the output has no particular direction.",
  "translatedText": "덧붙여서, 경로에 실제로 출력이 정확히 0인 지점이 포함되어 있는 경우 출력에 특정 방향이 없기 때문에 기술적으로 이를 따라 굴곡 수를 정의할 수 없습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 986.18,
  "end": 996.66
 },
 {
  "input": "This isn't going to be a problem for us, because our whole goal is to find zeros, so if this ever comes up, we just lucked out early.",
  "translatedText": "이것은 우리에게 문제가 되지 않을 것입니다. 왜냐하면 우리의 전체 목표는 0을 찾는 것이기 때문입니다. 따라서 이런 일이 발생하더라도 우리는 일찍 운이 좋았을 뿐입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 997.4,
  "end": 1004.04
 },
 {
  "input": "The main thing to notice about these winding numbers is that they add up nicely when you combine paths into bigger paths.",
  "translatedText": "이러한 구불구불한 숫자에 대해 주목해야 할 가장 중요한 점은 경로를 더 큰 경로로 결합할 때 그 숫자가 멋지게 합산된다는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1004.98,
  "end": 1010.68
 },
 {
  "input": "But what we really want is for the winding numbers along the borders of regions to add up nicely when we combine regions to make bigger regions.",
  "translatedText": "그러나 우리가 정말로 원하는 것은 지역을 결합하여 더 큰 지역을 만들 때 지역 경계를 따라 구불구불한 숫자가 멋지게 합산되는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1014.8,
  "end": 1022.44
 },
 {
  "input": "So do we have that property?",
  "translatedText": "그럼 우리는 그 재산을 갖고 있나요?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1022.98,
  "end": 1024.52
 },
 {
  "input": "Well, take a look.",
  "translatedText": "글쎄, 한번보세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1027.76,
  "end": 1029.06
 },
 {
  "input": "The winding number as we go clockwise around this region on the left is the sum of the winding numbers from these four paths.",
  "translatedText": "왼쪽에 있는 이 지역을 시계 방향으로 돌면서 구불구불한 숫자는 이 네 경로의 구불구불한 숫자의 합입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1029.54,
  "end": 1036.94
 },
 {
  "input": "And the winding as we go clockwise around this region on the right is the sum of the winding numbers from these four paths.",
  "translatedText": "그리고 오른쪽에 있는 이 지역을 시계 방향으로 회전하는 구불구불한 부분은 이 네 경로의 구불구불한 숫자의 합입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1037.5,
  "end": 1044.36
 },
 {
  "input": "And when we combine those two regions into a bigger one, most of those paths become part of the clockwise border of the bigger region.",
  "translatedText": "그리고 이 두 지역을 더 큰 지역으로 결합하면 대부분의 경로가 더 큰 지역의 시계 방향 경계의 일부가 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1045.34,
  "end": 1052.5
 },
 {
  "input": "And as for those two paths that don't?",
  "translatedText": "그렇지 않은 두 경로는 무엇입니까?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1053.26,
  "end": 1055.16
 },
 {
  "input": "They cancel out perfectly, one of them is just the reverse, the rewinding of the other one like we saw before.",
  "translatedText": "그것들은 완벽하게 상쇄됩니다. 그 중 하나는 우리가 전에 본 것처럼 다른 하나의 역방향입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1055.68,
  "end": 1061.76
 },
 {
  "input": "So the winding numbers along borders of regions add up in just the way we want them to.",
  "translatedText": "따라서 지역 경계를 따라 구불구불한 숫자는 우리가 원하는 방식으로 합산됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1062.56,
  "end": 1067.9
 },
 {
  "input": "Also side note, this reasoning about oriented borders adding up nicely like this comes up a lot in mathematics, and it often goes under the name Stokes' theorem.",
  "translatedText": "또한 참고로, 이렇게 멋지게 합산되는 지향성 경계에 대한 추론은 수학에서 많이 나타나며 종종 스톡스의 정리라는 이름으로 사용됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1068.64,
  "end": 1076.68
 },
 {
  "input": "Those of you who've studied multivariable calculus might recognize it from that context.",
  "translatedText": "다변수 미적분학을 공부해본 분들이라면 그 맥락에서 이를 인식하실 수도 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1077.06,
  "end": 1081.02
 },
 {
  "input": "So now, finally, with winding numbers in hand, we can get back to our equation solving goals.",
  "translatedText": "이제 마침내 구불구불한 숫자를 손에 쥐고 방정식 풀이 목표로 돌아갈 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1082.36,
  "end": 1087.44
 },
 {
  "input": "The problem with the region we saw earlier is that even though its border passed through all possible colors, the winding number was actually zero.",
  "translatedText": "앞서 본 영역의 문제점은 경계선이 가능한 모든 색상을 통과했음에도 불구하고 권선 수가 실제로 0이라는 것입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1088.0,
  "end": 1095.94
 },
 {
  "input": "The outputs wound around halfway, through yellow to red, and then started going counterclockwise back the other direction, then continued going through blue and hitting red from the other way, all in such a way that the total winding netted out to be zero.",
  "translatedText": "출력은 노란색을 거쳐 빨간색으로 반쯤 감겨진 다음 시계 반대 방향으로 다른 방향으로 돌아가기 시작한 다음 계속해서 파란색을 통과하고 반대쪽에서 빨간색에 도달하여 전체 권선이 0이 되는 방식으로 이루어졌습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1096.5,
  "end": 1110.86
 },
 {
  "input": "But if you find a loop which not only hits every color, but it has the stronger condition of a non-zero winding number, then if you were to split it in half, you're guaranteed that at least one of those halves has a non-zero winding number as well, since things add up nicely in the way we want them to.",
  "translatedText": "그러나 모든 색상에 해당할 뿐만 아니라 0이 아닌 구불구불한 숫자라는 더 강력한 조건을 갖는 루프를 찾은 경우 이를 반으로 분할하면 해당 반쪽 중 적어도 하나는 0이 아닌 굴곡 숫자도 마찬가지입니다. 왜냐하면 모든 것이 우리가 원하는 방식으로 멋지게 추가되기 때문입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1111.84,
  "end": 1128.04
 },
 {
  "input": "So in this way, you can keep going, narrowing in further and further onto one point.",
  "translatedText": "따라서 이런 방식으로 계속 진행하면서 한 지점으로 점점 더 범위를 좁힐 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1128.44,
  "end": 1133.5
 },
 {
  "input": "And as you narrow in onto a point, you'll be doing so with tiny loops that have non-zero winding numbers, which implies they go through all possible colors, and therefore, like I said before, the point they're narrowing in on must be a zero.",
  "translatedText": "그리고 한 지점으로 범위를 좁히면 0이 아닌 구불구불한 숫자가 있는 작은 루프를 사용하게 됩니다. 이는 가능한 모든 색상을 통과한다는 것을 의미합니다. 따라서 앞서 말했듯이 지점이 좁아지고 있습니다. on은 0이어야 합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1134.05,
  "end": 1146.4
 },
 {
  "input": "And that's it!",
  "translatedText": "그리고 그게 다야!",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1147.42,
  "end": 1148.36
 },
 {
  "input": "We have now created a two-dimensional equation solver, and this time, I promise, there are no bugs.",
  "translatedText": "이제 우리는 2차원 방정식 솔버를 만들었습니다. 이번에는 버그가 없을 것이라고 약속합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1148.6,
  "end": 1153.86
 },
 {
  "input": "Winding numbers are precisely the tool we need to make this work.",
  "translatedText": "권선 번호는 정확하게 이 작업을 수행하는 데 필요한 도구입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1154.56,
  "end": 1157.54
 },
 {
  "input": "We can now solve equations that look like where does f of x equal g of x in two dimensions, just by considering how the difference between f and g winds around.",
  "translatedText": "이제 f와 g 사이의 차이가 어떻게 돌아가는지 고려함으로써 2차원에서 f(x)가 g(x)와 어디가 같은지 방정식을 풀 수 있습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1158.1,
  "end": 1166.82
 },
 {
  "input": "Whenever we have a loop whose winding number isn't zero, we can run this algorithm on it, and we're guaranteed to find a solution somewhere within it.",
  "translatedText": "굴곡 수가 0이 아닌 루프가 있을 때마다 우리는 이 알고리즘을 루프에서 실행할 수 있으며 루프 내의 어딘가에서 솔루션을 찾도록 보장됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1167.6,
  "end": 1175.1
 },
 {
  "input": "And what's more, just like in one dimension, this algorithm is incredibly efficient.",
  "translatedText": "게다가 한 차원에서와 마찬가지로 이 알고리즘은 놀라울 정도로 효율적입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1175.66,
  "end": 1179.84
 },
 {
  "input": "We keep narrowing in on half the size of our region each round, thus quickly narrowing in on the zeros, and all the while, we only have to check the value of the function along points of these loops, rather than checking it on the many points of the interior.",
  "translatedText": "우리는 매 라운드마다 영역 크기를 절반으로 좁혀서 0으로 빠르게 좁혀지고 그 동안 많은 루프에서 확인하는 대신 이러한 루프의 지점을 따라 함수 값만 확인하면 됩니다. 인테리어 포인트.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1180.24,
  "end": 1194.4
 },
 {
  "input": "So in some sense, the overall work done is proportional only to the search space's perimeter, not the full area, which is amazing.",
  "translatedText": "따라서 어떤 의미에서 수행된 전체 작업은 전체 영역이 아닌 검색 공간의 둘레에만 비례합니다. 이는 놀라운 일입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1195.16,
  "end": 1203.74
 },
 {
  "input": "Now once you understand what's going on, it's weirdly mesmerizing to just watch this in action, giving it some function and letting it search for zeros.",
  "translatedText": "이제 무슨 일이 일어나고 있는지 이해하고 나면 이것이 작동하는 모습을 지켜보면서 기능을 제공하고 0을 검색하게 하는 것은 이상하게도 매혹적입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1204.92,
  "end": 1212.96
 },
 {
  "input": "Like I said before, complex numbers are two-dimensional, so let's apply it to some equation with complex numbers.",
  "translatedText": "앞서 말한 것처럼 복소수는 2차원이므로 복소수가 있는 방정식에 적용해 보겠습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1213.62,
  "end": 1219.56
 },
 {
  "input": "For example, here's the algorithm finding the zeros of the function x to the fifth minus x minus one over the complex plane.",
  "translatedText": "예를 들어, 복소 평면에서 5번째 빼기 x 빼기 1까지의 함수 x의 영점을 찾는 알고리즘은 다음과 같습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1220.3,
  "end": 1228.1
 },
 {
  "input": "It started by considering a very large region around the origin, which ended up having a winding number of 5.",
  "translatedText": "원점 주변의 매우 넓은 영역을 고려하여 시작하여 권선 수는 5가 되었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1228.9,
  "end": 1234.48
 },
 {
  "input": "Each time you find a loop with a non-zero winding number, you split it in half, and figure out the winding number of the two smaller loops.",
  "translatedText": "0이 아닌 굴곡 번호가 있는 루프를 찾을 때마다 이를 반으로 나누고 두 개의 작은 루프의 굴곡 번호를 알아냅니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1235.28,
  "end": 1242.12
 },
 {
  "input": "Either one or both of them is guaranteed to have a non-zero winding number, and when you see this, you know there's a zero somewhere inside that smaller loop, so you keep going in the same way, searching the smaller space.",
  "translatedText": "둘 중 하나 또는 둘 다 0이 아닌 굴곡 숫자를 갖는 것이 보장되며, 이를 보면 작은 루프 내부 어딘가에 0이 있다는 것을 알 수 있으므로 계속해서 동일한 방식으로 더 작은 공간을 검색합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1242.7,
  "end": 1253.4
 },
 {
  "input": "We also stop exploring a region if the path we're computing along happens to stumble across a zero, which actually happened once for this example on the right half here.",
  "translatedText": "또한 우리가 계산하고 있는 경로가 0을 우연히 발견하면 영역 탐색을 중단합니다. 실제로 여기 오른쪽 절반의 예에서 한 번 발생했습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1254.18,
  "end": 1262.9
 },
 {
  "input": "Those rare occurrences interfere with our ability to compute winding numbers, but hey, we got a zero.",
  "translatedText": "이러한 드문 현상은 권선 수를 계산하는 능력을 방해하지만 0을 얻었습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1263.28,
  "end": 1268.14
 },
 {
  "input": "And as for loops whose winding number is zero, you just don't explore those further.",
  "translatedText": "그리고 굴곡 수가 0인 루프의 경우 더 이상 탐색하지 않습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1269.22,
  "end": 1272.92
 },
 {
  "input": "Maybe they have a solution inside, maybe they don't, we have no guarantees.",
  "translatedText": "내부에 해결책이 있을 수도 있고 없을 수도 있습니다. 우리는 보장할 수 없습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1272.92,
  "end": 1276.2
 },
 {
  "input": "And letting our equation solver continue in this same way, it eventually converges to lots of zeros for this polynomial.",
  "translatedText": "그리고 방정식 솔버가 이와 동일한 방식으로 계속되도록 하면 결국 이 다항식에 대해 많은 0으로 수렴됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1278.4,
  "end": 1284.02
 },
 {
  "input": "By the way, it is no coincidence that the total winding number in this example happened to be 5.",
  "translatedText": "그런데 이 예에서 총 권선 수가 5인 것은 우연이 아닙니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1285.84,
  "end": 1291.0
 },
 {
  "input": "With complex numbers, the operation x to the n directly corresponds to walking around the output's origin n times as you walk around the input's origin once.",
  "translatedText": "복소수의 경우 x에서 n까지의 연산은 입력 원점을 한 번 돌아다니면서 출력 원점을 n번 돌아다니는 것과 직접적으로 일치합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1291.58,
  "end": 1302.24
 },
 {
  "input": "So with the polynomial, for large enough inputs, every term other than the leading term becomes insignificant in comparison.",
  "translatedText": "따라서 다항식을 사용하면 입력이 충분히 큰 경우 주요 항을 제외한 모든 항이 비교에서 중요하지 않게 됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1304.68,
  "end": 1311.98
 },
 {
  "input": "So any complex polynomial whose leading term is x to the n has a winding number of n around a large enough loop.",
  "translatedText": "따라서 선행항이 x에서 n까지인 모든 복소 다항식은 충분히 큰 루프 주위에 n의 굴곡 수를 갖습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1312.48,
  "end": 1319.78
 },
 {
  "input": "And in that way, our winding number technology actually guarantees that every complex polynomial has a zero.",
  "translatedText": "그런 식으로 우리의 굴곡수 기술은 실제로 모든 복소 다항식에 0이 있음을 보장합니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1320.54,
  "end": 1326.82
 },
 {
  "input": "This is such an important fact that mathematicians call it the fundamental theorem of algebra.",
  "translatedText": "이는 수학자들이 대수학의 기본 정리라고 부를 만큼 중요한 사실입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1327.48,
  "end": 1332.0
 },
 {
  "input": "Having an algorithm for finding numerical solutions to equations like this is extremely practical, but the fundamental theorem of algebra is a good example of how these winding numbers are also quite useful on a theoretical level, guaranteeing the existence of a solution to a broad class of equations for suitable conditions, which is much more the kind of thing mathematicians like thinking about.",
  "translatedText": "이와 같은 방정식에 대한 수치적 해를 찾는 알고리즘을 갖는 것은 매우 실용적이지만 대수학의 기본 정리는 이러한 구불구불한 숫자가 이론적 수준에서도 매우 유용하여 광범위한 클래스에 대한 해의 존재를 보장하는 방법을 보여주는 좋은 예입니다. 적합한 조건에 대한 방정식은 수학자들이 생각하고 싶어하는 종류에 훨씬 더 가깝습니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1333.8,
  "end": 1353.94
 },
 {
  "input": "I'll show you a couple more amazing applications of this in the context of topology in a follow-up video, which includes correcting a mistake from an old 3blue1brown video.",
  "translatedText": "후속 비디오에서 토폴로지 맥락에서 이에 대한 몇 가지 놀라운 응용 프로그램을 보여 드리겠습니다. 여기에는 오래된 3blue1brown 비디오의 실수 수정이 포함됩니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1353.94,
  "end": 1363.44
 },
 {
  "input": "Which one?",
  "translatedText": "어느 것?",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1364.06,
  "end": 1364.44
 },
 {
  "input": "Well, watch all of the videos, everything on this channel, and see if you can spot the error first.",
  "translatedText": "이 채널의 모든 동영상과 모든 내용을 시청하고 먼저 오류를 발견할 수 있는지 확인하세요.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1364.94,
  "end": 1369.6
 },
 {
  "input": "The primary author of this video is one of the newest 3blue1brown team members, Sridhar Ramesh.",
  "translatedText": "이 비디오의 주요 작성자는 3blue1brown의 최신 팀원 중 한 명인 Sridhar Ramesh입니다.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1371.3,
  "end": 1390.06
 }
]