[
 {
  "input": "There's two things here, the main topic and the meta topic.",
  "translatedText": "这里有两件事，主要主题和元主题。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 3.06,
  "end": 6.14
 },
 {
  "input": "The main topic is going to be this really neat algorithm for solving two-dimensional equations, things that have two unknown real numbers, or also those involving a single unknown which is a complex number.",
  "translatedText": "主要主题将是这个非常简洁的算法，用于 求解二维方程，具有两个未知实数的事物 ，或者涉及单个未知数（复数）的事物。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 6.64,
  "end": 16.84
 },
 {
  "input": "So for example, if you wanted to find the complex roots of a polynomial, or maybe some of those million dollar zeros of the Riemann zeta function, this algorithm would do it for you.",
  "translatedText": "例如，如果您想找到多项式的复数根， 或者黎曼 zeta 函数的一些百万 美元零点，这个算法可以为您做到。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 17.44,
  "end": 26.5
 },
 {
  "input": "And this method is super pretty, since a lot of colors are involved.",
  "translatedText": "而且这个方法超级漂亮，因为涉及到很多颜色。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 26.8,
  "end": 30.06
 },
 {
  "input": "And more importantly, the core underlying idea applies to all sorts of math well beyond this algorithm for solving equations, including a bit of topology, which I'll talk about afterwards.",
  "translatedText": "更重要的是，核心的基本思想适用于各 种数学，远远超出了求解方程的算法， 包括一些拓扑学，我将在后面讨论。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 30.54,
  "end": 40.06
 },
 {
  "input": "But what really makes this worth 20 minutes or so of your time is that it illustrates a lesson much more generally useful throughout math, which is try to define constructs that compose nicely with each other.",
  "translatedText": "但真正让您花费 20 分钟左右的时间的 原因是，它说明了在整个数学中更普遍有用 的课程，即尝试定义彼此完美组合的结构。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 40.74,
  "end": 51.98
 },
 {
  "input": "You'll see what I mean by that as the story progresses.",
  "translatedText": "随着故事的进展，你会明白我的意思。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 52.4,
  "end": 54.48
 },
 {
  "input": "To motivate the case with functions that have 2d inputs and 2d outputs, let's start off simpler, with functions that just take in a real number and spit out a real number.",
  "translatedText": "为了用具有 2d 输入和 2d 输出的函数来激发这个案例 ，让我们从更简单的开始，使用只接受实数并输出实数的函数。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 55.06,
  "end": 63.82
 },
 {
  "input": "If you want to know when a function f of x equals some other function g of x, you might think of this as searching for when the graphs of those functions intersect, right?",
  "translatedText": "如果您想知道 x 的函数 f 何时等于 x 的其他函数 g，您可能会认为这是搜索这些函数的图形何时相交，对吧？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 65.08,
  "end": 74.52
 },
 {
  "input": "I mean, that gives you an input where both functions have the same output.",
  "translatedText": "我的意思是，这为您提供了两个函数具有相同输出的输入。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 75.02,
  "end": 78.52
 },
 {
  "input": "To take a very simple example, imagine f of x is x squared, and g of x is the constant function 2.",
  "translatedText": "举一个非常简单的例子，假设 x 的 f 是 x 的平方，x 的 g 是常数函数 2。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 78.52,
  "end": 85.3
 },
 {
  "input": "In other words, you want to find the square root of 2.",
  "translatedText": "换句话说，您想要找到 2 的平方根。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 85.96,
  "end": 88.64
 },
 {
  "input": "Even if you know almost nothing about finding square roots, you can probably see that 1 squared is less than 2, and 2 squared is bigger than 2, so you realize, ah, there's going to be some solution in between those two values.",
  "translatedText": "即使您对求平方根几乎一无所知，您也可能会看到 1 的平方小于 2，而 2 的平方大于 2，所 以您意识到，啊，这两个值之间会有一些解决方案。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 89.46,
  "end": 101.86
 },
 {
  "input": "And then if you wanted to narrow it down further, maybe you try squaring the halfway point, 1.5.",
  "translatedText": "然后，如果您想进一步缩小范围，也许您可以尝试对 中间点 1 进行平方。5.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 102.58,
  "end": 107.14
 },
 {
  "input": "This comes out to be 2.25, a little too high, so you'd focus on the region between 1 and 1.5.",
  "translatedText": "结果是 2。25，有点太高了，所以您应该关注 1 和 1 之间的区域。5.",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 107.72,
  "end": 113.76
 },
 {
  "input": "And so on, you can probably see how this would keep going, you'd keep computing at the midpoint and then chopping your search space in half.",
  "translatedText": "依此类推，您可能会看到这将如何继续下去，您将 继续在中点进行计算，然后将搜索空间切成两半。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 114.76,
  "end": 120.92
 },
 {
  "input": "Another way to think about this, which is going to make it easier for us once we get up to higher dimensions, is to instead focus on the equivalent question for when the difference between these two functions is zero.",
  "translatedText": "思考这个问题的另一种方法是，当我们达到更高 的维度时，这将使我们更容易理解，即专注于 这两个函数之间的差异何时为零的等效问题。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 125.1,
  "end": 135.52
 },
 {
  "input": "In those terms, we found a region of inputs where that difference was negative on one end, and it was positive on another end.",
  "translatedText": "就这些而言，我们发现了一个输入区域，其 中一端的差异为负，另一端的差异为正。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 136.1,
  "end": 143.34
 },
 {
  "input": "We split it into two, and the half we narrowed our attention to was the one where the outermost points had varying signs.",
  "translatedText": "我们把它分成两半，我们将注意力集中 到最外面的点有不同符号的那一半。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 143.84,
  "end": 150.56
 },
 {
  "input": "Like this, we were able to keep going forever, taking each region with varying signs on the border, finding a smaller such region among its halves, knowing that ultimately we have to be narrowing in on a point which is going to be exactly zero.",
  "translatedText": "像这样，我们能够永远继续前进，选取边界上具有不同 标志的每个区域，在其两半中找到一个更小的这样的 区域，知道最终我们必须缩小到一个恰好为零的点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 151.36,
  "end": 164.2
 },
 {
  "input": "In short, solving equations can always be framed as finding when a certain function is equal to zero, and to do that, we have this heuristic, if f is positive at one point and negative at another point, you can find someplace in between where it's zero, at least if everything changes smoothly with no sudden jumps.",
  "translatedText": "简而言之，求解方程总是可以被框架为找到某个函数何时等 于零，为此，我们有这样的启发式，如果 f 在一点为 正，在另一点为负，您可以找到中间的某个位置，其中它 为零，至少如果一切都顺利变化而没有突然的跳跃的话。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 165.76,
  "end": 183.02
 },
 {
  "input": "The amazing thing I want to show you is that you can extend this kind of thinking into two-dimensional equations, equations between functions whose inputs and outputs are both two-dimensional.",
  "translatedText": "我想向您展示的令人惊奇的事情是，您 可以将这种思维扩展到二维方程，即输 入和输出都是二维的函数之间的方程。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 183.88,
  "end": 194.08
 },
 {
  "input": "For example, complex numbers are 2D, and this tool we're developing is perfect for finding solutions to complex equations.",
  "translatedText": "例如，复数是二维的，我们正在开发的 这个工具非常适合寻找复杂方程的解。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 194.74,
  "end": 201.4
 },
 {
  "input": "Now, since we're going to be talking about these 2D functions so much, let's take a brief side step and consider how we illustrate these.",
  "translatedText": "现在，既然我们要详细讨论这些 2D 函数，那 么让我们先简单地考虑一下如何说明这些函数。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 202.36,
  "end": 208.34
 },
 {
  "input": "Graphing a function with a 2D input and 2D output would require four dimensions, and that's not going to work so well in our 3D world on our 2D screens, but we still have a couple good options.",
  "translatedText": "用 2D 输入和 2D 输出绘制一个函数需要 四个维度，这在 2D 屏幕上的 3D 世界 中效果不太好，但我们仍然有一些不错的选择。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 209.06,
  "end": 220.22
 },
 {
  "input": "One is to just look at both the input space and output space side by side.",
  "translatedText": "一种是并排查看输入空间和输出空间。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 220.86,
  "end": 225.44
 },
 {
  "input": "Each point in the input space moves to a particular point in the output space, and I can show how moving around that input point corresponds to certain movements in the output space.",
  "translatedText": "输入空间中的每个点都会移动到输出空间中的特定点，我可以 展示围绕该输入点的移动如何对应于输出空间中的某些移动。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 225.54,
  "end": 236.26
 },
 {
  "input": "All of the functions we consider will be continuous, in the sense that small little changes to the input only correspond to small little changes in the output, there's no sudden jumps.",
  "translatedText": "我们考虑的所有函数都将是连续的，从某 种意义上说，输入的微小变化仅对应于 输出的微小变化，不存在突然的跳跃。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 236.94,
  "end": 246.3
 },
 {
  "input": "Another option we have is to imagine the arrow from the origin of the output space to that output point, and to attach a miniature version of that arrow to the input point.",
  "translatedText": "我们的另一个选择是想象从输出空间的原点到该输出 点的箭头，并将该箭头的微型版本附加到输入点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 246.94,
  "end": 256.58
 },
 {
  "input": "This can give us a sense, at a glance, for where a given input point goes, or where many different input points go by drawing the full vector field.",
  "translatedText": "这可以让我们一目了然地了解给定输入点的去向，或者 通过绘制完整的矢量场来了解许多不同输入点的去向。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 257.36,
  "end": 265.84
 },
 {
  "input": "And unfortunately when you do this at a lot of points it can get pretty cluttered, so here let me make all of the arrows the same size, and what this means is we can get a sense of the direction of each output point.",
  "translatedText": "不幸的是，当你在很多点上这样做时，它可能会变得 非常混乱，所以在这里让我将所有箭头设置为相同的 大小，这意味着我们可以了解每个输出点的方向。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 267.6,
  "end": 277.1
 },
 {
  "input": "But perhaps the prettiest way to illustrate two-dimensional functions, and the one we'll be using most this video, is to associate each point in that output space with a color.",
  "translatedText": "但也许说明二维函数的最漂亮的方法，也是我们在本视频中最 常用的方法，是将输出空间中的每个点与一种颜色相关联。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 277.78,
  "end": 286.38
 },
 {
  "input": "Here we've used hues, that is where the color falls along a rainbow or a color wheel, to correspond to the direction away from the origin, and we're using darkness or brightness to correspond to the distance from the origin.",
  "translatedText": "在这里，我们使用色调（即颜色沿着彩虹或色 轮下降的位置）来对应远离原点的方向，并且 我们使用暗度或亮度来对应距原点的距离。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 287.22,
  "end": 299.26
 },
 {
  "input": "For example, focusing on this array of outputs, all of these points are red, but the ones closer to the origin are a little darker, and the ones farther away are a little brighter.",
  "translatedText": "例如，关注这个输出数组，所有这些点都是红色的，但 是靠近原点的点更暗一些，远离原点的点更亮一些。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 299.26,
  "end": 309.62
 },
 {
  "input": "And focusing on this array of outputs, all of the points are green, and again, closer to the origin means darker, farther away means lighter.",
  "translatedText": "关注这个输出数组，所有的点都是绿色的，同 样，靠近原点意味着更暗，更远意味着更亮。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 310.36,
  "end": 317.98
 },
 {
  "input": "And so on, all we're doing here is assigning a specific color to each direction, all changing continuously.",
  "translatedText": "依此类推，我们在这里所做的就是为每个方向 分配特定的颜色，所有颜色都在不断变化。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 318.78,
  "end": 324.84
 },
 {
  "input": "You might notice the darkness and brightness differences here are pretty subtle, but for this video, all we care about is the direction of outputs, not the magnitudes, the hues, not the brightness.",
  "translatedText": "您可能会注意到这里的黑暗和亮度差异非常 微妙，但对于这个视频，我们关心的是输出 的方向，而不是幅度、色调，而不是亮度。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 325.36,
  "end": 334.56
 },
 {
  "input": "The one important thing about brightness for you to notice is that near the origin, which has no particular direction, all of the colors fade to black.",
  "translatedText": "关于亮度，您需要注意的一件重要的事情是，在没有 特定方向的原点附近，所有颜色都会褪色为黑色。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 335.3,
  "end": 343.12
 },
 {
  "input": "So for thinking about functions, now that we've decided on a color for each output, we can visualize 2D functions by coloring each point in the input space based on the color of the point where it lands in the output space.",
  "translatedText": "因此，在考虑函数时，现在我们已经决定了每个输出 的颜色，我们可以通过根据输出空间中点的颜色为 输入空间中的每个点着色来可视化 2D 函数。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 344.44,
  "end": 357.1
 },
 {
  "input": "I like to imagine many different points from that input space hopping over to their corresponding outputs in the output space, then getting painted based on the color of the point where they land, and then hopping back to where they came from in the input space.",
  "translatedText": "我喜欢想象输入空间中的许多不同点跳跃到输出空 间中相应的输出，然后根据它们着陆点的颜色进行 绘制，然后跳回它们在输入空间中的来源位置。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 357.84,
  "end": 370.36
 },
 {
  "input": "Doing this for every point in the input space, you can get a sense just by looking at that input space for roughly where the function takes each point.",
  "translatedText": "对输入空间中的每个点执行此操作，只需查看该 输入空间即可大致了解函数获取每个点的位置。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 371.64,
  "end": 378.42
 },
 {
  "input": "For example, this stripe of pink points on the left tells us that all of those points get mapped somewhere in the pink direction, that lower left of the output space.",
  "translatedText": "例如，左侧的粉红色点条纹告诉我们所有这些点都映 射到粉红色方向的某个位置，即输出空间的左下角。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 379.12,
  "end": 388.28
 },
 {
  "input": "Also those three points which are black with lots of colors around them are the ones that go to zero.",
  "translatedText": "另外，那些周围有很多颜色 的黑色点也是归零的点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 389.78,
  "end": 394.9
 },
 {
  "input": "Alright, so just like the 1D case, solving equations of 2D functions can always be reframed by asking when a certain function is equal to zero.",
  "translatedText": "好吧，就像一维情况一样，二维函数的求解方程总 是可以通过询问某个函数何时等于零来重新构建。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 399.34,
  "end": 408.88
 },
 {
  "input": "So that's our challenge right now, create an algorithm that finds which input points of a given 2D function go to zero.",
  "translatedText": "所以这就是我们现在的挑战，创建一个算法来 查找给定 2D 函数的哪些输入点变为零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 409.58,
  "end": 417.06
 },
 {
  "input": "You might point out that if you're looking at a color map like this by seeing those black dots, you already know where the zeros of the function are.",
  "translatedText": "您可能会指出，如果您通过看到这些黑点来查看这 样的彩色图，您就已经知道函数的零点在哪里。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 420.86,
  "end": 428.3
 },
 {
  "input": "So does that count?",
  "translatedText": "那么这算吗？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 428.62,
  "end": 430.0
 },
 {
  "input": "Keep in mind that to create a diagram like this, we've had the computer compute the function at all the pixels on the plane, but our goal is to find a more efficient algorithm that only requires computing the function at as few points as possible, only having a limited view of the colors, so to speak.",
  "translatedText": "请记住，要创建这样的图表，我们已经让计算机在 平面上的所有像素上计算函数，但我们的目标是 找到一种更有效的算法，只需要在尽可能少的点 上计算函数，可以这么说，对颜色的了解有限。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 430.92,
  "end": 447.86
 },
 {
  "input": "And also from a more theoretical standpoint, it'd be nice to have a general construct that tells us the conditions for whether or not a zero exists inside a given region.",
  "translatedText": "而且从更理论的角度来看，最好有一个通用的构 造来告诉我们给定区域内是否存在零的条件。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 449.36,
  "end": 457.64
 },
 {
  "input": "Remember, in one dimension the main insight was that if a continuous function is positive at one point and negative at another, somewhere in between it must be zero.",
  "translatedText": "请记住，在一个维度上，主要见解是，如果连续函数在某一点 为正，在另一点为负，则介于两者之间的某个位置必须为零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 459.0,
  "end": 467.92
 },
 {
  "input": "So how do we extend that into two dimensions?",
  "translatedText": "那么我们如何将其扩展到二维呢？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 468.84,
  "end": 470.58
 },
 {
  "input": "We need some sort of analog of talking about signs.",
  "translatedText": "我们需要某种类似谈论符号的方式。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 470.94,
  "end": 473.58
 },
 {
  "input": "One way to think about what signs even are is directions.",
  "translatedText": "思考标志是什么的一种方法是方向。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 474.7,
  "end": 478.14
 },
 {
  "input": "Positive means you're pointing to the right along the number line, and negative means you're pointing to the left.",
  "translatedText": "正数表示您沿着数轴指向右侧， 负数表示您沿着数轴指向左侧。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 478.8,
  "end": 483.5
 },
 {
  "input": "Two-dimensional quantities also have direction, but for them the options are much wider, they can point anywhere along a whole circle of possibilities.",
  "translatedText": "二维量也有方向，但对它们来说，选择范围要广泛 得多，它们可以指向整个可能性圈中的任何地方。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 484.2,
  "end": 491.8
 },
 {
  "input": "So the same way that in one dimension we were asking whether a given function is positive or negative on the boundary of a range, which is just two points, for 2d functions we're going to be looking at the boundary of a region, which is a loop, and ask about the direction of the function's output along that boundary.",
  "translatedText": "因此，就像在一维中我们询问给定函数在范围边 界（只有两个点）上是正值还是负值一样，对 于二维函数，我们将查看一个区域的边界，即是 一个循环，并询问函数输出沿该边界的方向。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 492.53,
  "end": 510.86
 },
 {
  "input": "For example, we see that along this loop around this zero, the output goes through every possible direction, all the colors of the rainbow, red, yellow, green, blue, back to red, and everything in between along the way.",
  "translatedText": "例如，我们看到沿着围绕这个零的循环，输出经过 每个可能的方向，彩虹的所有颜色，红色，黄色， 绿色，蓝色，回到红色，以及沿途的所有颜色。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 513.64,
  "end": 525.06
 },
 {
  "input": "But along this loop over here, with no zeros inside of it, the output doesn't go through every color, it goes through some of the orangish ones, but never, say, green or blue.",
  "translatedText": "但是沿着这里的循环，内部没有零，输出不会经历每种颜色 ，它会经历一些橙色的颜色，但永远不会经历绿色或蓝色。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 525.7,
  "end": 534.64
 },
 {
  "input": "And this is promising, it looks a lot like how things worked in one dimension.",
  "translatedText": "这是有希望的，它看起来很像在一维中的运作方式。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 535.3,
  "end": 538.46
 },
 {
  "input": "Maybe in the same way that if a 1d function takes both possible signs on the boundary of a 1d region, there was a zero somewhere inside, we might hypothesize that if a 2d function hits outputs of all possible directions, all possible colors, along the boundary of a 2d region, then somewhere inside that region it must go to zero.",
  "translatedText": "也许以同样的方式，如果 1d 函数在 1d 区域的边界 上取两个可能的符号，内部某处有一个零，我们可以假设，如 果 2d 函数命中所有可能方向、所有可能颜色的输出，沿 着二维区域的边界，那么该区域内的某个位置它必须为零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 539.34,
  "end": 559.86
 },
 {
  "input": "So that's our guess, and take a moment to think about if this should be true, and if so why.",
  "translatedText": "这就是我们的猜测，请花点时间思考这 是否属实，如果属实，原因是什么。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 560.96,
  "end": 566.12
 },
 {
  "input": "If we start thinking about a tiny loop around some input point, we know that since everything is continuous, our function takes it to some tiny loop near the corresponding output.",
  "translatedText": "如果我们开始考虑围绕某个输入点的小循环，我们就会知道，由于一 切都是连续的，我们的函数会将其带到相应输出附近的某个小循环。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 567.42,
  "end": 576.28
 },
 {
  "input": "But look, for most tiny loops, the output varies in color.",
  "translatedText": "但请注意，对于大多数微小循环，输出的颜色各不相同。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 577.14,
  "end": 580.52
 },
 {
  "input": "If you pick any output point other than zero, and draw a sufficiently tight loop near it, the loop's colors are all going to be about the same color as that point.",
  "translatedText": "如果您选择零以外的任何输出点，并在其附近绘制一个足 够紧密的循环，则循环的颜色将与该点的颜色大致相同。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 580.98,
  "end": 589.42
 },
 {
  "input": "A tight loop over here is all bluish, a tight loop over here is all yellowish, you certainly aren't going to get every color of the rainbow.",
  "translatedText": "这里的紧密环都是蓝色的，这里的紧密环都是 淡黄色的，你当然不会得到彩虹的每种颜色。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 589.84,
  "end": 597.68
 },
 {
  "input": "The only point where you can tighten loops around it while still getting all the colors is the colorless origin, zero itself.",
  "translatedText": "唯一可以收紧它周围的循环同时仍然获得 所有颜色的点是无色原点，即零本身。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 598.22,
  "end": 606.32
 },
 {
  "input": "So it is indeed the case that if you have loops going through every color of the rainbow, tightening and tightening, narrowing in on a point, then that point must in fact be a zero.",
  "translatedText": "因此，情况确实如此，如果你有循环穿 过彩虹的每种颜色，收紧再收紧，缩小 到一个点，那么该点实际上一定是零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 607.1,
  "end": 616.38
 },
 {
  "input": "And so let's set up a 2d equation solver just like our one-dimensional equation solver.",
  "translatedText": "因此，让我们设置一个二维方程求解器，就像我们的一维方程求解器一样。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 617.32,
  "end": 621.86
 },
 {
  "input": "When we find a large region whose border goes through every color, split it into two, and then look at the colors on the boundary of each half.",
  "translatedText": "当我们找到一个边界穿过每种颜色的大区域时， 将其分成两半，然后查看每一半边界上的颜色。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 622.26,
  "end": 629.9
 },
 {
  "input": "In the example shown here, the border on the left half doesn't go through all colors, there are no points that map to the orangeish yellowish directions, for example.",
  "translatedText": "在此显示的示例中，左半部分的边框并未穿过所 有颜色，例如，没有映射到橙黄色方向的点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 630.54,
  "end": 638.6
 },
 {
  "input": "So I'll grey out this area as a way of saying we don't want to search it any further.",
  "translatedText": "因此，我会将这个区域灰显，以表示我们不想再进一步搜索它。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 639.06,
  "end": 642.62
 },
 {
  "input": "The right half does go through all the colors, spends a lot of time in the green direction, then passes through yellow orange red, as well as blue violet pink.",
  "translatedText": "右半部分确实经历了所有颜色，在绿色方向上花了 很多时间，然后经历了黄橙红，以及蓝紫粉色。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 643.38,
  "end": 650.7
 },
 {
  "input": "Now remember, what that means is that points of this boundary get mapped to outputs of all possible directions.",
  "translatedText": "现在请记住，这意味着该边界的点 被映射到所有可能方向的输出。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 651.56,
  "end": 657.36
 },
 {
  "input": "So we'll explore it further, subdividing again and checking the boundary for each region.",
  "translatedText": "因此，我们将进一步探索它，再次细分并检查每个区域的边界。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 657.84,
  "end": 661.86
 },
 {
  "input": "The boundary of the top is all green, so we'll stop searching there.",
  "translatedText": "顶部的边界全是绿色的，所以我们在那里停止搜索。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 662.88,
  "end": 666.56
 },
 {
  "input": "But the bottom is colorful enough to deserve a subdivision.",
  "translatedText": "但底部的色彩足以值得细分。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 666.86,
  "end": 669.52
 },
 {
  "input": "And just continue like this.",
  "translatedText": "就这样继续下去。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 670.34,
  "end": 672.02
 },
 {
  "input": "Check which subregion has a boundary covering all possible colors, meaning points of that boundary get mapped to all possible directions, and keep chopping those regions in half like we did for the one-dimensional case, eventually leading us to a zero over the func- Oh, hang on a second.",
  "translatedText": "检查哪个子区域具有覆盖所有可能颜色的边界 ，这意味着该边界的点被映射到所有可能的方 向，并像我们对一维情况一样将这些区域切成 两半，最终导致我们的函数为零哦，等一下。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 672.36,
  "end": 687.48
 },
 {
  "input": "What happened here?",
  "translatedText": "这里发生了什么？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 688.88,
  "end": 689.92
 },
 {
  "input": "Neither of those last subdivisions on the bottom right passed through all the colors, so our algorithm stopped because it didn't want to search through either of those, but it also didn't find a zero.",
  "translatedText": "右下角的最后一个细分都没有遍历所有颜 色，因此我们的算法停止了，因为它不想 搜索其中任何一个，但它也没有找到零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 690.38,
  "end": 699.92
 },
 {
  "input": "Okay, clearly something's wrong here.",
  "translatedText": "好吧，显然这里出了问题。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 701.06,
  "end": 703.3
 },
 {
  "input": "And that's okay, being wrong is a regular part of doing math.",
  "translatedText": "没关系，犯错是做数学的正常现象。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 703.54,
  "end": 706.52
 },
 {
  "input": "If we look back, we had this hypothesis, and it led us to this proposed algorithm, so we were mistaken somewhere.",
  "translatedText": "如果我们回顾过去，我们有这个假设，它导致我们 提出了这个算法，所以我们在某个地方犯了错误。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 706.52,
  "end": 712.98
 },
 {
  "input": "And being good at math is not about being right the first time, it's about having the resilience to carefully look back and understand the mistakes, and understand how to fix them.",
  "translatedText": "擅长数学并不在于第一次就正确， 而是在于具有仔细回顾并理解错误 的能力，并了解如何纠正它们。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 713.66,
  "end": 721.8
 },
 {
  "input": "Now the problem here is that we had a region whose border went through every color, but when we split it in the middle, neither subregion's border went through every color, we had no options for where to keep searching next, and that broke the zero finder.",
  "translatedText": "现在的问题是，我们有一个区域，其边界穿过每种颜色，但是当 我们将其从中间分割时，两个子区域的边界都没有穿过每种颜色 ，我们无法选择下一步在哪里继续搜索，这就打破了零发现者。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 722.48,
  "end": 734.74
 },
 {
  "input": "Now in one dimension, this sort of thing never happened.",
  "translatedText": "现在在一个维度中，这种事情从来没有发生过。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 734.74,
  "end": 737.56
 },
 {
  "input": "Any time you had an interval whose endpoints have different signs, if you split it up, you know that you're guaranteed to get some subinterval whose endpoints also have different signs.",
  "translatedText": "每当您有一个端点具有不同符号的区间 时，如果将其拆分，您就知道一定会得 到一些端点也具有不同符号的子区间。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 737.98,
  "end": 748.46
 },
 {
  "input": "Or put another way, any time you have two intervals whose endpoints don't change signs, if you combine them, you'll get a bigger interval whose endpoints also don't change sign.",
  "translatedText": "或者换句话说，任何时候你有两个端点不改变 符号的区间，如果将它们组合起来，你将得 到一个更大的区间，其端点也不改变符号。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 749.02,
  "end": 758.38
 },
 {
  "input": "But in two dimensions, it's possible to find two regions whose borders don't go through every color, but whose boundaries combine to give a region whose border does go through every color.",
  "translatedText": "但在二维中，可以找到两个区域，其边界 不穿过每种颜色，但其边界组合起来给 出一个边界确实穿过每种颜色的区域。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 759.08,
  "end": 769.1
 },
 {
  "input": "And in just this way, our proposed zero-finding algorithm broke.",
  "translatedText": "就这样，我们提出的找零算法失效了。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 769.84,
  "end": 773.5
 },
 {
  "input": "In fact, if you think about it, you can find a big loop whose border goes through every possible color without there being a zero inside of it.",
  "translatedText": "事实上，如果你仔细想想，你会发现一个大循环 ，其边界穿过所有可能的颜色，而内部没有零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 774.38,
  "end": 782.38
 },
 {
  "input": "Now that's not to say that we were wrong in our claims about tiny loops when we said that a forever narrowing loop going through every color has to be narrowing in on a zero.",
  "translatedText": "现在，这并不是说我们关于微小循环的说法是错误的，当 我们说穿过每种颜色的永远缩小的循环必须缩小到零时。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 783.08,
  "end": 792.16
 },
 {
  "input": "But what made a mess of things for us is that this does-my-border-go-through-every-color-or-not property doesn't combine in a nice, predictable way when you combine regions.",
  "translatedText": "但让我们变得一团糟的是，当您组合区域时，“我的边框是否 穿过每种颜色”属性并不能以良好的、可预测的方式组合。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 792.8,
  "end": 802.14
 },
 {
  "input": "But don't worry, it turns out we can modify this slightly to a more sophisticated property that does combine to give us what we want.",
  "translatedText": "但别担心，事实证明我们可以将其稍微修改为更复杂的属性 ，这些属性结合起来确实可以给我们带来我们想要的东西。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 803.0,
  "end": 810.74
 },
 {
  "input": "The idea is that instead of simply asking whether we can find a color at some point along the loop, let's keep more careful track of how these colors change as we walk around that loop.",
  "translatedText": "我们的想法是，不要简单地询问我们是否可以在 循环的某个点找到颜色，而是让我们更仔细地跟 踪当我们绕着该循环走动时这些颜色如何变化。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 818.18,
  "end": 827.86
 },
 {
  "input": "Let me show you what I mean with an example.",
  "translatedText": "让我用一个例子来告诉你我的意思。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 828.58,
  "end": 829.96
 },
 {
  "input": "I'll keep a little color wheel up here in the corner to help us keep track.",
  "translatedText": "我会在角落里放一个小色轮来帮助我们跟踪。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 830.4,
  "end": 833.26
 },
 {
  "input": "When the colors along a path of inputs move through the rainbow in a specific direction, from red to yellow, yellow to green, green to blue, or blue to red, the output is swinging clockwise.",
  "translatedText": "当沿着输入路径的颜色以特定方向穿过彩 虹时，从红色到黄色、黄色到绿色、绿色 到蓝色或蓝色到红色，输出顺时针摆动。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 833.94,
  "end": 844.96
 },
 {
  "input": "But on the other hand, if the colors move the other way through the rainbow, from blue to green, green to yellow, yellow to red, or red to blue, the output is swinging counterclockwise.",
  "translatedText": "但另一方面，如果颜色在彩虹中以相反的方式移动，从蓝色到绿色 、绿色到黄色、黄色到红色或红色到蓝色，则输出会逆时针摆动。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 845.7,
  "end": 856.32
 },
 {
  "input": "So walking along this short path here, the colors wind a fifth of the way clockwise through the color wheel, and walking along this path here, the colors wind another fifth of the way clockwise through the color wheel.",
  "translatedText": "因此，沿着这里的这条短路径行走，颜色会在色轮中顺 时针缠绕五分之一的路径，沿着这里的这条路径行走 ，颜色会在色轮中顺时针缠绕另外五分之一的路径。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 857.16,
  "end": 870.36
 },
 {
  "input": "Of course, that means that if you go through both paths, one after the other, the colors wind a total of two-fifths of a full turn clockwise.",
  "translatedText": "当然，这意味着如果您一条接一条地穿过两条路 径，颜色总共会顺时针旋转五分之二一整圈。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 871.16,
  "end": 878.64
 },
 {
  "input": "The total amount of winding just adds up, and this is going to be key, this is the kind of straightforward combining that will be useful to us.",
  "translatedText": "缠绕的总量只是加起来，这将是关键 ，这是一种对我们有用的简单组合。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 879.28,
  "end": 886.3
 },
 {
  "input": "When I say total amount of winding, I want you to imagine an old fashioned odometer that ticks forward as the arrow spins clockwise, but backwards as the arrow spins counterclockwise.",
  "translatedText": "当我说总缠绕量时，我希望你想象一个老式的里程表，当箭头顺时 针旋转时，它向前滴答，但当箭头逆时针旋转时，它向后滴答。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 886.98,
  "end": 897.9
 },
 {
  "input": "So counterclockwise winding counts as negative clockwise winding.",
  "translatedText": "所以逆时针缠绕算作负顺时针缠绕。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 898.74,
  "end": 902.46
 },
 {
  "input": "The outputs may turn a lot, but if some of that turning is in the opposite direction, it cancels out.",
  "translatedText": "输出可能会转动很多，但如果其中 一些转动方向相反，则会抵消。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 903.0,
  "end": 908.26
 },
 {
  "input": "For example, if you move forward along this path, and then move backwards along that same path, the total amount of winding ends up being zero, the backwards movement literally rewinds through the previously seen colors, reversing all the previous winding, and returning the odometer back to where it started.",
  "translatedText": "例如，如果您沿着这条路径向前移动，然后沿 着同一条路径向后移动，则缠绕总量最终为零 ，向后移动实际上会倒回之前看到的颜色，反 转所有先前的缠绕，并返回里程表回到起点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 908.92,
  "end": 925.08
 },
 {
  "input": "For our purposes, we'll care most about looking at the winding along loops.",
  "translatedText": "出于我们的目的，我们最关心的是观察沿环的缠绕情况。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 926.28,
  "end": 929.9
 },
 {
  "input": "For example, let's say we walk around this entire loop clockwise.",
  "translatedText": "例如，假设我们顺时针绕着整个循环走。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 930.44,
  "end": 933.68
 },
 {
  "input": "The outputs we come across wind around a total of three full clockwise turns, the colors swung through the rainbow, in order, from red to red again, and then again, and again.",
  "translatedText": "我们遇到的输出总共绕了三个完整的顺时针方向，颜色按顺 序在彩虹中摆动，从红色再次变为红色，然后再次，再次。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 934.24,
  "end": 946.18
 },
 {
  "input": "In the jargon mathematicians use, we say that along this loop, the total winding number is 3.",
  "translatedText": "用数学家的行话来说，我们说沿着 这个循环，总的缠绕数是 3。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 946.92,
  "end": 952.72
 },
 {
  "input": "For other loops, it could be any other whole number, maybe a larger one if the output swings around many times as the input walks around a single loop, or it could be a smaller number if the output only swings around once or twice.",
  "translatedText": "对于其他循环，它可以是任何其他整数，如果输出在输入围 绕单个循环运行时多次摆动，则可能是一个较大的数字，或 者如果输出仅摆动一次或两次，则它可能是较小的数字。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 953.82,
  "end": 965.98
 },
 {
  "input": "Or that winding number could even be a negative integer, if the output was swinging counterclockwise as we walk clockwise around the loop.",
  "translatedText": "或者，如果当我们沿环路顺时针行走时输出 逆时针摆动，则该绕数甚至可能是负整数。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 966.32,
  "end": 974.32
 },
 {
  "input": "But along any loop, this total amount of winding has to be a whole number.",
  "translatedText": "但沿着任何环路，缠绕总数必须是整数。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 975.18,
  "end": 978.86
 },
 {
  "input": "I mean, by the time you get back to where you started, you'll have the same output that you started with.",
  "translatedText": "我的意思是，当你回到开始的地方时 ，你将得到与开始时相同的输出。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 980.88,
  "end": 985.0
 },
 {
  "input": "Incidentally, if a path actually contains a point where the output is precisely zero, then technically you can't define a winding number along that, since the output has no particular direction.",
  "translatedText": "顺便说一句，如果一条路径实际上包含一个输 出恰好为零的点，那么从技术上讲，您无法沿 着该点定义缠绕数，因为输出没有特定方向。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 986.18,
  "end": 996.66
 },
 {
  "input": "This isn't going to be a problem for us, because our whole goal is to find zeros, so if this ever comes up, we just lucked out early.",
  "translatedText": "这对我们来说不会成为问题，因为我们的整个目标是找 到零，所以如果出现这种情况，我们只是运气好而已。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 997.4,
  "end": 1004.04
 },
 {
  "input": "The main thing to notice about these winding numbers is that they add up nicely when you combine paths into bigger paths.",
  "translatedText": "关于这些蜿蜒的数字，需要注意的主要一点是，当您 将路径组合成更大的路径时，它们会很好地相加。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1004.98,
  "end": 1010.68
 },
 {
  "input": "But what we really want is for the winding numbers along the borders of regions to add up nicely when we combine regions to make bigger regions.",
  "translatedText": "但我们真正想要的是，当我们将区域组合成更大的区 域时，沿着区域边界的蜿蜒数字能够很好地相加。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1014.8,
  "end": 1022.44
 },
 {
  "input": "So do we have that property?",
  "translatedText": "那么我们有这个财产吗？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1022.98,
  "end": 1024.52
 },
 {
  "input": "Well, take a look.",
  "translatedText": "好吧，看一下。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1027.76,
  "end": 1029.06
 },
 {
  "input": "The winding number as we go clockwise around this region on the left is the sum of the winding numbers from these four paths.",
  "translatedText": "当我们绕着左边这个区域顺时针旋转时 ，绕行数是这四条路径的绕行数之和。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1029.54,
  "end": 1036.94
 },
 {
  "input": "And the winding as we go clockwise around this region on the right is the sum of the winding numbers from these four paths.",
  "translatedText": "当我们沿着右侧这个区域顺时针旋转时 ，绕线是这四个路径的绕线数之和。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1037.5,
  "end": 1044.36
 },
 {
  "input": "And when we combine those two regions into a bigger one, most of those paths become part of the clockwise border of the bigger region.",
  "translatedText": "当我们将这两个区域合并成一个更大的区域时，大多 数路径都会成为更大区域的顺时针边界的一部分。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1045.34,
  "end": 1052.5
 },
 {
  "input": "And as for those two paths that don't?",
  "translatedText": "至于那两条没有的路呢？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1053.26,
  "end": 1055.16
 },
 {
  "input": "They cancel out perfectly, one of them is just the reverse, the rewinding of the other one like we saw before.",
  "translatedText": "它们完美地抵消了，其中一个正好相反， 另一个就像我们之前看到的那样倒带。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1055.68,
  "end": 1061.76
 },
 {
  "input": "So the winding numbers along borders of regions add up in just the way we want them to.",
  "translatedText": "因此，沿着区域边界的蜿蜒数字按照我们希望的方式加起来。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1062.56,
  "end": 1067.9
 },
 {
  "input": "Also side note, this reasoning about oriented borders adding up nicely like this comes up a lot in mathematics, and it often goes under the name Stokes' theorem.",
  "translatedText": "另请注意，这种关于有向边界很好地相加的推理在 数学中经常出现，并且通常被称为斯托克斯定理。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1068.64,
  "end": 1076.68
 },
 {
  "input": "Those of you who've studied multivariable calculus might recognize it from that context.",
  "translatedText": "研究过多元微积分的人可能会从这种背景下认识到它。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1077.06,
  "end": 1081.02
 },
 {
  "input": "So now, finally, with winding numbers in hand, we can get back to our equation solving goals.",
  "translatedText": "现在，终于，有了绕数，我们就可以回到我们的方程求解目标了。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1082.36,
  "end": 1087.44
 },
 {
  "input": "The problem with the region we saw earlier is that even though its border passed through all possible colors, the winding number was actually zero.",
  "translatedText": "我们之前看到的区域的问题在于，即使它的边界 穿过了所有可能的颜色，但缠绕数实际上为零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1088.0,
  "end": 1095.94
 },
 {
  "input": "The outputs wound around halfway, through yellow to red, and then started going counterclockwise back the other direction, then continued going through blue and hitting red from the other way, all in such a way that the total winding netted out to be zero.",
  "translatedText": "输出缠绕到一半，从黄色到红色，然后开始逆时针返 回另一个方向，然后继续穿过蓝色并从另一个方向到 达红色，所有这些都以这样的方式使总缠绕净为零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1096.5,
  "end": 1110.86
 },
 {
  "input": "But if you find a loop which not only hits every color, but it has the stronger condition of a non-zero winding number, then if you were to split it in half, you're guaranteed that at least one of those halves has a non-zero winding number as well, since things add up nicely in the way we want them to.",
  "translatedText": "但是，如果您发现一个循环不仅命中每种颜色，而且 具有非零缠绕数的更强条件，那么如果您将其分成 两半，则可以保证至少其中一个具有缠绕数也是非 零，因为事情按照我们想要的方式很好地加起来。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1111.84,
  "end": 1128.04
 },
 {
  "input": "So in this way, you can keep going, narrowing in further and further onto one point.",
  "translatedText": "这样，你就可以继续前进，越来越缩小到一个点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1128.44,
  "end": 1133.5
 },
 {
  "input": "And as you narrow in onto a point, you'll be doing so with tiny loops that have non-zero winding numbers, which implies they go through all possible colors, and therefore, like I said before, the point they're narrowing in on must be a zero.",
  "translatedText": "当你缩小到一个点时，你将使用具有非零缠绕数的小循环来 做到这一点，这意味着它们会经历所有可能的颜色，因此， 就像我之前所说的那样，它们缩小的点on 必须为零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1134.05,
  "end": 1146.4
 },
 {
  "input": "And that's it!",
  "translatedText": "就是这样！",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1147.42,
  "end": 1148.36
 },
 {
  "input": "We have now created a two-dimensional equation solver, and this time, I promise, there are no bugs.",
  "translatedText": "我们现在已经创建了一个二维方程求 解器，这一次，我保证，没有错误。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1148.6,
  "end": 1153.86
 },
 {
  "input": "Winding numbers are precisely the tool we need to make this work.",
  "translatedText": "绕数正是我们实现这项工作所需的工具。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1154.56,
  "end": 1157.54
 },
 {
  "input": "We can now solve equations that look like where does f of x equal g of x in two dimensions, just by considering how the difference between f and g winds around.",
  "translatedText": "现在，我们只需考虑 f 和 g 之间的差值如何变化，就可以 解出类似于二维中 x 的 f 等于 x 的 g 的方程。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1158.1,
  "end": 1166.82
 },
 {
  "input": "Whenever we have a loop whose winding number isn't zero, we can run this algorithm on it, and we're guaranteed to find a solution somewhere within it.",
  "translatedText": "每当我们有一个缠绕数不为零的循环时，我们就可以在它上面运行 这个算法，并且我们保证在其中的某个地方找到一个解决方案。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1167.6,
  "end": 1175.1
 },
 {
  "input": "And what's more, just like in one dimension, this algorithm is incredibly efficient.",
  "translatedText": "更重要的是，就像在一维中一样，该算法非常高效。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1175.66,
  "end": 1179.84
 },
 {
  "input": "We keep narrowing in on half the size of our region each round, thus quickly narrowing in on the zeros, and all the while, we only have to check the value of the function along points of these loops, rather than checking it on the many points of the interior.",
  "translatedText": "我们每轮不断缩小区域大小的一半，从而快速缩小零 点，并且一直以来，我们只需要沿着这些循环的点检 查函数的值，而不是在许多点上检查它内部的点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1180.24,
  "end": 1194.4
 },
 {
  "input": "So in some sense, the overall work done is proportional only to the search space's perimeter, not the full area, which is amazing.",
  "translatedText": "因此，从某种意义上说，完成的总体工作仅与搜索空间的周 长成正比，而不是与整个面积成正比，这是令人惊奇的。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1195.16,
  "end": 1203.74
 },
 {
  "input": "Now once you understand what's going on, it's weirdly mesmerizing to just watch this in action, giving it some function and letting it search for zeros.",
  "translatedText": "现在，一旦你了解了发生了什么，仅仅观察它的实际情况，赋予它 一些功能并让它搜索零，就会产生一种奇怪的令人着迷的感觉。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1204.92,
  "end": 1212.96
 },
 {
  "input": "Like I said before, complex numbers are two-dimensional, so let's apply it to some equation with complex numbers.",
  "translatedText": "正如我之前所说，复数是二维的，所以让 我们将其应用到一些具有复数的方程中。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1213.62,
  "end": 1219.56
 },
 {
  "input": "For example, here's the algorithm finding the zeros of the function x to the fifth minus x minus one over the complex plane.",
  "translatedText": "例如，以下算法在复平面上查找函数 x 到第五次减 x 减一的零点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1220.3,
  "end": 1228.1
 },
 {
  "input": "It started by considering a very large region around the origin, which ended up having a winding number of 5.",
  "translatedText": "首先考虑原点周围的一个非常大 的区域，最终缠绕数为 5。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1228.9,
  "end": 1234.48
 },
 {
  "input": "Each time you find a loop with a non-zero winding number, you split it in half, and figure out the winding number of the two smaller loops.",
  "translatedText": "每次找到一个具有非零缠绕数的环路时，您将其 分成两半，并计算出两个较小环路的缠绕数。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1235.28,
  "end": 1242.12
 },
 {
  "input": "Either one or both of them is guaranteed to have a non-zero winding number, and when you see this, you know there's a zero somewhere inside that smaller loop, so you keep going in the same way, searching the smaller space.",
  "translatedText": "它们中的一个或两个都保证具有非零缠绕数，当您 看到这一点时，您知道在较小的循环内某处有一个 零，因此您继续以相同的方式搜索较小的空间。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1242.7,
  "end": 1253.4
 },
 {
  "input": "We also stop exploring a region if the path we're computing along happens to stumble across a zero, which actually happened once for this example on the right half here.",
  "translatedText": "如果我们正在计算的路径碰巧遇到零，我们也会停止探索一 个区域，这种情况在右半部分的示例中实际上发生过一次。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1254.18,
  "end": 1262.9
 },
 {
  "input": "Those rare occurrences interfere with our ability to compute winding numbers, but hey, we got a zero.",
  "translatedText": "这些罕见的情况会干扰我们计算缠绕 数的能力，但是嘿，我们得到了零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1263.28,
  "end": 1268.14
 },
 {
  "input": "And as for loops whose winding number is zero, you just don't explore those further.",
  "translatedText": "至于绕数为零的循环，您只是不进一步探索它们。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1269.22,
  "end": 1272.92
 },
 {
  "input": "Maybe they have a solution inside, maybe they don't, we have no guarantees.",
  "translatedText": "也许他们内部有解决方案，也许他们没有，我们无法保证。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1272.92,
  "end": 1276.2
 },
 {
  "input": "And letting our equation solver continue in this same way, it eventually converges to lots of zeros for this polynomial.",
  "translatedText": "让我们的方程求解器以同样的方式继续下去 ，它最终会收敛到该多项式的许多零点。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1278.4,
  "end": 1284.02
 },
 {
  "input": "By the way, it is no coincidence that the total winding number in this example happened to be 5.",
  "translatedText": "顺便说一句，本例中的总绕组 数恰好为 5 并非巧合。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1285.84,
  "end": 1291.0
 },
 {
  "input": "With complex numbers, the operation x to the n directly corresponds to walking around the output's origin n times as you walk around the input's origin once.",
  "translatedText": "对于复数，x 到 n 的运算直接对应于绕输出原 点绕行 n 次，就像绕输入原点绕行一次一样。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1291.58,
  "end": 1302.24
 },
 {
  "input": "So with the polynomial, for large enough inputs, every term other than the leading term becomes insignificant in comparison.",
  "translatedText": "因此，对于多项式，对于足够大的输入，相比之 下，除了首项之外的每一项都变得微不足道。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1304.68,
  "end": 1311.98
 },
 {
  "input": "So any complex polynomial whose leading term is x to the n has a winding number of n around a large enough loop.",
  "translatedText": "因此，任何首项为 x 到 n 的复多项 式都具有围绕足够大的循环的绕数 n。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1312.48,
  "end": 1319.78
 },
 {
  "input": "And in that way, our winding number technology actually guarantees that every complex polynomial has a zero.",
  "translatedText": "这样，我们的绕数技术实际上保证 了每个复数多项式都有一个零。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1320.54,
  "end": 1326.82
 },
 {
  "input": "This is such an important fact that mathematicians call it the fundamental theorem of algebra.",
  "translatedText": "这是一个非常重要的事实，数学家将其称为代数基本定理。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1327.48,
  "end": 1332.0
 },
 {
  "input": "Having an algorithm for finding numerical solutions to equations like this is extremely practical, but the fundamental theorem of algebra is a good example of how these winding numbers are also quite useful on a theoretical level, guaranteeing the existence of a solution to a broad class of equations for suitable conditions, which is much more the kind of thing mathematicians like thinking about.",
  "translatedText": "拥有一个算法来找到这样的方程的数值解是非 常实用的，但代数的基本定理是一个很好的例 子，说明这些绕数在理论层面上也非常有用 ，保证了广泛的一类方程的解的存在。 适合条 件的方程，这更是数学家喜欢思考的事情。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1333.8,
  "end": 1353.94
 },
 {
  "input": "I'll show you a couple more amazing applications of this in the context of topology in a follow-up video, which includes correcting a mistake from an old 3blue1brown video.",
  "translatedText": "我将在后续视频中向您展示拓扑上下文中的一些更令人惊奇的应用 ，其中包括纠正旧 3blue1brown 视频中的错误。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1353.94,
  "end": 1363.44
 },
 {
  "input": "Which one?",
  "translatedText": "哪一个？",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1364.06,
  "end": 1364.44
 },
 {
  "input": "Well, watch all of the videos, everything on this channel, and see if you can spot the error first.",
  "translatedText": "好吧，观看该频道上的所有视频和所有 内容，看看您是否能首先发现错误。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1364.94,
  "end": 1369.6
 },
 {
  "input": "The primary author of this video is one of the newest 3blue1brown team members, Sridhar Ramesh.",
  "translatedText": "该视频的主要作者是 3blue1brown 团队 的最新成员之一 Sridhar Ramesh。",
  "model": "google_nmt",
  "n_reviews": 0,
  "start": 1371.3,
  "end": 1390.06
 }
]