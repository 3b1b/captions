1
00:00:03,060 --> 00:00:06,140
这里有两件事，主要主题和元主题。

2
00:00:06,640 --> 00:00:11,375
主要主题将是这个非常简洁的算法，用于 求解二维方程，

3
00:00:11,375 --> 00:00:16,840
具有两个未知实数的事物 ，或者涉及单个未知数（复数）的事物。

4
00:00:17,440 --> 00:00:20,401
例如，如果您想找到多项式的复数根，

5
00:00:20,401 --> 00:00:24,583
 或者黎曼 zeta 函数的一些百万 美元零点，

6
00:00:24,583 --> 00:00:26,500
这个算法可以为您做到。

7
00:00:26,800 --> 00:00:30,060
而且这个方法超级漂亮，因为涉及到很多颜色。

8
00:00:30,540 --> 00:00:34,567
更重要的是，核心的基本思想适用于各 种数学，

9
00:00:34,567 --> 00:00:40,060
远远超出了求解方程的算法， 包括一些拓扑学，我将在后面讨论。

10
00:00:40,740 --> 00:00:45,312
但真正让您花费 20 分钟左右的时间的 原因是，

11
00:00:45,312 --> 00:00:49,122
它说明了在整个数学中更普遍有用 的课程，

12
00:00:49,122 --> 00:00:51,980
即尝试定义彼此完美组合的结构。

13
00:00:52,400 --> 00:00:54,480
随着故事的进展，你会明白我的意思。

14
00:00:55,060 --> 00:00:59,670
为了用具有 2d 输入和 2d 输出的函数来激发这个案例 ，

15
00:00:59,670 --> 00:01:03,820
让我们从更简单的开始，使用只接受实数并输出实数的函数。

16
00:01:05,080 --> 00:01:10,229
如果您想知道 x 的函数 f 何时等于 x 的其他函数 g，

17
00:01:10,229 --> 00:01:14,520
您可能会认为这是搜索这些函数的图形何时相交，对吧？

18
00:01:15,020 --> 00:01:18,520
我的意思是，这为您提供了两个函数具有相同输出的输入。

19
00:01:18,520 --> 00:01:23,039
举一个非常简单的例子，假设 x 的 f 是 x 的平方，

20
00:01:23,039 --> 00:01:25,300
x 的 g 是常数函数 2。

21
00:01:25,960 --> 00:01:28,640
换句话说，您想要找到 2 的平方根。

22
00:01:29,460 --> 00:01:33,534
即使您对求平方根几乎一无所知，您也可能会看到 

23
00:01:33,534 --> 00:01:37,431
1 的平方小于 2，而 2 的平方大于 2，

24
00:01:37,431 --> 00:01:41,860
所 以您意识到，啊，这两个值之间会有一些解决方案。

25
00:01:42,580 --> 00:01:45,537
然后，如果您想进一步缩小范围，也许您可以尝试对 

26
00:01:45,537 --> 00:01:47,140
中间点 1 进行平方。5.

27
00:01:47,720 --> 00:01:51,474
结果是 2。25，有点太高了，所以您应该关注 

28
00:01:51,474 --> 00:01:53,760
1 和 1 之间的区域。5.

29
00:01:54,760 --> 00:01:57,497
依此类推，您可能会看到这将如何继续下去，

30
00:01:57,497 --> 00:02:00,920
您将 继续在中点进行计算，然后将搜索空间切成两半。

31
00:02:05,100 --> 00:02:09,565
思考这个问题的另一种方法是，当我们达到更高 的维度时，

32
00:02:09,565 --> 00:02:12,212
这将使我们更容易理解，即专注于 

33
00:02:12,212 --> 00:02:15,520
这两个函数之间的差异何时为零的等效问题。

34
00:02:16,100 --> 00:02:19,927
就这些而言，我们发现了一个输入区域，

35
00:02:19,927 --> 00:02:24,180
其 中一端的差异为负，另一端的差异为正。

36
00:02:24,180 --> 00:02:28,055
我们把它分成两半，我们将注意力集中 

37
00:02:28,055 --> 00:02:31,500
到最外面的点有不同符号的那一半。

38
00:02:31,500 --> 00:02:35,909
像这样，我们能够永远继续前进，选取边界上具有不同 

39
00:02:35,909 --> 00:02:40,672
标志的每个区域，在其两半中找到一个更小的这样的 区域，

40
00:02:40,672 --> 00:02:44,200
知道最终我们必须缩小到一个恰好为零的点。

41
00:02:45,760 --> 00:02:50,992
简而言之，求解方程总是可以被框架为找到某个函数何时等 于零，

42
00:02:50,992 --> 00:02:55,353
为此，我们有这样的启发式，如果 f 在一点为 正，

43
00:02:55,353 --> 00:03:00,062
在另一点为负，您可以找到中间的某个位置，其中它 为零，

44
00:03:00,062 --> 00:03:03,900
至少如果一切都顺利变化而没有突然的跳跃的话。

45
00:03:03,900 --> 00:03:06,973
我想向您展示的令人惊奇的事情是，

46
00:03:06,973 --> 00:03:10,238
您 可以将这种思维扩展到二维方程，

47
00:03:10,238 --> 00:03:14,080
即输 入和输出都是二维的函数之间的方程。

48
00:03:14,739 --> 00:03:18,165
例如，复数是二维的，我们正在开发的 

49
00:03:18,165 --> 00:03:21,400
这个工具非常适合寻找复杂方程的解。

50
00:03:22,360 --> 00:03:25,214
现在，既然我们要详细讨论这些 2D 函数，

51
00:03:25,214 --> 00:03:28,340
那 么让我们先简单地考虑一下如何说明这些函数。

52
00:03:29,060 --> 00:03:33,794
用 2D 输入和 2D 输出绘制一个函数需要 四个维度，

53
00:03:33,794 --> 00:03:37,852
这在 2D 屏幕上的 3D 世界 中效果不太好，

54
00:03:37,852 --> 00:03:40,220
但我们仍然有一些不错的选择。

55
00:03:40,859 --> 00:03:45,440
一种是并排查看输入空间和输出空间。

56
00:03:45,540 --> 00:03:50,217
输入空间中的每个点都会移动到输出空间中的特定点，

57
00:03:50,217 --> 00:03:55,480
我可以 展示围绕该输入点的移动如何对应于输出空间中的某

58
00:03:55,480 --> 00:03:56,260
些移动。

59
00:03:56,940 --> 00:04:01,273
我们考虑的所有函数都将是连续的，从某 种意义上说，

60
00:04:01,273 --> 00:04:06,300
输入的微小变化仅对应于 输出的微小变化，不存在突然的跳跃。

61
00:04:06,940 --> 00:04:13,017
我们的另一个选择是想象从输出空间的原点到该输出 点的箭头，

62
00:04:13,017 --> 00:04:16,579
并将该箭头的微型版本附加到输入点。

63
00:04:17,360 --> 00:04:21,167
这可以让我们一目了然地了解给定输入点的去向，

64
00:04:21,167 --> 00:04:25,840
或者 通过绘制完整的矢量场来了解许多不同输入点的去向。

65
00:04:27,600 --> 00:04:29,907
不幸的是，当你在很多点上这样做时，

66
00:04:29,907 --> 00:04:33,028
它可能会变得 非常混乱，所以在这里让我将所有箭

67
00:04:33,028 --> 00:04:37,100
头设置为相同的 大小，这意味着我们可以了解每个输出点的方向。

68
00:04:37,780 --> 00:04:40,487
但也许说明二维函数的最漂亮的方法，

69
00:04:40,487 --> 00:04:43,194
也是我们在本视频中最 常用的方法，

70
00:04:43,194 --> 00:04:46,380
是将输出空间中的每个点与一种颜色相关联。

71
00:04:47,220 --> 00:04:51,364
在这里，我们使用色调（即颜色沿着彩虹或色 

72
00:04:51,364 --> 00:04:54,917
轮下降的位置）来对应远离原点的方向，

73
00:04:54,917 --> 00:04:59,260
并且 我们使用暗度或亮度来对应距原点的距离。

74
00:04:59,260 --> 00:05:04,224
例如，关注这个输出数组，所有这些点都是红色的，

75
00:05:04,224 --> 00:05:09,620
但 是靠近原点的点更暗一些，远离原点的点更亮一些。

76
00:05:10,360 --> 00:05:13,891
关注这个输出数组，所有的点都是绿色的，

77
00:05:13,891 --> 00:05:17,980
同 样，靠近原点意味着更暗，更远意味着更亮。

78
00:05:18,780 --> 00:05:23,173
依此类推，我们在这里所做的就是为每个方向 分配特定的颜色，

79
00:05:23,173 --> 00:05:24,840
所有颜色都在不断变化。

80
00:05:25,359 --> 00:05:28,946
您可能会注意到这里的黑暗和亮度差异非常 微妙，

81
00:05:28,946 --> 00:05:33,624
但对于这个视频，我们关心的是输出 的方向，而不是幅度、色调，

82
00:05:33,624 --> 00:05:34,560
而不是亮度。

83
00:05:35,300 --> 00:05:38,700
关于亮度，您需要注意的一件重要的事情是，

84
00:05:38,700 --> 00:05:43,120
在没有 特定方向的原点附近，所有颜色都会褪色为黑色。

85
00:05:44,440 --> 00:05:49,577
因此，在考虑函数时，现在我们已经决定了每个输出 的颜色，

86
00:05:49,577 --> 00:05:53,063
我们可以通过根据输出空间中点的颜色为 

87
00:05:53,063 --> 00:05:57,100
输入空间中的每个点着色来可视化 2D 函数。

88
00:05:57,840 --> 00:06:02,137
我喜欢想象输入空间中的许多不同点跳跃到输出空 

89
00:06:02,137 --> 00:06:06,996
间中相应的输出，然后根据它们着陆点的颜色进行 绘制，

90
00:06:06,996 --> 00:06:10,360
然后跳回它们在输入空间中的来源位置。

91
00:06:11,640 --> 00:06:14,058
对输入空间中的每个点执行此操作，

92
00:06:14,058 --> 00:06:18,140
只需查看该 输入空间即可大致了解函数获取每个点的位置。

93
00:06:18,140 --> 00:06:23,317
例如，左侧的粉红色点条纹告诉我们所有这些点都映 

94
00:06:23,317 --> 00:06:28,280
射到粉红色方向的某个位置，即输出空间的左下角。

95
00:06:29,780 --> 00:06:34,900
另外，那些周围有很多颜色 的黑色点也是归零的点。

96
00:06:39,340 --> 00:06:44,216
好吧，就像一维情况一样，二维函数的求解方程总 

97
00:06:44,216 --> 00:06:48,880
是可以通过询问某个函数何时等于零来重新构建。

98
00:06:49,580 --> 00:06:55,378
所以这就是我们现在的挑战，创建一个算法来 

99
00:06:55,378 --> 00:07:00,900
查找给定 2D 函数的哪些输入点变为零。

100
00:07:00,900 --> 00:07:05,777
您可能会指出，如果您通过看到这些黑点来查看这 样的彩色图，

101
00:07:05,777 --> 00:07:08,300
您就已经知道函数的零点在哪里。

102
00:07:08,620 --> 00:07:11,080
那么这算吗？

103
00:07:11,080 --> 00:07:15,465
请记住，要创建这样的图表，我们已经让计算机在 

104
00:07:15,465 --> 00:07:19,660
平面上的所有像素上计算函数，但我们的目标是 

105
00:07:19,660 --> 00:07:24,999
找到一种更有效的算法，只需要在尽可能少的点 上计算函数，

106
00:07:24,999 --> 00:07:27,860
可以这么说，对颜色的了解有限。

107
00:07:29,360 --> 00:07:34,451
而且从更理论的角度来看，最好有一个通用的构 

108
00:07:34,451 --> 00:07:39,080
造来告诉我们给定区域内是否存在零的条件。

109
00:07:39,080 --> 00:07:41,812
请记住，在一个维度上，主要见解是，

110
00:07:41,812 --> 00:07:45,187
如果连续函数在某一点 为正，在另一点为负，

111
00:07:45,187 --> 00:07:47,920
则介于两者之间的某个位置必须为零。

112
00:07:48,840 --> 00:07:50,580
那么我们如何将其扩展到二维呢？

113
00:07:50,940 --> 00:07:53,580
我们需要某种类似谈论符号的方式。

114
00:07:54,700 --> 00:07:58,140
思考标志是什么的一种方法是方向。

115
00:07:58,800 --> 00:08:03,500
正数表示您沿着数轴指向右侧， 负数表示您沿着数轴指向左侧。

116
00:08:04,200 --> 00:08:08,591
二维量也有方向，但对它们来说，选择范围要广泛 得多，

117
00:08:08,591 --> 00:08:11,800
它们可以指向整个可能性圈中的任何地方。

118
00:08:12,530 --> 00:08:17,274
因此，就像在一维中我们询问给定函数在范围边 

119
00:08:17,274 --> 00:08:23,096
界（只有两个点）上是正值还是负值一样，对 于二维函数，

120
00:08:23,096 --> 00:08:27,625
我们将查看一个区域的边界，即是 一个循环，

121
00:08:27,625 --> 00:08:30,860
并询问函数输出沿该边界的方向。

122
00:08:33,640 --> 00:08:36,708
例如，我们看到沿着围绕这个零的循环，

123
00:08:36,708 --> 00:08:40,287
输出经过 每个可能的方向，彩虹的所有颜色，

124
00:08:40,287 --> 00:08:45,060
红色，黄色， 绿色，蓝色，回到红色，以及沿途的所有颜色。

125
00:08:45,700 --> 00:08:50,423
但是沿着这里的循环，内部没有零，输出不会经历每种颜色 ，

126
00:08:50,423 --> 00:08:54,640
它会经历一些橙色的颜色，但永远不会经历绿色或蓝色。

127
00:08:55,300 --> 00:08:58,460
这是有希望的，它看起来很像在一维中的运作方式。

128
00:08:59,340 --> 00:09:04,563
也许以同样的方式，如果 1d 函数在 1d 区域的边界 

129
00:09:04,563 --> 00:09:09,413
上取两个可能的符号，内部某处有一个零，我们可以假设，

130
00:09:09,413 --> 00:09:14,636
如 果 2d 函数命中所有可能方向、所有可能颜色的输出，

131
00:09:14,636 --> 00:09:19,860
沿 着二维区域的边界，那么该区域内的某个位置它必须为零。

132
00:09:20,960 --> 00:09:24,450
这就是我们的猜测，请花点时间思考这 是否属实，

133
00:09:24,450 --> 00:09:26,120
如果属实，原因是什么。

134
00:09:27,420 --> 00:09:30,324
如果我们开始考虑围绕某个输入点的小循环，

135
00:09:30,324 --> 00:09:32,939
我们就会知道，由于一 切都是连续的，

136
00:09:32,939 --> 00:09:36,280
我们的函数会将其带到相应输出附近的某个小循环。

137
00:09:37,140 --> 00:09:40,520
但请注意，对于大多数微小循环，输出的颜色各不相同。

138
00:09:40,980 --> 00:09:45,282
如果您选择零以外的任何输出点，并在其附近绘制一个足 

139
00:09:45,282 --> 00:09:49,420
够紧密的循环，则循环的颜色将与该点的颜色大致相同。

140
00:09:49,840 --> 00:09:54,811
这里的紧密环都是蓝色的，这里的紧密环都是 淡黄色的，

141
00:09:54,811 --> 00:09:57,680
你当然不会得到彩虹的每种颜色。

142
00:09:58,220 --> 00:10:02,495
唯一可以收紧它周围的循环同时仍然获得 

143
00:10:02,495 --> 00:10:06,320
所有颜色的点是无色原点，即零本身。

144
00:10:07,100 --> 00:10:11,827
因此，情况确实如此，如果你有循环穿 过彩虹的每种颜色，

145
00:10:11,827 --> 00:10:16,380
收紧再收紧，缩小 到一个点，那么该点实际上一定是零。

146
00:10:17,320 --> 00:10:19,796
因此，让我们设置一个二维方程求解器，

147
00:10:19,796 --> 00:10:21,860
就像我们的一维方程求解器一样。

148
00:10:22,260 --> 00:10:25,991
当我们找到一个边界穿过每种颜色的大区域时，

149
00:10:25,991 --> 00:10:29,900
 将其分成两半，然后查看每一半边界上的颜色。

150
00:10:30,540 --> 00:10:35,529
在此显示的示例中，左半部分的边框并未穿过所 有颜色，

151
00:10:35,529 --> 00:10:38,600
例如，没有映射到橙黄色方向的点。

152
00:10:39,060 --> 00:10:42,620
因此，我会将这个区域灰显，以表示我们不想再进一步搜索它。

153
00:10:43,380 --> 00:10:48,038
右半部分确实经历了所有颜色，在绿色方向上花了 很多时间，

154
00:10:48,038 --> 00:10:50,700
然后经历了黄橙红，以及蓝紫粉色。

155
00:10:51,560 --> 00:10:57,360
现在请记住，这意味着该边界的点 被映射到所有可能方向的输出。

156
00:10:57,840 --> 00:11:01,860
因此，我们将进一步探索它，再次细分并检查每个区域的边界。

157
00:11:02,880 --> 00:11:06,560
顶部的边界全是绿色的，所以我们在那里停止搜索。

158
00:11:06,860 --> 00:11:09,520
但底部的色彩足以值得细分。

159
00:11:10,340 --> 00:11:12,020
就这样继续下去。

160
00:11:12,360 --> 00:11:16,367
检查哪个子区域具有覆盖所有可能颜色的边界 ，

161
00:11:16,367 --> 00:11:20,375
这意味着该边界的点被映射到所有可能的方 向，

162
00:11:20,375 --> 00:11:24,383
并像我们对一维情况一样将这些区域切成 两半，

163
00:11:24,383 --> 00:11:27,480
最终导致我们的函数为零哦，等一下。

164
00:11:28,880 --> 00:11:29,920
这里发生了什么？

165
00:11:30,380 --> 00:11:33,957
右下角的最后一个细分都没有遍历所有颜 色，

166
00:11:33,957 --> 00:11:38,386
因此我们的算法停止了，因为它不想 搜索其中任何一个，

167
00:11:38,386 --> 00:11:39,920
但它也没有找到零。

168
00:11:41,060 --> 00:11:43,300
好吧，显然这里出了问题。

169
00:11:43,540 --> 00:11:46,520
没关系，犯错是做数学的正常现象。

170
00:11:46,520 --> 00:11:48,960
如果我们回顾过去，我们有这个假设，

171
00:11:48,960 --> 00:11:52,980
它导致我们 提出了这个算法，所以我们在某个地方犯了错误。

172
00:11:53,660 --> 00:11:56,491
擅长数学并不在于第一次就正确， 

173
00:11:56,491 --> 00:12:01,800
而是在于具有仔细回顾并理解错误 的能力，并了解如何纠正它们。

174
00:12:02,480 --> 00:12:06,043
现在的问题是，我们有一个区域，其边界穿过每种颜色，

175
00:12:06,043 --> 00:12:10,035
但是当 我们将其从中间分割时，两个子区域的边界都没有穿过

176
00:12:10,035 --> 00:12:13,314
每种颜色 ，我们无法选择下一步在哪里继续搜索，

177
00:12:13,314 --> 00:12:14,740
这就打破了零发现者。

178
00:12:14,740 --> 00:12:17,560
现在在一个维度中，这种事情从来没有发生过。

179
00:12:17,980 --> 00:12:23,318
每当您有一个端点具有不同符号的区间 时，如果将其拆分，

180
00:12:23,318 --> 00:12:28,460
您就知道一定会得 到一些端点也具有不同符号的子区间。

181
00:12:29,020 --> 00:12:33,232
或者换句话说，任何时候你有两个端点不改变 符号的区间，

182
00:12:33,232 --> 00:12:36,819
如果将它们组合起来，你将得 到一个更大的区间，

183
00:12:36,819 --> 00:12:38,380
其端点也不改变符号。

184
00:12:39,080 --> 00:12:44,090
但在二维中，可以找到两个区域，其边界 不穿过每种颜色，

185
00:12:44,090 --> 00:12:49,100
但其边界组合起来给 出一个边界确实穿过每种颜色的区域。

186
00:12:49,840 --> 00:12:53,500
就这样，我们提出的找零算法失效了。

187
00:12:54,380 --> 00:12:58,659
事实上，如果你仔细想想，你会发现一个大循环 ，

188
00:12:58,659 --> 00:13:02,380
其边界穿过所有可能的颜色，而内部没有零。

189
00:13:03,080 --> 00:13:07,352
现在，这并不是说我们关于微小循环的说法是错误的，

190
00:13:07,352 --> 00:13:12,160
当 我们说穿过每种颜色的永远缩小的循环必须缩小到零时。

191
00:13:12,800 --> 00:13:16,259
但让我们变得一团糟的是，当您组合区域时，

192
00:13:16,259 --> 00:13:20,929
“我的边框是否 穿过每种颜色”属性并不能以良好的、可预

193
00:13:20,929 --> 00:13:22,140
测的方式组合。

194
00:13:23,000 --> 00:13:27,089
但别担心，事实证明我们可以将其稍微修改为更复杂的属性 ，

195
00:13:27,089 --> 00:13:30,740
这些属性结合起来确实可以给我们带来我们想要的东西。

196
00:13:38,180 --> 00:13:41,456
我们的想法是，不要简单地询问我们是否可以在 

197
00:13:41,456 --> 00:13:44,732
循环的某个点找到颜色，而是让我们更仔细地跟 

198
00:13:44,732 --> 00:13:47,860
踪当我们绕着该循环走动时这些颜色如何变化。

199
00:13:48,580 --> 00:13:49,960
让我用一个例子来告诉你我的意思。

200
00:13:50,400 --> 00:13:53,260
我会在角落里放一个小色轮来帮助我们跟踪。

201
00:13:53,940 --> 00:13:58,269
当沿着输入路径的颜色以特定方向穿过彩 虹时，

202
00:13:58,269 --> 00:14:03,385
从红色到黄色、黄色到绿色、绿色 到蓝色或蓝色到红色，

203
00:14:03,385 --> 00:14:04,960
输出顺时针摆动。

204
00:14:05,700 --> 00:14:09,839
但另一方面，如果颜色在彩虹中以相反的方式移动，

205
00:14:09,839 --> 00:14:14,520
从蓝色到绿色 、绿色到黄色、黄色到红色或红色到蓝色，

206
00:14:14,520 --> 00:14:16,320
则输出会逆时针摆动。

207
00:14:17,160 --> 00:14:20,302
因此，沿着这里的这条短路径行走，

208
00:14:20,302 --> 00:14:24,426
颜色会在色轮中顺 时针缠绕五分之一的路径，

209
00:14:24,426 --> 00:14:29,139
沿着这里的这条路径行走 ，颜色会在色轮中顺时针缠

210
00:14:29,139 --> 00:14:31,300
绕另外五分之一的路径。

211
00:14:31,300 --> 00:14:35,494
当然，这意味着如果您一条接一条地穿过两条路 径，

212
00:14:35,494 --> 00:14:38,640
颜色总共会顺时针旋转五分之二一整圈。

213
00:14:39,280 --> 00:14:43,545
缠绕的总量只是加起来，这将是关键 ，

214
00:14:43,545 --> 00:14:47,100
这是一种对我们有用的简单组合。

215
00:14:47,100 --> 00:14:51,568
当我说总缠绕量时，我希望你想象一个老式的里程表，

216
00:14:51,568 --> 00:14:56,782
当箭头顺时 针旋转时，它向前滴答，但当箭头逆时针旋转时，

217
00:14:56,782 --> 00:14:57,900
它向后滴答。

218
00:14:58,740 --> 00:15:02,460
所以逆时针缠绕算作负顺时针缠绕。

219
00:15:03,000 --> 00:15:08,260
输出可能会转动很多，但如果其中 一些转动方向相反，则会抵消。

220
00:15:08,920 --> 00:15:12,229
例如，如果您沿着这条路径向前移动，

221
00:15:12,229 --> 00:15:17,292
然后沿 着同一条路径向后移动，则缠绕总量最终为零 ，

222
00:15:17,292 --> 00:15:22,938
向后移动实际上会倒回之前看到的颜色，反 转所有先前的缠绕，

223
00:15:22,938 --> 00:15:25,080
并返回里程表回到起点。

224
00:15:26,280 --> 00:15:29,900
出于我们的目的，我们最关心的是观察沿环的缠绕情况。

225
00:15:30,440 --> 00:15:34,780
例如，假设我们顺时针绕着整个循环走。

226
00:15:34,780 --> 00:15:39,512
我们遇到的输出总共绕了三个完整的顺时针方向，

227
00:15:39,512 --> 00:15:45,534
颜色按顺 序在彩虹中摆动，从红色再次变为红色，然后再次，

228
00:15:45,534 --> 00:15:46,180
再次。

229
00:15:46,920 --> 00:15:54,020
用数学家的行话来说，我们说沿着 这个循环，总的缠绕数是 3。

230
00:15:54,020 --> 00:15:56,745
对于其他循环，它可以是任何其他整数，

231
00:15:56,745 --> 00:16:00,075
如果输出在输入围 绕单个循环运行时多次摆动，

232
00:16:00,075 --> 00:16:04,314
则可能是一个较大的数字，或 者如果输出仅摆动一次或两次，

233
00:16:04,314 --> 00:16:05,980
则它可能是较小的数字。

234
00:16:06,320 --> 00:16:11,653
或者，如果当我们沿环路顺时针行走时输出 逆时针摆动，

235
00:16:11,653 --> 00:16:14,320
则该绕数甚至可能是负整数。

236
00:16:15,180 --> 00:16:18,860
但沿着任何环路，缠绕总数必须是整数。

237
00:16:20,880 --> 00:16:23,197
我的意思是，当你回到开始的地方时 ，

238
00:16:23,197 --> 00:16:25,000
你将得到与开始时相同的输出。

239
00:16:26,180 --> 00:16:31,493
顺便说一句，如果一条路径实际上包含一个输 出恰好为零的点，

240
00:16:31,493 --> 00:16:35,524
那么从技术上讲，您无法沿 着该点定义缠绕数，

241
00:16:35,524 --> 00:16:37,540
因为输出没有特定方向。

242
00:16:37,540 --> 00:16:41,894
这对我们来说不会成为问题，因为我们的整个目标是找 到零，

243
00:16:41,894 --> 00:16:45,160
所以如果出现这种情况，我们只是运气好而已。

244
00:16:45,160 --> 00:16:47,679
关于这些蜿蜒的数字，需要注意的主要一点是，

245
00:16:47,679 --> 00:16:50,680
当您 将路径组合成更大的路径时，它们会很好地相加。

246
00:16:54,800 --> 00:16:59,284
但我们真正想要的是，当我们将区域组合成更大的区 域时，

247
00:16:59,284 --> 00:17:02,440
沿着区域边界的蜿蜒数字能够很好地相加。

248
00:17:02,980 --> 00:17:04,520
那么我们有这个财产吗？

249
00:17:07,760 --> 00:17:09,060
好吧，看一下。

250
00:17:09,540 --> 00:17:13,557
当我们绕着左边这个区域顺时针旋转时 ，

251
00:17:13,557 --> 00:17:16,940
绕行数是这四条路径的绕行数之和。

252
00:17:17,500 --> 00:17:21,333
当我们沿着右侧这个区域顺时针旋转时 ，

253
00:17:21,333 --> 00:17:24,359
绕线是这四个路径的绕线数之和。

254
00:17:25,339 --> 00:17:28,608
当我们将这两个区域合并成一个更大的区域时，

255
00:17:28,608 --> 00:17:32,500
大多 数路径都会成为更大区域的顺时针边界的一部分。

256
00:17:33,260 --> 00:17:35,800
至于那两条没有的路呢？

257
00:17:36,020 --> 00:17:38,889
它们完美地抵消了，其中一个正好相反，

258
00:17:38,889 --> 00:17:41,760
 另一个就像我们之前看到的那样倒带。

259
00:17:42,560 --> 00:17:47,900
因此，沿着区域边界的蜿蜒数字按照我们希望的方式加起来。

260
00:17:48,640 --> 00:17:52,749
另请注意，这种关于有向边界很好地相加的推理在 

261
00:17:52,749 --> 00:17:56,680
数学中经常出现，并且通常被称为斯托克斯定理。

262
00:17:57,060 --> 00:18:01,020
研究过多元微积分的人可能会从这种背景下认识到它。

263
00:18:02,360 --> 00:18:07,440
现在，终于，有了绕数，我们就可以回到我们的方程求解目标了。

264
00:18:08,000 --> 00:18:12,062
我们之前看到的区域的问题在于，即使它的边界 

265
00:18:12,062 --> 00:18:15,940
穿过了所有可能的颜色，但缠绕数实际上为零。

266
00:18:16,500 --> 00:18:21,354
输出缠绕到一半，从黄色到红色，然后开始逆时针返 

267
00:18:21,354 --> 00:18:27,017
回另一个方向，然后继续穿过蓝色并从另一个方向到 达红色，

268
00:18:27,017 --> 00:18:30,860
所有这些都以这样的方式使总缠绕净为零。

269
00:18:31,840 --> 00:18:35,537
但是，如果您发现一个循环不仅命中每种颜色，

270
00:18:35,537 --> 00:18:40,644
而且 具有非零缠绕数的更强条件，那么如果您将其分成 两半，

271
00:18:40,644 --> 00:18:44,518
则可以保证至少其中一个具有缠绕数也是非 零，

272
00:18:44,518 --> 00:18:48,040
因为事情按照我们想要的方式很好地加起来。

273
00:18:48,440 --> 00:18:53,500
这样，你就可以继续前进，越来越缩小到一个点。

274
00:18:54,050 --> 00:18:58,270
当你缩小到一个点时，你将使用具有非零缠绕数的小循环来 

275
00:18:58,270 --> 00:19:02,335
做到这一点，这意味着它们会经历所有可能的颜色，因此，

276
00:19:02,335 --> 00:19:06,400
 就像我之前所说的那样，它们缩小的点on 必须为零。

277
00:19:07,420 --> 00:19:08,360
就是这样！

278
00:19:08,600 --> 00:19:11,787
我们现在已经创建了一个二维方程求 解器，

279
00:19:11,787 --> 00:19:13,860
这一次，我保证，没有错误。

280
00:19:14,560 --> 00:19:17,540
绕数正是我们实现这项工作所需的工具。

281
00:19:18,100 --> 00:19:22,008
现在，我们只需考虑 f 和 g 之间的差值如何变化，

282
00:19:22,008 --> 00:19:26,218
就可以 解出类似于二维中 x 的 f 等于 x 的 g 

283
00:19:26,218 --> 00:19:26,820
的方程。

284
00:19:27,600 --> 00:19:29,927
每当我们有一个缠绕数不为零的循环时，

285
00:19:29,927 --> 00:19:32,125
我们就可以在它上面运行 这个算法，

286
00:19:32,125 --> 00:19:35,100
并且我们保证在其中的某个地方找到一个解决方案。

287
00:19:35,660 --> 00:19:39,840
更重要的是，就像在一维中一样，该算法非常高效。

288
00:19:40,240 --> 00:19:45,499
我们每轮不断缩小区域大小的一半，从而快速缩小零 点，

289
00:19:45,499 --> 00:19:51,163
并且一直以来，我们只需要沿着这些循环的点检 查函数的值，

290
00:19:51,163 --> 00:19:54,400
而不是在许多点上检查它内部的点。

291
00:19:55,160 --> 00:19:59,615
因此，从某种意义上说，完成的总体工作仅与搜索空间的周 

292
00:19:59,615 --> 00:20:03,740
长成正比，而不是与整个面积成正比，这是令人惊奇的。

293
00:20:04,920 --> 00:20:08,524
现在，一旦你了解了发生了什么，仅仅观察它的实际情况，

294
00:20:08,524 --> 00:20:12,544
赋予它 一些功能并让它搜索零，就会产生一种奇怪的令人着迷的

295
00:20:12,544 --> 00:20:12,960
感觉。

296
00:20:13,620 --> 00:20:16,670
正如我之前所说，复数是二维的，所以让 

297
00:20:16,670 --> 00:20:19,560
我们将其应用到一些具有复数的方程中。

298
00:20:20,300 --> 00:20:24,318
例如，以下算法在复平面上查找函数 

299
00:20:24,318 --> 00:20:28,100
x 到第五次减 x 减一的零点。

300
00:20:28,900 --> 00:20:34,480
首先考虑原点周围的一个非常大 的区域，最终缠绕数为 5。

301
00:20:35,280 --> 00:20:38,211
每次找到一个具有非零缠绕数的环路时，

302
00:20:38,211 --> 00:20:42,120
您将其 分成两半，并计算出两个较小环路的缠绕数。

303
00:20:42,700 --> 00:20:45,894
它们中的一个或两个都保证具有非零缠绕数，

304
00:20:45,894 --> 00:20:50,365
当您 看到这一点时，您知道在较小的循环内某处有一个 零，

305
00:20:50,365 --> 00:20:53,400
因此您继续以相同的方式搜索较小的空间。

306
00:20:54,180 --> 00:20:56,976
如果我们正在计算的路径碰巧遇到零，

307
00:20:56,976 --> 00:21:01,254
我们也会停止探索一 个区域，这种情况在右半部分的示例

308
00:21:01,254 --> 00:21:02,900
中实际上发生过一次。

309
00:21:03,280 --> 00:21:06,520
这些罕见的情况会干扰我们计算缠绕 数的能力，

310
00:21:06,520 --> 00:21:08,140
但是嘿，我们得到了零。

311
00:21:09,220 --> 00:21:12,920
至于绕数为零的循环，您只是不进一步探索它们。

312
00:21:12,920 --> 00:21:16,200
也许他们内部有解决方案，也许他们没有，我们无法保证。

313
00:21:18,400 --> 00:21:21,505
让我们的方程求解器以同样的方式继续下去 ，

314
00:21:21,505 --> 00:21:24,020
它最终会收敛到该多项式的许多零点。

315
00:21:25,840 --> 00:21:31,000
顺便说一句，本例中的总绕组 数恰好为 5 并非巧合。

316
00:21:31,580 --> 00:21:37,141
对于复数，x 到 n 的运算直接对应于绕输出原 

317
00:21:37,141 --> 00:21:42,240
点绕行 n 次，就像绕输入原点绕行一次一样。

318
00:21:44,680 --> 00:21:47,808
因此，对于多项式，对于足够大的输入，

319
00:21:47,808 --> 00:21:51,980
相比之 下，除了首项之外的每一项都变得微不足道。

320
00:21:52,480 --> 00:21:56,322
因此，任何首项为 x 到 n 的复多项 

321
00:21:56,322 --> 00:21:59,780
式都具有围绕足够大的循环的绕数 n。

322
00:22:00,540 --> 00:22:06,820
这样，我们的绕数技术实际上保证 了每个复数多项式都有一个零。

323
00:22:07,480 --> 00:22:12,000
这是一个非常重要的事实，数学家将其称为代数基本定理。

324
00:22:13,800 --> 00:22:18,883
拥有一个算法来找到这样的方程的数值解是非 常实用的，

325
00:22:18,883 --> 00:22:22,403
但代数的基本定理是一个很好的例 子，

326
00:22:22,403 --> 00:22:26,118
说明这些绕数在理论层面上也非常有用 ，

327
00:22:26,118 --> 00:22:31,202
保证了广泛的一类方程的解的存在。 适合条 件的方程，

328
00:22:31,202 --> 00:22:33,940
这更是数学家喜欢思考的事情。

329
00:22:33,940 --> 00:22:38,853
我将在后续视频中向您展示拓扑上下文中的一些更令人惊奇的应用 

330
00:22:38,853 --> 00:22:43,440
，其中包括纠正旧 3blue1brown 视频中的错误。

331
00:22:44,060 --> 00:22:44,440
哪一个？

332
00:22:44,940 --> 00:22:47,818
好吧，观看该频道上的所有视频和所有 内容，

333
00:22:47,818 --> 00:22:49,600
看看您是否能首先发现错误。

334
00:22:51,300 --> 00:23:01,070
该视频的主要作者是 3blue1brown 团队 

335
00:23:01,070 --> 00:23:10,060
的最新成员之一 Sridhar Ramesh。

