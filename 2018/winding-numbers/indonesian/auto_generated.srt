1
00:00:00,000 --> 00:00:06,720
Ada dua hal di sini, topik utama dan topik meta.

2
00:00:06,720 --> 00:00:10,015
Topik utamanya adalah algoritma yang sangat rapi untuk menyelesaikan

3
00:00:10,015 --> 00:00:14,076
persamaan dua dimensi, hal-hal yang memiliki dua bilangan real yang tidak diketahui,

4
00:00:14,076 --> 00:00:17,420
atau juga yang melibatkan satu bilangan kompleks yang tidak diketahui.

5
00:00:17,420 --> 00:00:21,183
Jadi misalnya, jika Anda ingin mencari akar kompleks dari sebuah polinomial,

6
00:00:21,183 --> 00:00:24,898
atau mungkin beberapa dari angka nol jutaan dolar dari fungsi Riemann zeta,

7
00:00:24,898 --> 00:00:27,000
algoritma ini akan melakukannya untuk Anda.

8
00:00:27,000 --> 00:00:30,520
Dan metode ini sangat cantik, karena melibatkan banyak warna.

9
00:00:30,520 --> 00:00:33,812
Dan yang lebih penting, ide inti yang mendasarinya berlaku untuk

10
00:00:33,812 --> 00:00:37,662
semua jenis matematika di luar algoritma untuk menyelesaikan persamaan ini,

11
00:00:37,662 --> 00:00:40,600
termasuk sedikit topologi, yang akan saya bicarakan nanti.

12
00:00:40,600 --> 00:00:44,485
Tapi apa yang membuat ini bernilai sekitar 20 menit dari waktu Anda adalah bahwa ini

13
00:00:44,485 --> 00:00:48,188
mengilustrasikan pelajaran yang jauh lebih berguna secara umum dalam matematika,

14
00:00:48,188 --> 00:00:52,120
yaitu mencoba mendefinisikan konstruksi yang dapat disusun dengan baik satu sama lain.

15
00:00:52,120 --> 00:00:55,460
Anda akan melihat apa yang saya maksud dengan itu seiring berjalannya cerita.

16
00:00:55,460 --> 00:00:59,286
Untuk memotivasi kasus dengan fungsi yang memiliki masukan 2d dan keluaran 2d,

17
00:00:59,286 --> 00:01:02,435
mari kita mulai dengan lebih sederhana, dengan fungsi yang hanya

18
00:01:02,435 --> 00:01:05,100
mengambil bilangan real dan mengeluarkan bilangan real.

19
00:01:05,100 --> 00:01:08,199
Jika Anda ingin mengetahui kapan suatu fungsi f dari x sama dengan

20
00:01:08,199 --> 00:01:11,021
fungsi g lainnya dari x, Anda mungkin menganggap ini sebagai

21
00:01:11,021 --> 00:01:14,260
pencarian kapan grafik dari fungsi-fungsi tersebut berpotongan, bukan?

22
00:01:14,260 --> 00:01:19,340
Maksud saya, itu memberi Anda masukan di mana kedua fungsi memiliki keluaran yang sama.

23
00:01:19,340 --> 00:01:23,544
Untuk mengambil contoh yang sangat sederhana, bayangkan f dari x adalah x kuadrat,

24
00:01:23,544 --> 00:01:25,520
dan g dari x adalah fungsi konstanta 2.

25
00:01:25,520 --> 00:01:29,620
Dengan kata lain, Anda ingin mencari akar kuadrat dari 2.

26
00:01:29,620 --> 00:01:33,630
Bahkan jika Anda hampir tidak tahu apa-apa tentang mencari akar kuadrat,

27
00:01:33,630 --> 00:01:37,036
Anda mungkin bisa melihat bahwa 1 kuadrat lebih kecil dari 2,

28
00:01:37,036 --> 00:01:40,057
dan 2 kuadrat lebih besar dari 2, jadi Anda sadar, ah,

29
00:01:40,057 --> 00:01:42,640
akan ada solusi di antara kedua nilai tersebut.

30
00:01:42,640 --> 00:01:44,997
Lalu jika Anda ingin mempersempitnya lebih jauh,

31
00:01:44,997 --> 00:01:47,740
mungkin Anda mencoba mengkuadratkan titik tengahnya, 1.5.

32
00:01:47,740 --> 00:01:51,340
Ini keluar menjadi 2.25, agak terlalu tinggi, jadi

33
00:01:51,340 --> 00:01:54,940
Anda sebaiknya fokus pada wilayah antara 1 dan 1.5.

34
00:01:54,940 --> 00:01:59,774
Dan seterusnya, Anda mungkin dapat melihat bagaimana hal ini akan terus berlanjut,

35
00:01:59,774 --> 00:02:03,152
Anda akan terus menghitung pada titik tengah dan kemudian

36
00:02:03,152 --> 00:02:05,540
membagi ruang pencarian Anda menjadi dua.

37
00:02:05,540 --> 00:02:09,153
Cara lain untuk memikirkan hal ini, yang akan memudahkan kita ketika kita

38
00:02:09,153 --> 00:02:12,815
mencapai dimensi yang lebih tinggi, adalah dengan berfokus pada pertanyaan

39
00:02:12,815 --> 00:02:16,380
ekuivalen mengenai kapan selisih antara kedua fungsi ini sama dengan nol.

40
00:02:16,380 --> 00:02:20,200
Dalam istilah tersebut, kami menemukan wilayah masukan yang

41
00:02:20,200 --> 00:02:24,020
perbedaannya negatif di satu sisi, dan positif di sisi lain.

42
00:02:24,020 --> 00:02:27,916
Kami membaginya menjadi dua, dan bagian yang kami persempit perhatiannya

43
00:02:27,916 --> 00:02:31,600
adalah bagian yang titik terluarnya memiliki tanda yang berbeda-beda.

44
00:02:31,600 --> 00:02:34,427
Dengan cara ini, kami dapat terus berjalan selamanya,

45
00:02:34,427 --> 00:02:38,615
mengambil setiap wilayah dengan tanda-tanda yang berbeda-beda di perbatasannya,

46
00:02:38,615 --> 00:02:41,914
menemukan wilayah yang lebih kecil di antara bagian-bagiannya,

47
00:02:41,914 --> 00:02:46,260
mengetahui bahwa pada akhirnya kami harus mempersempit titik yang akan menjadi nol.

48
00:02:46,260 --> 00:02:50,637
Singkatnya, menyelesaikan persamaan selalu bisa dirumuskan sebagai menemukan kapan

49
00:02:50,637 --> 00:02:55,172
fungsi tertentu sama dengan nol, dan untuk melakukannya, kita memiliki heuristik ini,

50
00:02:55,172 --> 00:02:58,126
jika f positif di satu titik dan negatif di titik lain,

51
00:02:58,126 --> 00:03:02,661
Anda dapat mencari di antara di mana itu nol, setidaknya jika semuanya berubah lancar

52
00:03:02,661 --> 00:03:03,980
tanpa lompatan tiba-tiba.

53
00:03:03,980 --> 00:03:07,719
Hal menakjubkan yang ingin saya tunjukkan kepada Anda adalah Anda dapat

54
00:03:07,719 --> 00:03:11,096
memperluas pemikiran seperti ini ke dalam persamaan dua dimensi,

55
00:03:11,096 --> 00:03:14,940
persamaan antara fungsi yang masukan dan keluarannya keduanya dua dimensi.

56
00:03:14,940 --> 00:03:18,225
Misalnya, bilangan kompleks berbentuk 2D, dan alat yang kami

57
00:03:18,225 --> 00:03:21,780
kembangkan ini sempurna untuk menemukan solusi persamaan kompleks.

58
00:03:21,780 --> 00:03:25,037
Sekarang, karena kita akan banyak membicarakan fungsi-fungsi 2D ini,

59
00:03:25,037 --> 00:03:28,435
mari kita mengambil langkah singkat dan mempertimbangkan bagaimana kita

60
00:03:28,435 --> 00:03:29,380
mengilustrasikannya.

61
00:03:29,380 --> 00:03:34,157
Membuat grafik fungsi dengan input 2D dan output 2D memerlukan empat dimensi,

62
00:03:34,157 --> 00:03:38,322
dan itu tidak akan berfungsi dengan baik di dunia 3D pada layar 2D,

63
00:03:38,322 --> 00:03:41,140
namun kami masih memiliki beberapa opsi bagus.

64
00:03:41,140 --> 00:03:46,020
Salah satunya adalah dengan melihat ruang masukan dan ruang keluaran secara berdampingan.

65
00:03:46,020 --> 00:03:49,955
Setiap titik di ruang masukan berpindah ke titik tertentu di ruang keluaran,

66
00:03:49,955 --> 00:03:53,686
dan saya dapat menunjukkan bagaimana pergerakan di sekitar titik masukan

67
00:03:53,686 --> 00:03:57,060
tersebut berhubungan dengan pergerakan tertentu di ruang keluaran.

68
00:03:57,060 --> 00:04:00,396
Semua fungsi yang kita pertimbangkan akan bersifat kontinu,

69
00:04:00,396 --> 00:04:03,845
dalam artian perubahan kecil pada masukan hanya sesuai dengan

70
00:04:03,845 --> 00:04:07,460
perubahan kecil pada keluaran, tidak ada lompatan yang tiba-tiba.

71
00:04:07,460 --> 00:04:12,304
Pilihan lain yang kita miliki adalah membayangkan panah dari asal ruang keluaran ke

72
00:04:12,304 --> 00:04:17,380
titik keluaran tersebut, dan melampirkan versi miniatur panah tersebut ke titik masukan.

73
00:04:17,380 --> 00:04:20,550
Sekilas hal ini dapat memberi kita gambaran tentang ke mana

74
00:04:20,550 --> 00:04:23,774
perginya suatu titik masukan tertentu, atau ke mana perginya

75
00:04:23,774 --> 00:04:27,580
banyak titik masukan yang berbeda dengan menggambar bidang vektor penuh.

76
00:04:27,580 --> 00:04:30,217
Dan sayangnya ketika Anda melakukan ini di banyak titik,

77
00:04:30,217 --> 00:04:33,642
hal ini bisa menjadi sangat berantakan, jadi di sini izinkan saya membuat

78
00:04:33,642 --> 00:04:37,205
semua panah berukuran sama, dan ini berarti kita bisa mengetahui arah setiap

79
00:04:37,205 --> 00:04:37,900
titik keluaran.

80
00:04:37,900 --> 00:04:41,286
Namun mungkin cara tercantik untuk mengilustrasikan fungsi dua dimensi,

81
00:04:41,286 --> 00:04:43,778
dan yang paling sering kita gunakan dalam video ini,

82
00:04:43,778 --> 00:04:47,400
adalah dengan mengasosiasikan setiap titik dalam ruang keluaran dengan warna.

83
00:04:47,400 --> 00:04:51,690
Di sini kita menggunakan warna, yaitu warna yang jatuh di sepanjang pelangi atau

84
00:04:51,690 --> 00:04:55,080
roda warna, untuk menyesuaikan dengan arah menjauhi titik asal,

85
00:04:55,080 --> 00:04:59,212
dan kita menggunakan kegelapan atau kecerahan untuk menyesuaikan dengan jarak

86
00:04:59,212 --> 00:05:00,060
dari titik asal.

87
00:05:00,060 --> 00:05:02,693
Misalnya, dengan fokus pada rangkaian keluaran ini,

88
00:05:02,693 --> 00:05:05,934
semua titik ini berwarna merah, namun titik yang lebih dekat ke

89
00:05:05,934 --> 00:05:10,340
titik asal sedikit lebih gelap, dan titik yang lebih jauh menjadi sedikit lebih terang.

90
00:05:10,340 --> 00:05:14,100
Dan dengan fokus pada rangkaian keluaran ini, semua titik berwarna hijau,

91
00:05:14,100 --> 00:05:17,353
dan sekali lagi, lebih dekat ke titik asal berarti lebih gelap,

92
00:05:17,353 --> 00:05:18,980
lebih jauh berarti lebih terang.

93
00:05:18,980 --> 00:05:22,300
Dan seterusnya, yang kita lakukan di sini hanyalah memberikan

94
00:05:22,300 --> 00:05:25,300
warna tertentu pada setiap arah, semuanya terus berubah.

95
00:05:25,300 --> 00:05:29,279
Anda mungkin melihat perbedaan kegelapan dan kecerahan di sini cukup halus,

96
00:05:29,279 --> 00:05:32,943
namun untuk video ini, yang kami pedulikan hanyalah arah keluarannya,

97
00:05:32,943 --> 00:05:35,300
bukan besarnya, warnanya, bukan kecerahannya.

98
00:05:35,300 --> 00:05:39,953
Satu hal penting tentang kecerahan yang harus Anda perhatikan adalah bahwa di dekat

99
00:05:39,953 --> 00:05:44,440
titik asal, yang tidak memiliki arah tertentu, semua warna memudar menjadi hitam.

100
00:05:44,440 --> 00:05:49,346
Jadi untuk memikirkan fungsi, setelah kita menentukan warna untuk setiap keluaran,

101
00:05:49,346 --> 00:05:53,899
kita dapat memvisualisasikan fungsi 2D dengan mewarnai setiap titik di ruang

102
00:05:53,899 --> 00:05:57,860
masukan berdasarkan warna titik tempatnya berada di ruang keluaran.

103
00:05:57,860 --> 00:06:02,694
Saya suka membayangkan banyak titik berbeda dari ruang masukan yang melompat ke keluaran

104
00:06:02,694 --> 00:06:07,257
yang sesuai di ruang keluaran, kemudian dicat berdasarkan warna titik di mana titik

105
00:06:07,257 --> 00:06:11,820
tersebut mendarat, dan kemudian melompat kembali ke tempat asalnya di ruang masukan.

106
00:06:11,820 --> 00:06:14,023
Dengan melakukan hal ini untuk setiap titik di ruang masukan,

107
00:06:14,023 --> 00:06:16,403
Anda dapat memahaminya hanya dengan melihat ruang masukan tersebut

108
00:06:16,403 --> 00:06:19,140
untuk mengetahui secara kasar di mana fungsi tersebut mengambil setiap titik.

109
00:06:19,140 --> 00:06:24,631
Misalnya, garis titik merah muda di sebelah kiri ini memberi tahu kita bahwa semua titik

110
00:06:24,631 --> 00:06:30,000
tersebut dipetakan di suatu tempat dalam arah merah muda, di kiri bawah ruang keluaran.

111
00:06:30,000 --> 00:06:33,390
Juga tiga titik yang berwarna hitam dengan banyak

112
00:06:33,390 --> 00:06:37,120
warna di sekelilingnya adalah titik yang menuju ke nol.

113
00:06:37,120 --> 00:06:43,725
Baiklah, sama seperti kasus 1D, penyelesaian persamaan fungsi 2D selalu

114
00:06:43,725 --> 00:06:49,780
dapat diubah dengan menanyakan kapan suatu fungsi sama dengan nol.

115
00:06:49,780 --> 00:06:54,873
Jadi itulah tantangan kita saat ini, membuat algoritme yang

116
00:06:54,873 --> 00:07:00,900
menemukan titik masukan mana dari fungsi 2D tertentu yang bernilai nol.

117
00:07:00,900 --> 00:07:04,891
Anda mungkin menunjukkan bahwa jika Anda melihat peta warna seperti ini dengan melihat

118
00:07:04,891 --> 00:07:08,700
titik-titik hitam tersebut, Anda sudah mengetahui di mana angka nol dari fungsinya.

119
00:07:08,700 --> 00:07:11,460
Jadi apakah itu masuk hitungan?

120
00:07:11,460 --> 00:07:14,395
Ingatlah bahwa untuk membuat diagram seperti ini,

121
00:07:14,395 --> 00:07:18,798
kita telah meminta komputer menghitung fungsi di semua piksel pada bidang,

122
00:07:18,798 --> 00:07:23,201
namun tujuan kita adalah menemukan algoritma yang lebih efisien yang hanya

123
00:07:23,201 --> 00:07:26,723
memerlukan komputasi fungsi pada titik sesedikit mungkin. ,

124
00:07:26,723 --> 00:07:29,600
hanya memiliki pandangan terbatas terhadap warna.

125
00:07:29,600 --> 00:07:31,916
Dan juga dari sudut pandang yang lebih teoritis,

126
00:07:31,916 --> 00:07:34,706
akan lebih baik jika memiliki konstruksi umum yang memberi

127
00:07:34,706 --> 00:07:38,300
tahu kita kondisi apakah ada angka nol atau tidak di dalam wilayah tertentu.

128
00:07:38,300 --> 00:07:43,640
Ingat, dalam satu dimensi, pemahaman utamanya adalah jika suatu fungsi kontinu bernilai

129
00:07:43,640 --> 00:07:48,920
positif di satu titik dan negatif di titik lain, maka di antara keduanya pasti ada nol.

130
00:07:48,920 --> 00:07:50,960
Jadi bagaimana kita memperluasnya menjadi dua dimensi?

131
00:07:50,960 --> 00:07:55,180
Kita memerlukan semacam analogi dalam membicarakan tanda.

132
00:07:55,180 --> 00:07:59,140
Salah satu cara untuk memikirkan tentang tanda-tanda adalah petunjuk arah.

133
00:07:59,140 --> 00:08:02,238
Positif berarti Anda menunjuk ke kanan sepanjang garis bilangan,

134
00:08:02,238 --> 00:08:04,240
dan negatif berarti Anda menunjuk ke kiri.

135
00:08:04,240 --> 00:08:09,226
Besaran dua dimensi juga memiliki arah, tetapi bagi mereka pilihannya jauh lebih luas,

136
00:08:09,226 --> 00:08:12,780
mereka dapat menunjuk ke mana saja dalam berbagai kemungkinan.

137
00:08:12,780 --> 00:08:18,025
Jadi sama seperti dalam satu dimensi kita menanyakan apakah suatu fungsi tertentu

138
00:08:18,025 --> 00:08:21,606
bernilai positif atau negatif pada batas suatu rentang,

139
00:08:21,606 --> 00:08:27,363
yang hanya terdiri dari dua titik, untuk fungsi 2d kita akan melihat batas suatu wilayah,

140
00:08:27,363 --> 00:08:32,800
yang mana adalah sebuah loop, dan tanyakan tentang arah keluaran fungsi di sepanjang

141
00:08:32,800 --> 00:08:33,760
batas tersebut.

142
00:08:33,760 --> 00:08:37,506
Misalnya, kita melihat bahwa sepanjang putaran di sekitar angka nol ini,

143
00:08:37,506 --> 00:08:41,611
keluaran melewati setiap arah yang mungkin, semua warna pelangi, merah, kuning,

144
00:08:41,611 --> 00:08:45,820
hijau, biru, kembali ke merah, dan segala sesuatu di antaranya di sepanjang jalan.

145
00:08:45,820 --> 00:08:49,105
Namun di sepanjang perulangan ini, tanpa angka nol di dalamnya,

146
00:08:49,105 --> 00:08:52,955
keluarannya tidak melewati semua warna, ia melewati beberapa warna jingga,

147
00:08:52,955 --> 00:08:55,420
namun tidak pernah, katakanlah, hijau atau biru.

148
00:08:55,420 --> 00:08:57,237
Dan ini cukup menjanjikan, hal ini mirip dengan

149
00:08:57,237 --> 00:08:59,320
bagaimana segala sesuatunya bekerja dalam satu dimensi.

150
00:08:59,320 --> 00:09:03,640
Mungkin dengan cara yang sama jika fungsi 1d mengambil kedua tanda yang

151
00:09:03,640 --> 00:09:08,080
mungkin pada batas wilayah 1d, ada angka nol di suatu tempat di dalamnya,

152
00:09:08,080 --> 00:09:12,400
kita dapat berhipotesis bahwa jika fungsi 2d menghasilkan keluaran dari

153
00:09:12,400 --> 00:09:17,260
semua arah yang mungkin, semua kemungkinan warna, di sepanjang batas wilayah 2d,

154
00:09:17,260 --> 00:09:20,980
maka di suatu tempat di dalam wilayah itu harus menuju ke nol.

155
00:09:20,980 --> 00:09:24,059
Jadi itulah tebakan kami, dan luangkan waktu sejenak untuk

156
00:09:24,059 --> 00:09:27,660
memikirkan apakah hal ini benar, dan jika demikian, mengapa demikian.

157
00:09:27,660 --> 00:09:31,083
Jika kita mulai memikirkan perulangan kecil di sekitar titik masukan,

158
00:09:31,083 --> 00:09:34,214
kita tahu bahwa karena semuanya kontinu, fungsi kita membawanya

159
00:09:34,214 --> 00:09:36,660
ke perulangan kecil di dekat keluaran yang sesuai.

160
00:09:36,660 --> 00:09:41,140
Tapi lihat, untuk sebagian besar loop kecil, warna keluarannya bervariasi.

161
00:09:41,140 --> 00:09:44,030
Jika Anda memilih titik keluaran selain nol, dan menggambar

162
00:09:44,030 --> 00:09:47,017
lingkaran yang cukup rapat di dekatnya, semua warna lingkaran

163
00:09:47,017 --> 00:09:49,860
akan memiliki warna yang hampir sama dengan titik tersebut.

164
00:09:49,860 --> 00:09:52,814
Lingkaran ketat di sini semuanya berwarna kebiruan,

165
00:09:52,814 --> 00:09:57,303
lingkaran ketat di sini semuanya kekuningan, Anda tentu tidak akan mendapatkan

166
00:09:57,303 --> 00:09:58,440
semua warna pelangi.

167
00:09:58,440 --> 00:10:02,675
Satu-satunya titik di mana Anda dapat mengencangkan loop di sekelilingnya sambil

168
00:10:02,675 --> 00:10:07,120
tetap mendapatkan semua warna adalah titik asal yang tidak berwarna, nol itu sendiri.

169
00:10:07,120 --> 00:10:11,952
Jadi memang benar bahwa jika Anda memiliki loop yang melewati setiap warna pelangi,

170
00:10:11,952 --> 00:10:15,461
mengencangkan dan mengencangkan, menyempit pada suatu titik,

171
00:10:15,461 --> 00:10:17,360
maka titik tersebut pastilah nol.

172
00:10:17,360 --> 00:10:22,360
Jadi mari kita siapkan pemecah persamaan 2d seperti pemecah persamaan satu dimensi.

173
00:10:22,360 --> 00:10:26,621
Saat kita menemukan wilayah luas yang batasnya melewati setiap warna,

174
00:10:26,621 --> 00:10:30,640
bagilah menjadi dua, lalu lihat warna pada batas setiap bagiannya.

175
00:10:30,640 --> 00:10:35,439
Pada contoh yang ditunjukkan di sini, batas di bagian kiri tidak mencakup semua warna,

176
00:10:35,439 --> 00:10:39,080
misalnya tidak ada titik yang dipetakan ke arah oranye kekuningan.

177
00:10:39,080 --> 00:10:41,212
Jadi saya akan menghapus area ini dengan warna abu-abu sebagai

178
00:10:41,212 --> 00:10:43,480
cara untuk mengatakan bahwa kami tidak ingin mencarinya lebih jauh.

179
00:10:43,480 --> 00:10:47,569
Bagian kanan melewati semua warna, menghabiskan banyak waktu ke arah hijau,

180
00:10:47,569 --> 00:10:51,120
kemudian melewati kuning oranye merah, serta biru ungu merah muda.

181
00:10:51,120 --> 00:10:54,287
Sekarang ingat, artinya titik-titik batas ini

182
00:10:54,287 --> 00:10:57,800
dipetakan ke keluaran dari semua arah yang mungkin.

183
00:10:57,800 --> 00:11:02,900
Makanya kita telusuri lebih jauh lagi, dipecah lagi dan dicek batas tiap wilayahnya.

184
00:11:02,900 --> 00:11:07,000
Batas atas semuanya hijau, jadi kita berhenti mencari di sana.

185
00:11:07,000 --> 00:11:10,500
Tapi bagian bawahnya cukup berwarna sehingga layak untuk dibagi lagi.

186
00:11:10,500 --> 00:11:12,420
Dan terus seperti ini.

187
00:11:12,420 --> 00:11:16,594
Periksa subwilayah mana yang memiliki batas yang mencakup semua kemungkinan warna,

188
00:11:16,594 --> 00:11:20,769
yang berarti titik-titik batas tersebut akan dipetakan ke semua arah yang mungkin,

189
00:11:20,769 --> 00:11:24,994
dan terus potong wilayah tersebut menjadi dua seperti yang kita lakukan untuk kasus

190
00:11:24,994 --> 00:11:29,320
satu dimensi, yang pada akhirnya membawa kita ke nol pada fungsi- Oh, tunggu sebentar.

191
00:11:29,320 --> 00:11:30,320
Apa yang terjadi disini?

192
00:11:30,320 --> 00:11:34,213
Tak satu pun dari subdivisi terakhir di kanan bawah melewati semua warna,

193
00:11:34,213 --> 00:11:37,844
sehingga algoritme kami berhenti karena tidak ingin menelusuri salah

194
00:11:37,844 --> 00:11:41,160
satu dari warna tersebut, namun juga tidak menemukan angka nol.

195
00:11:41,160 --> 00:11:43,720
Oke, jelas ada sesuatu yang salah di sini.

196
00:11:43,720 --> 00:11:46,680
Dan tidak apa-apa, melakukan kesalahan adalah hal yang biasa dalam mengerjakan matematika.

197
00:11:46,680 --> 00:11:49,666
Jika kita melihat ke belakang, kita mempunyai hipotesis ini,

198
00:11:49,666 --> 00:11:53,680
dan hipotesis ini membawa kita pada algoritma yang diusulkan ini, jadi kita salah.

199
00:11:53,680 --> 00:11:57,041
Dan menjadi ahli dalam matematika bukan berarti menjadi benar pada kali pertama,

200
00:11:57,041 --> 00:12:00,071
namun tentang memiliki ketahanan untuk melihat ke belakang secara cermat

201
00:12:00,071 --> 00:12:02,520
dan memahami kesalahan, serta memahami cara memperbaikinya.

202
00:12:02,520 --> 00:12:06,428
Sekarang masalahnya adalah kita mempunyai wilayah yang batasnya melewati setiap warna,

203
00:12:06,428 --> 00:12:09,618
tapi ketika kita membaginya di tengah, tidak ada batas subwilayah yang

204
00:12:09,618 --> 00:12:13,617
melewati setiap warna, kita tidak punya pilihan ke mana harus terus mencari selanjutnya,

205
00:12:13,617 --> 00:12:15,280
dan itu memecahkan angka nol. penemu.

206
00:12:15,280 --> 00:12:18,120
Sekarang dalam satu dimensi, hal seperti ini tidak pernah terjadi.

207
00:12:18,120 --> 00:12:22,826
Setiap kali Anda memiliki interval yang titik akhirnya memiliki tanda berbeda,

208
00:12:22,826 --> 00:12:26,638
jika Anda membaginya, Anda dijamin mendapatkan subinterval yang

209
00:12:26,638 --> 00:12:29,200
titik akhirnya juga memiliki tanda berbeda.

210
00:12:29,200 --> 00:12:32,485
Atau dengan kata lain, setiap kali Anda memiliki dua interval yang titik

211
00:12:32,485 --> 00:12:35,095
akhirnya tidak berubah tanda, jika Anda menggabungkannya,

212
00:12:35,095 --> 00:12:38,380
Anda akan mendapatkan interval yang lebih besar yang titik akhirnya juga

213
00:12:38,380 --> 00:12:39,280
tidak berubah tanda.

214
00:12:39,280 --> 00:12:43,026
Namun dalam dua dimensi, kita bisa menemukan dua wilayah yang batasnya

215
00:12:43,026 --> 00:12:46,615
tidak menembus setiap warna, namun batas-batasnya digabungkan untuk

216
00:12:46,615 --> 00:12:49,940
menghasilkan suatu wilayah yang batasnya menembus setiap warna.

217
00:12:49,940 --> 00:12:53,740
Dan dengan cara ini, algoritma zero-finding yang kami usulkan gagal.

218
00:12:53,740 --> 00:12:58,303
Faktanya, jika dipikir-pikir, Anda dapat menemukan lingkaran besar yang

219
00:12:58,303 --> 00:13:03,120
batasnya melewati setiap warna yang mungkin tanpa ada angka nol di dalamnya.

220
00:13:03,120 --> 00:13:07,914
Hal ini tidak berarti bahwa kami salah dalam klaim kami tentang loop kecil ketika kami

221
00:13:07,914 --> 00:13:12,819
mengatakan bahwa loop yang selalu menyempit pada setiap warna harus menyempit pada angka

222
00:13:12,819 --> 00:13:13,040
nol.

223
00:13:13,040 --> 00:13:15,480
Namun yang membuat kami kacau adalah properti yang

224
00:13:15,480 --> 00:13:18,829
melakukan-perbatasan-saya-melintasi-setiap-warna-atau-tidak ini tidak

225
00:13:18,829 --> 00:13:23,040
digabungkan dengan cara yang bagus dan dapat diprediksi saat Anda menggabungkan wilayah.

226
00:13:23,040 --> 00:13:31,094
Tapi jangan khawatir, ternyata kita bisa memodifikasinya sedikit menjadi properti

227
00:13:31,094 --> 00:13:38,560
yang lebih canggih yang digabungkan untuk memberikan apa yang kita inginkan.

228
00:13:38,560 --> 00:13:41,645
Idenya adalah daripada sekadar menanyakan apakah kita dapat menemukan warna

229
00:13:41,645 --> 00:13:44,730
pada titik tertentu di sepanjang putaran, mari kita perhatikan lebih cermat

230
00:13:44,730 --> 00:13:48,100
bagaimana warna-warna ini berubah saat kita berjalan mengelilingi putaran tersebut.

231
00:13:48,100 --> 00:13:50,060
Izinkan saya menunjukkan kepada Anda apa yang saya maksud dengan sebuah contoh.

232
00:13:50,060 --> 00:13:54,120
Saya akan menyimpan roda warna kecil di pojok sini untuk membantu kita melacaknya.

233
00:13:54,120 --> 00:13:59,282
Ketika warna-warna di sepanjang jalur masukan bergerak melalui pelangi ke arah tertentu,

234
00:13:59,282 --> 00:14:03,574
dari merah ke kuning, kuning ke hijau, hijau ke biru, atau biru ke merah,

235
00:14:03,574 --> 00:14:05,720
keluarannya berayun searah jarum jam.

236
00:14:05,720 --> 00:14:09,896
Namun sebaliknya, jika warna bergerak berlawanan arah dalam pelangi,

237
00:14:09,896 --> 00:14:13,165
dari biru ke hijau, hijau ke kuning, kuning ke merah,

238
00:14:13,165 --> 00:14:17,160
atau merah ke biru, keluarannya berayun berlawanan arah jarum jam.

239
00:14:17,160 --> 00:14:21,482
Jadi berjalan di sepanjang jalur pendek ini, warna berputar seperlima

240
00:14:21,482 --> 00:14:26,544
searah jarum jam melalui roda warna, dan berjalan di sepanjang jalur ini di sini,

241
00:14:26,544 --> 00:14:30,620
warna berputar seperlima lagi searah jarum jam melalui roda warna.

242
00:14:30,620 --> 00:14:35,168
Tentu saja, ini berarti jika Anda melewati kedua jalur tersebut, satu demi satu,

243
00:14:35,168 --> 00:14:39,380
warnanya akan berputar sebanyak dua perlima putaran penuh searah jarum jam.

244
00:14:39,380 --> 00:14:43,504
Jumlah total penggulungan semakin bertambah, dan ini akan menjadi kuncinya,

245
00:14:43,504 --> 00:14:47,140
ini adalah jenis penggabungan langsung yang akan berguna bagi kita.

246
00:14:47,140 --> 00:14:51,083
Saat saya menyebutkan jumlah total belitan, saya ingin Anda membayangkan

247
00:14:51,083 --> 00:14:55,512
sebuah odometer kuno yang berdetak ke depan saat panah berputar searah jarum jam,

248
00:14:55,512 --> 00:14:58,700
namun mundur saat panah berputar berlawanan arah jarum jam.

249
00:14:58,700 --> 00:15:03,020
Jadi belitan berlawanan arah jarum jam dihitung sebagai belitan negatif searah jarum jam.

250
00:15:03,020 --> 00:15:07,933
Keluarannya mungkin banyak, tetapi jika sebagian dari putaran itu berlawanan arah,

251
00:15:07,933 --> 00:15:08,940
maka akan hilang.

252
00:15:08,940 --> 00:15:11,713
Misalnya, jika Anda bergerak maju di sepanjang jalur ini,

253
00:15:11,713 --> 00:15:14,535
dan kemudian bergerak mundur di sepanjang jalur yang sama,

254
00:15:14,535 --> 00:15:17,883
jumlah total belitan akan menjadi nol, gerakan mundur secara harafiah

255
00:15:17,883 --> 00:15:22,091
memundurkan warna-warna yang terlihat sebelumnya, membalikkan semua belitan sebelumnya,

256
00:15:22,091 --> 00:15:26,300
dan mengembalikan warna yang terlihat sebelumnya. odometer kembali ke tempat dimulainya.

257
00:15:26,300 --> 00:15:30,480
Untuk tujuan kita, kita akan sangat memperhatikan lilitan sepanjang loop.

258
00:15:30,480 --> 00:15:34,280
Sebagai contoh, katakanlah kita mengelilingi seluruh putaran ini searah jarum jam.

259
00:15:34,280 --> 00:15:40,147
Keluaran yang kita temui berputar sebanyak tiga kali putaran penuh searah jarum jam,

260
00:15:40,147 --> 00:15:43,944
warna-warna berayun melalui pelangi, secara berurutan,

261
00:15:43,944 --> 00:15:47,120
dari merah ke merah lagi, lalu lagi, dan lagi.

262
00:15:47,120 --> 00:15:52,310
Dalam jargon yang digunakan ahli matematika, kita mengatakan bahwa sepanjang loop ini,

263
00:15:52,310 --> 00:15:54,100
jumlah total belitan adalah 3.

264
00:15:54,100 --> 00:15:57,160
Untuk perulangan yang lain, bisa berupa bilangan bulat lainnya,

265
00:15:57,160 --> 00:16:00,651
mungkin bilangan yang lebih besar jika keluarannya berputar berkali-kali

266
00:16:00,651 --> 00:16:03,808
saat masukan berputar dalam satu putaran, atau bisa juga bilangan

267
00:16:03,808 --> 00:16:07,060
yang lebih kecil jika keluarannya hanya berputar satu atau dua kali.

268
00:16:07,060 --> 00:16:10,287
Atau bilangan belitan itu bahkan bisa berupa bilangan bulat negatif,

269
00:16:10,287 --> 00:16:14,404
jika keluarannya berayun berlawanan arah jarum jam saat kita berjalan mengelilingi loop

270
00:16:14,404 --> 00:16:15,200
searah jarum jam.

271
00:16:15,200 --> 00:16:19,720
Namun sepanjang loop mana pun, jumlah total belitan ini harus berupa bilangan bulat.

272
00:16:19,720 --> 00:16:22,662
Maksud saya, saat Anda kembali ke awal, Anda akan

273
00:16:22,662 --> 00:16:25,840
mendapatkan hasil yang sama seperti saat Anda memulai.

274
00:16:25,840 --> 00:16:29,895
Secara kebetulan, jika suatu jalur benar-benar berisi titik di mana keluarannya

275
00:16:29,895 --> 00:16:33,848
tepat nol, maka secara teknis Anda tidak dapat menentukan bilangan belitan di

276
00:16:33,848 --> 00:16:37,600
sepanjang jalur tersebut, karena keluarannya tidak memiliki arah tertentu.

277
00:16:37,600 --> 00:16:41,450
Ini tidak akan menjadi masalah bagi kami, karena seluruh tujuan kami adalah

278
00:16:41,450 --> 00:16:45,200
menemukan angka nol, jadi jika hal ini terjadi, kami hanya beruntung saja.

279
00:16:45,200 --> 00:16:49,925
Hal utama yang perlu diperhatikan tentang angka-angka berliku ini adalah angka-angka

280
00:16:49,925 --> 00:16:54,706
tersebut bertambah dengan baik saat Anda menggabungkan jalur menjadi jalur yang lebih

281
00:16:54,706 --> 00:16:55,040
besar.

282
00:16:55,040 --> 00:16:57,733
Namun yang sebenarnya kita inginkan adalah angka-angka yang berkelok-kelok

283
00:16:57,733 --> 00:17:00,354
di sepanjang perbatasan suatu wilayah dapat bertambah dengan baik ketika

284
00:17:00,354 --> 00:17:03,120
kita menggabungkan wilayah-wilayah tersebut menjadi wilayah yang lebih besar.

285
00:17:03,120 --> 00:17:06,320
Jadi, apakah kita memiliki properti itu?

286
00:17:06,320 --> 00:17:09,600
Nah, lihatlah.

287
00:17:09,600 --> 00:17:13,697
Bilangan belitan searah jarum jam mengelilingi wilayah di sebelah

288
00:17:13,697 --> 00:17:17,920
kiri ini adalah jumlah bilangan belitan dari keempat jalur tersebut.

289
00:17:17,920 --> 00:17:21,775
Dan lilitan yang kita putar searah jarum jam mengelilingi wilayah di sebelah

290
00:17:21,775 --> 00:17:25,480
kanan ini adalah jumlah dari bilangan lilitan dari keempat jalur tersebut.

291
00:17:25,480 --> 00:17:28,282
Dan ketika kita menggabungkan kedua wilayah tersebut menjadi satu

292
00:17:28,282 --> 00:17:31,000
wilayah yang lebih besar, sebagian besar jalur tersebut menjadi

293
00:17:31,000 --> 00:17:33,760
bagian dari perbatasan wilayah yang lebih besar searah jarum jam.

294
00:17:33,760 --> 00:17:36,040
Dan adapun dua jalur yang tidak?

295
00:17:36,040 --> 00:17:39,600
Mereka membatalkan dengan sempurna, salah satunya justru kebalikannya,

296
00:17:39,600 --> 00:17:42,660
pemutaran ulang yang lain seperti yang kita lihat sebelumnya.

297
00:17:42,660 --> 00:17:45,864
Jadi angka-angka yang berkelok-kelok di sepanjang batas

298
00:17:45,864 --> 00:17:48,840
wilayah akan bertambah sesuai dengan keinginan kita.

299
00:17:48,840 --> 00:17:53,028
Catatan tambahan, alasan tentang batas berorientasi yang dijumlahkan dengan baik

300
00:17:53,028 --> 00:17:57,320
seperti ini banyak muncul dalam matematika, dan sering kali disebut teorema Stokes.

301
00:17:57,320 --> 00:18:00,363
Anda yang pernah mempelajari kalkulus multivariabel

302
00:18:00,363 --> 00:18:02,880
mungkin mengenalinya dari konteks tersebut.

303
00:18:02,880 --> 00:18:05,648
Jadi sekarang, akhirnya, dengan berlikunya angka-angka di tangan,

304
00:18:05,648 --> 00:18:08,040
kita dapat kembali ke tujuan penyelesaian persamaan kita.

305
00:18:08,040 --> 00:18:12,056
Masalah dengan wilayah yang kita lihat sebelumnya adalah meskipun

306
00:18:12,056 --> 00:18:16,620
batasnya melewati semua kemungkinan warna, bilangan belitan sebenarnya nol.

307
00:18:16,620 --> 00:18:20,002
Outputnya berputar sekitar setengah, dari kuning ke merah,

308
00:18:20,002 --> 00:18:24,645
dan kemudian mulai berputar berlawanan arah jarum jam kembali ke arah yang lain,

309
00:18:24,645 --> 00:18:28,600
kemudian melanjutkan melalui biru dan mencapai merah dari arah lain,

310
00:18:28,600 --> 00:18:32,040
semuanya sedemikian rupa sehingga total belitan menjadi nol.

311
00:18:32,040 --> 00:18:35,394
Tetapi jika Anda menemukan sebuah loop yang tidak hanya mengenai setiap warna,

312
00:18:35,394 --> 00:18:38,664
namun juga memiliki kondisi yang lebih kuat dari bilangan lilitan bukan nol,

313
00:18:38,664 --> 00:18:42,060
maka jika Anda membaginya menjadi dua, Anda dijamin bahwa setidaknya salah satu

314
00:18:42,060 --> 00:18:45,670
dari bagian tersebut memiliki warna yang sama. bilangan belitan yang bukan nol juga,

315
00:18:45,670 --> 00:18:48,600
karena segala sesuatunya akan bertambah sesuai dengan keinginan kita.

316
00:18:48,600 --> 00:18:54,280
Jadi dengan cara ini, Anda dapat melanjutkan, semakin mempersempit ke satu titik.

317
00:18:54,280 --> 00:18:57,618
Dan saat Anda mempersempit suatu titik, Anda akan melakukannya dengan

318
00:18:57,618 --> 00:19:00,002
loop kecil yang memiliki nomor belitan bukan nol,

319
00:19:00,002 --> 00:19:02,911
yang berarti loop tersebut melewati semua kemungkinan warna,

320
00:19:02,911 --> 00:19:05,486
dan oleh karena itu, seperti saya katakan sebelumnya,

321
00:19:05,486 --> 00:19:07,680
titik di mana mereka menyempit pada harus nol.

322
00:19:07,680 --> 00:19:08,760
Dan itu saja!

323
00:19:08,760 --> 00:19:12,230
Kami sekarang telah membuat pemecah persamaan dua dimensi,

324
00:19:12,230 --> 00:19:14,760
dan kali ini, saya berjanji, tidak ada bug.

325
00:19:14,760 --> 00:19:18,200
Angka berliku adalah alat yang kita perlukan agar ini berhasil.

326
00:19:18,200 --> 00:19:21,369
Sekarang kita dapat menyelesaikan persamaan yang terlihat seperti

327
00:19:21,369 --> 00:19:24,106
di mana f dari x sama dengan g dari x dalam dua dimensi,

328
00:19:24,106 --> 00:19:27,660
hanya dengan mempertimbangkan bagaimana perbedaan antara f dan g berputar.

329
00:19:27,660 --> 00:19:30,477
Setiap kali kita mempunyai loop yang nomor lilitannya bukan nol,

330
00:19:30,477 --> 00:19:32,949
kita dapat menjalankan algoritma ini pada loop tersebut,

331
00:19:32,949 --> 00:19:35,160
dan dijamin kita akan menemukan solusi di dalamnya.

332
00:19:35,160 --> 00:19:40,300
Terlebih lagi, seperti dalam satu dimensi, algoritma ini sangat efisien.

333
00:19:40,300 --> 00:19:44,197
Kita terus mempersempit setengah ukuran wilayah kita di setiap putaran,

334
00:19:44,197 --> 00:19:47,715
sehingga dengan cepat mempersempit angka nol, dan sementara itu,

335
00:19:47,715 --> 00:19:52,100
kita hanya perlu memeriksa nilai fungsi di sepanjang titik-titik perulangan ini,

336
00:19:52,100 --> 00:19:55,240
daripada memeriksanya di banyak perulangan. poin interior.

337
00:19:55,240 --> 00:19:59,920
Jadi dalam beberapa hal, keseluruhan pekerjaan yang dilakukan hanya sebanding

338
00:19:59,920 --> 00:20:04,960
dengan keliling ruang pencarian, bukan seluruh luasnya, dan ini sungguh menakjubkan.

339
00:20:04,960 --> 00:20:10,160
Sekarang setelah Anda memahami apa yang terjadi, sungguh menakjubkan melihat ini beraksi,

340
00:20:10,160 --> 00:20:13,800
memberinya beberapa fungsi dan membiarkannya mencari angka nol.

341
00:20:13,800 --> 00:20:17,427
Seperti saya katakan sebelumnya, bilangan kompleks adalah dua dimensi,

342
00:20:17,427 --> 00:20:20,340
jadi mari kita terapkan pada persamaan bilangan kompleks.

343
00:20:20,340 --> 00:20:24,596
Misalnya, inilah algoritme yang mencari angka nol dari fungsi x

344
00:20:24,596 --> 00:20:28,920
hingga seperlima dikurangi x dikurangi satu pada bidang kompleks.

345
00:20:28,920 --> 00:20:33,336
Ini dimulai dengan mempertimbangkan wilayah yang sangat luas di sekitar titik asal,

346
00:20:33,336 --> 00:20:35,440
yang akhirnya memiliki jumlah lilitan 5.

347
00:20:35,440 --> 00:20:38,512
Setiap kali Anda menemukan loop dengan nomor belitan bukan nol,

348
00:20:38,512 --> 00:20:42,304
Anda membaginya menjadi dua, dan mencari tahu nomor belitan dari dua loop yang

349
00:20:42,304 --> 00:20:42,880
lebih kecil.

350
00:20:42,880 --> 00:20:46,230
Salah satu atau kedua-duanya dijamin memiliki nomor belitan bukan nol,

351
00:20:46,230 --> 00:20:50,100
dan ketika Anda melihat ini, Anda tahu ada nol di suatu tempat di dalam loop yang

352
00:20:50,100 --> 00:20:54,300
lebih kecil itu, jadi Anda terus melakukan hal yang sama, mencari ruang yang lebih kecil.

353
00:20:54,300 --> 00:20:58,501
Kami juga berhenti menjelajahi suatu wilayah jika jalur yang kami lalui komputasi

354
00:20:58,501 --> 00:21:02,907
kebetulan menemukan angka nol, yang sebenarnya terjadi sekali untuk contoh di sebelah

355
00:21:02,907 --> 00:21:03,420
kanan ini.

356
00:21:03,420 --> 00:21:07,479
Kejadian langka itu mengganggu kemampuan kita menghitung bilangan berliku,

357
00:21:07,479 --> 00:21:09,320
tapi hei, kita mendapat angka nol.

358
00:21:09,320 --> 00:21:13,320
Dan untuk loop yang nomor belitannya nol, Anda tidak perlu menjelajahinya lebih jauh.

359
00:21:13,320 --> 00:21:18,520
Mungkin mereka punya solusi di dalam, mungkin juga tidak, kami tidak punya jaminan.

360
00:21:18,520 --> 00:21:21,963
Dan membiarkan pemecah persamaan kita melanjutkan dengan cara yang sama,

361
00:21:21,963 --> 00:21:26,020
pada akhirnya persamaan tersebut akan menyatu menjadi banyak nol untuk polinomial ini.

362
00:21:26,020 --> 00:21:29,180
Ngomong-ngomong, bukan suatu kebetulan jika jumlah

363
00:21:29,180 --> 00:21:31,660
total belitan dalam contoh ini adalah 5.

364
00:21:31,660 --> 00:21:38,176
Dengan bilangan kompleks, operasi x ke n secara langsung berhubungan dengan berjalan

365
00:21:38,176 --> 00:21:45,000
mengelilingi asal keluaran sebanyak n kali saat Anda mengelilingi asal masukan satu kali.

366
00:21:45,000 --> 00:21:48,342
Jadi dengan polinomial, untuk masukan yang cukup besar,

367
00:21:48,342 --> 00:21:52,700
setiap suku selain suku utama menjadi tidak signifikan jika dibandingkan.

368
00:21:52,700 --> 00:21:56,668
Jadi setiap polinomial kompleks yang suku utamanya adalah x ke

369
00:21:56,668 --> 00:22:00,700
n mempunyai bilangan belitan n di sekitar loop yang cukup besar.

370
00:22:00,700 --> 00:22:04,095
Dan dengan cara itu, teknologi bilangan berliku kami

371
00:22:04,095 --> 00:22:07,620
menjamin bahwa setiap polinomial kompleks memiliki nol.

372
00:22:07,620 --> 00:22:11,169
Fakta ini sangat penting sehingga para ahli matematika

373
00:22:11,169 --> 00:22:13,880
menyebutnya sebagai teorema dasar aljabar.

374
00:22:13,880 --> 00:22:18,548
Memiliki algoritma untuk menemukan solusi numerik terhadap persamaan seperti ini

375
00:22:18,548 --> 00:22:23,678
sangatlah praktis, namun teorema dasar aljabar adalah contoh yang baik tentang bagaimana

376
00:22:23,678 --> 00:22:27,310
bilangan berliku ini juga cukup berguna pada tingkat teoritis,

377
00:22:27,310 --> 00:22:32,094
menjamin adanya solusi untuk kelas yang luas. persamaan untuk kondisi yang sesuai,

378
00:22:32,094 --> 00:22:34,400
yang lebih disukai para ahli matematika.

379
00:22:34,400 --> 00:22:38,913
Saya akan menunjukkan kepada Anda beberapa penerapan menakjubkan ini dalam konteks

380
00:22:38,913 --> 00:22:43,808
topologi dalam video tindak lanjut, termasuk memperbaiki kesalahan dari video 3blue1Brown

381
00:22:43,808 --> 00:22:44,080
lama.

382
00:22:44,080 --> 00:22:45,080
Yang mana?

383
00:22:45,080 --> 00:22:48,007
Tonton semua videonya, semua yang ada di saluran ini,

384
00:22:48,007 --> 00:22:51,640
dan lihat apakah Anda dapat menemukan kesalahannya terlebih dahulu.

385
00:22:51,640 --> 00:22:55,247
Penulis utama video ini adalah salah satu anggota tim 3blue1 brown terbaru,

386
00:22:55,247 --> 00:22:55,960
Sridhar Ramesh.

