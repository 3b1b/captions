1
00:00:00,000 --> 00:00:06,720
Ada dua hal di sini, topik utama dan topik meta.

2
00:00:06,720 --> 00:00:10,015
Topik utamanya adalah algoritma yang sangat rapi untuk menyelesaikan

3
00:00:10,015 --> 00:00:13,550
persamaan dua dimensi, hal-hal yang memiliki dua bilangan real yang tidak

4
00:00:13,550 --> 00:00:17,420
diketahui, atau juga yang melibatkan satu bilangan kompleks yang tidak diketahui.

5
00:00:17,420 --> 00:00:20,597
Jadi misalnya, jika Anda ingin mencari akar kompleks dari sebuah

6
00:00:20,597 --> 00:00:23,871
polinomial, atau mungkin beberapa dari angka nol jutaan dolar dari

7
00:00:23,871 --> 00:00:27,000
fungsi Riemann zeta, algoritma ini akan melakukannya untuk Anda.

8
00:00:27,000 --> 00:00:30,520
Dan metode ini sangat cantik, karena melibatkan banyak warna.

9
00:00:30,520 --> 00:00:33,812
Dan yang lebih penting, ide inti yang mendasarinya berlaku untuk

10
00:00:33,812 --> 00:00:36,902
semua jenis matematika di luar algoritma untuk menyelesaikan

11
00:00:36,902 --> 00:00:40,600
persamaan ini, termasuk sedikit topologi, yang akan saya bicarakan nanti.

12
00:00:40,600 --> 00:00:44,485
Tapi apa yang membuat ini bernilai sekitar 20 menit dari waktu Anda adalah bahwa ini

13
00:00:44,485 --> 00:00:48,188
mengilustrasikan pelajaran yang jauh lebih berguna secara umum dalam matematika,

14
00:00:48,188 --> 00:00:52,120
yaitu mencoba mendefinisikan konstruksi yang dapat disusun dengan baik satu sama lain.

15
00:00:52,120 --> 00:00:55,460
Anda akan melihat apa yang saya maksud dengan itu seiring berjalannya cerita.

16
00:00:55,460 --> 00:00:58,657
Untuk memotivasi kasus dengan fungsi yang memiliki masukan 2d dan

17
00:00:58,657 --> 00:01:01,902
keluaran 2d, mari kita mulai dengan lebih sederhana, dengan fungsi

18
00:01:01,902 --> 00:01:05,100
yang hanya mengambil bilangan real dan mengeluarkan bilangan real.

19
00:01:05,100 --> 00:01:08,199
Jika Anda ingin mengetahui kapan suatu fungsi f dari x sama dengan

20
00:01:08,199 --> 00:01:11,021
fungsi g lainnya dari x, Anda mungkin menganggap ini sebagai

21
00:01:11,021 --> 00:01:14,260
pencarian kapan grafik dari fungsi-fungsi tersebut berpotongan, bukan?

22
00:01:14,260 --> 00:01:19,340
Maksud saya, itu memberi Anda masukan di mana kedua fungsi memiliki keluaran yang sama.

23
00:01:19,340 --> 00:01:22,531
Untuk mengambil contoh yang sangat sederhana, bayangkan f dari

24
00:01:22,531 --> 00:01:25,520
x adalah x kuadrat, dan g dari x adalah fungsi konstanta 2.

25
00:01:25,520 --> 00:01:29,620
Dengan kata lain, Anda ingin mencari akar kuadrat dari 2.

26
00:01:29,620 --> 00:01:33,905
Bahkan jika Anda hampir tidak tahu apa-apa tentang mencari akar kuadrat, Anda

27
00:01:33,905 --> 00:01:38,135
mungkin bisa melihat bahwa 1 kuadrat lebih kecil dari 2, dan 2 kuadrat lebih

28
00:01:38,135 --> 00:01:42,640
besar dari 2, jadi Anda sadar, ah, akan ada solusi di antara kedua nilai tersebut.

29
00:01:42,640 --> 00:01:44,807
Lalu jika Anda ingin mempersempitnya lebih jauh,

30
00:01:44,807 --> 00:01:47,240
mungkin Anda mencoba mengkuadratkan titik tengahnya, 1.

31
00:01:47,240 --> 00:01:47,740
5.

32
00:01:47,740 --> 00:01:49,085
Ini keluar menjadi 2.

33
00:01:49,085 --> 00:01:54,000
25, agak terlalu tinggi, jadi Anda sebaiknya fokus pada wilayah antara 1 dan 1.

34
00:01:54,000 --> 00:01:54,940
5.

35
00:01:54,940 --> 00:01:58,492
Dan seterusnya, Anda mungkin dapat melihat bagaimana hal ini

36
00:01:58,492 --> 00:02:01,987
akan terus berlanjut, Anda akan terus menghitung pada titik

37
00:02:01,987 --> 00:02:05,540
tengah dan kemudian membagi ruang pencarian Anda menjadi dua.

38
00:02:05,540 --> 00:02:09,153
Cara lain untuk memikirkan hal ini, yang akan memudahkan kita ketika kita

39
00:02:09,153 --> 00:02:12,815
mencapai dimensi yang lebih tinggi, adalah dengan berfokus pada pertanyaan

40
00:02:12,815 --> 00:02:16,380
ekuivalen mengenai kapan selisih antara kedua fungsi ini sama dengan nol.

41
00:02:16,380 --> 00:02:20,200
Dalam istilah tersebut, kami menemukan wilayah masukan yang

42
00:02:20,200 --> 00:02:24,020
perbedaannya negatif di satu sisi, dan positif di sisi lain.

43
00:02:24,020 --> 00:02:27,916
Kami membaginya menjadi dua, dan bagian yang kami persempit perhatiannya

44
00:02:27,916 --> 00:02:31,600
adalah bagian yang titik terluarnya memiliki tanda yang berbeda-beda.

45
00:02:31,600 --> 00:02:35,317
Dengan cara ini, kami dapat terus berjalan selamanya, mengambil setiap

46
00:02:35,317 --> 00:02:39,139
wilayah dengan tanda-tanda yang berbeda-beda di perbatasannya, menemukan

47
00:02:39,139 --> 00:02:42,804
wilayah yang lebih kecil di antara bagian-bagiannya, mengetahui bahwa

48
00:02:42,804 --> 00:02:46,260
pada akhirnya kami harus mempersempit titik yang akan menjadi nol.

49
00:02:46,260 --> 00:02:50,637
Singkatnya, menyelesaikan persamaan selalu bisa dirumuskan sebagai menemukan kapan

50
00:02:50,637 --> 00:02:55,172
fungsi tertentu sama dengan nol, dan untuk melakukannya, kita memiliki heuristik ini,

51
00:02:55,172 --> 00:02:59,655
jika f positif di satu titik dan negatif di titik lain, Anda dapat mencari di antara

52
00:02:59,655 --> 00:03:03,980
di mana itu nol, setidaknya jika semuanya berubah lancar tanpa lompatan tiba-tiba.

53
00:03:03,980 --> 00:03:07,719
Hal menakjubkan yang ingin saya tunjukkan kepada Anda adalah Anda dapat

54
00:03:07,719 --> 00:03:11,096
memperluas pemikiran seperti ini ke dalam persamaan dua dimensi,

55
00:03:11,096 --> 00:03:14,940
persamaan antara fungsi yang masukan dan keluarannya keduanya dua dimensi.

56
00:03:14,940 --> 00:03:18,225
Misalnya, bilangan kompleks berbentuk 2D, dan alat yang kami

57
00:03:18,225 --> 00:03:21,780
kembangkan ini sempurna untuk menemukan solusi persamaan kompleks.

58
00:03:21,780 --> 00:03:25,509
Sekarang, karena kita akan banyak membicarakan fungsi-fungsi 2D ini, mari kita

59
00:03:25,509 --> 00:03:29,380
mengambil langkah singkat dan mempertimbangkan bagaimana kita mengilustrasikannya.

60
00:03:29,380 --> 00:03:33,238
Membuat grafik fungsi dengan input 2D dan output 2D memerlukan

61
00:03:33,238 --> 00:03:37,220
empat dimensi, dan itu tidak akan berfungsi dengan baik di dunia

62
00:03:37,220 --> 00:03:41,140
3D pada layar 2D, namun kami masih memiliki beberapa opsi bagus.

63
00:03:41,140 --> 00:03:46,020
Salah satunya adalah dengan melihat ruang masukan dan ruang keluaran secara berdampingan.

64
00:03:46,020 --> 00:03:49,444
Setiap titik di ruang masukan berpindah ke titik tertentu di ruang

65
00:03:49,444 --> 00:03:52,971
keluaran, dan saya dapat menunjukkan bagaimana pergerakan di sekitar

66
00:03:52,971 --> 00:03:57,060
titik masukan tersebut berhubungan dengan pergerakan tertentu di ruang keluaran.

67
00:03:57,060 --> 00:04:00,396
Semua fungsi yang kita pertimbangkan akan bersifat kontinu,

68
00:04:00,396 --> 00:04:03,845
dalam artian perubahan kecil pada masukan hanya sesuai dengan

69
00:04:03,845 --> 00:04:07,460
perubahan kecil pada keluaran, tidak ada lompatan yang tiba-tiba.

70
00:04:07,460 --> 00:04:12,304
Pilihan lain yang kita miliki adalah membayangkan panah dari asal ruang keluaran ke

71
00:04:12,304 --> 00:04:17,380
titik keluaran tersebut, dan melampirkan versi miniatur panah tersebut ke titik masukan.

72
00:04:17,380 --> 00:04:20,550
Sekilas hal ini dapat memberi kita gambaran tentang ke mana

73
00:04:20,550 --> 00:04:23,774
perginya suatu titik masukan tertentu, atau ke mana perginya

74
00:04:23,774 --> 00:04:27,580
banyak titik masukan yang berbeda dengan menggambar bidang vektor penuh.

75
00:04:27,580 --> 00:04:30,819
Dan sayangnya ketika Anda melakukan ini di banyak titik, hal ini bisa

76
00:04:30,819 --> 00:04:34,197
menjadi sangat berantakan, jadi di sini izinkan saya membuat semua panah

77
00:04:34,197 --> 00:04:37,900
berukuran sama, dan ini berarti kita bisa mengetahui arah setiap titik keluaran.

78
00:04:37,900 --> 00:04:40,862
Namun mungkin cara tercantik untuk mengilustrasikan fungsi dua

79
00:04:40,862 --> 00:04:44,107
dimensi, dan yang paling sering kita gunakan dalam video ini, adalah

80
00:04:44,107 --> 00:04:47,400
dengan mengasosiasikan setiap titik dalam ruang keluaran dengan warna.

81
00:04:47,400 --> 00:04:51,690
Di sini kita menggunakan warna, yaitu warna yang jatuh di sepanjang pelangi atau

82
00:04:51,690 --> 00:04:55,557
roda warna, untuk menyesuaikan dengan arah menjauhi titik asal, dan kita

83
00:04:55,557 --> 00:05:00,060
menggunakan kegelapan atau kecerahan untuk menyesuaikan dengan jarak dari titik asal.

84
00:05:00,060 --> 00:05:03,503
Misalnya, dengan fokus pada rangkaian keluaran ini, semua titik ini

85
00:05:03,503 --> 00:05:06,896
berwarna merah, namun titik yang lebih dekat ke titik asal sedikit

86
00:05:06,896 --> 00:05:10,340
lebih gelap, dan titik yang lebih jauh menjadi sedikit lebih terang.

87
00:05:10,340 --> 00:05:14,660
Dan dengan fokus pada rangkaian keluaran ini, semua titik berwarna hijau, dan sekali

88
00:05:14,660 --> 00:05:18,980
lagi, lebih dekat ke titik asal berarti lebih gelap, lebih jauh berarti lebih terang.

89
00:05:18,980 --> 00:05:22,300
Dan seterusnya, yang kita lakukan di sini hanyalah memberikan

90
00:05:22,300 --> 00:05:25,300
warna tertentu pada setiap arah, semuanya terus berubah.

91
00:05:25,300 --> 00:05:28,598
Anda mungkin melihat perbedaan kegelapan dan kecerahan di sini

92
00:05:28,598 --> 00:05:32,001
cukup halus, namun untuk video ini, yang kami pedulikan hanyalah

93
00:05:32,001 --> 00:05:35,300
arah keluarannya, bukan besarnya, warnanya, bukan kecerahannya.

94
00:05:35,300 --> 00:05:39,953
Satu hal penting tentang kecerahan yang harus Anda perhatikan adalah bahwa di dekat

95
00:05:39,953 --> 00:05:44,440
titik asal, yang tidak memiliki arah tertentu, semua warna memudar menjadi hitam.

96
00:05:44,440 --> 00:05:48,755
Jadi untuk memikirkan fungsi, setelah kita menentukan warna untuk setiap

97
00:05:48,755 --> 00:05:53,012
keluaran, kita dapat memvisualisasikan fungsi 2D dengan mewarnai setiap

98
00:05:53,012 --> 00:05:57,860
titik di ruang masukan berdasarkan warna titik tempatnya berada di ruang keluaran.

99
00:05:57,860 --> 00:06:02,694
Saya suka membayangkan banyak titik berbeda dari ruang masukan yang melompat ke keluaran

100
00:06:02,694 --> 00:06:07,257
yang sesuai di ruang keluaran, kemudian dicat berdasarkan warna titik di mana titik

101
00:06:07,257 --> 00:06:11,820
tersebut mendarat, dan kemudian melompat kembali ke tempat asalnya di ruang masukan.

102
00:06:11,820 --> 00:06:14,200
Dengan melakukan hal ini untuk setiap titik di ruang masukan, Anda

103
00:06:14,200 --> 00:06:16,617
dapat memahaminya hanya dengan melihat ruang masukan tersebut untuk

104
00:06:16,617 --> 00:06:19,140
mengetahui secara kasar di mana fungsi tersebut mengambil setiap titik.

105
00:06:19,140 --> 00:06:24,631
Misalnya, garis titik merah muda di sebelah kiri ini memberi tahu kita bahwa semua titik

106
00:06:24,631 --> 00:06:30,000
tersebut dipetakan di suatu tempat dalam arah merah muda, di kiri bawah ruang keluaran.

107
00:06:30,000 --> 00:06:33,390
Juga tiga titik yang berwarna hitam dengan banyak

108
00:06:33,390 --> 00:06:37,120
warna di sekelilingnya adalah titik yang menuju ke nol.

109
00:06:37,120 --> 00:06:43,725
Baiklah, sama seperti kasus 1D, penyelesaian persamaan fungsi 2D selalu

110
00:06:43,725 --> 00:06:49,780
dapat diubah dengan menanyakan kapan suatu fungsi sama dengan nol.

111
00:06:49,780 --> 00:06:54,873
Jadi itulah tantangan kita saat ini, membuat algoritme yang

112
00:06:54,873 --> 00:07:00,900
menemukan titik masukan mana dari fungsi 2D tertentu yang bernilai nol.

113
00:07:00,900 --> 00:07:04,891
Anda mungkin menunjukkan bahwa jika Anda melihat peta warna seperti ini dengan melihat

114
00:07:04,891 --> 00:07:08,700
titik-titik hitam tersebut, Anda sudah mengetahui di mana angka nol dari fungsinya.

115
00:07:08,700 --> 00:07:11,460
Jadi apakah itu masuk hitungan?

116
00:07:11,460 --> 00:07:16,039
Ingatlah bahwa untuk membuat diagram seperti ini, kita telah meminta komputer

117
00:07:16,039 --> 00:07:20,265
menghitung fungsi di semua piksel pada bidang, namun tujuan kita adalah

118
00:07:20,265 --> 00:07:24,844
menemukan algoritma yang lebih efisien yang hanya memerlukan komputasi fungsi

119
00:07:24,844 --> 00:07:29,600
pada titik sesedikit mungkin. , hanya memiliki pandangan terbatas terhadap warna.

120
00:07:29,600 --> 00:07:32,436
Dan juga dari sudut pandang yang lebih teoritis, akan lebih

121
00:07:32,436 --> 00:07:35,179
baik jika memiliki konstruksi umum yang memberi tahu kita

122
00:07:35,179 --> 00:07:38,300
kondisi apakah ada angka nol atau tidak di dalam wilayah tertentu.

123
00:07:38,300 --> 00:07:43,640
Ingat, dalam satu dimensi, pemahaman utamanya adalah jika suatu fungsi kontinu bernilai

124
00:07:43,640 --> 00:07:48,920
positif di satu titik dan negatif di titik lain, maka di antara keduanya pasti ada nol.

125
00:07:48,920 --> 00:07:50,960
Jadi bagaimana kita memperluasnya menjadi dua dimensi?

126
00:07:50,960 --> 00:07:55,180
Kita memerlukan semacam analogi dalam membicarakan tanda.

127
00:07:55,180 --> 00:07:59,140
Salah satu cara untuk memikirkan tentang tanda-tanda adalah petunjuk arah.

128
00:07:59,140 --> 00:08:01,761
Positif berarti Anda menunjuk ke kanan sepanjang garis

129
00:08:01,761 --> 00:08:04,240
bilangan, dan negatif berarti Anda menunjuk ke kiri.

130
00:08:04,240 --> 00:08:08,538
Besaran dua dimensi juga memiliki arah, tetapi bagi mereka pilihannya jauh

131
00:08:08,538 --> 00:08:12,780
lebih luas, mereka dapat menunjuk ke mana saja dalam berbagai kemungkinan.

132
00:08:12,780 --> 00:08:18,025
Jadi sama seperti dalam satu dimensi kita menanyakan apakah suatu fungsi tertentu

133
00:08:18,025 --> 00:08:23,142
bernilai positif atau negatif pada batas suatu rentang, yang hanya terdiri dari

134
00:08:23,142 --> 00:08:28,451
dua titik, untuk fungsi 2d kita akan melihat batas suatu wilayah, yang mana adalah

135
00:08:28,451 --> 00:08:33,760
sebuah loop, dan tanyakan tentang arah keluaran fungsi di sepanjang batas tersebut.

136
00:08:33,760 --> 00:08:37,968
Misalnya, kita melihat bahwa sepanjang putaran di sekitar angka nol ini, keluaran

137
00:08:37,968 --> 00:08:41,971
melewati setiap arah yang mungkin, semua warna pelangi, merah, kuning, hijau,

138
00:08:41,971 --> 00:08:45,820
biru, kembali ke merah, dan segala sesuatu di antaranya di sepanjang jalan.

139
00:08:45,820 --> 00:08:49,105
Namun di sepanjang perulangan ini, tanpa angka nol di dalamnya,

140
00:08:49,105 --> 00:08:52,237
keluarannya tidak melewati semua warna, ia melewati beberapa

141
00:08:52,237 --> 00:08:55,420
warna jingga, namun tidak pernah, katakanlah, hijau atau biru.

142
00:08:55,420 --> 00:08:57,237
Dan ini cukup menjanjikan, hal ini mirip dengan

143
00:08:57,237 --> 00:08:59,320
bagaimana segala sesuatunya bekerja dalam satu dimensi.

144
00:08:59,320 --> 00:09:03,640
Mungkin dengan cara yang sama jika fungsi 1d mengambil kedua tanda yang

145
00:09:03,640 --> 00:09:08,080
mungkin pada batas wilayah 1d, ada angka nol di suatu tempat di dalamnya,

146
00:09:08,080 --> 00:09:12,400
kita dapat berhipotesis bahwa jika fungsi 2d menghasilkan keluaran dari

147
00:09:12,400 --> 00:09:16,540
semua arah yang mungkin, semua kemungkinan warna, di sepanjang batas

148
00:09:16,540 --> 00:09:20,980
wilayah 2d, maka di suatu tempat di dalam wilayah itu harus menuju ke nol.

149
00:09:20,980 --> 00:09:24,059
Jadi itulah tebakan kami, dan luangkan waktu sejenak untuk

150
00:09:24,059 --> 00:09:27,660
memikirkan apakah hal ini benar, dan jika demikian, mengapa demikian.

151
00:09:27,660 --> 00:09:30,643
Jika kita mulai memikirkan perulangan kecil di sekitar titik

152
00:09:30,643 --> 00:09:33,676
masukan, kita tahu bahwa karena semuanya kontinu, fungsi kita

153
00:09:33,676 --> 00:09:36,660
membawanya ke perulangan kecil di dekat keluaran yang sesuai.

154
00:09:36,660 --> 00:09:41,140
Tapi lihat, untuk sebagian besar loop kecil, warna keluarannya bervariasi.

155
00:09:41,140 --> 00:09:44,030
Jika Anda memilih titik keluaran selain nol, dan menggambar

156
00:09:44,030 --> 00:09:47,017
lingkaran yang cukup rapat di dekatnya, semua warna lingkaran

157
00:09:47,017 --> 00:09:49,860
akan memiliki warna yang hampir sama dengan titik tersebut.

158
00:09:49,860 --> 00:09:54,178
Lingkaran ketat di sini semuanya berwarna kebiruan, lingkaran ketat di sini

159
00:09:54,178 --> 00:09:58,440
semuanya kekuningan, Anda tentu tidak akan mendapatkan semua warna pelangi.

160
00:09:58,440 --> 00:10:02,675
Satu-satunya titik di mana Anda dapat mengencangkan loop di sekelilingnya sambil

161
00:10:02,675 --> 00:10:07,120
tetap mendapatkan semua warna adalah titik asal yang tidak berwarna, nol itu sendiri.

162
00:10:07,120 --> 00:10:11,952
Jadi memang benar bahwa jika Anda memiliki loop yang melewati setiap warna pelangi,

163
00:10:11,952 --> 00:10:17,129
mengencangkan dan mengencangkan, menyempit pada suatu titik, maka titik tersebut pastilah

164
00:10:17,129 --> 00:10:17,360
nol.

165
00:10:17,360 --> 00:10:22,360
Jadi mari kita siapkan pemecah persamaan 2d seperti pemecah persamaan satu dimensi.

166
00:10:22,360 --> 00:10:26,621
Saat kita menemukan wilayah luas yang batasnya melewati setiap warna,

167
00:10:26,621 --> 00:10:30,640
bagilah menjadi dua, lalu lihat warna pada batas setiap bagiannya.

168
00:10:30,640 --> 00:10:34,722
Pada contoh yang ditunjukkan di sini, batas di bagian kiri tidak mencakup

169
00:10:34,722 --> 00:10:39,080
semua warna, misalnya tidak ada titik yang dipetakan ke arah oranye kekuningan.

170
00:10:39,080 --> 00:10:41,212
Jadi saya akan menghapus area ini dengan warna abu-abu sebagai

171
00:10:41,212 --> 00:10:43,480
cara untuk mengatakan bahwa kami tidak ingin mencarinya lebih jauh.

172
00:10:43,480 --> 00:10:47,192
Bagian kanan melewati semua warna, menghabiskan banyak waktu ke arah

173
00:10:47,192 --> 00:10:51,120
hijau, kemudian melewati kuning oranye merah, serta biru ungu merah muda.

174
00:10:51,120 --> 00:10:54,287
Sekarang ingat, artinya titik-titik batas ini

175
00:10:54,287 --> 00:10:57,800
dipetakan ke keluaran dari semua arah yang mungkin.

176
00:10:57,800 --> 00:11:02,900
Makanya kita telusuri lebih jauh lagi, dipecah lagi dan dicek batas tiap wilayahnya.

177
00:11:02,900 --> 00:11:07,000
Batas atas semuanya hijau, jadi kita berhenti mencari di sana.

178
00:11:07,000 --> 00:11:10,500
Tapi bagian bawahnya cukup berwarna sehingga layak untuk dibagi lagi.

179
00:11:10,500 --> 00:11:12,420
Dan terus seperti ini.

180
00:11:12,420 --> 00:11:16,594
Periksa subwilayah mana yang memiliki batas yang mencakup semua kemungkinan warna,

181
00:11:16,594 --> 00:11:20,769
yang berarti titik-titik batas tersebut akan dipetakan ke semua arah yang mungkin,

182
00:11:20,769 --> 00:11:24,994
dan terus potong wilayah tersebut menjadi dua seperti yang kita lakukan untuk kasus

183
00:11:24,994 --> 00:11:29,320
satu dimensi, yang pada akhirnya membawa kita ke nol pada fungsi- Oh, tunggu sebentar.

184
00:11:29,320 --> 00:11:30,320
Apa yang terjadi disini?

185
00:11:30,320 --> 00:11:33,845
Tak satu pun dari subdivisi terakhir di kanan bawah melewati semua

186
00:11:33,845 --> 00:11:37,529
warna, sehingga algoritme kami berhenti karena tidak ingin menelusuri

187
00:11:37,529 --> 00:11:41,160
salah satu dari warna tersebut, namun juga tidak menemukan angka nol.

188
00:11:41,160 --> 00:11:43,720
Oke, jelas ada sesuatu yang salah di sini.

189
00:11:43,720 --> 00:11:46,680
Dan tidak apa-apa, melakukan kesalahan adalah hal yang biasa dalam mengerjakan matematika.

190
00:11:46,680 --> 00:11:50,351
Jika kita melihat ke belakang, kita mempunyai hipotesis ini, dan hipotesis

191
00:11:50,351 --> 00:11:53,680
ini membawa kita pada algoritma yang diusulkan ini, jadi kita salah.

192
00:11:53,680 --> 00:11:56,668
Dan menjadi ahli dalam matematika bukan berarti menjadi benar pada kali

193
00:11:56,668 --> 00:11:59,490
pertama, namun tentang memiliki ketahanan untuk melihat ke belakang

194
00:11:59,490 --> 00:12:02,520
secara cermat dan memahami kesalahan, serta memahami cara memperbaikinya.

195
00:12:02,520 --> 00:12:05,799
Sekarang masalahnya adalah kita mempunyai wilayah yang batasnya melewati

196
00:12:05,799 --> 00:12:08,900
setiap warna, tapi ketika kita membaginya di tengah, tidak ada batas

197
00:12:08,900 --> 00:12:12,134
subwilayah yang melewati setiap warna, kita tidak punya pilihan ke mana

198
00:12:12,134 --> 00:12:15,280
harus terus mencari selanjutnya, dan itu memecahkan angka nol. penemu.

199
00:12:15,280 --> 00:12:18,120
Sekarang dalam satu dimensi, hal seperti ini tidak pernah terjadi.

200
00:12:18,120 --> 00:12:21,932
Setiap kali Anda memiliki interval yang titik akhirnya memiliki

201
00:12:21,932 --> 00:12:25,625
tanda berbeda, jika Anda membaginya, Anda dijamin mendapatkan

202
00:12:25,625 --> 00:12:29,200
subinterval yang titik akhirnya juga memiliki tanda berbeda.

203
00:12:29,200 --> 00:12:32,485
Atau dengan kata lain, setiap kali Anda memiliki dua interval yang titik

204
00:12:32,485 --> 00:12:35,545
akhirnya tidak berubah tanda, jika Anda menggabungkannya, Anda akan

205
00:12:35,545 --> 00:12:39,280
mendapatkan interval yang lebih besar yang titik akhirnya juga tidak berubah tanda.

206
00:12:39,280 --> 00:12:43,026
Namun dalam dua dimensi, kita bisa menemukan dua wilayah yang batasnya

207
00:12:43,026 --> 00:12:46,615
tidak menembus setiap warna, namun batas-batasnya digabungkan untuk

208
00:12:46,615 --> 00:12:49,940
menghasilkan suatu wilayah yang batasnya menembus setiap warna.

209
00:12:49,940 --> 00:12:53,740
Dan dengan cara ini, algoritma zero-finding yang kami usulkan gagal.

210
00:12:53,740 --> 00:12:58,303
Faktanya, jika dipikir-pikir, Anda dapat menemukan lingkaran besar yang

211
00:12:58,303 --> 00:13:03,120
batasnya melewati setiap warna yang mungkin tanpa ada angka nol di dalamnya.

212
00:13:03,120 --> 00:13:07,914
Hal ini tidak berarti bahwa kami salah dalam klaim kami tentang loop kecil ketika kami

213
00:13:07,914 --> 00:13:12,819
mengatakan bahwa loop yang selalu menyempit pada setiap warna harus menyempit pada angka

214
00:13:12,819 --> 00:13:13,040
nol.

215
00:13:13,040 --> 00:13:15,480
Namun yang membuat kami kacau adalah properti yang

216
00:13:15,480 --> 00:13:18,829
melakukan-perbatasan-saya-melintasi-setiap-warna-atau-tidak ini tidak

217
00:13:18,829 --> 00:13:23,040
digabungkan dengan cara yang bagus dan dapat diprediksi saat Anda menggabungkan wilayah.

218
00:13:23,040 --> 00:13:31,094
Tapi jangan khawatir, ternyata kita bisa memodifikasinya sedikit menjadi properti

219
00:13:31,094 --> 00:13:38,560
yang lebih canggih yang digabungkan untuk memberikan apa yang kita inginkan.

220
00:13:38,560 --> 00:13:41,645
Idenya adalah daripada sekadar menanyakan apakah kita dapat menemukan warna

221
00:13:41,645 --> 00:13:44,730
pada titik tertentu di sepanjang putaran, mari kita perhatikan lebih cermat

222
00:13:44,730 --> 00:13:48,100
bagaimana warna-warna ini berubah saat kita berjalan mengelilingi putaran tersebut.

223
00:13:48,100 --> 00:13:50,060
Izinkan saya menunjukkan kepada Anda apa yang saya maksud dengan sebuah contoh.

224
00:13:50,060 --> 00:13:54,120
Saya akan menyimpan roda warna kecil di pojok sini untuk membantu kita melacaknya.

225
00:13:54,120 --> 00:13:57,774
Ketika warna-warna di sepanjang jalur masukan bergerak melalui

226
00:13:57,774 --> 00:14:01,544
pelangi ke arah tertentu, dari merah ke kuning, kuning ke hijau,

227
00:14:01,544 --> 00:14:05,720
hijau ke biru, atau biru ke merah, keluarannya berayun searah jarum jam.

228
00:14:05,720 --> 00:14:09,351
Namun sebaliknya, jika warna bergerak berlawanan arah dalam

229
00:14:09,351 --> 00:14:13,165
pelangi, dari biru ke hijau, hijau ke kuning, kuning ke merah,

230
00:14:13,165 --> 00:14:17,160
atau merah ke biru, keluarannya berayun berlawanan arah jarum jam.

231
00:14:17,160 --> 00:14:21,482
Jadi berjalan di sepanjang jalur pendek ini, warna berputar seperlima

232
00:14:21,482 --> 00:14:25,989
searah jarum jam melalui roda warna, dan berjalan di sepanjang jalur ini

233
00:14:25,989 --> 00:14:30,620
di sini, warna berputar seperlima lagi searah jarum jam melalui roda warna.

234
00:14:30,620 --> 00:14:34,831
Tentu saja, ini berarti jika Anda melewati kedua jalur tersebut, satu demi

235
00:14:34,831 --> 00:14:39,380
satu, warnanya akan berputar sebanyak dua perlima putaran penuh searah jarum jam.

236
00:14:39,380 --> 00:14:42,961
Jumlah total penggulungan semakin bertambah, dan ini akan menjadi

237
00:14:42,961 --> 00:14:47,140
kuncinya, ini adalah jenis penggabungan langsung yang akan berguna bagi kita.

238
00:14:47,140 --> 00:14:51,083
Saat saya menyebutkan jumlah total belitan, saya ingin Anda membayangkan

239
00:14:51,083 --> 00:14:54,918
sebuah odometer kuno yang berdetak ke depan saat panah berputar searah

240
00:14:54,918 --> 00:14:58,700
jarum jam, namun mundur saat panah berputar berlawanan arah jarum jam.

241
00:14:58,700 --> 00:15:03,020
Jadi belitan berlawanan arah jarum jam dihitung sebagai belitan negatif searah jarum jam.

242
00:15:03,020 --> 00:15:05,920
Keluarannya mungkin banyak, tetapi jika sebagian

243
00:15:05,920 --> 00:15:08,940
dari putaran itu berlawanan arah, maka akan hilang.

244
00:15:08,940 --> 00:15:12,335
Misalnya, jika Anda bergerak maju di sepanjang jalur ini, dan kemudian

245
00:15:12,335 --> 00:15:15,778
bergerak mundur di sepanjang jalur yang sama, jumlah total belitan akan

246
00:15:15,778 --> 00:15:19,269
menjadi nol, gerakan mundur secara harafiah memundurkan warna-warna yang

247
00:15:19,269 --> 00:15:22,952
terlihat sebelumnya, membalikkan semua belitan sebelumnya, dan mengembalikan

248
00:15:22,952 --> 00:15:26,300
warna yang terlihat sebelumnya. odometer kembali ke tempat dimulainya.

249
00:15:26,300 --> 00:15:30,480
Untuk tujuan kita, kita akan sangat memperhatikan lilitan sepanjang loop.

250
00:15:30,480 --> 00:15:34,280
Sebagai contoh, katakanlah kita mengelilingi seluruh putaran ini searah jarum jam.

251
00:15:34,280 --> 00:15:38,490
Keluaran yang kita temui berputar sebanyak tiga kali putaran

252
00:15:38,490 --> 00:15:42,701
penuh searah jarum jam, warna-warna berayun melalui pelangi,

253
00:15:42,701 --> 00:15:47,120
secara berurutan, dari merah ke merah lagi, lalu lagi, dan lagi.

254
00:15:47,120 --> 00:15:50,759
Dalam jargon yang digunakan ahli matematika, kita mengatakan

255
00:15:50,759 --> 00:15:54,100
bahwa sepanjang loop ini, jumlah total belitan adalah 3.

256
00:15:54,100 --> 00:15:57,160
Untuk perulangan yang lain, bisa berupa bilangan bulat lainnya,

257
00:15:57,160 --> 00:16:00,651
mungkin bilangan yang lebih besar jika keluarannya berputar berkali-kali

258
00:16:00,651 --> 00:16:03,808
saat masukan berputar dalam satu putaran, atau bisa juga bilangan

259
00:16:03,808 --> 00:16:07,060
yang lebih kecil jika keluarannya hanya berputar satu atau dua kali.

260
00:16:07,060 --> 00:16:11,083
Atau bilangan belitan itu bahkan bisa berupa bilangan bulat negatif, jika keluarannya

261
00:16:11,083 --> 00:16:15,200
berayun berlawanan arah jarum jam saat kita berjalan mengelilingi loop searah jarum jam.

262
00:16:15,200 --> 00:16:19,720
Namun sepanjang loop mana pun, jumlah total belitan ini harus berupa bilangan bulat.

263
00:16:19,720 --> 00:16:22,662
Maksud saya, saat Anda kembali ke awal, Anda akan

264
00:16:22,662 --> 00:16:25,840
mendapatkan hasil yang sama seperti saat Anda memulai.

265
00:16:25,840 --> 00:16:29,895
Secara kebetulan, jika suatu jalur benar-benar berisi titik di mana keluarannya

266
00:16:29,895 --> 00:16:33,848
tepat nol, maka secara teknis Anda tidak dapat menentukan bilangan belitan di

267
00:16:33,848 --> 00:16:37,600
sepanjang jalur tersebut, karena keluarannya tidak memiliki arah tertentu.

268
00:16:37,600 --> 00:16:41,450
Ini tidak akan menjadi masalah bagi kami, karena seluruh tujuan kami adalah

269
00:16:41,450 --> 00:16:45,200
menemukan angka nol, jadi jika hal ini terjadi, kami hanya beruntung saja.

270
00:16:45,200 --> 00:16:49,925
Hal utama yang perlu diperhatikan tentang angka-angka berliku ini adalah angka-angka

271
00:16:49,925 --> 00:16:54,706
tersebut bertambah dengan baik saat Anda menggabungkan jalur menjadi jalur yang lebih

272
00:16:54,706 --> 00:16:55,040
besar.

273
00:16:55,040 --> 00:16:57,733
Namun yang sebenarnya kita inginkan adalah angka-angka yang berkelok-kelok

274
00:16:57,733 --> 00:17:00,354
di sepanjang perbatasan suatu wilayah dapat bertambah dengan baik ketika

275
00:17:00,354 --> 00:17:03,120
kita menggabungkan wilayah-wilayah tersebut menjadi wilayah yang lebih besar.

276
00:17:03,120 --> 00:17:06,320
Jadi, apakah kita memiliki properti itu?

277
00:17:06,320 --> 00:17:09,600
Nah, lihatlah.

278
00:17:09,600 --> 00:17:13,697
Bilangan belitan searah jarum jam mengelilingi wilayah di sebelah

279
00:17:13,697 --> 00:17:17,920
kiri ini adalah jumlah bilangan belitan dari keempat jalur tersebut.

280
00:17:17,920 --> 00:17:21,775
Dan lilitan yang kita putar searah jarum jam mengelilingi wilayah di sebelah

281
00:17:21,775 --> 00:17:25,480
kanan ini adalah jumlah dari bilangan lilitan dari keempat jalur tersebut.

282
00:17:25,480 --> 00:17:28,282
Dan ketika kita menggabungkan kedua wilayah tersebut menjadi satu

283
00:17:28,282 --> 00:17:31,000
wilayah yang lebih besar, sebagian besar jalur tersebut menjadi

284
00:17:31,000 --> 00:17:33,760
bagian dari perbatasan wilayah yang lebih besar searah jarum jam.

285
00:17:33,760 --> 00:17:36,040
Dan adapun dua jalur yang tidak?

286
00:17:36,040 --> 00:17:39,600
Mereka membatalkan dengan sempurna, salah satunya justru kebalikannya,

287
00:17:39,600 --> 00:17:42,660
pemutaran ulang yang lain seperti yang kita lihat sebelumnya.

288
00:17:42,660 --> 00:17:45,864
Jadi angka-angka yang berkelok-kelok di sepanjang batas

289
00:17:45,864 --> 00:17:48,840
wilayah akan bertambah sesuai dengan keinginan kita.

290
00:17:48,840 --> 00:17:53,028
Catatan tambahan, alasan tentang batas berorientasi yang dijumlahkan dengan baik

291
00:17:53,028 --> 00:17:57,320
seperti ini banyak muncul dalam matematika, dan sering kali disebut teorema Stokes.

292
00:17:57,320 --> 00:18:00,363
Anda yang pernah mempelajari kalkulus multivariabel

293
00:18:00,363 --> 00:18:02,880
mungkin mengenalinya dari konteks tersebut.

294
00:18:02,880 --> 00:18:05,313
Jadi sekarang, akhirnya, dengan berlikunya angka-angka di

295
00:18:05,313 --> 00:18:08,040
tangan, kita dapat kembali ke tujuan penyelesaian persamaan kita.

296
00:18:08,040 --> 00:18:12,056
Masalah dengan wilayah yang kita lihat sebelumnya adalah meskipun

297
00:18:12,056 --> 00:18:16,620
batasnya melewati semua kemungkinan warna, bilangan belitan sebenarnya nol.

298
00:18:16,620 --> 00:18:21,607
Outputnya berputar sekitar setengah, dari kuning ke merah, dan kemudian mulai berputar

299
00:18:21,607 --> 00:18:26,594
berlawanan arah jarum jam kembali ke arah yang lain, kemudian melanjutkan melalui biru

300
00:18:26,594 --> 00:18:31,352
dan mencapai merah dari arah lain, semuanya sedemikian rupa sehingga total belitan

301
00:18:31,352 --> 00:18:32,040
menjadi nol.

302
00:18:32,040 --> 00:18:35,394
Tetapi jika Anda menemukan sebuah loop yang tidak hanya mengenai setiap warna,

303
00:18:35,394 --> 00:18:38,664
namun juga memiliki kondisi yang lebih kuat dari bilangan lilitan bukan nol,

304
00:18:38,664 --> 00:18:42,060
maka jika Anda membaginya menjadi dua, Anda dijamin bahwa setidaknya salah satu

305
00:18:42,060 --> 00:18:45,415
dari bagian tersebut memiliki warna yang sama. bilangan belitan yang bukan nol

306
00:18:45,415 --> 00:18:48,600
juga, karena segala sesuatunya akan bertambah sesuai dengan keinginan kita.

307
00:18:48,600 --> 00:18:54,280
Jadi dengan cara ini, Anda dapat melanjutkan, semakin mempersempit ke satu titik.

308
00:18:54,280 --> 00:18:57,618
Dan saat Anda mempersempit suatu titik, Anda akan melakukannya dengan

309
00:18:57,618 --> 00:19:00,860
loop kecil yang memiliki nomor belitan bukan nol, yang berarti loop

310
00:19:00,860 --> 00:19:04,294
tersebut melewati semua kemungkinan warna, dan oleh karena itu, seperti

311
00:19:04,294 --> 00:19:07,680
saya katakan sebelumnya, titik di mana mereka menyempit pada harus nol.

312
00:19:07,680 --> 00:19:08,760
Dan itu saja!

313
00:19:08,760 --> 00:19:11,701
Kami sekarang telah membuat pemecah persamaan dua

314
00:19:11,701 --> 00:19:14,760
dimensi, dan kali ini, saya berjanji, tidak ada bug.

315
00:19:14,760 --> 00:19:18,200
Angka berliku adalah alat yang kita perlukan agar ini berhasil.

316
00:19:18,200 --> 00:19:21,369
Sekarang kita dapat menyelesaikan persamaan yang terlihat seperti

317
00:19:21,369 --> 00:19:24,394
di mana f dari x sama dengan g dari x dalam dua dimensi, hanya

318
00:19:24,394 --> 00:19:27,660
dengan mempertimbangkan bagaimana perbedaan antara f dan g berputar.

319
00:19:27,660 --> 00:19:31,475
Setiap kali kita mempunyai loop yang nomor lilitannya bukan nol, kita dapat menjalankan

320
00:19:31,475 --> 00:19:35,160
algoritma ini pada loop tersebut, dan dijamin kita akan menemukan solusi di dalamnya.

321
00:19:35,160 --> 00:19:40,300
Terlebih lagi, seperti dalam satu dimensi, algoritma ini sangat efisien.

322
00:19:40,300 --> 00:19:44,197
Kita terus mempersempit setengah ukuran wilayah kita di setiap putaran,

323
00:19:44,197 --> 00:19:47,986
sehingga dengan cepat mempersempit angka nol, dan sementara itu, kita

324
00:19:47,986 --> 00:19:51,829
hanya perlu memeriksa nilai fungsi di sepanjang titik-titik perulangan

325
00:19:51,829 --> 00:19:55,240
ini, daripada memeriksanya di banyak perulangan. poin interior.

326
00:19:55,240 --> 00:19:59,920
Jadi dalam beberapa hal, keseluruhan pekerjaan yang dilakukan hanya sebanding

327
00:19:59,920 --> 00:20:04,960
dengan keliling ruang pencarian, bukan seluruh luasnya, dan ini sungguh menakjubkan.

328
00:20:04,960 --> 00:20:09,408
Sekarang setelah Anda memahami apa yang terjadi, sungguh menakjubkan melihat

329
00:20:09,408 --> 00:20:13,800
ini beraksi, memberinya beberapa fungsi dan membiarkannya mencari angka nol.

330
00:20:13,800 --> 00:20:16,967
Seperti saya katakan sebelumnya, bilangan kompleks adalah dua

331
00:20:16,967 --> 00:20:20,340
dimensi, jadi mari kita terapkan pada persamaan bilangan kompleks.

332
00:20:20,340 --> 00:20:24,596
Misalnya, inilah algoritme yang mencari angka nol dari fungsi x

333
00:20:24,596 --> 00:20:28,920
hingga seperlima dikurangi x dikurangi satu pada bidang kompleks.

334
00:20:28,920 --> 00:20:32,127
Ini dimulai dengan mempertimbangkan wilayah yang sangat luas

335
00:20:32,127 --> 00:20:35,440
di sekitar titik asal, yang akhirnya memiliki jumlah lilitan 5.

336
00:20:35,440 --> 00:20:39,280
Setiap kali Anda menemukan loop dengan nomor belitan bukan nol, Anda membaginya

337
00:20:39,280 --> 00:20:42,880
menjadi dua, dan mencari tahu nomor belitan dari dua loop yang lebih kecil.

338
00:20:42,880 --> 00:20:46,749
Salah satu atau kedua-duanya dijamin memiliki nomor belitan bukan nol, dan ketika

339
00:20:46,749 --> 00:20:50,383
Anda melihat ini, Anda tahu ada nol di suatu tempat di dalam loop yang lebih

340
00:20:50,383 --> 00:20:54,300
kecil itu, jadi Anda terus melakukan hal yang sama, mencari ruang yang lebih kecil.

341
00:20:54,300 --> 00:20:58,501
Kami juga berhenti menjelajahi suatu wilayah jika jalur yang kami lalui komputasi

342
00:20:58,501 --> 00:21:02,907
kebetulan menemukan angka nol, yang sebenarnya terjadi sekali untuk contoh di sebelah

343
00:21:02,907 --> 00:21:03,420
kanan ini.

344
00:21:03,420 --> 00:21:06,505
Kejadian langka itu mengganggu kemampuan kita menghitung

345
00:21:06,505 --> 00:21:09,320
bilangan berliku, tapi hei, kita mendapat angka nol.

346
00:21:09,320 --> 00:21:13,320
Dan untuk loop yang nomor belitannya nol, Anda tidak perlu menjelajahinya lebih jauh.

347
00:21:13,320 --> 00:21:18,520
Mungkin mereka punya solusi di dalam, mungkin juga tidak, kami tidak punya jaminan.

348
00:21:18,520 --> 00:21:22,199
Dan membiarkan pemecah persamaan kita melanjutkan dengan cara yang sama, pada

349
00:21:22,199 --> 00:21:26,020
akhirnya persamaan tersebut akan menyatu menjadi banyak nol untuk polinomial ini.

350
00:21:26,020 --> 00:21:29,180
Ngomong-ngomong, bukan suatu kebetulan jika jumlah

351
00:21:29,180 --> 00:21:31,660
total belitan dalam contoh ini adalah 5.

352
00:21:31,660 --> 00:21:38,176
Dengan bilangan kompleks, operasi x ke n secara langsung berhubungan dengan berjalan

353
00:21:38,176 --> 00:21:45,000
mengelilingi asal keluaran sebanyak n kali saat Anda mengelilingi asal masukan satu kali.

354
00:21:45,000 --> 00:21:48,760
Jadi dengan polinomial, untuk masukan yang cukup besar, setiap

355
00:21:48,760 --> 00:21:52,700
suku selain suku utama menjadi tidak signifikan jika dibandingkan.

356
00:21:52,700 --> 00:21:56,668
Jadi setiap polinomial kompleks yang suku utamanya adalah x ke

357
00:21:56,668 --> 00:22:00,700
n mempunyai bilangan belitan n di sekitar loop yang cukup besar.

358
00:22:00,700 --> 00:22:04,095
Dan dengan cara itu, teknologi bilangan berliku kami

359
00:22:04,095 --> 00:22:07,620
menjamin bahwa setiap polinomial kompleks memiliki nol.

360
00:22:07,620 --> 00:22:11,169
Fakta ini sangat penting sehingga para ahli matematika

361
00:22:11,169 --> 00:22:13,880
menyebutnya sebagai teorema dasar aljabar.

362
00:22:13,880 --> 00:22:18,548
Memiliki algoritma untuk menemukan solusi numerik terhadap persamaan seperti ini

363
00:22:18,548 --> 00:22:23,678
sangatlah praktis, namun teorema dasar aljabar adalah contoh yang baik tentang bagaimana

364
00:22:23,678 --> 00:22:28,635
bilangan berliku ini juga cukup berguna pada tingkat teoritis, menjamin adanya solusi

365
00:22:28,635 --> 00:22:33,765
untuk kelas yang luas. persamaan untuk kondisi yang sesuai, yang lebih disukai para ahli

366
00:22:33,765 --> 00:22:34,400
matematika.

367
00:22:34,400 --> 00:22:38,913
Saya akan menunjukkan kepada Anda beberapa penerapan menakjubkan ini dalam konteks

368
00:22:38,913 --> 00:22:43,808
topologi dalam video tindak lanjut, termasuk memperbaiki kesalahan dari video 3blue1Brown

369
00:22:43,808 --> 00:22:44,080
lama.

370
00:22:44,080 --> 00:22:45,080
Yang mana?

371
00:22:45,080 --> 00:22:48,224
Tonton semua videonya, semua yang ada di saluran ini, dan

372
00:22:48,224 --> 00:22:51,640
lihat apakah Anda dapat menemukan kesalahannya terlebih dahulu.

373
00:22:51,640 --> 00:22:54,013
Penulis utama video ini adalah salah satu anggota

374
00:22:54,013 --> 00:22:55,960
tim 3blue1 brown terbaru, Sridhar Ramesh.

