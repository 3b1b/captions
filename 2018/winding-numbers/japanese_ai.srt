1
00:00:00,000 --> 00:00:06,720
ここにはメイントピックとメタトピックの 2 つがあります。

2
00:00:06,720 --> 00:00:10,440
主なトピックは、2 次元方程式、2 つの未知の実数

3
00:00:10,440 --> 00:00:14,900
を持つもの、または 1 つの未知の複素数を含むもの

4
00:00:14,900 --> 00:00:17,420
を解くための、この非常に優れたアルゴリズムです。

5
00:00:17,420 --> 00:00:21,840
たとえば、多項式の複素根を見つけたい場合、またはおそらく

6
00:00:21,840 --> 00:00:25,960
リーマン ゼータ関数の数百万ドルのゼロの一部を見つけた

7
00:00:25,960 --> 00:00:26,960
い場合は、このアルゴリズムが代わりにそれを実行します。

8
00:00:27,000 --> 00:00:30,520
そしてこの方法はたくさんの色が使われているのでとてもきれいです。

9
00:00:30,520 --> 00:00:34,960
そしてさらに重要なことは、核となる基礎的な考え方は、この方程式

10
00:00:34,960 --> 00:00:39,600
を解くためのアルゴリズムをはるかに超えて、後で説明する少しのト

11
00:00:39,600 --> 00:00:40,600
ポロジーを含め、あらゆる種類の数学に適用できるということです。

12
00:00:40,600 --> 00:00:44,880
しかし、これが 20 分ほどの時間をかける価値があるのは、

13
00:00:44,880 --> 00:00:50,000
互いに適切に構成する構成要素を定義するという、数学全体を

14
00:00:50,000 --> 00:00:52,120
通してより一般的に役立つレッスンを説明していることです。

15
00:00:52,120 --> 00:00:55,460
物語が進むにつれて、私が何を意味するかがわかります。

16
00:00:55,460 --> 00:00:59,460
2 次元入力と 2 次元出力を持つ関数のケースを動機付けるために、実数を

17
00:00:59,460 --> 00:01:05,100
取り込んで実数を吐き出すだけの関数から、より単純なことから始めましょう。

18
00:01:05,100 --> 00:01:10,060
x の関数 f が x の他の関数 g と等しいときを知りたい場合、これは

19
00:01:10,060 --> 00:01:14,260
それらの関数のグラフが交差するときを検索すると考えることができますよね。

20
00:01:14,260 --> 00:01:19,340
つまり、両方の関数が同じ出力を持つ入力が得られます。

21
00:01:19,340 --> 00:01:24,520
非常に単純な例を挙げると、x の f は x の 2 乗であ

22
00:01:24,520 --> 00:01:25,520
り、x の g は定数関数 2 であると想像してください。

23
00:01:25,520 --> 00:01:29,620
つまり、2 の平方根を求めます。

24
00:01:29,620 --> 00:01:33,620
平方根を求めることについてほとんど何も知らなかったとしても、1 の 2

25
00:01:33,620 --> 00:01:39,260
乗は 2 より小さく、2 の 2 乗は 2 より大きいことがわかるの

26
00:01:39,260 --> 00:01:42,640
で、ああ、これら 2 つの値の間に何らかの解があることがわかります。

27
00:01:42,640 --> 00:01:46,740
さらに絞り込みたい場合は、中間点 1 を二乗し

28
00:01:46,740 --> 00:01:47,740
てみるとよいでしょう。5.

29
00:01:47,740 --> 00:01:53,060
これは 2 になります。25 は少し高すぎるため、1 と 1 の

30
00:01:53,060 --> 00:01:54,940
間の領域に焦点を当てます。5.

31
00:01:54,940 --> 00:01:58,560
などなど、おそらくこれがどのように継続するかがわかるでしょう。中

32
00:01:58,560 --> 00:02:05,540
間点で計算を続け、検索スペースを半分に切り分けることになります。

33
00:02:05,540 --> 00:02:08,340
これについて考えるもう 1 つの方法は、より高い次元に到

34
00:02:08,340 --> 00:02:13,560
達すると簡単になりますが、代わりに、これら 2 つの関

35
00:02:13,560 --> 00:02:16,300
数の差がゼロの場合の同等の質問に焦点を当てることです。

36
00:02:16,380 --> 00:02:20,700
これらの観点から、その差が一方の端では負であり、も

37
00:02:20,700 --> 00:02:24,020
う一方の端では正である入力の領域が見つかりました。

38
00:02:24,020 --> 00:02:28,660
私たちはそれを 2 つに分割し、最も外側の点に

39
00:02:28,660 --> 00:02:31,600
さまざまな兆候がある半分に注意を絞りました。

40
00:02:31,600 --> 00:02:36,020
このようにして、最終的には正確にゼロになる点に絞り込む必要があることを認

41
00:02:36,020 --> 00:02:41,320
識しながら、境界上のさまざまな標識を持つ各領域を取得し、その半分の中から

42
00:02:41,320 --> 00:02:46,260
そのような小さな領域を見つけながら、永遠に作業を続けることができました。

43
00:02:46,260 --> 00:02:50,480
つまり、方程式を解くということは、常に特定の関数がゼロに等しいときを見つけると

44
00:02:50,480 --> 00:02:55,780
いう枠組みで行うことができ、それを行うには、このヒューリスティックがあり、f

45
00:02:55,780 --> 00:03:00,420
がある点で正で、別の点で負である場合、その間のどこかを見つけることができます。

46
00:03:00,420 --> 00:03:03,980
少なくとも、すべてが急激に変化することなくスムーズに変化する場合はゼロです。

47
00:03:03,980 --> 00:03:08,060
私がお見せしたい驚くべきことは、この種の考え方を 2

48
00:03:08,060 --> 00:03:13,220
次元の方程式、つまり入力と出力が両方とも 2 次

49
00:03:13,220 --> 00:03:14,940
元である関数間の方程式に拡張できるということです。

50
00:03:14,940 --> 00:03:19,540
たとえば、複素数は 2D であり、私たちが開発している

51
00:03:19,540 --> 00:03:21,780
このツールは、複雑な方程式の解を見つけるのに最適です。

52
00:03:21,780 --> 00:03:25,700
さて、これらの 2D 関数についてたくさん話しますので、少し横

53
00:03:25,700 --> 00:03:29,380
道にそれて、これらをどのように説明するかを考えてみましょう。

54
00:03:29,380 --> 00:03:34,700
2D 入力と 2D 出力を持つ関数をグラフ化するには 4 次

55
00:03:34,700 --> 00:03:39,220
元が必要ですが、2D 画面上の 3D 世界ではあまりうまく機

56
00:03:39,220 --> 00:03:41,140
能しませんが、それでもいくつかの良いオプションがあります。

57
00:03:41,140 --> 00:03:46,020
1 つは、入力空間と出力空間の両方を並べて見ることです。

58
00:03:46,020 --> 00:03:51,540
入力空間内の各点は出力空間内の特定の点に移動し、その入力点の周りの移動

59
00:03:51,540 --> 00:03:57,060
が出力空間内の特定の動きにどのように対応するかを示すことができます。

60
00:03:57,060 --> 00:04:01,460
私たちが考慮する関数はすべて連続的であり、入力に対

61
00:04:01,460 --> 00:04:05,820
する小さな小さな変化は出力の小さな小さな変化にのみ

62
00:04:05,820 --> 00:04:07,460
対応するという意味で、突然のジャンプはありません。

63
00:04:07,460 --> 00:04:12,020
もう 1 つのオプションは、出力空間の原点からその出力点までの矢印を

64
00:04:12,020 --> 00:04:17,380
想像し、その矢印のミニチュア バージョンを入力点に接続することです。

65
00:04:17,380 --> 00:04:22,340
これにより、特定の入力ポイントがどこに行くのか、または完全なベクトル フィール

66
00:04:22,340 --> 00:04:27,580
ドを描画することで多くの異なる入力ポイントがどこに行くのかが一目でわかります。

67
00:04:27,580 --> 00:04:30,740
残念ながら、多くのポイントでこれを行うと、かなり乱雑になる可

68
00:04:30,740 --> 00:04:34,340
能性があるため、ここではすべての矢印を同じサイズにします。

69
00:04:34,340 --> 00:04:37,900
これは、各出力ポイントの方向を把握できることを意味します。

70
00:04:37,900 --> 00:04:41,660
しかし、おそらく 2 次元関数を説明する最も美しい方法は、このビデオ

71
00:04:41,660 --> 00:04:47,400
で最も使用する方法であり、出力空間内の各点を色に関連付けることです。

72
00:04:47,400 --> 00:04:52,180
ここでは、原点から遠ざかる方向に対応するために色相、つまり虹

73
00:04:52,180 --> 00:04:57,020
またはカラー ホイールに沿って色が分布する場所を使用し、原点

74
00:04:57,020 --> 00:05:00,060
からの距離に対応するために暗さまたは明るさを使用しています。

75
00:05:00,060 --> 00:05:05,720
たとえば、この出力配列に注目すると、これらの点はすべて赤で

76
00:05:05,720 --> 00:05:10,340
すが、原点に近い点は少し暗く、遠い点は少し明るくなります。

77
00:05:10,340 --> 00:05:15,360
この出力の配列に注目すると、すべての点が緑色であり、

78
00:05:15,360 --> 00:05:18,980
原点に近いほど暗く、遠いほど明るいことを意味します。

79
00:05:18,980 --> 00:05:24,300
など、ここで行っているのは各方向に特定の色を割り

80
00:05:24,300 --> 00:05:25,300
当てているだけであり、すべて継続的に変化します。

81
00:05:25,300 --> 00:05:29,100
ここでの暗さと明るさの違いは非常に微妙であることに気

82
00:05:29,140 --> 00:05:33,940
づくかもしれませんが、このビデオでは、出力の方向だけ

83
00:05:33,940 --> 00:05:35,300
が重要であり、大きさ、色相、明るさではありません。

84
00:05:35,300 --> 00:05:39,160
明るさに関して注目していただきたい重要な点は、特定の方向のな

85
00:05:39,160 --> 00:05:44,440
い原点付近では、すべての色が黒にフェードアウトすることです。

86
00:05:44,440 --> 00:05:48,820
関数について考えるために、各出力の色を決定したので

87
00:05:48,820 --> 00:05:54,020
、出力空間で到達する点の色に基づいて入力空間の各点

88
00:05:54,020 --> 00:05:57,860
を色付けすることで 2D 関数を視覚化できます。

89
00:05:57,860 --> 00:06:02,340
私は、多くの異なる点が入力空間から出力空間の対応する出

90
00:06:02,340 --> 00:06:06,340
力に飛び移り、着地した点の色に基づいてペイントされ、入

91
00:06:06,340 --> 00:06:11,820
力空間の元の場所に飛び戻る様子を想像するのが好きです。

92
00:06:11,820 --> 00:06:15,700
入力空間内のすべてのポイントに対してこれを行うと、その入力空間を見

93
00:06:15,700 --> 00:06:19,140
るだけで、関数が各ポイントを取得するおおよその場所がわかります。

94
00:06:19,140 --> 00:06:23,880
たとえば、左側のピンク色の点のストライプは、これらの点すべてがピンク

95
00:06:23,920 --> 00:06:30,000
色の方向、つまり出力空間の左下にマッピングされることを示しています。

96
00:06:30,000 --> 00:06:34,120
また、周囲が黒く色がたくさんある

97
00:06:34,120 --> 00:06:37,120
3 つの点は、ゼロになる点です。

98
00:06:37,120 --> 00:06:46,120
わかりました。1 次元の場合と同様に、2 次元関数の方程式を解くことは、

99
00:06:46,120 --> 00:06:49,780
特定の関数がいつゼロに等しいかを尋ねることによって常に再構成できます。

100
00:06:49,780 --> 00:06:54,820
それが今の私たちの課題です。与えられた 2D 関数のどの

101
00:06:54,820 --> 00:07:00,900
入力点がゼロになるかを見つけるアルゴリズムを作成します。

102
00:07:00,900 --> 00:07:04,560
このようなカラー マップを見ている場合、これらの黒い点を見れば、関数

103
00:07:04,560 --> 00:07:08,700
のゼロがどこにあるかがすでにわかっていると指摘されるかもしれません。

104
00:07:08,700 --> 00:07:11,460
それで、それはカウントされますか？

105
00:07:11,460 --> 00:07:15,100
このような図を作成するために、コンピューターに平面上のすべてのピクセ

106
00:07:15,100 --> 00:07:21,020
ルで関数を計算させましたが、私たちの目標は、できるだけ少ない点で関

107
00:07:21,020 --> 00:07:25,380
数を計算するだけで済む、より効率的なアルゴリズムを見つけることである

108
00:07:25,380 --> 00:07:29,600
ことに注意してください。いわば、色の見え方が限られているだけです。

109
00:07:29,600 --> 00:07:33,940
また、より理論的な観点から見ると、特定の領域内にゼロが存

110
00:07:33,940 --> 00:07:38,300
在するかどうかの条件を示す一般的な構成があれば便利です。

111
00:07:38,300 --> 00:07:43,700
ある次元での主要な洞察は、連続関数がある点で正で別の点で負である場合

112
00:07:43,700 --> 00:07:48,920
、その間のどこかでゼロになるはずだということを思い出してください。

113
00:07:48,920 --> 00:07:50,960
では、それを二次元に拡張するにはどうすればよいでしょうか?

114
00:07:50,960 --> 00:07:55,180
記号について話すのに似たようなものが必要です。

115
00:07:55,180 --> 00:07:59,140
標識とは何かについて考える 1 つの方法は、方向です。

116
00:07:59,140 --> 00:08:02,620
正は数直線に沿って右を指していることを意味

117
00:08:02,620 --> 00:08:04,240
し、負は左を指していることを意味します。

118
00:08:04,240 --> 00:08:08,800
2 次元の量にも方向がありますが、2 次元の量の場合、選択肢は

119
00:08:08,800 --> 00:08:12,780
はるかに広く、可能性の円全体に沿ってどこを指すこともできます。

120
00:08:12,780 --> 00:08:16,860
したがって、1 次元で特定の関数が範囲の境界 (わずか

121
00:08:16,860 --> 00:08:22,860
2 点) で正であるか負であるかを尋ねるのと同じように

122
00:08:22,860 --> 00:08:28,200
、2 次元関数の場合は領域の境界を調べます。はループであ

123
00:08:28,200 --> 00:08:33,760
り、その境界に沿った関数の出力の方向について尋ねます。

124
00:08:33,760 --> 00:08:39,220
たとえば、このゼロを中心としたループに沿って、出力があら

125
00:08:39,220 --> 00:08:43,460
ゆる方向、つまり虹のすべての色、赤、黄、緑、青から赤に戻

126
00:08:43,460 --> 00:08:45,820
り、途中でその間のすべての色を通過することがわかります。

127
00:08:45,820 --> 00:08:50,640
しかし、このループに沿って、内部にゼロがないので、出力はすべての色を通過するわ

128
00:08:50,640 --> 00:08:55,420
けではなく、オレンジ色のいくつかを通過しますが、たとえば緑や青は通過しません。

129
00:08:55,420 --> 00:08:59,320
これは有望であり、ある次元で物事がどのように機能したかによく似ています。

130
00:08:59,320 --> 00:09:03,540
おそらく、1 次元関数が 1 次元領域の境界で両方の可能な符号を

131
00:09:03,540 --> 00:09:09,700
取る場合、内部のどこかにゼロがあったのと同じように、2 次元関

132
00:09:09,700 --> 00:09:15,140
数がすべての可能な方向、すべての可能な色の出力を、 2D 領域の

133
00:09:15,140 --> 00:09:20,980
境界にある場合、その領域内のどこかでゼロになる必要があります。

134
00:09:20,980 --> 00:09:25,100
これは私たちの推測であり、これが真実であるべきかどうか、

135
00:09:25,100 --> 00:09:27,660
そうであるならなぜその理由について少し考えてください。

136
00:09:27,660 --> 00:09:32,020
ある入力点の周りの小さなループについて考え始めると、すべてが連続しているた

137
00:09:32,020 --> 00:09:36,660
め、関数が対応する出力近くの小さなループにそれを取り込むことがわかります。

138
00:09:36,660 --> 00:09:41,140
ただし、ほとんどの小さなループでは、出力の色が異なります。

139
00:09:41,140 --> 00:09:46,300
ゼロ以外の出力点を選択し、その近くに十分に密なループを描画

140
00:09:46,300 --> 00:09:49,860
すると、ループの色はすべてその点とほぼ同じ色になります。

141
00:09:49,860 --> 00:09:55,980
ここのタイトなループはすべて青みがかっており、こちらのタイトなループはす

142
00:09:55,980 --> 00:09:58,440
べて黄色がかっていますが、虹のすべての色が得られるわけではありません。

143
00:09:58,440 --> 00:10:03,580
すべての色を取得しながらその周りのループを締めることが

144
00:10:03,580 --> 00:10:07,120
できる唯一のポイントは、無色の原点であるゼロ自体です。

145
00:10:07,120 --> 00:10:11,680
したがって、虹のすべての色を通過するループがあり、締め付

146
00:10:11,680 --> 00:10:15,960
けて締め付け、ある点を狭めていく場合、その点は実際にはゼ

147
00:10:15,960 --> 00:10:17,360
ロでなければならないということは実際に当てはまります。

148
00:10:17,360 --> 00:10:22,360
それでは、1 次元方程式ソルバーと同じように 2 次元方程式ソルバーをセットアップしましょう。

149
00:10:22,360 --> 00:10:27,200
境界がすべての色を通過する大きな領域を見つけたら、それを

150
00:10:27,200 --> 00:10:30,640
2 つに分割し、それぞれの半分の境界にある色を調べます。

151
00:10:30,640 --> 00:10:34,920
ここに示す例では、左半分の境界線はすべての色を通過しているわけではなく、たとえ

152
00:10:34,920 --> 00:10:39,080
ば、オレンジがかった黄色がかった方向にマッピングされるポイントはありません。

153
00:10:39,080 --> 00:10:43,480
したがって、これ以上検索したくないという意味で、この領域をグレー表示にします。

154
00:10:43,480 --> 00:10:47,840
右半分はすべての色を通過し、緑の方向に多くの時間を費やし

155
00:10:47,840 --> 00:10:51,120
、その後、黄、オレンジ、赤、青、紫、ピンクを通過します。

156
00:10:51,120 --> 00:10:56,060
これが意味するのは、この境界の点がすべての可能な方向の

157
00:10:56,060 --> 00:10:57,800
出力にマッピングされるということを思い出してください。

158
00:10:57,800 --> 00:11:02,900
そこで、さらに詳しく調べて、再度細分化し、各領域の境界を確認します。

159
00:11:02,900 --> 00:11:07,000
上部の境界はすべて緑色なので、そこで探索を終了します。

160
00:11:07,000 --> 00:11:10,500
しかし、底部は細分化に値するほどカラフルです。

161
00:11:10,500 --> 00:11:12,420
そしてこのまま続けてください。

162
00:11:12,420 --> 00:11:16,860
どのサブ領域にすべての可能な色をカバーする境界があるかを確認し

163
00:11:16,860 --> 00:11:21,280
ます。つまり、その境界の点がすべての可能な方向にマッピングさ

164
00:11:21,280 --> 00:11:25,400
れ、1 次元の場合と同様にそれらの領域を半分に切り続け、最終

165
00:11:25,400 --> 00:11:29,320
的に関数全体をゼロに導きます。ああ、ちょっと待ってください。

166
00:11:29,320 --> 00:11:30,320
ここで何が起こったのでしょうか？

167
00:11:30,320 --> 00:11:34,520
右下の最後のサブディビジョンはどちらもすべての色を通過し

168
00:11:34,520 --> 00:11:38,160
なかったので、アルゴリズムはそれらのいずれも検索したくな

169
00:11:38,160 --> 00:11:41,160
かったため停止しましたが、ゼロも見つかりませんでした。

170
00:11:41,160 --> 00:11:43,720
さて、明らかにここで何かが間違っています。

171
00:11:43,720 --> 00:11:46,680
大丈夫、数学をやっていると間違うのはつきものです。

172
00:11:46,680 --> 00:11:51,400
振り返ってみると、この仮説があり、それがこの提案されたア

173
00:11:51,400 --> 00:11:53,680
ルゴリズムにつながったので、どこかで間違っていました。

174
00:11:53,680 --> 00:11:56,860
そして、数学が得意であるということは、最初から正しいと

175
00:11:56,860 --> 00:12:00,920
いうことではなく、注意深く振り返って間違いを理解し、

176
00:12:00,920 --> 00:12:02,520
それらを修正する方法を理解する回復力を持つことです。

177
00:12:02,520 --> 00:12:06,760
ここでの問題は、境界線がすべての色を通過する領域があったのですが、それを中央で分

178
00:12:06,760 --> 00:12:11,260
割すると、どちらのサブ領域の境界線もすべての色を通過しなくなり、次にどこで検索を

179
00:12:11,260 --> 00:12:14,880
続けるかについての選択肢がなく、それがゼロを突破してしまうことです。ファインダ。

180
00:12:15,280 --> 00:12:18,120
さて、ある次元では、このようなことは決して起こりませんでした。

181
00:12:18,120 --> 00:12:22,960
端点の符号が異なる区間がある場合、それ

182
00:12:22,960 --> 00:12:28,200
を分割すると、端点の符号も異なる部分区

183
00:12:28,200 --> 00:12:29,200
間が確実に得られることがわかります。

184
00:12:29,200 --> 00:12:34,120
別の言い方をすると、終点の符号が変わらない 2

185
00:12:34,120 --> 00:12:38,280
つの区間がある場合、それらを結合すると、終点

186
00:12:38,280 --> 00:12:39,280
の符号も変わらないより大きな区間が得られます。

187
00:12:39,280 --> 00:12:43,140
しかし、2 次元では、境界線がすべての色を通過するわ

188
00:12:43,140 --> 00:12:48,040
けではなく、境界線が結合してすべての色を通過する境

189
00:12:48,040 --> 00:12:49,940
界線を持つ 2 つの領域を見つけることができます。

190
00:12:49,940 --> 00:12:53,740
そしてまさにこのようにして、私たちが提案したゼロ探索アルゴリズムは機能しませんでした。

191
00:12:53,740 --> 00:12:58,680
実際、よく考えてみると、内側にゼロがなく、境界線がすべての

192
00:12:58,680 --> 00:13:03,120
可能な色を通過する大きなループを見つけることができます。

193
00:13:03,120 --> 00:13:07,100
これは、すべての色を通過する永遠に狭くなるループはゼロに近づく必要があると述べた

194
00:13:07,100 --> 00:13:13,040
とき、小さなループに関する私たちの主張が間違っていたということではありません。

195
00:13:13,040 --> 00:13:17,120
しかし、私たちにとって問題を引き起こしたのは、領域を結合するときに、この dos-my-border-go-t

196
00:13:17,120 --> 00:13:23,040
hrough-every-color-or-not プロパティが、適切かつ予測可能な方法で結合しないことです。

197
00:13:23,040 --> 00:13:28,100
ただし、心配しないでください。これを少し変更して、必要なものを実現する

198
00:13:28,100 --> 00:13:38,560
より洗練されたプロパティを組み合わせることができることがわかりました。

199
00:13:38,560 --> 00:13:42,540
このアイデアは、単にループ沿いのある点で色が見つかるかどうか

200
00:13:42,540 --> 00:13:47,100
を尋ねるのではなく、そのループを歩き回るときにこれらの色がど

201
00:13:47,100 --> 00:13:48,100
のように変化するかをより注意深く追跡しようというものです。

202
00:13:48,100 --> 00:13:50,060
例を挙げて私が何を意味するのかを説明しましょう。

203
00:13:50,060 --> 00:13:54,120
追跡しやすくするために、ここの隅に小さなカラーホイールを置いておきます。

204
00:13:54,120 --> 00:13:58,540
入力のパスに沿った色が、赤から黄色、黄から緑、

205
00:13:58,540 --> 00:14:04,380
緑から青、または青から赤という特定の方向に虹を

206
00:14:04,380 --> 00:14:05,720
通って移動すると、出力は時計回りに振れます。

207
00:14:05,720 --> 00:14:09,980
しかしその一方で、色が虹を通って青から緑、緑から黄、黄から赤、ま

208
00:14:09,980 --> 00:14:17,160
たは赤から青へ逆方向に移動する場合、出力は反時計回りに振れます。

209
00:14:17,160 --> 00:14:22,940
ここでこの短いパスに沿って歩くと、色はカラー ホイールを時計回り

210
00:14:22,940 --> 00:14:28,340
に 5 分の 1 曲がります。そして、このパスに沿って歩くと、色

211
00:14:28,340 --> 00:14:30,620
はカラー ホイールを時計回りにさらに 5 分の 1 曲がります。

212
00:14:30,620 --> 00:14:35,400
もちろん、これは、両方のパスを順番に通過すると、色が時

213
00:14:35,400 --> 00:14:39,380
計回りに合計 5 分の 2 回転することを意味します。

214
00:14:39,380 --> 00:14:43,740
巻き上げの総量は加算されるだけであり、これが重要になるでし

215
00:14:43,740 --> 00:14:47,140
ょう。これは私たちにとって役立つ、簡単な組み合わせです。

216
00:14:47,140 --> 00:14:51,980
総巻き上げ量というと、矢印が時計回りに回転すると前進し、反時計回

217
00:14:51,980 --> 00:14:58,700
りに回転すると後進する昔ながらの走行距離計を想像してください。

218
00:14:58,700 --> 00:15:03,020
したがって、反時計回りの巻きは負の時計回りの巻きとしてカウントされます。

219
00:15:03,020 --> 00:15:07,460
出力は大きく回転する可能性がありますが、その回

220
00:15:07,460 --> 00:15:08,940
転の一部が反対方向にある場合は相殺されます。

221
00:15:08,940 --> 00:15:13,220
たとえば、このパスに沿って前方に移動し、同じパスに沿って後方

222
00:15:13,220 --> 00:15:18,100
に移動すると、巻き上げの総量は最終的にゼロになり、後方への移

223
00:15:18,100 --> 00:15:23,440
動は文字通り前に見た色を巻き戻し、前の巻き上げをすべて反転し

224
00:15:23,440 --> 00:15:26,300
、元の色に戻ります。オドメーターがスタート地点に戻りました。

225
00:15:26,300 --> 00:15:30,480
私たちの目的では、ループに沿った巻き付けを観察することに最も重点を置きます。

226
00:15:30,480 --> 00:15:34,280
たとえば、このループ全体を時計回りに歩くとします。

227
00:15:34,280 --> 00:15:39,680
私たちが目にする出力は時計回りに合計 3 回転し、色は

228
00:15:39,680 --> 00:15:47,120
虹の中を順番に、赤から赤、そしてまた赤へと変化します。

229
00:15:47,120 --> 00:15:52,260
数学者が使う専門用語では、このループに沿っ

230
00:15:52,260 --> 00:15:54,100
た巻き数の合計は 3 であると言います。

231
00:15:54,100 --> 00:15:58,440
他のループの場合、これは他の整数になる可能性があり、入力が 1 つのループを

232
00:15:58,440 --> 00:16:03,680
周回するときに出力が何度も変動する場合はより大きな値になる可能性があり、出力

233
00:16:03,720 --> 00:16:07,060
が 1 回か 2 回しか変動しない場合はより小さい数になる可能性があります。

234
00:16:07,060 --> 00:16:12,260
あるいは、ループを時計回りに歩くときに出力が反時計回りに

235
00:16:12,260 --> 00:16:15,200
振れる場合、その巻数は負の整数になる可能性もあります。

236
00:16:15,200 --> 00:16:19,720
ただし、どのループに沿っても、この巻線の合計量は整数でなければなりません。

237
00:16:19,720 --> 00:16:23,980
つまり、最初の場所に戻るまでに、最初

238
00:16:23,980 --> 00:16:25,840
と同じ出力が得られることになります。

239
00:16:25,840 --> 00:16:31,520
ちなみに、実際にパスに出力が正確にゼロになる点が含ま

240
00:16:31,560 --> 00:16:35,640
れている場合、出力には特定の方向がないため、技術的に

241
00:16:35,640 --> 00:16:37,600
はそれに沿った曲がり数を定義することはできません。

242
00:16:37,600 --> 00:16:41,740
私たちの目標はゼロを見つけることなので、これは私たちにとって問題にはなりません。その

243
00:16:41,740 --> 00:16:45,200
ため、もしこのようなことが起こったとしても、私たちは早くに幸運に恵まれただけです。

244
00:16:45,200 --> 00:16:48,720
これらの曲がりくねった数値について注目すべき主な点は、パスをより

245
00:16:48,720 --> 00:16:55,040
大きなパスに結合すると、それらの数値が適切に加算されることです。

246
00:16:55,040 --> 00:16:59,440
しかし、私たちが本当に望んでいるのは、リージョンを結合してより大きなリージョンを作成

247
00:16:59,440 --> 00:17:03,120
するときに、リージョンの境界に沿った曲がりくねった数字が適切に合計されることです。

248
00:17:03,120 --> 00:17:06,320
それで、私たちはその財産を持っていますか？

249
00:17:06,320 --> 00:17:09,600
まあ、見てください。

250
00:17:09,600 --> 00:17:14,760
左側のこの領域の周りを時計回りに進むときの巻き数

251
00:17:14,760 --> 00:17:17,920
は、これら 4 つのパスからの巻き数の合計です。

252
00:17:17,920 --> 00:17:21,960
そして、右側のこの領域の周囲を時計回りに進むときの曲が

253
00:17:21,960 --> 00:17:25,480
りは、これら 4 つのパスからの曲がりの数の合計です。

254
00:17:25,480 --> 00:17:29,840
そして、これら 2 つの領域をより大きな領域に結合すると、それらの

255
00:17:29,840 --> 00:17:33,760
パスのほとんどは、より大きな領域の時計回りの境界の一部になります。

256
00:17:33,760 --> 00:17:36,040
では、そうでない 2 つのパスについてはどうでしょうか?

257
00:17:36,040 --> 00:17:40,520
それらは完全に打ち消し合い、そのうちの 1 つはちょう

258
00:17:40,520 --> 00:17:42,660
ど逆で、前に見たようにもう 1 つは巻き戻されます。

259
00:17:42,660 --> 00:17:48,840
したがって、地域の境界に沿った曲がりくねった数字は、私たちが望んでいるとおりに合計されます。

260
00:17:48,840 --> 00:17:53,560
また、余談ですが、このように方向性のある境界線がうまく合計されるという推論は

261
00:17:53,560 --> 00:17:57,320
数学でよく出てきて、ストークスの定理という名前で呼ばれることがよくあります。

262
00:17:57,320 --> 00:18:02,880
多変数微積分を勉強したことがある人なら、その文脈からそれを認識できるかもしれません。

263
00:18:02,880 --> 00:18:08,040
さて、いよいよ、曲がりくねった数字を手に入れて、方程式を解く目標に戻ることができます。

264
00:18:08,040 --> 00:18:12,400
先ほど見た領域の問題は、その境界がすべての可能な色を通過して

265
00:18:12,400 --> 00:18:16,620
いるにもかかわらず、実際には巻き数が 0 であることです。

266
00:18:16,620 --> 00:18:22,360
出力は、黄色から赤に向かって半分ほど巻き、その後、反時計回りに反

267
00:18:22,360 --> 00:18:26,000
対方向に戻り始め、その後、青を通過し続け、反対方向から赤に到達し

268
00:18:26,000 --> 00:18:32,040
ます。すべて、巻き線の合計がゼロになるような方法で行われました。

269
00:18:32,040 --> 00:18:36,000
しかし、すべての色にヒットするだけでなく、巻き数がゼロではないと

270
00:18:36,000 --> 00:18:41,200
いうより強力な条件を備えたループを見つけた場合、それを半分に分

271
00:18:41,200 --> 00:18:46,400
割した場合、それらの半分の少なくとも 1 つは確実にゼロ以外の巻

272
00:18:46,400 --> 00:18:48,600
き数も同様です。これは、物事が希望どおりに合計されるためです。

273
00:18:48,600 --> 00:18:54,280
このようにして、1 点にどんどん絞り込んで進み続けることができます。

274
00:18:54,280 --> 00:18:58,440
そして、点を絞り込むとき、ゼロ以外の巻き数を持つ小さなループを使用して絞り込む

275
00:18:58,440 --> 00:19:02,840
ことになります。これは、ループがすべての可能な色を通過することを意味し、したが

276
00:19:02,840 --> 00:19:07,680
って、前に述べたように、絞り込まれている点はon はゼロでなければなりません。

277
00:19:07,680 --> 00:19:08,760
以上です！

278
00:19:08,760 --> 00:19:13,280
これで 2 次元方程式ソルバーが作成されま

279
00:19:13,280 --> 00:19:14,760
した。今回はバグがないことを約束します。

280
00:19:14,760 --> 00:19:18,200
巻線番号はまさにこれを機能させるために必要なツールです。

281
00:19:18,200 --> 00:19:23,040
これで、f と g の差がどのように変化するかを考慮するだけで、2 次元で x

282
00:19:23,040 --> 00:19:27,660
の f が x の g に等しいかというような方程式を解くことができます。

283
00:19:27,660 --> 00:19:31,800
巻き数が 0 ではないループがある場合はいつでも、そのループに対してこのアル

284
00:19:31,800 --> 00:19:35,160
ゴリズムを実行でき、ループ内のどこかで必ず解が見つかることが保証されます。

285
00:19:35,160 --> 00:19:40,300
さらに、一次元の場合と同様に、このアルゴリズムは信じられないほど効率的です。

286
00:19:40,300 --> 00:19:44,880
各ラウンドで領域の半分のサイズに絞り込み続けることで、すぐにゼロに絞り込みま

287
00:19:44,880 --> 00:19:49,840
す。その間、多くのループで関数の値をチェックするのではなく、これらのループの

288
00:19:49,840 --> 00:19:55,240
ポイントに沿って関数の値をチェックするだけで済みます。インテリアのポイント。

289
00:19:55,240 --> 00:20:00,400
したがって、ある意味、行われる全体的な作業は、検索スペースの全領域では

290
00:20:00,400 --> 00:20:04,960
なく、その周囲にのみ比例することになります。これは驚くべきことです。

291
00:20:04,960 --> 00:20:09,360
何が起こっているのかを理解したら、これが実際に動作しているのを見るだけ

292
00:20:09,360 --> 00:20:13,800
で、これに何らかの機能を与え、ゼロを検索させるのは、奇妙に魅惑的です。

293
00:20:13,800 --> 00:20:18,600
前に述べたように、複素数は 2 次元なので、そ

294
00:20:18,600 --> 00:20:20,340
れを複素数を含む方程式に適用してみましょう。

295
00:20:20,340 --> 00:20:25,240
たとえば、複素平面上で関数 x の 5 番目から x から 1

296
00:20:25,240 --> 00:20:28,920
を引いた値までのゼロを見つけるアルゴリズムを次に示します。

297
00:20:28,920 --> 00:20:33,160
それは原点の周りの非常に広い領域を検討することか

298
00:20:33,160 --> 00:20:35,440
ら始まり、最終的に巻き数は 5 になりました。

299
00:20:35,440 --> 00:20:39,640
巻き数が 0 以外のループを見つけるたびに、それを半分

300
00:20:39,640 --> 00:20:42,840
に分割し、2 つの小さいループの巻き数を計算します。

301
00:20:42,880 --> 00:20:46,880
それらの一方または両方の巻き数がゼロではないことが保証されており

302
00:20:46,880 --> 00:20:51,440
、これを見ると、その小さなループの内側のどこかにゼロがあることが

303
00:20:51,440 --> 00:20:54,300
わかります。そのため、同じ方法で小さなスペースを検索し続けます。

304
00:20:54,300 --> 00:20:58,920
また、計算中のパスがたまたまゼロに遭遇した場合にも、領域の探索を

305
00:20:58,920 --> 00:21:03,420
停止します。これは、この例の右半分で実際に 1 回発生しました。

306
00:21:03,420 --> 00:21:07,600
このようなまれな出来事は、巻数を計算する能

307
00:21:07,600 --> 00:21:09,320
力を妨げますが、まあ、ゼロが得られました。

308
00:21:09,320 --> 00:21:13,320
また、巻き数が 0 のループについては、それ以上探索しません。

309
00:21:13,320 --> 00:21:18,520
おそらく彼らは内部に解決策を持っているかもしれませんが、もしかしたら持っていないかもしれません。私たちには何の保証もありません。

310
00:21:18,520 --> 00:21:22,240
そして、方程式ソルバーを同じ方法で継続させると、

311
00:21:22,240 --> 00:21:26,020
最終的にはこの多項式の多くのゼロに収束します。

312
00:21:26,020 --> 00:21:30,400
ちなみに、この例の総巻き数がたまたま

313
00:21:30,400 --> 00:21:31,660
5 だったのは偶然ではありません。

314
00:21:31,660 --> 00:21:37,280
複素数の場合、x から n への操作は、入力の原点の周りを 1 回歩く

315
00:21:37,280 --> 00:21:45,000
のと同じように、出力の原点の周りを n 回歩くことに直接対応します。

316
00:21:45,000 --> 00:21:50,500
したがって、多項式では、入力が十分に大きい場合、先頭の

317
00:21:50,500 --> 00:21:52,700
項以外のすべての項は比較すると重要ではなくなります。

318
00:21:52,700 --> 00:21:58,780
したがって、主項が x から n までである複素多項式は

319
00:21:58,780 --> 00:22:00,700
、十分に大きなループの周りに n の巻き数を持ちます。

320
00:22:00,700 --> 00:22:06,240
このようにして、当社の巻数技術は実際に、すべ

321
00:22:06,240 --> 00:22:07,620
ての複素多項式がゼロを持つことを保証します。

322
00:22:07,620 --> 00:22:13,880
これは数学者が代数学の基本定理と呼ぶほど重要な事実です。

323
00:22:13,880 --> 00:22:18,040
このような方程式の数値解を見つけるアルゴリズムは非常に実

324
00:22:18,040 --> 00:22:22,420
用的ですが、代数学の基本定理は、これらの巻き数が理論レベ

325
00:22:22,420 --> 00:22:27,780
ルでも非常に役立つことを示す良い例であり、広範なクラス

326
00:22:27,780 --> 00:22:32,280
の解の存在を保証します。適切な条件を方程式で導き出すとい

327
00:22:32,280 --> 00:22:34,060
うもので、むしろ数学者が考えるのが好きな類のものです。

328
00:22:34,400 --> 00:22:39,360
フォローアップ ビデオでは、トポロジに関連したこれの驚くべき応用例をいくつか紹介し

329
00:22:39,360 --> 00:22:44,080
ます。これには、古い 3blue1brown ビデオの間違いの修正も含まれます。

330
00:22:44,080 --> 00:22:45,080
どれ？

331
00:22:45,080 --> 00:22:48,740
このチャンネルのすべてのビデオを見て、まず間違

332
00:22:48,740 --> 00:22:51,640
いを見つけられるかどうかを確認してください。

333
00:22:51,640 --> 00:22:55,960
このビデオの主な作成者は、3blue1brown チームの最

334
00:22:55,960 --> 00:22:56,460
新メンバーの 1 人、Sridhar Ramesh です。

