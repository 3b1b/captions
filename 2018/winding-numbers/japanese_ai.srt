1
00:00:00,000 --> 00:00:06,720
ここにはメイントピックとメタトピックの 2 つがあります。

2
00:00:06,720 --> 00:00:10,440
主なトピックは、2 次元方程式、2

3
00:00:10,440 --> 00:00:14,900
つの未知の実数を持つもの、または 1

4
00:00:14,900 --> 00:00:17,420
つの未知の複素数を含むものを解くための、この非常に優れたアルゴリズムです。

5
00:00:17,420 --> 00:00:21,840
たとえば、多項式の複素根を見つけたい場合、またはおそらくリーマン

6
00:00:21,840 --> 00:00:25,960
ゼータ関数の数百万ドルのゼロの一部を見つけたい場合は、このアルゴリズムが代わりにそれを実行します。

7
00:00:25,960 --> 00:00:26,960


8
00:00:27,000 --> 00:00:30,520
そしてこの方法はたくさんの色が使われているのでとてもきれいです。

9
00:00:30,520 --> 00:00:34,960
そしてさらに重要なことは、核となる基礎的な考え方は、この方程式を解くためのアルゴリズムをはるかに超えて、後で説明する少しのトポロジーを含め、あらゆる種類の数学に適用できるということです。

10
00:00:34,960 --> 00:00:39,600


11
00:00:39,600 --> 00:00:40,600


12
00:00:40,600 --> 00:00:44,880
しかし、これが

13
00:00:44,880 --> 00:00:50,000
20

14
00:00:50,000 --> 00:00:52,120
分ほどの時間をかける価値があるのは、互いに適切に構成する構成要素を定義するという、数学全体を通してより一般的に役立つレッスンを説明していることです。

15
00:00:52,120 --> 00:00:55,460
物語が進むにつれて、私が何を意味するかがわかります。

16
00:00:55,460 --> 00:00:59,460
2 次元入力と

17
00:00:59,460 --> 00:01:05,100
2 次元出力を持つ関数のケースを動機付けるために、実数を取り込んで実数を吐き出すだけの関数から、より単純なことから始めましょう。

18
00:01:05,100 --> 00:01:10,060
x の関数 f が

19
00:01:10,060 --> 00:01:14,260
x の他の関数 g と等しいときを知りたい場合、これはそれらの関数のグラフが交差するときを検索すると考えることができますよね。

20
00:01:14,260 --> 00:01:19,340
つまり、両方の関数が同じ出力を持つ入力が得られます。

21
00:01:19,340 --> 00:01:24,520
非常に単純な例を挙げると、x の f は x の 2

22
00:01:24,520 --> 00:01:25,520
乗であり、x の g は定数関数 2 であると想像してください。

23
00:01:25,520 --> 00:01:29,620
つまり、2 の平方根を求めます。

24
00:01:29,620 --> 00:01:33,620
平方根を求めることについてほとんど何も知らなかったとしても、1 の 2 乗は 2

25
00:01:33,620 --> 00:01:39,260
より小さく、2 の 2 乗は

26
00:01:39,260 --> 00:01:42,640
2 より大きいことがわかるので、ああ、これら 2 つの値の間に何らかの解があることがわかります。

27
00:01:42,640 --> 00:01:46,740
さらに絞り込みたい場合は、中間点 1

28
00:01:46,740 --> 00:01:47,740
を二乗してみるとよいでしょう。 5.

29
00:01:47,740 --> 00:01:53,060
これは 2 になります。 25 は少し高すぎるため、1 と

30
00:01:53,060 --> 00:01:54,940
1 の間の領域に焦点を当てます。 5.

31
00:01:54,940 --> 00:01:58,560
などなど、おそらくこれがどのように継続するかがわかるでしょう。中間点で計算を続け、検索スペースを半分に切り分けることになります。

32
00:01:58,560 --> 00:02:05,540


33
00:02:05,540 --> 00:02:08,340
これについて考えるもう 1

34
00:02:08,340 --> 00:02:13,560
つの方法は、より高い次元に到達すると簡単になりますが、代わりに、これら 2

35
00:02:13,560 --> 00:02:16,300
つの関数の差がゼロの場合の同等の質問に焦点を当てることです。

36
00:02:16,380 --> 00:02:20,700
これらの観点から、その差が一方の端では負であり、もう一方の端では正である入力の領域が見つかりました。

37
00:02:20,700 --> 00:02:24,020


38
00:02:24,020 --> 00:02:28,660
私たちはそれを 2

39
00:02:28,660 --> 00:02:31,600
つに分割し、最も外側の点にさまざまな兆候がある半分に注意を絞りました。

40
00:02:31,600 --> 00:02:36,020
このようにして、最終的には正確にゼロになる点に絞り込む必要があることを認識しながら、境界上のさまざまな標識を持つ各領域を取得し、その半分の中からそのような小さな領域を見つけながら、永遠に作業を続けることができました。

41
00:02:36,020 --> 00:02:41,320


42
00:02:41,320 --> 00:02:46,260


43
00:02:46,260 --> 00:02:50,480
つまり、方程式を解くということは、常に特定の関数がゼロに等しいときを見つけるという枠組みで行うことができ、それを行うには、このヒューリスティックがあり、f

44
00:02:50,480 --> 00:02:55,780


45
00:02:55,780 --> 00:03:00,420
がある点で正で、別の点で負である場合、その間のどこかを見つけることができます。少なくとも、すべてが急激に変化することなくスムーズに変化する場合はゼロです。

46
00:03:00,420 --> 00:03:03,980


47
00:03:03,980 --> 00:03:08,060
私がお見せしたい驚くべきことは、この種の考え方を 2

48
00:03:08,060 --> 00:03:13,220
次元の方程式、つまり入力と出力が両方とも 2

49
00:03:13,220 --> 00:03:14,940
次元である関数間の方程式に拡張できるということです。

50
00:03:14,940 --> 00:03:19,540
たとえば、複素数は 2D

51
00:03:19,540 --> 00:03:21,780
であり、私たちが開発しているこのツールは、複雑な方程式の解を見つけるのに最適です。

52
00:03:21,780 --> 00:03:25,700
さて、これらの 2D

53
00:03:25,700 --> 00:03:29,380
関数についてたくさん話しますので、少し横道にそれて、これらをどのように説明するかを考えてみましょう。

54
00:03:29,380 --> 00:03:34,700
2D 入力と 2D

55
00:03:34,700 --> 00:03:39,220
出力を持つ関数をグラフ化するには 4 次元が必要ですが、2D

56
00:03:39,220 --> 00:03:41,140
画面上の 3D 世界ではあまりうまく機能しませんが、それでもいくつかの良いオプションがあります。

57
00:03:41,140 --> 00:03:46,020
1 つは、入力空間と出力空間の両方を並べて見ることです。

58
00:03:46,020 --> 00:03:51,540
入力空間内の各点は出力空間内の特定の点に移動し、その入力点の周りの移動が出力空間内の特定の動きにどのように対応するかを示すことができます。

59
00:03:51,540 --> 00:03:57,060


60
00:03:57,060 --> 00:04:01,460
私たちが考慮する関数はすべて連続的であり、入力に対する小さな小さな変化は出力の小さな小さな変化にのみ対応するという意味で、突然のジャンプはありません。

61
00:04:01,460 --> 00:04:05,820


62
00:04:05,820 --> 00:04:07,460


63
00:04:07,460 --> 00:04:12,020
もう 1

64
00:04:12,020 --> 00:04:17,380
つのオプションは、出力空間の原点からその出力点までの矢印を想像し、その矢印のミニチュア バージョンを入力点に接続することです。

65
00:04:17,380 --> 00:04:22,340
これにより、特定の入力ポイントがどこに行くのか、または完全なベクトル

66
00:04:22,340 --> 00:04:27,580
フィールドを描画することで多くの異なる入力ポイントがどこに行くのかが一目でわかります。

67
00:04:27,580 --> 00:04:30,740
残念ながら、多くのポイントでこれを行うと、かなり乱雑になる可能性があるため、ここではすべての矢印を同じサイズにします。これは、各出力ポイントの方向を把握できることを意味します。

68
00:04:30,740 --> 00:04:34,340


69
00:04:34,340 --> 00:04:37,900


70
00:04:37,900 --> 00:04:41,660
しかし、おそらく 2

71
00:04:41,660 --> 00:04:47,400
次元関数を説明する最も美しい方法は、このビデオで最も使用する方法であり、出力空間内の各点を色に関連付けることです。

72
00:04:47,400 --> 00:04:52,180
ここでは、原点から遠ざかる方向に対応するために色相、つまり虹またはカラー

73
00:04:52,180 --> 00:04:57,020
ホイールに沿って色が分布する場所を使用し、原点からの距離に対応するために暗さまたは明るさを使用しています。

74
00:04:57,020 --> 00:05:00,060


75
00:05:00,060 --> 00:05:05,720
たとえば、この出力配列に注目すると、これらの点はすべて赤ですが、原点に近い点は少し暗く、遠い点は少し明るくなります。

76
00:05:05,720 --> 00:05:10,340


77
00:05:10,340 --> 00:05:15,360
この出力の配列に注目すると、すべての点が緑色であり、原点に近いほど暗く、遠いほど明るいことを意味します。

78
00:05:15,360 --> 00:05:18,980


79
00:05:18,980 --> 00:05:24,300
など、ここで行っているのは各方向に特定の色を割り当てているだけであり、すべて継続的に変化します。

80
00:05:24,300 --> 00:05:25,300


81
00:05:25,300 --> 00:05:29,100
ここでの暗さと明るさの違いは非常に微妙であることに気づくかもしれませんが、このビデオでは、出力の方向だけが重要であり、大きさ、色相、明るさではありません。

82
00:05:29,140 --> 00:05:33,940


83
00:05:33,940 --> 00:05:35,300


84
00:05:35,300 --> 00:05:39,160
明るさに関して注目していただきたい重要な点は、特定の方向のない原点付近では、すべての色が黒にフェードアウトすることです。

85
00:05:39,160 --> 00:05:44,440


86
00:05:44,440 --> 00:05:48,820
関数について考えるために、各出力の色を決定したので、出力空間で到達する点の色に基づいて入力空間の各点を色付けすることで

87
00:05:48,820 --> 00:05:54,020
2D

88
00:05:54,020 --> 00:05:57,860
関数を視覚化できます。

89
00:05:57,860 --> 00:06:02,340
私は、多くの異なる点が入力空間から出力空間の対応する出力に飛び移り、着地した点の色に基づいてペイントされ、入力空間の元の場所に飛び戻る様子を想像するのが好きです。

90
00:06:02,340 --> 00:06:06,340


91
00:06:06,340 --> 00:06:11,820


92
00:06:11,820 --> 00:06:15,700
入力空間内のすべてのポイントに対してこれを行うと、その入力空間を見るだけで、関数が各ポイントを取得するおおよその場所がわかります。

93
00:06:15,700 --> 00:06:19,140


94
00:06:19,140 --> 00:06:23,880
たとえば、左側のピンク色の点のストライプは、これらの点すべてがピンク色の方向、つまり出力空間の左下にマッピングされることを示しています。

95
00:06:23,920 --> 00:06:30,000


96
00:06:30,000 --> 00:06:34,120
また、周囲が黒く色がたくさんある 3

97
00:06:34,120 --> 00:06:37,120
つの点は、ゼロになる点です。

98
00:06:37,120 --> 00:06:46,120
わかりました。1 次元の場合と同様に、2

99
00:06:46,120 --> 00:06:49,780
次元関数の方程式を解くことは、特定の関数がいつゼロに等しいかを尋ねることによって常に再構成できます。

100
00:06:49,780 --> 00:06:54,820
それが今の私たちの課題です。与えられた 2D

101
00:06:54,820 --> 00:07:00,900
関数のどの入力点がゼロになるかを見つけるアルゴリズムを作成します。

102
00:07:00,900 --> 00:07:04,560
このようなカラー

103
00:07:04,560 --> 00:07:08,700
マップを見ている場合、これらの黒い点を見れば、関数のゼロがどこにあるかがすでにわかっていると指摘されるかもしれません。

104
00:07:08,700 --> 00:07:11,460
それで、それはカウントされますか？

105
00:07:11,460 --> 00:07:15,100
このような図を作成するために、コンピューターに平面上のすべてのピクセルで関数を計算させましたが、私たちの目標は、できるだけ少ない点で関数を計算するだけで済む、より効率的なアルゴリズムを見つけることであることに注意してください。いわば、色の見え方が限られているだけです。

106
00:07:15,100 --> 00:07:21,020


107
00:07:21,020 --> 00:07:25,380


108
00:07:25,380 --> 00:07:29,600


109
00:07:29,600 --> 00:07:33,940
また、より理論的な観点から見ると、特定の領域内にゼロが存在するかどうかの条件を示す一般的な構成があれば便利です。

110
00:07:33,940 --> 00:07:38,300


111
00:07:38,300 --> 00:07:43,700
ある次元での主要な洞察は、連続関数がある点で正で別の点で負である場合、その間のどこかでゼロになるはずだということを思い出してください。

112
00:07:43,700 --> 00:07:48,920


113
00:07:48,920 --> 00:07:50,960
では、それを二次元に拡張するにはどうすればよいでしょうか?

114
00:07:50,960 --> 00:07:55,180
記号について話すのと同じようなものが必要です。

115
00:07:55,180 --> 00:07:59,140
標識とは何かについて考える 1 つの方法は、方向です。

116
00:07:59,140 --> 00:08:02,620
正は数直線に沿って右を指していることを意味し、負は左を指していることを意味します。

117
00:08:02,620 --> 00:08:04,240


118
00:08:04,240 --> 00:08:08,800
2 次元の量にも方向がありますが、2

119
00:08:08,800 --> 00:08:12,780
次元の量の場合、選択肢ははるかに広く、可能性の円全体に沿ってどこを指すこともできます。

120
00:08:12,780 --> 00:08:16,860
したがって、1 次元で特定の関数が範囲の境界

121
00:08:16,860 --> 00:08:22,860
(わずか 2

122
00:08:22,860 --> 00:08:28,200
点) で正であるか負であるかを尋ねるのと同じように、2

123
00:08:28,200 --> 00:08:33,760
次元関数の場合は領域の境界を調べます。はループであり、その境界に沿った関数の出力の方向について尋ねます。

124
00:08:33,760 --> 00:08:39,220
たとえば、このゼロを中心としたループに沿って、出力があらゆる方向、つまり虹のすべての色、赤、黄、緑、青から赤に戻り、途中でその間のすべての色を通過することがわかります。

125
00:08:39,220 --> 00:08:43,460


126
00:08:43,460 --> 00:08:45,820


127
00:08:45,820 --> 00:08:50,640
しかし、このループに沿って、内部にゼロがないので、出力はすべての色を通過するわけではなく、オレンジ色のいくつかを通過しますが、たとえば緑や青は通過しません。

128
00:08:50,640 --> 00:08:55,420


129
00:08:55,420 --> 00:08:59,320
これは有望であり、ある次元で物事がどのように機能したかによく似ています。

130
00:08:59,320 --> 00:09:03,540
おそらく、1 次元関数が

131
00:09:03,540 --> 00:09:09,700
1 次元領域の境界で両方の可能な符号を取る場合、内部のどこかにゼロがあったのと同じように、2

132
00:09:09,700 --> 00:09:15,140
次元関数がすべての可能な方向、すべての可能な色の出力を、 2D

133
00:09:15,140 --> 00:09:20,980
領域の境界にある場合、その領域内のどこかでゼロになる必要があります。

134
00:09:20,980 --> 00:09:25,100
これは私たちの推測であり、これが真実であるべきかどうか、そうであるならなぜその理由について少し考えてください。

135
00:09:25,100 --> 00:09:27,660


136
00:09:27,660 --> 00:09:32,020
ある入力点の周りの小さなループについて考え始めると、すべてが連続しているため、関数が対応する出力近くの小さなループにそれを取り込むことがわかります。

137
00:09:32,020 --> 00:09:36,660


138
00:09:36,660 --> 00:09:41,140
ただし、ほとんどの小さなループでは、出力の色が異なります。

139
00:09:41,140 --> 00:09:46,300
ゼロ以外の出力点を選択し、その近くに十分に密なループを描画すると、ループの色はすべてその点とほぼ同じ色になります。

140
00:09:46,300 --> 00:09:49,860


141
00:09:49,860 --> 00:09:55,980
ここのタイトなループはすべて青みがかっており、こちらのタイトなループはすべて黄色がかっていますが、虹のすべての色が得られるわけではありません。

142
00:09:55,980 --> 00:09:58,440


143
00:09:58,440 --> 00:10:03,580
すべての色を取得しながらその周りのループを締めることができる唯一のポイントは、無色の原点であるゼロ自体です。

144
00:10:03,580 --> 00:10:07,120


145
00:10:07,120 --> 00:10:11,680
したがって、虹のすべての色を通過するループがあり、締め付けて締め付け、ある点を狭めていく場合、その点は実際にはゼロでなければならないということは実際に当てはまります。

146
00:10:11,680 --> 00:10:15,960


147
00:10:15,960 --> 00:10:17,360


148
00:10:17,360 --> 00:10:22,360
それでは、1 次元方程式ソルバーと同じように 2 次元方程式ソルバーをセットアップしましょう。

149
00:10:22,360 --> 00:10:27,200
境界がすべての色を通過する大きな領域を見つけたら、それを 2

150
00:10:27,200 --> 00:10:30,640
つに分割し、それぞれの半分の境界にある色を調べます。

151
00:10:30,640 --> 00:10:34,920
ここに示す例では、左半分の境界線はすべての色を通過しているわけではなく、たとえば、オレンジがかった黄色がかった方向にマッピングされるポイントはありません。

152
00:10:34,920 --> 00:10:39,080


153
00:10:39,080 --> 00:10:43,480
したがって、これ以上検索したくないという意味で、この領域をグレー表示にします。

154
00:10:43,480 --> 00:10:47,840
右半分はすべての色を通過し、緑の方向に多くの時間を費やし、その後、黄、オレンジ、赤、青、紫、ピンクを通過します。

155
00:10:47,840 --> 00:10:51,120


156
00:10:51,120 --> 00:10:56,060
これが意味するのは、この境界の点がすべての可能な方向の出力にマッピングされるということを思い出してください。

157
00:10:56,060 --> 00:10:57,800


158
00:10:57,800 --> 00:11:02,900
そこで、さらに詳しく調べて、再度細分化し、各領域の境界を確認します。

159
00:11:02,900 --> 00:11:07,000
上部の境界はすべて緑色なので、そこで探索を終了します。

160
00:11:07,000 --> 00:11:10,500
しかし、底部は細分化に値するほどカラフルです。

161
00:11:10,500 --> 00:11:12,420
そしてこのまま続けてください。

162
00:11:12,420 --> 00:11:16,860
どのサブ領域にすべての可能な色をカバーする境界があるかを確認します。つまり、その境界の点がすべての可能な方向にマッピングされ、1

163
00:11:16,860 --> 00:11:21,280
次元の場合と同様にそれらの領域を半分に切り続け、最終的に関数全体が

164
00:11:21,280 --> 00:11:25,400
0

165
00:11:25,400 --> 00:11:29,320
になります。ああ、ちょっと待ってください。

166
00:11:29,320 --> 00:11:30,320
ここで何が起こったのでしょうか？

167
00:11:30,320 --> 00:11:34,520
右下の最後のサブディビジョンはどちらもすべての色を通過しなかったので、アルゴリズムはそれらのいずれも検索したくなかったため停止しましたが、ゼロも見つかりませんでした。

168
00:11:34,520 --> 00:11:38,160


169
00:11:38,160 --> 00:11:41,160


170
00:11:41,160 --> 00:11:43,720
さて、明らかにここで何かが間違っています。

171
00:11:43,720 --> 00:11:46,680
大丈夫、数学をやっていると間違うのはつきものです。

172
00:11:46,680 --> 00:11:51,400
振り返ってみると、この仮説があり、それがこの提案されたアルゴリズムにつながったので、どこかで間違っていました。

173
00:11:51,400 --> 00:11:53,680


174
00:11:53,680 --> 00:11:56,860
そして、数学が得意であるということは、最初から正しいということではなく、注意深く振り返って間違いを理解し、それらを修正する方法を理解する回復力を持つことです。

175
00:11:56,860 --> 00:12:00,920


176
00:12:00,920 --> 00:12:02,520


177
00:12:02,520 --> 00:12:06,760
ここでの問題は、境界線がすべての色を通過する領域があったのですが、それを中央で分割すると、どちらのサブ領域の境界線もすべての色を通過しなくなり、次にどこで検索を続けるかについての選択肢がなく、それがゼロを突破してしまうことです。ファインダ。

178
00:12:06,760 --> 00:12:11,260


179
00:12:11,260 --> 00:12:14,880


180
00:12:15,280 --> 00:12:18,120
さて、ある次元では、このようなことは決して起こりませんでした。

181
00:12:18,120 --> 00:12:22,960
端点の符号が異なる区間がある場合、それを分割すると、端点の符号も異なる部分区間が確実に得られることがわかります。

182
00:12:22,960 --> 00:12:28,200


183
00:12:28,200 --> 00:12:29,200


184
00:12:29,200 --> 00:12:34,120
別の言い方をすると、終点の符号が変わらない

185
00:12:34,120 --> 00:12:38,280
2

186
00:12:38,280 --> 00:12:39,280
つの区間がある場合、それらを結合すると、終点の符号も変わらないより大きな区間が得られます。

187
00:12:39,280 --> 00:12:43,140
しかし、2 次元では、境界線がすべての色を通過するわけではなく、境界線が結合してすべての色を通過する境界線を持つ

188
00:12:43,140 --> 00:12:48,040
2

189
00:12:48,040 --> 00:12:49,940
つの領域を見つけることができます。

190
00:12:49,940 --> 00:12:53,740
そしてまさにこのようにして、私たちが提案したゼロ探索アルゴリズムは機能しませんでした。

191
00:12:53,740 --> 00:12:58,680
実際、よく考えてみると、内側にゼロがなく、境界線がすべての可能な色を通過する大きなループを見つけることができます。

192
00:12:58,680 --> 00:13:03,120


193
00:13:03,120 --> 00:13:07,100
これは、すべての色を通過する永遠に狭くなるループはゼロに近づく必要があると述べたとき、小さなループに関する私たちの主張が間違っていたということではありません。

194
00:13:07,100 --> 00:13:13,040


195
00:13:13,040 --> 00:13:17,120
しかし、私たちにとって問題を引き起こしたのは、領域を結合するときに、この dos-my-border-go-through-every-color-or-not

196
00:13:17,120 --> 00:13:23,040
プロパティが、適切かつ予測可能な方法で結合しないことです。

197
00:13:23,040 --> 00:13:28,100
ただし、心配しないでください。これを少し変更して、必要なものを実現するより洗練されたプロパティを組み合わせることができることがわかりました。

198
00:13:28,100 --> 00:13:38,560


199
00:13:38,560 --> 00:13:42,540
このアイデアは、単にループ沿いのある点で色が見つかるかどうかを尋ねるのではなく、そのループを歩き回るときにこれらの色がどのように変化するかをより注意深く追跡しようというものです。

200
00:13:42,540 --> 00:13:47,100


201
00:13:47,100 --> 00:13:48,100


202
00:13:48,100 --> 00:13:50,060
例を挙げて私が何を意味するのかを説明しましょう。

203
00:13:50,060 --> 00:13:54,120
追跡しやすくするために、ここの隅に小さなカラーホイールを置いておきます。

204
00:13:54,120 --> 00:13:58,540
入力のパスに沿った色が、赤から黄色、黄から緑、緑から青、または青から赤という特定の方向に虹を通って移動すると、出力は時計回りに振れます。

205
00:13:58,540 --> 00:14:04,380


206
00:14:04,380 --> 00:14:05,720


207
00:14:05,720 --> 00:14:09,980
しかしその一方で、色が虹を通って青から緑、緑から黄、黄から赤、または赤から青へと逆方向に移動する場合、出力は反時計回りに振れます。

208
00:14:09,980 --> 00:14:17,160


209
00:14:17,160 --> 00:14:22,940
ここでこの短いパスに沿って歩くと、色はカラー ホイールを時計回りに 5 分の

210
00:14:22,940 --> 00:14:28,340
1 曲がります。そして、このパスに沿って歩くと、色はカラー ホイールを時計回りにさらに 5

211
00:14:28,340 --> 00:14:30,620
分の 1 曲がります。

212
00:14:30,620 --> 00:14:35,400
もちろん、これは、両方のパスを順番に通過すると、色が時計回りに合計 5 分の

213
00:14:35,400 --> 00:14:39,380
2 回転することを意味します。

214
00:14:39,380 --> 00:14:43,740
巻き上げの総量は加算されるだけであり、これが重要になるでしょう。これは私たちにとって役立つ、簡単な組み合わせです。

215
00:14:43,740 --> 00:14:47,140


216
00:14:47,140 --> 00:14:51,980
総巻き量というと、矢印が時計回りに回転すると前進し、矢印が反時計回りに回転すると後進する昔ながらの走行距離計を想像してください。

217
00:14:51,980 --> 00:14:58,700


218
00:14:58,700 --> 00:15:03,020
したがって、反時計回りの巻きは負の時計回りの巻きとしてカウントされます。

219
00:15:03,020 --> 00:15:07,460
出力は大きく回転する可能性がありますが、その回転の一部が反対方向にある場合は相殺されます。

220
00:15:07,460 --> 00:15:08,940


221
00:15:08,940 --> 00:15:13,220
たとえば、このパスに沿って前方に移動し、同じパスに沿って後方に移動すると、巻き上げの総量は最終的にゼロになり、後方への移動は文字通り前に見た色を巻き戻し、前の巻き上げをすべて反転し、元の色に戻ります。オドメーターがスタート地点に戻りました。

222
00:15:13,220 --> 00:15:18,100


223
00:15:18,100 --> 00:15:23,440


224
00:15:23,440 --> 00:15:26,300


225
00:15:26,300 --> 00:15:30,480
私たちの目的では、ループに沿った巻き付けを観察することに最も重点を置きます。

226
00:15:30,480 --> 00:15:34,280
たとえば、このループ全体を時計回りに歩くとします。

227
00:15:34,280 --> 00:15:39,680
私たちが目にする出力は時計回りに合計 3

228
00:15:39,680 --> 00:15:47,120
回転し、色は虹の中を順番に、赤から赤、そしてまた赤へと変化します。

229
00:15:47,120 --> 00:15:52,260
数学者が使う専門用語では、このループに沿った巻き数の合計は 3

230
00:15:52,260 --> 00:15:54,100
であると言います。

231
00:15:54,100 --> 00:15:58,440
他のループの場合、これは他の整数になる可能性があり、入力が 1 つのループを周回するときに出力が何度も変動する場合はより大きな値になる可能性があり、出力が

232
00:15:58,440 --> 00:16:03,680
1 回か

233
00:16:03,720 --> 00:16:07,060
2 回しか変動しない場合はより小さい数になる可能性があります。

234
00:16:07,060 --> 00:16:12,260
あるいは、ループを時計回りに歩くときに出力が反時計回りに振れる場合、その巻き数は負の整数になる可能性もあります。

235
00:16:12,260 --> 00:16:15,200


236
00:16:15,200 --> 00:16:19,720
ただし、どのループに沿っても、この巻線の合計量は整数でなければなりません。

237
00:16:19,720 --> 00:16:23,980
つまり、最初の場所に戻るまでに、最初と同じ出力が得られることになります。

238
00:16:23,980 --> 00:16:25,840


239
00:16:25,840 --> 00:16:31,520
ちなみに、実際にパスに出力が正確にゼロになる点が含まれている場合、出力には特定の方向がないため、技術的にはそれに沿った曲がり数を定義することはできません。

240
00:16:31,560 --> 00:16:35,640


241
00:16:35,640 --> 00:16:37,600


242
00:16:37,600 --> 00:16:41,740
私たちの目標はゼロを見つけることなので、これは私たちにとって問題にはなりません。そのため、もしこのようなことが起こったとしても、私たちは早くに幸運に恵まれただけです。

243
00:16:41,740 --> 00:16:45,200


244
00:16:45,200 --> 00:16:48,720
これらの曲がりくねった数値について注目すべき主な点は、パスをより大きなパスに結合すると、それらの数値が適切に加算されることです。

245
00:16:48,720 --> 00:16:55,040


246
00:16:55,040 --> 00:16:59,440
しかし、私たちが本当に望んでいるのは、リージョンを結合してより大きなリージョンを作成するときに、リージョンの境界に沿った曲がりくねった数字が適切に合計されることです。

247
00:16:59,440 --> 00:17:03,120


248
00:17:03,120 --> 00:17:06,320
それで、私たちはその財産を持っていますか？

249
00:17:06,320 --> 00:17:09,600
まあ、見てください。

250
00:17:09,600 --> 00:17:14,760
左側のこの領域の周りを時計回りに進むときの巻き数は、これら 4

251
00:17:14,760 --> 00:17:17,920
つのパスからの巻き数の合計です。

252
00:17:17,920 --> 00:17:21,960
そして、右側のこの領域の周囲を時計回りに進むときの曲がりは、これら 4

253
00:17:21,960 --> 00:17:25,480
つのパスからの曲がりの数の合計です。

254
00:17:25,480 --> 00:17:29,840
そして、これら 2

255
00:17:29,840 --> 00:17:33,760
つの領域をより大きな領域に結合すると、それらのパスのほとんどは、より大きな領域の時計回りの境界の一部になります。

256
00:17:33,760 --> 00:17:36,040
では、そうでない 2 つのパスについてはどうでしょうか?

257
00:17:36,040 --> 00:17:40,520
それらは完全に打ち消し合い、そのうちの 1 つはちょうど逆で、前に見たようにもう

258
00:17:40,520 --> 00:17:42,660
1 つは巻き戻されます。

259
00:17:42,660 --> 00:17:48,840
したがって、地域の境界に沿った曲がりくねった数字は、私たちが望んでいるとおりに合計されます。

260
00:17:48,840 --> 00:17:53,560
また、余談ですが、このように方向性のある境界線がうまく合計されるという推論は数学でよく出てきて、ストークスの定理という名前で呼ばれることがよくあります。

261
00:17:53,560 --> 00:17:57,320


262
00:17:57,320 --> 00:18:02,880
多変数微積分を勉強したことがある人なら、その文脈からそれを認識できるかもしれません。

263
00:18:02,880 --> 00:18:08,040
さて、いよいよ、曲がりくねった数字を手に入れて、方程式を解く目標に戻ることができます。

264
00:18:08,040 --> 00:18:12,400
先ほど見た領域の問題は、その境界がすべての可能な色を通過しているにもかかわらず、実際には巻き数が 0

265
00:18:12,400 --> 00:18:16,620
であることです。

266
00:18:16,620 --> 00:18:22,360
出力は、黄色から赤に向かって半分ほど巻き、その後、反時計回りに反対方向に戻り始め、その後、青を通過し続け、反対方向から赤に到達します。すべて、巻き線の合計がゼロになるような方法で行われました。

267
00:18:22,360 --> 00:18:26,000


268
00:18:26,000 --> 00:18:32,040


269
00:18:32,040 --> 00:18:36,000
しかし、すべての色にヒットするだけでなく、巻き数がゼロではないというより強力な条件を備えたループを見つけた場合、それを半分に分割した場合、それらの半分の少なくとも

270
00:18:36,000 --> 00:18:41,200
1

271
00:18:41,200 --> 00:18:46,400
つは確実にゼロ以外の巻き数も同様です。これは、物事が希望どおりに合計されるためです。

272
00:18:46,400 --> 00:18:48,600


273
00:18:48,600 --> 00:18:54,280
このようにして、1 点にどんどん絞り込んで進み続けることができます。

274
00:18:54,280 --> 00:18:58,440
そして、点を絞り込むとき、ゼロ以外の巻き数を持つ小さなループを使用して絞り込むことになります。これは、ループがすべての可能な色を通過することを意味し、したがって、前に述べたように、絞り込まれている点はon

275
00:18:58,440 --> 00:19:02,840
はゼロでなければなりません。

276
00:19:02,840 --> 00:19:07,680


277
00:19:07,680 --> 00:19:08,760
以上です！

278
00:19:08,760 --> 00:19:13,280
これで 2

279
00:19:13,280 --> 00:19:14,760
次元方程式ソルバーが作成されました。今回はバグがないことを約束します。

280
00:19:14,760 --> 00:19:18,200
巻線番号はまさにこれを機能させるために必要なツールです。

281
00:19:18,200 --> 00:19:23,040
これで、f と g の差がどのように変化するかを考慮するだけで、2 次元で x の

282
00:19:23,040 --> 00:19:27,660
f が x の g に等しいかというような方程式を解くことができます。

283
00:19:27,660 --> 00:19:31,800
巻き数が 0

284
00:19:31,800 --> 00:19:35,160
ではないループがある場合はいつでも、そのループに対してこのアルゴリズムを実行でき、ループ内のどこかで必ず解が見つかることが保証されます。

285
00:19:35,160 --> 00:19:40,300
さらに、一次元の場合と同様に、このアルゴリズムは信じられないほど効率的です。

286
00:19:40,300 --> 00:19:44,880
各ラウンドで領域の半分のサイズに絞り込み続けることで、すぐにゼロに絞り込みます。その間、多くのループで関数の値をチェックするのではなく、これらのループのポイントに沿って関数の値をチェックするだけで済みます。インテリアのポイント。

287
00:19:44,880 --> 00:19:49,840


288
00:19:49,840 --> 00:19:55,240


289
00:19:55,240 --> 00:20:00,400
したがって、ある意味、行われる全体的な作業は、検索スペースの全領域ではなく、その周囲にのみ比例することになります。これは驚くべきことです。

290
00:20:00,400 --> 00:20:04,960


291
00:20:04,960 --> 00:20:09,360
何が起こっているのかを理解したら、これが実際に動作しているのを見るだけで、これに何らかの機能を与え、ゼロを検索させるのは、奇妙に魅惑的です。

292
00:20:09,360 --> 00:20:13,800


293
00:20:13,800 --> 00:20:18,600
前に述べたように、複素数は 2

294
00:20:18,600 --> 00:20:20,340
次元なので、それを複素数を含む方程式に適用してみましょう。

295
00:20:20,340 --> 00:20:25,240
たとえば、複素平面上で関数 x の 5 番目から

296
00:20:25,240 --> 00:20:28,920
x から 1 を引いた値までのゼロを見つけるアルゴリズムを次に示します。

297
00:20:28,920 --> 00:20:33,160
それは原点の周りの非常に広い領域を検討することから始まり、最終的に巻き数は 5

298
00:20:33,160 --> 00:20:35,440
になりました。

299
00:20:35,440 --> 00:20:39,640
巻き数が 0

300
00:20:39,640 --> 00:20:42,840
以外のループを見つけるたびに、それを半分に分割し、2 つの小さいループの巻き数を計算します。

301
00:20:42,880 --> 00:20:46,880
それらの一方または両方の巻き数がゼロではないことが保証されており、これを見ると、その小さなループの内側のどこかにゼロがあることがわかります。そのため、同じ方法で小さなスペースを検索し続けます。

302
00:20:46,880 --> 00:20:51,440


303
00:20:51,440 --> 00:20:54,300


304
00:20:54,300 --> 00:20:58,920
また、計算中のパスがたまたまゼロに遭遇した場合にも、領域の探索を停止します。これは、この例の右半分で実際に 1

305
00:20:58,920 --> 00:21:03,420
回発生しました。

306
00:21:03,420 --> 00:21:07,600
このようなまれな出来事は、巻数を計算する能力を妨げますが、まあ、ゼロが得られました。

307
00:21:07,600 --> 00:21:09,320


308
00:21:09,320 --> 00:21:13,320
また、巻き数が 0 のループについては、それ以上探索しません。

309
00:21:13,320 --> 00:21:18,520
おそらく彼らは内部に解決策を持っているかもしれませんが、もしかしたら持っていないかもしれません。私たちには何の保証もありません。

310
00:21:18,520 --> 00:21:22,240
そして、方程式ソルバーを同じ方法で継続させると、最終的にはこの多項式の多くのゼロに収束します。

311
00:21:22,240 --> 00:21:26,020


312
00:21:26,020 --> 00:21:30,400
ちなみに、この例の総巻き数がたまたま 5

313
00:21:30,400 --> 00:21:31,660
だったのは偶然ではありません。

314
00:21:31,660 --> 00:21:37,280
複素数の場合、x から n への操作は、入力の原点の周りを

315
00:21:37,280 --> 00:21:45,000
1 回歩くのと同じように、出力の原点の周りを n 回歩くことに直接対応します。

316
00:21:45,000 --> 00:21:50,500
したがって、多項式では、入力が十分に大きい場合、先頭の項以外のすべての項は比較すると重要ではなくなります。

317
00:21:50,500 --> 00:21:52,700


318
00:21:52,700 --> 00:21:58,780
したがって、主項が x から n

319
00:21:58,780 --> 00:22:00,700
までである複素多項式は、十分に大きなループの周りに n の巻き数を持ちます。

320
00:22:00,700 --> 00:22:06,240
このようにして、当社の巻数技術は実際に、すべての複素多項式がゼロを持つことを保証します。

321
00:22:06,240 --> 00:22:07,620


322
00:22:07,620 --> 00:22:13,880
これは数学者が代数学の基本定理と呼ぶほど重要な事実です。

323
00:22:13,880 --> 00:22:18,040
このような方程式の数値解を見つけるアルゴリズムは非常に実用的ですが、代数学の基本定理は、これらの巻き数が理論レベルでも非常に役立つことを示す良い例であり、広範なクラスの解の存在を保証します。適切な条件を方程式で導き出すというもので、むしろ数学者が考えるのが好きな類のものです。

324
00:22:18,040 --> 00:22:22,420


325
00:22:22,420 --> 00:22:27,780


326
00:22:27,780 --> 00:22:32,280


327
00:22:32,280 --> 00:22:34,060


328
00:22:34,400 --> 00:22:39,360
フォローアップ ビデオでは、トポロジに関連したこれの驚くべき応用例をいくつか紹介します。これには、古い

329
00:22:39,360 --> 00:22:44,080
3blue1brown ビデオの間違いの修正も含まれます。

330
00:22:44,080 --> 00:22:45,080
どれ？

331
00:22:45,080 --> 00:22:48,740
このチャンネルのすべてのビデオを見て、まず間違いを見つけられるかどうかを確認してください。

332
00:22:48,740 --> 00:22:51,640


333
00:22:51,640 --> 00:22:55,960
このビデオの主な作成者は、3blue1brown チームの最新メンバーの 1

334
00:22:55,960 --> 00:22:56,460
人、Sridhar Ramesh です。

