1
00:00:03,060 --> 00:00:06,140
ここにはメイントピックとメタトピックの 2 つがあります。

2
00:00:06,640 --> 00:00:10,129
主なトピックは、2 次元方程式、2 つの未知の実数 

3
00:00:10,129 --> 00:00:13,618
を持つもの、または 1 つの未知の複素数を含むもの 

4
00:00:13,618 --> 00:00:16,840
を解くための、この非常に優れたアルゴリズムです。

5
00:00:17,440 --> 00:00:20,567
たとえば、多項式の複素根を見つけたい場合、またはおそらく 

6
00:00:20,567 --> 00:00:23,587
リーマン ゼータ関数の数百万ドルのゼロの一部を見つけた 

7
00:00:23,587 --> 00:00:26,500
い場合は、このアルゴリズムが代わりにそれを実行します。

8
00:00:26,800 --> 00:00:28,430
そしてこの方法はたくさんの色が使

9
00:00:28,430 --> 00:00:30,060
われているのでとてもきれいです。

10
00:00:30,540 --> 00:00:32,844
そしてさらに重要なことは、核となる基礎的な考え

11
00:00:32,844 --> 00:00:35,149
方は、この方程式 を解くためのアルゴリズムをは

12
00:00:35,149 --> 00:00:36,953
るかに超えて、後で説明する少しのト 

13
00:00:36,953 --> 00:00:39,258
ポロジーを含め、あらゆる種類の数学に適用できる

14
00:00:39,258 --> 00:00:40,060
ということです。

15
00:00:40,740 --> 00:00:44,615
しかし、これが 20 分ほどの時間をかける価値があるのは、 

16
00:00:44,615 --> 00:00:48,362
互いに適切に構成する構成要素を定義するという、数学全体を 

17
00:00:48,362 --> 00:00:51,980
通してより一般的に役立つレッスンを説明していることです。

18
00:00:52,400 --> 00:00:54,480
物語が進むにつれて、私が何を意味するかがわかります。

19
00:00:55,060 --> 00:00:57,940
2 次元入力と 2 次元出力を持つ関数のケースを

20
00:00:57,940 --> 00:01:00,820
動機付けるために、実数を 取り込んで実数を吐き出

21
00:01:00,820 --> 00:01:03,820
すだけの関数から、より単純なことから始めましょう。

22
00:01:05,080 --> 00:01:07,631
x の関数 f が x の他の関数 g 

23
00:01:07,631 --> 00:01:09,927
と等しいときを知りたい場合、これは 

24
00:01:09,927 --> 00:01:12,989
それらの関数のグラフが交差するときを検索すると考

25
00:01:12,989 --> 00:01:14,520
えることができますよね。

26
00:01:15,020 --> 00:01:18,520
つまり、両方の関数が同じ出力を持つ入力が得られます。

27
00:01:18,520 --> 00:01:21,571
非常に単純な例を挙げると、x の f は x の 2 

28
00:01:21,571 --> 00:01:23,830
乗であ り、x の g は定数関数 2 

29
00:01:23,830 --> 00:01:25,300
であると想像してください。

30
00:01:25,960 --> 00:01:28,640
つまり、2 の平方根を求めます。

31
00:01:29,460 --> 00:01:32,530
平方根を求めることについてほとんど何も知らなかったと

32
00:01:32,530 --> 00:01:35,482
しても、1 の 2 乗は 2 より小さく、2 の 

33
00:01:35,482 --> 00:01:38,907
2 乗は 2 より大きいことがわかるの で、ああ、これら 

34
00:01:38,907 --> 00:01:41,860
2 つの値の間に何らかの解があることがわかります。

35
00:01:42,580 --> 00:01:44,675
さらに絞り込みたい場合は、中間点 

36
00:01:44,675 --> 00:01:47,140
1 を二乗し てみるとよいでしょう。5.

37
00:01:47,720 --> 00:01:51,117
これは 2 になります。25 は少し高すぎるため、1 

38
00:01:51,117 --> 00:01:53,760
と 1 の 間の領域に焦点を当てます。5.

39
00:01:54,760 --> 00:01:56,813
などなど、おそらくこれがどのように継続するか

40
00:01:56,813 --> 00:01:58,866
がわかるでしょう。 中 間点で計算を続け、検

41
00:01:58,866 --> 00:02:00,920
索スペースを半分に切り分けることになります。

42
00:02:05,100 --> 00:02:08,697
これについて考えるもう 1 つの方法は、より高い次元に到 

43
00:02:08,697 --> 00:02:12,170
達すると簡単になりますが、代わりに、これら 2 つの関 

44
00:02:12,170 --> 00:02:15,520
数の差がゼロの場合の同等の質問に焦点を当てることです。

45
00:02:16,100 --> 00:02:20,219
これらの観点から、その差が一方の端では負であり、も 

46
00:02:20,219 --> 00:02:24,180
う一方の端では正である入力の領域が見つかりました。

47
00:02:24,180 --> 00:02:27,999
私たちはそれを 2 つに分割し、最も外側の点に 

48
00:02:27,999 --> 00:02:31,500
さまざまな兆候がある半分に注意を絞りました。

49
00:02:31,500 --> 00:02:34,617
このようにして、最終的には正確にゼロになる点に絞り込む

50
00:02:34,617 --> 00:02:37,734
必要があることを認 識しながら、境界上のさまざまな標識

51
00:02:37,734 --> 00:02:40,043
を持つ各領域を取得し、その半分の中から 

52
00:02:40,043 --> 00:02:43,160
そのような小さな領域を見つけながら、永遠に作業を続ける

53
00:02:43,160 --> 00:02:44,200
ことができました。

54
00:02:45,760 --> 00:02:48,764
つまり、方程式を解くということは、常に特定の関数がゼ

55
00:02:48,764 --> 00:02:51,768
ロに等しいときを見つけると いう枠組みで行うことがで

56
00:02:51,768 --> 00:02:54,887
き、それを行うには、このヒューリスティックがあり、f 

57
00:02:54,887 --> 00:02:57,891
がある点で正で、別の点で負である場合、その間のどこか

58
00:02:57,891 --> 00:03:00,895
を見つけることができます。 少なくとも、すべてが急激

59
00:03:00,895 --> 00:03:03,900
に変化することなくスムーズに変化する場合はゼロです。

60
00:03:03,900 --> 00:03:07,205
私がお見せしたい驚くべきことは、この種の考え方を 

61
00:03:07,205 --> 00:03:10,510
2 次元の方程式、つまり入力と出力が両方とも 2 

62
00:03:10,510 --> 00:03:14,080
次 元である関数間の方程式に拡張できるということです。

63
00:03:14,739 --> 00:03:18,130
たとえば、複素数は 2D であり、私たちが開発している 

64
00:03:18,130 --> 00:03:21,400
このツールは、複雑な方程式の解を見つけるのに最適です。

65
00:03:22,360 --> 00:03:24,289
さて、これらの 2D 関数についてたくさ

66
00:03:24,289 --> 00:03:26,218
ん話しますので、少し横 道にそれて、これ

67
00:03:26,218 --> 00:03:28,340
らをどのように説明するかを考えてみましょう。

68
00:03:29,060 --> 00:03:32,371
2D 入力と 2D 出力を持つ関数をグラフ化するには 

69
00:03:32,371 --> 00:03:35,191
4 次 元が必要ですが、2D 画面上の 3D 

70
00:03:35,191 --> 00:03:37,889
世界ではあまりうまく機 能しませんが、それで

71
00:03:37,889 --> 00:03:40,220
もいくつかの良いオプションがあります。

72
00:03:40,859 --> 00:03:45,440
1 つは、入力空間と出力空間の両方を並べて見ることです。

73
00:03:45,540 --> 00:03:49,062
入力空間内の各点は出力空間内の特定の点に移動し

74
00:03:49,062 --> 00:03:52,584
、その入力点の周りの移動 が出力空間内の特定の

75
00:03:52,584 --> 00:03:56,260
動きにどのように対応するかを示すことができます。

76
00:03:56,940 --> 00:04:00,100
私たちが考慮する関数はすべて連続的であり、入力に対 

77
00:04:00,100 --> 00:04:03,261
する小さな小さな変化は出力の小さな小さな変化にのみ 

78
00:04:03,261 --> 00:04:06,300
対応するという意味で、突然のジャンプはありません。

79
00:04:06,940 --> 00:04:10,153
もう 1 つのオプションは、出力空間の原点から

80
00:04:10,153 --> 00:04:13,925
その出力点までの矢印を 想像し、その矢印のミニチュア 

81
00:04:13,925 --> 00:04:16,579
バージョンを入力点に接続することです。

82
00:04:17,360 --> 00:04:20,150
これにより、特定の入力ポイントがどこに行くのか、また

83
00:04:20,150 --> 00:04:22,941
は完全なベクトル フィール ドを描画することで多くの

84
00:04:22,941 --> 00:04:25,840
異なる入力ポイントがどこに行くのかが一目でわかります。

85
00:04:27,600 --> 00:04:30,766
残念ながら、多くのポイントでこれを行うと、かなり乱雑になる可

86
00:04:30,766 --> 00:04:33,933
 能性があるため、ここではすべての矢印を同じサイズにします。

87
00:04:33,933 --> 00:04:37,100
 これは、各出力ポイントの方向を把握できることを意味します。

88
00:04:37,780 --> 00:04:40,646
しかし、おそらく 2 次元関数を説明する最も美

89
00:04:40,646 --> 00:04:43,513
しい方法は、このビデオ で最も使用する方法であ

90
00:04:43,513 --> 00:04:46,380
り、出力空間内の各点を色に関連付けることです。

91
00:04:47,220 --> 00:04:50,230
ここでは、原点から遠ざかる方向に対応するために

92
00:04:50,230 --> 00:04:53,240
色相、つまり虹 またはカラー ホイールに沿って

93
00:04:53,240 --> 00:04:55,333
色が分布する場所を使用し、原点 

94
00:04:55,333 --> 00:04:59,260
からの距離に対応するために暗さまたは明るさを使用しています。

95
00:04:59,260 --> 00:05:04,527
たとえば、この出力配列に注目すると、これらの点はすべて赤で 

96
00:05:04,527 --> 00:05:09,620
すが、原点に近い点は少し暗く、遠い点は少し明るくなります。

97
00:05:10,360 --> 00:05:14,241
この出力の配列に注目すると、すべての点が緑色であり、 

98
00:05:14,241 --> 00:05:17,980
原点に近いほど暗く、遠いほど明るいことを意味します。

99
00:05:18,780 --> 00:05:21,871
など、ここで行っているのは各方向に特定の色を割り 

100
00:05:21,871 --> 00:05:24,840
当てているだけであり、すべて継続的に変化します。

101
00:05:25,359 --> 00:05:28,504
ここでの暗さと明るさの違いは非常に微妙であることに気 

102
00:05:28,504 --> 00:05:31,648
づくかもしれませんが、このビデオでは、出力の方向だけ 

103
00:05:31,648 --> 00:05:34,560
が重要であり、大きさ、色相、明るさではありません。

104
00:05:35,300 --> 00:05:37,863
明るさに関して注目していただきたい重要な

105
00:05:37,863 --> 00:05:40,427
点は、特定の方向のな い原点付近では、す

106
00:05:40,427 --> 00:05:43,120
べての色が黒にフェードアウトすることです。

107
00:05:44,440 --> 00:05:48,771
関数について考えるために、各出力の色を決定したので 

108
00:05:48,771 --> 00:05:53,102
、出力空間で到達する点の色に基づいて入力空間の各点 

109
00:05:53,102 --> 00:05:57,100
を色付けすることで 2D 関数を視覚化できます。

110
00:05:57,840 --> 00:06:02,063
私は、多くの異なる点が入力空間から出力空間の対応する出 

111
00:06:02,063 --> 00:06:06,287
力に飛び移り、着地した点の色に基づいてペイントされ、入 

112
00:06:06,287 --> 00:06:10,360
力空間の元の場所に飛び戻る様子を想像するのが好きです。

113
00:06:11,640 --> 00:06:13,806
入力空間内のすべてのポイントに対してこれを行

114
00:06:13,806 --> 00:06:15,973
うと、その入力空間を見 るだけで、関数が各ポ

115
00:06:15,973 --> 00:06:18,140
イントを取得するおおよその場所がわかります。

116
00:06:18,140 --> 00:06:21,520
たとえば、左側のピンク色の点のストライプは、こ

117
00:06:21,520 --> 00:06:24,900
れらの点すべてがピンク 色の方向、つまり出力空

118
00:06:24,900 --> 00:06:28,280
間の左下にマッピングされることを示しています。

119
00:06:29,780 --> 00:06:32,417
また、周囲が黒く色がたくさんある 

120
00:06:32,417 --> 00:06:34,900
3 つの点は、ゼロになる点です。

121
00:06:39,340 --> 00:06:42,215
わかりました。 1 次元の場合と同様に、2 

122
00:06:42,215 --> 00:06:44,306
次元関数の方程式を解くことは、 

123
00:06:44,306 --> 00:06:47,442
特定の関数がいつゼロに等しいかを尋ねることによっ

124
00:06:47,442 --> 00:06:48,880
て常に再構成できます。

125
00:06:49,580 --> 00:06:55,435
それが今の私たちの課題です。 与えられた 2D 関数のどの 

126
00:06:55,435 --> 00:07:00,900
入力点がゼロになるかを見つけるアルゴリズムを作成します。

127
00:07:00,900 --> 00:07:03,366
このようなカラー マップを見ている場合、これら

128
00:07:03,366 --> 00:07:05,833
の黒い点を見れば、関数 のゼロがどこにあるかが

129
00:07:05,833 --> 00:07:08,300
すでにわかっていると指摘されるかもしれません。

130
00:07:08,620 --> 00:07:11,080
それで、それはカウントされますか？

131
00:07:11,080 --> 00:07:14,363
このような図を作成するために、コンピューターに平面上の

132
00:07:14,363 --> 00:07:17,646
すべてのピクセ ルで関数を計算させましたが、私たちの目

133
00:07:17,646 --> 00:07:20,929
標は、できるだけ少ない点で関 数を計算するだけで済む、

134
00:07:20,929 --> 00:07:23,725
より効率的なアルゴリズムを見つけることである 

135
00:07:23,725 --> 00:07:27,008
ことに注意してください。 いわば、色の見え方が限られて

136
00:07:27,008 --> 00:07:27,860
いるだけです。

137
00:07:29,360 --> 00:07:34,305
また、より理論的な観点から見ると、特定の領域内にゼロが存 

138
00:07:34,305 --> 00:07:39,080
在するかどうかの条件を示す一般的な構成があれば便利です。

139
00:07:39,080 --> 00:07:41,940
ある次元での主要な洞察は、連続関数がある点で

140
00:07:41,940 --> 00:07:44,800
正で別の点で負である場合 、その間のどこかで

141
00:07:44,800 --> 00:07:47,920
ゼロになるはずだということを思い出してください。

142
00:07:48,840 --> 00:07:50,580
では、それを二次元に拡張するにはどうすればよいでしょうか?

143
00:07:50,940 --> 00:07:53,580
記号について話すのに似たようなものが必要です。

144
00:07:54,700 --> 00:07:58,140
標識とは何かについて考える 1 つの方法は、方向です。

145
00:07:58,800 --> 00:08:01,261
正は数直線に沿って右を指していることを意味 

146
00:08:01,261 --> 00:08:03,500
し、負は左を指していることを意味します。

147
00:08:04,200 --> 00:08:06,492
2 次元の量にも方向がありますが、2 

148
00:08:06,492 --> 00:08:09,025
次元の量の場合、選択肢は はるかに広く、可

149
00:08:09,025 --> 00:08:11,800
能性の円全体に沿ってどこを指すこともできます。

150
00:08:12,530 --> 00:08:17,071
したがって、1 次元で特定の関数が範囲の境界 (わずか 

151
00:08:17,071 --> 00:08:21,613
2 点) で正であるか負であるかを尋ねるのと同じように 

152
00:08:21,613 --> 00:08:25,182
、2 次元関数の場合は領域の境界を調べます。

153
00:08:25,182 --> 00:08:29,724
 はループであ り、その境界に沿った関数の出力の方向につ

154
00:08:29,724 --> 00:08:30,860
いて尋ねます。

155
00:08:33,640 --> 00:08:37,490
たとえば、このゼロを中心としたループに沿って、出力があら 

156
00:08:37,490 --> 00:08:41,341
ゆる方向、つまり虹のすべての色、赤、黄、緑、青から赤に戻 

157
00:08:41,341 --> 00:08:45,060
り、途中でその間のすべての色を通過することがわかります。

158
00:08:45,700 --> 00:08:48,642
しかし、このループに沿って、内部にゼロがないので、出

159
00:08:48,642 --> 00:08:51,584
力はすべての色を通過するわ けではなく、オレンジ色の

160
00:08:51,584 --> 00:08:54,640
いくつかを通過しますが、たとえば緑や青は通過しません。

161
00:08:55,300 --> 00:08:56,880
これは有望であり、ある次元で物事がど

162
00:08:56,880 --> 00:08:58,460
のように機能したかによく似ています。

163
00:08:59,340 --> 00:09:03,316
おそらく、1 次元関数が 1 次元領域の境界で両方

164
00:09:03,316 --> 00:09:07,293
の可能な符号を 取る場合、内部のどこかにゼロがあっ

165
00:09:07,293 --> 00:09:11,270
たのと同じように、2 次元関 数がすべての可能な方

166
00:09:11,270 --> 00:09:14,928
向、すべての可能な色の出力を、 2D 領域の 

167
00:09:14,928 --> 00:09:18,905
境界にある場合、その領域内のどこかでゼロになる必要

168
00:09:18,905 --> 00:09:19,860
があります。

169
00:09:20,960 --> 00:09:23,632
これは私たちの推測であり、これが真実であるべきかどうか、 

170
00:09:23,632 --> 00:09:26,120
そうであるならなぜその理由について少し考えてください。

171
00:09:27,420 --> 00:09:30,373
ある入力点の周りの小さなループについて考え始めると

172
00:09:30,373 --> 00:09:33,326
、すべてが連続しているた め、関数が対応する出力近

173
00:09:33,326 --> 00:09:36,280
くの小さなループにそれを取り込むことがわかります。

174
00:09:37,140 --> 00:09:40,520
ただし、ほとんどの小さなループでは、出力の色が異なります。

175
00:09:40,980 --> 00:09:45,345
ゼロ以外の出力点を選択し、その近くに十分に密なループを描画 

176
00:09:45,345 --> 00:09:49,420
すると、ループの色はすべてその点とほぼ同じ色になります。

177
00:09:49,840 --> 00:09:52,453
ここのタイトなループはすべて青みがかっており、こ

178
00:09:52,453 --> 00:09:55,066
ちらのタイトなループはす べて黄色がかっています

179
00:09:55,066 --> 00:09:57,680
が、虹のすべての色が得られるわけではありません。

180
00:09:58,220 --> 00:10:02,343
すべての色を取得しながらその周りのループを締めることが 

181
00:10:02,343 --> 00:10:06,320
できる唯一のポイントは、無色の原点であるゼロ自体です。

182
00:10:07,100 --> 00:10:10,266
したがって、虹のすべての色を通過するループがあり、締め付 

183
00:10:10,266 --> 00:10:13,432
けて締め付け、ある点を狭めていく場合、その点は実際にはゼ 

184
00:10:13,432 --> 00:10:16,380
ロでなければならないということは実際に当てはまります。

185
00:10:17,320 --> 00:10:19,541
それでは、1 次元方程式ソルバーと同じように 

186
00:10:19,541 --> 00:10:21,860
2 次元方程式ソルバーをセットアップしましょう。

187
00:10:22,260 --> 00:10:26,147
境界がすべての色を通過する大きな領域を見つけたら、それを 

188
00:10:26,147 --> 00:10:29,900
2 つに分割し、それぞれの半分の境界にある色を調べます。

189
00:10:30,540 --> 00:10:33,226
ここに示す例では、左半分の境界線はすべての色を通過し

190
00:10:33,226 --> 00:10:35,913
ているわけではなく、たとえ ば、オレンジがかった黄色

191
00:10:35,913 --> 00:10:38,600
がかった方向にマッピングされるポイントはありません。

192
00:10:39,060 --> 00:10:40,794
したがって、これ以上検索したくないとい

193
00:10:40,794 --> 00:10:42,620
う意味で、この領域をグレー表示にします。

194
00:10:43,380 --> 00:10:47,104
右半分はすべての色を通過し、緑の方向に多くの時間を費やし 

195
00:10:47,104 --> 00:10:50,700
、その後、黄、オレンジ、赤、青、紫、ピンクを通過します。

196
00:10:51,560 --> 00:10:54,512
これが意味するのは、この境界の点がすべての可能な方向の 

197
00:10:54,512 --> 00:10:57,360
出力にマッピングされるということを思い出してください。

198
00:10:57,840 --> 00:10:59,850
そこで、さらに詳しく調べて、再度細

199
00:10:59,850 --> 00:11:01,860
分化し、各領域の境界を確認します。

200
00:11:02,880 --> 00:11:06,560
上部の境界はすべて緑色なので、そこで探索を終了します。

201
00:11:06,860 --> 00:11:09,520
しかし、底部は細分化に値するほどカラフルです。

202
00:11:10,340 --> 00:11:12,020
そしてこのまま続けてください。

203
00:11:12,360 --> 00:11:15,360
どのサブ領域にすべての可能な色をカバーする境界があ

204
00:11:15,360 --> 00:11:18,360
るかを確認し ます。 つまり、その境界の点がすべて

205
00:11:18,360 --> 00:11:20,520
の可能な方向にマッピングさ れ、1 

206
00:11:20,520 --> 00:11:23,760
次元の場合と同様にそれらの領域を半分に切り続け、最終 

207
00:11:23,760 --> 00:11:25,680
的に関数全体をゼロに導きます。 

208
00:11:25,680 --> 00:11:27,480
ああ、ちょっと待ってください。

209
00:11:28,880 --> 00:11:29,920
ここで何が起こったのでしょうか？

210
00:11:30,380 --> 00:11:33,634
右下の最後のサブディビジョンはどちらもすべての色を通過し 

211
00:11:33,634 --> 00:11:36,889
なかったので、アルゴリズムはそれらのいずれも検索したくな 

212
00:11:36,889 --> 00:11:39,920
かったため停止しましたが、ゼロも見つかりませんでした。

213
00:11:41,060 --> 00:11:43,300
さて、明らかにここで何かが間違っています。

214
00:11:43,540 --> 00:11:46,520
大丈夫、数学をやっていると間違うのはつきものです。

215
00:11:46,520 --> 00:11:49,865
振り返ってみると、この仮説があり、それがこの提案されたア 

216
00:11:49,865 --> 00:11:52,980
ルゴリズムにつながったので、どこかで間違っていました。

217
00:11:53,660 --> 00:11:56,473
そして、数学が得意であるということは、最初から正しいと 

218
00:11:56,473 --> 00:11:59,187
いうことではなく、注意深く振り返って間違いを理解し、 

219
00:11:59,187 --> 00:12:01,800
それらを修正する方法を理解する回復力を持つことです。

220
00:12:02,480 --> 00:12:04,872
ここでの問題は、境界線がすべての色を通過する領域

221
00:12:04,872 --> 00:12:06,566
があったのですが、それを中央で分 

222
00:12:06,566 --> 00:12:08,958
割すると、どちらのサブ領域の境界線もすべての色を

223
00:12:08,958 --> 00:12:10,653
通過しなくなり、次にどこで検索を 

224
00:12:10,653 --> 00:12:13,045
続けるかについての選択肢がなく、それがゼロを突破

225
00:12:13,045 --> 00:12:14,740
してしまうことです。 ファインダ。

226
00:12:14,740 --> 00:12:16,104
さて、ある次元では、このような

227
00:12:16,104 --> 00:12:17,560
ことは決して起こりませんでした。

228
00:12:17,980 --> 00:12:21,593
端点の符号が異なる区間がある場合、それ 

229
00:12:21,593 --> 00:12:25,207
を分割すると、端点の符号も異なる部分区 

230
00:12:25,207 --> 00:12:28,460
間が確実に得られることがわかります。

231
00:12:29,020 --> 00:12:31,961
別の言い方をすると、終点の符号が変わらない 

232
00:12:31,961 --> 00:12:35,304
2 つの区間がある場合、それらを結合すると、終点 

233
00:12:35,304 --> 00:12:38,380
の符号も変わらないより大きな区間が得られます。

234
00:12:39,080 --> 00:12:42,548
しかし、2 次元では、境界線がすべての色を通過するわ 

235
00:12:42,548 --> 00:12:45,888
けではなく、境界線が結合してすべての色を通過する境 

236
00:12:45,888 --> 00:12:49,100
界線を持つ 2 つの領域を見つけることができます。

237
00:12:49,840 --> 00:12:51,627
そしてまさにこのようにして、私たちが提案し

238
00:12:51,627 --> 00:12:53,500
たゼロ探索アルゴリズムは機能しませんでした。

239
00:12:54,380 --> 00:12:58,517
実際、よく考えてみると、内側にゼロがなく、境界線がすべての 

240
00:12:58,517 --> 00:13:02,380
可能な色を通過する大きなループを見つけることができます。

241
00:13:03,080 --> 00:13:06,031
これは、すべての色を通過する永遠に狭くなるループはゼ

242
00:13:06,031 --> 00:13:08,982
ロに近づく必要があると述べた とき、小さなループに関

243
00:13:08,982 --> 00:13:12,160
する私たちの主張が間違っていたということではありません。

244
00:13:12,800 --> 00:13:15,071
しかし、私たちにとって問題を引き起こしたのは、領域を結

245
00:13:15,071 --> 00:13:17,512
合するときに、この dos-my-border-go-t 

246
00:13:17,512 --> 00:13:19,699
hrough-every-color-or-not 

247
00:13:19,699 --> 00:13:22,140
プロパティが、適切かつ予測可能な方法で結合しないことです。

248
00:13:23,000 --> 00:13:24,720
ただし、心配しないでください。 

249
00:13:24,720 --> 00:13:26,977
これを少し変更して、必要なものを実現する 

250
00:13:26,977 --> 00:13:29,557
より洗練されたプロパティを組み合わせることができ

251
00:13:29,557 --> 00:13:30,740
ることがわかりました。

252
00:13:38,180 --> 00:13:40,520
このアイデアは、単にループ沿いのある点で色が

253
00:13:40,520 --> 00:13:42,860
見つかるかどうか を尋ねるのではなく、そのル

254
00:13:42,860 --> 00:13:44,775
ープを歩き回るときにこれらの色がど 

255
00:13:44,775 --> 00:13:47,860
のように変化するかをより注意深く追跡しようというものです。

256
00:13:48,580 --> 00:13:49,960
例を挙げて私が何を意味するのかを説明しましょう。

257
00:13:50,400 --> 00:13:51,829
追跡しやすくするために、ここの隅に小

258
00:13:51,829 --> 00:13:53,260
さなカラーホイールを置いておきます。

259
00:13:53,940 --> 00:13:57,718
入力のパスに沿った色が、赤から黄色、黄から緑、 

260
00:13:57,718 --> 00:14:01,496
緑から青、または青から赤という特定の方向に虹を 

261
00:14:01,496 --> 00:14:04,960
通って移動すると、出力は時計回りに振れます。

262
00:14:05,700 --> 00:14:09,131
しかしその一方で、色が虹を通って青から緑、

263
00:14:09,131 --> 00:14:12,562
緑から黄、黄から赤、ま たは赤から青へ逆方

264
00:14:12,562 --> 00:14:16,320
向に移動する場合、出力は反時計回りに振れます。

265
00:14:17,160 --> 00:14:20,445
ここでこの短いパスに沿って歩くと、色はカラー 

266
00:14:20,445 --> 00:14:24,015
ホイールを時計回り に 5 分の 1 曲がります。

267
00:14:24,015 --> 00:14:27,443
 そして、このパスに沿って歩くと、色 はカラー 

268
00:14:27,443 --> 00:14:31,300
ホイールを時計回りにさらに 5 分の 1 曲がります。

269
00:14:31,300 --> 00:14:35,036
もちろん、これは、両方のパスを順番に通過すると、色が時 

270
00:14:35,036 --> 00:14:38,640
計回りに合計 5 分の 2 回転することを意味します。

271
00:14:39,280 --> 00:14:43,256
巻き上げの総量は加算されるだけであり、これが重要になるでし 

272
00:14:43,256 --> 00:14:47,100
ょう。 これは私たちにとって役立つ、簡単な組み合わせです。

273
00:14:47,100 --> 00:14:50,643
総巻き上げ量というと、矢印が時計回りに回転

274
00:14:50,643 --> 00:14:54,187
すると前進し、反時計回 りに回転すると後進

275
00:14:54,187 --> 00:14:57,900
する昔ながらの走行距離計を想像してください。

276
00:14:58,740 --> 00:15:00,600
したがって、反時計回りの巻きは負の時

277
00:15:00,600 --> 00:15:02,460
計回りの巻きとしてカウントされます。

278
00:15:03,000 --> 00:15:05,744
出力は大きく回転する可能性がありますが、その回 

279
00:15:05,744 --> 00:15:08,260
転の一部が反対方向にある場合は相殺されます。

280
00:15:08,920 --> 00:15:12,047
たとえば、このパスに沿って前方に移動し、同じパス

281
00:15:12,047 --> 00:15:15,175
に沿って後方 に移動すると、巻き上げの総量は最終

282
00:15:15,175 --> 00:15:18,303
的にゼロになり、後方への移 動は文字通り前に見た

283
00:15:18,303 --> 00:15:21,040
色を巻き戻し、前の巻き上げをすべて反転し 

284
00:15:21,040 --> 00:15:24,167
、元の色に戻ります。 オドメーターがスタート地点

285
00:15:24,167 --> 00:15:25,080
に戻りました。

286
00:15:26,280 --> 00:15:28,089
私たちの目的では、ループに沿った巻き付

287
00:15:28,089 --> 00:15:29,900
けを観察することに最も重点を置きます。

288
00:15:30,440 --> 00:15:34,780
たとえば、このループ全体を時計回りに歩くとします。

289
00:15:34,780 --> 00:15:40,583
私たちが目にする出力は時計回りに合計 3 回転し、色は 

290
00:15:40,583 --> 00:15:46,180
虹の中を順番に、赤から赤、そしてまた赤へと変化します。

291
00:15:46,920 --> 00:15:50,639
数学者が使う専門用語では、このループに沿っ 

292
00:15:50,639 --> 00:15:54,020
た巻き数の合計は 3 であると言います。

293
00:15:54,020 --> 00:15:57,113
他のループの場合、これは他の整数になる可能性があり、入力が 

294
00:15:57,113 --> 00:16:00,103
1 つのループを 周回するときに出力が何度も変動する場合は

295
00:16:00,103 --> 00:16:02,990
より大きな値になる可能性があり、出力 が 1 回か 2 

296
00:16:02,990 --> 00:16:05,980
回しか変動しない場合はより小さい数になる可能性があります。

297
00:16:06,320 --> 00:16:10,462
あるいは、ループを時計回りに歩くときに出力が反時計回りに 

298
00:16:10,462 --> 00:16:14,320
振れる場合、その巻数は負の整数になる可能性もあります。

299
00:16:15,180 --> 00:16:16,970
ただし、どのループに沿っても、この巻

300
00:16:16,970 --> 00:16:18,860
線の合計量は整数でなければなりません。

301
00:16:20,880 --> 00:16:22,995
つまり、最初の場所に戻るまでに、最初 

302
00:16:22,995 --> 00:16:25,000
と同じ出力が得られることになります。

303
00:16:26,180 --> 00:16:30,062
ちなみに、実際にパスに出力が正確にゼロになる点が含ま 

304
00:16:30,062 --> 00:16:33,945
れている場合、出力には特定の方向がないため、技術的に 

305
00:16:33,945 --> 00:16:37,540
はそれに沿った曲がり数を定義することはできません。

306
00:16:37,540 --> 00:16:40,050
私たちの目標はゼロを見つけることなので、これは私たちにと

307
00:16:40,050 --> 00:16:41,484
って問題にはなりません。 その 

308
00:16:41,484 --> 00:16:43,994
ため、もしこのようなことが起こったとしても、私たちは早く

309
00:16:43,994 --> 00:16:45,160
に幸運に恵まれただけです。

310
00:16:45,160 --> 00:16:46,943
これらの曲がりくねった数値について注目すべ

311
00:16:46,943 --> 00:16:48,726
き主な点は、パスをより 大きなパスに結合す

312
00:16:48,726 --> 00:16:50,680
ると、それらの数値が適切に加算されることです。

313
00:16:54,800 --> 00:16:57,346
しかし、私たちが本当に望んでいるのは、リージョンを結合し

314
00:16:57,346 --> 00:16:59,893
てより大きなリージョンを作成 するときに、リージョンの境

315
00:16:59,893 --> 00:17:02,440
界に沿った曲がりくねった数字が適切に合計されることです。

316
00:17:02,980 --> 00:17:04,520
それで、私たちはその財産を持っていますか？

317
00:17:07,760 --> 00:17:09,060
まあ、見てください。

318
00:17:09,540 --> 00:17:13,315
左側のこの領域の周りを時計回りに進むときの巻き数 

319
00:17:13,315 --> 00:17:16,940
は、これら 4 つのパスからの巻き数の合計です。

320
00:17:17,500 --> 00:17:20,992
そして、右側のこの領域の周囲を時計回りに進むときの曲が 

321
00:17:20,992 --> 00:17:24,359
りは、これら 4 つのパスからの曲がりの数の合計です。

322
00:17:25,339 --> 00:17:27,691
そして、これら 2 つの領域をより大きな領域

323
00:17:27,691 --> 00:17:30,042
に結合すると、それらの パスのほとんどは、よ

324
00:17:30,042 --> 00:17:32,500
り大きな領域の時計回りの境界の一部になります。

325
00:17:33,260 --> 00:17:35,800
では、そうでない 2 つのパスについてはどうでしょうか?

326
00:17:36,020 --> 00:17:38,996
それらは完全に打ち消し合い、そのうちの 1 つはちょう 

327
00:17:38,996 --> 00:17:41,760
ど逆で、前に見たようにもう 1 つは巻き戻されます。

328
00:17:42,560 --> 00:17:45,230
したがって、地域の境界に沿った曲がりくねった数

329
00:17:45,230 --> 00:17:47,900
字は、私たちが望んでいるとおりに合計されます。

330
00:17:48,640 --> 00:17:51,250
また、余談ですが、このように方向性のある境界線がう

331
00:17:51,250 --> 00:17:53,860
まく合計されるという推論は 数学でよく出てきて、ス

332
00:17:53,860 --> 00:17:56,680
トークスの定理という名前で呼ばれることがよくあります。

333
00:17:57,060 --> 00:17:59,040
多変数微積分を勉強したことがある人なら、そ

334
00:17:59,040 --> 00:18:01,020
の文脈からそれを認識できるかもしれません。

335
00:18:02,360 --> 00:18:04,840
さて、いよいよ、曲がりくねった数字を手に入

336
00:18:04,840 --> 00:18:07,440
れて、方程式を解く目標に戻ることができます。

337
00:18:08,000 --> 00:18:11,970
先ほど見た領域の問題は、その境界がすべての可能な色を通過して

338
00:18:11,970 --> 00:18:15,940
 いるにもかかわらず、実際には巻き数が 0 であることです。

339
00:18:16,500 --> 00:18:19,981
出力は、黄色から赤に向かって半分ほど巻き、その後

340
00:18:19,981 --> 00:18:23,462
、反時計回りに反 対方向に戻り始め、その後、青を

341
00:18:23,462 --> 00:18:26,508
通過し続け、反対方向から赤に到達し ます。

342
00:18:26,508 --> 00:18:30,860
 すべて、巻き線の合計がゼロになるような方法で行われました。

343
00:18:31,840 --> 00:18:35,080
しかし、すべての色にヒットするだけでなく、巻き数がゼ

344
00:18:35,080 --> 00:18:38,320
ロではないと いうより強力な条件を備えたループを見つ

345
00:18:38,320 --> 00:18:41,560
けた場合、それを半分に分 割した場合、それらの半分の

346
00:18:41,560 --> 00:18:45,049
少なくとも 1 つは確実にゼロ以外の巻 き数も同様です。

347
00:18:45,049 --> 00:18:48,040
 これは、物事が希望どおりに合計されるためです。

348
00:18:48,440 --> 00:18:50,970
このようにして、1 点にどんどん絞

349
00:18:50,970 --> 00:18:53,500
り込んで進み続けることができます。

350
00:18:54,050 --> 00:18:57,137
そして、点を絞り込むとき、ゼロ以外の巻き数を持つ小さなループ

351
00:18:57,137 --> 00:18:58,990
を使用して絞り込む ことになります。

352
00:18:58,990 --> 00:19:02,077
 これは、ループがすべての可能な色を通過することを意味し、し

353
00:19:02,077 --> 00:19:04,959
たが って、前に述べたように、絞り込まれている点はon 

354
00:19:04,959 --> 00:19:06,400
はゼロでなければなりません。

355
00:19:07,420 --> 00:19:08,360
以上です！

356
00:19:08,600 --> 00:19:11,658
これで 2 次元方程式ソルバーが作成されま した。

357
00:19:11,658 --> 00:19:13,860
 今回はバグがないことを約束します。

358
00:19:14,560 --> 00:19:17,540
巻線番号はまさにこれを機能させるために必要なツールです。

359
00:19:18,100 --> 00:19:20,931
これで、f と g の差がどのように変化するかを考

360
00:19:20,931 --> 00:19:23,762
慮するだけで、2 次元で x の f が x の 

361
00:19:23,762 --> 00:19:26,820
g に等しいかというような方程式を解くことができます。

362
00:19:27,600 --> 00:19:30,067
巻き数が 0 ではないループがある場合はいつでも、

363
00:19:30,067 --> 00:19:32,534
そのループに対してこのアル ゴリズムを実行でき、ル

364
00:19:32,534 --> 00:19:35,100
ープ内のどこかで必ず解が見つかることが保証されます。

365
00:19:35,660 --> 00:19:37,750
さらに、一次元の場合と同様に、このアル

366
00:19:37,750 --> 00:19:39,840
ゴリズムは信じられないほど効率的です。

367
00:19:40,240 --> 00:19:43,720
各ラウンドで領域の半分のサイズに絞り込み続けることで、すぐ

368
00:19:43,720 --> 00:19:47,200
にゼロに絞り込みま す。 その間、多くのループで関数の値を

369
00:19:47,200 --> 00:19:49,720
チェックするのではなく、これらのループの 

370
00:19:49,720 --> 00:19:52,960
ポイントに沿って関数の値をチェックするだけで済みます。

371
00:19:52,960 --> 00:19:54,400
 インテリアのポイント。

372
00:19:55,160 --> 00:19:57,939
したがって、ある意味、行われる全体的な作業は、

373
00:19:57,939 --> 00:20:00,718
検索スペースの全領域では なく、その周囲にのみ

374
00:20:00,718 --> 00:20:03,740
比例することになります。 これは驚くべきことです。

375
00:20:04,920 --> 00:20:07,524
何が起こっているのかを理解したら、これが実際に

376
00:20:07,524 --> 00:20:10,129
動作しているのを見るだけ で、これに何らかの機

377
00:20:10,129 --> 00:20:12,960
能を与え、ゼロを検索させるのは、奇妙に魅惑的です。

378
00:20:13,620 --> 00:20:16,719
前に述べたように、複素数は 2 次元なので、そ 

379
00:20:16,719 --> 00:20:19,560
れを複素数を含む方程式に適用してみましょう。

380
00:20:20,300 --> 00:20:22,857
たとえば、複素平面上で関数 x の 5 

381
00:20:22,857 --> 00:20:25,414
番目から x から 1 を引いた値までの

382
00:20:25,414 --> 00:20:28,100
ゼロを見つけるアルゴリズムを次に示します。

383
00:20:28,900 --> 00:20:31,806
それは原点の周りの非常に広い領域を検討することか 

384
00:20:31,806 --> 00:20:34,480
ら始まり、最終的に巻き数は 5 になりました。

385
00:20:35,280 --> 00:20:38,826
巻き数が 0 以外のループを見つけるたびに、それを半分 

386
00:20:38,826 --> 00:20:42,120
に分割し、2 つの小さいループの巻き数を計算します。

387
00:20:42,700 --> 00:20:45,293
それらの一方または両方の巻き数がゼロではないこと

388
00:20:45,293 --> 00:20:47,887
が保証されており 、これを見ると、その小さなルー

389
00:20:47,887 --> 00:20:50,481
プの内側のどこかにゼロがあることが わかります。

390
00:20:50,481 --> 00:20:53,400
 そのため、同じ方法で小さなスペースを検索し続けます。

391
00:20:54,180 --> 00:20:57,086
また、計算中のパスがたまたまゼロに遭遇した場

392
00:20:57,086 --> 00:20:59,332
合にも、領域の探索を 停止します。

393
00:20:59,332 --> 00:21:02,900
 これは、この例の右半分で実際に 1 回発生しました。

394
00:21:03,280 --> 00:21:05,766
このようなまれな出来事は、巻数を計算する能 

395
00:21:05,766 --> 00:21:08,140
力を妨げますが、まあ、ゼロが得られました。

396
00:21:09,220 --> 00:21:11,010
また、巻き数が 0 のループに

397
00:21:11,010 --> 00:21:12,920
ついては、それ以上探索しません。

398
00:21:12,920 --> 00:21:13,979
おそらく彼らは内部に解決策を持っているかも

399
00:21:13,979 --> 00:21:15,342
しれませんが、もしかしたら持っていないかもしれません。

400
00:21:15,342 --> 00:21:16,200
 私たちには何の保証もありません。

401
00:21:18,400 --> 00:21:21,327
そして、方程式ソルバーを同じ方法で継続させると、 

402
00:21:21,327 --> 00:21:24,020
最終的にはこの多項式の多くのゼロに収束します。

403
00:21:25,840 --> 00:21:28,563
ちなみに、この例の総巻き数がたまたま 

404
00:21:28,563 --> 00:21:31,000
5 だったのは偶然ではありません。

405
00:21:31,580 --> 00:21:36,148
複素数の場合、x から n への操作は、入力の原点の周りを 

406
00:21:36,148 --> 00:21:39,803
1 回歩く のと同じように、出力の原点の周りを 

407
00:21:39,803 --> 00:21:42,240
n 回歩くことに直接対応します。

408
00:21:44,680 --> 00:21:48,465
したがって、多項式では、入力が十分に大きい場合、先頭の 

409
00:21:48,465 --> 00:21:51,980
項以外のすべての項は比較すると重要ではなくなります。

410
00:21:52,480 --> 00:21:56,260
したがって、主項が x から n までである複素多項式は 

411
00:21:56,260 --> 00:21:59,780
、十分に大きなループの周りに n の巻き数を持ちます。

412
00:22:00,540 --> 00:22:03,749
このようにして、当社の巻数技術は実際に、すべ 

413
00:22:03,749 --> 00:22:06,820
ての複素多項式がゼロを持つことを保証します。

414
00:22:07,480 --> 00:22:12,000
これは数学者が代数学の基本定理と呼ぶほど重要な事実です。

415
00:22:13,800 --> 00:22:17,884
このような方程式の数値解を見つけるアルゴリズムは非常に実 

416
00:22:17,884 --> 00:22:21,968
用的ですが、代数学の基本定理は、これらの巻き数が理論レベ 

417
00:22:21,968 --> 00:22:25,912
ルでも非常に役立つことを示す良い例であり、広範なクラス 

418
00:22:25,912 --> 00:22:30,137
の解の存在を保証します。 適切な条件を方程式で導き出すとい 

419
00:22:30,137 --> 00:22:33,940
うもので、むしろ数学者が考えるのが好きな類のものです。

420
00:22:33,940 --> 00:22:37,030
フォローアップ ビデオでは、トポロジに関連したこれの驚

421
00:22:37,030 --> 00:22:39,090
くべき応用例をいくつか紹介し ます。

422
00:22:39,090 --> 00:22:41,494
 これには、古い 3blue1brown 

423
00:22:41,494 --> 00:22:43,440
ビデオの間違いの修正も含まれます。

424
00:22:44,060 --> 00:22:44,440
どれ？

425
00:22:44,940 --> 00:22:47,371
このチャンネルのすべてのビデオを見て、まず間違 

426
00:22:47,371 --> 00:22:49,600
いを見つけられるかどうかを確認してください。

427
00:22:51,300 --> 00:22:59,116
このビデオの主な作成者は、3blue1brown 

428
00:22:59,116 --> 00:23:06,933
チームの最 新メンバーの 1 人、Sridhar 

429
00:23:06,933 --> 00:23:10,060
Ramesh です。

