1
00:00:00,000 --> 00:00:06,720
ここにはメイントピックとメタトピックの 2 つがあります。

2
00:00:06,720 --> 00:00:10,380
主なトピックは、2 次元方程式、2 つの未知の実数

3
00:00:10,380 --> 00:00:14,041
を持つもの、または 1 つの未知の複素数を含むもの

4
00:00:14,041 --> 00:00:17,420
を解くための、この非常に優れたアルゴリズムです。

5
00:00:17,420 --> 00:00:20,727
たとえば、多項式の複素根を見つけたい場合、またはおそらく

6
00:00:20,727 --> 00:00:23,920
リーマン ゼータ関数の数百万ドルのゼロの一部を見つけた

7
00:00:23,920 --> 00:00:27,000
い場合は、このアルゴリズムが代わりにそれを実行します。

8
00:00:27,000 --> 00:00:28,760
そしてこの方法はたくさんの色が使

9
00:00:28,760 --> 00:00:30,520
われているのでとてもきれいです。

10
00:00:30,520 --> 00:00:32,960
そしてさらに重要なことは、核となる基礎的な考え

11
00:00:32,960 --> 00:00:35,400
方は、この方程式 を解くためのアルゴリズムをは

12
00:00:35,400 --> 00:00:37,310
るかに超えて、後で説明する少しのト

13
00:00:37,310 --> 00:00:39,751
ポロジーを含め、あらゆる種類の数学に適用できる

14
00:00:39,751 --> 00:00:40,600
ということです。

15
00:00:40,600 --> 00:00:44,572
しかし、これが 20 分ほどの時間をかける価値があるのは、

16
00:00:44,572 --> 00:00:48,412
互いに適切に構成する構成要素を定義するという、数学全体を

17
00:00:48,412 --> 00:00:52,120
通してより一般的に役立つレッスンを説明していることです。

18
00:00:52,120 --> 00:00:55,460
物語が進むにつれて、私が何を意味するかがわかります。

19
00:00:55,460 --> 00:00:58,629
2 次元入力と 2 次元出力を持つ関数のケースを

20
00:00:58,629 --> 00:01:01,798
動機付けるために、実数を 取り込んで実数を吐き出

21
00:01:01,798 --> 00:01:05,100
すだけの関数から、より単純なことから始めましょう。

22
00:01:05,100 --> 00:01:07,575
x の関数 f が x の他の関数 g

23
00:01:07,575 --> 00:01:09,803
と等しいときを知りたい場合、これは

24
00:01:09,803 --> 00:01:12,774
それらの関数のグラフが交差するときを検索すると考

25
00:01:12,774 --> 00:01:14,260
えることができますよね。

26
00:01:14,260 --> 00:01:19,340
つまり、両方の関数が同じ出力を持つ入力が得られます。

27
00:01:19,340 --> 00:01:22,121
非常に単純な例を挙げると、x の f は x の 2

28
00:01:22,121 --> 00:01:24,181
乗であ り、x の g は定数関数 2

29
00:01:24,181 --> 00:01:25,520
であると想像してください。

30
00:01:25,520 --> 00:01:29,620
つまり、2 の平方根を求めます。

31
00:01:29,620 --> 00:01:32,844
平方根を求めることについてほとんど何も知らなかったと

32
00:01:32,844 --> 00:01:35,944
しても、1 の 2 乗は 2 より小さく、2 の

33
00:01:35,944 --> 00:01:39,540
2 乗は 2 より大きいことがわかるの で、ああ、これら

34
00:01:39,540 --> 00:01:42,640
2 つの値の間に何らかの解があることがわかります。

35
00:01:42,640 --> 00:01:44,983
さらに絞り込みたい場合は、中間点

36
00:01:44,983 --> 00:01:47,740
1 を二乗し てみるとよいでしょう。5.

37
00:01:47,740 --> 00:01:51,790
これは 2 になります。25 は少し高すぎるため、1

38
00:01:51,790 --> 00:01:54,940
と 1 の 間の領域に焦点を当てます。5.

39
00:01:54,940 --> 00:01:58,473
などなど、おそらくこれがどのように継続するか

40
00:01:58,473 --> 00:02:02,006
がわかるでしょう。 中 間点で計算を続け、検

41
00:02:02,006 --> 00:02:05,540
索スペースを半分に切り分けることになります。

42
00:02:05,540 --> 00:02:09,282
これについて考えるもう 1 つの方法は、より高い次元に到

43
00:02:09,282 --> 00:02:12,895
達すると簡単になりますが、代わりに、これら 2 つの関

44
00:02:12,895 --> 00:02:16,380
数の差がゼロの場合の同等の質問に焦点を当てることです。

45
00:02:16,380 --> 00:02:20,274
これらの観点から、その差が一方の端では負であり、も

46
00:02:20,274 --> 00:02:24,020
う一方の端では正である入力の領域が見つかりました。

47
00:02:24,020 --> 00:02:27,974
私たちはそれを 2 つに分割し、最も外側の点に

48
00:02:27,974 --> 00:02:31,600
さまざまな兆候がある半分に注意を絞りました。

49
00:02:31,600 --> 00:02:35,198
このようにして、最終的には正確にゼロになる点に絞り込む

50
00:02:35,198 --> 00:02:38,796
必要があることを認 識しながら、境界上のさまざまな標識

51
00:02:38,796 --> 00:02:41,462
を持つ各領域を取得し、その半分の中から

52
00:02:41,462 --> 00:02:45,060
そのような小さな領域を見つけながら、永遠に作業を続ける

53
00:02:45,060 --> 00:02:46,260
ことができました。

54
00:02:46,260 --> 00:02:49,194
つまり、方程式を解くということは、常に特定の関数がゼ

55
00:02:49,194 --> 00:02:52,129
ロに等しいときを見つけると いう枠組みで行うことがで

56
00:02:52,129 --> 00:02:55,176
き、それを行うには、このヒューリスティックがあり、f

57
00:02:55,176 --> 00:02:58,110
がある点で正で、別の点で負である場合、その間のどこか

58
00:02:58,110 --> 00:03:01,045
を見つけることができます。 少なくとも、すべてが急激

59
00:03:01,045 --> 00:03:03,980
に変化することなくスムーズに変化する場合はゼロです。

60
00:03:03,980 --> 00:03:07,538
私がお見せしたい驚くべきことは、この種の考え方を

61
00:03:07,538 --> 00:03:11,096
2 次元の方程式、つまり入力と出力が両方とも 2

62
00:03:11,096 --> 00:03:14,940
次 元である関数間の方程式に拡張できるということです。

63
00:03:14,940 --> 00:03:18,422
たとえば、複素数は 2D であり、私たちが開発している

64
00:03:18,422 --> 00:03:21,780
このツールは、複雑な方程式の解を見つけるのに最適です。

65
00:03:21,780 --> 00:03:24,231
さて、これらの 2D 関数についてたくさ

66
00:03:24,231 --> 00:03:26,683
ん話しますので、少し横 道にそれて、これ

67
00:03:26,683 --> 00:03:29,380
らをどのように説明するかを考えてみましょう。

68
00:03:29,380 --> 00:03:32,869
2D 入力と 2D 出力を持つ関数をグラフ化するには

69
00:03:32,869 --> 00:03:35,841
4 次 元が必要ですが、2D 画面上の 3D

70
00:03:35,841 --> 00:03:38,684
世界ではあまりうまく機 能しませんが、それで

71
00:03:38,684 --> 00:03:41,140
もいくつかの良いオプションがあります。

72
00:03:41,140 --> 00:03:46,020
1 つは、入力空間と出力空間の両方を並べて見ることです。

73
00:03:46,020 --> 00:03:49,647
入力空間内の各点は出力空間内の特定の点に移動し

74
00:03:49,647 --> 00:03:53,274
、その入力点の周りの移動 が出力空間内の特定の

75
00:03:53,274 --> 00:03:57,060
動きにどのように対応するかを示すことができます。

76
00:03:57,060 --> 00:04:00,571
私たちが考慮する関数はすべて連続的であり、入力に対

77
00:04:00,571 --> 00:04:04,083
する小さな小さな変化は出力の小さな小さな変化にのみ

78
00:04:04,083 --> 00:04:07,460
対応するという意味で、突然のジャンプはありません。

79
00:04:07,460 --> 00:04:10,766
もう 1 つのオプションは、出力空間の原点から

80
00:04:10,766 --> 00:04:14,648
その出力点までの矢印を 想像し、その矢印のミニチュア

81
00:04:14,648 --> 00:04:17,380
バージョンを入力点に接続することです。

82
00:04:17,380 --> 00:04:20,736
これにより、特定の入力ポイントがどこに行くのか、また

83
00:04:20,736 --> 00:04:24,093
は完全なベクトル フィール ドを描画することで多くの

84
00:04:24,093 --> 00:04:27,580
異なる入力ポイントがどこに行くのかが一目でわかります。

85
00:04:27,580 --> 00:04:31,020
残念ながら、多くのポイントでこれを行うと、かなり乱雑になる可

86
00:04:31,020 --> 00:04:34,460
能性があるため、ここではすべての矢印を同じサイズにします。

87
00:04:34,460 --> 00:04:37,900
これは、各出力ポイントの方向を把握できることを意味します。

88
00:04:37,900 --> 00:04:41,066
しかし、おそらく 2 次元関数を説明する最も美

89
00:04:41,066 --> 00:04:44,233
しい方法は、このビデオ で最も使用する方法であ

90
00:04:44,233 --> 00:04:47,400
り、出力空間内の各点を色に関連付けることです。

91
00:04:47,400 --> 00:04:50,565
ここでは、原点から遠ざかる方向に対応するために

92
00:04:50,565 --> 00:04:53,730
色相、つまり虹 またはカラー ホイールに沿って

93
00:04:53,730 --> 00:04:55,931
色が分布する場所を使用し、原点

94
00:04:55,931 --> 00:05:00,060
からの距離に対応するために暗さまたは明るさを使用しています。

95
00:05:00,060 --> 00:05:05,287
たとえば、この出力配列に注目すると、これらの点はすべて赤で

96
00:05:05,287 --> 00:05:10,340
すが、原点に近い点は少し暗く、遠い点は少し明るくなります。

97
00:05:10,340 --> 00:05:14,741
この出力の配列に注目すると、すべての点が緑色であり、

98
00:05:14,741 --> 00:05:18,980
原点に近いほど暗く、遠いほど明るいことを意味します。

99
00:05:18,980 --> 00:05:22,204
など、ここで行っているのは各方向に特定の色を割り

100
00:05:22,204 --> 00:05:25,300
当てているだけであり、すべて継続的に変化します。

101
00:05:25,300 --> 00:05:28,717
ここでの暗さと明るさの違いは非常に微妙であることに気

102
00:05:28,717 --> 00:05:32,135
づくかもしれませんが、このビデオでは、出力の方向だけ

103
00:05:32,135 --> 00:05:35,300
が重要であり、大きさ、色相、明るさではありません。

104
00:05:35,300 --> 00:05:38,296
明るさに関して注目していただきたい重要な

105
00:05:38,296 --> 00:05:41,293
点は、特定の方向のな い原点付近では、す

106
00:05:41,293 --> 00:05:44,440
べての色が黒にフェードアウトすることです。

107
00:05:44,440 --> 00:05:49,031
関数について考えるために、各出力の色を決定したので

108
00:05:49,031 --> 00:05:53,622
、出力空間で到達する点の色に基づいて入力空間の各点

109
00:05:53,622 --> 00:05:57,860
を色付けすることで 2D 関数を視覚化できます。

110
00:05:57,860 --> 00:06:02,569
私は、多くの異なる点が入力空間から出力空間の対応する出

111
00:06:02,569 --> 00:06:07,278
力に飛び移り、着地した点の色に基づいてペイントされ、入

112
00:06:07,278 --> 00:06:11,820
力空間の元の場所に飛び戻る様子を想像するのが好きです。

113
00:06:11,820 --> 00:06:14,260
入力空間内のすべてのポイントに対してこれを行

114
00:06:14,260 --> 00:06:16,700
うと、その入力空間を見 るだけで、関数が各ポ

115
00:06:16,700 --> 00:06:19,140
イントを取得するおおよその場所がわかります。

116
00:06:19,140 --> 00:06:22,760
たとえば、左側のピンク色の点のストライプは、こ

117
00:06:22,760 --> 00:06:26,380
れらの点すべてがピンク 色の方向、つまり出力空

118
00:06:26,380 --> 00:06:30,000
間の左下にマッピングされることを示しています。

119
00:06:30,000 --> 00:06:33,667
また、周囲が黒く色がたくさんある

120
00:06:33,667 --> 00:06:37,120
3 つの点は、ゼロになる点です。

121
00:06:37,120 --> 00:06:40,935
わかりました。 1 次元の場合と同様に、2

122
00:06:40,935 --> 00:06:43,710
次元関数の方程式を解くことは、

123
00:06:43,710 --> 00:06:47,872
特定の関数がいつゼロに等しいかを尋ねることによっ

124
00:06:47,872 --> 00:06:49,780
て常に再構成できます。

125
00:06:49,780 --> 00:06:55,531
それが今の私たちの課題です。 与えられた 2D 関数のどの

126
00:06:55,531 --> 00:07:00,900
入力点がゼロになるかを見つけるアルゴリズムを作成します。

127
00:07:00,900 --> 00:07:03,500
このようなカラー マップを見ている場合、これら

128
00:07:03,500 --> 00:07:06,100
の黒い点を見れば、関数 のゼロがどこにあるかが

129
00:07:06,100 --> 00:07:08,700
すでにわかっていると指摘されるかもしれません。

130
00:07:08,700 --> 00:07:11,460
それで、それはカウントされますか？

131
00:07:11,460 --> 00:07:15,009
このような図を作成するために、コンピューターに平面上の

132
00:07:15,009 --> 00:07:18,558
すべてのピクセ ルで関数を計算させましたが、私たちの目

133
00:07:18,558 --> 00:07:22,107
標は、できるだけ少ない点で関 数を計算するだけで済む、

134
00:07:22,107 --> 00:07:25,130
より効率的なアルゴリズムを見つけることである

135
00:07:25,130 --> 00:07:28,679
ことに注意してください。 いわば、色の見え方が限られて

136
00:07:28,679 --> 00:07:29,600
いるだけです。

137
00:07:29,600 --> 00:07:34,026
また、より理論的な観点から見ると、特定の領域内にゼロが存

138
00:07:34,026 --> 00:07:38,300
在するかどうかの条件を示す一般的な構成があれば便利です。

139
00:07:38,300 --> 00:07:41,735
ある次元での主要な洞察は、連続関数がある点で

140
00:07:41,735 --> 00:07:45,171
正で別の点で負である場合 、その間のどこかで

141
00:07:45,171 --> 00:07:48,920
ゼロになるはずだということを思い出してください。

142
00:07:48,920 --> 00:07:50,960
では、それを二次元に拡張するにはどうすればよいでしょうか?

143
00:07:50,960 --> 00:07:55,180
記号について話すのに似たようなものが必要です。

144
00:07:55,180 --> 00:07:59,140
標識とは何かについて考える 1 つの方法は、方向です。

145
00:07:59,140 --> 00:08:01,811
正は数直線に沿って右を指していることを意味

146
00:08:01,811 --> 00:08:04,240
し、負は左を指していることを意味します。

147
00:08:04,240 --> 00:08:06,815
2 次元の量にも方向がありますが、2

148
00:08:06,815 --> 00:08:09,662
次元の量の場合、選択肢は はるかに広く、可

149
00:08:09,662 --> 00:08:12,780
能性の円全体に沿ってどこを指すこともできます。

150
00:08:12,780 --> 00:08:17,978
したがって、1 次元で特定の関数が範囲の境界 (わずか

151
00:08:17,978 --> 00:08:23,177
2 点) で正であるか負であるかを尋ねるのと同じように

152
00:08:23,177 --> 00:08:27,261
、2 次元関数の場合は領域の境界を調べます。

153
00:08:27,261 --> 00:08:32,460
はループであ り、その境界に沿った関数の出力の方向につ

154
00:08:32,460 --> 00:08:33,760
いて尋ねます。

155
00:08:33,760 --> 00:08:37,826
たとえば、このゼロを中心としたループに沿って、出力があら

156
00:08:37,826 --> 00:08:41,893
ゆる方向、つまり虹のすべての色、赤、黄、緑、青から赤に戻

157
00:08:41,893 --> 00:08:45,820
り、途中でその間のすべての色を通過することがわかります。

158
00:08:45,820 --> 00:08:48,979
しかし、このループに沿って、内部にゼロがないので、出

159
00:08:48,979 --> 00:08:52,138
力はすべての色を通過するわ けではなく、オレンジ色の

160
00:08:52,138 --> 00:08:55,420
いくつかを通過しますが、たとえば緑や青は通過しません。

161
00:08:55,420 --> 00:08:57,370
これは有望であり、ある次元で物事がど

162
00:08:57,370 --> 00:08:59,320
のように機能したかによく似ています。

163
00:08:59,320 --> 00:09:03,517
おそらく、1 次元関数が 1 次元領域の境界で両方

164
00:09:03,517 --> 00:09:07,715
の可能な符号を 取る場合、内部のどこかにゼロがあっ

165
00:09:07,715 --> 00:09:11,913
たのと同じように、2 次元関 数がすべての可能な方

166
00:09:11,913 --> 00:09:15,774
向、すべての可能な色の出力を、 2D 領域の

167
00:09:15,774 --> 00:09:19,972
境界にある場合、その領域内のどこかでゼロになる必要

168
00:09:19,972 --> 00:09:20,980
があります。

169
00:09:20,980 --> 00:09:24,439
これは私たちの推測であり、これが真実であるべきかどうか、

170
00:09:24,439 --> 00:09:27,660
そうであるならなぜその理由について少し考えてください。

171
00:09:27,660 --> 00:09:30,660
ある入力点の周りの小さなループについて考え始めると

172
00:09:30,660 --> 00:09:33,660
、すべてが連続しているた め、関数が対応する出力近

173
00:09:33,660 --> 00:09:36,660
くの小さなループにそれを取り込むことがわかります。

174
00:09:36,660 --> 00:09:41,140
ただし、ほとんどの小さなループでは、出力の色が異なります。

175
00:09:41,140 --> 00:09:45,650
ゼロ以外の出力点を選択し、その近くに十分に密なループを描画

176
00:09:45,650 --> 00:09:49,860
すると、ループの色はすべてその点とほぼ同じ色になります。

177
00:09:49,860 --> 00:09:52,720
ここのタイトなループはすべて青みがかっており、こ

178
00:09:52,720 --> 00:09:55,580
ちらのタイトなループはす べて黄色がかっています

179
00:09:55,580 --> 00:09:58,440
が、虹のすべての色が得られるわけではありません。

180
00:09:58,440 --> 00:10:02,858
すべての色を取得しながらその周りのループを締めることが

181
00:10:02,858 --> 00:10:07,120
できる唯一のポイントは、無色の原点であるゼロ自体です。

182
00:10:07,120 --> 00:10:10,613
したがって、虹のすべての色を通過するループがあり、締め付

183
00:10:10,613 --> 00:10:14,107
けて締め付け、ある点を狭めていく場合、その点は実際にはゼ

184
00:10:14,107 --> 00:10:17,360
ロでなければならないということは実際に当てはまります。

185
00:10:17,360 --> 00:10:19,806
それでは、1 次元方程式ソルバーと同じように

186
00:10:19,806 --> 00:10:22,360
2 次元方程式ソルバーをセットアップしましょう。

187
00:10:22,360 --> 00:10:26,572
境界がすべての色を通過する大きな領域を見つけたら、それを

188
00:10:26,572 --> 00:10:30,640
2 つに分割し、それぞれの半分の境界にある色を調べます。

189
00:10:30,640 --> 00:10:33,453
ここに示す例では、左半分の境界線はすべての色を通過し

190
00:10:33,453 --> 00:10:36,266
ているわけではなく、たとえ ば、オレンジがかった黄色

191
00:10:36,266 --> 00:10:39,080
がかった方向にマッピングされるポイントはありません。

192
00:10:39,080 --> 00:10:41,223
したがって、これ以上検索したくないとい

193
00:10:41,223 --> 00:10:43,480
う意味で、この領域をグレー表示にします。

194
00:10:43,480 --> 00:10:47,367
右半分はすべての色を通過し、緑の方向に多くの時間を費やし

195
00:10:47,367 --> 00:10:51,120
、その後、黄、オレンジ、赤、青、紫、ピンクを通過します。

196
00:10:51,120 --> 00:10:54,520
これが意味するのは、この境界の点がすべての可能な方向の

197
00:10:54,520 --> 00:10:57,800
出力にマッピングされるということを思い出してください。

198
00:10:57,800 --> 00:11:00,350
そこで、さらに詳しく調べて、再度細

199
00:11:00,350 --> 00:11:02,900
分化し、各領域の境界を確認します。

200
00:11:02,900 --> 00:11:07,000
上部の境界はすべて緑色なので、そこで探索を終了します。

201
00:11:07,000 --> 00:11:10,500
しかし、底部は細分化に値するほどカラフルです。

202
00:11:10,500 --> 00:11:12,420
そしてこのまま続けてください。

203
00:11:12,420 --> 00:11:15,773
どのサブ領域にすべての可能な色をカバーする境界があ

204
00:11:15,773 --> 00:11:19,126
るかを確認し ます。 つまり、その境界の点がすべて

205
00:11:19,126 --> 00:11:21,540
の可能な方向にマッピングさ れ、1

206
00:11:21,540 --> 00:11:25,162
次元の場合と同様にそれらの領域を半分に切り続け、最終

207
00:11:25,162 --> 00:11:27,308
的に関数全体をゼロに導きます。

208
00:11:27,308 --> 00:11:29,320
ああ、ちょっと待ってください。

209
00:11:29,320 --> 00:11:30,320
ここで何が起こったのでしょうか？

210
00:11:30,320 --> 00:11:34,018
右下の最後のサブディビジョンはどちらもすべての色を通過し

211
00:11:34,018 --> 00:11:37,716
なかったので、アルゴリズムはそれらのいずれも検索したくな

212
00:11:37,716 --> 00:11:41,160
かったため停止しましたが、ゼロも見つかりませんでした。

213
00:11:41,160 --> 00:11:43,720
さて、明らかにここで何かが間違っています。

214
00:11:43,720 --> 00:11:46,680
大丈夫、数学をやっていると間違うのはつきものです。

215
00:11:46,680 --> 00:11:50,305
振り返ってみると、この仮説があり、それがこの提案されたア

216
00:11:50,305 --> 00:11:53,680
ルゴリズムにつながったので、どこかで間違っていました。

217
00:11:53,680 --> 00:11:56,735
そして、数学が得意であるということは、最初から正しいと

218
00:11:56,735 --> 00:11:59,682
いうことではなく、注意深く振り返って間違いを理解し、

219
00:11:59,682 --> 00:12:02,520
それらを修正する方法を理解する回復力を持つことです。

220
00:12:02,520 --> 00:12:05,009
ここでの問題は、境界線がすべての色を通過する領域

221
00:12:05,009 --> 00:12:06,773
があったのですが、それを中央で分

222
00:12:06,773 --> 00:12:09,263
割すると、どちらのサブ領域の境界線もすべての色を

223
00:12:09,263 --> 00:12:11,026
通過しなくなり、次にどこで検索を

224
00:12:11,026 --> 00:12:13,516
続けるかについての選択肢がなく、それがゼロを突破

225
00:12:13,516 --> 00:12:15,280
してしまうことです。 ファインダ。

226
00:12:15,280 --> 00:12:16,654
さて、ある次元では、このような

227
00:12:16,654 --> 00:12:18,120
ことは決して起こりませんでした。

228
00:12:18,120 --> 00:12:21,940
端点の符号が異なる区間がある場合、それ

229
00:12:21,940 --> 00:12:25,761
を分割すると、端点の符号も異なる部分区

230
00:12:25,761 --> 00:12:29,200
間が確実に得られることがわかります。

231
00:12:29,200 --> 00:12:32,368
別の言い方をすると、終点の符号が変わらない

232
00:12:32,368 --> 00:12:35,968
2 つの区間がある場合、それらを結合すると、終点

233
00:12:35,968 --> 00:12:39,280
の符号も変わらないより大きな区間が得られます。

234
00:12:39,280 --> 00:12:42,970
しかし、2 次元では、境界線がすべての色を通過するわ

235
00:12:42,970 --> 00:12:46,523
けではなく、境界線が結合してすべての色を通過する境

236
00:12:46,523 --> 00:12:49,940
界線を持つ 2 つの領域を見つけることができます。

237
00:12:49,940 --> 00:12:51,795
そしてまさにこのようにして、私たちが提案し

238
00:12:51,795 --> 00:12:53,740
たゼロ探索アルゴリズムは機能しませんでした。

239
00:12:53,740 --> 00:12:58,591
実際、よく考えてみると、内側にゼロがなく、境界線がすべての

240
00:12:58,591 --> 00:13:03,120
可能な色を通過する大きなループを見つけることができます。

241
00:13:03,120 --> 00:13:06,344
これは、すべての色を通過する永遠に狭くなるループはゼ

242
00:13:06,344 --> 00:13:09,568
ロに近づく必要があると述べた とき、小さなループに関

243
00:13:09,568 --> 00:13:13,040
する私たちの主張が間違っていたということではありません。

244
00:13:13,040 --> 00:13:15,472
しかし、私たちにとって問題を引き起こしたのは、領域を結

245
00:13:15,472 --> 00:13:18,085
合するときに、この dos-my-border-go-t

246
00:13:18,085 --> 00:13:20,427
hrough-every-color-or-not

247
00:13:20,427 --> 00:13:23,040
プロパティが、適切かつ予測可能な方法で結合しないことです。

248
00:13:23,040 --> 00:13:26,488
ただし、心配しないでください。

249
00:13:26,488 --> 00:13:31,015
これを少し変更して、必要なものを実現する

250
00:13:31,015 --> 00:13:36,188
より洗練されたプロパティを組み合わせることができ

251
00:13:36,188 --> 00:13:38,560
ることがわかりました。

252
00:13:38,560 --> 00:13:40,866
このアイデアは、単にループ沿いのある点で色が

253
00:13:40,866 --> 00:13:43,172
見つかるかどうか を尋ねるのではなく、そのル

254
00:13:43,172 --> 00:13:45,059
ープを歩き回るときにこれらの色がど

255
00:13:45,059 --> 00:13:48,100
のように変化するかをより注意深く追跡しようというものです。

256
00:13:48,100 --> 00:13:50,060
例を挙げて私が何を意味するのかを説明しましょう。

257
00:13:50,060 --> 00:13:52,090
追跡しやすくするために、ここの隅に小

258
00:13:52,090 --> 00:13:54,120
さなカラーホイールを置いておきます。

259
00:13:54,120 --> 00:13:58,097
入力のパスに沿った色が、赤から黄色、黄から緑、

260
00:13:58,097 --> 00:14:02,074
緑から青、または青から赤という特定の方向に虹を

261
00:14:02,074 --> 00:14:05,720
通って移動すると、出力は時計回りに振れます。

262
00:14:05,720 --> 00:14:09,416
しかしその一方で、色が虹を通って青から緑、

263
00:14:09,416 --> 00:14:13,112
緑から黄、黄から赤、ま たは赤から青へ逆方

264
00:14:13,112 --> 00:14:17,160
向に移動する場合、出力は反時計回りに振れます。

265
00:14:17,160 --> 00:14:20,287
ここでこの短いパスに沿って歩くと、色はカラー

266
00:14:20,287 --> 00:14:23,686
ホイールを時計回り に 5 分の 1 曲がります。

267
00:14:23,686 --> 00:14:26,949
そして、このパスに沿って歩くと、色 はカラー

268
00:14:26,949 --> 00:14:30,620
ホイールを時計回りにさらに 5 分の 1 曲がります。

269
00:14:30,620 --> 00:14:35,079
もちろん、これは、両方のパスを順番に通過すると、色が時

270
00:14:35,079 --> 00:14:39,380
計回りに合計 5 分の 2 回転することを意味します。

271
00:14:39,380 --> 00:14:43,325
巻き上げの総量は加算されるだけであり、これが重要になるでし

272
00:14:43,325 --> 00:14:47,140
ょう。 これは私たちにとって役立つ、簡単な組み合わせです。

273
00:14:47,140 --> 00:14:50,933
総巻き上げ量というと、矢印が時計回りに回転

274
00:14:50,933 --> 00:14:54,726
すると前進し、反時計回 りに回転すると後進

275
00:14:54,726 --> 00:14:58,700
する昔ながらの走行距離計を想像してください。

276
00:14:58,700 --> 00:15:00,860
したがって、反時計回りの巻きは負の時

277
00:15:00,860 --> 00:15:03,020
計回りの巻きとしてカウントされます。

278
00:15:03,020 --> 00:15:06,108
出力は大きく回転する可能性がありますが、その回

279
00:15:06,108 --> 00:15:08,940
転の一部が反対方向にある場合は相殺されます。

280
00:15:08,940 --> 00:15:12,300
たとえば、このパスに沿って前方に移動し、同じパス

281
00:15:12,300 --> 00:15:15,660
に沿って後方 に移動すると、巻き上げの総量は最終

282
00:15:15,660 --> 00:15:19,020
的にゼロになり、後方への移 動は文字通り前に見た

283
00:15:19,020 --> 00:15:21,960
色を巻き戻し、前の巻き上げをすべて反転し

284
00:15:21,960 --> 00:15:25,320
、元の色に戻ります。 オドメーターがスタート地点

285
00:15:25,320 --> 00:15:26,300
に戻りました。

286
00:15:26,300 --> 00:15:28,390
私たちの目的では、ループに沿った巻き付

287
00:15:28,390 --> 00:15:30,480
けを観察することに最も重点を置きます。

288
00:15:30,480 --> 00:15:34,280
たとえば、このループ全体を時計回りに歩くとします。

289
00:15:34,280 --> 00:15:40,816
私たちが目にする出力は時計回りに合計 3 回転し、色は

290
00:15:40,816 --> 00:15:47,120
虹の中を順番に、赤から赤、そしてまた赤へと変化します。

291
00:15:47,120 --> 00:15:50,776
数学者が使う専門用語では、このループに沿っ

292
00:15:50,776 --> 00:15:54,100
た巻き数の合計は 3 であると言います。

293
00:15:54,100 --> 00:15:57,451
他のループの場合、これは他の整数になる可能性があり、入力が

294
00:15:57,451 --> 00:16:00,691
1 つのループを 周回するときに出力が何度も変動する場合は

295
00:16:00,691 --> 00:16:03,820
より大きな値になる可能性があり、出力 が 1 回か 2

296
00:16:03,820 --> 00:16:07,060
回しか変動しない場合はより小さい数になる可能性があります。

297
00:16:07,060 --> 00:16:11,275
あるいは、ループを時計回りに歩くときに出力が反時計回りに

298
00:16:11,275 --> 00:16:15,200
振れる場合、その巻数は負の整数になる可能性もあります。

299
00:16:15,200 --> 00:16:17,398
ただし、どのループに沿っても、この巻

300
00:16:17,398 --> 00:16:19,720
線の合計量は整数でなければなりません。

301
00:16:19,720 --> 00:16:22,862
つまり、最初の場所に戻るまでに、最初

302
00:16:22,862 --> 00:16:25,840
と同じ出力が得られることになります。

303
00:16:25,840 --> 00:16:29,859
ちなみに、実際にパスに出力が正確にゼロになる点が含ま

304
00:16:29,859 --> 00:16:33,878
れている場合、出力には特定の方向がないため、技術的に

305
00:16:33,878 --> 00:16:37,600
はそれに沿った曲がり数を定義することはできません。

306
00:16:37,600 --> 00:16:40,103
私たちの目標はゼロを見つけることなので、これは私たちにと

307
00:16:40,103 --> 00:16:41,534
って問題にはなりません。 その

308
00:16:41,534 --> 00:16:44,037
ため、もしこのようなことが起こったとしても、私たちは早く

309
00:16:44,037 --> 00:16:45,200
に幸運に恵まれただけです。

310
00:16:45,200 --> 00:16:48,379
これらの曲がりくねった数値について注目すべ

311
00:16:48,379 --> 00:16:51,558
き主な点は、パスをより 大きなパスに結合す

312
00:16:51,558 --> 00:16:55,040
ると、それらの数値が適切に加算されることです。

313
00:16:55,040 --> 00:16:57,733
しかし、私たちが本当に望んでいるのは、リージョンを結合し

314
00:16:57,733 --> 00:17:00,426
てより大きなリージョンを作成 するときに、リージョンの境

315
00:17:00,426 --> 00:17:03,120
界に沿った曲がりくねった数字が適切に合計されることです。

316
00:17:03,120 --> 00:17:06,320
それで、私たちはその財産を持っていますか？

317
00:17:06,320 --> 00:17:09,600
まあ、見てください。

318
00:17:09,600 --> 00:17:13,844
左側のこの領域の周りを時計回りに進むときの巻き数

319
00:17:13,844 --> 00:17:17,920
は、これら 4 つのパスからの巻き数の合計です。

320
00:17:17,920 --> 00:17:21,768
そして、右側のこの領域の周囲を時計回りに進むときの曲が

321
00:17:21,768 --> 00:17:25,480
りは、これら 4 つのパスからの曲がりの数の合計です。

322
00:17:25,480 --> 00:17:28,198
そして、これら 2 つの領域をより大きな領域

323
00:17:28,198 --> 00:17:30,917
に結合すると、それらの パスのほとんどは、よ

324
00:17:30,917 --> 00:17:33,760
り大きな領域の時計回りの境界の一部になります。

325
00:17:33,760 --> 00:17:36,040
では、そうでない 2 つのパスについてはどうでしょうか?

326
00:17:36,040 --> 00:17:39,472
それらは完全に打ち消し合い、そのうちの 1 つはちょう

327
00:17:39,472 --> 00:17:42,660
ど逆で、前に見たようにもう 1 つは巻き戻されます。

328
00:17:42,660 --> 00:17:45,750
したがって、地域の境界に沿った曲がりくねった数

329
00:17:45,750 --> 00:17:48,840
字は、私たちが望んでいるとおりに合計されます。

330
00:17:48,840 --> 00:17:51,593
また、余談ですが、このように方向性のある境界線がう

331
00:17:51,593 --> 00:17:54,346
まく合計されるという推論は 数学でよく出てきて、ス

332
00:17:54,346 --> 00:17:57,320
トークスの定理という名前で呼ばれることがよくあります。

333
00:17:57,320 --> 00:18:00,100
多変数微積分を勉強したことがある人なら、そ

334
00:18:00,100 --> 00:18:02,880
の文脈からそれを認識できるかもしれません。

335
00:18:02,880 --> 00:18:05,400
さて、いよいよ、曲がりくねった数字を手に入

336
00:18:05,400 --> 00:18:08,040
れて、方程式を解く目標に戻ることができます。

337
00:18:08,040 --> 00:18:12,330
先ほど見た領域の問題は、その境界がすべての可能な色を通過して

338
00:18:12,330 --> 00:18:16,620
いるにもかかわらず、実際には巻き数が 0 であることです。

339
00:18:16,620 --> 00:18:20,358
出力は、黄色から赤に向かって半分ほど巻き、その後

340
00:18:20,358 --> 00:18:24,096
、反時計回りに反 対方向に戻り始め、その後、青を

341
00:18:24,096 --> 00:18:27,367
通過し続け、反対方向から赤に到達し ます。

342
00:18:27,367 --> 00:18:32,040
すべて、巻き線の合計がゼロになるような方法で行われました。

343
00:18:32,040 --> 00:18:35,352
しかし、すべての色にヒットするだけでなく、巻き数がゼ

344
00:18:35,352 --> 00:18:38,664
ロではないと いうより強力な条件を備えたループを見つ

345
00:18:38,664 --> 00:18:41,976
けた場合、それを半分に分 割した場合、それらの半分の

346
00:18:41,976 --> 00:18:45,542
少なくとも 1 つは確実にゼロ以外の巻 き数も同様です。

347
00:18:45,542 --> 00:18:48,600
これは、物事が希望どおりに合計されるためです。

348
00:18:48,600 --> 00:18:51,440
このようにして、1 点にどんどん絞

349
00:18:51,440 --> 00:18:54,280
り込んで進み続けることができます。

350
00:18:54,280 --> 00:18:57,630
そして、点を絞り込むとき、ゼロ以外の巻き数を持つ小さなループ

351
00:18:57,630 --> 00:18:59,640
を使用して絞り込む ことになります。

352
00:18:59,640 --> 00:19:02,990
これは、ループがすべての可能な色を通過することを意味し、し

353
00:19:02,990 --> 00:19:06,116
たが って、前に述べたように、絞り込まれている点はon

354
00:19:06,116 --> 00:19:07,680
はゼロでなければなりません。

355
00:19:07,680 --> 00:19:08,760
以上です！

356
00:19:08,760 --> 00:19:12,248
これで 2 次元方程式ソルバーが作成されま した。

357
00:19:12,248 --> 00:19:14,760
今回はバグがないことを約束します。

358
00:19:14,760 --> 00:19:18,200
巻線番号はまさにこれを機能させるために必要なツールです。

359
00:19:18,200 --> 00:19:21,271
これで、f と g の差がどのように変化するかを考

360
00:19:21,271 --> 00:19:24,342
慮するだけで、2 次元で x の f が x の

361
00:19:24,342 --> 00:19:27,660
g に等しいかというような方程式を解くことができます。

362
00:19:27,660 --> 00:19:30,127
巻き数が 0 ではないループがある場合はいつでも、

363
00:19:30,127 --> 00:19:32,594
そのループに対してこのアル ゴリズムを実行でき、ル

364
00:19:32,594 --> 00:19:35,160
ープ内のどこかで必ず解が見つかることが保証されます。

365
00:19:35,160 --> 00:19:37,730
さらに、一次元の場合と同様に、このアル

366
00:19:37,730 --> 00:19:40,300
ゴリズムは信じられないほど効率的です。

367
00:19:40,300 --> 00:19:43,971
各ラウンドで領域の半分のサイズに絞り込み続けることで、すぐ

368
00:19:43,971 --> 00:19:47,643
にゼロに絞り込みま す。 その間、多くのループで関数の値を

369
00:19:47,643 --> 00:19:50,302
チェックするのではなく、これらのループの

370
00:19:50,302 --> 00:19:53,720
ポイントに沿って関数の値をチェックするだけで済みます。

371
00:19:53,720 --> 00:19:55,240
インテリアのポイント。

372
00:19:55,240 --> 00:19:58,388
したがって、ある意味、行われる全体的な作業は、

373
00:19:58,388 --> 00:20:01,537
検索スペースの全領域では なく、その周囲にのみ

374
00:20:01,537 --> 00:20:04,960
比例することになります。 これは驚くべきことです。

375
00:20:04,960 --> 00:20:07,823
何が起こっているのかを理解したら、これが実際に

376
00:20:07,823 --> 00:20:10,687
動作しているのを見るだけ で、これに何らかの機

377
00:20:10,687 --> 00:20:13,800
能を与え、ゼロを検索させるのは、奇妙に魅惑的です。

378
00:20:13,800 --> 00:20:17,212
前に述べたように、複素数は 2 次元なので、そ

379
00:20:17,212 --> 00:20:20,340
れを複素数を含む方程式に適用してみましょう。

380
00:20:20,340 --> 00:20:23,153
たとえば、複素平面上で関数 x の 5

381
00:20:23,153 --> 00:20:25,966
番目から x から 1 を引いた値までの

382
00:20:25,966 --> 00:20:28,920
ゼロを見つけるアルゴリズムを次に示します。

383
00:20:28,920 --> 00:20:32,315
それは原点の周りの非常に広い領域を検討することか

384
00:20:32,315 --> 00:20:35,440
ら始まり、最終的に巻き数は 5 になりました。

385
00:20:35,440 --> 00:20:39,297
巻き数が 0 以外のループを見つけるたびに、それを半分

386
00:20:39,297 --> 00:20:42,880
に分割し、2 つの小さいループの巻き数を計算します。

387
00:20:42,880 --> 00:20:45,648
それらの一方または両方の巻き数がゼロではないこと

388
00:20:45,648 --> 00:20:48,416
が保証されており 、これを見ると、その小さなルー

389
00:20:48,416 --> 00:20:51,185
プの内側のどこかにゼロがあることが わかります。

390
00:20:51,185 --> 00:20:54,300
そのため、同じ方法で小さなスペースを検索し続けます。

391
00:20:54,300 --> 00:20:57,340
また、計算中のパスがたまたまゼロに遭遇した場

392
00:20:57,340 --> 00:20:59,689
合にも、領域の探索を 停止します。

393
00:20:59,689 --> 00:21:03,420
これは、この例の右半分で実際に 1 回発生しました。

394
00:21:03,420 --> 00:21:06,438
このようなまれな出来事は、巻数を計算する能

395
00:21:06,438 --> 00:21:09,320
力を妨げますが、まあ、ゼロが得られました。

396
00:21:09,320 --> 00:21:11,255
また、巻き数が 0 のループに

397
00:21:11,255 --> 00:21:13,320
ついては、それ以上探索しません。

398
00:21:13,320 --> 00:21:15,000
おそらく彼らは内部に解決策を持っているかも

399
00:21:15,000 --> 00:21:17,160
しれませんが、もしかしたら持っていないかもしれません。

400
00:21:17,160 --> 00:21:18,520
私たちには何の保証もありません。

401
00:21:18,520 --> 00:21:22,426
そして、方程式ソルバーを同じ方法で継続させると、

402
00:21:22,426 --> 00:21:26,020
最終的にはこの多項式の多くのゼロに収束します。

403
00:21:26,020 --> 00:21:28,996
ちなみに、この例の総巻き数がたまたま

404
00:21:28,996 --> 00:21:31,660
5 だったのは偶然ではありません。

405
00:21:31,660 --> 00:21:37,377
複素数の場合、x から n への操作は、入力の原点の周りを

406
00:21:37,377 --> 00:21:41,950
1 回歩く のと同じように、出力の原点の周りを

407
00:21:41,950 --> 00:21:45,000
n 回歩くことに直接対応します。

408
00:21:45,000 --> 00:21:48,992
したがって、多項式では、入力が十分に大きい場合、先頭の

409
00:21:48,992 --> 00:21:52,700
項以外のすべての項は比較すると重要ではなくなります。

410
00:21:52,700 --> 00:21:56,842
したがって、主項が x から n までである複素多項式は

411
00:21:56,842 --> 00:22:00,700
、十分に大きなループの周りに n の巻き数を持ちます。

412
00:22:00,700 --> 00:22:04,236
このようにして、当社の巻数技術は実際に、すべ

413
00:22:04,236 --> 00:22:07,620
ての複素多項式がゼロを持つことを保証します。

414
00:22:07,620 --> 00:22:13,880
これは数学者が代数学の基本定理と呼ぶほど重要な事実です。

415
00:22:13,880 --> 00:22:18,041
このような方程式の数値解を見つけるアルゴリズムは非常に実

416
00:22:18,041 --> 00:22:22,202
用的ですが、代数学の基本定理は、これらの巻き数が理論レベ

417
00:22:22,202 --> 00:22:26,220
ルでも非常に役立つことを示す良い例であり、広範なクラス

418
00:22:26,220 --> 00:22:30,525
の解の存在を保証します。 適切な条件を方程式で導き出すとい

419
00:22:30,525 --> 00:22:34,400
うもので、むしろ数学者が考えるのが好きな類のものです。

420
00:22:34,400 --> 00:22:37,548
フォローアップ ビデオでは、トポロジに関連したこれの驚

421
00:22:37,548 --> 00:22:39,648
くべき応用例をいくつか紹介し ます。

422
00:22:39,648 --> 00:22:42,097
これには、古い 3blue1brown

423
00:22:42,097 --> 00:22:44,080
ビデオの間違いの修正も含まれます。

424
00:22:44,080 --> 00:22:45,080
どれ？

425
00:22:45,080 --> 00:22:48,502
このチャンネルのすべてのビデオを見て、まず間違

426
00:22:48,502 --> 00:22:51,640
いを見つけられるかどうかを確認してください。

427
00:22:51,640 --> 00:22:53,440
このビデオの主な作成者は、3blue1brown

428
00:22:53,440 --> 00:22:55,240
チームの最 新メンバーの 1 人、Sridhar

429
00:22:55,240 --> 00:22:55,960
Ramesh です。

