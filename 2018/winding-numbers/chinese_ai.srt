1
00:00:00,000 --> 00:00:06,720
这里有两件事，主要主题和元主题。

2
00:00:06,720 --> 00:00:10,440
主要主题将是这个非常简洁的算法，用于求解二维方程，具有两个未知实数的事物，或者涉及单个未知数（复数）的事物。

3
00:00:10,440 --> 00:00:14,900


4
00:00:14,900 --> 00:00:17,420


5
00:00:17,420 --> 00:00:21,840
例如，如果您想找到多项式的复数根，或者黎曼

6
00:00:21,840 --> 00:00:25,960
zeta

7
00:00:25,960 --> 00:00:26,960
函数的一些百万美元零点，这个算法可以为您做到。

8
00:00:27,000 --> 00:00:30,520
而且这个方法超级漂亮，因为涉及到很多颜色。

9
00:00:30,520 --> 00:00:34,960
更重要的是，核心的基本思想适用于各种数学，远远超出了求解方程的算法，包括一些拓扑学，我将在后面讨论。

10
00:00:34,960 --> 00:00:39,600


11
00:00:39,600 --> 00:00:40,600


12
00:00:40,600 --> 00:00:44,880
但真正让您花费

13
00:00:44,880 --> 00:00:50,000
20

14
00:00:50,000 --> 00:00:52,120
分钟左右的时间的原因是，它说明了在整个数学中更普遍有用的课程，即尝试定义彼此完美组合的结构。

15
00:00:52,120 --> 00:00:55,460
随着故事的进展，你会明白我的意思。

16
00:00:55,460 --> 00:00:59,460
为了用具有 2d 输入和

17
00:00:59,460 --> 00:01:05,100
2d 输出的函数来激发这个案例，让我们从更简单的开始，使用只接受实数并输出实数的函数。

18
00:01:05,100 --> 00:01:10,060
如果您想知道 x 的函数 f

19
00:01:10,060 --> 00:01:14,260
何时等于 x 的其他函数 g，您可能会认为这是搜索这些函数的图形何时相交，对吧？

20
00:01:14,260 --> 00:01:19,340
我的意思是，这为您提供了两个函数具有相同输出的输入。

21
00:01:19,340 --> 00:01:24,520
举一个非常简单的例子，假设 x 的 f 是 x

22
00:01:24,520 --> 00:01:25,520
的平方，x 的 g 是常数函数 2。

23
00:01:25,520 --> 00:01:29,620
换句话说，您想要找到 2 的平方根。

24
00:01:29,620 --> 00:01:33,620
即使您对求平方根几乎一无所知，您也可能会看到 1 的平方小于

25
00:01:33,620 --> 00:01:39,260
2，而 2

26
00:01:39,260 --> 00:01:42,640
的平方大于 2，所以您意识到，啊，这两个值之间会有一些解决方案。

27
00:01:42,640 --> 00:01:46,740
然后，如果您想进一步缩小范围，也许您可以尝试对中间点 1

28
00:01:46,740 --> 00:01:47,740
进行平方。 5.

29
00:01:47,740 --> 00:01:53,060
结果是 2。 25，有点太高了，所以您应该关注 1 和

30
00:01:53,060 --> 00:01:54,940
1 之间的区域。 5.

31
00:01:54,940 --> 00:01:58,560
依此类推，您可能会看到这将如何继续下去，您将继续在中点进行计算，然后将搜索空间切成两半。

32
00:01:58,560 --> 00:02:05,540


33
00:02:05,540 --> 00:02:08,340
思考这个问题的另一种方法是，当我们达到更高的维度时，这将使我们更容易理解，即专注于这两个函数之间的差异何时为零的等效问题。

34
00:02:08,340 --> 00:02:13,560


35
00:02:13,560 --> 00:02:16,300


36
00:02:16,380 --> 00:02:20,700
就这些而言，我们发现了一个输入区域，其中一端的差异为负，另一端的差异为正。

37
00:02:20,700 --> 00:02:24,020


38
00:02:24,020 --> 00:02:28,660
我们把它分成两半，我们将注意力集中到最外面的点有不同符号的那一半。

39
00:02:28,660 --> 00:02:31,600


40
00:02:31,600 --> 00:02:36,020
像这样，我们能够永远继续前进，选取边界上具有不同标志的每个区域，在其两半中找到一个更小的这样的区域，知道最终我们必须缩小到一个恰好为零的点。

41
00:02:36,020 --> 00:02:41,320


42
00:02:41,320 --> 00:02:46,260


43
00:02:46,260 --> 00:02:50,480
简而言之，求解方程总是可以被框架为找到某个函数何时等于零，为此，我们有这样的启发式，如果

44
00:02:50,480 --> 00:02:55,780
f

45
00:02:55,780 --> 00:03:00,420
在一点为正，在另一点为负，您可以找到中间的某个位置，其中它为零，至少如果一切都顺利变化而没有突然的跳跃的话。

46
00:03:00,420 --> 00:03:03,980


47
00:03:03,980 --> 00:03:08,060
我想向您展示的令人惊奇的事情是，您可以将这种思维扩展到二维方程，即输入和输出都是二维的函数之间的方程。

48
00:03:08,060 --> 00:03:13,220


49
00:03:13,220 --> 00:03:14,940


50
00:03:14,940 --> 00:03:19,540
例如，复数是二维的，我们正在开发的这个工具非常适合寻找复杂方程的解。

51
00:03:19,540 --> 00:03:21,780


52
00:03:21,780 --> 00:03:25,700
现在，既然我们要详细讨论这些 2D

53
00:03:25,700 --> 00:03:29,380
函数，那么让我们先简单地考虑一下如何说明这些函数。

54
00:03:29,380 --> 00:03:34,700
用 2D 输入和

55
00:03:34,700 --> 00:03:39,220
2D 输出绘制一个函数需要四个维度，这在 2D

56
00:03:39,220 --> 00:03:41,140
屏幕上的 3D 世界中效果不太好，但我们仍然有一些不错的选择。

57
00:03:41,140 --> 00:03:46,020
一种是并排查看输入空间和输出空间。

58
00:03:46,020 --> 00:03:51,540
输入空间中的每个点都会移动到输出空间中的特定点，我可以展示围绕该输入点的移动如何对应于输出空间中的某些移动。

59
00:03:51,540 --> 00:03:57,060


60
00:03:57,060 --> 00:04:01,460
我们考虑的所有函数都将是连续的，从某种意义上说，输入的微小变化仅对应于输出的微小变化，不存在突然的跳跃。

61
00:04:01,460 --> 00:04:05,820


62
00:04:05,820 --> 00:04:07,460


63
00:04:07,460 --> 00:04:12,020
我们的另一个选择是想象从输出空间的原点到该输出点的箭头，并将该箭头的微型版本附加到输入点。

64
00:04:12,020 --> 00:04:17,380


65
00:04:17,380 --> 00:04:22,340
这可以让我们一目了然地了解给定输入点的去向，或者通过绘制完整的矢量场来了解许多不同输入点的去向。

66
00:04:22,340 --> 00:04:27,580


67
00:04:27,580 --> 00:04:30,740
不幸的是，当你在很多点上这样做时，它可能会变得非常混乱，所以在这里让我将所有箭头设置为相同的大小，这意味着我们可以了解每个输出点的方向。

68
00:04:30,740 --> 00:04:34,340


69
00:04:34,340 --> 00:04:37,900


70
00:04:37,900 --> 00:04:41,660
但也许说明二维函数的最漂亮的方法，也是我们在本视频中最常用的方法，是将输出空间中的每个点与一种颜色相关联。

71
00:04:41,660 --> 00:04:47,400


72
00:04:47,400 --> 00:04:52,180
在这里，我们使用色调（即颜色沿着彩虹或色轮下降的位置）来对应远离原点的方向，并且我们使用暗度或亮度来对应距原点的距离。

73
00:04:52,180 --> 00:04:57,020


74
00:04:57,020 --> 00:05:00,060


75
00:05:00,060 --> 00:05:05,720
例如，关注这个输出数组，所有这些点都是红色的，但是靠近原点的点更暗一些，远离原点的点更亮一些。

76
00:05:05,720 --> 00:05:10,340


77
00:05:10,340 --> 00:05:15,360
关注这个输出数组，所有的点都是绿色的，同样，靠近原点意味着更暗，更远意味着更亮。

78
00:05:15,360 --> 00:05:18,980


79
00:05:18,980 --> 00:05:24,300
依此类推，我们在这里所做的就是为每个方向分配特定的颜色，所有颜色都在不断变化。

80
00:05:24,300 --> 00:05:25,300


81
00:05:25,300 --> 00:05:29,100
您可能会注意到这里的黑暗和亮度差异非常微妙，但对于这个视频，我们关心的是输出的方向，而不是幅度、色调，而不是亮度。

82
00:05:29,140 --> 00:05:33,940


83
00:05:33,940 --> 00:05:35,300


84
00:05:35,300 --> 00:05:39,160
关于亮度，您需要注意的一件重要的事情是，在没有特定方向的原点附近，所有颜色都会褪色为黑色。

85
00:05:39,160 --> 00:05:44,440


86
00:05:44,440 --> 00:05:48,820
因此，在考虑函数时，现在我们已经决定了每个输出的颜色，我们可以通过根据输出空间中点的颜色为输入空间中的每个点着色来可视化

87
00:05:48,820 --> 00:05:54,020
2D

88
00:05:54,020 --> 00:05:57,860
函数。

89
00:05:57,860 --> 00:06:02,340
我喜欢想象输入空间中的许多不同点跳跃到输出空间中相应的输出，然后根据它们着陆点的颜色进行绘制，然后跳回它们在输入空间中的来源位置。

90
00:06:02,340 --> 00:06:06,340


91
00:06:06,340 --> 00:06:11,820


92
00:06:11,820 --> 00:06:15,700
对输入空间中的每个点执行此操作，只需查看该输入空间即可大致了解函数获取每个点的位置。

93
00:06:15,700 --> 00:06:19,140


94
00:06:19,140 --> 00:06:23,880
例如，左侧的粉红色点条纹告诉我们所有这些点都映射到粉红色方向的某个位置，即输出空间的左下角。

95
00:06:23,920 --> 00:06:30,000


96
00:06:30,000 --> 00:06:34,120
另外，那些周围有很多颜色的黑色点也是归零的点。

97
00:06:34,120 --> 00:06:37,120


98
00:06:37,120 --> 00:06:46,120
好吧，就像一维情况一样，二维函数的求解方程总是可以通过询问某个函数何时等于零来重新构建。

99
00:06:46,120 --> 00:06:49,780


100
00:06:49,780 --> 00:06:54,820
所以这就是我们现在的挑战，创建一个算法来查找给定 2D

101
00:06:54,820 --> 00:07:00,900
函数的哪些输入点变为零。

102
00:07:00,900 --> 00:07:04,560
您可能会指出，如果您通过看到这些黑点来查看这样的彩色图，您就已经知道函数的零点在哪里。

103
00:07:04,560 --> 00:07:08,700


104
00:07:08,700 --> 00:07:11,460
那么这算吗？

105
00:07:11,460 --> 00:07:15,100
请记住，要创建这样的图表，我们已经让计算机在平面上的所有像素上计算函数，但我们的目标是找到一种更有效的算法，只需要在尽可能少的点上计算函数，可以这么说，对颜色的了解有限。

106
00:07:15,100 --> 00:07:21,020


107
00:07:21,020 --> 00:07:25,380


108
00:07:25,380 --> 00:07:29,600


109
00:07:29,600 --> 00:07:33,940
而且从更理论的角度来看，最好有一个通用的构造来告诉我们给定区域内是否存在零的条件。

110
00:07:33,940 --> 00:07:38,300


111
00:07:38,300 --> 00:07:43,700
请记住，在一个维度上，主要见解是，如果连续函数在某一点为正，在另一点为负，则介于两者之间的某个位置必须为零。

112
00:07:43,700 --> 00:07:48,920


113
00:07:48,920 --> 00:07:50,960
那么我们如何将其扩展到二维呢？

114
00:07:50,960 --> 00:07:55,180
我们需要某种类似谈论符号的方式。

115
00:07:55,180 --> 00:07:59,140
思考标志是什么的一种方法是方向。

116
00:07:59,140 --> 00:08:02,620
正数表示您沿着数轴指向右侧，负数表示您沿着数轴指向左侧。

117
00:08:02,620 --> 00:08:04,240


118
00:08:04,240 --> 00:08:08,800
二维量也有方向，但对它们来说，选择范围要广泛得多，它们可以指向整个可能性圈中的任何地方。

119
00:08:08,800 --> 00:08:12,780


120
00:08:12,780 --> 00:08:16,860
因此，就像在一维中我们询问给定函数在范围边界（只有两个点）上是正还是负一样，对于二维函数，我们将查看一个区域的边界，是一个循环，并询问函数输出沿该边界的方向。

121
00:08:16,860 --> 00:08:22,860


122
00:08:22,860 --> 00:08:28,200


123
00:08:28,200 --> 00:08:33,760


124
00:08:33,760 --> 00:08:39,220
例如，我们看到沿着围绕这个零的循环，输出会经过每个可能的方向，彩虹的所有颜色，红色，黄色，绿色，蓝色，回到红色，以及沿途的所有颜色。

125
00:08:39,220 --> 00:08:43,460


126
00:08:43,460 --> 00:08:45,820


127
00:08:45,820 --> 00:08:50,640
但是沿着这里的循环，内部没有零，输出不会经历每种颜色，它会经历一些橙色的颜色，但永远不会经历绿色或蓝色。

128
00:08:50,640 --> 00:08:55,420


129
00:08:55,420 --> 00:08:59,320
这是有希望的，它看起来很像在一维中的运作方式。

130
00:08:59,320 --> 00:09:03,540
也许以同样的方式，如果 1d

131
00:09:03,540 --> 00:09:09,700
函数在 1d

132
00:09:09,700 --> 00:09:15,140
区域的边界上取两个可能的符号，内部某处有一个零，我们可以假设，如果 2d

133
00:09:15,140 --> 00:09:20,980
函数命中所有可能方向、所有可能颜色的输出，沿着二维区域的边界，那么该区域内的某个位置它必须为零。

134
00:09:20,980 --> 00:09:25,100
这就是我们的猜测，请花点时间思考这是否属实，如果属实，原因是什么。

135
00:09:25,100 --> 00:09:27,660


136
00:09:27,660 --> 00:09:32,020
如果我们开始考虑围绕某个输入点的小循环，我们就会知道，由于一切都是连续的，我们的函数会将其带到相应输出附近的某个小循环。

137
00:09:32,020 --> 00:09:36,660


138
00:09:36,660 --> 00:09:41,140
但请注意，对于大多数微小循环，输出的颜色各不相同。

139
00:09:41,140 --> 00:09:46,300
如果您选择零以外的任何输出点，并在其附近绘制一个足够紧密的循环，则循环的颜色将与该点的颜色大致相同。

140
00:09:46,300 --> 00:09:49,860


141
00:09:49,860 --> 00:09:55,980
这里的紧密环都是蓝色的，这里的紧密环都是淡黄色的，你当然不会得到彩虹的每种颜色。

142
00:09:55,980 --> 00:09:58,440


143
00:09:58,440 --> 00:10:03,580
唯一可以收紧它周围的循环同时仍然获得所有颜色的点是无色原点，即零本身。

144
00:10:03,580 --> 00:10:07,120


145
00:10:07,120 --> 00:10:11,680
因此，情况确实如此，如果你有循环穿过彩虹的每种颜色，收紧再收紧，缩小到一个点，那么该点实际上一定是零。

146
00:10:11,680 --> 00:10:15,960


147
00:10:15,960 --> 00:10:17,360


148
00:10:17,360 --> 00:10:22,360
因此，让我们设置一个二维方程求解器，就像我们的一维方程求解器一样。

149
00:10:22,360 --> 00:10:27,200
当我们找到一个边界穿过每种颜色的大区域时，将其分成两半，然后查看每一半边界上的颜色。

150
00:10:27,200 --> 00:10:30,640


151
00:10:30,640 --> 00:10:34,920
在此显示的示例中，左半部分的边框并未穿过所有颜色，例如，没有映射到橙黄色方向的点。

152
00:10:34,920 --> 00:10:39,080


153
00:10:39,080 --> 00:10:43,480
因此，我会将这个区域灰显，以表示我们不想再进一步搜索它。

154
00:10:43,480 --> 00:10:47,840
右半部分确实经历了所有颜色，在绿色方向上花了很多时间，然后经历了黄橙红，以及蓝紫粉色。

155
00:10:47,840 --> 00:10:51,120


156
00:10:51,120 --> 00:10:56,060
现在请记住，这意味着该边界的点被映射到所有可能方向的输出。

157
00:10:56,060 --> 00:10:57,800


158
00:10:57,800 --> 00:11:02,900
因此，我们将进一步探索它，再次细分并检查每个区域的边界。

159
00:11:02,900 --> 00:11:07,000
顶部的边界全是绿色的，所以我们在那里停止搜索。

160
00:11:07,000 --> 00:11:10,500
但底部的色彩足以值得细分。

161
00:11:10,500 --> 00:11:12,420
就这样继续下去。

162
00:11:12,420 --> 00:11:16,860
检查哪个子区域具有覆盖所有可能颜色的边界，这意味着该边界的点被映射到所有可能的方向，并像我们对一维情况一样将这些区域切成两半，最终导致我们的函数为零哦，等一下。

163
00:11:16,860 --> 00:11:21,280


164
00:11:21,280 --> 00:11:25,400


165
00:11:25,400 --> 00:11:29,320


166
00:11:29,320 --> 00:11:30,320
这里发生了什么？

167
00:11:30,320 --> 00:11:34,520
右下角的最后一个细分都没有遍历所有颜色，因此我们的算法停止了，因为它不想搜索其中任何一个，但它也没有找到零。

168
00:11:34,520 --> 00:11:38,160


169
00:11:38,160 --> 00:11:41,160


170
00:11:41,160 --> 00:11:43,720
好吧，显然这里出了问题。

171
00:11:43,720 --> 00:11:46,680
没关系，犯错是做数学的正常现象。

172
00:11:46,680 --> 00:11:51,400
如果我们回顾过去，我们有这个假设，它导致我们提出了这个算法，所以我们在某个地方犯了错误。

173
00:11:51,400 --> 00:11:53,680


174
00:11:53,680 --> 00:11:56,860
擅长数学并不在于第一次就正确，而是在于具有仔细回顾并理解错误的能力，并了解如何纠正它们。

175
00:11:56,860 --> 00:12:00,920


176
00:12:00,920 --> 00:12:02,520


177
00:12:02,520 --> 00:12:06,760
现在的问题是，我们有一个区域，其边界穿过每种颜色，但是当我们将其从中间分割时，两个子区域的边界都没有穿过每种颜色，我们没有选择下一步在哪里继续搜索，这就打破了零发现者。

178
00:12:06,760 --> 00:12:11,260


179
00:12:11,260 --> 00:12:14,880


180
00:12:15,280 --> 00:12:18,120
现在在一个维度中，这种事情从来没有发生过。

181
00:12:18,120 --> 00:12:22,960
每当您有一个端点具有不同符号的区间时，如果将其拆分，您就知道一定会得到一些端点也具有不同符号的子区间。

182
00:12:22,960 --> 00:12:28,200


183
00:12:28,200 --> 00:12:29,200


184
00:12:29,200 --> 00:12:34,120
或者换句话说，任何时候你有两个端点不改变符号的区间，如果将它们组合起来，你将得到一个更大的区间，其端点也不改变符号。

185
00:12:34,120 --> 00:12:38,280


186
00:12:38,280 --> 00:12:39,280


187
00:12:39,280 --> 00:12:43,140
但在二维中，可以找到两个区域，其边界不穿过每种颜色，但其边界组合起来给出一个边界确实穿过每种颜色的区域。

188
00:12:43,140 --> 00:12:48,040


189
00:12:48,040 --> 00:12:49,940


190
00:12:49,940 --> 00:12:53,740
就这样，我们提出的找零算法失效了。

191
00:12:53,740 --> 00:12:58,680
事实上，如果你仔细想想，你会发现一个大循环，其边界穿过所有可能的颜色，而内部没有零。

192
00:12:58,680 --> 00:13:03,120


193
00:13:03,120 --> 00:13:07,100
现在，这并不是说我们关于微小循环的说法是错误的，当我们说穿过每种颜色的永远缩小的循环必须缩小到零时。

194
00:13:07,100 --> 00:13:13,040


195
00:13:13,040 --> 00:13:17,120
但让我们变得一团糟的是，当您组合区域时，“我的边框是否穿过每种颜色”属性并不能以良好的、可预测的方式组合。

196
00:13:17,120 --> 00:13:23,040


197
00:13:23,040 --> 00:13:28,100
但别担心，事实证明我们可以将其稍微修改为更复杂的属性，这些属性结合起来确实可以给我们带来我们想要的东西。

198
00:13:28,100 --> 00:13:38,560


199
00:13:38,560 --> 00:13:42,540
我们的想法是，不要简单地询问我们是否可以在循环的某个点找到颜色，而是让我们更仔细地跟踪当我们绕着该循环走动时这些颜色如何变化。

200
00:13:42,540 --> 00:13:47,100


201
00:13:47,100 --> 00:13:48,100


202
00:13:48,100 --> 00:13:50,060
让我用一个例子来告诉你我的意思。

203
00:13:50,060 --> 00:13:54,120
我会在角落里放一个小色轮来帮助我们跟踪。

204
00:13:54,120 --> 00:13:58,540
当沿着输入路径的颜色以特定方向穿过彩虹时，从红色到黄色、黄色到绿色、绿色到蓝色或蓝色到红色，输出顺时针摆动。

205
00:13:58,540 --> 00:14:04,380


206
00:14:04,380 --> 00:14:05,720


207
00:14:05,720 --> 00:14:09,980
但另一方面，如果颜色在彩虹中以相反的方式移动，从蓝色到绿色、绿色到黄色、黄色到红色或红色到蓝色，则输出会逆时针摆动。

208
00:14:09,980 --> 00:14:17,160


209
00:14:17,160 --> 00:14:22,940
因此，沿着这里的这条短路径行走，颜色会在色轮中顺时针缠绕五分之一的路径，沿着这里的这条路径行走，颜色会在色轮中顺时针缠绕另外五分之一的路径。

210
00:14:22,940 --> 00:14:28,340


211
00:14:28,340 --> 00:14:30,620


212
00:14:30,620 --> 00:14:35,400
当然，这意味着如果您一条接一条地穿过两条路径，颜色总共会顺时针旋转五分之二一整圈。

213
00:14:35,400 --> 00:14:39,380


214
00:14:39,380 --> 00:14:43,740
缠绕的总量只是加起来，这将是关键，这是一种对我们有用的简单组合。

215
00:14:43,740 --> 00:14:47,140


216
00:14:47,140 --> 00:14:51,980
当我说总缠绕量时，我希望你想象一个老式的里程表，当箭头顺时针旋转时，它向前滴答，但当箭头逆时针旋转时，它向后滴答。

217
00:14:51,980 --> 00:14:58,700


218
00:14:58,700 --> 00:15:03,020
所以逆时针缠绕算作负顺时针缠绕。

219
00:15:03,020 --> 00:15:07,460
输出可能会转动很多，但如果其中一些转动方向相反，则会抵消。

220
00:15:07,460 --> 00:15:08,940


221
00:15:08,940 --> 00:15:13,220
例如，如果您沿着这条路径向前移动，然后沿着同一条路径向后移动，则缠绕总量最终为零，向后移动实际上会倒回之前看到的颜色，反转所有先前的缠绕，并返回里程表回到起点。

222
00:15:13,220 --> 00:15:18,100


223
00:15:18,100 --> 00:15:23,440


224
00:15:23,440 --> 00:15:26,300


225
00:15:26,300 --> 00:15:30,480
出于我们的目的，我们最关心的是观察沿环的缠绕情况。

226
00:15:30,480 --> 00:15:34,280
例如，假设我们顺时针绕着整个循环走。

227
00:15:34,280 --> 00:15:39,680
我们遇到的输出总共绕了三个完整的顺时针方向，颜色按顺序在彩虹中摆动，从红色再次变为红色，然后再次，再次。

228
00:15:39,680 --> 00:15:47,120


229
00:15:47,120 --> 00:15:52,260
用数学家的行话来说，我们说沿着这个循环，总的缠绕数是

230
00:15:52,260 --> 00:15:54,100
3。

231
00:15:54,100 --> 00:15:58,440
对于其他循环，它可以是任何其他整数，如果输出在输入围绕单个循环运行时多次摆动，则可能是一个较大的数字，或者如果输出仅摆动一次或两次，则它可能是较小的数字。

232
00:15:58,440 --> 00:16:03,680


233
00:16:03,720 --> 00:16:07,060


234
00:16:07,060 --> 00:16:12,260
或者，如果当我们沿环路顺时针行走时输出逆时针摆动，则该绕数甚至可能是负整数。

235
00:16:12,260 --> 00:16:15,200


236
00:16:15,200 --> 00:16:19,720
但沿着任何环路，缠绕总数必须是整数。

237
00:16:19,720 --> 00:16:23,980
我的意思是，当你回到开始的地方时，你将得到与开始时相同的输出。

238
00:16:23,980 --> 00:16:25,840


239
00:16:25,840 --> 00:16:31,520
顺便说一句，如果一条路径实际上包含一个输出恰好为零的点，那么从技术上讲，您无法沿着该点定义缠绕数，因为输出没有特定方向。

240
00:16:31,560 --> 00:16:35,640


241
00:16:35,640 --> 00:16:37,600


242
00:16:37,600 --> 00:16:41,740
这对我们来说不会成为问题，因为我们的整个目标是找到零，所以如果出现这种情况，我们只是运气好而已。

243
00:16:41,740 --> 00:16:45,200


244
00:16:45,200 --> 00:16:48,720
关于这些蜿蜒的数字，需要注意的主要一点是，当您将路径组合成更大的路径时，它们会很好地相加。

245
00:16:48,720 --> 00:16:55,040


246
00:16:55,040 --> 00:16:59,440
但我们真正想要的是，当我们将区域组合成更大的区域时，沿着区域边界的蜿蜒数字能够很好地相加。

247
00:16:59,440 --> 00:17:03,120


248
00:17:03,120 --> 00:17:06,320
那么我们有这个属性吗？

249
00:17:06,320 --> 00:17:09,600
好吧，看一下。

250
00:17:09,600 --> 00:17:14,760
当我们绕着左边这个区域顺时针旋转时，绕行数是这四条路径的绕行数之和。

251
00:17:14,760 --> 00:17:17,920


252
00:17:17,920 --> 00:17:21,960
当我们沿着右侧这个区域顺时针旋转时，绕线是这四个路径的绕线数之和。

253
00:17:21,960 --> 00:17:25,480


254
00:17:25,480 --> 00:17:29,840
当我们将这两个区域合并成一个更大的区域时，大多数路径都会成为更大区域的顺时针边界的一部分。

255
00:17:29,840 --> 00:17:33,760


256
00:17:33,760 --> 00:17:36,040
至于那两条没有的路呢？

257
00:17:36,040 --> 00:17:40,520
它们完美地抵消了，其中一个正好相反，另一个就像我们之前看到的那样倒带。

258
00:17:40,520 --> 00:17:42,660


259
00:17:42,660 --> 00:17:48,840
因此，沿着区域边界的蜿蜒数字按照我们希望的方式加起来。

260
00:17:48,840 --> 00:17:53,560
另请注意，这种关于有向边界很好地相加的推理在数学中经常出现，并且通常被称为斯托克斯定理。

261
00:17:53,560 --> 00:17:57,320


262
00:17:57,320 --> 00:18:02,880
研究过多元微积分的人可能会从这种背景下认识到它。

263
00:18:02,880 --> 00:18:08,040
现在，终于，有了绕数，我们就可以回到我们的方程求解目标了。

264
00:18:08,040 --> 00:18:12,400
我们之前看到的区域的问题在于，即使它的边界穿过了所有可能的颜色，但缠绕数实际上为零。

265
00:18:12,400 --> 00:18:16,620


266
00:18:16,620 --> 00:18:22,360
输出缠绕到一半，从黄色到红色，然后开始逆时针返回另一个方向，然后继续穿过蓝色并从另一个方向到达红色，所有这些都以这样的方式使总缠绕净为零。

267
00:18:22,360 --> 00:18:26,000


268
00:18:26,000 --> 00:18:32,040


269
00:18:32,040 --> 00:18:36,000
但是，如果您发现一个循环不仅命中每种颜色，而且具有非零缠绕数的更强条件，那么如果您将其分成两半，则可以保证至少其中一个具有缠绕数也是非零，因为事情按照我们想要的方式很好地加起来。

270
00:18:36,000 --> 00:18:41,200


271
00:18:41,200 --> 00:18:46,400


272
00:18:46,400 --> 00:18:48,600


273
00:18:48,600 --> 00:18:54,280
这样，你就可以继续前进，越来越缩小到一个点。

274
00:18:54,280 --> 00:18:58,440
当你缩小到一个点时，你将使用具有非零缠绕数的小循环来做到这一点，这意味着它们会经历所有可能的颜色，因此，就像我之前所说的那样，它们缩小的点on

275
00:18:58,440 --> 00:19:02,840
必须为零。

276
00:19:02,840 --> 00:19:07,680


277
00:19:07,680 --> 00:19:08,760
就是这样！

278
00:19:08,760 --> 00:19:13,280
我们现在已经创建了一个二维方程求解器，这一次，我保证，没有错误。

279
00:19:13,280 --> 00:19:14,760


280
00:19:14,760 --> 00:19:18,200
绕数正是我们实现这项工作所需的工具。

281
00:19:18,200 --> 00:19:23,040
现在，我们只需考虑 f 和 g 之间的差值如何变化，就可以解出类似于二维中 x 的

282
00:19:23,040 --> 00:19:27,660
f 等于 x 的 g 的方程。

283
00:19:27,660 --> 00:19:31,800
每当我们有一个缠绕数不为零的循环时，我们就可以在它上面运行这个算法，并且我们保证在其中的某个地方找到一个解决方案。

284
00:19:31,800 --> 00:19:35,160


285
00:19:35,160 --> 00:19:40,300
更重要的是，就像在一维中一样，该算法非常高效。

286
00:19:40,300 --> 00:19:44,880
我们每轮不断缩小区域大小的一半，从而快速缩小零点，并且一直以来，我们只需要沿着这些循环的点检查函数的值，而不是在许多点上检查它内部的点。

287
00:19:44,880 --> 00:19:49,840


288
00:19:49,840 --> 00:19:55,240


289
00:19:55,240 --> 00:20:00,400
因此，从某种意义上说，完成的总体工作仅与搜索空间的周长成正比，而不是与整个面积成正比，这是令人惊奇的。

290
00:20:00,400 --> 00:20:04,960


291
00:20:04,960 --> 00:20:09,360
现在，一旦你了解了发生了什么，仅仅观察它的实际情况，赋予它一些功能并让它搜索零，就会产生一种奇怪的令人着迷的感觉。

292
00:20:09,360 --> 00:20:13,800


293
00:20:13,800 --> 00:20:18,600
正如我之前所说，复数是二维的，所以让我们将其应用到一些具有复数的方程中。

294
00:20:18,600 --> 00:20:20,340


295
00:20:20,340 --> 00:20:25,240
例如，以下算法在复平面上查找函数 x 到第五次减

296
00:20:25,240 --> 00:20:28,920
x 减一的零点。

297
00:20:28,920 --> 00:20:33,160
首先考虑原点周围的一个非常大的区域，最终缠绕数为

298
00:20:33,160 --> 00:20:35,440
5。

299
00:20:35,440 --> 00:20:39,640
每次找到一个具有非零缠绕数的环路时，您将其分成两半，并计算出两个较小环路的缠绕数。

300
00:20:39,640 --> 00:20:42,840


301
00:20:42,880 --> 00:20:46,880
它们中的一个或两个都保证具有非零缠绕数，当您看到这一点时，您知道在较小的循环内某处有一个零，因此您继续以相同的方式搜索较小的空间。

302
00:20:46,880 --> 00:20:51,440


303
00:20:51,440 --> 00:20:54,300


304
00:20:54,300 --> 00:20:58,920
如果我们正在计算的路径碰巧遇到零，我们也会停止探索一个区域，这种情况在右半部分的示例中实际上发生过一次。

305
00:20:58,920 --> 00:21:03,420


306
00:21:03,420 --> 00:21:07,600
这些罕见的情况会干扰我们计算缠绕数的能力，但是嘿，我们得到了零。

307
00:21:07,600 --> 00:21:09,320


308
00:21:09,320 --> 00:21:13,320
至于绕数为零的循环，您只是不进一步探索它们。

309
00:21:13,320 --> 00:21:18,520
也许他们内部有解决方案，也许他们没有，我们无法保证。

310
00:21:18,520 --> 00:21:22,240
让我们的方程求解器以同样的方式继续下去，它最终会收敛到该多项式的许多零点。

311
00:21:22,240 --> 00:21:26,020


312
00:21:26,020 --> 00:21:30,400
顺便说一句，本例中的总绕组数恰好为 5

313
00:21:30,400 --> 00:21:31,660
并非巧合。

314
00:21:31,660 --> 00:21:37,280
对于复数，x 到 n

315
00:21:37,280 --> 00:21:45,000
的运算直接对应于绕输出原点绕行 n 次，就像绕输入原点绕行一次一样。

316
00:21:45,000 --> 00:21:50,500
因此，对于多项式，对于足够大的输入，相比之下，除了首项之外的每一项都变得微不足道。

317
00:21:50,500 --> 00:21:52,700


318
00:21:52,700 --> 00:21:58,780
因此，任何首项为 x 到

319
00:21:58,780 --> 00:22:00,700
n 的复多项式都具有围绕足够大的循环的绕数 n。

320
00:22:00,700 --> 00:22:06,240
这样，我们的绕数技术实际上保证了每个复数多项式都有一个零。

321
00:22:06,240 --> 00:22:07,620


322
00:22:07,620 --> 00:22:13,880
这是一个非常重要的事实，数学家将其称为代数基本定理。

323
00:22:13,880 --> 00:22:18,040
拥有一个算法来找到这样的方程的数值解是非常实用的，但代数的基本定理是一个很好的例子，说明这些绕数在理论层面上也非常有用，保证了广泛的一类方程的解的存在。适合条件的方程，这更是数学家喜欢思考的事情。

324
00:22:18,040 --> 00:22:22,420


325
00:22:22,420 --> 00:22:27,780


326
00:22:27,780 --> 00:22:32,280


327
00:22:32,280 --> 00:22:34,060


328
00:22:34,400 --> 00:22:39,360
我将在后续视频中向您展示拓扑上下文中的一些更令人惊奇的应用，其中包括纠正旧 3blue1brown

329
00:22:39,360 --> 00:22:44,080
视频中的错误。

330
00:22:44,080 --> 00:22:45,080
哪一个？

331
00:22:45,080 --> 00:22:48,740
好吧，观看该频道上的所有视频和所有内容，看看您是否能首先发现错误。

332
00:22:48,740 --> 00:22:51,640


333
00:22:51,640 --> 00:22:55,960
该视频的主要作者是 3blue1brown 团队的最新成员之一

334
00:22:55,960 --> 00:22:56,460
Sridhar Ramesh。

